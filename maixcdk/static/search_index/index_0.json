{"/maixcdk/doc/dev/docker/index.html":{"title":"MaixCDK docker building environment","content":"MaixCDK docker building environment ## About Docker and install Docker Docker is a tool, here we use it to create a clean Ubuntu environment to build MaixCDK. Use docker you don't need to install dependencies manually, just create a docker container and then all ready. Docker install doc see [Docker official doc](https://docs.docker.com/engine/install/ubuntu/) After installation, you can use `docker version` to check if it is installed successfully. ## Pull from docker hub (recommended), or build by yourself ```shell docker pull sipeed/maixcdk builder ``` > Or you can build from Dockerfile by yourself. > > ```shell > docker build network host t maixcdk builder . > ``` > You can also add proxy by add args:` network host build arg http_proxy http://127.0.0.1:8123 build arg https_proxy http://127.0.0.1:8123` ## Create and run container The upper step we got a docker system image, now we create a container to run this image. ```shell docker run it network host hostname maixcdk env name maixcdk env env USER $USER env UID `id u` env GID `id g` env MAIXCDK_PATH /home/${USER}/MaixCDK v /home/${USER}/MaixCDK:/home/${USER}/MaixCDK sipeed/maixcdk builder ``` > !! DO NOT add `/bin/bash` to the end of the command. > ` network host` means use the same network as host PC. > ` hostname` means set hostname of container to `maixcdk env`. > ` name` means set container name to `maixcdk env`, then you can use `docker` command to control it. > Then assign `USER`(your user name of host PC), user id, group id to use the same as host PC's user info in container to avoid permission problem. > You can use ` v host_dir:container_dir` to map your data to container, e.g. ` v /home/${USER}/MaixCDK:/home/${USER}/MaixCDK v /home/${USER}/projects:/home/${USER}/projects`. > It's recommended to map your directories to the container's same directory, this is useful to see logs. > ` env MAIXCDK_PATH /home/${USER}/MaixCDK` arg to set `MAIXCDK_PATH` environment variable, so you can compile your project anywhere in container. > `sipeed/maixcdk builder` is the image name, if you build by yourself, use `maixcdk builder` instead. Then you can use shell command in container. The user's password is `maixcdk` by default, if you want to change it, use `docker exec it maixcdk env passwd` to change it. ## Build MaixCDK projects or examples When step into container, you can use shell command to build according to the MaixCDK document. ```shell cd /MaixCDK/examples/hello_world maixcdk build maixcdk run cd ~/projects/my_project maixcdk build maixcdk run ``` ## Stop container ```shell docker stop maixcdk env ``` ## RUN container ```shell docker start maixcdk env docker attach maixcdk env ``` ## Execute command through host shell ```shell docker exec it user $USER maixcdk env \"cd /MaixCDK/examples/hello_world && maixcdk build && maixcdk run\" ``` ```shell docker exec it user $USER maixcdk env /bin/bash ``` ## Remove container ```shell docker stop maixcdk env docker rm maixcdk env ```"},"/maixcdk/doc/dev/quick_start.html":{"title":"MaixCDK quick start","content":" title: MaixCDK quick start see [quick start](../index.html)"},"/maixcdk/doc/application/ai/yolo11.html":{"title":"MaixCDK YOLO11 develop notes","content":" title: MaixCDK YOLO11 develop notes Souce code in [MaixCDK/components/nn/include/maix_nn_yolo11.hpp](https://github.com/sipeed/MaixCDK/blob/main/components/nn/include/maix_nn_yolo11.hpp) Model port from [ultralytics/ultralytics](https://github.com/ultralytics/ultralytics), train and convert model refer to [MaixPy doc customize yolo11](https://wiki.sipeed.com/maixpy/doc/en/vision/customize_model_yolov8.html)."},"/maixcdk/doc/application/index.html":{"title":"MaixCDK Application notes","content":" title: MaixCDK Application notes These notes is MaixCDK developer notes, taken down by developer when create some functions. If you want to known more features and functions and documentation, please visit [MaixPy documentation](https://wiki.sipeed.com/maixpy/)"},"/maixcdk/doc/application/ui/lvgl.html":{"title":"Use LVGL in MaixCDK","content":" title: Use LVGL in MaixCDK ## run gui_lvgl demo * Go to `examples/gui_lvgl` in MaixCDK. * Execute `maixcdk build` to build the project for PC. * Execute `maixcdk run` to run the project on PC. You can also execute `maixcdk menuconfig` to change platform to build for other platform. ## Custom your own UI * Download [squareline](https://squareline.io/) and install first. * Create a new UI project in squareline. * Edit your UI. * Export UI files, then you will get a `ui` folder. * Copy all ui files to `examples/gui_lvgl/ui` folder. * Run `maixcdk build` to build. Or you can mannually write code and not use squareline."},"/maixcdk/doc/application/peripheral/uart.html":{"title":"","content":""},"/maixcdk/doc/index.html":{"title":"Quick Start with MaixCDK","content":" title: Quick Start with MaixCDK ## Introduction to MaixCDK MaixCDK provides C++ APIs for commonly used AI functions related to image processing, vision, audio, and peripherals, enabling quick prototyping and stable product development. MaixCDK is not only a C++ SDK but also auto generates Python API bindings, so development can be done in Python through [MaixPy](https://wiki.sipeed.com/maixpy/). Basic Linux knowledge and a fundamental understanding of cross compilation are required to use MaixCDK. ## Basic Knowledge To use MaixCDK, it is assumed that you are already familiar with the following knowledge. If not, please learn them first or consider using [MaixPy](https://wiki.sipeed.com/maixpy/): * Proficient in using Linux for development, familiar with the terminal and common commands. * Proficient in either C or C++ programming language. C++ proficiency is not required, but you must understand the basic syntax and object oriented concepts. * Able to actively read and analyze source code to troubleshoot issues. * Chinese developers should be familiar with using network proxies. * Understand cross compilation. ## How to Find Resources and Troubleshoot 1. Read [MaixCDK source code](https://github.com/sipeed/MaixCDK). 2. Since MaixCDK shares the same functionality/API as MaixPy, detailed tutorials are not provided separately. Refer to the [MaixPy documentation](https://wiki.sipeed.com/maixpy/); the principles and code are nearly identical, requiring only minor modifications. 3. It’s recommended to get hands on experience with MaixPy before using MaixCDK for a smoother learning curve. 4. Carefully review the official documentation, including MaixCDK, MaixPy, and hardware documentation. 5. If issues arise, start by checking [MaixCDK FAQ](https://wiki.sipeed.com/maixcdk/doc/zh/faq.html), [MaixPy FAQ](https://wiki.sipeed.com/maixpy/doc/zh/faq.html), [MaixCAM Hardware FAQ](https://wiki.sipeed.com/hardware/zh/maixcam/faq.html), and the [source code issues](https://github.com/sipeed/MaixCDK/issues). 6. Check out the [MaixHub Share Plaza](https://maixhub.com/share) for community insights. 7. **Read error logs carefully and patiently**, following logs from top to bottom, as errors might appear in the middle—don’t skip ahead hastily! ## Quick Start ### Setting Up the System and Environment Two options are available: #### Local Machine: **Only supported on Linux**, with **Ubuntu > 20.04** recommended. Note that the MaixCAM toolchain only supports x86_64 CPUs and is not compatible with ARM based computers, such as ARM MacOS. ```shell sudo apt update sudo apt install git cmake build essential python3 python3 pip autoconf automake libtool cmake version # cmake version should be > 3.13 ``` > To compile for a Linux PC (instead of cross compiling for a dev board), if you’re using `Ubuntu`, ensure the system version is `> 20.04`, or some dependencies may be too outdated to compile. Install dependencies following the commands in the [Dockerfile](https://github.com/sipeed/MaixCDK/blob/main/docs/doc/dev/docker/Dockerfile). > If compilation errors occur, consider [using Docker to compile](./dev/docker/index.html). #### Docker: The `Docker` environment includes `ubuntu20.04` and dependencies, making it ready for compilation. For users familiar with `Docker` or those facing issues with local setup, refer to the [Docker Usage Guide](./dev/docker/index.html). ### Obtaining the Source Code ```shell git clone https://github.com/Sipeed/MaixCDK ``` > * Stable Release versions can be downloaded from the [release page](https://github.com/Sipeed/MaixCDK/releases). > * Alternatively, check [MaixPy release](https://github.com/Sipeed/MaixPy/releases) assets for `maixcdk_version_xxxxx.txt`, where `xxxxx` indicates the MaixPy version in use. Use `git checkout xxxx` to switch to the corresponding version. > For users in China experiencing slow clone speeds, use `git clone https://gitee.com/Sipeed/MaixCDK`. ### Installing Dependencies ```shell cd MaixCDK pip install U pip # Update pip to the latest version pip install U r requirements.txt # Install dependencies ``` > Users in China can add the parameter ` i https://pypi.tuna.tsinghua.edu.cn/simple` to use the Tsinghua mirror. > Dependencies are already installed in the `Docker` environment, but you can update them to the latest version within the Docker container. Run `maixtool` and `maixcdk` commands in the terminal to view help information. > If the commands are not found, try restarting the terminal or use `find / name \"maixtool\"` to locate `maixtool`, then set it in the system path using `export PATH directory_containing_maixtool:$PATH`. ### Compilation ```shell cd examples/hello_world maixcdk menuconfig ``` Follow the prompts to select the device platform. A menu appears to configure parameters. For first time use, the default parameters are fine (or skip `menuconfig` and go straight to build), then press `ESC`, and `Y` to save and exit. ```shell maixcdk build ``` The first time you run this step, the device will download the compilation toolchain. If the download is slow, you can manually download it to the specified directory as prompted, and then proceed with the compilation. >! The resources are mostly downloaded from GitHub, and download speeds in China may be slow or even fail (the list of files to download is in `dl/pkgs_info.json`). There are several common solutions: > 1. Set a proxy in the terminal (recommended), for example: `export http_proxy http://127.0.0.1:8123 https_proxy http://127.0.0.1:8123`. Here, `http://127.0.0.1:8123` is the address of your HTTP proxy. > 2. Manually download to the `dl/pkgs` folder: During the download, the download URL and local path will be printed. You can manually download the files and place them in the corresponding directory. When you run the build command again, it will use the locally prepared files (Note: the file’s sha256 checksum must match, i.e., it must be the same file). > 3. Users in China can go to the [QQ Group](../) on the homepage, find the `MaixCDK` folder, and download the files to the `MaixCDK/dl` directory. >! For common errors and solutions, refer to the [FAQ](./faq.html). After the compilation, you will find the binary program files in the `build` directory, and the dependent `.so` files in `build/dl_lib`. After modifying the code, you can run `maixcdk build` again to compile. If you **haven’t added or removed source files**, you can run `maixcdk build2` or `maixcdk build no gen` for faster compilation (it will only compile the modified files). > This is because the `build` command starts the entire build process from scratch, scanning files and recompiling. In contrast, the `build2` command will not scan for file additions or deletions and will only compile the edited files. > Note: The `build2` command will not detect file additions or deletions, so if you **add or remove files**, you must run the `build` command again. Run `maixcdk distclean` to clear all temporary build files and start fresh (this increases build time and is typically used to troubleshoot issues). ### Uploading to the Device Copy the executable and `dl_lib` folder to the device for execution. Use `scp` to copy files, for example: ```shell scp r dist/ root@10.127.117.1:/root/ ``` The default password is `root`. ### Running the Program Run the program via SSH. Ensure no other programs are running (including the startup application launcher). Steps: * Connect MaixVision to the device to close the Launcher, or use SSH to `kill` the `launcher_daemon`. * SSH into the device, e.g., `ssh root@192.168.0.123`, password `root`. * Navigate to the executable directory and run it, e.g., `cd /root/dist/camera_display_release && ./camera_display`. ### Packaging for Release In the project directory, use `maixcdk p maixcam release` to create a program package for `maixcam` in the `dist` folder. This package can be uploaded to the [MaixHub App Store](https://maixhub.com/app). Usage: * Method 1: Unzip and copy to the device, run `chmod +x program_name && ./program_name`. * Method 2: Use the [App Store](https://maixhub.com/app/12) application on the device to install from MaixHub. * Method 3: For developers, if the device is connected to the same LAN as the PC, use `maixcdk deploy` to generate a QR code, which the device can scan to install. * Method 4: Copy the package to the device and install it by running `/maixapp/apps/app_store/app_store install xxx.zip`. Application releases should follow the [App Development Guidelines](./convention/app.html). ### Creating a New Project To create a project: ```shell maixcdk new ``` ## Development convention To get started with MaixCDK, please begin by reading the [MaixCDK Development Guidelines](./convention/index.html). ## Adding an API to MaixPy Since MaixPy’s core is largely MaixCDK, adding APIs to MaixPy is straightforward. Just annotate the function with `@maixpy maix.xxx.xxxx`. For example, to implement the following API: ```python from maix import example result example.hello(\"Bob\") print(result) ``` Simply add a declaration in [maix_api_example.hpp](https://github.com/sipeed/MaixCDK/blob/main/components/basic/include/maix_api_example.hpp): ```cpp namespace maix::example { /** * @brief say hello to someone * @param[in] name name of someone, string type * @return string type, content is hello + name * @maixpy maix.example.hello */ std::string hello(std::string name); } ``` Then compile the `MaixPy` project to get an installation package, which can be installed on the device to use the new API—simple, right? For more detailed documentation, refer to [Add API](./convention/add_api.html)."},"/maixcdk/doc/more.html":{"title":"更多 MaixCDK 文档","content":" title: 更多 MaixCDK 文档 MaixCDK 由于是 MaixPy 的大多数 API 底层实现，所以 [MaixPy 的文档](https://wiki.sipeed.com/maixpy/)也适用于 MaixCDK，比如 功能介绍和教程，系统定制等等。"},"/maixcdk/doc/convention/add_api.html":{"title":"Add API for MaixCDK / MaixPy","content":" title: Add API for MaixCDK / MaixPy ## Code Guidelines Please refer to [Code Guidelines](./index.html) first. ## How to Add an API At the end of the [Quick Start](../index.html), we briefly mentioned adding a new API to MaixPy using annotations. It looks straightforward – you only need to add a comment to the API function, for example: ```cpp namespace maix::example { /** * @brief Say hello to someone * @param[in] name The name of the person, of string type * @return A string containing \"hello\" + name * @maixpy maix.example.hello */ std::string hello(std::string name); } ``` Then you can call this in MaixPy: ```python from maix import example result example.hello(\"Bob\") print(result) ``` To ensure that the APIs we add are **usable** for users, we need to follow these guidelines: * Design the API names and parameters to be reasonable, general, and highly cross platform. * Ensure the API is annotated (documentation will be automatically generated during compilation). * The API should come with usage documentation, a tutorial, and example code. Here is a more detailed process and guidelines: 1. **Confirm the functionality and add a usage document and example code in the [MaixPy Documentation Source](https://github.com/sipeed/MaixPy/tree/main/docs/doc)**. This acts as a design document, helping to avoid frequent API changes due to incomplete considerations during coding. It also serves as documentation. **(This is very important!)** 2. You can add an **application document** under [docs/doc/application](https://github.com/sipeed/MaixCDK/tree/main/docs/doc/application) to record development details. Use lowercase filenames with underscores, e.g., `peripheral/uart.md` or `ai/yolov2.md`. 3. Mention the sources or open source projects referenced for API design in the development document to facilitate the review process and improve the chances of passing the review quickly. 4. Refer to [components/basic/include/maix_api_example.hpp] and add the API to an appropriate `component`. If it's a new component, consider discussing its rationality first in [issues](https://github.com/sipeed/MaixCDK/issues). > Note: The `API` is identified through comments, which helps automatically generate documentation and `MaixPy` source code. Pay close attention to the annotation guidelines and refer to `maix_api_example.hpp` for specifics. > Additionally, because `MaixCDK` does not include definitions related to `Python.h` or `Pybind11.h`, language native types are automatically converted by `pybind11`. For instance, `void hello(std::string a, std::vector<int> b)` is equivalent to `def hello(a: str, b: list)` in `MaixPy`. > Common conversions include `std::vector` to `list`, `std::map` to `dict`, `std::valarray` (accepts `list` and `bytes` as input, returns `list`), and `maix::Bytes` (both input and return values are `bytes`). `std::function` maps to a function in MaixPy. For more details, refer to the [pybind11 documentation](https://pybind11.readthedocs.io/en/stable/advanced/cast/overview.html#conversion table). 5. Add a C++ example to the `examples` directory and ensure it compiles and runs successfully. 6. The documentation will be automatically generated during compilation. Check the generated files under `docs/doc/api` for any errors and correct them in the code if needed. 7. Test the updated `MaixPy` project with the new `MaixCDK` to ensure it compiles successfully and the generated documentation is correct. Fix any errors if they occur. 8. Submit your code to your own GitHub repository and wait for the `action` to automatically build and test it. Correct any errors promptly. 9. Once all online tests pass, submit a `PR` (Pull Request) and request to merge it into the `dev` branch on [GitHub](https://github.com/sipeed/MaixCDK). ## Manually Adding a MaixPy API The above method can automatically generate a MaixPy API, but in certain scenarios, manual addition might be necessary. For example, when the parameter is a specific type, such as `numpy.array`: * Add the header file and code under `components/maix/include` in the `MaixPy` project. You can use the same `namespace` as in `MaixCDK`. For instance, the function `maix.image.cv2image` converts a `numpy` array to an `image.Image` object. Refer to the definitions in the `convert_image.hpp` file. More references: * [Building MaixPy](https://wiki.sipeed.com/maixpy/doc/zh/source_code/build.html) * [Adding a C/C++ Module to MaixPy for MaixCAM](https://wiki.sipeed.com/maixpy/doc/zh/source_code/add_c_module.html)"},"/maixcdk/doc/convention/i18n.html":{"title":"MaixCDK i18n(Internationalization), multi language support","content":" title: MaixCDK i18n(Internationalization), multi language support You can use any i18n library you like, [gettext](https://www.gnu.org/software/gettext/) for example, they are supported in Python and C++. And we provide a simple i18n library, for simple use case. ## For MaixPy See [MaixPy i18n documentation](https://wiki.sipeed.com/maixpy/doc/zh/gui/i18n.html). ## For MaixCDK: The same as MaixPy's, there's two ways: ### Simple translation dict Ensure your source file if `UTF 8` encoded first. ```cpp #include \"maix_i18n.hpp\" const std::map<string, string> locale_zh_dict { {\"out\", \"输出\"}, {\"hello\", \"你好\"} }; const std::map<string, string> locale_ja_dict { // {\"out\", \"出力\"}, {\"hello\", \"こんにちは\"} }; const std::map<string, const std::map<string, string>> locales_dict { {\"zh\", locale_zh_dict}, {\"ja\", locale_ja_dict} }; i18n::Trans trans(locales_dict); int main() { log::info(\"system locale: %s\\n\", i18n::get_locale().c_str()); log::info(\"%s: %s\\n\", trans.tr(\"out\").c_str(), trans.tr(\"hello\").c_str()); trans.set_locale(\"zh\"); printf(\"%s: %s\\n\", trans.tr(\"out\").c_str(), trans.tr(\"hello\").c_str()); trans.set_locale(\"en\"); printf(\"%s: %s\\n\", trans.tr(\"out\").c_str(), trans.tr(\"hello\").c_str()); trans.set_locale(\"ja\"); printf(\"%s: %s\\n\", trans.tr(\"out\").c_str(), trans.tr(\"hello\").c_str()); return 0; } ``` ### Seperated translation files The upper demo is more simple for little translation strings, but if you have many strings need to translate, this way is recommended, use this way: * We don't need to change source code when we want to change translation, translation strings in seperate yaml files. * It's easier to find translation strings, support auto scan strings which need to be translated and auto generate yaml files. ```cpp err::Err e trans.load(\"locales\"); // load from locales directory err::check_raise(e, \"load translation yamls failed\"); log::info(\"system locale: %s\\n\", i18n::get_locale().c_str()); log::info(\"%s: %s, %s\\n\", i18n::get_locale().c_str(), trans.tr(\"out\").c_str(), trans.tr(\"hello\").c_str()); trans.set_locale(\"zh\"); log::info(\"zh: %s, %s\\n\", trans.tr(\"out\").c_str(), trans.tr(\"hello\").c_str()); trans.set_locale(\"en\"); log::info(\"en: %s, %s\\n\", trans.tr(\"out\").c_str(), trans.tr(\"hello\").c_str()); trans.set_locale(\"ja\"); log::info(\"ja: %s, %s\\n\", trans.tr(\"out\").c_str(), trans.tr(\"hello\").c_str()); ``` Full demo see [examples/i18n](https://github.com/sipeed/MaixCDK/tree/main/examples/i18n) for example. Then we exexute `maixtool i18n d . r`, this will scan all the strings translate by `tr()` or `_()` function and generate `locales` directory and translation files. Manually translate the `yaml` files in `locales`, then run program on device, put `locales` directory besides program. ## Show in LVGL APP See how to show custom font at [https://neucrack.com/p/514](https://neucrack.com/p/514) . Then use this piece of code: ```cpp LV_FONT_DECLARE(zh_fonts); static const std::map<string, void*> fonts { {\"zh\", (void*)&zh_fonts} }; const lv_font_t *get_font_by_locale(const string &locale) { const std::map<string, void*>::const_iterator iter fonts.find(locale); if (iter fonts.end()) { return &zh_fonts; } return (lv_font_t *)iter >second; } ``` Finally you can use i18n font by ```cpp std::string locale i18n::get_locale(); lv_obj_set_style_text_font(lv_scr_act() , get_font_by_locale(locale), LV_PART_MAIN); lv_obj_t *label lv_label_create(lv_scr_act()); lv_label_set_text(label, trans.tr(\"hello\").c_str()); ```"},"/maixcdk/doc/convention/index.html":{"title":"MaixCDK Development Guidelines and Guidance","content":" title: MaixCDK Development Guidelines and Guidance ## General Guidelines * **Simplicity and Ease of Use**: Assume minimal prior experience from users. Minimize required actions and provide simple APIs with comprehensive documentation. > For example, instead of asking users to choose and download a toolchain, it is better to automatically select and download the toolchain based on the chosen platform, reducing the entry barrier. * **Universality**: APIs should be designed to be platform agnostic and provide consistent abstraction. If this cannot be achieved, reconsider whether the feature should be included. * **Consistency**: Maintain consistent API styles and coding standards. * **Extensibility**: While ensuring core functionality, provide extension interfaces to allow users to add features easily. * **Depth**: Keep APIs simple but document the underlying principles. Open source as much code as possible to facilitate deeper exploration by users. ## Source Code and Binary Files * **Avoid Using Git Submodules**: This facilitates faster downloads for users in China. Even if the main repository is mirrored, submodules still need to be fetched from GitHub, which can be slow for Chinese users. * **Do Not Store Large Files or Binaries in the Source Code Repository**: Storing these will significantly increase the Git repository size. Git is optimized for text files; handle binary files as described below. * **Automatically Download Third Party Libraries and Binaries Before Compilation**: Define necessary files for download in [component.py](https://github.com/sipeed/MaixCDK/blob/main/components/3rd_party/asio/component.py). During compilation, they will be downloaded to `dl/pkgs` and extracted to `dl/extracted`, allowing direct inclusion in `CMakeLists.txt`, e.g., `list(APPEND ADD_INCLUDE \"${DL_EXTRACTED_PATH}/sunxi_mpp/sunxi mpp 1.0.0/include\")`. > The list of files to be downloaded is stored in `dl/pkgs_info.json` during each build. Users with slow internet connections can manually download these files from official sources or third party services and place them in `dl/pkgs`. * **Do Not Modify Third Party Libraries**: Avoid modifying the source code of third party libraries to facilitate upgrades. If modifications are necessary, consider applying patches automatically after extraction. ## Overview of MaixCDK Architecture For general application developers, key concepts include: * MaixCDK consists of two main parts: `MaixCDK` (library storage) and `project` (application code). Official examples and apps are located in `MaixCDK/examples` and `MaixCDK/projects`, respectively. You can also create your own projects in `MaixCDK/projects`. Alternatively, you can separate the two and set an environment variable `MAIXCDK_PATH` pointing to the `MaixCDK` directory, e.g., `export MAIXCDK_PATH /home/xxx/MaixCDK`. This allows projects to reside in other locations, such as `/home/xxx/projects`. * **Components**: Each functional module can be encapsulated as a component, making it easy to include in different applications. * For example, the `main` component in [examples/hello_world](./examples/hello_world) and various components in [components](./components). You can also add custom components, like `hello_world/component1`. * Use the environment variable `MAIXCDK_EXTRA_COMPONENTS_PATH` to specify additional component paths. * Each component includes a `CMakeLists.txt` file describing its contents, e.g., `list(APPEND ADD_INCLUDE \"include\")` for header files, `list(APPEND ADD_SRCS \"src/hello.c\")` for source files, and `list(APPEND ADD_REQUIREMENTS basic)` for dependencies. * **Kconfig**: Provides terminal based configuration options. Each component can include a `Kconfig` file for setting options, accessible via `maixcdk menuconfig`. The configuration is saved in `build/config`, generating `global_config.cmake` and `global_config.h` for use in `CMakeLists.txt` and C/C++ files. * **Third Party Library Integration**: There are two recommended methods: * **Method 1**: Specify third party libraries in the component’s `CMakeLists.txt` for automatic download during compilation. This is preferred for libraries integrated into `MaixCDK`. * **Method 2**: Package and publish the library as a Python package on [pypi.org](https://pypi.org) with the naming convention `maixcdk xxx`. Users can then install it using `pip install maixcdk xxx`. * **Documentation**: Located in the [docs](./docs/) directory. API documentation is auto generated from code; do not edit it manually. The application documentation serves as a user guide. ## Coding Style To ensure consistency across MaixCDK and MaixPy APIs, follow these coding style guidelines: * **Function Names**: Use lowercase with underscores, e.g., `get_name`. * **Variable Names**: Use lowercase with underscores, e.g., `file_path`. * **Class Names**: Use CamelCase, with common abbreviations in uppercase, e.g., `Person`, `YOLOv2`, `UART`. * **Macros**: Use uppercase with underscores, e.g., `MAIXPY_VERSION`. * **Class Member Variables**: Use lowercase with underscores without `m_` prefix, e.g., `name`. * **Private Class Member Variables**: Prefix with `_`, e.g., `_name`. * **Using Class Member Variables**: Explicitly use `this >` for clarity, e.g., `this >name`. * **Namespace**: Use the `maix` namespace for all official APIs, with sub namespaces for different features, e.g., `maix::thread`, `maix::peripheral`. * **Source File Naming**: Use lowercase with underscores, e.g., `maix_peripheral_uart.cpp`. Use `.hpp` for C++ header files. * **Comments**: Follow Doxygen style for API documentation, as shown in [components/basic/include/maix_api_example.hpp](../../../components/basic/include/maix_api_example.hpp). ### API Documentation Guidelines Include the following keywords in your API comments: * **brief**: A brief description of the functionality. * **param**: Detailed parameter descriptions, including value requirements and direction (e.g., `param[in] a`). * **return**: Detailed return value descriptions. * **retval**: Use this for specific return value explanations, e.g., `@retval 0 success`. * **attention**: Special considerations for using the API. * **maixpy**: Indicates a `MaixPy` API, including the package and variable name, e.g., `maix.example`. * **maixcdk**: Indicates a `MaixCDK` API. Follow the guidelines strictly, especially when defining types and default values, to ensure accurate `MaixPy API` and documentation generation. ## API Standardization Suggestions * Prefer MaixCDK APIs over direct third party APIs for better cross platform compatibility, e.g., use `maix_fs.hpp` for file operations. * Use logging APIs from `maix_log.hpp` for consistent logging and to manage log levels. * Use error handling from `maix_err.hpp` for consistent error codes and exception handling. * For common APIs across modules, define a base class and inherit it in specific implementations, enhancing code reuse and consistency across platforms."},"/maixcdk/doc/convention/memcheck.html":{"title":"Memory Check Method","content":" title: Memory Check Method ## Introduction Use the **Valgrind** tool to check for memory leaks, out of bounds memory access, and other memory related issues. ## Installation ```shell sudo apt install valgrind ``` ## Using Valgrind ```shell cd examples/hello_world maixcdk build # Output a brief log valgrind ./build/hello_world # Output a detailed log # tool memcheck: Specifies the tool as memcheck. Memcheck is the default tool, so this option can be omitted. # leak check full: Displays detailed information for each memory leak. # log file valgrind.log: Outputs the memory leak check result to the specified file. Here, valgrind.log is a custom filename. valgrind tool memcheck leak check full log file valgrind.log ./build/hello_world ``` ## Analyzing Valgrind Output ### Checking Memory Leak Summary In case of memory leaks, you may see logs similar to the following: ```shell LEAK SUMMARY: definitely lost: 48 bytes in 3 blocks. # Memory definitely leaked (e.g., memory allocated by a pointer not freed) indirectly lost: 32 bytes in 2 blocks. # Indirectly leaked memory (e.g., a double pointer's memory not freed, causing indirect leakage) possibly lost: 96 bytes in 6 blocks. still reachable: 64 bytes in 4 blocks. suppressed: 0 bytes in 0 blocks. ``` ### Checking Detailed Memory Errors There are various types of memory errors that Valgrind can detect. Here is an example log. For more details, refer to the [official documentation](https://valgrind.org/docs/manual/mc manual.html). ```shell 8 bytes in 1 blocks are definitely lost in loss record 1 of 14 # Identifies where memory is leaked at 0x........: malloc (vg_replace_malloc.c:...) by 0x........: mk (leak tree.c:11) by 0x........: main (leak tree.c:39) 88 (8 direct, 80 indirect) bytes in 1 blocks are definitely lost in loss record 13 of 14 at 0x........: malloc (vg_replace_malloc.c:...) by 0x........: mk (leak tree.c:11) by 0x........: main (leak tree.c:25) ``` ## Troubleshooting Unresolved Issues If you encounter issues that cannot be resolved, refer to the [official documentation](https://valgrind.org)."},"/maixcdk/doc/convention/nn.html":{"title":"NN convention","content":"NN convention ## NN model file Every AI model described by a `.mud` file, which is a INI format file. MUD(Model Universal Description) file is a simple format to describe a model. > The reason we create this file is that every hardware platform has its own model format, it's difficult to load them directly, and we have to write many different code to load them, now we use MUD file and wrote model info in it to make load model easier. MUD file definition: ```ini [basic] type cvimodel model model_path_relative_to_mud_file [extra] model_type classifier input_type bgr mean 103.94, 116.78, 123.68 scale 0.017, 0.017, 0.017 labels labels.txt ``` `basic` section is required, `extra` section is optional. `basic` section describes model type and model path. * `type` is model type, now we support `cvimodel` for `MaixCam`. * `model` is model path relative to MUD file. `extra` section describes model extra info, the application can get it by `model.extra_info()` method. * `model_type` is model function type, like `classifier` and `yolov2`, it's optional for application. * `input_type` is model input type, like `bgr` and `gray`, it's optional for application. * `mean` is model input mean value, it's optional for application. * `scale` is model input scale value, it's optional for application. * `labels` is model labels file path, it's optional for application. Current MaixCDK support: * classifier * classifier_no_top * yolo11 * yolov8 * yolov5 * pp_ocr * retinaface * nanotrack * retinaface * face_detector * speech * and more ... please refer to [components/nn/include](https://github.com/sipeed/MaixCDK/tree/main/components/nn/include) souce code and search `model_type` keyword and see `load` method."},"/maixcdk/doc/convention/protocol.html":{"title":"Maix Communicate Protocol","content":" title: Maix Communicate Protocol update: date: 2023 11 28 author: neucrack version: 1.0.0 content: Designed and implemented the protocol documentation and code API > This article is translated from Chinese by ChatGPT, may have error, Pull Request is welcome! ## Introduction to Maix Serial Protocol Devices running MaixCDK or MaixPy can be controlled not only directly via the device's touch screen and buttons but also as modules using `UART` (serial port) or `I2C`. > Since I2C operates in a master slave mode, the protocol adopts a request response format: `Request` + `Response`. > For UART protocol, some functions support active reporting. Please refer to the specific protocol details. The communication protocol is explained in detail below. ## How to Use Maix Device Upon startup, go to the `Settings` application, and select the communication interface under `Communication` settings: * **Serial Port**: Uses the serial port for communication. The specific serial port depends on the board, with a default baud rate of `115200`. * **TCP**: Starts a TCP service on the Maix device, allowing the master device to connect via TCP. The default port is `5555`. Once the master device is connected to the Maix device, it can communicate following the protocol, where the master device acts as the primary device, and the Maix device as the slave. **Development on Maix Device Side**: You can easily implement command responses using the provided `maix.comm.CommProtocol` class. Refer to the examples [comm_protocol](../../../examples/protocol_demo) (C++) or [comm_protocol.py](https://github.com/sipeed/MaixPy/blob/main/examples/protocol) (MaixPy) for details. **Development on Master Device Side**: The master device can implement the protocol based on the chip and programming language. Template code is provided in the appendix. ## Data Frame header (4B LE) data len (4B LE)(flags+cmd+body+crc) flags (1B) cmd (1B) body (nB) CRC16_IBM (2B LE) (all previous) Decimal Example 3148663466 9 0 1 hello 17451 Hex Example 0xBBACCAAA 0x00000009 0x00 0x01 hello 0x442B Byte Stream (Hex) AA CA AC BB 09 00 00 00 00 01 68 65 6C 6C 6F 2B 44 > **Note**: Multi byte data uses little endian (LE) encoding. For example, `data_len` is `0x00000006`, with `06` in the lowest byte, so it is sent first as `0x06`, followed by `0x00 0x00 0x00`. > Strings are sent in order, e.g., `hello` is sent as `h`, then `e`, `l`, `l`, `o`. > In this example, the final data sent is: `AA CA AC BB 09 00 00 00 00 01 68 65 6C 6C 6F 2B 44`. `header`: 4 byte header marking the start of a frame, fixed as `0xAA 0xCA 0xAC 0xBB`, sent starting with `0xAA`. `data len`: 4 byte data length, including the length of `flags`, `cmd`, `body`, and `CRC`. `flags`: 1 byte flag where each bit indicates: MSB `is_resp`: Indicates if it is a response. `0` for request, `1` for response or active report (requires the third highest bit set to `1`). Second highest bit `resp_ok`: For requests: Reserved. For responses: `1` for success, `0` for failure. Third highest bit `is_report`: For requests: Reserved. For responses: `1` for active report, `0` for response message. Bits 4 6: Reserved for future use. Lowest 2 bits `version`: Protocol version, updated only for incompatible changes. Compatible changes do not require a version update. The current version is `1`. `cmd`: 1 byte command type, with several predefined commands listed in [Command Definitions](#command definitions). Custom commands range from `0` to `maix.protocol.CMD.CMD_APP_MAX`. `body`: Variable length, `< (2^32 1)`. Different commands have different `body` content, detailed below for each command. `crc16`: 2 byte CRC check value using the `CRC IBM` method, verifying data integrity during transmission. See [C Code Implementation](#C CRC16) or [Python CRC16](#Python CRC16). For encoding and decoding, see [Appendix: Code](#Appendix Code). ### Request and Response #### Sending Request Data direction: MCU or other master device > Maix device Set the highest bit of `flags` (`is_resp`) to `0`. The `body` content is determined by `cmd`. #### Receiving Response Data direction: Maix device > MCU or other master device Set the highest bit of `flags` (`is_resp`) to `1`. For a successful response: Set `resp_ok` to `1`, and the `body` content is determined by `cmd`. An empty `body` is the simplest successful response. For a failed response: Set `resp_ok` to `0`. The first byte of `body` is the error code. Refer to [MaixCDK maix.err.Err](../../../components/basic/include/maix_err.hpp) for error codes. The following bytes in `body` contain the error message in `UTF 8` encoding, preferably in plain English for better compatibility. Each request must have a corresponding response, indicating either success or failure. Hereafter, `RESP_OK` and `RESP_ERR` are used to represent successful and failed responses, respectively. If the `body` of `RESP_OK` is not explicitly described, it means there is none. If present, it will be explained separately. ### Active Data Reporting Data direction: Maix device > MCU or other master device The master device must first enable active reporting using the `CMD_SET_REPORT` command (only supported for specific commands). > For example, if the APP supports the `CMD_GET_TEMP` command to get temperature data, the master can use the `CMD_SET_REPORT` command to enable periodic temperature reporting. If the APP does not support active reporting for `CMD_GET_TEMP`, it will respond with `CMD_ERROR`. Set the highest bit of `flags` (`is_resp`) to `1` and the third bit `is_report` to `1`. The `body` content depends on the `cmd`. ## Examples Example: The MCU connects to the Maix device via the serial port using the default baud rate of `115200`. The MCU requests the list of applications from the Maix device. The steps are as follows: 1. According to the protocol specification, the MCU sends a request with `cmd` set to `0xF9` (`CMD_APP_LIST`), and an empty `body`. Actual byte stream: `AA CA AC BB 04 00 00 00 01 F9 C9 77`. 2. The Maix device responds with `cmd` set to `0xF9` and `flags` set to `0xC1` (with `0x80` for response and `0x40` for success). The `body` contains the application list. If there are two applications, the actual byte stream is: `AA CA AC BB 0A 00 00 00 C1 F9 02 66 61 63 65 00 66 61 63 65 00 F6 06`. ## Command Definitions And System CMDs The `cmd` values in the protocol frame are defined as follows: Command Name Value Description CMD_APP_MAX 0xC8 Maximum value for custom commands (exclusive) CMD_SET_REPORT 0xF8 Set active reporting CMD_APP_LIST 0xF9 Query application list CMD_START_APP 0xFA Start an application CMD_EXIT_APP 0xFB Exit the current application CMD_CUR_APP_INFO 0xFC Query current application info CMD_APP_INFO 0xFD Query specific application info CMD_KEY 0xFE Simulate key press message CMD_TOUCH 0xFF Simulate touch message The commands specified here are system commands. Each application can define its own custom commands based on its functional characteristics. For example, in the `Camera` application, `0x01` can be defined as the \"take photo\" command, and `0x02` as the \"set flash\" command; in the `Classifier` application, `0x01` can be defined as the \"object recognition\" command. In other words, the formulation of **application commands** should follow these principles: * Commands are independent within each application. Once an application is entered, its specific command rules must be followed. For instance, if one application uses command `0x01`, another can still use `0x01` for a different purpose. * Any custom command defined by an app must fall within the range `0 ~ CMD_APP_MAX`, including `0` but excluding `CMD_APP_MAX`, as the upper range is reserved for system commands. * Each command’s definition and functionality should be clearly documented in the application’s user manual. Each `cmd` has specific request and response data and a unique `body`. Detailed explanations for each command are provided below: ### CMD_SET_REPORT Enables or disables active reporting for specific commands. Active reporting includes: 1. Event based reporting, such as reporting detected faces. 2. Periodic reporting, such as reporting temperature every 5 seconds. If both periodic and event based reporting are enabled, the timer restarts after an event report. #### Request `body`: cmd (1B) on_off (1B) event (1B) timer (4B) Description Command for active reporting Enable (1) or disable (0) Event reporting (1 for enable, 0 for disable) Timer for periodic reporting in ms (set to 0 if not needed) Example 0x02 0x01 1 5000 #### Response If the command supports active reporting, respond with `RESP_OK`; otherwise, respond with `RESP_ERR`. `body`: None ### CMD_APP_LIST Queries the list of available applications. #### Request `body`: None #### Response `body`: number (1B) app1 ... app n info Description Number of applications id1 (null terminated string) ... idn Example 0x02 'face\\0' ... 'appn\\0' ### CMD_CUR_APP_INFO Gets the current application information. #### Request `body`: None #### Response `body`: idx (1B) app info (id + name + brief) Description Application index Application info (id, name in UTF 8, brief description in UTF 8) Example 0x00 'face\\0face\\0face detect\\0' ### CMD_APP_INFO Queries specific application information. #### Request `body`: idx (1B) app_id (nB) Description Application index Application ID Example 0x02 'face' Either `idx` or `app_id` can be specified: * `idx`: Application index (starts from 0). Setting to `0xFF` means it is not specified. * `app_id`: Application ID. If `idx` is specified, `app_id` can be omitted. #### Response `body`: idx (1B) app info (id + name + brief) Example 0x00 'face\\0face\\0face detect\\0' ### CMD_START_APP Requests to start a specified application. This command will exit the current application and start the specified one. * If the APP receives this command, it must call the API `maix.app.switch_app` to switch the application. > There is a risk if the APP does not correctly implement the response to this command, prompting the developer to implement it. * If the Launcher receives this command, it will start the specified application. #### Request `body`: idx (1B) app_id (nB) app_func (nB) Description Application index (starts from 0, set to `0xFF` if unspecified) Application ID (optional if `idx` is specified) Function to execute if the application has multiple functions Example 0x02 'scan' 'qrcode' #### Response `body`: None ### CMD_EXIT_APP Requests to exit the current application. #### Request `body`: None #### Response `body`: None ### CMD_KEY Sends a simulated key press request. #### Request `body`: key (4B) value (1B) Key value (little endian) 0x01 (pressed), 0x00 (released), 0x02 (long press) #### Response `body`: None ### CMD_TOUCH Sends a simulated touch request. #### Request `body`: x y event (1B) x coordinate y coordinate Event type Event types: * 0x00: Press * 0x01: Release * 0x02: Move #### Response `body`: None ## Application (APPS) Protocol Specification Here are a few example applications to illustrate the usage—**note that these are not necessarily the actual command specifications**. For precise information, please refer to the corresponding **application documentation**. If an application supports the Maix communication protocol, the command specifications are usually documented. If not explicitly stated, you may assume they are unavailable. However, system commands generally remain usable. Application documentation can typically be found in the following locations: * **[MaixHub Application Center](https://maixhub.com/app)**: Simply find and open the homepage of the corresponding application. * **Source Repositories**: * **Community open source projects**: Available in their respective open source repositories. * **Official open source applications based on MaixCDK**: Available under the corresponding directories in [MaixCDK/projects](https://github.com/sipeed/MaixCDK/tree/main/projects). * **Official open source applications based on MaixPy**: Available under the corresponding directories in [MaixPy/projects](https://github.com/sipeed/MaixPy/tree/main/projects). ### Camera Commands: Command Value Description Response CMD_SNAP 0x01 Take a photo ### Classifier **Note: These are only examples.** For the actual protocol specifications, please refer to the corresponding [application documentation](https://github.com/sipeed/MaixCDK/tree/main/projects/app_camera). `body` Description: The request consists of a single byte representing the command, as shown in the table below: Command Value Description Response CMD_RECOGNIZE 0x01 Recognize object CMD_APP_CMD Response: * Response for command `CMD_RECOGNIZE`: The response `cmd` is `CMD_APP_CMD`, and the `body` is structured as follows: CMD_RECOGNIZE id (2B uint16 LE) prob (4B float LE) name CMD_RECOGNIZE value Recognized id (index), little endian Probability, float, little endian Name, UTF 8 encoded ### Face Detection **Note: These are only examples.** For the actual protocol specifications, please refer to the corresponding [application documentation](https://github.com/sipeed/MaixPy/tree/main/projects/app_face_landmarks). `body` Description: The request consists of a single byte representing the command, as shown in the table below: Command Value Description Response CMD_POS 0x01 Detect face CMD_APP_CMD Response: * Response for command `CMD_POS`: The response `cmd` is `CMD_APP_CMD`, and the `body` is structured as follows: CMD_POS face num (2B LE) prob (4B float LE) x (2B LE) y (2B LE) w (2B LE) h (2B LE) ... CMD_POS value Number of detected faces Probability, float, little endian Top left x coordinate of the face box Top left y coordinate of the face box Width of the face box Height of the face box Remaining faces... ### Face Recognition **Note: These are only examples.** For the actual protocol specifications, please refer to the corresponding [application documentation](https://github.com/sipeed/MaixPy/tree/main/projects/app_face_recognizer). `body` Description: The request consists of a single byte representing the command, as shown in the table below: Command Value Description Response CMD_FACES 0x01 Recognize faces CMD_APP_CMD CMD_USERS 0x02 Query all users CMD_APP_CMD CMD_RECORD 0x03 Record a face CMD_APP_CMD CMD_REMOVE 0x04 Remove a face CMD_APP_CMD Request: `CMD_APP_CMD` plus an additional byte for `app_cmd`. Some commands have extra parameters, as follows: * Request for command `CMD_RECORD`: CMD_RECORD user name CMD_RECORD value Name of the user being recorded * Request for command `CMD_REMOVE`: CMD_REMOVE user idx (2B int16) user name CMD_REMOVE value User index, 2 bytes, little endian Name of the user to be removed Either index or username can be provided. Response: * Response for command `CMD_FACES`: The response `cmd` is `CMD_APP_CMD`, and the `body` is structured as follows: CMD_FACES face num (2B LE) id (2B) name_len (1B) name prob (4B float LE) x (2B LE) y (2B LE) w (2B LE) h (2B LE) ... CMD_FACES value Number of detected faces Face ID (index) Length of the name Name, UTF 8 encoded Probability, float, little endian Top left x coordinate of the face box Top left y coordinate of the face box Width of the face box Height of the face box Remaining faces... * Response for command `CMD_USERS`: The response `cmd` is `CMD_APP_CMD`, and the `body` is structured as follows: CMD_USERS user num (2B LE) name_len (1B) name ... CMD_USERS value Number of users Length of the username Name, UTF 8 encoded Remaining usernames... * Response for command `CMD_RECORD`: `CMD_OK` or `CMD_ERROR` * Response for command `CMD_REMOVE`: `CMD_OK` or `CMD_ERROR` ## Using Maix Communication Protocol in MaixPy In MaixPy, the protocol parsing and transmission are already encapsulated in `maix.comm.protocol` and `maix.comm.CommProtocol`, making it very convenient to use. For more details, please refer to the [MaixPy documentation](https://wiki.sipeed.com/maixpy/doc/zh/comm/maix_protocol.html). ## Using Maix Communication Protocol in MaixCDK It is recommended to first read the MaixPy documentation above and try using it successfully in MaixPy, as the usage is essentially the same in MaixCDK. **Note:** If your application does not use `maix::comm::CommProtocol` to define custom commands, it is recommended to call the following function at the beginning of your program: ```c++ maix::comm::add_default_comm_listener(); ``` This function will automatically start a thread to listen for system commands, enabling support for system instructions such as starting and exiting your application via serial communication. ## Appendix: Code for Easy Porting to Other MCUs If you're not using the protocol within MaixCDK or MaixPy for example, if your MaixCAM is communicating with an external STM32. the following information will help you quickly port the protocol to STM32 or other devices. ### Refer to MaixCDK Source Code MaixCDK has open sourced the implementation of the Maix communication protocol. You can refer to the following files: * [`maix_protocol.hpp`](https://github.com/sipeed/MaixCDK/blob/main/components/basic/include/maix_protocol.hpp) * [`maix_protocol.cpp`](https://github.com/sipeed/MaixCDK/blob/main/components/basic/src/maix_protocol.cpp) Pay special attention to the `encode` and `get_msg` functions, and adapt them according to the needs of your target platform. ### C CRC16 IBM ```c unsigned short crc16_IBM(unsigned char *ptr, int len) { unsigned int i; unsigned short crc 0x0000; while(len ) { crc ^ *ptr++; for (i 0; i < 8; ++i) { if (crc & 1) crc (crc >> 1) ^ 0xA001; else crc (crc >> 1); } } return crc; } ``` Alternatively, using a lookup table: ```c const unsigned int crc16_table[256] { 0x0000, 0xc0c1, 0xc181, 0x0140, 0xc301, 0x03c0, 0x0280, 0xc241, 0xc601, 0x06c0, 0x0780, 0xc741, 0x0500, 0xc5c1, 0xc481, 0x0440, 0xcc01, 0x0cc0, 0x0d80, 0xcd41, 0x0f00, 0xcfc1, 0xce81, 0x0e40, 0x0a00, 0xcac1, 0xcb81, 0x0b40, 0xc901, 0x09c0, 0x0880, 0xc841, 0xd801, 0x18c0, 0x1980, 0xd941, 0x1b00, 0xdbc1, 0xda81, 0x1a40, 0x1e00, 0xdec1, 0xdf81, 0x1f40, 0xdd01, 0x1dc0, 0x1c80, 0xdc41, 0x1400, 0xd4c1, 0xd581, 0x1540, 0xd701, 0x17c0, 0x1680, 0xd641, 0xd201, 0x12c0, 0x1380, 0xd341, 0x1100, 0xd1c1, 0xd081, 0x1040, 0xf001, 0x30c0, 0x3180, 0xf141, 0x3300, 0xf3c1, 0xf281, 0x3240, 0x3600, 0xf6c1, 0xf781, 0x3740, 0xf501, 0x35c0, 0x3480, 0xf441, 0x3c00, 0xfcc1, 0xfd81, 0x3d40, 0xff01, 0x3fc0, 0x3e80, 0xfe41, 0xfa01, 0x3ac0, 0x3b80, 0xfb41, 0x3900, 0xf9c1, 0xf881, 0x3840, 0x2800, 0xe8c1, 0xe981, 0x2940, 0xeb01, 0x2bc0, 0x2a80, 0xea41, 0xee01, 0x2ec0, 0x2f80, 0xef41, 0x2d00, 0xedc1, 0xec81, 0x2c40, 0xe401, 0x24c0, 0x2580, 0xe541, 0x2700, 0xe7c1, 0xe681, 0x2640, 0x2200, 0xe2c1, 0xe381, 0x2340, 0xe101, 0x21c0, 0x2080, 0xe041, 0xa001, 0x60c0, 0x6180, 0xa141, 0x6300, 0xa3c1, 0xa281, 0x6240, 0x6600, 0xa6c1, 0xa781, 0x6740, 0xa501, 0x65c0, 0x6480, 0xa441, 0x6c00, 0xacc1, 0xad81, 0x6d40, 0xaf01, 0x6fc0, 0x6e80, 0xae41, 0xaa01, 0x6ac0, 0x6b80, 0xab41, 0x6900, 0xa9c1, 0xa881, 0x6840, 0x7800, 0xb8c1, 0xb981, 0x7940, 0xbb01, 0x7bc0, 0x7a80, 0xba41, 0xbe01, 0x7ec0, 0x7f80, 0xbf41, 0x7d00, 0xbdc1, 0xbc81, 0x7c40, 0xb401, 0x74c0, 0x7580, 0xb541, 0x7700, 0xb7c1, 0xb681, 0x7640, 0x7200, 0xb2c1, 0xb381, 0x7340, 0xb101, 0x71c0, 0x7080, 0xb041, 0x5000, 0x90c1, 0x9181, 0x5140, 0x9301, 0x53c0, 0x5280, 0x9241, 0x9601, 0x56c0, 0x5780, 0x9741, 0x5500, 0x95c1, 0x9481, 0x5440, 0x9c01, 0x5cc0, 0x5d80, 0x9d41, 0x5f00, 0x9fc1, 0x9e81, 0x5e40, 0x5a00, 0x9ac1, 0x9b81, 0x5b40, 0x9901, 0x59c0, 0x5880, 0x9841, 0x8801, 0x48c0, 0x4980, 0x8941, 0x4b00, 0x8bc1, 0x8a81, 0x4a40, 0x4e00, 0x8ec1, 0x8f81, 0x4f40, 0x8d01, 0x4dc0, 0x4c80, 0x8c41, 0x4400, 0x84c1, 0x8581, 0x4540, 0x8701, 0x47c0, 0x4680, 0x8641, 0x8201, 0x42c0, 0x4380, 0x8341, 0x4100, 0x81c1, 0x8081, 0x4040, }; unsigned short crc16_IBM(const unsigned char *ptr,int len) { unsigned short crc 0x0000; while(len ) { crc (crc >> 8) ^ crc16_table[(crc ^ *ptr++) & 0xff]; } return (crc); } ```"},"/maixcdk/doc/convention/app.html":{"title":"MaixCDK APP framework guide","content":"MaixCDK APP framework guide ## Introduction User use steps: * When device boot up, will automatically start `launcher`. * Use select one APP to start. * Run selected APP. * User interact with APP. * User exit APP. * `launcher` will start again and wait for user to select APP. User install new APP: * Ensure device is connected to internet(can connect WiFi in `app_settings` APP). * Open [maixhub.com/app](https://maixhub.com/app) to find APP, click `download` button, and a `QR code` and a `install code` will be shown. * Open `app_store` APP in device to open camera to scan QR code, or input install code to install the APP. * Return to launcher, the new APP will be shown in the list. ## Pack APP If use `MaixCDK`: * Create a `app.yaml` in your project folder, see below for format. * Execute `maixcdk release P maixcam` to pack APP for `maixcam` platform. * Then you will find a `app_store_v1.0.0.zip` in `dist` folder, this is the APP package. * You can upload this package to [maixhub.com/app](https://maixhub.com/app) to share with others. * Or you can execute `maixcdk deploy P maixcam` to serve a local server and a QR code will be shown. * Or you can upload this app file to device and execute `app_store install app_path.zip` to install by command. If use `MaixPy`, you can use `MaixVision Workstation` to release APP, or use `maixtool` to release manually: * Create a `app.yaml` in your project folder, see below for format. * Create a `main.py` in your project folder, this is the entry of your APP. * Execute `maixtool release` in this folder, `dist/app_id_vx.x.x.zip` will be generated. * You can upload this package to [maixhub.com/app](https://maixhub.com/app) to share with others. * Or you can execute `maixtool deploy` to serve a local server and a QR code will be shown. `app.yaml` format: ```yaml id: my_app # unique id, use lowercase and `_` to separate words name: My APP name[zh]: 我的应用 # Chinese name version: 1.0.0 # version number, major.minor.patch icon: assets/my_app.png # can be png or lottie json file, or empty author: Sipeed Ltd desc: My APP description desc[zh]: 我的应用描述 #### Include files method 1: # By default will include all files in project dir except exclude files exclude: # not support regular expression, .git and __pycache__ is always exclude .vscode compile build dist # extra_include: # src: dst # build/filename123: filename123 #### Include files method 2: # White list mode, only include files in files dict. # If no this key or value is empty, will use method 1. # files: # assets # hello.py # main.py #### Include files method 2.1: # White list mode, only include files in files dict. # If no this key or value is empty, will use method 1. # files: # assets: assets ``` `exclude` is blacklist mode, `files` is whitelist mode, you can use one of them. ## Files convention * All app data is stored in `/maixapp`. * Apps are stored in `/maixapp/apps`. * There is a `/maixapp/apps/app.info` INI file for simple description of installed apps. Install and uninstall APP will update this file. > developer or use can manually copy APP directories here and execute `python gen_app_info.py` will generate `app.info` file. * APP store in `/maixapp/apps/app_id` folder, every app must contain `app_id` executable file, or `main.sh` shell script, or `main.py` python script. * When boot up APP, the launcher will find file in app_id folder: `main.sh` > `main.py` > `app_id`. The `main.sh` will be executed by `sh`, `main.py` will be executed by `python3`, `app_id` will be directly executed. * All shared data is stored in `/maixapp/share`. * All pictures are stored in `/maixapp/share/picture`. * All video files are stored in `/maixapp/share/video`. * Temporary data can be stored in `/maixapp/tmp`. Note that this directory is located on the file system (SD card), which differs from the system's `/tmp` directory. The `/tmp` directory on the system is a virtual file system in memory, offering faster read/write speeds but with limited memory size. Large files and log files that need to be stored long term (which may grow over time) are recommended to be placed in the `/maixapp/tmp` directory. * Font files are stored in `/maixapp/share/font`. * Icon files are stored in `/maixapp/share/icon`. * APP's data files created at runtime can be stored in `/maixapp/apps/app_id/data`. * **All this path can be get by API `maix.app.get_xxx_path`, more detail see API doc or [maix_app.hpp](https://github.com/sipeed/MaixCDK/blob/main/components/basic/include/maix_app.hpp) file.** ## Switch from APP to anothor APP Use `void maix::app::switch_app(const string &app_id, int idx 1, const std::string &start_param \"\")` function to switch APP. This will exit current APP and start another APP, and parse `start_param` string to the second APP, the second APP can get this param by `maix::app::get_start_param()`."},"/maixcdk/doc/faq.html":{"title":"MaixCDK FAQ","content":"MaixCDK FAQ You can also find FAQ from: * [MaixPy FAQ](https://wiki.sipeed.com/maixpy/doc/en/faq.html) * [MaixCAM FAQ](https://wiki.sipeed.com/hardware/zh/maixcam/faq.html) * [MaixPy souce code FAQ](https://wiki.sipeed.com/maixpy/doc/zh/source_code/faq.html) ## Common Compilation Errors and General Solutions * **Errors such as extraction failures**: Try deleting the corresponding files in the `dl/pkgs` and `dl/extracted` directories, then recompile and download again. * **Compilation errors**: * Run `maixcdk build verbose` to see where the error occurs. **Carefully check the error log** and investigate the issue step by step. * Run `maixcdk distclean` to clean temporary files, then try recompiling. * Visit the [GitHub commit history](https://github.com/sipeed/MaixCDK/commits/main/) to check whether the automated tests for each commit passed (a green checkmark ✅ means it passed, a red cross ❌ means it failed). You can switch your local code to a commit that passed the tests ✅ and recompile. Use the command `git checkout <commit hash>`, for example: `git checkout 3aba2fe3fa9de9f638bb9cb34eca0c2e0f5f3813`. If switching fails, you may need to search for Git usage instructions or start over, but make sure to back up any changes you made to your code. ## Downloading ippicv_2021.8_lnx_intel64_20230330_general.tgz takes a long time or fail Manually download according to the log's url, and put it into: `MaixCDK > components > opencv > opencv4 > .cache > ippicv` The file name is `43219bdc7e3805adcbe3a1e2f1f3ef3b ippicv_2021.8_lnx_intel64_20230330_general.tgz`, File name and url can also be found in `MaixCDK/components/3rd_party/opencv/opencv4/3rdparty/ippicv/ippicv.cmake` So the same as `ade` cache file `.cache/ade/4f93a0844dfc463c617d83b09011819a v0.1.2b.zip` ## Exception: parse_api_from_header **.hpp error: 'members' API comment not complete. e.g. ```cpp /** * Class for communication protocol */ class CommProtocol { /** * Read data to buffer, and try to decode it as maix.protocol.MSG object * @return decoded data, if nullptr, means no valid frame found. * Attentioin, delete it after use in C++. * @maixpy maix.comm.CommProtocol.get_msg */ protocol::MSG *get_msg(); } ``` Here `class CommProtocol` not add `@maixpy maix.comm.CommProtocol` but its method `get_msg` add it. So we add `@maixpy maix.comm.CommProtocol` to `class CommProtocol` comment will fix this error. ## Build OpenSSL Error when using WSL( Windows Subsystem Layer) When I add openssl to my project ![a0cee88e7a7a747c2d34eadb31a925bd](https://github.com/user attachments/assets/77b0c057 fb0b 4980 8ff4 413fd14dec28) build fail occured: ![3b42197634ee4cd6a7b0462636e8dd34](https://github.com/user attachments/assets/d23da336 8096 43ec aec8 23691caaacf2) Use \"maixcdk build verbose\" to check . I found that windows path polluted wsl path . and there are \"(\" and space in path ,which make configure of openssl fail . Fix : fix the path : edit `wsl.conf` in wsl ```sh sudo nano /etc/wsl.conf ``` create the file if no exist. add the content below : ``` [interop] appendWindowsPath false ``` restart wsl ``` wsl shutdown Ubuntu ``` ![9a86a628630209725d362f07b51ecb9a](https://github.com/user attachments/assets/79571b2c 3449 4ae8 afdd 69917d4986ce) path is fixed ,openssl configure succ ![d6e43b3bf8e5c68d9966636464b08a43](https://github.com/user attachments/assets/f69be859 dc9c 4a7d 82f3 06df0ea03ed5)"},"/maixcdk/doc/dev/vscode_debug.html":{"title":"使用 VSCode 在线调试","content":" title: 使用 VSCode 在线调试 ## 调试 这里主要提供 vscode + gdb 的调试方法，看不太懂可以先跳过，可以先使用代码加`printf`打印的方式调试。 **(1).** 对于在本机（PC）运行，VSCode + GDB 在线调试 这里以 PC 为 Linux 系统为例： * 添加 MaixCDK（第一次试用推荐这样） 或者 工程目录到 VSCode 工作区 * 拷贝 [tools/vscode/vscode_local_debug/.vscode](../../../tools/vscode/vscode_local_debug/.vscode) 目录到上一步的工作目录下 * 根据`.vscode`是在 MaixCDK 还是在工程目录下，修改`.vscode/launch.json`中的`cwd`字段 * 按键盘 `F5` 即可开始调试 > windows 也类似，修改`.vscode`里面的相关命令和路径即可 **(2).** 对于在嵌入式设备（/远程设备，带 Linux 系统）调试 使用 VSCode + gdbserver 在嵌入式设备（/远程设备，带 Linux 系统）调试 这里以 PC 为 Linux 系统为例： * 先保证远程设备有`gdbserver`这个程序，以及 PC 有`gdb multiarch`这个程序 * 将 [tools/vscode/vscode_remote_debug/.vscode](../../../tools/vscode/vscode_remote_debug/.vscode) 目录拷贝到工程目录下 * 编辑 `launch.json` 和 `build_run_gdbserver.sh` 文件，修改里面的路径和命令，以及用户名等。 > 建议先将 PC 的 ssh key 加入到远程设备的 `~/.ssh/authorized_keys` 文件中，这样就不需要输入密码了。 * 每次调试需要执行 `build_run_gdbserver.sh` 脚本，然后在 VSCode 中按 `F5` 即可开始调试 > 脚本会编译工程，然后拷贝可执行文件到远程设备，并且启动 `gdbserver`。 > 按 F5 启动调试时， VSCode 使用 GDB 连接到远程设备的`gdbserver`以调试。"},"/maixcdk/doc/dev/comm_protocol_internal.html":{"title":"Maix 串口协议内部实现规范","content":" title: Maix 串口协议内部实现规范 ## 串口协议内部实现规范 Maix Comm Protocol 内部根据系统设置的通信方式（比如 uart），构建一个 UART 对象使用，并且调用 uart 的 register_comm_callback(obj, callback)（obj是一个UART对象指针）, 用户需要使用串口时构建UART对象构造函数会先检查是否已经注册过（比如判断已经注册过的obj使用的UART编号和即将初始化的UART编号是否相同）， 如果没有注册过就普通构造，已经注册过那就先回调设置的callback函数,callback 负责释放obj（注意 uart 里面 callback后UART不要再使用register_comm_callback传进来的obj了），然后再构造。"}}