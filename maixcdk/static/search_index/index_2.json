{"/maixcdk/doc/zh/dev/docker/index.html":{"title":"MaixCDK Docker 构建环境","content":"MaixCDK Docker 构建环境 ## 关于 Docker 和安装 Docker Docker 是一种工具，我们在这里使用它来创建一个干净的 Ubuntu 环境用于构建 MaixCDK。 使用 Docker，你无需手动安装依赖项，只需创建一个 Docker 容器，一切环境就准备好了。 安装 Docker 的文档请参考 [Docker 官方文档](https://docs.docker.com/engine/install/ubuntu/)。 安装完成后，你可以使用 `docker version` 检查是否安装成功。 ## 从 Docker Hub 拉取（推荐），或自行构建 ```shell docker pull sipeed/maixcdk builder ``` > 或者你也可以通过 Dockerfile 自行构建： > > ```shell > docker build network host t maixcdk builder . > ``` > 你也可以通过添加参数使用代理： > ` network host build arg http_proxy http://127.0.0.1:8123 build arg https_proxy http://127.0.0.1:8123`。 ## 创建并运行容器 在上一步中我们得到了一个 Docker 系统镜像，现在我们创建一个容器来运行这个镜像。 ```shell docker run it network host hostname maixcdk env name maixcdk env env USER $USER env UID `id u` env GID `id g` env MAIXCDK_PATH /home/${USER}/MaixCDK v /home/${USER}/MaixCDK:/home/${USER}/MaixCDK sipeed/maixcdk builder ``` > !! 不要在命令末尾添加 `/bin/bash`。 > ` network host` 表示使用与主机相同的网络。 > ` hostname` 设置容器的主机名为 `maixcdk env`。 > ` name` 设置容器名称为 `maixcdk env`，方便使用 `docker` 命令进行控制。 > `USER`（主机的用户名）、用户 ID 和组 ID 将与主机的用户信息一致，避免权限问题。 > 你可以使用 ` v host_dir:container_dir` 将你的数据映射到容器中，例如：` v /home/${USER}/MaixCDK:/home/${USER}/MaixCDK v /home/${USER}/projects:/home/${USER}/projects`。 > 建议将主机目录映射到容器的相同目录，这样查看日志会更方便。 > 使用 ` env MAIXCDK_PATH /home/${USER}/MaixCDK` 参数设置 `MAIXCDK_PATH` 环境变量，这样你可以在容器内任何位置编译项目。 > `sipeed/maixcdk builder` 是镜像名称，如果你自行构建，请使用 `maixcdk builder`。 接下来你可以在容器中使用 shell 命令。默认用户密码为 `maixcdk`，如果需要修改密码，可以使用以下命令： ```shell docker exec it maixcdk env passwd ``` ## 构建 MaixCDK 项目或示例 进入容器后，可以根据 MaixCDK 文档使用 shell 命令进行构建。 ```shell cd /MaixCDK/examples/hello_world maixcdk build maixcdk run cd ~/projects/my_project maixcdk build maixcdk run ``` ## 停止容器 ```shell docker stop maixcdk env ``` ## 启动容器 ```shell docker start maixcdk env docker attach maixcdk env ``` ## 从主机 shell 执行命令 ```shell docker exec it user $USER maixcdk env \"cd /MaixCDK/examples/hello_world && maixcdk build && maixcdk run\" ``` ```shell docker exec it user $USER maixcdk env /bin/bash ``` ## 删除容器 ```shell docker stop maixcdk env docker rm maixcdk env ```"},"/maixcdk/doc/zh/dev/quick_start.html":{"title":"MaixCDK quick start","content":" title: MaixCDK quick start see [quick start](../index.html)"},"/maixcdk/doc/zh/application/ai/yolo11.html":{"title":"MaixCDK YOLO11 develop notes","content":" title: MaixCDK YOLO11 develop notes 源代码在： [MaixCDK/components/nn/include/maix_nn_yolo11.hpp](https://github.com/sipeed/MaixCDK/blob/main/components/nn/include/maix_nn_yolo11.hpp) 模型来自 [ultralytics/ultralytics](https://github.com/ultralytics/ultralytics), 训练和转换模型参考 [MaixPy doc customize yolo11](https://wiki.sipeed.com/maixpy/doc/en/vision/customize_model_yolov8.html)。"},"/maixcdk/doc/zh/application/index.html":{"title":"MaixCDK 应用笔记","content":" title: MaixCDK 应用笔记 这些笔记是 MaixCDK 开发者在创建某些功能时记录的开发笔记。 如果你想了解更多功能和详细文档，请访问 [MaixPy 文档](https://wiki.sipeed.com/maixpy/)。"},"/maixcdk/doc/zh/application/ui/lvgl.html":{"title":"在 MaixCDK 中使用 LVGL","content":" title: 在 MaixCDK 中使用 LVGL ## 运行 gui_lvgl 示例 * 进入 MaixCDK 的 `examples/gui_lvgl` 目录。 * 执行 `maixcdk build` 来在 PC 上构建项目。 * 执行 `maixcdk run` 来在 PC 上运行项目。 你还可以执行 `maixcdk menuconfig` 来切换平台，构建适用于其他平台的项目。 ## 自定义 UI * 首先下载并安装 [Squareline](https://squareline.io/)。 * 在 Squareline 中创建一个新的 UI 项目。 * 编辑你的 UI。 * 导出 UI 文件，此时会得到一个 `ui` 文件夹。 * 将所有 UI 文件复制到 `examples/gui_lvgl/ui` 文件夹。 * 运行 `maixcdk build` 进行构建。"},"/maixcdk/doc/zh/application/peripheral/uart.html":{"title":"","content":""},"/maixcdk/doc/zh/index.html":{"title":"MaixCDK 快速开始","content":" title: MaixCDK 快速开始 ## MaixCDK 基本介绍 MaixCDK 使用 C++ 封装了常用的 AI 图像、视觉、语音，外设相关的 API，使用 MaixCDK 可以快速验证产品原型和开发稳定的产品。 MaixCDK 不光是一套 C++ SDK，同时会自动生成 Python API 绑定，即可以使用 Python 进行开发，也就是[MaixPy](https://wiki.sipeed.com/maixpy/)。 使用 MaixCDK 需要基本的 Linux 使用经验和懂交叉编译的基本概念。 ## 基础知识 要使用 MaixCDK，均假设你已经会以下知识，不会请先自行学习或者请转角使用[MaixPy](https://wiki.sipeed.com/maixpy/)： * 熟练使用 Linux 进行开发，熟悉终端以及常见命令使用。 * 熟练掌握 C/C++ 其中一种语言，其中 C++ 可以不熟练但是必须了解基础语法和面向对象概念。 * 会主动看源码分析问题。 * 中国开发者须了解使用网络代理。 * 了解交叉编译。 ## 如何找资料和解决问题 1. 多看 [MaixCDK 源码](https://github.com/sipeed/MaixCDK)。 2. 由于功能 / `API` 和 `MaixPy` 相同，`MaixCDK` 不再单独提供详细的教程，请参考[MaixPy 文档](https://wiki.sipeed.com/maixpy/)，原理和代码基本一致，稍微转换一下就能使用。 3. 建议不要直接从 `MaixCDK` 上手，先体验完基本的 `MaixPy` 使用再使用 MaixCDK 会轻松很多。 4. 多看仔细看官方文档，包括 MaixCDK、MaixPy、硬件文档。 5. 遇到问题先从 [MaixCDK FAQ](https://wiki.sipeed.com/maixcdk/doc/zh/faq.html), [MaixPy FAQ](https://wiki.sipeed.com/maixpy/doc/zh/faq.html), [MaixCAM 硬件 FAQ](https://wiki.sipeed.com/hardware/zh/maixcam/faq.html) 以及[源码 issues](https://github.com/sipeed/MaixCDK/issues) 等地方找答案。 6. [MaixHub 分享广场](https://maixhub.com/share) 看社区成员的经验。 7. **仔细 耐心** 看 错误`LOG`， 从上到下看日志，出错日志有时可能在中间，不要跳过着急！！ ## 快速开始 ### 准备系统和环境 两种方式： #### 本机： **仅支持 Linux 系统**，推荐使用 **Ubuntu > 20.04**。 注意 MaixCAM 工具链只支持 x86_64 CPU，不支持 ARM 电脑，特别是如果你是 ARM MacOS 则无法编译过。 ``` sudo apt update sudo apt install git cmake build essential python3 python3 pip autoconf automake libtool cmake version # cmake 版本应该 > 3.13 ``` > 如果你希望编译出来到 Linux PC 上跑，而不是交叉编译到开发板，如果是 `Ubuntu`，请使用系统版本`> 20.04`，否则有些依赖包可能会版本太旧无法编译通过，并且按照[Dockerfile](https://github.com/sipeed/MaixCDK/blob/main/docs/doc/dev/docker/Dockerfile)里面的安装依赖的命令来安装依赖。 > 如果编译仍然报错，请[使用 Docker 环境进行编译](./dev/docker/index.html)。 #### Docker： `Docker` 环境准备好了 `ubuntu20.04` 系统和依赖，可以直接获取开始编译，**对 `Docker` 熟悉 或者 搭建本地开发环境遇到问题**可以参考。 详细请看 [Docker 环境使用方法](./dev/docker/index.html)。 ### 获取源码 ``` git clone https://github.com/Sipeed/MaixCDK ``` > * 稳定的 Release 版本可以到 [release 页面](https://github.com/Sipeed/MaixCDK/releases) 下载。 > * 另外也可以看 [MaixPy release](https://github.com/Sipeed/MaixPy/releases) assets 下的 `maixcdk_version_xxxxx.txt`， 这个`xxxxx` 就是 MaixPy 对应 release 使用的版本，可以使用`git checkout xxxx`来切换到对应的版本。 > 中国国内用户可能克隆速度比较慢，可以使用`git clone https://gitee.com/Sipeed/MaixCDK` ### 安装依赖 ``` cd MaixCDK pip install U pip # 更新 pip 到最新版本 pip install U r requirements.txt # 安装依赖 ``` > 中国国内可以加` i https://pypi.tuna.tsinghua.edu.cn/simple`参数来使用清华源。 > `Docker`环境里面已经装好了，不过也可以在`Docker`容器里面执行命令更新到最新版本。 此时在终端执行`maixtool`和`maixcdk`命令可以看到帮助信息。 > 如果报错找不到命令，可以尝试重启终端，或者通过`find / name \"maixtool\"`来找到`maixtool`命令的位置，然后通过`export PATH maixtool所在目录;$PATH`来设置系统环境变量，重启终端就可以执行`maixtool`命令了。 ### 编译 ```shell cd examples/hello_world maixcdk menuconfig ``` 根据提示选择设备平台，会出来一个界面可以配置一些参数，初次使用用默认的参数即可（用默认的参数也可以不执行 menuconfig, 直接执行 build 命令），然后按`ESC`按键，再按`Y`保存退出。 ```shell maixcdk build ``` 第一次执行这一步会根据设备下载编译工具链，下载如果太慢，可以根据提示手动下载到提示的目录，然后再执行编译。 >! 下载的资源基本都是 github 上的，中国国内下载速度可能会比较慢甚至失败（要下载的文件列表在`dl/pkgs_info.json`），有几种常见解决方法： > 1. 终端设置代理（推荐）， 比如：`export http_proxy http://127.0.0.1:8123 https_proxy http://127.0.0.1:8123`，这里`http://127.0.0.1:8123`就是你的`http`代理的地址。 > 2. 手动下载到`dl/pkgs`下：下载时，会打印下载连接和下载到本地的路径，手动下载文件方到对应路径，再次执行编译就会直接使用本地准备好的（注意文件 sha256 校验值必须相同即同一个文件）。 > 3. 中国国内用户可以到 [首页 QQ 群](../) 群文件`MaixCDK`文件夹下载放到`MaixCDK/dl`目录下。 >! 常见错误和解决方法看[FAQ](./faq.html) 编译完后在`build`目录下可以看到二进制程序文件，以及`build/dl_lib`下有依赖的`so`文件。 修改了代码后，再次执行`maixcdk build`即可编译。 如果你**没有增删源码文件可以执行`maixcdk build2` 或者 `maixcdk build no gen` 编译会更快**（只编译修改了的文件）。 > 因为`build`命令会从头开始构建，扫描文件再编译，`build2`命令则不会扫描文件增删，直接编译编辑过的文件。 > 注意`build2`命令不会检测到文件增加或者删除，如果**增删了文件必须再执行一遍`build`命令**。 也可以执行`maixcdk distclean` 清除所有编译产生的临时文件以从一个干净的环境开始编译（但是这样构建时间会很长，一般编译出现奇怪的问题可以先尝试这样解决）。 ### 上传程序到设备 拷贝 可执行文件 和 `dl_lib`文件夹 到设备运行。 可以通过 `scp`命令来拷贝，比如： ```shell scp r dist/ root@10.127.117.1:/root/ ``` 默认密码是`root` ### 运行 通过 ssh 终端运行程序。注意要保证没有程序正在运行（包括开机的应用选择界面(Launcher)）。 具体方法： * MaixVision 连接设备，这会让 Launcher 退出。也可以在 ssh 终端手动`kill` `launcher_daemon`程序。（**重要!!**） * ssh 连接设备，比如 `ssh root@192.168.0.123`， 密码是 `root`。 * 然后到可知性文件目录下执行文件， 比如 `cd /root/dist/camera_display_release && ./camera_display` ### 打包发布 在工程目录下，使用 `maixcdk p maixcam release` 可以为 `maixcam` 打包一个程序包并且存放在`dist`目录，可以上传发布到[MaixHub 应用商店](https://maixhub.com/app)。 安装包使用方法： * 方法一： ssh 终端，直接解压拷贝到设备，执行`chmod +x 程序名 && ./程序名`即可运行。 * 方法二： 在设备运行[应用商店](https://maixhub.com/app/12)应用，在 [MaixHub 应用商店](https://maixhub.com/app) 扫码安装。 * 方法三： 对于开发者，保证设备已经连到了和电脑所在局域网，在工程目录执行`maixcdk deploy` 会出现一个二维码， 在设备运行[应用商店](https://maixhub.com/app/12)应用扫码安装。 * 方法四： 拷贝安装包到设备，在设备执行`/maixapp/apps/app_store/app_store install xxx.zip` 即可安装应用。 这里简单提及一下，发布的应用需要遵循[APP 开发准则](./convention/app.html)。 ### 新建工程 使用命令创建工程： ```shell maixcdk new ``` ## 为 MaixPy 添加 API 因为 MaixPy 底层大多数就是 MaixCDK，而为 MaixPy 添加 API 也非常简单，给函数加一个注释`@maixpy maix.xxx.xxxx` 就可以了。 比如要实现以下 API： ```python from maix import example result example.hello(\"Bob\") print(result) ``` 只需要在[maix_api_example.hpp](https://github.com/sipeed/MaixCDK/blob/main/components/basic/include/maix_api_example.hpp) 中添加声明： ```cpp namespace maix::example { /** * @brief say hello to someone * @param[in] name name of someone, string type * @return string type, content is hello + name * @maixpy maix.example.hello */ std::string hello(std::string name); } ``` 然后编译`MaixPy`项目得到 MaixPy 安装包，安装到设备即可使用新的 API 了，简单吧！ 更详细的文档请看 [添加 API](./convention/add_api.html) ## 开发准则 要开始使用 MaixCDK，请从阅读[MaixCDK 开发准则](./convention/index.html) 开始。"},"/maixcdk/doc/zh/more.html":{"title":"更多 MaixCDK 文档","content":" title: 更多 MaixCDK 文档 MaixCDK 由于是 MaixPy 的大多数 API 底层实现，所以 [MaixPy 的文档](https://wiki.sipeed.com/maixpy/)也适用于 MaixCDK，比如 功能介绍和教程，系统定制等等。"},"/maixcdk/doc/zh/convention/add_api.html":{"title":"Add API for MaixCDK / MaixPy","content":" title: Add API for MaixCDK / MaixPy ## 代码规范 请先看[代码规范](./index.html) ## 如何添加 API 在 [快速开始](../index.html) 中末尾我们提到过通过注释的方式给 MaixPy 添加一个新的 API，看起来非常简单，只需要给 API 函数添加一个注释即可，比如 ```cpp namespace maix::example { /** * @brief say hello to someone * @param[in] name name of someone, string type * @return string type, content is hello + name * @maixpy maix.example.hello */ std::string hello(std::string name); } ``` 然后就可以在 MaixPy 中调用了： ```python from maix import example result example.hello(\"Bob\") print(result) ``` 为了尽量保证我们添加的 API 对用户**可用**，我们需要保证以下几个特性： * API 名字和参数设计合理，通用性、跨平台性强。 * API 有注释（编译时会自动生成 API 文档）。 * API 不只是 API，有使用介绍文档教程和例程代码。 这里更详细地阐述和规范流程： * **确认功能，先在[MaixPy 文档源码](https://github.com/sipeed/MaixPy/tree/main/docs/doc)中添加一份使用**文档和例程**。相当于设计文档，这样做可以避免直接写代码考虑不全后期不停修改 API，同时也有了文档。**（这很重要！！！） * 可以在[docs/doc/application](https://github.com/sipeed/MaixCDK/tree/main/docs/doc/application) 目录下找到合适的地方添加一份**应用文档**，用来记录开发时的一些细节。文件名全小写，单词使用下划线隔开比如`peripheral/uart.md` 或者`ai/yolov2.md`。 * 最好是在开发文档里面注明 API 设计参考了哪些资料或者开源项目，方便大家审阅 API 的通用性和合理性，会更快通过审阅。 * 参考[components/basic/include/maix_api_example.hpp]，在合适的 `component`中添加 API，如果是新的组件，尽量先在[issues](https://github.com/sipeed/MaixCDK/issues)中讨论合理性。 > 注意这里使用了注释来标识 `API`，方便自动生成文档和`MaixPy`源码，所以要十分小心，具体请看上面的注释规范说明以及`maix_api_example.hpp`文件。 > 另外为了让在`MaixCDK`中写的 `API`能顺利生成 `MaixPy` 的 `API`，而且因为`MaixCDK`中不包含 `Python.h` 和 `Pybind11.h`等跟 `Python`相关的定义， > 语言自带的类型都是最终由`pybind11`自动转换的，比如`void hello(std::string a, std::vector<int> b)` 最终等价 `MaixPy` 中的`def hello(a: str, b: list)`。 > 常见的比如 `std::vector`对应`list`， `std::map`对应`dict`, `std::valarray`(作为参数可以接受`list`和`bytes`, 返回值会变成 `list`) 和 `maix::Bytes`(作为参数和返回值都是`bytes`)对应 `bytes`，`std::function` 对应 MaixPy 中的函数等，具体更多可以参考[pybind11 文档](https://pybind11.readthedocs.io/en/stable/advanced/cast/overview.html#conversion table) * 在`examples`目录添加一个 C++ 例程，保证它能编译运行。 * 编译会自动生成文档，检查 `docs/doc/api`下生成的文档是否有误，有误则检测修改代码。 * 编译测试[MaixPy](https://github.com/sipeed/MaixPy)工程基于更新后的 `MaixCDK` 能否通过，以及查看生成的`MaixPy`文档是否有误，有误则检测修改代码。 * `git`提交代码到`github`自己的仓库，等待`action`自动构建和测试，检查是否有错误，如果有错误，及时修改。 * 所有在线测试无误后，提交 `PR`(`Pull Request`)， 在 [github](https://github.com/sipeed/MaixCDK) 和 [github](https://github.com/sipeed/MaixCDK) 分别请求合并到`dev`分支。 ## 手动添加 MaixPy API 上面的方法可以自动生成 MaixPy API，但是在某些场景下可能需要手动添加，比如 参数是特定的类型，以 `numpy.array`为参数举例： * 在 `MaixPy` 项目中的`components/maix/include`下添加头文件和代码，可以使用和 `MaixCDK`相同的`namespace`，比如`maix.image.cv2image`函数是将`numpy`数组转化为`image.Image`对象，具体看`convert_image.hpp`文件中的定义。 更多参考： * [构建 MaixPy](https://wiki.sipeed.com/maixpy/doc/zh/source_code/build.html) * [给 MaixCAM MaixPy 添加一个 C/C++ 模块](https://wiki.sipeed.com/maixpy/doc/zh/source_code/add_c_module.html)"},"/maixcdk/doc/zh/convention/i18n.html":{"title":"MaixCDK 国际化（i18n）与多语言支持","content":" title: MaixCDK 国际化（i18n）与多语言支持 你可以使用任何喜欢的国际化库，例如 [gettext](https://www.gnu.org/software/gettext/)，它支持 Python 和 C++。 此外，我们还提供了一个简单的 i18n 库，适用于简单的使用场景。 ## 针对 MaixPy 请参阅 [MaixPy 国际化文档](https://wiki.sipeed.com/maixpy/doc/zh/gui/i18n.html)。 ## 针对 MaixCDK 与 MaixPy 相同，有两种方法可以使用： ### 简单的翻译字典 首先确保你的源文件编码为 `UTF 8`。 ```cpp #include \"maix_i18n.hpp\" const std::map<string, string> locale_zh_dict { {\"out\", \"输出\"}, {\"hello\", \"你好\"} }; const std::map<string, string> locale_ja_dict { // {\"out\", \"出力\"}, {\"hello\", \"こんにちは\"} }; const std::map<string, const std::map<string, string>> locales_dict { {\"zh\", locale_zh_dict}, {\"ja\", locale_ja_dict} }; i18n::Trans trans(locales_dict); int main() { log::info(\"系统语言: %s\\n\", i18n::get_locale().c_str()); log::info(\"%s: %s\\n\", trans.tr(\"out\").c_str(), trans.tr(\"hello\").c_str()); trans.set_locale(\"zh\"); printf(\"%s: %s\\n\", trans.tr(\"out\").c_str(), trans.tr(\"hello\").c_str()); trans.set_locale(\"en\"); printf(\"%s: %s\\n\", trans.tr(\"out\").c_str(), trans.tr(\"hello\").c_str()); trans.set_locale(\"ja\"); printf(\"%s: %s\\n\", trans.tr(\"out\").c_str(), trans.tr(\"hello\").c_str()); return 0; } ``` ### 分离的翻译文件 上面的示例适用于少量翻译字符串。如果需要翻译大量字符串，推荐使用此方法： * 不需要修改源代码即可更换翻译内容，翻译字符串保存在独立的 yaml 文件中。 * 更容易定位翻译字符串，支持自动扫描需要翻译的字符串，并自动生成 yaml 文件。 ```cpp err::Err e trans.load(\"locales\"); // 从 locales 目录加载翻译文件 err::check_raise(e, \"加载翻译 yaml 文件失败\"); log::info(\"系统语言: %s\\n\", i18n::get_locale().c_str()); log::info(\"%s: %s, %s\\n\", i18n::get_locale().c_str(), trans.tr(\"out\").c_str(), trans.tr(\"hello\").c_str()); trans.set_locale(\"zh\"); log::info(\"zh: %s, %s\\n\", trans.tr(\"out\").c_str(), trans.tr(\"hello\").c_str()); trans.set_locale(\"en\"); log::info(\"en: %s, %s\\n\", trans.tr(\"out\").c_str(), trans.tr(\"hello\").c_str()); trans.set_locale(\"ja\"); log::info(\"ja: %s, %s\\n\", trans.tr(\"out\").c_str(), trans.tr(\"hello\").c_str()); ``` 完整示例请参见 [examples/i18n](https://github.com/sipeed/MaixCDK/tree/main/examples/i18n)。 然后执行 `maixtool i18n d . r`，这将扫描所有使用 `tr()` 或 `_()` 的翻译字符串，生成 `locales` 目录和翻译文件。手动翻译 `locales` 中的 yaml 文件后，将其放置在程序旁边并运行。 ## 在 LVGL 应用中显示国际化字体 查看如何显示自定义字体：[https://neucrack.com/p/514](https://neucrack.com/p/514)。 使用以下代码： ```cpp LV_FONT_DECLARE(zh_fonts); static const std::map<string, void*> fonts { {\"zh\", (void*)&zh_fonts} }; const lv_font_t *get_font_by_locale(const string &locale) { const std::map<string, void*>::const_iterator iter fonts.find(locale); if (iter fonts.end()) { return &zh_fonts; } return (lv_font_t *)iter >second; } ``` 最后，使用国际化字体： ```cpp std::string locale i18n::get_locale(); lv_obj_set_style_text_font(lv_scr_act(), get_font_by_locale(locale), LV_PART_MAIN); lv_obj_t *label lv_label_create(lv_scr_act()); lv_label_set_text(label, trans.tr(\"hello\").c_str()); ```"},"/maixcdk/doc/zh/convention/index.html":{"title":"MaixCDK 开发准则和指导","content":"MaixCDK 开发准则和指导 ## 总体准则 * 简单简洁易用。 不假设用户已经有特定的开发经验，尽量少操作，API 尽量简单，有详细指导文档。 > 比如 相比 让用户自己选择并下载工具链，根据用户选择的平台自动选择并下载工具链更好，入门门槛更低。 * 通用性。API 在设计时应该保证能在不同平台通用和统一抽象，如果做不到，那么这个功能可能得再三斟酌是否应该增加。 * 统一性。API 风格统一，代码风格统一。 * 扩展性。 保证核心功能的同时，尽量提供扩展接口，方便用户扩展。 * 深度性。API 足够简单，文档写明原理，源码尽量开源，方便用户深入研究。 ## 源码和二进制文件 * **不用 git 子模块**：方便中国用户下载，因为如果子模块在 github，就算对仓库做了镜像，子模块始终还是要去 github 拉取，中国用户会非常缓慢。 * **不要往源码仓库放大文件和二进制文件**：这会大大增加仓库 git 的大小， git 只擅长管理文本文件，二进制文件采用下一条的方式管理。 * **对于第三方库和二进制文件，在编译前自动下载到本地**：使用[component.py](https://github.com/sipeed/MaixCDK/blob/main/components/3rd_party/asio/component.py)定义在编译开始前需要自动下载到`dl/pkgs`并自动解压到`dl/extracted`目录下的文件，这样就能直接在`CMakeLists.txt`中引用源码了，比如`list(APPEND ADD_INCLUDE \"${DL_EXTRACTED_PATH}/sunxi_mpp/sunxi mpp 1.0.0/include\")`。 > 每次编译时会将所有需要下载的文件列表写入到`dl/pkgs_info.json`，用户有网速问题的可以到官方 QQ 群或者第三方提供的网盘手动下载放到`dl/pkgs`目录即可，这样可以解决网络环境导致的下载速度慢问题。 * **不修改第三方库源码**：不修改第三方源码，方便升级第三方库。（如果以后发现有这样的需求可以考虑在解压后增加自动打 patch 的功能） ## MaixCDK 架构简介 对于普通应用开发者， 必要知识： * 主要由`MaixCDK` 和 `project`两大部分组成，前者是`库`存放的地方，后者是应用代码存放的地方。 官方的例程和`APP`都直接放在`MaixCDK/examples` 和 `MaixCDK/projects`目录下，你也可以直接在`MaixCDK/projects`创建你的应用项目。 另外也可以两者分开放，在系统环境变量中加一个变量`MAIXCDK_PATH`，值为`MaixCDK`目录比如`/home/xxx/MaixCDK`，比如编辑`~/.bashrc`添加`export MAIXCDK_PATH /home/xxx/MaixCDK`。 这样项目就可以放其它位置了比如`/home/xxx/projects` * 组件：每个功能模块可以封装成一个组件，方便不同应用选择性地使用。 * 可以看到[examples/hello_world](./examples/hello_world)中有个`main`组件，[components](./components)中有很多组件，还可以自己添加组件，比如`hello_world/component1`或者`hello_world/compoents/component2`。 * 也可以设置环境变量`MAIXCDK_EXTRA_COMPONENTS_PATH`来指定其它额外的组件库。 * 每个组件包含一个`CMakeLists.txt`来描述组件内容，比如`list(APPEND ADD_INCLUDE \"include\")`来指定包含的头文件路径，`list(APPEND ADD_SRCS \"src/hello.c\")`来包含源文件，`list(APPEND ADD_REQUIREMENTS basic)`来依赖其它组件等。 * 另外，默认也会到 python `site packages` 目录寻找，也就是说，如果你了解 python 库打包，你的组件包可以直接发布到 [pypi.org](https://pypi.org), 这样用户通过`pip install maixcdk xxx` 就可以快速安装你的组件包了！ 可以参考[examples/maixcdk example](https://github.com/sipeed/MaixCDK/blob/main//examples/maixcdk example)组件。 * Kconfig: 带终端界面的可配置项。每个组件下面都可以有一个`Kconfig`文件，里面可以设置一些配置项，在执行`maixcdk menuconfig`时就可以看到选项了，保存后会在`build/config`目录下生成`global_config.cmake`,`global_config.h`文件，可以直接在组件的`CMakeLists.txt`和`c/cpp`文件中使用。`Kconfig`的语法可以参考其它组件，活话则自行搜索、参考[这里](https://github.com/ulfalizer/Kconfiglib/tree/master/tests)等。 * 依赖的第三方库： 两种方式，开发者可以自行选择，推荐集成到`MaixCDK`中的使用方式一，个人开发者发布的组件可以使用方式二。 * 方式一：依赖的第三方库在编译时会自动被下载到`dl`文件夹，都在组件`CMakeLists.txt`中指定需要下载的文件，编译时会将所有需要下载的文件列表写入到`dl/pkgs_info.json`，这样的好处是遇到网络问题可以手动下载放到对应位置。 * 方式二：使用 python package 的方式将源码和资源文件都打包发布到 [pypi.org](https://pypi.org)，取名为`maixcdk xxx`方便大家搜索到，这样用户通过`pip install maixcdk xxx` 就可以快速安装你的组件包了，而且用户也可以在安装时通过` i`参数来设置镜像源。可以参考[examples/maixcdk example](https://github.com/sipeed/MaixCDK/blob/main/examples/maixcdk example)组件。 * 文档：在[docs](./docs/)目录下包含了应用文档和 API 文档， API 文档是从代码自动生成的，不要手动修改，应用文档是具体功能的入门指导文档。 ## 代码风格 为了保持 MaixCDK 和 MaixPy API 的统一性，以及方便用户和开发者阅读，简单规范了以下代码风格： * **函数名**：全小写，单词之间用下划线隔开，比如`get_name`。 * **变量名**：全小写，单词之间用下划线隔开，比如`file_path`。 * **类名**：大驼峰，某些简单的缩写词可以全大写，比如 `Person`, `YOLOv2`, `UART`, `PWM`。 * **宏**：全大写，单词之间用下划线隔开，比如`MAIXPY_VERSION`。 * **类成员变量**：不用加`m_`前缀，全小写+下划线，比如`name`，这样方便`Python`里的`API`足够简洁。 * **类私有成员变量**：前面加`_`，比如`_name`。 * **使用类成员变量**：因为成员变量没有类似`m_`开头的明显标识，所以显示地使用`this >`，比如`this >name`，而不是`name`来提高可阅读性。 * **namespace**：所有`MaixCDK`官方的`API`都在`maix`命名空间下，`maix`下再有一个`namespace`用来区分不同的功能，可以是一个头文件一个`namespace`，也可以是一个目录一个`namespace`，比如比如`maix::thread`、`maix::peripheral`、`maix::nn`、`maix::peripheral::uart`等。 在生成`MaixPy` `API` 时，也会自动生成相应的模块，比如`maix.thread`、`maix.peripheral`、`maix.nn`、`maix.peripheral.uart`等。 * **源文件命名**：全小写，单词之间用下划线隔开，比如`maix_peripheral_uart.cpp`， `C++` 头文件使用`.hpp`后缀。 * **注释**：`API`的注释使用`doxygen`风格，参考[components/basic/include/maix_api_example.hpp](../../../components/basic/include/maix_api_example.hpp)中的使用方法。 * **API 注释文档**：一般需要写以下关键字 * **brief**: 一句话描述功能 * **param**: 参数说明，一定要详细说明参数的取值要求（比如取值范围），注意点，不能是简单的参数名称复读，那文档就没什么意义了，还不如不写。也可以加数据方向，比如`param[in] a`表示`a`是输入参数，`param[out] b`表示`b`是输出参数，`param[in,out] c`表示`c`是输入输出参数。 * **return**：返回值说明，一定要详细说明返回值的取值情况（比如取值范围），注意点，同样不能是简单的返回值名称复读。 * **retval**：出了使用`return`统一说明返回值，也可以用过过个这个关键字来阐述不同返回值的意义，比如`@retval 0 success`。 * **attention**： API 使用的注意点。 * **maixpy**：标识这是一个 `MaixPy` `API`，内容为在`MaixPy`中的包名+变量名，比如`maix.example`、`maix.example.hello`、`maix.example.Example.name`等。注意加了这个关键词不仅会生成`MaixPy` `API`和文档，如果没有同时指定`maixcdk`关键字，还会用这个名称生成`MaixCDK`的`API`文档 * **maixcdk**： 标识这是一个 `MaixCDK` `API`，如果同时存在`maixpy`关键字则优先使用这个作为`MaixCDK`的`API`名称。比如`* @maixcdk maix.example.hello_maixcdk`。 另外，对于本 SDK 中特殊的地方，比如为了能正确准确地生成 `MaixPy API`和文档，需要遵循： * **API 中的类型和默认值需要完整的定义，不省略**，`maix`明明空间可以省略，具体地： * **命名空间写全**， 比如`image::Image`，而不是`Image`。 * **枚举类型写全**，比如`image::Format::FMT_RGB888`，而不是`Format::FMT_RGB888`或者`image::FMT_RGB888`或者`FMT_RGB888`。 ## API 规范化建议 * 如果 MaixCDK 有的 API， 尽量使用，而不是直接使用第三方 API，方便不同平台移植，比如文件操作用`maix_fs.hpp`中的 API，而不是直接使用 C++ 的`fstream`。 * 打印日志使用`maix_log.hpp`中的`log::info` `log::debug`等 API， 这样在`release`版本中`debug`日志会被自动去掉，而且可以通过`maixcdk menuconfig`来设置日志级别。也方便不同平台移植。 * 错误代码使用`maix_err.hpp`中的`err::Err`，统一管理所有错误代码，方便用户查找错误原因。 * 抛出异常使用`maix_err.hpp`中的`err::Exception`，统一管理所有异常，方便用户查找错误原因， 并且**需要在 API 注释中说明可能抛出的异常和类型**。 * 对于多个模块有共性的 API，尽量有一个共同特性的基类，其它类继承并实现，比如`maix_peripheral_uart.hpp`中的`UART`继承`maix_comm.hpp`中的通信基类`CommBase`，这样方便 C++ 开发，也方便编写`MaixPy`的 API。 > 比如 `Display` 类，可以直接暴露给 MaixPy 作为 API，由于不同平台实现可能不同，定义一个`DisplayBase`基类，不同平台实现自己的`Display`类比如`SDL_Display`，然后在`Display`类里面统一调用`DisplayBase`的 API，这样就可以保证`MaixPy`的 API 通用性，用户只需要知道`Display`类，不需要知道下面用了什么具体的实现方法，提高移植性的同时用户使用也更加简单。"},"/maixcdk/doc/zh/convention/memcheck.html":{"title":"内存检查方法","content":"内存检查方法 ## 简介 使用valgrind工具检查内存泄露、内存越界等问题 ## 安装 ```shell sudo apt install valgrind ``` ## 使用valgrind ```shell cd examples/hello_world maixcdk build # 输出简要日志 valgrind ./build/hello_world # 输出更详细日志 # tool memcheck：指定工具为memcheck, memcheck是默认工具，该参数可以省略 # leak check full：详细的显示每个单独的内存泄露信息 # log file valgrind.log：将内存泄露检查结果输出到指定文件, valgrind.log为自定义的文件名 valgrind tool memcheck leak check full log file valgrind.log ./build/hello_world ``` ## 观察valgrind输出日志的方法 ### 观察内存泄露摘要信息 内存泄露时可以看到类似如下日志 ```shell LEAK SUMMARY: definitely lost: 48 bytes in 3 blocks. # 一定泄露的内存，例如一级指针指向的内存没有free indirectly lost: 32 bytes in 2 blocks. # 间接泄露的内存，例如二级指针指向的内存没有free，间接导致二级指针指向的一级指针指向的内存没有free possibly lost: 96 bytes in 6 blocks. still reachable: 64 bytes in 4 blocks. suppressed: 0 bytes in 0 blocks. ``` ### 观察内存异常详细信息 内存操作有多种异常，可以看到类似如下日志，详情见[官方文档](https://valgrind.org/docs/manual/mc manual.html)查看具体含义。 ```shell 8 bytes in 1 blocks are definitely lost in loss record 1 of 14 # 找到内存泄露的位置 at 0x........: malloc (vg_replace_malloc.c:...) by 0x........: mk (leak tree.c:11) by 0x........: main (leak tree.c:39) 88 (8 direct, 80 indirect) bytes in 1 blocks are definitely lost in loss record 13 of 14 at 0x........: malloc (vg_replace_malloc.c:...) by 0x........: mk (leak tree.c:11) by 0x........: main (leak tree.c:25) ``` ## 遇到无法解决的问题 见[官方文档](https://valgrind.org)"},"/maixcdk/doc/zh/convention/nn.html":{"title":"NN 规范","content":"# NN 规范 ## 神经网络模型文件 每个 AI 模型都使用 `.mud` 文件进行描述，这是一种 INI 格式的文件。 MUD（Model Universal Description，模型通用描述）文件是一种简单的模型描述格式。 > 创建这个文件的原因在于，各种硬件平台的模型格式不同，无法直接加载，我们需要编写多种不同的代码来加载模型。而现在使用 MUD 文件，只需在其中写入模型信息，即可简化模型加载过程。 MUD 文件定义如下： ```ini [basic] type cvimodel model model_path_relative_to_mud_file [extra] model_type classifier input_type bgr mean 103.94, 116.78, 123.68 scale 0.017, 0.017, 0.017 labels labels.txt ``` `basic` 部分是必需的，`extra` 部分是可选的。 * `basic` 部分描述了模型的类型和模型路径。 * `type` 表示模型类型，目前支持 `MaixCam` 的 `cvimodel` 类型。 * `model` 表示模型的相对路径，相对于 MUD 文件所在位置。 * `extra` 部分描述了模型的额外信息，应用程序可以通过 `model.extra_info()` 方法获取。 * `model_type` 表示模型的功能类型，如 `classifier`（分类器）和 `yolov2`（目标检测），此项为可选。 * `input_type` 表示模型的输入类型，如 `bgr` 和 `gray`（灰度图），此项为可选。 * `mean` 表示模型输入的均值，此项为可选。 * `scale` 表示模型输入的缩放比例，此项为可选。 * `labels` 表示模型标签文件的路径，此项为可选。 ## 当前 MaixCDK 支持的模型类型： * `classifier` * `classifier_no_top` * `yolo11` * `yolov8` * `yolov5` * `pp_ocr` * `retinaface` * `nanotrack` * `face_detector` * `speech` * 以及更多类型，详情请参考 [components/nn/include](https://github.com/sipeed/MaixCDK/tree/main/components/nn/include) 源代码，并搜索 `model_type` 关键字查看 `load` 方法。"},"/maixcdk/doc/zh/convention/protocol.html":{"title":"Maix communicate Protocol","content":" title: Maix communicate Protocol update: date: 2023 11 28 author: neucrack version: 1.0.0 content: 设计并编写协议文档和代码 API 实现 ## Maix 串口协议简介 运行 MaixCDK 或者 MaixPy 的设备， 除了可以直接使用设备上的触摸屏和按键操作外， 还可以作为模块，可以使用 `UART`（串口） 或者 `I2C` 进行通信控制。 > 因为 I2C 为主从模式，所以协议都采用问答模式，一问一答，即`Request`+`Response` > 对于 UART 协议， 部分功能支持配置主动上报，具体请看协议 后文会详细阐述通信协议内容。 ## Maix 设备端如何使用 开机进入 `设置` 应用，在 `通信` 设置里面选择通信接口，有： * **串口**：选择后会使用串口进行通信，串口根据板子决定，波特率默认为`115200`。 * **TCP**：选择后 Maix 设备会启动一个 TCP 服务，主控端可以通过 TCP 连接 Maix 设备，端口默认为`5555`。 然后主控连接上 Maix 设备后，就可以通过协议进行通信了， 主控作为主设备， Maix 设备作为从设备。 **Maix 设备端开发**： 用提供的`maix.comm.CommProtocol`类可以很方便实现命令响应，具体参考例程 [comm_protocol](../../../examples/protocol_demo)（C++）或者 [comm_protocol.py](https://github.com/sipeed/MaixPy/blob/main/examples/protocol)（MaixPy）。 **主控端开发**： 主控端根据芯片和开发语言可自行实现协议，在文末附录中有提供模板代码。 ## 数据帧 header(4B LE) data len(4B LE)(flags+cmd+body+crc) flags(1B) cmd(1B) body(nB) CRC16_IBM(2B LE)(前面所有) 十进制示例 3148663466 9 0 1 hello 17451 十六进制示例 0xBBACCAAA 0x00000009 0x00 0x01 hello 0x442B 字节流(十六进制) AA CA AC BB 09 00 00 00 00 01 68 65 6c 6c 6F 2B 44 > **注意**这里超过一个字节的数据均采用小端(LE)编码，比如这里 `data_len` 为 `0x00000006`，`06`在最低位，发送时需要先发送`0x06`再发送`0x00` `0x00` `0x00`。 > 字符串就按照顺序发即可，比如`hello`，先发`h`再发`e` `l` `l` `o`。 > 这里的例子，最终发送数据： `AA CA AC BB 09 00 00 00 00 01 68 65 6c 6c 6F 2B 44`。 * `header`: 头，4 字节，用来标识一帧的开始，固定为 4 字节 `0xAA 0xCA 0xAC 0xBB`, 先发`0xAA` * `data len`: 数据长度， 4 字节， 包含了 `flags` `cmd` + `body` + `CRC` 的长度。 * `flags`: 一个字节，各个位分别表示： * 最高位 `is_resp`: 是否是响应，`0`代表发送请求，`1`代表 响应 或者 主动上报（第三高位需要置`1`）。 * 第二高位 `resp_ok`: * 对于请求，保留位。 * 对于响应，`1`表示成功，`0`表示失败。 * 第三高位 `is_report`： * 对于请求，保留位。 * 对于响应，`1`表示主动上报，`0`表示为响应消息。 * 第 4~6 高位： 保留以后使用。 * 低 2位 `version`: 协议版本，以后修改不兼容的协议才会更改这个版本号，如果修改协议后与当前版本协议兼容则这个版本号不需要升级。目前的版本为 `1`。 * `cmd`: 基本命令类型，1 字节，已经预先定义了几个命令，看后文[命令定义](#命令定义)，这些预定义命令的值从 255 逐渐递减，APP 自定义的命令可以从 `0 ~ maix.protocol.CMD.CMD_APP_MAX`。 * `body`: 内容，变长, 长度只要 `< (2^32 1)` 即可，不同的命令对应不同的`body`，在后面会对每个命令进行详细说明 * `crc16`: CRC 校验值，2 字节， 用以校验帧数据在传输过程中是否出错，使用 `CRC IBM` 方法计算，可以参见[C 代码实现](#C CRC16)，或者 [Python CRC16](#Python CRC16)。和`data_len`同样两个字节小端存放，传输时先传输低位再传输高位。 编解码的代码见[附录：代码](#附录：代码) ## 请求和响应 ### 发送方主动请求 数据方向为： 单片机或其它主控设备 > Maix 设备 `flags`最高位`is_resp`设置为`0`， `body` 内容由`cmd`决定; ### 接收方响应 数据方向为： Maix 设备 > 单片机或其它主控设备 `flags`最高位`is_resp`设置为`1`。 * 对于成功响应：`resp_ok` 设置为 `1`, `body` 内容由`cmd`决定, 其中最简单的成功响应即 `body` 为空。 * 对是失败响应： * `resp_ok`设置为 `0`。 * `body` 第一个字节为错误码, 具体的错误码见[MaixCDK maix.err.Err](../../../components/basic/include/maix_err.hpp)。 * `body` 后面的字节为错误字符串信息，`UTF 8` 编码，一般情况下建议用纯英文，提高兼容性。 每个请求均应有对应的响应，即执行成功或者失败，后文均用`RESP_OK`和`RESP_ERR`来代替执行成功和失败两种响应。 `RESP_OK`的 `body` 字节不说明就是没有，有会单独进行说明。 ### 主动上报数据 数据方向为： Maix 设备 > 单片机或其它主控设备 需要主控先通过`CMD_SET_REPORT`命令设置需要主动上报的数据（需要对应的命令支持） > 比如 APP 支持 `CMD_GET_TEMP` 命令获取温度，主控可以通过 `CMD_SET_REPORT` 命令设置主动定时上报温度，然后 APP 收到这个命令后，就会定时上报温度，如果 APP 不支持设置`CMD_GET_TEMP`命令的主动上报，则会响应`CMD_ERROR`。 `flags`最高位`is_resp`设置为`1`，第三位`is_report` 设置为 `1`，`body` 内容由`cmd`决定。 ## 实例 举例： 单片机与 Maix 设备通过串口连接，默认使用`115200`波特率。 单片机向 Maix 设备请求获取 应用列表，步骤： 1. 根据下方的协议说明，单片机通过串口发送`cmd`为`0xF9`的请求，即`CMD_APP_LIST`，`body`为空。实际字节流： `AA CA AC BB 04 00 00 00 01 F9 C9 77`。 2. Maix 设备收到请求后，返回`cmd`为`0xF9`, `flags`为`0x01 0x80 0x40 > 0xC1`的响应（响应`flags`最高为`1`所以有`0x80`, 成功响应第二高位为`1`所以有`0x40`），`body`内容为应用列表，具体内容见下方协议说明。假如有两个 APP,实际字节流： `AA CA AC BB 0A 00 00 00 C1 F9 02 66 61 63 65 00 66 61 63 65 00 F6 06`。 ## 命令定义和系统命令 协议帧中的`cmd`取值如下： 命令名 值 含义 CMD_APP_MAX 0xC8 应用可自定义命令最大值（不含） CMD_SET_REPORT 0xF8 设置主动上报 CMD_APP_LIST 0xF9 应用列表查询 CMD_START_APP 0xFA 启动应用 CMD_EXIT_APP 0xFB 退出应用 CMD_CUR_APP_INFO 0xFC 当前应用信息查询 CMD_APP_INFO 0xFD 应用信息查询 CMD_KEY 0xFE 按键模拟消息 CMD_TOUCH 0xFF 触摸模拟消息 这里指定的命令都是系统命令，每个应用可以根据自身的功能特性自定义命令。 比如 在`相机`应用中，我们可以自定义`0x01`为拍照命令, `0x02`为闪光灯设置；在`分类器`应用中，我们自定义`0x01`为识别物体命令； 也就是说`应用命令`制定应该遵循： * 对于每个应用来说命令都是独立的，当进入了一个应用，就要遵循应用制定的命令规则。比如一个应用使用了 `0x01` 命令， 另一个仍然可以用`0x01`。 * 任何 APP 自定义的命令都应该在`0 ~ CMD_APP_MAX`之间，包含`0`，不包含`CMD_APP_MAX`，保留系统命令。 * 应该在应用使用说明文档中详细说明每个命令的定义和作用。 不同的`cmd`对应不同的请求和响应数据， 以及不同的`body`，详细协议（主要阐述`cmd`和`body`）如下： ### CMD_SET_REPORT 开启或关闭命令主动上报。 主动上报包括： 1. 有事件时主动上报，比如检测到人脸时主动上报人脸信息。 2. 定时上报，比如每隔 5s 上报一次温度。 如果定时上报和事件上报同时开启，则事件上报后，定时器重新计时。 #### 请求 `body`： cmd(1B) on_off(1B) event(1B) timer(4B) 解释 需要开启主动上报的命令 开关(1 开， 0 关) 事件上报（1 开， 0 关） 定时上报，单位 ms，不需要定时则设置为 0 例子 0x02 0x01 5000 #### 响应 如果相应的命令支持主动上报，则响应`RESP_OK`，否则响应`RESP_ERR`，均由应用自行决定。 `body`： 无 ### CMD_APP_LIST 获取应用列表 #### 请求 `body` 为空 #### 响应 `body`: number(1B) app1 ... app n info 解释 应用数量 id1 + '\\0'结尾的字符串 ... idn 例子 0x02 'face\\0' ... 'appn\\0' ### CMD_CUR_APP_INFO 获取当前应用信息 #### 请求 `body` 为空 #### 响应 `body`: idx(1B) app info(id + name + brief) 解释 应用序号 应用信息（id， 名字(UTF 8 编码)，简介（UTF 8 编码）） 例子 0x00 'face\\0face\\0face detect\\0' ### CMD_APP_INFO 获取指定应用信息 #### 请求 `body` ： idx(1B) app_id(nB) 解释 应用序号 应用 ID 例子 0x02 'face' `idx` 和 `app_id` 二选一即可 * `idx`: 应用序号（从0开始），设置为 0xFF 表示不设置 * `app_id`: 应用 ID，如果 idx 设置了，可以不用设置 #### 响应 `body`: idx(1B) app info(id + name + brief) 解释 应用序号 应用信息（id， 名字(UTF 8 编码)，简介（UTF 8 编码）） 例子 0x00 'face\\0face\\0face detect\\0' ### CMD_START_APP 请求启动指定应用，执行此命令会退出当前应用，然后启动指定应用。 * 如果是 APP 收到这个命令，则它需要调用 API `maix.app.switch_app` 切换 APP。 > 这里存在一个风险，就是如果 APP 没有正确实现响应这个命令，则可以敦促开发者实现这个命令。 * 如果时 Launcher 收到这个命令后会启动对应的应用。 #### 请求 `body`： idx(1B) app_id(nB) app_func(nB) 解释 应用序号（从0开始），设置为 0xFF 表示不设置 应用 ID，如果 idx 设置了，可以不用设置 该应用存在多个功能时用于指定应用启动时执行的功能 例子 0x02 'scan' 'qrcode' `idx` 、 `app_id` 和 `app_func` 三个参数如何使用： * 不带参数启动应用: 单独设置 `idx` 或者 `app_id` * 带参数启动应用: > `idx` + `app_func`，设置 `idx` 后，解释器会将后续的第一个字符串视为 `app_func`，如果有多个字符串将会返回错误。 > `app_id` + `app_func`，不设置 `idx`，解释器会在后续字符串中查找 `app_id` 和 `app_func`，不符合条件将会返回错误。 #### 响应 `body`: 无 ### CMD_EXIT_APP 请求退出当前应用 #### 请求 无 `body` #### 响应 `body`: 无 ### CMD_KEY 发送模拟按键请求 #### 请求 `body`： key(4B) value(1B) 键值(小端) 取值：0x01(/0x00/0x02) * `key`: 键值，4 字节，发送时需要按小端编码，比如`0x00000001` 发送时的字节流为`0x01 0x00 0x00 0x00`，支持的取值为： * 38: \"up\" * 40: \"down\" * 37: \"left\" * 39: \"right\" * 108: \"enter\" * 27: \"esc\" * 0x01010101: \"ok\" * 0x02020202: \"ret\" * 0x03030303: \"pre\" * 0x04040404: \"next\" * `value`: 按键值， 1 字节 * 0x01: 按下 * 0x00: 释放 * 0x02: 长按 #### 响应 `body`: 无 ### CMD_TOUCH 发送模拟触摸请求 #### 请求 `body`： x y event(1B) x 坐标 y 坐标 事件 event 取值： * 0x00: 按下 * 0x01: 抬起 * 0x02: 移动 #### 响应 `body`：无 ## 应用（APPS）协议说明 这里使用几个应用举例，**注意不一定为应用真实命令规范**，具体请看对应的**应用说明文档**。 如果应用支持 Maix 通信协议，一般会在说明文档中说明命令规范，没有说明可以认为没有，不过一般也仍然可以使用系统指令。 应用说明文档一般在： * [MaixHub应用中心](https://maixhub.com/app)，直接找到对应应用查看主页即可。 * 源码仓库： * 网友开源的： 可以在对应的开源仓库看到。 * 官方开源的基于 MaixCDK 的应用：在[MaixCDK/projects](https://github.com/sipeed/MaixCDK/tree/main/projects) 对应目录可以看到。 * 官方开源的基于 MaixPy 的应用：在[MaixPy/projects](https://github.com/sipeed/MaixPy/tree/main/projects) 对应目录可以看到。 ### 相机 命令: 命令 取值 含义 响应 CMD_SNAP 0x01 拍照 ### 分类器 **注意只是举例**，真实协议请看对应[应用](https://github.com/sipeed/MaixCDK/tree/main/projects/app_camera) 介绍。 `body`说明： 请求只有一个字节， 代表了命令， 具体如下表： 命令 取值 含义 响应 CMD_RECOGNIZE 0x01 识别物体 CMD_APP_CMD 响应： * 命令 `CMD_RECOGNIZE` 的响应： 响应 `cmd`为 `CMD_APP_CMD`, `body`: CMD_RECOGNIZE id(2B uint16 LE) prob(4B float LE) name CMD_RECOGNIZE 值 识别到的 id（下标），小端 概率， 浮点型， 小端 名字， UTF 8 编码 ### 人脸和人脸关键点检测 **注意只是举例**，真实协议请看对应[应用](https://github.com/sipeed/MaixPy/tree/main/projects/app_face_landmarks) 介绍。 `body`说明： 请求只有一个字节， 代表了命令， 具体如下表： 命令 取值 含义 响应 CMD_POS 0x01 检测人脸 CMD_APP_CMD 响应： * 命令 `CMD_POS` 的响应： 响应 `cmd`为 `CMD_APP_CMD`, `body`: CMD_POS face num(2B LE) prob(4B float LE) x(2B LE) y(2B LE) w(2B LE) h(2B LE) ... CMD_POS 值 检测到的人脸数量 概率， 浮点型， 小端 人脸框左上角横坐标 人脸框左上角纵坐标 人脸框宽 人脸框高 剩下的人脸... ### 人脸识别 **注意只是举例**，真实协议请看对应[应用](https://github.com/sipeed/MaixPy/tree/main/projects/app_face_recognizer) 介绍。 `body`说明： 请求只有一个字节， 代表了命令， 具体如下表： 命令 取值 含义 响应 CMD_FACES 0x01 识别人脸 CMD_APP_CMD CMD_USERS 0x02 查询所有用户 CMD_APP_CMD CMD_RECORD 0x03 录入人脸 CMD_APP_CMD CMD_REMOVE 0x04 删除人脸 CMD_APP_CMD 请求 `CMD_APP_CMD`加一个字节的`app_cmd`，个别命令有额外的参数，如下： * 命令 `CMD_RECORD` 的请求 CMD_RECORD user name CMD_RECORD 值 录制的用户名 * 命令 `CMD_REMOVE` 的请求 CMD_REMOVE user idx(2B int16) user name CMD_REMOVE 值 用户下标， 两字节，小端 要删除的用户名 下标和用户名二选一 响应： * 命令 `CMD_FACES` 的响应： 响应 `cmd`为 `CMD_APP_CMD`, `body`: CMD_FACES face num(2B LE) id(2B) name_len(1B) name prob(4B float LE) x(2B LE) y(2B LE) w(2B LE) h(2B LE) ... CMD_FACES 值 检测到的人脸数量 人脸 ID（下标） 名字长度 名字， UTF 8 编码 概率， 浮点型， 小端 人脸框左上角横坐标 人脸框左上角纵坐标 人脸框宽 人脸框高 剩下的人脸... * 命令 `CMD_USERS` 的响应： 响应 `cmd`为 `CMD_APP_CMD`, `body`: CMD_USERS user num(2B LE) name_len(1B) name ... CMD_USERS 值 用户数量 用户名长度 名字， UTF 8 编码 剩下的用户名... * 命令 `CMD_RECORD` 的响应： `CMD_OK` 或者 `CMD_ERROR` * 命令 `CMD_REMOVE` 的响应： `CMD_OK` 或者 `CMD_ERROR` ## MaixPy 中使用 Maix 通信协议 MaixPy 中已经将协议的解析和发送封装在`maix.comm.protocol` 和 `maix.comm.CommProtocol` 中了，使用起来很方便。 请看[MaixPy 文档](https://wiki.sipeed.com/maixpy/doc/zh/comm/maix_protocol.html) 进行详细了解。 ## MaixCDK 中使用 Maix 通信协议 建议先看上面的 MaixPy 使用文档，在 MaixPy 中成功使用后再尝试 MaixCDK，用法一致。 注意如果你的应用没有使用`maix::comm::CommProtocol` 进行自定义命令，建议在程序开头调用一下 ```c++ maix::comm::add_default_comm_listener(); ``` 这个函数会自动开一个线程监听系统指令，这样你的应用就支持系统指令了比如通过串口启动和退出你的应用。 ## 附录：方便移植到其它主控的代码 如果你不是在 MaixCDK / MaixPy 中使用协议时，比如 MaixCAM 外接了一个 STM32 来进行通信，下面的代码方便你快速移植到 STM32 等其它设备。 ### 参考 MaixCDK 源码 MaixCDK 开源了 Maix 通信协议的代码，可以参考: * [maix_protocol.hpp](https://github.com/sipeed/MaixCDK/blob/main/components/basic/include/maix_protocol.hpp) * [maix_protocol.cpp](https://github.com/sipeed/MaixCDK/blob/main/components/basic/src/maix_protocol.cpp) 可以关注 `encode` 和 `get_msg` 函数，根据你的平台进行移植。 ### C CRC16 IBM ```c unsigned short crc16_IBM(unsigned char *ptr, int len) { unsigned int i; unsigned short crc 0x0000; while(len ) { crc ^ *ptr++; for (i 0; i < 8; ++i) { if (crc & 1) crc (crc >> 1) ^ 0xA001; else crc (crc >> 1); } } return crc; } ``` 或者查表法： ```c const unsigned int crc16_table[256] { 0x0000, 0xc0c1, 0xc181, 0x0140, 0xc301, 0x03c0, 0x0280, 0xc241, 0xc601, 0x06c0, 0x0780, 0xc741, 0x0500, 0xc5c1, 0xc481, 0x0440, 0xcc01, 0x0cc0, 0x0d80, 0xcd41, 0x0f00, 0xcfc1, 0xce81, 0x0e40, 0x0a00, 0xcac1, 0xcb81, 0x0b40, 0xc901, 0x09c0, 0x0880, 0xc841, 0xd801, 0x18c0, 0x1980, 0xd941, 0x1b00, 0xdbc1, 0xda81, 0x1a40, 0x1e00, 0xdec1, 0xdf81, 0x1f40, 0xdd01, 0x1dc0, 0x1c80, 0xdc41, 0x1400, 0xd4c1, 0xd581, 0x1540, 0xd701, 0x17c0, 0x1680, 0xd641, 0xd201, 0x12c0, 0x1380, 0xd341, 0x1100, 0xd1c1, 0xd081, 0x1040, 0xf001, 0x30c0, 0x3180, 0xf141, 0x3300, 0xf3c1, 0xf281, 0x3240, 0x3600, 0xf6c1, 0xf781, 0x3740, 0xf501, 0x35c0, 0x3480, 0xf441, 0x3c00, 0xfcc1, 0xfd81, 0x3d40, 0xff01, 0x3fc0, 0x3e80, 0xfe41, 0xfa01, 0x3ac0, 0x3b80, 0xfb41, 0x3900, 0xf9c1, 0xf881, 0x3840, 0x2800, 0xe8c1, 0xe981, 0x2940, 0xeb01, 0x2bc0, 0x2a80, 0xea41, 0xee01, 0x2ec0, 0x2f80, 0xef41, 0x2d00, 0xedc1, 0xec81, 0x2c40, 0xe401, 0x24c0, 0x2580, 0xe541, 0x2700, 0xe7c1, 0xe681, 0x2640, 0x2200, 0xe2c1, 0xe381, 0x2340, 0xe101, 0x21c0, 0x2080, 0xe041, 0xa001, 0x60c0, 0x6180, 0xa141, 0x6300, 0xa3c1, 0xa281, 0x6240, 0x6600, 0xa6c1, 0xa781, 0x6740, 0xa501, 0x65c0, 0x6480, 0xa441, 0x6c00, 0xacc1, 0xad81, 0x6d40, 0xaf01, 0x6fc0, 0x6e80, 0xae41, 0xaa01, 0x6ac0, 0x6b80, 0xab41, 0x6900, 0xa9c1, 0xa881, 0x6840, 0x7800, 0xb8c1, 0xb981, 0x7940, 0xbb01, 0x7bc0, 0x7a80, 0xba41, 0xbe01, 0x7ec0, 0x7f80, 0xbf41, 0x7d00, 0xbdc1, 0xbc81, 0x7c40, 0xb401, 0x74c0, 0x7580, 0xb541, 0x7700, 0xb7c1, 0xb681, 0x7640, 0x7200, 0xb2c1, 0xb381, 0x7340, 0xb101, 0x71c0, 0x7080, 0xb041, 0x5000, 0x90c1, 0x9181, 0x5140, 0x9301, 0x53c0, 0x5280, 0x9241, 0x9601, 0x56c0, 0x5780, 0x9741, 0x5500, 0x95c1, 0x9481, 0x5440, 0x9c01, 0x5cc0, 0x5d80, 0x9d41, 0x5f00, 0x9fc1, 0x9e81, 0x5e40, 0x5a00, 0x9ac1, 0x9b81, 0x5b40, 0x9901, 0x59c0, 0x5880, 0x9841, 0x8801, 0x48c0, 0x4980, 0x8941, 0x4b00, 0x8bc1, 0x8a81, 0x4a40, 0x4e00, 0x8ec1, 0x8f81, 0x4f40, 0x8d01, 0x4dc0, 0x4c80, 0x8c41, 0x4400, 0x84c1, 0x8581, 0x4540, 0x8701, 0x47c0, 0x4680, 0x8641, 0x8201, 0x42c0, 0x4380, 0x8341, 0x4100, 0x81c1, 0x8081, 0x4040, }; unsigned short crc16_IBM(const unsigned char *ptr,int len) { unsigned short crc 0x0000; while(len ) { crc (crc >> 8) ^ crc16_table[(crc ^ *ptr++) & 0xff]; } return (crc); } ```"},"/maixcdk/doc/zh/convention/app.html":{"title":"MaixCDK 应用框架指南","content":"MaixCDK 应用框架指南 ## 简介 用户使用步骤： * 设备启动时会自动启动 `launcher`。 * 用户选择一个 APP 启动。 * 运行选中的 APP。 * 用户与 APP 交互。 * 用户退出 APP。 * `launcher` 会再次启动并等待用户选择 APP。 用户安装新的 APP： * 确保设备已连接到互联网（可以在 `app_settings` APP 中连接 WiFi）。 * 打开 [maixhub.com/app](https://maixhub.com/app) 查找 APP，点击“下载”按钮，会显示一个二维码和安装码。 * 在设备上打开 `app_store` APP，使用摄像头扫描二维码，或输入安装码来安装 APP。 * 返回 `launcher`，新安装的 APP 会显示在列表中。 ## 打包 APP 如果使用 `MaixCDK`： * 在项目文件夹中创建一个 `app.yaml`，格式见下文。 * 执行 `maixcdk release P maixcam` 来为 `maixcam` 平台打包 APP。 * 在 `dist` 文件夹中会找到一个 `app_store_v1.0.0.zip`，这是打包好的 APP 文件。 * 你可以将这个包上传到 [maixhub.com/app](https://maixhub.com/app) 与他人分享。 * 或者执行 `maixcdk deploy P maixcam` 来启动本地服务器，并显示一个二维码。 * 你也可以将这个文件上传到设备，并执行 `app_store install app_path.zip` 来通过命令安装。 如果使用 `MaixPy`，你可以使用 `MaixVision Workstation` 打包 APP，或手动使用 `maixtool`： * 在项目文件夹中创建一个 `app.yaml` 文件，格式见下文。 * 创建一个 `main.py` 文件，这是 APP 的入口。 * 在此文件夹中执行 `maixtool release`，将生成 `dist/app_id_vx.x.x.zip`。 * 你可以将这个包上传到 [maixhub.com/app](https://maixhub.com/app) 与他人分享。 * 或者执行 `maixtool deploy` 来启动本地服务器，并显示一个二维码。 `app.yaml` 格式： ```yaml id: my_app # 唯一 ID，使用小写字母并用下划线分隔单词 name: My APP name[zh]: 我的应用 # 中文名称 version: 1.0.0 # 版本号，格式为 major.minor.patch icon: assets/my_app.png # 图标文件，可以是 png 或 lottie json 文件，或为空 author: Sipeed Ltd desc: My APP description desc[zh]: 我的应用描述 #### 包含文件方法 1： # 默认情况下，会包含项目目录中的所有文件，除了排除文件 exclude: # 不支持正则表达式，.git 和 __pycache__ 总是会被排除 .vscode compile build dist # extra_include: # src: dst # build/filename123: filename123 #### 包含文件方法 2： # 白名单模式，只包含 files 字典中的文件。 # 如果没有此键或值为空，将使用方法 1。 # files: # assets # hello.py # main.py #### 包含文件方法 2.1： # 白名单模式，只包含 files 字典中的文件。 # 如果没有此键或值为空，将使用方法 1。 # files: # assets: assets ``` `exclude` 为黑名单模式，`files` 为白名单模式，你可以选择其中一种方式。 ## 文件约定 * 所有应用数据存储在 `/maixapp`。 * 应用存储在 `/maixapp/apps`。 * `/maixapp/apps/app.info` 为描述已安装应用的 INI 文件。安装和卸载应用会更新此文件。 > 开发者或用户也可以手动复制应用目录到此，并执行 `python gen_app_info.py` 生成 `app.info` 文件。 * 应用存放在 `/maixapp/apps/app_id` 文件夹中，每个应用必须包含 `app_id` 可执行文件，或 `main.sh` 脚本，或 `main.py` 脚本。 * 启动应用时，launcher 会在 `app_id` 文件夹中寻找：`main.sh` > `main.py` > `app_id` 文件。`main.sh` 使用 `sh` 执行，`main.py` 使用 `python3` 执行，`app_id` 直接执行。 * 共享数据存储在 `/maixapp/share`。 * 图片文件存储在 `/maixapp/share/picture`。 * 视频文件存储在 `/maixapp/share/video`。 * 临时数据可以存储在 `/maixapp/tmp`，注意，和 Linux 本身的`/tmp` 目录不同的是这个目录是在文件系统（SD卡）上的，系统`/tmp`是在内存上虚拟的文件系统，`/tmp`读写速度更快但是内存大小受限，大文件以及需要长期记录的日志文件（随着时间推移可能变得比较大）建议放在`/maixapp/tmp`目录下。 * 字体文件存储在 `/maixapp/share/font`。 * 图标文件存储在 `/maixapp/share/icon`。 * 应用运行时创建的数据文件可以存储在 `/maixapp/apps/app_id/data`。 * **所有路径都可以通过 API `maix.app.get_xxx_path` 获取，更多详情请参考 API 文档或 [maix_app.hpp](https://github.com/sipeed/MaixCDK/blob/main/components/basic/include/maix_app.hpp) 文件。** ## 切换应用 使用 `void maix::app::switch_app(const string &app_id, int idx 1, const std::string &start_param \"\")` 函数来切换应用。 这将退出当前应用并启动另一个应用，并将 `start_param` 字符串传递给目标应用，目标应用可以通过 `maix::app::get_start_param()` 获取此参数。"},"/maixcdk/doc/zh/faq.html":{"title":"MaixCDK FAQ","content":"MaixCDK FAQ You can also find FAQ from: * [MaixPy FAQ](https://wiki.sipeed.com/maixpy/doc/en/faq.html) * [MaixCAM FAQ](https://wiki.sipeed.com/hardware/zh/maixcam/faq.html) * [MaixPy 源码 FAQ](https://wiki.sipeed.com/maixpy/doc/zh/source_code/faq.html) ## 常见编译错误的通用解决方法 * **提示解压失败等错误**: 可以尝试删除掉`dl/pkgs`和`dl/extracted`目录下的对应文件让重新编译下载即可。 * **编译报错**： * 执行`maixcdk build verbose` 查看哪里报错，**仔细看报错日志**一步一步探寻问题。 * 执行 `maixcdk distclean` 清理临时文件后重新编译。 * 到[github 提交记录](https://github.com/sipeed/MaixCDK/commits/main/)处看到每个提交的自动测试是否通过（绿色的勾勾✅就是通过，红色叉叉❌就是失败），可以将本地代码切换到测试通过的提交✅再编译（本地执行`git checkout 提交号`比如`git checkout 3aba2fe3fa9de9f638bb9cb34eca0c2e0f5f3813`， 如果切换失败请自行搜索 git 用法或者直接从头来过，注意备份自己修改的代码）。 ## Downloading ippicv_2021.8_lnx_intel64_20230330_general.tgz takes a long time or fail Manually download according to the log's url, and put it into: `MaixCDK > components > opencv > opencv4 > .cache > ippicv` The file name is `43219bdc7e3805adcbe3a1e2f1f3ef3b ippicv_2021.8_lnx_intel64_20230330_general.tgz`, File name and url can also be found in `MaixCDK/components/3rd_party/opencv/opencv4/3rdparty/ippicv/ippicv.cmake` So the same as `ade` cache file `.cache/ade/4f93a0844dfc463c617d83b09011819a v0.1.2b.zip` ## Exception: parse_api_from_header **.hpp error: 'members' API comment not complete. e.g. ```cpp /** * Class for communication protocol */ class CommProtocol { /** * Read data to buffer, and try to decode it as maix.protocol.MSG object * @return decoded data, if nullptr, means no valid frame found. * Attentioin, delete it after use in C++. * @maixpy maix.comm.CommProtocol.get_msg */ protocol::MSG *get_msg(); } ``` Here `class CommProtocol` not add `@maixpy maix.comm.CommProtocol` but its method `get_msg` add it. So we add `@maixpy maix.comm.CommProtocol` to `class CommProtocol` comment will fix this error. ## 使用WSL编译OpenSSL时出错的修复方法 当我在工程中使用openssl时： ![a0cee88e7a7a747c2d34eadb31a925bd](https://github.com/user attachments/assets/7de123b5 aae6 4a92 8d88 9d9a7a57f419) 编译报错： ![3b42197634ee4cd6a7b0462636e8dd34](https://github.com/user attachments/assets/5ffe5433 ac0f 4096 8374 5d76c43ed320) 用verbose查看命令发现， Path里是包含“（”的，这是windows的Path将WSL的path污染了。 参照网上的方法，在WSL中： ``` sudo nano /etc/wsl.conf ``` 如果没有则新建，内容如下： ```conf [interop] appendWindowsPath false ``` 重启WSL后， Path干净了。 ![9a86a628630209725d362f07b51ecb9a](https://github.com/user attachments/assets/af7f11d2 9bef 4df1 aeeb 0388dce18241) 编译openssl也成功了。 ![d6e43b3bf8e5c68d9966636464b08a43](https://github.com/user attachments/assets/c41eaa03 f1d8 49b9 bc27 88c63ee4cf4f)"},"/maixcdk/doc/zh/dev/vscode_debug.html":{"title":"使用 VSCode 在线调试","content":" title: 使用 VSCode 在线调试 ## 调试 这里主要提供 vscode + gdb 的调试方法，看不太懂可以先跳过，可以先使用代码加`printf`打印的方式调试。 **(1).** 对于在本机（PC）运行，VSCode + GDB 在线调试 这里以 PC 为 Linux 系统为例： * 添加 MaixCDK（第一次试用推荐这样） 或者 工程目录到 VSCode 工作区 * 拷贝 [tools/vscode/vscode_local_debug/.vscode](../../../tools/vscode/vscode_local_debug/.vscode) 目录到上一步的工作目录下 * 根据`.vscode`是在 MaixCDK 还是在工程目录下，修改`.vscode/launch.json`中的`cwd`字段 * 按键盘 `F5` 即可开始调试 > windows 也类似，修改`.vscode`里面的相关命令和路径即可 **(2).** 对于在嵌入式设备（/远程设备，带 Linux 系统）调试 使用 VSCode + gdbserver 在嵌入式设备（/远程设备，带 Linux 系统）调试 这里以 PC 为 Linux 系统为例： * 先保证远程设备有`gdbserver`这个程序，以及 PC 有`gdb multiarch`这个程序 * 将 [tools/vscode/vscode_remote_debug/.vscode](../../../tools/vscode/vscode_remote_debug/.vscode) 目录拷贝到工程目录下 * 编辑 `launch.json` 和 `build_run_gdbserver.sh` 文件，修改里面的路径和命令，以及用户名等。 > 建议先将 PC 的 ssh key 加入到远程设备的 `~/.ssh/authorized_keys` 文件中，这样就不需要输入密码了。 * 每次调试需要执行 `build_run_gdbserver.sh` 脚本，然后在 VSCode 中按 `F5` 即可开始调试 > 脚本会编译工程，然后拷贝可执行文件到远程设备，并且启动 `gdbserver`。 > 按 F5 启动调试时， VSCode 使用 GDB 连接到远程设备的`gdbserver`以调试。"},"/maixcdk/doc/zh/dev/comm_protocol_internal.html":{"title":"Maix 串口协议内部实现规范","content":" title: Maix 串口协议内部实现规范 ## 串口协议内部实现规范 Maix Comm Protocol 内部根据系统设置的通信方式（比如 uart），构建一个 UART 对象使用，并且调用 uart 的 register_comm_callback(obj, callback)（obj是一个UART对象指针）, 用户需要使用串口时构建UART对象构造函数会先检查是否已经注册过（比如判断已经注册过的obj使用的UART编号和即将初始化的UART编号是否相同）， 如果没有注册过就普通构造，已经注册过那就先回调设置的callback函数,callback 负责释放obj（注意 uart 里面 callback后UART不要再使用register_comm_callback传进来的obj了），然后再构造。"},"/maixcdk/doc/zh/no_translate.html":{"title":"no_translate_title","content":" title: no_translate_title class: md_page <div id \"visit_from\"></div> <div id \"no_translate_hint\">no_translate_hint</div> <div> <span id \"visit_hint\">visit_hint</span> <a id \"translate_src\"></a> </div> <div> <script> function getQueryVariable(variable) { var query window.location.search.substring(1); var vars query.split(\"&\"); for (var i 0;i<vars.length;i++) { var pair vars[i].split(\" \"); if(pair[0] variable){return pair[1];} } return(false); } var ref getQueryVariable(\"ref\"); var from getQueryVariable(\"from\"); var link document.getElementById(\"translate_src\"); var fromDis document.getElementById(\"visit_from\"); link.href ref; link.text ref; fromDis.innerHTML from; </script> </div>"}}