<!DOCTYPE html>

<html lang="en"  class="">


<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <meta name="keywords" content="">
    
    
    <meta name="description" content="">
    
    <meta name="generator" content="teedoc">
    <meta name="theme" content="teedoc-plugin-theme-default">
    
        
        <meta name="markdown-generator" content="teedoc-plugin-markdown-parser">
        
        <script>
MathJax = {"loader": {"load": ["output/svg"]}, "tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]]}, "svg": {"fontCache": "global"}};
</script>
        
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        
        <script src="/maixcdk/static/js/theme_default/pre_main.js"></script>
        
        <link rel="stylesheet" href="/maixcdk/static/css/theme_default/prism.min.css" type="text/css"/>
        
        <link rel="stylesheet" href="/maixcdk/static/css/theme_default/viewer.min.css" type="text/css"/>
        
        <link rel="stylesheet" href="/maixcdk/static/css/theme_default/dark.css" type="text/css"/>
        
        <link rel="stylesheet" href="/maixcdk/static/css/theme_default/light.css" type="text/css"/>
        
        <script src="/maixcdk/static/js/theme_default/jquery.min.js"></script>
        
        <script src="/maixcdk/static/js/theme_default/split.js"></script>
        
        <link rel="stylesheet" href="/maixcdk/static/css/search/style.css" type="text/css"/>
        
        <link rel="stylesheet" href="/maixcdk/static/css/custom.css" type="text/css"/>
        
        <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?9cb07365544a53067c56c346c838181a";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
        
        <link rel="stylesheet" href="/maixcdk/static/js/thumbs_up/style.css" type="text/css"/>
        
    
    
    <title>maix::image - MaixCDK</title>
    
    <script type="text/javascript">js_vars = {"teedoc-plugin-thumbs-up": {"label_up": "Helpful", "label_down": "Not Helpful", "icon": "/static/images/thumbs_up/up.svg", "icon_clicked": "/static/images/thumbs_up/upped.svg", "url": "https://thumbs-up.sipeed.com", "show_up_count": true, "show_down_count": false, "msg_already_voted": "You have already voted", "msg_thanks": "Thanks for your vote", "msg_down_prompt": "Thanks to tell us where we can improve?(At least 10 characters)", "msg_down_prompt_error": "Message should be at least 10 characters and less than 256 characters", "msg_error": "Request server failed!"}}</script>
    <script type="text/javascript">metadata = {"tags": [], "date": false, "update": [], "ts": 0, "author": "", "brief": "", "cover": ""}</script>
</head>


<body class="type_doc">
    
    <div id="navbar">
        <div id="navbar_menu">
            <a class="site_title" href="/maixcdk/">
                
                
                    <h2>MaixCDK</h2>
                
        </a>
            <a id="navbar_menu_btn"></a>
        </div>
        <div id="navbar_items">
            <div>
                <ul id="nav_left">
<li class=""><a  href="/maixcdk/doc/">Documentation</a></li>
<li class="active"><a  href="/maixcdk/api/">API</a></li>
<li class=""><a  href="/maixcdk/doc/faq.html">FAQ</a></li>
</ul>

            </div>
            <div>
                <ul id="nav_right">
<li class=""><a target="_blank" href="https://github.com/sipeed/MaixCDK"><img src='/maixcdk/static/image/github-fill.svg' style='height: 1.5em;vertical-align: middle;'>&nbsp;</a></li>
</ul>

                <ul class="nav_plugins"><li><a id="themes" class="light"></a></li></ul><ul class="nav_plugins"><li><a id="search"><span class="icon"></span><span class="placeholder">Search</span>
                            <div id="search_hints">
                                <span id="search_input_hint">Keywords separated by space</span>
                                <span id="search_loading_hint">Loading, wait please ...</span>
                                <span id="search_download_err_hint">Download error, please check network and refresh again</span>
                                <span id="search_other_docs_result_hint">Result from other docs</span>
                                <span id="search_curr_doc_result_hint">Result from current doc</span>
                            </div></a></li></ul>
            </div>
        </div>
    </div>
    
    <div id="wrapper">
        <div id="sidebar_wrapper">
            <div id="sidebar">
                <div id="sidebar_title">
                    
                </div>
                <ul class="show">
<li class="not_active with_link"><a href="/maixcdk/api/index.html"><span class="label">Brief</span><span class=""></span></a></li>
<li class="active_parent no_link"><a><span class="label">maix</span><span class="sub_indicator"></span></a><ul class="show">
<li class="not_active with_link"><a href="/maixcdk/api/maix/nn.html"><span class="label">nn</span><span class="sub_indicator"></span></a><ul class="show">
<li class="not_active with_link"><a href="/maixcdk/api/maix/nn/F.html"><span class="label">F</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active with_link"><a href="/maixcdk/api/maix/audio.html"><span class="label">audio</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/maixcdk/api/maix/network.html"><span class="label">network</span><span class="sub_indicator"></span></a><ul class="show">
<li class="not_active with_link"><a href="/maixcdk/api/maix/network/wifi.html"><span class="label">wifi</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active with_link"><a href="/maixcdk/api/maix/comm.html"><span class="label">comm</span><span class="sub_indicator"></span></a><ul class="show">
<li class="not_active with_link"><a href="/maixcdk/api/maix/comm/modbus.html"><span class="label">modbus</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active with_link"><a href="/maixcdk/api/maix/modbus.html"><span class="label">modbus</span><span class="sub_indicator"></span></a><ul class="show">
<li class="not_active with_link"><a href="/maixcdk/api/maix/modbus/Slave.html"><span class="label">Slave</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active with_link"><a href="/maixcdk/api/maix/example.html"><span class="label">example</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/maixcdk/api/maix/tensor.html"><span class="label">tensor</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/maixcdk/api/maix/log.html"><span class="label">log</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/maixcdk/api/maix/app.html"><span class="label">app</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/maixcdk/api/maix/thread.html"><span class="label">thread</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/maixcdk/api/maix/protocol.html"><span class="label">protocol</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/maixcdk/api/maix/sys.html"><span class="label">sys</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/maixcdk/api/maix/fs.html"><span class="label">fs</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/maixcdk/api/maix/i18n.html"><span class="label">i18n</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/maixcdk/api/maix/time.html"><span class="label">time</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/maixcdk/api/maix/util.html"><span class="label">util</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/maixcdk/api/maix/err.html"><span class="label">err</span><span class=""></span></a></li>
<li class="active with_link"><a href="/maixcdk/api/maix/image.html"><span class="label">image</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/maixcdk/api/maix/touchscreen.html"><span class="label">touchscreen</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/maixcdk/api/maix/rtmp.html"><span class="label">rtmp</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/maixcdk/api/maix/tracker.html"><span class="label">tracker</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/maixcdk/api/maix/video.html"><span class="label">video</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/maixcdk/api/maix/camera.html"><span class="label">camera</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/maixcdk/api/maix/uvc.html"><span class="label">uvc</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/maixcdk/api/maix/pipeline.html"><span class="label">pipeline</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/maixcdk/api/maix/http.html"><span class="label">http</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/maixcdk/api/maix/display.html"><span class="label">display</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/maixcdk/api/maix/rtsp.html"><span class="label">rtsp</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/maixcdk/api/maix/peripheral.html"><span class="label">peripheral</span><span class="sub_indicator"></span></a><ul class="show">
<li class="not_active with_link"><a href="/maixcdk/api/maix/peripheral/pwm.html"><span class="label">pwm</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/maixcdk/api/maix/peripheral/timer.html"><span class="label">timer</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/maixcdk/api/maix/peripheral/pinmap.html"><span class="label">pinmap</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/maixcdk/api/maix/peripheral/gpio.html"><span class="label">gpio</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/maixcdk/api/maix/peripheral/spi.html"><span class="label">spi</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/maixcdk/api/maix/peripheral/key.html"><span class="label">key</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/maixcdk/api/maix/peripheral/i2c.html"><span class="label">i2c</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/maixcdk/api/maix/peripheral/adc.html"><span class="label">adc</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/maixcdk/api/maix/peripheral/uart.html"><span class="label">uart</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/maixcdk/api/maix/peripheral/hid.html"><span class="label">hid</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/maixcdk/api/maix/peripheral/wdt.html"><span class="label">wdt</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active with_link"><a href="/maixcdk/api/maix/ahrs.html"><span class="label">ahrs</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/maixcdk/api/maix/ext_dev.html"><span class="label">ext_dev</span><span class="sub_indicator"></span></a><ul class="show">
<li class="not_active with_link"><a href="/maixcdk/api/maix/ext_dev/mlx90640.html"><span class="label">mlx90640</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/maixcdk/api/maix/ext_dev/tof100.html"><span class="label">tof100</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/maixcdk/api/maix/ext_dev/tmc2209.html"><span class="label">tmc2209</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/maixcdk/api/maix/ext_dev/cmap.html"><span class="label">cmap</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/maixcdk/api/maix/ext_dev/fp5510.html"><span class="label">fp5510</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/maixcdk/api/maix/ext_dev/imu.html"><span class="label">imu</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/maixcdk/api/maix/ext_dev/bm8563.html"><span class="label">bm8563</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/maixcdk/api/maix/ext_dev/pmu.html"><span class="label">pmu</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/maixcdk/api/maix/ext_dev/qmi8658.html"><span class="label">qmi8658</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/maixcdk/api/maix/ext_dev/axp2101.html"><span class="label">axp2101</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/maixcdk/api/maix/ext_dev/lsm6dsowtr.html"><span class="label">lsm6dsowtr</span><span class=""></span></a></li>
</ul>
</li>
</ul>
</li>
</ul>

            </div>
        </div>
        <div id="article">
            <div id="menu_wrapper">
                <div id="menu">
                </div>
            </div>
            <div id="content_wrapper">
                <div id="content_body">
                    <div id="article_head">
                        <div id="article_title">
                            
                            <h1>maix::image</h1>
                            
                        </div>
                        <div id="article_tags">
                            <ul>
                            
                            </ul>
                        </div>
                        <div id="article_info">
                        <div id="article_info_left">
                            <span class="article_author">
                                
                            </span>
                            
                        </div>
                        <div id="article_info_right">
                            
                            <div id="source_link">
                                <a href="https://github.com/sipeed/MaixCDK/blob/main/docs/api/maix/image.md" target="_blank">
                                    Edit this page
                                </a>
                            </div>
                            
                        </div>
                        </div>
                    </div>
                    <div id="article_tools">
                        <span></span>
                        <span id="toc_btn"></span>
                    </div>
                    <div id="update_history">
                        
                    </div>
                    <div id="article_content">
                        
                            <p>maix.image module, image related definition and functions</p>
<blockquote>
<p>This is <code>maix::image</code> module of <a href="https://github.com/sipeed/MaixCDK"  target="_blank">MaixCDK</a>.<br />
All of these elements are in namespace <code>maix::image</code>.</p>
<p>For MaixCDK developer: DO NOT edit this doc file manually, this doc is auto generated!</p>
</blockquote>
<h2 id="Module">Module</h2>
<p>No module</p>
<h2 id="Enum">Enum</h2>
<h3 id="Format">Format</h3>
<p>Image formats</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>describe</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>attention</strong></td>
  <td>for MaixPy firmware developers, update this enum will also need to update the fmt_size and fmt_names too !!!</td>
</tr>
<tr>
  <td><strong>values</strong></td>
  <td><strong>FMT_RGB888</strong>: RGBRGB...RGB, R at the lowest address<br><strong>FMT_BGR888</strong>: BGRBGR...BGR, B at the lowest address<br><strong>FMT_RGBA8888</strong>: RGBARGBA...RGBA, R at the lowest address<br><strong>FMT_BGRA8888</strong>: BGRABGRA...BGRA, B at the lowest address<br><strong>FMT_RGB565</strong>: <br><strong>FMT_BGR565</strong>: <br><strong>FMT_YUV422SP</strong>: YYY...UVUVUV...UVUV<br><strong>FMT_YUV422P</strong>: YYY...UUU...VVV<br><strong>FMT_YVU420SP</strong>: YYY...VUVUVU...VUVU, NV21<br><strong>FMT_YUV420SP</strong>: YYY...UVUVUV...UVUV, NV12<br><strong>FMT_YVU420P</strong>: YYY...VVV...UUU<br><strong>FMT_YUV420P</strong>: YYY...UUU...VVV<br><strong>FMT_GRAYSCALE</strong>: <br><strong>FMT_BGGR6</strong>: 6-bit Bayer format with a BGGR pattern.<br><strong>FMT_GBRG6</strong>: 6-bit Bayer format with a GBRG pattern.<br><strong>FMT_GRBG6</strong>: 6-bit Bayer format with a GRBG pattern.<br><strong>FMT_RGGB6</strong>: 6-bit Bayer format with a RGGB pattern.<br><strong>FMT_BGGR8</strong>: 8-bit Bayer format with a BGGR pattern.<br><strong>FMT_GBRG8</strong>: 8-bit Bayer format with a GBRG pattern.<br><strong>FMT_GRBG8</strong>: 8-bit Bayer format with a GRBG pattern.<br><strong>FMT_RGGB8</strong>: 8-bit Bayer format with a RGGB pattern.<br><strong>FMT_BGGR10</strong>: 10-bit Bayer format with a BGGR pattern.<br><strong>FMT_GBRG10</strong>: 10-bit Bayer format with a GBRG pattern.<br><strong>FMT_GRBG10</strong>: 10-bit Bayer format with a GRBG pattern.<br><strong>FMT_RGGB10</strong>: 10-bit Bayer format with a RGGB pattern.<br><strong>FMT_BGGR12</strong>: 12-bit Bayer format with a BGGR pattern.<br><strong>FMT_GBRG12</strong>: 12-bit Bayer format with a GBRG pattern.<br><strong>FMT_GRBG12</strong>: 12-bit Bayer format with a GRBG pattern.<br><strong>FMT_RGGB12</strong>: 12-bit Bayer format with a RGGB pattern.<br><strong>FMT_UNCOMPRESSED_MAX</strong>: <br><strong>FMT_COMPRESSED_MIN</strong>: <br><strong>FMT_JPEG</strong>: <br><strong>FMT_PNG</strong>: <br><strong>FMT_COMPRESSED_MAX</strong>: <br><strong>FMT_INVALID</strong>: format not valid<br></td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">enum Format
    {
        FMT_RGB888 = 0, // RGBRGB...RGB, R at the lowest address
        FMT_BGR888,     // BGRBGR...BGR, B at the lowest address
        FMT_RGBA8888,   // RGBARGBA...RGBA, R at the lowest address
        FMT_BGRA8888,   // BGRABGRA...BGRA, B at the lowest address
        FMT_RGB565,
        FMT_BGR565,
        FMT_YUV422SP, // YYY...UVUVUV...UVUV
        FMT_YUV422P,  // YYY...UUU...VVV
        FMT_YVU420SP, // YYY...VUVUVU...VUVU, NV21
        FMT_YUV420SP, // YYY...UVUVUV...UVUV, NV12
        FMT_YVU420P,  // YYY...VVV...UUU
        FMT_YUV420P,  // YYY...UUU...VVV
        FMT_GRAYSCALE,
        FMT_BGGR6,      // 6-bit Bayer format with a BGGR pattern.
        FMT_GBRG6,      // 6-bit Bayer format with a GBRG pattern.
        FMT_GRBG6,      // 6-bit Bayer format with a GRBG pattern.
        FMT_RGGB6,      // 6-bit Bayer format with a RGGB pattern.
        FMT_BGGR8,      // 8-bit Bayer format with a BGGR pattern.
        FMT_GBRG8,      // 8-bit Bayer format with a GBRG pattern.
        FMT_GRBG8,      // 8-bit Bayer format with a GRBG pattern.
        FMT_RGGB8,      // 8-bit Bayer format with a RGGB pattern.
        FMT_BGGR10,     // 10-bit Bayer format with a BGGR pattern.
        FMT_GBRG10,     // 10-bit Bayer format with a GBRG pattern.
        FMT_GRBG10,     // 10-bit Bayer format with a GRBG pattern.
        FMT_RGGB10,     // 10-bit Bayer format with a RGGB pattern.
        FMT_BGGR12,     // 12-bit Bayer format with a BGGR pattern.
        FMT_GBRG12,     // 12-bit Bayer format with a GBRG pattern.
        FMT_GRBG12,     // 12-bit Bayer format with a GRBG pattern.
        FMT_RGGB12,     // 12-bit Bayer format with a RGGB pattern.
        FMT_UNCOMPRESSED_MAX,

        // compressed format below, not compressed should define upper
        FMT_COMPRESSED_MIN,
        FMT_JPEG,
        FMT_PNG,
        FMT_COMPRESSED_MAX,

        FMT_INVALID = 0xFF  // format not valid
    }
</code></pre>
</blockquote>
<h3 id="Fit">Fit</h3>
<p>Object fit method</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>describe</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>values</strong></td>
  <td><strong>FIT_NONE</strong>: no object fit, keep original<br><strong>FIT_FILL</strong>: width to new width, height to new height, may be stretch<br><strong>FIT_CONTAIN</strong>: keep aspect ratio, fill blank area with black color<br><strong>FIT_COVER</strong>: keep aspect ratio, crop image to fit new size<br><strong>FIT_MAX</strong>: <br></td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">enum Fit
    {
        FIT_NONE = -1, // no object fit, keep original
        FIT_FILL = 0,  // width to new width, height to new height, may be stretch
        FIT_CONTAIN,   // keep aspect ratio, fill blank area with black color
        FIT_COVER,     // keep aspect ratio, crop image to fit new size
        FIT_MAX
    }
</code></pre>
</blockquote>
<h3 id="ResizeMethod">ResizeMethod</h3>
<p>Resize method</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>describe</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>values</strong></td>
  <td><strong>NEAREST</strong>: <br><strong>BILINEAR</strong>: <br><strong>BICUBIC</strong>: <br><strong>AREA</strong>: <br><strong>LANCZOS</strong>: <br><strong>HAMMING</strong>: <br><strong>RESIZE_METHOD_MAX</strong>: <br></td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">enum ResizeMethod
    {
        NEAREST = 0,
        BILINEAR,
        BICUBIC,
        AREA,
        LANCZOS,
        HAMMING,
        RESIZE_METHOD_MAX
    }
</code></pre>
</blockquote>
<h3 id="ApriltagFamilies">ApriltagFamilies</h3>
<p>Family of apriltag</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>describe</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>values</strong></td>
  <td><strong>TAG16H5</strong>: <br><strong>TAG25H7</strong>: <br><strong>TAG25H9</strong>: <br><strong>TAG36H10</strong>: <br><strong>TAG36H11</strong>: <br><strong>ARTOOLKIT</strong>: <br></td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">enum ApriltagFamilies
    {
        TAG16H5   = 1,
        TAG25H7   = 2,
        TAG25H9   = 4,
        TAG36H10  = 8,
        TAG36H11  = 16,
        ARTOOLKIT = 32
    }
</code></pre>
</blockquote>
<h3 id="TemplateMatch">TemplateMatch</h3>
<p>Template match method</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>describe</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>values</strong></td>
  <td><strong>SEARCH_EX</strong>: Exhaustive search<br><strong>SEARCH_DS</strong>: Diamond search<br></td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">enum TemplateMatch
    {
        SEARCH_EX,  // Exhaustive search
        SEARCH_DS,  // Diamond search
    }
</code></pre>
</blockquote>
<h3 id="CornerDetector">CornerDetector</h3>
<p>CornerDetector class</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>describe</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>values</strong></td>
  <td><strong>CORNER_FAST</strong>: <br><strong>CORNER_AGAST</strong>: <br></td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">enum CornerDetector
    {
        CORNER_FAST,
        CORNER_AGAST
    }
</code></pre>
</blockquote>
<h3 id="EdgeDetector">EdgeDetector</h3>
<p>EdgeDetector class</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>describe</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>values</strong></td>
  <td><strong>EDGE_CANNY</strong>: <br><strong>EDGE_SIMPLE</strong>: <br></td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">enum EdgeDetector
    {
        EDGE_CANNY,
        EDGE_SIMPLE,
    }
</code></pre>
</blockquote>
<h3 id="FlipDir">FlipDir</h3>
<p>FlipDir</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>describe</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>values</strong></td>
  <td><strong>X</strong>: <br><strong>Y</strong>: <br><strong>XY</strong>: <br></td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">enum class FlipDir
    {
        X,
        Y,
        XY
    }
</code></pre>
</blockquote>
<h3 id="QRCodeDecoderType">QRCodeDecoderType</h3>
<p>QRCode decode type class</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>describe</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>values</strong></td>
  <td><strong>QRCODE_DECODER_TYPE_ZBAR</strong>: <br><strong>QRCODE_DECODER_TYPE_QUIRC</strong>: <br><strong>QRCODE_DECODER_TYPE_ZXING</strong>: <br></td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">enum class QRCodeDecoderType {
        QRCODE_DECODER_TYPE_ZBAR,
        QRCODE_DECODER_TYPE_QUIRC,
        QRCODE_DECODER_TYPE_ZXING
    }
</code></pre>
</blockquote>
<h3 id="LineType">LineType</h3>
<p>Line type class</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>describe</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>values</strong></td>
  <td><strong>LINE_NORMAL</strong>: <br><strong>LINE_CROSS</strong>: <br><strong>LINE_T</strong>: <br><strong>LINE_L</strong>: <br></td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">enum class LineType {
        LINE_NORMAL,
        LINE_CROSS,
        LINE_T,
        LINE_L,
    }
</code></pre>
</blockquote>
<h3 id="CMap">CMap</h3>
<p>Image formats</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>describe</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>attention</strong></td>
  <td>for MaixPy firmware developers, update this enum will also need to update the fmt_size and fmt_names too !!!</td>
</tr>
<tr>
  <td><strong>values</strong></td>
  <td><strong>TURBO</strong>: Google-designed smooth, bright colormap; good Jet replacement for heatmaps<br><strong>VIRIDIS</strong>: Default perceptually uniform colormap; colorblind-friendly and widely recommended<br><strong>INFERNO</strong>: High-contrast, perceptually uniform; ideal for dark backgrounds and scientific data<br><strong>PLASMA</strong>: Bright and visually appealing; perceptually uniform and colorblind-friendly<br><strong>CIVIDIS</strong>: Grayscale-compatible and colorblind-safe; designed for visual accessibility<br><strong>CUBEHELIX</strong>: Perceptually uniform and printable in grayscale; spirals through color space<br><strong>MAGMA</strong>: Dark background-optimized; smooth gradient with good visibility in low-light visuals<br><strong>TWILIGHT</strong>: Cyclic gradient; useful for circular data such as angles or phase data<br><strong>TWILIGHT_SHIFTED</strong>: Phase-shifted version of Twilight; same use case but shifted zero point<br><strong>GREYS</strong>: Monotonic black-to-white gradient; useful for basic grayscale visualization<br><strong>JET</strong>: Classic but non-uniform RGB colormap; visually vibrant but not perceptually linear<br><strong>COOLWARM</strong>: Blue-white-red diverging map; ideal for visualizing deviation from a neutral center<br><strong>RDYBU</strong>: Red-white-blue diverging map; suitable for highlighting opposing directions/values<br><strong>SET1</strong>: High-contrast colors; up to 9 distinct categories, ideal for class segmentation<br><strong>TAB10</strong>: Matplotlib default for 10-category labeling; visually distinct and colorblind-friendly<br><strong>TAB20</strong>: Matplotlib default for 20-category labeling; visually distinct and colorblind-friendly<br><strong>THERMAL_WHITE_HOT</strong>: Hotter whiter; used thermal imaging mode due to its natural contrast.<br><strong>THERMAL_BLACK_HOT</strong>: Hotter darker; Often used in security and tactical applications for better object detection.<br><strong>THERMAL_RED_HOT</strong>: Hotter red，cooler areas dark； Emphasizes hotspots, useful for quick temperature anomaly detection.<br><strong>THERMAL_WHITE_HOT_SD</strong>: White Hot SD (Smooth Detail): Enhanced White Hot with improved local contrast and smoother tone transitions.<br>Helps distinguish fine temperature differences in subtle thermal scenes.<br><strong>THERMAL_BLACK_HOT_SD</strong>: Black Hot SD (Smooth Detail): Enhanced Black Hot with detail-preserving smoothing and finer thermal gradients.<br>Improves readability of dark-hot scenes with less visual noise.<br><strong>THERMAL_RED_HOT_SD</strong>: Red Hot SD (Smooth Detail): Enhanced Red Hot with more gradual color changes and smoother heat spot highlighting.<br>Offers better heat trace visualization with reduced abrupt transitions.<br><strong>THERMAL_IRONBOW</strong>: Ironbow: A classic thermal colormap that uses a smooth gradient from dark to bright (black → red → yellow → white).<br>Commonly used in industrial and medical thermography for better visualization.<br><strong>THERMAL_NIGHT</strong>: Night: A low-brightness thermal mode optimized for night operations or low-light display environments.<br>Typically enhances visibility in high-contrast night-time scenarios.<br><strong>GITHUB_GREEN</strong>: GitHub-themed green-based palette; custom usage such as contribution graphs<br><strong>MAX</strong>: Total count of valid colormaps (not a colormap itself)<br></td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">enum class CMap
    {
        // Sequential (Perceptually uniform linear gradients)
        TURBO = 0,           // Google-designed smooth, bright colormap; good Jet replacement for heatmaps
        VIRIDIS,             // Default perceptually uniform colormap; colorblind-friendly and widely recommended
        INFERNO,             // High-contrast, perceptually uniform; ideal for dark backgrounds and scientific data
        PLASMA,              // Bright and visually appealing; perceptually uniform and colorblind-friendly
        CIVIDIS,             // Grayscale-compatible and colorblind-safe; designed for visual accessibility
        CUBEHELIX,           // Perceptually uniform and printable in grayscale; spirals through color space
        MAGMA,               // Dark background-optimized; smooth gradient with good visibility in low-light visuals
        TWILIGHT,            // Cyclic gradient; useful for circular data such as angles or phase data
        TWILIGHT_SHIFTED,    // Phase-shifted version of Twilight; same use case but shifted zero point
        GREYS,               // Monotonic black-to-white gradient; useful for basic grayscale visualization

        // Traditional (Legacy and visually distinct maps)
        JET,                 // Classic but non-uniform RGB colormap; visually vibrant but not perceptually linear

        // Diverging (Center-out maps for relative differences)
        COOLWARM,            // Blue-white-red diverging map; ideal for visualizing deviation from a neutral center
        RDYBU,               // Red-white-blue diverging map; suitable for highlighting opposing directions/values

        // Qualitative (For categorical or class label data)
        SET1,                // High-contrast colors; up to 9 distinct categories, ideal for class segmentation
        TAB10,               // Matplotlib default for 10-category labeling; visually distinct and colorblind-friendly
        TAB20,               // Matplotlib default for 20-category labeling; visually distinct and colorblind-friendly

        // thermal
        THERMAL_WHITE_HOT,   // Hotter whiter; used thermal imaging mode due to its natural contrast.
        THERMAL_BLACK_HOT,   // Hotter darker; Often used in security and tactical applications for better object detection.
        THERMAL_RED_HOT,     // Hotter red，cooler areas dark； Emphasizes hotspots, useful for quick temperature anomaly detection.
        THERMAL_WHITE_HOT_SD, /* White Hot SD (Smooth Detail): Enhanced White Hot with improved local contrast and smoother tone transitions.
                                 Helps distinguish fine temperature differences in subtle thermal scenes.
                              */
        THERMAL_BLACK_HOT_SD, /* Black Hot SD (Smooth Detail): Enhanced Black Hot with detail-preserving smoothing and finer thermal gradients.
                                 Improves readability of dark-hot scenes with less visual noise.
                              */
        THERMAL_RED_HOT_SD,   /* Red Hot SD (Smooth Detail): Enhanced Red Hot with more gradual color changes and smoother heat spot highlighting.
                                 Offers better heat trace visualization with reduced abrupt transitions.
                              */
        THERMAL_IRONBOW,      /* Ironbow: A classic thermal colormap that uses a smooth gradient from dark to bright (black → red → yellow → white).
                                 Commonly used in industrial and medical thermography for better visualization.
                              */
        THERMAL_NIGHT,      /* Night: A low-brightness thermal mode optimized for night operations or low-light display environments.
                                 Typically enhances visibility in high-contrast night-time scenarios.
                              */

        // Special / Custom
        GITHUB_GREEN,        // GitHub-themed green-based palette; custom usage such as contribution graphs

        MAX                 // Total count of valid colormaps (not a colormap itself)
    }
</code></pre>
</blockquote>
<h2 id="Variable">Variable</h2>
<h3 id="COLOR_WHITE">COLOR_WHITE</h3>
<p>Predefined color white</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>value</strong></td>
  <td><strong>image::Color::from_rgb(255, 255, 255)</strong></td>
</tr>
<tr>
  <td><strong>readonly</strong></td>
  <td>True</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">const image::Color COLOR_WHITE = image::Color::from_rgb(255, 255, 255)
</code></pre>
</blockquote>
<h3 id="COLOR_BLACK">COLOR_BLACK</h3>
<p>Predefined color black</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>value</strong></td>
  <td><strong>image::Color::from_rgb(0, 0, 0)</strong></td>
</tr>
<tr>
  <td><strong>readonly</strong></td>
  <td>True</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">const image::Color COLOR_BLACK = image::Color::from_rgb(0, 0, 0)
</code></pre>
</blockquote>
<h3 id="COLOR_RED">COLOR_RED</h3>
<p>Predefined color red</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>value</strong></td>
  <td><strong>image::Color::from_rgb(255, 0, 0)</strong></td>
</tr>
<tr>
  <td><strong>readonly</strong></td>
  <td>True</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">const image::Color COLOR_RED = image::Color::from_rgb(255, 0, 0)
</code></pre>
</blockquote>
<h3 id="COLOR_GREEN">COLOR_GREEN</h3>
<p>Predefined color green</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>value</strong></td>
  <td><strong>image::Color::from_rgb(0, 255, 0)</strong></td>
</tr>
<tr>
  <td><strong>readonly</strong></td>
  <td>True</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">const image::Color COLOR_GREEN = image::Color::from_rgb(0, 255, 0)
</code></pre>
</blockquote>
<h3 id="COLOR_BLUE">COLOR_BLUE</h3>
<p>Predefined color blue</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>value</strong></td>
  <td><strong>image::Color::from_rgb(0, 0, 255)</strong></td>
</tr>
<tr>
  <td><strong>readonly</strong></td>
  <td>True</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">const image::Color COLOR_BLUE = image::Color::from_rgb(0, 0, 255)
</code></pre>
</blockquote>
<h3 id="COLOR_YELLOW">COLOR_YELLOW</h3>
<p>Predefined color yellow</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>value</strong></td>
  <td><strong>image::Color::from_rgb(255, 255, 0)</strong></td>
</tr>
<tr>
  <td><strong>readonly</strong></td>
  <td>True</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">const image::Color COLOR_YELLOW = image::Color::from_rgb(255, 255, 0)
</code></pre>
</blockquote>
<h3 id="COLOR_PURPLE">COLOR_PURPLE</h3>
<p>Predefined color purple</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>value</strong></td>
  <td><strong>image::Color::from_rgb(143, 0, 255)</strong></td>
</tr>
<tr>
  <td><strong>readonly</strong></td>
  <td>True</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">const image::Color COLOR_PURPLE = image::Color::from_rgb(143, 0, 255)
</code></pre>
</blockquote>
<h3 id="COLOR_ORANGE">COLOR_ORANGE</h3>
<p>Predefined color orange</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>value</strong></td>
  <td><strong>image::Color::from_rgb(255, 127, 0)</strong></td>
</tr>
<tr>
  <td><strong>readonly</strong></td>
  <td>True</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">const image::Color COLOR_ORANGE = image::Color::from_rgb(255, 127, 0)
</code></pre>
</blockquote>
<h3 id="COLOR_GRAY">COLOR_GRAY</h3>
<p>Predefined color gray</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>value</strong></td>
  <td><strong>image::Color::from_rgb(127, 127, 127)</strong></td>
</tr>
<tr>
  <td><strong>readonly</strong></td>
  <td>True</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">const image::Color COLOR_GRAY = image::Color::from_rgb(127, 127, 127)
</code></pre>
</blockquote>
<h3 id="COLOR_INVALID">COLOR_INVALID</h3>
<p>Predefined color invalid, for special usage.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>value</strong></td>
  <td><strong>image::Color(0, 0, 0, 0, image::Format::FMT_INVALID)</strong></td>
</tr>
<tr>
  <td><strong>readonly</strong></td>
  <td>True</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">const image::Color COLOR_INVALID = image::Color(0, 0, 0, 0, image::Format::FMT_INVALID)
</code></pre>
</blockquote>
<h3 id="fmt_size">fmt_size</h3>
<p>Image format size in bytes</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>attention</strong></td>
  <td>It's a copy of this variable in MaixPy,<br>so change it in C++ (e.g. update var in hello function) will not take effect the var inMaixPy.<br>So we add const for this var to avoid this mistake.</td>
</tr>
<tr>
  <td><strong>value</strong></td>
  <td><strong>{<br>        3,<br>        3,<br>        4,<br>        4,<br>        2,<br>        2,<br>        2,<br>        2,<br>        1.5,<br>        1.5,<br>        1.5,<br>        1.5,<br>        1, // grayscale<br>        0.75,   // 6-bit Bayer format<br>        0.75,   // 6-bit Bayer format<br>        0.75,   // 6-bit Bayer format<br>        0.75,   // 6-bit Bayer format<br>        1,      // 8-bit Bayer format<br>        1,      // 8-bit Bayer format<br>        1,      // 8-bit Bayer format<br>        1,      // 8-bit Bayer format<br>        1.25,   // 10-bit Bayer format<br>        1.25,   // 10-bit Bayer format<br>        1.25,   // 10-bit Bayer format<br>        1.25,   // 10-bit Bayer format<br>        1.5,    // 12-bit Bayer format<br>        1.5,    // 12-bit Bayer format<br>        1.5,    // 12-bit Bayer format<br>        1.5,    // 12-bit Bayer format<br>        0, // uncompereed_max<br>        0, // compressed_min<br>        1, // jpeg<br>        1, // png<br>        0, // compressed_max<br>        0  // invalid<br>        }</strong></td>
</tr>
<tr>
  <td><strong>readonly</strong></td>
  <td>True</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">const std::vector&lt;float&gt; fmt_size = {
        3,
        3,
        4,
        4,
        2,
        2,
        2,
        2,
        1.5,
        1.5,
        1.5,
        1.5,
        1, // grayscale
        0.75,   // 6-bit Bayer format
        0.75,   // 6-bit Bayer format
        0.75,   // 6-bit Bayer format
        0.75,   // 6-bit Bayer format
        1,      // 8-bit Bayer format
        1,      // 8-bit Bayer format
        1,      // 8-bit Bayer format
        1,      // 8-bit Bayer format
        1.25,   // 10-bit Bayer format
        1.25,   // 10-bit Bayer format
        1.25,   // 10-bit Bayer format
        1.25,   // 10-bit Bayer format
        1.5,    // 12-bit Bayer format
        1.5,    // 12-bit Bayer format
        1.5,    // 12-bit Bayer format
        1.5,    // 12-bit Bayer format
        0, // uncompereed_max
        0, // compressed_min
        1, // jpeg
        1, // png
        0, // compressed_max
        0  // invalid
        }
</code></pre>
</blockquote>
<h3 id="fmt_names">fmt_names</h3>
<p>Image format string.\n!!Deprecated!! Please use format_name() function instead.\nThis attribute will be removed in future.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>value</strong></td>
  <td><strong>{<br>        &quot;RGB888&quot;,<br>        &quot;BGR888&quot;,<br>        &quot;RGBA8888&quot;,<br>        &quot;BGRA8888&quot;,<br>        &quot;RGB565&quot;,<br>        &quot;BGR565&quot;,<br>        &quot;YUV422SP&quot;,<br>        &quot;YUV422P&quot;,<br>        &quot;YVU420SP&quot;,<br>        &quot;YUV420SP&quot;,<br>        &quot;YVU420P&quot;,<br>        &quot;YUV420P&quot;,<br>        &quot;GRAYSCALE&quot;,<br>        &quot;BGGR6&quot;,<br>        &quot;GBRG6&quot;,<br>        &quot;GRBG6&quot;,<br>        &quot;RG6B6&quot;,<br>        &quot;BGGR8&quot;,<br>        &quot;GBRG8&quot;,<br>        &quot;GRBG8&quot;,<br>        &quot;RG6B8&quot;,<br>        &quot;BGGR10&quot;,<br>        &quot;GBRG10&quot;,<br>        &quot;GRBG10&quot;,<br>        &quot;RG6B10&quot;,<br>        &quot;BGGR12&quot;,<br>        &quot;GBRG12&quot;,<br>        &quot;GRBG12&quot;,<br>        &quot;RG6B12&quot;,<br>        &quot;UNCOMPRESSED_MAX&quot;,<br>        &quot;COMPRESSED_MIN&quot;,<br>        &quot;JPEG&quot;,<br>        &quot;PNG&quot;,<br>        &quot;COMPRESSED_MAX&quot;,<br>        &quot;INVALID&quot;<br>        }</strong></td>
</tr>
<tr>
  <td><strong>readonly</strong></td>
  <td>True</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">const std::vector&lt;std::string&gt; fmt_names = {
        &quot;RGB888&quot;,
        &quot;BGR888&quot;,
        &quot;RGBA8888&quot;,
        &quot;BGRA8888&quot;,
        &quot;RGB565&quot;,
        &quot;BGR565&quot;,
        &quot;YUV422SP&quot;,
        &quot;YUV422P&quot;,
        &quot;YVU420SP&quot;,
        &quot;YUV420SP&quot;,
        &quot;YVU420P&quot;,
        &quot;YUV420P&quot;,
        &quot;GRAYSCALE&quot;,
        &quot;BGGR6&quot;,
        &quot;GBRG6&quot;,
        &quot;GRBG6&quot;,
        &quot;RG6B6&quot;,
        &quot;BGGR8&quot;,
        &quot;GBRG8&quot;,
        &quot;GRBG8&quot;,
        &quot;RG6B8&quot;,
        &quot;BGGR10&quot;,
        &quot;GBRG10&quot;,
        &quot;GRBG10&quot;,
        &quot;RG6B10&quot;,
        &quot;BGGR12&quot;,
        &quot;GBRG12&quot;,
        &quot;GRBG12&quot;,
        &quot;RG6B12&quot;,
        &quot;UNCOMPRESSED_MAX&quot;,
        &quot;COMPRESSED_MIN&quot;,
        &quot;JPEG&quot;,
        &quot;PNG&quot;,
        &quot;COMPRESSED_MAX&quot;,
        &quot;INVALID&quot;
        }
</code></pre>
</blockquote>
<h2 id="Function">Function</h2>
<h3 id="resize_map_pos">resize_map_pos</h3>
<p>map point position or rectangle position from one image size to another image size(resize)</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>param</strong></td>
  <td><strong>int</strong>: h_out target image height<br><strong>fit</strong>: resize method, see maix.image.Fit<br><strong>x</strong>: original point x, or rectagle left-top point's x<br><strong>y</strong>: original point y, or rectagle left-top point's y<br><strong>w</strong>: original rectagle width, can be -1 if not use this arg, default -1.<br><strong>h</strong>: original rectagle height, can be -1 if not use this arg, default -1.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>list type, [x, y] if map point, [x, y, w, h] if resize rectangle.</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">std::vector&lt;int&gt; resize_map_pos(int w_in, int h_in, int w_out, int h_out, image::Fit fit, int x, int y, int w = -1, int h = -1)
</code></pre>
</blockquote>
<h3 id="resize_map_pos_reverse">resize_map_pos_reverse</h3>
<p>reverse resize_map_pos method, when we call image.resize method resiz image 'a' to image 'b', we want to known the original position on 'a' whith a knew point on 'b'</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>param</strong></td>
  <td><strong>int</strong>: h_out image height after resized<br><strong>fit</strong>: resize method, see maix.image.Fit<br><strong>x</strong>: point on resized image x, or rectagle left-top point's x<br><strong>y</strong>: original point y, or rectagle left-top point's y<br><strong>w</strong>: original rectagle width, can be -1 if not use this arg, default -1.<br><strong>h</strong>: original rectagle height, can be -1 if not use this arg, default -1.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>list type, [x, y] if map point, [x, y, w, h] if resize rectangle.</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">std::vector&lt;int&gt; resize_map_pos_reverse(int w_in, int h_in, int w_out, int h_out, image::Fit fit, int x, int y, int w = -1, int h = -1)
</code></pre>
</blockquote>
<h3 id="load">load</h3>
<p>Load image from file, and convert to Image object</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>param</strong></td>
  <td><strong>path</strong>: image file path<br><strong>format</strong>: read as this format, if not match, will convert to this format, by default is RGB888<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Image object, if load failed, will return None(nullptr in C++), so you should care about it.</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *load(const std::string &amp;path, image::Format format = image::Format::FMT_RGB888)
</code></pre>
</blockquote>
<h3 id="from_bytes">from_bytes</h3>
<p>Create image from bytes</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>param</strong></td>
  <td><strong>width</strong>: image width<br><strong>height</strong>: image height<br><strong>format</strong>: image format<br><strong>data</strong>: image data, if data is None, will malloc memory for image data<br>If the image is in jpeg format, data must be filled in.<br><strong>copy</strong>: if true and data is not None, will copy data to new buffer, else will use data directly. default is true to avoid memory leak.<br>Use it carefully!!!<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Image object</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *from_bytes(int width, int height, image::Format format, Bytes *data, bool copy = true)
</code></pre>
</blockquote>
<h3 id="load_font">load_font</h3>
<p>Load font from file</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>param</strong></td>
  <td><strong>name</strong>: font name, used to identify font<br><strong>path</strong>: font file path, support ttf, ttc, otf<br><strong>size</strong>: font size, font height, by default is 16<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>error code, err::ERR_NONE is ok, other is error</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">err::Err load_font(const std::string &amp;name, const char *path, int size = 16)
</code></pre>
</blockquote>
<h3 id="set_default_font">set_default_font</h3>
<p>Set default font, if not call this method, default is hershey_plain</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>param</strong></td>
  <td><strong>name</strong>: font name, supported names can be get by fonts()<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>error code, err::ERR_NONE is ok, other is error</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">err::Err set_default_font(const std::string &amp;name)
</code></pre>
</blockquote>
<h3 id="fonts">fonts</h3>
<p>Get all loaded fonts</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>return</strong></td>
  <td>all loaded fonts, string list type</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">std::vector&lt;std::string&gt; *fonts()
</code></pre>
</blockquote>
<h3 id="string_size">string_size</h3>
<p>Get text rendered width and height</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>param</strong></td>
  <td><strong>string</strong>: text content<br><strong>scale</strong>: font scale, by default(value is 1)<br><strong>thickness</strong>: text thickness(line width), by default(value is 1)<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>text rendered width and height, [width, height]</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Size string_size(std::string string, float scale = 1, int thickness = 1, const std::string &amp;font = &quot;&quot;)
</code></pre>
</blockquote>
<h3 id="image2cv">image2cv</h3>
<p>Convert image::Image object to opencv Mat object</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>param</strong></td>
  <td><strong>img</strong>: direction [in], image::Image object<br><strong>mat</strong>: direction [out], cv::Mat object, output image, will be allocated by this function.<br><strong>ensure_bgr</strong>: direction [in], auto convert to BGR888 or BGRA8888 if img format is not BGR or BGRA, if set to false, will not auto convert and directly use img's data, default false.<br>If copy is false, ensure_bgr always be false.<br><strong>copy</strong>: direction [in], Whether alloc new image and copy data or not, if ensure_bgr and img is not bgr or bgra format, always copy,<br>if not copy, array object will directly use img's data buffer, will faster but change array will affect img's data, default true.<br></td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">err::Err image2cv(image::Image &amp;img, cv::Mat &amp;mat, bool ensure_bgr = false, bool copy = true)
</code></pre>
</blockquote>
<h3 id="cv2image">cv2image</h3>
<p>OpenCV Mat object to Image object</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>param</strong></td>
  <td><strong>mat</strong>: cv::Mat image object.<br><strong>bgr</strong>: if set bgr, the return image will be marked as BGR888 or BGRA8888 format, grayscale will ignore this arg.<br><strong>copy</strong>: if true, will alloc new buffer and copy data, else will directly use array's data buffer, default true.<br>Use this arg carefully, when set to false, ther array MUST keep alive until we don't use the return img of this func, or will cause program crash.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Image object</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *cv2image(cv::Mat &amp;mat, bool bgr = true, bool copy = true)
</code></pre>
</blockquote>
<h3 id="format_name">format_name</h3>
<p>Get format name by format.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>return</strong></td>
  <td>format name string</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">std::string format_name(maix::image::Format fmt)
</code></pre>
</blockquote>
<h3 id="cmap_to_str">cmap_to_str</h3>
<p>Get the string representation of a colormap enum value.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>param</strong></td>
  <td><strong>cmap</strong>: Colormap enum value, @see image::CMap<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Corresponding colormap name as a string.</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">std::string cmap_to_str(image::CMap cmap)
</code></pre>
</blockquote>
<h3 id="cmap_from_str">cmap_from_str</h3>
<p>Get the colormap enum value from a string name.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>param</strong></td>
  <td><strong>name</strong>: Name of the colormap (case-insensitive).<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Corresponding colormap enum value, or throws if name is invalid.</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::CMap cmap_from_str(const std::string&amp; name)
</code></pre>
</blockquote>
<h3 id="cmap_strs">cmap_strs</h3>
<p>Get a list of all available colormap name strings.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>param</strong></td>
  <td><strong>claasify</strong>: cmaps for classify, wihch cmap size not equal to 256.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Vector of all supported colormap name strings.</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">std::vector&lt;std::string&gt; cmap_strs(bool classify = false)
</code></pre>
</blockquote>
<h3 id="cmap_color">cmap_color</h3>
<p>Get the mapped color of a grayscale value under a specific colormap.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>param</strong></td>
  <td><strong>gray</strong>: Grayscale value in [0, 255].<br><strong>cmap</strong>: Colormap enum value to map the grayscale to color.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>The mapped image::Color.</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Color cmap_color(uint8_t gray, image::CMap cmap)
</code></pre>
</blockquote>
<h3 id="cmap_colors">cmap_colors</h3>
<p>Get all 256 mapped colors of a colormap.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>param</strong></td>
  <td><strong>cmap</strong>: Colormap enum value.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Vector of 256 image::Color values corresponding to grayscale values [0, 255].<br>Return value will alloc data, you need to delete it after use in C++.</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">std::vector&lt;image::Color&gt; cmap_colors(image::CMap cmap)
</code></pre>
</blockquote>
<h3 id="cmap_colors_rgb">cmap_colors_rgb</h3>
<p>Get all 256 mapped RGB colors of a colormap.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>param</strong></td>
  <td><strong>cmap</strong>: Colormap enum value.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Vector of 256 RGB arrays (each array has 3 uint8_t: R, G, B).<br>Return value is a internal table refrence.</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">const std::vector&lt;std::array&lt;uint8_t, 3&gt;&gt; &amp;cmap_colors_rgb(image::CMap cmap)
</code></pre>
</blockquote>
<h2 id="Class">Class</h2>
<h3 id="Image">Image</h3>
<p>Image class</p>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">class Image
</code></pre>
</blockquote>
<h4 id="Image-2">Image</h4>
<p>Image constructor</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>width</strong>: image width, should &gt; 0<br><strong>height</strong>: image height, should &gt; 0<br><strong>format</strong>: image format @see image::Format<br><strong>bg</strong>: background color, default is black, grayscale color will be faster,<br>if bg is image.COLOR_INVALID, will not fill background color, so background may be garbage(random content).<br>So you can set to image.COLOR_INVALID to save time in some case.<br></td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">Image(int width, int height, image::Format format = image::Format::FMT_RGB888, const image::Color &amp;bg = image::COLOR_INVALID)
</code></pre>
</blockquote>
<h4 id="Image (overload 1)">Image (overload 1)</h4>
<p>Image constructor</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>width</strong>: image width, should &gt; 0<br><strong>height</strong>: image height, should &gt; 0<br><strong>format</strong>: image format @see image::Format<br><strong>data</strong>: image data, if data is nullptr, will malloc memory for image data<br>If the image is in jpeg format, data must be filled in.<br><strong>data_size</strong>: image data size, only for compressed format like jpeg png, data_size must be filled in, or should be -1, default is -1.<br><strong>copy</strong>: if true and data is not nullptr, will copy data to new buffer, else will use data directly. default is true to avoid memory leak.<br><strong>bg</strong>: background color, default is black, grayscale color will be faster,<br>if bg is image.COLOR_INVALID, will not fill background color, so background may be garbage(random content).<br>So you can set to image.COLOR_INVALID to save time in some case.<br></td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">Image(int width, int height, image::Format format, uint8_t *data, int data_size, bool copy, const image::Color &amp;bg = image::COLOR_INVALID)
</code></pre>
</blockquote>
<h4 id="update">update</h4>
<p>set image</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">err::Err update(int width, int height, image::Format format, uint8_t *data = NULL, int data_size = 0, bool copy = true)
</code></pre>
</blockquote>
<h4 id="format-2">format</h4>
<p>Get image's format</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>see</strong></td>
  <td>image.Format</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Format format()
</code></pre>
</blockquote>
<h4 id="size">size</h4>
<p>Get image's size, [width, height]</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Size size()
</code></pre>
</blockquote>
<h4 id="data_size">data_size</h4>
<p>Get image's data size</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int data_size()
</code></pre>
</blockquote>
<h4 id="width">width</h4>
<p>Get image's width</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int width()
</code></pre>
</blockquote>
<h4 id="height">height</h4>
<p>Get image's height</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int height()
</code></pre>
</blockquote>
<h4 id="data">data</h4>
<p>Get image's data pointer.\nIn MaixPy is capsule object.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">void *data()
</code></pre>
</blockquote>
<h4 id="__str__">__str__</h4>
<p>To string method</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">std::string __str__()
</code></pre>
</blockquote>
<h4 id="to_str">to_str</h4>
<p>To string method</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">std::string to_str()
</code></pre>
</blockquote>
<h4 id="get_pixel">get_pixel</h4>
<p>Get pixel of image</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>x</strong>: pixel's coordinate x. x must less than image's width<br><strong>y</strong>: pixel's coordinate y. y must less than image's height<br><strong>rgbtuple</strong>: switch return value method. rgbtuple decides whether to split the return or not. default is false.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>pixel value,<br>According to image format and rgbtuple, return different value:<br>format is FMT_RGB888, rgbtuple is true, return [R, G, B]; rgbtuple is false, return [RGB]<br>foramt is FMT_BGR888, rgbtuple is true, return [B, G, R]; rgbtuple is false, return [BGR]<br>format is FMT_GRAYSCALE, return [GRAY];</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">std::vector&lt;uint32_t&gt; get_pixel(int x, int y, bool rgbtuple = false)
</code></pre>
</blockquote>
<h4 id="set_pixel">set_pixel</h4>
<p>Set pixel of image</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>x</strong>: pixel's coordinate x. x must less than image's width<br><strong>y</strong>: pixel's coordinate y. y must less than image's height<br><strong>pixel</strong>: pixel value, according to image format and size of pixel, has different operation:<br>format is FMT_RGB888, pixel size must be 1 or 3, if size is 1, will split pixel[0] to [R, G, B]; if size is 3, will use pixel directly<br>format is FMT_BGR888, pixel size must be 1 or 3, if size is 1, will split pixel[0] to [B, G, R]; if size is 3, will use pixel directly<br>format is FMT_GRAYSCALE, pixel size must be 1, will use pixel directly<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>error code, Err::ERR_NONE is ok, other is error</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">err::Err set_pixel(int x, int y, std::vector&lt;uint32_t&gt; pixel)
</code></pre>
</blockquote>
<h4 id="to_tensor">to_tensor</h4>
<p>Convert Image object to tensor::Tensor object</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>chw</strong>: convert to tensor with CHW or HWC layout result, image is HWC,<br>so default chw is false, if set true, will convert to CHW layout.<br>Attention, if set chw to true, copy must be true, or will raise err.Exception.<br><strong>copy</strong>: if true, will alloc memory for tensor data, else will use the memory of Image object.<br>Attention, if set chw to true, copy must be true, or will raise err.Exception.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>tensor::Tensor object pointer, an allocated tensor object</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">tensor::Tensor *to_tensor(bool chw = false, bool copy = true)
</code></pre>
</blockquote>
<h4 id="to_tensor_float32">to_tensor_float32</h4>
<p>Convert image to float32 tensor, and support normlize with mean and scale(1/std).\nIf mean and scale not empty, Will execute (data - mean) * scale, and return float32 tensor.Tensor.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>attention</strong></td>
  <td>only support grayscale, RGB, BGR, RGBA, BGRA image.</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>chw</strong>: convert to chw layout or not, default false.<br><strong>mean</strong>: mean value, list type, can be on or three elements according to image's format. Default empty means not normalize.<br><strong>scale</strong>: scale value, list type, can be on or three elements according to image's format.  Default empty means not normalize.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>float32 tensor.Tensor object with new alloc memory, so you need to delete it manually in C++.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">tensor::Tensor * to_tensor_float32(bool chw = false, std::vector&lt;float&gt; mean = std::vector&lt;float&gt;(), std::vector&lt;float&gt; scale = std::vector&lt;float&gt;())
</code></pre>
</blockquote>
<h4 id="to_tensor_float32 (overload 1)">to_tensor_float32 (overload 1)</h4>
<p>Convert image to float32 tensor, and support normlize with mean and scale(1/std).\nIf mean and scale not empty, Will execute (data - mean) * scale, and return float32 tensor.Tensor.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>attention</strong></td>
  <td>only support grayscale, RGB, BGR, RGBA, BGRA image.</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>tensor_result</strong>: output tensor, address of Tensor pointer, if nullptr, this func will alloc Tensor object, then you need to delete object by yourself.<br>If not nullptr, will directly use its float32 data and not alloc again.<br><strong>chw</strong>: convert to chw layout or not, default false.<br><strong>mean</strong>: mean value, list type, can be on or three elements according to image's format. Default empty means not normalize.<br><strong>scale</strong>: scale value, list type, can be on or three elements according to image's format.  Default empty means not normalize.<br></td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">void to_tensor_float32(tensor::Tensor **tensor_result, bool chw = false, std::vector&lt;float&gt; mean = std::vector&lt;float&gt;(), std::vector&lt;float&gt; scale = std::vector&lt;float&gt;())
</code></pre>
</blockquote>
<h4 id="to_bytes">to_bytes</h4>
<p>Get image's data and convert to array bytes</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>copy</strong>: if true, will alloc memory and copy data to new buffer,<br>else will use the memory of Image object, delete bytes object will not affect Image object，<br>but delete Image object will make bytes object invalid, it may cause program crash !!!!<br>So use this param carefully.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>image's data bytes, need be delete by caller in C++.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">Bytes *to_bytes(bool copy = true)
</code></pre>
</blockquote>
<h4 id="to_format">to_format</h4>
<p>Convert image to specific format</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>format</strong>: format want to convert to, @see image::Format, only support RGB888, BGR888, RGBA8888, BGRA8888, GRAYSCALE, JPEG.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>new image object. Need be delete by caller in C++.</td>
</tr>
<tr>
  <td><strong>throw</strong></td>
  <td>err.Exception, if two images' format not support, <strong>or already the format</strong>, will raise exception</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *to_format(const image::Format &amp;format)
</code></pre>
</blockquote>
<h4 id="to_format (overload 1)">to_format (overload 1)</h4>
<p>Convert image to specific format</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>format</strong>: format want to convert to, @see image::Format, only support RGB888, BGR888, RGBA8888, BGRA8888, GRAYSCALE, JPEG.<br><strong>buff</strong>: user's buffer, if buff is nullptr, will malloc memory for new image data, else will use buff directly<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>new image object. Need be delete by caller in C++.</td>
</tr>
<tr>
  <td><strong>throw</strong></td>
  <td>err.Exception, if two images' format not support, <strong>or already the format</strong>, will raise exception</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *to_format(const image::Format &amp;format, void *buff, size_t buff_size)
</code></pre>
</blockquote>
<h4 id="to_jpeg">to_jpeg</h4>
<p>Convert image to jpeg</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>quality</strong>: the quality of jpg, default is 95. For MaixCAM supported range is (50, 100], if &lt;= 50 will be fixed to 51.<br><strong>buff</strong>: user's buffer, if buff is nullptr, will malloc memory for new image data, else will use buff directly<br><strong>buff_size</strong>: the size of buff, if buff is nullptr, buff_size is ignored.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>new image object. Need be delete by caller in C++.</td>
</tr>
<tr>
  <td><strong>throw</strong></td>
  <td>err.Exception, if two images' format not support, <strong>or already the format</strong>, will raise exception</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *to_jpeg(int quality = 95, void *buff = nullptr, size_t buff_size = 0)
</code></pre>
</blockquote>
<h4 id="draw_image">draw_image</h4>
<p>Draw image on this image</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>x</strong>: left top corner of image point's coordinate x<br><strong>y</strong>: left top corner of image point's coordinate y<br><strong>img</strong>: image object to draw, the caller's channel must &lt;= the args' channel,<br>e.g. caller is RGB888, args is RGBA8888, will throw exception, but caller is RGBA8888, args is RGB888 or RGBA8888 is ok<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>this image object self</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *draw_image(int x, int y, image::Image &amp;img)
</code></pre>
</blockquote>
<h4 id="draw_rect">draw_rect</h4>
<p>Fill rectangle color to image</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>x</strong>: left top corner of rectangle point's coordinate x<br><strong>y</strong>: left top corner of rectangle point's coordinate y<br><strong>w</strong>: rectangle width<br><strong>h</strong>: rectangle height<br><strong>color</strong>: rectangle color<br><strong>thickness</strong>: rectangle thickness(line width), by default(value is 1), -1 means fill rectangle<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>this image object self</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *draw_rect(int x, int y, int w, int h, const image::Color &amp;color, int thickness = 1)
</code></pre>
</blockquote>
<h4 id="draw_line">draw_line</h4>
<p>Draw line on image</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>x1</strong>: start point's coordinate x<br><strong>y1</strong>: start point's coordinate y<br><strong>x2</strong>: end point's coordinate x<br><strong>y2</strong>: end point's coordinate y<br><strong>color</strong>: line color @see image::Color<br><strong>thickness</strong>: line thickness(line width), by default(value is 1)<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>this image object self</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *draw_line(int x1, int y1, int x2, int y2, const image::Color &amp;color, int thickness = 1)
</code></pre>
</blockquote>
<h4 id="draw_circle">draw_circle</h4>
<p>Draw circle on image</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>x</strong>: circle center point's coordinate x<br><strong>y</strong>: circle center point's coordinate y<br><strong>radius</strong>: circle radius<br><strong>color</strong>: circle color @see image::Color<br><strong>thickness</strong>: circle thickness(line width), default -1 means fill circle<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>this image object self</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *draw_circle(int x, int y, int radius, const image::Color &amp;color, int thickness = 1)
</code></pre>
</blockquote>
<h4 id="draw_ellipse">draw_ellipse</h4>
<p>Draw ellipse on image</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>x</strong>: ellipse center point's coordinate x<br><strong>y</strong>: ellipse center point's coordinate y<br><strong>a</strong>: ellipse major axis length<br><strong>b</strong>: ellipse minor axis length<br><strong>angle</strong>: ellipse rotation angle<br><strong>start_angle</strong>: ellipse start angle<br><strong>end_angle</strong>: ellipse end angle<br><strong>color</strong>: ellipse color @see image::Color<br><strong>thickness</strong>: ellipse thickness(line width), by default(value is 1), -1 means fill ellipse<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>this image object self</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *draw_ellipse(int x, int y, int a, int b, float angle, float start_angle, float end_angle, const image::Color &amp;color, int thickness = 1)
</code></pre>
</blockquote>
<h4 id="draw_string">draw_string</h4>
<p>Draw text on image</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>x</strong>: text left top point's coordinate x<br><strong>y</strong>: text left top point's coordinate y<br><strong>string</strong>: text content<br><strong>color</strong>: text color @see image::Color, default is white<br><strong>scale</strong>: font scale, by default(value is 1)<br><strong>thickness</strong>: text thickness(line width), if negative, the glyph is filled, by default(value is -1)<br><strong>wrap</strong>: if true, will auto wrap text to next line if text width &gt; image width, by default(value is true)<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>this image object self</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *draw_string(int x, int y, const std::string &amp;textstring, const image::Color &amp;color = image::COLOR_WHITE, float scale = 1, int thickness = -1,
                                bool wrap = true, int wrap_space = 4, const std::string &amp;font = &quot;&quot;)
</code></pre>
</blockquote>
<h4 id="draw_cross">draw_cross</h4>
<p>Draw cross on image</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>x</strong>: cross center point's coordinate x<br><strong>y</strong>: cross center point's coordinate y<br><strong>color</strong>: cross color @see image::Color<br><strong>size</strong>: how long the lines of the cross extend, by default(value is 5). So the line length is <code>2 * size + thickness</code><br><strong>thickness</strong>: cross thickness(line width), by default(value is 1)<br></td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *draw_cross(int x, int y, const image::Color &amp;color, int size = 5, int thickness = 1)
</code></pre>
</blockquote>
<h4 id="draw_arrow">draw_arrow</h4>
<p>Draw arrow on image</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>x0</strong>: start coordinate of the arrow x0<br><strong>y0</strong>: start coordinate of the arrow y0<br><strong>x1</strong>: end coordinate of the arrow x1<br><strong>y1</strong>: end coordinate of the arrow y1<br><strong>color</strong>: cross color @see image::Color<br><strong>thickness</strong>: cross thickness(line width), by default(value is 1)<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>this image object self</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *draw_arrow(int x0, int y0, int x1, int y1, const image::Color &amp;color, int thickness = 1)
</code></pre>
</blockquote>
<h4 id="draw_edges">draw_edges</h4>
<p>Draw edges on image</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>corners</strong>: edges, [[x0, y0], [x1, y1], [x2, y2], [x3, y3]]<br><strong>color</strong>: edges color @see image::Color<br><strong>size</strong>: the circle of radius size. TODO: support in the future<br><strong>thickness</strong>: edges thickness(line width), by default(value is 1)<br><strong>fill</strong>: if true, will fill edges, by default(value is false)<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>this image object self</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *draw_edges(std::vector&lt;std::vector&lt;int&gt;&gt; corners, const image::Color &amp;color, int size = 0, int thickness = 1, bool fill = false)
</code></pre>
</blockquote>
<h4 id="draw_keypoints">draw_keypoints</h4>
<p>Draw keypoints on image</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>keypoints</strong>: keypoints, [x1, y1, x2, y2...] or [x, y, rotation_andle_in_degrees, x2, y2, rotation_andle_in_degrees2](TODO: rotation_andle_in_degrees support in the future)<br><strong>color</strong>: keypoints color @see image::Color<br><strong>size</strong>: size of keypoints(radius)<br><strong>thickness</strong>: keypoints thickness(line width), by default(value is -1 means fill circle)<br><strong>line_thickness</strong>: line thickness, default 0 means not draw lines, &gt; 0 will draw lines connect points.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>this image object self</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *draw_keypoints(const std::vector&lt;int&gt; &amp;keypoints, const image::Color &amp;color, int size = 4, int thickness = -1, int line_thickness = 0)
</code></pre>
</blockquote>
<h4 id="resize">resize</h4>
<p>Resize image, will create a new resized image object</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>width</strong>: new width, if value is -1, will use height to calculate aspect ratio<br><strong>height</strong>: new height, if value is -1, will use width to calculate aspect ratio<br><strong>fit</strong>: fill, contain, cover, by default is fill<br><strong>method</strong>: resize method, by default is NEAREST<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Always return a new resized image object even size not change, So in C++ you should take care of the return value to avoid memory leak.<br>And it's better to judge whether the size has changed before calling this function to make the program more efficient.<br>e.g.<br>if img-&gt;width() != width</td>
  <td></td>
  <td>img-&gt;height() != height:<br>img = img-&gt;resize(width, height);</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *resize(int width, int height, image::Fit fit = image::Fit::FIT_FILL, image::ResizeMethod method = image::ResizeMethod::NEAREST)
</code></pre>
</blockquote>
<h4 id="affine">affine</h4>
<p>Affine transform image, will create a new transformed image object, need 3 points.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>src_points</strong>: three source points, [x1, y1, x2, y2, x3, y3]<br><strong>dst_points</strong>: three destination points, [x1, y1, x2, y2, x3, y3]<br><strong>width</strong>: new width, if value is -1, will use height to calculate aspect ratio<br><strong>height</strong>: new height, if value is -1, will use width to calculate aspect ratio<br><strong>method</strong>: resize method, by default is bilinear<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>new transformed image object</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *affine(std::vector&lt;int&gt; src_points, std::vector&lt;int&gt; dst_points, int width = -1, int height = -1, image::ResizeMethod method = image::ResizeMethod::BILINEAR)
</code></pre>
</blockquote>
<h4 id="perspective">perspective</h4>
<p>Perspective transform image, will create a new transformed image object, need 4 points.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>src_points</strong>: three source points, [x1, y1, x2, y2, x3, y3, x4, y4]<br><strong>dst_points</strong>: three destination points, [x1, y1, x2, y2, x3, y3, x4, y4]<br><strong>width</strong>: new width, if value is -1, will use height to calculate aspect ratio<br><strong>height</strong>: new height, if value is -1, will use width to calculate aspect ratio<br><strong>method</strong>: resize method, by default is bilinear<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>new transformed image object</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image* perspective(std::vector&lt;int&gt; src_points, std::vector&lt;int&gt; dst_points, int width = -1, int height = -1, image::ResizeMethod method = image::ResizeMethod::BILINEAR)
</code></pre>
</blockquote>
<h4 id="copy">copy</h4>
<p>Copy image, will create a new copied image object</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>new copied image object</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *copy()
</code></pre>
</blockquote>
<h4 id="crop">crop</h4>
<p>Crop image, will create a new cropped image object</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>x</strong>: left top corner of crop rectangle point's coordinate x<br><strong>y</strong>: left top corner of crop rectangle point's coordinate y<br><strong>w</strong>: crop rectangle width<br><strong>h</strong>: crop rectangle height<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>new cropped image object</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *crop(int x, int y, int w, int h)
</code></pre>
</blockquote>
<h4 id="rotate">rotate</h4>
<p>Rotate image, will create a new rotated image object</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>angle</strong>: anti-clock wise rotate angle, if angle is 90 or 270, and width or height is -1, will swap width and height, or will throw exception<br><strong>width</strong>: new width, if value is -1, will use height to calculate aspect ratio<br><strong>height</strong>: new height, if value is -1, will use width to calculate aspect ratio<br><strong>method</strong>: resize method, by default is bilinear<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>new rotated image object</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *rotate(float angle, int width = -1, int height = -1, image::ResizeMethod method = image::ResizeMethod::BILINEAR)
</code></pre>
</blockquote>
<h4 id="flip">flip</h4>
<p>Vertical flip image, and return a new image.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>dir</strong>: flip dir, see image.FlipDir, e.g. image.FlipDir.X is vertical flip.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>new flipped image.</td>
</tr>
<tr>
  <td><strong>throw</strong></td>
  <td>When arg error, will throw out err.Err exception.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *flip(const image::FlipDir dir)
</code></pre>
</blockquote>
<h4 id="mean_pool">mean_pool</h4>
<p>Finds the mean of x_div * y_div squares in the image and returns the modified image composed of the mean of each square.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>x_div</strong>: The width of the squares.<br><strong>y_div</strong>: The height of the squares.<br><strong>copy</strong>: Select whether to return a new image or modify the original image. default is false.<br>If true, returns a new image composed of the mean of each square; If false, returns the modified image composed of the mean of each square.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the image after the operation is completed.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *mean_pool(int x_div, int y_div, bool copy = false)
</code></pre>
</blockquote>
<h4 id="midpoint_pool">midpoint_pool</h4>
<p>Finds the midpoint of x_div * y_div squares in the image and returns the modified image composed of the mean of each square.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>x_div</strong>: The width of the squares.<br><strong>y_div</strong>: The height of the squares.<br><strong>bias</strong>: The bias of the midpoint. default is 0.5.<br>midpoint value is equal to (max * bias + min * (1 - bias))<br><strong>copy</strong>: Select whether to return a new image or modify the original image. default is false.<br>If true, returns a new image composed of the midpoint of each square; If false, returns the modified image composed of the midpoint of each square.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the image after the operation is completed.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *midpoint_pool(int x_div, int y_div, double bias = 0.5, bool copy = false)
</code></pre>
</blockquote>
<h4 id="compress">compress</h4>
<p>JPEG compresses the image in place, the same as to_jpeg functioin, it's recommend to use to_jpeg instead.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>quality</strong>: The quality of the compressed image. default is 95.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the compressed JPEG image</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *compress(int quality = 95)
</code></pre>
</blockquote>
<h4 id="clear">clear</h4>
<p>Sets all pixels in the image to zero</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>mask</strong>: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the image after the operation is completed.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *clear(image::Image *mask = nullptr)
</code></pre>
</blockquote>
<h4 id="mask_rectange">mask_rectange</h4>
<p>Zeros a rectangular part of the image. If no arguments are supplied this method zeros the center of the image.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>x</strong>: The x coordinate of the top left corner of the rectangle.<br><strong>y</strong>: The y coordinate of the top left corner of the rectangle.<br><strong>w</strong>: The width of the rectangle.<br><strong>h</strong>: The height of the rectangle.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the image after the operation is completed.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *mask_rectange(int x = -1, int y = -1, int w = -1, int h = -1)
</code></pre>
</blockquote>
<h4 id="mask_circle">mask_circle</h4>
<p>Zeros a circular part of the image. If no arguments are supplied this method zeros the center of the image.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>x</strong>: The x coordinate of the center of the circle.<br><strong>y</strong>: The y coordinate of the center of the circle.<br><strong>radius</strong>: The radius of the circle.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the image after the operation is completed.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *mask_circle(int x = -1, int y = -1, int radius = -1)
</code></pre>
</blockquote>
<h4 id="mask_ellipse">mask_ellipse</h4>
<p>Zeros a ellipse part of the image. If no arguments are supplied this method zeros the center of the image.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>x</strong>: The x coordinate of the center of the ellipse.<br><strong>y</strong>: The y coordinate of the center of the ellipse.<br><strong>radius_x</strong>: The radius of the ellipse in the x direction.<br><strong>radius_y</strong>: The radius of the ellipse in the y direction.<br><strong>rotation_angle_in_degrees</strong>: The rotation angle of the ellipse in degrees.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the image after the operation is completed.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *mask_ellipse(int x = -1, int y = -1, int radius_x = -1, int radius_y = -1, float rotation_angle_in_degrees = 0)
</code></pre>
</blockquote>
<h4 id="binary">binary</h4>
<p>Sets all pixels in the image to black or white depending on if the pixel is inside of a threshold in the threshold list thresholds or not.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>note</strong></td>
  <td>For GRAYSCALE format, Lmin and Lmax range is [0, 255]. For RGB888 format, Lmin and Lmax range is [0, 100].</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>thresholds</strong>: You can define multiple thresholds.<br>For GRAYSCALE format, you can use {{Lmin, Lmax}, ...} to define one or more thresholds.<br>For RGB888 format, you can use {{Lmin, Lmax, Amin, Amax, Bmin, Bmax}, ...} to define one or more thresholds.<br>Where the upper case L,A,B represent the L,A,B channels of the LAB image format, and min, max represent the minimum and maximum values of the corresponding channels.<br><strong>invert</strong>: If true, the thresholds will be inverted before the operation. default is false.<br><strong>zero</strong>: If zero is true, the image will be set the pixels within the threshold to 0, other pixels remain unchanged. If zero is false, the image will be set to black or white. default is false.<br><strong>mask</strong>: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br><strong>to_bitmap</strong>: If true, the image will be converted to a bitmap image before thresholding. default is false. TODO: support in the future<br><strong>copy</strong>: Select whether to return a new image or modify the original image. default is false.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the image after the operation is completed.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *binary(std::vector&lt;std::vector&lt;int&gt;&gt; thresholds = std::vector&lt;std::vector&lt;int&gt;&gt;(), bool invert = false, bool zero = false, image::Image *mask = nullptr, bool to_bitmap = false, bool copy = false)
</code></pre>
</blockquote>
<h4 id="invert">invert</h4>
<p>Inverts the image in place.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the image after the operation is completed</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *invert()
</code></pre>
</blockquote>
<h4 id="b_and">b_and</h4>
<p>Performs a bitwise and operation between the image and the other image.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>other</strong>: The other image should be an image and should be the same size as the image being operated on.        TODO: support path?<br><strong>mask</strong>: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the image after the operation is completed.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *b_and(image::Image *other, image::Image *mask = nullptr)
</code></pre>
</blockquote>
<h4 id="b_nand">b_nand</h4>
<p>Performs a bitwise nand operation between the image and the other image.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>other</strong>: The other image should be an image and should be the same size as the image being operated on.        TODO: support path?<br><strong>mask</strong>: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the image after the operation is completed.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *b_nand(image::Image *other, image::Image *mask = nullptr)
</code></pre>
</blockquote>
<h4 id="b_or">b_or</h4>
<p>Performs a bitwise or operation between the image and the other image.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>other</strong>: The other image should be an image and should be the same size as the image being operated on.        TODO: support path?<br><strong>mask</strong>: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the image after the operation is completed.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *b_or(image::Image *other, image::Image *mask = nullptr)
</code></pre>
</blockquote>
<h4 id="b_nor">b_nor</h4>
<p>Performs a bitwise nor operation between the image and the other image.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>other</strong>: The other image should be an image and should be the same size as the image being operated on.        TODO: support path?<br><strong>mask</strong>: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the image after the operation is completed.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *b_nor(image::Image *other, image::Image *mask = nullptr)
</code></pre>
</blockquote>
<h4 id="b_xor">b_xor</h4>
<p>Performs a bitwise xor operation between the image and the other image.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>other</strong>: The other image should be an image and should be the same size as the image being operated on.        TODO: support path?<br><strong>mask</strong>: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the image after the operation is completed.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *b_xor(image::Image *other, image::Image *mask = nullptr)
</code></pre>
</blockquote>
<h4 id="b_xnor">b_xnor</h4>
<p>Performs a bitwise xnor operation between the image and the other image.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>other</strong>: The other image should be an image and should be the same size as the image being operated on.        TODO: support path?<br><strong>mask</strong>: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the image after the operation is completed.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *b_xnor(image::Image *other, image::Image *mask = nullptr)
</code></pre>
</blockquote>
<h4 id="awb">awb</h4>
<p>Performs an auto white balance operation on the image. TODO: support in the future</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>max</strong>: if True uses the white-patch algorithm instead. default is false.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the image after the operation is completed.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *awb(bool max = false)
</code></pre>
</blockquote>
<h4 id="ccm">ccm</h4>
<p>Multiples the passed (3x3) or (4x3) floating-point color-correction-matrix with the image.\nnote: Grayscale format is not support.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>matrix</strong>: The color correction matrix to use. 3x3 or 4x3 matrix.<br>Weights may either be positive or negative, and the sum of each column in the 3x3 matrix should generally be 1.<br>example:<br>{<br>1, 0, 0,<br>0, 1, 0,<br>0, 0, 1,<br>}<br>Where the last row of the 4x3 matrix is an offset per color channel. If you add an offset you may wish to make the<br>weights sum to less than 1 to account for the offset.<br>example:<br>{<br>1, 0, 0,<br>0, 1, 0,<br>0, 0, 1,<br>0, 0, 0,<br>}<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the image after the operation is completed.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *ccm(std::vector&lt;float&gt; &amp;matrix)
</code></pre>
</blockquote>
<h4 id="gamma">gamma</h4>
<p>Quickly changes the image gamma, contrast, and brightness. Create a array whose size is usually 255,\nand use the parameters gamma, contrast, and brightness to calculate the value of the array, and then map the\nimage pixel value through the value of the array.\nThe calculation method for array is: array[array_idx] = (powf((array_idx / 255.0), (1 / gamma)) * contrast + brightness) * scale,\n<code>powf</code> is a function used to calculate floating point power.\n<code>array</code> is the array used for mapping.\n<code>array_idx</code> is the index of the array, the maximum value is determined according to the image format, usually 255.\n<code>scale</code> is a constant, the value is determined by the image format, usually 255.\nMapping method:\nAssume that a pixel value in the image is 128, then map the pixel value to the value of array[128]\nUsers can adjust the value of the array through the gamma, contrast, and brightness parameters.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>gamma</strong>: The contrast gamma greater than 1.0 makes the image darker in a non-linear manner while less than 1.0 makes the image brighter. default is 1.0.<br><strong>contrast</strong>: The contrast value greater than 1.0 makes the image brighter in a linear manner while less than 1.0 makes the image darker. default is 1.0.<br><strong>brightness</strong>: The brightness value greater than 0.0 makes the image brighter in a constant manner while less than 0.0 makes the image darker. default is 0.0.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the image after the operation is completed.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *gamma(double gamma = 1.0, double contrast = 1.0, double brightness = 0.0)
</code></pre>
</blockquote>
<h4 id="gamma_corr">gamma_corr</h4>
<p>Alias for Image.gamma.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>gamma</strong>: The contrast gamma greater than 1.0 makes the image darker in a non-linear manner while less than 1.0 makes the image brighter. default is 1.0.<br><strong>contrast</strong>: The contrast value greater than 1.0 makes the image brighter in a linear manner while less than 1.0 makes the image darker. default is 1.0.<br><strong>brightness</strong>: The brightness value greater than 0.0 makes the image brighter in a constant manner while less than 0.0 makes the image darker. default is 0.0.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the image after the operation is completed.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *gamma_corr(double gamma, double contrast = 1.0, double brightness = 0.0)
</code></pre>
</blockquote>
<h4 id="negate">negate</h4>
<p>Flips (numerically inverts) all pixels values in an image</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the image after the operation is completed.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *negate()
</code></pre>
</blockquote>
<h4 id="replace">replace</h4>
<p>Replaces all pixels in the image with the corresponding pixels in the other image.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>other</strong>: The other image should be an image and should be the same size as the image being operated on.<br><strong>hmirror</strong>: If true, the image will be horizontally mirrored before the operation. default is false.<br><strong>vflip</strong>: If true, the image will be vertically flipped before the operation. default is false.<br><strong>transpose</strong>: If true, the image can be used to rotate 90 degrees or 270 degrees.<br>hmirror = false, vflip = false, transpose = false, the image will not be rotated.<br>hmirror = false, vflip = true, transpose = true, the image will be rotated 90 degrees.<br>hmirror = true, vflip = true, transpose = false, the image will be rotated 180 degrees.<br>hmirror = true, vflip = false, transpose = true, the image will be rotated 270 degrees.<br><strong>mask</strong>: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the image after the operation is completed.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *replace(image::Image *other = nullptr, bool hmirror = false, bool vflip = false, bool transpose = false, image::Image *mask = nullptr)
</code></pre>
</blockquote>
<h4 id="set">set</h4>
<p>Alias for Image::replace.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>other</strong>: The other image should be an image and should be the same size as the image being operated on.<br><strong>hmirror</strong>: If true, the image will be horizontally mirrored before the operation. default is false.<br><strong>vflip</strong>: If true, the image will be vertically flipped before the operation. default is false.<br><strong>mask</strong>: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the image after the operation is completed.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *set(image::Image *other, bool hmirror = false, bool vflip = false, bool transpose = false, image::Image *mask = nullptr)
</code></pre>
</blockquote>
<h4 id="add">add</h4>
<p>Adds the other image to the image.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>other</strong>: The other image should be an image and should be the same size as the image being operated on.    TODO: support path?<br><strong>mask</strong>: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the image after the operation is completed.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *add(image::Image *other, image::Image *mask = nullptr)
</code></pre>
</blockquote>
<h4 id="sub">sub</h4>
<p>Subtracts the other image from the image.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>other</strong>: The other image should be an image and should be the same size as the image being operated on.    TODO: support path?<br><strong>reverse</strong>: If true, the image will be reversed before the operation. default is false.<br><strong>mask</strong>: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the image after the operation is completed.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *sub(image::Image *other, bool reverse = false, image::Image *mask = nullptr)
</code></pre>
</blockquote>
<h4 id="mul">mul</h4>
<p>Multiplies the image by the other image.\nNote: This method is meant for image blending and cannot multiply the pixels in the image by a scalar like 2.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>other</strong>: The other image should be an image and should be the same size as the image being operated on.    TODO: support path?<br><strong>invert</strong>: If true, the image will be change the multiplication operation from a<em>b to 1/((1/a)</em>(1/b)).<br>In particular, this lightens the image instead of darkening it (e.g. multiply versus burn operations). default is false.<br><strong>mask</strong>: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the image after the operation is completed.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *mul(image::Image *other, bool invert = false, image::Image *mask = nullptr)
</code></pre>
</blockquote>
<h4 id="div">div</h4>
<p>Divides the image by the other image.\nThis method is meant for image blending and cannot divide the pixels in the image by a scalar like 2.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>other</strong>: The other image should be an image and should be the same size as the image being operated on.    TODO: support path?<br><strong>invert</strong>: If true, the image will be change the division direction from a/b to b/a. default is false.<br><strong>mod</strong>: If true, the image will be change the division operation to the modulus operation. default is false.<br><strong>mask</strong>: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the image after the operation is completed.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *div(image::Image *other, bool invert = false, bool mod = false, image::Image *mask = nullptr)
</code></pre>
</blockquote>
<h4 id="min">min</h4>
<p>Caculate the minimum of each pixel in the image and the other image.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>other</strong>: The other image should be an image and should be the same size as the image being operated on.<br><strong>mask</strong>: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the image after the operation is completed.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *min(image::Image *other, image::Image *mask = nullptr)
</code></pre>
</blockquote>
<h4 id="max">max</h4>
<p>Caculate the maximum of each pixel in the image and the other image.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>other</strong>: The other image should be an image and should be the same size as the image being operated on.<br><strong>mask</strong>: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the image after the operation is completed.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *max(image::Image *other, image::Image *mask = nullptr)
</code></pre>
</blockquote>
<h4 id="difference">difference</h4>
<p>Caculate the absolute value of the difference between each pixel in the image and the other image.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>other</strong>: The other image should be an image and should be the same size as the image being operated on.<br><strong>mask</strong>: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the image after the operation is completed.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *difference(image::Image *other, image::Image *mask = nullptr)
</code></pre>
</blockquote>
<h4 id="blend">blend</h4>
<p>Blends the image with the other image.\nres = alpha * this_img / 256 + (256 - alpha) * other_img / 256</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>other</strong>: The other image should be an image and should be the same size as the image being operated on.<br><strong>alpha</strong>: The alpha value of the blend, the value range is [0, 256],default is 128.<br><strong>mask</strong>: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the image after the operation is completed.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *blend(image::Image *other, int alpha = 128, image::Image *mask = nullptr)
</code></pre>
</blockquote>
<h4 id="histeq">histeq</h4>
<p>Runs the histogram equalization algorithm on the image.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>adaptive</strong>: If true, an adaptive histogram equalization method will be run on the image instead which as generally better results than non-adaptive histogram qualization but a longer run time. default is false.<br><strong>clip_limit</strong>: Provides a way to limit the contrast of the adaptive histogram qualization. Use a small value for this, like 10, to produce good histogram equalized contrast limited images. default is -1.<br><strong>mask</strong>: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the image after the operation is completed.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *histeq(bool adaptive = false, int clip_limit = -1, image::Image *mask = nullptr)
</code></pre>
</blockquote>
<h4 id="mean">mean</h4>
<p>Standard mean blurring filter using a box filter.\nThe parameters offset and invert are valid when threshold is True.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>size</strong>: Kernel size. The actual kernel size is ((size * 2) + 1) * ((size * 2) + 1). Use 1(3x3 kernel), 2(5x5 kernel).<br><strong>threshold</strong>: If true, which will enable adaptive thresholding of the image which sets pixels to white or black based on a pixel’s brightness in relation to the brightness of the kernel of pixels around them.<br>default is false.<br><strong>offset</strong>: The larger the offset value, the lower brightness pixels on the original image will be set to white. default is 0.<br><strong>invert</strong>: If true, the image will be inverted before the operation. default is false.<br><strong>mask</strong>: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the image after the operation is completed.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *mean(int size, bool threshold = false, int offset = 0, bool invert = false, image::Image *mask = nullptr)
</code></pre>
</blockquote>
<h4 id="median">median</h4>
<p>Runs the median filter on the image. The median filter is the best filter for smoothing surfaces while preserving edges but it is very slow.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>size</strong>: Kernel size. The actual kernel size is ((size * 2) + 1) * ((size * 2) + 1). Use 1(3x3 kernel), 2(5x5 kernel).<br><strong>percentile</strong>: This parameter controls the percentile of the value used in the kernel. You can set this to 0 for a min filter, 0.25 for a lower quartile filter, 0.75 for an upper quartile filter, and 1.0 for a max filter. default is 0.5.<br><strong>threshold</strong>: If true, which will enable adaptive thresholding of the image which sets pixels to white or black based on a pixel’s brightness in relation to the brightness of the kernel of pixels around them.<br>default is false.<br><strong>offset</strong>: The larger the offset value, the lower brightness pixels on the original image will be set to white. default is 0.<br><strong>invert</strong>: If true, the image will be inverted before the operation. default is false.<br><strong>mask</strong>: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the image after the operation is completed.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *median(int size, double percentile = 0.5, bool threshold = false, int offset = 0, bool invert = false, image::Image *mask = nullptr)
</code></pre>
</blockquote>
<h4 id="mode">mode</h4>
<p>Runs the mode filter on the image by replacing each pixel with the mode of their neighbors.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>size</strong>: Kernel size. The actual kernel size is ((size * 2) + 1) * ((size * 2) + 1). Use 1(3x3 kernel), 2(5x5 kernel).<br><strong>threshold</strong>: If true, which will enable adaptive thresholding of the image which sets pixels to white or black based on a pixel’s brightness in relation to the brightness of the kernel of pixels around them.<br>default is false.<br><strong>offset</strong>: The larger the offset value, the lower brightness pixels on the original image will be set to white. default is 0.<br><strong>invert</strong>: If true, the image will be inverted before the operation. default is false.<br><strong>mask</strong>: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the image after the operation is completed.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *mode(int size, bool threshold = false, int offset = 0, bool invert = false, image::Image *mask = nullptr)
</code></pre>
</blockquote>
<h4 id="midpoint">midpoint</h4>
<p>Runs the midpoint filter on the image.This filter finds the midpoint (max * bias + min * (1 - bias)) of each pixel neighborhood in the image.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>size</strong>: Kernel size. The actual kernel size is ((size * 2) + 1) * ((size * 2) + 1). Use 1(3x3 kernel), 2(5x5 kernel).<br><strong>bias</strong>: The bias of the midpoint. default is 0.5.<br><strong>threshold</strong>: If true, which will enable adaptive thresholding of the image which sets pixels to white or black based on a pixel’s brightness in relation to the brightness of the kernel of pixels around them.<br>default is false.<br><strong>offset</strong>: The larger the offset value, the lower brightness pixels on the original image will be set to white. default is 0.<br><strong>invert</strong>: If true, the image will be inverted before the operation. default is false.<br><strong>mask</strong>: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the image after the operation is completed.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *midpoint(int size, double bias = 0.5, bool threshold = false, int offset = 0, bool invert = false, image::Image *mask = nullptr)
</code></pre>
</blockquote>
<h4 id="morph">morph</h4>
<p>Convolves the image by a filter kernel. This allows you to do general purpose convolutions on an image.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>size</strong>: Kernel size. The actual kernel size is ((size * 2) + 1) * ((size * 2) + 1). Use 1(3x3 kernel), 2(5x5 kernel).<br><strong>kernel</strong>: The kernel used for convolution. The kernel should be a list of lists of numbers. The kernel should be the same size as the actual kernel size.<br><strong>mul</strong>: This parameter is used to multiply the convolved pixel results. default is auto.<br><strong>add</strong>: This parameter is the value to be added to each convolution pixel result. default is 0.0.<br><strong>threshold</strong>: If true, which will enable adaptive thresholding of the image which sets pixels to white or black based on a pixel’s brightness in relation to the brightness of the kernel of pixels around them.<br>default is false.<br><strong>offset</strong>: The larger the offset value, the lower brightness pixels on the original image will be set to white. default is 0.<br><strong>invert</strong>: If true, the image will be inverted before the operation. default is false.<br><strong>mask</strong>: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the image after the operation is completed.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *morph(int size, std::vector&lt;int&gt; kernel, float mul = -1, float add = 0.0, bool threshold = false, int offset = 0, bool invert = false, image::Image *mask = nullptr)
</code></pre>
</blockquote>
<h4 id="gaussian">gaussian</h4>
<p>Convolves the image by a smoothing guassian kernel.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>size</strong>: Kernel size. The actual kernel size is ((size * 2) + 1) * ((size * 2) + 1). Use 1(3x3 kernel), 2(5x5 kernel).<br><strong>unsharp</strong>: If true, this method will perform an unsharp mask operation instead of gaussian filtering operation, this improves the clarity of image edges. default is false.<br><strong>mul</strong>: This parameter is used to multiply the convolved pixel results. default is auto.<br><strong>add</strong>: This parameter is the value to be added to each convolution pixel result. default is 0.0.<br><strong>threshold</strong>: If true, which will enable adaptive thresholding of the image which sets pixels to white or black based on a pixel’s brightness in relation to the brightness of the kernel of pixels around them.<br>default is false.<br><strong>offset</strong>: The larger the offset value, the lower brightness pixels on the original image will be set to white. default is 0.<br><strong>invert</strong>: If true, the image will be inverted before the operation. default is false.<br><strong>mask</strong>: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the image after the operation is completed.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *gaussian(int size, bool unsharp = false, float mul = -1, float add = 0.0, bool threshold = false, int offset = 0, bool invert = false, image::Image *mask = nullptr)
</code></pre>
</blockquote>
<h4 id="laplacian">laplacian</h4>
<p>Convolves the image by a edge detecting laplacian kernel.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>size</strong>: Kernel size. The actual kernel size is ((size * 2) + 1) * ((size * 2) + 1). Use 1(3x3 kernel), 2(5x5 kernel).<br><strong>sharpen</strong>: If True, this method will sharpen the image instead of an unthresholded edge detection image. Then increase the kernel size to improve image clarity. default is false.<br><strong>mul</strong>: This parameter is used to multiply the convolved pixel results. default is auto.<br><strong>add</strong>: This parameter is the value to be added to each convolution pixel result. default is 0.0.<br><strong>threshold</strong>: If true, which will enable adaptive thresholding of the image which sets pixels to white or black based on a pixel’s brightness in relation to the brightness of the kernel of pixels around them.<br>default is false.<br><strong>offset</strong>: The larger the offset value, the lower brightness pixels on the original image will be set to white. default is 0.<br><strong>invert</strong>: If true, the image will be inverted before the operation. default is false.<br><strong>mask</strong>: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the image after the operation is completed.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *laplacian(int size, bool sharpen = false, float mul = -1, float add = 0.0, bool threshold = false, int offset = 0, bool invert = false, image::Image *mask = nullptr)
</code></pre>
</blockquote>
<h4 id="bilateral">bilateral</h4>
<p>Convolves the image by a bilateral filter.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>size</strong>: Kernel size. The actual kernel size is ((size * 2) + 1) * ((size * 2) + 1). Use 1(3x3 kernel), 2(5x5 kernel).<br><strong>color_sigma</strong>: Controls how closely colors are matched using the bilateral filter. default is 0.1.<br><strong>space_sigma</strong>: Controls how closely pixels space-wise are blurred with each other. default is 1.<br><strong>threshold</strong>: If true, which will enable adaptive thresholding of the image which sets pixels to white or black based on a pixel’s brightness in relation to the brightness of the kernel of pixels around them.<br>default is false.<br><strong>offset</strong>: The larger the offset value, the lower brightness pixels on the original image will be set to white. default is 0.<br><strong>invert</strong>: If true, the image will be inverted before the operation. default is false.<br><strong>mask</strong>: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the image after the operation is completed.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *bilateral(int size, double color_sigma = 0.1, double space_sigma = 1, bool threshold = false, int offset = 0, bool invert = false, image::Image *mask = nullptr)
</code></pre>
</blockquote>
<h4 id="linpolar">linpolar</h4>
<p>Re-project’s and image from cartessian coordinates to linear polar coordinates.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>reverse</strong>: If true, the image will be reverse polar transformed. default is false.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the image after the operation is completed.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *linpolar(bool reverse = false)
</code></pre>
</blockquote>
<h4 id="logpolar">logpolar</h4>
<p>Re-project’s and image from cartessian coordinates to log polar coordinates.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>reverse</strong>: If true, the image will be reverse polar transformed. default is false.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the image after the operation is completed.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *logpolar(bool reverse = false)
</code></pre>
</blockquote>
<h4 id="lens_corr">lens_corr</h4>
<p>Performs a lens correction operation on the image. TODO: support in the future</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>strength</strong>: The strength of the lens correction. default is 1.8.<br><strong>zoom</strong>: The zoom of the lens correction. default is 1.0.<br><strong>x_corr</strong>: The x correction of the lens correction. default is 0.0.<br><strong>y_corr</strong>: The y correction of the lens correction. default is 0.0.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the image after the operation is completed.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *lens_corr(double strength = 1.8, double zoom = 1.0, double x_corr = 0.0, double y_corr = 0.0)
</code></pre>
</blockquote>
<h4 id="rotation_corr">rotation_corr</h4>
<p>Performs a rotation correction operation on the image. TODO: support in the future</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>x_rotation</strong>: The x rotation of the rotation correction. default is 0.0.<br><strong>y_rotation</strong>: The y rotation of the rotation correction. default is 0.0.<br><strong>z_rotation</strong>: The z rotation of the rotation correction. default is 0.0.<br><strong>x_translation</strong>: The x translation of the rotation correction. default is 0.0.<br><strong>y_translation</strong>: The y translation of the rotation correction. default is 0.0.<br><strong>zoom</strong>: The zoom of the rotation correction. default is 1.0.<br><strong>fov</strong>: The fov of the rotation correction. default is 60.0.<br><strong>corners</strong>: The corners of the rotation correction. default is None.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the image after the operation is completed.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *rotation_corr(double x_rotation = 0.0, double y_rotation = 0.0, double z_rotation = 0.0, double x_translation = 0.0, double y_translation = 0.0, double zoom = 1.0, double fov = 60.0, std::vector&lt;float&gt; corners = std::vector&lt;float&gt;())
</code></pre>
</blockquote>
<h4 id="get_histogram">get_histogram</h4>
<p>Computes the normalized histogram on all color channels and returns a image::Histogram object.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>note</strong></td>
  <td>For GRAYSCALE format, Lmin and Lmax range is [0, 255]. For RGB888 format, Lmin and Lmax range is [0, 100].</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>thresholds</strong>: You can define multiple thresholds.<br>For GRAYSCALE format, you can use {{Lmin, Lmax}, ...} to define one or more thresholds.<br>For RGB888 format, you can use {{Lmin, Lmax, Amin, Amax, Bmin, Bmax}, ...} to define one or more thresholds.<br>Where the upper case L,A,B represent the L,A,B channels of the LAB image format, and min, max represent the minimum and maximum values of the corresponding channels.<br><strong>invert</strong>: If true, the thresholds will be inverted before the operation. default is false.<br><strong>roi</strong>: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br><strong>bins</strong>: The number of bins to use for the histogram.<br>In GRAYSCALE format, setting range is [2, 256], default is 100.<br>In RGB888 format, setting range is [2, 100], default is 100.<br><strong>l_bins</strong>: The number of bins to use for the l channel of the histogram. Only valid in RGB888 format.<br>If an invalid value is set, bins will be used instead. The setting range is [2, 100], default is 100.<br><strong>a_bins</strong>: The number of bins to use for the a channel of the histogram.<br>Only valid in RGB888 format.The setting range is [2, 256],  default is 256.<br><strong>b_bins</strong>: The number of bins to use for the b channel of the histogram.<br>Only valid in RGB888 format. The setting range is [2, 256], default is 256.<br><strong>difference</strong>: difference may be set to an image object to cause this method to operate on the difference image between the current image and the difference image object.<br>default is None.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns image::Histogram object</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Histogram get_histogram(std::vector&lt;std::vector&lt;int&gt;&gt; thresholds = std::vector&lt;std::vector&lt;int&gt;&gt;(), bool invert = false, std::vector&lt;int&gt; roi = std::vector&lt;int&gt;(), int bins = -1, int l_bins = 100, int a_bins = 256, int b_bins = 256, image::Image *difference = nullptr)
</code></pre>
</blockquote>
<h4 id="get_statistics">get_statistics</h4>
<p>Gets the statistics of the image. TODO: support in the future</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>note</strong></td>
  <td>For GRAYSCALE format, Lmin and Lmax range is [0, 255]. For RGB888 format, Lmin and Lmax range is [0, 100].</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>thresholds</strong>: You can define multiple thresholds.<br>For GRAYSCALE format, you can use {{Lmin, Lmax}, ...} to define one or more thresholds.<br>For RGB888 format, you can use {{Lmin, Lmax, Amin, Amax, Bmin, Bmax}, ...} to define one or more thresholds.<br>Where the upper case L,A,B represent the L,A,B channels of the LAB image format, and min, max represent the minimum and maximum values of the corresponding channels.<br><strong>invert</strong>: If true, the image will be inverted before the operation. default is false.<br><strong>roi</strong>: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br><strong>bins</strong>: The number of bins to use for the statistics. default is -1.<br><strong>l_bins</strong>: The number of bins to use for the l channel of the statistics. default is -1.<br><strong>a_bins</strong>: The number of bins to use for the a channel of the statistics. default is -1.<br><strong>b_bins</strong>: The number of bins to use for the b channel of the statistics. default is -1.<br><strong>difference</strong>: The difference image to use for the statistics. default is None.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the statistics of the image</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Statistics get_statistics(std::vector&lt;std::vector&lt;int&gt;&gt; thresholds = std::vector&lt;std::vector&lt;int&gt;&gt;(), bool invert = false, std::vector&lt;int&gt; roi = std::vector&lt;int&gt;(), int bins = -1, int l_bins = -1, int a_bins = -1, int b_bins = -1, image::Image *difference = nullptr)
</code></pre>
</blockquote>
<h4 id="get_regression">get_regression</h4>
<p>Gets the regression of the image.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>note</strong></td>
  <td>For GRAYSCALE format, Lmin and Lmax range is [0, 255]. For RGB888 format, Lmin and Lmax range is [0, 100].</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>thresholds</strong>: You can define multiple thresholds.<br>For GRAYSCALE format, you can use {{Lmin, Lmax}, ...} to define one or more thresholds.<br>For RGB888 format, you can use {{Lmin, Lmax, Amin, Amax, Bmin, Bmax}, ...} to define one or more thresholds.<br>Where the upper case L,A,B represent the L,A,B channels of the LAB image format, and min, max represent the minimum and maximum values of the corresponding channels.<br><strong>invert</strong>: If true, the image will be inverted before the operation. default is false.<br><strong>roi</strong>: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br><strong>x_stride</strong>: The x stride to use for the regression. default is 2.<br><strong>y_stride</strong>: The y stride to use for the regression. default is 1.<br><strong>area_threshold</strong>: The area threshold to use for the regression. default is 10.<br><strong>pixels_threshold</strong>: The pixels threshold to use for the regression. default is 10.<br><strong>robust</strong>: If true, the regression will be robust. default is false.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the regression of the image</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">std::vector&lt;image::Line&gt; get_regression(std::vector&lt;std::vector&lt;int&gt;&gt; thresholds = std::vector&lt;std::vector&lt;int&gt;&gt;(), bool invert = false, std::vector&lt;int&gt; roi = std::vector&lt;int&gt;(), int x_stride = 2, int y_stride = 1, int area_threshold = 10, int pixels_threshold = 10, bool robust = false)
</code></pre>
</blockquote>
<h4 id="save">save</h4>
<p>Save image to file</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>path</strong>: file path<br><strong>quality</strong>: image quality, by default(value is 95), support jpeg and png format<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>error code, err::ERR_NONE is ok, other is error</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">err::Err save(const char *path, int quality = 95)
</code></pre>
</blockquote>
<h4 id="flood_fill">flood_fill</h4>
<p>Flood fills a region of the image starting from location x, y.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>x</strong>: The x coordinate of the seed point.<br><strong>y</strong>: The y coordinate of the seed point.<br><strong>seed_threshold</strong>: The seed_threshold value controls how different any pixel in the fill area may be from the original starting pixel. default is 0.05.<br><strong>floating_threshold</strong>: The floating_threshold value controls how different any pixel in the fill area may be from any neighbor pixels. default is 0.05.<br><strong>color</strong>: The color to fill the region with. default is white.<br><strong>invert</strong>: If true, the image will be inverted before the operation. default is false.<br><strong>clear_background</strong>: If true, the background will be cleared before the operation. default is false.<br><strong>mask</strong>: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None. FIXME: the mask image works abnormally<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the image after the operation is completed.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *flood_fill(int x, int y, float seed_threshold = 0.05, float floating_threshold = 0.05, image::Color color = image::COLOR_WHITE, bool invert = false, bool clear_background = false, image::Image *mask = nullptr)
</code></pre>
</blockquote>
<h4 id="erode">erode</h4>
<p>Erodes the image in place.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>size</strong>: Kernel size. The actual kernel size is ((size * 2) + 1) * ((size * 2) + 1). Use 1(3x3 kernel), 2(5x5 kernel).<br><strong>threshold</strong>: The number of pixels in the kernel that are not 0. If it is less than or equal to the threshold, set the center pixel to black. default is (kernel_size - 1).<br><strong>mask</strong>: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the image after the operation is completed.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *erode(int size, int threshold = -1, image::Image *mask = nullptr)
</code></pre>
</blockquote>
<h4 id="dilate">dilate</h4>
<p>Dilates the image in place.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>size</strong>: Kernel size. The actual kernel size is ((size * 2) + 1) * ((size * 2) + 1). Use 1(3x3 kernel), 2(5x5 kernel).<br><strong>threshold</strong>: The number of pixels in the kernel that are not 0. If it is greater than or equal to the threshold, set the center pixel to white. default is 0.<br><strong>mask</strong>: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the image after the operation is completed.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *dilate(int size, int threshold = 0, image::Image *mask = nullptr)
</code></pre>
</blockquote>
<h4 id="open">open</h4>
<p>Performs erosion and dilation on an image in order.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>size</strong>: Kernel size. The actual kernel size is ((size * 2) + 1) * ((size * 2) + 1). Use 1(3x3 kernel), 2(5x5 kernel).<br><strong>threshold</strong>: As the threshold for erosion and dilation, the actual threshold for erosion is (kernel_size - 1 - threshold), the actual threshold for dialation is threshold. default is 0.<br><strong>mask</strong>: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the image after the operation is completed.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *open(int size, int threshold = 0, image::Image *mask = nullptr)
</code></pre>
</blockquote>
<h4 id="close">close</h4>
<p>Performs dilation and erosion on an image in order.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>size</strong>: Kernel size. The actual kernel size is ((size * 2) + 1) * ((size * 2) + 1). Use 1(3x3 kernel), 2(5x5 kernel).<br><strong>threshold</strong>: As the threshold for erosion and dilation, the actual threshold for erosion is (kernel_size - 1 - threshold), the actual threshold for dialation is threshold. default is 0.<br><strong>mask</strong>: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the image after the operation is completed.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *close(int size, int threshold = 0, image::Image *mask = nullptr)
</code></pre>
</blockquote>
<h4 id="top_hat">top_hat</h4>
<p>Returns the image difference of the image and Image.open()’ed image.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>size</strong>: Kernel size. The actual kernel size is ((size * 2) + 1) * ((size * 2) + 1). Use 1(3x3 kernel), 2(5x5 kernel).<br><strong>threshold</strong>: As the threshold for open method. default is 0.<br><strong>mask</strong>: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the image after the operation is completed.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *top_hat(int size, int threshold = 0, image::Image *mask = nullptr)
</code></pre>
</blockquote>
<h4 id="black_hat">black_hat</h4>
<p>Returns the image difference of the image and Image.close()’ed image.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>size</strong>: Kernel size. The actual kernel size is ((size * 2) + 1) * ((size * 2) + 1). Use 1(3x3 kernel), 2(5x5 kernel).<br><strong>threshold</strong>: As the threshold for close method. default is 0.<br><strong>mask</strong>: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the image after the operation is completed.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image *black_hat(int size, int threshold = 0, image::Image *mask = nullptr)
</code></pre>
</blockquote>
<h4 id="find_blobs">find_blobs</h4>
<p>Finds all blobs in the image and returns a list of image.Blob class which describe each Blob.\nPlease see the image.Blob object more more information.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>note</strong></td>
  <td>For GRAYSCALE format, Lmin and Lmax range is [0, 255]. For RGB888 format, Lmin and Lmax range is [0, 100].</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>thresholds</strong>: You can define multiple thresholds.<br>For GRAYSCALE format, you can use {{Lmin, Lmax}, ...} to define one or more thresholds.<br>For RGB888 format, you can use {{Lmin, Lmax, Amin, Amax, Bmin, Bmax}, ...} to define one or more thresholds.<br>Where the upper case L,A,B represent the L,A,B channels of the LAB image format, and min, max represent the minimum and maximum values of the corresponding channels.<br><strong>invert</strong>: if true, will invert thresholds before find blobs, default is false<br><strong>roi</strong>: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br><strong>x_stride</strong>: x stride is the number of x pixels to skip when doing the hough transform. default is 2<br><strong>y_stride</strong>: y_stride is the number of y pixels to skip when doing the hough transform. default is 1<br><strong>area_threshold</strong>: area threshold, if the blob area is smaller than area_threshold, the blob is not returned, default is 10<br><strong>pixels_threshold</strong>: pixels threshold, if the blob pixels is smaller than area_threshold, the blob is not returned,, default is 10.<br>when x_stride and y_stride is equal to 1, pixels_threshold is equivalent to area_threshold<br><strong>merge</strong>: if True merges all not filtered out blobs whos bounding rectangles intersect each other. default is false<br><strong>margin</strong>: margin can be used to increase or decrease the size of the bounding rectangles for blobs during the intersection test.<br>For example, with a margin of 1 blobs whos bounding rectangles are 1 pixel away from each other will be merged. default is 0<br><strong>x_hist_bins_max</strong>: if set to non-zero populates a histogram buffer in each blob object with an x_histogram projection of all columns in the object. This value then sets the number of bins for that projection.<br><strong>y_hist_bins_max</strong>: if set to non-zero populates a histogram buffer in each blob object with an y_histogram projection of all rows in the object. This value then sets the number of bins for that projection.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Return the blob when found blobs, format is (blob1, blob2, ...), you can use blob class methods to do more operations.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">std::vector&lt;image::Blob&gt; find_blobs(std::vector&lt;std::vector&lt;int&gt;&gt; thresholds = std::vector&lt;std::vector&lt;int&gt;&gt;(), bool invert = false, std::vector&lt;int&gt; roi = std::vector&lt;int&gt;(), int x_stride = 2, int y_stride = 1, int area_threshold = 10, int pixels_threshold = 10, bool merge = false, int margin = 0, int x_hist_bins_max = 0, int y_hist_bins_max = 0)
</code></pre>
</blockquote>
<h4 id="find_lines">find_lines</h4>
<p>Find lines in image</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>roi</strong>: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br><strong>x_stride</strong>: x stride is the number of x pixels to skip when doing the hough transform. default is 2<br><strong>y_stride</strong>: y_stride is the number of y pixels to skip when doing the hough transform. default is 1<br><strong>threshold</strong>: threshold threshold controls what lines are detected from the hough transform. Only lines with a magnitude greater than or equal to threshold are returned.<br>The right value of threshold for your application is image dependent. default is 1000.<br><strong>theta_margin</strong>: theta_margin controls the merging of detected lines. default is 25.<br><strong>rho_margin</strong>: rho_margin controls the merging of detected lines. default is 25.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Return the line when found lines, format is (line1, line2, ...), you can use line class methods to do more operations</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">std::vector&lt;image::Line&gt; find_lines(std::vector&lt;int&gt; roi = std::vector&lt;int&gt;(), int x_stride = 2, int y_stride = 1, double threshold = 1000, double theta_margin = 25, double rho_margin = 25)
</code></pre>
</blockquote>
<h4 id="find_line_segments">find_line_segments</h4>
<p>Finds all line segments in the image.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>roi</strong>: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br><strong>merge_distance</strong>: The maximum distance between two lines to merge them. default is 0.<br><strong>max_theta_difference</strong>: The maximum difference between two lines to merge them. default is 15.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Return the line when found lines, format is (line1, line2, ...), you can use line class methods to do more operations</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">std::vector&lt;image::Line&gt; find_line_segments(std::vector&lt;int&gt; roi = std::vector&lt;int&gt;(), int merge_distance = 0, int max_theta_difference = 15)
</code></pre>
</blockquote>
<h4 id="search_line_path">search_line_path</h4>
<p>Search the path of line</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>threshold</strong>: Threshold for finding a line, the larger the value the more accurate the line is found<br><strong>merge_degree</strong>: Minimum angle difference required when merging multiple lines<br><strong>min_len_of_new_path</strong>: The minimum length of a new path, if the crossing length exceeds this value, it is considered a new path.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Return the line when found lines, format is (groupline1, groupline2, ...), you can use LineGroup class methods to do more operations</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">std::vector&lt;image::LineGroup&gt; search_line_path(int threshold = 30, int merge_degree = 10, int min_len_of_new_path = 10)
</code></pre>
</blockquote>
<h4 id="find_circles">find_circles</h4>
<p>Find circles in image</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>roi</strong>: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br><strong>x_stride</strong>: x stride is the number of x pixels to skip when doing the hough transform. default is 2<br><strong>y_stride</strong>: y_stride is the number of y pixels to skip when doing the hough transform. default is 1<br><strong>threshold</strong>: threshold controls what circles are detected from the hough transform. Only circles with a magnitude greater than or equal to threshold are returned.<br>The right value of threshold for your application is image dependent.<br><strong>x_margin</strong>: x_margin controls the merging of detected circles. Circles which are x_margin, y_margin, and r_margin pixels apart are merged. default is 10<br><strong>y_margin</strong>: y_margin controls the merging of detected circles. Circles which are x_margin, y_margin, and r_margin pixels apart are merged. default is 10<br><strong>r_margin</strong>: r_margin controls the merging of detected circles. Circles which are x_margin, y_margin, and r_margin pixels apart are merged. default is 10<br><strong>r_min</strong>: r_min controls the minimum circle radius detected. Increase this to speed up the algorithm. default is 2<br><strong>r_max</strong>: r_max controls the maximum circle radius detected. Decrease this to speed up the algorithm. default is min(roi.w / 2, roi.h / 2)<br><strong>r_step</strong>: r_step controls how to step the radius detection by. default is 2.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Return the circle when found circles, format is (circle1, circle2, ...), you can use circle class methods to do more operations</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">std::vector&lt;image::Circle&gt; find_circles(std::vector&lt;int&gt; roi = std::vector&lt;int&gt;(), int x_stride = 2, int y_stride = 1, int threshold = 2000, int x_margin = 10, int y_margin = 10, int r_margin = 10, int r_min = 2, int r_max = -1, int r_step = 2)
</code></pre>
</blockquote>
<h4 id="find_rects">find_rects</h4>
<p>Finds all rects in the image.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>roi</strong>: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br><strong>threshold</strong>: The threshold to use for the rects. default is 10000.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the rects of the image</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">std::vector&lt;image::Rect&gt; find_rects(std::vector&lt;int&gt; roi = std::vector&lt;int&gt;(), int threshold = 10000)
</code></pre>
</blockquote>
<h4 id="find_qrcodes">find_qrcodes</h4>
<p>Finds all qrcodes in the image.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>roi</strong>: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br><strong>decoder_type</strong>: Select the QR code decoding method. Choosing QRCODE_DECODER_TYPE_QUIRC allows for retrieving QR code version, ECC level, mask, data type, and other details,<br>though it may decode slower at lower resolutions. Opting for QRCODE_DECODER_TYPE_ZBAR enables faster decoding at lower resolutions but may slow down at higher resolutions,<br>providing only the QR code content and position information. default is QRCODE_DECODER_TYPE_ZBAR.<br>Choosing the QRCODE_DECODER_TYPE_ZXING option will use the ZXing library for decoding. Supports both QRCode and Datamatrix.<br>Can be used as an alternative to function find_datamatrices to decode Datamatrix codes.<br>If you find that find_datamatrices is not working well for your Datamatrix codes, you can try using this option instead.<br>Provides only the QR code/ datamatrix content and position information. default is QRCODE_DECODER_TYPE_ZXING.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the qrcodes / (and/or datamatrix for option ZXing) of the image</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">std::vector&lt;image::QRCode&gt; find_qrcodes(std::vector&lt;int&gt; roi = std::vector&lt;int&gt;(), image::QRCodeDecoderType decoder_type = image::QRCodeDecoderType::QRCODE_DECODER_TYPE_ZBAR)
</code></pre>
</blockquote>
<h4 id="find_apriltags">find_apriltags</h4>
<p>Finds all apriltags in the image.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>roi</strong>: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br><strong>families</strong>: The families to use for the apriltags. default is TAG36H11.<br><strong>fx</strong>: The camera X focal length in pixels, default is -1.<br><strong>fy</strong>: The camera Y focal length in pixels, default is -1.<br><strong>cx</strong>: The camera X center in pixels, default is image.width / 2.<br><strong>cy</strong>: The camera Y center in pixels, default is image.height / 2.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the apriltags of the image</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">std::vector&lt;image::AprilTag&gt; find_apriltags(std::vector&lt;int&gt; roi = std::vector&lt;int&gt;(), image::ApriltagFamilies families = image::ApriltagFamilies::TAG36H11, float fx = -1, float fy = -1, int cx = -1, int cy = -1)
</code></pre>
</blockquote>
<h4 id="find_datamatrices">find_datamatrices</h4>
<p>Finds all datamatrices in the image.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>roi</strong>: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br><strong>effort</strong>: Controls how much time to spend trying to find data matrix matches. default is 200.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the datamatrices of the image</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">std::vector&lt;image::DataMatrix&gt; find_datamatrices(std::vector&lt;int&gt; roi = std::vector&lt;int&gt;(), int effort = 200)
</code></pre>
</blockquote>
<h4 id="find_barcodes">find_barcodes</h4>
<p>Finds all barcodes in the image.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>roi</strong>: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the barcodes of the image</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">std::vector&lt;image::BarCode&gt; find_barcodes(std::vector&lt;int&gt; roi = std::vector&lt;int&gt;())
</code></pre>
</blockquote>
<h4 id="find_displacement">find_displacement</h4>
<p>Finds the displacement between the image and the template.    TODO: support in the future\nnote: this method must be used on power-of-2 image sizes</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>template_image</strong>: The template image.<br><strong>roi</strong>: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br><strong>template_roi</strong>: The region-of-interest rectangle (x, y, w, h) to work in. If not specified, it is equal to the image rectangle.<br><strong>logpolar</strong>: If true, it will instead find rotation and scale changes between the two images. default is false.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the displacement of the image</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Displacement find_displacement(image::Image &amp;template_image, std::vector&lt;int&gt; roi = std::vector&lt;int&gt;(), std::vector&lt;int&gt; template_roi = std::vector&lt;int&gt;(), bool logpolar = false)
</code></pre>
</blockquote>
<h4 id="find_template">find_template</h4>
<p>Finds the template in the image.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>template_image</strong>: The template image.<br><strong>threshold</strong>: Threshold is floating point number (0.0-1.0) where a higher threshold prevents false positives while lowering the detection rate while a lower threshold does the opposite.<br><strong>roi</strong>: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image. Only valid in SEARCH_EX mode.<br><strong>step</strong>: The step size to use for the template. default is 2. Only valid in SEARCH_EX mode<br><strong>search</strong>: The search method to use for the template. default is SEARCH_EX.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns a bounding box tuple (x, y, w, h) for the matching location otherwise None.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">std::vector&lt;int&gt; find_template(image::Image &amp;template_image, float threshold, std::vector&lt;int&gt; roi = std::vector&lt;int&gt;(), int step = 2, image::TemplateMatch search = image::TemplateMatch::SEARCH_EX)
</code></pre>
</blockquote>
<h4 id="find_features">find_features</h4>
<p>Finds the features in the image.  TODO: support in the future</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>cascade</strong>: The cascade to use for the features. default is CASCADE_FRONTALFACE_ALT.<br><strong>threshold</strong>: The threshold to use for the features. default is 0.5.<br><strong>scale</strong>: The scale to use for the features. default is 1.5.<br><strong>roi</strong>: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the features of the image</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">std::vector&lt;int&gt; find_features(int cascade, float threshold = 0.5, float scale = 1.5, std::vector&lt;int&gt; roi = std::vector&lt;int&gt;())
</code></pre>
</blockquote>
<h4 id="find_lbp">find_lbp</h4>
<p>Finds the lbp in the image. TODO: support in the future.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>roi</strong>: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the lbp of the image</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::LBPKeyPoint find_lbp(std::vector&lt;int&gt; roi = std::vector&lt;int&gt;())
</code></pre>
</blockquote>
<h4 id="find_keypoints">find_keypoints</h4>
<p>Finds the keypoints in the image. TODO: support in the future.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>roi</strong>: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br><strong>threshold</strong>: The threshold to use for the keypoints. default is 20.<br><strong>normalized</strong>: If true, the image will be normalized before the operation. default is false.<br><strong>scale_factor</strong>: The scale factor to use for the keypoints. default is 1.5.<br><strong>max_keypoints</strong>: The maximum number of keypoints to use for the keypoints. default is 100.<br><strong>corner_detector</strong>: The corner detector to use for the keypoints. default is CORNER_AGAST.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the keypoints of the image</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::ORBKeyPoint find_keypoints(std::vector&lt;int&gt; roi = std::vector&lt;int&gt;(), int threshold = 20, bool normalized = false, float scale_factor = 1.5, int max_keypoints = 100, image::CornerDetector corner_detector = image::CornerDetector::CORNER_AGAST)
</code></pre>
</blockquote>
<h4 id="find_edges">find_edges</h4>
<p>Finds the edges in the image.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>edge_type</strong>: The edge type to use for the edges. default is EDGE_CANNY.<br><strong>roi</strong>: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br><strong>threshold</strong>: The threshold to use for the edges. default is 20.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the edges of the image</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image* find_edges(image::EdgeDetector edge_type, std::vector&lt;int&gt; roi = std::vector&lt;int&gt;(), std::vector&lt;int&gt; threshold = std::vector&lt;int&gt;({100, 200}))
</code></pre>
</blockquote>
<h4 id="find_hog">find_hog</h4>
<p>Finds the hog in the image.   TODO: support in the future</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>roi</strong>: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br><strong>size</strong>: The size to use for the hog. default is 8.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the hog of the image</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Image* find_hog(std::vector&lt;int&gt; roi = std::vector&lt;int&gt;(), int size = 8)
</code></pre>
</blockquote>
<h4 id="match_lbp_descriptor">match_lbp_descriptor</h4>
<p>Matches the lbp descriptor of the image.  TODO: support in the future</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>desc1</strong>: The descriptor to use for the match.<br><strong>desc2</strong>: The descriptor to use for the match.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the match of the image</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int match_lbp_descriptor(image::LBPKeyPoint &amp;desc1, image::LBPKeyPoint &amp;desc2)
</code></pre>
</blockquote>
<h4 id="match_orb_descriptor">match_orb_descriptor</h4>
<p>Matches the orb descriptor of the image. TODO: support in the future</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>desc1</strong>: The descriptor to use for the match.<br><strong>desc2</strong>: The descriptor to use for the match.<br><strong>threshold</strong>: The threshold to use for the match. default is 95.<br><strong>filter_outliers</strong>: If true, the image will be filter_outliers before the operation. default is false.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the match of the image</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::KPTMatch match_orb_descriptor(image::ORBKeyPoint &amp;desc1, image::ORBKeyPoint &amp;desc2, int threshold = 95, bool filter_outliers = false)
</code></pre>
</blockquote>
<h4 id="resize_map_pos-2">resize_map_pos</h4>
<p>map point position or rectangle position from this image size to another image size(resize)</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>int</strong>: h_out target image height<br><strong>fit</strong>: resize method, see maix.image.Fit<br><strong>x</strong>: original point x, or rectagle left-top point's x<br><strong>y</strong>: original point y, or rectagle left-top point's y<br><strong>w</strong>: original rectagle width, can be -1 if not use this arg, default -1.<br><strong>h</strong>: original rectagle height, can be -1 if not use this arg, default -1.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>list type, [x, y] if map point, [x, y, w, h] if resize rectangle.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">std::vector&lt;int&gt; resize_map_pos(int w_out, int h_out, image::Fit fit, int x, int y, int w = -1, int h = -1)
</code></pre>
</blockquote>
<h3 id="Color">Color</h3>
<p>Color class</p>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">class Color
</code></pre>
</blockquote>
<h4 id="__init__">__init__</h4>
<p>Color constructor</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>alpha</strong>: alpha channel, value range: 0 ~ 1, 0 means transparent.<br></td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">Color(uint8_t ch1, uint8_t ch2 = 0, uint8_t ch3 = 0, float alpha = 0, image::Format format = image::FMT_GRAYSCALE)
</code></pre>
</blockquote>
<h4 id="r">r</h4>
<p>Color red channel</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>var</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
<tr>
  <td><strong>readonly</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">uint8_t r
</code></pre>
</blockquote>
<h4 id="g">g</h4>
<p>Color green channel</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>var</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
<tr>
  <td><strong>readonly</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">uint8_t g
</code></pre>
</blockquote>
<h4 id="b">b</h4>
<p>Color blue channel</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>var</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
<tr>
  <td><strong>readonly</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">uint8_t b
</code></pre>
</blockquote>
<h4 id="alpha">alpha</h4>
<p>Color alpha channel, value from 0.0 to 1.0, float value, 0 means transparent.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>var</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
<tr>
  <td><strong>readonly</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">float alpha
</code></pre>
</blockquote>
<h4 id="gray">gray</h4>
<p>Color gray channel</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>var</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
<tr>
  <td><strong>readonly</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">uint8_t gray
</code></pre>
</blockquote>
<h4 id="format-3">format</h4>
<p>Color format</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>var</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
<tr>
  <td><strong>readonly</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Format format
</code></pre>
</blockquote>
<h4 id="hex">hex</h4>
<p>Get color's hex value</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">uint32_t hex()
</code></pre>
</blockquote>
<h4 id="from_rgb">from_rgb</h4>
<p>Create Color object from RGB channels</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>True</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">static image::Color from_rgb(uint8_t r, uint8_t g, uint8_t b)
</code></pre>
</blockquote>
<h4 id="from_bgr">from_bgr</h4>
<p>Create Color object from BGR channels</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>True</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">static image::Color from_bgr(uint8_t b, uint8_t g, uint8_t r)
</code></pre>
</blockquote>
<h4 id="from_gray">from_gray</h4>
<p>Create Color object from gray channel</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>True</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">static image::Color from_gray(uint8_t gray)
</code></pre>
</blockquote>
<h4 id="from_rgba">from_rgba</h4>
<p>Create Color object from RGBA channels</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>alpha</strong>: alpha channel, float value, value range: 0 ~ 1<br></td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>True</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">static image::Color from_rgba(uint8_t r, uint8_t g, uint8_t b, float alpha)
</code></pre>
</blockquote>
<h4 id="from_bgra">from_bgra</h4>
<p>Create Color object from BGRA channels</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>alpha</strong>: alpha channel, float value, value range: 0 ~ 1<br></td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>True</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">static image::Color from_bgra(uint8_t b, uint8_t g, uint8_t r, float alpha)
</code></pre>
</blockquote>
<h4 id="from_hex">from_hex</h4>
<p>Create Color object from hex value</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>hex</strong>: hex value, e.g. 0x0000FF00, lower address if first channel<br><strong>format</strong>: color format, @see image::Format<br></td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>True</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">static image::Color from_hex(uint32_t hex, image::Format &amp;format)
</code></pre>
</blockquote>
<h4 id="to_format-2">to_format</h4>
<p>Convert Color format</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>format</strong>: format want to convert to, @see image::Format, only support RGB888, BGR888, RGBA8888, BGRA8888, GRAYSCALE.<br></td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">void to_format(const image::Format &amp;format)
</code></pre>
</blockquote>
<h4 id="to_format2">to_format2</h4>
<p>Convert color format and return a new Color object</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>format</strong>: format want to convert to, @see image::Format, only support RGB888, BGR888, RGBA8888, BGRA8888, GRAYSCALE.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>new Color object, you need to delete it manually in C++.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Color *to_format2(const image::Format &amp;format)
</code></pre>
</blockquote>
<h3 id="Size-2">Size</h3>
<p>Image size type</p>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">class Size
</code></pre>
</blockquote>
<h4 id="__init__-2">__init__</h4>
<p>Construct a new Size object</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>width</strong>: image width<br><strong>height</strong>: image height<br></td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">Size(int width = 0, int height = 0)
</code></pre>
</blockquote>
<h4 id="width-2">width</h4>
<p>width of size</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>width</strong>: set new width, if not set, only return current width<br></td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int width(int width = -1)
</code></pre>
</blockquote>
<h4 id="height-2">height</h4>
<p>height of size</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>height</strong>: set new height, if not set, only return current height<br></td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int height(int height = -1)
</code></pre>
</blockquote>
<h4 id="operator[]">operator[]</h4>
<p>Subscript operator</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>index</strong>: 0 for width, 1 for height<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>int&amp; width or height</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int &amp;operator[](int index)
</code></pre>
</blockquote>
<h4 id="__str__-2">__str__</h4>
<p>to string</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">std::string __str__()
</code></pre>
</blockquote>
<h3 id="Line">Line</h3>
<p>Line class</p>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">class Line
</code></pre>
</blockquote>
<h4 id="__init__-3">__init__</h4>
<p>Line constructor</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>x1</strong>: coordinate x1 of the straight line<br><strong>y1</strong>: coordinate y1 of the straight line<br><strong>x2</strong>: coordinate x2 of the straight line<br><strong>y2</strong>: coordinate y2 of the straight line<br><strong>magnitude</strong>: magnitude of the straight line after Hough transformation<br><strong>theta</strong>: angle of the straight line after Hough transformation<br><strong>rho</strong>: p-value of the straight line after Hough transformation<br></td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">Line(int x1, int y1, int x2, int y2, int magnitude = 0, int theta = 0, int rho = 0)
</code></pre>
</blockquote>
<h4 id="__getitem__">__getitem__</h4>
<p>Subscript operator</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>index</strong>: [0] get x1 of line<br>[1] get y1 of line<br>[2] get x2 of line<br>[3] get y2 of line<br>[4] get length of line<br>[5] get magnitude of the straight line after Hough transformation<br>[6] get angle of the straight line after Hough transformation (0-179 degrees)<br>[7] get p-value of the straight line after Hough transformation<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>int&amp;</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int &amp;__getitem__(int index)
</code></pre>
</blockquote>
<h4 id="x1">x1</h4>
<p>get x1 of line</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return x1 of the line, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int x1()
</code></pre>
</blockquote>
<h4 id="y1">y1</h4>
<p>get y1 of line</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return y1 of the line, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int y1()
</code></pre>
</blockquote>
<h4 id="x2">x2</h4>
<p>get x2 of line</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return x2 of the line, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int x2()
</code></pre>
</blockquote>
<h4 id="y2">y2</h4>
<p>get y2 of line</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return y2 of the line, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int y2()
</code></pre>
</blockquote>
<h4 id="length">length</h4>
<p>get length of line</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return length of the line, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int length()
</code></pre>
</blockquote>
<h4 id="magnitude">magnitude</h4>
<p>get magnitude of the straight line after Hough transformation</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return magnitude, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int magnitude()
</code></pre>
</blockquote>
<h4 id="theta">theta</h4>
<p>get angle of the straight line after Hough transformation (0-179 degrees)</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return angle, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int theta()
</code></pre>
</blockquote>
<h4 id="rho">rho</h4>
<p>get p-value of the straight line after Hough transformation</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return p-value, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int rho()
</code></pre>
</blockquote>
<h3 id="Rect">Rect</h3>
<p>Rect class</p>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">class Rect
</code></pre>
</blockquote>
<h4 id="__init__-4">__init__</h4>
<p>Rect constructor</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>corners</strong>: corners of rect<br><strong>x</strong>: coordinate x of the straight line<br><strong>y</strong>: coordinate y of the straight line<br><strong>w</strong>: coordinate w of the straight line<br><strong>h</strong>: coordinate h of the straight line<br><strong>magnitude</strong>: magnitude of the straight line after Hough transformation<br></td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">Rect(std::vector&lt;std::vector&lt;int&gt;&gt; &amp;corners, int x, int y, int w, int h, int magnitude = 0)
</code></pre>
</blockquote>
<h4 id="__getitem__-2">__getitem__</h4>
<p>Subscript operator</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>index</strong>: [0] get x of rect<br>[1] get y of rect<br>[2] get w of rect<br>[3] get h of rect<br>[4] get magnitude of the straight line after Hough transformation<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>int&amp;</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int &amp;__getitem__(int index)
</code></pre>
</blockquote>
<h4 id="corners">corners</h4>
<p>get corners of rect</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return the coordinate of the rect.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">std::vector&lt;std::vector&lt;int&gt;&gt; corners()
</code></pre>
</blockquote>
<h4 id="rect-2">rect</h4>
<p>get rectangle of rect</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return the rectangle of the rect. format is {x, y, w, h}, type is std::vector<int></td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">std::vector&lt;int&gt; rect()
</code></pre>
</blockquote>
<h4 id="x">x</h4>
<p>get x of rect</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return x of the rect, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int x()
</code></pre>
</blockquote>
<h4 id="y">y</h4>
<p>get y of rect</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return y of the rect, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int y()
</code></pre>
</blockquote>
<h4 id="w">w</h4>
<p>get w of rect</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return w of the rect, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int w()
</code></pre>
</blockquote>
<h4 id="h">h</h4>
<p>get h of rect</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return h of the rect, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int h()
</code></pre>
</blockquote>
<h4 id="magnitude-2">magnitude</h4>
<p>get the rectangle’s magnitude.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return magnitude, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int magnitude()
</code></pre>
</blockquote>
<h3 id="Circle">Circle</h3>
<p>circle class</p>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">class Circle
</code></pre>
</blockquote>
<h4 id="__init__-5">__init__</h4>
<p>Circle constructor</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>x</strong>: coordinate x of the circle<br><strong>y</strong>: coordinate y of the circle<br><strong>r</strong>: coordinate r of the circle<br><strong>magnitude</strong>: coordinate y2 of the straight line<br></td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">Circle(int x, int y, int r, int magnitude)
</code></pre>
</blockquote>
<h4 id="__getitem__-3">__getitem__</h4>
<p>Subscript operator</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>index</strong>: [0] get x of circle<br>[1] get y of circle<br>[2] get r of circle<br>[3] get magnitude of the circle after Hough transformation<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>int&amp;</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int &amp;__getitem__(int index)
</code></pre>
</blockquote>
<h4 id="x-2">x</h4>
<p>get x of circle</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return x of the circle, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int x()
</code></pre>
</blockquote>
<h4 id="y-2">y</h4>
<p>get y of circle</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return y of the circle, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int y()
</code></pre>
</blockquote>
<h4 id="r-2">r</h4>
<p>get r of circle</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return r of the circle, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int r()
</code></pre>
</blockquote>
<h4 id="magnitude-3">magnitude</h4>
<p>get magnitude of the circle after Hough transformation</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return magnitude, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int magnitude()
</code></pre>
</blockquote>
<h3 id="Blob">Blob</h3>
<p>Blob class</p>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">class Blob
</code></pre>
</blockquote>
<h4 id="__init__-6">__init__</h4>
<p>Blob constructor</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>rect</strong>: blob rect, type is std::vector<int><br><strong>corners</strong>: blob corners, type is std::vector&lt;std::vector<int>&gt;<br><strong>mini_corners</strong>: blob mini_corners, type is std::vector&lt;std::vector<int>&gt;<br><strong>cx</strong>: blob center x, type is float<br><strong>cy</strong>: blob center y, type is float<br><strong>pixels</strong>: blob pixels, type is int<br><strong>rotation</strong>: blob rotation, type is float<br><strong>code</strong>: blob code, type is int<br><strong>count</strong>: blob count, type is int<br><strong>perimeter</strong>: blob perimeter, type is int<br><strong>roundness</strong>: blob roundness, type is float<br><strong>x_hist_bins</strong>: blob x_hist_bins, type is std::vector<int><br><strong>y_hist_bins</strong>: blob y_hist_bins, type is std::vector<int><br></td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">Blob(std::vector&lt;int&gt; &amp;rect, std::vector&lt;std::vector&lt;int&gt;&gt; &amp;corners, std::vector&lt;std::vector&lt;int&gt;&gt; &amp;mini_corners,float cx, float cy, int pixels, float rotation, int code, int count, int perimeter, float roundness, std::vector&lt;int&gt; &amp;x_hist_bins, std::vector&lt;int&gt; &amp;y_hist_bins)
</code></pre>
</blockquote>
<h4 id="__getitem__-4">__getitem__</h4>
<p>Subscript operator</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>index</strong>: [0] Returns the blob’s bounding box x coordinate<br>[1] Returns the blob’s bounding box y coordinate<br>[2] Returns the blob’s bounding box w coordinate<br>[3] Returns the blob’s bounding box h coordinate<br>[4] Returns the number of pixels that are part of this blob<br>[5] Returns the centroid x position of the blob<br>[6] Returns the centroid y position of the blob<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>int&amp; width or height</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int &amp;__getitem__(int index)
</code></pre>
</blockquote>
<h4 id="corners-2">corners</h4>
<p>get blob corners</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns a list of 4 (x,y) tuples of the 4 corners of the object.<br>(x0, y0)___________(x1, y1)<br></td>
  <td></td>
  <td><br></td>
  <td></td>
  <td><br></td>
  <td></td>
  <td><br></td>
  <td>___________</td>
  <td><br>(x3, y3)           (x2, y2)<br>note: the order of corners may change</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">std::vector&lt;std::vector&lt;int&gt;&gt; corners()
</code></pre>
</blockquote>
<h4 id="mini_corners">mini_corners</h4>
<p>get blob mini corners</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns a list of 4 (x,y) tuples of the 4 corners than bound the min area rectangle of the blob.<br>(x0, y0)___________(x1, y1)<br></td>
  <td></td>
  <td><br></td>
  <td></td>
  <td><br></td>
  <td></td>
  <td><br></td>
  <td>___________</td>
  <td><br>(x3, y3)           (x2, y2)<br>note: the order of corners may change</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">std::vector&lt;std::vector&lt;int&gt;&gt; mini_corners()
</code></pre>
</blockquote>
<h4 id="rect-3">rect</h4>
<p>get blob rect</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the center coordinates and width and height of the rectangle. format is (x, y, w, h)<br>w<br>(x, y) ___________<br></td>
  <td></td>
  <td><br></td>
  <td></td>
  <td>h<br></td>
  <td></td>
  <td><br></td>
  <td>___________</td>
  <td></td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">std::vector&lt;int&gt; rect()
</code></pre>
</blockquote>
<h4 id="x-3">x</h4>
<p>get blob x of the upper left coordinate</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the x coordinate of the upper left corner of the rectangle.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int x()
</code></pre>
</blockquote>
<h4 id="y-3">y</h4>
<p>get blob y of the upper left coordinate</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the y coordinate of the upper left corner of the rectangle.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int y()
</code></pre>
</blockquote>
<h4 id="w-2">w</h4>
<p>get blob width</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the blob’s bounding box w coordinate</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int w()
</code></pre>
</blockquote>
<h4 id="h-2">h</h4>
<p>get blob height</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the blob’s bounding box h coordinate</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int h()
</code></pre>
</blockquote>
<h4 id="pixels">pixels</h4>
<p>get blob pixels</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the number of pixels that are part of this blob.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int pixels()
</code></pre>
</blockquote>
<h4 id="cx">cx</h4>
<p>get blob center x</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the centroid x position of the blob</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int cx()
</code></pre>
</blockquote>
<h4 id="cy">cy</h4>
<p>get blob center y</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the centroid y position of the blob</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int cy()
</code></pre>
</blockquote>
<h4 id="cxf">cxf</h4>
<p>get blob center x</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the centroid x position of the blob</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">float cxf()
</code></pre>
</blockquote>
<h4 id="cyf">cyf</h4>
<p>get blob center y</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the centroid y position of the blob</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">float cyf()
</code></pre>
</blockquote>
<h4 id="rotation">rotation</h4>
<p>get blob rotation</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the rotation of the blob in radians (float). If the blob is like a pencil or pen this value will be unique for 0-180 degrees.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">float rotation()
</code></pre>
</blockquote>
<h4 id="rotation_rad">rotation_rad</h4>
<p>get blob rotation_rad</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the rotation of the blob in radians</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">float rotation_rad()
</code></pre>
</blockquote>
<h4 id="rotation_deg">rotation_deg</h4>
<p>get blob rotation_deg</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the rotation of the blob in degrees.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int rotation_deg()
</code></pre>
</blockquote>
<h4 id="code">code</h4>
<p>get blob code</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns a 32-bit binary number with a bit set in it for each color threshold that’s part of this blob</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int code()
</code></pre>
</blockquote>
<h4 id="count">count</h4>
<p>get blob count</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the number of blobs merged into this blob.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int count()
</code></pre>
</blockquote>
<h4 id="perimeter">perimeter</h4>
<p>get blob merge_cnt</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the number of pixels on this blob’s perimeter.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int perimeter()
</code></pre>
</blockquote>
<h4 id="roundness">roundness</h4>
<p>get blob roundness</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns a value between 0 and 1 representing how round the object is</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">float roundness()
</code></pre>
</blockquote>
<h4 id="elongation">elongation</h4>
<p>get blob elongation</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>returnReturns</strong></td>
  <td>a value between 0 and 1 representing how long (not round) the object is</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">float elongation()
</code></pre>
</blockquote>
<h4 id="area">area</h4>
<p>get blob area</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the area of the bounding box around the blob</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int area()
</code></pre>
</blockquote>
<h4 id="density">density</h4>
<p>get blob density</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the density ratio of the blob</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">float density()
</code></pre>
</blockquote>
<h4 id="extent">extent</h4>
<p>Alias for blob.density()</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the density ratio of the blob</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">float extent()
</code></pre>
</blockquote>
<h4 id="compactness">compactness</h4>
<p>get blob compactness</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the compactness ratio of the blob</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">float compactness()
</code></pre>
</blockquote>
<h4 id="solidity">solidity</h4>
<p>get blob solidity</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the solidity ratio of the blob</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">float solidity()
</code></pre>
</blockquote>
<h4 id="convexity">convexity</h4>
<p>get blob convexity</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns a value between 0 and 1 representing how convex the object is</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">float convexity()
</code></pre>
</blockquote>
<h4 id="x_hist_bins">x_hist_bins</h4>
<p>get blob x_hist_bins</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the x_hist_bins of the blob</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">std::vector&lt;int&gt; x_hist_bins()
</code></pre>
</blockquote>
<h4 id="y_hist_bins">y_hist_bins</h4>
<p>get blob y_hist_bins</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the y_hist_bins of the blob</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">std::vector&lt;int&gt; y_hist_bins()
</code></pre>
</blockquote>
<h4 id="major_axis_line">major_axis_line</h4>
<p>get blob major_axis_line</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns a line tuple (x1, y1, x2, y2) of the minor axis of the blob.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">std::vector&lt;int&gt; major_axis_line()
</code></pre>
</blockquote>
<h4 id="minor_axis_line">minor_axis_line</h4>
<p>get blob minor_axis_line</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns a line tuple (x1, y1, x2, y2) of the minor axis of the blob.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">std::vector&lt;int&gt; minor_axis_line()
</code></pre>
</blockquote>
<h4 id="enclosing_circle">enclosing_circle</h4>
<p>get blob enclosing_circle</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns a circle tuple (x, y, r) of the circle that encloses the min area rectangle of a blob.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">std::vector&lt;int&gt; enclosing_circle()
</code></pre>
</blockquote>
<h4 id="enclosed_ellipse">enclosed_ellipse</h4>
<p>get blob enclosed_ellipse</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns an ellipse tuple (x, y, rx, ry, rotation) of the ellipse that fits inside of the min area rectangle of a blob.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">std::vector&lt;int&gt; enclosed_ellipse()
</code></pre>
</blockquote>
<h3 id="QRCode">QRCode</h3>
<p>QRCode class</p>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">class QRCode
</code></pre>
</blockquote>
<h4 id="__init__-7">__init__</h4>
<p>QRCode constructor</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>rect</strong>: rect of corners, type is std::vector<int><br><strong>corners</strong>: corners of QRCode<br><strong>payload</strong>: payload of the QRCode<br><strong>version</strong>: version of the QRCode<br><strong>ecc_level</strong>: ecc_level of the QRCode<br><strong>mask</strong>: mask of the QRCode<br><strong>data_type</strong>: data_type of the QRCode<br><strong>eci</strong>: eci of the QRCode<br></td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">QRCode(std::vector&lt;int&gt; &amp;rect, std::vector&lt;std::vector&lt;int&gt;&gt; &amp;corners, std::string &amp;payload, int version, int ecc_level, int mask, int data_type, int eci)
</code></pre>
</blockquote>
<h4 id="__getitem__-5">__getitem__</h4>
<p>Subscript operator</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>index</strong>: [0] Returns the qrcode’s bounding box x coordinate<br>[1] Returns the qrcode’s bounding box y coordinate<br>[2] Returns the qrcode’s bounding box w coordinate<br>[3] Returns the qrcode’s bounding box h coordinate<br>[4] Not support this index, try to use payload() method<br>[5] Returns the version of qrcode<br>[6] Returns the error correction level of qrcode<br>[7] Returns the mask of qrcode<br>[8] Returns the datatype of qrcode<br>[9] Returns the eci of qrcode<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>int&amp;</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int &amp;__getitem__(int index)
</code></pre>
</blockquote>
<h4 id="corners-3">corners</h4>
<p>get coordinate of QRCode</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return the coordinate of the QRCode.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">std::vector&lt;std::vector&lt;int&gt;&gt; corners()
</code></pre>
</blockquote>
<h4 id="rect-4">rect</h4>
<p>get rectangle of QRCode</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return the rectangle of the QRCode. format is {x, y, w, h}, type is std::vector<int></td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">std::vector&lt;int&gt; rect()
</code></pre>
</blockquote>
<h4 id="x-4">x</h4>
<p>get x of QRCode</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return x of the QRCode, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int x()
</code></pre>
</blockquote>
<h4 id="y-4">y</h4>
<p>get y of QRCode</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return y of the QRCode, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int y()
</code></pre>
</blockquote>
<h4 id="w-3">w</h4>
<p>get w of QRCode</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return w of the QRCode, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int w()
</code></pre>
</blockquote>
<h4 id="h-3">h</h4>
<p>get h of QRCode</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return h of the QRCode, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int h()
</code></pre>
</blockquote>
<h4 id="payload">payload</h4>
<p>get QRCode payload</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return area of the QRCode</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">std::string payload()
</code></pre>
</blockquote>
<h4 id="version">version</h4>
<p>get QRCode version</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return version of the QRCode</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int version()
</code></pre>
</blockquote>
<h4 id="ecc_level">ecc_level</h4>
<p>get QRCode error correction level</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return error correction level of the QRCode</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int ecc_level()
</code></pre>
</blockquote>
<h4 id="mask">mask</h4>
<p>get QRCode mask</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return mask of the QRCode</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int mask()
</code></pre>
</blockquote>
<h4 id="data_type">data_type</h4>
<p>get QRCode dataType</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return mask of the QRCode</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int data_type()
</code></pre>
</blockquote>
<h4 id="eci">eci</h4>
<p>get QRCode eci</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return data of the QRCode</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int eci()
</code></pre>
</blockquote>
<h4 id="is_numeric">is_numeric</h4>
<p>check QRCode is numeric</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return true if the result type of the QRCode is numeric</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">bool is_numeric()
</code></pre>
</blockquote>
<h4 id="is_alphanumeric">is_alphanumeric</h4>
<p>check QRCode is alphanumeric</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return true if the result type of the QRCode is alphanumeric</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">bool is_alphanumeric()
</code></pre>
</blockquote>
<h4 id="is_binary">is_binary</h4>
<p>check QRCode is binary</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return true if the result type of the QRCode is binary</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">bool is_binary()
</code></pre>
</blockquote>
<h4 id="is_kanji">is_kanji</h4>
<p>check QRCode is kanji</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return true if the result type of the QRCode is kanji</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">bool is_kanji()
</code></pre>
</blockquote>
<h3 id="AprilTag">AprilTag</h3>
<p>AprilTag class</p>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">class AprilTag
</code></pre>
</blockquote>
<h4 id="__init__-8">__init__</h4>
<p>AprilTag constructor</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>rect</strong>: Inlucdes the top-left corner and the width and height of the rectangle. format is {x, y, w, h}, type is std::vector<int><br><strong>corners</strong>: Includes the four corners of the rectangle. format is {{x0, y0}, {x1, y1}, {x2, y2}, {x3, y3}}, type is std::vector&lt;std::vector<int>&gt;<br><strong>id</strong>: The id of the AprilTag<br><strong>famliy</strong>: The family of the AprilTag<br><strong>centroid_x</strong>: The x coordinate of the center of the AprilTag<br><strong>centroid_y</strong>: The y coordinate of the center of the AprilTag<br><strong>rotation</strong>: The rotation of the AprilTag<br><strong>decision_margin</strong>: The decision_margin of the AprilTag<br><strong>hamming</strong>: The hamming of the AprilTag<br><strong>goodness</strong>: The goodness of the AprilTag<br><strong>x_translation</strong>: The x_translation of the AprilTag<br><strong>y_translation</strong>: The y_translation of the AprilTag<br><strong>z_translation</strong>: The z_translation of the AprilTag<br><strong>x_rotation</strong>: The x_rotation of the AprilTag<br><strong>y_rotation</strong>: The y_rotation of the AprilTag<br><strong>z_rotation</strong>: The z_rotation of the AprilTag<br></td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">AprilTag(std::vector&lt;int&gt; &amp;rect, std::vector&lt;std::vector&lt;int&gt;&gt; &amp;corners, int id, int famliy, float centroid_x, float centroid_y, float rotation, float decision_margin, int hamming, float goodness, float x_translation, float y_translation, float z_translation, float x_rotation, float y_rotation, float z_rotation)
</code></pre>
</blockquote>
<h4 id="__getitem__-6">__getitem__</h4>
<p>Subscript operator</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>index</strong>: [0] Returns the apriltag’s bounding box x coordinate<br>[1] Returns the apriltag’s bounding box y coordinate<br>[2] Returns the apriltag’s bounding box w coordinate<br>[3] Returns the apriltag’s bounding box h coordinate<br>[4] Returns the apriltag’s id<br>[5] Returns the apriltag’s family<br>[6] Not support<br>[7] Not support<br>[8] Not support<br>[9] Not support<br>[10] Returns the apriltag’s hamming<br>[11] Not support<br>[12] Not support<br>[13] Not support<br>[14] Not support<br>[15] Not support<br>[16] Not support<br>[17] Not support<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>int&amp;</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int &amp;__getitem__(int index)
</code></pre>
</blockquote>
<h4 id="corners-4">corners</h4>
<p>get coordinate of AprilTag</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return the coordinate of the AprilTag.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">std::vector&lt;std::vector&lt;int&gt;&gt; corners()
</code></pre>
</blockquote>
<h4 id="rect-5">rect</h4>
<p>get rectangle of AprilTag</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return the rectangle of the AprilTag. format is {x, y, w, h}, type is std::vector<int></td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">std::vector&lt;int&gt; rect()
</code></pre>
</blockquote>
<h4 id="x-5">x</h4>
<p>get x of AprilTag</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return x of the AprilTag, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int x()
</code></pre>
</blockquote>
<h4 id="y-5">y</h4>
<p>get y of AprilTag</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return y of the AprilTag, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int y()
</code></pre>
</blockquote>
<h4 id="w-4">w</h4>
<p>get w of AprilTag</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return w of the AprilTag, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int w()
</code></pre>
</blockquote>
<h4 id="h-4">h</h4>
<p>get h of AprilTag</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return h of the AprilTag, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int h()
</code></pre>
</blockquote>
<h4 id="id">id</h4>
<p>get id of AprilTag</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return id of the AprilTag, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int id()
</code></pre>
</blockquote>
<h4 id="family">family</h4>
<p>get family of AprilTag</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return family of the AprilTag, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int family()
</code></pre>
</blockquote>
<h4 id="cx-2">cx</h4>
<p>get cx of AprilTag</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return cx of the AprilTag, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int cx()
</code></pre>
</blockquote>
<h4 id="cxf-2">cxf</h4>
<p>get cxf of AprilTag</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return cxf of the AprilTag, type is float</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">float cxf()
</code></pre>
</blockquote>
<h4 id="cy-2">cy</h4>
<p>get cy of AprilTag</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return cy of the AprilTag, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int cy()
</code></pre>
</blockquote>
<h4 id="cyf-2">cyf</h4>
<p>get cyf of AprilTag</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return cyf of the AprilTag, type is float</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">float cyf()
</code></pre>
</blockquote>
<h4 id="rotation-2">rotation</h4>
<p>get rotation of AprilTag</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return rotation of the AprilTag, type is float</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">float rotation()
</code></pre>
</blockquote>
<h4 id="decision_margin">decision_margin</h4>
<p>Get decision_margin of AprilTag</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the quality of the apriltag match (0.0 - 1.0) where 1.0 is the best.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">float decision_margin()
</code></pre>
</blockquote>
<h4 id="hamming">hamming</h4>
<p>get hamming of AprilTag</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the number of accepted bit errors for this tag.<br>return 0, means 0 bit errors will be accepted.<br>1 is TAG25H7, means up to 1 bit error may be accepted<br>2 is TAG25H9, means up to 3 bit errors may be accepted<br>3 is TAG36H10, means up to 3 bit errors may be accepted<br>4 is TAG36H11, means up to 4 bit errors may be accepted<br>5 is ARTOOLKIT, means 0 bit errors will be accepted</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int hamming()
</code></pre>
</blockquote>
<h4 id="goodness">goodness</h4>
<p>get goodness of AprilTag</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return goodness of the AprilTag, type is float<br>Note: This value is always 0.0 for now.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">float goodness()
</code></pre>
</blockquote>
<h4 id="x_translation">x_translation</h4>
<p>get x_translation of AprilTag</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return x_translation of the AprilTag, type is float</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">float x_translation()
</code></pre>
</blockquote>
<h4 id="y_translation">y_translation</h4>
<p>get y_translation of AprilTag</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return y_translation of the AprilTag, type is float</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">float y_translation()
</code></pre>
</blockquote>
<h4 id="z_translation">z_translation</h4>
<p>get z_translation of AprilTag</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return z_translation of the AprilTag, type is float</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">float z_translation()
</code></pre>
</blockquote>
<h4 id="x_rotation">x_rotation</h4>
<p>get x_rotation of AprilTag</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return x_rotation of the AprilTag, type is float</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">float x_rotation()
</code></pre>
</blockquote>
<h4 id="y_rotation">y_rotation</h4>
<p>get y_rotation of AprilTag</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return y_rotation of the AprilTag, type is float</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">float y_rotation()
</code></pre>
</blockquote>
<h4 id="z_rotation">z_rotation</h4>
<p>get z_rotation of AprilTag</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return z_rotation of the AprilTag, type is float</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">float z_rotation()
</code></pre>
</blockquote>
<h3 id="DataMatrix">DataMatrix</h3>
<p>DataMatrix class</p>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">class DataMatrix
</code></pre>
</blockquote>
<h4 id="__init__-9">__init__</h4>
<p>DataMatrix constructor</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>rect</strong>: Inlucdes the top-left corner and the width and height of the rectangle. format is {x, y, w, h}, type is std::vector<int><br><strong>corners</strong>: Includes the four corners of the rectangle. format is {{x0, y0}, {x1, y1}, {x2, y2}, {x3, y3}}, type is std::vector&lt;std::vector<int>&gt;<br><strong>payload</strong>: The payload of the DataMatrix<br><strong>rotation</strong>: The rotation of the DataMatrix<br><strong>rows</strong>: The rows of the DataMatrix<br><strong>columns</strong>: The columns of the DataMatrix<br><strong>capacity</strong>: The capacity of the DataMatrix<br><strong>padding</strong>: The padding of the DataMatrix<br></td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">DataMatrix(std::vector&lt;int&gt; &amp;rect, std::vector&lt;std::vector&lt;int&gt;&gt; &amp;corners, std::string &amp;payload, float rotation, int rows, int columns, int capacity, int padding)
</code></pre>
</blockquote>
<h4 id="__getitem__-7">__getitem__</h4>
<p>Subscript operator</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>index</strong>: [0] get x of DataMatrix<br>[1] get y of DataMatrix<br>[2] get w of DataMatrix<br>[3] get h of DataMatrix<br>[4] Not support this index, try to use payload() method<br>[5] Not support this index, try to use rotation() method<br>[6] get rows of DataMatrix<br>[7] get columns of DataMatrix<br>[8] get capacity of DataMatrix<br>[9] get padding of DataMatrix<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>int&amp;</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int &amp;__getitem__(int index)
</code></pre>
</blockquote>
<h4 id="corners-5">corners</h4>
<p>get coordinate of DataMatrix</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return the coordinate of the DataMatrix.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">std::vector&lt;std::vector&lt;int&gt;&gt; corners()
</code></pre>
</blockquote>
<h4 id="rect-6">rect</h4>
<p>get rectangle of DataMatrix</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return the rectangle of the DataMatrix. format is {x, y, w, h}, type is std::vector<int></td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">std::vector&lt;int&gt; rect()
</code></pre>
</blockquote>
<h4 id="x-6">x</h4>
<p>get x of DataMatrix</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return x of the DataMatrix, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int x()
</code></pre>
</blockquote>
<h4 id="y-6">y</h4>
<p>get y of DataMatrix</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return y of the DataMatrix, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int y()
</code></pre>
</blockquote>
<h4 id="w-5">w</h4>
<p>get w of DataMatrix</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return w of the DataMatrix, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int w()
</code></pre>
</blockquote>
<h4 id="h-5">h</h4>
<p>get h of DataMatrix</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return h of the DataMatrix, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int h()
</code></pre>
</blockquote>
<h4 id="payload-2">payload</h4>
<p>get payload of DataMatrix</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return payload of the DataMatrix, type is std::string</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">std::string payload()
</code></pre>
</blockquote>
<h4 id="rotation-3">rotation</h4>
<p>get rotation of DataMatrix</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return rotation of the DataMatrix, type is float</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">float rotation()
</code></pre>
</blockquote>
<h4 id="rows">rows</h4>
<p>get rows of DataMatrix</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return rows of the DataMatrix, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int rows()
</code></pre>
</blockquote>
<h4 id="columns">columns</h4>
<p>get columns of DataMatrix</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return columns of the DataMatrix, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int columns()
</code></pre>
</blockquote>
<h4 id="capacity">capacity</h4>
<p>get capacity of DataMatrix</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>returns how many characters could fit in this data matrix, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int capacity()
</code></pre>
</blockquote>
<h4 id="padding">padding</h4>
<p>get padding of DataMatrix</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>returns how many unused characters are in this data matrix, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int padding()
</code></pre>
</blockquote>
<h3 id="BarCode">BarCode</h3>
<p>BarCode class</p>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">class BarCode
</code></pre>
</blockquote>
<h4 id="__init__-10">__init__</h4>
<p>BarCode constructor</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>rect</strong>: Inlucdes the top-left corner and the width and height of the rectangle. format is {x, y, w, h}, type is std::vector<int><br><strong>corners</strong>: Includes the four corners of the rectangle. format is {{x0, y0}, {x1, y1}, {x2, y2}, {x3, y3}}, type is std::vector&lt;std::vector<int>&gt;<br><strong>payload</strong>: The payload of the BarCode<br><strong>type</strong>: The type of the BarCode<br><strong>rotation</strong>: The rotation of the BarCode<br><strong>quality</strong>: The quality of the BarCode<br></td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">BarCode(std::vector&lt;int&gt; &amp;rect, std::vector&lt;std::vector&lt;int&gt;&gt; &amp;corners, std::string &amp;payload, int type, float rotation, int quality)
</code></pre>
</blockquote>
<h4 id="__getitem__-8">__getitem__</h4>
<p>Subscript operator</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>index</strong>: [0] get x of BarCode<br>[1] get y of BarCode<br>[2] get w of BarCode<br>[3] get h of BarCode<br>[4] Not support this index, try to use payload() method<br>[5] get type of BarCode<br>[6] Not support this index, try to use rotation() method<br>[7] get quality of BarCode<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>int&amp;</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int &amp;__getitem__(int index)
</code></pre>
</blockquote>
<h4 id="corners-6">corners</h4>
<p>get coordinate of BarCode</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return the coordinate of the BarCode.</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">std::vector&lt;std::vector&lt;int&gt;&gt; corners()
</code></pre>
</blockquote>
<h4 id="rect-7">rect</h4>
<p>get rectangle of BarCode</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return the rectangle of the BarCode. format is {x, y, w, h}, type is std::vector<int></td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">std::vector&lt;int&gt; rect()
</code></pre>
</blockquote>
<h4 id="x-7">x</h4>
<p>get x of BarCode</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return x of the BarCode, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int x()
</code></pre>
</blockquote>
<h4 id="y-7">y</h4>
<p>get y of BarCode</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return y of the BarCode, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int y()
</code></pre>
</blockquote>
<h4 id="w-6">w</h4>
<p>get w of BarCode</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return w of the BarCode, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int w()
</code></pre>
</blockquote>
<h4 id="h-6">h</h4>
<p>get h of BarCode</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return h of the BarCode, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int h()
</code></pre>
</blockquote>
<h4 id="payload-3">payload</h4>
<p>get payload of BarCode</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return payload of the BarCode, type is std::string</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">std::string payload()
</code></pre>
</blockquote>
<h4 id="type">type</h4>
<p>get type of BarCode</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return type of the BarCode, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int type()
</code></pre>
</blockquote>
<h4 id="rotation-4">rotation</h4>
<p>get rotation of BarCode</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return rotation of the BarCode, type is float. FIXME: always return 0.0</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">float rotation()
</code></pre>
</blockquote>
<h4 id="quality">quality</h4>
<p>get quality of BarCode</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return quality of the BarCode, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int quality()
</code></pre>
</blockquote>
<h3 id="Statistics">Statistics</h3>
<p>Statistics class</p>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">class Statistics
</code></pre>
</blockquote>
<h4 id="__init__-11">__init__</h4>
<p>Statistics constructor</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>format</strong>: The statistics source image format<br><strong>l_statistics</strong>: The statistics of the L channel. format is {mean, median, mode, std_dev, min, max, lq, uq}, type is std::vector<int><br><strong>a_statistics</strong>: The statistics of the A channel. format is {mean, median, mode, std_dev, min, max, lq, uq}, type is std::vector<int><br><strong>b_statistics</strong>: The statistics of the B channel. format is {mean, median, mode, std_dev, min, max, lq, uq}, type is std::vector<int><br></td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">Statistics(image::Format format, std::vector&lt;int&gt; &amp;l_statistics, std::vector&lt;int&gt; &amp;a_statistics, std::vector&lt;int&gt; &amp;b_statistics)
</code></pre>
</blockquote>
<h4 id="__getitem__-9">__getitem__</h4>
<p>Subscript operator</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>index</strong>: array index<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>int&amp;</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int &amp;__getitem__(int index)
</code></pre>
</blockquote>
<h4 id="format-4">format</h4>
<p>get format of Statistics source image</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return format of the Statistics source image, type is image::Format</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Format format()
</code></pre>
</blockquote>
<h4 id="l_mean">l_mean</h4>
<p>get L channel mean</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return L channel mean, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int l_mean()
</code></pre>
</blockquote>
<h4 id="l_median">l_median</h4>
<p>get L channel median</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return L channel median, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int l_median()
</code></pre>
</blockquote>
<h4 id="l_mode">l_mode</h4>
<p>get L channel mode</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return L channel mode, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int l_mode()
</code></pre>
</blockquote>
<h4 id="l_std_dev">l_std_dev</h4>
<p>get L channel std_dev</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return L channel std_dev, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int l_std_dev()
</code></pre>
</blockquote>
<h4 id="l_min">l_min</h4>
<p>get L channel min</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return L channel min, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int l_min()
</code></pre>
</blockquote>
<h4 id="l_max">l_max</h4>
<p>get L channel max</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return L channel max, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int l_max()
</code></pre>
</blockquote>
<h4 id="l_lq">l_lq</h4>
<p>get L channel lq</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return L channel lq, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int l_lq()
</code></pre>
</blockquote>
<h4 id="l_uq">l_uq</h4>
<p>get L channel uq</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return L channel uq, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int l_uq()
</code></pre>
</blockquote>
<h4 id="a_mean">a_mean</h4>
<p>get A channel mean</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return A channel mean, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int a_mean()
</code></pre>
</blockquote>
<h4 id="a_median">a_median</h4>
<p>get A channea median</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return A channel median, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int a_median()
</code></pre>
</blockquote>
<h4 id="a_mode">a_mode</h4>
<p>get A channel mode</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return A channel mode, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int a_mode()
</code></pre>
</blockquote>
<h4 id="a_std_dev">a_std_dev</h4>
<p>get A channel std_dev</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return A channel std_dev, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int a_std_dev()
</code></pre>
</blockquote>
<h4 id="a_min">a_min</h4>
<p>get A channel min</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return A channel min, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int a_min()
</code></pre>
</blockquote>
<h4 id="a_max">a_max</h4>
<p>get A channel max</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return A channel max, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int a_max()
</code></pre>
</blockquote>
<h4 id="a_lq">a_lq</h4>
<p>get A channel lq</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return A channel lq, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int a_lq()
</code></pre>
</blockquote>
<h4 id="a_uq">a_uq</h4>
<p>get A channel uq</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return A channel uq, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int a_uq()
</code></pre>
</blockquote>
<h4 id="b_mean">b_mean</h4>
<p>get B channel mean</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return B channel mean, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int b_mean()
</code></pre>
</blockquote>
<h4 id="b_median">b_median</h4>
<p>get B channea median</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return B channel median, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int b_median()
</code></pre>
</blockquote>
<h4 id="b_mode">b_mode</h4>
<p>get B channel mode</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return B channel mode, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int b_mode()
</code></pre>
</blockquote>
<h4 id="b_std_dev">b_std_dev</h4>
<p>get B channel std_dev</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return B channel std_dev, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int b_std_dev()
</code></pre>
</blockquote>
<h4 id="b_min">b_min</h4>
<p>get B channel min</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return B channel min, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int b_min()
</code></pre>
</blockquote>
<h4 id="b_max">b_max</h4>
<p>get B channel max</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return B channel max, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int b_max()
</code></pre>
</blockquote>
<h4 id="b_lq">b_lq</h4>
<p>get B channel lq</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return B channel lq, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int b_lq()
</code></pre>
</blockquote>
<h4 id="b_uq">b_uq</h4>
<p>get B channel uq</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return B channel uq, type is int</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int b_uq()
</code></pre>
</blockquote>
<h3 id="Displacement">Displacement</h3>
<p>Displacement class</p>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">class Displacement
</code></pre>
</blockquote>
<h4 id="__init__-12">__init__</h4>
<p>Displacement constructor</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>x_translation</strong>: The x_translation of the Displacement<br><strong>y_translation</strong>: The y_translation of the Displacement<br><strong>rotation</strong>: The rotation of the Displacement<br><strong>scale</strong>: The scale of the Displacement<br><strong>response</strong>: The response of the Displacement<br></td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">Displacement(float x_translation, float y_translation, float rotation, float scale, float response)
</code></pre>
</blockquote>
<h4 id="__getitem__-10">__getitem__</h4>
<p>Subscript operator</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>index</strong>: array index<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>int&amp;</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int &amp;__getitem__(int index)
</code></pre>
</blockquote>
<h4 id="x_translation-2">x_translation</h4>
<p>get x_translation of Displacement</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return x_translation of the Displacement, type is float</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">float x_translation()
</code></pre>
</blockquote>
<h4 id="y_translation-2">y_translation</h4>
<p>get y_translation of Displacement</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return y_translation of the Displacement, type is float</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">float y_translation()
</code></pre>
</blockquote>
<h4 id="rotation-5">rotation</h4>
<p>get rotation of Displacement</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return rotation of the Displacement, type is float</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">float rotation()
</code></pre>
</blockquote>
<h4 id="scale">scale</h4>
<p>get scale of Displacement</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return scale of the Displacement, type is float</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">float scale()
</code></pre>
</blockquote>
<h4 id="response">response</h4>
<p>get response of Displacement</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return response of the Displacement, type is float</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">float response()
</code></pre>
</blockquote>
<h3 id="Percentile">Percentile</h3>
<p>Percentile class</p>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">class Percentile
</code></pre>
</blockquote>
<h4 id="__init__-13">__init__</h4>
<p>Percentile constructor</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>l_value</strong>: for grayscale image, it is grayscale percentile value (between 0 and 255).<br>for rgb888 image, it is l channel percentile value of lab (between 0 and 100).<br><strong>a_value</strong>: for rgb888 image, it is a channel percentile value of lab format(between -128 and 127).<br><strong>b_value</strong>: for rgb888 image, it is b channel percentile value of lab format(between -128 and 127).<br></td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">Percentile(int l_value, int a_value = 0, int b_value = 0)
</code></pre>
</blockquote>
<h4 id="__getitem__-11">__getitem__</h4>
<p>Subscript operator</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int &amp;__getitem__(int index)
</code></pre>
</blockquote>
<h4 id="value">value</h4>
<p>Return the grayscale percentile value (between 0 and 255).</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>returns grayscale percentile value</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int value()
</code></pre>
</blockquote>
<h4 id="l_value">l_value</h4>
<p>Return the l channel percentile value of lab format (between 0 and 100).</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>returns l channel percentile value</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int l_value()
</code></pre>
</blockquote>
<h4 id="a_value">a_value</h4>
<p>Return the a channel percentile value of lab format (between -128 and 127).</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>returns a channel percentile value</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int a_value()
</code></pre>
</blockquote>
<h4 id="b_value">b_value</h4>
<p>Return the b channel percentile value of lab format (between -128 and 127).</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>returns b channel percentile value</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int b_value()
</code></pre>
</blockquote>
<h3 id="Threshold">Threshold</h3>
<p>Threshold class</p>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">class Threshold
</code></pre>
</blockquote>
<h4 id="__init__-14">__init__</h4>
<p>Threshold constructor</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>l_value</strong>: for grayscale image, it is grayscale threshold value (between 0 and 255).<br>for rgb888 image, it is l channel threshold value of lab (between 0 and 100).<br><strong>a_value</strong>: for rgb888 image, it is a channel threshold value of lab format(between -128 and 127).<br><strong>b_value</strong>: for rgb888 image, it is b channel threshold value of lab format(between -128 and 127).<br></td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">Threshold(int l_value, int a_value = 0, int b_value = 0)
</code></pre>
</blockquote>
<h4 id="__getitem__-12">__getitem__</h4>
<p>Subscript operator</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int &amp;__getitem__(int index)
</code></pre>
</blockquote>
<h4 id="value-2">value</h4>
<p>Return the grayscale threshold value (between 0 and 255).</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>returns grayscale threshold value</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int value()
</code></pre>
</blockquote>
<h4 id="l_value-2">l_value</h4>
<p>Return the l channel threshold value of lab format (between 0 and 100).</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>returns l channel percentile value</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int l_value()
</code></pre>
</blockquote>
<h4 id="a_value-2">a_value</h4>
<p>Return the a channel threshold value of lab format (between -128 and 127).</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>returns a channel percentile value</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int a_value()
</code></pre>
</blockquote>
<h4 id="b_value-2">b_value</h4>
<p>Return the b channel threshold value of lab format (between -128 and 127).</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>returns b channel percentile value</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int b_value()
</code></pre>
</blockquote>
<h3 id="Histogram">Histogram</h3>
<p>Histogram class</p>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">class Histogram
</code></pre>
</blockquote>
<h4 id="__init__-15">__init__</h4>
<p>Histogram constructor</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>l_value</strong>: for grayscale image, it is grayscale threshold value list (the range of element values in the list is 0 and 255).<br>for rgb888 image, it is l channel threshold value list of lab (the range of element values in the list is 0 and 100).<br><strong>a_value</strong>: for rgb888 image, it is a channel threshold value list of lab format(the range of element values in the list is -128 and 127).<br><strong>b_value</strong>: for rgb888 image, it is b channel threshold value list of lab format(the range of element values in the list is -128 and 127).<br><strong>format</strong>: format of the source image<br></td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">Histogram(std::vector&lt;float&gt; l_bin, std::vector&lt;float&gt; a_bin, std::vector&lt;float&gt; b_bin, image::Format format = image::Format::FMT_RGB888)
</code></pre>
</blockquote>
<h4 id="__getitem__-13">__getitem__</h4>
<p>Subscript operator</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int &amp;__getitem__(int index)
</code></pre>
</blockquote>
<h4 id="bins">bins</h4>
<p>Returns a list of floats for the grayscale histogram.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">std::vector&lt;float&gt; bins()
</code></pre>
</blockquote>
<h4 id="l_bins">l_bins</h4>
<p>Returns a list of floats for the RGB565 histogram LAB L channel.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">std::vector&lt;float&gt; l_bins()
</code></pre>
</blockquote>
<h4 id="a_bins">a_bins</h4>
<p>Returns a list of floats for the RGB565 histogram LAB A channel.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">std::vector&lt;float&gt; a_bins()
</code></pre>
</blockquote>
<h4 id="b_bins">b_bins</h4>
<p>Returns a list of floats for the RGB565 histogram LAB B channel.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">std::vector&lt;float&gt; b_bins()
</code></pre>
</blockquote>
<h4 id="get_percentile">get_percentile</h4>
<p>Computes the CDF of the histogram channels and returns a image::Percentile object</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>percentile</strong>: the values of the histogram at the passed in percentile (0.0 - 1.0) (float).<br>So, if you pass in 0.1 this method will tell you (going from left-to-right in the histogram)<br>what bin when summed into an accumulator caused the accumulator to cross 0.1. This is useful<br>to determine min (with 0.1) and max (with 0.9) of a color distribution without outlier effects<br>ruining your results for adaptive color tracking.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>image::Percentile object</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Percentile get_percentile(float percentile)
</code></pre>
</blockquote>
<h4 id="get_threshold">get_threshold</h4>
<p>Uses Otsu’s Method to compute the optimal threshold values that split the histogram into two halves for each channel of the histogram and returns a image::Threshold object.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>image::Threshold object</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Threshold get_threshold()
</code></pre>
</blockquote>
<h4 id="get_statistics-2">get_statistics</h4>
<p>Computes the mean, median, mode, standard deviation, min, max, lower quartile, and upper quartile of each color channel in the histogram and returns a image::Statistics object.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>image::Statistics object</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::Statistics get_statistics()
</code></pre>
</blockquote>
<h3 id="LBPKeyPoint">LBPKeyPoint</h3>
<p>LBPKeyPoint class</p>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">class LBPKeyPoint
</code></pre>
</blockquote>
<h4 id="__init__-16">__init__</h4>
<p>LBPKeyPoint constructor</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>data</strong>: The data of the LBPKeyPoint<br></td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">LBPKeyPoint(std::valarray&lt;uint8_t&gt; &amp;data)
</code></pre>
</blockquote>
<h3 id="KeyPoint">KeyPoint</h3>
<p>KeyPoint class</p>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">class KeyPoint
</code></pre>
</blockquote>
<h4 id="__init__-17">__init__</h4>
<p>KeyPoint constructor</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>x</strong>: The x of the KeyPoint<br><strong>y</strong>: The y of the KeyPoint<br><strong>score</strong>: The score of the KeyPoint<br><strong>octave</strong>: The octave of the KeyPoint<br><strong>angle</strong>: The angle of the KeyPoint<br><strong>matched</strong>: The matched of the KeyPoint<br><strong>desc</strong>: The desc of the KeyPoint<br></td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">KeyPoint(uint16_t x, uint16_t y, uint16_t score, uint16_t octave, uint16_t angle, uint16_t matched, std::vector&lt;uint8_t&gt; &amp;desc)
</code></pre>
</blockquote>
<h3 id="KPTMatch">KPTMatch</h3>
<p>KPTMatch class</p>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">class KPTMatch
</code></pre>
</blockquote>
<h4 id="__init__-18">__init__</h4>
<p>KPTMatch constructor</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>cx</strong>: The cx of the KPTMatch<br><strong>cy</strong>: The cy of the KPTMatch<br><strong>x</strong>: The x of the KPTMatch<br><strong>y</strong>: The y of the KPTMatch<br><strong>w</strong>: The w of the KPTMatch<br><strong>h</strong>: The h of the KPTMatch<br><strong>score</strong>: The score of the KPTMatch<br><strong>theta</strong>: The theta of the KPTMatch<br><strong>match</strong>: The match of the KPTMatch<br></td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">KPTMatch(int cx, int cy, int x, int y, int w, int h, int score, int theta, int match)
</code></pre>
</blockquote>
<h3 id="ORBKeyPoint">ORBKeyPoint</h3>
<p>ORBKeyPoint class</p>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">class ORBKeyPoint
</code></pre>
</blockquote>
<h4 id="__init__-19">__init__</h4>
<p>ORBKeyPoint constructor</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>data</strong>: The data of the ORBKeyPoint<br><strong>threshold</strong>: The threshold of the ORBKeyPoint<br><strong>normalized</strong>: The normalized of the ORBKeyPoint<br></td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">ORBKeyPoint(std::vector&lt;image::KeyPoint&gt; &amp;data, int threshold, bool normalized)
</code></pre>
</blockquote>
<h4 id="get_data">get_data</h4>
<p>get data of ORBKeyPoint</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return data of the ORBKeyPoint, type is std::vector<KeyPoint></td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">std::vector&lt;image::KeyPoint&gt; get_data()
</code></pre>
</blockquote>
<h3 id="HaarCascade">HaarCascade</h3>
<p>HaarCascade class</p>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">class HaarCascade
</code></pre>
</blockquote>
<h4 id="__init__-20">__init__</h4>
<p>HaarCascade constructor</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>data</strong>: The data of the HaarCascade<br><strong>threshold</strong>: The threshold of the HaarCascade<br><strong>normalized</strong>: The normalized of the HaarCascade<br></td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">HaarCascade()
</code></pre>
</blockquote>
<h3 id="LineGroup">LineGroup</h3>
<p>LineGroup class</p>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">class LineGroup
</code></pre>
</blockquote>
<h4 id="__init__-21">__init__</h4>
<p>LineGroup constructor</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>id</strong>: The id of line<br><strong>type</strong>: The line list type, @see image::LineType<br><strong>lines</strong>: The line list<br></td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">LineGroup(int id, image::LineType type, std::vector&lt;image::Line&gt; lines)
</code></pre>
</blockquote>
<h4 id="id-2">id</h4>
<p>Get the line id of group, first id is 0.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>return id</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">int id()
</code></pre>
</blockquote>
<h4 id="type-2">type</h4>
<p>Get the line type of group</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>returns line type. @see LineType</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">image::LineType type()
</code></pre>
</blockquote>
<h4 id="lines">lines</h4>
<p>Get a list of line</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>returns a list composed of Line objects</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">std::vector&lt;image::Line&gt; lines()
</code></pre>
</blockquote>
<h3 id="QRCodeDetector">QRCodeDetector</h3>
<p>QRCodeDetector class</p>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">class QRCodeDetector
</code></pre>
</blockquote>
<h4 id="__init__-22">__init__</h4>
<p>QRCodeDetector constructor.\nUse npu to accelerate the speed of QR code scanning, note that this object will occupy npu resources</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">QRCodeDetector()
</code></pre>
</blockquote>
<h4 id="detect">detect</h4>
<p>Finds all qrcodes in the image.</p>
<table>
<thead>
<tr>
  <th>item</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>type</strong></td>
  <td>func</td>
</tr>
<tr>
  <td><strong>param</strong></td>
  <td><strong>img</strong>: The image to find qrcodes.<br><strong>roi</strong>: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br><strong>decoder_type</strong>: Select the QR code decoding method. Choosing QRCODE_DECODER_TYPE_QUIRC allows for retrieving QR code version, ECC level, mask, data type, and other details,<br>though it may decode slower at lower resolutions. Opting for QRCODE_DECODER_TYPE_ZBAR enables faster decoding at lower resolutions but may slow down at higher resolutions,<br>providing only the QR code content and position information. default is QRCODE_DECODER_TYPE_ZBAR.<br></td>
</tr>
<tr>
  <td><strong>return</strong></td>
  <td>Returns the qrcodes of the image</td>
</tr>
<tr>
  <td><strong>static</strong></td>
  <td>False</td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ defination code:</p>

<pre class="language-cpp"><code class="language-cpp">std::vector&lt;image::QRCode&gt; detect(image::Image *img, std::vector&lt;int&gt; roi = std::vector&lt;int&gt;(), image::QRCodeDecoderType decoder_type = image::QRCodeDecoderType::QRCODE_DECODER_TYPE_ZBAR)
</code></pre>
</blockquote>

                        
                    </div>
                </div>
                <div id="previous_next">
                    <div id="previous">
                        
                        <a href="/maixcdk/api/maix/err.html">
                            <span class="icon"></span>
                            <span class="label">err</span>
                        </a>
                        
                    </div>
                    <div id="next">
                        
                        <a href="/maixcdk/api/maix/touchscreen.html">
                            <span class="label">touchscreen</span>
                            <span class="icon"></span>
                        </a>
                        
                    </div>
                </div>
                <div id="comments-container"></div>
            </div>
            <div id="toc_wrapper">
                <div id="toc">
                    <div id="toc_content">
                            
                    </div>
                </div>
            </div>
        </div>
    </div>
    <a id="to_top" href="#"></a>
    <div id="doc_footer">
        <div id="footer">
            <div id="footer_top">
                <ul>
<li><a>Links</a><ul><li><a target="_blank" href="https://wiki.sipeed.com">Sipeed Wiki</a></li>
<li><a target="_blank" href="https://www.sipeed.com">Sipeed Official</a></li>
<li><a target="_blank" href="https://maixhub.com/">MaixHub</a></li>
<li><a  href="/maixcdk/sitemap.xml">Site map</a></li>
<li><a target="_blank" href="https://github.com/neutree/teedoc">Generated by teedoc</a></li>
</ul>
</li>
<li><a>Source code</a><ul><li><a target="_blank" href="https://github.com/sipeed/maixpy">MaixPy source code</a></li>
<li><a target="_blank" href="https://github.com/sipeed/MaixCDK">MaixCDK source code</a></li>
<li><a target="_blank" href="https://github.com/sipeed/sipeed_wiki">Wiki source code</a></li>
<li><a target="_blank" href="https://github.com/sipeed">Open source projects</a></li>
</ul>
</li>
<li><a>Follow us</a><ul><li><a target="_blank" href="https://twitter.com/SipeedIO">twitter</a></li>
<li><a target="_blank" href="https://sipeed.taobao.com/">Taobao</a></li>
<li><a target="_blank" href="https://www.aliexpress.com/store/911876460">AliExpress</a></li>
<li><a target="_blank" href="https://github.com/sipeed">github</a></li>
<li><a><a>Wechat </a><img src='https://wiki.sipeed.com/static/image/wechat.png'></a>
</li>
</ul>
</li>
<li><a>Contact us</a><ul><li><a>Tel: +86 0755-27808509</a>
</li>
<li><a>Bussiness: support@sipeed.com</a>
</li>
<li><a>Addr: 深圳市宝安区新湖路4008号蘅芳科技办公大厦A座-2101C</a>
</li>
<li><a  href="https://wiki.sipeed.com/join_us.html">Join us</a></li>
</ul>
</li>
</ul>

            </div>
            <div id="footer_bottom">
                <ul>
<li><a target="_blank" href="https://www.sipeed.com">©2018-2023 深圳矽速科技有限公司</a></li>
<li><a target="_blank" href="https://beian.miit.gov.cn/#/Integrated/index">粤ICP备19015433号</a></li>
</ul>

            </div>
        </div>
    </div>
    
        <script src="/maixcdk/teedoc-plugin-markdown-parser/mermaid.min.js"></script>
    
        <script>mermaid.initialize({startOnLoad:true});</script>
    
        <script src="/maixcdk/static/js/theme_default/tocbot.min.js"></script>
    
        <script src="/maixcdk/static/js/theme_default/main.js"></script>
    
        <script src="/maixcdk/static/js/theme_default/viewer.min.js"></script>
    
        <script src="/maixcdk/static/css/theme_default/prism.min.js"></script>
    
        <script src="/maixcdk/static/js/search/search_main.js"></script>
    
        <script src="/maixcdk/static/js/custom.js"></script>
    
        <script src="/maixcdk/static/js/thumbs_up/main.js"></script>
    
</body>

</html>