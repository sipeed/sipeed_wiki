电容触摸屏适配
================================

.. contents:: 本文目录

本篇需要启动linux系统，所需用到的工具：

    - ts-lib

        + ts_test
        + ts_calibrate
    - evtest

在前文设备树中，我们就已经对i2c接口的电容触摸屏做了初始化，以下是进行电容触摸屏的调整与测试：

.. code-block:: bash

    ls /dev/input   # 查看是否存在input/event0
    
    # 若不存在，找到触摸模块并加载 
    insmod goodix.ko   
    # 如根文件系统未找到goodix.ko，请在linux源码的output目录下查找并放入根文件系统下

    # 若存在
    evtest /dev/input/event0  # 使用evtest测试输入的xy坐标数据
    
    # 直观的测试
    ts_test

    # 触摸校准工具
    ts_calibrate

但是 ts_calibrate 仅仅是将校准参数写到 /etc/pointcrl 文件中，适用于微调，tslib下的工具如 ts_test 将会读取此校准文件而表现的触摸正常；而 evtest 读取原始数据、littlevGL 程序调用 event0 的输入时，并未去解析该参数文件。同样也有一定可能是该触摸屏内置参数即为错误的，难以进行校准。

测试时，发现xy轴输出互相调换了，请添加或去掉 gt911节点下 的 *touchscreen-swapped-x-y* 属性

若是发现触摸屏输出跳动大，屏幕上有些地方检测不到输出，此处采取修改驱动的办法进行解决：通过 i2c 向 电容触摸芯片GT911 写入固定的参数(相当于重刷GT911的固件)；

.. code-block:: c
   :caption: linux/drivers/input/touchscreen/goodix.c

    // 找到一个加载模块时会调用到的函数 

    static void goodix_read_config(struct goodix_ts_data *ts)
    {
        u8 config[GOODIX_CONFIG_MAX_LENGTH];
        int error, i;

        error = goodix_i2c_read(ts->client, ts->chip->config_addr,
                                config, ts->chip->config_len);

    /* end of the code user added */

        u8 check_sum = 0;         //校验和

        /* 800*480屏使用 */
        u8 write2gt911[GOODIX_CONFIG_911_LENGTH] = {0x42, 0xe0, 0x01, 0x20, 0x03, 0x0a, 0x35, 0x00, 0x01, 0x08, 0x28, 0x08, 0x5a, 0x46, 0x03, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x1a, 0x1e, 0x14, 0x89, 0x2a, 0x09, 0x57, 0x5c, 0xb5, 0x06, 0x00, 0x00, 0x00, 0x02, 0x01, 0x1d, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x82, 0x94, 0xc5, 0x02, 0x07, 0x00, 0x00, 0x04, 0x96, 0x4a, 0x00, 0x85, 0x54, 0x00, 0x77, 0x5f, 0x00, 0x6a, 0x6c, 0x00, 0x5f, 0x7a, 0x00, 0x5f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x10, 0x12, 0x14, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0f, 0x10, 0x12, 0x16, 0x18, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x24, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x52, 0x00};

        /* 480*272屏使用 */
        u8 write2gt911[GOODIX_CONFIG_911_LENGTH] = {0x42, 0xe0, 0x01, 0x10, 0x01, 0x0a, 0x3d, 0x00, 0x02, 0x08, 0x28, 0x08, 0x64, 0x46, 0x03, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x1a, 0x1e, 0x14, 0x89, 0x2a, 0x09, 0xc8, 0xca, 0x40, 0x04, 0x00, 0x00, 0x00, 0x61, 0x02, 0x1d, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 0xfa, 0x94, 0xd5, 0xf4, 0x07, 0x00, 0x00, 0x04, 0x86, 0xa7, 0x00, 0x82, 0xb7, 0x00, 0x80, 0xc8, 0x00, 0x7d, 0xda, 0x00, 0x7c, 0xef, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x10, 0x12, 0x14, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0f, 0x10, 0x12, 0x16, 0x18, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x24, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x01};

        write2gt911[GOODIX_CONFIG_911_LENGTH - 1] = 0x01; //update flag
        for (i = 0; i < (GOODIX_CONFIG_911_LENGTH - 2); i++)    //校验和计算
            check_sum += write2gt911[i];
        write2gt911[184] = (~check_sum) + 1; //checksum

        error = goodix_i2c_write(ts->client, ts->chip->config_addr, write2gt911, GOODIX_CONFIG_911_LENGTH);

        dev_warn(&ts->client->dev,
                "updated the user defined config \n",
                error);
        /* Let the firmware reconfigure itself, so sleep for 10ms */
        usleep_range(10000, 11000);

        error = goodix_i2c_read(ts->client, ts->chip->config_addr,
                                config, ts->chip->config_len);
    

        for (i = 0; i < GOODIX_CONFIG_911_LENGTH; i++)
        {
            printk("Config Reg 0x%.4X : 0x%.2x,",
                i + 0x8047, config[i]);
        }
    /* end of the code user added */

    /* -----------略------------- */
    }

将此驱动编译成模块，使用 ``insmod`` 加载模块后作为修正屏幕参数所用，控制台将会输出gt911各寄存器的参数；修改完毕后使用 ``rmmod goodix.ko`` 卸载模块，重新加载正常的驱动。

若再测试时，发现xy轴输出互相调换了，请添加或去掉gt911节点下的 *touchscreen-swapped-x-y* 属性

.. admonition:: 交流与答疑

    对于本节内容，如有疑问，欢迎到 `模组使用交流帖 <http://bbs.lichee.pro/d/24-->`_ 提问或分享经验。
