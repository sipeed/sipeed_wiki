(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vue')) :
    typeof define === 'function' && define.amd ? define(['exports', 'vue'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.naive = {}, global.Vue));
})(this, (function (exports, vue) { 'use strict';

    let onceCbs = [];
    const paramsMap = new WeakMap();

    function flushOnceCallbacks() {
      onceCbs.forEach(cb => cb(...paramsMap.get(cb)));
      onceCbs = [];
    }

    function beforeNextFrameOnce(cb) {
      for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        params[_key - 1] = arguments[_key];
      }

      paramsMap.set(cb, params);
      if (onceCbs.includes(cb)) return;
      onceCbs.push(cb) === 1 && requestAnimationFrame(flushOnceCallbacks);
    }

    function getParentNode$1(node) {
      // document type
      if (node.nodeType === 9) {
        return null;
      }

      return node.parentNode;
    }

    function getScrollParent$1(node) {
      if (node === null) return null;
      const parentNode = getParentNode$1(node);

      if (parentNode === null) {
        return null;
      } // Document


      if (parentNode.nodeType === 9) {
        return document.documentElement;
      } // Element


      if (parentNode.nodeType === 1) {
        // Firefox want us to check `-x` and `-y` variations as well
        const {
          overflow,
          overflowX,
          overflowY
        } = getComputedStyle(parentNode);

        if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
          return parentNode;
        }
      }

      return getScrollParent$1(parentNode);
    }

    function unwrapElement(target) {
      if (typeof target === 'string') return document.querySelector(target);
      if (typeof target === 'function') return target();
      return target;
    }

    function happensIn(e, dataSetPropName) {
      let {
        target
      } = e;

      while (target) {
        if (target.dataset) {
          if (target.dataset[dataSetPropName] !== undefined) return true;
        }

        target = target.parentElement;
      }

      return false;
    }

    function getPreciseEventTarget(event) {
      return event.composedPath()[0] || null;
    }

    function parseResponsiveProp(reponsiveProp) {
      if (typeof reponsiveProp === "number") {
        return {
          '': reponsiveProp.toString()
        };
      }

      const params = {};
      reponsiveProp.split(/ +/).forEach(pairLiteral => {
        if (pairLiteral === '') return;
        const [prefix, value] = pairLiteral.split(':');

        if (value === undefined) {
          params[''] = prefix;
        } else {
          params[prefix] = value;
        }
      });
      return params;
    }

    function parseResponsivePropValue(reponsiveProp, activeKeyOrSize) {
      var _a;

      if (reponsiveProp === undefined || reponsiveProp === null) return undefined;
      const classObj = parseResponsiveProp(reponsiveProp);
      if (activeKeyOrSize === undefined) return classObj[''];

      if (typeof activeKeyOrSize === 'string') {
        return (_a = classObj[activeKeyOrSize]) !== null && _a !== void 0 ? _a : classObj[''];
      } else if (Array.isArray(activeKeyOrSize)) {
        for (let i = activeKeyOrSize.length - 1; i >= 0; --i) {
          const key = activeKeyOrSize[i];
          if (key in classObj) return classObj[key];
        }

        return classObj[''];
      } else {
        // Here we suppose all the keys are number formatted
        let activeValue = undefined;
        let activeKey = -1;
        Object.keys(classObj).forEach(key => {
          const keyAsNum = Number(key);

          if (!Number.isNaN(keyAsNum) && activeKeyOrSize >= keyAsNum && keyAsNum >= activeKey) {
            activeKey = keyAsNum;
            activeValue = classObj[key];
          }
        });
        return activeValue;
      }
    }

    function depx(value) {
      if (typeof value === 'string') {
        if (value.endsWith('px')) {
          return Number(value.slice(0, value.length - 2));
        }

        return Number(value);
      }

      return value;
    }

    function pxfy(value) {
      if (value === undefined || value === null) return undefined;
      if (typeof value === 'number') return `${value}px`;
      if (value.endsWith('px')) return value;
      return `${value}px`;
    }

    function getMargin(value, position) {
      const parts = value.trim().split(/\s+/g);
      const margin = {
        top: parts[0]
      };

      switch (parts.length) {
        case 1:
          margin.right = parts[0];
          margin.bottom = parts[0];
          margin.left = parts[0];
          break;

        case 2:
          margin.right = parts[1];
          margin.left = parts[1];
          margin.bottom = parts[0];
          break;

        case 3:
          margin.right = parts[1];
          margin.bottom = parts[2];
          margin.left = parts[1];
          break;

        case 4:
          margin.right = parts[1];
          margin.bottom = parts[2];
          margin.left = parts[3];
          break;

        default:
          throw new Error('[seemly/getMargin]:' + value + ' is not a valid value.');
      }

      if (position === undefined) return margin;
      return margin[position];
    }

    function getGap(value, orient) {
      const [rowGap, colGap] = value.split(' ');
      if (!orient) return {
        row: rowGap,
        col: colGap || rowGap
      };
      return orient === 'row' ? rowGap : colGap;
    }

    var colors = {
      black: '#000',
      silver: '#C0C0C0',
      gray: '#808080',
      white: '#FFF',
      maroon: '#800000',
      red: '#F00',
      purple: '#800080',
      fuchsia: '#F0F',
      green: '#008000',
      lime: '#0F0',
      olive: '#808000',
      yellow: '#FF0',
      navy: '#000080',
      blue: '#00F',
      teal: '#008080',
      aqua: '#0FF',
      transparent: '#0000'
    };

    // All the algorithms credit to https://stackoverflow.com/questions/36721830/convert-hsl-to-rgb-and-hex/54014428#54014428
    // original author: Kamil Kiełczewski

    /**
     * @param h 360
     * @param s 100
     * @param l 100
     * @returns [h, s, v] 360, 100, 100
     */
    function hsl2hsv(h, s, l) {
      s /= 100;
      l /= 100;
      const v = s * Math.min(l, 1 - l) + l;
      return [h, v ? (2 - 2 * l / v) * 100 : 0, v * 100];
    }
    /**
     * @param h 360
     * @param s 100
     * @param v 100
     * @returns [h, s, l] 360, 100, 100
     */

    function hsv2hsl(h, s, v) {
      s /= 100;
      v /= 100;
      const l = v - v * s / 2;
      const m = Math.min(l, 1 - l);
      return [h, m ? (v - l) / m * 100 : 0, l * 100];
    }
    /**
     * @param h 360
     * @param s 100
     * @param v 100
     * @returns [r, g, b] 255, 255, 255
     */

    function hsv2rgb(h, s, v) {
      s /= 100;
      v /= 100;

      let f = function (n) {
        let k = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (n + h / 60) % 6;
        return v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
      };

      return [f(5) * 255, f(3) * 255, f(1) * 255];
    }
    /**
     * @param r 255
     * @param g 255
     * @param b 255
     * @returns [360, 100, 100]
     */

    function rgb2hsv(r, g, b) {
      r /= 255;
      g /= 255;
      b /= 255;
      let v = Math.max(r, g, b),
          c = v - Math.min(r, g, b);
      let h = c && (v == r ? (g - b) / c : v == g ? 2 + (b - r) / c : 4 + (r - g) / c);
      return [60 * (h < 0 ? h + 6 : h), v && c / v * 100, v * 100];
    }
    /**
     * @param r 255
     * @param g 255
     * @param b 255
     * @returns [360, 100, 100]
     */

    function rgb2hsl(r, g, b) {
      r /= 255;
      g /= 255;
      b /= 255;
      let v = Math.max(r, g, b),
          c = v - Math.min(r, g, b),
          f = 1 - Math.abs(v + v - c - 1);
      let h = c && (v == r ? (g - b) / c : v == g ? 2 + (b - r) / c : 4 + (r - g) / c);
      return [60 * (h < 0 ? h + 6 : h), f ? c / f * 100 : 0, (v + v - c) * 50];
    }
    /**
     * @param h 360
     * @param s 100
     * @param l 100
     * @returns [255, 255, 255]
     */

    function hsl2rgb(h, s, l) {
      s /= 100;
      l /= 100;
      let a = s * Math.min(l, 1 - l);

      let f = function (n) {
        let k = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (n + h / 30) % 12;
        return l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
      };

      return [f(0) * 255, f(8) * 255, f(4) * 255];
    }

    const prefix$1 = '^\\s*';
    const suffix = '\\s*$';
    const percent = '\\s*((\\.\\d+)|(\\d+(\\.\\d*)?))%\\s*'; // 4 offset

    const float = '\\s*((\\.\\d+)|(\\d+(\\.\\d*)?))\\s*'; // 4 offset

    const hex = '([0-9A-Fa-f])';
    const dhex = '([0-9A-Fa-f]{2})';
    const hslRegex = new RegExp(`${prefix$1}hsl\\s*\\(${float},${percent},${percent}\\)${suffix}`);
    const hsvRegex = new RegExp(`${prefix$1}hsv\\s*\\(${float},${percent},${percent}\\)${suffix}`);
    const hslaRegex = new RegExp(`${prefix$1}hsla\\s*\\(${float},${percent},${percent},${float}\\)${suffix}`);
    const hsvaRegex = new RegExp(`${prefix$1}hsva\\s*\\(${float},${percent},${percent},${float}\\)${suffix}`);
    const rgbRegex = new RegExp(`${prefix$1}rgb\\s*\\(${float},${float},${float}\\)${suffix}`);
    const rgbaRegex = new RegExp(`${prefix$1}rgba\\s*\\(${float},${float},${float},${float}\\)${suffix}`);
    const sHexRegex = new RegExp(`${prefix$1}#${hex}${hex}${hex}${suffix}`);
    const hexRegex = new RegExp(`${prefix$1}#${dhex}${dhex}${dhex}${suffix}`);
    const sHexaRegex = new RegExp(`${prefix$1}#${hex}${hex}${hex}${hex}${suffix}`);
    const hexaRegex = new RegExp(`${prefix$1}#${dhex}${dhex}${dhex}${dhex}${suffix}`);

    function parseHex(value) {
      return parseInt(value, 16);
    }
    /**
     * Convert color string to hsla array
     * @param color format like hsl(180, 100%, 100%), hsla(180, 100%, 100%, 1)
     * @returns
     */


    function hsla(color) {
      try {
        let i;

        if (i = hslaRegex.exec(color)) {
          return [roundDeg(i[1]), roundPercent(i[5]), roundPercent(i[9]), roundAlpha(i[13])];
        } else if (i = hslRegex.exec(color)) {
          return [roundDeg(i[1]), roundPercent(i[5]), roundPercent(i[9]), 1];
        }

        throw new Error(`[seemly/hsla]: Invalid color value ${color}.`);
      } catch (e) {
        throw e;
      }
    }
    /**
     * Convert color string to hsva array
     * @param color format like hsv(180, 100%, 100%), hsva(180, 100%, 100%, 1)
     * @returns
     */

    function hsva(color) {
      try {
        let i;

        if (i = hsvaRegex.exec(color)) {
          return [roundDeg(i[1]), roundPercent(i[5]), roundPercent(i[9]), roundAlpha(i[13])];
        } else if (i = hsvRegex.exec(color)) {
          return [roundDeg(i[1]), roundPercent(i[5]), roundPercent(i[9]), 1];
        }

        throw new Error(`[seemly/hsva]: Invalid color value ${color}.`);
      } catch (e) {
        throw e;
      }
    }
    /**
     * Convert color string to rgba array.
     * @param color format like #000[0], #000000[00], rgb(0, 0, 0), rgba(0, 0, 0, 0) and basic color keywords https://www.w3.org/TR/css-color-3/#html4 and transparent
     * @returns
     */

    function rgba(color) {
      try {
        let i;

        if (i = hexRegex.exec(color)) {
          return [parseHex(i[1]), parseHex(i[2]), parseHex(i[3]), 1];
        } else if (i = rgbRegex.exec(color)) {
          return [roundChannel(i[1]), roundChannel(i[5]), roundChannel(i[9]), 1];
        } else if (i = rgbaRegex.exec(color)) {
          return [roundChannel(i[1]), roundChannel(i[5]), roundChannel(i[9]), roundAlpha(i[13])];
        } else if (i = sHexRegex.exec(color)) {
          return [parseHex(i[1] + i[1]), parseHex(i[2] + i[2]), parseHex(i[3] + i[3]), 1];
        } else if (i = hexaRegex.exec(color)) {
          return [parseHex(i[1]), parseHex(i[2]), parseHex(i[3]), roundAlpha(parseHex(i[4]) / 255)];
        } else if (i = sHexaRegex.exec(color)) {
          return [parseHex(i[1] + i[1]), parseHex(i[2] + i[2]), parseHex(i[3] + i[3]), roundAlpha(parseHex(i[4] + i[4]) / 255)];
        } else if (color in colors) {
          return rgba(colors[color]);
        }

        throw new Error(`[seemly/rgba]: Invalid color value ${color}.`);
      } catch (e) {
        throw e;
      }
    }

    function normalizeAlpha$1(alphaValue) {
      return alphaValue > 1 ? 1 : alphaValue < 0 ? 0 : alphaValue;
    }

    function stringifyRgb(r, g, b) {
      return `rgb(${roundChannel(r)}, ${roundChannel(g)}, ${roundChannel(b)})`;
    }

    function stringifyRgba(r, g, b, a) {
      return `rgba(${roundChannel(r)}, ${roundChannel(g)}, ${roundChannel(b)}, ${normalizeAlpha$1(a)})`;
    }

    function compositeChannel(v1, a1, v2, a2, a) {
      return roundChannel((v1 * a1 * (1 - a2) + v2 * a2) / a);
    }

    function composite(background, overlay) {
      if (!Array.isArray(background)) background = rgba(background);
      if (!Array.isArray(overlay)) overlay = rgba(overlay);
      const a1 = background[3];
      const a2 = overlay[3];
      const alpha = roundAlpha(a1 + a2 - a1 * a2);
      return stringifyRgba(compositeChannel(background[0], a1, overlay[0], a2, alpha), compositeChannel(background[1], a1, overlay[1], a2, alpha), compositeChannel(background[2], a1, overlay[2], a2, alpha), alpha);
    }
    function changeColor(base, options) {
      const [r, g, b, a = 1] = Array.isArray(base) ? base : rgba(base);

      if (options.alpha) {
        return stringifyRgba(r, g, b, options.alpha);
      }

      return stringifyRgba(r, g, b, a);
    }
    function scaleColor(base, options) {
      const [r, g, b, a = 1] = Array.isArray(base) ? base : rgba(base);
      const {
        lightness = 1,
        alpha = 1
      } = options;
      return toRgbaString([r * lightness, g * lightness, b * lightness, a * alpha]);
    }
    function roundAlpha(value) {
      const v = Math.round(Number(value) * 100) / 100;
      if (v > 1) return 1;
      if (v < 0) return 0;
      return v;
    }
    function roundDeg(value) {
      const v = Math.round(Number(value));
      if (v >= 360) return 0;
      if (v < 0) return 0;
      return v;
    }
    function roundChannel(value) {
      const v = Math.round(Number(value));
      if (v > 255) return 255;
      if (v < 0) return 0;
      return v;
    }
    function roundPercent(value) {
      const v = Math.round(Number(value));
      if (v > 100) return 100;
      if (v < 0) return 0;
      return v;
    }
    function toRgbString(base) {
      const [r, g, b] = Array.isArray(base) ? base : rgba(base);
      return stringifyRgb(r, g, b);
    }
    function toRgbaString(base) {
      const [r, g, b] = base;

      if (3 in base) {
        return `rgba(${roundChannel(r)}, ${roundChannel(g)}, ${roundChannel(b)}, ${roundAlpha(base[3])})`;
      }

      return `rgba(${roundChannel(r)}, ${roundChannel(g)}, ${roundChannel(b)}, 1)`;
    }
    function toHsvString(base) {
      return `hsv(${roundDeg(base[0])}, ${roundPercent(base[1])}%, ${roundPercent(base[2])}%)`;
    }
    function toHsvaString(base) {
      const [h, s, v] = base;

      if (3 in base) {
        return `hsva(${roundDeg(h)}, ${roundPercent(s)}%, ${roundPercent(v)}%, ${roundAlpha(base[3])})`;
      }

      return `hsva(${roundDeg(h)}, ${roundPercent(s)}%, ${roundPercent(v)}%, 1)`;
    }
    function toHslString(base) {
      return `hsl(${roundDeg(base[0])}, ${roundPercent(base[1])}%, ${roundPercent(base[2])}%)`;
    }
    function toHslaString(base) {
      const [h, s, l] = base;

      if (3 in base) {
        return `hsla(${roundDeg(h)}, ${roundPercent(s)}%, ${roundPercent(l)}%, ${roundAlpha(base[3])})`;
      }

      return `hsla(${roundDeg(h)}, ${roundPercent(s)}%, ${roundPercent(l)}%, 1)`;
    }
    /**
     *
     * @param base [255, 255, 255, 255], [255, 255, 255], any hex string
     * @returns
     */

    function toHexaString(base) {
      if (typeof base === 'string') {
        let i;

        if (i = hexRegex.exec(base)) {
          return `${i[0]}FF`;
        } else if (i = hexaRegex.exec(base)) {
          return i[0];
        } else if (i = sHexRegex.exec(base)) {
          return `#${i[1]}${i[1]}${i[2]}${i[2]}${i[3]}${i[3]}FF`;
        } else if (i = sHexaRegex.exec(base)) {
          return `#${i[1]}${i[1]}${i[2]}${i[2]}${i[3]}${i[3]}${i[4]}${i[4]}`;
        }

        throw new Error(`[seemly/toHexString]: Invalid hex value ${base}.`);
      }

      const hex = `#${base.slice(0, 3).map(unit => roundChannel(unit).toString(16).toUpperCase().padStart(2, '0')).join('')}`;
      const a = base.length === 3 ? 'FF' : roundChannel(base[3] * 255).toString(16).padStart(2, '0').toUpperCase();
      return hex + a;
    }
    /**
     *
     * @param base [255, 255, 255, 255], [255, 255, 255], any hex string
     * @returns
     */

    function toHexString(base) {
      if (typeof base === 'string') {
        let i;

        if (i = hexRegex.exec(base)) {
          return i[0];
        } else if (i = hexaRegex.exec(base)) {
          return i[0].slice(0, 7);
        } else if (i = sHexRegex.exec(base) || sHexaRegex.exec(base)) {
          return `#${i[1]}${i[1]}${i[2]}${i[2]}${i[3]}${i[3]}`;
        }

        throw new Error(`[seemly/toHexString]: Invalid hex value ${base}.`);
      }

      return `#${base.slice(0, 3).map(unit => roundChannel(unit).toString(16).toUpperCase().padStart(2, '0')).join('')}`;
    }

    function createId() {
      let length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8;
      return Math.random().toString(16).slice(2, 2 + length);
    }
    function repeat(count, v) {
      const ret = [];

      for (let i = 0; i < count; ++i) {
        ret.push(v);
      }

      return ret;
    }

    function indexMap(count, createValue) {
      const ret = [];

      if (!createValue) {
        for (let i = 0; i < count; ++i) {
          ret.push(i);
        }

        return ret;
      }

      for (let i = 0; i < count; ++i) {
        ret.push(createValue(i));
      }

      return ret;
    }

    function getSlot$1(instance) {
      let slotName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "default";
      let fallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
      const slots = instance.$slots;
      const slot = slots[slotName];
      if (slot === void 0) return fallback;
      return slot();
    }

    function getVNodeChildren(vNode) {
      let slotName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "default";
      let fallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
      const {
        children
      } = vNode;

      if (children !== null && typeof children === "object" && !Array.isArray(children)) {
        const slot = children[slotName];

        if (typeof slot === "function") {
          return slot();
        }
      }

      return fallback;
    }

    function keep(object) {
      let keys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      let rest = arguments.length > 2 ? arguments[2] : undefined;
      const keepedObject = {};
      keys.forEach(key => {
        keepedObject[key] = object[key];
      });
      return Object.assign(keepedObject, rest);
    }

    function omit(object) {
      let keys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      let rest = arguments.length > 2 ? arguments[2] : undefined;
      const omitedObject = {};
      const originalKeys = Object.getOwnPropertyNames(object);
      originalKeys.forEach(originalKey => {
        if (!keys.includes(originalKey)) {
          omitedObject[originalKey] = object[originalKey];
        }
      });
      return Object.assign(omitedObject, rest);
    }

    function flatten$3(vNodes) {
      let filterCommentNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      let result = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
      vNodes.forEach(vNode => {
        if (vNode === null) return;

        if (typeof vNode !== "object") {
          if (typeof vNode === "string" || typeof vNode === "number") {
            result.push(vue.createTextVNode(String(vNode)));
          }

          return;
        }

        if (Array.isArray(vNode)) {
          flatten$3(vNode, filterCommentNode, result);
          return;
        }

        if (vNode.type === vue.Fragment) {
          if (vNode.children === null) return;

          if (Array.isArray(vNode.children)) {
            flatten$3(vNode.children, filterCommentNode, result);
          }
        } else if (vNode.type !== vue.Comment) {
          result.push(vNode);
        }
      });
      return result;
    }

    function call(funcs) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      if (Array.isArray(funcs)) {
        funcs.forEach(func => call(func, ...args));
      } else return funcs(...args);
    }

    function keysOf(obj) {
      return Object.keys(obj);
    }

    const render$1 = function (r) {
      if (typeof r === "function") {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        return r(...args);
      } else if (typeof r === "string") {
        return vue.createTextVNode(r);
      } else if (typeof r === "number") {
        return vue.createTextVNode(String(r));
      } else {
        return null;
      }
    };

    const warnedMessages = /* @__PURE__ */new Set();
    function warnOnce(location, message) {
      const mergedMessage = `[naive/${location}]: ${message}`;
      if (warnedMessages.has(mergedMessage)) return;
      warnedMessages.add(mergedMessage);
      console.error(mergedMessage);
    }
    function warn$2(location, message) {
      console.error(`[naive/${location}]: ${message}`);
    }
    function throwError(location, message) {
      throw new Error(`[naive/${location}]: ${message}`);
    }

    function smallerSize(size) {
      switch (size) {
        case "tiny":
          return "mini";

        case "small":
          return "tiny";

        case "medium":
          return "small";

        case "large":
          return "medium";

        case "huge":
          return "large";
      }

      throw Error(`${size} has no smaller size.`);
    }

    function getTitleAttribute(value) {
      switch (typeof value) {
        case "string":
          return value || void 0;

        case "number":
          return String(value);

        default:
          return void 0;
      }
    }

    function getFirstSlotVNode(slots) {
      let slotName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "default";
      let props = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : void 0;
      const slot = slots[slotName];

      if (!slot) {
        warn$2("getFirstSlotVNode", `slot[${slotName}] is empty`);
        return null;
      }

      const slotContent = flatten$3(slot(props));

      if (slotContent.length === 1) {
        return slotContent[0];
      } else {
        warn$2("getFirstSlotVNode", `slot[${slotName}] should have exactly one child`);
        return null;
      }
    }

    function createDataKey(key) {
      return typeof key === "string" ? `s-${key}` : `n-${key}`;
    }

    function createRefSetter(ref) {
      return inst => {
        if (inst) {
          ref.value = inst.$el;
        } else {
          ref.value = null;
        }
      };
    }

    function createInjectionKey(key) {
      return key;
    }

    function ensureValidVNode(vnodes) {
      return vnodes.some(child => {
        if (!vue.isVNode(child)) {
          return true;
        }

        if (child.type === vue.Comment) {
          return false;
        }

        if (child.type === vue.Fragment && !ensureValidVNode(child.children)) {
          return false;
        }

        return true;
      }) ? vnodes : null;
    }

    function resolveSlot(slot, fallback) {
      return slot && ensureValidVNode(slot()) || fallback();
    }
    function resolveSlotWithProps(slot, props, fallback) {
      return slot && ensureValidVNode(slot(props)) || fallback(props);
    }
    function resolveWrappedSlot(slot, wrapper) {
      const children = slot && ensureValidVNode(slot());
      return wrapper(children || null);
    }
    function isSlotEmpty(slot) {
      return !(slot && ensureValidVNode(slot()));
    }

    function mergeEventHandlers(handlers) {
      const filteredHandlers = handlers.filter(handler => handler !== void 0);
      if (filteredHandlers.length === 0) return void 0;
      if (filteredHandlers.length === 1) return filteredHandlers[0];
      return e => {
        handlers.forEach(handler => {
          if (handler) {
            handler(e);
          }
        });
      };
    }

    function isNodeVShowFalse(vNode) {
      var _vNode$dirs;

      const showDir = (_vNode$dirs = vNode.dirs) === null || _vNode$dirs === void 0 ? void 0 : _vNode$dirs.find(_ref => {
        let {
          dir
        } = _ref;
        return dir === vue.vShow;
      });
      return !!(showDir && showDir.value === false);
    }

    const Wrapper = vue.defineComponent({
      render() {
        return this.$slots.default?.();
      }
    });

    const pureNumberRegex = /^(\d|\.)+$/;
    const numberRegex = /(\d|\.)+/;
    function formatLength(length) {
      let {
        c = 1,
        offset = 0,
        attachPx = true
      } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (typeof length === "number") {
        const result = (length + offset) * c;
        if (result === 0) return "0";
        return `${result}px`;
      } else if (typeof length === "string") {
        if (pureNumberRegex.test(length)) {
          const result = (Number(length) + offset) * c;

          if (attachPx) {
            if (result === 0) return "0";
            return `${result}px`;
          } else {
            return `${result}`;
          }
        } else {
          const result = numberRegex.exec(length);
          if (!result) return length;
          return length.replace(numberRegex, String((Number(result[0]) + offset) * c));
        }
      }

      return length;
    }

    function color2Class(color) {
      return color.replace(/#|\(|\)|,|\s/g, "_");
    }

    function ampCount(selector) {
      let cnt = 0;

      for (let i = 0; i < selector.length; ++i) {
        if (selector[i] === '&') ++cnt;
      }

      return cnt;
    }
    /**
     * Don't just use ',' to separate css selector. For example:
     * x:(a, b) {} will be split into 'x:(a' and 'b)', which is not expected.
     * Make sure comma doesn't exist inside parentheses.
     */


    const separatorRegex = /\s*,(?![^(]*\))\s*/g;
    const extraSpaceRegex = /\s+/g;
    /**
     * selector must includes '&'
     * selector is trimmed
     * every part of amp is trimmed
     */

    function resolveSelectorWithAmp(amp, selector) {
      const nextAmp = [];
      selector.split(separatorRegex).forEach(partialSelector => {
        let round = ampCount(partialSelector); // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions

        if (!round) {
          amp.forEach(partialAmp => {
            nextAmp.push( // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
            (partialAmp && partialAmp + ' ') + partialSelector);
          });
          return;
        } else if (round === 1) {
          amp.forEach(partialAmp => {
            nextAmp.push(partialSelector.replace('&', partialAmp));
          });
          return;
        }

        let partialNextAmp = [partialSelector]; // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions

        while (round--) {
          const nextPartialNextAmp = [];
          partialNextAmp.forEach(selectorItr => {
            amp.forEach(partialAmp => {
              nextPartialNextAmp.push(selectorItr.replace('&', partialAmp));
            });
          });
          partialNextAmp = nextPartialNextAmp;
        }

        partialNextAmp.forEach(part => nextAmp.push(part));
      });
      return nextAmp;
    }
    /**
     * selector mustn't includes '&'
     * selector is trimmed
     */


    function resolveSelector(amp, selector) {
      const nextAmp = [];
      selector.split(separatorRegex).forEach(partialSelector => {
        amp.forEach(partialAmp => {
          // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
          nextAmp.push((partialAmp && partialAmp + ' ') + partialSelector);
        });
      });
      return nextAmp;
    }

    function parseSelectorPath(selectorPaths) {
      let amp = [''];
      selectorPaths.forEach(selector => {
        // eslint-disable-next-line
        selector = selector && selector.trim();

        if ( // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
        !selector) {
          /**
           * if it's a empty selector, do nothing
           */
          return;
        } // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions


        if (selector.includes('&')) {
          amp = resolveSelectorWithAmp(amp, selector);
        } else {
          amp = resolveSelector(amp, selector);
        }
      });
      return amp.join(', ').replace(extraSpaceRegex, ' ');
    }

    function removeElement(el) {
      /* istanbul ignore if */
      // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
      if (!el) return;
      const parentElement = el.parentElement;
      /* istanbul ignore else */
      // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions

      if (parentElement) parentElement.removeChild(el);
    }
    function queryElement(id) {
      return document.querySelector(`style[cssr-id="${id}"]`);
    }
    function createElement(id) {
      const el = document.createElement('style');
      el.setAttribute('cssr-id', id);
      return el;
    }
    function isMediaOrSupports(selector) {
      // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
      if (!selector) return false;
      return /^\s*@(s|m)/.test(selector);
    }

    const kebabRegex = /[A-Z]/g;

    function kebabCase(pattern) {
      return pattern.replace(kebabRegex, match => '-' + match.toLowerCase());
    }
    /** TODO: refine it to solve nested object */


    function unwrapProperty(prop) {
      let indent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '  ';

      if (typeof prop === 'object' && prop !== null) {
        return ' {\n' + Object.entries(prop).map(v => {
          return indent + `  ${kebabCase(v[0])}: ${v[1]};`;
        }).join('\n') + '\n' + indent + '}';
      }

      return `: ${prop};`;
    }
    /** unwrap properties */


    function unwrapProperties(props, instance, params) {
      if (typeof props === 'function') {
        return props({
          context: instance.context,
          props: params
        });
      }

      return props;
    }

    function createStyle(selector, props, instance, params) {
      if (!props) return ''; // eslint-disable-next-line

      const unwrappedProps = unwrapProperties(props, instance, params);
      if (!unwrappedProps) return '';

      if (typeof unwrappedProps === 'string') {
        return `${selector} {\n${unwrappedProps}\n}`;
      }

      const propertyNames = Object.keys(unwrappedProps);

      if (propertyNames.length === 0) {
        if (instance.config.keepEmptyBlock) return selector + ' {\n}';
        return '';
      }

      const statements = selector ? [selector + ' {'] : [];
      propertyNames.forEach(propertyName => {
        const property = unwrappedProps[propertyName];

        if (propertyName === 'raw') {
          statements.push('\n' + property + '\n');
          return;
        }

        propertyName = kebabCase(propertyName);

        if (property !== null && property !== undefined) {
          statements.push(`  ${propertyName}${unwrapProperty(property)}`);
        }
      });

      if (selector) {
        statements.push('}');
      }

      return statements.join('\n');
    }

    function loopCNodeListWithCallback(children, options, callback) {
      /* istanbul ignore if */
      if (!children) return;
      children.forEach(child => {
        if (Array.isArray(child)) {
          loopCNodeListWithCallback(child, options, callback);
        } else if (typeof child === 'function') {
          const grandChildren = child(options);

          if (Array.isArray(grandChildren)) {
            loopCNodeListWithCallback(grandChildren, options, callback);
          } else if (grandChildren) {
            callback(grandChildren);
          }
        } else if (child) {
          callback(child);
        }
      });
    }

    function traverseCNode(node, selectorPaths, styles, instance, params, styleSheet) {
      const $ = node.$;
      let blockSelector = '';

      if (!$ || typeof $ === 'string') {
        if (isMediaOrSupports($)) {
          blockSelector = $;
        } else {
          // as a string selector
          selectorPaths.push($);
        }
      } else if (typeof $ === 'function') {
        const selector = $({
          context: instance.context,
          props: params
        });

        if (isMediaOrSupports(selector)) {
          blockSelector = selector;
        } else {
          // as a lazy selector
          selectorPaths.push(selector);
        }
      } else {
        // as a option selector
        if ($.before) $.before(instance.context);

        if (!$.$ || typeof $.$ === 'string') {
          if (isMediaOrSupports($.$)) {
            blockSelector = $.$;
          } else {
            // as a string selector
            selectorPaths.push($.$);
          }
        } else
          /* istanbul ignore else */
          if ($.$) {
            const selector = $.$({
              context: instance.context,
              props: params
            });

            if (isMediaOrSupports(selector)) {
              blockSelector = selector;
            } else {
              // as a lazy selector
              selectorPaths.push(selector);
            }
          }
      }

      const selector = parseSelectorPath(selectorPaths);
      const style = createStyle(selector, node.props, instance, params);

      if (blockSelector) {
        styles.push(`${blockSelector} {`);

        if (styleSheet && style) {
          styleSheet.insertRule(`${blockSelector} {\n${style}\n}\n`);
        }
      } else {
        if (styleSheet && style) {
          styleSheet.insertRule(style);
        }

        if (!styleSheet && style.length) styles.push(style);
      }

      if (node.children) {
        loopCNodeListWithCallback(node.children, {
          context: instance.context,
          props: params
        }, childNode => {
          if (typeof childNode === 'string') {
            const style = createStyle(selector, {
              raw: childNode
            }, instance, params);

            if (styleSheet) {
              styleSheet.insertRule(style);
            } else {
              styles.push(style);
            }
          } else {
            traverseCNode(childNode, selectorPaths, styles, instance, params, styleSheet);
          }
        });
      }

      selectorPaths.pop();

      if (blockSelector) {
        styles.push('}');
      }

      if ($ && $.after) $.after(instance.context);
    }

    function render(node, instance, props) {
      let insertRule = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      const styles = [];
      traverseCNode(node, [], styles, instance, props, insertRule ? node.instance.__styleSheet : undefined);
      if (insertRule) return '';
      return styles.join('\n\n');
    }

    /* eslint-disable */
    // Inspired by https://github.com/garycourt/murmurhash-js
    // Ported from https://github.com/aappleby/smhasher/blob/61a0530f28277f2e850bfc39600ce61d02b518de/src/MurmurHash2.cpp#L37-L86
    function murmur2(str) {
      // 'm' and 'r' are mixing constants generated offline.
      // They're not really 'magic', they just happen to work well.
      // const m = 0x5bd1e995;
      // const r = 24;
      // Initialize the hash
      var h = 0; // Mix 4 bytes at a time into the hash

      var k,
          i = 0,
          len = str.length;

      for (; len >= 4; ++i, len -= 4) {
        k = str.charCodeAt(i) & 0xff | (str.charCodeAt(++i) & 0xff) << 8 | (str.charCodeAt(++i) & 0xff) << 16 | (str.charCodeAt(++i) & 0xff) << 24;
        k =
        /* Math.imul(k, m): */
        (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16);
        k ^=
        /* k >>> r: */
        k >>> 24;
        h =
        /* Math.imul(k, m): */
        (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16) ^
        /* Math.imul(h, m): */
        (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
      } // Handle the last few bytes of the input array


      switch (len) {
        case 3:
          h ^= (str.charCodeAt(i + 2) & 0xff) << 16;

        case 2:
          h ^= (str.charCodeAt(i + 1) & 0xff) << 8;

        case 1:
          h ^= str.charCodeAt(i) & 0xff;
          h =
          /* Math.imul(h, m): */
          (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
      } // Do a few final mixes of the hash to ensure the last few
      // bytes are well-incorporated.


      h ^= h >>> 13;
      h =
      /* Math.imul(h, m): */
      (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
      return ((h ^ h >>> 15) >>> 0).toString(36);
    }

    /* eslint-disable @typescript-eslint/prefer-ts-expect-error */

    if (typeof window !== 'undefined') {
      window.__cssrContext = {};
    }

    function unmount(intance, node, id) {
      const {
        els
      } = node; // If id is undefined, unmount all styles

      if (id === undefined) {
        els.forEach(removeElement);
        node.els = [];
      } else {
        const target = queryElement(id); // eslint-disable-next-line

        if (target && els.includes(target)) {
          removeElement(target);
          node.els = els.filter(el => el !== target);
        }
      }
    }

    function addElementToList(els, target) {
      els.push(target);
    }

    function mount(instance, node, id, props, head, silent, force, anchorMetaName, ssrAdapter // eslint-disable-next-line @typescript-eslint/no-invalid-void-type
    ) {
      if (silent && !ssrAdapter) {
        if (id === undefined) {
          // it is possible to use hash to get rid of the requirements of id
          // if you are interested in it, please create a pr
          // i have no time to impl it
          console.error('[css-render/mount]: `id` is required in `silent` mode.');
          return;
        }

        const cssrContext = window.__cssrContext;

        if (!cssrContext[id]) {
          cssrContext[id] = true;
          render(node, instance, props, silent);
        }

        return;
      }

      let style;

      if (id === undefined) {
        style = node.render(props);
        id = murmur2(style);
      }

      if (ssrAdapter) {
        ssrAdapter.adapter(id, style !== null && style !== void 0 ? style : node.render(props));
        return;
      }

      const queriedTarget = queryElement(id);

      if (queriedTarget !== null && !force) {
        return queriedTarget;
      }

      const target = queriedTarget !== null && queriedTarget !== void 0 ? queriedTarget : createElement(id);
      if (style === undefined) style = node.render(props);
      target.textContent = style;
      if (queriedTarget !== null) return queriedTarget;

      if (anchorMetaName) {
        const anchorMetaEl = document.head.querySelector(`meta[name="${anchorMetaName}"]`);

        if (anchorMetaEl) {
          document.head.insertBefore(target, anchorMetaEl);
          addElementToList(node.els, target);
          return target;
        }
      }

      if (head) {
        document.head.insertBefore(target, document.head.querySelector('style, link'));
      } else {
        document.head.appendChild(target);
      }

      addElementToList(node.els, target);
      return target;
    }

    function wrappedRender(props) {
      return render(this, this.instance, props);
    } // do not guard node calling, it should throw an error.


    function wrappedMount() {
      let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      const {
        id,
        ssr,
        props,
        head = false,
        silent = false,
        force = false,
        anchorMetaName
      } = options;
      const targetElement = mount(this.instance, this, id, props, head, silent, force, anchorMetaName, ssr);
      return targetElement;
    }

    function wrappedUnmount() {
      let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /* istanbul ignore next */
      // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
      const {
        id
      } = options;
      unmount(this.instance, this, id);
    }

    const createCNode = function (instance, $, props, children) {
      return {
        instance,
        $,
        props,
        children,
        els: [],
        render: wrappedRender,
        mount: wrappedMount,
        unmount: wrappedUnmount
      };
    };

    const c$2 = function (instance, $, props, children) {
      if (Array.isArray($)) {
        return createCNode(instance, {
          $: null
        }, null, $);
      } else if (Array.isArray(props)) {
        return createCNode(instance, $, null, props);
      } else if (Array.isArray(children)) {
        return createCNode(instance, $, props, children);
      } else {
        return createCNode(instance, $, props, null);
      }
    };

    function CssRender() {
      let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      let styleSheet = null;
      const cssr = {
        c: function () {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          return c$2(cssr, ...args);
        },
        use: function (plugin) {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }

          return plugin.install(cssr, ...args);
        },
        find: queryElement,
        context: {},
        config,

        get __styleSheet() {
          // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
          if (!styleSheet) {
            const style = document.createElement('style');
            document.head.appendChild(style);
            styleSheet = document.styleSheets[document.styleSheets.length - 1];
            return styleSheet;
          }

          return styleSheet;
        }

      };
      return cssr;
    }

    function exists(id, ssr) {
      if (id === undefined) return false;

      if (ssr) {
        const {
          context: {
            ids
          }
        } = ssr;
        return ids.has(id);
      }

      return queryElement(id) !== null;
    }

    /* eslint-disable @typescript-eslint/restrict-template-expressions */

    /* eslint-disable @typescript-eslint/strict-boolean-expressions */
    function plugin$1(options) {
      let _bPrefix = '.';
      let _ePrefix = '__';
      let _mPrefix = '--';
      let c;

      if (options) {
        let t = options.blockPrefix;

        if (t) {
          _bPrefix = t;
        }

        t = options.elementPrefix;

        if (t) {
          _ePrefix = t;
        }

        t = options.modifierPrefix;

        if (t) {
          _mPrefix = t;
        }
      }

      const _plugin = {
        install(instance) {
          c = instance.c;
          const ctx = instance.context;
          ctx.bem = {};
          ctx.bem.b = null;
          ctx.bem.els = null;
        }

      };

      function b(arg) {
        let memorizedB;
        let memorizedE;
        return {
          before(ctx) {
            memorizedB = ctx.bem.b;
            memorizedE = ctx.bem.els;
            ctx.bem.els = null;
          },

          after(ctx) {
            ctx.bem.b = memorizedB;
            ctx.bem.els = memorizedE;
          },

          $(_ref) {
            let {
              context,
              props
            } = _ref;
            arg = typeof arg === 'string' ? arg : arg({
              context,
              props
            });
            context.bem.b = arg;
            return `${(props === null || props === void 0 ? void 0 : props.bPrefix) || _bPrefix}${context.bem.b}`;
          }

        };
      }

      function e(arg) {
        let memorizedE;
        return {
          before(ctx) {
            memorizedE = ctx.bem.els;
          },

          after(ctx) {
            ctx.bem.els = memorizedE;
          },

          $(_ref2) {
            let {
              context,
              props
            } = _ref2;
            arg = typeof arg === 'string' ? arg : arg({
              context,
              props
            });
            context.bem.els = arg.split(',').map(v => v.trim());
            return context.bem.els.map(el => `${(props === null || props === void 0 ? void 0 : props.bPrefix) || _bPrefix}${context.bem.b}${_ePrefix}${el}`).join(', ');
          }

        };
      }

      function m(arg) {
        return {
          $(_ref3) {
            let {
              context,
              props
            } = _ref3;
            arg = typeof arg === 'string' ? arg : arg({
              context,
              props
            });
            const modifiers = arg.split(',').map(v => v.trim());

            function elementToSelector(el) {
              return modifiers.map(modifier => `&${(props === null || props === void 0 ? void 0 : props.bPrefix) || _bPrefix}${context.bem.b}${el !== undefined ? `${_ePrefix}${el}` : ''}${_mPrefix}${modifier}`).join(', ');
            }

            const els = context.bem.els;

            if (els !== null) {
              if (els.length >= 2) {
                throw Error(`[css-render/plugin-bem]: m(${arg}) is invalid, using modifier inside multiple elements is not allowed`);
              }

              return elementToSelector(els[0]);
            } else {
              return elementToSelector();
            }
          }

        };
      }

      function notM(arg) {
        return {
          $(_ref4) {
            let {
              context,
              props
            } = _ref4;
            arg = typeof arg === 'string' ? arg : arg({
              context,
              props
            });
            const els = context.bem.els;

            if (els !== null && els.length >= 2) {
              throw Error(`[css-render/plugin-bem]: notM(${arg}) is invalid, using modifier inside multiple elements is not allowed`);
            }

            return `&:not(${(props === null || props === void 0 ? void 0 : props.bPrefix) || _bPrefix}${context.bem.b}${els !== null && els.length > 0 ? `${_ePrefix}${els[0]}` : ''}${_mPrefix}${arg})`;
          }

        };
      }

      const cB = function () {
        return c(b(arguments.length <= 0 ? undefined : arguments[0]), arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2]);
      };

      const cE = function () {
        return c(e(arguments.length <= 0 ? undefined : arguments[0]), arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2]);
      };

      const cM = function () {
        return c(m(arguments.length <= 0 ? undefined : arguments[0]), arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2]);
      };

      const cNotM = function () {
        return c(notM(arguments.length <= 0 ? undefined : arguments[0]), arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2]);
      };

      Object.assign(_plugin, {
        cB,
        cE,
        cM,
        cNotM
      });
      return _plugin;
    }

    function createKey(prefix, suffix) {
      return prefix + (suffix === "default" ? "" : suffix.replace(/^[a-z]/, startChar => startChar.toUpperCase()));
    }
    createKey("abc", "def");

    const namespace = "n";
    const prefix = `.${namespace}-`;
    const elementPrefix = "__";
    const modifierPrefix = "--";
    const cssr = CssRender();
    const plugin = plugin$1({
      blockPrefix: prefix,
      elementPrefix,
      modifierPrefix
    });
    cssr.use(plugin);
    const {
      c: c$1,
      find
    } = cssr;
    const {
      cB,
      cE,
      cM,
      cNotM
    } = plugin;

    function insideModal(style) {
      return c$1(_ref => {
        let {
          props: {
            bPrefix
          }
        } = _ref;
        return `${bPrefix || prefix}modal, ${bPrefix || prefix}drawer`;
      }, [style]);
    }

    function insidePopover(style) {
      return c$1(_ref2 => {
        let {
          props: {
            bPrefix
          }
        } = _ref2;
        return `${bPrefix || prefix}popover`;
      }, [style]);
    }

    function asModal(style) {
      return c$1(_ref3 => {
        let {
          props: {
            bPrefix
          }
        } = _ref3;
        return `&${bPrefix || prefix}modal`;
      }, style);
    }

    const cCB = function () {
      return c$1(">", [cB(...arguments)]);
    };

    let _isJsdom;

    function isJsdom() {
      if (_isJsdom === void 0) {
        _isJsdom = navigator.userAgent.includes("Node.js") || navigator.userAgent.includes("jsdom");
      }

      return _isJsdom;
    }

    const isBrowser$2 = typeof document !== "undefined" && typeof window !== "undefined";

    const eventSet = /* @__PURE__ */new WeakSet();
    function markEventEffectPerformed(event) {
      eventSet.add(event);
    }
    function eventEffectNotPerformed(event) {
      return !eventSet.has(event);
    }

    function useInjectionInstanceCollection(injectionName, collectionKey, registerKeyRef) {
      var _getCurrentInstance;

      const injection = vue.inject(injectionName, null);
      if (injection === null) return;
      const vm = (_getCurrentInstance = vue.getCurrentInstance()) === null || _getCurrentInstance === void 0 ? void 0 : _getCurrentInstance.proxy;
      vue.watch(registerKeyRef, registerInstance);
      registerInstance(registerKeyRef.value);
      vue.onBeforeUnmount(() => {
        registerInstance(void 0, registerKeyRef.value);
      });

      function registerInstance(key, oldKey) {
        const collection = injection[collectionKey];
        if (oldKey !== void 0) removeInstance(collection, oldKey);
        if (key !== void 0) addInstance(collection, key);
      }

      function removeInstance(collection, key) {
        if (!collection[key]) collection[key] = [];
        collection[key].splice(collection[key].findIndex(instance => instance === vm), 1);
      }

      function addInstance(collection, key) {
        if (!collection[key]) collection[key] = [];

        if (!~collection[key].findIndex(instance => instance === vm)) {
          collection[key].push(vm);
        }
      }
    }
    function useInjectionCollection(injectionName, collectionKey, valueRef) {
      const injection = vue.inject(injectionName, null);
      if (injection === null) return;

      if (!(collectionKey in injection)) {
        injection[collectionKey] = [];
      }

      injection[collectionKey].push(valueRef.value);
      vue.watch(valueRef, (value, prevValue) => {
        const collectionArray = injection[collectionKey];
        const index = collectionArray.findIndex(collectionValue => collectionValue === prevValue);
        if (~index) collectionArray.splice(index, 1);
        collectionArray.push(value);
      });
      vue.onBeforeUnmount(() => {
        const collectionArray = injection[collectionKey];
        const index = collectionArray.findIndex(collectionValue => collectionValue === valueRef.value);
        if (~index) collectionArray.splice(index, 1);
      });
    }
    function useInjectionElementCollection(injectionName, collectionKey, getElement) {
      const injection = vue.inject(injectionName, null);
      if (injection === null) return;

      if (!(collectionKey in injection)) {
        injection[collectionKey] = [];
      }

      vue.onMounted(() => {
        const el = getElement();
        if (!el) return;
        injection[collectionKey].push(el);
      });
      vue.onBeforeUnmount(() => {
        const collectionArray = injection[collectionKey];
        const element = getElement();
        const index = collectionArray.findIndex(collectionElement => collectionElement === element);
        if (~index) collectionArray.splice(index, 1);
      });
    }

    function useDeferredTrue(valueRef, delay, shouldDelayRef) {
      if (!delay) return valueRef;
      const delayedRef = vue.ref(valueRef.value);
      let timerId = null;
      vue.watch(valueRef, value => {
        if (timerId !== null) window.clearTimeout(timerId);

        if (value === true) {
          if (shouldDelayRef && !shouldDelayRef.value) {
            delayedRef.value = true;
          } else {
            timerId = window.setTimeout(() => {
              delayedRef.value = true;
            }, delay);
          }
        } else {
          delayedRef.value = false;
        }
      });
      return delayedRef;
    }

    function useFalseUntilTruthy(originalRef) {
      const currentRef = vue.ref(!!originalRef.value);
      if (currentRef.value) return vue.readonly(currentRef);
      const stop = vue.watch(originalRef, value => {
        if (value) {
          currentRef.value = true;
          stop();
        }
      });
      return vue.readonly(currentRef);
    }

    function useMemo(getterOrOptions) {
      const computedValueRef = vue.computed(getterOrOptions); // Maybe it's not possible to lazy evaluate the value, since we can't make
      // render phase capture the deps behind useMemo

      const valueRef = vue.ref(computedValueRef.value);
      vue.watch(computedValueRef, value => {
        valueRef.value = value;
      });

      if (typeof getterOrOptions === 'function') {
        return valueRef;
      } else {
        return {
          __v_isRef: true,

          get value() {
            return valueRef.value;
          },

          set value(v) {
            getterOrOptions.set(v);
          }

        };
      }
    }

    function hasInstance() {
      return vue.getCurrentInstance() !== null;
    }
    const isBrowser$1 = typeof window !== 'undefined';

    let fontsReady;
    let isFontReady;

    const init$1 = () => {
      var _a, _b;

      fontsReady = isBrowser$1 ? (_b = (_a = document) === null || _a === void 0 ? void 0 : _a.fonts) === null || _b === void 0 ? void 0 : _b.ready : undefined;
      isFontReady = false;
      /* istanbul ignore if */

      if (fontsReady !== undefined) {
        void fontsReady.then(() => {
          isFontReady = true;
        });
      } else {
        isFontReady = true;
      }
    };

    init$1(); // For testing
    /**
     * Call callback on fontsReady is resolved. If fontsReady is already resolved,
     * callback won't be called.
     */

    function onFontsReady(cb) {
      /* istanbul ignore next */
      if (isFontReady) return;
      let deactivated = false;
      vue.onMounted(() => {
        /* istanbul ignore next */
        if (!isFontReady) {
          fontsReady === null || fontsReady === void 0 ? void 0 : fontsReady.then(() => {
            if (deactivated) return;
            cb();
          });
        }
      });
      vue.onBeforeUnmount(() => {
        deactivated = true;
      });
    }

    function getEventTarget(e) {
      const path = e.composedPath();
      return path[0];
    }

    const traps = {
      mousemoveoutside: new WeakMap(),
      clickoutside: new WeakMap()
    };

    function createTrapHandler(name, el, originalHandler) {
      if (name === 'mousemoveoutside') {
        const moveHandler = e => {
          if (el.contains(getEventTarget(e))) return;
          originalHandler(e);
        };

        return {
          mousemove: moveHandler,
          touchstart: moveHandler
        };
      } else if (name === 'clickoutside') {
        let mouseDownOutside = false;

        const downHandler = e => {
          mouseDownOutside = !el.contains(getEventTarget(e));
        };

        const upHanlder = e => {
          if (!mouseDownOutside) return;
          if (el.contains(getEventTarget(e))) return;
          originalHandler(e);
        };

        return {
          mousedown: downHandler,
          mouseup: upHanlder,
          touchstart: downHandler,
          touchend: upHanlder
        };
      }

      console.error( // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
      `[evtd/create-trap-handler]: name \`${name}\` is invalid. This could be a bug of evtd.`);
      return {};
    }

    function ensureTrapHandlers(name, el, handler) {
      const handlers = traps[name];
      let elHandlers = handlers.get(el);

      if (elHandlers === undefined) {
        handlers.set(el, elHandlers = new WeakMap());
      }

      let trapHandler = elHandlers.get(handler);

      if (trapHandler === undefined) {
        elHandlers.set(handler, trapHandler = createTrapHandler(name, el, handler));
      }

      return trapHandler;
    }

    function trapOn(name, el, handler, options) {
      if (name === 'mousemoveoutside' || name === 'clickoutside') {
        const trapHandlers = ensureTrapHandlers(name, el, handler);
        Object.keys(trapHandlers).forEach(key => {
          on(key, document, trapHandlers[key], options);
        });
        return true;
      }

      return false;
    }

    function trapOff(name, el, handler, options) {
      if (name === 'mousemoveoutside' || name === 'clickoutside') {
        const trapHandlers = ensureTrapHandlers(name, el, handler);
        Object.keys(trapHandlers).forEach(key => {
          off(key, document, trapHandlers[key], options);
        });
        return true;
      }

      return false;
    }

    function createDelegate() {
      if (typeof window === 'undefined') {
        return {
          on: () => {},
          off: () => {}
        };
      }

      const propagationStopped = new WeakMap();
      const immediatePropagationStopped = new WeakMap();

      function trackPropagation() {
        propagationStopped.set(this, true);
      }

      function trackImmediate() {
        propagationStopped.set(this, true);
        immediatePropagationStopped.set(this, true);
      }

      function spy(event, propName, fn) {
        const source = event[propName];

        event[propName] = function () {
          fn.apply(event, arguments);
          return source.apply(event, arguments);
        };

        return event;
      }

      function unspy(event, propName) {
        event[propName] = Event.prototype[propName];
      }

      const currentTargets = new WeakMap();
      const currentTargetDescriptor = Object.getOwnPropertyDescriptor(Event.prototype, 'currentTarget');

      function getCurrentTarget() {
        var _a;

        return (_a = currentTargets.get(this)) !== null && _a !== void 0 ? _a : null;
      }

      function defineCurrentTarget(event, getter) {
        if (currentTargetDescriptor === undefined) return;
        Object.defineProperty(event, 'currentTarget', {
          configurable: true,
          enumerable: true,
          get: getter !== null && getter !== void 0 ? getter : currentTargetDescriptor.get
        });
      }

      const phaseToTypeToElToHandlers = {
        bubble: {},
        capture: {}
      };
      const typeToWindowEventHandlers = {};

      function createUnifiedHandler() {
        const delegeteHandler = function (e) {
          const {
            type,
            eventPhase,
            bubbles
          } = e;
          const target = getEventTarget(e);
          if (eventPhase === 2) return;
          const phase = eventPhase === 1 ? 'capture' : 'bubble';
          let cursor = target;
          const path = []; // collecting bubble path

          while (true) {
            if (cursor === null) cursor = window;
            path.push(cursor);

            if (cursor === window) {
              break;
            } // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions


            cursor = cursor.parentNode || null;
          }

          const captureElToHandlers = phaseToTypeToElToHandlers.capture[type];
          const bubbleElToHandlers = phaseToTypeToElToHandlers.bubble[type];
          spy(e, 'stopPropagation', trackPropagation);
          spy(e, 'stopImmediatePropagation', trackImmediate);
          defineCurrentTarget(e, getCurrentTarget);

          if (phase === 'capture') {
            if (captureElToHandlers === undefined) return; // capture

            for (let i = path.length - 1; i >= 0; --i) {
              if (propagationStopped.has(e)) break;
              const target = path[i];
              const handlers = captureElToHandlers.get(target);

              if (handlers !== undefined) {
                currentTargets.set(e, target);

                for (const handler of handlers) {
                  if (immediatePropagationStopped.has(e)) break;
                  handler(e);
                }
              }

              if (i === 0 && !bubbles && bubbleElToHandlers !== undefined) {
                const bubbleHandlers = bubbleElToHandlers.get(target);

                if (bubbleHandlers !== undefined) {
                  for (const handler of bubbleHandlers) {
                    if (immediatePropagationStopped.has(e)) break;
                    handler(e);
                  }
                }
              }
            }
          } else if (phase === 'bubble') {
            if (bubbleElToHandlers === undefined) return; // bubble

            for (let i = 0; i < path.length; ++i) {
              if (propagationStopped.has(e)) break;
              const target = path[i];
              const handlers = bubbleElToHandlers.get(target);

              if (handlers !== undefined) {
                currentTargets.set(e, target);

                for (const handler of handlers) {
                  if (immediatePropagationStopped.has(e)) break;
                  handler(e);
                }
              }
            }
          }

          unspy(e, 'stopPropagation');
          unspy(e, 'stopImmediatePropagation');
          defineCurrentTarget(e);
        };

        delegeteHandler.displayName = 'evtdUnifiedHandler';
        return delegeteHandler;
      }

      function createUnifiedWindowEventHandler() {
        const delegateHandler = function (e) {
          const {
            type,
            eventPhase
          } = e;
          if (eventPhase !== 2) return;
          const handlers = typeToWindowEventHandlers[type];
          if (handlers === undefined) return;
          handlers.forEach(handler => handler(e));
        };

        delegateHandler.displayName = 'evtdUnifiedWindowEventHandler';
        return delegateHandler;
      }

      const unifiedHandler = createUnifiedHandler();
      const unfiendWindowEventHandler = createUnifiedWindowEventHandler();

      function ensureElToHandlers(phase, type) {
        const phaseHandlers = phaseToTypeToElToHandlers[phase];

        if (phaseHandlers[type] === undefined) {
          phaseHandlers[type] = new Map();
          window.addEventListener(type, unifiedHandler, phase === 'capture');
        }

        return phaseHandlers[type];
      }

      function ensureWindowEventHandlers(type) {
        const windowEventHandlers = typeToWindowEventHandlers[type];

        if (windowEventHandlers === undefined) {
          typeToWindowEventHandlers[type] = new Set();
          window.addEventListener(type, unfiendWindowEventHandler);
        }

        return typeToWindowEventHandlers[type];
      }

      function ensureHandlers(elToHandlers, el) {
        let elHandlers = elToHandlers.get(el);

        if (elHandlers === undefined) {
          elToHandlers.set(el, elHandlers = new Set());
        }

        return elHandlers;
      }

      function handlerExist(el, phase, type, handler) {
        const elToHandlers = phaseToTypeToElToHandlers[phase][type]; // phase ${type} event has handlers

        if (elToHandlers !== undefined) {
          const handlers = elToHandlers.get(el); // phase using el with ${type} event has handlers

          if (handlers !== undefined) {
            if (handlers.has(handler)) return true;
          }
        }

        return false;
      }

      function windowEventHandlerExist(type, handler) {
        const handlers = typeToWindowEventHandlers[type];

        if (handlers !== undefined) {
          if (handlers.has(handler)) {
            return true;
          }
        }

        return false;
      }

      function on(type, el, handler, options) {
        let mergedHandler;

        if (typeof options === 'object' && options.once === true) {
          mergedHandler = e => {
            off(type, el, mergedHandler, options);
            handler(e);
          };
        } else {
          mergedHandler = handler;
        }

        const trapped = trapOn(type, el, mergedHandler, options);
        if (trapped) return;
        const phase = options === true || typeof options === 'object' && options.capture === true ? 'capture' : 'bubble';
        const elToHandlers = ensureElToHandlers(phase, type);
        const handlers = ensureHandlers(elToHandlers, el);
        if (!handlers.has(mergedHandler)) handlers.add(mergedHandler);

        if (el === window) {
          const windowEventHandlers = ensureWindowEventHandlers(type);

          if (!windowEventHandlers.has(mergedHandler)) {
            windowEventHandlers.add(mergedHandler);
          }
        }
      }

      function off(type, el, handler, options) {
        const trapped = trapOff(type, el, handler, options);
        if (trapped) return;
        const capture = options === true || typeof options === 'object' && options.capture === true;
        const phase = capture ? 'capture' : 'bubble';
        const elToHandlers = ensureElToHandlers(phase, type);
        const handlers = ensureHandlers(elToHandlers, el);

        if (el === window) {
          const mirrorPhase = capture ? 'bubble' : 'capture';

          if (!handlerExist(el, mirrorPhase, type, handler) && windowEventHandlerExist(type, handler)) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const windowEventHandlers = typeToWindowEventHandlers[type];
            windowEventHandlers.delete(handler);

            if (windowEventHandlers.size === 0) {
              window.removeEventListener(type, unfiendWindowEventHandler);
              typeToWindowEventHandlers[type] = undefined;
            }
          }
        }

        if (handlers.has(handler)) handlers.delete(handler);

        if (handlers.size === 0) {
          elToHandlers.delete(el);
        }

        if (elToHandlers.size === 0) {
          window.removeEventListener(type, unifiedHandler, phase === 'capture');
          phaseToTypeToElToHandlers[phase][type] = undefined;
        }
      }

      return {
        on: on,
        off: off
      };
    }

    const {
      on,
      off
    } = createDelegate();

    const mousePositionRef = vue.ref(null);

    function clickHandler(e) {
      if (e.clientX > 0 || e.clientY > 0) {
        mousePositionRef.value = {
          x: e.clientX,
          y: e.clientY
        };
      } else {
        // x = 0 & y = 0
        const {
          target
        } = e;

        if (target instanceof Element) {
          const {
            left,
            top,
            width,
            height
          } = target.getBoundingClientRect();

          if (left > 0 || top > 0) {
            // impossible to be triggered by real click
            mousePositionRef.value = {
              x: left + width / 2,
              y: top + height / 2
            };
          } else {
            mousePositionRef.value = {
              x: 0,
              y: 0
            };
          }
        } else {
          mousePositionRef.value = null;
        }
      }
    }

    let usedCount$2 = 0;
    let managable$2 = true;
    function useClickPosition() {
      if (!isBrowser$1) return vue.readonly(vue.ref(null));
      if (usedCount$2 === 0) on('click', document, clickHandler, true);

      const setup = () => {
        usedCount$2 += 1;
      };

      if (managable$2 && (managable$2 = hasInstance())) {
        vue.onBeforeMount(setup);
        vue.onBeforeUnmount(() => {
          usedCount$2 -= 1;
          if (usedCount$2 === 0) off('click', document, clickHandler, true);
        });
      } else {
        setup();
      }

      return vue.readonly(mousePositionRef);
    }

    const clickedTimeRef = vue.ref(undefined);
    let usedCount$1 = 0;

    function handleClick() {
      clickedTimeRef.value = Date.now();
    }

    let managable$1 = true;
    function useClicked(timeout) {
      if (!isBrowser$1) return vue.readonly(vue.ref(false));
      const clickedRef = vue.ref(false);
      let timerId = null;

      function clearTimer() {
        if (timerId !== null) window.clearTimeout(timerId);
      }

      function clickedHandler() {
        clearTimer();
        clickedRef.value = true;
        timerId = window.setTimeout(() => {
          clickedRef.value = false;
        }, timeout);
      }

      if (usedCount$1 === 0) {
        on('click', window, handleClick, true);
      }

      const setup = () => {
        usedCount$1 += 1;
        on('click', window, clickedHandler, true);
      };

      if (managable$1 && (managable$1 = hasInstance())) {
        vue.onBeforeMount(setup);
        vue.onBeforeUnmount(() => {
          usedCount$1 -= 1;

          if (usedCount$1 === 0) {
            off('click', window, handleClick, true);
          }

          off('click', window, clickedHandler, true);
          clearTimer();
        });
      } else {
        setup();
      }

      return vue.readonly(clickedRef);
    }

    /* eslint-disable @typescript-eslint/strict-boolean-expressions */
    let usedCount = 0; // Mql means media query list

    const supportMatchMedia = typeof window !== 'undefined' && window.matchMedia !== undefined;
    const osTheme = vue.ref(null);
    let darkMql;
    let lightMql;

    function handleDarkMqlChange(e) {
      if (e.matches) {
        osTheme.value = 'dark';
      }
    }

    function handleLightMqlChange(e) {
      if (e.matches) {
        osTheme.value = 'light';
      }
    }

    function init() {
      darkMql = window.matchMedia('(prefers-color-scheme: dark)');
      lightMql = window.matchMedia('(prefers-color-scheme: light)');

      if (darkMql.matches) {
        osTheme.value = 'dark';
      } else if (lightMql.matches) {
        osTheme.value = 'light';
      } else {
        osTheme.value = null;
      }

      if (darkMql.addEventListener) {
        darkMql.addEventListener('change', handleDarkMqlChange);
        lightMql.addEventListener('change', handleLightMqlChange);
      } else if (darkMql.addListener) {
        darkMql.addListener(handleDarkMqlChange);
        lightMql.addListener(handleLightMqlChange);
      }
    }

    function clean() {
      if ('removeEventListener' in darkMql) {
        darkMql.removeEventListener('change', handleDarkMqlChange);
        lightMql.removeEventListener('change', handleLightMqlChange);
      } else if ('removeListener' in darkMql) {
        darkMql.removeListener(handleDarkMqlChange);
        lightMql.removeListener(handleLightMqlChange);
      }

      darkMql = undefined;
      lightMql = undefined;
    }

    let managable = true;
    function useOsTheme() {
      /* istanbul ignore next */
      if (!supportMatchMedia) {
        return vue.readonly(osTheme);
      }

      if (usedCount === 0) init();

      if (managable && (managable = hasInstance())) {
        vue.onBeforeMount(() => {
          usedCount += 1;
        });
        vue.onBeforeUnmount(() => {
          usedCount -= 1;
          if (usedCount === 0) clean();
        });
      }

      return vue.readonly(osTheme);
    }

    function useMergedState(controlledStateRef, uncontrolledStateRef) {
      vue.watch(controlledStateRef, value => {
        if (value !== undefined) {
          uncontrolledStateRef.value = value;
        }
      });
      return vue.computed(() => {
        if (controlledStateRef.value === undefined) {
          return uncontrolledStateRef.value;
        }

        return controlledStateRef.value;
      });
    }

    function isMounted() {
      const isMounted = vue.ref(false);
      vue.onMounted(() => {
        isMounted.value = true;
      });
      return vue.readonly(isMounted);
    }

    function useCompitable(reactive, keys) {
      // @ts-expect-error
      return vue.computed(() => {
        for (const key of keys) {
          if (reactive[key] !== undefined) return reactive[key];
        }

        return reactive[keys[keys.length - 1]];
      });
    }

    const isIos = (typeof window === 'undefined' ? false : /iPad|iPhone|iPod/.test(navigator.platform) || navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1) && // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
    !window.MSStream;
    function useIsIos() {
      return isIos;
    }

    /* eslint-disable @typescript-eslint/consistent-type-assertions */
    const defaultBreakpointOptions = {
      // mobile
      // 0 ~ 640 doesn't mean it should display well in all the range,
      // but means you should treat it like a mobile phone.)
      xs: 0,
      s: 640,
      m: 1024,
      l: 1280,
      xl: 1536,
      '2xl': 1920 // normal desktop display

    };

    function createMediaQuery(screenWidth) {
      return `(min-width: ${screenWidth}px)`;
    }

    const mqlMap = {};

    function useBreakpoints() {
      let screens = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultBreakpointOptions;
      if (!isBrowser$1) return vue.computed(() => []); // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions

      if (typeof window.matchMedia !== 'function') return vue.computed(() => []);
      const breakpointStatusRef = vue.ref({});
      const breakpoints = Object.keys(screens);

      const updateBreakpoints = (e, breakpointName) => {
        if (e.matches) breakpointStatusRef.value[breakpointName] = true;else breakpointStatusRef.value[breakpointName] = false;
      };

      breakpoints.forEach(key => {
        const breakpointValue = screens[key];
        let mql;
        let cbs;

        if (mqlMap[breakpointValue] === undefined) {
          mql = window.matchMedia(createMediaQuery(breakpointValue)); // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions

          if (mql.addEventListener) {
            mql.addEventListener('change', e => {
              cbs.forEach(cb => {
                cb(e, key);
              });
            }); // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
          } else if (mql.addListener) {
            mql.addListener(e => {
              cbs.forEach(cb => {
                cb(e, key);
              });
            });
          }

          cbs = new Set();
          mqlMap[breakpointValue] = {
            mql,
            cbs
          };
        } else {
          mql = mqlMap[breakpointValue].mql;
          cbs = mqlMap[breakpointValue].cbs;
        }

        cbs.add(updateBreakpoints);

        if (mql.matches) {
          cbs.forEach(cb => {
            cb(mql, key);
          });
        }
      });
      vue.onBeforeUnmount(() => {
        breakpoints.forEach(breakpoint => {
          const {
            cbs
          } = mqlMap[screens[breakpoint]];

          if (cbs.has(updateBreakpoints)) {
            cbs.delete(updateBreakpoints);
          }
        });
      });
      return vue.computed(() => {
        const {
          value
        } = breakpointStatusRef;
        return breakpoints.filter(key => value[key]);
      });
    }

    function useKeyboard$1() {
      let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      let enabledRef = arguments.length > 1 ? arguments[1] : undefined;
      const state = vue.reactive({
        ctrl: false,
        command: false,
        win: false,
        shift: false,
        tab: false
      });
      const {
        keydown,
        keyup
      } = options;

      const keydownHandler = e => {
        switch (e.key) {
          case 'Control':
            state.ctrl = true;
            break;

          case 'Meta':
            state.command = true;
            state.win = true;
            break;

          case 'Shift':
            state.shift = true;
            break;

          case 'Tab':
            state.tab = true;
            break;
        }

        if (keydown !== undefined) {
          Object.keys(keydown).forEach(key => {
            if (key !== e.key) return;
            const handler = keydown[key];

            if (typeof handler === 'function') {
              handler(e);
            } else {
              const {
                stop = false,
                prevent = false
              } = handler;
              if (stop) e.stopPropagation();
              if (prevent) e.preventDefault();
              handler.handler(e);
            }
          });
        }
      };

      const keyupHandler = e => {
        switch (e.key) {
          case 'Control':
            state.ctrl = false;
            break;

          case 'Meta':
            state.command = false;
            state.win = false;
            break;

          case 'Shift':
            state.shift = false;
            break;

          case 'Tab':
            state.tab = false;
            break;
        }

        if (keyup !== undefined) {
          Object.keys(keyup).forEach(key => {
            if (key !== e.key) return;
            const handler = keyup[key];

            if (typeof handler === 'function') {
              handler(e);
            } else {
              const {
                stop = false,
                prevent = false
              } = handler;
              if (stop) e.stopPropagation();
              if (prevent) e.preventDefault();
              handler.handler(e);
            }
          });
        }
      };

      const setup = () => {
        if (enabledRef === undefined || enabledRef.value) {
          on('keydown', document, keydownHandler);
          on('keyup', document, keyupHandler);
        }

        if (enabledRef !== undefined) {
          vue.watch(enabledRef, value => {
            if (value) {
              on('keydown', document, keydownHandler);
              on('keyup', document, keyupHandler);
            } else {
              off('keydown', document, keydownHandler);
              off('keyup', document, keyupHandler);
            }
          });
        }
      };

      if (hasInstance()) {
        vue.onBeforeMount(setup);
        vue.onBeforeUnmount(() => {
          if (enabledRef === undefined || enabledRef.value) {
            off('keydown', document, keydownHandler);
            off('keyup', document, keyupHandler);
          }
        });
      } else {
        setup();
      }

      return vue.readonly(state);
    }

    const internalSelectionMenuInjectionKey = createInjectionKey("n-internal-select-menu");
    const internalSelectionMenuBodyInjectionKey = createInjectionKey("n-internal-select-menu-body");

    const modalBodyInjectionKey = createInjectionKey("n-modal-body");
    const modalInjectionKey = createInjectionKey("n-modal");

    const drawerBodyInjectionKey = createInjectionKey("n-drawer-body");
    const drawerInjectionKey = createInjectionKey("n-drawer");

    const popoverBodyInjectionKey = createInjectionKey("n-popover-body");

    const teleportDisabled = "__disabled__";

    function useAdjustedTo(props) {
      const modal = vue.inject(modalBodyInjectionKey, null);
      const drawer = vue.inject(drawerBodyInjectionKey, null);
      const popover = vue.inject(popoverBodyInjectionKey, null);
      const selectMenu = vue.inject(internalSelectionMenuBodyInjectionKey, null);
      const fullscreenElementRef = vue.ref();

      if (typeof document !== "undefined") {
        fullscreenElementRef.value = document.fullscreenElement;

        const handleFullscreenChange = () => {
          fullscreenElementRef.value = document.fullscreenElement;
        };

        vue.onMounted(() => {
          on("fullscreenchange", document, handleFullscreenChange);
        });
        vue.onBeforeUnmount(() => {
          off("fullscreenchange", document, handleFullscreenChange);
        });
      }

      return useMemo(() => {
        const {
          to
        } = props;

        if (to !== void 0) {
          if (to === false) return teleportDisabled;
          if (to === true) return fullscreenElementRef.value || "body";
          return to;
        }

        if (modal !== null && modal !== void 0 && modal.value) {
          return modal.value.$el ?? modal.value;
        }

        if (drawer !== null && drawer !== void 0 && drawer.value) return drawer.value;
        if (popover !== null && popover !== void 0 && popover.value) return popover.value;
        if (selectMenu !== null && selectMenu !== void 0 && selectMenu.value) return selectMenu.value;
        return to ?? (fullscreenElementRef.value || "body");
      });
    }

    useAdjustedTo.tdkey = teleportDisabled;
    useAdjustedTo.propTo = {
      type: [String, Object, Boolean],
      default: void 0
    };

    let houdiniRegistered = false;
    function useHoudini() {
      if (!isBrowser$2) return;
      if (!window.CSS) return;

      if (!houdiniRegistered) {
        var _window;

        houdiniRegistered = true;

        if ("registerProperty" in ((_window = window) === null || _window === void 0 ? void 0 : _window.CSS)) {
          try {
            ;
            CSS.registerProperty({
              name: "--n-color-start",
              syntax: "<color>",
              inherits: false,
              initialValue: "#0000"
            });
            CSS.registerProperty({
              name: "--n-color-end",
              syntax: "<color>",
              inherits: false,
              initialValue: "#0000"
            });
          } catch (e) {}
        }
      }
    }

    function getSlot(scope, slots) {
      let slotName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'default';
      const slot = slots[slotName];

      if (slot === undefined) {
        throw new Error(`[vueuc/${scope}]: slot[${slotName}] is empty.`);
      }

      return slot();
    } // o(n) flatten

    function flatten$2(vNodes) {
      let filterCommentNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      let result = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
      vNodes.forEach(vNode => {
        if (vNode === null) return;

        if (typeof vNode !== 'object') {
          if (typeof vNode === 'string' || typeof vNode === 'number') {
            result.push(vue.createTextVNode(String(vNode)));
          }

          return;
        }

        if (Array.isArray(vNode)) {
          flatten$2(vNode, filterCommentNode, result);
          return;
        }

        if (vNode.type === vue.Fragment) {
          if (vNode.children === null) return;

          if (Array.isArray(vNode.children)) {
            flatten$2(vNode.children, filterCommentNode, result);
          } // rawSlot

        } else if (vNode.type !== vue.Comment) {
          result.push(vNode);
        }
      });
      return result;
    }
    function getFirstVNode(scope, slots) {
      let slotName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'default';
      const slot = slots[slotName];

      if (slot === undefined) {
        throw new Error(`[vueuc/${scope}]: slot[${slotName}] is empty.`);
      }

      const content = flatten$2(slot()); // vue will normalize the slot, so slot must be an array

      if (content.length === 1) {
        return content[0];
      } else {
        throw new Error(`[vueuc/${scope}]: slot[${slotName}] should have exactly one child.`);
      }
    }

    let viewMeasurer = null;
    function ensureViewBoundingRect() {
      if (viewMeasurer === null) {
        viewMeasurer = document.getElementById('v-binder-view-measurer');

        if (viewMeasurer === null) {
          viewMeasurer = document.createElement('div');
          viewMeasurer.id = 'v-binder-view-measurer';
          const {
            style
          } = viewMeasurer;
          style.position = 'fixed';
          style.left = '0';
          style.right = '0';
          style.top = '0';
          style.bottom = '0';
          style.pointerEvents = 'none';
          style.visibility = 'hidden';
          document.body.appendChild(viewMeasurer);
        }
      }

      return viewMeasurer.getBoundingClientRect();
    }
    function getPointRect(x, y) {
      const viewRect = ensureViewBoundingRect();
      return {
        top: y,
        left: x,
        height: 0,
        width: 0,
        right: viewRect.width - x,
        bottom: viewRect.height - y
      };
    }
    function getRect$1(el) {
      const elRect = el.getBoundingClientRect();
      const viewRect = ensureViewBoundingRect();
      return {
        left: elRect.left - viewRect.left,
        top: elRect.top - viewRect.top,
        bottom: viewRect.height + viewRect.top - elRect.bottom,
        right: viewRect.width + viewRect.left - elRect.right,
        width: elRect.width,
        height: elRect.height
      };
    }
    function getParentNode(node) {
      // document type
      if (node.nodeType === 9) {
        return null;
      }

      return node.parentNode;
    }
    function getScrollParent(node) {
      if (node === null) return null;
      const parentNode = getParentNode(node);

      if (parentNode === null) {
        return null;
      } // Document


      if (parentNode.nodeType === 9) {
        return document;
      } // Element


      if (parentNode.nodeType === 1) {
        // Firefox want us to check `-x` and `-y` variations as well
        const {
          overflow,
          overflowX,
          overflowY
        } = getComputedStyle(parentNode);

        if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
          return parentNode;
        }
      }

      return getScrollParent(parentNode);
    }

    /* eslint-disable @typescript-eslint/no-non-null-assertion */
    const Binder = vue.defineComponent({
      name: 'Binder',
      props: {
        syncTargetWithParent: Boolean,
        syncTarget: {
          type: Boolean,
          default: true
        }
      },

      setup(props) {
        var _a;

        vue.provide('VBinder', (_a = vue.getCurrentInstance()) === null || _a === void 0 ? void 0 : _a.proxy);
        const VBinder = vue.inject('VBinder', null);
        const targetRef = vue.ref(null);
        /**
         * If there's no nested vbinder, we can simply set the target ref.
         *
         * However, when it comes to:
         * <VBinder> <- syncTarget = false
         *
         *              Should hold target DOM ref, but can't get it directly from
         *              its VTarget. So if there are nested VBinder, we should:
         *              1. Stop setting target DOM from level-1 VTarget
         *              2. Set target DOM from level-2 VTarget
         *              For (1), we need `syncTarget` to `false`
         *              For (2), we need to set `syncTargetWithParent` to `true` on
         *              level-2 VBinder
         *   <VTarget>
         *     <VBinder> <- syncTargetWithParent = true
         *       <VTarget>target</VTarget>
         *     </VBinder>
         *     <VFollower>
         *       content1
         *     </VFollower>
         *   </VTarget>
         *   <VFollower>
         *     content2
         *   </VFollower>
         * </VBinder>
         */

        const setTargetRef = el => {
          targetRef.value = el; // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions

          if (VBinder && props.syncTargetWithParent) {
            VBinder.setTargetRef(el);
          }
        }; // scroll related


        let scrollableNodes = [];

        const ensureScrollListener = () => {
          let cursor = targetRef.value;

          while (true) {
            cursor = getScrollParent(cursor);
            if (cursor === null) break;
            scrollableNodes.push(cursor);
          }

          for (const el of scrollableNodes) {
            on('scroll', el, onScroll, true);
          }
        };

        const removeScrollListeners = () => {
          for (const el of scrollableNodes) {
            off('scroll', el, onScroll, true);
          }

          scrollableNodes = [];
        };

        const followerScrollListeners = new Set();

        const addScrollListener = listener => {
          if (followerScrollListeners.size === 0) {
            ensureScrollListener();
          }

          if (!followerScrollListeners.has(listener)) {
            followerScrollListeners.add(listener);
          }
        };

        const removeScrollListener = listener => {
          if (followerScrollListeners.has(listener)) {
            followerScrollListeners.delete(listener);
          }

          if (followerScrollListeners.size === 0) {
            removeScrollListeners();
          }
        };

        const onScroll = () => {
          beforeNextFrameOnce(onScrollRaf);
        };

        const onScrollRaf = () => {
          followerScrollListeners.forEach(listener => listener());
        }; // resize related


        const followerResizeListeners = new Set();

        const addResizeListener = listener => {
          if (followerResizeListeners.size === 0) {
            on('resize', window, onResize);
          }

          if (!followerResizeListeners.has(listener)) {
            followerResizeListeners.add(listener);
          }
        };

        const removeResizeListener = listener => {
          if (followerResizeListeners.has(listener)) {
            followerResizeListeners.delete(listener);
          }

          if (followerResizeListeners.size === 0) {
            off('resize', window, onResize);
          }
        };

        const onResize = () => {
          followerResizeListeners.forEach(listener => listener());
        };

        vue.onBeforeUnmount(() => {
          off('resize', window, onResize);
          removeScrollListeners();
        });
        return {
          targetRef,
          setTargetRef,
          addScrollListener,
          removeScrollListener,
          addResizeListener,
          removeResizeListener
        };
      },

      render() {
        return getSlot('binder', this.$slots);
      }

    });
    var VBinder = Binder;

    /* eslint-disable @typescript-eslint/no-non-null-assertion */
    var VTarget = vue.defineComponent({
      name: 'Target',

      setup() {
        const {
          setTargetRef,
          syncTarget
        } = vue.inject('VBinder');
        const setTargetDirective = {
          mounted: setTargetRef,
          updated: setTargetRef
        };
        return {
          syncTarget,
          setTargetDirective
        };
      },

      render() {
        const {
          syncTarget,
          setTargetDirective
        } = this;
        /**
         * If you are using VBinder as a child of VBinder, the children wouldn't be
         * a valid DOM or component that can be attached to by directive.
         * So we won't sync target on those kind of situation and control the
         * target sync logic manually.
         */

        if (syncTarget) {
          return vue.withDirectives(getFirstVNode('follower', this.$slots), [[setTargetDirective]]);
        }

        return getFirstVNode('follower', this.$slots);
      }

    });

    const ctxKey$1 = '@@mmoContext';
    const mousemoveoutside = {
      mounted(el, _ref) {
        let {
          value
        } = _ref;
        el[ctxKey$1] = {
          handler: undefined
        };

        if (typeof value === 'function') {
          el[ctxKey$1].handler = value;
          on('mousemoveoutside', el, value);
        }
      },

      updated(el, _ref2) {
        let {
          value
        } = _ref2;
        const ctx = el[ctxKey$1];

        if (typeof value === 'function') {
          if (ctx.handler) {
            if (ctx.handler !== value) {
              off('mousemoveoutside', el, ctx.handler);
              ctx.handler = value;
              on('mousemoveoutside', el, value);
            }
          } else {
            el[ctxKey$1].handler = value;
            on('mousemoveoutside', el, value);
          }
        } else {
          if (ctx.handler) {
            off('mousemoveoutside', el, ctx.handler);
            ctx.handler = undefined;
          }
        }
      },

      unmounted(el) {
        const {
          handler
        } = el[ctxKey$1];

        if (handler) {
          off('mousemoveoutside', el, handler);
        }

        el[ctxKey$1].handler = undefined;
      }

    };
    var mousemoveoutside$1 = mousemoveoutside;

    const ctxKey = '@@coContext';
    const clickoutside = {
      mounted(el, _ref) {
        let {
          value,
          modifiers
        } = _ref;
        el[ctxKey] = {
          handler: undefined
        };

        if (typeof value === 'function') {
          el[ctxKey].handler = value;
          on('clickoutside', el, value, {
            capture: modifiers.capture
          });
        }
      },

      updated(el, _ref2) {
        let {
          value,
          modifiers
        } = _ref2;
        const ctx = el[ctxKey];

        if (typeof value === 'function') {
          if (ctx.handler) {
            if (ctx.handler !== value) {
              off('clickoutside', el, ctx.handler, {
                capture: modifiers.capture
              });
              ctx.handler = value;
              on('clickoutside', el, value, {
                capture: modifiers.capture
              });
            }
          } else {
            el[ctxKey].handler = value;
            on('clickoutside', el, value, {
              capture: modifiers.capture
            });
          }
        } else {
          if (ctx.handler) {
            off('clickoutside', el, ctx.handler, {
              capture: modifiers.capture
            });
            ctx.handler = undefined;
          }
        }
      },

      unmounted(el, _ref3) {
        let {
          modifiers
        } = _ref3;
        const {
          handler
        } = el[ctxKey];

        if (handler) {
          off('clickoutside', el, handler, {
            capture: modifiers.capture
          });
        }

        el[ctxKey].handler = undefined;
      }

    };
    var clickoutside$1 = clickoutside;

    function warn$1(location, message) {
      console.error(`[vdirs/${location}]: ${message}`);
    }

    class ZIndexManager {
      constructor() {
        this.elementZIndex = new Map();
        this.nextZIndex = 2000;
      }

      get elementCount() {
        return this.elementZIndex.size;
      }

      ensureZIndex(el, zIndex) {
        const {
          elementZIndex
        } = this;

        if (zIndex !== undefined) {
          el.style.zIndex = `${zIndex}`;
          elementZIndex.delete(el);
          return;
        }

        const {
          nextZIndex
        } = this;

        if (elementZIndex.has(el)) {
          const currentZIndex = elementZIndex.get(el);
          if (currentZIndex + 1 === this.nextZIndex) return;
        }

        el.style.zIndex = `${nextZIndex}`;
        elementZIndex.set(el, nextZIndex);
        this.nextZIndex = nextZIndex + 1;
        this.squashState();
      }

      unregister(el, zIndex) {
        const {
          elementZIndex
        } = this;

        if (elementZIndex.has(el)) {
          elementZIndex.delete(el);
        } else if (zIndex === undefined) {
          warn$1('z-index-manager/unregister-element', 'Element not found when unregistering.');
        }

        this.squashState();
      }

      squashState() {
        const {
          elementCount
        } = this;

        if (!elementCount) {
          this.nextZIndex = 2000;
        }

        if (this.nextZIndex - elementCount > 2500) this.rearrange();
      }

      rearrange() {
        const elementZIndexPair = Array.from(this.elementZIndex.entries());
        elementZIndexPair.sort((pair1, pair2) => {
          return pair1[1] - pair2[1];
        });
        this.nextZIndex = 2000;
        elementZIndexPair.forEach(pair => {
          const el = pair[0];
          const zIndex = this.nextZIndex++;
          if (`${zIndex}` !== el.style.zIndex) el.style.zIndex = `${zIndex}`;
        });
      }

    }

    var zIndexManager = new ZIndexManager();

    const ctx = '@@ziContext'; // We don't expect manually bound zindex should be changed

    const zindexable = {
      mounted(el, bindings) {
        const {
          value = {}
        } = bindings;
        const {
          zIndex,
          enabled
        } = value;
        el[ctx] = {
          enabled: !!enabled,
          initialized: false
        };

        if (enabled) {
          zIndexManager.ensureZIndex(el, zIndex);
          el[ctx].initialized = true;
        }
      },

      updated(el, bindings) {
        const {
          value = {}
        } = bindings;
        const {
          zIndex,
          enabled
        } = value;
        const cachedEnabled = el[ctx].enabled;

        if (enabled && !cachedEnabled) {
          zIndexManager.ensureZIndex(el, zIndex);
          el[ctx].initialized = true;
        }

        el[ctx].enabled = !!enabled;
      },

      unmounted(el, bindings) {
        if (!el[ctx].initialized) return;
        const {
          value = {}
        } = bindings;
        const {
          zIndex
        } = value;
        zIndexManager.unregister(el, zIndex);
      }

    };
    var zindexable$1 = zindexable;

    const ssrContextKey = Symbol('@css-render/vue3-ssr');

    function createStyleString(id, style) {
      return `<style cssr-id="${id}">\n${style}\n</style>`;
    }

    function ssrAdapter(id, style) {
      const ssrContext = vue.inject(ssrContextKey, null);

      if (ssrContext === null) {
        console.error('[css-render/vue3-ssr]: no ssr context found.');
        return;
      }

      const {
        styles,
        ids
      } = ssrContext; // we need to impl other options to make it behaves the same as the client side

      if (ids.has(id)) return;

      if (styles !== null) {
        ids.add(id);
        styles.push(createStyleString(id, style));
      }
    }

    const isBrowser = typeof document !== 'undefined';
    function useSsrAdapter() {
      if (isBrowser) return undefined;
      const context = vue.inject(ssrContextKey, null);
      if (context === null) return undefined;
      return {
        adapter: ssrAdapter,
        context
      };
    }

    function warn(location, message) {
      console.error(`[vueuc/${location}]: ${message}`);
    }

    const {
      c
    } = CssRender();
    const cssrAnchorMetaName$1 = 'vueuc-style';

    function lowBit(n) {
      return n & -n;
    }

    class FinweckTree {
      /**
       * @param l length of the array
       * @param min min value of the array
       */
      constructor(l, min) {
        this.l = l;
        this.min = min;
        const ft = new Array(l + 1);

        for (let i = 0; i < l + 1; ++i) {
          ft[i] = 0;
        }

        this.ft = ft;
      }
      /**
       * Add arr[i] by n, start from 0
       * @param i the index of the element to be added
       * @param n the value to be added
       */


      add(i, n) {
        if (n === 0) return;
        const {
          l,
          ft
        } = this;
        i += 1;

        while (i <= l) {
          ft[i] += n;
          i += lowBit(i);
        }
      }
      /**
       * Get the value of index i
       * @param i index
       * @returns value of the index
       */


      get(i) {
        return this.sum(i + 1) - this.sum(i);
      }
      /**
       * Get the sum of first i elements
       * @param i count of head elements to be added
       * @returns the sum of first i elements
       */


      sum(i) {
        if (i === undefined) i = this.l;
        if (i <= 0) return 0;
        const {
          ft,
          min,
          l
        } = this;
        if (i > l) throw new Error('[FinweckTree.sum]: `i` is larger than length.');
        let ret = i * min;

        while (i > 0) {
          ret += ft[i];
          i -= lowBit(i);
        }

        return ret;
      }
      /**
       * Get the largest count of head elements whose sum are <= threshold
       * @param threshold
       * @returns the largest count of head elements whose sum are <= threshold
       */


      getBound(threshold) {
        let l = 0;
        let r = this.l;

        while (r > l) {
          const m = Math.floor((l + r) / 2);
          const sumM = this.sum(m);

          if (sumM > threshold) {
            r = m;
            continue;
          } else if (sumM < threshold) {
            if (l === m) {
              if (this.sum(l + 1) <= threshold) return l + 1;
              return m;
            }

            l = m;
          } else {
            return m;
          }
        }

        return l;
      }

    }

    function resolveTo(selector) {
      if (typeof selector === 'string') {
        return document.querySelector(selector);
      }

      return selector();
    }

    var LazyTeleport = vue.defineComponent({
      name: 'LazyTeleport',
      props: {
        to: {
          type: [String, Object],
          default: undefined
        },
        disabled: Boolean,
        show: {
          type: Boolean,
          required: true
        }
      },

      setup(props) {
        return {
          showTeleport: useFalseUntilTruthy(vue.toRef(props, 'show')),
          mergedTo: vue.computed(() => {
            const {
              to
            } = props;
            return to !== null && to !== void 0 ? to : 'body';
          })
        };
      },

      render() {
        return this.showTeleport ? this.disabled ? getSlot('lazy-teleport', this.$slots) : vue.h(vue.Teleport, {
          disabled: this.disabled,
          to: this.mergedTo
        }, getSlot('lazy-teleport', this.$slots)) : null;
      }

    });

    const oppositionPositions = {
      top: 'bottom',
      bottom: 'top',
      left: 'right',
      right: 'left'
    };
    const oppositeAligns = {
      start: 'end',
      center: 'center',
      end: 'start'
    };
    const propToCompare = {
      top: 'height',
      bottom: 'height',
      left: 'width',
      right: 'width'
    };
    const transformOrigins = {
      'bottom-start': 'top left',
      bottom: 'top center',
      'bottom-end': 'top right',
      'top-start': 'bottom left',
      top: 'bottom center',
      'top-end': 'bottom right',
      'right-start': 'top left',
      right: 'center left',
      'right-end': 'bottom left',
      'left-start': 'top right',
      left: 'center right',
      'left-end': 'bottom right'
    };
    const overlapTransformOrigin = {
      'bottom-start': 'bottom left',
      bottom: 'bottom center',
      'bottom-end': 'bottom right',
      'top-start': 'top left',
      top: 'top center',
      'top-end': 'top right',
      'right-start': 'top right',
      right: 'center right',
      'right-end': 'bottom right',
      'left-start': 'top left',
      left: 'center left',
      'left-end': 'bottom left'
    };
    const oppositeAlignCssPositionProps = {
      'bottom-start': 'right',
      'bottom-end': 'left',
      'top-start': 'right',
      'top-end': 'left',
      'right-start': 'bottom',
      'right-end': 'top',
      'left-start': 'bottom',
      'left-end': 'top'
    };
    const keepOffsetDirection = {
      top: true,
      bottom: false,
      left: true,
      right: false // left--

    };
    const cssPositionToOppositeAlign = {
      top: 'end',
      bottom: 'start',
      left: 'end',
      right: 'start'
    };
    function getPlacementAndOffsetOfFollower(placement, targetRect, followerRect, shift, flip, overlap) {
      if (!flip || overlap) {
        return {
          placement: placement,
          top: 0,
          left: 0
        };
      }

      const [position, align] = placement.split('-');
      let properAlign = align !== null && align !== void 0 ? align : 'center';
      let properOffset = {
        top: 0,
        left: 0
      };

      const deriveOffset = (oppositeAlignCssSizeProp, alignCssPositionProp, offsetVertically) => {
        let left = 0;
        let top = 0;
        const diff = followerRect[oppositeAlignCssSizeProp] - targetRect[alignCssPositionProp] - targetRect[oppositeAlignCssSizeProp];

        if (diff > 0 && shift) {
          if (offsetVertically) {
            //       screen border
            // |-----------------------------------------|
            // |                    | f  |               |
            // |                    | o  |               |
            // |                    | l  |               |
            // |                    | l  |----           |
            // |                    | o  |tar |          |
            // |                    | w  |get |          |
            // |                    | e  |    |          |
            // |                    | r  |----           |
            // |                     ----                |
            // |-----------------------------------------|
            top = keepOffsetDirection[alignCssPositionProp] ? diff : -diff;
          } else {
            //       screen border
            // |----------------------------------------|
            // |                                        |
            // |          ----------                    |
            // |          | target |                    |
            // |       ----------------------------------
            // |       |       follower                 |
            // |       ----------------------------------
            // |                                        |
            // |----------------------------------------|
            left = keepOffsetDirection[alignCssPositionProp] ? diff : -diff;
          }
        }

        return {
          left,
          top
        };
      };

      const offsetVertically = position === 'left' || position === 'right'; // choose proper placement for non-center align

      if (properAlign !== 'center') {
        const oppositeAlignCssPositionProp = oppositeAlignCssPositionProps[placement];
        const currentAlignCssPositionProp = oppositionPositions[oppositeAlignCssPositionProp];
        const oppositeAlignCssSizeProp = propToCompare[oppositeAlignCssPositionProp]; // if follower rect is larger than target rect in align direction
        // ----------[ target ]---------|
        // ----------[     follower     ]

        if (followerRect[oppositeAlignCssSizeProp] > targetRect[oppositeAlignCssSizeProp]) {
          if ( // current space is not enough
          // ----------[ target ]---------|
          // -------[     follower        ]
          targetRect[oppositeAlignCssPositionProp] + targetRect[oppositeAlignCssSizeProp] < followerRect[oppositeAlignCssSizeProp]) {
            const followerOverTargetSize = (followerRect[oppositeAlignCssSizeProp] - targetRect[oppositeAlignCssSizeProp]) / 2;

            if (targetRect[oppositeAlignCssPositionProp] < followerOverTargetSize || targetRect[currentAlignCssPositionProp] < followerOverTargetSize) {
              // opposite align has larger space
              // -------[ target ]-----------|
              // -------[     follower     ]-|
              if (targetRect[oppositeAlignCssPositionProp] < targetRect[currentAlignCssPositionProp]) {
                properAlign = oppositeAligns[align];
                properOffset = deriveOffset(oppositeAlignCssSizeProp, currentAlignCssPositionProp, offsetVertically);
              } else {
                // ----------------[ target ]----|
                // --------[   follower     ]----|
                properOffset = deriveOffset(oppositeAlignCssSizeProp, oppositeAlignCssPositionProp, offsetVertically);
              }
            } else {
              // 'center' align is better
              // ------------[ target ]--------|
              // -------[       follower    ]--|
              properAlign = 'center';
            }
          }
        } else if (followerRect[oppositeAlignCssSizeProp] < targetRect[oppositeAlignCssSizeProp]) {
          // TODO: maybe center is better
          if (targetRect[currentAlignCssPositionProp] < 0 && // opposite align has larger space
          // ------------[   target   ]
          // ----------------[follower]
          targetRect[oppositeAlignCssPositionProp] > targetRect[currentAlignCssPositionProp]) {
            properAlign = oppositeAligns[align];
          }
        }
      } else {
        const possibleAlternativeAlignCssPositionProp1 = position === 'bottom' || position === 'top' ? 'left' : 'top';
        const possibleAlternativeAlignCssPositionProp2 = oppositionPositions[possibleAlternativeAlignCssPositionProp1];
        const alternativeAlignCssSizeProp = propToCompare[possibleAlternativeAlignCssPositionProp1];
        const followerOverTargetSize = (followerRect[alternativeAlignCssSizeProp] - targetRect[alternativeAlignCssSizeProp]) / 2;

        if ( // center is not enough
        // ----------- [ target ]--|
        // -------[     follower     ]
        targetRect[possibleAlternativeAlignCssPositionProp1] < followerOverTargetSize || targetRect[possibleAlternativeAlignCssPositionProp2] < followerOverTargetSize) {
          // alternative 2 position's space is larger
          if (targetRect[possibleAlternativeAlignCssPositionProp1] > targetRect[possibleAlternativeAlignCssPositionProp2]) {
            properAlign = cssPositionToOppositeAlign[possibleAlternativeAlignCssPositionProp1];
            properOffset = deriveOffset(alternativeAlignCssSizeProp, possibleAlternativeAlignCssPositionProp1, offsetVertically);
          } else {
            // alternative 1 position's space is larger
            properAlign = cssPositionToOppositeAlign[possibleAlternativeAlignCssPositionProp2];
            properOffset = deriveOffset(alternativeAlignCssSizeProp, possibleAlternativeAlignCssPositionProp2, offsetVertically);
          }
        }
      }

      let properPosition = position;

      if ( // space is not enough
      targetRect[position] < followerRect[propToCompare[position]] && // opposite position's space is larger
      targetRect[position] < targetRect[oppositionPositions[position]]) {
        properPosition = oppositionPositions[position];
      }

      return {
        placement: properAlign !== 'center' ? `${properPosition}-${properAlign}` : properPosition,
        left: properOffset.left,
        top: properOffset.top
      };
    }
    function getProperTransformOrigin(placement, overlap) {
      if (overlap) return overlapTransformOrigin[placement];
      return transformOrigins[placement];
    } // ------------
    // |  offset  |
    // |          |
    // | [target] |
    // |          |
    // ------------
    // TODO: refactor it to remove dup logic

    function getOffset$1(placement, offsetRect, targetRect, offsetTopToStandardPlacement, offsetLeftToStandardPlacement, overlap) {
      if (overlap) {
        switch (placement) {
          case 'bottom-start':
            return {
              top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height)}px`,
              left: `${Math.round(targetRect.left - offsetRect.left)}px`,
              transform: 'translateY(-100%)'
            };

          case 'bottom-end':
            return {
              top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height)}px`,
              left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width)}px`,
              transform: 'translateX(-100%) translateY(-100%)'
            };

          case 'top-start':
            return {
              top: `${Math.round(targetRect.top - offsetRect.top)}px`,
              left: `${Math.round(targetRect.left - offsetRect.left)}px`,
              transform: ''
            };

          case 'top-end':
            return {
              top: `${Math.round(targetRect.top - offsetRect.top)}px`,
              left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width)}px`,
              transform: 'translateX(-100%)'
            };

          case 'right-start':
            return {
              top: `${Math.round(targetRect.top - offsetRect.top)}px`,
              left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width)}px`,
              transform: 'translateX(-100%)'
            };

          case 'right-end':
            return {
              top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height)}px`,
              left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width)}px`,
              transform: 'translateX(-100%) translateY(-100%)'
            };

          case 'left-start':
            return {
              top: `${Math.round(targetRect.top - offsetRect.top)}px`,
              left: `${Math.round(targetRect.left - offsetRect.left)}px`,
              transform: ''
            };

          case 'left-end':
            return {
              top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height)}px`,
              left: `${Math.round(targetRect.left - offsetRect.left)}px`,
              transform: 'translateY(-100%)'
            };

          case 'top':
            return {
              top: `${Math.round(targetRect.top - offsetRect.top)}px`,
              left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width / 2)}px`,
              transform: 'translateX(-50%)'
            };

          case 'right':
            return {
              top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height / 2)}px`,
              left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width)}px`,
              transform: 'translateX(-100%) translateY(-50%)'
            };

          case 'left':
            return {
              top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height / 2)}px`,
              left: `${Math.round(targetRect.left - offsetRect.left)}px`,
              transform: 'translateY(-50%)'
            };

          case 'bottom':
          default:
            return {
              top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height)}px`,
              left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width / 2)}px`,
              transform: 'translateX(-50%) translateY(-100%)'
            };
        }
      }

      switch (placement) {
        case 'bottom-start':
          return {
            top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height + offsetTopToStandardPlacement)}px`,
            left: `${Math.round(targetRect.left - offsetRect.left + offsetLeftToStandardPlacement)}px`,
            transform: ''
          };

        case 'bottom-end':
          return {
            top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height + offsetTopToStandardPlacement)}px`,
            left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width + offsetLeftToStandardPlacement)}px`,
            transform: 'translateX(-100%)'
          };

        case 'top-start':
          return {
            top: `${Math.round(targetRect.top - offsetRect.top + offsetTopToStandardPlacement)}px`,
            left: `${Math.round(targetRect.left - offsetRect.left + offsetLeftToStandardPlacement)}px`,
            transform: 'translateY(-100%)'
          };

        case 'top-end':
          return {
            top: `${Math.round(targetRect.top - offsetRect.top + offsetTopToStandardPlacement)}px`,
            left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width + offsetLeftToStandardPlacement)}px`,
            transform: 'translateX(-100%) translateY(-100%)'
          };

        case 'right-start':
          return {
            top: `${Math.round(targetRect.top - offsetRect.top + offsetTopToStandardPlacement)}px`,
            left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width + offsetLeftToStandardPlacement)}px`,
            transform: ''
          };

        case 'right-end':
          return {
            top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height + offsetTopToStandardPlacement)}px`,
            left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width + offsetLeftToStandardPlacement)}px`,
            transform: 'translateY(-100%)'
          };

        case 'left-start':
          return {
            top: `${Math.round(targetRect.top - offsetRect.top + offsetTopToStandardPlacement)}px`,
            left: `${Math.round(targetRect.left - offsetRect.left + offsetLeftToStandardPlacement)}px`,
            transform: 'translateX(-100%)'
          };

        case 'left-end':
          return {
            top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height + offsetTopToStandardPlacement)}px`,
            left: `${Math.round(targetRect.left - offsetRect.left + offsetLeftToStandardPlacement)}px`,
            transform: 'translateX(-100%) translateY(-100%)'
          };

        case 'top':
          return {
            top: `${Math.round(targetRect.top - offsetRect.top + offsetTopToStandardPlacement)}px`,
            left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width / 2 + offsetLeftToStandardPlacement)}px`,
            transform: 'translateY(-100%) translateX(-50%)'
          };

        case 'right':
          return {
            top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height / 2 + offsetTopToStandardPlacement)}px`,
            left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width + offsetLeftToStandardPlacement)}px`,
            transform: 'translateY(-50%)'
          };

        case 'left':
          return {
            top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height / 2 + offsetTopToStandardPlacement)}px`,
            left: `${Math.round(targetRect.left - offsetRect.left + offsetLeftToStandardPlacement)}px`,
            transform: 'translateY(-50%) translateX(-100%)'
          };

        case 'bottom':
        default:
          return {
            top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height + offsetTopToStandardPlacement)}px`,
            left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width / 2 + offsetLeftToStandardPlacement)}px`,
            transform: 'translateX(-50%)'
          };
      }
    }

    /* eslint-disable @typescript-eslint/no-non-null-assertion */
    const style$1B = c([c('.v-binder-follower-container', {
      position: 'absolute',
      left: '0',
      right: '0',
      top: '0',
      height: '0',
      pointerEvents: 'none',
      zIndex: 'auto'
    }), c('.v-binder-follower-content', {
      position: 'absolute',
      zIndex: 'auto'
    }, [c('> *', {
      pointerEvents: 'all'
    })])]);
    var VFollower = vue.defineComponent({
      name: 'Follower',
      inheritAttrs: false,
      props: {
        show: Boolean,
        enabled: {
          type: Boolean,
          default: undefined
        },
        placement: {
          type: String,
          default: 'bottom'
        },
        syncTrigger: {
          type: Array,
          default: ['resize', 'scroll']
        },
        to: [String, Object],
        flip: {
          type: Boolean,
          default: true
        },
        internalShift: Boolean,
        x: Number,
        y: Number,
        width: String,
        minWidth: String,
        containerClass: String,
        teleportDisabled: Boolean,
        zindexable: {
          type: Boolean,
          default: true
        },
        zIndex: Number,
        overlap: Boolean
      },

      setup(props) {
        const VBinder = vue.inject('VBinder');
        const mergedEnabledRef = useMemo(() => {
          return props.enabled !== undefined ? props.enabled : props.show;
        });
        const followerRef = vue.ref(null);
        const offsetContainerRef = vue.ref(null);

        const ensureListeners = () => {
          const {
            syncTrigger
          } = props;

          if (syncTrigger.includes('scroll')) {
            VBinder.addScrollListener(syncPosition);
          }

          if (syncTrigger.includes('resize')) {
            VBinder.addResizeListener(syncPosition);
          }
        };

        const removeListeners = () => {
          VBinder.removeScrollListener(syncPosition);
          VBinder.removeResizeListener(syncPosition);
        };

        vue.onMounted(() => {
          if (mergedEnabledRef.value) {
            syncPosition();
            ensureListeners();
          }
        });
        const ssrAdapter = useSsrAdapter();
        style$1B.mount({
          id: 'vueuc/binder',
          head: true,
          anchorMetaName: cssrAnchorMetaName$1,
          ssr: ssrAdapter
        });
        vue.onBeforeUnmount(() => {
          removeListeners();
        });
        onFontsReady(() => {
          if (mergedEnabledRef.value) {
            syncPosition();
          }
        });

        const syncPosition = () => {
          if (!mergedEnabledRef.value) {
            return;
          }

          const follower = followerRef.value; // sometimes watched props change before its dom is ready
          // for example: show=false, x=undefined, y=undefined
          //              show=true,  x=0,         y=0
          // will cause error
          // I may optimize the watch start point later

          if (follower === null) return;
          const target = VBinder.targetRef;
          const {
            x,
            y,
            overlap
          } = props;
          const targetRect = x !== undefined && y !== undefined ? getPointRect(x, y) : getRect$1(target);
          follower.style.setProperty('--v-target-width', `${Math.round(targetRect.width)}px`);
          follower.style.setProperty('--v-target-height', `${Math.round(targetRect.height)}px`);
          const {
            width,
            minWidth,
            placement,
            internalShift,
            flip
          } = props;
          follower.setAttribute('v-placement', placement);

          if (overlap) {
            follower.setAttribute('v-overlap', '');
          } else {
            follower.removeAttribute('v-overlap');
          }

          const {
            style
          } = follower;

          if (width === 'target') {
            style.width = `${targetRect.width}px`;
          } else if (width !== undefined) {
            style.width = width;
          } else {
            style.width = '';
          }

          if (minWidth === 'target') {
            style.minWidth = `${targetRect.width}px`;
          } else if (minWidth !== undefined) {
            style.minWidth = minWidth;
          } else {
            style.minWidth = '';
          }

          const followerRect = getRect$1(follower);
          const offsetContainerRect = getRect$1(offsetContainerRef.value);
          const {
            left: offsetLeftToStandardPlacement,
            top: offsetTopToStandardPlacement,
            placement: properPlacement
          } = getPlacementAndOffsetOfFollower(placement, targetRect, followerRect, internalShift, flip, overlap);
          const properTransformOrigin = getProperTransformOrigin(properPlacement, overlap);
          const {
            left,
            top,
            transform
          } = getOffset$1(properPlacement, offsetContainerRect, targetRect, offsetTopToStandardPlacement, offsetLeftToStandardPlacement, overlap); // we assume that the content size doesn't change after flip,
          // nor we need to make sync logic more complex

          follower.setAttribute('v-placement', properPlacement);
          follower.style.setProperty('--v-offset-left', `${Math.round(offsetLeftToStandardPlacement)}px`);
          follower.style.setProperty('--v-offset-top', `${Math.round(offsetTopToStandardPlacement)}px`);
          follower.style.transform = `translateX(${left}) translateY(${top}) ${transform}`;
          follower.style.setProperty('--v-transform-origin', properTransformOrigin);
          follower.style.transformOrigin = properTransformOrigin;
        };

        vue.watch(mergedEnabledRef, value => {
          if (value) {
            ensureListeners();
            syncOnNextTick();
          } else {
            removeListeners();
          }
        });

        const syncOnNextTick = () => {
          vue.nextTick().then(syncPosition).catch(e => console.error(e));
        };

        ['placement', 'x', 'y', 'internalShift', 'flip', 'width', 'overlap', 'minWidth'].forEach(prop => {
          vue.watch(vue.toRef(props, prop), syncPosition);
        });
        ['teleportDisabled'].forEach(prop => {
          vue.watch(vue.toRef(props, prop), syncOnNextTick);
        });
        vue.watch(vue.toRef(props, 'syncTrigger'), value => {
          if (!value.includes('resize')) {
            VBinder.removeResizeListener(syncPosition);
          } else {
            VBinder.addResizeListener(syncPosition);
          }

          if (!value.includes('scroll')) {
            VBinder.removeScrollListener(syncPosition);
          } else {
            VBinder.addScrollListener(syncPosition);
          }
        });
        const isMountedRef = isMounted();
        const mergedToRef = useMemo(() => {
          const {
            to
          } = props;
          if (to !== undefined) return to;

          if (isMountedRef.value) {
            // TODO: find proper container
            return undefined;
          }

          return undefined;
        });
        return {
          VBinder,
          mergedEnabled: mergedEnabledRef,
          offsetContainerRef,
          followerRef,
          mergedTo: mergedToRef,
          syncPosition
        };
      },

      render() {
        return vue.h(LazyTeleport, {
          show: this.show,
          to: this.mergedTo,
          disabled: this.teleportDisabled
        }, {
          default: () => {
            var _a, _b;

            const vNode = vue.h('div', {
              class: ['v-binder-follower-container', this.containerClass],
              ref: 'offsetContainerRef'
            }, [vue.h('div', {
              class: 'v-binder-follower-content',
              ref: 'followerRef'
            }, (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a))]);

            if (this.zindexable) {
              return vue.withDirectives(vNode, [[zindexable$1, {
                enabled: this.mergedEnabled,
                zIndex: this.zIndex
              }]]);
            }

            return vNode;
          }
        });
      }

    });

    var resizeObservers = [];

    var hasActiveObservations = function () {
      return resizeObservers.some(function (ro) {
        return ro.activeTargets.length > 0;
      });
    };

    var hasSkippedObservations = function () {
      return resizeObservers.some(function (ro) {
        return ro.skippedTargets.length > 0;
      });
    };

    var msg = 'ResizeObserver loop completed with undelivered notifications.';

    var deliverResizeLoopError = function () {
      var event;

      if (typeof ErrorEvent === 'function') {
        event = new ErrorEvent('error', {
          message: msg
        });
      } else {
        event = document.createEvent('Event');
        event.initEvent('error', false, false);
        event.message = msg;
      }

      window.dispatchEvent(event);
    };

    var ResizeObserverBoxOptions;

    (function (ResizeObserverBoxOptions) {
      ResizeObserverBoxOptions["BORDER_BOX"] = "border-box";
      ResizeObserverBoxOptions["CONTENT_BOX"] = "content-box";
      ResizeObserverBoxOptions["DEVICE_PIXEL_CONTENT_BOX"] = "device-pixel-content-box";
    })(ResizeObserverBoxOptions || (ResizeObserverBoxOptions = {}));

    var freeze = function (obj) {
      return Object.freeze(obj);
    };

    var ResizeObserverSize = function () {
      function ResizeObserverSize(inlineSize, blockSize) {
        this.inlineSize = inlineSize;
        this.blockSize = blockSize;
        freeze(this);
      }

      return ResizeObserverSize;
    }();

    var DOMRectReadOnly = function () {
      function DOMRectReadOnly(x, y, width, height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.top = this.y;
        this.left = this.x;
        this.bottom = this.top + this.height;
        this.right = this.left + this.width;
        return freeze(this);
      }

      DOMRectReadOnly.prototype.toJSON = function () {
        var _a = this,
            x = _a.x,
            y = _a.y,
            top = _a.top,
            right = _a.right,
            bottom = _a.bottom,
            left = _a.left,
            width = _a.width,
            height = _a.height;

        return {
          x: x,
          y: y,
          top: top,
          right: right,
          bottom: bottom,
          left: left,
          width: width,
          height: height
        };
      };

      DOMRectReadOnly.fromRect = function (rectangle) {
        return new DOMRectReadOnly(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
      };

      return DOMRectReadOnly;
    }();

    var isSVG = function (target) {
      return target instanceof SVGElement && 'getBBox' in target;
    };

    var isHidden = function (target) {
      if (isSVG(target)) {
        var _a = target.getBBox(),
            width = _a.width,
            height = _a.height;

        return !width && !height;
      }

      var _b = target,
          offsetWidth = _b.offsetWidth,
          offsetHeight = _b.offsetHeight;
      return !(offsetWidth || offsetHeight || target.getClientRects().length);
    };

    var isElement = function (obj) {
      var _a, _b;

      if (obj instanceof Element) {
        return true;
      }

      var scope = (_b = (_a = obj) === null || _a === void 0 ? void 0 : _a.ownerDocument) === null || _b === void 0 ? void 0 : _b.defaultView;
      return !!(scope && obj instanceof scope.Element);
    };

    var isReplacedElement = function (target) {
      switch (target.tagName) {
        case 'INPUT':
          if (target.type !== 'image') {
            break;
          }

        case 'VIDEO':
        case 'AUDIO':
        case 'EMBED':
        case 'OBJECT':
        case 'CANVAS':
        case 'IFRAME':
        case 'IMG':
          return true;
      }

      return false;
    };

    var global$1 = typeof window !== 'undefined' ? window : {};

    var cache = new WeakMap();
    var scrollRegexp = /auto|scroll/;
    var verticalRegexp = /^tb|vertical/;
    var IE = /msie|trident/i.test(global$1.navigator && global$1.navigator.userAgent);

    var parseDimension = function (pixel) {
      return parseFloat(pixel || '0');
    };

    var size = function (inlineSize, blockSize, switchSizes) {
      if (inlineSize === void 0) {
        inlineSize = 0;
      }

      if (blockSize === void 0) {
        blockSize = 0;
      }

      if (switchSizes === void 0) {
        switchSizes = false;
      }

      return new ResizeObserverSize((switchSizes ? blockSize : inlineSize) || 0, (switchSizes ? inlineSize : blockSize) || 0);
    };

    var zeroBoxes = freeze({
      devicePixelContentBoxSize: size(),
      borderBoxSize: size(),
      contentBoxSize: size(),
      contentRect: new DOMRectReadOnly(0, 0, 0, 0)
    });

    var calculateBoxSizes = function (target, forceRecalculation) {
      if (forceRecalculation === void 0) {
        forceRecalculation = false;
      }

      if (cache.has(target) && !forceRecalculation) {
        return cache.get(target);
      }

      if (isHidden(target)) {
        cache.set(target, zeroBoxes);
        return zeroBoxes;
      }

      var cs = getComputedStyle(target);
      var svg = isSVG(target) && target.ownerSVGElement && target.getBBox();
      var removePadding = !IE && cs.boxSizing === 'border-box';
      var switchSizes = verticalRegexp.test(cs.writingMode || '');
      var canScrollVertically = !svg && scrollRegexp.test(cs.overflowY || '');
      var canScrollHorizontally = !svg && scrollRegexp.test(cs.overflowX || '');
      var paddingTop = svg ? 0 : parseDimension(cs.paddingTop);
      var paddingRight = svg ? 0 : parseDimension(cs.paddingRight);
      var paddingBottom = svg ? 0 : parseDimension(cs.paddingBottom);
      var paddingLeft = svg ? 0 : parseDimension(cs.paddingLeft);
      var borderTop = svg ? 0 : parseDimension(cs.borderTopWidth);
      var borderRight = svg ? 0 : parseDimension(cs.borderRightWidth);
      var borderBottom = svg ? 0 : parseDimension(cs.borderBottomWidth);
      var borderLeft = svg ? 0 : parseDimension(cs.borderLeftWidth);
      var horizontalPadding = paddingLeft + paddingRight;
      var verticalPadding = paddingTop + paddingBottom;
      var horizontalBorderArea = borderLeft + borderRight;
      var verticalBorderArea = borderTop + borderBottom;
      var horizontalScrollbarThickness = !canScrollHorizontally ? 0 : target.offsetHeight - verticalBorderArea - target.clientHeight;
      var verticalScrollbarThickness = !canScrollVertically ? 0 : target.offsetWidth - horizontalBorderArea - target.clientWidth;
      var widthReduction = removePadding ? horizontalPadding + horizontalBorderArea : 0;
      var heightReduction = removePadding ? verticalPadding + verticalBorderArea : 0;
      var contentWidth = svg ? svg.width : parseDimension(cs.width) - widthReduction - verticalScrollbarThickness;
      var contentHeight = svg ? svg.height : parseDimension(cs.height) - heightReduction - horizontalScrollbarThickness;
      var borderBoxWidth = contentWidth + horizontalPadding + verticalScrollbarThickness + horizontalBorderArea;
      var borderBoxHeight = contentHeight + verticalPadding + horizontalScrollbarThickness + verticalBorderArea;
      var boxes = freeze({
        devicePixelContentBoxSize: size(Math.round(contentWidth * devicePixelRatio), Math.round(contentHeight * devicePixelRatio), switchSizes),
        borderBoxSize: size(borderBoxWidth, borderBoxHeight, switchSizes),
        contentBoxSize: size(contentWidth, contentHeight, switchSizes),
        contentRect: new DOMRectReadOnly(paddingLeft, paddingTop, contentWidth, contentHeight)
      });
      cache.set(target, boxes);
      return boxes;
    };

    var calculateBoxSize = function (target, observedBox, forceRecalculation) {
      var _a = calculateBoxSizes(target, forceRecalculation),
          borderBoxSize = _a.borderBoxSize,
          contentBoxSize = _a.contentBoxSize,
          devicePixelContentBoxSize = _a.devicePixelContentBoxSize;

      switch (observedBox) {
        case ResizeObserverBoxOptions.DEVICE_PIXEL_CONTENT_BOX:
          return devicePixelContentBoxSize;

        case ResizeObserverBoxOptions.BORDER_BOX:
          return borderBoxSize;

        default:
          return contentBoxSize;
      }
    };

    var ResizeObserverEntry = function () {
      function ResizeObserverEntry(target) {
        var boxes = calculateBoxSizes(target);
        this.target = target;
        this.contentRect = boxes.contentRect;
        this.borderBoxSize = freeze([boxes.borderBoxSize]);
        this.contentBoxSize = freeze([boxes.contentBoxSize]);
        this.devicePixelContentBoxSize = freeze([boxes.devicePixelContentBoxSize]);
      }

      return ResizeObserverEntry;
    }();

    var calculateDepthForNode = function (node) {
      if (isHidden(node)) {
        return Infinity;
      }

      var depth = 0;
      var parent = node.parentNode;

      while (parent) {
        depth += 1;
        parent = parent.parentNode;
      }

      return depth;
    };

    var broadcastActiveObservations = function () {
      var shallowestDepth = Infinity;
      var callbacks = [];
      resizeObservers.forEach(function processObserver(ro) {
        if (ro.activeTargets.length === 0) {
          return;
        }

        var entries = [];
        ro.activeTargets.forEach(function processTarget(ot) {
          var entry = new ResizeObserverEntry(ot.target);
          var targetDepth = calculateDepthForNode(ot.target);
          entries.push(entry);
          ot.lastReportedSize = calculateBoxSize(ot.target, ot.observedBox);

          if (targetDepth < shallowestDepth) {
            shallowestDepth = targetDepth;
          }
        });
        callbacks.push(function resizeObserverCallback() {
          ro.callback.call(ro.observer, entries, ro.observer);
        });
        ro.activeTargets.splice(0, ro.activeTargets.length);
      });

      for (var _i = 0, callbacks_1 = callbacks; _i < callbacks_1.length; _i++) {
        var callback = callbacks_1[_i];
        callback();
      }

      return shallowestDepth;
    };

    var gatherActiveObservationsAtDepth = function (depth) {
      resizeObservers.forEach(function processObserver(ro) {
        ro.activeTargets.splice(0, ro.activeTargets.length);
        ro.skippedTargets.splice(0, ro.skippedTargets.length);
        ro.observationTargets.forEach(function processTarget(ot) {
          if (ot.isActive()) {
            if (calculateDepthForNode(ot.target) > depth) {
              ro.activeTargets.push(ot);
            } else {
              ro.skippedTargets.push(ot);
            }
          }
        });
      });
    };

    var process$1 = function () {
      var depth = 0;
      gatherActiveObservationsAtDepth(depth);

      while (hasActiveObservations()) {
        depth = broadcastActiveObservations();
        gatherActiveObservationsAtDepth(depth);
      }

      if (hasSkippedObservations()) {
        deliverResizeLoopError();
      }

      return depth > 0;
    };

    var trigger;
    var callbacks = [];

    var notify = function () {
      return callbacks.splice(0).forEach(function (cb) {
        return cb();
      });
    };

    var queueMicroTask = function (callback) {
      if (!trigger) {
        var toggle_1 = 0;
        var el_1 = document.createTextNode('');
        var config = {
          characterData: true
        };
        new MutationObserver(function () {
          return notify();
        }).observe(el_1, config);

        trigger = function () {
          el_1.textContent = "" + (toggle_1 ? toggle_1-- : toggle_1++);
        };
      }

      callbacks.push(callback);
      trigger();
    };

    var queueResizeObserver = function (cb) {
      queueMicroTask(function ResizeObserver() {
        requestAnimationFrame(cb);
      });
    };

    var watching = 0;

    var isWatching = function () {
      return !!watching;
    };

    var CATCH_PERIOD = 250;
    var observerConfig = {
      attributes: true,
      characterData: true,
      childList: true,
      subtree: true
    };
    var events = ['resize', 'load', 'transitionend', 'animationend', 'animationstart', 'animationiteration', 'keyup', 'keydown', 'mouseup', 'mousedown', 'mouseover', 'mouseout', 'blur', 'focus'];

    var time$1 = function (timeout) {
      if (timeout === void 0) {
        timeout = 0;
      }

      return Date.now() + timeout;
    };

    var scheduled = false;

    var Scheduler = function () {
      function Scheduler() {
        var _this = this;

        this.stopped = true;

        this.listener = function () {
          return _this.schedule();
        };
      }

      Scheduler.prototype.run = function (timeout) {
        var _this = this;

        if (timeout === void 0) {
          timeout = CATCH_PERIOD;
        }

        if (scheduled) {
          return;
        }

        scheduled = true;
        var until = time$1(timeout);
        queueResizeObserver(function () {
          var elementsHaveResized = false;

          try {
            elementsHaveResized = process$1();
          } finally {
            scheduled = false;
            timeout = until - time$1();

            if (!isWatching()) {
              return;
            }

            if (elementsHaveResized) {
              _this.run(1000);
            } else if (timeout > 0) {
              _this.run(timeout);
            } else {
              _this.start();
            }
          }
        });
      };

      Scheduler.prototype.schedule = function () {
        this.stop();
        this.run();
      };

      Scheduler.prototype.observe = function () {
        var _this = this;

        var cb = function () {
          return _this.observer && _this.observer.observe(document.body, observerConfig);
        };

        document.body ? cb() : global$1.addEventListener('DOMContentLoaded', cb);
      };

      Scheduler.prototype.start = function () {
        var _this = this;

        if (this.stopped) {
          this.stopped = false;
          this.observer = new MutationObserver(this.listener);
          this.observe();
          events.forEach(function (name) {
            return global$1.addEventListener(name, _this.listener, true);
          });
        }
      };

      Scheduler.prototype.stop = function () {
        var _this = this;

        if (!this.stopped) {
          this.observer && this.observer.disconnect();
          events.forEach(function (name) {
            return global$1.removeEventListener(name, _this.listener, true);
          });
          this.stopped = true;
        }
      };

      return Scheduler;
    }();

    var scheduler = new Scheduler();

    var updateCount = function (n) {
      !watching && n > 0 && scheduler.start();
      watching += n;
      !watching && scheduler.stop();
    };

    var skipNotifyOnElement = function (target) {
      return !isSVG(target) && !isReplacedElement(target) && getComputedStyle(target).display === 'inline';
    };

    var ResizeObservation = function () {
      function ResizeObservation(target, observedBox) {
        this.target = target;
        this.observedBox = observedBox || ResizeObserverBoxOptions.CONTENT_BOX;
        this.lastReportedSize = {
          inlineSize: 0,
          blockSize: 0
        };
      }

      ResizeObservation.prototype.isActive = function () {
        var size = calculateBoxSize(this.target, this.observedBox, true);

        if (skipNotifyOnElement(this.target)) {
          this.lastReportedSize = size;
        }

        if (this.lastReportedSize.inlineSize !== size.inlineSize || this.lastReportedSize.blockSize !== size.blockSize) {
          return true;
        }

        return false;
      };

      return ResizeObservation;
    }();

    var ResizeObserverDetail = function () {
      function ResizeObserverDetail(resizeObserver, callback) {
        this.activeTargets = [];
        this.skippedTargets = [];
        this.observationTargets = [];
        this.observer = resizeObserver;
        this.callback = callback;
      }

      return ResizeObserverDetail;
    }();

    var observerMap = new WeakMap();

    var getObservationIndex = function (observationTargets, target) {
      for (var i = 0; i < observationTargets.length; i += 1) {
        if (observationTargets[i].target === target) {
          return i;
        }
      }

      return -1;
    };

    var ResizeObserverController = function () {
      function ResizeObserverController() {}

      ResizeObserverController.connect = function (resizeObserver, callback) {
        var detail = new ResizeObserverDetail(resizeObserver, callback);
        observerMap.set(resizeObserver, detail);
      };

      ResizeObserverController.observe = function (resizeObserver, target, options) {
        var detail = observerMap.get(resizeObserver);
        var firstObservation = detail.observationTargets.length === 0;

        if (getObservationIndex(detail.observationTargets, target) < 0) {
          firstObservation && resizeObservers.push(detail);
          detail.observationTargets.push(new ResizeObservation(target, options && options.box));
          updateCount(1);
          scheduler.schedule();
        }
      };

      ResizeObserverController.unobserve = function (resizeObserver, target) {
        var detail = observerMap.get(resizeObserver);
        var index = getObservationIndex(detail.observationTargets, target);
        var lastObservation = detail.observationTargets.length === 1;

        if (index >= 0) {
          lastObservation && resizeObservers.splice(resizeObservers.indexOf(detail), 1);
          detail.observationTargets.splice(index, 1);
          updateCount(-1);
        }
      };

      ResizeObserverController.disconnect = function (resizeObserver) {
        var _this = this;

        var detail = observerMap.get(resizeObserver);
        detail.observationTargets.slice().forEach(function (ot) {
          return _this.unobserve(resizeObserver, ot.target);
        });
        detail.activeTargets.splice(0, detail.activeTargets.length);
      };

      return ResizeObserverController;
    }();

    var ResizeObserver = function () {
      function ResizeObserver(callback) {
        if (arguments.length === 0) {
          throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
        }

        if (typeof callback !== 'function') {
          throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
        }

        ResizeObserverController.connect(this, callback);
      }

      ResizeObserver.prototype.observe = function (target, options) {
        if (arguments.length === 0) {
          throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
        }

        if (!isElement(target)) {
          throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
        }

        ResizeObserverController.observe(this, target, options);
      };

      ResizeObserver.prototype.unobserve = function (target) {
        if (arguments.length === 0) {
          throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
        }

        if (!isElement(target)) {
          throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
        }

        ResizeObserverController.unobserve(this, target);
      };

      ResizeObserver.prototype.disconnect = function () {
        ResizeObserverController.disconnect(this);
      };

      ResizeObserver.toString = function () {
        return 'function ResizeObserver () { [polyfill code] }';
      };

      return ResizeObserver;
    }();

    class ResizeObserverDelegate {
      constructor() {
        this.handleResize = this.handleResize.bind(this);
        this.observer = new ResizeObserver(this.handleResize);
        this.elHandlersMap = new Map();
      }

      handleResize(entries) {
        for (const entry of entries) {
          const handler = this.elHandlersMap.get(entry.target);

          if (handler !== undefined) {
            handler(entry);
          }
        }
      }

      registerHandler(el, handler) {
        this.elHandlersMap.set(el, handler);
        this.observer.observe(el);
      }

      unregisterHandler(el) {
        if (!this.elHandlersMap.has(el)) {
          return;
        }

        this.elHandlersMap.delete(el);
        this.observer.unobserve(el);
      }

    }

    var resizeObserverManager = new ResizeObserverDelegate();

    var VResizeObserver = vue.defineComponent({
      name: 'ResizeObserver',
      props: {
        onResize: Function
      },

      setup(props) {
        let registered = false; // eslint-disable-next-line @typescript-eslint/no-non-null-assertion

        const proxy = vue.getCurrentInstance().proxy;

        function handleResize(entry) {
          const {
            onResize
          } = props;
          if (onResize !== undefined) onResize(entry);
        }

        vue.onMounted(() => {
          const el = proxy.$el;

          if (el === undefined) {
            warn('resize-observer', '$el does not exist.');
            return;
          }

          if (el.nextElementSibling !== el.nextSibling) {
            if (el.nodeType === 3 && el.nodeValue !== '') {
              warn('resize-observer', '$el can not be observed (it may be a text node).');
              return;
            }
          }

          if (el.nextElementSibling !== null) {
            resizeObserverManager.registerHandler(el.nextElementSibling, handleResize);
            registered = true;
          }
        });
        vue.onBeforeUnmount(() => {
          if (registered) {
            resizeObserverManager.unregisterHandler(proxy.$el.nextElementSibling);
          }
        });
      },

      render() {
        return vue.renderSlot(this.$slots, 'default');
      }

    });

    let maybeTouch;
    function ensureMaybeTouch() {
      if (maybeTouch === undefined) {
        if ('matchMedia' in window) {
          maybeTouch = window.matchMedia('(pointer:coarse)').matches;
        } else {
          maybeTouch = false;
        }
      }

      return maybeTouch;
    }
    let wheelScale;
    function ensureWheelScale() {
      if (wheelScale === undefined) {
        wheelScale = 'chrome' in window ? window.devicePixelRatio : 1;
      }

      return wheelScale;
    }

    /* eslint-disable no-void */
    const styles$1 = c('.v-vl', {
      maxHeight: 'inherit',
      height: '100%',
      overflow: 'auto',
      minWidth: '1px' // a zero width container won't be scrollable

    }, [c('&:not(.v-vl--show-scrollbar)', {
      scrollbarWidth: 'none'
    }, [c('&::-webkit-scrollbar, &::-webkit-scrollbar-track-piece, &::-webkit-scrollbar-thumb', {
      width: 0,
      height: 0,
      display: 'none'
    })])]);
    var VVirtualList = vue.defineComponent({
      name: 'VirtualList',
      inheritAttrs: false,
      props: {
        showScrollbar: {
          type: Boolean,
          default: true
        },
        items: {
          type: Array,
          default: () => []
        },
        // it is suppose to be the min height
        itemSize: {
          type: Number,
          required: true
        },
        itemResizable: Boolean,
        itemsStyle: [String, Object],
        visibleItemsTag: {
          type: [String, Object],
          default: 'div'
        },
        visibleItemsProps: Object,
        ignoreItemResize: Boolean,
        onScroll: Function,
        onWheel: Function,
        onResize: Function,
        defaultScrollKey: [Number, String],
        defaultScrollIndex: Number,
        keyField: {
          type: String,
          default: 'key'
        },
        // Whether it is a good API?
        // ResizeObserver + footer & header is not enough.
        // Too complex for simple case
        paddingTop: {
          type: [Number, String],
          default: 0
        },
        paddingBottom: {
          type: [Number, String],
          default: 0
        }
      },

      setup(props) {
        const ssrAdapter = useSsrAdapter();
        styles$1.mount({
          id: 'vueuc/virtual-list',
          head: true,
          anchorMetaName: cssrAnchorMetaName$1,
          ssr: ssrAdapter
        });
        vue.onMounted(() => {
          const {
            defaultScrollIndex,
            defaultScrollKey
          } = props;

          if (defaultScrollIndex !== undefined && defaultScrollIndex !== null) {
            scrollTo({
              index: defaultScrollIndex
            });
          } else if (defaultScrollKey !== undefined && defaultScrollKey !== null) {
            scrollTo({
              key: defaultScrollKey
            });
          }
        });
        let isDeactivated = false;
        let activateStateInitialized = false;
        vue.onActivated(() => {
          isDeactivated = false;

          if (!activateStateInitialized) {
            activateStateInitialized = true;
            return;
          } // remount


          scrollTo({
            top: scrollTopRef.value,
            left: scrollLeft
          });
        });
        vue.onDeactivated(() => {
          isDeactivated = true;

          if (!activateStateInitialized) {
            activateStateInitialized = true;
          }
        });
        const keyIndexMapRef = vue.computed(() => {
          const map = new Map();
          const {
            keyField
          } = props;
          props.items.forEach((item, index) => {
            map.set(item[keyField], index);
          });
          return map;
        });
        const listElRef = vue.ref(null);
        const listHeightRef = vue.ref(undefined);
        const keyToHeightOffset = new Map();
        const finweckTreeRef = vue.computed(() => {
          const {
            items,
            itemSize,
            keyField
          } = props;
          const ft = new FinweckTree(items.length, itemSize);
          items.forEach((item, index) => {
            const key = item[keyField];
            const heightOffset = keyToHeightOffset.get(key);

            if (heightOffset !== undefined) {
              ft.add(index, heightOffset);
            }
          });
          return ft;
        });
        const finweckTreeUpdateTrigger = vue.ref(0);
        let scrollLeft = 0;
        const scrollTopRef = vue.ref(0);
        const startIndexRef = useMemo(() => {
          return Math.max(finweckTreeRef.value.getBound(scrollTopRef.value - depx(props.paddingTop)) - 1, 0);
        });
        const viewportItemsRef = vue.computed(() => {
          const {
            value: listHeight
          } = listHeightRef;
          if (listHeight === undefined) return [];
          const {
            items,
            itemSize
          } = props;
          const startIndex = startIndexRef.value;
          const endIndex = Math.min(startIndex + Math.ceil(listHeight / itemSize + 1), items.length - 1);
          const viewportItems = [];

          for (let i = startIndex; i <= endIndex; ++i) {
            viewportItems.push(items[i]);
          }

          return viewportItems;
        });

        const scrollTo = (options, y) => {
          if (typeof options === 'number') {
            scrollToPosition(options, y, 'auto');
            return;
          }

          const {
            left,
            top,
            index,
            key,
            position,
            behavior,
            debounce = true
          } = options;

          if (left !== undefined || top !== undefined) {
            scrollToPosition(left, top, behavior);
          } else if (index !== undefined) {
            scrollToIndex(index, behavior, debounce);
          } else if (key !== undefined) {
            const toIndex = keyIndexMapRef.value.get(key);
            if (toIndex !== undefined) scrollToIndex(toIndex, behavior, debounce);
          } else if (position === 'bottom') {
            scrollToPosition(0, Number.MAX_SAFE_INTEGER, behavior);
          } else if (position === 'top') {
            scrollToPosition(0, 0, behavior);
          }
        };

        let anchorIndex;
        let anchorTimerId = null;

        function scrollToIndex(index, behavior, debounce) {
          const {
            value: ft
          } = finweckTreeRef;
          const targetTop = ft.sum(index) + depx(props.paddingTop);

          if (!debounce) {
            listElRef.value.scrollTo({
              left: 0,
              top: targetTop,
              behavior
            });
          } else {
            anchorIndex = index;

            if (anchorTimerId !== null) {
              window.clearTimeout(anchorTimerId);
            }

            anchorTimerId = window.setTimeout(() => {
              anchorIndex = undefined;
              anchorTimerId = null;
            }, 16); // use 0 ms may be ealier than resize callback...

            const {
              scrollTop,
              offsetHeight
            } = listElRef.value;

            if (targetTop > scrollTop) {
              const itemSize = ft.get(index);

              if (targetTop + itemSize <= scrollTop + offsetHeight) ; else {
                listElRef.value.scrollTo({
                  left: 0,
                  top: targetTop + itemSize - offsetHeight,
                  behavior
                });
              }
            } else {
              listElRef.value.scrollTo({
                left: 0,
                top: targetTop,
                behavior
              });
            }
          }
        }

        function scrollToPosition(left, top, behavior) {
          listElRef.value.scrollTo({
            left,
            top,
            behavior
          });
        }

        function handleItemResize(key, entry) {
          var _a, _b, _c;

          if (isDeactivated) return;
          if (props.ignoreItemResize) return;
          if (isHideByVShow(entry.target)) return;
          const {
            value: ft
          } = finweckTreeRef;
          const index = keyIndexMapRef.value.get(key);
          const previousHeight = ft.get(index);
          const height = (_c = (_b = (_a = entry.borderBoxSize) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.blockSize) !== null && _c !== void 0 ? _c : entry.contentRect.height;
          if (height === previousHeight) return; // height offset based on itemSize
          // used when rebuild the finweck tree

          const offset = height - props.itemSize;

          if (offset === 0) {
            keyToHeightOffset.delete(key);
          } else {
            keyToHeightOffset.set(key, height - props.itemSize);
          } // delta height based on finweck tree data


          const delta = height - previousHeight;
          if (delta === 0) return;
          ft.add(index, delta);
          const listEl = listElRef.value;

          if (listEl != null) {
            if (anchorIndex === undefined) {
              const previousHeightSum = ft.sum(index);

              if (listEl.scrollTop > previousHeightSum) {
                listEl.scrollBy(0, delta);
              }
            } else {
              if (index < anchorIndex) {
                listEl.scrollBy(0, delta);
              } else if (index === anchorIndex) {
                const previousHeightSum = ft.sum(index);

                if (height + previousHeightSum > // Note, listEl shouldn't have border, nor offsetHeight won't be
                // correct
                listEl.scrollTop + listEl.offsetHeight) {
                  listEl.scrollBy(0, delta);
                }
              }
            }

            syncViewport();
          }

          finweckTreeUpdateTrigger.value++;
        }

        const mayUseWheel = !ensureMaybeTouch();
        let wheelCatched = false;

        function handleListScroll(e) {
          var _a;

          (_a = props.onScroll) === null || _a === void 0 ? void 0 : _a.call(props, e);

          if (!mayUseWheel || !wheelCatched) {
            syncViewport();
          }
        }

        function handleListWheel(e) {
          var _a;

          (_a = props.onWheel) === null || _a === void 0 ? void 0 : _a.call(props, e);

          if (mayUseWheel) {
            const listEl = listElRef.value;

            if (listEl != null) {
              if (e.deltaX === 0) {
                if (listEl.scrollTop === 0 && e.deltaY <= 0) {
                  return;
                }

                if (listEl.scrollTop + listEl.offsetHeight >= listEl.scrollHeight && e.deltaY >= 0) {
                  return;
                }
              }

              e.preventDefault();
              listEl.scrollTop += e.deltaY / ensureWheelScale();
              listEl.scrollLeft += e.deltaX / ensureWheelScale();
              syncViewport();
              wheelCatched = true;
              beforeNextFrameOnce(() => {
                wheelCatched = false;
              });
            }
          }
        }

        function handleListResize(entry) {
          if (isDeactivated) return; // List is HTMLElement

          if (isHideByVShow(entry.target)) return; // If height is same, return

          if (entry.contentRect.height === listHeightRef.value) return;
          listHeightRef.value = entry.contentRect.height;
          const {
            onResize
          } = props;
          if (onResize !== undefined) onResize(entry);
        }

        function syncViewport() {
          const {
            value: listEl
          } = listElRef; // sometime ref el can be null
          // https://github.com/TuSimple/naive-ui/issues/811

          if (listEl == null) return;
          scrollTopRef.value = listEl.scrollTop;
          scrollLeft = listEl.scrollLeft;
        }

        function isHideByVShow(el) {
          let cursor = el;

          while (cursor !== null) {
            if (cursor.style.display === 'none') return true;
            cursor = cursor.parentElement;
          }

          return false;
        }

        return {
          listHeight: listHeightRef,
          listStyle: {
            overflow: 'auto'
          },
          keyToIndex: keyIndexMapRef,
          itemsStyle: vue.computed(() => {
            const {
              itemResizable
            } = props;
            const height = pxfy(finweckTreeRef.value.sum()); // eslint-disable-next-line @typescript-eslint/no-unused-expressions

            finweckTreeUpdateTrigger.value;
            return [props.itemsStyle, {
              boxSizing: 'content-box',
              height: itemResizable ? '' : height,
              minHeight: itemResizable ? height : '',
              paddingTop: pxfy(props.paddingTop),
              paddingBottom: pxfy(props.paddingBottom)
            }];
          }),
          visibleItemsStyle: vue.computed(() => {
            // eslint-disable-next-line @typescript-eslint/no-unused-expressions
            finweckTreeUpdateTrigger.value;
            return {
              transform: `translateY(${pxfy(finweckTreeRef.value.sum(startIndexRef.value))})`
            };
          }),
          viewportItems: viewportItemsRef,
          listElRef,
          itemsElRef: vue.ref(null),
          scrollTo,
          handleListResize,
          handleListScroll,
          handleListWheel,
          handleItemResize
        };
      },

      render() {
        const {
          itemResizable,
          keyField,
          keyToIndex,
          visibleItemsTag
        } = this;
        return vue.h(VResizeObserver, {
          onResize: this.handleListResize
        }, {
          default: () => {
            var _a, _b;

            return vue.h('div', vue.mergeProps(this.$attrs, {
              class: ['v-vl', this.showScrollbar && 'v-vl--show-scrollbar'],
              onScroll: this.handleListScroll,
              onWheel: this.handleListWheel,
              ref: 'listElRef'
            }), [this.items.length !== 0 ? vue.h('div', {
              ref: 'itemsElRef',
              class: 'v-vl-items',
              style: this.itemsStyle
            }, [vue.h(visibleItemsTag, Object.assign({
              class: 'v-vl-visible-items',
              style: this.visibleItemsStyle
            }, this.visibleItemsProps), {
              default: () => this.viewportItems.map(item => {
                const key = item[keyField];
                const index = keyToIndex.get(key);
                const itemVNode = this.$slots.default({
                  item,
                  index
                })[0];

                if (itemResizable) {
                  return vue.h(VResizeObserver, {
                    key,
                    onResize: entry => this.handleItemResize(key, entry)
                  }, {
                    default: () => itemVNode
                  });
                }

                itemVNode.key = key;
                return itemVNode;
              })
            })]) : (_b = (_a = this.$slots).empty) === null || _b === void 0 ? void 0 : _b.call(_a)]);
          }
        });
      }

    });

    const styles = c('.v-x-scroll', {
      overflow: 'auto',
      scrollbarWidth: 'none'
    }, [c('&::-webkit-scrollbar', {
      width: 0,
      height: 0
    })]);
    var VXScroll = vue.defineComponent({
      name: 'XScroll',
      props: {
        disabled: Boolean,
        onScroll: Function
      },

      setup() {
        const selfRef = vue.ref(null);

        function handleWheel(e) {
          const preventYWheel = e.currentTarget.offsetWidth < e.currentTarget.scrollWidth;
          if (!preventYWheel || e.deltaY === 0) return;
          e.currentTarget.scrollLeft += e.deltaY + e.deltaX;
          e.preventDefault();
        }

        const ssrAdapter = useSsrAdapter();
        styles.mount({
          id: 'vueuc/x-scroll',
          head: true,
          anchorMetaName: cssrAnchorMetaName$1,
          ssr: ssrAdapter
        });
        const exposedMethods = {
          scrollTo() {
            var _a;

            (_a = selfRef.value) === null || _a === void 0 ? void 0 : _a.scrollTo(...arguments);
          }

        };
        return Object.assign({
          selfRef,
          handleWheel
        }, exposedMethods);
      },

      render() {
        return vue.h('div', {
          ref: 'selfRef',
          onScroll: this.onScroll,
          onWheel: this.disabled ? undefined : this.handleWheel,
          class: 'v-x-scroll'
        }, this.$slots);
      }

    });

    /* eslint-disable @typescript-eslint/strict-boolean-expressions */
    const hiddenAttr = 'v-hidden';
    const style$1A = c('[v-hidden]', {
      display: 'none!important'
    });
    var VOverflow = vue.defineComponent({
      name: 'Overflow',
      props: {
        getCounter: Function,
        getTail: Function,
        updateCounter: Function,
        onUpdateOverflow: Function
      },

      setup(props, _ref) {
        let {
          slots
        } = _ref;
        const selfRef = vue.ref(null);
        const counterRef = vue.ref(null);

        function deriveCounter() {
          const {
            value: self
          } = selfRef;
          const {
            getCounter,
            getTail
          } = props;
          let counter;
          if (getCounter !== undefined) counter = getCounter();else {
            counter = counterRef.value;
          }
          if (!self || !counter) return;

          if (counter.hasAttribute(hiddenAttr)) {
            counter.removeAttribute(hiddenAttr);
          }

          const {
            children
          } = self;
          const containerWidth = self.offsetWidth;
          const childWidths = [];
          const tail = slots.tail ? getTail === null || getTail === void 0 ? void 0 : getTail() : null;
          let childWidthSum = tail ? tail.offsetWidth : 0;
          let overflow = false;
          const len = self.children.length - (slots.tail ? 1 : 0);

          for (let i = 0; i < len - 1; ++i) {
            if (i < 0) continue;
            const child = children[i];

            if (overflow) {
              if (!child.hasAttribute(hiddenAttr)) {
                child.setAttribute(hiddenAttr, '');
              }

              continue;
            } else if (child.hasAttribute(hiddenAttr)) {
              child.removeAttribute(hiddenAttr);
            }

            const childWidth = child.offsetWidth;
            childWidthSum += childWidth;
            childWidths[i] = childWidth;

            if (childWidthSum > containerWidth) {
              const {
                updateCounter
              } = props;

              for (let j = i; j >= 0; --j) {
                const restCount = len - 1 - j;

                if (updateCounter !== undefined) {
                  updateCounter(restCount);
                } else {
                  counter.textContent = `${restCount}`;
                }

                const counterWidth = counter.offsetWidth;
                childWidthSum -= childWidths[j];

                if (childWidthSum + counterWidth <= containerWidth || j === 0) {
                  overflow = true;
                  i = j - 1;

                  if (tail) {
                    // tail too long or 1st element too long
                    // we only consider tail now
                    if (i === -1) {
                      tail.style.maxWidth = `${containerWidth - counterWidth}px`;
                      tail.style.boxSizing = 'border-box';
                    } else {
                      tail.style.maxWidth = '';
                    }
                  }

                  break;
                }
              }
            }
          }

          const {
            onUpdateOverflow
          } = props;

          if (!overflow) {
            if (onUpdateOverflow !== undefined) {
              onUpdateOverflow(false);
            }

            counter.setAttribute(hiddenAttr, '');
          } else {
            if (onUpdateOverflow !== undefined) {
              onUpdateOverflow(true);
            }
          }
        }

        const ssrAdapter = useSsrAdapter();
        style$1A.mount({
          id: 'vueuc/overflow',
          head: true,
          anchorMetaName: cssrAnchorMetaName$1,
          ssr: ssrAdapter
        });
        vue.onMounted(deriveCounter); // besides onMounted, other case should be manually triggered, or we shoud watch items

        return {
          selfRef,
          counterRef,
          sync: deriveCounter
        };
      },

      render() {
        const {
          $slots
        } = this; // eslint-disable-next-line @typescript-eslint/no-floating-promises

        vue.nextTick(this.sync); // It shouldn't have border

        return vue.h('div', {
          class: 'v-overflow',
          ref: 'selfRef'
        }, [vue.renderSlot($slots, 'default'), // $slots.counter should only has 1 element
        $slots.counter ? $slots.counter() : vue.h('span', {
          style: {
            display: 'inline-block'
          },
          ref: 'counterRef'
        }), // $slots.tail should only has 1 element
        $slots.tail ? $slots.tail() : null]);
      }

    });

    /* eslint-disable @typescript-eslint/strict-boolean-expressions */
    // ref https://www.w3.org/TR/wai-aria-practices-1.1/examples/dialog-modal/js/dialog.js
    function isHTMLElement(node) {
      return node instanceof HTMLElement;
    }

    function focusFirstDescendant(node) {
      for (let i = 0; i < node.childNodes.length; i++) {
        const child = node.childNodes[i];

        if (isHTMLElement(child)) {
          if (attemptFocus(child) || focusFirstDescendant(child)) {
            return true;
          }
        }
      }

      return false;
    }
    function focusLastDescendant(element) {
      for (let i = element.childNodes.length - 1; i >= 0; i--) {
        const child = element.childNodes[i];

        if (isHTMLElement(child)) {
          if (attemptFocus(child) || focusLastDescendant(child)) {
            return true;
          }
        }
      }

      return false;
    }

    function attemptFocus(element) {
      if (!isFocusable(element)) {
        return false;
      }

      try {
        element.focus({
          preventScroll: true
        });
      } catch (e) {}

      return document.activeElement === element;
    }

    function isFocusable(element) {
      if (element.tabIndex > 0 || element.tabIndex === 0 && element.getAttribute('tabIndex') !== null) {
        return true;
      }

      if (element.getAttribute('disabled')) {
        return false;
      }

      switch (element.nodeName) {
        case 'A':
          return !!element.href && element.rel !== 'ignore';

        case 'INPUT':
          return element.type !== 'hidden' && element.type !== 'file';

        case 'BUTTON':
        case 'SELECT':
        case 'TEXTAREA':
          return true;

        default:
          return false;
      }
    }

    let stack = [];
    const FocusTrap = vue.defineComponent({
      name: 'FocusTrap',
      props: {
        disabled: Boolean,
        active: Boolean,
        autoFocus: {
          type: Boolean,
          default: true
        },
        onEsc: Function,
        initialFocusTo: String,
        finalFocusTo: String,
        returnFocusOnDeactivated: {
          type: Boolean,
          default: true
        }
      },

      setup(props) {
        const id = createId();
        const focusableStartRef = vue.ref(null);
        const focusableEndRef = vue.ref(null);
        let activated = false;
        let ignoreInternalFocusChange = false;
        const lastFocusedElement = document.activeElement;

        function isCurrentActive() {
          const currentActiveId = stack[stack.length - 1];
          return currentActiveId === id;
        }

        function handleDocumentKeydown(e) {
          var _a;

          if (e.code === 'Escape') {
            if (isCurrentActive()) {
              (_a = props.onEsc) === null || _a === void 0 ? void 0 : _a.call(props, e);
            }
          }
        }

        vue.onMounted(() => {
          vue.watch(() => props.active, value => {
            if (value) {
              activate();
              on('keydown', document, handleDocumentKeydown);
            } else {
              off('keydown', document, handleDocumentKeydown);

              if (activated) {
                deactivate();
              }
            }
          }, {
            immediate: true
          });
        });
        vue.onBeforeUnmount(() => {
          off('keydown', document, handleDocumentKeydown);
          if (activated) deactivate();
        });

        function handleDocumentFocus(e) {
          if (ignoreInternalFocusChange) return;

          if (isCurrentActive()) {
            const mainEl = getMainEl();
            if (mainEl === null) return;
            if (mainEl.contains(getPreciseEventTarget(e))) return; // I don't handle shift + tab status since it's too tricky to handle
            // Not impossible but I need to sleep

            resetFocusTo('first');
          }
        }

        function getMainEl() {
          const focusableStartEl = focusableStartRef.value;
          if (focusableStartEl === null) return null;
          let mainEl = focusableStartEl;

          while (true) {
            mainEl = mainEl.nextSibling;
            if (mainEl === null) break;

            if (mainEl instanceof Element && mainEl.tagName === 'DIV') {
              break;
            }
          }

          return mainEl;
        }

        function activate() {
          var _a;

          if (props.disabled) return;
          stack.push(id);

          if (props.autoFocus) {
            const {
              initialFocusTo
            } = props;

            if (initialFocusTo === undefined) {
              resetFocusTo('first');
            } else {
              (_a = resolveTo(initialFocusTo)) === null || _a === void 0 ? void 0 : _a.focus({
                preventScroll: true
              });
            }
          }

          activated = true;
          document.addEventListener('focus', handleDocumentFocus, true);
        }

        function deactivate() {
          var _a;

          if (props.disabled) return;
          document.removeEventListener('focus', handleDocumentFocus, true);
          stack = stack.filter(idInStack => idInStack !== id);
          if (isCurrentActive()) return;
          const {
            finalFocusTo
          } = props;

          if (finalFocusTo !== undefined) {
            (_a = resolveTo(finalFocusTo)) === null || _a === void 0 ? void 0 : _a.focus({
              preventScroll: true
            });
          } else if (props.returnFocusOnDeactivated) {
            if (lastFocusedElement instanceof HTMLElement) {
              ignoreInternalFocusChange = true;
              lastFocusedElement.focus({
                preventScroll: true
              });
              ignoreInternalFocusChange = false;
            }
          }
        }

        function resetFocusTo(target) {
          if (!isCurrentActive()) return;

          if (props.active) {
            const focusableStartEl = focusableStartRef.value;
            const focusableEndEl = focusableEndRef.value;

            if (focusableStartEl !== null && focusableEndEl !== null) {
              const mainEl = getMainEl();

              if (mainEl == null || mainEl === focusableEndEl) {
                ignoreInternalFocusChange = true;
                focusableStartEl.focus({
                  preventScroll: true
                });
                ignoreInternalFocusChange = false;
                return;
              }

              ignoreInternalFocusChange = true;
              const focused = target === 'first' ? focusFirstDescendant(mainEl) : focusLastDescendant(mainEl);
              ignoreInternalFocusChange = false;

              if (!focused) {
                ignoreInternalFocusChange = true;
                focusableStartEl.focus({
                  preventScroll: true
                });
                ignoreInternalFocusChange = false;
              }
            }
          }
        }

        function handleStartFocus(e) {
          if (ignoreInternalFocusChange) return;
          const mainEl = getMainEl();
          if (mainEl === null) return;

          if (e.relatedTarget !== null && mainEl.contains(e.relatedTarget)) {
            // if it comes from inner, focus last
            resetFocusTo('last');
          } else {
            // otherwise focus first
            resetFocusTo('first');
          }
        }

        function handleEndFocus(e) {
          if (ignoreInternalFocusChange) return;

          if (e.relatedTarget !== null && e.relatedTarget === focusableStartRef.value) {
            // if it comes from first, focus last
            resetFocusTo('last');
          } else {
            // otherwise focus first
            resetFocusTo('first');
          }
        }

        return {
          focusableStartRef,
          focusableEndRef,
          focusableStyle: 'position: absolute; height: 0; width: 0;',
          handleStartFocus,
          handleEndFocus
        };
      },

      render() {
        const {
          default: defaultSlot
        } = this.$slots;
        if (defaultSlot === undefined) return null;
        if (this.disabled) return defaultSlot();
        const {
          active,
          focusableStyle
        } = this;
        return vue.h(vue.Fragment, null, [vue.h('div', {
          'aria-hidden': 'true',
          tabindex: active ? '0' : '-1',
          ref: 'focusableStartRef',
          style: focusableStyle,
          onFocus: this.handleStartFocus
        }), defaultSlot(), vue.h('div', {
          'aria-hidden': 'true',
          style: focusableStyle,
          ref: 'focusableEndRef',
          tabindex: active ? '0' : '-1',
          onFocus: this.handleEndFocus
        })]);
      }

    });

    function useOnResize(elRef, onResize) {
      if (onResize) {
        vue.onMounted(() => {
          const {
            value: el
          } = elRef;

          if (el) {
            resizeObserverManager.registerHandler(el, onResize);
          }
        });
        vue.onBeforeUnmount(() => {
          const {
            value: el
          } = elRef;

          if (el) {
            resizeObserverManager.unregisterHandler(el);
          }
        });
      }
    }

    let lockCount = 0;
    let originalMarginRight = "";
    let originalOverflow = "";
    let originalOverflowX = "";
    let originalOverflowY = "";
    const lockHtmlScrollRightCompensationRef = vue.ref("0px");
    function useLockHtmlScroll(lockRef) {
      if (typeof document === "undefined") return;
      const el = document.documentElement;
      let watchStopHandle;
      let activated = false;

      const unlock = () => {
        el.style.marginRight = originalMarginRight;
        el.style.overflow = originalOverflow;
        el.style.overflowX = originalOverflowX;
        el.style.overflowY = originalOverflowY;
        lockHtmlScrollRightCompensationRef.value = "0px";
      };

      vue.onMounted(() => {
        watchStopHandle = vue.watch(lockRef, value => {
          if (value) {
            if (!lockCount) {
              const scrollbarWidth = window.innerWidth - el.offsetWidth;

              if (scrollbarWidth > 0) {
                originalMarginRight = el.style.marginRight;
                el.style.marginRight = `${scrollbarWidth}px`;
                lockHtmlScrollRightCompensationRef.value = `${scrollbarWidth}px`;
              }

              originalOverflow = el.style.overflow;
              originalOverflowX = el.style.overflowX;
              originalOverflowY = el.style.overflowY;
              el.style.overflow = "hidden";
              el.style.overflowX = "hidden";
              el.style.overflowY = "hidden";
            }

            activated = true;
            lockCount++;
          } else {
            lockCount--;

            if (!lockCount) {
              unlock();
            }

            activated = false;
          }
        }, {
          immediate: true
        });
      });
      vue.onBeforeUnmount(() => {
        var _watchStopHandle;

        (_watchStopHandle = watchStopHandle) === null || _watchStopHandle === void 0 ? void 0 : _watchStopHandle();

        if (activated) {
          lockCount--;

          if (!lockCount) {
            unlock();
          }

          activated = false;
        }
      });
    }

    const isComposingRef = vue.ref(false);

    const compositionStartHandler = () => {
      isComposingRef.value = true;
    };

    const compositionEndHandler = () => {
      isComposingRef.value = false;
    };

    let mountedCount = 0;
    const useIsComposing = () => {
      if (isBrowser$2) {
        vue.onBeforeMount(() => {
          if (!mountedCount) {
            window.addEventListener("compositionstart", compositionStartHandler);
            window.addEventListener("compositionend", compositionEndHandler);
          }

          mountedCount++;
        });
        vue.onBeforeUnmount(() => {
          if (mountedCount <= 1) {
            window.removeEventListener("compositionstart", compositionStartHandler);
            window.removeEventListener("compositionend", compositionEndHandler);
            mountedCount = 0;
          } else {
            mountedCount--;
          }
        });
      }

      return isComposingRef;
    };

    function useReactivated(callback) {
      const isDeactivatedRef = {
        isDeactivated: false
      };
      let activateStateInitialized = false;
      vue.onActivated(() => {
        isDeactivatedRef.isDeactivated = false;

        if (!activateStateInitialized) {
          activateStateInitialized = true;
          return;
        }

        callback();
      });
      vue.onDeactivated(() => {
        isDeactivatedRef.isDeactivated = true;

        if (!activateStateInitialized) {
          activateStateInitialized = true;
        }
      });
      return isDeactivatedRef;
    }

    function isDocument(node) {
      return node.nodeName === "#document";
    }

    const formItemInjectionKey = createInjectionKey("n-form-item");
    function useFormItem(props) {
      let {
        defaultSize = "medium",
        mergedSize,
        mergedDisabled
      } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      const NFormItem = vue.inject(formItemInjectionKey, null);
      vue.provide(formItemInjectionKey, null);
      const mergedSizeRef = vue.computed(mergedSize ? () => mergedSize(NFormItem) : () => {
        const {
          size
        } = props;
        if (size) return size;

        if (NFormItem) {
          const {
            mergedSize: mergedSize2
          } = NFormItem;

          if (mergedSize2.value !== void 0) {
            return mergedSize2.value;
          }
        }

        return defaultSize;
      });
      const mergedDisabledRef = vue.computed(mergedDisabled ? () => mergedDisabled(NFormItem) : () => {
        const {
          disabled
        } = props;

        if (disabled !== void 0) {
          return disabled;
        }

        if (NFormItem) {
          return NFormItem.disabled.value;
        }

        return false;
      });
      const mergedStatusRef = vue.computed(() => {
        const {
          status
        } = props;
        if (status) return status;
        return NFormItem === null || NFormItem === void 0 ? void 0 : NFormItem.mergedValidationStatus.value;
      });
      vue.onBeforeUnmount(() => {
        if (NFormItem) {
          NFormItem.restoreValidation();
        }
      });
      return {
        mergedSizeRef,
        mergedDisabledRef,
        mergedStatusRef,

        nTriggerFormBlur() {
          if (NFormItem) {
            NFormItem.handleContentBlur();
          }
        },

        nTriggerFormChange() {
          if (NFormItem) {
            NFormItem.handleContentChange();
          }
        },

        nTriggerFormFocus() {
          if (NFormItem) {
            NFormItem.handleContentFocus();
          }
        },

        nTriggerFormInput() {
          if (NFormItem) {
            NFormItem.handleContentInput();
          }
        }

      };
    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function getDefaultExportFromCjs (x) {
    	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }

    var lodash = {exports: {}};

    /**
     * @license
     * Lodash <https://lodash.com/>
     * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
     * Released under MIT license <https://lodash.com/license>
     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
     * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     */

    (function (module, exports) {
    (function(){/** Used as a safe reference for `undefined` in pre-ES5 environments. */var undefined$1;/** Used as the semantic version number. */var VERSION='4.17.21';/** Used as the size to enable large array optimizations. */var LARGE_ARRAY_SIZE=200;/** Error message constants. */var CORE_ERROR_TEXT='Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',FUNC_ERROR_TEXT='Expected a function',INVALID_TEMPL_VAR_ERROR_TEXT='Invalid `variable` option passed into `_.template`';/** Used to stand-in for `undefined` hash values. */var HASH_UNDEFINED='__lodash_hash_undefined__';/** Used as the maximum memoize cache size. */var MAX_MEMOIZE_SIZE=500;/** Used as the internal argument placeholder. */var PLACEHOLDER='__lodash_placeholder__';/** Used to compose bitmasks for cloning. */var CLONE_DEEP_FLAG=1,CLONE_FLAT_FLAG=2,CLONE_SYMBOLS_FLAG=4;/** Used to compose bitmasks for value comparisons. */var COMPARE_PARTIAL_FLAG=1,COMPARE_UNORDERED_FLAG=2;/** Used to compose bitmasks for function metadata. */var WRAP_BIND_FLAG=1,WRAP_BIND_KEY_FLAG=2,WRAP_CURRY_BOUND_FLAG=4,WRAP_CURRY_FLAG=8,WRAP_CURRY_RIGHT_FLAG=16,WRAP_PARTIAL_FLAG=32,WRAP_PARTIAL_RIGHT_FLAG=64,WRAP_ARY_FLAG=128,WRAP_REARG_FLAG=256,WRAP_FLIP_FLAG=512;/** Used as default options for `_.truncate`. */var DEFAULT_TRUNC_LENGTH=30,DEFAULT_TRUNC_OMISSION='...';/** Used to detect hot functions by number of calls within a span of milliseconds. */var HOT_COUNT=800,HOT_SPAN=16;/** Used to indicate the type of lazy iteratees. */var LAZY_FILTER_FLAG=1,LAZY_MAP_FLAG=2,LAZY_WHILE_FLAG=3;/** Used as references for various `Number` constants. */var INFINITY=1/0,MAX_SAFE_INTEGER=9007199254740991,MAX_INTEGER=1.7976931348623157e+308,NAN=0/0;/** Used as references for the maximum length and index of an array. */var MAX_ARRAY_LENGTH=4294967295,MAX_ARRAY_INDEX=MAX_ARRAY_LENGTH-1,HALF_MAX_ARRAY_LENGTH=MAX_ARRAY_LENGTH>>>1;/** Used to associate wrap methods with their bit flags. */var wrapFlags=[['ary',WRAP_ARY_FLAG],['bind',WRAP_BIND_FLAG],['bindKey',WRAP_BIND_KEY_FLAG],['curry',WRAP_CURRY_FLAG],['curryRight',WRAP_CURRY_RIGHT_FLAG],['flip',WRAP_FLIP_FLAG],['partial',WRAP_PARTIAL_FLAG],['partialRight',WRAP_PARTIAL_RIGHT_FLAG],['rearg',WRAP_REARG_FLAG]];/** `Object#toString` result references. */var argsTag='[object Arguments]',arrayTag='[object Array]',asyncTag='[object AsyncFunction]',boolTag='[object Boolean]',dateTag='[object Date]',domExcTag='[object DOMException]',errorTag='[object Error]',funcTag='[object Function]',genTag='[object GeneratorFunction]',mapTag='[object Map]',numberTag='[object Number]',nullTag='[object Null]',objectTag='[object Object]',promiseTag='[object Promise]',proxyTag='[object Proxy]',regexpTag='[object RegExp]',setTag='[object Set]',stringTag='[object String]',symbolTag='[object Symbol]',undefinedTag='[object Undefined]',weakMapTag='[object WeakMap]',weakSetTag='[object WeakSet]';var arrayBufferTag='[object ArrayBuffer]',dataViewTag='[object DataView]',float32Tag='[object Float32Array]',float64Tag='[object Float64Array]',int8Tag='[object Int8Array]',int16Tag='[object Int16Array]',int32Tag='[object Int32Array]',uint8Tag='[object Uint8Array]',uint8ClampedTag='[object Uint8ClampedArray]',uint16Tag='[object Uint16Array]',uint32Tag='[object Uint32Array]';/** Used to match empty string literals in compiled template source. */var reEmptyStringLeading=/\b__p \+= '';/g,reEmptyStringMiddle=/\b(__p \+=) '' \+/g,reEmptyStringTrailing=/(__e\(.*?\)|\b__t\)) \+\n'';/g;/** Used to match HTML entities and HTML characters. */var reEscapedHtml=/&(?:amp|lt|gt|quot|#39);/g,reUnescapedHtml=/[&<>"']/g,reHasEscapedHtml=RegExp(reEscapedHtml.source),reHasUnescapedHtml=RegExp(reUnescapedHtml.source);/** Used to match template delimiters. */var reEscape=/<%-([\s\S]+?)%>/g,reEvaluate=/<%([\s\S]+?)%>/g,reInterpolate=/<%=([\s\S]+?)%>/g;/** Used to match property names within property paths. */var reIsDeepProp=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,reIsPlainProp=/^\w*$/,rePropName=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;/**
    	   * Used to match `RegExp`
    	   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
    	   */var reRegExpChar=/[\\^$.*+?()[\]{}|]/g,reHasRegExpChar=RegExp(reRegExpChar.source);/** Used to match leading whitespace. */var reTrimStart=/^\s+/;/** Used to match a single whitespace character. */var reWhitespace=/\s/;/** Used to match wrap detail comments. */var reWrapComment=/\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,reWrapDetails=/\{\n\/\* \[wrapped with (.+)\] \*/,reSplitDetails=/,? & /;/** Used to match words composed of alphanumeric characters. */var reAsciiWord=/[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;/**
    	   * Used to validate the `validate` option in `_.template` variable.
    	   *
    	   * Forbids characters which could potentially change the meaning of the function argument definition:
    	   * - "()," (modification of function parameters)
    	   * - "=" (default value)
    	   * - "[]{}" (destructuring of function parameters)
    	   * - "/" (beginning of a comment)
    	   * - whitespace
    	   */var reForbiddenIdentifierChars=/[()=,{}\[\]\/\s]/;/** Used to match backslashes in property paths. */var reEscapeChar=/\\(\\)?/g;/**
    	   * Used to match
    	   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
    	   */var reEsTemplate=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;/** Used to match `RegExp` flags from their coerced string values. */var reFlags=/\w*$/;/** Used to detect bad signed hexadecimal string values. */var reIsBadHex=/^[-+]0x[0-9a-f]+$/i;/** Used to detect binary string values. */var reIsBinary=/^0b[01]+$/i;/** Used to detect host constructors (Safari). */var reIsHostCtor=/^\[object .+?Constructor\]$/;/** Used to detect octal string values. */var reIsOctal=/^0o[0-7]+$/i;/** Used to detect unsigned integer values. */var reIsUint=/^(?:0|[1-9]\d*)$/;/** Used to match Latin Unicode letters (excluding mathematical operators). */var reLatin=/[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;/** Used to ensure capturing order of template delimiters. */var reNoMatch=/($^)/;/** Used to match unescaped characters in compiled string literals. */var reUnescapedString=/['\n\r\u2028\u2029\\]/g;/** Used to compose unicode character classes. */var rsAstralRange='\\ud800-\\udfff',rsComboMarksRange='\\u0300-\\u036f',reComboHalfMarksRange='\\ufe20-\\ufe2f',rsComboSymbolsRange='\\u20d0-\\u20ff',rsComboRange=rsComboMarksRange+reComboHalfMarksRange+rsComboSymbolsRange,rsDingbatRange='\\u2700-\\u27bf',rsLowerRange='a-z\\xdf-\\xf6\\xf8-\\xff',rsMathOpRange='\\xac\\xb1\\xd7\\xf7',rsNonCharRange='\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',rsPunctuationRange='\\u2000-\\u206f',rsSpaceRange=' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',rsUpperRange='A-Z\\xc0-\\xd6\\xd8-\\xde',rsVarRange='\\ufe0e\\ufe0f',rsBreakRange=rsMathOpRange+rsNonCharRange+rsPunctuationRange+rsSpaceRange;/** Used to compose unicode capture groups. */var rsApos="['\u2019]",rsAstral='['+rsAstralRange+']',rsBreak='['+rsBreakRange+']',rsCombo='['+rsComboRange+']',rsDigits='\\d+',rsDingbat='['+rsDingbatRange+']',rsLower='['+rsLowerRange+']',rsMisc='[^'+rsAstralRange+rsBreakRange+rsDigits+rsDingbatRange+rsLowerRange+rsUpperRange+']',rsFitz='\\ud83c[\\udffb-\\udfff]',rsModifier='(?:'+rsCombo+'|'+rsFitz+')',rsNonAstral='[^'+rsAstralRange+']',rsRegional='(?:\\ud83c[\\udde6-\\uddff]){2}',rsSurrPair='[\\ud800-\\udbff][\\udc00-\\udfff]',rsUpper='['+rsUpperRange+']',rsZWJ='\\u200d';/** Used to compose unicode regexes. */var rsMiscLower='(?:'+rsLower+'|'+rsMisc+')',rsMiscUpper='(?:'+rsUpper+'|'+rsMisc+')',rsOptContrLower='(?:'+rsApos+'(?:d|ll|m|re|s|t|ve))?',rsOptContrUpper='(?:'+rsApos+'(?:D|LL|M|RE|S|T|VE))?',reOptMod=rsModifier+'?',rsOptVar='['+rsVarRange+']?',rsOptJoin='(?:'+rsZWJ+'(?:'+[rsNonAstral,rsRegional,rsSurrPair].join('|')+')'+rsOptVar+reOptMod+')*',rsOrdLower='\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',rsOrdUpper='\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',rsSeq=rsOptVar+reOptMod+rsOptJoin,rsEmoji='(?:'+[rsDingbat,rsRegional,rsSurrPair].join('|')+')'+rsSeq,rsSymbol='(?:'+[rsNonAstral+rsCombo+'?',rsCombo,rsRegional,rsSurrPair,rsAstral].join('|')+')';/** Used to match apostrophes. */var reApos=RegExp(rsApos,'g');/**
    	   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
    	   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
    	   */var reComboMark=RegExp(rsCombo,'g');/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */var reUnicode=RegExp(rsFitz+'(?='+rsFitz+')|'+rsSymbol+rsSeq,'g');/** Used to match complex or compound words. */var reUnicodeWord=RegExp([rsUpper+'?'+rsLower+'+'+rsOptContrLower+'(?='+[rsBreak,rsUpper,'$'].join('|')+')',rsMiscUpper+'+'+rsOptContrUpper+'(?='+[rsBreak,rsUpper+rsMiscLower,'$'].join('|')+')',rsUpper+'?'+rsMiscLower+'+'+rsOptContrLower,rsUpper+'+'+rsOptContrUpper,rsOrdUpper,rsOrdLower,rsDigits,rsEmoji].join('|'),'g');/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */var reHasUnicode=RegExp('['+rsZWJ+rsAstralRange+rsComboRange+rsVarRange+']');/** Used to detect strings that need a more robust regexp to match words. */var reHasUnicodeWord=/[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;/** Used to assign default `context` object properties. */var contextProps=['Array','Buffer','DataView','Date','Error','Float32Array','Float64Array','Function','Int8Array','Int16Array','Int32Array','Map','Math','Object','Promise','RegExp','Set','String','Symbol','TypeError','Uint8Array','Uint8ClampedArray','Uint16Array','Uint32Array','WeakMap','_','clearTimeout','isFinite','parseInt','setTimeout'];/** Used to make template sourceURLs easier to identify. */var templateCounter=-1;/** Used to identify `toStringTag` values of typed arrays. */var typedArrayTags={};typedArrayTags[float32Tag]=typedArrayTags[float64Tag]=typedArrayTags[int8Tag]=typedArrayTags[int16Tag]=typedArrayTags[int32Tag]=typedArrayTags[uint8Tag]=typedArrayTags[uint8ClampedTag]=typedArrayTags[uint16Tag]=typedArrayTags[uint32Tag]=true;typedArrayTags[argsTag]=typedArrayTags[arrayTag]=typedArrayTags[arrayBufferTag]=typedArrayTags[boolTag]=typedArrayTags[dataViewTag]=typedArrayTags[dateTag]=typedArrayTags[errorTag]=typedArrayTags[funcTag]=typedArrayTags[mapTag]=typedArrayTags[numberTag]=typedArrayTags[objectTag]=typedArrayTags[regexpTag]=typedArrayTags[setTag]=typedArrayTags[stringTag]=typedArrayTags[weakMapTag]=false;/** Used to identify `toStringTag` values supported by `_.clone`. */var cloneableTags={};cloneableTags[argsTag]=cloneableTags[arrayTag]=cloneableTags[arrayBufferTag]=cloneableTags[dataViewTag]=cloneableTags[boolTag]=cloneableTags[dateTag]=cloneableTags[float32Tag]=cloneableTags[float64Tag]=cloneableTags[int8Tag]=cloneableTags[int16Tag]=cloneableTags[int32Tag]=cloneableTags[mapTag]=cloneableTags[numberTag]=cloneableTags[objectTag]=cloneableTags[regexpTag]=cloneableTags[setTag]=cloneableTags[stringTag]=cloneableTags[symbolTag]=cloneableTags[uint8Tag]=cloneableTags[uint8ClampedTag]=cloneableTags[uint16Tag]=cloneableTags[uint32Tag]=true;cloneableTags[errorTag]=cloneableTags[funcTag]=cloneableTags[weakMapTag]=false;/** Used to map Latin Unicode letters to basic Latin letters. */var deburredLetters={// Latin-1 Supplement block.
    	'\xc0':'A','\xc1':'A','\xc2':'A','\xc3':'A','\xc4':'A','\xc5':'A','\xe0':'a','\xe1':'a','\xe2':'a','\xe3':'a','\xe4':'a','\xe5':'a','\xc7':'C','\xe7':'c','\xd0':'D','\xf0':'d','\xc8':'E','\xc9':'E','\xca':'E','\xcb':'E','\xe8':'e','\xe9':'e','\xea':'e','\xeb':'e','\xcc':'I','\xcd':'I','\xce':'I','\xcf':'I','\xec':'i','\xed':'i','\xee':'i','\xef':'i','\xd1':'N','\xf1':'n','\xd2':'O','\xd3':'O','\xd4':'O','\xd5':'O','\xd6':'O','\xd8':'O','\xf2':'o','\xf3':'o','\xf4':'o','\xf5':'o','\xf6':'o','\xf8':'o','\xd9':'U','\xda':'U','\xdb':'U','\xdc':'U','\xf9':'u','\xfa':'u','\xfb':'u','\xfc':'u','\xdd':'Y','\xfd':'y','\xff':'y','\xc6':'Ae','\xe6':'ae','\xde':'Th','\xfe':'th','\xdf':'ss',// Latin Extended-A block.
    	'\u0100':'A','\u0102':'A','\u0104':'A','\u0101':'a','\u0103':'a','\u0105':'a','\u0106':'C','\u0108':'C','\u010a':'C','\u010c':'C','\u0107':'c','\u0109':'c','\u010b':'c','\u010d':'c','\u010e':'D','\u0110':'D','\u010f':'d','\u0111':'d','\u0112':'E','\u0114':'E','\u0116':'E','\u0118':'E','\u011a':'E','\u0113':'e','\u0115':'e','\u0117':'e','\u0119':'e','\u011b':'e','\u011c':'G','\u011e':'G','\u0120':'G','\u0122':'G','\u011d':'g','\u011f':'g','\u0121':'g','\u0123':'g','\u0124':'H','\u0126':'H','\u0125':'h','\u0127':'h','\u0128':'I','\u012a':'I','\u012c':'I','\u012e':'I','\u0130':'I','\u0129':'i','\u012b':'i','\u012d':'i','\u012f':'i','\u0131':'i','\u0134':'J','\u0135':'j','\u0136':'K','\u0137':'k','\u0138':'k','\u0139':'L','\u013b':'L','\u013d':'L','\u013f':'L','\u0141':'L','\u013a':'l','\u013c':'l','\u013e':'l','\u0140':'l','\u0142':'l','\u0143':'N','\u0145':'N','\u0147':'N','\u014a':'N','\u0144':'n','\u0146':'n','\u0148':'n','\u014b':'n','\u014c':'O','\u014e':'O','\u0150':'O','\u014d':'o','\u014f':'o','\u0151':'o','\u0154':'R','\u0156':'R','\u0158':'R','\u0155':'r','\u0157':'r','\u0159':'r','\u015a':'S','\u015c':'S','\u015e':'S','\u0160':'S','\u015b':'s','\u015d':'s','\u015f':'s','\u0161':'s','\u0162':'T','\u0164':'T','\u0166':'T','\u0163':'t','\u0165':'t','\u0167':'t','\u0168':'U','\u016a':'U','\u016c':'U','\u016e':'U','\u0170':'U','\u0172':'U','\u0169':'u','\u016b':'u','\u016d':'u','\u016f':'u','\u0171':'u','\u0173':'u','\u0174':'W','\u0175':'w','\u0176':'Y','\u0177':'y','\u0178':'Y','\u0179':'Z','\u017b':'Z','\u017d':'Z','\u017a':'z','\u017c':'z','\u017e':'z','\u0132':'IJ','\u0133':'ij','\u0152':'Oe','\u0153':'oe','\u0149':"'n",'\u017f':'s'};/** Used to map characters to HTML entities. */var htmlEscapes={'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'};/** Used to map HTML entities to characters. */var htmlUnescapes={'&amp;':'&','&lt;':'<','&gt;':'>','&quot;':'"','&#39;':"'"};/** Used to escape characters for inclusion in compiled string literals. */var stringEscapes={'\\':'\\',"'":"'",'\n':'n','\r':'r','\u2028':'u2028','\u2029':'u2029'};/** Built-in method references without a dependency on `root`. */var freeParseFloat=parseFloat,freeParseInt=parseInt;/** Detect free variable `global` from Node.js. */var freeGlobal=typeof commonjsGlobal=='object'&&commonjsGlobal&&commonjsGlobal.Object===Object&&commonjsGlobal;/** Detect free variable `self`. */var freeSelf=typeof self=='object'&&self&&self.Object===Object&&self;/** Used as a reference to the global object. */var root=freeGlobal||freeSelf||Function('return this')();/** Detect free variable `exports`. */var freeExports=exports&&!exports.nodeType&&exports;/** Detect free variable `module`. */var freeModule=freeExports&&'object'=='object'&&module&&!module.nodeType&&module;/** Detect the popular CommonJS extension `module.exports`. */var moduleExports=freeModule&&freeModule.exports===freeExports;/** Detect free variable `process` from Node.js. */var freeProcess=moduleExports&&freeGlobal.process;/** Used to access faster Node.js helpers. */var nodeUtil=function(){try{// Use `util.types` for Node.js 10+.
    	var types=freeModule&&freeModule.require&&freeModule.require('util').types;if(types){return types;}// Legacy `process.binding('util')` for Node.js < 10.
    	return freeProcess&&freeProcess.binding&&freeProcess.binding('util');}catch(e){}}();/* Node.js helper references. */var nodeIsArrayBuffer=nodeUtil&&nodeUtil.isArrayBuffer,nodeIsDate=nodeUtil&&nodeUtil.isDate,nodeIsMap=nodeUtil&&nodeUtil.isMap,nodeIsRegExp=nodeUtil&&nodeUtil.isRegExp,nodeIsSet=nodeUtil&&nodeUtil.isSet,nodeIsTypedArray=nodeUtil&&nodeUtil.isTypedArray;/*--------------------------------------------------------------------------*/ /**
    	   * A faster alternative to `Function#apply`, this function invokes `func`
    	   * with the `this` binding of `thisArg` and the arguments of `args`.
    	   *
    	   * @private
    	   * @param {Function} func The function to invoke.
    	   * @param {*} thisArg The `this` binding of `func`.
    	   * @param {Array} args The arguments to invoke `func` with.
    	   * @returns {*} Returns the result of `func`.
    	   */function apply(func,thisArg,args){switch(args.length){case 0:return func.call(thisArg);case 1:return func.call(thisArg,args[0]);case 2:return func.call(thisArg,args[0],args[1]);case 3:return func.call(thisArg,args[0],args[1],args[2]);}return func.apply(thisArg,args);}/**
    	   * A specialized version of `baseAggregator` for arrays.
    	   *
    	   * @private
    	   * @param {Array} [array] The array to iterate over.
    	   * @param {Function} setter The function to set `accumulator` values.
    	   * @param {Function} iteratee The iteratee to transform keys.
    	   * @param {Object} accumulator The initial aggregated object.
    	   * @returns {Function} Returns `accumulator`.
    	   */function arrayAggregator(array,setter,iteratee,accumulator){var index=-1,length=array==null?0:array.length;while(++index<length){var value=array[index];setter(accumulator,value,iteratee(value),array);}return accumulator;}/**
    	   * A specialized version of `_.forEach` for arrays without support for
    	   * iteratee shorthands.
    	   *
    	   * @private
    	   * @param {Array} [array] The array to iterate over.
    	   * @param {Function} iteratee The function invoked per iteration.
    	   * @returns {Array} Returns `array`.
    	   */function arrayEach(array,iteratee){var index=-1,length=array==null?0:array.length;while(++index<length){if(iteratee(array[index],index,array)===false){break;}}return array;}/**
    	   * A specialized version of `_.forEachRight` for arrays without support for
    	   * iteratee shorthands.
    	   *
    	   * @private
    	   * @param {Array} [array] The array to iterate over.
    	   * @param {Function} iteratee The function invoked per iteration.
    	   * @returns {Array} Returns `array`.
    	   */function arrayEachRight(array,iteratee){var length=array==null?0:array.length;while(length--){if(iteratee(array[length],length,array)===false){break;}}return array;}/**
    	   * A specialized version of `_.every` for arrays without support for
    	   * iteratee shorthands.
    	   *
    	   * @private
    	   * @param {Array} [array] The array to iterate over.
    	   * @param {Function} predicate The function invoked per iteration.
    	   * @returns {boolean} Returns `true` if all elements pass the predicate check,
    	   *  else `false`.
    	   */function arrayEvery(array,predicate){var index=-1,length=array==null?0:array.length;while(++index<length){if(!predicate(array[index],index,array)){return false;}}return true;}/**
    	   * A specialized version of `_.filter` for arrays without support for
    	   * iteratee shorthands.
    	   *
    	   * @private
    	   * @param {Array} [array] The array to iterate over.
    	   * @param {Function} predicate The function invoked per iteration.
    	   * @returns {Array} Returns the new filtered array.
    	   */function arrayFilter(array,predicate){var index=-1,length=array==null?0:array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(predicate(value,index,array)){result[resIndex++]=value;}}return result;}/**
    	   * A specialized version of `_.includes` for arrays without support for
    	   * specifying an index to search from.
    	   *
    	   * @private
    	   * @param {Array} [array] The array to inspect.
    	   * @param {*} target The value to search for.
    	   * @returns {boolean} Returns `true` if `target` is found, else `false`.
    	   */function arrayIncludes(array,value){var length=array==null?0:array.length;return !!length&&baseIndexOf(array,value,0)>-1;}/**
    	   * This function is like `arrayIncludes` except that it accepts a comparator.
    	   *
    	   * @private
    	   * @param {Array} [array] The array to inspect.
    	   * @param {*} target The value to search for.
    	   * @param {Function} comparator The comparator invoked per element.
    	   * @returns {boolean} Returns `true` if `target` is found, else `false`.
    	   */function arrayIncludesWith(array,value,comparator){var index=-1,length=array==null?0:array.length;while(++index<length){if(comparator(value,array[index])){return true;}}return false;}/**
    	   * A specialized version of `_.map` for arrays without support for iteratee
    	   * shorthands.
    	   *
    	   * @private
    	   * @param {Array} [array] The array to iterate over.
    	   * @param {Function} iteratee The function invoked per iteration.
    	   * @returns {Array} Returns the new mapped array.
    	   */function arrayMap(array,iteratee){var index=-1,length=array==null?0:array.length,result=Array(length);while(++index<length){result[index]=iteratee(array[index],index,array);}return result;}/**
    	   * Appends the elements of `values` to `array`.
    	   *
    	   * @private
    	   * @param {Array} array The array to modify.
    	   * @param {Array} values The values to append.
    	   * @returns {Array} Returns `array`.
    	   */function arrayPush(array,values){var index=-1,length=values.length,offset=array.length;while(++index<length){array[offset+index]=values[index];}return array;}/**
    	   * A specialized version of `_.reduce` for arrays without support for
    	   * iteratee shorthands.
    	   *
    	   * @private
    	   * @param {Array} [array] The array to iterate over.
    	   * @param {Function} iteratee The function invoked per iteration.
    	   * @param {*} [accumulator] The initial value.
    	   * @param {boolean} [initAccum] Specify using the first element of `array` as
    	   *  the initial value.
    	   * @returns {*} Returns the accumulated value.
    	   */function arrayReduce(array,iteratee,accumulator,initAccum){var index=-1,length=array==null?0:array.length;if(initAccum&&length){accumulator=array[++index];}while(++index<length){accumulator=iteratee(accumulator,array[index],index,array);}return accumulator;}/**
    	   * A specialized version of `_.reduceRight` for arrays without support for
    	   * iteratee shorthands.
    	   *
    	   * @private
    	   * @param {Array} [array] The array to iterate over.
    	   * @param {Function} iteratee The function invoked per iteration.
    	   * @param {*} [accumulator] The initial value.
    	   * @param {boolean} [initAccum] Specify using the last element of `array` as
    	   *  the initial value.
    	   * @returns {*} Returns the accumulated value.
    	   */function arrayReduceRight(array,iteratee,accumulator,initAccum){var length=array==null?0:array.length;if(initAccum&&length){accumulator=array[--length];}while(length--){accumulator=iteratee(accumulator,array[length],length,array);}return accumulator;}/**
    	   * A specialized version of `_.some` for arrays without support for iteratee
    	   * shorthands.
    	   *
    	   * @private
    	   * @param {Array} [array] The array to iterate over.
    	   * @param {Function} predicate The function invoked per iteration.
    	   * @returns {boolean} Returns `true` if any element passes the predicate check,
    	   *  else `false`.
    	   */function arraySome(array,predicate){var index=-1,length=array==null?0:array.length;while(++index<length){if(predicate(array[index],index,array)){return true;}}return false;}/**
    	   * Gets the size of an ASCII `string`.
    	   *
    	   * @private
    	   * @param {string} string The string inspect.
    	   * @returns {number} Returns the string size.
    	   */var asciiSize=baseProperty('length');/**
    	   * Converts an ASCII `string` to an array.
    	   *
    	   * @private
    	   * @param {string} string The string to convert.
    	   * @returns {Array} Returns the converted array.
    	   */function asciiToArray(string){return string.split('');}/**
    	   * Splits an ASCII `string` into an array of its words.
    	   *
    	   * @private
    	   * @param {string} The string to inspect.
    	   * @returns {Array} Returns the words of `string`.
    	   */function asciiWords(string){return string.match(reAsciiWord)||[];}/**
    	   * The base implementation of methods like `_.findKey` and `_.findLastKey`,
    	   * without support for iteratee shorthands, which iterates over `collection`
    	   * using `eachFunc`.
    	   *
    	   * @private
    	   * @param {Array|Object} collection The collection to inspect.
    	   * @param {Function} predicate The function invoked per iteration.
    	   * @param {Function} eachFunc The function to iterate over `collection`.
    	   * @returns {*} Returns the found element or its key, else `undefined`.
    	   */function baseFindKey(collection,predicate,eachFunc){var result;eachFunc(collection,function(value,key,collection){if(predicate(value,key,collection)){result=key;return false;}});return result;}/**
    	   * The base implementation of `_.findIndex` and `_.findLastIndex` without
    	   * support for iteratee shorthands.
    	   *
    	   * @private
    	   * @param {Array} array The array to inspect.
    	   * @param {Function} predicate The function invoked per iteration.
    	   * @param {number} fromIndex The index to search from.
    	   * @param {boolean} [fromRight] Specify iterating from right to left.
    	   * @returns {number} Returns the index of the matched value, else `-1`.
    	   */function baseFindIndex(array,predicate,fromIndex,fromRight){var length=array.length,index=fromIndex+(fromRight?1:-1);while(fromRight?index--:++index<length){if(predicate(array[index],index,array)){return index;}}return -1;}/**
    	   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
    	   *
    	   * @private
    	   * @param {Array} array The array to inspect.
    	   * @param {*} value The value to search for.
    	   * @param {number} fromIndex The index to search from.
    	   * @returns {number} Returns the index of the matched value, else `-1`.
    	   */function baseIndexOf(array,value,fromIndex){return value===value?strictIndexOf(array,value,fromIndex):baseFindIndex(array,baseIsNaN,fromIndex);}/**
    	   * This function is like `baseIndexOf` except that it accepts a comparator.
    	   *
    	   * @private
    	   * @param {Array} array The array to inspect.
    	   * @param {*} value The value to search for.
    	   * @param {number} fromIndex The index to search from.
    	   * @param {Function} comparator The comparator invoked per element.
    	   * @returns {number} Returns the index of the matched value, else `-1`.
    	   */function baseIndexOfWith(array,value,fromIndex,comparator){var index=fromIndex-1,length=array.length;while(++index<length){if(comparator(array[index],value)){return index;}}return -1;}/**
    	   * The base implementation of `_.isNaN` without support for number objects.
    	   *
    	   * @private
    	   * @param {*} value The value to check.
    	   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
    	   */function baseIsNaN(value){return value!==value;}/**
    	   * The base implementation of `_.mean` and `_.meanBy` without support for
    	   * iteratee shorthands.
    	   *
    	   * @private
    	   * @param {Array} array The array to iterate over.
    	   * @param {Function} iteratee The function invoked per iteration.
    	   * @returns {number} Returns the mean.
    	   */function baseMean(array,iteratee){var length=array==null?0:array.length;return length?baseSum(array,iteratee)/length:NAN;}/**
    	   * The base implementation of `_.property` without support for deep paths.
    	   *
    	   * @private
    	   * @param {string} key The key of the property to get.
    	   * @returns {Function} Returns the new accessor function.
    	   */function baseProperty(key){return function(object){return object==null?undefined$1:object[key];};}/**
    	   * The base implementation of `_.propertyOf` without support for deep paths.
    	   *
    	   * @private
    	   * @param {Object} object The object to query.
    	   * @returns {Function} Returns the new accessor function.
    	   */function basePropertyOf(object){return function(key){return object==null?undefined$1:object[key];};}/**
    	   * The base implementation of `_.reduce` and `_.reduceRight`, without support
    	   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
    	   *
    	   * @private
    	   * @param {Array|Object} collection The collection to iterate over.
    	   * @param {Function} iteratee The function invoked per iteration.
    	   * @param {*} accumulator The initial value.
    	   * @param {boolean} initAccum Specify using the first or last element of
    	   *  `collection` as the initial value.
    	   * @param {Function} eachFunc The function to iterate over `collection`.
    	   * @returns {*} Returns the accumulated value.
    	   */function baseReduce(collection,iteratee,accumulator,initAccum,eachFunc){eachFunc(collection,function(value,index,collection){accumulator=initAccum?(initAccum=false,value):iteratee(accumulator,value,index,collection);});return accumulator;}/**
    	   * The base implementation of `_.sortBy` which uses `comparer` to define the
    	   * sort order of `array` and replaces criteria objects with their corresponding
    	   * values.
    	   *
    	   * @private
    	   * @param {Array} array The array to sort.
    	   * @param {Function} comparer The function to define sort order.
    	   * @returns {Array} Returns `array`.
    	   */function baseSortBy(array,comparer){var length=array.length;array.sort(comparer);while(length--){array[length]=array[length].value;}return array;}/**
    	   * The base implementation of `_.sum` and `_.sumBy` without support for
    	   * iteratee shorthands.
    	   *
    	   * @private
    	   * @param {Array} array The array to iterate over.
    	   * @param {Function} iteratee The function invoked per iteration.
    	   * @returns {number} Returns the sum.
    	   */function baseSum(array,iteratee){var result,index=-1,length=array.length;while(++index<length){var current=iteratee(array[index]);if(current!==undefined$1){result=result===undefined$1?current:result+current;}}return result;}/**
    	   * The base implementation of `_.times` without support for iteratee shorthands
    	   * or max array length checks.
    	   *
    	   * @private
    	   * @param {number} n The number of times to invoke `iteratee`.
    	   * @param {Function} iteratee The function invoked per iteration.
    	   * @returns {Array} Returns the array of results.
    	   */function baseTimes(n,iteratee){var index=-1,result=Array(n);while(++index<n){result[index]=iteratee(index);}return result;}/**
    	   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
    	   * of key-value pairs for `object` corresponding to the property names of `props`.
    	   *
    	   * @private
    	   * @param {Object} object The object to query.
    	   * @param {Array} props The property names to get values for.
    	   * @returns {Object} Returns the key-value pairs.
    	   */function baseToPairs(object,props){return arrayMap(props,function(key){return [key,object[key]];});}/**
    	   * The base implementation of `_.trim`.
    	   *
    	   * @private
    	   * @param {string} string The string to trim.
    	   * @returns {string} Returns the trimmed string.
    	   */function baseTrim(string){return string?string.slice(0,trimmedEndIndex(string)+1).replace(reTrimStart,''):string;}/**
    	   * The base implementation of `_.unary` without support for storing metadata.
    	   *
    	   * @private
    	   * @param {Function} func The function to cap arguments for.
    	   * @returns {Function} Returns the new capped function.
    	   */function baseUnary(func){return function(value){return func(value);};}/**
    	   * The base implementation of `_.values` and `_.valuesIn` which creates an
    	   * array of `object` property values corresponding to the property names
    	   * of `props`.
    	   *
    	   * @private
    	   * @param {Object} object The object to query.
    	   * @param {Array} props The property names to get values for.
    	   * @returns {Object} Returns the array of property values.
    	   */function baseValues(object,props){return arrayMap(props,function(key){return object[key];});}/**
    	   * Checks if a `cache` value for `key` exists.
    	   *
    	   * @private
    	   * @param {Object} cache The cache to query.
    	   * @param {string} key The key of the entry to check.
    	   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
    	   */function cacheHas(cache,key){return cache.has(key);}/**
    	   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
    	   * that is not found in the character symbols.
    	   *
    	   * @private
    	   * @param {Array} strSymbols The string symbols to inspect.
    	   * @param {Array} chrSymbols The character symbols to find.
    	   * @returns {number} Returns the index of the first unmatched string symbol.
    	   */function charsStartIndex(strSymbols,chrSymbols){var index=-1,length=strSymbols.length;while(++index<length&&baseIndexOf(chrSymbols,strSymbols[index],0)>-1){}return index;}/**
    	   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
    	   * that is not found in the character symbols.
    	   *
    	   * @private
    	   * @param {Array} strSymbols The string symbols to inspect.
    	   * @param {Array} chrSymbols The character symbols to find.
    	   * @returns {number} Returns the index of the last unmatched string symbol.
    	   */function charsEndIndex(strSymbols,chrSymbols){var index=strSymbols.length;while(index--&&baseIndexOf(chrSymbols,strSymbols[index],0)>-1){}return index;}/**
    	   * Gets the number of `placeholder` occurrences in `array`.
    	   *
    	   * @private
    	   * @param {Array} array The array to inspect.
    	   * @param {*} placeholder The placeholder to search for.
    	   * @returns {number} Returns the placeholder count.
    	   */function countHolders(array,placeholder){var length=array.length,result=0;while(length--){if(array[length]===placeholder){++result;}}return result;}/**
    	   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
    	   * letters to basic Latin letters.
    	   *
    	   * @private
    	   * @param {string} letter The matched letter to deburr.
    	   * @returns {string} Returns the deburred letter.
    	   */var deburrLetter=basePropertyOf(deburredLetters);/**
    	   * Used by `_.escape` to convert characters to HTML entities.
    	   *
    	   * @private
    	   * @param {string} chr The matched character to escape.
    	   * @returns {string} Returns the escaped character.
    	   */var escapeHtmlChar=basePropertyOf(htmlEscapes);/**
    	   * Used by `_.template` to escape characters for inclusion in compiled string literals.
    	   *
    	   * @private
    	   * @param {string} chr The matched character to escape.
    	   * @returns {string} Returns the escaped character.
    	   */function escapeStringChar(chr){return '\\'+stringEscapes[chr];}/**
    	   * Gets the value at `key` of `object`.
    	   *
    	   * @private
    	   * @param {Object} [object] The object to query.
    	   * @param {string} key The key of the property to get.
    	   * @returns {*} Returns the property value.
    	   */function getValue(object,key){return object==null?undefined$1:object[key];}/**
    	   * Checks if `string` contains Unicode symbols.
    	   *
    	   * @private
    	   * @param {string} string The string to inspect.
    	   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
    	   */function hasUnicode(string){return reHasUnicode.test(string);}/**
    	   * Checks if `string` contains a word composed of Unicode symbols.
    	   *
    	   * @private
    	   * @param {string} string The string to inspect.
    	   * @returns {boolean} Returns `true` if a word is found, else `false`.
    	   */function hasUnicodeWord(string){return reHasUnicodeWord.test(string);}/**
    	   * Converts `iterator` to an array.
    	   *
    	   * @private
    	   * @param {Object} iterator The iterator to convert.
    	   * @returns {Array} Returns the converted array.
    	   */function iteratorToArray(iterator){var data,result=[];while(!(data=iterator.next()).done){result.push(data.value);}return result;}/**
    	   * Converts `map` to its key-value pairs.
    	   *
    	   * @private
    	   * @param {Object} map The map to convert.
    	   * @returns {Array} Returns the key-value pairs.
    	   */function mapToArray(map){var index=-1,result=Array(map.size);map.forEach(function(value,key){result[++index]=[key,value];});return result;}/**
    	   * Creates a unary function that invokes `func` with its argument transformed.
    	   *
    	   * @private
    	   * @param {Function} func The function to wrap.
    	   * @param {Function} transform The argument transform.
    	   * @returns {Function} Returns the new function.
    	   */function overArg(func,transform){return function(arg){return func(transform(arg));};}/**
    	   * Replaces all `placeholder` elements in `array` with an internal placeholder
    	   * and returns an array of their indexes.
    	   *
    	   * @private
    	   * @param {Array} array The array to modify.
    	   * @param {*} placeholder The placeholder to replace.
    	   * @returns {Array} Returns the new array of placeholder indexes.
    	   */function replaceHolders(array,placeholder){var index=-1,length=array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(value===placeholder||value===PLACEHOLDER){array[index]=PLACEHOLDER;result[resIndex++]=index;}}return result;}/**
    	   * Converts `set` to an array of its values.
    	   *
    	   * @private
    	   * @param {Object} set The set to convert.
    	   * @returns {Array} Returns the values.
    	   */function setToArray(set){var index=-1,result=Array(set.size);set.forEach(function(value){result[++index]=value;});return result;}/**
    	   * Converts `set` to its value-value pairs.
    	   *
    	   * @private
    	   * @param {Object} set The set to convert.
    	   * @returns {Array} Returns the value-value pairs.
    	   */function setToPairs(set){var index=-1,result=Array(set.size);set.forEach(function(value){result[++index]=[value,value];});return result;}/**
    	   * A specialized version of `_.indexOf` which performs strict equality
    	   * comparisons of values, i.e. `===`.
    	   *
    	   * @private
    	   * @param {Array} array The array to inspect.
    	   * @param {*} value The value to search for.
    	   * @param {number} fromIndex The index to search from.
    	   * @returns {number} Returns the index of the matched value, else `-1`.
    	   */function strictIndexOf(array,value,fromIndex){var index=fromIndex-1,length=array.length;while(++index<length){if(array[index]===value){return index;}}return -1;}/**
    	   * A specialized version of `_.lastIndexOf` which performs strict equality
    	   * comparisons of values, i.e. `===`.
    	   *
    	   * @private
    	   * @param {Array} array The array to inspect.
    	   * @param {*} value The value to search for.
    	   * @param {number} fromIndex The index to search from.
    	   * @returns {number} Returns the index of the matched value, else `-1`.
    	   */function strictLastIndexOf(array,value,fromIndex){var index=fromIndex+1;while(index--){if(array[index]===value){return index;}}return index;}/**
    	   * Gets the number of symbols in `string`.
    	   *
    	   * @private
    	   * @param {string} string The string to inspect.
    	   * @returns {number} Returns the string size.
    	   */function stringSize(string){return hasUnicode(string)?unicodeSize(string):asciiSize(string);}/**
    	   * Converts `string` to an array.
    	   *
    	   * @private
    	   * @param {string} string The string to convert.
    	   * @returns {Array} Returns the converted array.
    	   */function stringToArray(string){return hasUnicode(string)?unicodeToArray(string):asciiToArray(string);}/**
    	   * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
    	   * character of `string`.
    	   *
    	   * @private
    	   * @param {string} string The string to inspect.
    	   * @returns {number} Returns the index of the last non-whitespace character.
    	   */function trimmedEndIndex(string){var index=string.length;while(index--&&reWhitespace.test(string.charAt(index))){}return index;}/**
    	   * Used by `_.unescape` to convert HTML entities to characters.
    	   *
    	   * @private
    	   * @param {string} chr The matched character to unescape.
    	   * @returns {string} Returns the unescaped character.
    	   */var unescapeHtmlChar=basePropertyOf(htmlUnescapes);/**
    	   * Gets the size of a Unicode `string`.
    	   *
    	   * @private
    	   * @param {string} string The string inspect.
    	   * @returns {number} Returns the string size.
    	   */function unicodeSize(string){var result=reUnicode.lastIndex=0;while(reUnicode.test(string)){++result;}return result;}/**
    	   * Converts a Unicode `string` to an array.
    	   *
    	   * @private
    	   * @param {string} string The string to convert.
    	   * @returns {Array} Returns the converted array.
    	   */function unicodeToArray(string){return string.match(reUnicode)||[];}/**
    	   * Splits a Unicode `string` into an array of its words.
    	   *
    	   * @private
    	   * @param {string} The string to inspect.
    	   * @returns {Array} Returns the words of `string`.
    	   */function unicodeWords(string){return string.match(reUnicodeWord)||[];}/*--------------------------------------------------------------------------*/ /**
    	   * Create a new pristine `lodash` function using the `context` object.
    	   *
    	   * @static
    	   * @memberOf _
    	   * @since 1.1.0
    	   * @category Util
    	   * @param {Object} [context=root] The context object.
    	   * @returns {Function} Returns a new `lodash` function.
    	   * @example
    	   *
    	   * _.mixin({ 'foo': _.constant('foo') });
    	   *
    	   * var lodash = _.runInContext();
    	   * lodash.mixin({ 'bar': lodash.constant('bar') });
    	   *
    	   * _.isFunction(_.foo);
    	   * // => true
    	   * _.isFunction(_.bar);
    	   * // => false
    	   *
    	   * lodash.isFunction(lodash.foo);
    	   * // => false
    	   * lodash.isFunction(lodash.bar);
    	   * // => true
    	   *
    	   * // Create a suped-up `defer` in Node.js.
    	   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
    	   */var runInContext=function runInContext(context){context=context==null?root:_.defaults(root.Object(),context,_.pick(root,contextProps));/** Built-in constructor references. */var Array=context.Array,Date=context.Date,Error=context.Error,Function=context.Function,Math=context.Math,Object=context.Object,RegExp=context.RegExp,String=context.String,TypeError=context.TypeError;/** Used for built-in method references. */var arrayProto=Array.prototype,funcProto=Function.prototype,objectProto=Object.prototype;/** Used to detect overreaching core-js shims. */var coreJsData=context['__core-js_shared__'];/** Used to resolve the decompiled source of functions. */var funcToString=funcProto.toString;/** Used to check objects for own properties. */var hasOwnProperty=objectProto.hasOwnProperty;/** Used to generate unique IDs. */var idCounter=0;/** Used to detect methods masquerading as native. */var maskSrcKey=function(){var uid=/[^.]+$/.exec(coreJsData&&coreJsData.keys&&coreJsData.keys.IE_PROTO||'');return uid?'Symbol(src)_1.'+uid:'';}();/**
    	     * Used to resolve the
    	     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
    	     * of values.
    	     */var nativeObjectToString=objectProto.toString;/** Used to infer the `Object` constructor. */var objectCtorString=funcToString.call(Object);/** Used to restore the original `_` reference in `_.noConflict`. */var oldDash=root._;/** Used to detect if a method is native. */var reIsNative=RegExp('^'+funcToString.call(hasOwnProperty).replace(reRegExpChar,'\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,'$1.*?')+'$');/** Built-in value references. */var Buffer=moduleExports?context.Buffer:undefined$1,Symbol=context.Symbol,Uint8Array=context.Uint8Array,allocUnsafe=Buffer?Buffer.allocUnsafe:undefined$1,getPrototype=overArg(Object.getPrototypeOf,Object),objectCreate=Object.create,propertyIsEnumerable=objectProto.propertyIsEnumerable,splice=arrayProto.splice,spreadableSymbol=Symbol?Symbol.isConcatSpreadable:undefined$1,symIterator=Symbol?Symbol.iterator:undefined$1,symToStringTag=Symbol?Symbol.toStringTag:undefined$1;var defineProperty=function(){try{var func=getNative(Object,'defineProperty');func({},'',{});return func;}catch(e){}}();/** Mocked built-ins. */var ctxClearTimeout=context.clearTimeout!==root.clearTimeout&&context.clearTimeout,ctxNow=Date&&Date.now!==root.Date.now&&Date.now,ctxSetTimeout=context.setTimeout!==root.setTimeout&&context.setTimeout;/* Built-in method references for those with the same name as other `lodash` methods. */var nativeCeil=Math.ceil,nativeFloor=Math.floor,nativeGetSymbols=Object.getOwnPropertySymbols,nativeIsBuffer=Buffer?Buffer.isBuffer:undefined$1,nativeIsFinite=context.isFinite,nativeJoin=arrayProto.join,nativeKeys=overArg(Object.keys,Object),nativeMax=Math.max,nativeMin=Math.min,nativeNow=Date.now,nativeParseInt=context.parseInt,nativeRandom=Math.random,nativeReverse=arrayProto.reverse;/* Built-in method references that are verified to be native. */var DataView=getNative(context,'DataView'),Map=getNative(context,'Map'),Promise=getNative(context,'Promise'),Set=getNative(context,'Set'),WeakMap=getNative(context,'WeakMap'),nativeCreate=getNative(Object,'create');/** Used to store function metadata. */var metaMap=WeakMap&&new WeakMap();/** Used to lookup unminified function names. */var realNames={};/** Used to detect maps, sets, and weakmaps. */var dataViewCtorString=toSource(DataView),mapCtorString=toSource(Map),promiseCtorString=toSource(Promise),setCtorString=toSource(Set),weakMapCtorString=toSource(WeakMap);/** Used to convert symbols to primitives and strings. */var symbolProto=Symbol?Symbol.prototype:undefined$1,symbolValueOf=symbolProto?symbolProto.valueOf:undefined$1,symbolToString=symbolProto?symbolProto.toString:undefined$1;/*------------------------------------------------------------------------*/ /**
    	     * Creates a `lodash` object which wraps `value` to enable implicit method
    	     * chain sequences. Methods that operate on and return arrays, collections,
    	     * and functions can be chained together. Methods that retrieve a single value
    	     * or may return a primitive value will automatically end the chain sequence
    	     * and return the unwrapped value. Otherwise, the value must be unwrapped
    	     * with `_#value`.
    	     *
    	     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
    	     * enabled using `_.chain`.
    	     *
    	     * The execution of chained methods is lazy, that is, it's deferred until
    	     * `_#value` is implicitly or explicitly called.
    	     *
    	     * Lazy evaluation allows several methods to support shortcut fusion.
    	     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
    	     * the creation of intermediate arrays and can greatly reduce the number of
    	     * iteratee executions. Sections of a chain sequence qualify for shortcut
    	     * fusion if the section is applied to an array and iteratees accept only
    	     * one argument. The heuristic for whether a section qualifies for shortcut
    	     * fusion is subject to change.
    	     *
    	     * Chaining is supported in custom builds as long as the `_#value` method is
    	     * directly or indirectly included in the build.
    	     *
    	     * In addition to lodash methods, wrappers have `Array` and `String` methods.
    	     *
    	     * The wrapper `Array` methods are:
    	     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
    	     *
    	     * The wrapper `String` methods are:
    	     * `replace` and `split`
    	     *
    	     * The wrapper methods that support shortcut fusion are:
    	     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
    	     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
    	     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
    	     *
    	     * The chainable wrapper methods are:
    	     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
    	     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
    	     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
    	     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
    	     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
    	     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
    	     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
    	     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
    	     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
    	     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
    	     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
    	     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
    	     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
    	     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
    	     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
    	     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
    	     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
    	     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
    	     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
    	     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
    	     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
    	     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
    	     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
    	     * `zipObject`, `zipObjectDeep`, and `zipWith`
    	     *
    	     * The wrapper methods that are **not** chainable by default are:
    	     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
    	     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
    	     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
    	     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
    	     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
    	     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
    	     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
    	     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
    	     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
    	     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
    	     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
    	     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
    	     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
    	     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
    	     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
    	     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
    	     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
    	     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
    	     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
    	     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
    	     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
    	     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
    	     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
    	     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
    	     * `upperFirst`, `value`, and `words`
    	     *
    	     * @name _
    	     * @constructor
    	     * @category Seq
    	     * @param {*} value The value to wrap in a `lodash` instance.
    	     * @returns {Object} Returns the new `lodash` wrapper instance.
    	     * @example
    	     *
    	     * function square(n) {
    	     *   return n * n;
    	     * }
    	     *
    	     * var wrapped = _([1, 2, 3]);
    	     *
    	     * // Returns an unwrapped value.
    	     * wrapped.reduce(_.add);
    	     * // => 6
    	     *
    	     * // Returns a wrapped value.
    	     * var squares = wrapped.map(square);
    	     *
    	     * _.isArray(squares);
    	     * // => false
    	     *
    	     * _.isArray(squares.value());
    	     * // => true
    	     */function lodash(value){if(isObjectLike(value)&&!isArray(value)&&!(value instanceof LazyWrapper)){if(value instanceof LodashWrapper){return value;}if(hasOwnProperty.call(value,'__wrapped__')){return wrapperClone(value);}}return new LodashWrapper(value);}/**
    	     * The base implementation of `_.create` without support for assigning
    	     * properties to the created object.
    	     *
    	     * @private
    	     * @param {Object} proto The object to inherit from.
    	     * @returns {Object} Returns the new object.
    	     */var baseCreate=function(){function object(){}return function(proto){if(!isObject(proto)){return {};}if(objectCreate){return objectCreate(proto);}object.prototype=proto;var result=new object();object.prototype=undefined$1;return result;};}();/**
    	     * The function whose prototype chain sequence wrappers inherit from.
    	     *
    	     * @private
    	     */function baseLodash(){// No operation performed.
    	}/**
    	     * The base constructor for creating `lodash` wrapper objects.
    	     *
    	     * @private
    	     * @param {*} value The value to wrap.
    	     * @param {boolean} [chainAll] Enable explicit method chain sequences.
    	     */function LodashWrapper(value,chainAll){this.__wrapped__=value;this.__actions__=[];this.__chain__=!!chainAll;this.__index__=0;this.__values__=undefined$1;}/**
    	     * By default, the template delimiters used by lodash are like those in
    	     * embedded Ruby (ERB) as well as ES2015 template strings. Change the
    	     * following template settings to use alternative delimiters.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @type {Object}
    	     */lodash.templateSettings={/**
    	       * Used to detect `data` property values to be HTML-escaped.
    	       *
    	       * @memberOf _.templateSettings
    	       * @type {RegExp}
    	       */'escape':reEscape,/**
    	       * Used to detect code to be evaluated.
    	       *
    	       * @memberOf _.templateSettings
    	       * @type {RegExp}
    	       */'evaluate':reEvaluate,/**
    	       * Used to detect `data` property values to inject.
    	       *
    	       * @memberOf _.templateSettings
    	       * @type {RegExp}
    	       */'interpolate':reInterpolate,/**
    	       * Used to reference the data object in the template text.
    	       *
    	       * @memberOf _.templateSettings
    	       * @type {string}
    	       */'variable':'',/**
    	       * Used to import variables into the compiled template.
    	       *
    	       * @memberOf _.templateSettings
    	       * @type {Object}
    	       */'imports':{/**
    	         * A reference to the `lodash` function.
    	         *
    	         * @memberOf _.templateSettings.imports
    	         * @type {Function}
    	         */'_':lodash}};// Ensure wrappers are instances of `baseLodash`.
    	lodash.prototype=baseLodash.prototype;lodash.prototype.constructor=lodash;LodashWrapper.prototype=baseCreate(baseLodash.prototype);LodashWrapper.prototype.constructor=LodashWrapper;/*------------------------------------------------------------------------*/ /**
    	     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
    	     *
    	     * @private
    	     * @constructor
    	     * @param {*} value The value to wrap.
    	     */function LazyWrapper(value){this.__wrapped__=value;this.__actions__=[];this.__dir__=1;this.__filtered__=false;this.__iteratees__=[];this.__takeCount__=MAX_ARRAY_LENGTH;this.__views__=[];}/**
    	     * Creates a clone of the lazy wrapper object.
    	     *
    	     * @private
    	     * @name clone
    	     * @memberOf LazyWrapper
    	     * @returns {Object} Returns the cloned `LazyWrapper` object.
    	     */function lazyClone(){var result=new LazyWrapper(this.__wrapped__);result.__actions__=copyArray(this.__actions__);result.__dir__=this.__dir__;result.__filtered__=this.__filtered__;result.__iteratees__=copyArray(this.__iteratees__);result.__takeCount__=this.__takeCount__;result.__views__=copyArray(this.__views__);return result;}/**
    	     * Reverses the direction of lazy iteration.
    	     *
    	     * @private
    	     * @name reverse
    	     * @memberOf LazyWrapper
    	     * @returns {Object} Returns the new reversed `LazyWrapper` object.
    	     */function lazyReverse(){if(this.__filtered__){var result=new LazyWrapper(this);result.__dir__=-1;result.__filtered__=true;}else {result=this.clone();result.__dir__*=-1;}return result;}/**
    	     * Extracts the unwrapped value from its lazy wrapper.
    	     *
    	     * @private
    	     * @name value
    	     * @memberOf LazyWrapper
    	     * @returns {*} Returns the unwrapped value.
    	     */function lazyValue(){var array=this.__wrapped__.value(),dir=this.__dir__,isArr=isArray(array),isRight=dir<0,arrLength=isArr?array.length:0,view=getView(0,arrLength,this.__views__),start=view.start,end=view.end,length=end-start,index=isRight?end:start-1,iteratees=this.__iteratees__,iterLength=iteratees.length,resIndex=0,takeCount=nativeMin(length,this.__takeCount__);if(!isArr||!isRight&&arrLength==length&&takeCount==length){return baseWrapperValue(array,this.__actions__);}var result=[];outer:while(length--&&resIndex<takeCount){index+=dir;var iterIndex=-1,value=array[index];while(++iterIndex<iterLength){var data=iteratees[iterIndex],iteratee=data.iteratee,type=data.type,computed=iteratee(value);if(type==LAZY_MAP_FLAG){value=computed;}else if(!computed){if(type==LAZY_FILTER_FLAG){continue outer;}else {break outer;}}}result[resIndex++]=value;}return result;}// Ensure `LazyWrapper` is an instance of `baseLodash`.
    	LazyWrapper.prototype=baseCreate(baseLodash.prototype);LazyWrapper.prototype.constructor=LazyWrapper;/*------------------------------------------------------------------------*/ /**
    	     * Creates a hash object.
    	     *
    	     * @private
    	     * @constructor
    	     * @param {Array} [entries] The key-value pairs to cache.
    	     */function Hash(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
    	     * Removes all key-value entries from the hash.
    	     *
    	     * @private
    	     * @name clear
    	     * @memberOf Hash
    	     */function hashClear(){this.__data__=nativeCreate?nativeCreate(null):{};this.size=0;}/**
    	     * Removes `key` and its value from the hash.
    	     *
    	     * @private
    	     * @name delete
    	     * @memberOf Hash
    	     * @param {Object} hash The hash to modify.
    	     * @param {string} key The key of the value to remove.
    	     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
    	     */function hashDelete(key){var result=this.has(key)&&delete this.__data__[key];this.size-=result?1:0;return result;}/**
    	     * Gets the hash value for `key`.
    	     *
    	     * @private
    	     * @name get
    	     * @memberOf Hash
    	     * @param {string} key The key of the value to get.
    	     * @returns {*} Returns the entry value.
    	     */function hashGet(key){var data=this.__data__;if(nativeCreate){var result=data[key];return result===HASH_UNDEFINED?undefined$1:result;}return hasOwnProperty.call(data,key)?data[key]:undefined$1;}/**
    	     * Checks if a hash value for `key` exists.
    	     *
    	     * @private
    	     * @name has
    	     * @memberOf Hash
    	     * @param {string} key The key of the entry to check.
    	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
    	     */function hashHas(key){var data=this.__data__;return nativeCreate?data[key]!==undefined$1:hasOwnProperty.call(data,key);}/**
    	     * Sets the hash `key` to `value`.
    	     *
    	     * @private
    	     * @name set
    	     * @memberOf Hash
    	     * @param {string} key The key of the value to set.
    	     * @param {*} value The value to set.
    	     * @returns {Object} Returns the hash instance.
    	     */function hashSet(key,value){var data=this.__data__;this.size+=this.has(key)?0:1;data[key]=nativeCreate&&value===undefined$1?HASH_UNDEFINED:value;return this;}// Add methods to `Hash`.
    	Hash.prototype.clear=hashClear;Hash.prototype['delete']=hashDelete;Hash.prototype.get=hashGet;Hash.prototype.has=hashHas;Hash.prototype.set=hashSet;/*------------------------------------------------------------------------*/ /**
    	     * Creates an list cache object.
    	     *
    	     * @private
    	     * @constructor
    	     * @param {Array} [entries] The key-value pairs to cache.
    	     */function ListCache(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
    	     * Removes all key-value entries from the list cache.
    	     *
    	     * @private
    	     * @name clear
    	     * @memberOf ListCache
    	     */function listCacheClear(){this.__data__=[];this.size=0;}/**
    	     * Removes `key` and its value from the list cache.
    	     *
    	     * @private
    	     * @name delete
    	     * @memberOf ListCache
    	     * @param {string} key The key of the value to remove.
    	     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
    	     */function listCacheDelete(key){var data=this.__data__,index=assocIndexOf(data,key);if(index<0){return false;}var lastIndex=data.length-1;if(index==lastIndex){data.pop();}else {splice.call(data,index,1);}--this.size;return true;}/**
    	     * Gets the list cache value for `key`.
    	     *
    	     * @private
    	     * @name get
    	     * @memberOf ListCache
    	     * @param {string} key The key of the value to get.
    	     * @returns {*} Returns the entry value.
    	     */function listCacheGet(key){var data=this.__data__,index=assocIndexOf(data,key);return index<0?undefined$1:data[index][1];}/**
    	     * Checks if a list cache value for `key` exists.
    	     *
    	     * @private
    	     * @name has
    	     * @memberOf ListCache
    	     * @param {string} key The key of the entry to check.
    	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
    	     */function listCacheHas(key){return assocIndexOf(this.__data__,key)>-1;}/**
    	     * Sets the list cache `key` to `value`.
    	     *
    	     * @private
    	     * @name set
    	     * @memberOf ListCache
    	     * @param {string} key The key of the value to set.
    	     * @param {*} value The value to set.
    	     * @returns {Object} Returns the list cache instance.
    	     */function listCacheSet(key,value){var data=this.__data__,index=assocIndexOf(data,key);if(index<0){++this.size;data.push([key,value]);}else {data[index][1]=value;}return this;}// Add methods to `ListCache`.
    	ListCache.prototype.clear=listCacheClear;ListCache.prototype['delete']=listCacheDelete;ListCache.prototype.get=listCacheGet;ListCache.prototype.has=listCacheHas;ListCache.prototype.set=listCacheSet;/*------------------------------------------------------------------------*/ /**
    	     * Creates a map cache object to store key-value pairs.
    	     *
    	     * @private
    	     * @constructor
    	     * @param {Array} [entries] The key-value pairs to cache.
    	     */function MapCache(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
    	     * Removes all key-value entries from the map.
    	     *
    	     * @private
    	     * @name clear
    	     * @memberOf MapCache
    	     */function mapCacheClear(){this.size=0;this.__data__={'hash':new Hash(),'map':new(Map||ListCache)(),'string':new Hash()};}/**
    	     * Removes `key` and its value from the map.
    	     *
    	     * @private
    	     * @name delete
    	     * @memberOf MapCache
    	     * @param {string} key The key of the value to remove.
    	     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
    	     */function mapCacheDelete(key){var result=getMapData(this,key)['delete'](key);this.size-=result?1:0;return result;}/**
    	     * Gets the map value for `key`.
    	     *
    	     * @private
    	     * @name get
    	     * @memberOf MapCache
    	     * @param {string} key The key of the value to get.
    	     * @returns {*} Returns the entry value.
    	     */function mapCacheGet(key){return getMapData(this,key).get(key);}/**
    	     * Checks if a map value for `key` exists.
    	     *
    	     * @private
    	     * @name has
    	     * @memberOf MapCache
    	     * @param {string} key The key of the entry to check.
    	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
    	     */function mapCacheHas(key){return getMapData(this,key).has(key);}/**
    	     * Sets the map `key` to `value`.
    	     *
    	     * @private
    	     * @name set
    	     * @memberOf MapCache
    	     * @param {string} key The key of the value to set.
    	     * @param {*} value The value to set.
    	     * @returns {Object} Returns the map cache instance.
    	     */function mapCacheSet(key,value){var data=getMapData(this,key),size=data.size;data.set(key,value);this.size+=data.size==size?0:1;return this;}// Add methods to `MapCache`.
    	MapCache.prototype.clear=mapCacheClear;MapCache.prototype['delete']=mapCacheDelete;MapCache.prototype.get=mapCacheGet;MapCache.prototype.has=mapCacheHas;MapCache.prototype.set=mapCacheSet;/*------------------------------------------------------------------------*/ /**
    	     *
    	     * Creates an array cache object to store unique values.
    	     *
    	     * @private
    	     * @constructor
    	     * @param {Array} [values] The values to cache.
    	     */function SetCache(values){var index=-1,length=values==null?0:values.length;this.__data__=new MapCache();while(++index<length){this.add(values[index]);}}/**
    	     * Adds `value` to the array cache.
    	     *
    	     * @private
    	     * @name add
    	     * @memberOf SetCache
    	     * @alias push
    	     * @param {*} value The value to cache.
    	     * @returns {Object} Returns the cache instance.
    	     */function setCacheAdd(value){this.__data__.set(value,HASH_UNDEFINED);return this;}/**
    	     * Checks if `value` is in the array cache.
    	     *
    	     * @private
    	     * @name has
    	     * @memberOf SetCache
    	     * @param {*} value The value to search for.
    	     * @returns {number} Returns `true` if `value` is found, else `false`.
    	     */function setCacheHas(value){return this.__data__.has(value);}// Add methods to `SetCache`.
    	SetCache.prototype.add=SetCache.prototype.push=setCacheAdd;SetCache.prototype.has=setCacheHas;/*------------------------------------------------------------------------*/ /**
    	     * Creates a stack cache object to store key-value pairs.
    	     *
    	     * @private
    	     * @constructor
    	     * @param {Array} [entries] The key-value pairs to cache.
    	     */function Stack(entries){var data=this.__data__=new ListCache(entries);this.size=data.size;}/**
    	     * Removes all key-value entries from the stack.
    	     *
    	     * @private
    	     * @name clear
    	     * @memberOf Stack
    	     */function stackClear(){this.__data__=new ListCache();this.size=0;}/**
    	     * Removes `key` and its value from the stack.
    	     *
    	     * @private
    	     * @name delete
    	     * @memberOf Stack
    	     * @param {string} key The key of the value to remove.
    	     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
    	     */function stackDelete(key){var data=this.__data__,result=data['delete'](key);this.size=data.size;return result;}/**
    	     * Gets the stack value for `key`.
    	     *
    	     * @private
    	     * @name get
    	     * @memberOf Stack
    	     * @param {string} key The key of the value to get.
    	     * @returns {*} Returns the entry value.
    	     */function stackGet(key){return this.__data__.get(key);}/**
    	     * Checks if a stack value for `key` exists.
    	     *
    	     * @private
    	     * @name has
    	     * @memberOf Stack
    	     * @param {string} key The key of the entry to check.
    	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
    	     */function stackHas(key){return this.__data__.has(key);}/**
    	     * Sets the stack `key` to `value`.
    	     *
    	     * @private
    	     * @name set
    	     * @memberOf Stack
    	     * @param {string} key The key of the value to set.
    	     * @param {*} value The value to set.
    	     * @returns {Object} Returns the stack cache instance.
    	     */function stackSet(key,value){var data=this.__data__;if(data instanceof ListCache){var pairs=data.__data__;if(!Map||pairs.length<LARGE_ARRAY_SIZE-1){pairs.push([key,value]);this.size=++data.size;return this;}data=this.__data__=new MapCache(pairs);}data.set(key,value);this.size=data.size;return this;}// Add methods to `Stack`.
    	Stack.prototype.clear=stackClear;Stack.prototype['delete']=stackDelete;Stack.prototype.get=stackGet;Stack.prototype.has=stackHas;Stack.prototype.set=stackSet;/*------------------------------------------------------------------------*/ /**
    	     * Creates an array of the enumerable property names of the array-like `value`.
    	     *
    	     * @private
    	     * @param {*} value The value to query.
    	     * @param {boolean} inherited Specify returning inherited property names.
    	     * @returns {Array} Returns the array of property names.
    	     */function arrayLikeKeys(value,inherited){var isArr=isArray(value),isArg=!isArr&&isArguments(value),isBuff=!isArr&&!isArg&&isBuffer(value),isType=!isArr&&!isArg&&!isBuff&&isTypedArray(value),skipIndexes=isArr||isArg||isBuff||isType,result=skipIndexes?baseTimes(value.length,String):[],length=result.length;for(var key in value){if((inherited||hasOwnProperty.call(value,key))&&!(skipIndexes&&(// Safari 9 has enumerable `arguments.length` in strict mode.
    	key=='length'||// Node.js 0.10 has enumerable non-index properties on buffers.
    	isBuff&&(key=='offset'||key=='parent')||// PhantomJS 2 has enumerable non-index properties on typed arrays.
    	isType&&(key=='buffer'||key=='byteLength'||key=='byteOffset')||// Skip index properties.
    	isIndex(key,length)))){result.push(key);}}return result;}/**
    	     * A specialized version of `_.sample` for arrays.
    	     *
    	     * @private
    	     * @param {Array} array The array to sample.
    	     * @returns {*} Returns the random element.
    	     */function arraySample(array){var length=array.length;return length?array[baseRandom(0,length-1)]:undefined$1;}/**
    	     * A specialized version of `_.sampleSize` for arrays.
    	     *
    	     * @private
    	     * @param {Array} array The array to sample.
    	     * @param {number} n The number of elements to sample.
    	     * @returns {Array} Returns the random elements.
    	     */function arraySampleSize(array,n){return shuffleSelf(copyArray(array),baseClamp(n,0,array.length));}/**
    	     * A specialized version of `_.shuffle` for arrays.
    	     *
    	     * @private
    	     * @param {Array} array The array to shuffle.
    	     * @returns {Array} Returns the new shuffled array.
    	     */function arrayShuffle(array){return shuffleSelf(copyArray(array));}/**
    	     * This function is like `assignValue` except that it doesn't assign
    	     * `undefined` values.
    	     *
    	     * @private
    	     * @param {Object} object The object to modify.
    	     * @param {string} key The key of the property to assign.
    	     * @param {*} value The value to assign.
    	     */function assignMergeValue(object,key,value){if(value!==undefined$1&&!eq(object[key],value)||value===undefined$1&&!(key in object)){baseAssignValue(object,key,value);}}/**
    	     * Assigns `value` to `key` of `object` if the existing value is not equivalent
    	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
    	     * for equality comparisons.
    	     *
    	     * @private
    	     * @param {Object} object The object to modify.
    	     * @param {string} key The key of the property to assign.
    	     * @param {*} value The value to assign.
    	     */function assignValue(object,key,value){var objValue=object[key];if(!(hasOwnProperty.call(object,key)&&eq(objValue,value))||value===undefined$1&&!(key in object)){baseAssignValue(object,key,value);}}/**
    	     * Gets the index at which the `key` is found in `array` of key-value pairs.
    	     *
    	     * @private
    	     * @param {Array} array The array to inspect.
    	     * @param {*} key The key to search for.
    	     * @returns {number} Returns the index of the matched value, else `-1`.
    	     */function assocIndexOf(array,key){var length=array.length;while(length--){if(eq(array[length][0],key)){return length;}}return -1;}/**
    	     * Aggregates elements of `collection` on `accumulator` with keys transformed
    	     * by `iteratee` and values set by `setter`.
    	     *
    	     * @private
    	     * @param {Array|Object} collection The collection to iterate over.
    	     * @param {Function} setter The function to set `accumulator` values.
    	     * @param {Function} iteratee The iteratee to transform keys.
    	     * @param {Object} accumulator The initial aggregated object.
    	     * @returns {Function} Returns `accumulator`.
    	     */function baseAggregator(collection,setter,iteratee,accumulator){baseEach(collection,function(value,key,collection){setter(accumulator,value,iteratee(value),collection);});return accumulator;}/**
    	     * The base implementation of `_.assign` without support for multiple sources
    	     * or `customizer` functions.
    	     *
    	     * @private
    	     * @param {Object} object The destination object.
    	     * @param {Object} source The source object.
    	     * @returns {Object} Returns `object`.
    	     */function baseAssign(object,source){return object&&copyObject(source,keys(source),object);}/**
    	     * The base implementation of `_.assignIn` without support for multiple sources
    	     * or `customizer` functions.
    	     *
    	     * @private
    	     * @param {Object} object The destination object.
    	     * @param {Object} source The source object.
    	     * @returns {Object} Returns `object`.
    	     */function baseAssignIn(object,source){return object&&copyObject(source,keysIn(source),object);}/**
    	     * The base implementation of `assignValue` and `assignMergeValue` without
    	     * value checks.
    	     *
    	     * @private
    	     * @param {Object} object The object to modify.
    	     * @param {string} key The key of the property to assign.
    	     * @param {*} value The value to assign.
    	     */function baseAssignValue(object,key,value){if(key=='__proto__'&&defineProperty){defineProperty(object,key,{'configurable':true,'enumerable':true,'value':value,'writable':true});}else {object[key]=value;}}/**
    	     * The base implementation of `_.at` without support for individual paths.
    	     *
    	     * @private
    	     * @param {Object} object The object to iterate over.
    	     * @param {string[]} paths The property paths to pick.
    	     * @returns {Array} Returns the picked elements.
    	     */function baseAt(object,paths){var index=-1,length=paths.length,result=Array(length),skip=object==null;while(++index<length){result[index]=skip?undefined$1:get(object,paths[index]);}return result;}/**
    	     * The base implementation of `_.clamp` which doesn't coerce arguments.
    	     *
    	     * @private
    	     * @param {number} number The number to clamp.
    	     * @param {number} [lower] The lower bound.
    	     * @param {number} upper The upper bound.
    	     * @returns {number} Returns the clamped number.
    	     */function baseClamp(number,lower,upper){if(number===number){if(upper!==undefined$1){number=number<=upper?number:upper;}if(lower!==undefined$1){number=number>=lower?number:lower;}}return number;}/**
    	     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
    	     * traversed objects.
    	     *
    	     * @private
    	     * @param {*} value The value to clone.
    	     * @param {boolean} bitmask The bitmask flags.
    	     *  1 - Deep clone
    	     *  2 - Flatten inherited properties
    	     *  4 - Clone symbols
    	     * @param {Function} [customizer] The function to customize cloning.
    	     * @param {string} [key] The key of `value`.
    	     * @param {Object} [object] The parent object of `value`.
    	     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
    	     * @returns {*} Returns the cloned value.
    	     */function baseClone(value,bitmask,customizer,key,object,stack){var result,isDeep=bitmask&CLONE_DEEP_FLAG,isFlat=bitmask&CLONE_FLAT_FLAG,isFull=bitmask&CLONE_SYMBOLS_FLAG;if(customizer){result=object?customizer(value,key,object,stack):customizer(value);}if(result!==undefined$1){return result;}if(!isObject(value)){return value;}var isArr=isArray(value);if(isArr){result=initCloneArray(value);if(!isDeep){return copyArray(value,result);}}else {var tag=getTag(value),isFunc=tag==funcTag||tag==genTag;if(isBuffer(value)){return cloneBuffer(value,isDeep);}if(tag==objectTag||tag==argsTag||isFunc&&!object){result=isFlat||isFunc?{}:initCloneObject(value);if(!isDeep){return isFlat?copySymbolsIn(value,baseAssignIn(result,value)):copySymbols(value,baseAssign(result,value));}}else {if(!cloneableTags[tag]){return object?value:{};}result=initCloneByTag(value,tag,isDeep);}}// Check for circular references and return its corresponding clone.
    	stack||(stack=new Stack());var stacked=stack.get(value);if(stacked){return stacked;}stack.set(value,result);if(isSet(value)){value.forEach(function(subValue){result.add(baseClone(subValue,bitmask,customizer,subValue,value,stack));});}else if(isMap(value)){value.forEach(function(subValue,key){result.set(key,baseClone(subValue,bitmask,customizer,key,value,stack));});}var keysFunc=isFull?isFlat?getAllKeysIn:getAllKeys:isFlat?keysIn:keys;var props=isArr?undefined$1:keysFunc(value);arrayEach(props||value,function(subValue,key){if(props){key=subValue;subValue=value[key];}// Recursively populate clone (susceptible to call stack limits).
    	assignValue(result,key,baseClone(subValue,bitmask,customizer,key,value,stack));});return result;}/**
    	     * The base implementation of `_.conforms` which doesn't clone `source`.
    	     *
    	     * @private
    	     * @param {Object} source The object of property predicates to conform to.
    	     * @returns {Function} Returns the new spec function.
    	     */function baseConforms(source){var props=keys(source);return function(object){return baseConformsTo(object,source,props);};}/**
    	     * The base implementation of `_.conformsTo` which accepts `props` to check.
    	     *
    	     * @private
    	     * @param {Object} object The object to inspect.
    	     * @param {Object} source The object of property predicates to conform to.
    	     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
    	     */function baseConformsTo(object,source,props){var length=props.length;if(object==null){return !length;}object=Object(object);while(length--){var key=props[length],predicate=source[key],value=object[key];if(value===undefined$1&&!(key in object)||!predicate(value)){return false;}}return true;}/**
    	     * The base implementation of `_.delay` and `_.defer` which accepts `args`
    	     * to provide to `func`.
    	     *
    	     * @private
    	     * @param {Function} func The function to delay.
    	     * @param {number} wait The number of milliseconds to delay invocation.
    	     * @param {Array} args The arguments to provide to `func`.
    	     * @returns {number|Object} Returns the timer id or timeout object.
    	     */function baseDelay(func,wait,args){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return setTimeout(function(){func.apply(undefined$1,args);},wait);}/**
    	     * The base implementation of methods like `_.difference` without support
    	     * for excluding multiple arrays or iteratee shorthands.
    	     *
    	     * @private
    	     * @param {Array} array The array to inspect.
    	     * @param {Array} values The values to exclude.
    	     * @param {Function} [iteratee] The iteratee invoked per element.
    	     * @param {Function} [comparator] The comparator invoked per element.
    	     * @returns {Array} Returns the new array of filtered values.
    	     */function baseDifference(array,values,iteratee,comparator){var index=-1,includes=arrayIncludes,isCommon=true,length=array.length,result=[],valuesLength=values.length;if(!length){return result;}if(iteratee){values=arrayMap(values,baseUnary(iteratee));}if(comparator){includes=arrayIncludesWith;isCommon=false;}else if(values.length>=LARGE_ARRAY_SIZE){includes=cacheHas;isCommon=false;values=new SetCache(values);}outer:while(++index<length){var value=array[index],computed=iteratee==null?value:iteratee(value);value=comparator||value!==0?value:0;if(isCommon&&computed===computed){var valuesIndex=valuesLength;while(valuesIndex--){if(values[valuesIndex]===computed){continue outer;}}result.push(value);}else if(!includes(values,computed,comparator)){result.push(value);}}return result;}/**
    	     * The base implementation of `_.forEach` without support for iteratee shorthands.
    	     *
    	     * @private
    	     * @param {Array|Object} collection The collection to iterate over.
    	     * @param {Function} iteratee The function invoked per iteration.
    	     * @returns {Array|Object} Returns `collection`.
    	     */var baseEach=createBaseEach(baseForOwn);/**
    	     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
    	     *
    	     * @private
    	     * @param {Array|Object} collection The collection to iterate over.
    	     * @param {Function} iteratee The function invoked per iteration.
    	     * @returns {Array|Object} Returns `collection`.
    	     */var baseEachRight=createBaseEach(baseForOwnRight,true);/**
    	     * The base implementation of `_.every` without support for iteratee shorthands.
    	     *
    	     * @private
    	     * @param {Array|Object} collection The collection to iterate over.
    	     * @param {Function} predicate The function invoked per iteration.
    	     * @returns {boolean} Returns `true` if all elements pass the predicate check,
    	     *  else `false`
    	     */function baseEvery(collection,predicate){var result=true;baseEach(collection,function(value,index,collection){result=!!predicate(value,index,collection);return result;});return result;}/**
    	     * The base implementation of methods like `_.max` and `_.min` which accepts a
    	     * `comparator` to determine the extremum value.
    	     *
    	     * @private
    	     * @param {Array} array The array to iterate over.
    	     * @param {Function} iteratee The iteratee invoked per iteration.
    	     * @param {Function} comparator The comparator used to compare values.
    	     * @returns {*} Returns the extremum value.
    	     */function baseExtremum(array,iteratee,comparator){var index=-1,length=array.length;while(++index<length){var value=array[index],current=iteratee(value);if(current!=null&&(computed===undefined$1?current===current&&!isSymbol(current):comparator(current,computed))){var computed=current,result=value;}}return result;}/**
    	     * The base implementation of `_.fill` without an iteratee call guard.
    	     *
    	     * @private
    	     * @param {Array} array The array to fill.
    	     * @param {*} value The value to fill `array` with.
    	     * @param {number} [start=0] The start position.
    	     * @param {number} [end=array.length] The end position.
    	     * @returns {Array} Returns `array`.
    	     */function baseFill(array,value,start,end){var length=array.length;start=toInteger(start);if(start<0){start=-start>length?0:length+start;}end=end===undefined$1||end>length?length:toInteger(end);if(end<0){end+=length;}end=start>end?0:toLength(end);while(start<end){array[start++]=value;}return array;}/**
    	     * The base implementation of `_.filter` without support for iteratee shorthands.
    	     *
    	     * @private
    	     * @param {Array|Object} collection The collection to iterate over.
    	     * @param {Function} predicate The function invoked per iteration.
    	     * @returns {Array} Returns the new filtered array.
    	     */function baseFilter(collection,predicate){var result=[];baseEach(collection,function(value,index,collection){if(predicate(value,index,collection)){result.push(value);}});return result;}/**
    	     * The base implementation of `_.flatten` with support for restricting flattening.
    	     *
    	     * @private
    	     * @param {Array} array The array to flatten.
    	     * @param {number} depth The maximum recursion depth.
    	     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
    	     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
    	     * @param {Array} [result=[]] The initial result value.
    	     * @returns {Array} Returns the new flattened array.
    	     */function baseFlatten(array,depth,predicate,isStrict,result){var index=-1,length=array.length;predicate||(predicate=isFlattenable);result||(result=[]);while(++index<length){var value=array[index];if(depth>0&&predicate(value)){if(depth>1){// Recursively flatten arrays (susceptible to call stack limits).
    	baseFlatten(value,depth-1,predicate,isStrict,result);}else {arrayPush(result,value);}}else if(!isStrict){result[result.length]=value;}}return result;}/**
    	     * The base implementation of `baseForOwn` which iterates over `object`
    	     * properties returned by `keysFunc` and invokes `iteratee` for each property.
    	     * Iteratee functions may exit iteration early by explicitly returning `false`.
    	     *
    	     * @private
    	     * @param {Object} object The object to iterate over.
    	     * @param {Function} iteratee The function invoked per iteration.
    	     * @param {Function} keysFunc The function to get the keys of `object`.
    	     * @returns {Object} Returns `object`.
    	     */var baseFor=createBaseFor();/**
    	     * This function is like `baseFor` except that it iterates over properties
    	     * in the opposite order.
    	     *
    	     * @private
    	     * @param {Object} object The object to iterate over.
    	     * @param {Function} iteratee The function invoked per iteration.
    	     * @param {Function} keysFunc The function to get the keys of `object`.
    	     * @returns {Object} Returns `object`.
    	     */var baseForRight=createBaseFor(true);/**
    	     * The base implementation of `_.forOwn` without support for iteratee shorthands.
    	     *
    	     * @private
    	     * @param {Object} object The object to iterate over.
    	     * @param {Function} iteratee The function invoked per iteration.
    	     * @returns {Object} Returns `object`.
    	     */function baseForOwn(object,iteratee){return object&&baseFor(object,iteratee,keys);}/**
    	     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
    	     *
    	     * @private
    	     * @param {Object} object The object to iterate over.
    	     * @param {Function} iteratee The function invoked per iteration.
    	     * @returns {Object} Returns `object`.
    	     */function baseForOwnRight(object,iteratee){return object&&baseForRight(object,iteratee,keys);}/**
    	     * The base implementation of `_.functions` which creates an array of
    	     * `object` function property names filtered from `props`.
    	     *
    	     * @private
    	     * @param {Object} object The object to inspect.
    	     * @param {Array} props The property names to filter.
    	     * @returns {Array} Returns the function names.
    	     */function baseFunctions(object,props){return arrayFilter(props,function(key){return isFunction(object[key]);});}/**
    	     * The base implementation of `_.get` without support for default values.
    	     *
    	     * @private
    	     * @param {Object} object The object to query.
    	     * @param {Array|string} path The path of the property to get.
    	     * @returns {*} Returns the resolved value.
    	     */function baseGet(object,path){path=castPath(path,object);var index=0,length=path.length;while(object!=null&&index<length){object=object[toKey(path[index++])];}return index&&index==length?object:undefined$1;}/**
    	     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
    	     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
    	     * symbols of `object`.
    	     *
    	     * @private
    	     * @param {Object} object The object to query.
    	     * @param {Function} keysFunc The function to get the keys of `object`.
    	     * @param {Function} symbolsFunc The function to get the symbols of `object`.
    	     * @returns {Array} Returns the array of property names and symbols.
    	     */function baseGetAllKeys(object,keysFunc,symbolsFunc){var result=keysFunc(object);return isArray(object)?result:arrayPush(result,symbolsFunc(object));}/**
    	     * The base implementation of `getTag` without fallbacks for buggy environments.
    	     *
    	     * @private
    	     * @param {*} value The value to query.
    	     * @returns {string} Returns the `toStringTag`.
    	     */function baseGetTag(value){if(value==null){return value===undefined$1?undefinedTag:nullTag;}return symToStringTag&&symToStringTag in Object(value)?getRawTag(value):objectToString(value);}/**
    	     * The base implementation of `_.gt` which doesn't coerce arguments.
    	     *
    	     * @private
    	     * @param {*} value The value to compare.
    	     * @param {*} other The other value to compare.
    	     * @returns {boolean} Returns `true` if `value` is greater than `other`,
    	     *  else `false`.
    	     */function baseGt(value,other){return value>other;}/**
    	     * The base implementation of `_.has` without support for deep paths.
    	     *
    	     * @private
    	     * @param {Object} [object] The object to query.
    	     * @param {Array|string} key The key to check.
    	     * @returns {boolean} Returns `true` if `key` exists, else `false`.
    	     */function baseHas(object,key){return object!=null&&hasOwnProperty.call(object,key);}/**
    	     * The base implementation of `_.hasIn` without support for deep paths.
    	     *
    	     * @private
    	     * @param {Object} [object] The object to query.
    	     * @param {Array|string} key The key to check.
    	     * @returns {boolean} Returns `true` if `key` exists, else `false`.
    	     */function baseHasIn(object,key){return object!=null&&key in Object(object);}/**
    	     * The base implementation of `_.inRange` which doesn't coerce arguments.
    	     *
    	     * @private
    	     * @param {number} number The number to check.
    	     * @param {number} start The start of the range.
    	     * @param {number} end The end of the range.
    	     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
    	     */function baseInRange(number,start,end){return number>=nativeMin(start,end)&&number<nativeMax(start,end);}/**
    	     * The base implementation of methods like `_.intersection`, without support
    	     * for iteratee shorthands, that accepts an array of arrays to inspect.
    	     *
    	     * @private
    	     * @param {Array} arrays The arrays to inspect.
    	     * @param {Function} [iteratee] The iteratee invoked per element.
    	     * @param {Function} [comparator] The comparator invoked per element.
    	     * @returns {Array} Returns the new array of shared values.
    	     */function baseIntersection(arrays,iteratee,comparator){var includes=comparator?arrayIncludesWith:arrayIncludes,length=arrays[0].length,othLength=arrays.length,othIndex=othLength,caches=Array(othLength),maxLength=Infinity,result=[];while(othIndex--){var array=arrays[othIndex];if(othIndex&&iteratee){array=arrayMap(array,baseUnary(iteratee));}maxLength=nativeMin(array.length,maxLength);caches[othIndex]=!comparator&&(iteratee||length>=120&&array.length>=120)?new SetCache(othIndex&&array):undefined$1;}array=arrays[0];var index=-1,seen=caches[0];outer:while(++index<length&&result.length<maxLength){var value=array[index],computed=iteratee?iteratee(value):value;value=comparator||value!==0?value:0;if(!(seen?cacheHas(seen,computed):includes(result,computed,comparator))){othIndex=othLength;while(--othIndex){var cache=caches[othIndex];if(!(cache?cacheHas(cache,computed):includes(arrays[othIndex],computed,comparator))){continue outer;}}if(seen){seen.push(computed);}result.push(value);}}return result;}/**
    	     * The base implementation of `_.invert` and `_.invertBy` which inverts
    	     * `object` with values transformed by `iteratee` and set by `setter`.
    	     *
    	     * @private
    	     * @param {Object} object The object to iterate over.
    	     * @param {Function} setter The function to set `accumulator` values.
    	     * @param {Function} iteratee The iteratee to transform values.
    	     * @param {Object} accumulator The initial inverted object.
    	     * @returns {Function} Returns `accumulator`.
    	     */function baseInverter(object,setter,iteratee,accumulator){baseForOwn(object,function(value,key,object){setter(accumulator,iteratee(value),key,object);});return accumulator;}/**
    	     * The base implementation of `_.invoke` without support for individual
    	     * method arguments.
    	     *
    	     * @private
    	     * @param {Object} object The object to query.
    	     * @param {Array|string} path The path of the method to invoke.
    	     * @param {Array} args The arguments to invoke the method with.
    	     * @returns {*} Returns the result of the invoked method.
    	     */function baseInvoke(object,path,args){path=castPath(path,object);object=parent(object,path);var func=object==null?object:object[toKey(last(path))];return func==null?undefined$1:apply(func,object,args);}/**
    	     * The base implementation of `_.isArguments`.
    	     *
    	     * @private
    	     * @param {*} value The value to check.
    	     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
    	     */function baseIsArguments(value){return isObjectLike(value)&&baseGetTag(value)==argsTag;}/**
    	     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
    	     *
    	     * @private
    	     * @param {*} value The value to check.
    	     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
    	     */function baseIsArrayBuffer(value){return isObjectLike(value)&&baseGetTag(value)==arrayBufferTag;}/**
    	     * The base implementation of `_.isDate` without Node.js optimizations.
    	     *
    	     * @private
    	     * @param {*} value The value to check.
    	     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
    	     */function baseIsDate(value){return isObjectLike(value)&&baseGetTag(value)==dateTag;}/**
    	     * The base implementation of `_.isEqual` which supports partial comparisons
    	     * and tracks traversed objects.
    	     *
    	     * @private
    	     * @param {*} value The value to compare.
    	     * @param {*} other The other value to compare.
    	     * @param {boolean} bitmask The bitmask flags.
    	     *  1 - Unordered comparison
    	     *  2 - Partial comparison
    	     * @param {Function} [customizer] The function to customize comparisons.
    	     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
    	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
    	     */function baseIsEqual(value,other,bitmask,customizer,stack){if(value===other){return true;}if(value==null||other==null||!isObjectLike(value)&&!isObjectLike(other)){return value!==value&&other!==other;}return baseIsEqualDeep(value,other,bitmask,customizer,baseIsEqual,stack);}/**
    	     * A specialized version of `baseIsEqual` for arrays and objects which performs
    	     * deep comparisons and tracks traversed objects enabling objects with circular
    	     * references to be compared.
    	     *
    	     * @private
    	     * @param {Object} object The object to compare.
    	     * @param {Object} other The other object to compare.
    	     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
    	     * @param {Function} customizer The function to customize comparisons.
    	     * @param {Function} equalFunc The function to determine equivalents of values.
    	     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
    	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
    	     */function baseIsEqualDeep(object,other,bitmask,customizer,equalFunc,stack){var objIsArr=isArray(object),othIsArr=isArray(other),objTag=objIsArr?arrayTag:getTag(object),othTag=othIsArr?arrayTag:getTag(other);objTag=objTag==argsTag?objectTag:objTag;othTag=othTag==argsTag?objectTag:othTag;var objIsObj=objTag==objectTag,othIsObj=othTag==objectTag,isSameTag=objTag==othTag;if(isSameTag&&isBuffer(object)){if(!isBuffer(other)){return false;}objIsArr=true;objIsObj=false;}if(isSameTag&&!objIsObj){stack||(stack=new Stack());return objIsArr||isTypedArray(object)?equalArrays(object,other,bitmask,customizer,equalFunc,stack):equalByTag(object,other,objTag,bitmask,customizer,equalFunc,stack);}if(!(bitmask&COMPARE_PARTIAL_FLAG)){var objIsWrapped=objIsObj&&hasOwnProperty.call(object,'__wrapped__'),othIsWrapped=othIsObj&&hasOwnProperty.call(other,'__wrapped__');if(objIsWrapped||othIsWrapped){var objUnwrapped=objIsWrapped?object.value():object,othUnwrapped=othIsWrapped?other.value():other;stack||(stack=new Stack());return equalFunc(objUnwrapped,othUnwrapped,bitmask,customizer,stack);}}if(!isSameTag){return false;}stack||(stack=new Stack());return equalObjects(object,other,bitmask,customizer,equalFunc,stack);}/**
    	     * The base implementation of `_.isMap` without Node.js optimizations.
    	     *
    	     * @private
    	     * @param {*} value The value to check.
    	     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
    	     */function baseIsMap(value){return isObjectLike(value)&&getTag(value)==mapTag;}/**
    	     * The base implementation of `_.isMatch` without support for iteratee shorthands.
    	     *
    	     * @private
    	     * @param {Object} object The object to inspect.
    	     * @param {Object} source The object of property values to match.
    	     * @param {Array} matchData The property names, values, and compare flags to match.
    	     * @param {Function} [customizer] The function to customize comparisons.
    	     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
    	     */function baseIsMatch(object,source,matchData,customizer){var index=matchData.length,length=index,noCustomizer=!customizer;if(object==null){return !length;}object=Object(object);while(index--){var data=matchData[index];if(noCustomizer&&data[2]?data[1]!==object[data[0]]:!(data[0]in object)){return false;}}while(++index<length){data=matchData[index];var key=data[0],objValue=object[key],srcValue=data[1];if(noCustomizer&&data[2]){if(objValue===undefined$1&&!(key in object)){return false;}}else {var stack=new Stack();if(customizer){var result=customizer(objValue,srcValue,key,object,source,stack);}if(!(result===undefined$1?baseIsEqual(srcValue,objValue,COMPARE_PARTIAL_FLAG|COMPARE_UNORDERED_FLAG,customizer,stack):result)){return false;}}}return true;}/**
    	     * The base implementation of `_.isNative` without bad shim checks.
    	     *
    	     * @private
    	     * @param {*} value The value to check.
    	     * @returns {boolean} Returns `true` if `value` is a native function,
    	     *  else `false`.
    	     */function baseIsNative(value){if(!isObject(value)||isMasked(value)){return false;}var pattern=isFunction(value)?reIsNative:reIsHostCtor;return pattern.test(toSource(value));}/**
    	     * The base implementation of `_.isRegExp` without Node.js optimizations.
    	     *
    	     * @private
    	     * @param {*} value The value to check.
    	     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
    	     */function baseIsRegExp(value){return isObjectLike(value)&&baseGetTag(value)==regexpTag;}/**
    	     * The base implementation of `_.isSet` without Node.js optimizations.
    	     *
    	     * @private
    	     * @param {*} value The value to check.
    	     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
    	     */function baseIsSet(value){return isObjectLike(value)&&getTag(value)==setTag;}/**
    	     * The base implementation of `_.isTypedArray` without Node.js optimizations.
    	     *
    	     * @private
    	     * @param {*} value The value to check.
    	     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
    	     */function baseIsTypedArray(value){return isObjectLike(value)&&isLength(value.length)&&!!typedArrayTags[baseGetTag(value)];}/**
    	     * The base implementation of `_.iteratee`.
    	     *
    	     * @private
    	     * @param {*} [value=_.identity] The value to convert to an iteratee.
    	     * @returns {Function} Returns the iteratee.
    	     */function baseIteratee(value){// Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
    	// See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
    	if(typeof value=='function'){return value;}if(value==null){return identity;}if(typeof value=='object'){return isArray(value)?baseMatchesProperty(value[0],value[1]):baseMatches(value);}return property(value);}/**
    	     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
    	     *
    	     * @private
    	     * @param {Object} object The object to query.
    	     * @returns {Array} Returns the array of property names.
    	     */function baseKeys(object){if(!isPrototype(object)){return nativeKeys(object);}var result=[];for(var key in Object(object)){if(hasOwnProperty.call(object,key)&&key!='constructor'){result.push(key);}}return result;}/**
    	     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
    	     *
    	     * @private
    	     * @param {Object} object The object to query.
    	     * @returns {Array} Returns the array of property names.
    	     */function baseKeysIn(object){if(!isObject(object)){return nativeKeysIn(object);}var isProto=isPrototype(object),result=[];for(var key in object){if(!(key=='constructor'&&(isProto||!hasOwnProperty.call(object,key)))){result.push(key);}}return result;}/**
    	     * The base implementation of `_.lt` which doesn't coerce arguments.
    	     *
    	     * @private
    	     * @param {*} value The value to compare.
    	     * @param {*} other The other value to compare.
    	     * @returns {boolean} Returns `true` if `value` is less than `other`,
    	     *  else `false`.
    	     */function baseLt(value,other){return value<other;}/**
    	     * The base implementation of `_.map` without support for iteratee shorthands.
    	     *
    	     * @private
    	     * @param {Array|Object} collection The collection to iterate over.
    	     * @param {Function} iteratee The function invoked per iteration.
    	     * @returns {Array} Returns the new mapped array.
    	     */function baseMap(collection,iteratee){var index=-1,result=isArrayLike(collection)?Array(collection.length):[];baseEach(collection,function(value,key,collection){result[++index]=iteratee(value,key,collection);});return result;}/**
    	     * The base implementation of `_.matches` which doesn't clone `source`.
    	     *
    	     * @private
    	     * @param {Object} source The object of property values to match.
    	     * @returns {Function} Returns the new spec function.
    	     */function baseMatches(source){var matchData=getMatchData(source);if(matchData.length==1&&matchData[0][2]){return matchesStrictComparable(matchData[0][0],matchData[0][1]);}return function(object){return object===source||baseIsMatch(object,source,matchData);};}/**
    	     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
    	     *
    	     * @private
    	     * @param {string} path The path of the property to get.
    	     * @param {*} srcValue The value to match.
    	     * @returns {Function} Returns the new spec function.
    	     */function baseMatchesProperty(path,srcValue){if(isKey(path)&&isStrictComparable(srcValue)){return matchesStrictComparable(toKey(path),srcValue);}return function(object){var objValue=get(object,path);return objValue===undefined$1&&objValue===srcValue?hasIn(object,path):baseIsEqual(srcValue,objValue,COMPARE_PARTIAL_FLAG|COMPARE_UNORDERED_FLAG);};}/**
    	     * The base implementation of `_.merge` without support for multiple sources.
    	     *
    	     * @private
    	     * @param {Object} object The destination object.
    	     * @param {Object} source The source object.
    	     * @param {number} srcIndex The index of `source`.
    	     * @param {Function} [customizer] The function to customize merged values.
    	     * @param {Object} [stack] Tracks traversed source values and their merged
    	     *  counterparts.
    	     */function baseMerge(object,source,srcIndex,customizer,stack){if(object===source){return;}baseFor(source,function(srcValue,key){stack||(stack=new Stack());if(isObject(srcValue)){baseMergeDeep(object,source,key,srcIndex,baseMerge,customizer,stack);}else {var newValue=customizer?customizer(safeGet(object,key),srcValue,key+'',object,source,stack):undefined$1;if(newValue===undefined$1){newValue=srcValue;}assignMergeValue(object,key,newValue);}},keysIn);}/**
    	     * A specialized version of `baseMerge` for arrays and objects which performs
    	     * deep merges and tracks traversed objects enabling objects with circular
    	     * references to be merged.
    	     *
    	     * @private
    	     * @param {Object} object The destination object.
    	     * @param {Object} source The source object.
    	     * @param {string} key The key of the value to merge.
    	     * @param {number} srcIndex The index of `source`.
    	     * @param {Function} mergeFunc The function to merge values.
    	     * @param {Function} [customizer] The function to customize assigned values.
    	     * @param {Object} [stack] Tracks traversed source values and their merged
    	     *  counterparts.
    	     */function baseMergeDeep(object,source,key,srcIndex,mergeFunc,customizer,stack){var objValue=safeGet(object,key),srcValue=safeGet(source,key),stacked=stack.get(srcValue);if(stacked){assignMergeValue(object,key,stacked);return;}var newValue=customizer?customizer(objValue,srcValue,key+'',object,source,stack):undefined$1;var isCommon=newValue===undefined$1;if(isCommon){var isArr=isArray(srcValue),isBuff=!isArr&&isBuffer(srcValue),isTyped=!isArr&&!isBuff&&isTypedArray(srcValue);newValue=srcValue;if(isArr||isBuff||isTyped){if(isArray(objValue)){newValue=objValue;}else if(isArrayLikeObject(objValue)){newValue=copyArray(objValue);}else if(isBuff){isCommon=false;newValue=cloneBuffer(srcValue,true);}else if(isTyped){isCommon=false;newValue=cloneTypedArray(srcValue,true);}else {newValue=[];}}else if(isPlainObject(srcValue)||isArguments(srcValue)){newValue=objValue;if(isArguments(objValue)){newValue=toPlainObject(objValue);}else if(!isObject(objValue)||isFunction(objValue)){newValue=initCloneObject(srcValue);}}else {isCommon=false;}}if(isCommon){// Recursively merge objects and arrays (susceptible to call stack limits).
    	stack.set(srcValue,newValue);mergeFunc(newValue,srcValue,srcIndex,customizer,stack);stack['delete'](srcValue);}assignMergeValue(object,key,newValue);}/**
    	     * The base implementation of `_.nth` which doesn't coerce arguments.
    	     *
    	     * @private
    	     * @param {Array} array The array to query.
    	     * @param {number} n The index of the element to return.
    	     * @returns {*} Returns the nth element of `array`.
    	     */function baseNth(array,n){var length=array.length;if(!length){return;}n+=n<0?length:0;return isIndex(n,length)?array[n]:undefined$1;}/**
    	     * The base implementation of `_.orderBy` without param guards.
    	     *
    	     * @private
    	     * @param {Array|Object} collection The collection to iterate over.
    	     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
    	     * @param {string[]} orders The sort orders of `iteratees`.
    	     * @returns {Array} Returns the new sorted array.
    	     */function baseOrderBy(collection,iteratees,orders){if(iteratees.length){iteratees=arrayMap(iteratees,function(iteratee){if(isArray(iteratee)){return function(value){return baseGet(value,iteratee.length===1?iteratee[0]:iteratee);};}return iteratee;});}else {iteratees=[identity];}var index=-1;iteratees=arrayMap(iteratees,baseUnary(getIteratee()));var result=baseMap(collection,function(value,key,collection){var criteria=arrayMap(iteratees,function(iteratee){return iteratee(value);});return {'criteria':criteria,'index':++index,'value':value};});return baseSortBy(result,function(object,other){return compareMultiple(object,other,orders);});}/**
    	     * The base implementation of `_.pick` without support for individual
    	     * property identifiers.
    	     *
    	     * @private
    	     * @param {Object} object The source object.
    	     * @param {string[]} paths The property paths to pick.
    	     * @returns {Object} Returns the new object.
    	     */function basePick(object,paths){return basePickBy(object,paths,function(value,path){return hasIn(object,path);});}/**
    	     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
    	     *
    	     * @private
    	     * @param {Object} object The source object.
    	     * @param {string[]} paths The property paths to pick.
    	     * @param {Function} predicate The function invoked per property.
    	     * @returns {Object} Returns the new object.
    	     */function basePickBy(object,paths,predicate){var index=-1,length=paths.length,result={};while(++index<length){var path=paths[index],value=baseGet(object,path);if(predicate(value,path)){baseSet(result,castPath(path,object),value);}}return result;}/**
    	     * A specialized version of `baseProperty` which supports deep paths.
    	     *
    	     * @private
    	     * @param {Array|string} path The path of the property to get.
    	     * @returns {Function} Returns the new accessor function.
    	     */function basePropertyDeep(path){return function(object){return baseGet(object,path);};}/**
    	     * The base implementation of `_.pullAllBy` without support for iteratee
    	     * shorthands.
    	     *
    	     * @private
    	     * @param {Array} array The array to modify.
    	     * @param {Array} values The values to remove.
    	     * @param {Function} [iteratee] The iteratee invoked per element.
    	     * @param {Function} [comparator] The comparator invoked per element.
    	     * @returns {Array} Returns `array`.
    	     */function basePullAll(array,values,iteratee,comparator){var indexOf=comparator?baseIndexOfWith:baseIndexOf,index=-1,length=values.length,seen=array;if(array===values){values=copyArray(values);}if(iteratee){seen=arrayMap(array,baseUnary(iteratee));}while(++index<length){var fromIndex=0,value=values[index],computed=iteratee?iteratee(value):value;while((fromIndex=indexOf(seen,computed,fromIndex,comparator))>-1){if(seen!==array){splice.call(seen,fromIndex,1);}splice.call(array,fromIndex,1);}}return array;}/**
    	     * The base implementation of `_.pullAt` without support for individual
    	     * indexes or capturing the removed elements.
    	     *
    	     * @private
    	     * @param {Array} array The array to modify.
    	     * @param {number[]} indexes The indexes of elements to remove.
    	     * @returns {Array} Returns `array`.
    	     */function basePullAt(array,indexes){var length=array?indexes.length:0,lastIndex=length-1;while(length--){var index=indexes[length];if(length==lastIndex||index!==previous){var previous=index;if(isIndex(index)){splice.call(array,index,1);}else {baseUnset(array,index);}}}return array;}/**
    	     * The base implementation of `_.random` without support for returning
    	     * floating-point numbers.
    	     *
    	     * @private
    	     * @param {number} lower The lower bound.
    	     * @param {number} upper The upper bound.
    	     * @returns {number} Returns the random number.
    	     */function baseRandom(lower,upper){return lower+nativeFloor(nativeRandom()*(upper-lower+1));}/**
    	     * The base implementation of `_.range` and `_.rangeRight` which doesn't
    	     * coerce arguments.
    	     *
    	     * @private
    	     * @param {number} start The start of the range.
    	     * @param {number} end The end of the range.
    	     * @param {number} step The value to increment or decrement by.
    	     * @param {boolean} [fromRight] Specify iterating from right to left.
    	     * @returns {Array} Returns the range of numbers.
    	     */function baseRange(start,end,step,fromRight){var index=-1,length=nativeMax(nativeCeil((end-start)/(step||1)),0),result=Array(length);while(length--){result[fromRight?length:++index]=start;start+=step;}return result;}/**
    	     * The base implementation of `_.repeat` which doesn't coerce arguments.
    	     *
    	     * @private
    	     * @param {string} string The string to repeat.
    	     * @param {number} n The number of times to repeat the string.
    	     * @returns {string} Returns the repeated string.
    	     */function baseRepeat(string,n){var result='';if(!string||n<1||n>MAX_SAFE_INTEGER){return result;}// Leverage the exponentiation by squaring algorithm for a faster repeat.
    	// See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
    	do{if(n%2){result+=string;}n=nativeFloor(n/2);if(n){string+=string;}}while(n);return result;}/**
    	     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
    	     *
    	     * @private
    	     * @param {Function} func The function to apply a rest parameter to.
    	     * @param {number} [start=func.length-1] The start position of the rest parameter.
    	     * @returns {Function} Returns the new function.
    	     */function baseRest(func,start){return setToString(overRest(func,start,identity),func+'');}/**
    	     * The base implementation of `_.sample`.
    	     *
    	     * @private
    	     * @param {Array|Object} collection The collection to sample.
    	     * @returns {*} Returns the random element.
    	     */function baseSample(collection){return arraySample(values(collection));}/**
    	     * The base implementation of `_.sampleSize` without param guards.
    	     *
    	     * @private
    	     * @param {Array|Object} collection The collection to sample.
    	     * @param {number} n The number of elements to sample.
    	     * @returns {Array} Returns the random elements.
    	     */function baseSampleSize(collection,n){var array=values(collection);return shuffleSelf(array,baseClamp(n,0,array.length));}/**
    	     * The base implementation of `_.set`.
    	     *
    	     * @private
    	     * @param {Object} object The object to modify.
    	     * @param {Array|string} path The path of the property to set.
    	     * @param {*} value The value to set.
    	     * @param {Function} [customizer] The function to customize path creation.
    	     * @returns {Object} Returns `object`.
    	     */function baseSet(object,path,value,customizer){if(!isObject(object)){return object;}path=castPath(path,object);var index=-1,length=path.length,lastIndex=length-1,nested=object;while(nested!=null&&++index<length){var key=toKey(path[index]),newValue=value;if(key==='__proto__'||key==='constructor'||key==='prototype'){return object;}if(index!=lastIndex){var objValue=nested[key];newValue=customizer?customizer(objValue,key,nested):undefined$1;if(newValue===undefined$1){newValue=isObject(objValue)?objValue:isIndex(path[index+1])?[]:{};}}assignValue(nested,key,newValue);nested=nested[key];}return object;}/**
    	     * The base implementation of `setData` without support for hot loop shorting.
    	     *
    	     * @private
    	     * @param {Function} func The function to associate metadata with.
    	     * @param {*} data The metadata.
    	     * @returns {Function} Returns `func`.
    	     */var baseSetData=!metaMap?identity:function(func,data){metaMap.set(func,data);return func;};/**
    	     * The base implementation of `setToString` without support for hot loop shorting.
    	     *
    	     * @private
    	     * @param {Function} func The function to modify.
    	     * @param {Function} string The `toString` result.
    	     * @returns {Function} Returns `func`.
    	     */var baseSetToString=!defineProperty?identity:function(func,string){return defineProperty(func,'toString',{'configurable':true,'enumerable':false,'value':constant(string),'writable':true});};/**
    	     * The base implementation of `_.shuffle`.
    	     *
    	     * @private
    	     * @param {Array|Object} collection The collection to shuffle.
    	     * @returns {Array} Returns the new shuffled array.
    	     */function baseShuffle(collection){return shuffleSelf(values(collection));}/**
    	     * The base implementation of `_.slice` without an iteratee call guard.
    	     *
    	     * @private
    	     * @param {Array} array The array to slice.
    	     * @param {number} [start=0] The start position.
    	     * @param {number} [end=array.length] The end position.
    	     * @returns {Array} Returns the slice of `array`.
    	     */function baseSlice(array,start,end){var index=-1,length=array.length;if(start<0){start=-start>length?0:length+start;}end=end>length?length:end;if(end<0){end+=length;}length=start>end?0:end-start>>>0;start>>>=0;var result=Array(length);while(++index<length){result[index]=array[index+start];}return result;}/**
    	     * The base implementation of `_.some` without support for iteratee shorthands.
    	     *
    	     * @private
    	     * @param {Array|Object} collection The collection to iterate over.
    	     * @param {Function} predicate The function invoked per iteration.
    	     * @returns {boolean} Returns `true` if any element passes the predicate check,
    	     *  else `false`.
    	     */function baseSome(collection,predicate){var result;baseEach(collection,function(value,index,collection){result=predicate(value,index,collection);return !result;});return !!result;}/**
    	     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
    	     * performs a binary search of `array` to determine the index at which `value`
    	     * should be inserted into `array` in order to maintain its sort order.
    	     *
    	     * @private
    	     * @param {Array} array The sorted array to inspect.
    	     * @param {*} value The value to evaluate.
    	     * @param {boolean} [retHighest] Specify returning the highest qualified index.
    	     * @returns {number} Returns the index at which `value` should be inserted
    	     *  into `array`.
    	     */function baseSortedIndex(array,value,retHighest){var low=0,high=array==null?low:array.length;if(typeof value=='number'&&value===value&&high<=HALF_MAX_ARRAY_LENGTH){while(low<high){var mid=low+high>>>1,computed=array[mid];if(computed!==null&&!isSymbol(computed)&&(retHighest?computed<=value:computed<value)){low=mid+1;}else {high=mid;}}return high;}return baseSortedIndexBy(array,value,identity,retHighest);}/**
    	     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
    	     * which invokes `iteratee` for `value` and each element of `array` to compute
    	     * their sort ranking. The iteratee is invoked with one argument; (value).
    	     *
    	     * @private
    	     * @param {Array} array The sorted array to inspect.
    	     * @param {*} value The value to evaluate.
    	     * @param {Function} iteratee The iteratee invoked per element.
    	     * @param {boolean} [retHighest] Specify returning the highest qualified index.
    	     * @returns {number} Returns the index at which `value` should be inserted
    	     *  into `array`.
    	     */function baseSortedIndexBy(array,value,iteratee,retHighest){var low=0,high=array==null?0:array.length;if(high===0){return 0;}value=iteratee(value);var valIsNaN=value!==value,valIsNull=value===null,valIsSymbol=isSymbol(value),valIsUndefined=value===undefined$1;while(low<high){var mid=nativeFloor((low+high)/2),computed=iteratee(array[mid]),othIsDefined=computed!==undefined$1,othIsNull=computed===null,othIsReflexive=computed===computed,othIsSymbol=isSymbol(computed);if(valIsNaN){var setLow=retHighest||othIsReflexive;}else if(valIsUndefined){setLow=othIsReflexive&&(retHighest||othIsDefined);}else if(valIsNull){setLow=othIsReflexive&&othIsDefined&&(retHighest||!othIsNull);}else if(valIsSymbol){setLow=othIsReflexive&&othIsDefined&&!othIsNull&&(retHighest||!othIsSymbol);}else if(othIsNull||othIsSymbol){setLow=false;}else {setLow=retHighest?computed<=value:computed<value;}if(setLow){low=mid+1;}else {high=mid;}}return nativeMin(high,MAX_ARRAY_INDEX);}/**
    	     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
    	     * support for iteratee shorthands.
    	     *
    	     * @private
    	     * @param {Array} array The array to inspect.
    	     * @param {Function} [iteratee] The iteratee invoked per element.
    	     * @returns {Array} Returns the new duplicate free array.
    	     */function baseSortedUniq(array,iteratee){var index=-1,length=array.length,resIndex=0,result=[];while(++index<length){var value=array[index],computed=iteratee?iteratee(value):value;if(!index||!eq(computed,seen)){var seen=computed;result[resIndex++]=value===0?0:value;}}return result;}/**
    	     * The base implementation of `_.toNumber` which doesn't ensure correct
    	     * conversions of binary, hexadecimal, or octal string values.
    	     *
    	     * @private
    	     * @param {*} value The value to process.
    	     * @returns {number} Returns the number.
    	     */function baseToNumber(value){if(typeof value=='number'){return value;}if(isSymbol(value)){return NAN;}return +value;}/**
    	     * The base implementation of `_.toString` which doesn't convert nullish
    	     * values to empty strings.
    	     *
    	     * @private
    	     * @param {*} value The value to process.
    	     * @returns {string} Returns the string.
    	     */function baseToString(value){// Exit early for strings to avoid a performance hit in some environments.
    	if(typeof value=='string'){return value;}if(isArray(value)){// Recursively convert values (susceptible to call stack limits).
    	return arrayMap(value,baseToString)+'';}if(isSymbol(value)){return symbolToString?symbolToString.call(value):'';}var result=value+'';return result=='0'&&1/value==-INFINITY?'-0':result;}/**
    	     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
    	     *
    	     * @private
    	     * @param {Array} array The array to inspect.
    	     * @param {Function} [iteratee] The iteratee invoked per element.
    	     * @param {Function} [comparator] The comparator invoked per element.
    	     * @returns {Array} Returns the new duplicate free array.
    	     */function baseUniq(array,iteratee,comparator){var index=-1,includes=arrayIncludes,length=array.length,isCommon=true,result=[],seen=result;if(comparator){isCommon=false;includes=arrayIncludesWith;}else if(length>=LARGE_ARRAY_SIZE){var set=iteratee?null:createSet(array);if(set){return setToArray(set);}isCommon=false;includes=cacheHas;seen=new SetCache();}else {seen=iteratee?[]:result;}outer:while(++index<length){var value=array[index],computed=iteratee?iteratee(value):value;value=comparator||value!==0?value:0;if(isCommon&&computed===computed){var seenIndex=seen.length;while(seenIndex--){if(seen[seenIndex]===computed){continue outer;}}if(iteratee){seen.push(computed);}result.push(value);}else if(!includes(seen,computed,comparator)){if(seen!==result){seen.push(computed);}result.push(value);}}return result;}/**
    	     * The base implementation of `_.unset`.
    	     *
    	     * @private
    	     * @param {Object} object The object to modify.
    	     * @param {Array|string} path The property path to unset.
    	     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
    	     */function baseUnset(object,path){path=castPath(path,object);object=parent(object,path);return object==null||delete object[toKey(last(path))];}/**
    	     * The base implementation of `_.update`.
    	     *
    	     * @private
    	     * @param {Object} object The object to modify.
    	     * @param {Array|string} path The path of the property to update.
    	     * @param {Function} updater The function to produce the updated value.
    	     * @param {Function} [customizer] The function to customize path creation.
    	     * @returns {Object} Returns `object`.
    	     */function baseUpdate(object,path,updater,customizer){return baseSet(object,path,updater(baseGet(object,path)),customizer);}/**
    	     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
    	     * without support for iteratee shorthands.
    	     *
    	     * @private
    	     * @param {Array} array The array to query.
    	     * @param {Function} predicate The function invoked per iteration.
    	     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
    	     * @param {boolean} [fromRight] Specify iterating from right to left.
    	     * @returns {Array} Returns the slice of `array`.
    	     */function baseWhile(array,predicate,isDrop,fromRight){var length=array.length,index=fromRight?length:-1;while((fromRight?index--:++index<length)&&predicate(array[index],index,array)){}return isDrop?baseSlice(array,fromRight?0:index,fromRight?index+1:length):baseSlice(array,fromRight?index+1:0,fromRight?length:index);}/**
    	     * The base implementation of `wrapperValue` which returns the result of
    	     * performing a sequence of actions on the unwrapped `value`, where each
    	     * successive action is supplied the return value of the previous.
    	     *
    	     * @private
    	     * @param {*} value The unwrapped value.
    	     * @param {Array} actions Actions to perform to resolve the unwrapped value.
    	     * @returns {*} Returns the resolved value.
    	     */function baseWrapperValue(value,actions){var result=value;if(result instanceof LazyWrapper){result=result.value();}return arrayReduce(actions,function(result,action){return action.func.apply(action.thisArg,arrayPush([result],action.args));},result);}/**
    	     * The base implementation of methods like `_.xor`, without support for
    	     * iteratee shorthands, that accepts an array of arrays to inspect.
    	     *
    	     * @private
    	     * @param {Array} arrays The arrays to inspect.
    	     * @param {Function} [iteratee] The iteratee invoked per element.
    	     * @param {Function} [comparator] The comparator invoked per element.
    	     * @returns {Array} Returns the new array of values.
    	     */function baseXor(arrays,iteratee,comparator){var length=arrays.length;if(length<2){return length?baseUniq(arrays[0]):[];}var index=-1,result=Array(length);while(++index<length){var array=arrays[index],othIndex=-1;while(++othIndex<length){if(othIndex!=index){result[index]=baseDifference(result[index]||array,arrays[othIndex],iteratee,comparator);}}}return baseUniq(baseFlatten(result,1),iteratee,comparator);}/**
    	     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
    	     *
    	     * @private
    	     * @param {Array} props The property identifiers.
    	     * @param {Array} values The property values.
    	     * @param {Function} assignFunc The function to assign values.
    	     * @returns {Object} Returns the new object.
    	     */function baseZipObject(props,values,assignFunc){var index=-1,length=props.length,valsLength=values.length,result={};while(++index<length){var value=index<valsLength?values[index]:undefined$1;assignFunc(result,props[index],value);}return result;}/**
    	     * Casts `value` to an empty array if it's not an array like object.
    	     *
    	     * @private
    	     * @param {*} value The value to inspect.
    	     * @returns {Array|Object} Returns the cast array-like object.
    	     */function castArrayLikeObject(value){return isArrayLikeObject(value)?value:[];}/**
    	     * Casts `value` to `identity` if it's not a function.
    	     *
    	     * @private
    	     * @param {*} value The value to inspect.
    	     * @returns {Function} Returns cast function.
    	     */function castFunction(value){return typeof value=='function'?value:identity;}/**
    	     * Casts `value` to a path array if it's not one.
    	     *
    	     * @private
    	     * @param {*} value The value to inspect.
    	     * @param {Object} [object] The object to query keys on.
    	     * @returns {Array} Returns the cast property path array.
    	     */function castPath(value,object){if(isArray(value)){return value;}return isKey(value,object)?[value]:stringToPath(toString(value));}/**
    	     * A `baseRest` alias which can be replaced with `identity` by module
    	     * replacement plugins.
    	     *
    	     * @private
    	     * @type {Function}
    	     * @param {Function} func The function to apply a rest parameter to.
    	     * @returns {Function} Returns the new function.
    	     */var castRest=baseRest;/**
    	     * Casts `array` to a slice if it's needed.
    	     *
    	     * @private
    	     * @param {Array} array The array to inspect.
    	     * @param {number} start The start position.
    	     * @param {number} [end=array.length] The end position.
    	     * @returns {Array} Returns the cast slice.
    	     */function castSlice(array,start,end){var length=array.length;end=end===undefined$1?length:end;return !start&&end>=length?array:baseSlice(array,start,end);}/**
    	     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
    	     *
    	     * @private
    	     * @param {number|Object} id The timer id or timeout object of the timer to clear.
    	     */var clearTimeout=ctxClearTimeout||function(id){return root.clearTimeout(id);};/**
    	     * Creates a clone of  `buffer`.
    	     *
    	     * @private
    	     * @param {Buffer} buffer The buffer to clone.
    	     * @param {boolean} [isDeep] Specify a deep clone.
    	     * @returns {Buffer} Returns the cloned buffer.
    	     */function cloneBuffer(buffer,isDeep){if(isDeep){return buffer.slice();}var length=buffer.length,result=allocUnsafe?allocUnsafe(length):new buffer.constructor(length);buffer.copy(result);return result;}/**
    	     * Creates a clone of `arrayBuffer`.
    	     *
    	     * @private
    	     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
    	     * @returns {ArrayBuffer} Returns the cloned array buffer.
    	     */function cloneArrayBuffer(arrayBuffer){var result=new arrayBuffer.constructor(arrayBuffer.byteLength);new Uint8Array(result).set(new Uint8Array(arrayBuffer));return result;}/**
    	     * Creates a clone of `dataView`.
    	     *
    	     * @private
    	     * @param {Object} dataView The data view to clone.
    	     * @param {boolean} [isDeep] Specify a deep clone.
    	     * @returns {Object} Returns the cloned data view.
    	     */function cloneDataView(dataView,isDeep){var buffer=isDeep?cloneArrayBuffer(dataView.buffer):dataView.buffer;return new dataView.constructor(buffer,dataView.byteOffset,dataView.byteLength);}/**
    	     * Creates a clone of `regexp`.
    	     *
    	     * @private
    	     * @param {Object} regexp The regexp to clone.
    	     * @returns {Object} Returns the cloned regexp.
    	     */function cloneRegExp(regexp){var result=new regexp.constructor(regexp.source,reFlags.exec(regexp));result.lastIndex=regexp.lastIndex;return result;}/**
    	     * Creates a clone of the `symbol` object.
    	     *
    	     * @private
    	     * @param {Object} symbol The symbol object to clone.
    	     * @returns {Object} Returns the cloned symbol object.
    	     */function cloneSymbol(symbol){return symbolValueOf?Object(symbolValueOf.call(symbol)):{};}/**
    	     * Creates a clone of `typedArray`.
    	     *
    	     * @private
    	     * @param {Object} typedArray The typed array to clone.
    	     * @param {boolean} [isDeep] Specify a deep clone.
    	     * @returns {Object} Returns the cloned typed array.
    	     */function cloneTypedArray(typedArray,isDeep){var buffer=isDeep?cloneArrayBuffer(typedArray.buffer):typedArray.buffer;return new typedArray.constructor(buffer,typedArray.byteOffset,typedArray.length);}/**
    	     * Compares values to sort them in ascending order.
    	     *
    	     * @private
    	     * @param {*} value The value to compare.
    	     * @param {*} other The other value to compare.
    	     * @returns {number} Returns the sort order indicator for `value`.
    	     */function compareAscending(value,other){if(value!==other){var valIsDefined=value!==undefined$1,valIsNull=value===null,valIsReflexive=value===value,valIsSymbol=isSymbol(value);var othIsDefined=other!==undefined$1,othIsNull=other===null,othIsReflexive=other===other,othIsSymbol=isSymbol(other);if(!othIsNull&&!othIsSymbol&&!valIsSymbol&&value>other||valIsSymbol&&othIsDefined&&othIsReflexive&&!othIsNull&&!othIsSymbol||valIsNull&&othIsDefined&&othIsReflexive||!valIsDefined&&othIsReflexive||!valIsReflexive){return 1;}if(!valIsNull&&!valIsSymbol&&!othIsSymbol&&value<other||othIsSymbol&&valIsDefined&&valIsReflexive&&!valIsNull&&!valIsSymbol||othIsNull&&valIsDefined&&valIsReflexive||!othIsDefined&&valIsReflexive||!othIsReflexive){return -1;}}return 0;}/**
    	     * Used by `_.orderBy` to compare multiple properties of a value to another
    	     * and stable sort them.
    	     *
    	     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
    	     * specify an order of "desc" for descending or "asc" for ascending sort order
    	     * of corresponding values.
    	     *
    	     * @private
    	     * @param {Object} object The object to compare.
    	     * @param {Object} other The other object to compare.
    	     * @param {boolean[]|string[]} orders The order to sort by for each property.
    	     * @returns {number} Returns the sort order indicator for `object`.
    	     */function compareMultiple(object,other,orders){var index=-1,objCriteria=object.criteria,othCriteria=other.criteria,length=objCriteria.length,ordersLength=orders.length;while(++index<length){var result=compareAscending(objCriteria[index],othCriteria[index]);if(result){if(index>=ordersLength){return result;}var order=orders[index];return result*(order=='desc'?-1:1);}}// Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
    	// that causes it, under certain circumstances, to provide the same value for
    	// `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
    	// for more details.
    	//
    	// This also ensures a stable sort in V8 and other engines.
    	// See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
    	return object.index-other.index;}/**
    	     * Creates an array that is the composition of partially applied arguments,
    	     * placeholders, and provided arguments into a single array of arguments.
    	     *
    	     * @private
    	     * @param {Array} args The provided arguments.
    	     * @param {Array} partials The arguments to prepend to those provided.
    	     * @param {Array} holders The `partials` placeholder indexes.
    	     * @params {boolean} [isCurried] Specify composing for a curried function.
    	     * @returns {Array} Returns the new array of composed arguments.
    	     */function composeArgs(args,partials,holders,isCurried){var argsIndex=-1,argsLength=args.length,holdersLength=holders.length,leftIndex=-1,leftLength=partials.length,rangeLength=nativeMax(argsLength-holdersLength,0),result=Array(leftLength+rangeLength),isUncurried=!isCurried;while(++leftIndex<leftLength){result[leftIndex]=partials[leftIndex];}while(++argsIndex<holdersLength){if(isUncurried||argsIndex<argsLength){result[holders[argsIndex]]=args[argsIndex];}}while(rangeLength--){result[leftIndex++]=args[argsIndex++];}return result;}/**
    	     * This function is like `composeArgs` except that the arguments composition
    	     * is tailored for `_.partialRight`.
    	     *
    	     * @private
    	     * @param {Array} args The provided arguments.
    	     * @param {Array} partials The arguments to append to those provided.
    	     * @param {Array} holders The `partials` placeholder indexes.
    	     * @params {boolean} [isCurried] Specify composing for a curried function.
    	     * @returns {Array} Returns the new array of composed arguments.
    	     */function composeArgsRight(args,partials,holders,isCurried){var argsIndex=-1,argsLength=args.length,holdersIndex=-1,holdersLength=holders.length,rightIndex=-1,rightLength=partials.length,rangeLength=nativeMax(argsLength-holdersLength,0),result=Array(rangeLength+rightLength),isUncurried=!isCurried;while(++argsIndex<rangeLength){result[argsIndex]=args[argsIndex];}var offset=argsIndex;while(++rightIndex<rightLength){result[offset+rightIndex]=partials[rightIndex];}while(++holdersIndex<holdersLength){if(isUncurried||argsIndex<argsLength){result[offset+holders[holdersIndex]]=args[argsIndex++];}}return result;}/**
    	     * Copies the values of `source` to `array`.
    	     *
    	     * @private
    	     * @param {Array} source The array to copy values from.
    	     * @param {Array} [array=[]] The array to copy values to.
    	     * @returns {Array} Returns `array`.
    	     */function copyArray(source,array){var index=-1,length=source.length;array||(array=Array(length));while(++index<length){array[index]=source[index];}return array;}/**
    	     * Copies properties of `source` to `object`.
    	     *
    	     * @private
    	     * @param {Object} source The object to copy properties from.
    	     * @param {Array} props The property identifiers to copy.
    	     * @param {Object} [object={}] The object to copy properties to.
    	     * @param {Function} [customizer] The function to customize copied values.
    	     * @returns {Object} Returns `object`.
    	     */function copyObject(source,props,object,customizer){var isNew=!object;object||(object={});var index=-1,length=props.length;while(++index<length){var key=props[index];var newValue=customizer?customizer(object[key],source[key],key,object,source):undefined$1;if(newValue===undefined$1){newValue=source[key];}if(isNew){baseAssignValue(object,key,newValue);}else {assignValue(object,key,newValue);}}return object;}/**
    	     * Copies own symbols of `source` to `object`.
    	     *
    	     * @private
    	     * @param {Object} source The object to copy symbols from.
    	     * @param {Object} [object={}] The object to copy symbols to.
    	     * @returns {Object} Returns `object`.
    	     */function copySymbols(source,object){return copyObject(source,getSymbols(source),object);}/**
    	     * Copies own and inherited symbols of `source` to `object`.
    	     *
    	     * @private
    	     * @param {Object} source The object to copy symbols from.
    	     * @param {Object} [object={}] The object to copy symbols to.
    	     * @returns {Object} Returns `object`.
    	     */function copySymbolsIn(source,object){return copyObject(source,getSymbolsIn(source),object);}/**
    	     * Creates a function like `_.groupBy`.
    	     *
    	     * @private
    	     * @param {Function} setter The function to set accumulator values.
    	     * @param {Function} [initializer] The accumulator object initializer.
    	     * @returns {Function} Returns the new aggregator function.
    	     */function createAggregator(setter,initializer){return function(collection,iteratee){var func=isArray(collection)?arrayAggregator:baseAggregator,accumulator=initializer?initializer():{};return func(collection,setter,getIteratee(iteratee,2),accumulator);};}/**
    	     * Creates a function like `_.assign`.
    	     *
    	     * @private
    	     * @param {Function} assigner The function to assign values.
    	     * @returns {Function} Returns the new assigner function.
    	     */function createAssigner(assigner){return baseRest(function(object,sources){var index=-1,length=sources.length,customizer=length>1?sources[length-1]:undefined$1,guard=length>2?sources[2]:undefined$1;customizer=assigner.length>3&&typeof customizer=='function'?(length--,customizer):undefined$1;if(guard&&isIterateeCall(sources[0],sources[1],guard)){customizer=length<3?undefined$1:customizer;length=1;}object=Object(object);while(++index<length){var source=sources[index];if(source){assigner(object,source,index,customizer);}}return object;});}/**
    	     * Creates a `baseEach` or `baseEachRight` function.
    	     *
    	     * @private
    	     * @param {Function} eachFunc The function to iterate over a collection.
    	     * @param {boolean} [fromRight] Specify iterating from right to left.
    	     * @returns {Function} Returns the new base function.
    	     */function createBaseEach(eachFunc,fromRight){return function(collection,iteratee){if(collection==null){return collection;}if(!isArrayLike(collection)){return eachFunc(collection,iteratee);}var length=collection.length,index=fromRight?length:-1,iterable=Object(collection);while(fromRight?index--:++index<length){if(iteratee(iterable[index],index,iterable)===false){break;}}return collection;};}/**
    	     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
    	     *
    	     * @private
    	     * @param {boolean} [fromRight] Specify iterating from right to left.
    	     * @returns {Function} Returns the new base function.
    	     */function createBaseFor(fromRight){return function(object,iteratee,keysFunc){var index=-1,iterable=Object(object),props=keysFunc(object),length=props.length;while(length--){var key=props[fromRight?length:++index];if(iteratee(iterable[key],key,iterable)===false){break;}}return object;};}/**
    	     * Creates a function that wraps `func` to invoke it with the optional `this`
    	     * binding of `thisArg`.
    	     *
    	     * @private
    	     * @param {Function} func The function to wrap.
    	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
    	     * @param {*} [thisArg] The `this` binding of `func`.
    	     * @returns {Function} Returns the new wrapped function.
    	     */function createBind(func,bitmask,thisArg){var isBind=bitmask&WRAP_BIND_FLAG,Ctor=createCtor(func);function wrapper(){var fn=this&&this!==root&&this instanceof wrapper?Ctor:func;return fn.apply(isBind?thisArg:this,arguments);}return wrapper;}/**
    	     * Creates a function like `_.lowerFirst`.
    	     *
    	     * @private
    	     * @param {string} methodName The name of the `String` case method to use.
    	     * @returns {Function} Returns the new case function.
    	     */function createCaseFirst(methodName){return function(string){string=toString(string);var strSymbols=hasUnicode(string)?stringToArray(string):undefined$1;var chr=strSymbols?strSymbols[0]:string.charAt(0);var trailing=strSymbols?castSlice(strSymbols,1).join(''):string.slice(1);return chr[methodName]()+trailing;};}/**
    	     * Creates a function like `_.camelCase`.
    	     *
    	     * @private
    	     * @param {Function} callback The function to combine each word.
    	     * @returns {Function} Returns the new compounder function.
    	     */function createCompounder(callback){return function(string){return arrayReduce(words(deburr(string).replace(reApos,'')),callback,'');};}/**
    	     * Creates a function that produces an instance of `Ctor` regardless of
    	     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
    	     *
    	     * @private
    	     * @param {Function} Ctor The constructor to wrap.
    	     * @returns {Function} Returns the new wrapped function.
    	     */function createCtor(Ctor){return function(){// Use a `switch` statement to work with class constructors. See
    	// http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
    	// for more details.
    	var args=arguments;switch(args.length){case 0:return new Ctor();case 1:return new Ctor(args[0]);case 2:return new Ctor(args[0],args[1]);case 3:return new Ctor(args[0],args[1],args[2]);case 4:return new Ctor(args[0],args[1],args[2],args[3]);case 5:return new Ctor(args[0],args[1],args[2],args[3],args[4]);case 6:return new Ctor(args[0],args[1],args[2],args[3],args[4],args[5]);case 7:return new Ctor(args[0],args[1],args[2],args[3],args[4],args[5],args[6]);}var thisBinding=baseCreate(Ctor.prototype),result=Ctor.apply(thisBinding,args);// Mimic the constructor's `return` behavior.
    	// See https://es5.github.io/#x13.2.2 for more details.
    	return isObject(result)?result:thisBinding;};}/**
    	     * Creates a function that wraps `func` to enable currying.
    	     *
    	     * @private
    	     * @param {Function} func The function to wrap.
    	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
    	     * @param {number} arity The arity of `func`.
    	     * @returns {Function} Returns the new wrapped function.
    	     */function createCurry(func,bitmask,arity){var Ctor=createCtor(func);function wrapper(){var length=arguments.length,args=Array(length),index=length,placeholder=getHolder(wrapper);while(index--){args[index]=arguments[index];}var holders=length<3&&args[0]!==placeholder&&args[length-1]!==placeholder?[]:replaceHolders(args,placeholder);length-=holders.length;if(length<arity){return createRecurry(func,bitmask,createHybrid,wrapper.placeholder,undefined$1,args,holders,undefined$1,undefined$1,arity-length);}var fn=this&&this!==root&&this instanceof wrapper?Ctor:func;return apply(fn,this,args);}return wrapper;}/**
    	     * Creates a `_.find` or `_.findLast` function.
    	     *
    	     * @private
    	     * @param {Function} findIndexFunc The function to find the collection index.
    	     * @returns {Function} Returns the new find function.
    	     */function createFind(findIndexFunc){return function(collection,predicate,fromIndex){var iterable=Object(collection);if(!isArrayLike(collection)){var iteratee=getIteratee(predicate,3);collection=keys(collection);predicate=function(key){return iteratee(iterable[key],key,iterable);};}var index=findIndexFunc(collection,predicate,fromIndex);return index>-1?iterable[iteratee?collection[index]:index]:undefined$1;};}/**
    	     * Creates a `_.flow` or `_.flowRight` function.
    	     *
    	     * @private
    	     * @param {boolean} [fromRight] Specify iterating from right to left.
    	     * @returns {Function} Returns the new flow function.
    	     */function createFlow(fromRight){return flatRest(function(funcs){var length=funcs.length,index=length,prereq=LodashWrapper.prototype.thru;if(fromRight){funcs.reverse();}while(index--){var func=funcs[index];if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}if(prereq&&!wrapper&&getFuncName(func)=='wrapper'){var wrapper=new LodashWrapper([],true);}}index=wrapper?index:length;while(++index<length){func=funcs[index];var funcName=getFuncName(func),data=funcName=='wrapper'?getData(func):undefined$1;if(data&&isLaziable(data[0])&&data[1]==(WRAP_ARY_FLAG|WRAP_CURRY_FLAG|WRAP_PARTIAL_FLAG|WRAP_REARG_FLAG)&&!data[4].length&&data[9]==1){wrapper=wrapper[getFuncName(data[0])].apply(wrapper,data[3]);}else {wrapper=func.length==1&&isLaziable(func)?wrapper[funcName]():wrapper.thru(func);}}return function(){var args=arguments,value=args[0];if(wrapper&&args.length==1&&isArray(value)){return wrapper.plant(value).value();}var index=0,result=length?funcs[index].apply(this,args):value;while(++index<length){result=funcs[index].call(this,result);}return result;};});}/**
    	     * Creates a function that wraps `func` to invoke it with optional `this`
    	     * binding of `thisArg`, partial application, and currying.
    	     *
    	     * @private
    	     * @param {Function|string} func The function or method name to wrap.
    	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
    	     * @param {*} [thisArg] The `this` binding of `func`.
    	     * @param {Array} [partials] The arguments to prepend to those provided to
    	     *  the new function.
    	     * @param {Array} [holders] The `partials` placeholder indexes.
    	     * @param {Array} [partialsRight] The arguments to append to those provided
    	     *  to the new function.
    	     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
    	     * @param {Array} [argPos] The argument positions of the new function.
    	     * @param {number} [ary] The arity cap of `func`.
    	     * @param {number} [arity] The arity of `func`.
    	     * @returns {Function} Returns the new wrapped function.
    	     */function createHybrid(func,bitmask,thisArg,partials,holders,partialsRight,holdersRight,argPos,ary,arity){var isAry=bitmask&WRAP_ARY_FLAG,isBind=bitmask&WRAP_BIND_FLAG,isBindKey=bitmask&WRAP_BIND_KEY_FLAG,isCurried=bitmask&(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG),isFlip=bitmask&WRAP_FLIP_FLAG,Ctor=isBindKey?undefined$1:createCtor(func);function wrapper(){var length=arguments.length,args=Array(length),index=length;while(index--){args[index]=arguments[index];}if(isCurried){var placeholder=getHolder(wrapper),holdersCount=countHolders(args,placeholder);}if(partials){args=composeArgs(args,partials,holders,isCurried);}if(partialsRight){args=composeArgsRight(args,partialsRight,holdersRight,isCurried);}length-=holdersCount;if(isCurried&&length<arity){var newHolders=replaceHolders(args,placeholder);return createRecurry(func,bitmask,createHybrid,wrapper.placeholder,thisArg,args,newHolders,argPos,ary,arity-length);}var thisBinding=isBind?thisArg:this,fn=isBindKey?thisBinding[func]:func;length=args.length;if(argPos){args=reorder(args,argPos);}else if(isFlip&&length>1){args.reverse();}if(isAry&&ary<length){args.length=ary;}if(this&&this!==root&&this instanceof wrapper){fn=Ctor||createCtor(fn);}return fn.apply(thisBinding,args);}return wrapper;}/**
    	     * Creates a function like `_.invertBy`.
    	     *
    	     * @private
    	     * @param {Function} setter The function to set accumulator values.
    	     * @param {Function} toIteratee The function to resolve iteratees.
    	     * @returns {Function} Returns the new inverter function.
    	     */function createInverter(setter,toIteratee){return function(object,iteratee){return baseInverter(object,setter,toIteratee(iteratee),{});};}/**
    	     * Creates a function that performs a mathematical operation on two values.
    	     *
    	     * @private
    	     * @param {Function} operator The function to perform the operation.
    	     * @param {number} [defaultValue] The value used for `undefined` arguments.
    	     * @returns {Function} Returns the new mathematical operation function.
    	     */function createMathOperation(operator,defaultValue){return function(value,other){var result;if(value===undefined$1&&other===undefined$1){return defaultValue;}if(value!==undefined$1){result=value;}if(other!==undefined$1){if(result===undefined$1){return other;}if(typeof value=='string'||typeof other=='string'){value=baseToString(value);other=baseToString(other);}else {value=baseToNumber(value);other=baseToNumber(other);}result=operator(value,other);}return result;};}/**
    	     * Creates a function like `_.over`.
    	     *
    	     * @private
    	     * @param {Function} arrayFunc The function to iterate over iteratees.
    	     * @returns {Function} Returns the new over function.
    	     */function createOver(arrayFunc){return flatRest(function(iteratees){iteratees=arrayMap(iteratees,baseUnary(getIteratee()));return baseRest(function(args){var thisArg=this;return arrayFunc(iteratees,function(iteratee){return apply(iteratee,thisArg,args);});});});}/**
    	     * Creates the padding for `string` based on `length`. The `chars` string
    	     * is truncated if the number of characters exceeds `length`.
    	     *
    	     * @private
    	     * @param {number} length The padding length.
    	     * @param {string} [chars=' '] The string used as padding.
    	     * @returns {string} Returns the padding for `string`.
    	     */function createPadding(length,chars){chars=chars===undefined$1?' ':baseToString(chars);var charsLength=chars.length;if(charsLength<2){return charsLength?baseRepeat(chars,length):chars;}var result=baseRepeat(chars,nativeCeil(length/stringSize(chars)));return hasUnicode(chars)?castSlice(stringToArray(result),0,length).join(''):result.slice(0,length);}/**
    	     * Creates a function that wraps `func` to invoke it with the `this` binding
    	     * of `thisArg` and `partials` prepended to the arguments it receives.
    	     *
    	     * @private
    	     * @param {Function} func The function to wrap.
    	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
    	     * @param {*} thisArg The `this` binding of `func`.
    	     * @param {Array} partials The arguments to prepend to those provided to
    	     *  the new function.
    	     * @returns {Function} Returns the new wrapped function.
    	     */function createPartial(func,bitmask,thisArg,partials){var isBind=bitmask&WRAP_BIND_FLAG,Ctor=createCtor(func);function wrapper(){var argsIndex=-1,argsLength=arguments.length,leftIndex=-1,leftLength=partials.length,args=Array(leftLength+argsLength),fn=this&&this!==root&&this instanceof wrapper?Ctor:func;while(++leftIndex<leftLength){args[leftIndex]=partials[leftIndex];}while(argsLength--){args[leftIndex++]=arguments[++argsIndex];}return apply(fn,isBind?thisArg:this,args);}return wrapper;}/**
    	     * Creates a `_.range` or `_.rangeRight` function.
    	     *
    	     * @private
    	     * @param {boolean} [fromRight] Specify iterating from right to left.
    	     * @returns {Function} Returns the new range function.
    	     */function createRange(fromRight){return function(start,end,step){if(step&&typeof step!='number'&&isIterateeCall(start,end,step)){end=step=undefined$1;}// Ensure the sign of `-0` is preserved.
    	start=toFinite(start);if(end===undefined$1){end=start;start=0;}else {end=toFinite(end);}step=step===undefined$1?start<end?1:-1:toFinite(step);return baseRange(start,end,step,fromRight);};}/**
    	     * Creates a function that performs a relational operation on two values.
    	     *
    	     * @private
    	     * @param {Function} operator The function to perform the operation.
    	     * @returns {Function} Returns the new relational operation function.
    	     */function createRelationalOperation(operator){return function(value,other){if(!(typeof value=='string'&&typeof other=='string')){value=toNumber(value);other=toNumber(other);}return operator(value,other);};}/**
    	     * Creates a function that wraps `func` to continue currying.
    	     *
    	     * @private
    	     * @param {Function} func The function to wrap.
    	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
    	     * @param {Function} wrapFunc The function to create the `func` wrapper.
    	     * @param {*} placeholder The placeholder value.
    	     * @param {*} [thisArg] The `this` binding of `func`.
    	     * @param {Array} [partials] The arguments to prepend to those provided to
    	     *  the new function.
    	     * @param {Array} [holders] The `partials` placeholder indexes.
    	     * @param {Array} [argPos] The argument positions of the new function.
    	     * @param {number} [ary] The arity cap of `func`.
    	     * @param {number} [arity] The arity of `func`.
    	     * @returns {Function} Returns the new wrapped function.
    	     */function createRecurry(func,bitmask,wrapFunc,placeholder,thisArg,partials,holders,argPos,ary,arity){var isCurry=bitmask&WRAP_CURRY_FLAG,newHolders=isCurry?holders:undefined$1,newHoldersRight=isCurry?undefined$1:holders,newPartials=isCurry?partials:undefined$1,newPartialsRight=isCurry?undefined$1:partials;bitmask|=isCurry?WRAP_PARTIAL_FLAG:WRAP_PARTIAL_RIGHT_FLAG;bitmask&=~(isCurry?WRAP_PARTIAL_RIGHT_FLAG:WRAP_PARTIAL_FLAG);if(!(bitmask&WRAP_CURRY_BOUND_FLAG)){bitmask&=~(WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG);}var newData=[func,bitmask,thisArg,newPartials,newHolders,newPartialsRight,newHoldersRight,argPos,ary,arity];var result=wrapFunc.apply(undefined$1,newData);if(isLaziable(func)){setData(result,newData);}result.placeholder=placeholder;return setWrapToString(result,func,bitmask);}/**
    	     * Creates a function like `_.round`.
    	     *
    	     * @private
    	     * @param {string} methodName The name of the `Math` method to use when rounding.
    	     * @returns {Function} Returns the new round function.
    	     */function createRound(methodName){var func=Math[methodName];return function(number,precision){number=toNumber(number);precision=precision==null?0:nativeMin(toInteger(precision),292);if(precision&&nativeIsFinite(number)){// Shift with exponential notation to avoid floating-point issues.
    	// See [MDN](https://mdn.io/round#Examples) for more details.
    	var pair=(toString(number)+'e').split('e'),value=func(pair[0]+'e'+(+pair[1]+precision));pair=(toString(value)+'e').split('e');return +(pair[0]+'e'+(+pair[1]-precision));}return func(number);};}/**
    	     * Creates a set object of `values`.
    	     *
    	     * @private
    	     * @param {Array} values The values to add to the set.
    	     * @returns {Object} Returns the new set.
    	     */var createSet=!(Set&&1/setToArray(new Set([,-0]))[1]==INFINITY)?noop:function(values){return new Set(values);};/**
    	     * Creates a `_.toPairs` or `_.toPairsIn` function.
    	     *
    	     * @private
    	     * @param {Function} keysFunc The function to get the keys of a given object.
    	     * @returns {Function} Returns the new pairs function.
    	     */function createToPairs(keysFunc){return function(object){var tag=getTag(object);if(tag==mapTag){return mapToArray(object);}if(tag==setTag){return setToPairs(object);}return baseToPairs(object,keysFunc(object));};}/**
    	     * Creates a function that either curries or invokes `func` with optional
    	     * `this` binding and partially applied arguments.
    	     *
    	     * @private
    	     * @param {Function|string} func The function or method name to wrap.
    	     * @param {number} bitmask The bitmask flags.
    	     *    1 - `_.bind`
    	     *    2 - `_.bindKey`
    	     *    4 - `_.curry` or `_.curryRight` of a bound function
    	     *    8 - `_.curry`
    	     *   16 - `_.curryRight`
    	     *   32 - `_.partial`
    	     *   64 - `_.partialRight`
    	     *  128 - `_.rearg`
    	     *  256 - `_.ary`
    	     *  512 - `_.flip`
    	     * @param {*} [thisArg] The `this` binding of `func`.
    	     * @param {Array} [partials] The arguments to be partially applied.
    	     * @param {Array} [holders] The `partials` placeholder indexes.
    	     * @param {Array} [argPos] The argument positions of the new function.
    	     * @param {number} [ary] The arity cap of `func`.
    	     * @param {number} [arity] The arity of `func`.
    	     * @returns {Function} Returns the new wrapped function.
    	     */function createWrap(func,bitmask,thisArg,partials,holders,argPos,ary,arity){var isBindKey=bitmask&WRAP_BIND_KEY_FLAG;if(!isBindKey&&typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}var length=partials?partials.length:0;if(!length){bitmask&=~(WRAP_PARTIAL_FLAG|WRAP_PARTIAL_RIGHT_FLAG);partials=holders=undefined$1;}ary=ary===undefined$1?ary:nativeMax(toInteger(ary),0);arity=arity===undefined$1?arity:toInteger(arity);length-=holders?holders.length:0;if(bitmask&WRAP_PARTIAL_RIGHT_FLAG){var partialsRight=partials,holdersRight=holders;partials=holders=undefined$1;}var data=isBindKey?undefined$1:getData(func);var newData=[func,bitmask,thisArg,partials,holders,partialsRight,holdersRight,argPos,ary,arity];if(data){mergeData(newData,data);}func=newData[0];bitmask=newData[1];thisArg=newData[2];partials=newData[3];holders=newData[4];arity=newData[9]=newData[9]===undefined$1?isBindKey?0:func.length:nativeMax(newData[9]-length,0);if(!arity&&bitmask&(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG)){bitmask&=~(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG);}if(!bitmask||bitmask==WRAP_BIND_FLAG){var result=createBind(func,bitmask,thisArg);}else if(bitmask==WRAP_CURRY_FLAG||bitmask==WRAP_CURRY_RIGHT_FLAG){result=createCurry(func,bitmask,arity);}else if((bitmask==WRAP_PARTIAL_FLAG||bitmask==(WRAP_BIND_FLAG|WRAP_PARTIAL_FLAG))&&!holders.length){result=createPartial(func,bitmask,thisArg,partials);}else {result=createHybrid.apply(undefined$1,newData);}var setter=data?baseSetData:setData;return setWrapToString(setter(result,newData),func,bitmask);}/**
    	     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
    	     * of source objects to the destination object for all destination properties
    	     * that resolve to `undefined`.
    	     *
    	     * @private
    	     * @param {*} objValue The destination value.
    	     * @param {*} srcValue The source value.
    	     * @param {string} key The key of the property to assign.
    	     * @param {Object} object The parent object of `objValue`.
    	     * @returns {*} Returns the value to assign.
    	     */function customDefaultsAssignIn(objValue,srcValue,key,object){if(objValue===undefined$1||eq(objValue,objectProto[key])&&!hasOwnProperty.call(object,key)){return srcValue;}return objValue;}/**
    	     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
    	     * objects into destination objects that are passed thru.
    	     *
    	     * @private
    	     * @param {*} objValue The destination value.
    	     * @param {*} srcValue The source value.
    	     * @param {string} key The key of the property to merge.
    	     * @param {Object} object The parent object of `objValue`.
    	     * @param {Object} source The parent object of `srcValue`.
    	     * @param {Object} [stack] Tracks traversed source values and their merged
    	     *  counterparts.
    	     * @returns {*} Returns the value to assign.
    	     */function customDefaultsMerge(objValue,srcValue,key,object,source,stack){if(isObject(objValue)&&isObject(srcValue)){// Recursively merge objects and arrays (susceptible to call stack limits).
    	stack.set(srcValue,objValue);baseMerge(objValue,srcValue,undefined$1,customDefaultsMerge,stack);stack['delete'](srcValue);}return objValue;}/**
    	     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
    	     * objects.
    	     *
    	     * @private
    	     * @param {*} value The value to inspect.
    	     * @param {string} key The key of the property to inspect.
    	     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
    	     */function customOmitClone(value){return isPlainObject(value)?undefined$1:value;}/**
    	     * A specialized version of `baseIsEqualDeep` for arrays with support for
    	     * partial deep comparisons.
    	     *
    	     * @private
    	     * @param {Array} array The array to compare.
    	     * @param {Array} other The other array to compare.
    	     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
    	     * @param {Function} customizer The function to customize comparisons.
    	     * @param {Function} equalFunc The function to determine equivalents of values.
    	     * @param {Object} stack Tracks traversed `array` and `other` objects.
    	     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
    	     */function equalArrays(array,other,bitmask,customizer,equalFunc,stack){var isPartial=bitmask&COMPARE_PARTIAL_FLAG,arrLength=array.length,othLength=other.length;if(arrLength!=othLength&&!(isPartial&&othLength>arrLength)){return false;}// Check that cyclic values are equal.
    	var arrStacked=stack.get(array);var othStacked=stack.get(other);if(arrStacked&&othStacked){return arrStacked==other&&othStacked==array;}var index=-1,result=true,seen=bitmask&COMPARE_UNORDERED_FLAG?new SetCache():undefined$1;stack.set(array,other);stack.set(other,array);// Ignore non-index properties.
    	while(++index<arrLength){var arrValue=array[index],othValue=other[index];if(customizer){var compared=isPartial?customizer(othValue,arrValue,index,other,array,stack):customizer(arrValue,othValue,index,array,other,stack);}if(compared!==undefined$1){if(compared){continue;}result=false;break;}// Recursively compare arrays (susceptible to call stack limits).
    	if(seen){if(!arraySome(other,function(othValue,othIndex){if(!cacheHas(seen,othIndex)&&(arrValue===othValue||equalFunc(arrValue,othValue,bitmask,customizer,stack))){return seen.push(othIndex);}})){result=false;break;}}else if(!(arrValue===othValue||equalFunc(arrValue,othValue,bitmask,customizer,stack))){result=false;break;}}stack['delete'](array);stack['delete'](other);return result;}/**
    	     * A specialized version of `baseIsEqualDeep` for comparing objects of
    	     * the same `toStringTag`.
    	     *
    	     * **Note:** This function only supports comparing values with tags of
    	     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
    	     *
    	     * @private
    	     * @param {Object} object The object to compare.
    	     * @param {Object} other The other object to compare.
    	     * @param {string} tag The `toStringTag` of the objects to compare.
    	     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
    	     * @param {Function} customizer The function to customize comparisons.
    	     * @param {Function} equalFunc The function to determine equivalents of values.
    	     * @param {Object} stack Tracks traversed `object` and `other` objects.
    	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
    	     */function equalByTag(object,other,tag,bitmask,customizer,equalFunc,stack){switch(tag){case dataViewTag:if(object.byteLength!=other.byteLength||object.byteOffset!=other.byteOffset){return false;}object=object.buffer;other=other.buffer;case arrayBufferTag:if(object.byteLength!=other.byteLength||!equalFunc(new Uint8Array(object),new Uint8Array(other))){return false;}return true;case boolTag:case dateTag:case numberTag:// Coerce booleans to `1` or `0` and dates to milliseconds.
    	// Invalid dates are coerced to `NaN`.
    	return eq(+object,+other);case errorTag:return object.name==other.name&&object.message==other.message;case regexpTag:case stringTag:// Coerce regexes to strings and treat strings, primitives and objects,
    	// as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
    	// for more details.
    	return object==other+'';case mapTag:var convert=mapToArray;case setTag:var isPartial=bitmask&COMPARE_PARTIAL_FLAG;convert||(convert=setToArray);if(object.size!=other.size&&!isPartial){return false;}// Assume cyclic values are equal.
    	var stacked=stack.get(object);if(stacked){return stacked==other;}bitmask|=COMPARE_UNORDERED_FLAG;// Recursively compare objects (susceptible to call stack limits).
    	stack.set(object,other);var result=equalArrays(convert(object),convert(other),bitmask,customizer,equalFunc,stack);stack['delete'](object);return result;case symbolTag:if(symbolValueOf){return symbolValueOf.call(object)==symbolValueOf.call(other);}}return false;}/**
    	     * A specialized version of `baseIsEqualDeep` for objects with support for
    	     * partial deep comparisons.
    	     *
    	     * @private
    	     * @param {Object} object The object to compare.
    	     * @param {Object} other The other object to compare.
    	     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
    	     * @param {Function} customizer The function to customize comparisons.
    	     * @param {Function} equalFunc The function to determine equivalents of values.
    	     * @param {Object} stack Tracks traversed `object` and `other` objects.
    	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
    	     */function equalObjects(object,other,bitmask,customizer,equalFunc,stack){var isPartial=bitmask&COMPARE_PARTIAL_FLAG,objProps=getAllKeys(object),objLength=objProps.length,othProps=getAllKeys(other),othLength=othProps.length;if(objLength!=othLength&&!isPartial){return false;}var index=objLength;while(index--){var key=objProps[index];if(!(isPartial?key in other:hasOwnProperty.call(other,key))){return false;}}// Check that cyclic values are equal.
    	var objStacked=stack.get(object);var othStacked=stack.get(other);if(objStacked&&othStacked){return objStacked==other&&othStacked==object;}var result=true;stack.set(object,other);stack.set(other,object);var skipCtor=isPartial;while(++index<objLength){key=objProps[index];var objValue=object[key],othValue=other[key];if(customizer){var compared=isPartial?customizer(othValue,objValue,key,other,object,stack):customizer(objValue,othValue,key,object,other,stack);}// Recursively compare objects (susceptible to call stack limits).
    	if(!(compared===undefined$1?objValue===othValue||equalFunc(objValue,othValue,bitmask,customizer,stack):compared)){result=false;break;}skipCtor||(skipCtor=key=='constructor');}if(result&&!skipCtor){var objCtor=object.constructor,othCtor=other.constructor;// Non `Object` object instances with different constructors are not equal.
    	if(objCtor!=othCtor&&'constructor'in object&&'constructor'in other&&!(typeof objCtor=='function'&&objCtor instanceof objCtor&&typeof othCtor=='function'&&othCtor instanceof othCtor)){result=false;}}stack['delete'](object);stack['delete'](other);return result;}/**
    	     * A specialized version of `baseRest` which flattens the rest array.
    	     *
    	     * @private
    	     * @param {Function} func The function to apply a rest parameter to.
    	     * @returns {Function} Returns the new function.
    	     */function flatRest(func){return setToString(overRest(func,undefined$1,flatten),func+'');}/**
    	     * Creates an array of own enumerable property names and symbols of `object`.
    	     *
    	     * @private
    	     * @param {Object} object The object to query.
    	     * @returns {Array} Returns the array of property names and symbols.
    	     */function getAllKeys(object){return baseGetAllKeys(object,keys,getSymbols);}/**
    	     * Creates an array of own and inherited enumerable property names and
    	     * symbols of `object`.
    	     *
    	     * @private
    	     * @param {Object} object The object to query.
    	     * @returns {Array} Returns the array of property names and symbols.
    	     */function getAllKeysIn(object){return baseGetAllKeys(object,keysIn,getSymbolsIn);}/**
    	     * Gets metadata for `func`.
    	     *
    	     * @private
    	     * @param {Function} func The function to query.
    	     * @returns {*} Returns the metadata for `func`.
    	     */var getData=!metaMap?noop:function(func){return metaMap.get(func);};/**
    	     * Gets the name of `func`.
    	     *
    	     * @private
    	     * @param {Function} func The function to query.
    	     * @returns {string} Returns the function name.
    	     */function getFuncName(func){var result=func.name+'',array=realNames[result],length=hasOwnProperty.call(realNames,result)?array.length:0;while(length--){var data=array[length],otherFunc=data.func;if(otherFunc==null||otherFunc==func){return data.name;}}return result;}/**
    	     * Gets the argument placeholder value for `func`.
    	     *
    	     * @private
    	     * @param {Function} func The function to inspect.
    	     * @returns {*} Returns the placeholder value.
    	     */function getHolder(func){var object=hasOwnProperty.call(lodash,'placeholder')?lodash:func;return object.placeholder;}/**
    	     * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
    	     * this function returns the custom method, otherwise it returns `baseIteratee`.
    	     * If arguments are provided, the chosen function is invoked with them and
    	     * its result is returned.
    	     *
    	     * @private
    	     * @param {*} [value] The value to convert to an iteratee.
    	     * @param {number} [arity] The arity of the created iteratee.
    	     * @returns {Function} Returns the chosen function or its result.
    	     */function getIteratee(){var result=lodash.iteratee||iteratee;result=result===iteratee?baseIteratee:result;return arguments.length?result(arguments[0],arguments[1]):result;}/**
    	     * Gets the data for `map`.
    	     *
    	     * @private
    	     * @param {Object} map The map to query.
    	     * @param {string} key The reference key.
    	     * @returns {*} Returns the map data.
    	     */function getMapData(map,key){var data=map.__data__;return isKeyable(key)?data[typeof key=='string'?'string':'hash']:data.map;}/**
    	     * Gets the property names, values, and compare flags of `object`.
    	     *
    	     * @private
    	     * @param {Object} object The object to query.
    	     * @returns {Array} Returns the match data of `object`.
    	     */function getMatchData(object){var result=keys(object),length=result.length;while(length--){var key=result[length],value=object[key];result[length]=[key,value,isStrictComparable(value)];}return result;}/**
    	     * Gets the native function at `key` of `object`.
    	     *
    	     * @private
    	     * @param {Object} object The object to query.
    	     * @param {string} key The key of the method to get.
    	     * @returns {*} Returns the function if it's native, else `undefined`.
    	     */function getNative(object,key){var value=getValue(object,key);return baseIsNative(value)?value:undefined$1;}/**
    	     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
    	     *
    	     * @private
    	     * @param {*} value The value to query.
    	     * @returns {string} Returns the raw `toStringTag`.
    	     */function getRawTag(value){var isOwn=hasOwnProperty.call(value,symToStringTag),tag=value[symToStringTag];try{value[symToStringTag]=undefined$1;var unmasked=true;}catch(e){}var result=nativeObjectToString.call(value);if(unmasked){if(isOwn){value[symToStringTag]=tag;}else {delete value[symToStringTag];}}return result;}/**
    	     * Creates an array of the own enumerable symbols of `object`.
    	     *
    	     * @private
    	     * @param {Object} object The object to query.
    	     * @returns {Array} Returns the array of symbols.
    	     */var getSymbols=!nativeGetSymbols?stubArray:function(object){if(object==null){return [];}object=Object(object);return arrayFilter(nativeGetSymbols(object),function(symbol){return propertyIsEnumerable.call(object,symbol);});};/**
    	     * Creates an array of the own and inherited enumerable symbols of `object`.
    	     *
    	     * @private
    	     * @param {Object} object The object to query.
    	     * @returns {Array} Returns the array of symbols.
    	     */var getSymbolsIn=!nativeGetSymbols?stubArray:function(object){var result=[];while(object){arrayPush(result,getSymbols(object));object=getPrototype(object);}return result;};/**
    	     * Gets the `toStringTag` of `value`.
    	     *
    	     * @private
    	     * @param {*} value The value to query.
    	     * @returns {string} Returns the `toStringTag`.
    	     */var getTag=baseGetTag;// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
    	if(DataView&&getTag(new DataView(new ArrayBuffer(1)))!=dataViewTag||Map&&getTag(new Map())!=mapTag||Promise&&getTag(Promise.resolve())!=promiseTag||Set&&getTag(new Set())!=setTag||WeakMap&&getTag(new WeakMap())!=weakMapTag){getTag=function(value){var result=baseGetTag(value),Ctor=result==objectTag?value.constructor:undefined$1,ctorString=Ctor?toSource(Ctor):'';if(ctorString){switch(ctorString){case dataViewCtorString:return dataViewTag;case mapCtorString:return mapTag;case promiseCtorString:return promiseTag;case setCtorString:return setTag;case weakMapCtorString:return weakMapTag;}}return result;};}/**
    	     * Gets the view, applying any `transforms` to the `start` and `end` positions.
    	     *
    	     * @private
    	     * @param {number} start The start of the view.
    	     * @param {number} end The end of the view.
    	     * @param {Array} transforms The transformations to apply to the view.
    	     * @returns {Object} Returns an object containing the `start` and `end`
    	     *  positions of the view.
    	     */function getView(start,end,transforms){var index=-1,length=transforms.length;while(++index<length){var data=transforms[index],size=data.size;switch(data.type){case'drop':start+=size;break;case'dropRight':end-=size;break;case'take':end=nativeMin(end,start+size);break;case'takeRight':start=nativeMax(start,end-size);break;}}return {'start':start,'end':end};}/**
    	     * Extracts wrapper details from the `source` body comment.
    	     *
    	     * @private
    	     * @param {string} source The source to inspect.
    	     * @returns {Array} Returns the wrapper details.
    	     */function getWrapDetails(source){var match=source.match(reWrapDetails);return match?match[1].split(reSplitDetails):[];}/**
    	     * Checks if `path` exists on `object`.
    	     *
    	     * @private
    	     * @param {Object} object The object to query.
    	     * @param {Array|string} path The path to check.
    	     * @param {Function} hasFunc The function to check properties.
    	     * @returns {boolean} Returns `true` if `path` exists, else `false`.
    	     */function hasPath(object,path,hasFunc){path=castPath(path,object);var index=-1,length=path.length,result=false;while(++index<length){var key=toKey(path[index]);if(!(result=object!=null&&hasFunc(object,key))){break;}object=object[key];}if(result||++index!=length){return result;}length=object==null?0:object.length;return !!length&&isLength(length)&&isIndex(key,length)&&(isArray(object)||isArguments(object));}/**
    	     * Initializes an array clone.
    	     *
    	     * @private
    	     * @param {Array} array The array to clone.
    	     * @returns {Array} Returns the initialized clone.
    	     */function initCloneArray(array){var length=array.length,result=new array.constructor(length);// Add properties assigned by `RegExp#exec`.
    	if(length&&typeof array[0]=='string'&&hasOwnProperty.call(array,'index')){result.index=array.index;result.input=array.input;}return result;}/**
    	     * Initializes an object clone.
    	     *
    	     * @private
    	     * @param {Object} object The object to clone.
    	     * @returns {Object} Returns the initialized clone.
    	     */function initCloneObject(object){return typeof object.constructor=='function'&&!isPrototype(object)?baseCreate(getPrototype(object)):{};}/**
    	     * Initializes an object clone based on its `toStringTag`.
    	     *
    	     * **Note:** This function only supports cloning values with tags of
    	     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
    	     *
    	     * @private
    	     * @param {Object} object The object to clone.
    	     * @param {string} tag The `toStringTag` of the object to clone.
    	     * @param {boolean} [isDeep] Specify a deep clone.
    	     * @returns {Object} Returns the initialized clone.
    	     */function initCloneByTag(object,tag,isDeep){var Ctor=object.constructor;switch(tag){case arrayBufferTag:return cloneArrayBuffer(object);case boolTag:case dateTag:return new Ctor(+object);case dataViewTag:return cloneDataView(object,isDeep);case float32Tag:case float64Tag:case int8Tag:case int16Tag:case int32Tag:case uint8Tag:case uint8ClampedTag:case uint16Tag:case uint32Tag:return cloneTypedArray(object,isDeep);case mapTag:return new Ctor();case numberTag:case stringTag:return new Ctor(object);case regexpTag:return cloneRegExp(object);case setTag:return new Ctor();case symbolTag:return cloneSymbol(object);}}/**
    	     * Inserts wrapper `details` in a comment at the top of the `source` body.
    	     *
    	     * @private
    	     * @param {string} source The source to modify.
    	     * @returns {Array} details The details to insert.
    	     * @returns {string} Returns the modified source.
    	     */function insertWrapDetails(source,details){var length=details.length;if(!length){return source;}var lastIndex=length-1;details[lastIndex]=(length>1?'& ':'')+details[lastIndex];details=details.join(length>2?', ':' ');return source.replace(reWrapComment,'{\n/* [wrapped with '+details+'] */\n');}/**
    	     * Checks if `value` is a flattenable `arguments` object or array.
    	     *
    	     * @private
    	     * @param {*} value The value to check.
    	     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
    	     */function isFlattenable(value){return isArray(value)||isArguments(value)||!!(spreadableSymbol&&value&&value[spreadableSymbol]);}/**
    	     * Checks if `value` is a valid array-like index.
    	     *
    	     * @private
    	     * @param {*} value The value to check.
    	     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
    	     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
    	     */function isIndex(value,length){var type=typeof value;length=length==null?MAX_SAFE_INTEGER:length;return !!length&&(type=='number'||type!='symbol'&&reIsUint.test(value))&&value>-1&&value%1==0&&value<length;}/**
    	     * Checks if the given arguments are from an iteratee call.
    	     *
    	     * @private
    	     * @param {*} value The potential iteratee value argument.
    	     * @param {*} index The potential iteratee index or key argument.
    	     * @param {*} object The potential iteratee object argument.
    	     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
    	     *  else `false`.
    	     */function isIterateeCall(value,index,object){if(!isObject(object)){return false;}var type=typeof index;if(type=='number'?isArrayLike(object)&&isIndex(index,object.length):type=='string'&&index in object){return eq(object[index],value);}return false;}/**
    	     * Checks if `value` is a property name and not a property path.
    	     *
    	     * @private
    	     * @param {*} value The value to check.
    	     * @param {Object} [object] The object to query keys on.
    	     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
    	     */function isKey(value,object){if(isArray(value)){return false;}var type=typeof value;if(type=='number'||type=='symbol'||type=='boolean'||value==null||isSymbol(value)){return true;}return reIsPlainProp.test(value)||!reIsDeepProp.test(value)||object!=null&&value in Object(object);}/**
    	     * Checks if `value` is suitable for use as unique object key.
    	     *
    	     * @private
    	     * @param {*} value The value to check.
    	     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
    	     */function isKeyable(value){var type=typeof value;return type=='string'||type=='number'||type=='symbol'||type=='boolean'?value!=='__proto__':value===null;}/**
    	     * Checks if `func` has a lazy counterpart.
    	     *
    	     * @private
    	     * @param {Function} func The function to check.
    	     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
    	     *  else `false`.
    	     */function isLaziable(func){var funcName=getFuncName(func),other=lodash[funcName];if(typeof other!='function'||!(funcName in LazyWrapper.prototype)){return false;}if(func===other){return true;}var data=getData(other);return !!data&&func===data[0];}/**
    	     * Checks if `func` has its source masked.
    	     *
    	     * @private
    	     * @param {Function} func The function to check.
    	     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
    	     */function isMasked(func){return !!maskSrcKey&&maskSrcKey in func;}/**
    	     * Checks if `func` is capable of being masked.
    	     *
    	     * @private
    	     * @param {*} value The value to check.
    	     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
    	     */var isMaskable=coreJsData?isFunction:stubFalse;/**
    	     * Checks if `value` is likely a prototype object.
    	     *
    	     * @private
    	     * @param {*} value The value to check.
    	     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
    	     */function isPrototype(value){var Ctor=value&&value.constructor,proto=typeof Ctor=='function'&&Ctor.prototype||objectProto;return value===proto;}/**
    	     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
    	     *
    	     * @private
    	     * @param {*} value The value to check.
    	     * @returns {boolean} Returns `true` if `value` if suitable for strict
    	     *  equality comparisons, else `false`.
    	     */function isStrictComparable(value){return value===value&&!isObject(value);}/**
    	     * A specialized version of `matchesProperty` for source values suitable
    	     * for strict equality comparisons, i.e. `===`.
    	     *
    	     * @private
    	     * @param {string} key The key of the property to get.
    	     * @param {*} srcValue The value to match.
    	     * @returns {Function} Returns the new spec function.
    	     */function matchesStrictComparable(key,srcValue){return function(object){if(object==null){return false;}return object[key]===srcValue&&(srcValue!==undefined$1||key in Object(object));};}/**
    	     * A specialized version of `_.memoize` which clears the memoized function's
    	     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
    	     *
    	     * @private
    	     * @param {Function} func The function to have its output memoized.
    	     * @returns {Function} Returns the new memoized function.
    	     */function memoizeCapped(func){var result=memoize(func,function(key){if(cache.size===MAX_MEMOIZE_SIZE){cache.clear();}return key;});var cache=result.cache;return result;}/**
    	     * Merges the function metadata of `source` into `data`.
    	     *
    	     * Merging metadata reduces the number of wrappers used to invoke a function.
    	     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
    	     * may be applied regardless of execution order. Methods like `_.ary` and
    	     * `_.rearg` modify function arguments, making the order in which they are
    	     * executed important, preventing the merging of metadata. However, we make
    	     * an exception for a safe combined case where curried functions have `_.ary`
    	     * and or `_.rearg` applied.
    	     *
    	     * @private
    	     * @param {Array} data The destination metadata.
    	     * @param {Array} source The source metadata.
    	     * @returns {Array} Returns `data`.
    	     */function mergeData(data,source){var bitmask=data[1],srcBitmask=source[1],newBitmask=bitmask|srcBitmask,isCommon=newBitmask<(WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG|WRAP_ARY_FLAG);var isCombo=srcBitmask==WRAP_ARY_FLAG&&bitmask==WRAP_CURRY_FLAG||srcBitmask==WRAP_ARY_FLAG&&bitmask==WRAP_REARG_FLAG&&data[7].length<=source[8]||srcBitmask==(WRAP_ARY_FLAG|WRAP_REARG_FLAG)&&source[7].length<=source[8]&&bitmask==WRAP_CURRY_FLAG;// Exit early if metadata can't be merged.
    	if(!(isCommon||isCombo)){return data;}// Use source `thisArg` if available.
    	if(srcBitmask&WRAP_BIND_FLAG){data[2]=source[2];// Set when currying a bound function.
    	newBitmask|=bitmask&WRAP_BIND_FLAG?0:WRAP_CURRY_BOUND_FLAG;}// Compose partial arguments.
    	var value=source[3];if(value){var partials=data[3];data[3]=partials?composeArgs(partials,value,source[4]):value;data[4]=partials?replaceHolders(data[3],PLACEHOLDER):source[4];}// Compose partial right arguments.
    	value=source[5];if(value){partials=data[5];data[5]=partials?composeArgsRight(partials,value,source[6]):value;data[6]=partials?replaceHolders(data[5],PLACEHOLDER):source[6];}// Use source `argPos` if available.
    	value=source[7];if(value){data[7]=value;}// Use source `ary` if it's smaller.
    	if(srcBitmask&WRAP_ARY_FLAG){data[8]=data[8]==null?source[8]:nativeMin(data[8],source[8]);}// Use source `arity` if one is not provided.
    	if(data[9]==null){data[9]=source[9];}// Use source `func` and merge bitmasks.
    	data[0]=source[0];data[1]=newBitmask;return data;}/**
    	     * This function is like
    	     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
    	     * except that it includes inherited enumerable properties.
    	     *
    	     * @private
    	     * @param {Object} object The object to query.
    	     * @returns {Array} Returns the array of property names.
    	     */function nativeKeysIn(object){var result=[];if(object!=null){for(var key in Object(object)){result.push(key);}}return result;}/**
    	     * Converts `value` to a string using `Object.prototype.toString`.
    	     *
    	     * @private
    	     * @param {*} value The value to convert.
    	     * @returns {string} Returns the converted string.
    	     */function objectToString(value){return nativeObjectToString.call(value);}/**
    	     * A specialized version of `baseRest` which transforms the rest array.
    	     *
    	     * @private
    	     * @param {Function} func The function to apply a rest parameter to.
    	     * @param {number} [start=func.length-1] The start position of the rest parameter.
    	     * @param {Function} transform The rest array transform.
    	     * @returns {Function} Returns the new function.
    	     */function overRest(func,start,transform){start=nativeMax(start===undefined$1?func.length-1:start,0);return function(){var args=arguments,index=-1,length=nativeMax(args.length-start,0),array=Array(length);while(++index<length){array[index]=args[start+index];}index=-1;var otherArgs=Array(start+1);while(++index<start){otherArgs[index]=args[index];}otherArgs[start]=transform(array);return apply(func,this,otherArgs);};}/**
    	     * Gets the parent value at `path` of `object`.
    	     *
    	     * @private
    	     * @param {Object} object The object to query.
    	     * @param {Array} path The path to get the parent value of.
    	     * @returns {*} Returns the parent value.
    	     */function parent(object,path){return path.length<2?object:baseGet(object,baseSlice(path,0,-1));}/**
    	     * Reorder `array` according to the specified indexes where the element at
    	     * the first index is assigned as the first element, the element at
    	     * the second index is assigned as the second element, and so on.
    	     *
    	     * @private
    	     * @param {Array} array The array to reorder.
    	     * @param {Array} indexes The arranged array indexes.
    	     * @returns {Array} Returns `array`.
    	     */function reorder(array,indexes){var arrLength=array.length,length=nativeMin(indexes.length,arrLength),oldArray=copyArray(array);while(length--){var index=indexes[length];array[length]=isIndex(index,arrLength)?oldArray[index]:undefined$1;}return array;}/**
    	     * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
    	     *
    	     * @private
    	     * @param {Object} object The object to query.
    	     * @param {string} key The key of the property to get.
    	     * @returns {*} Returns the property value.
    	     */function safeGet(object,key){if(key==='constructor'&&typeof object[key]==='function'){return;}if(key=='__proto__'){return;}return object[key];}/**
    	     * Sets metadata for `func`.
    	     *
    	     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
    	     * period of time, it will trip its breaker and transition to an identity
    	     * function to avoid garbage collection pauses in V8. See
    	     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
    	     * for more details.
    	     *
    	     * @private
    	     * @param {Function} func The function to associate metadata with.
    	     * @param {*} data The metadata.
    	     * @returns {Function} Returns `func`.
    	     */var setData=shortOut(baseSetData);/**
    	     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
    	     *
    	     * @private
    	     * @param {Function} func The function to delay.
    	     * @param {number} wait The number of milliseconds to delay invocation.
    	     * @returns {number|Object} Returns the timer id or timeout object.
    	     */var setTimeout=ctxSetTimeout||function(func,wait){return root.setTimeout(func,wait);};/**
    	     * Sets the `toString` method of `func` to return `string`.
    	     *
    	     * @private
    	     * @param {Function} func The function to modify.
    	     * @param {Function} string The `toString` result.
    	     * @returns {Function} Returns `func`.
    	     */var setToString=shortOut(baseSetToString);/**
    	     * Sets the `toString` method of `wrapper` to mimic the source of `reference`
    	     * with wrapper details in a comment at the top of the source body.
    	     *
    	     * @private
    	     * @param {Function} wrapper The function to modify.
    	     * @param {Function} reference The reference function.
    	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
    	     * @returns {Function} Returns `wrapper`.
    	     */function setWrapToString(wrapper,reference,bitmask){var source=reference+'';return setToString(wrapper,insertWrapDetails(source,updateWrapDetails(getWrapDetails(source),bitmask)));}/**
    	     * Creates a function that'll short out and invoke `identity` instead
    	     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
    	     * milliseconds.
    	     *
    	     * @private
    	     * @param {Function} func The function to restrict.
    	     * @returns {Function} Returns the new shortable function.
    	     */function shortOut(func){var count=0,lastCalled=0;return function(){var stamp=nativeNow(),remaining=HOT_SPAN-(stamp-lastCalled);lastCalled=stamp;if(remaining>0){if(++count>=HOT_COUNT){return arguments[0];}}else {count=0;}return func.apply(undefined$1,arguments);};}/**
    	     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
    	     *
    	     * @private
    	     * @param {Array} array The array to shuffle.
    	     * @param {number} [size=array.length] The size of `array`.
    	     * @returns {Array} Returns `array`.
    	     */function shuffleSelf(array,size){var index=-1,length=array.length,lastIndex=length-1;size=size===undefined$1?length:size;while(++index<size){var rand=baseRandom(index,lastIndex),value=array[rand];array[rand]=array[index];array[index]=value;}array.length=size;return array;}/**
    	     * Converts `string` to a property path array.
    	     *
    	     * @private
    	     * @param {string} string The string to convert.
    	     * @returns {Array} Returns the property path array.
    	     */var stringToPath=memoizeCapped(function(string){var result=[];if(string.charCodeAt(0)===46/* . */){result.push('');}string.replace(rePropName,function(match,number,quote,subString){result.push(quote?subString.replace(reEscapeChar,'$1'):number||match);});return result;});/**
    	     * Converts `value` to a string key if it's not a string or symbol.
    	     *
    	     * @private
    	     * @param {*} value The value to inspect.
    	     * @returns {string|symbol} Returns the key.
    	     */function toKey(value){if(typeof value=='string'||isSymbol(value)){return value;}var result=value+'';return result=='0'&&1/value==-INFINITY?'-0':result;}/**
    	     * Converts `func` to its source code.
    	     *
    	     * @private
    	     * @param {Function} func The function to convert.
    	     * @returns {string} Returns the source code.
    	     */function toSource(func){if(func!=null){try{return funcToString.call(func);}catch(e){}try{return func+'';}catch(e){}}return '';}/**
    	     * Updates wrapper `details` based on `bitmask` flags.
    	     *
    	     * @private
    	     * @returns {Array} details The details to modify.
    	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
    	     * @returns {Array} Returns `details`.
    	     */function updateWrapDetails(details,bitmask){arrayEach(wrapFlags,function(pair){var value='_.'+pair[0];if(bitmask&pair[1]&&!arrayIncludes(details,value)){details.push(value);}});return details.sort();}/**
    	     * Creates a clone of `wrapper`.
    	     *
    	     * @private
    	     * @param {Object} wrapper The wrapper to clone.
    	     * @returns {Object} Returns the cloned wrapper.
    	     */function wrapperClone(wrapper){if(wrapper instanceof LazyWrapper){return wrapper.clone();}var result=new LodashWrapper(wrapper.__wrapped__,wrapper.__chain__);result.__actions__=copyArray(wrapper.__actions__);result.__index__=wrapper.__index__;result.__values__=wrapper.__values__;return result;}/*------------------------------------------------------------------------*/ /**
    	     * Creates an array of elements split into groups the length of `size`.
    	     * If `array` can't be split evenly, the final chunk will be the remaining
    	     * elements.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 3.0.0
    	     * @category Array
    	     * @param {Array} array The array to process.
    	     * @param {number} [size=1] The length of each chunk
    	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
    	     * @returns {Array} Returns the new array of chunks.
    	     * @example
    	     *
    	     * _.chunk(['a', 'b', 'c', 'd'], 2);
    	     * // => [['a', 'b'], ['c', 'd']]
    	     *
    	     * _.chunk(['a', 'b', 'c', 'd'], 3);
    	     * // => [['a', 'b', 'c'], ['d']]
    	     */function chunk(array,size,guard){if(guard?isIterateeCall(array,size,guard):size===undefined$1){size=1;}else {size=nativeMax(toInteger(size),0);}var length=array==null?0:array.length;if(!length||size<1){return [];}var index=0,resIndex=0,result=Array(nativeCeil(length/size));while(index<length){result[resIndex++]=baseSlice(array,index,index+=size);}return result;}/**
    	     * Creates an array with all falsey values removed. The values `false`, `null`,
    	     * `0`, `""`, `undefined`, and `NaN` are falsey.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.1.0
    	     * @category Array
    	     * @param {Array} array The array to compact.
    	     * @returns {Array} Returns the new array of filtered values.
    	     * @example
    	     *
    	     * _.compact([0, 1, false, 2, '', 3]);
    	     * // => [1, 2, 3]
    	     */function compact(array){var index=-1,length=array==null?0:array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(value){result[resIndex++]=value;}}return result;}/**
    	     * Creates a new array concatenating `array` with any additional arrays
    	     * and/or values.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Array
    	     * @param {Array} array The array to concatenate.
    	     * @param {...*} [values] The values to concatenate.
    	     * @returns {Array} Returns the new concatenated array.
    	     * @example
    	     *
    	     * var array = [1];
    	     * var other = _.concat(array, 2, [3], [[4]]);
    	     *
    	     * console.log(other);
    	     * // => [1, 2, 3, [4]]
    	     *
    	     * console.log(array);
    	     * // => [1]
    	     */function concat(){var length=arguments.length;if(!length){return [];}var args=Array(length-1),array=arguments[0],index=length;while(index--){args[index-1]=arguments[index];}return arrayPush(isArray(array)?copyArray(array):[array],baseFlatten(args,1));}/**
    	     * Creates an array of `array` values not included in the other given arrays
    	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
    	     * for equality comparisons. The order and references of result values are
    	     * determined by the first array.
    	     *
    	     * **Note:** Unlike `_.pullAll`, this method returns a new array.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.1.0
    	     * @category Array
    	     * @param {Array} array The array to inspect.
    	     * @param {...Array} [values] The values to exclude.
    	     * @returns {Array} Returns the new array of filtered values.
    	     * @see _.without, _.xor
    	     * @example
    	     *
    	     * _.difference([2, 1], [2, 3]);
    	     * // => [1]
    	     */var difference=baseRest(function(array,values){return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true)):[];});/**
    	     * This method is like `_.difference` except that it accepts `iteratee` which
    	     * is invoked for each element of `array` and `values` to generate the criterion
    	     * by which they're compared. The order and references of result values are
    	     * determined by the first array. The iteratee is invoked with one argument:
    	     * (value).
    	     *
    	     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Array
    	     * @param {Array} array The array to inspect.
    	     * @param {...Array} [values] The values to exclude.
    	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
    	     * @returns {Array} Returns the new array of filtered values.
    	     * @example
    	     *
    	     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
    	     * // => [1.2]
    	     *
    	     * // The `_.property` iteratee shorthand.
    	     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
    	     * // => [{ 'x': 2 }]
    	     */var differenceBy=baseRest(function(array,values){var iteratee=last(values);if(isArrayLikeObject(iteratee)){iteratee=undefined$1;}return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true),getIteratee(iteratee,2)):[];});/**
    	     * This method is like `_.difference` except that it accepts `comparator`
    	     * which is invoked to compare elements of `array` to `values`. The order and
    	     * references of result values are determined by the first array. The comparator
    	     * is invoked with two arguments: (arrVal, othVal).
    	     *
    	     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Array
    	     * @param {Array} array The array to inspect.
    	     * @param {...Array} [values] The values to exclude.
    	     * @param {Function} [comparator] The comparator invoked per element.
    	     * @returns {Array} Returns the new array of filtered values.
    	     * @example
    	     *
    	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
    	     *
    	     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
    	     * // => [{ 'x': 2, 'y': 1 }]
    	     */var differenceWith=baseRest(function(array,values){var comparator=last(values);if(isArrayLikeObject(comparator)){comparator=undefined$1;}return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true),undefined$1,comparator):[];});/**
    	     * Creates a slice of `array` with `n` elements dropped from the beginning.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.5.0
    	     * @category Array
    	     * @param {Array} array The array to query.
    	     * @param {number} [n=1] The number of elements to drop.
    	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
    	     * @returns {Array} Returns the slice of `array`.
    	     * @example
    	     *
    	     * _.drop([1, 2, 3]);
    	     * // => [2, 3]
    	     *
    	     * _.drop([1, 2, 3], 2);
    	     * // => [3]
    	     *
    	     * _.drop([1, 2, 3], 5);
    	     * // => []
    	     *
    	     * _.drop([1, 2, 3], 0);
    	     * // => [1, 2, 3]
    	     */function drop(array,n,guard){var length=array==null?0:array.length;if(!length){return [];}n=guard||n===undefined$1?1:toInteger(n);return baseSlice(array,n<0?0:n,length);}/**
    	     * Creates a slice of `array` with `n` elements dropped from the end.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 3.0.0
    	     * @category Array
    	     * @param {Array} array The array to query.
    	     * @param {number} [n=1] The number of elements to drop.
    	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
    	     * @returns {Array} Returns the slice of `array`.
    	     * @example
    	     *
    	     * _.dropRight([1, 2, 3]);
    	     * // => [1, 2]
    	     *
    	     * _.dropRight([1, 2, 3], 2);
    	     * // => [1]
    	     *
    	     * _.dropRight([1, 2, 3], 5);
    	     * // => []
    	     *
    	     * _.dropRight([1, 2, 3], 0);
    	     * // => [1, 2, 3]
    	     */function dropRight(array,n,guard){var length=array==null?0:array.length;if(!length){return [];}n=guard||n===undefined$1?1:toInteger(n);n=length-n;return baseSlice(array,0,n<0?0:n);}/**
    	     * Creates a slice of `array` excluding elements dropped from the end.
    	     * Elements are dropped until `predicate` returns falsey. The predicate is
    	     * invoked with three arguments: (value, index, array).
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 3.0.0
    	     * @category Array
    	     * @param {Array} array The array to query.
    	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
    	     * @returns {Array} Returns the slice of `array`.
    	     * @example
    	     *
    	     * var users = [
    	     *   { 'user': 'barney',  'active': true },
    	     *   { 'user': 'fred',    'active': false },
    	     *   { 'user': 'pebbles', 'active': false }
    	     * ];
    	     *
    	     * _.dropRightWhile(users, function(o) { return !o.active; });
    	     * // => objects for ['barney']
    	     *
    	     * // The `_.matches` iteratee shorthand.
    	     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
    	     * // => objects for ['barney', 'fred']
    	     *
    	     * // The `_.matchesProperty` iteratee shorthand.
    	     * _.dropRightWhile(users, ['active', false]);
    	     * // => objects for ['barney']
    	     *
    	     * // The `_.property` iteratee shorthand.
    	     * _.dropRightWhile(users, 'active');
    	     * // => objects for ['barney', 'fred', 'pebbles']
    	     */function dropRightWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),true,true):[];}/**
    	     * Creates a slice of `array` excluding elements dropped from the beginning.
    	     * Elements are dropped until `predicate` returns falsey. The predicate is
    	     * invoked with three arguments: (value, index, array).
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 3.0.0
    	     * @category Array
    	     * @param {Array} array The array to query.
    	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
    	     * @returns {Array} Returns the slice of `array`.
    	     * @example
    	     *
    	     * var users = [
    	     *   { 'user': 'barney',  'active': false },
    	     *   { 'user': 'fred',    'active': false },
    	     *   { 'user': 'pebbles', 'active': true }
    	     * ];
    	     *
    	     * _.dropWhile(users, function(o) { return !o.active; });
    	     * // => objects for ['pebbles']
    	     *
    	     * // The `_.matches` iteratee shorthand.
    	     * _.dropWhile(users, { 'user': 'barney', 'active': false });
    	     * // => objects for ['fred', 'pebbles']
    	     *
    	     * // The `_.matchesProperty` iteratee shorthand.
    	     * _.dropWhile(users, ['active', false]);
    	     * // => objects for ['pebbles']
    	     *
    	     * // The `_.property` iteratee shorthand.
    	     * _.dropWhile(users, 'active');
    	     * // => objects for ['barney', 'fred', 'pebbles']
    	     */function dropWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),true):[];}/**
    	     * Fills elements of `array` with `value` from `start` up to, but not
    	     * including, `end`.
    	     *
    	     * **Note:** This method mutates `array`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 3.2.0
    	     * @category Array
    	     * @param {Array} array The array to fill.
    	     * @param {*} value The value to fill `array` with.
    	     * @param {number} [start=0] The start position.
    	     * @param {number} [end=array.length] The end position.
    	     * @returns {Array} Returns `array`.
    	     * @example
    	     *
    	     * var array = [1, 2, 3];
    	     *
    	     * _.fill(array, 'a');
    	     * console.log(array);
    	     * // => ['a', 'a', 'a']
    	     *
    	     * _.fill(Array(3), 2);
    	     * // => [2, 2, 2]
    	     *
    	     * _.fill([4, 6, 8, 10], '*', 1, 3);
    	     * // => [4, '*', '*', 10]
    	     */function fill(array,value,start,end){var length=array==null?0:array.length;if(!length){return [];}if(start&&typeof start!='number'&&isIterateeCall(array,value,start)){start=0;end=length;}return baseFill(array,value,start,end);}/**
    	     * This method is like `_.find` except that it returns the index of the first
    	     * element `predicate` returns truthy for instead of the element itself.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 1.1.0
    	     * @category Array
    	     * @param {Array} array The array to inspect.
    	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
    	     * @param {number} [fromIndex=0] The index to search from.
    	     * @returns {number} Returns the index of the found element, else `-1`.
    	     * @example
    	     *
    	     * var users = [
    	     *   { 'user': 'barney',  'active': false },
    	     *   { 'user': 'fred',    'active': false },
    	     *   { 'user': 'pebbles', 'active': true }
    	     * ];
    	     *
    	     * _.findIndex(users, function(o) { return o.user == 'barney'; });
    	     * // => 0
    	     *
    	     * // The `_.matches` iteratee shorthand.
    	     * _.findIndex(users, { 'user': 'fred', 'active': false });
    	     * // => 1
    	     *
    	     * // The `_.matchesProperty` iteratee shorthand.
    	     * _.findIndex(users, ['active', false]);
    	     * // => 0
    	     *
    	     * // The `_.property` iteratee shorthand.
    	     * _.findIndex(users, 'active');
    	     * // => 2
    	     */function findIndex(array,predicate,fromIndex){var length=array==null?0:array.length;if(!length){return -1;}var index=fromIndex==null?0:toInteger(fromIndex);if(index<0){index=nativeMax(length+index,0);}return baseFindIndex(array,getIteratee(predicate,3),index);}/**
    	     * This method is like `_.findIndex` except that it iterates over elements
    	     * of `collection` from right to left.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 2.0.0
    	     * @category Array
    	     * @param {Array} array The array to inspect.
    	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
    	     * @param {number} [fromIndex=array.length-1] The index to search from.
    	     * @returns {number} Returns the index of the found element, else `-1`.
    	     * @example
    	     *
    	     * var users = [
    	     *   { 'user': 'barney',  'active': true },
    	     *   { 'user': 'fred',    'active': false },
    	     *   { 'user': 'pebbles', 'active': false }
    	     * ];
    	     *
    	     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
    	     * // => 2
    	     *
    	     * // The `_.matches` iteratee shorthand.
    	     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
    	     * // => 0
    	     *
    	     * // The `_.matchesProperty` iteratee shorthand.
    	     * _.findLastIndex(users, ['active', false]);
    	     * // => 2
    	     *
    	     * // The `_.property` iteratee shorthand.
    	     * _.findLastIndex(users, 'active');
    	     * // => 0
    	     */function findLastIndex(array,predicate,fromIndex){var length=array==null?0:array.length;if(!length){return -1;}var index=length-1;if(fromIndex!==undefined$1){index=toInteger(fromIndex);index=fromIndex<0?nativeMax(length+index,0):nativeMin(index,length-1);}return baseFindIndex(array,getIteratee(predicate,3),index,true);}/**
    	     * Flattens `array` a single level deep.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.1.0
    	     * @category Array
    	     * @param {Array} array The array to flatten.
    	     * @returns {Array} Returns the new flattened array.
    	     * @example
    	     *
    	     * _.flatten([1, [2, [3, [4]], 5]]);
    	     * // => [1, 2, [3, [4]], 5]
    	     */function flatten(array){var length=array==null?0:array.length;return length?baseFlatten(array,1):[];}/**
    	     * Recursively flattens `array`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 3.0.0
    	     * @category Array
    	     * @param {Array} array The array to flatten.
    	     * @returns {Array} Returns the new flattened array.
    	     * @example
    	     *
    	     * _.flattenDeep([1, [2, [3, [4]], 5]]);
    	     * // => [1, 2, 3, 4, 5]
    	     */function flattenDeep(array){var length=array==null?0:array.length;return length?baseFlatten(array,INFINITY):[];}/**
    	     * Recursively flatten `array` up to `depth` times.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.4.0
    	     * @category Array
    	     * @param {Array} array The array to flatten.
    	     * @param {number} [depth=1] The maximum recursion depth.
    	     * @returns {Array} Returns the new flattened array.
    	     * @example
    	     *
    	     * var array = [1, [2, [3, [4]], 5]];
    	     *
    	     * _.flattenDepth(array, 1);
    	     * // => [1, 2, [3, [4]], 5]
    	     *
    	     * _.flattenDepth(array, 2);
    	     * // => [1, 2, 3, [4], 5]
    	     */function flattenDepth(array,depth){var length=array==null?0:array.length;if(!length){return [];}depth=depth===undefined$1?1:toInteger(depth);return baseFlatten(array,depth);}/**
    	     * The inverse of `_.toPairs`; this method returns an object composed
    	     * from key-value `pairs`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Array
    	     * @param {Array} pairs The key-value pairs.
    	     * @returns {Object} Returns the new object.
    	     * @example
    	     *
    	     * _.fromPairs([['a', 1], ['b', 2]]);
    	     * // => { 'a': 1, 'b': 2 }
    	     */function fromPairs(pairs){var index=-1,length=pairs==null?0:pairs.length,result={};while(++index<length){var pair=pairs[index];result[pair[0]]=pair[1];}return result;}/**
    	     * Gets the first element of `array`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.1.0
    	     * @alias first
    	     * @category Array
    	     * @param {Array} array The array to query.
    	     * @returns {*} Returns the first element of `array`.
    	     * @example
    	     *
    	     * _.head([1, 2, 3]);
    	     * // => 1
    	     *
    	     * _.head([]);
    	     * // => undefined
    	     */function head(array){return array&&array.length?array[0]:undefined$1;}/**
    	     * Gets the index at which the first occurrence of `value` is found in `array`
    	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
    	     * for equality comparisons. If `fromIndex` is negative, it's used as the
    	     * offset from the end of `array`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.1.0
    	     * @category Array
    	     * @param {Array} array The array to inspect.
    	     * @param {*} value The value to search for.
    	     * @param {number} [fromIndex=0] The index to search from.
    	     * @returns {number} Returns the index of the matched value, else `-1`.
    	     * @example
    	     *
    	     * _.indexOf([1, 2, 1, 2], 2);
    	     * // => 1
    	     *
    	     * // Search from the `fromIndex`.
    	     * _.indexOf([1, 2, 1, 2], 2, 2);
    	     * // => 3
    	     */function indexOf(array,value,fromIndex){var length=array==null?0:array.length;if(!length){return -1;}var index=fromIndex==null?0:toInteger(fromIndex);if(index<0){index=nativeMax(length+index,0);}return baseIndexOf(array,value,index);}/**
    	     * Gets all but the last element of `array`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.1.0
    	     * @category Array
    	     * @param {Array} array The array to query.
    	     * @returns {Array} Returns the slice of `array`.
    	     * @example
    	     *
    	     * _.initial([1, 2, 3]);
    	     * // => [1, 2]
    	     */function initial(array){var length=array==null?0:array.length;return length?baseSlice(array,0,-1):[];}/**
    	     * Creates an array of unique values that are included in all given arrays
    	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
    	     * for equality comparisons. The order and references of result values are
    	     * determined by the first array.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.1.0
    	     * @category Array
    	     * @param {...Array} [arrays] The arrays to inspect.
    	     * @returns {Array} Returns the new array of intersecting values.
    	     * @example
    	     *
    	     * _.intersection([2, 1], [2, 3]);
    	     * // => [2]
    	     */var intersection=baseRest(function(arrays){var mapped=arrayMap(arrays,castArrayLikeObject);return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped):[];});/**
    	     * This method is like `_.intersection` except that it accepts `iteratee`
    	     * which is invoked for each element of each `arrays` to generate the criterion
    	     * by which they're compared. The order and references of result values are
    	     * determined by the first array. The iteratee is invoked with one argument:
    	     * (value).
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Array
    	     * @param {...Array} [arrays] The arrays to inspect.
    	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
    	     * @returns {Array} Returns the new array of intersecting values.
    	     * @example
    	     *
    	     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
    	     * // => [2.1]
    	     *
    	     * // The `_.property` iteratee shorthand.
    	     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
    	     * // => [{ 'x': 1 }]
    	     */var intersectionBy=baseRest(function(arrays){var iteratee=last(arrays),mapped=arrayMap(arrays,castArrayLikeObject);if(iteratee===last(mapped)){iteratee=undefined$1;}else {mapped.pop();}return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped,getIteratee(iteratee,2)):[];});/**
    	     * This method is like `_.intersection` except that it accepts `comparator`
    	     * which is invoked to compare elements of `arrays`. The order and references
    	     * of result values are determined by the first array. The comparator is
    	     * invoked with two arguments: (arrVal, othVal).
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Array
    	     * @param {...Array} [arrays] The arrays to inspect.
    	     * @param {Function} [comparator] The comparator invoked per element.
    	     * @returns {Array} Returns the new array of intersecting values.
    	     * @example
    	     *
    	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
    	     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
    	     *
    	     * _.intersectionWith(objects, others, _.isEqual);
    	     * // => [{ 'x': 1, 'y': 2 }]
    	     */var intersectionWith=baseRest(function(arrays){var comparator=last(arrays),mapped=arrayMap(arrays,castArrayLikeObject);comparator=typeof comparator=='function'?comparator:undefined$1;if(comparator){mapped.pop();}return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped,undefined$1,comparator):[];});/**
    	     * Converts all elements in `array` into a string separated by `separator`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Array
    	     * @param {Array} array The array to convert.
    	     * @param {string} [separator=','] The element separator.
    	     * @returns {string} Returns the joined string.
    	     * @example
    	     *
    	     * _.join(['a', 'b', 'c'], '~');
    	     * // => 'a~b~c'
    	     */function join(array,separator){return array==null?'':nativeJoin.call(array,separator);}/**
    	     * Gets the last element of `array`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.1.0
    	     * @category Array
    	     * @param {Array} array The array to query.
    	     * @returns {*} Returns the last element of `array`.
    	     * @example
    	     *
    	     * _.last([1, 2, 3]);
    	     * // => 3
    	     */function last(array){var length=array==null?0:array.length;return length?array[length-1]:undefined$1;}/**
    	     * This method is like `_.indexOf` except that it iterates over elements of
    	     * `array` from right to left.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.1.0
    	     * @category Array
    	     * @param {Array} array The array to inspect.
    	     * @param {*} value The value to search for.
    	     * @param {number} [fromIndex=array.length-1] The index to search from.
    	     * @returns {number} Returns the index of the matched value, else `-1`.
    	     * @example
    	     *
    	     * _.lastIndexOf([1, 2, 1, 2], 2);
    	     * // => 3
    	     *
    	     * // Search from the `fromIndex`.
    	     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
    	     * // => 1
    	     */function lastIndexOf(array,value,fromIndex){var length=array==null?0:array.length;if(!length){return -1;}var index=length;if(fromIndex!==undefined$1){index=toInteger(fromIndex);index=index<0?nativeMax(length+index,0):nativeMin(index,length-1);}return value===value?strictLastIndexOf(array,value,index):baseFindIndex(array,baseIsNaN,index,true);}/**
    	     * Gets the element at index `n` of `array`. If `n` is negative, the nth
    	     * element from the end is returned.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.11.0
    	     * @category Array
    	     * @param {Array} array The array to query.
    	     * @param {number} [n=0] The index of the element to return.
    	     * @returns {*} Returns the nth element of `array`.
    	     * @example
    	     *
    	     * var array = ['a', 'b', 'c', 'd'];
    	     *
    	     * _.nth(array, 1);
    	     * // => 'b'
    	     *
    	     * _.nth(array, -2);
    	     * // => 'c';
    	     */function nth(array,n){return array&&array.length?baseNth(array,toInteger(n)):undefined$1;}/**
    	     * Removes all given values from `array` using
    	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
    	     * for equality comparisons.
    	     *
    	     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
    	     * to remove elements from an array by predicate.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 2.0.0
    	     * @category Array
    	     * @param {Array} array The array to modify.
    	     * @param {...*} [values] The values to remove.
    	     * @returns {Array} Returns `array`.
    	     * @example
    	     *
    	     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
    	     *
    	     * _.pull(array, 'a', 'c');
    	     * console.log(array);
    	     * // => ['b', 'b']
    	     */var pull=baseRest(pullAll);/**
    	     * This method is like `_.pull` except that it accepts an array of values to remove.
    	     *
    	     * **Note:** Unlike `_.difference`, this method mutates `array`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Array
    	     * @param {Array} array The array to modify.
    	     * @param {Array} values The values to remove.
    	     * @returns {Array} Returns `array`.
    	     * @example
    	     *
    	     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
    	     *
    	     * _.pullAll(array, ['a', 'c']);
    	     * console.log(array);
    	     * // => ['b', 'b']
    	     */function pullAll(array,values){return array&&array.length&&values&&values.length?basePullAll(array,values):array;}/**
    	     * This method is like `_.pullAll` except that it accepts `iteratee` which is
    	     * invoked for each element of `array` and `values` to generate the criterion
    	     * by which they're compared. The iteratee is invoked with one argument: (value).
    	     *
    	     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Array
    	     * @param {Array} array The array to modify.
    	     * @param {Array} values The values to remove.
    	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
    	     * @returns {Array} Returns `array`.
    	     * @example
    	     *
    	     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
    	     *
    	     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
    	     * console.log(array);
    	     * // => [{ 'x': 2 }]
    	     */function pullAllBy(array,values,iteratee){return array&&array.length&&values&&values.length?basePullAll(array,values,getIteratee(iteratee,2)):array;}/**
    	     * This method is like `_.pullAll` except that it accepts `comparator` which
    	     * is invoked to compare elements of `array` to `values`. The comparator is
    	     * invoked with two arguments: (arrVal, othVal).
    	     *
    	     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.6.0
    	     * @category Array
    	     * @param {Array} array The array to modify.
    	     * @param {Array} values The values to remove.
    	     * @param {Function} [comparator] The comparator invoked per element.
    	     * @returns {Array} Returns `array`.
    	     * @example
    	     *
    	     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
    	     *
    	     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
    	     * console.log(array);
    	     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
    	     */function pullAllWith(array,values,comparator){return array&&array.length&&values&&values.length?basePullAll(array,values,undefined$1,comparator):array;}/**
    	     * Removes elements from `array` corresponding to `indexes` and returns an
    	     * array of removed elements.
    	     *
    	     * **Note:** Unlike `_.at`, this method mutates `array`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 3.0.0
    	     * @category Array
    	     * @param {Array} array The array to modify.
    	     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
    	     * @returns {Array} Returns the new array of removed elements.
    	     * @example
    	     *
    	     * var array = ['a', 'b', 'c', 'd'];
    	     * var pulled = _.pullAt(array, [1, 3]);
    	     *
    	     * console.log(array);
    	     * // => ['a', 'c']
    	     *
    	     * console.log(pulled);
    	     * // => ['b', 'd']
    	     */var pullAt=flatRest(function(array,indexes){var length=array==null?0:array.length,result=baseAt(array,indexes);basePullAt(array,arrayMap(indexes,function(index){return isIndex(index,length)?+index:index;}).sort(compareAscending));return result;});/**
    	     * Removes all elements from `array` that `predicate` returns truthy for
    	     * and returns an array of the removed elements. The predicate is invoked
    	     * with three arguments: (value, index, array).
    	     *
    	     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
    	     * to pull elements from an array by value.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 2.0.0
    	     * @category Array
    	     * @param {Array} array The array to modify.
    	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
    	     * @returns {Array} Returns the new array of removed elements.
    	     * @example
    	     *
    	     * var array = [1, 2, 3, 4];
    	     * var evens = _.remove(array, function(n) {
    	     *   return n % 2 == 0;
    	     * });
    	     *
    	     * console.log(array);
    	     * // => [1, 3]
    	     *
    	     * console.log(evens);
    	     * // => [2, 4]
    	     */function remove(array,predicate){var result=[];if(!(array&&array.length)){return result;}var index=-1,indexes=[],length=array.length;predicate=getIteratee(predicate,3);while(++index<length){var value=array[index];if(predicate(value,index,array)){result.push(value);indexes.push(index);}}basePullAt(array,indexes);return result;}/**
    	     * Reverses `array` so that the first element becomes the last, the second
    	     * element becomes the second to last, and so on.
    	     *
    	     * **Note:** This method mutates `array` and is based on
    	     * [`Array#reverse`](https://mdn.io/Array/reverse).
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Array
    	     * @param {Array} array The array to modify.
    	     * @returns {Array} Returns `array`.
    	     * @example
    	     *
    	     * var array = [1, 2, 3];
    	     *
    	     * _.reverse(array);
    	     * // => [3, 2, 1]
    	     *
    	     * console.log(array);
    	     * // => [3, 2, 1]
    	     */function reverse(array){return array==null?array:nativeReverse.call(array);}/**
    	     * Creates a slice of `array` from `start` up to, but not including, `end`.
    	     *
    	     * **Note:** This method is used instead of
    	     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
    	     * returned.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 3.0.0
    	     * @category Array
    	     * @param {Array} array The array to slice.
    	     * @param {number} [start=0] The start position.
    	     * @param {number} [end=array.length] The end position.
    	     * @returns {Array} Returns the slice of `array`.
    	     */function slice(array,start,end){var length=array==null?0:array.length;if(!length){return [];}if(end&&typeof end!='number'&&isIterateeCall(array,start,end)){start=0;end=length;}else {start=start==null?0:toInteger(start);end=end===undefined$1?length:toInteger(end);}return baseSlice(array,start,end);}/**
    	     * Uses a binary search to determine the lowest index at which `value`
    	     * should be inserted into `array` in order to maintain its sort order.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.1.0
    	     * @category Array
    	     * @param {Array} array The sorted array to inspect.
    	     * @param {*} value The value to evaluate.
    	     * @returns {number} Returns the index at which `value` should be inserted
    	     *  into `array`.
    	     * @example
    	     *
    	     * _.sortedIndex([30, 50], 40);
    	     * // => 1
    	     */function sortedIndex(array,value){return baseSortedIndex(array,value);}/**
    	     * This method is like `_.sortedIndex` except that it accepts `iteratee`
    	     * which is invoked for `value` and each element of `array` to compute their
    	     * sort ranking. The iteratee is invoked with one argument: (value).
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Array
    	     * @param {Array} array The sorted array to inspect.
    	     * @param {*} value The value to evaluate.
    	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
    	     * @returns {number} Returns the index at which `value` should be inserted
    	     *  into `array`.
    	     * @example
    	     *
    	     * var objects = [{ 'x': 4 }, { 'x': 5 }];
    	     *
    	     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
    	     * // => 0
    	     *
    	     * // The `_.property` iteratee shorthand.
    	     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
    	     * // => 0
    	     */function sortedIndexBy(array,value,iteratee){return baseSortedIndexBy(array,value,getIteratee(iteratee,2));}/**
    	     * This method is like `_.indexOf` except that it performs a binary
    	     * search on a sorted `array`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Array
    	     * @param {Array} array The array to inspect.
    	     * @param {*} value The value to search for.
    	     * @returns {number} Returns the index of the matched value, else `-1`.
    	     * @example
    	     *
    	     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
    	     * // => 1
    	     */function sortedIndexOf(array,value){var length=array==null?0:array.length;if(length){var index=baseSortedIndex(array,value);if(index<length&&eq(array[index],value)){return index;}}return -1;}/**
    	     * This method is like `_.sortedIndex` except that it returns the highest
    	     * index at which `value` should be inserted into `array` in order to
    	     * maintain its sort order.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 3.0.0
    	     * @category Array
    	     * @param {Array} array The sorted array to inspect.
    	     * @param {*} value The value to evaluate.
    	     * @returns {number} Returns the index at which `value` should be inserted
    	     *  into `array`.
    	     * @example
    	     *
    	     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
    	     * // => 4
    	     */function sortedLastIndex(array,value){return baseSortedIndex(array,value,true);}/**
    	     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
    	     * which is invoked for `value` and each element of `array` to compute their
    	     * sort ranking. The iteratee is invoked with one argument: (value).
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Array
    	     * @param {Array} array The sorted array to inspect.
    	     * @param {*} value The value to evaluate.
    	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
    	     * @returns {number} Returns the index at which `value` should be inserted
    	     *  into `array`.
    	     * @example
    	     *
    	     * var objects = [{ 'x': 4 }, { 'x': 5 }];
    	     *
    	     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
    	     * // => 1
    	     *
    	     * // The `_.property` iteratee shorthand.
    	     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
    	     * // => 1
    	     */function sortedLastIndexBy(array,value,iteratee){return baseSortedIndexBy(array,value,getIteratee(iteratee,2),true);}/**
    	     * This method is like `_.lastIndexOf` except that it performs a binary
    	     * search on a sorted `array`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Array
    	     * @param {Array} array The array to inspect.
    	     * @param {*} value The value to search for.
    	     * @returns {number} Returns the index of the matched value, else `-1`.
    	     * @example
    	     *
    	     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
    	     * // => 3
    	     */function sortedLastIndexOf(array,value){var length=array==null?0:array.length;if(length){var index=baseSortedIndex(array,value,true)-1;if(eq(array[index],value)){return index;}}return -1;}/**
    	     * This method is like `_.uniq` except that it's designed and optimized
    	     * for sorted arrays.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Array
    	     * @param {Array} array The array to inspect.
    	     * @returns {Array} Returns the new duplicate free array.
    	     * @example
    	     *
    	     * _.sortedUniq([1, 1, 2]);
    	     * // => [1, 2]
    	     */function sortedUniq(array){return array&&array.length?baseSortedUniq(array):[];}/**
    	     * This method is like `_.uniqBy` except that it's designed and optimized
    	     * for sorted arrays.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Array
    	     * @param {Array} array The array to inspect.
    	     * @param {Function} [iteratee] The iteratee invoked per element.
    	     * @returns {Array} Returns the new duplicate free array.
    	     * @example
    	     *
    	     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
    	     * // => [1.1, 2.3]
    	     */function sortedUniqBy(array,iteratee){return array&&array.length?baseSortedUniq(array,getIteratee(iteratee,2)):[];}/**
    	     * Gets all but the first element of `array`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Array
    	     * @param {Array} array The array to query.
    	     * @returns {Array} Returns the slice of `array`.
    	     * @example
    	     *
    	     * _.tail([1, 2, 3]);
    	     * // => [2, 3]
    	     */function tail(array){var length=array==null?0:array.length;return length?baseSlice(array,1,length):[];}/**
    	     * Creates a slice of `array` with `n` elements taken from the beginning.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.1.0
    	     * @category Array
    	     * @param {Array} array The array to query.
    	     * @param {number} [n=1] The number of elements to take.
    	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
    	     * @returns {Array} Returns the slice of `array`.
    	     * @example
    	     *
    	     * _.take([1, 2, 3]);
    	     * // => [1]
    	     *
    	     * _.take([1, 2, 3], 2);
    	     * // => [1, 2]
    	     *
    	     * _.take([1, 2, 3], 5);
    	     * // => [1, 2, 3]
    	     *
    	     * _.take([1, 2, 3], 0);
    	     * // => []
    	     */function take(array,n,guard){if(!(array&&array.length)){return [];}n=guard||n===undefined$1?1:toInteger(n);return baseSlice(array,0,n<0?0:n);}/**
    	     * Creates a slice of `array` with `n` elements taken from the end.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 3.0.0
    	     * @category Array
    	     * @param {Array} array The array to query.
    	     * @param {number} [n=1] The number of elements to take.
    	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
    	     * @returns {Array} Returns the slice of `array`.
    	     * @example
    	     *
    	     * _.takeRight([1, 2, 3]);
    	     * // => [3]
    	     *
    	     * _.takeRight([1, 2, 3], 2);
    	     * // => [2, 3]
    	     *
    	     * _.takeRight([1, 2, 3], 5);
    	     * // => [1, 2, 3]
    	     *
    	     * _.takeRight([1, 2, 3], 0);
    	     * // => []
    	     */function takeRight(array,n,guard){var length=array==null?0:array.length;if(!length){return [];}n=guard||n===undefined$1?1:toInteger(n);n=length-n;return baseSlice(array,n<0?0:n,length);}/**
    	     * Creates a slice of `array` with elements taken from the end. Elements are
    	     * taken until `predicate` returns falsey. The predicate is invoked with
    	     * three arguments: (value, index, array).
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 3.0.0
    	     * @category Array
    	     * @param {Array} array The array to query.
    	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
    	     * @returns {Array} Returns the slice of `array`.
    	     * @example
    	     *
    	     * var users = [
    	     *   { 'user': 'barney',  'active': true },
    	     *   { 'user': 'fred',    'active': false },
    	     *   { 'user': 'pebbles', 'active': false }
    	     * ];
    	     *
    	     * _.takeRightWhile(users, function(o) { return !o.active; });
    	     * // => objects for ['fred', 'pebbles']
    	     *
    	     * // The `_.matches` iteratee shorthand.
    	     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
    	     * // => objects for ['pebbles']
    	     *
    	     * // The `_.matchesProperty` iteratee shorthand.
    	     * _.takeRightWhile(users, ['active', false]);
    	     * // => objects for ['fred', 'pebbles']
    	     *
    	     * // The `_.property` iteratee shorthand.
    	     * _.takeRightWhile(users, 'active');
    	     * // => []
    	     */function takeRightWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),false,true):[];}/**
    	     * Creates a slice of `array` with elements taken from the beginning. Elements
    	     * are taken until `predicate` returns falsey. The predicate is invoked with
    	     * three arguments: (value, index, array).
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 3.0.0
    	     * @category Array
    	     * @param {Array} array The array to query.
    	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
    	     * @returns {Array} Returns the slice of `array`.
    	     * @example
    	     *
    	     * var users = [
    	     *   { 'user': 'barney',  'active': false },
    	     *   { 'user': 'fred',    'active': false },
    	     *   { 'user': 'pebbles', 'active': true }
    	     * ];
    	     *
    	     * _.takeWhile(users, function(o) { return !o.active; });
    	     * // => objects for ['barney', 'fred']
    	     *
    	     * // The `_.matches` iteratee shorthand.
    	     * _.takeWhile(users, { 'user': 'barney', 'active': false });
    	     * // => objects for ['barney']
    	     *
    	     * // The `_.matchesProperty` iteratee shorthand.
    	     * _.takeWhile(users, ['active', false]);
    	     * // => objects for ['barney', 'fred']
    	     *
    	     * // The `_.property` iteratee shorthand.
    	     * _.takeWhile(users, 'active');
    	     * // => []
    	     */function takeWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3)):[];}/**
    	     * Creates an array of unique values, in order, from all given arrays using
    	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
    	     * for equality comparisons.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.1.0
    	     * @category Array
    	     * @param {...Array} [arrays] The arrays to inspect.
    	     * @returns {Array} Returns the new array of combined values.
    	     * @example
    	     *
    	     * _.union([2], [1, 2]);
    	     * // => [2, 1]
    	     */var union=baseRest(function(arrays){return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true));});/**
    	     * This method is like `_.union` except that it accepts `iteratee` which is
    	     * invoked for each element of each `arrays` to generate the criterion by
    	     * which uniqueness is computed. Result values are chosen from the first
    	     * array in which the value occurs. The iteratee is invoked with one argument:
    	     * (value).
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Array
    	     * @param {...Array} [arrays] The arrays to inspect.
    	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
    	     * @returns {Array} Returns the new array of combined values.
    	     * @example
    	     *
    	     * _.unionBy([2.1], [1.2, 2.3], Math.floor);
    	     * // => [2.1, 1.2]
    	     *
    	     * // The `_.property` iteratee shorthand.
    	     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
    	     * // => [{ 'x': 1 }, { 'x': 2 }]
    	     */var unionBy=baseRest(function(arrays){var iteratee=last(arrays);if(isArrayLikeObject(iteratee)){iteratee=undefined$1;}return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true),getIteratee(iteratee,2));});/**
    	     * This method is like `_.union` except that it accepts `comparator` which
    	     * is invoked to compare elements of `arrays`. Result values are chosen from
    	     * the first array in which the value occurs. The comparator is invoked
    	     * with two arguments: (arrVal, othVal).
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Array
    	     * @param {...Array} [arrays] The arrays to inspect.
    	     * @param {Function} [comparator] The comparator invoked per element.
    	     * @returns {Array} Returns the new array of combined values.
    	     * @example
    	     *
    	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
    	     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
    	     *
    	     * _.unionWith(objects, others, _.isEqual);
    	     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
    	     */var unionWith=baseRest(function(arrays){var comparator=last(arrays);comparator=typeof comparator=='function'?comparator:undefined$1;return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true),undefined$1,comparator);});/**
    	     * Creates a duplicate-free version of an array, using
    	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
    	     * for equality comparisons, in which only the first occurrence of each element
    	     * is kept. The order of result values is determined by the order they occur
    	     * in the array.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.1.0
    	     * @category Array
    	     * @param {Array} array The array to inspect.
    	     * @returns {Array} Returns the new duplicate free array.
    	     * @example
    	     *
    	     * _.uniq([2, 1, 2]);
    	     * // => [2, 1]
    	     */function uniq(array){return array&&array.length?baseUniq(array):[];}/**
    	     * This method is like `_.uniq` except that it accepts `iteratee` which is
    	     * invoked for each element in `array` to generate the criterion by which
    	     * uniqueness is computed. The order of result values is determined by the
    	     * order they occur in the array. The iteratee is invoked with one argument:
    	     * (value).
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Array
    	     * @param {Array} array The array to inspect.
    	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
    	     * @returns {Array} Returns the new duplicate free array.
    	     * @example
    	     *
    	     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
    	     * // => [2.1, 1.2]
    	     *
    	     * // The `_.property` iteratee shorthand.
    	     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
    	     * // => [{ 'x': 1 }, { 'x': 2 }]
    	     */function uniqBy(array,iteratee){return array&&array.length?baseUniq(array,getIteratee(iteratee,2)):[];}/**
    	     * This method is like `_.uniq` except that it accepts `comparator` which
    	     * is invoked to compare elements of `array`. The order of result values is
    	     * determined by the order they occur in the array.The comparator is invoked
    	     * with two arguments: (arrVal, othVal).
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Array
    	     * @param {Array} array The array to inspect.
    	     * @param {Function} [comparator] The comparator invoked per element.
    	     * @returns {Array} Returns the new duplicate free array.
    	     * @example
    	     *
    	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
    	     *
    	     * _.uniqWith(objects, _.isEqual);
    	     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
    	     */function uniqWith(array,comparator){comparator=typeof comparator=='function'?comparator:undefined$1;return array&&array.length?baseUniq(array,undefined$1,comparator):[];}/**
    	     * This method is like `_.zip` except that it accepts an array of grouped
    	     * elements and creates an array regrouping the elements to their pre-zip
    	     * configuration.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 1.2.0
    	     * @category Array
    	     * @param {Array} array The array of grouped elements to process.
    	     * @returns {Array} Returns the new array of regrouped elements.
    	     * @example
    	     *
    	     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
    	     * // => [['a', 1, true], ['b', 2, false]]
    	     *
    	     * _.unzip(zipped);
    	     * // => [['a', 'b'], [1, 2], [true, false]]
    	     */function unzip(array){if(!(array&&array.length)){return [];}var length=0;array=arrayFilter(array,function(group){if(isArrayLikeObject(group)){length=nativeMax(group.length,length);return true;}});return baseTimes(length,function(index){return arrayMap(array,baseProperty(index));});}/**
    	     * This method is like `_.unzip` except that it accepts `iteratee` to specify
    	     * how regrouped values should be combined. The iteratee is invoked with the
    	     * elements of each group: (...group).
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 3.8.0
    	     * @category Array
    	     * @param {Array} array The array of grouped elements to process.
    	     * @param {Function} [iteratee=_.identity] The function to combine
    	     *  regrouped values.
    	     * @returns {Array} Returns the new array of regrouped elements.
    	     * @example
    	     *
    	     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
    	     * // => [[1, 10, 100], [2, 20, 200]]
    	     *
    	     * _.unzipWith(zipped, _.add);
    	     * // => [3, 30, 300]
    	     */function unzipWith(array,iteratee){if(!(array&&array.length)){return [];}var result=unzip(array);if(iteratee==null){return result;}return arrayMap(result,function(group){return apply(iteratee,undefined$1,group);});}/**
    	     * Creates an array excluding all given values using
    	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
    	     * for equality comparisons.
    	     *
    	     * **Note:** Unlike `_.pull`, this method returns a new array.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.1.0
    	     * @category Array
    	     * @param {Array} array The array to inspect.
    	     * @param {...*} [values] The values to exclude.
    	     * @returns {Array} Returns the new array of filtered values.
    	     * @see _.difference, _.xor
    	     * @example
    	     *
    	     * _.without([2, 1, 2, 3], 1, 2);
    	     * // => [3]
    	     */var without=baseRest(function(array,values){return isArrayLikeObject(array)?baseDifference(array,values):[];});/**
    	     * Creates an array of unique values that is the
    	     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
    	     * of the given arrays. The order of result values is determined by the order
    	     * they occur in the arrays.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 2.4.0
    	     * @category Array
    	     * @param {...Array} [arrays] The arrays to inspect.
    	     * @returns {Array} Returns the new array of filtered values.
    	     * @see _.difference, _.without
    	     * @example
    	     *
    	     * _.xor([2, 1], [2, 3]);
    	     * // => [1, 3]
    	     */var xor=baseRest(function(arrays){return baseXor(arrayFilter(arrays,isArrayLikeObject));});/**
    	     * This method is like `_.xor` except that it accepts `iteratee` which is
    	     * invoked for each element of each `arrays` to generate the criterion by
    	     * which by which they're compared. The order of result values is determined
    	     * by the order they occur in the arrays. The iteratee is invoked with one
    	     * argument: (value).
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Array
    	     * @param {...Array} [arrays] The arrays to inspect.
    	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
    	     * @returns {Array} Returns the new array of filtered values.
    	     * @example
    	     *
    	     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
    	     * // => [1.2, 3.4]
    	     *
    	     * // The `_.property` iteratee shorthand.
    	     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
    	     * // => [{ 'x': 2 }]
    	     */var xorBy=baseRest(function(arrays){var iteratee=last(arrays);if(isArrayLikeObject(iteratee)){iteratee=undefined$1;}return baseXor(arrayFilter(arrays,isArrayLikeObject),getIteratee(iteratee,2));});/**
    	     * This method is like `_.xor` except that it accepts `comparator` which is
    	     * invoked to compare elements of `arrays`. The order of result values is
    	     * determined by the order they occur in the arrays. The comparator is invoked
    	     * with two arguments: (arrVal, othVal).
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Array
    	     * @param {...Array} [arrays] The arrays to inspect.
    	     * @param {Function} [comparator] The comparator invoked per element.
    	     * @returns {Array} Returns the new array of filtered values.
    	     * @example
    	     *
    	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
    	     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
    	     *
    	     * _.xorWith(objects, others, _.isEqual);
    	     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
    	     */var xorWith=baseRest(function(arrays){var comparator=last(arrays);comparator=typeof comparator=='function'?comparator:undefined$1;return baseXor(arrayFilter(arrays,isArrayLikeObject),undefined$1,comparator);});/**
    	     * Creates an array of grouped elements, the first of which contains the
    	     * first elements of the given arrays, the second of which contains the
    	     * second elements of the given arrays, and so on.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.1.0
    	     * @category Array
    	     * @param {...Array} [arrays] The arrays to process.
    	     * @returns {Array} Returns the new array of grouped elements.
    	     * @example
    	     *
    	     * _.zip(['a', 'b'], [1, 2], [true, false]);
    	     * // => [['a', 1, true], ['b', 2, false]]
    	     */var zip=baseRest(unzip);/**
    	     * This method is like `_.fromPairs` except that it accepts two arrays,
    	     * one of property identifiers and one of corresponding values.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.4.0
    	     * @category Array
    	     * @param {Array} [props=[]] The property identifiers.
    	     * @param {Array} [values=[]] The property values.
    	     * @returns {Object} Returns the new object.
    	     * @example
    	     *
    	     * _.zipObject(['a', 'b'], [1, 2]);
    	     * // => { 'a': 1, 'b': 2 }
    	     */function zipObject(props,values){return baseZipObject(props||[],values||[],assignValue);}/**
    	     * This method is like `_.zipObject` except that it supports property paths.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.1.0
    	     * @category Array
    	     * @param {Array} [props=[]] The property identifiers.
    	     * @param {Array} [values=[]] The property values.
    	     * @returns {Object} Returns the new object.
    	     * @example
    	     *
    	     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
    	     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
    	     */function zipObjectDeep(props,values){return baseZipObject(props||[],values||[],baseSet);}/**
    	     * This method is like `_.zip` except that it accepts `iteratee` to specify
    	     * how grouped values should be combined. The iteratee is invoked with the
    	     * elements of each group: (...group).
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 3.8.0
    	     * @category Array
    	     * @param {...Array} [arrays] The arrays to process.
    	     * @param {Function} [iteratee=_.identity] The function to combine
    	     *  grouped values.
    	     * @returns {Array} Returns the new array of grouped elements.
    	     * @example
    	     *
    	     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
    	     *   return a + b + c;
    	     * });
    	     * // => [111, 222]
    	     */var zipWith=baseRest(function(arrays){var length=arrays.length,iteratee=length>1?arrays[length-1]:undefined$1;iteratee=typeof iteratee=='function'?(arrays.pop(),iteratee):undefined$1;return unzipWith(arrays,iteratee);});/*------------------------------------------------------------------------*/ /**
    	     * Creates a `lodash` wrapper instance that wraps `value` with explicit method
    	     * chain sequences enabled. The result of such sequences must be unwrapped
    	     * with `_#value`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 1.3.0
    	     * @category Seq
    	     * @param {*} value The value to wrap.
    	     * @returns {Object} Returns the new `lodash` wrapper instance.
    	     * @example
    	     *
    	     * var users = [
    	     *   { 'user': 'barney',  'age': 36 },
    	     *   { 'user': 'fred',    'age': 40 },
    	     *   { 'user': 'pebbles', 'age': 1 }
    	     * ];
    	     *
    	     * var youngest = _
    	     *   .chain(users)
    	     *   .sortBy('age')
    	     *   .map(function(o) {
    	     *     return o.user + ' is ' + o.age;
    	     *   })
    	     *   .head()
    	     *   .value();
    	     * // => 'pebbles is 1'
    	     */function chain(value){var result=lodash(value);result.__chain__=true;return result;}/**
    	     * This method invokes `interceptor` and returns `value`. The interceptor
    	     * is invoked with one argument; (value). The purpose of this method is to
    	     * "tap into" a method chain sequence in order to modify intermediate results.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.1.0
    	     * @category Seq
    	     * @param {*} value The value to provide to `interceptor`.
    	     * @param {Function} interceptor The function to invoke.
    	     * @returns {*} Returns `value`.
    	     * @example
    	     *
    	     * _([1, 2, 3])
    	     *  .tap(function(array) {
    	     *    // Mutate input array.
    	     *    array.pop();
    	     *  })
    	     *  .reverse()
    	     *  .value();
    	     * // => [2, 1]
    	     */function tap(value,interceptor){interceptor(value);return value;}/**
    	     * This method is like `_.tap` except that it returns the result of `interceptor`.
    	     * The purpose of this method is to "pass thru" values replacing intermediate
    	     * results in a method chain sequence.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 3.0.0
    	     * @category Seq
    	     * @param {*} value The value to provide to `interceptor`.
    	     * @param {Function} interceptor The function to invoke.
    	     * @returns {*} Returns the result of `interceptor`.
    	     * @example
    	     *
    	     * _('  abc  ')
    	     *  .chain()
    	     *  .trim()
    	     *  .thru(function(value) {
    	     *    return [value];
    	     *  })
    	     *  .value();
    	     * // => ['abc']
    	     */function thru(value,interceptor){return interceptor(value);}/**
    	     * This method is the wrapper version of `_.at`.
    	     *
    	     * @name at
    	     * @memberOf _
    	     * @since 1.0.0
    	     * @category Seq
    	     * @param {...(string|string[])} [paths] The property paths to pick.
    	     * @returns {Object} Returns the new `lodash` wrapper instance.
    	     * @example
    	     *
    	     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
    	     *
    	     * _(object).at(['a[0].b.c', 'a[1]']).value();
    	     * // => [3, 4]
    	     */var wrapperAt=flatRest(function(paths){var length=paths.length,start=length?paths[0]:0,value=this.__wrapped__,interceptor=function(object){return baseAt(object,paths);};if(length>1||this.__actions__.length||!(value instanceof LazyWrapper)||!isIndex(start)){return this.thru(interceptor);}value=value.slice(start,+start+(length?1:0));value.__actions__.push({'func':thru,'args':[interceptor],'thisArg':undefined$1});return new LodashWrapper(value,this.__chain__).thru(function(array){if(length&&!array.length){array.push(undefined$1);}return array;});});/**
    	     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
    	     *
    	     * @name chain
    	     * @memberOf _
    	     * @since 0.1.0
    	     * @category Seq
    	     * @returns {Object} Returns the new `lodash` wrapper instance.
    	     * @example
    	     *
    	     * var users = [
    	     *   { 'user': 'barney', 'age': 36 },
    	     *   { 'user': 'fred',   'age': 40 }
    	     * ];
    	     *
    	     * // A sequence without explicit chaining.
    	     * _(users).head();
    	     * // => { 'user': 'barney', 'age': 36 }
    	     *
    	     * // A sequence with explicit chaining.
    	     * _(users)
    	     *   .chain()
    	     *   .head()
    	     *   .pick('user')
    	     *   .value();
    	     * // => { 'user': 'barney' }
    	     */function wrapperChain(){return chain(this);}/**
    	     * Executes the chain sequence and returns the wrapped result.
    	     *
    	     * @name commit
    	     * @memberOf _
    	     * @since 3.2.0
    	     * @category Seq
    	     * @returns {Object} Returns the new `lodash` wrapper instance.
    	     * @example
    	     *
    	     * var array = [1, 2];
    	     * var wrapped = _(array).push(3);
    	     *
    	     * console.log(array);
    	     * // => [1, 2]
    	     *
    	     * wrapped = wrapped.commit();
    	     * console.log(array);
    	     * // => [1, 2, 3]
    	     *
    	     * wrapped.last();
    	     * // => 3
    	     *
    	     * console.log(array);
    	     * // => [1, 2, 3]
    	     */function wrapperCommit(){return new LodashWrapper(this.value(),this.__chain__);}/**
    	     * Gets the next value on a wrapped object following the
    	     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
    	     *
    	     * @name next
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Seq
    	     * @returns {Object} Returns the next iterator value.
    	     * @example
    	     *
    	     * var wrapped = _([1, 2]);
    	     *
    	     * wrapped.next();
    	     * // => { 'done': false, 'value': 1 }
    	     *
    	     * wrapped.next();
    	     * // => { 'done': false, 'value': 2 }
    	     *
    	     * wrapped.next();
    	     * // => { 'done': true, 'value': undefined }
    	     */function wrapperNext(){if(this.__values__===undefined$1){this.__values__=toArray(this.value());}var done=this.__index__>=this.__values__.length,value=done?undefined$1:this.__values__[this.__index__++];return {'done':done,'value':value};}/**
    	     * Enables the wrapper to be iterable.
    	     *
    	     * @name Symbol.iterator
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Seq
    	     * @returns {Object} Returns the wrapper object.
    	     * @example
    	     *
    	     * var wrapped = _([1, 2]);
    	     *
    	     * wrapped[Symbol.iterator]() === wrapped;
    	     * // => true
    	     *
    	     * Array.from(wrapped);
    	     * // => [1, 2]
    	     */function wrapperToIterator(){return this;}/**
    	     * Creates a clone of the chain sequence planting `value` as the wrapped value.
    	     *
    	     * @name plant
    	     * @memberOf _
    	     * @since 3.2.0
    	     * @category Seq
    	     * @param {*} value The value to plant.
    	     * @returns {Object} Returns the new `lodash` wrapper instance.
    	     * @example
    	     *
    	     * function square(n) {
    	     *   return n * n;
    	     * }
    	     *
    	     * var wrapped = _([1, 2]).map(square);
    	     * var other = wrapped.plant([3, 4]);
    	     *
    	     * other.value();
    	     * // => [9, 16]
    	     *
    	     * wrapped.value();
    	     * // => [1, 4]
    	     */function wrapperPlant(value){var result,parent=this;while(parent instanceof baseLodash){var clone=wrapperClone(parent);clone.__index__=0;clone.__values__=undefined$1;if(result){previous.__wrapped__=clone;}else {result=clone;}var previous=clone;parent=parent.__wrapped__;}previous.__wrapped__=value;return result;}/**
    	     * This method is the wrapper version of `_.reverse`.
    	     *
    	     * **Note:** This method mutates the wrapped array.
    	     *
    	     * @name reverse
    	     * @memberOf _
    	     * @since 0.1.0
    	     * @category Seq
    	     * @returns {Object} Returns the new `lodash` wrapper instance.
    	     * @example
    	     *
    	     * var array = [1, 2, 3];
    	     *
    	     * _(array).reverse().value()
    	     * // => [3, 2, 1]
    	     *
    	     * console.log(array);
    	     * // => [3, 2, 1]
    	     */function wrapperReverse(){var value=this.__wrapped__;if(value instanceof LazyWrapper){var wrapped=value;if(this.__actions__.length){wrapped=new LazyWrapper(this);}wrapped=wrapped.reverse();wrapped.__actions__.push({'func':thru,'args':[reverse],'thisArg':undefined$1});return new LodashWrapper(wrapped,this.__chain__);}return this.thru(reverse);}/**
    	     * Executes the chain sequence to resolve the unwrapped value.
    	     *
    	     * @name value
    	     * @memberOf _
    	     * @since 0.1.0
    	     * @alias toJSON, valueOf
    	     * @category Seq
    	     * @returns {*} Returns the resolved unwrapped value.
    	     * @example
    	     *
    	     * _([1, 2, 3]).value();
    	     * // => [1, 2, 3]
    	     */function wrapperValue(){return baseWrapperValue(this.__wrapped__,this.__actions__);}/*------------------------------------------------------------------------*/ /**
    	     * Creates an object composed of keys generated from the results of running
    	     * each element of `collection` thru `iteratee`. The corresponding value of
    	     * each key is the number of times the key was returned by `iteratee`. The
    	     * iteratee is invoked with one argument: (value).
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.5.0
    	     * @category Collection
    	     * @param {Array|Object} collection The collection to iterate over.
    	     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
    	     * @returns {Object} Returns the composed aggregate object.
    	     * @example
    	     *
    	     * _.countBy([6.1, 4.2, 6.3], Math.floor);
    	     * // => { '4': 1, '6': 2 }
    	     *
    	     * // The `_.property` iteratee shorthand.
    	     * _.countBy(['one', 'two', 'three'], 'length');
    	     * // => { '3': 2, '5': 1 }
    	     */var countBy=createAggregator(function(result,value,key){if(hasOwnProperty.call(result,key)){++result[key];}else {baseAssignValue(result,key,1);}});/**
    	     * Checks if `predicate` returns truthy for **all** elements of `collection`.
    	     * Iteration is stopped once `predicate` returns falsey. The predicate is
    	     * invoked with three arguments: (value, index|key, collection).
    	     *
    	     * **Note:** This method returns `true` for
    	     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
    	     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
    	     * elements of empty collections.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.1.0
    	     * @category Collection
    	     * @param {Array|Object} collection The collection to iterate over.
    	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
    	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
    	     * @returns {boolean} Returns `true` if all elements pass the predicate check,
    	     *  else `false`.
    	     * @example
    	     *
    	     * _.every([true, 1, null, 'yes'], Boolean);
    	     * // => false
    	     *
    	     * var users = [
    	     *   { 'user': 'barney', 'age': 36, 'active': false },
    	     *   { 'user': 'fred',   'age': 40, 'active': false }
    	     * ];
    	     *
    	     * // The `_.matches` iteratee shorthand.
    	     * _.every(users, { 'user': 'barney', 'active': false });
    	     * // => false
    	     *
    	     * // The `_.matchesProperty` iteratee shorthand.
    	     * _.every(users, ['active', false]);
    	     * // => true
    	     *
    	     * // The `_.property` iteratee shorthand.
    	     * _.every(users, 'active');
    	     * // => false
    	     */function every(collection,predicate,guard){var func=isArray(collection)?arrayEvery:baseEvery;if(guard&&isIterateeCall(collection,predicate,guard)){predicate=undefined$1;}return func(collection,getIteratee(predicate,3));}/**
    	     * Iterates over elements of `collection`, returning an array of all elements
    	     * `predicate` returns truthy for. The predicate is invoked with three
    	     * arguments: (value, index|key, collection).
    	     *
    	     * **Note:** Unlike `_.remove`, this method returns a new array.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.1.0
    	     * @category Collection
    	     * @param {Array|Object} collection The collection to iterate over.
    	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
    	     * @returns {Array} Returns the new filtered array.
    	     * @see _.reject
    	     * @example
    	     *
    	     * var users = [
    	     *   { 'user': 'barney', 'age': 36, 'active': true },
    	     *   { 'user': 'fred',   'age': 40, 'active': false }
    	     * ];
    	     *
    	     * _.filter(users, function(o) { return !o.active; });
    	     * // => objects for ['fred']
    	     *
    	     * // The `_.matches` iteratee shorthand.
    	     * _.filter(users, { 'age': 36, 'active': true });
    	     * // => objects for ['barney']
    	     *
    	     * // The `_.matchesProperty` iteratee shorthand.
    	     * _.filter(users, ['active', false]);
    	     * // => objects for ['fred']
    	     *
    	     * // The `_.property` iteratee shorthand.
    	     * _.filter(users, 'active');
    	     * // => objects for ['barney']
    	     *
    	     * // Combining several predicates using `_.overEvery` or `_.overSome`.
    	     * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
    	     * // => objects for ['fred', 'barney']
    	     */function filter(collection,predicate){var func=isArray(collection)?arrayFilter:baseFilter;return func(collection,getIteratee(predicate,3));}/**
    	     * Iterates over elements of `collection`, returning the first element
    	     * `predicate` returns truthy for. The predicate is invoked with three
    	     * arguments: (value, index|key, collection).
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.1.0
    	     * @category Collection
    	     * @param {Array|Object} collection The collection to inspect.
    	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
    	     * @param {number} [fromIndex=0] The index to search from.
    	     * @returns {*} Returns the matched element, else `undefined`.
    	     * @example
    	     *
    	     * var users = [
    	     *   { 'user': 'barney',  'age': 36, 'active': true },
    	     *   { 'user': 'fred',    'age': 40, 'active': false },
    	     *   { 'user': 'pebbles', 'age': 1,  'active': true }
    	     * ];
    	     *
    	     * _.find(users, function(o) { return o.age < 40; });
    	     * // => object for 'barney'
    	     *
    	     * // The `_.matches` iteratee shorthand.
    	     * _.find(users, { 'age': 1, 'active': true });
    	     * // => object for 'pebbles'
    	     *
    	     * // The `_.matchesProperty` iteratee shorthand.
    	     * _.find(users, ['active', false]);
    	     * // => object for 'fred'
    	     *
    	     * // The `_.property` iteratee shorthand.
    	     * _.find(users, 'active');
    	     * // => object for 'barney'
    	     */var find=createFind(findIndex);/**
    	     * This method is like `_.find` except that it iterates over elements of
    	     * `collection` from right to left.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 2.0.0
    	     * @category Collection
    	     * @param {Array|Object} collection The collection to inspect.
    	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
    	     * @param {number} [fromIndex=collection.length-1] The index to search from.
    	     * @returns {*} Returns the matched element, else `undefined`.
    	     * @example
    	     *
    	     * _.findLast([1, 2, 3, 4], function(n) {
    	     *   return n % 2 == 1;
    	     * });
    	     * // => 3
    	     */var findLast=createFind(findLastIndex);/**
    	     * Creates a flattened array of values by running each element in `collection`
    	     * thru `iteratee` and flattening the mapped results. The iteratee is invoked
    	     * with three arguments: (value, index|key, collection).
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Collection
    	     * @param {Array|Object} collection The collection to iterate over.
    	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
    	     * @returns {Array} Returns the new flattened array.
    	     * @example
    	     *
    	     * function duplicate(n) {
    	     *   return [n, n];
    	     * }
    	     *
    	     * _.flatMap([1, 2], duplicate);
    	     * // => [1, 1, 2, 2]
    	     */function flatMap(collection,iteratee){return baseFlatten(map(collection,iteratee),1);}/**
    	     * This method is like `_.flatMap` except that it recursively flattens the
    	     * mapped results.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.7.0
    	     * @category Collection
    	     * @param {Array|Object} collection The collection to iterate over.
    	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
    	     * @returns {Array} Returns the new flattened array.
    	     * @example
    	     *
    	     * function duplicate(n) {
    	     *   return [[[n, n]]];
    	     * }
    	     *
    	     * _.flatMapDeep([1, 2], duplicate);
    	     * // => [1, 1, 2, 2]
    	     */function flatMapDeep(collection,iteratee){return baseFlatten(map(collection,iteratee),INFINITY);}/**
    	     * This method is like `_.flatMap` except that it recursively flattens the
    	     * mapped results up to `depth` times.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.7.0
    	     * @category Collection
    	     * @param {Array|Object} collection The collection to iterate over.
    	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
    	     * @param {number} [depth=1] The maximum recursion depth.
    	     * @returns {Array} Returns the new flattened array.
    	     * @example
    	     *
    	     * function duplicate(n) {
    	     *   return [[[n, n]]];
    	     * }
    	     *
    	     * _.flatMapDepth([1, 2], duplicate, 2);
    	     * // => [[1, 1], [2, 2]]
    	     */function flatMapDepth(collection,iteratee,depth){depth=depth===undefined$1?1:toInteger(depth);return baseFlatten(map(collection,iteratee),depth);}/**
    	     * Iterates over elements of `collection` and invokes `iteratee` for each element.
    	     * The iteratee is invoked with three arguments: (value, index|key, collection).
    	     * Iteratee functions may exit iteration early by explicitly returning `false`.
    	     *
    	     * **Note:** As with other "Collections" methods, objects with a "length"
    	     * property are iterated like arrays. To avoid this behavior use `_.forIn`
    	     * or `_.forOwn` for object iteration.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.1.0
    	     * @alias each
    	     * @category Collection
    	     * @param {Array|Object} collection The collection to iterate over.
    	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
    	     * @returns {Array|Object} Returns `collection`.
    	     * @see _.forEachRight
    	     * @example
    	     *
    	     * _.forEach([1, 2], function(value) {
    	     *   console.log(value);
    	     * });
    	     * // => Logs `1` then `2`.
    	     *
    	     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
    	     *   console.log(key);
    	     * });
    	     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
    	     */function forEach(collection,iteratee){var func=isArray(collection)?arrayEach:baseEach;return func(collection,getIteratee(iteratee,3));}/**
    	     * This method is like `_.forEach` except that it iterates over elements of
    	     * `collection` from right to left.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 2.0.0
    	     * @alias eachRight
    	     * @category Collection
    	     * @param {Array|Object} collection The collection to iterate over.
    	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
    	     * @returns {Array|Object} Returns `collection`.
    	     * @see _.forEach
    	     * @example
    	     *
    	     * _.forEachRight([1, 2], function(value) {
    	     *   console.log(value);
    	     * });
    	     * // => Logs `2` then `1`.
    	     */function forEachRight(collection,iteratee){var func=isArray(collection)?arrayEachRight:baseEachRight;return func(collection,getIteratee(iteratee,3));}/**
    	     * Creates an object composed of keys generated from the results of running
    	     * each element of `collection` thru `iteratee`. The order of grouped values
    	     * is determined by the order they occur in `collection`. The corresponding
    	     * value of each key is an array of elements responsible for generating the
    	     * key. The iteratee is invoked with one argument: (value).
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.1.0
    	     * @category Collection
    	     * @param {Array|Object} collection The collection to iterate over.
    	     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
    	     * @returns {Object} Returns the composed aggregate object.
    	     * @example
    	     *
    	     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
    	     * // => { '4': [4.2], '6': [6.1, 6.3] }
    	     *
    	     * // The `_.property` iteratee shorthand.
    	     * _.groupBy(['one', 'two', 'three'], 'length');
    	     * // => { '3': ['one', 'two'], '5': ['three'] }
    	     */var groupBy=createAggregator(function(result,value,key){if(hasOwnProperty.call(result,key)){result[key].push(value);}else {baseAssignValue(result,key,[value]);}});/**
    	     * Checks if `value` is in `collection`. If `collection` is a string, it's
    	     * checked for a substring of `value`, otherwise
    	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
    	     * is used for equality comparisons. If `fromIndex` is negative, it's used as
    	     * the offset from the end of `collection`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.1.0
    	     * @category Collection
    	     * @param {Array|Object|string} collection The collection to inspect.
    	     * @param {*} value The value to search for.
    	     * @param {number} [fromIndex=0] The index to search from.
    	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
    	     * @returns {boolean} Returns `true` if `value` is found, else `false`.
    	     * @example
    	     *
    	     * _.includes([1, 2, 3], 1);
    	     * // => true
    	     *
    	     * _.includes([1, 2, 3], 1, 2);
    	     * // => false
    	     *
    	     * _.includes({ 'a': 1, 'b': 2 }, 1);
    	     * // => true
    	     *
    	     * _.includes('abcd', 'bc');
    	     * // => true
    	     */function includes(collection,value,fromIndex,guard){collection=isArrayLike(collection)?collection:values(collection);fromIndex=fromIndex&&!guard?toInteger(fromIndex):0;var length=collection.length;if(fromIndex<0){fromIndex=nativeMax(length+fromIndex,0);}return isString(collection)?fromIndex<=length&&collection.indexOf(value,fromIndex)>-1:!!length&&baseIndexOf(collection,value,fromIndex)>-1;}/**
    	     * Invokes the method at `path` of each element in `collection`, returning
    	     * an array of the results of each invoked method. Any additional arguments
    	     * are provided to each invoked method. If `path` is a function, it's invoked
    	     * for, and `this` bound to, each element in `collection`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Collection
    	     * @param {Array|Object} collection The collection to iterate over.
    	     * @param {Array|Function|string} path The path of the method to invoke or
    	     *  the function invoked per iteration.
    	     * @param {...*} [args] The arguments to invoke each method with.
    	     * @returns {Array} Returns the array of results.
    	     * @example
    	     *
    	     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
    	     * // => [[1, 5, 7], [1, 2, 3]]
    	     *
    	     * _.invokeMap([123, 456], String.prototype.split, '');
    	     * // => [['1', '2', '3'], ['4', '5', '6']]
    	     */var invokeMap=baseRest(function(collection,path,args){var index=-1,isFunc=typeof path=='function',result=isArrayLike(collection)?Array(collection.length):[];baseEach(collection,function(value){result[++index]=isFunc?apply(path,value,args):baseInvoke(value,path,args);});return result;});/**
    	     * Creates an object composed of keys generated from the results of running
    	     * each element of `collection` thru `iteratee`. The corresponding value of
    	     * each key is the last element responsible for generating the key. The
    	     * iteratee is invoked with one argument: (value).
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Collection
    	     * @param {Array|Object} collection The collection to iterate over.
    	     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
    	     * @returns {Object} Returns the composed aggregate object.
    	     * @example
    	     *
    	     * var array = [
    	     *   { 'dir': 'left', 'code': 97 },
    	     *   { 'dir': 'right', 'code': 100 }
    	     * ];
    	     *
    	     * _.keyBy(array, function(o) {
    	     *   return String.fromCharCode(o.code);
    	     * });
    	     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
    	     *
    	     * _.keyBy(array, 'dir');
    	     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
    	     */var keyBy=createAggregator(function(result,value,key){baseAssignValue(result,key,value);});/**
    	     * Creates an array of values by running each element in `collection` thru
    	     * `iteratee`. The iteratee is invoked with three arguments:
    	     * (value, index|key, collection).
    	     *
    	     * Many lodash methods are guarded to work as iteratees for methods like
    	     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
    	     *
    	     * The guarded methods are:
    	     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
    	     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
    	     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
    	     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.1.0
    	     * @category Collection
    	     * @param {Array|Object} collection The collection to iterate over.
    	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
    	     * @returns {Array} Returns the new mapped array.
    	     * @example
    	     *
    	     * function square(n) {
    	     *   return n * n;
    	     * }
    	     *
    	     * _.map([4, 8], square);
    	     * // => [16, 64]
    	     *
    	     * _.map({ 'a': 4, 'b': 8 }, square);
    	     * // => [16, 64] (iteration order is not guaranteed)
    	     *
    	     * var users = [
    	     *   { 'user': 'barney' },
    	     *   { 'user': 'fred' }
    	     * ];
    	     *
    	     * // The `_.property` iteratee shorthand.
    	     * _.map(users, 'user');
    	     * // => ['barney', 'fred']
    	     */function map(collection,iteratee){var func=isArray(collection)?arrayMap:baseMap;return func(collection,getIteratee(iteratee,3));}/**
    	     * This method is like `_.sortBy` except that it allows specifying the sort
    	     * orders of the iteratees to sort by. If `orders` is unspecified, all values
    	     * are sorted in ascending order. Otherwise, specify an order of "desc" for
    	     * descending or "asc" for ascending sort order of corresponding values.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Collection
    	     * @param {Array|Object} collection The collection to iterate over.
    	     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
    	     *  The iteratees to sort by.
    	     * @param {string[]} [orders] The sort orders of `iteratees`.
    	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
    	     * @returns {Array} Returns the new sorted array.
    	     * @example
    	     *
    	     * var users = [
    	     *   { 'user': 'fred',   'age': 48 },
    	     *   { 'user': 'barney', 'age': 34 },
    	     *   { 'user': 'fred',   'age': 40 },
    	     *   { 'user': 'barney', 'age': 36 }
    	     * ];
    	     *
    	     * // Sort by `user` in ascending order and by `age` in descending order.
    	     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
    	     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
    	     */function orderBy(collection,iteratees,orders,guard){if(collection==null){return [];}if(!isArray(iteratees)){iteratees=iteratees==null?[]:[iteratees];}orders=guard?undefined$1:orders;if(!isArray(orders)){orders=orders==null?[]:[orders];}return baseOrderBy(collection,iteratees,orders);}/**
    	     * Creates an array of elements split into two groups, the first of which
    	     * contains elements `predicate` returns truthy for, the second of which
    	     * contains elements `predicate` returns falsey for. The predicate is
    	     * invoked with one argument: (value).
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 3.0.0
    	     * @category Collection
    	     * @param {Array|Object} collection The collection to iterate over.
    	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
    	     * @returns {Array} Returns the array of grouped elements.
    	     * @example
    	     *
    	     * var users = [
    	     *   { 'user': 'barney',  'age': 36, 'active': false },
    	     *   { 'user': 'fred',    'age': 40, 'active': true },
    	     *   { 'user': 'pebbles', 'age': 1,  'active': false }
    	     * ];
    	     *
    	     * _.partition(users, function(o) { return o.active; });
    	     * // => objects for [['fred'], ['barney', 'pebbles']]
    	     *
    	     * // The `_.matches` iteratee shorthand.
    	     * _.partition(users, { 'age': 1, 'active': false });
    	     * // => objects for [['pebbles'], ['barney', 'fred']]
    	     *
    	     * // The `_.matchesProperty` iteratee shorthand.
    	     * _.partition(users, ['active', false]);
    	     * // => objects for [['barney', 'pebbles'], ['fred']]
    	     *
    	     * // The `_.property` iteratee shorthand.
    	     * _.partition(users, 'active');
    	     * // => objects for [['fred'], ['barney', 'pebbles']]
    	     */var partition=createAggregator(function(result,value,key){result[key?0:1].push(value);},function(){return [[],[]];});/**
    	     * Reduces `collection` to a value which is the accumulated result of running
    	     * each element in `collection` thru `iteratee`, where each successive
    	     * invocation is supplied the return value of the previous. If `accumulator`
    	     * is not given, the first element of `collection` is used as the initial
    	     * value. The iteratee is invoked with four arguments:
    	     * (accumulator, value, index|key, collection).
    	     *
    	     * Many lodash methods are guarded to work as iteratees for methods like
    	     * `_.reduce`, `_.reduceRight`, and `_.transform`.
    	     *
    	     * The guarded methods are:
    	     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
    	     * and `sortBy`
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.1.0
    	     * @category Collection
    	     * @param {Array|Object} collection The collection to iterate over.
    	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
    	     * @param {*} [accumulator] The initial value.
    	     * @returns {*} Returns the accumulated value.
    	     * @see _.reduceRight
    	     * @example
    	     *
    	     * _.reduce([1, 2], function(sum, n) {
    	     *   return sum + n;
    	     * }, 0);
    	     * // => 3
    	     *
    	     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
    	     *   (result[value] || (result[value] = [])).push(key);
    	     *   return result;
    	     * }, {});
    	     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
    	     */function reduce(collection,iteratee,accumulator){var func=isArray(collection)?arrayReduce:baseReduce,initAccum=arguments.length<3;return func(collection,getIteratee(iteratee,4),accumulator,initAccum,baseEach);}/**
    	     * This method is like `_.reduce` except that it iterates over elements of
    	     * `collection` from right to left.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.1.0
    	     * @category Collection
    	     * @param {Array|Object} collection The collection to iterate over.
    	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
    	     * @param {*} [accumulator] The initial value.
    	     * @returns {*} Returns the accumulated value.
    	     * @see _.reduce
    	     * @example
    	     *
    	     * var array = [[0, 1], [2, 3], [4, 5]];
    	     *
    	     * _.reduceRight(array, function(flattened, other) {
    	     *   return flattened.concat(other);
    	     * }, []);
    	     * // => [4, 5, 2, 3, 0, 1]
    	     */function reduceRight(collection,iteratee,accumulator){var func=isArray(collection)?arrayReduceRight:baseReduce,initAccum=arguments.length<3;return func(collection,getIteratee(iteratee,4),accumulator,initAccum,baseEachRight);}/**
    	     * The opposite of `_.filter`; this method returns the elements of `collection`
    	     * that `predicate` does **not** return truthy for.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.1.0
    	     * @category Collection
    	     * @param {Array|Object} collection The collection to iterate over.
    	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
    	     * @returns {Array} Returns the new filtered array.
    	     * @see _.filter
    	     * @example
    	     *
    	     * var users = [
    	     *   { 'user': 'barney', 'age': 36, 'active': false },
    	     *   { 'user': 'fred',   'age': 40, 'active': true }
    	     * ];
    	     *
    	     * _.reject(users, function(o) { return !o.active; });
    	     * // => objects for ['fred']
    	     *
    	     * // The `_.matches` iteratee shorthand.
    	     * _.reject(users, { 'age': 40, 'active': true });
    	     * // => objects for ['barney']
    	     *
    	     * // The `_.matchesProperty` iteratee shorthand.
    	     * _.reject(users, ['active', false]);
    	     * // => objects for ['fred']
    	     *
    	     * // The `_.property` iteratee shorthand.
    	     * _.reject(users, 'active');
    	     * // => objects for ['barney']
    	     */function reject(collection,predicate){var func=isArray(collection)?arrayFilter:baseFilter;return func(collection,negate(getIteratee(predicate,3)));}/**
    	     * Gets a random element from `collection`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 2.0.0
    	     * @category Collection
    	     * @param {Array|Object} collection The collection to sample.
    	     * @returns {*} Returns the random element.
    	     * @example
    	     *
    	     * _.sample([1, 2, 3, 4]);
    	     * // => 2
    	     */function sample(collection){var func=isArray(collection)?arraySample:baseSample;return func(collection);}/**
    	     * Gets `n` random elements at unique keys from `collection` up to the
    	     * size of `collection`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Collection
    	     * @param {Array|Object} collection The collection to sample.
    	     * @param {number} [n=1] The number of elements to sample.
    	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
    	     * @returns {Array} Returns the random elements.
    	     * @example
    	     *
    	     * _.sampleSize([1, 2, 3], 2);
    	     * // => [3, 1]
    	     *
    	     * _.sampleSize([1, 2, 3], 4);
    	     * // => [2, 3, 1]
    	     */function sampleSize(collection,n,guard){if(guard?isIterateeCall(collection,n,guard):n===undefined$1){n=1;}else {n=toInteger(n);}var func=isArray(collection)?arraySampleSize:baseSampleSize;return func(collection,n);}/**
    	     * Creates an array of shuffled values, using a version of the
    	     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.1.0
    	     * @category Collection
    	     * @param {Array|Object} collection The collection to shuffle.
    	     * @returns {Array} Returns the new shuffled array.
    	     * @example
    	     *
    	     * _.shuffle([1, 2, 3, 4]);
    	     * // => [4, 1, 3, 2]
    	     */function shuffle(collection){var func=isArray(collection)?arrayShuffle:baseShuffle;return func(collection);}/**
    	     * Gets the size of `collection` by returning its length for array-like
    	     * values or the number of own enumerable string keyed properties for objects.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.1.0
    	     * @category Collection
    	     * @param {Array|Object|string} collection The collection to inspect.
    	     * @returns {number} Returns the collection size.
    	     * @example
    	     *
    	     * _.size([1, 2, 3]);
    	     * // => 3
    	     *
    	     * _.size({ 'a': 1, 'b': 2 });
    	     * // => 2
    	     *
    	     * _.size('pebbles');
    	     * // => 7
    	     */function size(collection){if(collection==null){return 0;}if(isArrayLike(collection)){return isString(collection)?stringSize(collection):collection.length;}var tag=getTag(collection);if(tag==mapTag||tag==setTag){return collection.size;}return baseKeys(collection).length;}/**
    	     * Checks if `predicate` returns truthy for **any** element of `collection`.
    	     * Iteration is stopped once `predicate` returns truthy. The predicate is
    	     * invoked with three arguments: (value, index|key, collection).
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.1.0
    	     * @category Collection
    	     * @param {Array|Object} collection The collection to iterate over.
    	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
    	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
    	     * @returns {boolean} Returns `true` if any element passes the predicate check,
    	     *  else `false`.
    	     * @example
    	     *
    	     * _.some([null, 0, 'yes', false], Boolean);
    	     * // => true
    	     *
    	     * var users = [
    	     *   { 'user': 'barney', 'active': true },
    	     *   { 'user': 'fred',   'active': false }
    	     * ];
    	     *
    	     * // The `_.matches` iteratee shorthand.
    	     * _.some(users, { 'user': 'barney', 'active': false });
    	     * // => false
    	     *
    	     * // The `_.matchesProperty` iteratee shorthand.
    	     * _.some(users, ['active', false]);
    	     * // => true
    	     *
    	     * // The `_.property` iteratee shorthand.
    	     * _.some(users, 'active');
    	     * // => true
    	     */function some(collection,predicate,guard){var func=isArray(collection)?arraySome:baseSome;if(guard&&isIterateeCall(collection,predicate,guard)){predicate=undefined$1;}return func(collection,getIteratee(predicate,3));}/**
    	     * Creates an array of elements, sorted in ascending order by the results of
    	     * running each element in a collection thru each iteratee. This method
    	     * performs a stable sort, that is, it preserves the original sort order of
    	     * equal elements. The iteratees are invoked with one argument: (value).
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.1.0
    	     * @category Collection
    	     * @param {Array|Object} collection The collection to iterate over.
    	     * @param {...(Function|Function[])} [iteratees=[_.identity]]
    	     *  The iteratees to sort by.
    	     * @returns {Array} Returns the new sorted array.
    	     * @example
    	     *
    	     * var users = [
    	     *   { 'user': 'fred',   'age': 48 },
    	     *   { 'user': 'barney', 'age': 36 },
    	     *   { 'user': 'fred',   'age': 30 },
    	     *   { 'user': 'barney', 'age': 34 }
    	     * ];
    	     *
    	     * _.sortBy(users, [function(o) { return o.user; }]);
    	     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
    	     *
    	     * _.sortBy(users, ['user', 'age']);
    	     * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
    	     */var sortBy=baseRest(function(collection,iteratees){if(collection==null){return [];}var length=iteratees.length;if(length>1&&isIterateeCall(collection,iteratees[0],iteratees[1])){iteratees=[];}else if(length>2&&isIterateeCall(iteratees[0],iteratees[1],iteratees[2])){iteratees=[iteratees[0]];}return baseOrderBy(collection,baseFlatten(iteratees,1),[]);});/*------------------------------------------------------------------------*/ /**
    	     * Gets the timestamp of the number of milliseconds that have elapsed since
    	     * the Unix epoch (1 January 1970 00:00:00 UTC).
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 2.4.0
    	     * @category Date
    	     * @returns {number} Returns the timestamp.
    	     * @example
    	     *
    	     * _.defer(function(stamp) {
    	     *   console.log(_.now() - stamp);
    	     * }, _.now());
    	     * // => Logs the number of milliseconds it took for the deferred invocation.
    	     */var now=ctxNow||function(){return root.Date.now();};/*------------------------------------------------------------------------*/ /**
    	     * The opposite of `_.before`; this method creates a function that invokes
    	     * `func` once it's called `n` or more times.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.1.0
    	     * @category Function
    	     * @param {number} n The number of calls before `func` is invoked.
    	     * @param {Function} func The function to restrict.
    	     * @returns {Function} Returns the new restricted function.
    	     * @example
    	     *
    	     * var saves = ['profile', 'settings'];
    	     *
    	     * var done = _.after(saves.length, function() {
    	     *   console.log('done saving!');
    	     * });
    	     *
    	     * _.forEach(saves, function(type) {
    	     *   asyncSave({ 'type': type, 'complete': done });
    	     * });
    	     * // => Logs 'done saving!' after the two async saves have completed.
    	     */function after(n,func){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}n=toInteger(n);return function(){if(--n<1){return func.apply(this,arguments);}};}/**
    	     * Creates a function that invokes `func`, with up to `n` arguments,
    	     * ignoring any additional arguments.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 3.0.0
    	     * @category Function
    	     * @param {Function} func The function to cap arguments for.
    	     * @param {number} [n=func.length] The arity cap.
    	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
    	     * @returns {Function} Returns the new capped function.
    	     * @example
    	     *
    	     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
    	     * // => [6, 8, 10]
    	     */function ary(func,n,guard){n=guard?undefined$1:n;n=func&&n==null?func.length:n;return createWrap(func,WRAP_ARY_FLAG,undefined$1,undefined$1,undefined$1,undefined$1,n);}/**
    	     * Creates a function that invokes `func`, with the `this` binding and arguments
    	     * of the created function, while it's called less than `n` times. Subsequent
    	     * calls to the created function return the result of the last `func` invocation.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 3.0.0
    	     * @category Function
    	     * @param {number} n The number of calls at which `func` is no longer invoked.
    	     * @param {Function} func The function to restrict.
    	     * @returns {Function} Returns the new restricted function.
    	     * @example
    	     *
    	     * jQuery(element).on('click', _.before(5, addContactToList));
    	     * // => Allows adding up to 4 contacts to the list.
    	     */function before(n,func){var result;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}n=toInteger(n);return function(){if(--n>0){result=func.apply(this,arguments);}if(n<=1){func=undefined$1;}return result;};}/**
    	     * Creates a function that invokes `func` with the `this` binding of `thisArg`
    	     * and `partials` prepended to the arguments it receives.
    	     *
    	     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
    	     * may be used as a placeholder for partially applied arguments.
    	     *
    	     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
    	     * property of bound functions.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.1.0
    	     * @category Function
    	     * @param {Function} func The function to bind.
    	     * @param {*} thisArg The `this` binding of `func`.
    	     * @param {...*} [partials] The arguments to be partially applied.
    	     * @returns {Function} Returns the new bound function.
    	     * @example
    	     *
    	     * function greet(greeting, punctuation) {
    	     *   return greeting + ' ' + this.user + punctuation;
    	     * }
    	     *
    	     * var object = { 'user': 'fred' };
    	     *
    	     * var bound = _.bind(greet, object, 'hi');
    	     * bound('!');
    	     * // => 'hi fred!'
    	     *
    	     * // Bound with placeholders.
    	     * var bound = _.bind(greet, object, _, '!');
    	     * bound('hi');
    	     * // => 'hi fred!'
    	     */var bind=baseRest(function(func,thisArg,partials){var bitmask=WRAP_BIND_FLAG;if(partials.length){var holders=replaceHolders(partials,getHolder(bind));bitmask|=WRAP_PARTIAL_FLAG;}return createWrap(func,bitmask,thisArg,partials,holders);});/**
    	     * Creates a function that invokes the method at `object[key]` with `partials`
    	     * prepended to the arguments it receives.
    	     *
    	     * This method differs from `_.bind` by allowing bound functions to reference
    	     * methods that may be redefined or don't yet exist. See
    	     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
    	     * for more details.
    	     *
    	     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
    	     * builds, may be used as a placeholder for partially applied arguments.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.10.0
    	     * @category Function
    	     * @param {Object} object The object to invoke the method on.
    	     * @param {string} key The key of the method.
    	     * @param {...*} [partials] The arguments to be partially applied.
    	     * @returns {Function} Returns the new bound function.
    	     * @example
    	     *
    	     * var object = {
    	     *   'user': 'fred',
    	     *   'greet': function(greeting, punctuation) {
    	     *     return greeting + ' ' + this.user + punctuation;
    	     *   }
    	     * };
    	     *
    	     * var bound = _.bindKey(object, 'greet', 'hi');
    	     * bound('!');
    	     * // => 'hi fred!'
    	     *
    	     * object.greet = function(greeting, punctuation) {
    	     *   return greeting + 'ya ' + this.user + punctuation;
    	     * };
    	     *
    	     * bound('!');
    	     * // => 'hiya fred!'
    	     *
    	     * // Bound with placeholders.
    	     * var bound = _.bindKey(object, 'greet', _, '!');
    	     * bound('hi');
    	     * // => 'hiya fred!'
    	     */var bindKey=baseRest(function(object,key,partials){var bitmask=WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG;if(partials.length){var holders=replaceHolders(partials,getHolder(bindKey));bitmask|=WRAP_PARTIAL_FLAG;}return createWrap(key,bitmask,object,partials,holders);});/**
    	     * Creates a function that accepts arguments of `func` and either invokes
    	     * `func` returning its result, if at least `arity` number of arguments have
    	     * been provided, or returns a function that accepts the remaining `func`
    	     * arguments, and so on. The arity of `func` may be specified if `func.length`
    	     * is not sufficient.
    	     *
    	     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
    	     * may be used as a placeholder for provided arguments.
    	     *
    	     * **Note:** This method doesn't set the "length" property of curried functions.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 2.0.0
    	     * @category Function
    	     * @param {Function} func The function to curry.
    	     * @param {number} [arity=func.length] The arity of `func`.
    	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
    	     * @returns {Function} Returns the new curried function.
    	     * @example
    	     *
    	     * var abc = function(a, b, c) {
    	     *   return [a, b, c];
    	     * };
    	     *
    	     * var curried = _.curry(abc);
    	     *
    	     * curried(1)(2)(3);
    	     * // => [1, 2, 3]
    	     *
    	     * curried(1, 2)(3);
    	     * // => [1, 2, 3]
    	     *
    	     * curried(1, 2, 3);
    	     * // => [1, 2, 3]
    	     *
    	     * // Curried with placeholders.
    	     * curried(1)(_, 3)(2);
    	     * // => [1, 2, 3]
    	     */function curry(func,arity,guard){arity=guard?undefined$1:arity;var result=createWrap(func,WRAP_CURRY_FLAG,undefined$1,undefined$1,undefined$1,undefined$1,undefined$1,arity);result.placeholder=curry.placeholder;return result;}/**
    	     * This method is like `_.curry` except that arguments are applied to `func`
    	     * in the manner of `_.partialRight` instead of `_.partial`.
    	     *
    	     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
    	     * builds, may be used as a placeholder for provided arguments.
    	     *
    	     * **Note:** This method doesn't set the "length" property of curried functions.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 3.0.0
    	     * @category Function
    	     * @param {Function} func The function to curry.
    	     * @param {number} [arity=func.length] The arity of `func`.
    	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
    	     * @returns {Function} Returns the new curried function.
    	     * @example
    	     *
    	     * var abc = function(a, b, c) {
    	     *   return [a, b, c];
    	     * };
    	     *
    	     * var curried = _.curryRight(abc);
    	     *
    	     * curried(3)(2)(1);
    	     * // => [1, 2, 3]
    	     *
    	     * curried(2, 3)(1);
    	     * // => [1, 2, 3]
    	     *
    	     * curried(1, 2, 3);
    	     * // => [1, 2, 3]
    	     *
    	     * // Curried with placeholders.
    	     * curried(3)(1, _)(2);
    	     * // => [1, 2, 3]
    	     */function curryRight(func,arity,guard){arity=guard?undefined$1:arity;var result=createWrap(func,WRAP_CURRY_RIGHT_FLAG,undefined$1,undefined$1,undefined$1,undefined$1,undefined$1,arity);result.placeholder=curryRight.placeholder;return result;}/**
    	     * Creates a debounced function that delays invoking `func` until after `wait`
    	     * milliseconds have elapsed since the last time the debounced function was
    	     * invoked. The debounced function comes with a `cancel` method to cancel
    	     * delayed `func` invocations and a `flush` method to immediately invoke them.
    	     * Provide `options` to indicate whether `func` should be invoked on the
    	     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
    	     * with the last arguments provided to the debounced function. Subsequent
    	     * calls to the debounced function return the result of the last `func`
    	     * invocation.
    	     *
    	     * **Note:** If `leading` and `trailing` options are `true`, `func` is
    	     * invoked on the trailing edge of the timeout only if the debounced function
    	     * is invoked more than once during the `wait` timeout.
    	     *
    	     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
    	     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
    	     *
    	     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
    	     * for details over the differences between `_.debounce` and `_.throttle`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.1.0
    	     * @category Function
    	     * @param {Function} func The function to debounce.
    	     * @param {number} [wait=0] The number of milliseconds to delay.
    	     * @param {Object} [options={}] The options object.
    	     * @param {boolean} [options.leading=false]
    	     *  Specify invoking on the leading edge of the timeout.
    	     * @param {number} [options.maxWait]
    	     *  The maximum time `func` is allowed to be delayed before it's invoked.
    	     * @param {boolean} [options.trailing=true]
    	     *  Specify invoking on the trailing edge of the timeout.
    	     * @returns {Function} Returns the new debounced function.
    	     * @example
    	     *
    	     * // Avoid costly calculations while the window size is in flux.
    	     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
    	     *
    	     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
    	     * jQuery(element).on('click', _.debounce(sendMail, 300, {
    	     *   'leading': true,
    	     *   'trailing': false
    	     * }));
    	     *
    	     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
    	     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
    	     * var source = new EventSource('/stream');
    	     * jQuery(source).on('message', debounced);
    	     *
    	     * // Cancel the trailing debounced invocation.
    	     * jQuery(window).on('popstate', debounced.cancel);
    	     */function debounce(func,wait,options){var lastArgs,lastThis,maxWait,result,timerId,lastCallTime,lastInvokeTime=0,leading=false,maxing=false,trailing=true;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}wait=toNumber(wait)||0;if(isObject(options)){leading=!!options.leading;maxing='maxWait'in options;maxWait=maxing?nativeMax(toNumber(options.maxWait)||0,wait):maxWait;trailing='trailing'in options?!!options.trailing:trailing;}function invokeFunc(time){var args=lastArgs,thisArg=lastThis;lastArgs=lastThis=undefined$1;lastInvokeTime=time;result=func.apply(thisArg,args);return result;}function leadingEdge(time){// Reset any `maxWait` timer.
    	lastInvokeTime=time;// Start the timer for the trailing edge.
    	timerId=setTimeout(timerExpired,wait);// Invoke the leading edge.
    	return leading?invokeFunc(time):result;}function remainingWait(time){var timeSinceLastCall=time-lastCallTime,timeSinceLastInvoke=time-lastInvokeTime,timeWaiting=wait-timeSinceLastCall;return maxing?nativeMin(timeWaiting,maxWait-timeSinceLastInvoke):timeWaiting;}function shouldInvoke(time){var timeSinceLastCall=time-lastCallTime,timeSinceLastInvoke=time-lastInvokeTime;// Either this is the first call, activity has stopped and we're at the
    	// trailing edge, the system time has gone backwards and we're treating
    	// it as the trailing edge, or we've hit the `maxWait` limit.
    	return lastCallTime===undefined$1||timeSinceLastCall>=wait||timeSinceLastCall<0||maxing&&timeSinceLastInvoke>=maxWait;}function timerExpired(){var time=now();if(shouldInvoke(time)){return trailingEdge(time);}// Restart the timer.
    	timerId=setTimeout(timerExpired,remainingWait(time));}function trailingEdge(time){timerId=undefined$1;// Only invoke if we have `lastArgs` which means `func` has been
    	// debounced at least once.
    	if(trailing&&lastArgs){return invokeFunc(time);}lastArgs=lastThis=undefined$1;return result;}function cancel(){if(timerId!==undefined$1){clearTimeout(timerId);}lastInvokeTime=0;lastArgs=lastCallTime=lastThis=timerId=undefined$1;}function flush(){return timerId===undefined$1?result:trailingEdge(now());}function debounced(){var time=now(),isInvoking=shouldInvoke(time);lastArgs=arguments;lastThis=this;lastCallTime=time;if(isInvoking){if(timerId===undefined$1){return leadingEdge(lastCallTime);}if(maxing){// Handle invocations in a tight loop.
    	clearTimeout(timerId);timerId=setTimeout(timerExpired,wait);return invokeFunc(lastCallTime);}}if(timerId===undefined$1){timerId=setTimeout(timerExpired,wait);}return result;}debounced.cancel=cancel;debounced.flush=flush;return debounced;}/**
    	     * Defers invoking the `func` until the current call stack has cleared. Any
    	     * additional arguments are provided to `func` when it's invoked.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.1.0
    	     * @category Function
    	     * @param {Function} func The function to defer.
    	     * @param {...*} [args] The arguments to invoke `func` with.
    	     * @returns {number} Returns the timer id.
    	     * @example
    	     *
    	     * _.defer(function(text) {
    	     *   console.log(text);
    	     * }, 'deferred');
    	     * // => Logs 'deferred' after one millisecond.
    	     */var defer=baseRest(function(func,args){return baseDelay(func,1,args);});/**
    	     * Invokes `func` after `wait` milliseconds. Any additional arguments are
    	     * provided to `func` when it's invoked.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.1.0
    	     * @category Function
    	     * @param {Function} func The function to delay.
    	     * @param {number} wait The number of milliseconds to delay invocation.
    	     * @param {...*} [args] The arguments to invoke `func` with.
    	     * @returns {number} Returns the timer id.
    	     * @example
    	     *
    	     * _.delay(function(text) {
    	     *   console.log(text);
    	     * }, 1000, 'later');
    	     * // => Logs 'later' after one second.
    	     */var delay=baseRest(function(func,wait,args){return baseDelay(func,toNumber(wait)||0,args);});/**
    	     * Creates a function that invokes `func` with arguments reversed.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Function
    	     * @param {Function} func The function to flip arguments for.
    	     * @returns {Function} Returns the new flipped function.
    	     * @example
    	     *
    	     * var flipped = _.flip(function() {
    	     *   return _.toArray(arguments);
    	     * });
    	     *
    	     * flipped('a', 'b', 'c', 'd');
    	     * // => ['d', 'c', 'b', 'a']
    	     */function flip(func){return createWrap(func,WRAP_FLIP_FLAG);}/**
    	     * Creates a function that memoizes the result of `func`. If `resolver` is
    	     * provided, it determines the cache key for storing the result based on the
    	     * arguments provided to the memoized function. By default, the first argument
    	     * provided to the memoized function is used as the map cache key. The `func`
    	     * is invoked with the `this` binding of the memoized function.
    	     *
    	     * **Note:** The cache is exposed as the `cache` property on the memoized
    	     * function. Its creation may be customized by replacing the `_.memoize.Cache`
    	     * constructor with one whose instances implement the
    	     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
    	     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.1.0
    	     * @category Function
    	     * @param {Function} func The function to have its output memoized.
    	     * @param {Function} [resolver] The function to resolve the cache key.
    	     * @returns {Function} Returns the new memoized function.
    	     * @example
    	     *
    	     * var object = { 'a': 1, 'b': 2 };
    	     * var other = { 'c': 3, 'd': 4 };
    	     *
    	     * var values = _.memoize(_.values);
    	     * values(object);
    	     * // => [1, 2]
    	     *
    	     * values(other);
    	     * // => [3, 4]
    	     *
    	     * object.a = 2;
    	     * values(object);
    	     * // => [1, 2]
    	     *
    	     * // Modify the result cache.
    	     * values.cache.set(object, ['a', 'b']);
    	     * values(object);
    	     * // => ['a', 'b']
    	     *
    	     * // Replace `_.memoize.Cache`.
    	     * _.memoize.Cache = WeakMap;
    	     */function memoize(func,resolver){if(typeof func!='function'||resolver!=null&&typeof resolver!='function'){throw new TypeError(FUNC_ERROR_TEXT);}var memoized=function(){var args=arguments,key=resolver?resolver.apply(this,args):args[0],cache=memoized.cache;if(cache.has(key)){return cache.get(key);}var result=func.apply(this,args);memoized.cache=cache.set(key,result)||cache;return result;};memoized.cache=new(memoize.Cache||MapCache)();return memoized;}// Expose `MapCache`.
    	memoize.Cache=MapCache;/**
    	     * Creates a function that negates the result of the predicate `func`. The
    	     * `func` predicate is invoked with the `this` binding and arguments of the
    	     * created function.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 3.0.0
    	     * @category Function
    	     * @param {Function} predicate The predicate to negate.
    	     * @returns {Function} Returns the new negated function.
    	     * @example
    	     *
    	     * function isEven(n) {
    	     *   return n % 2 == 0;
    	     * }
    	     *
    	     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
    	     * // => [1, 3, 5]
    	     */function negate(predicate){if(typeof predicate!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return function(){var args=arguments;switch(args.length){case 0:return !predicate.call(this);case 1:return !predicate.call(this,args[0]);case 2:return !predicate.call(this,args[0],args[1]);case 3:return !predicate.call(this,args[0],args[1],args[2]);}return !predicate.apply(this,args);};}/**
    	     * Creates a function that is restricted to invoking `func` once. Repeat calls
    	     * to the function return the value of the first invocation. The `func` is
    	     * invoked with the `this` binding and arguments of the created function.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.1.0
    	     * @category Function
    	     * @param {Function} func The function to restrict.
    	     * @returns {Function} Returns the new restricted function.
    	     * @example
    	     *
    	     * var initialize = _.once(createApplication);
    	     * initialize();
    	     * initialize();
    	     * // => `createApplication` is invoked once
    	     */function once(func){return before(2,func);}/**
    	     * Creates a function that invokes `func` with its arguments transformed.
    	     *
    	     * @static
    	     * @since 4.0.0
    	     * @memberOf _
    	     * @category Function
    	     * @param {Function} func The function to wrap.
    	     * @param {...(Function|Function[])} [transforms=[_.identity]]
    	     *  The argument transforms.
    	     * @returns {Function} Returns the new function.
    	     * @example
    	     *
    	     * function doubled(n) {
    	     *   return n * 2;
    	     * }
    	     *
    	     * function square(n) {
    	     *   return n * n;
    	     * }
    	     *
    	     * var func = _.overArgs(function(x, y) {
    	     *   return [x, y];
    	     * }, [square, doubled]);
    	     *
    	     * func(9, 3);
    	     * // => [81, 6]
    	     *
    	     * func(10, 5);
    	     * // => [100, 10]
    	     */var overArgs=castRest(function(func,transforms){transforms=transforms.length==1&&isArray(transforms[0])?arrayMap(transforms[0],baseUnary(getIteratee())):arrayMap(baseFlatten(transforms,1),baseUnary(getIteratee()));var funcsLength=transforms.length;return baseRest(function(args){var index=-1,length=nativeMin(args.length,funcsLength);while(++index<length){args[index]=transforms[index].call(this,args[index]);}return apply(func,this,args);});});/**
    	     * Creates a function that invokes `func` with `partials` prepended to the
    	     * arguments it receives. This method is like `_.bind` except it does **not**
    	     * alter the `this` binding.
    	     *
    	     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
    	     * builds, may be used as a placeholder for partially applied arguments.
    	     *
    	     * **Note:** This method doesn't set the "length" property of partially
    	     * applied functions.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.2.0
    	     * @category Function
    	     * @param {Function} func The function to partially apply arguments to.
    	     * @param {...*} [partials] The arguments to be partially applied.
    	     * @returns {Function} Returns the new partially applied function.
    	     * @example
    	     *
    	     * function greet(greeting, name) {
    	     *   return greeting + ' ' + name;
    	     * }
    	     *
    	     * var sayHelloTo = _.partial(greet, 'hello');
    	     * sayHelloTo('fred');
    	     * // => 'hello fred'
    	     *
    	     * // Partially applied with placeholders.
    	     * var greetFred = _.partial(greet, _, 'fred');
    	     * greetFred('hi');
    	     * // => 'hi fred'
    	     */var partial=baseRest(function(func,partials){var holders=replaceHolders(partials,getHolder(partial));return createWrap(func,WRAP_PARTIAL_FLAG,undefined$1,partials,holders);});/**
    	     * This method is like `_.partial` except that partially applied arguments
    	     * are appended to the arguments it receives.
    	     *
    	     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
    	     * builds, may be used as a placeholder for partially applied arguments.
    	     *
    	     * **Note:** This method doesn't set the "length" property of partially
    	     * applied functions.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 1.0.0
    	     * @category Function
    	     * @param {Function} func The function to partially apply arguments to.
    	     * @param {...*} [partials] The arguments to be partially applied.
    	     * @returns {Function} Returns the new partially applied function.
    	     * @example
    	     *
    	     * function greet(greeting, name) {
    	     *   return greeting + ' ' + name;
    	     * }
    	     *
    	     * var greetFred = _.partialRight(greet, 'fred');
    	     * greetFred('hi');
    	     * // => 'hi fred'
    	     *
    	     * // Partially applied with placeholders.
    	     * var sayHelloTo = _.partialRight(greet, 'hello', _);
    	     * sayHelloTo('fred');
    	     * // => 'hello fred'
    	     */var partialRight=baseRest(function(func,partials){var holders=replaceHolders(partials,getHolder(partialRight));return createWrap(func,WRAP_PARTIAL_RIGHT_FLAG,undefined$1,partials,holders);});/**
    	     * Creates a function that invokes `func` with arguments arranged according
    	     * to the specified `indexes` where the argument value at the first index is
    	     * provided as the first argument, the argument value at the second index is
    	     * provided as the second argument, and so on.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 3.0.0
    	     * @category Function
    	     * @param {Function} func The function to rearrange arguments for.
    	     * @param {...(number|number[])} indexes The arranged argument indexes.
    	     * @returns {Function} Returns the new function.
    	     * @example
    	     *
    	     * var rearged = _.rearg(function(a, b, c) {
    	     *   return [a, b, c];
    	     * }, [2, 0, 1]);
    	     *
    	     * rearged('b', 'c', 'a')
    	     * // => ['a', 'b', 'c']
    	     */var rearg=flatRest(function(func,indexes){return createWrap(func,WRAP_REARG_FLAG,undefined$1,undefined$1,undefined$1,indexes);});/**
    	     * Creates a function that invokes `func` with the `this` binding of the
    	     * created function and arguments from `start` and beyond provided as
    	     * an array.
    	     *
    	     * **Note:** This method is based on the
    	     * [rest parameter](https://mdn.io/rest_parameters).
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Function
    	     * @param {Function} func The function to apply a rest parameter to.
    	     * @param {number} [start=func.length-1] The start position of the rest parameter.
    	     * @returns {Function} Returns the new function.
    	     * @example
    	     *
    	     * var say = _.rest(function(what, names) {
    	     *   return what + ' ' + _.initial(names).join(', ') +
    	     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
    	     * });
    	     *
    	     * say('hello', 'fred', 'barney', 'pebbles');
    	     * // => 'hello fred, barney, & pebbles'
    	     */function rest(func,start){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}start=start===undefined$1?start:toInteger(start);return baseRest(func,start);}/**
    	     * Creates a function that invokes `func` with the `this` binding of the
    	     * create function and an array of arguments much like
    	     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
    	     *
    	     * **Note:** This method is based on the
    	     * [spread operator](https://mdn.io/spread_operator).
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 3.2.0
    	     * @category Function
    	     * @param {Function} func The function to spread arguments over.
    	     * @param {number} [start=0] The start position of the spread.
    	     * @returns {Function} Returns the new function.
    	     * @example
    	     *
    	     * var say = _.spread(function(who, what) {
    	     *   return who + ' says ' + what;
    	     * });
    	     *
    	     * say(['fred', 'hello']);
    	     * // => 'fred says hello'
    	     *
    	     * var numbers = Promise.all([
    	     *   Promise.resolve(40),
    	     *   Promise.resolve(36)
    	     * ]);
    	     *
    	     * numbers.then(_.spread(function(x, y) {
    	     *   return x + y;
    	     * }));
    	     * // => a Promise of 76
    	     */function spread(func,start){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}start=start==null?0:nativeMax(toInteger(start),0);return baseRest(function(args){var array=args[start],otherArgs=castSlice(args,0,start);if(array){arrayPush(otherArgs,array);}return apply(func,this,otherArgs);});}/**
    	     * Creates a throttled function that only invokes `func` at most once per
    	     * every `wait` milliseconds. The throttled function comes with a `cancel`
    	     * method to cancel delayed `func` invocations and a `flush` method to
    	     * immediately invoke them. Provide `options` to indicate whether `func`
    	     * should be invoked on the leading and/or trailing edge of the `wait`
    	     * timeout. The `func` is invoked with the last arguments provided to the
    	     * throttled function. Subsequent calls to the throttled function return the
    	     * result of the last `func` invocation.
    	     *
    	     * **Note:** If `leading` and `trailing` options are `true`, `func` is
    	     * invoked on the trailing edge of the timeout only if the throttled function
    	     * is invoked more than once during the `wait` timeout.
    	     *
    	     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
    	     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
    	     *
    	     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
    	     * for details over the differences between `_.throttle` and `_.debounce`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.1.0
    	     * @category Function
    	     * @param {Function} func The function to throttle.
    	     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
    	     * @param {Object} [options={}] The options object.
    	     * @param {boolean} [options.leading=true]
    	     *  Specify invoking on the leading edge of the timeout.
    	     * @param {boolean} [options.trailing=true]
    	     *  Specify invoking on the trailing edge of the timeout.
    	     * @returns {Function} Returns the new throttled function.
    	     * @example
    	     *
    	     * // Avoid excessively updating the position while scrolling.
    	     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
    	     *
    	     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
    	     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
    	     * jQuery(element).on('click', throttled);
    	     *
    	     * // Cancel the trailing throttled invocation.
    	     * jQuery(window).on('popstate', throttled.cancel);
    	     */function throttle(func,wait,options){var leading=true,trailing=true;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}if(isObject(options)){leading='leading'in options?!!options.leading:leading;trailing='trailing'in options?!!options.trailing:trailing;}return debounce(func,wait,{'leading':leading,'maxWait':wait,'trailing':trailing});}/**
    	     * Creates a function that accepts up to one argument, ignoring any
    	     * additional arguments.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Function
    	     * @param {Function} func The function to cap arguments for.
    	     * @returns {Function} Returns the new capped function.
    	     * @example
    	     *
    	     * _.map(['6', '8', '10'], _.unary(parseInt));
    	     * // => [6, 8, 10]
    	     */function unary(func){return ary(func,1);}/**
    	     * Creates a function that provides `value` to `wrapper` as its first
    	     * argument. Any additional arguments provided to the function are appended
    	     * to those provided to the `wrapper`. The wrapper is invoked with the `this`
    	     * binding of the created function.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.1.0
    	     * @category Function
    	     * @param {*} value The value to wrap.
    	     * @param {Function} [wrapper=identity] The wrapper function.
    	     * @returns {Function} Returns the new function.
    	     * @example
    	     *
    	     * var p = _.wrap(_.escape, function(func, text) {
    	     *   return '<p>' + func(text) + '</p>';
    	     * });
    	     *
    	     * p('fred, barney, & pebbles');
    	     * // => '<p>fred, barney, &amp; pebbles</p>'
    	     */function wrap(value,wrapper){return partial(castFunction(wrapper),value);}/*------------------------------------------------------------------------*/ /**
    	     * Casts `value` as an array if it's not one.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.4.0
    	     * @category Lang
    	     * @param {*} value The value to inspect.
    	     * @returns {Array} Returns the cast array.
    	     * @example
    	     *
    	     * _.castArray(1);
    	     * // => [1]
    	     *
    	     * _.castArray({ 'a': 1 });
    	     * // => [{ 'a': 1 }]
    	     *
    	     * _.castArray('abc');
    	     * // => ['abc']
    	     *
    	     * _.castArray(null);
    	     * // => [null]
    	     *
    	     * _.castArray(undefined);
    	     * // => [undefined]
    	     *
    	     * _.castArray();
    	     * // => []
    	     *
    	     * var array = [1, 2, 3];
    	     * console.log(_.castArray(array) === array);
    	     * // => true
    	     */function castArray(){if(!arguments.length){return [];}var value=arguments[0];return isArray(value)?value:[value];}/**
    	     * Creates a shallow clone of `value`.
    	     *
    	     * **Note:** This method is loosely based on the
    	     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
    	     * and supports cloning arrays, array buffers, booleans, date objects, maps,
    	     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
    	     * arrays. The own enumerable properties of `arguments` objects are cloned
    	     * as plain objects. An empty object is returned for uncloneable values such
    	     * as error objects, functions, DOM nodes, and WeakMaps.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.1.0
    	     * @category Lang
    	     * @param {*} value The value to clone.
    	     * @returns {*} Returns the cloned value.
    	     * @see _.cloneDeep
    	     * @example
    	     *
    	     * var objects = [{ 'a': 1 }, { 'b': 2 }];
    	     *
    	     * var shallow = _.clone(objects);
    	     * console.log(shallow[0] === objects[0]);
    	     * // => true
    	     */function clone(value){return baseClone(value,CLONE_SYMBOLS_FLAG);}/**
    	     * This method is like `_.clone` except that it accepts `customizer` which
    	     * is invoked to produce the cloned value. If `customizer` returns `undefined`,
    	     * cloning is handled by the method instead. The `customizer` is invoked with
    	     * up to four arguments; (value [, index|key, object, stack]).
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Lang
    	     * @param {*} value The value to clone.
    	     * @param {Function} [customizer] The function to customize cloning.
    	     * @returns {*} Returns the cloned value.
    	     * @see _.cloneDeepWith
    	     * @example
    	     *
    	     * function customizer(value) {
    	     *   if (_.isElement(value)) {
    	     *     return value.cloneNode(false);
    	     *   }
    	     * }
    	     *
    	     * var el = _.cloneWith(document.body, customizer);
    	     *
    	     * console.log(el === document.body);
    	     * // => false
    	     * console.log(el.nodeName);
    	     * // => 'BODY'
    	     * console.log(el.childNodes.length);
    	     * // => 0
    	     */function cloneWith(value,customizer){customizer=typeof customizer=='function'?customizer:undefined$1;return baseClone(value,CLONE_SYMBOLS_FLAG,customizer);}/**
    	     * This method is like `_.clone` except that it recursively clones `value`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 1.0.0
    	     * @category Lang
    	     * @param {*} value The value to recursively clone.
    	     * @returns {*} Returns the deep cloned value.
    	     * @see _.clone
    	     * @example
    	     *
    	     * var objects = [{ 'a': 1 }, { 'b': 2 }];
    	     *
    	     * var deep = _.cloneDeep(objects);
    	     * console.log(deep[0] === objects[0]);
    	     * // => false
    	     */function cloneDeep(value){return baseClone(value,CLONE_DEEP_FLAG|CLONE_SYMBOLS_FLAG);}/**
    	     * This method is like `_.cloneWith` except that it recursively clones `value`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Lang
    	     * @param {*} value The value to recursively clone.
    	     * @param {Function} [customizer] The function to customize cloning.
    	     * @returns {*} Returns the deep cloned value.
    	     * @see _.cloneWith
    	     * @example
    	     *
    	     * function customizer(value) {
    	     *   if (_.isElement(value)) {
    	     *     return value.cloneNode(true);
    	     *   }
    	     * }
    	     *
    	     * var el = _.cloneDeepWith(document.body, customizer);
    	     *
    	     * console.log(el === document.body);
    	     * // => false
    	     * console.log(el.nodeName);
    	     * // => 'BODY'
    	     * console.log(el.childNodes.length);
    	     * // => 20
    	     */function cloneDeepWith(value,customizer){customizer=typeof customizer=='function'?customizer:undefined$1;return baseClone(value,CLONE_DEEP_FLAG|CLONE_SYMBOLS_FLAG,customizer);}/**
    	     * Checks if `object` conforms to `source` by invoking the predicate
    	     * properties of `source` with the corresponding property values of `object`.
    	     *
    	     * **Note:** This method is equivalent to `_.conforms` when `source` is
    	     * partially applied.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.14.0
    	     * @category Lang
    	     * @param {Object} object The object to inspect.
    	     * @param {Object} source The object of property predicates to conform to.
    	     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
    	     * @example
    	     *
    	     * var object = { 'a': 1, 'b': 2 };
    	     *
    	     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
    	     * // => true
    	     *
    	     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
    	     * // => false
    	     */function conformsTo(object,source){return source==null||baseConformsTo(object,source,keys(source));}/**
    	     * Performs a
    	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
    	     * comparison between two values to determine if they are equivalent.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Lang
    	     * @param {*} value The value to compare.
    	     * @param {*} other The other value to compare.
    	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
    	     * @example
    	     *
    	     * var object = { 'a': 1 };
    	     * var other = { 'a': 1 };
    	     *
    	     * _.eq(object, object);
    	     * // => true
    	     *
    	     * _.eq(object, other);
    	     * // => false
    	     *
    	     * _.eq('a', 'a');
    	     * // => true
    	     *
    	     * _.eq('a', Object('a'));
    	     * // => false
    	     *
    	     * _.eq(NaN, NaN);
    	     * // => true
    	     */function eq(value,other){return value===other||value!==value&&other!==other;}/**
    	     * Checks if `value` is greater than `other`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 3.9.0
    	     * @category Lang
    	     * @param {*} value The value to compare.
    	     * @param {*} other The other value to compare.
    	     * @returns {boolean} Returns `true` if `value` is greater than `other`,
    	     *  else `false`.
    	     * @see _.lt
    	     * @example
    	     *
    	     * _.gt(3, 1);
    	     * // => true
    	     *
    	     * _.gt(3, 3);
    	     * // => false
    	     *
    	     * _.gt(1, 3);
    	     * // => false
    	     */var gt=createRelationalOperation(baseGt);/**
    	     * Checks if `value` is greater than or equal to `other`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 3.9.0
    	     * @category Lang
    	     * @param {*} value The value to compare.
    	     * @param {*} other The other value to compare.
    	     * @returns {boolean} Returns `true` if `value` is greater than or equal to
    	     *  `other`, else `false`.
    	     * @see _.lte
    	     * @example
    	     *
    	     * _.gte(3, 1);
    	     * // => true
    	     *
    	     * _.gte(3, 3);
    	     * // => true
    	     *
    	     * _.gte(1, 3);
    	     * // => false
    	     */var gte=createRelationalOperation(function(value,other){return value>=other;});/**
    	     * Checks if `value` is likely an `arguments` object.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.1.0
    	     * @category Lang
    	     * @param {*} value The value to check.
    	     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
    	     *  else `false`.
    	     * @example
    	     *
    	     * _.isArguments(function() { return arguments; }());
    	     * // => true
    	     *
    	     * _.isArguments([1, 2, 3]);
    	     * // => false
    	     */var isArguments=baseIsArguments(function(){return arguments;}())?baseIsArguments:function(value){return isObjectLike(value)&&hasOwnProperty.call(value,'callee')&&!propertyIsEnumerable.call(value,'callee');};/**
    	     * Checks if `value` is classified as an `Array` object.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.1.0
    	     * @category Lang
    	     * @param {*} value The value to check.
    	     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
    	     * @example
    	     *
    	     * _.isArray([1, 2, 3]);
    	     * // => true
    	     *
    	     * _.isArray(document.body.children);
    	     * // => false
    	     *
    	     * _.isArray('abc');
    	     * // => false
    	     *
    	     * _.isArray(_.noop);
    	     * // => false
    	     */var isArray=Array.isArray;/**
    	     * Checks if `value` is classified as an `ArrayBuffer` object.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.3.0
    	     * @category Lang
    	     * @param {*} value The value to check.
    	     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
    	     * @example
    	     *
    	     * _.isArrayBuffer(new ArrayBuffer(2));
    	     * // => true
    	     *
    	     * _.isArrayBuffer(new Array(2));
    	     * // => false
    	     */var isArrayBuffer=nodeIsArrayBuffer?baseUnary(nodeIsArrayBuffer):baseIsArrayBuffer;/**
    	     * Checks if `value` is array-like. A value is considered array-like if it's
    	     * not a function and has a `value.length` that's an integer greater than or
    	     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Lang
    	     * @param {*} value The value to check.
    	     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
    	     * @example
    	     *
    	     * _.isArrayLike([1, 2, 3]);
    	     * // => true
    	     *
    	     * _.isArrayLike(document.body.children);
    	     * // => true
    	     *
    	     * _.isArrayLike('abc');
    	     * // => true
    	     *
    	     * _.isArrayLike(_.noop);
    	     * // => false
    	     */function isArrayLike(value){return value!=null&&isLength(value.length)&&!isFunction(value);}/**
    	     * This method is like `_.isArrayLike` except that it also checks if `value`
    	     * is an object.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Lang
    	     * @param {*} value The value to check.
    	     * @returns {boolean} Returns `true` if `value` is an array-like object,
    	     *  else `false`.
    	     * @example
    	     *
    	     * _.isArrayLikeObject([1, 2, 3]);
    	     * // => true
    	     *
    	     * _.isArrayLikeObject(document.body.children);
    	     * // => true
    	     *
    	     * _.isArrayLikeObject('abc');
    	     * // => false
    	     *
    	     * _.isArrayLikeObject(_.noop);
    	     * // => false
    	     */function isArrayLikeObject(value){return isObjectLike(value)&&isArrayLike(value);}/**
    	     * Checks if `value` is classified as a boolean primitive or object.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.1.0
    	     * @category Lang
    	     * @param {*} value The value to check.
    	     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
    	     * @example
    	     *
    	     * _.isBoolean(false);
    	     * // => true
    	     *
    	     * _.isBoolean(null);
    	     * // => false
    	     */function isBoolean(value){return value===true||value===false||isObjectLike(value)&&baseGetTag(value)==boolTag;}/**
    	     * Checks if `value` is a buffer.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.3.0
    	     * @category Lang
    	     * @param {*} value The value to check.
    	     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
    	     * @example
    	     *
    	     * _.isBuffer(new Buffer(2));
    	     * // => true
    	     *
    	     * _.isBuffer(new Uint8Array(2));
    	     * // => false
    	     */var isBuffer=nativeIsBuffer||stubFalse;/**
    	     * Checks if `value` is classified as a `Date` object.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.1.0
    	     * @category Lang
    	     * @param {*} value The value to check.
    	     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
    	     * @example
    	     *
    	     * _.isDate(new Date);
    	     * // => true
    	     *
    	     * _.isDate('Mon April 23 2012');
    	     * // => false
    	     */var isDate=nodeIsDate?baseUnary(nodeIsDate):baseIsDate;/**
    	     * Checks if `value` is likely a DOM element.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.1.0
    	     * @category Lang
    	     * @param {*} value The value to check.
    	     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
    	     * @example
    	     *
    	     * _.isElement(document.body);
    	     * // => true
    	     *
    	     * _.isElement('<body>');
    	     * // => false
    	     */function isElement(value){return isObjectLike(value)&&value.nodeType===1&&!isPlainObject(value);}/**
    	     * Checks if `value` is an empty object, collection, map, or set.
    	     *
    	     * Objects are considered empty if they have no own enumerable string keyed
    	     * properties.
    	     *
    	     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
    	     * jQuery-like collections are considered empty if they have a `length` of `0`.
    	     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.1.0
    	     * @category Lang
    	     * @param {*} value The value to check.
    	     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
    	     * @example
    	     *
    	     * _.isEmpty(null);
    	     * // => true
    	     *
    	     * _.isEmpty(true);
    	     * // => true
    	     *
    	     * _.isEmpty(1);
    	     * // => true
    	     *
    	     * _.isEmpty([1, 2, 3]);
    	     * // => false
    	     *
    	     * _.isEmpty({ 'a': 1 });
    	     * // => false
    	     */function isEmpty(value){if(value==null){return true;}if(isArrayLike(value)&&(isArray(value)||typeof value=='string'||typeof value.splice=='function'||isBuffer(value)||isTypedArray(value)||isArguments(value))){return !value.length;}var tag=getTag(value);if(tag==mapTag||tag==setTag){return !value.size;}if(isPrototype(value)){return !baseKeys(value).length;}for(var key in value){if(hasOwnProperty.call(value,key)){return false;}}return true;}/**
    	     * Performs a deep comparison between two values to determine if they are
    	     * equivalent.
    	     *
    	     * **Note:** This method supports comparing arrays, array buffers, booleans,
    	     * date objects, error objects, maps, numbers, `Object` objects, regexes,
    	     * sets, strings, symbols, and typed arrays. `Object` objects are compared
    	     * by their own, not inherited, enumerable properties. Functions and DOM
    	     * nodes are compared by strict equality, i.e. `===`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.1.0
    	     * @category Lang
    	     * @param {*} value The value to compare.
    	     * @param {*} other The other value to compare.
    	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
    	     * @example
    	     *
    	     * var object = { 'a': 1 };
    	     * var other = { 'a': 1 };
    	     *
    	     * _.isEqual(object, other);
    	     * // => true
    	     *
    	     * object === other;
    	     * // => false
    	     */function isEqual(value,other){return baseIsEqual(value,other);}/**
    	     * This method is like `_.isEqual` except that it accepts `customizer` which
    	     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
    	     * are handled by the method instead. The `customizer` is invoked with up to
    	     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Lang
    	     * @param {*} value The value to compare.
    	     * @param {*} other The other value to compare.
    	     * @param {Function} [customizer] The function to customize comparisons.
    	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
    	     * @example
    	     *
    	     * function isGreeting(value) {
    	     *   return /^h(?:i|ello)$/.test(value);
    	     * }
    	     *
    	     * function customizer(objValue, othValue) {
    	     *   if (isGreeting(objValue) && isGreeting(othValue)) {
    	     *     return true;
    	     *   }
    	     * }
    	     *
    	     * var array = ['hello', 'goodbye'];
    	     * var other = ['hi', 'goodbye'];
    	     *
    	     * _.isEqualWith(array, other, customizer);
    	     * // => true
    	     */function isEqualWith(value,other,customizer){customizer=typeof customizer=='function'?customizer:undefined$1;var result=customizer?customizer(value,other):undefined$1;return result===undefined$1?baseIsEqual(value,other,undefined$1,customizer):!!result;}/**
    	     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
    	     * `SyntaxError`, `TypeError`, or `URIError` object.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 3.0.0
    	     * @category Lang
    	     * @param {*} value The value to check.
    	     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
    	     * @example
    	     *
    	     * _.isError(new Error);
    	     * // => true
    	     *
    	     * _.isError(Error);
    	     * // => false
    	     */function isError(value){if(!isObjectLike(value)){return false;}var tag=baseGetTag(value);return tag==errorTag||tag==domExcTag||typeof value.message=='string'&&typeof value.name=='string'&&!isPlainObject(value);}/**
    	     * Checks if `value` is a finite primitive number.
    	     *
    	     * **Note:** This method is based on
    	     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.1.0
    	     * @category Lang
    	     * @param {*} value The value to check.
    	     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
    	     * @example
    	     *
    	     * _.isFinite(3);
    	     * // => true
    	     *
    	     * _.isFinite(Number.MIN_VALUE);
    	     * // => true
    	     *
    	     * _.isFinite(Infinity);
    	     * // => false
    	     *
    	     * _.isFinite('3');
    	     * // => false
    	     */function isFinite(value){return typeof value=='number'&&nativeIsFinite(value);}/**
    	     * Checks if `value` is classified as a `Function` object.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.1.0
    	     * @category Lang
    	     * @param {*} value The value to check.
    	     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
    	     * @example
    	     *
    	     * _.isFunction(_);
    	     * // => true
    	     *
    	     * _.isFunction(/abc/);
    	     * // => false
    	     */function isFunction(value){if(!isObject(value)){return false;}// The use of `Object#toString` avoids issues with the `typeof` operator
    	// in Safari 9 which returns 'object' for typed arrays and other constructors.
    	var tag=baseGetTag(value);return tag==funcTag||tag==genTag||tag==asyncTag||tag==proxyTag;}/**
    	     * Checks if `value` is an integer.
    	     *
    	     * **Note:** This method is based on
    	     * [`Number.isInteger`](https://mdn.io/Number/isInteger).
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Lang
    	     * @param {*} value The value to check.
    	     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
    	     * @example
    	     *
    	     * _.isInteger(3);
    	     * // => true
    	     *
    	     * _.isInteger(Number.MIN_VALUE);
    	     * // => false
    	     *
    	     * _.isInteger(Infinity);
    	     * // => false
    	     *
    	     * _.isInteger('3');
    	     * // => false
    	     */function isInteger(value){return typeof value=='number'&&value==toInteger(value);}/**
    	     * Checks if `value` is a valid array-like length.
    	     *
    	     * **Note:** This method is loosely based on
    	     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Lang
    	     * @param {*} value The value to check.
    	     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
    	     * @example
    	     *
    	     * _.isLength(3);
    	     * // => true
    	     *
    	     * _.isLength(Number.MIN_VALUE);
    	     * // => false
    	     *
    	     * _.isLength(Infinity);
    	     * // => false
    	     *
    	     * _.isLength('3');
    	     * // => false
    	     */function isLength(value){return typeof value=='number'&&value>-1&&value%1==0&&value<=MAX_SAFE_INTEGER;}/**
    	     * Checks if `value` is the
    	     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
    	     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.1.0
    	     * @category Lang
    	     * @param {*} value The value to check.
    	     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
    	     * @example
    	     *
    	     * _.isObject({});
    	     * // => true
    	     *
    	     * _.isObject([1, 2, 3]);
    	     * // => true
    	     *
    	     * _.isObject(_.noop);
    	     * // => true
    	     *
    	     * _.isObject(null);
    	     * // => false
    	     */function isObject(value){var type=typeof value;return value!=null&&(type=='object'||type=='function');}/**
    	     * Checks if `value` is object-like. A value is object-like if it's not `null`
    	     * and has a `typeof` result of "object".
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Lang
    	     * @param {*} value The value to check.
    	     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
    	     * @example
    	     *
    	     * _.isObjectLike({});
    	     * // => true
    	     *
    	     * _.isObjectLike([1, 2, 3]);
    	     * // => true
    	     *
    	     * _.isObjectLike(_.noop);
    	     * // => false
    	     *
    	     * _.isObjectLike(null);
    	     * // => false
    	     */function isObjectLike(value){return value!=null&&typeof value=='object';}/**
    	     * Checks if `value` is classified as a `Map` object.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.3.0
    	     * @category Lang
    	     * @param {*} value The value to check.
    	     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
    	     * @example
    	     *
    	     * _.isMap(new Map);
    	     * // => true
    	     *
    	     * _.isMap(new WeakMap);
    	     * // => false
    	     */var isMap=nodeIsMap?baseUnary(nodeIsMap):baseIsMap;/**
    	     * Performs a partial deep comparison between `object` and `source` to
    	     * determine if `object` contains equivalent property values.
    	     *
    	     * **Note:** This method is equivalent to `_.matches` when `source` is
    	     * partially applied.
    	     *
    	     * Partial comparisons will match empty array and empty object `source`
    	     * values against any array or object value, respectively. See `_.isEqual`
    	     * for a list of supported value comparisons.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 3.0.0
    	     * @category Lang
    	     * @param {Object} object The object to inspect.
    	     * @param {Object} source The object of property values to match.
    	     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
    	     * @example
    	     *
    	     * var object = { 'a': 1, 'b': 2 };
    	     *
    	     * _.isMatch(object, { 'b': 2 });
    	     * // => true
    	     *
    	     * _.isMatch(object, { 'b': 1 });
    	     * // => false
    	     */function isMatch(object,source){return object===source||baseIsMatch(object,source,getMatchData(source));}/**
    	     * This method is like `_.isMatch` except that it accepts `customizer` which
    	     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
    	     * are handled by the method instead. The `customizer` is invoked with five
    	     * arguments: (objValue, srcValue, index|key, object, source).
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Lang
    	     * @param {Object} object The object to inspect.
    	     * @param {Object} source The object of property values to match.
    	     * @param {Function} [customizer] The function to customize comparisons.
    	     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
    	     * @example
    	     *
    	     * function isGreeting(value) {
    	     *   return /^h(?:i|ello)$/.test(value);
    	     * }
    	     *
    	     * function customizer(objValue, srcValue) {
    	     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
    	     *     return true;
    	     *   }
    	     * }
    	     *
    	     * var object = { 'greeting': 'hello' };
    	     * var source = { 'greeting': 'hi' };
    	     *
    	     * _.isMatchWith(object, source, customizer);
    	     * // => true
    	     */function isMatchWith(object,source,customizer){customizer=typeof customizer=='function'?customizer:undefined$1;return baseIsMatch(object,source,getMatchData(source),customizer);}/**
    	     * Checks if `value` is `NaN`.
    	     *
    	     * **Note:** This method is based on
    	     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
    	     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
    	     * `undefined` and other non-number values.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.1.0
    	     * @category Lang
    	     * @param {*} value The value to check.
    	     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
    	     * @example
    	     *
    	     * _.isNaN(NaN);
    	     * // => true
    	     *
    	     * _.isNaN(new Number(NaN));
    	     * // => true
    	     *
    	     * isNaN(undefined);
    	     * // => true
    	     *
    	     * _.isNaN(undefined);
    	     * // => false
    	     */function isNaN(value){// An `NaN` primitive is the only value that is not equal to itself.
    	// Perform the `toStringTag` check first to avoid errors with some
    	// ActiveX objects in IE.
    	return isNumber(value)&&value!=+value;}/**
    	     * Checks if `value` is a pristine native function.
    	     *
    	     * **Note:** This method can't reliably detect native functions in the presence
    	     * of the core-js package because core-js circumvents this kind of detection.
    	     * Despite multiple requests, the core-js maintainer has made it clear: any
    	     * attempt to fix the detection will be obstructed. As a result, we're left
    	     * with little choice but to throw an error. Unfortunately, this also affects
    	     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
    	     * which rely on core-js.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 3.0.0
    	     * @category Lang
    	     * @param {*} value The value to check.
    	     * @returns {boolean} Returns `true` if `value` is a native function,
    	     *  else `false`.
    	     * @example
    	     *
    	     * _.isNative(Array.prototype.push);
    	     * // => true
    	     *
    	     * _.isNative(_);
    	     * // => false
    	     */function isNative(value){if(isMaskable(value)){throw new Error(CORE_ERROR_TEXT);}return baseIsNative(value);}/**
    	     * Checks if `value` is `null`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.1.0
    	     * @category Lang
    	     * @param {*} value The value to check.
    	     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
    	     * @example
    	     *
    	     * _.isNull(null);
    	     * // => true
    	     *
    	     * _.isNull(void 0);
    	     * // => false
    	     */function isNull(value){return value===null;}/**
    	     * Checks if `value` is `null` or `undefined`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Lang
    	     * @param {*} value The value to check.
    	     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
    	     * @example
    	     *
    	     * _.isNil(null);
    	     * // => true
    	     *
    	     * _.isNil(void 0);
    	     * // => true
    	     *
    	     * _.isNil(NaN);
    	     * // => false
    	     */function isNil(value){return value==null;}/**
    	     * Checks if `value` is classified as a `Number` primitive or object.
    	     *
    	     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
    	     * classified as numbers, use the `_.isFinite` method.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.1.0
    	     * @category Lang
    	     * @param {*} value The value to check.
    	     * @returns {boolean} Returns `true` if `value` is a number, else `false`.
    	     * @example
    	     *
    	     * _.isNumber(3);
    	     * // => true
    	     *
    	     * _.isNumber(Number.MIN_VALUE);
    	     * // => true
    	     *
    	     * _.isNumber(Infinity);
    	     * // => true
    	     *
    	     * _.isNumber('3');
    	     * // => false
    	     */function isNumber(value){return typeof value=='number'||isObjectLike(value)&&baseGetTag(value)==numberTag;}/**
    	     * Checks if `value` is a plain object, that is, an object created by the
    	     * `Object` constructor or one with a `[[Prototype]]` of `null`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.8.0
    	     * @category Lang
    	     * @param {*} value The value to check.
    	     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
    	     * @example
    	     *
    	     * function Foo() {
    	     *   this.a = 1;
    	     * }
    	     *
    	     * _.isPlainObject(new Foo);
    	     * // => false
    	     *
    	     * _.isPlainObject([1, 2, 3]);
    	     * // => false
    	     *
    	     * _.isPlainObject({ 'x': 0, 'y': 0 });
    	     * // => true
    	     *
    	     * _.isPlainObject(Object.create(null));
    	     * // => true
    	     */function isPlainObject(value){if(!isObjectLike(value)||baseGetTag(value)!=objectTag){return false;}var proto=getPrototype(value);if(proto===null){return true;}var Ctor=hasOwnProperty.call(proto,'constructor')&&proto.constructor;return typeof Ctor=='function'&&Ctor instanceof Ctor&&funcToString.call(Ctor)==objectCtorString;}/**
    	     * Checks if `value` is classified as a `RegExp` object.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.1.0
    	     * @category Lang
    	     * @param {*} value The value to check.
    	     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
    	     * @example
    	     *
    	     * _.isRegExp(/abc/);
    	     * // => true
    	     *
    	     * _.isRegExp('/abc/');
    	     * // => false
    	     */var isRegExp=nodeIsRegExp?baseUnary(nodeIsRegExp):baseIsRegExp;/**
    	     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
    	     * double precision number which isn't the result of a rounded unsafe integer.
    	     *
    	     * **Note:** This method is based on
    	     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Lang
    	     * @param {*} value The value to check.
    	     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
    	     * @example
    	     *
    	     * _.isSafeInteger(3);
    	     * // => true
    	     *
    	     * _.isSafeInteger(Number.MIN_VALUE);
    	     * // => false
    	     *
    	     * _.isSafeInteger(Infinity);
    	     * // => false
    	     *
    	     * _.isSafeInteger('3');
    	     * // => false
    	     */function isSafeInteger(value){return isInteger(value)&&value>=-MAX_SAFE_INTEGER&&value<=MAX_SAFE_INTEGER;}/**
    	     * Checks if `value` is classified as a `Set` object.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.3.0
    	     * @category Lang
    	     * @param {*} value The value to check.
    	     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
    	     * @example
    	     *
    	     * _.isSet(new Set);
    	     * // => true
    	     *
    	     * _.isSet(new WeakSet);
    	     * // => false
    	     */var isSet=nodeIsSet?baseUnary(nodeIsSet):baseIsSet;/**
    	     * Checks if `value` is classified as a `String` primitive or object.
    	     *
    	     * @static
    	     * @since 0.1.0
    	     * @memberOf _
    	     * @category Lang
    	     * @param {*} value The value to check.
    	     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
    	     * @example
    	     *
    	     * _.isString('abc');
    	     * // => true
    	     *
    	     * _.isString(1);
    	     * // => false
    	     */function isString(value){return typeof value=='string'||!isArray(value)&&isObjectLike(value)&&baseGetTag(value)==stringTag;}/**
    	     * Checks if `value` is classified as a `Symbol` primitive or object.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Lang
    	     * @param {*} value The value to check.
    	     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
    	     * @example
    	     *
    	     * _.isSymbol(Symbol.iterator);
    	     * // => true
    	     *
    	     * _.isSymbol('abc');
    	     * // => false
    	     */function isSymbol(value){return typeof value=='symbol'||isObjectLike(value)&&baseGetTag(value)==symbolTag;}/**
    	     * Checks if `value` is classified as a typed array.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 3.0.0
    	     * @category Lang
    	     * @param {*} value The value to check.
    	     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
    	     * @example
    	     *
    	     * _.isTypedArray(new Uint8Array);
    	     * // => true
    	     *
    	     * _.isTypedArray([]);
    	     * // => false
    	     */var isTypedArray=nodeIsTypedArray?baseUnary(nodeIsTypedArray):baseIsTypedArray;/**
    	     * Checks if `value` is `undefined`.
    	     *
    	     * @static
    	     * @since 0.1.0
    	     * @memberOf _
    	     * @category Lang
    	     * @param {*} value The value to check.
    	     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
    	     * @example
    	     *
    	     * _.isUndefined(void 0);
    	     * // => true
    	     *
    	     * _.isUndefined(null);
    	     * // => false
    	     */function isUndefined(value){return value===undefined$1;}/**
    	     * Checks if `value` is classified as a `WeakMap` object.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.3.0
    	     * @category Lang
    	     * @param {*} value The value to check.
    	     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
    	     * @example
    	     *
    	     * _.isWeakMap(new WeakMap);
    	     * // => true
    	     *
    	     * _.isWeakMap(new Map);
    	     * // => false
    	     */function isWeakMap(value){return isObjectLike(value)&&getTag(value)==weakMapTag;}/**
    	     * Checks if `value` is classified as a `WeakSet` object.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.3.0
    	     * @category Lang
    	     * @param {*} value The value to check.
    	     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
    	     * @example
    	     *
    	     * _.isWeakSet(new WeakSet);
    	     * // => true
    	     *
    	     * _.isWeakSet(new Set);
    	     * // => false
    	     */function isWeakSet(value){return isObjectLike(value)&&baseGetTag(value)==weakSetTag;}/**
    	     * Checks if `value` is less than `other`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 3.9.0
    	     * @category Lang
    	     * @param {*} value The value to compare.
    	     * @param {*} other The other value to compare.
    	     * @returns {boolean} Returns `true` if `value` is less than `other`,
    	     *  else `false`.
    	     * @see _.gt
    	     * @example
    	     *
    	     * _.lt(1, 3);
    	     * // => true
    	     *
    	     * _.lt(3, 3);
    	     * // => false
    	     *
    	     * _.lt(3, 1);
    	     * // => false
    	     */var lt=createRelationalOperation(baseLt);/**
    	     * Checks if `value` is less than or equal to `other`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 3.9.0
    	     * @category Lang
    	     * @param {*} value The value to compare.
    	     * @param {*} other The other value to compare.
    	     * @returns {boolean} Returns `true` if `value` is less than or equal to
    	     *  `other`, else `false`.
    	     * @see _.gte
    	     * @example
    	     *
    	     * _.lte(1, 3);
    	     * // => true
    	     *
    	     * _.lte(3, 3);
    	     * // => true
    	     *
    	     * _.lte(3, 1);
    	     * // => false
    	     */var lte=createRelationalOperation(function(value,other){return value<=other;});/**
    	     * Converts `value` to an array.
    	     *
    	     * @static
    	     * @since 0.1.0
    	     * @memberOf _
    	     * @category Lang
    	     * @param {*} value The value to convert.
    	     * @returns {Array} Returns the converted array.
    	     * @example
    	     *
    	     * _.toArray({ 'a': 1, 'b': 2 });
    	     * // => [1, 2]
    	     *
    	     * _.toArray('abc');
    	     * // => ['a', 'b', 'c']
    	     *
    	     * _.toArray(1);
    	     * // => []
    	     *
    	     * _.toArray(null);
    	     * // => []
    	     */function toArray(value){if(!value){return [];}if(isArrayLike(value)){return isString(value)?stringToArray(value):copyArray(value);}if(symIterator&&value[symIterator]){return iteratorToArray(value[symIterator]());}var tag=getTag(value),func=tag==mapTag?mapToArray:tag==setTag?setToArray:values;return func(value);}/**
    	     * Converts `value` to a finite number.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.12.0
    	     * @category Lang
    	     * @param {*} value The value to convert.
    	     * @returns {number} Returns the converted number.
    	     * @example
    	     *
    	     * _.toFinite(3.2);
    	     * // => 3.2
    	     *
    	     * _.toFinite(Number.MIN_VALUE);
    	     * // => 5e-324
    	     *
    	     * _.toFinite(Infinity);
    	     * // => 1.7976931348623157e+308
    	     *
    	     * _.toFinite('3.2');
    	     * // => 3.2
    	     */function toFinite(value){if(!value){return value===0?value:0;}value=toNumber(value);if(value===INFINITY||value===-INFINITY){var sign=value<0?-1:1;return sign*MAX_INTEGER;}return value===value?value:0;}/**
    	     * Converts `value` to an integer.
    	     *
    	     * **Note:** This method is loosely based on
    	     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Lang
    	     * @param {*} value The value to convert.
    	     * @returns {number} Returns the converted integer.
    	     * @example
    	     *
    	     * _.toInteger(3.2);
    	     * // => 3
    	     *
    	     * _.toInteger(Number.MIN_VALUE);
    	     * // => 0
    	     *
    	     * _.toInteger(Infinity);
    	     * // => 1.7976931348623157e+308
    	     *
    	     * _.toInteger('3.2');
    	     * // => 3
    	     */function toInteger(value){var result=toFinite(value),remainder=result%1;return result===result?remainder?result-remainder:result:0;}/**
    	     * Converts `value` to an integer suitable for use as the length of an
    	     * array-like object.
    	     *
    	     * **Note:** This method is based on
    	     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Lang
    	     * @param {*} value The value to convert.
    	     * @returns {number} Returns the converted integer.
    	     * @example
    	     *
    	     * _.toLength(3.2);
    	     * // => 3
    	     *
    	     * _.toLength(Number.MIN_VALUE);
    	     * // => 0
    	     *
    	     * _.toLength(Infinity);
    	     * // => 4294967295
    	     *
    	     * _.toLength('3.2');
    	     * // => 3
    	     */function toLength(value){return value?baseClamp(toInteger(value),0,MAX_ARRAY_LENGTH):0;}/**
    	     * Converts `value` to a number.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Lang
    	     * @param {*} value The value to process.
    	     * @returns {number} Returns the number.
    	     * @example
    	     *
    	     * _.toNumber(3.2);
    	     * // => 3.2
    	     *
    	     * _.toNumber(Number.MIN_VALUE);
    	     * // => 5e-324
    	     *
    	     * _.toNumber(Infinity);
    	     * // => Infinity
    	     *
    	     * _.toNumber('3.2');
    	     * // => 3.2
    	     */function toNumber(value){if(typeof value=='number'){return value;}if(isSymbol(value)){return NAN;}if(isObject(value)){var other=typeof value.valueOf=='function'?value.valueOf():value;value=isObject(other)?other+'':other;}if(typeof value!='string'){return value===0?value:+value;}value=baseTrim(value);var isBinary=reIsBinary.test(value);return isBinary||reIsOctal.test(value)?freeParseInt(value.slice(2),isBinary?2:8):reIsBadHex.test(value)?NAN:+value;}/**
    	     * Converts `value` to a plain object flattening inherited enumerable string
    	     * keyed properties of `value` to own properties of the plain object.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 3.0.0
    	     * @category Lang
    	     * @param {*} value The value to convert.
    	     * @returns {Object} Returns the converted plain object.
    	     * @example
    	     *
    	     * function Foo() {
    	     *   this.b = 2;
    	     * }
    	     *
    	     * Foo.prototype.c = 3;
    	     *
    	     * _.assign({ 'a': 1 }, new Foo);
    	     * // => { 'a': 1, 'b': 2 }
    	     *
    	     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
    	     * // => { 'a': 1, 'b': 2, 'c': 3 }
    	     */function toPlainObject(value){return copyObject(value,keysIn(value));}/**
    	     * Converts `value` to a safe integer. A safe integer can be compared and
    	     * represented correctly.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Lang
    	     * @param {*} value The value to convert.
    	     * @returns {number} Returns the converted integer.
    	     * @example
    	     *
    	     * _.toSafeInteger(3.2);
    	     * // => 3
    	     *
    	     * _.toSafeInteger(Number.MIN_VALUE);
    	     * // => 0
    	     *
    	     * _.toSafeInteger(Infinity);
    	     * // => 9007199254740991
    	     *
    	     * _.toSafeInteger('3.2');
    	     * // => 3
    	     */function toSafeInteger(value){return value?baseClamp(toInteger(value),-MAX_SAFE_INTEGER,MAX_SAFE_INTEGER):value===0?value:0;}/**
    	     * Converts `value` to a string. An empty string is returned for `null`
    	     * and `undefined` values. The sign of `-0` is preserved.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Lang
    	     * @param {*} value The value to convert.
    	     * @returns {string} Returns the converted string.
    	     * @example
    	     *
    	     * _.toString(null);
    	     * // => ''
    	     *
    	     * _.toString(-0);
    	     * // => '-0'
    	     *
    	     * _.toString([1, 2, 3]);
    	     * // => '1,2,3'
    	     */function toString(value){return value==null?'':baseToString(value);}/*------------------------------------------------------------------------*/ /**
    	     * Assigns own enumerable string keyed properties of source objects to the
    	     * destination object. Source objects are applied from left to right.
    	     * Subsequent sources overwrite property assignments of previous sources.
    	     *
    	     * **Note:** This method mutates `object` and is loosely based on
    	     * [`Object.assign`](https://mdn.io/Object/assign).
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.10.0
    	     * @category Object
    	     * @param {Object} object The destination object.
    	     * @param {...Object} [sources] The source objects.
    	     * @returns {Object} Returns `object`.
    	     * @see _.assignIn
    	     * @example
    	     *
    	     * function Foo() {
    	     *   this.a = 1;
    	     * }
    	     *
    	     * function Bar() {
    	     *   this.c = 3;
    	     * }
    	     *
    	     * Foo.prototype.b = 2;
    	     * Bar.prototype.d = 4;
    	     *
    	     * _.assign({ 'a': 0 }, new Foo, new Bar);
    	     * // => { 'a': 1, 'c': 3 }
    	     */var assign=createAssigner(function(object,source){if(isPrototype(source)||isArrayLike(source)){copyObject(source,keys(source),object);return;}for(var key in source){if(hasOwnProperty.call(source,key)){assignValue(object,key,source[key]);}}});/**
    	     * This method is like `_.assign` except that it iterates over own and
    	     * inherited source properties.
    	     *
    	     * **Note:** This method mutates `object`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @alias extend
    	     * @category Object
    	     * @param {Object} object The destination object.
    	     * @param {...Object} [sources] The source objects.
    	     * @returns {Object} Returns `object`.
    	     * @see _.assign
    	     * @example
    	     *
    	     * function Foo() {
    	     *   this.a = 1;
    	     * }
    	     *
    	     * function Bar() {
    	     *   this.c = 3;
    	     * }
    	     *
    	     * Foo.prototype.b = 2;
    	     * Bar.prototype.d = 4;
    	     *
    	     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
    	     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
    	     */var assignIn=createAssigner(function(object,source){copyObject(source,keysIn(source),object);});/**
    	     * This method is like `_.assignIn` except that it accepts `customizer`
    	     * which is invoked to produce the assigned values. If `customizer` returns
    	     * `undefined`, assignment is handled by the method instead. The `customizer`
    	     * is invoked with five arguments: (objValue, srcValue, key, object, source).
    	     *
    	     * **Note:** This method mutates `object`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @alias extendWith
    	     * @category Object
    	     * @param {Object} object The destination object.
    	     * @param {...Object} sources The source objects.
    	     * @param {Function} [customizer] The function to customize assigned values.
    	     * @returns {Object} Returns `object`.
    	     * @see _.assignWith
    	     * @example
    	     *
    	     * function customizer(objValue, srcValue) {
    	     *   return _.isUndefined(objValue) ? srcValue : objValue;
    	     * }
    	     *
    	     * var defaults = _.partialRight(_.assignInWith, customizer);
    	     *
    	     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
    	     * // => { 'a': 1, 'b': 2 }
    	     */var assignInWith=createAssigner(function(object,source,srcIndex,customizer){copyObject(source,keysIn(source),object,customizer);});/**
    	     * This method is like `_.assign` except that it accepts `customizer`
    	     * which is invoked to produce the assigned values. If `customizer` returns
    	     * `undefined`, assignment is handled by the method instead. The `customizer`
    	     * is invoked with five arguments: (objValue, srcValue, key, object, source).
    	     *
    	     * **Note:** This method mutates `object`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Object
    	     * @param {Object} object The destination object.
    	     * @param {...Object} sources The source objects.
    	     * @param {Function} [customizer] The function to customize assigned values.
    	     * @returns {Object} Returns `object`.
    	     * @see _.assignInWith
    	     * @example
    	     *
    	     * function customizer(objValue, srcValue) {
    	     *   return _.isUndefined(objValue) ? srcValue : objValue;
    	     * }
    	     *
    	     * var defaults = _.partialRight(_.assignWith, customizer);
    	     *
    	     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
    	     * // => { 'a': 1, 'b': 2 }
    	     */var assignWith=createAssigner(function(object,source,srcIndex,customizer){copyObject(source,keys(source),object,customizer);});/**
    	     * Creates an array of values corresponding to `paths` of `object`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 1.0.0
    	     * @category Object
    	     * @param {Object} object The object to iterate over.
    	     * @param {...(string|string[])} [paths] The property paths to pick.
    	     * @returns {Array} Returns the picked values.
    	     * @example
    	     *
    	     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
    	     *
    	     * _.at(object, ['a[0].b.c', 'a[1]']);
    	     * // => [3, 4]
    	     */var at=flatRest(baseAt);/**
    	     * Creates an object that inherits from the `prototype` object. If a
    	     * `properties` object is given, its own enumerable string keyed properties
    	     * are assigned to the created object.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 2.3.0
    	     * @category Object
    	     * @param {Object} prototype The object to inherit from.
    	     * @param {Object} [properties] The properties to assign to the object.
    	     * @returns {Object} Returns the new object.
    	     * @example
    	     *
    	     * function Shape() {
    	     *   this.x = 0;
    	     *   this.y = 0;
    	     * }
    	     *
    	     * function Circle() {
    	     *   Shape.call(this);
    	     * }
    	     *
    	     * Circle.prototype = _.create(Shape.prototype, {
    	     *   'constructor': Circle
    	     * });
    	     *
    	     * var circle = new Circle;
    	     * circle instanceof Circle;
    	     * // => true
    	     *
    	     * circle instanceof Shape;
    	     * // => true
    	     */function create(prototype,properties){var result=baseCreate(prototype);return properties==null?result:baseAssign(result,properties);}/**
    	     * Assigns own and inherited enumerable string keyed properties of source
    	     * objects to the destination object for all destination properties that
    	     * resolve to `undefined`. Source objects are applied from left to right.
    	     * Once a property is set, additional values of the same property are ignored.
    	     *
    	     * **Note:** This method mutates `object`.
    	     *
    	     * @static
    	     * @since 0.1.0
    	     * @memberOf _
    	     * @category Object
    	     * @param {Object} object The destination object.
    	     * @param {...Object} [sources] The source objects.
    	     * @returns {Object} Returns `object`.
    	     * @see _.defaultsDeep
    	     * @example
    	     *
    	     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
    	     * // => { 'a': 1, 'b': 2 }
    	     */var defaults=baseRest(function(object,sources){object=Object(object);var index=-1;var length=sources.length;var guard=length>2?sources[2]:undefined$1;if(guard&&isIterateeCall(sources[0],sources[1],guard)){length=1;}while(++index<length){var source=sources[index];var props=keysIn(source);var propsIndex=-1;var propsLength=props.length;while(++propsIndex<propsLength){var key=props[propsIndex];var value=object[key];if(value===undefined$1||eq(value,objectProto[key])&&!hasOwnProperty.call(object,key)){object[key]=source[key];}}}return object;});/**
    	     * This method is like `_.defaults` except that it recursively assigns
    	     * default properties.
    	     *
    	     * **Note:** This method mutates `object`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 3.10.0
    	     * @category Object
    	     * @param {Object} object The destination object.
    	     * @param {...Object} [sources] The source objects.
    	     * @returns {Object} Returns `object`.
    	     * @see _.defaults
    	     * @example
    	     *
    	     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
    	     * // => { 'a': { 'b': 2, 'c': 3 } }
    	     */var defaultsDeep=baseRest(function(args){args.push(undefined$1,customDefaultsMerge);return apply(mergeWith,undefined$1,args);});/**
    	     * This method is like `_.find` except that it returns the key of the first
    	     * element `predicate` returns truthy for instead of the element itself.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 1.1.0
    	     * @category Object
    	     * @param {Object} object The object to inspect.
    	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
    	     * @returns {string|undefined} Returns the key of the matched element,
    	     *  else `undefined`.
    	     * @example
    	     *
    	     * var users = {
    	     *   'barney':  { 'age': 36, 'active': true },
    	     *   'fred':    { 'age': 40, 'active': false },
    	     *   'pebbles': { 'age': 1,  'active': true }
    	     * };
    	     *
    	     * _.findKey(users, function(o) { return o.age < 40; });
    	     * // => 'barney' (iteration order is not guaranteed)
    	     *
    	     * // The `_.matches` iteratee shorthand.
    	     * _.findKey(users, { 'age': 1, 'active': true });
    	     * // => 'pebbles'
    	     *
    	     * // The `_.matchesProperty` iteratee shorthand.
    	     * _.findKey(users, ['active', false]);
    	     * // => 'fred'
    	     *
    	     * // The `_.property` iteratee shorthand.
    	     * _.findKey(users, 'active');
    	     * // => 'barney'
    	     */function findKey(object,predicate){return baseFindKey(object,getIteratee(predicate,3),baseForOwn);}/**
    	     * This method is like `_.findKey` except that it iterates over elements of
    	     * a collection in the opposite order.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 2.0.0
    	     * @category Object
    	     * @param {Object} object The object to inspect.
    	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
    	     * @returns {string|undefined} Returns the key of the matched element,
    	     *  else `undefined`.
    	     * @example
    	     *
    	     * var users = {
    	     *   'barney':  { 'age': 36, 'active': true },
    	     *   'fred':    { 'age': 40, 'active': false },
    	     *   'pebbles': { 'age': 1,  'active': true }
    	     * };
    	     *
    	     * _.findLastKey(users, function(o) { return o.age < 40; });
    	     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
    	     *
    	     * // The `_.matches` iteratee shorthand.
    	     * _.findLastKey(users, { 'age': 36, 'active': true });
    	     * // => 'barney'
    	     *
    	     * // The `_.matchesProperty` iteratee shorthand.
    	     * _.findLastKey(users, ['active', false]);
    	     * // => 'fred'
    	     *
    	     * // The `_.property` iteratee shorthand.
    	     * _.findLastKey(users, 'active');
    	     * // => 'pebbles'
    	     */function findLastKey(object,predicate){return baseFindKey(object,getIteratee(predicate,3),baseForOwnRight);}/**
    	     * Iterates over own and inherited enumerable string keyed properties of an
    	     * object and invokes `iteratee` for each property. The iteratee is invoked
    	     * with three arguments: (value, key, object). Iteratee functions may exit
    	     * iteration early by explicitly returning `false`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.3.0
    	     * @category Object
    	     * @param {Object} object The object to iterate over.
    	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
    	     * @returns {Object} Returns `object`.
    	     * @see _.forInRight
    	     * @example
    	     *
    	     * function Foo() {
    	     *   this.a = 1;
    	     *   this.b = 2;
    	     * }
    	     *
    	     * Foo.prototype.c = 3;
    	     *
    	     * _.forIn(new Foo, function(value, key) {
    	     *   console.log(key);
    	     * });
    	     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
    	     */function forIn(object,iteratee){return object==null?object:baseFor(object,getIteratee(iteratee,3),keysIn);}/**
    	     * This method is like `_.forIn` except that it iterates over properties of
    	     * `object` in the opposite order.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 2.0.0
    	     * @category Object
    	     * @param {Object} object The object to iterate over.
    	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
    	     * @returns {Object} Returns `object`.
    	     * @see _.forIn
    	     * @example
    	     *
    	     * function Foo() {
    	     *   this.a = 1;
    	     *   this.b = 2;
    	     * }
    	     *
    	     * Foo.prototype.c = 3;
    	     *
    	     * _.forInRight(new Foo, function(value, key) {
    	     *   console.log(key);
    	     * });
    	     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
    	     */function forInRight(object,iteratee){return object==null?object:baseForRight(object,getIteratee(iteratee,3),keysIn);}/**
    	     * Iterates over own enumerable string keyed properties of an object and
    	     * invokes `iteratee` for each property. The iteratee is invoked with three
    	     * arguments: (value, key, object). Iteratee functions may exit iteration
    	     * early by explicitly returning `false`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.3.0
    	     * @category Object
    	     * @param {Object} object The object to iterate over.
    	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
    	     * @returns {Object} Returns `object`.
    	     * @see _.forOwnRight
    	     * @example
    	     *
    	     * function Foo() {
    	     *   this.a = 1;
    	     *   this.b = 2;
    	     * }
    	     *
    	     * Foo.prototype.c = 3;
    	     *
    	     * _.forOwn(new Foo, function(value, key) {
    	     *   console.log(key);
    	     * });
    	     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
    	     */function forOwn(object,iteratee){return object&&baseForOwn(object,getIteratee(iteratee,3));}/**
    	     * This method is like `_.forOwn` except that it iterates over properties of
    	     * `object` in the opposite order.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 2.0.0
    	     * @category Object
    	     * @param {Object} object The object to iterate over.
    	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
    	     * @returns {Object} Returns `object`.
    	     * @see _.forOwn
    	     * @example
    	     *
    	     * function Foo() {
    	     *   this.a = 1;
    	     *   this.b = 2;
    	     * }
    	     *
    	     * Foo.prototype.c = 3;
    	     *
    	     * _.forOwnRight(new Foo, function(value, key) {
    	     *   console.log(key);
    	     * });
    	     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
    	     */function forOwnRight(object,iteratee){return object&&baseForOwnRight(object,getIteratee(iteratee,3));}/**
    	     * Creates an array of function property names from own enumerable properties
    	     * of `object`.
    	     *
    	     * @static
    	     * @since 0.1.0
    	     * @memberOf _
    	     * @category Object
    	     * @param {Object} object The object to inspect.
    	     * @returns {Array} Returns the function names.
    	     * @see _.functionsIn
    	     * @example
    	     *
    	     * function Foo() {
    	     *   this.a = _.constant('a');
    	     *   this.b = _.constant('b');
    	     * }
    	     *
    	     * Foo.prototype.c = _.constant('c');
    	     *
    	     * _.functions(new Foo);
    	     * // => ['a', 'b']
    	     */function functions(object){return object==null?[]:baseFunctions(object,keys(object));}/**
    	     * Creates an array of function property names from own and inherited
    	     * enumerable properties of `object`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Object
    	     * @param {Object} object The object to inspect.
    	     * @returns {Array} Returns the function names.
    	     * @see _.functions
    	     * @example
    	     *
    	     * function Foo() {
    	     *   this.a = _.constant('a');
    	     *   this.b = _.constant('b');
    	     * }
    	     *
    	     * Foo.prototype.c = _.constant('c');
    	     *
    	     * _.functionsIn(new Foo);
    	     * // => ['a', 'b', 'c']
    	     */function functionsIn(object){return object==null?[]:baseFunctions(object,keysIn(object));}/**
    	     * Gets the value at `path` of `object`. If the resolved value is
    	     * `undefined`, the `defaultValue` is returned in its place.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 3.7.0
    	     * @category Object
    	     * @param {Object} object The object to query.
    	     * @param {Array|string} path The path of the property to get.
    	     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
    	     * @returns {*} Returns the resolved value.
    	     * @example
    	     *
    	     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
    	     *
    	     * _.get(object, 'a[0].b.c');
    	     * // => 3
    	     *
    	     * _.get(object, ['a', '0', 'b', 'c']);
    	     * // => 3
    	     *
    	     * _.get(object, 'a.b.c', 'default');
    	     * // => 'default'
    	     */function get(object,path,defaultValue){var result=object==null?undefined$1:baseGet(object,path);return result===undefined$1?defaultValue:result;}/**
    	     * Checks if `path` is a direct property of `object`.
    	     *
    	     * @static
    	     * @since 0.1.0
    	     * @memberOf _
    	     * @category Object
    	     * @param {Object} object The object to query.
    	     * @param {Array|string} path The path to check.
    	     * @returns {boolean} Returns `true` if `path` exists, else `false`.
    	     * @example
    	     *
    	     * var object = { 'a': { 'b': 2 } };
    	     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
    	     *
    	     * _.has(object, 'a');
    	     * // => true
    	     *
    	     * _.has(object, 'a.b');
    	     * // => true
    	     *
    	     * _.has(object, ['a', 'b']);
    	     * // => true
    	     *
    	     * _.has(other, 'a');
    	     * // => false
    	     */function has(object,path){return object!=null&&hasPath(object,path,baseHas);}/**
    	     * Checks if `path` is a direct or inherited property of `object`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Object
    	     * @param {Object} object The object to query.
    	     * @param {Array|string} path The path to check.
    	     * @returns {boolean} Returns `true` if `path` exists, else `false`.
    	     * @example
    	     *
    	     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
    	     *
    	     * _.hasIn(object, 'a');
    	     * // => true
    	     *
    	     * _.hasIn(object, 'a.b');
    	     * // => true
    	     *
    	     * _.hasIn(object, ['a', 'b']);
    	     * // => true
    	     *
    	     * _.hasIn(object, 'b');
    	     * // => false
    	     */function hasIn(object,path){return object!=null&&hasPath(object,path,baseHasIn);}/**
    	     * Creates an object composed of the inverted keys and values of `object`.
    	     * If `object` contains duplicate values, subsequent values overwrite
    	     * property assignments of previous values.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.7.0
    	     * @category Object
    	     * @param {Object} object The object to invert.
    	     * @returns {Object} Returns the new inverted object.
    	     * @example
    	     *
    	     * var object = { 'a': 1, 'b': 2, 'c': 1 };
    	     *
    	     * _.invert(object);
    	     * // => { '1': 'c', '2': 'b' }
    	     */var invert=createInverter(function(result,value,key){if(value!=null&&typeof value.toString!='function'){value=nativeObjectToString.call(value);}result[value]=key;},constant(identity));/**
    	     * This method is like `_.invert` except that the inverted object is generated
    	     * from the results of running each element of `object` thru `iteratee`. The
    	     * corresponding inverted value of each inverted key is an array of keys
    	     * responsible for generating the inverted value. The iteratee is invoked
    	     * with one argument: (value).
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.1.0
    	     * @category Object
    	     * @param {Object} object The object to invert.
    	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
    	     * @returns {Object} Returns the new inverted object.
    	     * @example
    	     *
    	     * var object = { 'a': 1, 'b': 2, 'c': 1 };
    	     *
    	     * _.invertBy(object);
    	     * // => { '1': ['a', 'c'], '2': ['b'] }
    	     *
    	     * _.invertBy(object, function(value) {
    	     *   return 'group' + value;
    	     * });
    	     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
    	     */var invertBy=createInverter(function(result,value,key){if(value!=null&&typeof value.toString!='function'){value=nativeObjectToString.call(value);}if(hasOwnProperty.call(result,value)){result[value].push(key);}else {result[value]=[key];}},getIteratee);/**
    	     * Invokes the method at `path` of `object`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Object
    	     * @param {Object} object The object to query.
    	     * @param {Array|string} path The path of the method to invoke.
    	     * @param {...*} [args] The arguments to invoke the method with.
    	     * @returns {*} Returns the result of the invoked method.
    	     * @example
    	     *
    	     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
    	     *
    	     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
    	     * // => [2, 3]
    	     */var invoke=baseRest(baseInvoke);/**
    	     * Creates an array of the own enumerable property names of `object`.
    	     *
    	     * **Note:** Non-object values are coerced to objects. See the
    	     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
    	     * for more details.
    	     *
    	     * @static
    	     * @since 0.1.0
    	     * @memberOf _
    	     * @category Object
    	     * @param {Object} object The object to query.
    	     * @returns {Array} Returns the array of property names.
    	     * @example
    	     *
    	     * function Foo() {
    	     *   this.a = 1;
    	     *   this.b = 2;
    	     * }
    	     *
    	     * Foo.prototype.c = 3;
    	     *
    	     * _.keys(new Foo);
    	     * // => ['a', 'b'] (iteration order is not guaranteed)
    	     *
    	     * _.keys('hi');
    	     * // => ['0', '1']
    	     */function keys(object){return isArrayLike(object)?arrayLikeKeys(object):baseKeys(object);}/**
    	     * Creates an array of the own and inherited enumerable property names of `object`.
    	     *
    	     * **Note:** Non-object values are coerced to objects.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 3.0.0
    	     * @category Object
    	     * @param {Object} object The object to query.
    	     * @returns {Array} Returns the array of property names.
    	     * @example
    	     *
    	     * function Foo() {
    	     *   this.a = 1;
    	     *   this.b = 2;
    	     * }
    	     *
    	     * Foo.prototype.c = 3;
    	     *
    	     * _.keysIn(new Foo);
    	     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
    	     */function keysIn(object){return isArrayLike(object)?arrayLikeKeys(object,true):baseKeysIn(object);}/**
    	     * The opposite of `_.mapValues`; this method creates an object with the
    	     * same values as `object` and keys generated by running each own enumerable
    	     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
    	     * with three arguments: (value, key, object).
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 3.8.0
    	     * @category Object
    	     * @param {Object} object The object to iterate over.
    	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
    	     * @returns {Object} Returns the new mapped object.
    	     * @see _.mapValues
    	     * @example
    	     *
    	     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
    	     *   return key + value;
    	     * });
    	     * // => { 'a1': 1, 'b2': 2 }
    	     */function mapKeys(object,iteratee){var result={};iteratee=getIteratee(iteratee,3);baseForOwn(object,function(value,key,object){baseAssignValue(result,iteratee(value,key,object),value);});return result;}/**
    	     * Creates an object with the same keys as `object` and values generated
    	     * by running each own enumerable string keyed property of `object` thru
    	     * `iteratee`. The iteratee is invoked with three arguments:
    	     * (value, key, object).
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 2.4.0
    	     * @category Object
    	     * @param {Object} object The object to iterate over.
    	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
    	     * @returns {Object} Returns the new mapped object.
    	     * @see _.mapKeys
    	     * @example
    	     *
    	     * var users = {
    	     *   'fred':    { 'user': 'fred',    'age': 40 },
    	     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
    	     * };
    	     *
    	     * _.mapValues(users, function(o) { return o.age; });
    	     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
    	     *
    	     * // The `_.property` iteratee shorthand.
    	     * _.mapValues(users, 'age');
    	     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
    	     */function mapValues(object,iteratee){var result={};iteratee=getIteratee(iteratee,3);baseForOwn(object,function(value,key,object){baseAssignValue(result,key,iteratee(value,key,object));});return result;}/**
    	     * This method is like `_.assign` except that it recursively merges own and
    	     * inherited enumerable string keyed properties of source objects into the
    	     * destination object. Source properties that resolve to `undefined` are
    	     * skipped if a destination value exists. Array and plain object properties
    	     * are merged recursively. Other objects and value types are overridden by
    	     * assignment. Source objects are applied from left to right. Subsequent
    	     * sources overwrite property assignments of previous sources.
    	     *
    	     * **Note:** This method mutates `object`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.5.0
    	     * @category Object
    	     * @param {Object} object The destination object.
    	     * @param {...Object} [sources] The source objects.
    	     * @returns {Object} Returns `object`.
    	     * @example
    	     *
    	     * var object = {
    	     *   'a': [{ 'b': 2 }, { 'd': 4 }]
    	     * };
    	     *
    	     * var other = {
    	     *   'a': [{ 'c': 3 }, { 'e': 5 }]
    	     * };
    	     *
    	     * _.merge(object, other);
    	     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
    	     */var merge=createAssigner(function(object,source,srcIndex){baseMerge(object,source,srcIndex);});/**
    	     * This method is like `_.merge` except that it accepts `customizer` which
    	     * is invoked to produce the merged values of the destination and source
    	     * properties. If `customizer` returns `undefined`, merging is handled by the
    	     * method instead. The `customizer` is invoked with six arguments:
    	     * (objValue, srcValue, key, object, source, stack).
    	     *
    	     * **Note:** This method mutates `object`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Object
    	     * @param {Object} object The destination object.
    	     * @param {...Object} sources The source objects.
    	     * @param {Function} customizer The function to customize assigned values.
    	     * @returns {Object} Returns `object`.
    	     * @example
    	     *
    	     * function customizer(objValue, srcValue) {
    	     *   if (_.isArray(objValue)) {
    	     *     return objValue.concat(srcValue);
    	     *   }
    	     * }
    	     *
    	     * var object = { 'a': [1], 'b': [2] };
    	     * var other = { 'a': [3], 'b': [4] };
    	     *
    	     * _.mergeWith(object, other, customizer);
    	     * // => { 'a': [1, 3], 'b': [2, 4] }
    	     */var mergeWith=createAssigner(function(object,source,srcIndex,customizer){baseMerge(object,source,srcIndex,customizer);});/**
    	     * The opposite of `_.pick`; this method creates an object composed of the
    	     * own and inherited enumerable property paths of `object` that are not omitted.
    	     *
    	     * **Note:** This method is considerably slower than `_.pick`.
    	     *
    	     * @static
    	     * @since 0.1.0
    	     * @memberOf _
    	     * @category Object
    	     * @param {Object} object The source object.
    	     * @param {...(string|string[])} [paths] The property paths to omit.
    	     * @returns {Object} Returns the new object.
    	     * @example
    	     *
    	     * var object = { 'a': 1, 'b': '2', 'c': 3 };
    	     *
    	     * _.omit(object, ['a', 'c']);
    	     * // => { 'b': '2' }
    	     */var omit=flatRest(function(object,paths){var result={};if(object==null){return result;}var isDeep=false;paths=arrayMap(paths,function(path){path=castPath(path,object);isDeep||(isDeep=path.length>1);return path;});copyObject(object,getAllKeysIn(object),result);if(isDeep){result=baseClone(result,CLONE_DEEP_FLAG|CLONE_FLAT_FLAG|CLONE_SYMBOLS_FLAG,customOmitClone);}var length=paths.length;while(length--){baseUnset(result,paths[length]);}return result;});/**
    	     * The opposite of `_.pickBy`; this method creates an object composed of
    	     * the own and inherited enumerable string keyed properties of `object` that
    	     * `predicate` doesn't return truthy for. The predicate is invoked with two
    	     * arguments: (value, key).
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Object
    	     * @param {Object} object The source object.
    	     * @param {Function} [predicate=_.identity] The function invoked per property.
    	     * @returns {Object} Returns the new object.
    	     * @example
    	     *
    	     * var object = { 'a': 1, 'b': '2', 'c': 3 };
    	     *
    	     * _.omitBy(object, _.isNumber);
    	     * // => { 'b': '2' }
    	     */function omitBy(object,predicate){return pickBy(object,negate(getIteratee(predicate)));}/**
    	     * Creates an object composed of the picked `object` properties.
    	     *
    	     * @static
    	     * @since 0.1.0
    	     * @memberOf _
    	     * @category Object
    	     * @param {Object} object The source object.
    	     * @param {...(string|string[])} [paths] The property paths to pick.
    	     * @returns {Object} Returns the new object.
    	     * @example
    	     *
    	     * var object = { 'a': 1, 'b': '2', 'c': 3 };
    	     *
    	     * _.pick(object, ['a', 'c']);
    	     * // => { 'a': 1, 'c': 3 }
    	     */var pick=flatRest(function(object,paths){return object==null?{}:basePick(object,paths);});/**
    	     * Creates an object composed of the `object` properties `predicate` returns
    	     * truthy for. The predicate is invoked with two arguments: (value, key).
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Object
    	     * @param {Object} object The source object.
    	     * @param {Function} [predicate=_.identity] The function invoked per property.
    	     * @returns {Object} Returns the new object.
    	     * @example
    	     *
    	     * var object = { 'a': 1, 'b': '2', 'c': 3 };
    	     *
    	     * _.pickBy(object, _.isNumber);
    	     * // => { 'a': 1, 'c': 3 }
    	     */function pickBy(object,predicate){if(object==null){return {};}var props=arrayMap(getAllKeysIn(object),function(prop){return [prop];});predicate=getIteratee(predicate);return basePickBy(object,props,function(value,path){return predicate(value,path[0]);});}/**
    	     * This method is like `_.get` except that if the resolved value is a
    	     * function it's invoked with the `this` binding of its parent object and
    	     * its result is returned.
    	     *
    	     * @static
    	     * @since 0.1.0
    	     * @memberOf _
    	     * @category Object
    	     * @param {Object} object The object to query.
    	     * @param {Array|string} path The path of the property to resolve.
    	     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
    	     * @returns {*} Returns the resolved value.
    	     * @example
    	     *
    	     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
    	     *
    	     * _.result(object, 'a[0].b.c1');
    	     * // => 3
    	     *
    	     * _.result(object, 'a[0].b.c2');
    	     * // => 4
    	     *
    	     * _.result(object, 'a[0].b.c3', 'default');
    	     * // => 'default'
    	     *
    	     * _.result(object, 'a[0].b.c3', _.constant('default'));
    	     * // => 'default'
    	     */function result(object,path,defaultValue){path=castPath(path,object);var index=-1,length=path.length;// Ensure the loop is entered when path is empty.
    	if(!length){length=1;object=undefined$1;}while(++index<length){var value=object==null?undefined$1:object[toKey(path[index])];if(value===undefined$1){index=length;value=defaultValue;}object=isFunction(value)?value.call(object):value;}return object;}/**
    	     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
    	     * it's created. Arrays are created for missing index properties while objects
    	     * are created for all other missing properties. Use `_.setWith` to customize
    	     * `path` creation.
    	     *
    	     * **Note:** This method mutates `object`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 3.7.0
    	     * @category Object
    	     * @param {Object} object The object to modify.
    	     * @param {Array|string} path The path of the property to set.
    	     * @param {*} value The value to set.
    	     * @returns {Object} Returns `object`.
    	     * @example
    	     *
    	     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
    	     *
    	     * _.set(object, 'a[0].b.c', 4);
    	     * console.log(object.a[0].b.c);
    	     * // => 4
    	     *
    	     * _.set(object, ['x', '0', 'y', 'z'], 5);
    	     * console.log(object.x[0].y.z);
    	     * // => 5
    	     */function set(object,path,value){return object==null?object:baseSet(object,path,value);}/**
    	     * This method is like `_.set` except that it accepts `customizer` which is
    	     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
    	     * path creation is handled by the method instead. The `customizer` is invoked
    	     * with three arguments: (nsValue, key, nsObject).
    	     *
    	     * **Note:** This method mutates `object`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Object
    	     * @param {Object} object The object to modify.
    	     * @param {Array|string} path The path of the property to set.
    	     * @param {*} value The value to set.
    	     * @param {Function} [customizer] The function to customize assigned values.
    	     * @returns {Object} Returns `object`.
    	     * @example
    	     *
    	     * var object = {};
    	     *
    	     * _.setWith(object, '[0][1]', 'a', Object);
    	     * // => { '0': { '1': 'a' } }
    	     */function setWith(object,path,value,customizer){customizer=typeof customizer=='function'?customizer:undefined$1;return object==null?object:baseSet(object,path,value,customizer);}/**
    	     * Creates an array of own enumerable string keyed-value pairs for `object`
    	     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
    	     * entries are returned.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @alias entries
    	     * @category Object
    	     * @param {Object} object The object to query.
    	     * @returns {Array} Returns the key-value pairs.
    	     * @example
    	     *
    	     * function Foo() {
    	     *   this.a = 1;
    	     *   this.b = 2;
    	     * }
    	     *
    	     * Foo.prototype.c = 3;
    	     *
    	     * _.toPairs(new Foo);
    	     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
    	     */var toPairs=createToPairs(keys);/**
    	     * Creates an array of own and inherited enumerable string keyed-value pairs
    	     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
    	     * or set, its entries are returned.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @alias entriesIn
    	     * @category Object
    	     * @param {Object} object The object to query.
    	     * @returns {Array} Returns the key-value pairs.
    	     * @example
    	     *
    	     * function Foo() {
    	     *   this.a = 1;
    	     *   this.b = 2;
    	     * }
    	     *
    	     * Foo.prototype.c = 3;
    	     *
    	     * _.toPairsIn(new Foo);
    	     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
    	     */var toPairsIn=createToPairs(keysIn);/**
    	     * An alternative to `_.reduce`; this method transforms `object` to a new
    	     * `accumulator` object which is the result of running each of its own
    	     * enumerable string keyed properties thru `iteratee`, with each invocation
    	     * potentially mutating the `accumulator` object. If `accumulator` is not
    	     * provided, a new object with the same `[[Prototype]]` will be used. The
    	     * iteratee is invoked with four arguments: (accumulator, value, key, object).
    	     * Iteratee functions may exit iteration early by explicitly returning `false`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 1.3.0
    	     * @category Object
    	     * @param {Object} object The object to iterate over.
    	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
    	     * @param {*} [accumulator] The custom accumulator value.
    	     * @returns {*} Returns the accumulated value.
    	     * @example
    	     *
    	     * _.transform([2, 3, 4], function(result, n) {
    	     *   result.push(n *= n);
    	     *   return n % 2 == 0;
    	     * }, []);
    	     * // => [4, 9]
    	     *
    	     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
    	     *   (result[value] || (result[value] = [])).push(key);
    	     * }, {});
    	     * // => { '1': ['a', 'c'], '2': ['b'] }
    	     */function transform(object,iteratee,accumulator){var isArr=isArray(object),isArrLike=isArr||isBuffer(object)||isTypedArray(object);iteratee=getIteratee(iteratee,4);if(accumulator==null){var Ctor=object&&object.constructor;if(isArrLike){accumulator=isArr?new Ctor():[];}else if(isObject(object)){accumulator=isFunction(Ctor)?baseCreate(getPrototype(object)):{};}else {accumulator={};}}(isArrLike?arrayEach:baseForOwn)(object,function(value,index,object){return iteratee(accumulator,value,index,object);});return accumulator;}/**
    	     * Removes the property at `path` of `object`.
    	     *
    	     * **Note:** This method mutates `object`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Object
    	     * @param {Object} object The object to modify.
    	     * @param {Array|string} path The path of the property to unset.
    	     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
    	     * @example
    	     *
    	     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
    	     * _.unset(object, 'a[0].b.c');
    	     * // => true
    	     *
    	     * console.log(object);
    	     * // => { 'a': [{ 'b': {} }] };
    	     *
    	     * _.unset(object, ['a', '0', 'b', 'c']);
    	     * // => true
    	     *
    	     * console.log(object);
    	     * // => { 'a': [{ 'b': {} }] };
    	     */function unset(object,path){return object==null?true:baseUnset(object,path);}/**
    	     * This method is like `_.set` except that accepts `updater` to produce the
    	     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
    	     * is invoked with one argument: (value).
    	     *
    	     * **Note:** This method mutates `object`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.6.0
    	     * @category Object
    	     * @param {Object} object The object to modify.
    	     * @param {Array|string} path The path of the property to set.
    	     * @param {Function} updater The function to produce the updated value.
    	     * @returns {Object} Returns `object`.
    	     * @example
    	     *
    	     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
    	     *
    	     * _.update(object, 'a[0].b.c', function(n) { return n * n; });
    	     * console.log(object.a[0].b.c);
    	     * // => 9
    	     *
    	     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
    	     * console.log(object.x[0].y.z);
    	     * // => 0
    	     */function update(object,path,updater){return object==null?object:baseUpdate(object,path,castFunction(updater));}/**
    	     * This method is like `_.update` except that it accepts `customizer` which is
    	     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
    	     * path creation is handled by the method instead. The `customizer` is invoked
    	     * with three arguments: (nsValue, key, nsObject).
    	     *
    	     * **Note:** This method mutates `object`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.6.0
    	     * @category Object
    	     * @param {Object} object The object to modify.
    	     * @param {Array|string} path The path of the property to set.
    	     * @param {Function} updater The function to produce the updated value.
    	     * @param {Function} [customizer] The function to customize assigned values.
    	     * @returns {Object} Returns `object`.
    	     * @example
    	     *
    	     * var object = {};
    	     *
    	     * _.updateWith(object, '[0][1]', _.constant('a'), Object);
    	     * // => { '0': { '1': 'a' } }
    	     */function updateWith(object,path,updater,customizer){customizer=typeof customizer=='function'?customizer:undefined$1;return object==null?object:baseUpdate(object,path,castFunction(updater),customizer);}/**
    	     * Creates an array of the own enumerable string keyed property values of `object`.
    	     *
    	     * **Note:** Non-object values are coerced to objects.
    	     *
    	     * @static
    	     * @since 0.1.0
    	     * @memberOf _
    	     * @category Object
    	     * @param {Object} object The object to query.
    	     * @returns {Array} Returns the array of property values.
    	     * @example
    	     *
    	     * function Foo() {
    	     *   this.a = 1;
    	     *   this.b = 2;
    	     * }
    	     *
    	     * Foo.prototype.c = 3;
    	     *
    	     * _.values(new Foo);
    	     * // => [1, 2] (iteration order is not guaranteed)
    	     *
    	     * _.values('hi');
    	     * // => ['h', 'i']
    	     */function values(object){return object==null?[]:baseValues(object,keys(object));}/**
    	     * Creates an array of the own and inherited enumerable string keyed property
    	     * values of `object`.
    	     *
    	     * **Note:** Non-object values are coerced to objects.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 3.0.0
    	     * @category Object
    	     * @param {Object} object The object to query.
    	     * @returns {Array} Returns the array of property values.
    	     * @example
    	     *
    	     * function Foo() {
    	     *   this.a = 1;
    	     *   this.b = 2;
    	     * }
    	     *
    	     * Foo.prototype.c = 3;
    	     *
    	     * _.valuesIn(new Foo);
    	     * // => [1, 2, 3] (iteration order is not guaranteed)
    	     */function valuesIn(object){return object==null?[]:baseValues(object,keysIn(object));}/*------------------------------------------------------------------------*/ /**
    	     * Clamps `number` within the inclusive `lower` and `upper` bounds.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Number
    	     * @param {number} number The number to clamp.
    	     * @param {number} [lower] The lower bound.
    	     * @param {number} upper The upper bound.
    	     * @returns {number} Returns the clamped number.
    	     * @example
    	     *
    	     * _.clamp(-10, -5, 5);
    	     * // => -5
    	     *
    	     * _.clamp(10, -5, 5);
    	     * // => 5
    	     */function clamp(number,lower,upper){if(upper===undefined$1){upper=lower;lower=undefined$1;}if(upper!==undefined$1){upper=toNumber(upper);upper=upper===upper?upper:0;}if(lower!==undefined$1){lower=toNumber(lower);lower=lower===lower?lower:0;}return baseClamp(toNumber(number),lower,upper);}/**
    	     * Checks if `n` is between `start` and up to, but not including, `end`. If
    	     * `end` is not specified, it's set to `start` with `start` then set to `0`.
    	     * If `start` is greater than `end` the params are swapped to support
    	     * negative ranges.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 3.3.0
    	     * @category Number
    	     * @param {number} number The number to check.
    	     * @param {number} [start=0] The start of the range.
    	     * @param {number} end The end of the range.
    	     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
    	     * @see _.range, _.rangeRight
    	     * @example
    	     *
    	     * _.inRange(3, 2, 4);
    	     * // => true
    	     *
    	     * _.inRange(4, 8);
    	     * // => true
    	     *
    	     * _.inRange(4, 2);
    	     * // => false
    	     *
    	     * _.inRange(2, 2);
    	     * // => false
    	     *
    	     * _.inRange(1.2, 2);
    	     * // => true
    	     *
    	     * _.inRange(5.2, 4);
    	     * // => false
    	     *
    	     * _.inRange(-3, -2, -6);
    	     * // => true
    	     */function inRange(number,start,end){start=toFinite(start);if(end===undefined$1){end=start;start=0;}else {end=toFinite(end);}number=toNumber(number);return baseInRange(number,start,end);}/**
    	     * Produces a random number between the inclusive `lower` and `upper` bounds.
    	     * If only one argument is provided a number between `0` and the given number
    	     * is returned. If `floating` is `true`, or either `lower` or `upper` are
    	     * floats, a floating-point number is returned instead of an integer.
    	     *
    	     * **Note:** JavaScript follows the IEEE-754 standard for resolving
    	     * floating-point values which can produce unexpected results.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.7.0
    	     * @category Number
    	     * @param {number} [lower=0] The lower bound.
    	     * @param {number} [upper=1] The upper bound.
    	     * @param {boolean} [floating] Specify returning a floating-point number.
    	     * @returns {number} Returns the random number.
    	     * @example
    	     *
    	     * _.random(0, 5);
    	     * // => an integer between 0 and 5
    	     *
    	     * _.random(5);
    	     * // => also an integer between 0 and 5
    	     *
    	     * _.random(5, true);
    	     * // => a floating-point number between 0 and 5
    	     *
    	     * _.random(1.2, 5.2);
    	     * // => a floating-point number between 1.2 and 5.2
    	     */function random(lower,upper,floating){if(floating&&typeof floating!='boolean'&&isIterateeCall(lower,upper,floating)){upper=floating=undefined$1;}if(floating===undefined$1){if(typeof upper=='boolean'){floating=upper;upper=undefined$1;}else if(typeof lower=='boolean'){floating=lower;lower=undefined$1;}}if(lower===undefined$1&&upper===undefined$1){lower=0;upper=1;}else {lower=toFinite(lower);if(upper===undefined$1){upper=lower;lower=0;}else {upper=toFinite(upper);}}if(lower>upper){var temp=lower;lower=upper;upper=temp;}if(floating||lower%1||upper%1){var rand=nativeRandom();return nativeMin(lower+rand*(upper-lower+freeParseFloat('1e-'+((rand+'').length-1))),upper);}return baseRandom(lower,upper);}/*------------------------------------------------------------------------*/ /**
    	     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 3.0.0
    	     * @category String
    	     * @param {string} [string=''] The string to convert.
    	     * @returns {string} Returns the camel cased string.
    	     * @example
    	     *
    	     * _.camelCase('Foo Bar');
    	     * // => 'fooBar'
    	     *
    	     * _.camelCase('--foo-bar--');
    	     * // => 'fooBar'
    	     *
    	     * _.camelCase('__FOO_BAR__');
    	     * // => 'fooBar'
    	     */var camelCase=createCompounder(function(result,word,index){word=word.toLowerCase();return result+(index?capitalize(word):word);});/**
    	     * Converts the first character of `string` to upper case and the remaining
    	     * to lower case.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 3.0.0
    	     * @category String
    	     * @param {string} [string=''] The string to capitalize.
    	     * @returns {string} Returns the capitalized string.
    	     * @example
    	     *
    	     * _.capitalize('FRED');
    	     * // => 'Fred'
    	     */function capitalize(string){return upperFirst(toString(string).toLowerCase());}/**
    	     * Deburrs `string` by converting
    	     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
    	     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
    	     * letters to basic Latin letters and removing
    	     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 3.0.0
    	     * @category String
    	     * @param {string} [string=''] The string to deburr.
    	     * @returns {string} Returns the deburred string.
    	     * @example
    	     *
    	     * _.deburr('déjà vu');
    	     * // => 'deja vu'
    	     */function deburr(string){string=toString(string);return string&&string.replace(reLatin,deburrLetter).replace(reComboMark,'');}/**
    	     * Checks if `string` ends with the given target string.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 3.0.0
    	     * @category String
    	     * @param {string} [string=''] The string to inspect.
    	     * @param {string} [target] The string to search for.
    	     * @param {number} [position=string.length] The position to search up to.
    	     * @returns {boolean} Returns `true` if `string` ends with `target`,
    	     *  else `false`.
    	     * @example
    	     *
    	     * _.endsWith('abc', 'c');
    	     * // => true
    	     *
    	     * _.endsWith('abc', 'b');
    	     * // => false
    	     *
    	     * _.endsWith('abc', 'b', 2);
    	     * // => true
    	     */function endsWith(string,target,position){string=toString(string);target=baseToString(target);var length=string.length;position=position===undefined$1?length:baseClamp(toInteger(position),0,length);var end=position;position-=target.length;return position>=0&&string.slice(position,end)==target;}/**
    	     * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
    	     * corresponding HTML entities.
    	     *
    	     * **Note:** No other characters are escaped. To escape additional
    	     * characters use a third-party library like [_he_](https://mths.be/he).
    	     *
    	     * Though the ">" character is escaped for symmetry, characters like
    	     * ">" and "/" don't need escaping in HTML and have no special meaning
    	     * unless they're part of a tag or unquoted attribute value. See
    	     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
    	     * (under "semi-related fun fact") for more details.
    	     *
    	     * When working with HTML you should always
    	     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
    	     * XSS vectors.
    	     *
    	     * @static
    	     * @since 0.1.0
    	     * @memberOf _
    	     * @category String
    	     * @param {string} [string=''] The string to escape.
    	     * @returns {string} Returns the escaped string.
    	     * @example
    	     *
    	     * _.escape('fred, barney, & pebbles');
    	     * // => 'fred, barney, &amp; pebbles'
    	     */function escape(string){string=toString(string);return string&&reHasUnescapedHtml.test(string)?string.replace(reUnescapedHtml,escapeHtmlChar):string;}/**
    	     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
    	     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 3.0.0
    	     * @category String
    	     * @param {string} [string=''] The string to escape.
    	     * @returns {string} Returns the escaped string.
    	     * @example
    	     *
    	     * _.escapeRegExp('[lodash](https://lodash.com/)');
    	     * // => '\[lodash\]\(https://lodash\.com/\)'
    	     */function escapeRegExp(string){string=toString(string);return string&&reHasRegExpChar.test(string)?string.replace(reRegExpChar,'\\$&'):string;}/**
    	     * Converts `string` to
    	     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 3.0.0
    	     * @category String
    	     * @param {string} [string=''] The string to convert.
    	     * @returns {string} Returns the kebab cased string.
    	     * @example
    	     *
    	     * _.kebabCase('Foo Bar');
    	     * // => 'foo-bar'
    	     *
    	     * _.kebabCase('fooBar');
    	     * // => 'foo-bar'
    	     *
    	     * _.kebabCase('__FOO_BAR__');
    	     * // => 'foo-bar'
    	     */var kebabCase=createCompounder(function(result,word,index){return result+(index?'-':'')+word.toLowerCase();});/**
    	     * Converts `string`, as space separated words, to lower case.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category String
    	     * @param {string} [string=''] The string to convert.
    	     * @returns {string} Returns the lower cased string.
    	     * @example
    	     *
    	     * _.lowerCase('--Foo-Bar--');
    	     * // => 'foo bar'
    	     *
    	     * _.lowerCase('fooBar');
    	     * // => 'foo bar'
    	     *
    	     * _.lowerCase('__FOO_BAR__');
    	     * // => 'foo bar'
    	     */var lowerCase=createCompounder(function(result,word,index){return result+(index?' ':'')+word.toLowerCase();});/**
    	     * Converts the first character of `string` to lower case.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category String
    	     * @param {string} [string=''] The string to convert.
    	     * @returns {string} Returns the converted string.
    	     * @example
    	     *
    	     * _.lowerFirst('Fred');
    	     * // => 'fred'
    	     *
    	     * _.lowerFirst('FRED');
    	     * // => 'fRED'
    	     */var lowerFirst=createCaseFirst('toLowerCase');/**
    	     * Pads `string` on the left and right sides if it's shorter than `length`.
    	     * Padding characters are truncated if they can't be evenly divided by `length`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 3.0.0
    	     * @category String
    	     * @param {string} [string=''] The string to pad.
    	     * @param {number} [length=0] The padding length.
    	     * @param {string} [chars=' '] The string used as padding.
    	     * @returns {string} Returns the padded string.
    	     * @example
    	     *
    	     * _.pad('abc', 8);
    	     * // => '  abc   '
    	     *
    	     * _.pad('abc', 8, '_-');
    	     * // => '_-abc_-_'
    	     *
    	     * _.pad('abc', 3);
    	     * // => 'abc'
    	     */function pad(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;if(!length||strLength>=length){return string;}var mid=(length-strLength)/2;return createPadding(nativeFloor(mid),chars)+string+createPadding(nativeCeil(mid),chars);}/**
    	     * Pads `string` on the right side if it's shorter than `length`. Padding
    	     * characters are truncated if they exceed `length`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category String
    	     * @param {string} [string=''] The string to pad.
    	     * @param {number} [length=0] The padding length.
    	     * @param {string} [chars=' '] The string used as padding.
    	     * @returns {string} Returns the padded string.
    	     * @example
    	     *
    	     * _.padEnd('abc', 6);
    	     * // => 'abc   '
    	     *
    	     * _.padEnd('abc', 6, '_-');
    	     * // => 'abc_-_'
    	     *
    	     * _.padEnd('abc', 3);
    	     * // => 'abc'
    	     */function padEnd(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;return length&&strLength<length?string+createPadding(length-strLength,chars):string;}/**
    	     * Pads `string` on the left side if it's shorter than `length`. Padding
    	     * characters are truncated if they exceed `length`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category String
    	     * @param {string} [string=''] The string to pad.
    	     * @param {number} [length=0] The padding length.
    	     * @param {string} [chars=' '] The string used as padding.
    	     * @returns {string} Returns the padded string.
    	     * @example
    	     *
    	     * _.padStart('abc', 6);
    	     * // => '   abc'
    	     *
    	     * _.padStart('abc', 6, '_-');
    	     * // => '_-_abc'
    	     *
    	     * _.padStart('abc', 3);
    	     * // => 'abc'
    	     */function padStart(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;return length&&strLength<length?createPadding(length-strLength,chars)+string:string;}/**
    	     * Converts `string` to an integer of the specified radix. If `radix` is
    	     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
    	     * hexadecimal, in which case a `radix` of `16` is used.
    	     *
    	     * **Note:** This method aligns with the
    	     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 1.1.0
    	     * @category String
    	     * @param {string} string The string to convert.
    	     * @param {number} [radix=10] The radix to interpret `value` by.
    	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
    	     * @returns {number} Returns the converted integer.
    	     * @example
    	     *
    	     * _.parseInt('08');
    	     * // => 8
    	     *
    	     * _.map(['6', '08', '10'], _.parseInt);
    	     * // => [6, 8, 10]
    	     */function parseInt(string,radix,guard){if(guard||radix==null){radix=0;}else if(radix){radix=+radix;}return nativeParseInt(toString(string).replace(reTrimStart,''),radix||0);}/**
    	     * Repeats the given string `n` times.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 3.0.0
    	     * @category String
    	     * @param {string} [string=''] The string to repeat.
    	     * @param {number} [n=1] The number of times to repeat the string.
    	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
    	     * @returns {string} Returns the repeated string.
    	     * @example
    	     *
    	     * _.repeat('*', 3);
    	     * // => '***'
    	     *
    	     * _.repeat('abc', 2);
    	     * // => 'abcabc'
    	     *
    	     * _.repeat('abc', 0);
    	     * // => ''
    	     */function repeat(string,n,guard){if(guard?isIterateeCall(string,n,guard):n===undefined$1){n=1;}else {n=toInteger(n);}return baseRepeat(toString(string),n);}/**
    	     * Replaces matches for `pattern` in `string` with `replacement`.
    	     *
    	     * **Note:** This method is based on
    	     * [`String#replace`](https://mdn.io/String/replace).
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category String
    	     * @param {string} [string=''] The string to modify.
    	     * @param {RegExp|string} pattern The pattern to replace.
    	     * @param {Function|string} replacement The match replacement.
    	     * @returns {string} Returns the modified string.
    	     * @example
    	     *
    	     * _.replace('Hi Fred', 'Fred', 'Barney');
    	     * // => 'Hi Barney'
    	     */function replace(){var args=arguments,string=toString(args[0]);return args.length<3?string:string.replace(args[1],args[2]);}/**
    	     * Converts `string` to
    	     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 3.0.0
    	     * @category String
    	     * @param {string} [string=''] The string to convert.
    	     * @returns {string} Returns the snake cased string.
    	     * @example
    	     *
    	     * _.snakeCase('Foo Bar');
    	     * // => 'foo_bar'
    	     *
    	     * _.snakeCase('fooBar');
    	     * // => 'foo_bar'
    	     *
    	     * _.snakeCase('--FOO-BAR--');
    	     * // => 'foo_bar'
    	     */var snakeCase=createCompounder(function(result,word,index){return result+(index?'_':'')+word.toLowerCase();});/**
    	     * Splits `string` by `separator`.
    	     *
    	     * **Note:** This method is based on
    	     * [`String#split`](https://mdn.io/String/split).
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category String
    	     * @param {string} [string=''] The string to split.
    	     * @param {RegExp|string} separator The separator pattern to split by.
    	     * @param {number} [limit] The length to truncate results to.
    	     * @returns {Array} Returns the string segments.
    	     * @example
    	     *
    	     * _.split('a-b-c', '-', 2);
    	     * // => ['a', 'b']
    	     */function split(string,separator,limit){if(limit&&typeof limit!='number'&&isIterateeCall(string,separator,limit)){separator=limit=undefined$1;}limit=limit===undefined$1?MAX_ARRAY_LENGTH:limit>>>0;if(!limit){return [];}string=toString(string);if(string&&(typeof separator=='string'||separator!=null&&!isRegExp(separator))){separator=baseToString(separator);if(!separator&&hasUnicode(string)){return castSlice(stringToArray(string),0,limit);}}return string.split(separator,limit);}/**
    	     * Converts `string` to
    	     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 3.1.0
    	     * @category String
    	     * @param {string} [string=''] The string to convert.
    	     * @returns {string} Returns the start cased string.
    	     * @example
    	     *
    	     * _.startCase('--foo-bar--');
    	     * // => 'Foo Bar'
    	     *
    	     * _.startCase('fooBar');
    	     * // => 'Foo Bar'
    	     *
    	     * _.startCase('__FOO_BAR__');
    	     * // => 'FOO BAR'
    	     */var startCase=createCompounder(function(result,word,index){return result+(index?' ':'')+upperFirst(word);});/**
    	     * Checks if `string` starts with the given target string.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 3.0.0
    	     * @category String
    	     * @param {string} [string=''] The string to inspect.
    	     * @param {string} [target] The string to search for.
    	     * @param {number} [position=0] The position to search from.
    	     * @returns {boolean} Returns `true` if `string` starts with `target`,
    	     *  else `false`.
    	     * @example
    	     *
    	     * _.startsWith('abc', 'a');
    	     * // => true
    	     *
    	     * _.startsWith('abc', 'b');
    	     * // => false
    	     *
    	     * _.startsWith('abc', 'b', 1);
    	     * // => true
    	     */function startsWith(string,target,position){string=toString(string);position=position==null?0:baseClamp(toInteger(position),0,string.length);target=baseToString(target);return string.slice(position,position+target.length)==target;}/**
    	     * Creates a compiled template function that can interpolate data properties
    	     * in "interpolate" delimiters, HTML-escape interpolated data properties in
    	     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
    	     * properties may be accessed as free variables in the template. If a setting
    	     * object is given, it takes precedence over `_.templateSettings` values.
    	     *
    	     * **Note:** In the development build `_.template` utilizes
    	     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
    	     * for easier debugging.
    	     *
    	     * For more information on precompiling templates see
    	     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
    	     *
    	     * For more information on Chrome extension sandboxes see
    	     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
    	     *
    	     * @static
    	     * @since 0.1.0
    	     * @memberOf _
    	     * @category String
    	     * @param {string} [string=''] The template string.
    	     * @param {Object} [options={}] The options object.
    	     * @param {RegExp} [options.escape=_.templateSettings.escape]
    	     *  The HTML "escape" delimiter.
    	     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
    	     *  The "evaluate" delimiter.
    	     * @param {Object} [options.imports=_.templateSettings.imports]
    	     *  An object to import into the template as free variables.
    	     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
    	     *  The "interpolate" delimiter.
    	     * @param {string} [options.sourceURL='lodash.templateSources[n]']
    	     *  The sourceURL of the compiled template.
    	     * @param {string} [options.variable='obj']
    	     *  The data object variable name.
    	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
    	     * @returns {Function} Returns the compiled template function.
    	     * @example
    	     *
    	     * // Use the "interpolate" delimiter to create a compiled template.
    	     * var compiled = _.template('hello <%= user %>!');
    	     * compiled({ 'user': 'fred' });
    	     * // => 'hello fred!'
    	     *
    	     * // Use the HTML "escape" delimiter to escape data property values.
    	     * var compiled = _.template('<b><%- value %></b>');
    	     * compiled({ 'value': '<script>' });
    	     * // => '<b>&lt;script&gt;</b>'
    	     *
    	     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
    	     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
    	     * compiled({ 'users': ['fred', 'barney'] });
    	     * // => '<li>fred</li><li>barney</li>'
    	     *
    	     * // Use the internal `print` function in "evaluate" delimiters.
    	     * var compiled = _.template('<% print("hello " + user); %>!');
    	     * compiled({ 'user': 'barney' });
    	     * // => 'hello barney!'
    	     *
    	     * // Use the ES template literal delimiter as an "interpolate" delimiter.
    	     * // Disable support by replacing the "interpolate" delimiter.
    	     * var compiled = _.template('hello ${ user }!');
    	     * compiled({ 'user': 'pebbles' });
    	     * // => 'hello pebbles!'
    	     *
    	     * // Use backslashes to treat delimiters as plain text.
    	     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
    	     * compiled({ 'value': 'ignored' });
    	     * // => '<%- value %>'
    	     *
    	     * // Use the `imports` option to import `jQuery` as `jq`.
    	     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
    	     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
    	     * compiled({ 'users': ['fred', 'barney'] });
    	     * // => '<li>fred</li><li>barney</li>'
    	     *
    	     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
    	     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
    	     * compiled(data);
    	     * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
    	     *
    	     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
    	     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
    	     * compiled.source;
    	     * // => function(data) {
    	     * //   var __t, __p = '';
    	     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
    	     * //   return __p;
    	     * // }
    	     *
    	     * // Use custom template delimiters.
    	     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
    	     * var compiled = _.template('hello {{ user }}!');
    	     * compiled({ 'user': 'mustache' });
    	     * // => 'hello mustache!'
    	     *
    	     * // Use the `source` property to inline compiled templates for meaningful
    	     * // line numbers in error messages and stack traces.
    	     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
    	     *   var JST = {\
    	     *     "main": ' + _.template(mainText).source + '\
    	     *   };\
    	     * ');
    	     */function template(string,options,guard){// Based on John Resig's `tmpl` implementation
    	// (http://ejohn.org/blog/javascript-micro-templating/)
    	// and Laura Doktorova's doT.js (https://github.com/olado/doT).
    	var settings=lodash.templateSettings;if(guard&&isIterateeCall(string,options,guard)){options=undefined$1;}string=toString(string);options=assignInWith({},options,settings,customDefaultsAssignIn);var imports=assignInWith({},options.imports,settings.imports,customDefaultsAssignIn),importsKeys=keys(imports),importsValues=baseValues(imports,importsKeys);var isEscaping,isEvaluating,index=0,interpolate=options.interpolate||reNoMatch,source="__p += '";// Compile the regexp to match each delimiter.
    	var reDelimiters=RegExp((options.escape||reNoMatch).source+'|'+interpolate.source+'|'+(interpolate===reInterpolate?reEsTemplate:reNoMatch).source+'|'+(options.evaluate||reNoMatch).source+'|$','g');// Use a sourceURL for easier debugging.
    	// The sourceURL gets injected into the source that's eval-ed, so be careful
    	// to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in
    	// and escape the comment, thus injecting code that gets evaled.
    	var sourceURL='//# sourceURL='+(hasOwnProperty.call(options,'sourceURL')?(options.sourceURL+'').replace(/\s/g,' '):'lodash.templateSources['+ ++templateCounter+']')+'\n';string.replace(reDelimiters,function(match,escapeValue,interpolateValue,esTemplateValue,evaluateValue,offset){interpolateValue||(interpolateValue=esTemplateValue);// Escape characters that can't be included in string literals.
    	source+=string.slice(index,offset).replace(reUnescapedString,escapeStringChar);// Replace delimiters with snippets.
    	if(escapeValue){isEscaping=true;source+="' +\n__e("+escapeValue+") +\n'";}if(evaluateValue){isEvaluating=true;source+="';\n"+evaluateValue+";\n__p += '";}if(interpolateValue){source+="' +\n((__t = ("+interpolateValue+")) == null ? '' : __t) +\n'";}index=offset+match.length;// The JS engine embedded in Adobe products needs `match` returned in
    	// order to produce the correct `offset` value.
    	return match;});source+="';\n";// If `variable` is not specified wrap a with-statement around the generated
    	// code to add the data object to the top of the scope chain.
    	var variable=hasOwnProperty.call(options,'variable')&&options.variable;if(!variable){source='with (obj) {\n'+source+'\n}\n';}// Throw an error if a forbidden character was found in `variable`, to prevent
    	// potential command injection attacks.
    	else if(reForbiddenIdentifierChars.test(variable)){throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);}// Cleanup code by stripping empty strings.
    	source=(isEvaluating?source.replace(reEmptyStringLeading,''):source).replace(reEmptyStringMiddle,'$1').replace(reEmptyStringTrailing,'$1;');// Frame code as the function body.
    	source='function('+(variable||'obj')+') {\n'+(variable?'':'obj || (obj = {});\n')+"var __t, __p = ''"+(isEscaping?', __e = _.escape':'')+(isEvaluating?', __j = Array.prototype.join;\n'+"function print() { __p += __j.call(arguments, '') }\n":';\n')+source+'return __p\n}';var result=attempt(function(){return Function(importsKeys,sourceURL+'return '+source).apply(undefined$1,importsValues);});// Provide the compiled function's source by its `toString` method or
    	// the `source` property as a convenience for inlining compiled templates.
    	result.source=source;if(isError(result)){throw result;}return result;}/**
    	     * Converts `string`, as a whole, to lower case just like
    	     * [String#toLowerCase](https://mdn.io/toLowerCase).
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category String
    	     * @param {string} [string=''] The string to convert.
    	     * @returns {string} Returns the lower cased string.
    	     * @example
    	     *
    	     * _.toLower('--Foo-Bar--');
    	     * // => '--foo-bar--'
    	     *
    	     * _.toLower('fooBar');
    	     * // => 'foobar'
    	     *
    	     * _.toLower('__FOO_BAR__');
    	     * // => '__foo_bar__'
    	     */function toLower(value){return toString(value).toLowerCase();}/**
    	     * Converts `string`, as a whole, to upper case just like
    	     * [String#toUpperCase](https://mdn.io/toUpperCase).
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category String
    	     * @param {string} [string=''] The string to convert.
    	     * @returns {string} Returns the upper cased string.
    	     * @example
    	     *
    	     * _.toUpper('--foo-bar--');
    	     * // => '--FOO-BAR--'
    	     *
    	     * _.toUpper('fooBar');
    	     * // => 'FOOBAR'
    	     *
    	     * _.toUpper('__foo_bar__');
    	     * // => '__FOO_BAR__'
    	     */function toUpper(value){return toString(value).toUpperCase();}/**
    	     * Removes leading and trailing whitespace or specified characters from `string`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 3.0.0
    	     * @category String
    	     * @param {string} [string=''] The string to trim.
    	     * @param {string} [chars=whitespace] The characters to trim.
    	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
    	     * @returns {string} Returns the trimmed string.
    	     * @example
    	     *
    	     * _.trim('  abc  ');
    	     * // => 'abc'
    	     *
    	     * _.trim('-_-abc-_-', '_-');
    	     * // => 'abc'
    	     *
    	     * _.map(['  foo  ', '  bar  '], _.trim);
    	     * // => ['foo', 'bar']
    	     */function trim(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined$1)){return baseTrim(string);}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),chrSymbols=stringToArray(chars),start=charsStartIndex(strSymbols,chrSymbols),end=charsEndIndex(strSymbols,chrSymbols)+1;return castSlice(strSymbols,start,end).join('');}/**
    	     * Removes trailing whitespace or specified characters from `string`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category String
    	     * @param {string} [string=''] The string to trim.
    	     * @param {string} [chars=whitespace] The characters to trim.
    	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
    	     * @returns {string} Returns the trimmed string.
    	     * @example
    	     *
    	     * _.trimEnd('  abc  ');
    	     * // => '  abc'
    	     *
    	     * _.trimEnd('-_-abc-_-', '_-');
    	     * // => '-_-abc'
    	     */function trimEnd(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined$1)){return string.slice(0,trimmedEndIndex(string)+1);}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),end=charsEndIndex(strSymbols,stringToArray(chars))+1;return castSlice(strSymbols,0,end).join('');}/**
    	     * Removes leading whitespace or specified characters from `string`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category String
    	     * @param {string} [string=''] The string to trim.
    	     * @param {string} [chars=whitespace] The characters to trim.
    	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
    	     * @returns {string} Returns the trimmed string.
    	     * @example
    	     *
    	     * _.trimStart('  abc  ');
    	     * // => 'abc  '
    	     *
    	     * _.trimStart('-_-abc-_-', '_-');
    	     * // => 'abc-_-'
    	     */function trimStart(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined$1)){return string.replace(reTrimStart,'');}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),start=charsStartIndex(strSymbols,stringToArray(chars));return castSlice(strSymbols,start).join('');}/**
    	     * Truncates `string` if it's longer than the given maximum string length.
    	     * The last characters of the truncated string are replaced with the omission
    	     * string which defaults to "...".
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category String
    	     * @param {string} [string=''] The string to truncate.
    	     * @param {Object} [options={}] The options object.
    	     * @param {number} [options.length=30] The maximum string length.
    	     * @param {string} [options.omission='...'] The string to indicate text is omitted.
    	     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
    	     * @returns {string} Returns the truncated string.
    	     * @example
    	     *
    	     * _.truncate('hi-diddly-ho there, neighborino');
    	     * // => 'hi-diddly-ho there, neighbo...'
    	     *
    	     * _.truncate('hi-diddly-ho there, neighborino', {
    	     *   'length': 24,
    	     *   'separator': ' '
    	     * });
    	     * // => 'hi-diddly-ho there,...'
    	     *
    	     * _.truncate('hi-diddly-ho there, neighborino', {
    	     *   'length': 24,
    	     *   'separator': /,? +/
    	     * });
    	     * // => 'hi-diddly-ho there...'
    	     *
    	     * _.truncate('hi-diddly-ho there, neighborino', {
    	     *   'omission': ' [...]'
    	     * });
    	     * // => 'hi-diddly-ho there, neig [...]'
    	     */function truncate(string,options){var length=DEFAULT_TRUNC_LENGTH,omission=DEFAULT_TRUNC_OMISSION;if(isObject(options)){var separator='separator'in options?options.separator:separator;length='length'in options?toInteger(options.length):length;omission='omission'in options?baseToString(options.omission):omission;}string=toString(string);var strLength=string.length;if(hasUnicode(string)){var strSymbols=stringToArray(string);strLength=strSymbols.length;}if(length>=strLength){return string;}var end=length-stringSize(omission);if(end<1){return omission;}var result=strSymbols?castSlice(strSymbols,0,end).join(''):string.slice(0,end);if(separator===undefined$1){return result+omission;}if(strSymbols){end+=result.length-end;}if(isRegExp(separator)){if(string.slice(end).search(separator)){var match,substring=result;if(!separator.global){separator=RegExp(separator.source,toString(reFlags.exec(separator))+'g');}separator.lastIndex=0;while(match=separator.exec(substring)){var newEnd=match.index;}result=result.slice(0,newEnd===undefined$1?end:newEnd);}}else if(string.indexOf(baseToString(separator),end)!=end){var index=result.lastIndexOf(separator);if(index>-1){result=result.slice(0,index);}}return result+omission;}/**
    	     * The inverse of `_.escape`; this method converts the HTML entities
    	     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
    	     * their corresponding characters.
    	     *
    	     * **Note:** No other HTML entities are unescaped. To unescape additional
    	     * HTML entities use a third-party library like [_he_](https://mths.be/he).
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 0.6.0
    	     * @category String
    	     * @param {string} [string=''] The string to unescape.
    	     * @returns {string} Returns the unescaped string.
    	     * @example
    	     *
    	     * _.unescape('fred, barney, &amp; pebbles');
    	     * // => 'fred, barney, & pebbles'
    	     */function unescape(string){string=toString(string);return string&&reHasEscapedHtml.test(string)?string.replace(reEscapedHtml,unescapeHtmlChar):string;}/**
    	     * Converts `string`, as space separated words, to upper case.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category String
    	     * @param {string} [string=''] The string to convert.
    	     * @returns {string} Returns the upper cased string.
    	     * @example
    	     *
    	     * _.upperCase('--foo-bar');
    	     * // => 'FOO BAR'
    	     *
    	     * _.upperCase('fooBar');
    	     * // => 'FOO BAR'
    	     *
    	     * _.upperCase('__foo_bar__');
    	     * // => 'FOO BAR'
    	     */var upperCase=createCompounder(function(result,word,index){return result+(index?' ':'')+word.toUpperCase();});/**
    	     * Converts the first character of `string` to upper case.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category String
    	     * @param {string} [string=''] The string to convert.
    	     * @returns {string} Returns the converted string.
    	     * @example
    	     *
    	     * _.upperFirst('fred');
    	     * // => 'Fred'
    	     *
    	     * _.upperFirst('FRED');
    	     * // => 'FRED'
    	     */var upperFirst=createCaseFirst('toUpperCase');/**
    	     * Splits `string` into an array of its words.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 3.0.0
    	     * @category String
    	     * @param {string} [string=''] The string to inspect.
    	     * @param {RegExp|string} [pattern] The pattern to match words.
    	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
    	     * @returns {Array} Returns the words of `string`.
    	     * @example
    	     *
    	     * _.words('fred, barney, & pebbles');
    	     * // => ['fred', 'barney', 'pebbles']
    	     *
    	     * _.words('fred, barney, & pebbles', /[^, ]+/g);
    	     * // => ['fred', 'barney', '&', 'pebbles']
    	     */function words(string,pattern,guard){string=toString(string);pattern=guard?undefined$1:pattern;if(pattern===undefined$1){return hasUnicodeWord(string)?unicodeWords(string):asciiWords(string);}return string.match(pattern)||[];}/*------------------------------------------------------------------------*/ /**
    	     * Attempts to invoke `func`, returning either the result or the caught error
    	     * object. Any additional arguments are provided to `func` when it's invoked.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 3.0.0
    	     * @category Util
    	     * @param {Function} func The function to attempt.
    	     * @param {...*} [args] The arguments to invoke `func` with.
    	     * @returns {*} Returns the `func` result or error object.
    	     * @example
    	     *
    	     * // Avoid throwing errors for invalid selectors.
    	     * var elements = _.attempt(function(selector) {
    	     *   return document.querySelectorAll(selector);
    	     * }, '>_>');
    	     *
    	     * if (_.isError(elements)) {
    	     *   elements = [];
    	     * }
    	     */var attempt=baseRest(function(func,args){try{return apply(func,undefined$1,args);}catch(e){return isError(e)?e:new Error(e);}});/**
    	     * Binds methods of an object to the object itself, overwriting the existing
    	     * method.
    	     *
    	     * **Note:** This method doesn't set the "length" property of bound functions.
    	     *
    	     * @static
    	     * @since 0.1.0
    	     * @memberOf _
    	     * @category Util
    	     * @param {Object} object The object to bind and assign the bound methods to.
    	     * @param {...(string|string[])} methodNames The object method names to bind.
    	     * @returns {Object} Returns `object`.
    	     * @example
    	     *
    	     * var view = {
    	     *   'label': 'docs',
    	     *   'click': function() {
    	     *     console.log('clicked ' + this.label);
    	     *   }
    	     * };
    	     *
    	     * _.bindAll(view, ['click']);
    	     * jQuery(element).on('click', view.click);
    	     * // => Logs 'clicked docs' when clicked.
    	     */var bindAll=flatRest(function(object,methodNames){arrayEach(methodNames,function(key){key=toKey(key);baseAssignValue(object,key,bind(object[key],object));});return object;});/**
    	     * Creates a function that iterates over `pairs` and invokes the corresponding
    	     * function of the first predicate to return truthy. The predicate-function
    	     * pairs are invoked with the `this` binding and arguments of the created
    	     * function.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Util
    	     * @param {Array} pairs The predicate-function pairs.
    	     * @returns {Function} Returns the new composite function.
    	     * @example
    	     *
    	     * var func = _.cond([
    	     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
    	     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
    	     *   [_.stubTrue,                      _.constant('no match')]
    	     * ]);
    	     *
    	     * func({ 'a': 1, 'b': 2 });
    	     * // => 'matches A'
    	     *
    	     * func({ 'a': 0, 'b': 1 });
    	     * // => 'matches B'
    	     *
    	     * func({ 'a': '1', 'b': '2' });
    	     * // => 'no match'
    	     */function cond(pairs){var length=pairs==null?0:pairs.length,toIteratee=getIteratee();pairs=!length?[]:arrayMap(pairs,function(pair){if(typeof pair[1]!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return [toIteratee(pair[0]),pair[1]];});return baseRest(function(args){var index=-1;while(++index<length){var pair=pairs[index];if(apply(pair[0],this,args)){return apply(pair[1],this,args);}}});}/**
    	     * Creates a function that invokes the predicate properties of `source` with
    	     * the corresponding property values of a given object, returning `true` if
    	     * all predicates return truthy, else `false`.
    	     *
    	     * **Note:** The created function is equivalent to `_.conformsTo` with
    	     * `source` partially applied.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Util
    	     * @param {Object} source The object of property predicates to conform to.
    	     * @returns {Function} Returns the new spec function.
    	     * @example
    	     *
    	     * var objects = [
    	     *   { 'a': 2, 'b': 1 },
    	     *   { 'a': 1, 'b': 2 }
    	     * ];
    	     *
    	     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
    	     * // => [{ 'a': 1, 'b': 2 }]
    	     */function conforms(source){return baseConforms(baseClone(source,CLONE_DEEP_FLAG));}/**
    	     * Creates a function that returns `value`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 2.4.0
    	     * @category Util
    	     * @param {*} value The value to return from the new function.
    	     * @returns {Function} Returns the new constant function.
    	     * @example
    	     *
    	     * var objects = _.times(2, _.constant({ 'a': 1 }));
    	     *
    	     * console.log(objects);
    	     * // => [{ 'a': 1 }, { 'a': 1 }]
    	     *
    	     * console.log(objects[0] === objects[1]);
    	     * // => true
    	     */function constant(value){return function(){return value;};}/**
    	     * Checks `value` to determine whether a default value should be returned in
    	     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
    	     * or `undefined`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.14.0
    	     * @category Util
    	     * @param {*} value The value to check.
    	     * @param {*} defaultValue The default value.
    	     * @returns {*} Returns the resolved value.
    	     * @example
    	     *
    	     * _.defaultTo(1, 10);
    	     * // => 1
    	     *
    	     * _.defaultTo(undefined, 10);
    	     * // => 10
    	     */function defaultTo(value,defaultValue){return value==null||value!==value?defaultValue:value;}/**
    	     * Creates a function that returns the result of invoking the given functions
    	     * with the `this` binding of the created function, where each successive
    	     * invocation is supplied the return value of the previous.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 3.0.0
    	     * @category Util
    	     * @param {...(Function|Function[])} [funcs] The functions to invoke.
    	     * @returns {Function} Returns the new composite function.
    	     * @see _.flowRight
    	     * @example
    	     *
    	     * function square(n) {
    	     *   return n * n;
    	     * }
    	     *
    	     * var addSquare = _.flow([_.add, square]);
    	     * addSquare(1, 2);
    	     * // => 9
    	     */var flow=createFlow();/**
    	     * This method is like `_.flow` except that it creates a function that
    	     * invokes the given functions from right to left.
    	     *
    	     * @static
    	     * @since 3.0.0
    	     * @memberOf _
    	     * @category Util
    	     * @param {...(Function|Function[])} [funcs] The functions to invoke.
    	     * @returns {Function} Returns the new composite function.
    	     * @see _.flow
    	     * @example
    	     *
    	     * function square(n) {
    	     *   return n * n;
    	     * }
    	     *
    	     * var addSquare = _.flowRight([square, _.add]);
    	     * addSquare(1, 2);
    	     * // => 9
    	     */var flowRight=createFlow(true);/**
    	     * This method returns the first argument it receives.
    	     *
    	     * @static
    	     * @since 0.1.0
    	     * @memberOf _
    	     * @category Util
    	     * @param {*} value Any value.
    	     * @returns {*} Returns `value`.
    	     * @example
    	     *
    	     * var object = { 'a': 1 };
    	     *
    	     * console.log(_.identity(object) === object);
    	     * // => true
    	     */function identity(value){return value;}/**
    	     * Creates a function that invokes `func` with the arguments of the created
    	     * function. If `func` is a property name, the created function returns the
    	     * property value for a given element. If `func` is an array or object, the
    	     * created function returns `true` for elements that contain the equivalent
    	     * source properties, otherwise it returns `false`.
    	     *
    	     * @static
    	     * @since 4.0.0
    	     * @memberOf _
    	     * @category Util
    	     * @param {*} [func=_.identity] The value to convert to a callback.
    	     * @returns {Function} Returns the callback.
    	     * @example
    	     *
    	     * var users = [
    	     *   { 'user': 'barney', 'age': 36, 'active': true },
    	     *   { 'user': 'fred',   'age': 40, 'active': false }
    	     * ];
    	     *
    	     * // The `_.matches` iteratee shorthand.
    	     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
    	     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
    	     *
    	     * // The `_.matchesProperty` iteratee shorthand.
    	     * _.filter(users, _.iteratee(['user', 'fred']));
    	     * // => [{ 'user': 'fred', 'age': 40 }]
    	     *
    	     * // The `_.property` iteratee shorthand.
    	     * _.map(users, _.iteratee('user'));
    	     * // => ['barney', 'fred']
    	     *
    	     * // Create custom iteratee shorthands.
    	     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
    	     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
    	     *     return func.test(string);
    	     *   };
    	     * });
    	     *
    	     * _.filter(['abc', 'def'], /ef/);
    	     * // => ['def']
    	     */function iteratee(func){return baseIteratee(typeof func=='function'?func:baseClone(func,CLONE_DEEP_FLAG));}/**
    	     * Creates a function that performs a partial deep comparison between a given
    	     * object and `source`, returning `true` if the given object has equivalent
    	     * property values, else `false`.
    	     *
    	     * **Note:** The created function is equivalent to `_.isMatch` with `source`
    	     * partially applied.
    	     *
    	     * Partial comparisons will match empty array and empty object `source`
    	     * values against any array or object value, respectively. See `_.isEqual`
    	     * for a list of supported value comparisons.
    	     *
    	     * **Note:** Multiple values can be checked by combining several matchers
    	     * using `_.overSome`
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 3.0.0
    	     * @category Util
    	     * @param {Object} source The object of property values to match.
    	     * @returns {Function} Returns the new spec function.
    	     * @example
    	     *
    	     * var objects = [
    	     *   { 'a': 1, 'b': 2, 'c': 3 },
    	     *   { 'a': 4, 'b': 5, 'c': 6 }
    	     * ];
    	     *
    	     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
    	     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
    	     *
    	     * // Checking for several possible values
    	     * _.filter(objects, _.overSome([_.matches({ 'a': 1 }), _.matches({ 'a': 4 })]));
    	     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
    	     */function matches(source){return baseMatches(baseClone(source,CLONE_DEEP_FLAG));}/**
    	     * Creates a function that performs a partial deep comparison between the
    	     * value at `path` of a given object to `srcValue`, returning `true` if the
    	     * object value is equivalent, else `false`.
    	     *
    	     * **Note:** Partial comparisons will match empty array and empty object
    	     * `srcValue` values against any array or object value, respectively. See
    	     * `_.isEqual` for a list of supported value comparisons.
    	     *
    	     * **Note:** Multiple values can be checked by combining several matchers
    	     * using `_.overSome`
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 3.2.0
    	     * @category Util
    	     * @param {Array|string} path The path of the property to get.
    	     * @param {*} srcValue The value to match.
    	     * @returns {Function} Returns the new spec function.
    	     * @example
    	     *
    	     * var objects = [
    	     *   { 'a': 1, 'b': 2, 'c': 3 },
    	     *   { 'a': 4, 'b': 5, 'c': 6 }
    	     * ];
    	     *
    	     * _.find(objects, _.matchesProperty('a', 4));
    	     * // => { 'a': 4, 'b': 5, 'c': 6 }
    	     *
    	     * // Checking for several possible values
    	     * _.filter(objects, _.overSome([_.matchesProperty('a', 1), _.matchesProperty('a', 4)]));
    	     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
    	     */function matchesProperty(path,srcValue){return baseMatchesProperty(path,baseClone(srcValue,CLONE_DEEP_FLAG));}/**
    	     * Creates a function that invokes the method at `path` of a given object.
    	     * Any additional arguments are provided to the invoked method.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 3.7.0
    	     * @category Util
    	     * @param {Array|string} path The path of the method to invoke.
    	     * @param {...*} [args] The arguments to invoke the method with.
    	     * @returns {Function} Returns the new invoker function.
    	     * @example
    	     *
    	     * var objects = [
    	     *   { 'a': { 'b': _.constant(2) } },
    	     *   { 'a': { 'b': _.constant(1) } }
    	     * ];
    	     *
    	     * _.map(objects, _.method('a.b'));
    	     * // => [2, 1]
    	     *
    	     * _.map(objects, _.method(['a', 'b']));
    	     * // => [2, 1]
    	     */var method=baseRest(function(path,args){return function(object){return baseInvoke(object,path,args);};});/**
    	     * The opposite of `_.method`; this method creates a function that invokes
    	     * the method at a given path of `object`. Any additional arguments are
    	     * provided to the invoked method.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 3.7.0
    	     * @category Util
    	     * @param {Object} object The object to query.
    	     * @param {...*} [args] The arguments to invoke the method with.
    	     * @returns {Function} Returns the new invoker function.
    	     * @example
    	     *
    	     * var array = _.times(3, _.constant),
    	     *     object = { 'a': array, 'b': array, 'c': array };
    	     *
    	     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
    	     * // => [2, 0]
    	     *
    	     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
    	     * // => [2, 0]
    	     */var methodOf=baseRest(function(object,args){return function(path){return baseInvoke(object,path,args);};});/**
    	     * Adds all own enumerable string keyed function properties of a source
    	     * object to the destination object. If `object` is a function, then methods
    	     * are added to its prototype as well.
    	     *
    	     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
    	     * avoid conflicts caused by modifying the original.
    	     *
    	     * @static
    	     * @since 0.1.0
    	     * @memberOf _
    	     * @category Util
    	     * @param {Function|Object} [object=lodash] The destination object.
    	     * @param {Object} source The object of functions to add.
    	     * @param {Object} [options={}] The options object.
    	     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
    	     * @returns {Function|Object} Returns `object`.
    	     * @example
    	     *
    	     * function vowels(string) {
    	     *   return _.filter(string, function(v) {
    	     *     return /[aeiou]/i.test(v);
    	     *   });
    	     * }
    	     *
    	     * _.mixin({ 'vowels': vowels });
    	     * _.vowels('fred');
    	     * // => ['e']
    	     *
    	     * _('fred').vowels().value();
    	     * // => ['e']
    	     *
    	     * _.mixin({ 'vowels': vowels }, { 'chain': false });
    	     * _('fred').vowels();
    	     * // => ['e']
    	     */function mixin(object,source,options){var props=keys(source),methodNames=baseFunctions(source,props);if(options==null&&!(isObject(source)&&(methodNames.length||!props.length))){options=source;source=object;object=this;methodNames=baseFunctions(source,keys(source));}var chain=!(isObject(options)&&'chain'in options)||!!options.chain,isFunc=isFunction(object);arrayEach(methodNames,function(methodName){var func=source[methodName];object[methodName]=func;if(isFunc){object.prototype[methodName]=function(){var chainAll=this.__chain__;if(chain||chainAll){var result=object(this.__wrapped__),actions=result.__actions__=copyArray(this.__actions__);actions.push({'func':func,'args':arguments,'thisArg':object});result.__chain__=chainAll;return result;}return func.apply(object,arrayPush([this.value()],arguments));};}});return object;}/**
    	     * Reverts the `_` variable to its previous value and returns a reference to
    	     * the `lodash` function.
    	     *
    	     * @static
    	     * @since 0.1.0
    	     * @memberOf _
    	     * @category Util
    	     * @returns {Function} Returns the `lodash` function.
    	     * @example
    	     *
    	     * var lodash = _.noConflict();
    	     */function noConflict(){if(root._===this){root._=oldDash;}return this;}/**
    	     * This method returns `undefined`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 2.3.0
    	     * @category Util
    	     * @example
    	     *
    	     * _.times(2, _.noop);
    	     * // => [undefined, undefined]
    	     */function noop(){// No operation performed.
    	}/**
    	     * Creates a function that gets the argument at index `n`. If `n` is negative,
    	     * the nth argument from the end is returned.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Util
    	     * @param {number} [n=0] The index of the argument to return.
    	     * @returns {Function} Returns the new pass-thru function.
    	     * @example
    	     *
    	     * var func = _.nthArg(1);
    	     * func('a', 'b', 'c', 'd');
    	     * // => 'b'
    	     *
    	     * var func = _.nthArg(-2);
    	     * func('a', 'b', 'c', 'd');
    	     * // => 'c'
    	     */function nthArg(n){n=toInteger(n);return baseRest(function(args){return baseNth(args,n);});}/**
    	     * Creates a function that invokes `iteratees` with the arguments it receives
    	     * and returns their results.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Util
    	     * @param {...(Function|Function[])} [iteratees=[_.identity]]
    	     *  The iteratees to invoke.
    	     * @returns {Function} Returns the new function.
    	     * @example
    	     *
    	     * var func = _.over([Math.max, Math.min]);
    	     *
    	     * func(1, 2, 3, 4);
    	     * // => [4, 1]
    	     */var over=createOver(arrayMap);/**
    	     * Creates a function that checks if **all** of the `predicates` return
    	     * truthy when invoked with the arguments it receives.
    	     *
    	     * Following shorthands are possible for providing predicates.
    	     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
    	     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Util
    	     * @param {...(Function|Function[])} [predicates=[_.identity]]
    	     *  The predicates to check.
    	     * @returns {Function} Returns the new function.
    	     * @example
    	     *
    	     * var func = _.overEvery([Boolean, isFinite]);
    	     *
    	     * func('1');
    	     * // => true
    	     *
    	     * func(null);
    	     * // => false
    	     *
    	     * func(NaN);
    	     * // => false
    	     */var overEvery=createOver(arrayEvery);/**
    	     * Creates a function that checks if **any** of the `predicates` return
    	     * truthy when invoked with the arguments it receives.
    	     *
    	     * Following shorthands are possible for providing predicates.
    	     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
    	     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Util
    	     * @param {...(Function|Function[])} [predicates=[_.identity]]
    	     *  The predicates to check.
    	     * @returns {Function} Returns the new function.
    	     * @example
    	     *
    	     * var func = _.overSome([Boolean, isFinite]);
    	     *
    	     * func('1');
    	     * // => true
    	     *
    	     * func(null);
    	     * // => true
    	     *
    	     * func(NaN);
    	     * // => false
    	     *
    	     * var matchesFunc = _.overSome([{ 'a': 1 }, { 'a': 2 }])
    	     * var matchesPropertyFunc = _.overSome([['a', 1], ['a', 2]])
    	     */var overSome=createOver(arraySome);/**
    	     * Creates a function that returns the value at `path` of a given object.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 2.4.0
    	     * @category Util
    	     * @param {Array|string} path The path of the property to get.
    	     * @returns {Function} Returns the new accessor function.
    	     * @example
    	     *
    	     * var objects = [
    	     *   { 'a': { 'b': 2 } },
    	     *   { 'a': { 'b': 1 } }
    	     * ];
    	     *
    	     * _.map(objects, _.property('a.b'));
    	     * // => [2, 1]
    	     *
    	     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
    	     * // => [1, 2]
    	     */function property(path){return isKey(path)?baseProperty(toKey(path)):basePropertyDeep(path);}/**
    	     * The opposite of `_.property`; this method creates a function that returns
    	     * the value at a given path of `object`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 3.0.0
    	     * @category Util
    	     * @param {Object} object The object to query.
    	     * @returns {Function} Returns the new accessor function.
    	     * @example
    	     *
    	     * var array = [0, 1, 2],
    	     *     object = { 'a': array, 'b': array, 'c': array };
    	     *
    	     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
    	     * // => [2, 0]
    	     *
    	     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
    	     * // => [2, 0]
    	     */function propertyOf(object){return function(path){return object==null?undefined$1:baseGet(object,path);};}/**
    	     * Creates an array of numbers (positive and/or negative) progressing from
    	     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
    	     * `start` is specified without an `end` or `step`. If `end` is not specified,
    	     * it's set to `start` with `start` then set to `0`.
    	     *
    	     * **Note:** JavaScript follows the IEEE-754 standard for resolving
    	     * floating-point values which can produce unexpected results.
    	     *
    	     * @static
    	     * @since 0.1.0
    	     * @memberOf _
    	     * @category Util
    	     * @param {number} [start=0] The start of the range.
    	     * @param {number} end The end of the range.
    	     * @param {number} [step=1] The value to increment or decrement by.
    	     * @returns {Array} Returns the range of numbers.
    	     * @see _.inRange, _.rangeRight
    	     * @example
    	     *
    	     * _.range(4);
    	     * // => [0, 1, 2, 3]
    	     *
    	     * _.range(-4);
    	     * // => [0, -1, -2, -3]
    	     *
    	     * _.range(1, 5);
    	     * // => [1, 2, 3, 4]
    	     *
    	     * _.range(0, 20, 5);
    	     * // => [0, 5, 10, 15]
    	     *
    	     * _.range(0, -4, -1);
    	     * // => [0, -1, -2, -3]
    	     *
    	     * _.range(1, 4, 0);
    	     * // => [1, 1, 1]
    	     *
    	     * _.range(0);
    	     * // => []
    	     */var range=createRange();/**
    	     * This method is like `_.range` except that it populates values in
    	     * descending order.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Util
    	     * @param {number} [start=0] The start of the range.
    	     * @param {number} end The end of the range.
    	     * @param {number} [step=1] The value to increment or decrement by.
    	     * @returns {Array} Returns the range of numbers.
    	     * @see _.inRange, _.range
    	     * @example
    	     *
    	     * _.rangeRight(4);
    	     * // => [3, 2, 1, 0]
    	     *
    	     * _.rangeRight(-4);
    	     * // => [-3, -2, -1, 0]
    	     *
    	     * _.rangeRight(1, 5);
    	     * // => [4, 3, 2, 1]
    	     *
    	     * _.rangeRight(0, 20, 5);
    	     * // => [15, 10, 5, 0]
    	     *
    	     * _.rangeRight(0, -4, -1);
    	     * // => [-3, -2, -1, 0]
    	     *
    	     * _.rangeRight(1, 4, 0);
    	     * // => [1, 1, 1]
    	     *
    	     * _.rangeRight(0);
    	     * // => []
    	     */var rangeRight=createRange(true);/**
    	     * This method returns a new empty array.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.13.0
    	     * @category Util
    	     * @returns {Array} Returns the new empty array.
    	     * @example
    	     *
    	     * var arrays = _.times(2, _.stubArray);
    	     *
    	     * console.log(arrays);
    	     * // => [[], []]
    	     *
    	     * console.log(arrays[0] === arrays[1]);
    	     * // => false
    	     */function stubArray(){return [];}/**
    	     * This method returns `false`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.13.0
    	     * @category Util
    	     * @returns {boolean} Returns `false`.
    	     * @example
    	     *
    	     * _.times(2, _.stubFalse);
    	     * // => [false, false]
    	     */function stubFalse(){return false;}/**
    	     * This method returns a new empty object.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.13.0
    	     * @category Util
    	     * @returns {Object} Returns the new empty object.
    	     * @example
    	     *
    	     * var objects = _.times(2, _.stubObject);
    	     *
    	     * console.log(objects);
    	     * // => [{}, {}]
    	     *
    	     * console.log(objects[0] === objects[1]);
    	     * // => false
    	     */function stubObject(){return {};}/**
    	     * This method returns an empty string.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.13.0
    	     * @category Util
    	     * @returns {string} Returns the empty string.
    	     * @example
    	     *
    	     * _.times(2, _.stubString);
    	     * // => ['', '']
    	     */function stubString(){return '';}/**
    	     * This method returns `true`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.13.0
    	     * @category Util
    	     * @returns {boolean} Returns `true`.
    	     * @example
    	     *
    	     * _.times(2, _.stubTrue);
    	     * // => [true, true]
    	     */function stubTrue(){return true;}/**
    	     * Invokes the iteratee `n` times, returning an array of the results of
    	     * each invocation. The iteratee is invoked with one argument; (index).
    	     *
    	     * @static
    	     * @since 0.1.0
    	     * @memberOf _
    	     * @category Util
    	     * @param {number} n The number of times to invoke `iteratee`.
    	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
    	     * @returns {Array} Returns the array of results.
    	     * @example
    	     *
    	     * _.times(3, String);
    	     * // => ['0', '1', '2']
    	     *
    	     *  _.times(4, _.constant(0));
    	     * // => [0, 0, 0, 0]
    	     */function times(n,iteratee){n=toInteger(n);if(n<1||n>MAX_SAFE_INTEGER){return [];}var index=MAX_ARRAY_LENGTH,length=nativeMin(n,MAX_ARRAY_LENGTH);iteratee=getIteratee(iteratee);n-=MAX_ARRAY_LENGTH;var result=baseTimes(length,iteratee);while(++index<n){iteratee(index);}return result;}/**
    	     * Converts `value` to a property path array.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Util
    	     * @param {*} value The value to convert.
    	     * @returns {Array} Returns the new property path array.
    	     * @example
    	     *
    	     * _.toPath('a.b.c');
    	     * // => ['a', 'b', 'c']
    	     *
    	     * _.toPath('a[0].b.c');
    	     * // => ['a', '0', 'b', 'c']
    	     */function toPath(value){if(isArray(value)){return arrayMap(value,toKey);}return isSymbol(value)?[value]:copyArray(stringToPath(toString(value)));}/**
    	     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
    	     *
    	     * @static
    	     * @since 0.1.0
    	     * @memberOf _
    	     * @category Util
    	     * @param {string} [prefix=''] The value to prefix the ID with.
    	     * @returns {string} Returns the unique ID.
    	     * @example
    	     *
    	     * _.uniqueId('contact_');
    	     * // => 'contact_104'
    	     *
    	     * _.uniqueId();
    	     * // => '105'
    	     */function uniqueId(prefix){var id=++idCounter;return toString(prefix)+id;}/*------------------------------------------------------------------------*/ /**
    	     * Adds two numbers.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 3.4.0
    	     * @category Math
    	     * @param {number} augend The first number in an addition.
    	     * @param {number} addend The second number in an addition.
    	     * @returns {number} Returns the total.
    	     * @example
    	     *
    	     * _.add(6, 4);
    	     * // => 10
    	     */var add=createMathOperation(function(augend,addend){return augend+addend;},0);/**
    	     * Computes `number` rounded up to `precision`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 3.10.0
    	     * @category Math
    	     * @param {number} number The number to round up.
    	     * @param {number} [precision=0] The precision to round up to.
    	     * @returns {number} Returns the rounded up number.
    	     * @example
    	     *
    	     * _.ceil(4.006);
    	     * // => 5
    	     *
    	     * _.ceil(6.004, 2);
    	     * // => 6.01
    	     *
    	     * _.ceil(6040, -2);
    	     * // => 6100
    	     */var ceil=createRound('ceil');/**
    	     * Divide two numbers.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.7.0
    	     * @category Math
    	     * @param {number} dividend The first number in a division.
    	     * @param {number} divisor The second number in a division.
    	     * @returns {number} Returns the quotient.
    	     * @example
    	     *
    	     * _.divide(6, 4);
    	     * // => 1.5
    	     */var divide=createMathOperation(function(dividend,divisor){return dividend/divisor;},1);/**
    	     * Computes `number` rounded down to `precision`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 3.10.0
    	     * @category Math
    	     * @param {number} number The number to round down.
    	     * @param {number} [precision=0] The precision to round down to.
    	     * @returns {number} Returns the rounded down number.
    	     * @example
    	     *
    	     * _.floor(4.006);
    	     * // => 4
    	     *
    	     * _.floor(0.046, 2);
    	     * // => 0.04
    	     *
    	     * _.floor(4060, -2);
    	     * // => 4000
    	     */var floor=createRound('floor');/**
    	     * Computes the maximum value of `array`. If `array` is empty or falsey,
    	     * `undefined` is returned.
    	     *
    	     * @static
    	     * @since 0.1.0
    	     * @memberOf _
    	     * @category Math
    	     * @param {Array} array The array to iterate over.
    	     * @returns {*} Returns the maximum value.
    	     * @example
    	     *
    	     * _.max([4, 2, 8, 6]);
    	     * // => 8
    	     *
    	     * _.max([]);
    	     * // => undefined
    	     */function max(array){return array&&array.length?baseExtremum(array,identity,baseGt):undefined$1;}/**
    	     * This method is like `_.max` except that it accepts `iteratee` which is
    	     * invoked for each element in `array` to generate the criterion by which
    	     * the value is ranked. The iteratee is invoked with one argument: (value).
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Math
    	     * @param {Array} array The array to iterate over.
    	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
    	     * @returns {*} Returns the maximum value.
    	     * @example
    	     *
    	     * var objects = [{ 'n': 1 }, { 'n': 2 }];
    	     *
    	     * _.maxBy(objects, function(o) { return o.n; });
    	     * // => { 'n': 2 }
    	     *
    	     * // The `_.property` iteratee shorthand.
    	     * _.maxBy(objects, 'n');
    	     * // => { 'n': 2 }
    	     */function maxBy(array,iteratee){return array&&array.length?baseExtremum(array,getIteratee(iteratee,2),baseGt):undefined$1;}/**
    	     * Computes the mean of the values in `array`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Math
    	     * @param {Array} array The array to iterate over.
    	     * @returns {number} Returns the mean.
    	     * @example
    	     *
    	     * _.mean([4, 2, 8, 6]);
    	     * // => 5
    	     */function mean(array){return baseMean(array,identity);}/**
    	     * This method is like `_.mean` except that it accepts `iteratee` which is
    	     * invoked for each element in `array` to generate the value to be averaged.
    	     * The iteratee is invoked with one argument: (value).
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.7.0
    	     * @category Math
    	     * @param {Array} array The array to iterate over.
    	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
    	     * @returns {number} Returns the mean.
    	     * @example
    	     *
    	     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
    	     *
    	     * _.meanBy(objects, function(o) { return o.n; });
    	     * // => 5
    	     *
    	     * // The `_.property` iteratee shorthand.
    	     * _.meanBy(objects, 'n');
    	     * // => 5
    	     */function meanBy(array,iteratee){return baseMean(array,getIteratee(iteratee,2));}/**
    	     * Computes the minimum value of `array`. If `array` is empty or falsey,
    	     * `undefined` is returned.
    	     *
    	     * @static
    	     * @since 0.1.0
    	     * @memberOf _
    	     * @category Math
    	     * @param {Array} array The array to iterate over.
    	     * @returns {*} Returns the minimum value.
    	     * @example
    	     *
    	     * _.min([4, 2, 8, 6]);
    	     * // => 2
    	     *
    	     * _.min([]);
    	     * // => undefined
    	     */function min(array){return array&&array.length?baseExtremum(array,identity,baseLt):undefined$1;}/**
    	     * This method is like `_.min` except that it accepts `iteratee` which is
    	     * invoked for each element in `array` to generate the criterion by which
    	     * the value is ranked. The iteratee is invoked with one argument: (value).
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Math
    	     * @param {Array} array The array to iterate over.
    	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
    	     * @returns {*} Returns the minimum value.
    	     * @example
    	     *
    	     * var objects = [{ 'n': 1 }, { 'n': 2 }];
    	     *
    	     * _.minBy(objects, function(o) { return o.n; });
    	     * // => { 'n': 1 }
    	     *
    	     * // The `_.property` iteratee shorthand.
    	     * _.minBy(objects, 'n');
    	     * // => { 'n': 1 }
    	     */function minBy(array,iteratee){return array&&array.length?baseExtremum(array,getIteratee(iteratee,2),baseLt):undefined$1;}/**
    	     * Multiply two numbers.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.7.0
    	     * @category Math
    	     * @param {number} multiplier The first number in a multiplication.
    	     * @param {number} multiplicand The second number in a multiplication.
    	     * @returns {number} Returns the product.
    	     * @example
    	     *
    	     * _.multiply(6, 4);
    	     * // => 24
    	     */var multiply=createMathOperation(function(multiplier,multiplicand){return multiplier*multiplicand;},1);/**
    	     * Computes `number` rounded to `precision`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 3.10.0
    	     * @category Math
    	     * @param {number} number The number to round.
    	     * @param {number} [precision=0] The precision to round to.
    	     * @returns {number} Returns the rounded number.
    	     * @example
    	     *
    	     * _.round(4.006);
    	     * // => 4
    	     *
    	     * _.round(4.006, 2);
    	     * // => 4.01
    	     *
    	     * _.round(4060, -2);
    	     * // => 4100
    	     */var round=createRound('round');/**
    	     * Subtract two numbers.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Math
    	     * @param {number} minuend The first number in a subtraction.
    	     * @param {number} subtrahend The second number in a subtraction.
    	     * @returns {number} Returns the difference.
    	     * @example
    	     *
    	     * _.subtract(6, 4);
    	     * // => 2
    	     */var subtract=createMathOperation(function(minuend,subtrahend){return minuend-subtrahend;},0);/**
    	     * Computes the sum of the values in `array`.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 3.4.0
    	     * @category Math
    	     * @param {Array} array The array to iterate over.
    	     * @returns {number} Returns the sum.
    	     * @example
    	     *
    	     * _.sum([4, 2, 8, 6]);
    	     * // => 20
    	     */function sum(array){return array&&array.length?baseSum(array,identity):0;}/**
    	     * This method is like `_.sum` except that it accepts `iteratee` which is
    	     * invoked for each element in `array` to generate the value to be summed.
    	     * The iteratee is invoked with one argument: (value).
    	     *
    	     * @static
    	     * @memberOf _
    	     * @since 4.0.0
    	     * @category Math
    	     * @param {Array} array The array to iterate over.
    	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
    	     * @returns {number} Returns the sum.
    	     * @example
    	     *
    	     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
    	     *
    	     * _.sumBy(objects, function(o) { return o.n; });
    	     * // => 20
    	     *
    	     * // The `_.property` iteratee shorthand.
    	     * _.sumBy(objects, 'n');
    	     * // => 20
    	     */function sumBy(array,iteratee){return array&&array.length?baseSum(array,getIteratee(iteratee,2)):0;}/*------------------------------------------------------------------------*/ // Add methods that return wrapped values in chain sequences.
    	lodash.after=after;lodash.ary=ary;lodash.assign=assign;lodash.assignIn=assignIn;lodash.assignInWith=assignInWith;lodash.assignWith=assignWith;lodash.at=at;lodash.before=before;lodash.bind=bind;lodash.bindAll=bindAll;lodash.bindKey=bindKey;lodash.castArray=castArray;lodash.chain=chain;lodash.chunk=chunk;lodash.compact=compact;lodash.concat=concat;lodash.cond=cond;lodash.conforms=conforms;lodash.constant=constant;lodash.countBy=countBy;lodash.create=create;lodash.curry=curry;lodash.curryRight=curryRight;lodash.debounce=debounce;lodash.defaults=defaults;lodash.defaultsDeep=defaultsDeep;lodash.defer=defer;lodash.delay=delay;lodash.difference=difference;lodash.differenceBy=differenceBy;lodash.differenceWith=differenceWith;lodash.drop=drop;lodash.dropRight=dropRight;lodash.dropRightWhile=dropRightWhile;lodash.dropWhile=dropWhile;lodash.fill=fill;lodash.filter=filter;lodash.flatMap=flatMap;lodash.flatMapDeep=flatMapDeep;lodash.flatMapDepth=flatMapDepth;lodash.flatten=flatten;lodash.flattenDeep=flattenDeep;lodash.flattenDepth=flattenDepth;lodash.flip=flip;lodash.flow=flow;lodash.flowRight=flowRight;lodash.fromPairs=fromPairs;lodash.functions=functions;lodash.functionsIn=functionsIn;lodash.groupBy=groupBy;lodash.initial=initial;lodash.intersection=intersection;lodash.intersectionBy=intersectionBy;lodash.intersectionWith=intersectionWith;lodash.invert=invert;lodash.invertBy=invertBy;lodash.invokeMap=invokeMap;lodash.iteratee=iteratee;lodash.keyBy=keyBy;lodash.keys=keys;lodash.keysIn=keysIn;lodash.map=map;lodash.mapKeys=mapKeys;lodash.mapValues=mapValues;lodash.matches=matches;lodash.matchesProperty=matchesProperty;lodash.memoize=memoize;lodash.merge=merge;lodash.mergeWith=mergeWith;lodash.method=method;lodash.methodOf=methodOf;lodash.mixin=mixin;lodash.negate=negate;lodash.nthArg=nthArg;lodash.omit=omit;lodash.omitBy=omitBy;lodash.once=once;lodash.orderBy=orderBy;lodash.over=over;lodash.overArgs=overArgs;lodash.overEvery=overEvery;lodash.overSome=overSome;lodash.partial=partial;lodash.partialRight=partialRight;lodash.partition=partition;lodash.pick=pick;lodash.pickBy=pickBy;lodash.property=property;lodash.propertyOf=propertyOf;lodash.pull=pull;lodash.pullAll=pullAll;lodash.pullAllBy=pullAllBy;lodash.pullAllWith=pullAllWith;lodash.pullAt=pullAt;lodash.range=range;lodash.rangeRight=rangeRight;lodash.rearg=rearg;lodash.reject=reject;lodash.remove=remove;lodash.rest=rest;lodash.reverse=reverse;lodash.sampleSize=sampleSize;lodash.set=set;lodash.setWith=setWith;lodash.shuffle=shuffle;lodash.slice=slice;lodash.sortBy=sortBy;lodash.sortedUniq=sortedUniq;lodash.sortedUniqBy=sortedUniqBy;lodash.split=split;lodash.spread=spread;lodash.tail=tail;lodash.take=take;lodash.takeRight=takeRight;lodash.takeRightWhile=takeRightWhile;lodash.takeWhile=takeWhile;lodash.tap=tap;lodash.throttle=throttle;lodash.thru=thru;lodash.toArray=toArray;lodash.toPairs=toPairs;lodash.toPairsIn=toPairsIn;lodash.toPath=toPath;lodash.toPlainObject=toPlainObject;lodash.transform=transform;lodash.unary=unary;lodash.union=union;lodash.unionBy=unionBy;lodash.unionWith=unionWith;lodash.uniq=uniq;lodash.uniqBy=uniqBy;lodash.uniqWith=uniqWith;lodash.unset=unset;lodash.unzip=unzip;lodash.unzipWith=unzipWith;lodash.update=update;lodash.updateWith=updateWith;lodash.values=values;lodash.valuesIn=valuesIn;lodash.without=without;lodash.words=words;lodash.wrap=wrap;lodash.xor=xor;lodash.xorBy=xorBy;lodash.xorWith=xorWith;lodash.zip=zip;lodash.zipObject=zipObject;lodash.zipObjectDeep=zipObjectDeep;lodash.zipWith=zipWith;// Add aliases.
    	lodash.entries=toPairs;lodash.entriesIn=toPairsIn;lodash.extend=assignIn;lodash.extendWith=assignInWith;// Add methods to `lodash.prototype`.
    	mixin(lodash,lodash);/*------------------------------------------------------------------------*/ // Add methods that return unwrapped values in chain sequences.
    	lodash.add=add;lodash.attempt=attempt;lodash.camelCase=camelCase;lodash.capitalize=capitalize;lodash.ceil=ceil;lodash.clamp=clamp;lodash.clone=clone;lodash.cloneDeep=cloneDeep;lodash.cloneDeepWith=cloneDeepWith;lodash.cloneWith=cloneWith;lodash.conformsTo=conformsTo;lodash.deburr=deburr;lodash.defaultTo=defaultTo;lodash.divide=divide;lodash.endsWith=endsWith;lodash.eq=eq;lodash.escape=escape;lodash.escapeRegExp=escapeRegExp;lodash.every=every;lodash.find=find;lodash.findIndex=findIndex;lodash.findKey=findKey;lodash.findLast=findLast;lodash.findLastIndex=findLastIndex;lodash.findLastKey=findLastKey;lodash.floor=floor;lodash.forEach=forEach;lodash.forEachRight=forEachRight;lodash.forIn=forIn;lodash.forInRight=forInRight;lodash.forOwn=forOwn;lodash.forOwnRight=forOwnRight;lodash.get=get;lodash.gt=gt;lodash.gte=gte;lodash.has=has;lodash.hasIn=hasIn;lodash.head=head;lodash.identity=identity;lodash.includes=includes;lodash.indexOf=indexOf;lodash.inRange=inRange;lodash.invoke=invoke;lodash.isArguments=isArguments;lodash.isArray=isArray;lodash.isArrayBuffer=isArrayBuffer;lodash.isArrayLike=isArrayLike;lodash.isArrayLikeObject=isArrayLikeObject;lodash.isBoolean=isBoolean;lodash.isBuffer=isBuffer;lodash.isDate=isDate;lodash.isElement=isElement;lodash.isEmpty=isEmpty;lodash.isEqual=isEqual;lodash.isEqualWith=isEqualWith;lodash.isError=isError;lodash.isFinite=isFinite;lodash.isFunction=isFunction;lodash.isInteger=isInteger;lodash.isLength=isLength;lodash.isMap=isMap;lodash.isMatch=isMatch;lodash.isMatchWith=isMatchWith;lodash.isNaN=isNaN;lodash.isNative=isNative;lodash.isNil=isNil;lodash.isNull=isNull;lodash.isNumber=isNumber;lodash.isObject=isObject;lodash.isObjectLike=isObjectLike;lodash.isPlainObject=isPlainObject;lodash.isRegExp=isRegExp;lodash.isSafeInteger=isSafeInteger;lodash.isSet=isSet;lodash.isString=isString;lodash.isSymbol=isSymbol;lodash.isTypedArray=isTypedArray;lodash.isUndefined=isUndefined;lodash.isWeakMap=isWeakMap;lodash.isWeakSet=isWeakSet;lodash.join=join;lodash.kebabCase=kebabCase;lodash.last=last;lodash.lastIndexOf=lastIndexOf;lodash.lowerCase=lowerCase;lodash.lowerFirst=lowerFirst;lodash.lt=lt;lodash.lte=lte;lodash.max=max;lodash.maxBy=maxBy;lodash.mean=mean;lodash.meanBy=meanBy;lodash.min=min;lodash.minBy=minBy;lodash.stubArray=stubArray;lodash.stubFalse=stubFalse;lodash.stubObject=stubObject;lodash.stubString=stubString;lodash.stubTrue=stubTrue;lodash.multiply=multiply;lodash.nth=nth;lodash.noConflict=noConflict;lodash.noop=noop;lodash.now=now;lodash.pad=pad;lodash.padEnd=padEnd;lodash.padStart=padStart;lodash.parseInt=parseInt;lodash.random=random;lodash.reduce=reduce;lodash.reduceRight=reduceRight;lodash.repeat=repeat;lodash.replace=replace;lodash.result=result;lodash.round=round;lodash.runInContext=runInContext;lodash.sample=sample;lodash.size=size;lodash.snakeCase=snakeCase;lodash.some=some;lodash.sortedIndex=sortedIndex;lodash.sortedIndexBy=sortedIndexBy;lodash.sortedIndexOf=sortedIndexOf;lodash.sortedLastIndex=sortedLastIndex;lodash.sortedLastIndexBy=sortedLastIndexBy;lodash.sortedLastIndexOf=sortedLastIndexOf;lodash.startCase=startCase;lodash.startsWith=startsWith;lodash.subtract=subtract;lodash.sum=sum;lodash.sumBy=sumBy;lodash.template=template;lodash.times=times;lodash.toFinite=toFinite;lodash.toInteger=toInteger;lodash.toLength=toLength;lodash.toLower=toLower;lodash.toNumber=toNumber;lodash.toSafeInteger=toSafeInteger;lodash.toString=toString;lodash.toUpper=toUpper;lodash.trim=trim;lodash.trimEnd=trimEnd;lodash.trimStart=trimStart;lodash.truncate=truncate;lodash.unescape=unescape;lodash.uniqueId=uniqueId;lodash.upperCase=upperCase;lodash.upperFirst=upperFirst;// Add aliases.
    	lodash.each=forEach;lodash.eachRight=forEachRight;lodash.first=head;mixin(lodash,function(){var source={};baseForOwn(lodash,function(func,methodName){if(!hasOwnProperty.call(lodash.prototype,methodName)){source[methodName]=func;}});return source;}(),{'chain':false});/*------------------------------------------------------------------------*/ /**
    	     * The semantic version number.
    	     *
    	     * @static
    	     * @memberOf _
    	     * @type {string}
    	     */lodash.VERSION=VERSION;// Assign default placeholders.
    	arrayEach(['bind','bindKey','curry','curryRight','partial','partialRight'],function(methodName){lodash[methodName].placeholder=lodash;});// Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
    	arrayEach(['drop','take'],function(methodName,index){LazyWrapper.prototype[methodName]=function(n){n=n===undefined$1?1:nativeMax(toInteger(n),0);var result=this.__filtered__&&!index?new LazyWrapper(this):this.clone();if(result.__filtered__){result.__takeCount__=nativeMin(n,result.__takeCount__);}else {result.__views__.push({'size':nativeMin(n,MAX_ARRAY_LENGTH),'type':methodName+(result.__dir__<0?'Right':'')});}return result;};LazyWrapper.prototype[methodName+'Right']=function(n){return this.reverse()[methodName](n).reverse();};});// Add `LazyWrapper` methods that accept an `iteratee` value.
    	arrayEach(['filter','map','takeWhile'],function(methodName,index){var type=index+1,isFilter=type==LAZY_FILTER_FLAG||type==LAZY_WHILE_FLAG;LazyWrapper.prototype[methodName]=function(iteratee){var result=this.clone();result.__iteratees__.push({'iteratee':getIteratee(iteratee,3),'type':type});result.__filtered__=result.__filtered__||isFilter;return result;};});// Add `LazyWrapper` methods for `_.head` and `_.last`.
    	arrayEach(['head','last'],function(methodName,index){var takeName='take'+(index?'Right':'');LazyWrapper.prototype[methodName]=function(){return this[takeName](1).value()[0];};});// Add `LazyWrapper` methods for `_.initial` and `_.tail`.
    	arrayEach(['initial','tail'],function(methodName,index){var dropName='drop'+(index?'':'Right');LazyWrapper.prototype[methodName]=function(){return this.__filtered__?new LazyWrapper(this):this[dropName](1);};});LazyWrapper.prototype.compact=function(){return this.filter(identity);};LazyWrapper.prototype.find=function(predicate){return this.filter(predicate).head();};LazyWrapper.prototype.findLast=function(predicate){return this.reverse().find(predicate);};LazyWrapper.prototype.invokeMap=baseRest(function(path,args){if(typeof path=='function'){return new LazyWrapper(this);}return this.map(function(value){return baseInvoke(value,path,args);});});LazyWrapper.prototype.reject=function(predicate){return this.filter(negate(getIteratee(predicate)));};LazyWrapper.prototype.slice=function(start,end){start=toInteger(start);var result=this;if(result.__filtered__&&(start>0||end<0)){return new LazyWrapper(result);}if(start<0){result=result.takeRight(-start);}else if(start){result=result.drop(start);}if(end!==undefined$1){end=toInteger(end);result=end<0?result.dropRight(-end):result.take(end-start);}return result;};LazyWrapper.prototype.takeRightWhile=function(predicate){return this.reverse().takeWhile(predicate).reverse();};LazyWrapper.prototype.toArray=function(){return this.take(MAX_ARRAY_LENGTH);};// Add `LazyWrapper` methods to `lodash.prototype`.
    	baseForOwn(LazyWrapper.prototype,function(func,methodName){var checkIteratee=/^(?:filter|find|map|reject)|While$/.test(methodName),isTaker=/^(?:head|last)$/.test(methodName),lodashFunc=lodash[isTaker?'take'+(methodName=='last'?'Right':''):methodName],retUnwrapped=isTaker||/^find/.test(methodName);if(!lodashFunc){return;}lodash.prototype[methodName]=function(){var value=this.__wrapped__,args=isTaker?[1]:arguments,isLazy=value instanceof LazyWrapper,iteratee=args[0],useLazy=isLazy||isArray(value);var interceptor=function(value){var result=lodashFunc.apply(lodash,arrayPush([value],args));return isTaker&&chainAll?result[0]:result;};if(useLazy&&checkIteratee&&typeof iteratee=='function'&&iteratee.length!=1){// Avoid lazy use if the iteratee has a "length" value other than `1`.
    	isLazy=useLazy=false;}var chainAll=this.__chain__,isHybrid=!!this.__actions__.length,isUnwrapped=retUnwrapped&&!chainAll,onlyLazy=isLazy&&!isHybrid;if(!retUnwrapped&&useLazy){value=onlyLazy?value:new LazyWrapper(this);var result=func.apply(value,args);result.__actions__.push({'func':thru,'args':[interceptor],'thisArg':undefined$1});return new LodashWrapper(result,chainAll);}if(isUnwrapped&&onlyLazy){return func.apply(this,args);}result=this.thru(interceptor);return isUnwrapped?isTaker?result.value()[0]:result.value():result;};});// Add `Array` methods to `lodash.prototype`.
    	arrayEach(['pop','push','shift','sort','splice','unshift'],function(methodName){var func=arrayProto[methodName],chainName=/^(?:push|sort|unshift)$/.test(methodName)?'tap':'thru',retUnwrapped=/^(?:pop|shift)$/.test(methodName);lodash.prototype[methodName]=function(){var args=arguments;if(retUnwrapped&&!this.__chain__){var value=this.value();return func.apply(isArray(value)?value:[],args);}return this[chainName](function(value){return func.apply(isArray(value)?value:[],args);});};});// Map minified method names to their real names.
    	baseForOwn(LazyWrapper.prototype,function(func,methodName){var lodashFunc=lodash[methodName];if(lodashFunc){var key=lodashFunc.name+'';if(!hasOwnProperty.call(realNames,key)){realNames[key]=[];}realNames[key].push({'name':methodName,'func':lodashFunc});}});realNames[createHybrid(undefined$1,WRAP_BIND_KEY_FLAG).name]=[{'name':'wrapper','func':undefined$1}];// Add methods to `LazyWrapper`.
    	LazyWrapper.prototype.clone=lazyClone;LazyWrapper.prototype.reverse=lazyReverse;LazyWrapper.prototype.value=lazyValue;// Add chain sequence methods to the `lodash` wrapper.
    	lodash.prototype.at=wrapperAt;lodash.prototype.chain=wrapperChain;lodash.prototype.commit=wrapperCommit;lodash.prototype.next=wrapperNext;lodash.prototype.plant=wrapperPlant;lodash.prototype.reverse=wrapperReverse;lodash.prototype.toJSON=lodash.prototype.valueOf=lodash.prototype.value=wrapperValue;// Add lazy aliases.
    	lodash.prototype.first=lodash.prototype.head;if(symIterator){lodash.prototype[symIterator]=wrapperToIterator;}return lodash;};/*--------------------------------------------------------------------------*/ // Export lodash.
    	var _=runInContext();// Some AMD build optimizers, like r.js, check for condition patterns like:
    	if(freeModule){// Export for Node.js.
    	(freeModule.exports=_)._=_;// Export for CommonJS support.
    	freeExports._=_;}else {// Export to the global object.
    	root._=_;}}).call(commonjsGlobal);
    } (lodash, lodash.exports));

    var commonVariables$m = {
      fontFamily: 'v-sans, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"',
      fontFamilyMono: "v-mono, SFMono-Regular, Menlo, Consolas, Courier, monospace",
      fontWeight: "400",
      fontWeightStrong: "500",
      cubicBezierEaseInOut: "cubic-bezier(.4, 0, .2, 1)",
      cubicBezierEaseOut: "cubic-bezier(0, 0, .2, 1)",
      cubicBezierEaseIn: "cubic-bezier(.4, 0, 1, 1)",
      borderRadius: "3px",
      borderRadiusSmall: "2px",
      fontSize: "14px",
      fontSizeMini: "12px",
      fontSizeTiny: "12px",
      fontSizeSmall: "14px",
      fontSizeMedium: "14px",
      fontSizeLarge: "15px",
      fontSizeHuge: "16px",
      lineHeight: "1.6",
      heightMini: "16px",
      heightTiny: "22px",
      heightSmall: "28px",
      heightMedium: "34px",
      heightLarge: "40px",
      heightHuge: "46px"
    };

    const {
      fontSize,
      fontFamily,
      lineHeight: lineHeight$1
    } = commonVariables$m;
    var globalStyle = c$1("body", `
  margin: 0;
  font-size: ${fontSize};
  font-family: ${fontFamily};
  line-height: ${lineHeight$1};
  -webkit-text-size-adjust: 100%;
  -webkit-tap-highlight-color: transparent;
`, [c$1("input", `
    font-family: inherit;
    font-size: inherit;
  `)]);

    const configProviderInjectionKey = createInjectionKey("n-config-provider");

    const cssrAnchorMetaName = "naive-ui-style";

    function createTheme$1(theme) {
      return theme;
    }

    function useTheme(resolveId, mountId, style, defaultTheme, props, clsPrefixRef) {
      const ssrAdapter = useSsrAdapter();
      const NConfigProvider = vue.inject(configProviderInjectionKey, null);

      if (style) {
        const mountStyle = () => {
          const clsPrefix = clsPrefixRef === null || clsPrefixRef === void 0 ? void 0 : clsPrefixRef.value;
          style.mount({
            id: clsPrefix === void 0 ? mountId : clsPrefix + mountId,
            head: true,
            props: {
              bPrefix: clsPrefix ? `.${clsPrefix}-` : void 0
            },
            anchorMetaName: cssrAnchorMetaName,
            ssr: ssrAdapter
          });

          if (!(NConfigProvider !== null && NConfigProvider !== void 0 && NConfigProvider.preflightStyleDisabled)) {
            globalStyle.mount({
              id: "n-global",
              head: true,
              anchorMetaName: cssrAnchorMetaName,
              ssr: ssrAdapter
            });
          }
        };

        if (ssrAdapter) {
          mountStyle();
        } else {
          vue.onBeforeMount(mountStyle);
        }
      }

      const mergedThemeRef = vue.computed(() => {
        var _ref;

        const {
          theme: {
            common: selfCommon,
            self,
            peers = {}
          } = {},
          themeOverrides: selfOverrides = {},
          builtinThemeOverrides: builtinOverrides = {}
        } = props;
        const {
          common: selfCommonOverrides,
          peers: peersOverrides
        } = selfOverrides;
        const {
          common: globalCommon = void 0,
          [resolveId]: {
            common: globalSelfCommon = void 0,
            self: globalSelf = void 0,
            peers: globalPeers = {}
          } = {}
        } = (NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedThemeRef.value) || {};
        const {
          common: globalCommonOverrides = void 0,
          [resolveId]: globalSelfOverrides = {}
        } = (NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedThemeOverridesRef.value) || {};
        const {
          common: globalSelfCommonOverrides,
          peers: globalPeersOverrides = {}
        } = globalSelfOverrides;
        const mergedCommon = lodash.exports.merge({}, selfCommon || globalSelfCommon || globalCommon || defaultTheme.common, globalCommonOverrides, globalSelfCommonOverrides, selfCommonOverrides);
        const mergedSelf = lodash.exports.merge((_ref = self || globalSelf || defaultTheme.self) === null || _ref === void 0 ? void 0 : _ref(mergedCommon), builtinOverrides, globalSelfOverrides, selfOverrides);
        return {
          common: mergedCommon,
          self: mergedSelf,
          peers: lodash.exports.merge({}, defaultTheme.peers, globalPeers, peers),
          peerOverrides: lodash.exports.merge({}, builtinOverrides.peers, globalPeersOverrides, peersOverrides)
        };
      });
      return mergedThemeRef;
    }

    useTheme.props = {
      theme: Object,
      themeOverrides: Object,
      builtinThemeOverrides: Object
    };

    const defaultClsPrefix = "n";
    function useConfig() {
      let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        defaultBordered: true
      };
      const NConfigProvider = vue.inject(configProviderInjectionKey, null);
      return {
        inlineThemeDisabled: NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.inlineThemeDisabled,
        mergedRtlRef: NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedRtlRef,
        mergedComponentPropsRef: NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedComponentPropsRef,
        mergedBreakpointsRef: NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedBreakpointsRef,
        mergedBorderedRef: vue.computed(() => {
          const {
            bordered
          } = props;
          if (bordered !== void 0) return bordered;
          return (NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedBorderedRef.value) ?? options.defaultBordered ?? true;
        }),
        mergedClsPrefixRef: vue.computed(() => {
          const clsPrefix = NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedClsPrefixRef.value;
          return clsPrefix || defaultClsPrefix;
        }),
        namespaceRef: vue.computed(() => NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedNamespaceRef.value)
      };
    }

    const zhCN = {
      name: "zh-CN",
      global: {
        undo: "\u64A4\u9500",
        redo: "\u91CD\u505A",
        confirm: "\u786E\u8BA4"
      },
      Popconfirm: {
        positiveText: "\u786E\u8BA4",
        negativeText: "\u53D6\u6D88"
      },
      Cascader: {
        placeholder: "\u8BF7\u9009\u62E9",
        loading: "\u52A0\u8F7D\u4E2D",
        loadingRequiredMessage: label => `\u52A0\u8F7D\u5168\u90E8 ${label} \u7684\u5B50\u8282\u70B9\u540E\u624D\u53EF\u9009\u4E2D`
      },
      Time: {
        dateFormat: "yyyy-MM-dd",
        dateTimeFormat: "yyyy-MM-dd HH:mm:ss"
      },
      DatePicker: {
        yearFormat: "yyyy\u5E74",
        monthFormat: "MMM",
        dayFormat: "eeeeee",
        yearTypeFormat: "yyyy",
        monthTypeFormat: "yyyy-MM",
        dateFormat: "yyyy-MM-dd",
        dateTimeFormat: "yyyy-MM-dd HH:mm:ss",
        quarterFormat: "yyyy-qqq",
        clear: "\u6E05\u9664",
        now: "\u6B64\u523B",
        confirm: "\u786E\u8BA4",
        selectTime: "\u9009\u62E9\u65F6\u95F4",
        selectDate: "\u9009\u62E9\u65E5\u671F",
        datePlaceholder: "\u9009\u62E9\u65E5\u671F",
        datetimePlaceholder: "\u9009\u62E9\u65E5\u671F\u65F6\u95F4",
        monthPlaceholder: "\u9009\u62E9\u6708\u4EFD",
        yearPlaceholder: "\u9009\u62E9\u5E74\u4EFD",
        quarterPlaceholder: "\u9009\u62E9\u5B63\u5EA6",
        startDatePlaceholder: "\u5F00\u59CB\u65E5\u671F",
        endDatePlaceholder: "\u7ED3\u675F\u65E5\u671F",
        startDatetimePlaceholder: "\u5F00\u59CB\u65E5\u671F\u65F6\u95F4",
        endDatetimePlaceholder: "\u7ED3\u675F\u65E5\u671F\u65F6\u95F4",
        startMonthPlaceholder: "\u5F00\u59CB\u6708\u4EFD",
        endMonthPlaceholder: "\u7ED3\u675F\u6708\u4EFD",
        monthBeforeYear: false,
        firstDayOfWeek: 0,
        today: "\u4ECA\u5929"
      },
      DataTable: {
        checkTableAll: "\u9009\u62E9\u5168\u90E8\u8868\u683C\u6570\u636E",
        uncheckTableAll: "\u53D6\u6D88\u9009\u62E9\u5168\u90E8\u8868\u683C\u6570\u636E",
        confirm: "\u786E\u8BA4",
        clear: "\u91CD\u7F6E"
      },
      LegacyTransfer: {
        sourceTitle: "\u6E90\u9879",
        targetTitle: "\u76EE\u6807\u9879"
      },
      Transfer: {
        selectAll: "\u5168\u9009",
        clearAll: "\u6E05\u9664",
        unselectAll: "\u53D6\u6D88\u5168\u9009",
        total: num => `\u5171 ${num} \u9879`,
        selected: num => `\u5DF2\u9009 ${num} \u9879`
      },
      Empty: {
        description: "\u65E0\u6570\u636E"
      },
      Select: {
        placeholder: "\u8BF7\u9009\u62E9"
      },
      TimePicker: {
        placeholder: "\u8BF7\u9009\u62E9\u65F6\u95F4",
        positiveText: "\u786E\u8BA4",
        negativeText: "\u53D6\u6D88",
        now: "\u6B64\u523B"
      },
      Pagination: {
        goto: "\u8DF3\u81F3",
        selectionSuffix: "\u9875"
      },
      DynamicTags: {
        add: "\u6DFB\u52A0"
      },
      Log: {
        loading: "\u52A0\u8F7D\u4E2D"
      },
      Input: {
        placeholder: "\u8BF7\u8F93\u5165"
      },
      InputNumber: {
        placeholder: "\u8BF7\u8F93\u5165"
      },
      DynamicInput: {
        create: "\u6DFB\u52A0"
      },
      ThemeEditor: {
        title: "\u4E3B\u9898\u7F16\u8F91\u5668",
        clearAllVars: "\u6E05\u9664\u5168\u90E8\u53D8\u91CF",
        clearSearch: "\u6E05\u9664\u641C\u7D22",
        filterCompName: "\u8FC7\u6EE4\u7EC4\u4EF6\u540D",
        filterVarName: "\u8FC7\u6EE4\u53D8\u91CF\u540D",
        import: "\u5BFC\u5165",
        export: "\u5BFC\u51FA",
        restore: "\u6062\u590D\u9ED8\u8BA4"
      },
      Image: {
        tipPrevious: "\u4E0A\u4E00\u5F20\uFF08\u2190\uFF09",
        tipNext: "\u4E0B\u4E00\u5F20\uFF08\u2192\uFF09",
        tipCounterclockwise: "\u5411\u5DE6\u65CB\u8F6C",
        tipClockwise: "\u5411\u53F3\u65CB\u8F6C",
        tipZoomOut: "\u7F29\u5C0F",
        tipZoomIn: "\u653E\u5927",
        tipClose: "\u5173\u95ED\uFF08Esc\uFF09",
        tipOriginalSize: "\u7F29\u653E\u5230\u539F\u59CB\u5C3A\u5BF8"
      }
    };
    var zhCN$1 = zhCN;

    const zhTW = {
      name: "zh-TW",
      global: {
        undo: "\u64A4\u92B7",
        redo: "\u91CD\u505A",
        confirm: "\u78BA\u8A8D"
      },
      Popconfirm: {
        positiveText: "\u78BA\u8A8D",
        negativeText: "\u53D6\u6D88"
      },
      Cascader: {
        placeholder: "\u8ACB\u9078\u64C7",
        loading: "\u8F09\u5165\u4E2D",
        loadingRequiredMessage: label => `\u8F09\u5165\u5168\u90E8 ${label} \u7684\u5B50\u7BC0\u9EDE\u5F8C\u624D\u53EF\u9078\u4E2D`
      },
      Time: {
        dateFormat: "yyyy-MM-dd",
        dateTimeFormat: "yyyy-MM-dd HH:mm:ss"
      },
      DatePicker: {
        yearFormat: "yyyy\u5E74",
        monthFormat: "MMM",
        dayFormat: "eeeeee",
        yearTypeFormat: "yyyy",
        monthTypeFormat: "yyyy-MM",
        dateFormat: "yyyy-MM-dd",
        dateTimeFormat: "yyyy-MM-dd HH:mm:ss",
        quarterFormat: "yyyy-qqq",
        clear: "\u6E05\u9664",
        now: "\u6B64\u523B",
        confirm: "\u78BA\u8A8D",
        selectTime: "\u9078\u64C7\u6642\u9593",
        selectDate: "\u9078\u64C7\u65E5\u671F",
        datePlaceholder: "\u9078\u64C7\u65E5\u671F",
        datetimePlaceholder: "\u9078\u64C7\u65E5\u671F\u6642\u9593",
        monthPlaceholder: "\u9078\u64C7\u6708\u4EFD",
        yearPlaceholder: "\u9078\u64C7\u5E74\u4EFD",
        quarterPlaceholder: "\u9078\u64C7\u5B63\u5EA6",
        startDatePlaceholder: "\u958B\u59CB\u65E5\u671F",
        endDatePlaceholder: "\u7D50\u675F\u65E5\u671F",
        startDatetimePlaceholder: "\u958B\u59CB\u65E5\u671F\u6642\u9593",
        endDatetimePlaceholder: "\u7D50\u675F\u65E5\u671F\u6642\u9593",
        startMonthPlaceholder: "\u958B\u59CB\u6708\u4EFD",
        endMonthPlaceholder: "\u7D50\u675F\u6708\u4EFD",
        monthBeforeYear: false,
        firstDayOfWeek: 0,
        today: "\u4ECA\u5929"
      },
      DataTable: {
        checkTableAll: "\u9078\u64C7\u5168\u90E8\u8868\u683C\u8CC7\u6599",
        uncheckTableAll: "\u53D6\u6D88\u9078\u64C7\u5168\u90E8\u8868\u683C\u8CC7\u6599",
        confirm: "\u78BA\u8A8D",
        clear: "\u91CD\u7F6E"
      },
      LegacyTransfer: {
        sourceTitle: "\u6E90\u9805",
        targetTitle: "\u76EE\u6A19\u9805"
      },
      Transfer: {
        selectAll: "\u5168\u9009",
        unselectAll: "\u53D6\u6D88\u5168\u9009",
        clearAll: "\u6E05\u9664",
        total: num => `\u5171 ${num} \u9805`,
        selected: num => `\u5DF2\u9078 ${num} \u9805`
      },
      Empty: {
        description: "\u7121\u6578\u64DA"
      },
      Select: {
        placeholder: "\u8ACB\u9078\u64C7"
      },
      TimePicker: {
        placeholder: "\u8ACB\u9078\u64C7\u6642\u9593",
        positiveText: "\u78BA\u8A8D",
        negativeText: "\u53D6\u6D88",
        now: "\u6B64\u523B"
      },
      Pagination: {
        goto: "\u8DF3\u81F3",
        selectionSuffix: "\u9801"
      },
      DynamicTags: {
        add: "\u6DFB\u52A0"
      },
      Log: {
        loading: "\u8F09\u5165\u4E2D"
      },
      Input: {
        placeholder: "\u8ACB\u8F38\u5165"
      },
      InputNumber: {
        placeholder: "\u8ACB\u8F38\u5165"
      },
      DynamicInput: {
        create: "\u6DFB\u52A0"
      },
      ThemeEditor: {
        title: "\u4E3B\u984C\u7DE8\u8F2F\u5668",
        clearAllVars: "\u6E05\u9664\u5168\u90E8\u8B8A\u6578",
        clearSearch: "\u6E05\u9664\u641C\u7D22",
        filterCompName: "\u904E\u6FFE\u7D44\u4EF6\u540D",
        filterVarName: "\u904E\u6FFE\u8B8A\u6578\u540D",
        import: "\u5C0E\u5165",
        export: "\u532F\u51FA",
        restore: "\u6062\u5FA9\u9ED8\u8A8D"
      },
      Image: {
        tipPrevious: "\u4E0A\u4E00\u5F20\uFF08\u2190\uFF09",
        tipNext: "\u4E0B\u4E00\u5F20\uFF08\u2192\uFF09",
        tipCounterclockwise: "\u5411\u5DE6\u65CB\u8F6C",
        tipClockwise: "\u5411\u53F3\u65CB\u8F6C",
        tipZoomOut: "\u7F29\u5C0F",
        tipZoomIn: "\u653E\u5927",
        tipClose: "\u5173\u95ED\uFF08Esc\uFF09",
        tipOriginalSize: "\u7F29\u653E\u5230\u539F\u59CB\u5C3A\u5BF8"
      }
    };
    var zhTW$1 = zhTW;

    const enUS$1 = {
      name: "en-US",
      global: {
        undo: "Undo",
        redo: "Redo",
        confirm: "Confirm"
      },
      Popconfirm: {
        positiveText: "Confirm",
        negativeText: "Cancel"
      },
      Cascader: {
        placeholder: "Please Select",
        loading: "Loading",
        loadingRequiredMessage: label => `Please load all ${label}'s descendants before checking it.`
      },
      Time: {
        dateFormat: "yyyy-MM-dd",
        dateTimeFormat: "yyyy-MM-dd HH:mm:ss"
      },
      DatePicker: {
        yearFormat: "yyyy",
        monthFormat: "MMM",
        dayFormat: "eeeeee",
        yearTypeFormat: "yyyy",
        monthTypeFormat: "yyyy-MM",
        dateFormat: "yyyy-MM-dd",
        dateTimeFormat: "yyyy-MM-dd HH:mm:ss",
        quarterFormat: "yyyy-qqq",
        clear: "Clear",
        now: "Now",
        confirm: "Confirm",
        selectTime: "Select Time",
        selectDate: "Select Date",
        datePlaceholder: "Select Date",
        datetimePlaceholder: "Select Date and Time",
        monthPlaceholder: "Select Month",
        yearPlaceholder: "Select Year",
        quarterPlaceholder: "Select Quarter",
        startDatePlaceholder: "Start Date",
        endDatePlaceholder: "End Date",
        startDatetimePlaceholder: "Start Date and Time",
        endDatetimePlaceholder: "End Date and Time",
        startMonthPlaceholder: "Start Month",
        endMonthPlaceholder: "End Month",
        monthBeforeYear: true,
        firstDayOfWeek: 6,
        today: "Today"
      },
      DataTable: {
        checkTableAll: "Select all in the table",
        uncheckTableAll: "Unselect all in the table",
        confirm: "Confirm",
        clear: "Clear"
      },
      LegacyTransfer: {
        sourceTitle: "Source",
        targetTitle: "Target"
      },
      Transfer: {
        selectAll: "Select all",
        unselectAll: "Unselect all",
        clearAll: "Clear",
        total: num => `Total ${num} items`,
        selected: num => `${num} items selected`
      },
      Empty: {
        description: "No Data"
      },
      Select: {
        placeholder: "Please Select"
      },
      TimePicker: {
        placeholder: "Select Time",
        positiveText: "OK",
        negativeText: "Cancel",
        now: "Now"
      },
      Pagination: {
        goto: "Goto",
        selectionSuffix: "page"
      },
      DynamicTags: {
        add: "Add"
      },
      Log: {
        loading: "Loading"
      },
      Input: {
        placeholder: "Please Input"
      },
      InputNumber: {
        placeholder: "Please Input"
      },
      DynamicInput: {
        create: "Create"
      },
      ThemeEditor: {
        title: "Theme Editor",
        clearAllVars: "Clear All Variables",
        clearSearch: "Clear Search",
        filterCompName: "Filter Component Name",
        filterVarName: "Filter Variable Name",
        import: "Import",
        export: "Export",
        restore: "Reset to Default"
      },
      Image: {
        tipPrevious: "Previous picture (\u2190)",
        tipNext: "Next picture (\u2192)",
        tipCounterclockwise: "Counterclockwise",
        tipClockwise: "Clockwise",
        tipZoomOut: "Zoom out",
        tipZoomIn: "Zoom in",
        tipClose: "Close (Esc)",
        tipOriginalSize: "Zoom to original size"
      }
    };
    var enUS$2 = enUS$1;

    const ruRu = {
      name: "ru-RU",
      global: {
        undo: "\u041E\u0442\u043C\u0435\u043D\u0438\u0442\u044C",
        redo: "\u0412\u0435\u0440\u043D\u0443\u0442\u044C",
        confirm: "\u041F\u043E\u0434\u0442\u0432\u0435\u0440\u0434\u0438\u0442\u044C"
      },
      Popconfirm: {
        positiveText: "\u041F\u043E\u0434\u0442\u0432\u0435\u0440\u0434\u0438\u0442\u044C",
        negativeText: "\u041E\u0442\u043C\u0435\u043D\u0430"
      },
      Cascader: {
        placeholder: "\u0412\u044B\u0431\u0440\u0430\u0442\u044C",
        loading: "\u0417\u0430\u0433\u0440\u0443\u0437\u043A\u0430",
        loadingRequiredMessage: label => `\u0417\u0430\u0433\u0440\u0443\u0437\u0438\u0442\u0435 \u0432\u0441\u0435 \u0434\u043E\u0447\u0435\u0440\u043D\u0438\u0435 \u0443\u0437\u043B\u044B ${label} \u043F\u0440\u0435\u0436\u0434\u0435 \u0447\u0435\u043C \u043E\u043D\u0438 \u0441\u0442\u0430\u043D\u0443\u0442 \u043D\u0435\u043E\u0431\u044F\u0437\u0430\u0442\u0435\u043B\u044C\u043D\u044B\u043C\u0438`
      },
      Time: {
        dateFormat: "yyyy-MM-dd",
        dateTimeFormat: "yyyy-MM-dd HH:mm:ss"
      },
      DatePicker: {
        yearFormat: "yyyy",
        monthFormat: "MMM",
        dayFormat: "eeeeee",
        yearTypeFormat: "yyyy",
        monthTypeFormat: "yyyy-MM",
        dateFormat: "yyyy-MM-dd",
        dateTimeFormat: "yyyy-MM-dd HH:mm:ss",
        quarterFormat: "yyyy-qqq",
        clear: "\u041E\u0447\u0438\u0441\u0442\u0438\u0442\u044C",
        now: "\u0421\u0435\u0439\u0447\u0430\u0441",
        confirm: "\u041F\u043E\u0434\u0442\u0432\u0435\u0440\u0434\u0438\u0442\u044C",
        selectTime: "\u0412\u044B\u0431\u0440\u0430\u0442\u044C \u0432\u0440\u0435\u043C\u044F",
        selectDate: "\u0412\u044B\u0431\u0440\u0430\u0442\u044C \u0434\u0430\u0442\u0443",
        datePlaceholder: "\u0412\u044B\u0431\u0440\u0430\u0442\u044C \u0434\u0430\u0442\u0443",
        datetimePlaceholder: "\u0412\u044B\u0431\u0440\u0430\u0442\u044C \u0434\u0430\u0442\u0443 \u0438 \u0432\u0440\u0435\u043C\u044F",
        monthPlaceholder: "\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u043C\u0435\u0441\u044F\u0446",
        yearPlaceholder: "Select Year",
        quarterPlaceholder: "Select Quarter",
        startDatePlaceholder: "\u0414\u0430\u0442\u0430 \u043D\u0430\u0447\u0430\u043B\u0430",
        endDatePlaceholder: "\u0414\u0430\u0442\u0430 \u043E\u043A\u043E\u043D\u0447\u0430\u043D\u0438\u044F",
        startDatetimePlaceholder: "\u0414\u0430\u0442\u0430 \u0438 \u0432\u0440\u0435\u043C\u044F \u043D\u0430\u0447\u0430\u043B\u0430",
        endDatetimePlaceholder: "\u0414\u0430\u0442\u0430 \u0438 \u0432\u0440\u0435\u043C\u044F \u043E\u043A\u043E\u043D\u0447\u0430\u043D\u0438\u044F",
        startMonthPlaceholder: "Start Month",
        endMonthPlaceholder: "End Month",
        monthBeforeYear: true,
        firstDayOfWeek: 0,
        today: "\u0421\u0435\u0433\u043E\u0434\u043D\u044F"
      },
      DataTable: {
        checkTableAll: "\u0412\u044B\u0431\u0440\u0430\u0442\u044C \u0432\u0441\u0435 \u0432 \u0442\u0430\u0431\u043B\u0438\u0446\u0435",
        uncheckTableAll: "\u041E\u0442\u043C\u0435\u043D\u0438\u0442\u044C \u0432\u0441\u0435 \u0432 \u0442\u0430\u0431\u043B\u0438\u0446\u0435",
        confirm: "\u041F\u043E\u0434\u0442\u0432\u0435\u0440\u0434\u0438\u0442\u044C",
        clear: "\u041E\u0447\u0438\u0441\u0442\u0438\u0442\u044C"
      },
      LegacyTransfer: {
        sourceTitle: "\u0418\u0441\u0442\u043E\u0447\u043D\u0438\u043A",
        targetTitle: "\u041D\u0430\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"
      },
      Transfer: {
        selectAll: "Select all",
        unselectAll: "Unselect all",
        clearAll: "Clear",
        total: num => `Total ${num} items`,
        selected: num => `${num} items selected`
      },
      Empty: {
        description: "\u041D\u0435\u0442 \u0434\u0430\u043D\u043D\u044B\u0445"
      },
      Select: {
        placeholder: "\u0412\u044B\u0431\u0440\u0430\u0442\u044C"
      },
      TimePicker: {
        placeholder: "\u0412\u044B\u0431\u0440\u0430\u0442\u044C \u0432\u0440\u0435\u043C\u044F",
        positiveText: "OK",
        negativeText: "\u041E\u0442\u043C\u0435\u043D\u0438\u0442\u044C",
        now: "\u0421\u0435\u0439\u0447\u0430\u0441"
      },
      Pagination: {
        goto: "\u041F\u0435\u0440\u0435\u0439\u0442\u0438",
        selectionSuffix: "\u0441\u0442\u0440\u0430\u043D\u0438\u0446\u0430"
      },
      DynamicTags: {
        add: "\u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C"
      },
      Log: {
        loading: "\u0417\u0430\u0433\u0440\u0443\u0437\u043A\u0430"
      },
      Input: {
        placeholder: "\u0412\u0432\u0435\u0441\u0442\u0438"
      },
      InputNumber: {
        placeholder: "\u0412\u0432\u0435\u0441\u0442\u0438"
      },
      DynamicInput: {
        create: "\u0421\u043E\u0437\u0434\u0430\u0442\u044C"
      },
      ThemeEditor: {
        title: "\u0420\u0435\u0434\u0430\u043A\u0442\u043E\u0440 \u0442\u0435\u043C\u044B",
        clearAllVars: "\u041E\u0447\u0438\u0441\u0442\u0438\u0442\u044C \u0432\u0441\u0435",
        clearSearch: "\u041E\u0447\u0438\u0441\u0442\u0438\u0442\u044C \u043F\u043E\u0438\u0441\u043A",
        filterCompName: "\u0424\u0438\u043B\u044C\u0442\u0440\u043E\u0432\u0430\u0442\u044C \u043F\u043E \u0438\u043C\u0435\u043D\u0438 \u043A\u043E\u043C\u043F\u043E\u043D\u0435\u043D\u0442\u0430",
        filterVarName: "\u0424\u0438\u043B\u044C\u0442\u0440\u043E\u0432\u0430\u0442\u044C \u0438\u043C\u0435\u043D\u0430 \u043F\u0435\u0440\u0435\u043C\u0435\u043D\u043D\u044B\u0445",
        import: "\u0418\u043C\u043F\u043E\u0440\u0442",
        export: "\u042D\u043A\u0441\u043F\u043E\u0440\u0442",
        restore: "\u0421\u0431\u0440\u043E\u0441\u0438\u0442\u044C"
      },
      Image: {
        tipPrevious: "Previous picture (\u2190)",
        tipNext: "Next picture (\u2192)",
        tipCounterclockwise: "Counterclockwise",
        tipClockwise: "Clockwise",
        tipZoomOut: "Zoom out",
        tipZoomIn: "Zoom in",
        tipClose: "Close (Esc)",
        tipOriginalSize: "Zoom to original size"
      }
    };
    var ruRu$1 = ruRu;

    const ukUA = {
      name: "uk-UA",
      global: {
        undo: "\u0412\u0456\u0434\u043C\u0456\u043D\u0438\u0442\u0438",
        redo: "\u041F\u043E\u0432\u0442\u043E\u0440\u0438\u0442\u0438",
        confirm: "\u041F\u0456\u0434\u0442\u0432\u0435\u0440\u0434\u0438\u0442\u0438"
      },
      Popconfirm: {
        positiveText: "\u041F\u0456\u0434\u0442\u0432\u0435\u0440\u0434\u0438\u0442\u0438",
        negativeText: "\u0421\u043A\u0430\u0441\u0443\u0432\u0430\u0442\u0438"
      },
      Cascader: {
        placeholder: "\u041E\u0431\u0440\u0430\u0442\u0438",
        loading: "\u0417\u0430\u0432\u0430\u043D\u0442\u0430\u0436\u0435\u043D\u043D\u044F",
        loadingRequiredMessage: label => `\u0417\u0430\u0432\u0430\u043D\u0442\u0430\u0436\u0442\u0435 \u0432\u0441\u0456 \u0434\u043E\u0447\u0456\u0440\u043D\u0456 \u0432\u0443\u0437\u043B\u0438 ${label} \u043F\u0435\u0440\u0435\u0434 \u043F\u0435\u0440\u0435\u0432\u0456\u0440\u043A\u043E\u044E`
      },
      Time: {
        dateFormat: "yyyy-MM-dd",
        dateTimeFormat: "yyyy-MM-dd HH:mm:ss"
      },
      DatePicker: {
        yearFormat: "yyyy",
        monthFormat: "MMM",
        dayFormat: "eeeeee",
        yearTypeFormat: "yyyy",
        monthTypeFormat: "yyyy-MM",
        dateFormat: "yyyy-MM-dd",
        dateTimeFormat: "yyyy-MM-dd HH:mm:ss",
        quarterFormat: "yyyy-qqq",
        clear: "\u0421\u0442\u0435\u0440\u0442\u0438",
        now: "\u0417\u0430\u0440\u0430\u0437",
        confirm: "\u041F\u0456\u0434\u0442\u0432\u0435\u0440\u0434\u0438\u0442\u0438",
        selectTime: "\u041E\u0431\u0440\u0430\u0442\u0438 \u0447\u0430\u0441",
        selectDate: "\u041E\u0431\u0440\u0430\u0442\u0438 \u0434\u0430\u0442\u0443",
        datePlaceholder: "\u041E\u0431\u0440\u0430\u0442\u0438 \u0434\u0430\u0442\u0443",
        datetimePlaceholder: "\u041E\u0431\u0440\u0430\u0442\u0438 \u0434\u0430\u0442\u0443 \u0456 \u0447\u0430\u0441",
        monthPlaceholder: "\u041E\u0431\u0435\u0440\u0456\u0442\u044C \u043C\u0456\u0441\u044F\u0446\u044C",
        yearPlaceholder: "\u041E\u0431\u0435\u0440\u0456\u0442\u044C \u0440\u0456\u043A",
        quarterPlaceholder: "\u041E\u0431\u0435\u0440\u0456\u0442\u044C \u043A\u0432\u0430\u0440\u0442\u0430\u043B",
        startDatePlaceholder: "\u0414\u0430\u0442\u0430 \u043F\u043E\u0447\u0430\u0442\u043A\u0443",
        endDatePlaceholder: "\u0414\u0430\u0442\u0430 \u0437\u0430\u0432\u0435\u0440\u0448\u0435\u043D\u043D\u044F",
        startDatetimePlaceholder: "\u0414\u0430\u0442\u0430 \u0456 \u0447\u0430\u0441 \u043F\u043E\u0447\u0430\u0442\u043A\u0443",
        endDatetimePlaceholder: "\u0414\u0430\u0442\u0430 \u0456 \u0447\u0430\u0441 \u0437\u0430\u0432\u0435\u0440\u0448\u0435\u043D\u043D\u044F",
        startMonthPlaceholder: "\u041F\u0435\u0440\u0448\u0438\u0439 \u043C\u0456\u0441\u044F\u0446\u044C",
        endMonthPlaceholder: "\u041E\u0441\u0442\u0430\u043D\u043D\u0456\u0439 \u043C\u0456\u0441\u044F\u0446\u044C",
        monthBeforeYear: true,
        firstDayOfWeek: 0,
        today: "\u0421\u044C\u043E\u0433\u043E\u0434\u043D\u0456"
      },
      DataTable: {
        checkTableAll: "\u041E\u0431\u0440\u0430\u0442\u0438 \u0432\u0441\u0435 \u0432 \u0442\u0430\u0431\u043B\u0438\u0446\u0456",
        uncheckTableAll: "\u0421\u043A\u0430\u0441\u0443\u0432\u0430\u0442\u0438 \u0432\u0438\u0431\u0456\u0440 \u0443\u0441\u044C\u043E\u0433\u043E \u0432 \u0442\u0430\u0431\u043B\u0438\u0446\u0456",
        confirm: "\u041F\u0456\u0434\u0442\u0432\u0435\u0440\u0434\u0438\u0442\u0438",
        clear: "\u0421\u0442\u0435\u0440\u0442\u0438"
      },
      LegacyTransfer: {
        sourceTitle: "\u0414\u0436\u0435\u0440\u0435\u043B\u043E",
        targetTitle: "\u0426\u0456\u043B\u044C"
      },
      Transfer: {
        selectAll: "Select all",
        unselectAll: "Unselect all",
        clearAll: "Clear",
        total: num => `Total ${num} items`,
        selected: num => `${num} items selected`
      },
      Empty: {
        description: "\u041D\u0435\u043C\u0430\u0454 \u0434\u0430\u043D\u0438\u0445"
      },
      Select: {
        placeholder: "\u041E\u0431\u0440\u0430\u0442\u0438"
      },
      TimePicker: {
        placeholder: "\u041E\u0431\u0440\u0430\u0442\u0438 \u0447\u0430\u0441",
        positiveText: "OK",
        negativeText: "\u0421\u043A\u0430\u0441\u0443\u0432\u0430\u0442\u0438",
        now: "\u0417\u0430\u0440\u0430\u0437"
      },
      Pagination: {
        goto: "\u041F\u0435\u0440\u0435\u0439\u0442\u0438",
        selectionSuffix: "\u0441\u0442\u043E\u0440\u0456\u043D\u043A\u0430"
      },
      DynamicTags: {
        add: "\u0414\u043E\u0434\u0430\u0442\u0438"
      },
      Log: {
        loading: "\u0417\u0430\u0432\u0430\u043D\u0442\u0430\u0436\u0435\u043D\u043D\u044F"
      },
      Input: {
        placeholder: "\u0412\u0432\u0435\u0441\u0442\u0438"
      },
      InputNumber: {
        placeholder: "\u0412\u0432\u0435\u0441\u0442\u0438"
      },
      DynamicInput: {
        create: "\u0421\u0442\u0432\u043E\u0440\u0438\u0442\u0438"
      },
      ThemeEditor: {
        title: "\u0420\u0435\u0434\u0430\u043A\u0442\u043E\u0440 \u0442\u0435\u043C\u0438",
        clearAllVars: "\u0421\u0442\u0435\u0440\u0442\u0438 \u0432\u0441\u0435",
        clearSearch: "\u041E\u0447\u0438\u0441\u0442\u0438\u0442\u0438 \u043F\u043E\u0448\u0443\u043A",
        filterCompName: "\u0424\u0456\u043B\u044C\u0442\u0440\u0443\u0432\u0430\u0442\u0438 \u0437\u0430 \u0456\u043C\u0435\u043D\u0435\u043C \u043A\u043E\u043C\u043F\u043E\u043D\u0435\u043D\u0442\u0430",
        filterVarName: "\u0424\u0456\u043B\u044C\u0442\u0440\u0443\u0432\u0430\u0442\u0438 \u0456\u043C\u0435\u043D\u0430 \u0437\u043C\u0456\u043D\u043D\u0438\u0445",
        import: "\u0406\u043C\u043F\u043E\u0440\u0442",
        export: "\u0415\u043A\u0441\u043F\u043E\u0440\u0442",
        restore: "\u0421\u043A\u0438\u043D\u0443\u0442\u0438"
      },
      Image: {
        tipPrevious: "\u041F\u043E\u043F\u0435\u0440\u0435\u0434\u043D\u0454 \u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u043D\u044F (\u2190)",
        tipNext: "\u041D\u0430\u0441\u0442\u0443\u043F\u043D\u0435 \u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u043D\u044F (\u2192)",
        tipCounterclockwise: "\u041F\u0440\u043E\u0442\u0438 \u0433\u043E\u0434\u0438\u043D\u043D\u0438\u043A\u043E\u0432\u043E\u0457 \u0441\u0442\u0440\u0456\u043B\u043A\u0438",
        tipClockwise: "\u0417\u0430 \u0433\u043E\u0434\u0438\u043D\u043D\u0438\u043A\u043E\u0432\u043E\u044E \u0441\u0442\u0440\u0456\u043B\u043A\u043E\u044E",
        tipZoomOut: "\u0412\u0456\u0434\u0434\u0430\u043B\u0438\u0442\u0438",
        tipZoomIn: "\u041D\u0430\u0431\u043B\u0438\u0437\u0438\u0442\u0438",
        tipClose: "\u0417\u0430\u043A\u0440\u0438\u0442\u0438 (Esc)",
        tipOriginalSize: "\u041C\u0430\u0441\u0448\u0442\u0430\u0431\u0443\u0432\u0430\u0442\u0438 \u0434\u043E \u043E\u0440\u0438\u0433\u0456\u043D\u0430\u043B\u044C\u043D\u043E\u0433\u043E \u0440\u043E\u0437\u043C\u0456\u0440\u0443"
      }
    };
    var ukUA$1 = ukUA;

    const jaJP = {
      name: "ja-JP",
      global: {
        undo: "\u5143\u306B\u623B\u3059",
        redo: "\u3084\u308A\u76F4\u3059",
        confirm: "OK"
      },
      Popconfirm: {
        positiveText: "OK",
        negativeText: "\u30AD\u30E3\u30F3\u30BB\u30EB"
      },
      Cascader: {
        placeholder: "\u9078\u629E\u3057\u3066\u304F\u3060\u3055\u3044",
        loading: "\u30ED\u30FC\u30C9\u4E2D",
        loadingRequiredMessage: label => `\u3059\u3079\u3066\u306E ${label} \u30B5\u30D6\u30CE\u30FC\u30C9\u3092\u30ED\u30FC\u30C9\u3057\u3066\u304B\u3089\u9078\u629E\u3067\u304D\u307E\u3059\u3002`
      },
      Time: {
        dateFormat: "yyyy-MM-dd",
        dateTimeFormat: "yyyy-MM-dd HH:mm:ss"
      },
      DatePicker: {
        yearFormat: "yyyy\u5E74",
        monthFormat: "MMM",
        dayFormat: "eeeeee",
        yearTypeFormat: "yyyy",
        monthTypeFormat: "yyyy-MM",
        dateFormat: "yyyy-MM-dd",
        dateTimeFormat: "yyyy-MM-dd HH:mm:ss",
        quarterFormat: "yyyy-qqq",
        clear: "\u30AF\u30EA\u30A2",
        now: "\u73FE\u5728",
        confirm: "OK",
        selectTime: "\u6642\u9593\u3092\u9078\u629E",
        selectDate: "\u65E5\u4ED8\u3092\u9078\u629E",
        datePlaceholder: "\u65E5\u4ED8\u3092\u9078\u629E",
        datetimePlaceholder: "\u9078\u629E",
        monthPlaceholder: "\u6708\u3092\u9078\u629E",
        yearPlaceholder: "\u5E74\u3092\u9078\u629E",
        quarterPlaceholder: "\u56DB\u534A\u671F\u3092\u9078\u629E",
        startDatePlaceholder: "\u958B\u59CB\u65E5",
        endDatePlaceholder: "\u7D42\u4E86\u65E5",
        startDatetimePlaceholder: "\u958B\u59CB\u6642\u9593",
        endDatetimePlaceholder: "\u7D42\u4E86\u6642\u9593",
        startMonthPlaceholder: "Start Month",
        endMonthPlaceholder: "End Month",
        monthBeforeYear: false,
        firstDayOfWeek: 0,
        today: "\u4ECA\u65E5"
      },
      DataTable: {
        checkTableAll: "\u5168\u9078\u629E",
        uncheckTableAll: "\u5168\u9078\u629E\u53D6\u6D88",
        confirm: "OK",
        clear: "\u30EA\u30BB\u30C3\u30C8"
      },
      LegacyTransfer: {
        sourceTitle: "\u5143",
        targetTitle: "\u5148"
      },
      Transfer: {
        selectAll: "Select all",
        unselectAll: "Unselect all",
        clearAll: "Clear",
        total: num => `Total ${num} items`,
        selected: num => `${num} items selected`
      },
      Empty: {
        description: "\u30C7\u30FC\u30BF\u306A\u3057"
      },
      Select: {
        placeholder: "\u9078\u629E\u3057\u3066\u304F\u3060\u3055\u3044"
      },
      TimePicker: {
        placeholder: "\u9078\u629E\u3057\u3066\u304F\u3060\u3055\u3044",
        positiveText: "OK",
        negativeText: "\u30AD\u30E3\u30F3\u30BB\u30EB",
        now: "\u73FE\u5728"
      },
      Pagination: {
        goto: "\u30DA\u30FC\u30B8\u30B8\u30E3\u30F3\u30D7",
        selectionSuffix: "\u30DA\u30FC\u30B8"
      },
      DynamicTags: {
        add: "\u8FFD\u52A0"
      },
      Log: {
        loading: "\u30ED\u30FC\u30C9\u4E2D"
      },
      Input: {
        placeholder: "\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044"
      },
      InputNumber: {
        placeholder: "\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044"
      },
      DynamicInput: {
        create: "\u8FFD\u52A0"
      },
      ThemeEditor: {
        title: "\u30C6\u30FC\u30DE\u30A8\u30C7\u30A3\u30BF",
        clearAllVars: "\u5168\u4EF6\u5909\u6570\u30AF\u30EA\u30A2",
        clearSearch: "\u691C\u7D22\u30AF\u30EA\u30A2",
        filterCompName: "\u30B3\u30F3\u30DD\u30CD\u30F3\u30C8\u540D\u3092\u30D5\u30A3\u30EB\u30BF",
        filterVarName: "\u5909\u6570\u3092\u30D5\u30A3\u30EB\u30BF",
        import: "\u30A4\u30F3\u30DD\u30FC\u30C8",
        export: "\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8",
        restore: "\u30C7\u30D5\u30A9\u30EB\u30C8"
      },
      Image: {
        tipPrevious: "\u524D\u306E\u753B\u50CF (\u2190)",
        tipNext: "\u6B21\u306E\u753B\u50CF (\u2192)",
        tipCounterclockwise: "\u5DE6\u306B\u56DE\u8EE2",
        tipClockwise: "\u53F3\u306B\u56DE\u8EE2",
        tipZoomOut: "\u7E2E\u5C0F",
        tipZoomIn: "\u62E1\u5927",
        tipClose: "\u9589\u3058\u308B (Esc)",
        tipOriginalSize: "Zoom to original size"
      }
    };
    var jaJP$1 = jaJP;

    const koKR = {
      name: "ko-KR",
      global: {
        undo: "\uC2E4\uD589 \uCDE8\uC18C",
        redo: "\uB2E4\uC2DC \uC2E4\uD589",
        confirm: "\uD655\uC778"
      },
      Popconfirm: {
        positiveText: "\uD655\uC778",
        negativeText: "\uCDE8\uC18C"
      },
      Cascader: {
        placeholder: "\uC120\uD0DD\uD574 \uC8FC\uC138\uC694",
        loading: "\uBD88\uB7EC\uC624\uB294 \uC911",
        loadingRequiredMessage: label => `${label}\uC758 \uBAA8\uB4E0 \uD558\uC704 \uD56D\uBAA9\uC744 \uBD88\uB7EC\uC628 \uB4A4\uC5D0 \uC120\uD0DD\uD560 \uC218 \uC788\uC2B5\uB2C8\uB2E4.`
      },
      Time: {
        dateFormat: "yyyy-MM-dd",
        dateTimeFormat: "yyyy-MM-dd HH:mm:ss"
      },
      DatePicker: {
        yearFormat: "yyyy\uB144",
        monthFormat: "MMM",
        dayFormat: "eeeeee",
        yearTypeFormat: "yyyy",
        monthTypeFormat: "yyyy-MM",
        dateFormat: "yyyy-MM-dd",
        dateTimeFormat: "yyyy-MM-dd HH:mm:ss",
        quarterFormat: "yyyy-qqq",
        clear: "\uC9C0\uC6B0\uAE30",
        now: "\uD604\uC7AC",
        confirm: "\uD655\uC778",
        selectTime: "\uC2DC\uAC04 \uC120\uD0DD",
        selectDate: "\uB0A0\uC9DC \uC120\uD0DD",
        datePlaceholder: "\uB0A0\uC9DC \uC120\uD0DD",
        datetimePlaceholder: "\uB0A0\uC9DC \uBC0F \uC2DC\uAC04 \uC120\uD0DD",
        monthPlaceholder: "\uC6D4 \uC120\uD0DD",
        yearPlaceholder: "\uB144 \uC120\uD0DD",
        quarterPlaceholder: "\uBD84\uAE30 \uC120\uD0DD",
        startDatePlaceholder: "\uC2DC\uC791 \uB0A0\uC9DC",
        endDatePlaceholder: "\uC885\uB8CC \uB0A0\uC9DC",
        startDatetimePlaceholder: "\uC2DC\uC791 \uB0A0\uC9DC \uBC0F \uC2DC\uAC04",
        endDatetimePlaceholder: "\uC885\uB8CC \uB0A0\uC9DC \uBC0F \uC2DC\uAC04",
        startMonthPlaceholder: "Start Month",
        endMonthPlaceholder: "End Month",
        monthBeforeYear: false,
        firstDayOfWeek: 6,
        today: "\uC624\uB298"
      },
      DataTable: {
        checkTableAll: "\uBAA8\uB450 \uC120\uD0DD",
        uncheckTableAll: "\uBAA8\uB450 \uC120\uD0DD \uD574\uC81C",
        confirm: "\uD655\uC778",
        clear: "\uC9C0\uC6B0\uAE30"
      },
      LegacyTransfer: {
        sourceTitle: "\uC6D0\uBCF8",
        targetTitle: "\uD0C0\uAE43"
      },
      Transfer: {
        selectAll: "Select all",
        unselectAll: "Unselect all",
        clearAll: "Clear",
        total: num => `Total ${num} items`,
        selected: num => `${num} items selected`
      },
      Empty: {
        description: "\uB370\uC774\uD130 \uC5C6\uC74C"
      },
      Select: {
        placeholder: "\uC120\uD0DD\uD574 \uC8FC\uC138\uC694"
      },
      TimePicker: {
        placeholder: "\uC2DC\uAC04 \uC120\uD0DD",
        positiveText: "\uD655\uC778",
        negativeText: "\uCDE8\uC18C",
        now: "Now"
      },
      Pagination: {
        goto: "\uC774\uB3D9",
        selectionSuffix: "\uD398\uC774\uC9C0"
      },
      DynamicTags: {
        add: "\uCD94\uAC00"
      },
      Log: {
        loading: "\uBD88\uB7EC\uC624\uB294 \uC911"
      },
      Input: {
        placeholder: "\uC785\uB825\uD574 \uC8FC\uC138\uC694"
      },
      InputNumber: {
        placeholder: "\uC785\uB825\uD574 \uC8FC\uC138\uC694"
      },
      DynamicInput: {
        create: "\uCD94\uAC00"
      },
      ThemeEditor: {
        title: "\uD14C\uB9C8 \uD3B8\uC9D1\uAE30",
        clearAllVars: "\uBAA8\uB4E0 \uBCC0\uC218 \uC9C0\uC6B0\uAE30",
        clearSearch: "\uAC80\uC0C9 \uC9C0\uC6B0\uAE30",
        filterCompName: "\uAD6C\uC131 \uC694\uC18C \uC774\uB984 \uD544\uD130",
        filterVarName: "\uBCC0\uC218 \uC774\uB984 \uD544\uD130",
        import: "\uAC00\uC838\uC624\uAE30",
        export: "\uB0B4\uBCF4\uB0B4\uAE30",
        restore: "\uAE30\uBCF8\uC73C\uB85C \uC7AC\uC124\uC815"
      },
      Image: {
        tipPrevious: "\uC774\uC804 (\u2190)",
        tipNext: "\uB2E4\uC74C (\u2192)",
        tipCounterclockwise: "\uC2DC\uACC4 \uBC18\uB300 \uBC29\uD5A5\uC73C\uB85C \uD68C\uC804",
        tipClockwise: "\uC2DC\uACC4 \uBC29\uD5A5\uC73C\uB85C \uD68C\uC804",
        tipZoomOut: "\uCD95\uC18C",
        tipZoomIn: "\uD655\uB300",
        tipClose: "\uB2EB\uAE30 (Esc)",
        tipOriginalSize: "Zoom to original size"
      }
    };
    var koKR$1 = koKR;

    const idID = {
      name: "id-ID",
      global: {
        undo: "Membatalkan",
        redo: "Mem-perbarui",
        confirm: "Setuju"
      },
      Popconfirm: {
        positiveText: "Setuju",
        negativeText: "Batalkan"
      },
      Cascader: {
        placeholder: "Mohon Pilih",
        loading: "Memuat",
        loadingRequiredMessage: label => `Mohon muat semua ${label}'s turunan sebelum memeriksa.`
      },
      Time: {
        dateFormat: "dd-MM-yyyy",
        dateTimeFormat: "dd-MM-yyyy HH:mm:ss"
      },
      DatePicker: {
        yearFormat: "yyyy",
        monthFormat: "MMM",
        dayFormat: "eeeeee",
        yearTypeFormat: "yyyy",
        monthTypeFormat: "MM-yyyy",
        dateFormat: "dd-MM-yyyy",
        dateTimeFormat: "dd-MM-yyyy HH:mm:ss",
        quarterFormat: "yyyy-qqq",
        clear: "Bersihkan",
        now: "Sekarang",
        confirm: "Setuju",
        selectTime: "Pilih Waktu",
        selectDate: "Pilih Tanggal",
        datePlaceholder: "Pilih Tanggal",
        datetimePlaceholder: "Pilih Tanggal dan Waktu",
        monthPlaceholder: "Pilih Bulan",
        yearPlaceholder: "Select Year",
        quarterPlaceholder: "Select Quarter",
        startDatePlaceholder: "Tanggal Mulai",
        endDatePlaceholder: "Tanggal Selesai",
        startDatetimePlaceholder: "Tanggal dan Waktu Mulai",
        endDatetimePlaceholder: "Tanggal dan Waktu Selesai",
        startMonthPlaceholder: "Start Month",
        endMonthPlaceholder: "End Month",
        monthBeforeYear: true,
        firstDayOfWeek: 6,
        today: "Hari ini"
      },
      DataTable: {
        checkTableAll: "Pilih semua pada tabel",
        uncheckTableAll: "Batalkan pilihan semua",
        confirm: "Setuju",
        clear: "Bersihkan"
      },
      LegacyTransfer: {
        sourceTitle: "Sumber",
        targetTitle: "Tujuan"
      },
      Transfer: {
        selectAll: "Select all",
        unselectAll: "Unselect all",
        clearAll: "Clear",
        total: num => `Total ${num} items`,
        selected: num => `${num} items selected`
      },
      Empty: {
        description: "Tidak ada data"
      },
      Select: {
        placeholder: "Mohon Pilih"
      },
      TimePicker: {
        placeholder: "Pilih Waktu",
        positiveText: "OK",
        negativeText: "Batalkan",
        now: "Sekarang"
      },
      Pagination: {
        goto: "Ke",
        selectionSuffix: "halaman"
      },
      DynamicTags: {
        add: "Tambah"
      },
      Log: {
        loading: "Memuat"
      },
      Input: {
        placeholder: "Mohon isi"
      },
      InputNumber: {
        placeholder: "Mohon isi"
      },
      DynamicInput: {
        create: "Buat baru"
      },
      ThemeEditor: {
        title: "Tema editor",
        clearAllVars: "Bersihkan semua variabel",
        clearSearch: "Bersihkan pencarian",
        filterCompName: "Saring nama komponen",
        filterVarName: "Saring nama variabel",
        import: "Impor",
        export: "Ekspor",
        restore: "Setel ulang ke awal"
      },
      Image: {
        tipPrevious: "Previous picture (\u2190)",
        tipNext: "Next picture (\u2192)",
        tipCounterclockwise: "Counterclockwise",
        tipClockwise: "Clockwise",
        tipZoomOut: "Zoom out",
        tipZoomIn: "Zoom in",
        tipClose: "Close (Esc)",
        tipOriginalSize: "Zoom to original size"
      }
    };
    var idID$1 = idID;

    const deDE = {
      name: "de-DE",
      global: {
        undo: "R\xFCckg\xE4ngig",
        redo: "Wiederholen",
        confirm: "Best\xE4tigen"
      },
      Popconfirm: {
        positiveText: "Best\xE4tigen",
        negativeText: "Abbrechen"
      },
      Cascader: {
        placeholder: "Bitte ausw\xE4hlen",
        loading: "Wird geladen",
        loadingRequiredMessage: label => `Bitte laden Sie alle Unterpunkte von ${label}, bevor Sie es ausw\xE4hlen.`
      },
      Time: {
        dateFormat: "dd.MM.yyyy",
        dateTimeFormat: "dd.MM.yyyy HH:mm:ss"
      },
      DatePicker: {
        yearFormat: "yyyy",
        monthFormat: "MMM",
        dayFormat: "eeeeee",
        yearTypeFormat: "yyyy",
        monthTypeFormat: "MM-yyyy",
        dateFormat: "dd.MM.yyyy",
        dateTimeFormat: "dd.MM.yyyy HH:mm:ss",
        quarterFormat: "yyyy-qqq",
        clear: "L\xF6schen",
        now: "Jetzt",
        confirm: "Best\xE4tigen",
        selectTime: "Uhrzeit ausw\xE4hlen",
        selectDate: "Datum ausw\xE4hlen",
        datePlaceholder: "Datum ausw\xE4hlen",
        datetimePlaceholder: "Datum und Uhrzeit ausw\xE4hlen",
        monthPlaceholder: "Monat ausw\xE4hlen",
        yearPlaceholder: "Jahr ausw\xE4hlen",
        quarterPlaceholder: "Quartal ausw\xE4hlen",
        startDatePlaceholder: "Anfangsdatum",
        endDatePlaceholder: "Enddatum",
        startDatetimePlaceholder: "Anfangsdatum und Uhrzeit",
        endDatetimePlaceholder: "Enddatum und Uhrzeit",
        startMonthPlaceholder: "Anfangsmonat",
        endMonthPlaceholder: "Endmonat",
        monthBeforeYear: true,
        firstDayOfWeek: 0,
        today: "Heute"
      },
      DataTable: {
        checkTableAll: "Alles ausw\xE4hlen",
        uncheckTableAll: "Auswahl aufheben",
        confirm: "Best\xE4tigen",
        clear: "L\xF6schen"
      },
      LegacyTransfer: {
        sourceTitle: "Quelle",
        targetTitle: "Ziel"
      },
      Transfer: {
        selectAll: "Alle ausw\xE4hlen",
        unselectAll: "Alle abw\xE4hlen",
        clearAll: "Leeren",
        total: num => `Insgesamt ${num} Eintr\xE4ge`,
        selected: num => `${num} Eintr\xE4ge ausgew\xE4hlt`
      },
      Empty: {
        description: "Keine Daten"
      },
      Select: {
        placeholder: "Bitte ausw\xE4hlen"
      },
      TimePicker: {
        placeholder: "Uhrzeit ausw\xE4hlen",
        positiveText: "OK",
        negativeText: "Abbrechen",
        now: "Jetzt"
      },
      Pagination: {
        goto: "Gehe zu",
        selectionSuffix: "Seite"
      },
      DynamicTags: {
        add: "Hinzuf\xFCgen"
      },
      Log: {
        loading: "Wird geladen"
      },
      Input: {
        placeholder: "Bitte ausf\xFCllen"
      },
      InputNumber: {
        placeholder: "Bitte ausf\xFCllen"
      },
      DynamicInput: {
        create: "Erstellen"
      },
      ThemeEditor: {
        title: "Theme Editor",
        clearAllVars: "Alle Variablen l\xF6schen",
        clearSearch: "Suche l\xF6schen",
        filterCompName: "Filter Komponentenname",
        filterVarName: "Filter Variablenname",
        import: "Importieren",
        export: "Exportieren",
        restore: "Auf Standard zur\xFCcksetzen"
      },
      Image: {
        tipPrevious: "Vorheriges Bild (\u2190)",
        tipNext: "N\xE4chstes Bild (\u2192)",
        tipCounterclockwise: "Gegen Uhrzeigersinn",
        tipClockwise: "Uhrzeigersinn",
        tipZoomOut: "Rauszoomen",
        tipZoomIn: "Reinzoomen",
        tipClose: "Schlie\xDFen (Esc)",
        tipOriginalSize: "Zoom zur\xFCcksetzen"
      }
    };
    var deDE$1 = deDE;

    const nbNO = {
      name: "nb-NO",
      global: {
        undo: "Angre",
        redo: "Utf\xF8r likevel",
        confirm: "Bekreft"
      },
      Popconfirm: {
        positiveText: "Bekreft",
        negativeText: "Avbryt"
      },
      Cascader: {
        placeholder: "Vennligst velg",
        loading: "Laster",
        loadingRequiredMessage: label => `Vennligst last alle underpunkter av ${label} f\xF8r du velger oppf\xF8ringen.`
      },
      Time: {
        dateFormat: "dd.MM.yyyy",
        dateTimeFormat: "dd.MM.yyyy HH:mm:ss"
      },
      DatePicker: {
        yearFormat: "yyyy",
        monthFormat: "MMM",
        dayFormat: "eeeeee",
        yearTypeFormat: "yyyy",
        monthTypeFormat: "MM.yyyy",
        dateFormat: "dd.MM.yyyy",
        dateTimeFormat: "dd.MM.yyyy HH:mm:ss",
        quarterFormat: "yyyy-qqq",
        clear: "T\xF8m",
        now: "N\xE5",
        confirm: "Bekreft",
        selectTime: "Velg tid",
        selectDate: "Velg dato",
        datePlaceholder: "Velg dato",
        datetimePlaceholder: "Velg dato og tid",
        monthPlaceholder: "Velg m\xE5ned",
        yearPlaceholder: "Select Year",
        quarterPlaceholder: "Select Quarter",
        startDatePlaceholder: "Startdato",
        endDatePlaceholder: "Sluttdato",
        startDatetimePlaceholder: "Startdato og -tid",
        endDatetimePlaceholder: "Sluttdato og -tid",
        startMonthPlaceholder: "Start Month",
        endMonthPlaceholder: "End Month",
        monthBeforeYear: true,
        firstDayOfWeek: 0,
        today: "I dag"
      },
      DataTable: {
        checkTableAll: "Velg alt",
        uncheckTableAll: "Velg ingenting",
        confirm: "Bekreft",
        clear: "T\xF8m"
      },
      LegacyTransfer: {
        sourceTitle: "Kilde",
        targetTitle: "M\xE5l"
      },
      Transfer: {
        selectAll: "Select all",
        unselectAll: "Unselect all",
        clearAll: "Clear",
        total: num => `Total ${num} items`,
        selected: num => `${num} items selected`
      },
      Empty: {
        description: "Ingen data"
      },
      Select: {
        placeholder: "Vennligst velg"
      },
      TimePicker: {
        placeholder: "Velg tid",
        positiveText: "OK",
        negativeText: "Avbryt",
        now: "N\xE5"
      },
      Pagination: {
        goto: "G\xE5 til",
        selectionSuffix: "side"
      },
      DynamicTags: {
        add: "Legg til"
      },
      Log: {
        loading: "Laster"
      },
      Input: {
        placeholder: "Vennligst fyll ut"
      },
      InputNumber: {
        placeholder: "Vennligst fyll ut"
      },
      DynamicInput: {
        create: "Opprett"
      },
      ThemeEditor: {
        title: "Temaredigerer",
        clearAllVars: "Nullstill alle variabler",
        clearSearch: "T\xF8m s\xF8k",
        filterCompName: "Filtrer etter komponentnavn",
        filterVarName: "Filtrer etter variabelnavn",
        import: "Importer",
        export: "Eksporter",
        restore: "Nullstill til standardvalg"
      },
      Image: {
        tipPrevious: "Previous picture (\u2190)",
        tipNext: "Next picture (\u2192)",
        tipCounterclockwise: "Counterclockwise",
        tipClockwise: "Clockwise",
        tipZoomOut: "Zoom out",
        tipZoomIn: "Zoom in",
        tipClose: "Close (Esc)",
        tipOriginalSize: "Zoom to original size"
      }
    };
    var nbNO$1 = nbNO;

    const nlNL = {
      name: "nl-NL",
      global: {
        undo: "Ongedaan Maken",
        redo: "Opnieuw Doen",
        confirm: "Bevestig"
      },
      Popconfirm: {
        positiveText: "Bevestig",
        negativeText: "Annuleer"
      },
      Cascader: {
        placeholder: "Selecteer a.u.b.",
        loading: "Laden",
        loadingRequiredMessage: label => `Laad alle afstammelingen van ${label} alvorens het te selecteren.`
      },
      Time: {
        dateFormat: "dd/MM/yyyy",
        dateTimeFormat: "dd/MM/yyyy HH:mm:ss"
      },
      DatePicker: {
        yearFormat: "yyyy",
        monthFormat: "MMM",
        dayFormat: "eeeeee",
        yearTypeFormat: "yyyy",
        monthTypeFormat: "MM/yyyy",
        dateFormat: "dd/MM/yyyy",
        dateTimeFormat: "dd/MM/yyyy HH:mm:ss",
        quarterFormat: "qqq yyyy",
        clear: "Wis",
        now: "Nu",
        confirm: "Bevestig",
        selectTime: "Selecteer Uur",
        selectDate: "Selecteer Datum",
        datePlaceholder: "Selecteer Datum",
        datetimePlaceholder: "Selecteer Dag en Uur",
        monthPlaceholder: "Selecteer Maand",
        yearPlaceholder: "Selecteer Jaar",
        quarterPlaceholder: "Selecteer Kwartaal",
        startDatePlaceholder: "Begindatum",
        endDatePlaceholder: "Einddatum",
        startDatetimePlaceholder: "Begindatum en Uur",
        endDatetimePlaceholder: "Einddatum en Uur",
        startMonthPlaceholder: "Begin Maand",
        endMonthPlaceholder: "Eind Maand",
        monthBeforeYear: true,
        firstDayOfWeek: 0,
        today: "Vandaag"
      },
      DataTable: {
        checkTableAll: "Selecteer alles in de tabel",
        uncheckTableAll: "Alles in de tabel deselecteren",
        confirm: "Bevestig",
        clear: "Wis"
      },
      LegacyTransfer: {
        sourceTitle: "Bron",
        targetTitle: "Doel"
      },
      Transfer: {
        selectAll: "Select all",
        unselectAll: "Unselect all",
        clearAll: "Clear",
        total: num => `Total ${num} items`,
        selected: num => `${num} items selected`
      },
      Empty: {
        description: "Geen Data"
      },
      Select: {
        placeholder: "Selecteer a.u.b."
      },
      TimePicker: {
        placeholder: "Selecteer Uur",
        positiveText: "OK",
        negativeText: "Annuleer",
        now: "Nu"
      },
      Pagination: {
        goto: "Ga naar",
        selectionSuffix: "pagina"
      },
      DynamicTags: {
        add: "Toevoegen"
      },
      Log: {
        loading: "Laden"
      },
      Input: {
        placeholder: "Invoeren a.u.b."
      },
      InputNumber: {
        placeholder: "Invoeren a.u.b."
      },
      DynamicInput: {
        create: "Cre\xEBer"
      },
      ThemeEditor: {
        title: "Thema Bewerker",
        clearAllVars: "Wis Alle Variabelen",
        clearSearch: "Wis Zoekopdracht",
        filterCompName: "Filter Componentsnaam",
        filterVarName: "Filter Variablenaam",
        import: "Importen",
        export: "Exporteren",
        restore: "Reset naar Standaard"
      },
      Image: {
        tipPrevious: "Vorige afbeelding (\u2190)",
        tipNext: "Volgende afbeelding (\u2192)",
        tipCounterclockwise: "Tegen de klok in",
        tipClockwise: "Met de klok mee",
        tipZoomOut: "Uitzoomen",
        tipZoomIn: "Inzoomen",
        tipClose: "Sluiten (Esc)",
        tipOriginalSize: "Zoom to original size"
      }
    };
    var nlNL$1 = nlNL;

    const frFR = {
      name: "fr-FR",
      global: {
        undo: "D\xE9faire",
        redo: "Refaire",
        confirm: "Confirmer"
      },
      Popconfirm: {
        positiveText: "Confirmer",
        negativeText: "Annuler"
      },
      Cascader: {
        placeholder: "S\xE9lectionner",
        loading: "Chargement",
        loadingRequiredMessage: label => `Charger tous les enfants de ${label} avant de le s\xE9lectionner`
      },
      Time: {
        dateFormat: "dd/MM/yyyy",
        dateTimeFormat: "dd/MM/yyyy HH:mm:ss"
      },
      DatePicker: {
        yearFormat: "yyyy",
        monthFormat: "MMM",
        dayFormat: "eeeeee",
        yearTypeFormat: "yyyy",
        monthTypeFormat: "MM/yyyy",
        dateFormat: "dd/MM/yyyy",
        dateTimeFormat: "dd/MM/yyyy HH:mm:ss",
        quarterFormat: "qqq yyyy",
        clear: "Effacer",
        now: "Maintenant",
        confirm: "Confirmer",
        selectTime: "S\xE9lectionner l'heure",
        selectDate: "S\xE9lectionner la date",
        datePlaceholder: "S\xE9lectionner la date",
        datetimePlaceholder: "S\xE9lectionner la date et l'heure",
        monthPlaceholder: "S\xE9lectionner le mois",
        yearPlaceholder: "S\xE9lectionner l'ann\xE9e",
        quarterPlaceholder: "S\xE9lectionner le trimestre",
        startDatePlaceholder: "Date de d\xE9but",
        endDatePlaceholder: "Date de fin",
        startDatetimePlaceholder: "Date et heure de d\xE9but",
        endDatetimePlaceholder: "Date et heure de fin",
        startMonthPlaceholder: "Start Month",
        endMonthPlaceholder: "End Month",
        monthBeforeYear: true,
        firstDayOfWeek: 1,
        today: "Aujourd'hui"
      },
      DataTable: {
        checkTableAll: "S\xE9lectionner tout",
        uncheckTableAll: "D\xE9s\xE9lectionner tout",
        confirm: "Confirmer",
        clear: "Effacer"
      },
      LegacyTransfer: {
        sourceTitle: "Source",
        targetTitle: "Cible"
      },
      Transfer: {
        selectAll: "Select all",
        unselectAll: "Unselect all",
        clearAll: "Clear",
        total: num => `Total ${num} items`,
        selected: num => `${num} items selected`
      },
      Empty: {
        description: "Aucune donn\xE9e"
      },
      Select: {
        placeholder: "S\xE9lectionner"
      },
      TimePicker: {
        placeholder: "S\xE9lectionner l'heure",
        positiveText: "OK",
        negativeText: "Annuler",
        now: "Maintenant"
      },
      Pagination: {
        goto: "Aller \xE0",
        selectionSuffix: "page"
      },
      DynamicTags: {
        add: "Ajouter"
      },
      Log: {
        loading: "Chargement"
      },
      Input: {
        placeholder: "Saisir"
      },
      InputNumber: {
        placeholder: "Saisir"
      },
      DynamicInput: {
        create: "Cr\xE9er"
      },
      ThemeEditor: {
        title: "\xC9diteur de th\xE8me",
        clearAllVars: "Effacer toutes les variables",
        clearSearch: "Effacer la recherche",
        filterCompName: "Filtrer par nom de composant",
        filterVarName: "Filtrer par nom de variable",
        import: "Importer",
        export: "Exporter",
        restore: "R\xE9initialiser"
      },
      Image: {
        tipPrevious: "Image pr\xE9c\xE9dente (\u2190)",
        tipNext: "Image suivante (\u2192)",
        tipCounterclockwise: "Sens antihoraire",
        tipClockwise: "Sens horaire",
        tipZoomOut: "D\xE9zoomer",
        tipZoomIn: "Zoomer",
        tipClose: "Fermer (\xC9chap.)",
        tipOriginalSize: "Zoom to original size"
      }
    };
    var frFR$1 = frFR;

    const esAR = {
      name: "es-AR",
      global: {
        undo: "Deshacer",
        redo: "Rehacer",
        confirm: "Confirmar"
      },
      Popconfirm: {
        positiveText: "Confirmar",
        negativeText: "Cancelar"
      },
      Cascader: {
        placeholder: "Seleccionar por favor",
        loading: "Cargando",
        loadingRequiredMessage: label => `Por favor, cargue los descendientes de ${label} antes de marcarlo.`
      },
      Time: {
        dateFormat: "yyyy-MM-dd",
        dateTimeFormat: "yyyy-MM-dd HH:mm:ss"
      },
      DatePicker: {
        yearFormat: "yyyy",
        monthFormat: "MMM",
        dayFormat: "eeeeee",
        yearTypeFormat: "yyyy",
        monthTypeFormat: "yyyy-MM",
        dateFormat: "yyyy-MM-dd",
        dateTimeFormat: "yyyy-MM-dd HH:mm:ss",
        quarterFormat: "yyyy-qqq",
        clear: "Borrar",
        now: "Ahora",
        confirm: "Confirmar",
        selectTime: "Seleccionar hora",
        selectDate: "Seleccionar fecha",
        datePlaceholder: "Seleccionar fecha",
        datetimePlaceholder: "Seleccionar fecha y hora",
        monthPlaceholder: "Seleccionar mes",
        yearPlaceholder: "Seleccionar a\xF1o",
        quarterPlaceholder: "Seleccionar Trimestre",
        startDatePlaceholder: "Fecha de inicio",
        endDatePlaceholder: "Fecha final",
        startDatetimePlaceholder: "Fecha y hora de inicio",
        endDatetimePlaceholder: "Fecha y hora final",
        monthBeforeYear: true,
        startMonthPlaceholder: "Start Month",
        endMonthPlaceholder: "End Month",
        firstDayOfWeek: 6,
        today: "Hoy"
      },
      DataTable: {
        checkTableAll: "Seleccionar todo de la tabla",
        uncheckTableAll: "Deseleccionar todo de la tabla",
        confirm: "Confirmar",
        clear: "Limpiar"
      },
      LegacyTransfer: {
        sourceTitle: "Fuente",
        targetTitle: "Objetivo"
      },
      Transfer: {
        selectAll: "Select all",
        unselectAll: "Unselect all",
        clearAll: "Clear",
        total: num => `Total ${num} items`,
        selected: num => `${num} items selected`
      },
      Empty: {
        description: "Sin datos"
      },
      Select: {
        placeholder: "Seleccionar por favor"
      },
      TimePicker: {
        placeholder: "Seleccionar hora",
        positiveText: "OK",
        negativeText: "Cancelar",
        now: "Ahora"
      },
      Pagination: {
        goto: "Ir a",
        selectionSuffix: "p\xE1gina"
      },
      DynamicTags: {
        add: "Agregar"
      },
      Log: {
        loading: "Cargando"
      },
      Input: {
        placeholder: "Ingrese datos por favor"
      },
      InputNumber: {
        placeholder: "Ingrese datos por favor"
      },
      DynamicInput: {
        create: "Crear"
      },
      ThemeEditor: {
        title: "Editor de Tema",
        clearAllVars: "Limpiar todas las variables",
        clearSearch: "Limpiar b\xFAsqueda",
        filterCompName: "Filtro para nombre del componente",
        filterVarName: "Filtro para nombre de la variable",
        import: "Importar",
        export: "Exportar",
        restore: "Restablecer los valores por defecto"
      },
      Image: {
        tipPrevious: "Imagen anterior (\u2190)",
        tipNext: "Siguiente imagen (\u2192)",
        tipCounterclockwise: "Sentido antihorario",
        tipClockwise: "Sentido horario",
        tipZoomOut: "Alejar",
        tipZoomIn: "Acercar",
        tipClose: "Cerrar (Esc)",
        tipOriginalSize: "Zoom to original size"
      }
    };
    var esAR$1 = esAR;

    const itIT = {
      name: "it-IT",
      global: {
        undo: "Annulla",
        redo: "Ripeti",
        confirm: "Conferma"
      },
      Popconfirm: {
        positiveText: "Conferma",
        negativeText: "Annulla"
      },
      Cascader: {
        placeholder: "Si prega di selezionare",
        loading: "Caricamento",
        loadingRequiredMessage: label => `Carica tutti i discendenti di ${label} prima di controllarlo.`
      },
      Time: {
        dateFormat: "dd/MM/yyyy",
        dateTimeFormat: "dd/MM/yyyy HH:mm:ss"
      },
      DatePicker: {
        yearFormat: "yyyy",
        monthFormat: "MMM",
        dayFormat: "eeeeee",
        yearTypeFormat: "yyyy",
        monthTypeFormat: "yyyy-MM",
        dateFormat: "yyyy-MM-dd",
        dateTimeFormat: "yyyy-MM-dd HH:mm:ss",
        quarterFormat: "yyyy-qqq",
        clear: "Cancella",
        now: "Adesso",
        confirm: "Conferma",
        selectTime: "Seleziona ora",
        selectDate: "Seleziona data",
        datePlaceholder: "Seleziona data",
        datetimePlaceholder: "Seleziona data e ora",
        monthPlaceholder: "Seleziona mese",
        yearPlaceholder: "Seleziona anno",
        quarterPlaceholder: "Seleziona trimestre",
        startDatePlaceholder: "Data inizio",
        endDatePlaceholder: "Data fine",
        startDatetimePlaceholder: "Data e ora di inizio",
        endDatetimePlaceholder: "Data e ora di fine",
        startMonthPlaceholder: "Start Month",
        endMonthPlaceholder: "End Month",
        monthBeforeYear: true,
        firstDayOfWeek: 0,
        today: "Oggi"
      },
      DataTable: {
        checkTableAll: "Seleziona tutto nella tabella",
        uncheckTableAll: "Deseleziona tutto nella tabella",
        confirm: "Conferma",
        clear: "Cancella"
      },
      LegacyTransfer: {
        sourceTitle: "Fonte",
        targetTitle: "Destinazione"
      },
      Transfer: {
        selectAll: "Select all",
        unselectAll: "Unselect all",
        clearAll: "Clear",
        total: num => `Total ${num} items`,
        selected: num => `${num} items selected`
      },
      Empty: {
        description: "Nessun Dato"
      },
      Select: {
        placeholder: "Si prega di selezionare"
      },
      TimePicker: {
        placeholder: "Seleziona ora",
        positiveText: "OK",
        negativeText: "Annulla",
        now: "Ora"
      },
      Pagination: {
        goto: "Vai a",
        selectionSuffix: "per pagina"
      },
      DynamicTags: {
        add: "Aggiungi"
      },
      Log: {
        loading: "Caricamento"
      },
      Input: {
        placeholder: "Si prega di inserire"
      },
      InputNumber: {
        placeholder: "Si prega di inserire"
      },
      DynamicInput: {
        create: "Crea"
      },
      ThemeEditor: {
        title: "Editor Tema",
        clearAllVars: "Cancella tutte le variabili",
        clearSearch: "Cancella ricerca",
        filterCompName: "Filtra componenti",
        filterVarName: "Filtra variabili",
        import: "Importa",
        export: "Esporta",
        restore: "Ripristina"
      },
      Image: {
        tipPrevious: "Immagine precedente (\u2190)",
        tipNext: "Immagine successiva (\u2192)",
        tipCounterclockwise: "Ruota a sinistra",
        tipClockwise: "Ruota a destra",
        tipZoomOut: "Ingrandisci",
        tipZoomIn: "Riduci",
        tipClose: "Chiudi (Esc)",
        tipOriginalSize: "Zoom to original size"
      }
    };
    var itIT$1 = itIT;

    const skSK = {
      name: "sk-SK",
      global: {
        undo: "Sp\xE4\u0165",
        redo: "Obnovi\u0165",
        confirm: "Potvrdi\u0165"
      },
      Popconfirm: {
        positiveText: "Potvrdi\u0165",
        negativeText: "Zru\u0161i\u0165"
      },
      Cascader: {
        placeholder: "Pros\xEDm vyberte",
        loading: "Na\u010D\xEDtavanie",
        loadingRequiredMessage: label => `Pros\xEDm na\u010D\xEDtajte v\u0161etk\xFDch ${label} potomkov pred kontrolou.`
      },
      Time: {
        dateFormat: "d-M-yyyy",
        dateTimeFormat: "d-M-yyyy HH:mm:ss"
      },
      DatePicker: {
        yearFormat: "yyyy",
        monthFormat: "MMM",
        dayFormat: "EEEE",
        yearTypeFormat: "yyyy",
        monthTypeFormat: "MMM-yyyy",
        dateFormat: "d-M-yyyy",
        dateTimeFormat: "d-M-yyyy HH:mm:ss",
        quarterFormat: "qqq-yyyy",
        clear: "Vy\u010Disti\u0165",
        now: "Teraz",
        confirm: "Potvrdi\u0165",
        selectTime: "Vybra\u0165 \u010Das",
        selectDate: "Vybra\u0165 d\xE1tum",
        datePlaceholder: "Vyberte \u010Das",
        datetimePlaceholder: "Vyberte d\xE1tum a \u010Das",
        monthPlaceholder: "Vyberte mesiac",
        yearPlaceholder: "Vyberte rok",
        quarterPlaceholder: "Vyberte \u0161tvr\u0165rok",
        startDatePlaceholder: "D\xE1tum za\u010Diatku",
        endDatePlaceholder: "D\xE1tum ukon\u010Denia",
        startDatetimePlaceholder: "D\xE1tum a \u010Das za\u010Diatku",
        endDatetimePlaceholder: "D\xE1tum a \u010Das ukon\u010Denia ",
        startMonthPlaceholder: "Start Month",
        endMonthPlaceholder: "End Month",
        monthBeforeYear: true,
        firstDayOfWeek: 6,
        today: "Dnes"
      },
      DataTable: {
        checkTableAll: "Vybra\u0165 v\u0161etko v tabu\u013Eke",
        uncheckTableAll: "Zru\u0161i\u0165 v\xFDber v\u0161etk\xE9ho v tabu\u013Eke ",
        confirm: "Potvrdi\u0165",
        clear: "Vy\u010Disti\u0165"
      },
      LegacyTransfer: {
        sourceTitle: "Zdroj",
        targetTitle: "Cie\u013E"
      },
      Transfer: {
        selectAll: "Select all",
        unselectAll: "Unselect all",
        clearAll: "Clear",
        total: num => `Total ${num} items`,
        selected: num => `${num} items selected`
      },
      Empty: {
        description: "\u017Diadne d\xE1ta"
      },
      Select: {
        placeholder: "Pros\xEDm vyberte"
      },
      TimePicker: {
        placeholder: "Vybra\u0165 \u010Das",
        positiveText: "OK",
        negativeText: "Zru\u0161i\u0165",
        now: "Teraz"
      },
      Pagination: {
        goto: "\xCDs\u0165",
        selectionSuffix: "Strana"
      },
      DynamicTags: {
        add: "Prida\u0165"
      },
      Log: {
        loading: "Na\u010D\xEDtavanie"
      },
      Input: {
        placeholder: "Zadajte"
      },
      InputNumber: {
        placeholder: "Zadajte"
      },
      DynamicInput: {
        create: "Vytvori\u0165"
      },
      ThemeEditor: {
        title: "Editor t\xE9m",
        clearAllVars: "Vymaza\u0165 v\u0161etky premenn\xE9",
        clearSearch: "Vymaza\u0165 vyh\u013Ead\xE1vanie",
        filterCompName: "N\xE1zov komponentu filtra",
        filterVarName: "N\xE1zov premennej filtra",
        import: "Importova\u0165",
        export: "Exportova\u0165",
        restore: "Obnovi\u0165 p\xF4vodn\xE9 nastavenia"
      },
      Image: {
        tipPrevious: "Predch\xE1dzaj\xFAci obr\xE1zok (\u2190)",
        tipNext: "\u010Eal\u0161\xED obr\xE1zok (\u2192)",
        tipCounterclockwise: "Proti smeru hodinov\xFDch ru\u010Di\u010Diek",
        tipClockwise: "V smere hodinov\xFDch ru\u010Di\u010Diek",
        tipZoomOut: "Oddiali\u0165",
        tipZoomIn: "Pribl\xED\u017Ei\u0165",
        tipClose: "Zavrie\u0165 (Esc)",
        tipOriginalSize: "Zoom to original size"
      }
    };
    var skSK$1 = skSK;

    const enGB = {
      name: "en-GB",
      global: {
        undo: "Undo",
        redo: "Redo",
        confirm: "Confirm"
      },
      Popconfirm: {
        positiveText: "Confirm",
        negativeText: "Cancel"
      },
      Cascader: {
        placeholder: "Please Select",
        loading: "Loading",
        loadingRequiredMessage: label => `Please load all ${label}'s descendants before checking it.`
      },
      Time: {
        dateFormat: "yyyy/MM/dd",
        dateTimeFormat: "yyyy/MM/dd HH:mm:ss"
      },
      DatePicker: {
        yearFormat: "yyyy",
        monthFormat: "MMM",
        dayFormat: "eeeeee",
        yearTypeFormat: "yyyy",
        monthTypeFormat: "yyyy/MM",
        dateFormat: "yyyy/MM/dd",
        dateTimeFormat: "yyyy/MM/dd HH:mm:ss",
        quarterFormat: "yyyy-qqq",
        clear: "Clear",
        now: "Now",
        confirm: "Confirm",
        selectTime: "Select Time",
        selectDate: "Select Date",
        datePlaceholder: "Select Date",
        datetimePlaceholder: "Select Date and Time",
        monthPlaceholder: "Select Month",
        yearPlaceholder: "Select Year",
        quarterPlaceholder: "Select Quarter",
        startDatePlaceholder: "Start Date",
        endDatePlaceholder: "End Date",
        startDatetimePlaceholder: "Start Date and Time",
        endDatetimePlaceholder: "End Date and Time",
        startMonthPlaceholder: "Start Month",
        endMonthPlaceholder: "End Month",
        monthBeforeYear: true,
        firstDayOfWeek: 0,
        today: "Today"
      },
      DataTable: {
        checkTableAll: "Select all in the table",
        uncheckTableAll: "Unselect all in the table",
        confirm: "Confirm",
        clear: "Clear"
      },
      LegacyTransfer: {
        sourceTitle: "Source",
        targetTitle: "Target"
      },
      Transfer: {
        selectAll: "Select all",
        unselectAll: "Unselect all",
        clearAll: "Clear",
        total: num => `Total ${num} items`,
        selected: num => `${num} items selected`
      },
      Empty: {
        description: "No Data"
      },
      Select: {
        placeholder: "Please Select"
      },
      TimePicker: {
        placeholder: "Select Time",
        positiveText: "OK",
        negativeText: "Cancel",
        now: "Now"
      },
      Pagination: {
        goto: "Goto",
        selectionSuffix: "page"
      },
      DynamicTags: {
        add: "Add"
      },
      Log: {
        loading: "Loading"
      },
      Input: {
        placeholder: "Please Input"
      },
      InputNumber: {
        placeholder: "Please Input"
      },
      DynamicInput: {
        create: "Create"
      },
      ThemeEditor: {
        title: "Theme Editor",
        clearAllVars: "Clear All Variables",
        clearSearch: "Clear Search",
        filterCompName: "Filter Component Name",
        filterVarName: "Filter Variable Name",
        import: "Import",
        export: "Export",
        restore: "Reset to Default"
      },
      Image: {
        tipPrevious: "Previous picture (\u2190)",
        tipNext: "Next picture (\u2192)",
        tipCounterclockwise: "Counterclockwise",
        tipClockwise: "Clockwise",
        tipZoomOut: "Zoom out",
        tipZoomIn: "Zoom in",
        tipClose: "Close (Esc)",
        tipOriginalSize: "Zoom to original size"
      }
    };
    var enGB$1 = enGB;

    const plPL = {
      name: "pl-PL",
      global: {
        undo: "Cofnij",
        redo: "Pon\xF3w",
        confirm: "Potwierd\u017A"
      },
      Popconfirm: {
        positiveText: "Potwierd\u017A",
        negativeText: "Anuluj"
      },
      Cascader: {
        placeholder: "Wybierz",
        loading: "\u0141adowanie",
        loadingRequiredMessage: label => `Prosz\u0119 za\u0142adowa\u0107 wszystkie ${label}'s elementy przed sprawdzeniem.`
      },
      Time: {
        dateFormat: "yyyy-MM-dd",
        dateTimeFormat: "yyyy-MM-dd HH:mm:ss"
      },
      DatePicker: {
        yearFormat: "yyyy",
        monthFormat: "MMM",
        dayFormat: "eeeeee",
        yearTypeFormat: "yyyy",
        monthTypeFormat: "yyyy-MM",
        dateFormat: "yyyy-MM-dd",
        dateTimeFormat: "yyyy-MM-dd HH:mm:ss",
        quarterFormat: "yyyy-qqq",
        clear: "Wyczy\u015B\u0107",
        now: "Teraz",
        confirm: "Potwierd\u017A",
        selectTime: "Wybierz czas",
        selectDate: "Wybierz dat\u0119",
        datePlaceholder: "Wybierz dat\u0119",
        datetimePlaceholder: "Wybierz dat\u0119 i czas",
        monthPlaceholder: "Wybierz miesi\u0105c",
        yearPlaceholder: "Wybierz rok",
        quarterPlaceholder: "Wybierz kwarta\u0142",
        startDatePlaceholder: "Data rozpocz\u0119cia",
        endDatePlaceholder: "Data zako\u0144czenia",
        startDatetimePlaceholder: "Data i godzina rozpocz\u0119cia",
        endDatetimePlaceholder: "Data i godzina zako\u0144czenia",
        startMonthPlaceholder: "Start Month",
        endMonthPlaceholder: "End Month",
        monthBeforeYear: true,
        firstDayOfWeek: 6,
        today: "Dzi\u015B"
      },
      DataTable: {
        checkTableAll: "Zaznacz wszystkie w tabeli",
        uncheckTableAll: "Odznacz wszystkie w tabeli",
        confirm: "Potwierd\u017A",
        clear: "Wyczy\u015B\u0107"
      },
      LegacyTransfer: {
        sourceTitle: "\u0179r\xF3d\u0142o",
        targetTitle: "Cel"
      },
      Transfer: {
        selectAll: "Select all",
        unselectAll: "Unselect all",
        clearAll: "Clear",
        total: num => `Total ${num} items`,
        selected: num => `${num} items selected`
      },
      Empty: {
        description: "Brak danych"
      },
      Select: {
        placeholder: "Wybierz"
      },
      TimePicker: {
        placeholder: "Wybierz czas",
        positiveText: "Potwierd\u017A",
        negativeText: "Anuluj",
        now: "Teraz"
      },
      Pagination: {
        goto: "Id\u017A do",
        selectionSuffix: "strona"
      },
      DynamicTags: {
        add: "Dodaj"
      },
      Log: {
        loading: "\u0141adowanie"
      },
      Input: {
        placeholder: "Wprowad\u017A dane"
      },
      InputNumber: {
        placeholder: "Wprowad\u017A dane"
      },
      DynamicInput: {
        create: "Utw\xF3rz"
      },
      ThemeEditor: {
        title: "Edytor motyw\xF3w",
        clearAllVars: "Wyczy\u015B\u0107 wszystkie zmienne",
        clearSearch: "Wyczy\u015B\u0107 wyszukiwanie",
        filterCompName: "Nazwa komponentu filtra",
        filterVarName: "Nazwa zmiennej filtra",
        import: "Importuj",
        export: "Eksportuj",
        restore: "Przywr\xF3\u0107 ustawienia domy\u015Blne"
      },
      Image: {
        tipPrevious: "Poprzednie zdj\u0119cie (\u2190)",
        tipNext: "Nast\u0119pne zdj\u0119cie (\u2192)",
        tipCounterclockwise: "Przeciwnie do ruchu wskaz\xF3wek zegara",
        tipClockwise: "Zgodnie z ruchem wskaz\xF3wek zegara",
        tipZoomOut: "Powi\u0119ksz",
        tipZoomIn: "Pomniejsz",
        tipClose: "Zamknij (Esc)",
        tipOriginalSize: "Zoom to original size"
      }
    };
    var plPL$1 = plPL;

    const ptBR = {
      name: "pt-BR",
      global: {
        undo: "Desfazer",
        redo: "Refazer",
        confirm: "Confirmar"
      },
      Popconfirm: {
        positiveText: "Confirmar",
        negativeText: "Cancelar"
      },
      Cascader: {
        placeholder: "Por favor selecione",
        loading: "Carregando",
        loadingRequiredMessage: label => `Carregue todos os descendentes de ${label} antes de verificar.`
      },
      Time: {
        dateFormat: "dd/MM/yyyy",
        dateTimeFormat: "dd/MM/yyyy HH:mm:ss"
      },
      DatePicker: {
        yearFormat: "yyyy",
        monthFormat: "MMM",
        dayFormat: "eeeeee",
        yearTypeFormat: "yyyy",
        monthTypeFormat: "yyyy/MM",
        dateFormat: "dd/MM/yyyy",
        dateTimeFormat: "dd/MM/yyyy HH:mm:ss",
        quarterFormat: "yyyy/qqq",
        clear: "Limpar",
        now: "Agora",
        confirm: "Confirmar",
        selectTime: "Selecionar hora",
        selectDate: "Selecione a data",
        datePlaceholder: "Selecione a data",
        datetimePlaceholder: "Selecione Data e Hora",
        monthPlaceholder: "Selecione o m\xEAs",
        yearPlaceholder: "Selecione o ano",
        quarterPlaceholder: "Selecione o quatrimestre",
        startDatePlaceholder: "Selecione a data de in\xEDcio",
        endDatePlaceholder: "Selecione a data de t\xE9rmino",
        startDatetimePlaceholder: "Selecione a data e hora de in\xEDcio",
        endDatetimePlaceholder: "Select a data e hora de t\xE9rmino",
        startMonthPlaceholder: "Start Month",
        endMonthPlaceholder: "End Month",
        monthBeforeYear: true,
        firstDayOfWeek: 6,
        today: "Hoje"
      },
      DataTable: {
        checkTableAll: "Selecionar todos na tabela",
        uncheckTableAll: "Desmarcar todos na tabela",
        confirm: "Confirmar",
        clear: "Limpar"
      },
      LegacyTransfer: {
        sourceTitle: "Fonte",
        targetTitle: "Destino"
      },
      Transfer: {
        selectAll: "Select all",
        unselectAll: "Unselect all",
        clearAll: "Clear",
        total: num => `Total ${num} items`,
        selected: num => `${num} items selected`
      },
      Empty: {
        description: "N\xE3o h\xE1 dados"
      },
      Select: {
        placeholder: "Por favor selecione"
      },
      TimePicker: {
        placeholder: "Selecione a hora",
        positiveText: "OK",
        negativeText: "Cancelar",
        now: "Agora"
      },
      Pagination: {
        goto: "Ir para",
        selectionSuffix: "p\xE1gina"
      },
      DynamicTags: {
        add: "Adicionar"
      },
      Log: {
        loading: "Carregando"
      },
      Input: {
        placeholder: "Por favor digite"
      },
      InputNumber: {
        placeholder: "Por favor digite"
      },
      DynamicInput: {
        create: "Criar"
      },
      ThemeEditor: {
        title: "Editor de temas",
        clearAllVars: "Limpar todas as vari\xE1veis",
        clearSearch: "Limpar pesquisa",
        filterCompName: "Filtrar nome do componente",
        filterVarName: "Filtrar nome da vari\xE1vel",
        import: "Importar",
        export: "Exportar",
        restore: "Restaurar"
      },
      Image: {
        tipPrevious: "Foto anterior (\u2190)",
        tipNext: "Pr\xF3xima foto (\u2192)",
        tipCounterclockwise: "Sentido anti-hor\xE1rio",
        tipClockwise: "Sentido hor\xE1rio",
        tipZoomOut: "Reduzir o zoom",
        tipZoomIn: "Mais Zoom",
        tipClose: "Fechar (Esc)",
        tipOriginalSize: "Zoom to original size"
      }
    };
    var ptBR$1 = ptBR;

    const thTH = {
      name: "thTH",
      global: {
        undo: "\u0E40\u0E25\u0E34\u0E01\u0E17\u0E33",
        redo: "\u0E17\u0E33\u0E0B\u0E49\u0E33",
        confirm: "\u0E22\u0E37\u0E19\u0E22\u0E31\u0E19"
      },
      Popconfirm: {
        positiveText: "\u0E22\u0E37\u0E19\u0E22\u0E31\u0E19",
        negativeText: "\u0E22\u0E01\u0E40\u0E25\u0E34\u0E01"
      },
      Cascader: {
        placeholder: "\u0E01\u0E23\u0E38\u0E13\u0E32\u0E40\u0E25\u0E37\u0E2D\u0E01",
        loading: "\u0E01\u0E33\u0E25\u0E31\u0E07\u0E42\u0E2B\u0E25\u0E14",
        loadingRequiredMessage: label => `Please load all ${label}'s descendants before checking it.`
      },
      Time: {
        dateFormat: "dd-MMMM-yyyy",
        dateTimeFormat: "dd-MMMM-yyyy HH:mm:ss"
      },
      DatePicker: {
        yearFormat: "yyyy",
        monthFormat: "MMM",
        dayFormat: "eeeeee",
        yearTypeFormat: "yyyy",
        monthTypeFormat: "yyyy-MM",
        dateFormat: "dd/MMMM/yyyy",
        dateTimeFormat: "dd/MMMM/yyyy HH:mm:ss",
        quarterFormat: "yyyy-qqq",
        clear: "\u0E25\u0E49\u0E32\u0E07",
        now: "\u0E27\u0E31\u0E19\u0E19\u0E35\u0E49",
        confirm: "\u0E22\u0E37\u0E19\u0E22\u0E31\u0E19",
        selectTime: "\u0E40\u0E27\u0E25\u0E32",
        selectDate: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48",
        datePlaceholder: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48",
        datetimePlaceholder: "\u0E40\u0E27\u0E25\u0E32-\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48",
        monthPlaceholder: "\u0E40\u0E14\u0E37\u0E2D\u0E19",
        yearPlaceholder: "\u0E1B\u0E35",
        quarterPlaceholder: "\u0E44\u0E15\u0E23\u0E21\u0E32\u0E2A",
        startDatePlaceholder: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E40\u0E23\u0E34\u0E48\u0E21\u0E15\u0E49\u0E19",
        endDatePlaceholder: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E2A\u0E34\u0E49\u0E19\u0E2A\u0E38\u0E14",
        startDatetimePlaceholder: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E40\u0E23\u0E34\u0E48\u0E21\u0E15\u0E49\u0E19\u0E41\u0E25\u0E30\u0E2A\u0E34\u0E49\u0E19\u0E2A\u0E38\u0E14",
        endDatetimePlaceholder: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E2A\u0E34\u0E49\u0E19\u0E2A\u0E38\u0E14\u0E41\u0E25\u0E30\u0E40\u0E27\u0E25\u0E32",
        startMonthPlaceholder: "Start Month",
        endMonthPlaceholder: "End Month",
        monthBeforeYear: true,
        firstDayOfWeek: 6,
        today: "\u0E27\u0E31\u0E19\u0E19\u0E35\u0E49"
      },
      DataTable: {
        checkTableAll: "\u0E40\u0E25\u0E37\u0E2D\u0E01\u0E17\u0E31\u0E49\u0E07\u0E2B\u0E21\u0E14",
        uncheckTableAll: "\u0E44\u0E21\u0E48\u0E40\u0E25\u0E37\u0E2D\u0E01\u0E17\u0E31\u0E49\u0E07\u0E2B\u0E21\u0E14",
        confirm: "\u0E22\u0E37\u0E19\u0E22\u0E31\u0E19",
        clear: "\u0E25\u0E49\u0E32\u0E07\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25"
      },
      LegacyTransfer: {
        sourceTitle: "Source",
        targetTitle: "Target"
      },
      Transfer: {
        selectAll: "Select all",
        unselectAll: "Unselect all",
        clearAll: "Clear",
        total: num => `Total ${num} items`,
        selected: num => `${num} items selected`
      },
      Empty: {
        description: "\u0E44\u0E21\u0E48\u0E21\u0E35\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25"
      },
      Select: {
        placeholder: "\u0E01\u0E23\u0E38\u0E13\u0E32\u0E40\u0E25\u0E37\u0E2D\u0E01"
      },
      TimePicker: {
        placeholder: "\u0E40\u0E27\u0E25\u0E32",
        positiveText: "\u0E15\u0E01\u0E25\u0E07",
        negativeText: "\u0E22\u0E01\u0E40\u0E25\u0E34\u0E01",
        now: "\u0E27\u0E31\u0E19\u0E19\u0E35\u0E49"
      },
      Pagination: {
        goto: "\u0E44\u0E1B\u0E22\u0E31\u0E07",
        selectionSuffix: "\u0E2B\u0E19\u0E49\u0E32"
      },
      DynamicTags: {
        add: "\u0E40\u0E1E\u0E34\u0E48\u0E21"
      },
      Log: {
        loading: "\u0E01\u0E33\u0E25\u0E31\u0E07\u0E42\u0E2B\u0E25\u0E14"
      },
      Input: {
        placeholder: "\u0E01\u0E23\u0E38\u0E13\u0E32\u0E01\u0E23\u0E2D\u0E01"
      },
      InputNumber: {
        placeholder: "\u0E01\u0E23\u0E38\u0E13\u0E32\u0E01\u0E23\u0E2D\u0E01"
      },
      DynamicInput: {
        create: "\u0E2A\u0E23\u0E49\u0E32\u0E07"
      },
      ThemeEditor: {
        title: "\u0E41\u0E01\u0E49\u0E44\u0E02\u0E18\u0E35\u0E21",
        clearAllVars: "\u0E25\u0E49\u0E32\u0E07\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E15\u0E31\u0E27\u0E41\u0E1B\u0E23",
        clearSearch: "\u0E25\u0E49\u0E32\u0E07\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E04\u0E49\u0E19\u0E2B\u0E32",
        filterCompName: "\u0E01\u0E23\u0E2D\u0E07\u0E42\u0E14\u0E22\u0E0A\u0E37\u0E48\u0E2D Component",
        filterVarName: "\u0E01\u0E23\u0E2D\u0E07\u0E42\u0E14\u0E22\u0E0A\u0E37\u0E48\u0E2D\u0E15\u0E31\u0E27\u0E41\u0E1B\u0E23",
        import: "\u0E19\u0E33\u0E40\u0E02\u0E49\u0E32",
        export: "\u0E2A\u0E48\u0E07\u0E2D\u0E2D\u0E01",
        restore: "\u0E23\u0E35\u0E40\u0E0B\u0E47\u0E15"
      },
      Image: {
        tipPrevious: "\u0E01\u0E48\u0E2D\u0E19\u0E2B\u0E19\u0E49\u0E32 (\u2190)",
        tipNext: "\u0E16\u0E31\u0E14\u0E44\u0E1B (\u2192)",
        tipCounterclockwise: "\u0E2B\u0E21\u0E38\u0E19 (\u21BA)",
        tipClockwise: "\u0E2B\u0E21\u0E38\u0E19 (\u21BB)",
        tipZoomOut: "\u0E0B\u0E39\u0E21\u0E2D\u0E2D\u0E01",
        tipZoomIn: "\u0E0B\u0E39\u0E21\u0E40\u0E02\u0E49\u0E32",
        tipClose: "\u0E1B\u0E34\u0E14 (Esc)",
        tipOriginalSize: "Zoom to original size"
      }
    };
    var thTH$1 = thTH;

    const eo = {
      name: "eo",
      global: {
        undo: "Malfari",
        redo: "Refari",
        confirm: "Konfirmi"
      },
      Popconfirm: {
        positiveText: "Konfirmi",
        negativeText: "Nuligi"
      },
      Cascader: {
        placeholder: "Bonvolu elekti",
        loading: "\u015Cargi\u011Do",
        loadingRequiredMessage: label => `Bonvolu \u015Dargi \u0109iujn idojn de ${label} anta\u016D ol elekti \u011Din.`
      },
      Time: {
        dateFormat: "yyyy-MM-dd",
        dateTimeFormat: "yyyy-MM-dd HH:mm:ss"
      },
      DatePicker: {
        yearFormat: "yyyy",
        monthFormat: "MMM",
        dayFormat: "eeeeee",
        yearTypeFormat: "yyyy",
        monthTypeFormat: "yyyy-MM",
        dateFormat: "yyyy-MM-dd",
        dateTimeFormat: "yyyy-MM-dd HH:mm:ss",
        quarterFormat: "yyyy-qqq",
        clear: "Malplenigi",
        now: "Nun",
        confirm: "Konfirmi",
        selectTime: "Elekti tempon",
        selectDate: "Elekti daton",
        datePlaceholder: "Elekti daton",
        datetimePlaceholder: "Elekti daton kaj tempon",
        monthPlaceholder: "Elekti monaton",
        yearPlaceholder: "Elekti jaron",
        quarterPlaceholder: "Elekti jarkvaronon",
        startDatePlaceholder: "Komenca dato",
        endDatePlaceholder: "Fina dato",
        startDatetimePlaceholder: "Komencaj dato kaj tempo",
        endDatetimePlaceholder: "Finaj dato kaj tempo",
        startMonthPlaceholder: "Start Month",
        endMonthPlaceholder: "End Month",
        monthBeforeYear: true,
        firstDayOfWeek: 0,
        today: "Hodia\u016D"
      },
      DataTable: {
        checkTableAll: "Elekti \u0109iujn en la tabelo",
        uncheckTableAll: "Malelekti \u0109iujn en la tabelo",
        confirm: "Konfirmi",
        clear: "Malplenigi"
      },
      LegacyTransfer: {
        sourceTitle: "Source",
        targetTitle: "Target"
      },
      Transfer: {
        selectAll: "Select all",
        unselectAll: "Unselect all",
        clearAll: "Clear",
        total: num => `Total ${num} items`,
        selected: num => `${num} items selected`
      },
      Empty: {
        description: "Neniu datumo"
      },
      Select: {
        placeholder: "Bonvolu elekti"
      },
      TimePicker: {
        placeholder: "Elekti tempon",
        positiveText: "Bone",
        negativeText: "Nuligi",
        now: "Nun"
      },
      Pagination: {
        goto: "Iri al",
        selectionSuffix: "pa\u011Do"
      },
      DynamicTags: {
        add: "Aldoni"
      },
      Log: {
        loading: "\u015Cargado"
      },
      Input: {
        placeholder: "Bonvolu entajpi"
      },
      InputNumber: {
        placeholder: "Bonvolu entajpi"
      },
      DynamicInput: {
        create: "Krei"
      },
      ThemeEditor: {
        title: "Etosredaktilo",
        clearAllVars: "Malplenigi \u0109iujn variablojn",
        clearSearch: "Malplenigi ser\u0109on",
        filterCompName: "Filtri nomojn de kompona\u0135oj",
        filterVarName: "Filtri nomojn de variabloj",
        import: "Importi",
        export: "Eksporti",
        restore: "Restarigi defa\u016Dltajn valorojn"
      },
      Image: {
        tipPrevious: "Anta\u016Da bildo (\u2190)",
        tipNext: "Sekva bildo (\u2192)",
        tipCounterclockwise: "Maldekstrume",
        tipClockwise: "Dekstrume",
        tipZoomOut: "Malzomi",
        tipZoomIn: "Zomi",
        tipClose: "Fermi (Esc)",
        tipOriginalSize: "Zoom to original size"
      }
    };
    var eo$1 = eo;

    const viVN = {
      name: "vi-VN",
      global: {
        undo: "Ho\xE0n t\xE1c",
        redo: "L\xE0m l\u1EA1i",
        confirm: "X\xE1c nh\u1EADn"
      },
      Popconfirm: {
        positiveText: "X\xE1c nh\u1EADn",
        negativeText: "H\u1EE7y"
      },
      Cascader: {
        placeholder: "Vui l\xF2ng ch\u1ECDn",
        loading: "\u0110ang t\u1EA3i",
        loadingRequiredMessage: label => `Vui l\xF2ng t\u1EA3i t\u1EA5t c\u1EA3 th\xF4ng tin con c\u1EE7a ${label} tr\u01B0\u1EDBc.`
      },
      Time: {
        dateFormat: "",
        dateTimeFormat: "HH:mm:ss dd-MM-yyyy"
      },
      DatePicker: {
        yearFormat: "yyyy",
        monthFormat: "MMM",
        dayFormat: "eeeeee",
        yearTypeFormat: "yyyy",
        monthTypeFormat: "MM-yyyy",
        dateFormat: "dd-MM-yyyy",
        dateTimeFormat: "HH:mm:ss dd-MM-yyyy",
        quarterFormat: "qqq-yyyy",
        clear: "X\xF3a",
        now: "H\xF4m nay",
        confirm: "X\xE1c nh\u1EADn",
        selectTime: "Ch\u1ECDn gi\u1EDD",
        selectDate: "Ch\u1ECDn ng\xE0y",
        datePlaceholder: "Ch\u1ECDn ng\xE0y",
        datetimePlaceholder: "Ch\u1ECDn ng\xE0y gi\u1EDD",
        monthPlaceholder: "Ch\u1ECDn th\xE1ng",
        yearPlaceholder: "Ch\u1ECDn n\u0103m",
        quarterPlaceholder: "Ch\u1ECDn qu\xFD",
        startDatePlaceholder: "Ng\xE0y b\u1EAFt \u0111\u1EA7u",
        endDatePlaceholder: "Ng\xE0y k\u1EBFt th\xFAc",
        startDatetimePlaceholder: "Th\u1EDDi gian b\u1EAFt \u0111\u1EA7u",
        endDatetimePlaceholder: "Th\u1EDDi gian k\u1EBFt th\xFAc",
        startMonthPlaceholder: "Th\xE1ng b\u1EAFt \u0111\u1EA7u",
        endMonthPlaceholder: "Th\xE1ng k\u1EBFt th\xFAc",
        monthBeforeYear: true,
        firstDayOfWeek: 0,
        today: "H\xF4m nay"
      },
      DataTable: {
        checkTableAll: "Ch\u1ECDn t\u1EA5t c\u1EA3 c\xF3 trong b\u1EA3ng",
        uncheckTableAll: "B\u1ECF ch\u1ECDn t\u1EA5t c\u1EA3 c\xF3 trong b\u1EA3ng",
        confirm: "X\xE1c nh\u1EADn",
        clear: "X\xF3a"
      },
      LegacyTransfer: {
        sourceTitle: "Ngu\u1ED3n",
        targetTitle: "\u0110\xEDch"
      },
      Transfer: {
        selectAll: "Ch\u1ECDn t\u1EA5t c\u1EA3",
        unselectAll: "B\u1ECF ch\u1ECDn t\u1EA5t c\u1EA3",
        clearAll: "Xo\xE1 t\u1EA5t c\u1EA3",
        total: num => `T\u1ED5ng c\u1ED9ng ${num} m\u1EE5c`,
        selected: num => `${num} m\u1EE5c \u0111\u01B0\u1EE3c ch\u1ECDn`
      },
      Empty: {
        description: "Kh\xF4ng c\xF3 d\u1EEF li\u1EC7u"
      },
      Select: {
        placeholder: "Vui l\xF2ng ch\u1ECDn"
      },
      TimePicker: {
        placeholder: "Ch\u1ECDn th\u1EDDi gian",
        positiveText: "OK",
        negativeText: "H\u1EE7y",
        now: "Hi\u1EC7n t\u1EA1i"
      },
      Pagination: {
        goto: "\u0110i \u0111\u1EBFn trang",
        selectionSuffix: "trang"
      },
      DynamicTags: {
        add: "Th\xEAm"
      },
      Log: {
        loading: "\u0110ang t\u1EA3i"
      },
      Input: {
        placeholder: "Vui l\xF2ng nh\u1EADp"
      },
      InputNumber: {
        placeholder: "Vui l\xF2ng nh\u1EADp"
      },
      DynamicInput: {
        create: "T\u1EA1o"
      },
      ThemeEditor: {
        title: "T\xF9y ch\u1EC9nh giao di\u1EC7n",
        clearAllVars: "X\xF3a t\u1EA5t c\u1EA3 c\xE1c bi\u1EBFn",
        clearSearch: "X\xF3a t\xECm ki\u1EBFm",
        filterCompName: "L\u1ECDc t\xEAn component",
        filterVarName: "L\u1ECDc t\xEAn bi\u1EBFn",
        import: "Nh\u1EADp",
        export: "Xu\u1EA5t",
        restore: "\u0110\u1EB7t l\u1EA1i m\u1EB7c \u0111\u1ECBnh"
      },
      Image: {
        tipPrevious: "H\xECnh tr\u01B0\u1EDBc (\u2190)",
        tipNext: "H\xECnh ti\u1EBFp (\u2192)",
        tipCounterclockwise: "Counterclockwise",
        tipClockwise: "Chi\u1EC1u kim \u0111\u1ED3ng h\u1ED3",
        tipZoomOut: "Thu nh\u1ECF",
        tipZoomIn: "Ph\xF3ng to",
        tipClose: "\u0110\xF3ng (Esc)",
        tipOriginalSize: "Xem k\xEDch th\u01B0\u1EDBc g\u1ED1c"
      }
    };
    var viVN$1 = viVN;

    var formatDistanceLocale$j = {
      lessThanXSeconds: {
        one: '不到 1 秒',
        other: '不到 {{count}} 秒'
      },
      xSeconds: {
        one: '1 秒',
        other: '{{count}} 秒'
      },
      halfAMinute: '半分钟',
      lessThanXMinutes: {
        one: '不到 1 分钟',
        other: '不到 {{count}} 分钟'
      },
      xMinutes: {
        one: '1 分钟',
        other: '{{count}} 分钟'
      },
      xHours: {
        one: '1 小时',
        other: '{{count}} 小时'
      },
      aboutXHours: {
        one: '大约 1 小时',
        other: '大约 {{count}} 小时'
      },
      xDays: {
        one: '1 天',
        other: '{{count}} 天'
      },
      aboutXWeeks: {
        one: '大约 1 个星期',
        other: '大约 {{count}} 个星期'
      },
      xWeeks: {
        one: '1 个星期',
        other: '{{count}} 个星期'
      },
      aboutXMonths: {
        one: '大约 1 个月',
        other: '大约 {{count}} 个月'
      },
      xMonths: {
        one: '1 个月',
        other: '{{count}} 个月'
      },
      aboutXYears: {
        one: '大约 1 年',
        other: '大约 {{count}} 年'
      },
      xYears: {
        one: '1 年',
        other: '{{count}} 年'
      },
      overXYears: {
        one: '超过 1 年',
        other: '超过 {{count}} 年'
      },
      almostXYears: {
        one: '将近 1 年',
        other: '将近 {{count}} 年'
      }
    };

    var formatDistance$k = function (token, count, options) {
      var result;
      var tokenValue = formatDistanceLocale$j[token];

      if (typeof tokenValue === 'string') {
        result = tokenValue;
      } else if (count === 1) {
        result = tokenValue.one;
      } else {
        result = tokenValue.other.replace('{{count}}', String(count));
      }

      if (options !== null && options !== void 0 && options.addSuffix) {
        if (options.comparison && options.comparison > 0) {
          return result + '内';
        } else {
          return result + '前';
        }
      }

      return result;
    };

    function buildFormatLongFn$1(args) {
      return function () {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}; // TODO: Remove String()

        var width = options.width ? String(options.width) : args.defaultWidth;
        var format = args.formats[width] || args.formats[args.defaultWidth];
        return format;
      };
    }

    var dateFormats$k = {
      full: "y'年'M'月'd'日' EEEE",
      long: "y'年'M'月'd'日'",
      medium: 'yyyy-MM-dd',
      short: 'yy-MM-dd'
    };
    var timeFormats$k = {
      full: 'zzzz a h:mm:ss',
      long: 'z a h:mm:ss',
      medium: 'a h:mm:ss',
      short: 'a h:mm'
    };
    var dateTimeFormats$k = {
      full: '{{date}} {{time}}',
      long: '{{date}} {{time}}',
      medium: '{{date}} {{time}}',
      short: '{{date}} {{time}}'
    };
    var formatLong$l = {
      date: buildFormatLongFn$1({
        formats: dateFormats$k,
        defaultWidth: 'full'
      }),
      time: buildFormatLongFn$1({
        formats: timeFormats$k,
        defaultWidth: 'full'
      }),
      dateTime: buildFormatLongFn$1({
        formats: dateTimeFormats$k,
        defaultWidth: 'full'
      })
    };

    function requiredArgs$1(required, args) {
      if (args.length < required) {
        throw new TypeError(required + ' argument' + (required > 1 ? 's' : '') + ' required, but only ' + args.length + ' present');
      }
    }

    /**
     * @name toDate
     * @category Common Helpers
     * @summary Convert the given argument to an instance of Date.
     *
     * @description
     * Convert the given argument to an instance of Date.
     *
     * If the argument is an instance of Date, the function returns its clone.
     *
     * If the argument is a number, it is treated as a timestamp.
     *
     * If the argument is none of the above, the function returns Invalid Date.
     *
     * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
     *
     * @param {Date|Number} argument - the value to convert
     * @returns {Date} the parsed date in the local time zone
     * @throws {TypeError} 1 argument required
     *
     * @example
     * // Clone the date:
     * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))
     * //=> Tue Feb 11 2014 11:30:30
     *
     * @example
     * // Convert the timestamp to date:
     * const result = toDate(1392098430000)
     * //=> Tue Feb 11 2014 11:30:30
     */

    function toDate$2(argument) {
      requiredArgs$1(1, arguments);
      var argStr = Object.prototype.toString.call(argument); // Clone the date

      if (argument instanceof Date || typeof argument === 'object' && argStr === '[object Date]') {
        // Prevent the date to lose the milliseconds when passed to new Date() in IE10
        return new Date(argument.getTime());
      } else if (typeof argument === 'number' || argStr === '[object Number]') {
        return new Date(argument);
      } else {
        if ((typeof argument === 'string' || argStr === '[object String]') && typeof console !== 'undefined') {
          // eslint-disable-next-line no-console
          console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments"); // eslint-disable-next-line no-console

          console.warn(new Error().stack);
        }

        return new Date(NaN);
      }
    }

    function toInteger$1(dirtyNumber) {
      if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
        return NaN;
      }

      var number = Number(dirtyNumber);

      if (isNaN(number)) {
        return number;
      }

      return number < 0 ? Math.ceil(number) : Math.floor(number);
    }

    var defaultOptions$2 = {};
    function getDefaultOptions$1() {
      return defaultOptions$2;
    }

    function startOfUTCWeek$1(dirtyDate, options) {
      var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;

      requiredArgs$1(1, arguments);
      var defaultOptions = getDefaultOptions$1();
      var weekStartsOn = toInteger$1((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

      if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
        throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
      }

      var date = toDate$2(dirtyDate);
      var day = date.getUTCDay();
      var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
      date.setUTCDate(date.getUTCDate() - diff);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }

    function isSameUTCWeek(dirtyDateLeft, dirtyDateRight, options) {
      requiredArgs$1(2, arguments);
      var dateLeftStartOfWeek = startOfUTCWeek$1(dirtyDateLeft, options);
      var dateRightStartOfWeek = startOfUTCWeek$1(dirtyDateRight, options);
      return dateLeftStartOfWeek.getTime() === dateRightStartOfWeek.getTime();
    }

    function checkWeek(date, baseDate, options) {
      var baseFormat = 'eeee p';

      if (isSameUTCWeek(date, baseDate, options)) {
        return baseFormat; // in same week
      } else if (date.getTime() > baseDate.getTime()) {
        return "'下个'" + baseFormat; // in next week
      }

      return "'上个'" + baseFormat; // in last week
    }

    var formatRelativeLocale$j = {
      lastWeek: checkWeek,
      // days before yesterday, maybe in this week or last week
      yesterday: "'昨天' p",
      today: "'今天' p",
      tomorrow: "'明天' p",
      nextWeek: checkWeek,
      // days after tomorrow, maybe in this week or next week
      other: 'PP p'
    };

    var formatRelative$k = function (token, date, baseDate, options) {
      var format = formatRelativeLocale$j[token];

      if (typeof format === 'function') {
        return format(date, baseDate, options);
      }

      return format;
    };

    function buildLocalizeFn$1(args) {
      return function (dirtyIndex, options) {
        var context = options !== null && options !== void 0 && options.context ? String(options.context) : 'standalone';
        var valuesArray;

        if (context === 'formatting' && args.formattingValues) {
          var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
          var width = options !== null && options !== void 0 && options.width ? String(options.width) : defaultWidth;
          valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
        } else {
          var _defaultWidth = args.defaultWidth;

          var _width = options !== null && options !== void 0 && options.width ? String(options.width) : args.defaultWidth;

          valuesArray = args.values[_width] || args.values[_defaultWidth];
        }

        var index = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex; // @ts-ignore: For some reason TypeScript just don't want to match it, no matter how hard we try. I challenge you to try to remove it!

        return valuesArray[index];
      };
    }

    var eraValues$j = {
      narrow: ['前', '公元'],
      abbreviated: ['前', '公元'],
      wide: ['公元前', '公元']
    };
    var quarterValues$j = {
      narrow: ['1', '2', '3', '4'],
      abbreviated: ['第一季', '第二季', '第三季', '第四季'],
      wide: ['第一季度', '第二季度', '第三季度', '第四季度']
    };
    var monthValues$j = {
      narrow: ['一', '二', '三', '四', '五', '六', '七', '八', '九', '十', '十一', '十二'],
      abbreviated: ['1月', '2月', '3月', '4月', '5月', '6月', '7月', '8月', '9月', '10月', '11月', '12月'],
      wide: ['一月', '二月', '三月', '四月', '五月', '六月', '七月', '八月', '九月', '十月', '十一月', '十二月']
    };
    var dayValues$j = {
      narrow: ['日', '一', '二', '三', '四', '五', '六'],
      short: ['日', '一', '二', '三', '四', '五', '六'],
      abbreviated: ['周日', '周一', '周二', '周三', '周四', '周五', '周六'],
      wide: ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六']
    };
    var dayPeriodValues$j = {
      narrow: {
        am: '上',
        pm: '下',
        midnight: '凌晨',
        noon: '午',
        morning: '早',
        afternoon: '下午',
        evening: '晚',
        night: '夜'
      },
      abbreviated: {
        am: '上午',
        pm: '下午',
        midnight: '凌晨',
        noon: '中午',
        morning: '早晨',
        afternoon: '中午',
        evening: '晚上',
        night: '夜间'
      },
      wide: {
        am: '上午',
        pm: '下午',
        midnight: '凌晨',
        noon: '中午',
        morning: '早晨',
        afternoon: '中午',
        evening: '晚上',
        night: '夜间'
      }
    };
    var formattingDayPeriodValues$e = {
      narrow: {
        am: '上',
        pm: '下',
        midnight: '凌晨',
        noon: '午',
        morning: '早',
        afternoon: '下午',
        evening: '晚',
        night: '夜'
      },
      abbreviated: {
        am: '上午',
        pm: '下午',
        midnight: '凌晨',
        noon: '中午',
        morning: '早晨',
        afternoon: '中午',
        evening: '晚上',
        night: '夜间'
      },
      wide: {
        am: '上午',
        pm: '下午',
        midnight: '凌晨',
        noon: '中午',
        morning: '早晨',
        afternoon: '中午',
        evening: '晚上',
        night: '夜间'
      }
    };

    var ordinalNumber$j = function (dirtyNumber, options) {
      var number = Number(dirtyNumber);

      switch (options === null || options === void 0 ? void 0 : options.unit) {
        case 'date':
          return number.toString() + '日';

        case 'hour':
          return number.toString() + '时';

        case 'minute':
          return number.toString() + '分';

        case 'second':
          return number.toString() + '秒';

        default:
          return '第 ' + number.toString();
      }
    };

    var localize$k = {
      ordinalNumber: ordinalNumber$j,
      era: buildLocalizeFn$1({
        values: eraValues$j,
        defaultWidth: 'wide'
      }),
      quarter: buildLocalizeFn$1({
        values: quarterValues$j,
        defaultWidth: 'wide',
        argumentCallback: function (quarter) {
          return quarter - 1;
        }
      }),
      month: buildLocalizeFn$1({
        values: monthValues$j,
        defaultWidth: 'wide'
      }),
      day: buildLocalizeFn$1({
        values: dayValues$j,
        defaultWidth: 'wide'
      }),
      dayPeriod: buildLocalizeFn$1({
        values: dayPeriodValues$j,
        defaultWidth: 'wide',
        formattingValues: formattingDayPeriodValues$e,
        defaultFormattingWidth: 'wide'
      })
    };

    function buildMatchFn$1(args) {
      return function (string) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var width = options.width;
        var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
        var matchResult = string.match(matchPattern);

        if (!matchResult) {
          return null;
        }

        var matchedString = matchResult[0];
        var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
        var key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, function (pattern) {
          return pattern.test(matchedString);
        }) : findKey(parsePatterns, function (pattern) {
          return pattern.test(matchedString);
        });
        var value;
        value = args.valueCallback ? args.valueCallback(key) : key;
        value = options.valueCallback ? options.valueCallback(value) : value;
        var rest = string.slice(matchedString.length);
        return {
          value: value,
          rest: rest
        };
      };
    }

    function findKey(object, predicate) {
      for (var key in object) {
        if (object.hasOwnProperty(key) && predicate(object[key])) {
          return key;
        }
      }

      return undefined;
    }

    function findIndex(array, predicate) {
      for (var key = 0; key < array.length; key++) {
        if (predicate(array[key])) {
          return key;
        }
      }

      return undefined;
    }

    function buildMatchPatternFn$1(args) {
      return function (string) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var matchResult = string.match(args.matchPattern);
        if (!matchResult) return null;
        var matchedString = matchResult[0];
        var parseResult = string.match(args.parsePattern);
        if (!parseResult) return null;
        var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
        value = options.valueCallback ? options.valueCallback(value) : value;
        var rest = string.slice(matchedString.length);
        return {
          value: value,
          rest: rest
        };
      };
    }

    var matchOrdinalNumberPattern$j = /^(第\s*)?\d+(日|时|分|秒)?/i;
    var parseOrdinalNumberPattern$j = /\d+/i;
    var matchEraPatterns$j = {
      narrow: /^(前)/i,
      abbreviated: /^(前)/i,
      wide: /^(公元前|公元)/i
    };
    var parseEraPatterns$j = {
      any: [/^(前)/i, /^(公元)/i]
    };
    var matchQuarterPatterns$j = {
      narrow: /^[1234]/i,
      abbreviated: /^第[一二三四]刻/i,
      wide: /^第[一二三四]刻钟/i
    };
    var parseQuarterPatterns$j = {
      any: [/(1|一)/i, /(2|二)/i, /(3|三)/i, /(4|四)/i]
    };
    var matchMonthPatterns$j = {
      narrow: /^(一|二|三|四|五|六|七|八|九|十[二一])/i,
      abbreviated: /^(一|二|三|四|五|六|七|八|九|十[二一]|\d|1[12])月/i,
      wide: /^(一|二|三|四|五|六|七|八|九|十[二一])月/i
    };
    var parseMonthPatterns$j = {
      narrow: [/^一/i, /^二/i, /^三/i, /^四/i, /^五/i, /^六/i, /^七/i, /^八/i, /^九/i, /^十(?!(一|二))/i, /^十一/i, /^十二/i],
      any: [/^一|1/i, /^二|2/i, /^三|3/i, /^四|4/i, /^五|5/i, /^六|6/i, /^七|7/i, /^八|8/i, /^九|9/i, /^十(?!(一|二))|10/i, /^十一|11/i, /^十二|12/i]
    };
    var matchDayPatterns$j = {
      narrow: /^[一二三四五六日]/i,
      short: /^[一二三四五六日]/i,
      abbreviated: /^周[一二三四五六日]/i,
      wide: /^星期[一二三四五六日]/i
    };
    var parseDayPatterns$j = {
      any: [/日/i, /一/i, /二/i, /三/i, /四/i, /五/i, /六/i]
    };
    var matchDayPeriodPatterns$j = {
      any: /^(上午?|下午?|午夜|[中正]午|早上?|下午|晚上?|凌晨|)/i
    };
    var parseDayPeriodPatterns$j = {
      any: {
        am: /^上午?/i,
        pm: /^下午?/i,
        midnight: /^午夜/i,
        noon: /^[中正]午/i,
        morning: /^早上/i,
        afternoon: /^下午/i,
        evening: /^晚上?/i,
        night: /^凌晨/i
      }
    };
    var match$k = {
      ordinalNumber: buildMatchPatternFn$1({
        matchPattern: matchOrdinalNumberPattern$j,
        parsePattern: parseOrdinalNumberPattern$j,
        valueCallback: function (value) {
          return parseInt(value, 10);
        }
      }),
      era: buildMatchFn$1({
        matchPatterns: matchEraPatterns$j,
        defaultMatchWidth: 'wide',
        parsePatterns: parseEraPatterns$j,
        defaultParseWidth: 'any'
      }),
      quarter: buildMatchFn$1({
        matchPatterns: matchQuarterPatterns$j,
        defaultMatchWidth: 'wide',
        parsePatterns: parseQuarterPatterns$j,
        defaultParseWidth: 'any',
        valueCallback: function (index) {
          return index + 1;
        }
      }),
      month: buildMatchFn$1({
        matchPatterns: matchMonthPatterns$j,
        defaultMatchWidth: 'wide',
        parsePatterns: parseMonthPatterns$j,
        defaultParseWidth: 'any'
      }),
      day: buildMatchFn$1({
        matchPatterns: matchDayPatterns$j,
        defaultMatchWidth: 'wide',
        parsePatterns: parseDayPatterns$j,
        defaultParseWidth: 'any'
      }),
      dayPeriod: buildMatchFn$1({
        matchPatterns: matchDayPeriodPatterns$j,
        defaultMatchWidth: 'any',
        parsePatterns: parseDayPeriodPatterns$j,
        defaultParseWidth: 'any'
      })
    };

    /**
     * @type {Locale}
     * @category Locales
     * @summary Chinese Simplified locale.
     * @language Chinese Simplified
     * @iso-639-2 zho
     * @author Changyu Geng [@KingMario]{@link https://github.com/KingMario}
     * @author Song Shuoyun [@fnlctrl]{@link https://github.com/fnlctrl}
     * @author sabrinaM [@sabrinamiao]{@link https://github.com/sabrinamiao}
     * @author Carney Wu [@cubicwork]{@link https://github.com/cubicwork}
     * @author Terrence Lam [@skyuplam]{@link https://github.com/skyuplam}
     */

    var locale$k = {
      code: 'zh-CN',
      formatDistance: formatDistance$k,
      formatLong: formatLong$l,
      formatRelative: formatRelative$k,
      localize: localize$k,
      match: match$k,
      options: {
        weekStartsOn: 1
        /* Monday */
        ,
        firstWeekContainsDate: 4
      }
    };

    const dateZhCN = {
      name: "zh-CN",
      locale: locale$k
    };
    var dateZhCN$1 = dateZhCN;

    var formatDistanceLocale$i = {
      lessThanXSeconds: {
        one: '少於 1 秒',
        other: '少於 {{count}} 秒'
      },
      xSeconds: {
        one: '1 秒',
        other: '{{count}} 秒'
      },
      halfAMinute: '半分鐘',
      lessThanXMinutes: {
        one: '少於 1 分鐘',
        other: '少於 {{count}} 分鐘'
      },
      xMinutes: {
        one: '1 分鐘',
        other: '{{count}} 分鐘'
      },
      xHours: {
        one: '1 小時',
        other: '{{count}} 小時'
      },
      aboutXHours: {
        one: '大約 1 小時',
        other: '大約 {{count}} 小時'
      },
      xDays: {
        one: '1 天',
        other: '{{count}} 天'
      },
      aboutXWeeks: {
        one: '大約 1 個星期',
        other: '大約 {{count}} 個星期'
      },
      xWeeks: {
        one: '1 個星期',
        other: '{{count}} 個星期'
      },
      aboutXMonths: {
        one: '大約 1 個月',
        other: '大約 {{count}} 個月'
      },
      xMonths: {
        one: '1 個月',
        other: '{{count}} 個月'
      },
      aboutXYears: {
        one: '大約 1 年',
        other: '大約 {{count}} 年'
      },
      xYears: {
        one: '1 年',
        other: '{{count}} 年'
      },
      overXYears: {
        one: '超過 1 年',
        other: '超過 {{count}} 年'
      },
      almostXYears: {
        one: '將近 1 年',
        other: '將近 {{count}} 年'
      }
    };

    var formatDistance$j = function (token, count, options) {
      var result;
      var tokenValue = formatDistanceLocale$i[token];

      if (typeof tokenValue === 'string') {
        result = tokenValue;
      } else if (count === 1) {
        result = tokenValue.one;
      } else {
        result = tokenValue.other.replace('{{count}}', String(count));
      }

      if (options !== null && options !== void 0 && options.addSuffix) {
        if (options.comparison && options.comparison > 0) {
          return result + '內';
        } else {
          return result + '前';
        }
      }

      return result;
    };

    var dateFormats$j = {
      full: "y'年'M'月'd'日' EEEE",
      long: "y'年'M'月'd'日'",
      medium: 'yyyy-MM-dd',
      short: 'yy-MM-dd'
    };
    var timeFormats$j = {
      full: 'zzzz a h:mm:ss',
      long: 'z a h:mm:ss',
      medium: 'a h:mm:ss',
      short: 'a h:mm'
    };
    var dateTimeFormats$j = {
      full: '{{date}} {{time}}',
      long: '{{date}} {{time}}',
      medium: '{{date}} {{time}}',
      short: '{{date}} {{time}}'
    };
    var formatLong$k = {
      date: buildFormatLongFn$1({
        formats: dateFormats$j,
        defaultWidth: 'full'
      }),
      time: buildFormatLongFn$1({
        formats: timeFormats$j,
        defaultWidth: 'full'
      }),
      dateTime: buildFormatLongFn$1({
        formats: dateTimeFormats$j,
        defaultWidth: 'full'
      })
    };

    var formatRelativeLocale$i = {
      lastWeek: "'上個'eeee p",
      yesterday: "'昨天' p",
      today: "'今天' p",
      tomorrow: "'明天' p",
      nextWeek: "'下個'eeee p",
      other: 'P'
    };

    var formatRelative$j = function (token, _date, _baseDate, _options) {
      return formatRelativeLocale$i[token];
    };

    var eraValues$i = {
      narrow: ['前', '公元'],
      abbreviated: ['前', '公元'],
      wide: ['公元前', '公元']
    };
    var quarterValues$i = {
      narrow: ['1', '2', '3', '4'],
      abbreviated: ['第一刻', '第二刻', '第三刻', '第四刻'],
      wide: ['第一刻鐘', '第二刻鐘', '第三刻鐘', '第四刻鐘']
    };
    var monthValues$i = {
      narrow: ['一', '二', '三', '四', '五', '六', '七', '八', '九', '十', '十一', '十二'],
      abbreviated: ['1月', '2月', '3月', '4月', '5月', '6月', '7月', '8月', '9月', '10月', '11月', '12月'],
      wide: ['一月', '二月', '三月', '四月', '五月', '六月', '七月', '八月', '九月', '十月', '十一月', '十二月']
    };
    var dayValues$i = {
      narrow: ['日', '一', '二', '三', '四', '五', '六'],
      short: ['日', '一', '二', '三', '四', '五', '六'],
      abbreviated: ['週日', '週一', '週二', '週三', '週四', '週五', '週六'],
      wide: ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六']
    };
    var dayPeriodValues$i = {
      narrow: {
        am: '上',
        pm: '下',
        midnight: '凌晨',
        noon: '午',
        morning: '早',
        afternoon: '下午',
        evening: '晚',
        night: '夜'
      },
      abbreviated: {
        am: '上午',
        pm: '下午',
        midnight: '凌晨',
        noon: '中午',
        morning: '早晨',
        afternoon: '中午',
        evening: '晚上',
        night: '夜間'
      },
      wide: {
        am: '上午',
        pm: '下午',
        midnight: '凌晨',
        noon: '中午',
        morning: '早晨',
        afternoon: '中午',
        evening: '晚上',
        night: '夜間'
      }
    };
    var formattingDayPeriodValues$d = {
      narrow: {
        am: '上',
        pm: '下',
        midnight: '凌晨',
        noon: '午',
        morning: '早',
        afternoon: '下午',
        evening: '晚',
        night: '夜'
      },
      abbreviated: {
        am: '上午',
        pm: '下午',
        midnight: '凌晨',
        noon: '中午',
        morning: '早晨',
        afternoon: '中午',
        evening: '晚上',
        night: '夜間'
      },
      wide: {
        am: '上午',
        pm: '下午',
        midnight: '凌晨',
        noon: '中午',
        morning: '早晨',
        afternoon: '中午',
        evening: '晚上',
        night: '夜間'
      }
    };

    var ordinalNumber$i = function (dirtyNumber, options) {
      var number = Number(dirtyNumber);

      switch (options === null || options === void 0 ? void 0 : options.unit) {
        case 'date':
          return number + '日';

        case 'hour':
          return number + '時';

        case 'minute':
          return number + '分';

        case 'second':
          return number + '秒';

        default:
          return '第 ' + number;
      }
    };

    var localize$j = {
      ordinalNumber: ordinalNumber$i,
      era: buildLocalizeFn$1({
        values: eraValues$i,
        defaultWidth: 'wide'
      }),
      quarter: buildLocalizeFn$1({
        values: quarterValues$i,
        defaultWidth: 'wide',
        argumentCallback: function (quarter) {
          return quarter - 1;
        }
      }),
      month: buildLocalizeFn$1({
        values: monthValues$i,
        defaultWidth: 'wide'
      }),
      day: buildLocalizeFn$1({
        values: dayValues$i,
        defaultWidth: 'wide'
      }),
      dayPeriod: buildLocalizeFn$1({
        values: dayPeriodValues$i,
        defaultWidth: 'wide',
        formattingValues: formattingDayPeriodValues$d,
        defaultFormattingWidth: 'wide'
      })
    };

    var matchOrdinalNumberPattern$i = /^(第\s*)?\d+(日|時|分|秒)?/i;
    var parseOrdinalNumberPattern$i = /\d+/i;
    var matchEraPatterns$i = {
      narrow: /^(前)/i,
      abbreviated: /^(前)/i,
      wide: /^(公元前|公元)/i
    };
    var parseEraPatterns$i = {
      any: [/^(前)/i, /^(公元)/i]
    };
    var matchQuarterPatterns$i = {
      narrow: /^[1234]/i,
      abbreviated: /^第[一二三四]刻/i,
      wide: /^第[一二三四]刻鐘/i
    };
    var parseQuarterPatterns$i = {
      any: [/(1|一)/i, /(2|二)/i, /(3|三)/i, /(4|四)/i]
    };
    var matchMonthPatterns$i = {
      narrow: /^(一|二|三|四|五|六|七|八|九|十[二一])/i,
      abbreviated: /^(一|二|三|四|五|六|七|八|九|十[二一]|\d|1[12])月/i,
      wide: /^(一|二|三|四|五|六|七|八|九|十[二一])月/i
    };
    var parseMonthPatterns$i = {
      narrow: [/^一/i, /^二/i, /^三/i, /^四/i, /^五/i, /^六/i, /^七/i, /^八/i, /^九/i, /^十(?!(一|二))/i, /^十一/i, /^十二/i],
      any: [/^一|1/i, /^二|2/i, /^三|3/i, /^四|4/i, /^五|5/i, /^六|6/i, /^七|7/i, /^八|8/i, /^九|9/i, /^十(?!(一|二))|10/i, /^十一|11/i, /^十二|12/i]
    };
    var matchDayPatterns$i = {
      narrow: /^[一二三四五六日]/i,
      short: /^[一二三四五六日]/i,
      abbreviated: /^週[一二三四五六日]/i,
      wide: /^星期[一二三四五六日]/i
    };
    var parseDayPatterns$i = {
      any: [/日/i, /一/i, /二/i, /三/i, /四/i, /五/i, /六/i]
    };
    var matchDayPeriodPatterns$i = {
      any: /^(上午?|下午?|午夜|[中正]午|早上?|下午|晚上?|凌晨)/i
    };
    var parseDayPeriodPatterns$i = {
      any: {
        am: /^上午?/i,
        pm: /^下午?/i,
        midnight: /^午夜/i,
        noon: /^[中正]午/i,
        morning: /^早上/i,
        afternoon: /^下午/i,
        evening: /^晚上?/i,
        night: /^凌晨/i
      }
    };
    var match$j = {
      ordinalNumber: buildMatchPatternFn$1({
        matchPattern: matchOrdinalNumberPattern$i,
        parsePattern: parseOrdinalNumberPattern$i,
        valueCallback: function (value) {
          return parseInt(value, 10);
        }
      }),
      era: buildMatchFn$1({
        matchPatterns: matchEraPatterns$i,
        defaultMatchWidth: 'wide',
        parsePatterns: parseEraPatterns$i,
        defaultParseWidth: 'any'
      }),
      quarter: buildMatchFn$1({
        matchPatterns: matchQuarterPatterns$i,
        defaultMatchWidth: 'wide',
        parsePatterns: parseQuarterPatterns$i,
        defaultParseWidth: 'any',
        valueCallback: function (index) {
          return index + 1;
        }
      }),
      month: buildMatchFn$1({
        matchPatterns: matchMonthPatterns$i,
        defaultMatchWidth: 'wide',
        parsePatterns: parseMonthPatterns$i,
        defaultParseWidth: 'any'
      }),
      day: buildMatchFn$1({
        matchPatterns: matchDayPatterns$i,
        defaultMatchWidth: 'wide',
        parsePatterns: parseDayPatterns$i,
        defaultParseWidth: 'any'
      }),
      dayPeriod: buildMatchFn$1({
        matchPatterns: matchDayPeriodPatterns$i,
        defaultMatchWidth: 'any',
        parsePatterns: parseDayPeriodPatterns$i,
        defaultParseWidth: 'any'
      })
    };

    /**
     * @type {Locale}
     * @category Locales
     * @summary Chinese Traditional locale.
     * @language Chinese Traditional
     * @iso-639-2 zho
     * @author tonypai [@tpai]{@link https://github.com/tpai}
     * @author Jack Hsu [@jackhsu978]{@link https://github.com/jackhsu978}
     * @author Terrence Lam [@skyuplam]{@link https://github.com/skyuplam}
     */

    var locale$j = {
      code: 'zh-TW',
      formatDistance: formatDistance$j,
      formatLong: formatLong$k,
      formatRelative: formatRelative$j,
      localize: localize$j,
      match: match$j,
      options: {
        weekStartsOn: 1
        /* Monday */
        ,
        firstWeekContainsDate: 4
      }
    };

    const datezhTW = {
      name: "zh-TW",
      locale: locale$j
    };
    var datezhTW$1 = datezhTW;

    var formatDistanceLocale$h = {
      lessThanXSeconds: {
        one: 'less than a second',
        other: 'less than {{count}} seconds'
      },
      xSeconds: {
        one: '1 second',
        other: '{{count}} seconds'
      },
      halfAMinute: 'half a minute',
      lessThanXMinutes: {
        one: 'less than a minute',
        other: 'less than {{count}} minutes'
      },
      xMinutes: {
        one: '1 minute',
        other: '{{count}} minutes'
      },
      aboutXHours: {
        one: 'about 1 hour',
        other: 'about {{count}} hours'
      },
      xHours: {
        one: '1 hour',
        other: '{{count}} hours'
      },
      xDays: {
        one: '1 day',
        other: '{{count}} days'
      },
      aboutXWeeks: {
        one: 'about 1 week',
        other: 'about {{count}} weeks'
      },
      xWeeks: {
        one: '1 week',
        other: '{{count}} weeks'
      },
      aboutXMonths: {
        one: 'about 1 month',
        other: 'about {{count}} months'
      },
      xMonths: {
        one: '1 month',
        other: '{{count}} months'
      },
      aboutXYears: {
        one: 'about 1 year',
        other: 'about {{count}} years'
      },
      xYears: {
        one: '1 year',
        other: '{{count}} years'
      },
      overXYears: {
        one: 'over 1 year',
        other: 'over {{count}} years'
      },
      almostXYears: {
        one: 'almost 1 year',
        other: 'almost {{count}} years'
      }
    };

    var formatDistance$i = function (token, count, options) {
      var result;
      var tokenValue = formatDistanceLocale$h[token];

      if (typeof tokenValue === 'string') {
        result = tokenValue;
      } else if (count === 1) {
        result = tokenValue.one;
      } else {
        result = tokenValue.other.replace('{{count}}', count.toString());
      }

      if (options !== null && options !== void 0 && options.addSuffix) {
        if (options.comparison && options.comparison > 0) {
          return 'in ' + result;
        } else {
          return result + ' ago';
        }
      }

      return result;
    };

    var dateFormats$i = {
      full: 'EEEE, MMMM do, y',
      long: 'MMMM do, y',
      medium: 'MMM d, y',
      short: 'MM/dd/yyyy'
    };
    var timeFormats$i = {
      full: 'h:mm:ss a zzzz',
      long: 'h:mm:ss a z',
      medium: 'h:mm:ss a',
      short: 'h:mm a'
    };
    var dateTimeFormats$i = {
      full: "{{date}} 'at' {{time}}",
      long: "{{date}} 'at' {{time}}",
      medium: '{{date}}, {{time}}',
      short: '{{date}}, {{time}}'
    };
    var formatLong$j = {
      date: buildFormatLongFn$1({
        formats: dateFormats$i,
        defaultWidth: 'full'
      }),
      time: buildFormatLongFn$1({
        formats: timeFormats$i,
        defaultWidth: 'full'
      }),
      dateTime: buildFormatLongFn$1({
        formats: dateTimeFormats$i,
        defaultWidth: 'full'
      })
    };

    var formatRelativeLocale$h = {
      lastWeek: "'last' eeee 'at' p",
      yesterday: "'yesterday at' p",
      today: "'today at' p",
      tomorrow: "'tomorrow at' p",
      nextWeek: "eeee 'at' p",
      other: 'P'
    };

    var formatRelative$i = function (token, _date, _baseDate, _options) {
      return formatRelativeLocale$h[token];
    };

    var eraValues$h = {
      narrow: ['B', 'A'],
      abbreviated: ['BC', 'AD'],
      wide: ['Before Christ', 'Anno Domini']
    };
    var quarterValues$h = {
      narrow: ['1', '2', '3', '4'],
      abbreviated: ['Q1', 'Q2', 'Q3', 'Q4'],
      wide: ['1st quarter', '2nd quarter', '3rd quarter', '4th quarter']
    }; // Note: in English, the names of days of the week and months are capitalized.
    // If you are making a new locale based on this one, check if the same is true for the language you're working on.
    // Generally, formatted dates should look like they are in the middle of a sentence,
    // e.g. in Spanish language the weekdays and months should be in the lowercase.

    var monthValues$h = {
      narrow: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
      abbreviated: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
      wide: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
    };
    var dayValues$h = {
      narrow: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
      short: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
      abbreviated: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
      wide: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
    };
    var dayPeriodValues$h = {
      narrow: {
        am: 'a',
        pm: 'p',
        midnight: 'mi',
        noon: 'n',
        morning: 'morning',
        afternoon: 'afternoon',
        evening: 'evening',
        night: 'night'
      },
      abbreviated: {
        am: 'AM',
        pm: 'PM',
        midnight: 'midnight',
        noon: 'noon',
        morning: 'morning',
        afternoon: 'afternoon',
        evening: 'evening',
        night: 'night'
      },
      wide: {
        am: 'a.m.',
        pm: 'p.m.',
        midnight: 'midnight',
        noon: 'noon',
        morning: 'morning',
        afternoon: 'afternoon',
        evening: 'evening',
        night: 'night'
      }
    };
    var formattingDayPeriodValues$c = {
      narrow: {
        am: 'a',
        pm: 'p',
        midnight: 'mi',
        noon: 'n',
        morning: 'in the morning',
        afternoon: 'in the afternoon',
        evening: 'in the evening',
        night: 'at night'
      },
      abbreviated: {
        am: 'AM',
        pm: 'PM',
        midnight: 'midnight',
        noon: 'noon',
        morning: 'in the morning',
        afternoon: 'in the afternoon',
        evening: 'in the evening',
        night: 'at night'
      },
      wide: {
        am: 'a.m.',
        pm: 'p.m.',
        midnight: 'midnight',
        noon: 'noon',
        morning: 'in the morning',
        afternoon: 'in the afternoon',
        evening: 'in the evening',
        night: 'at night'
      }
    };

    var ordinalNumber$h = function (dirtyNumber, _options) {
      var number = Number(dirtyNumber); // If ordinal numbers depend on context, for example,
      // if they are different for different grammatical genders,
      // use `options.unit`.
      //
      // `unit` can be 'year', 'quarter', 'month', 'week', 'date', 'dayOfYear',
      // 'day', 'hour', 'minute', 'second'.

      var rem100 = number % 100;

      if (rem100 > 20 || rem100 < 10) {
        switch (rem100 % 10) {
          case 1:
            return number + 'st';

          case 2:
            return number + 'nd';

          case 3:
            return number + 'rd';
        }
      }

      return number + 'th';
    };

    var localize$i = {
      ordinalNumber: ordinalNumber$h,
      era: buildLocalizeFn$1({
        values: eraValues$h,
        defaultWidth: 'wide'
      }),
      quarter: buildLocalizeFn$1({
        values: quarterValues$h,
        defaultWidth: 'wide',
        argumentCallback: function (quarter) {
          return quarter - 1;
        }
      }),
      month: buildLocalizeFn$1({
        values: monthValues$h,
        defaultWidth: 'wide'
      }),
      day: buildLocalizeFn$1({
        values: dayValues$h,
        defaultWidth: 'wide'
      }),
      dayPeriod: buildLocalizeFn$1({
        values: dayPeriodValues$h,
        defaultWidth: 'wide',
        formattingValues: formattingDayPeriodValues$c,
        defaultFormattingWidth: 'wide'
      })
    };

    var matchOrdinalNumberPattern$h = /^(\d+)(th|st|nd|rd)?/i;
    var parseOrdinalNumberPattern$h = /\d+/i;
    var matchEraPatterns$h = {
      narrow: /^(b|a)/i,
      abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
      wide: /^(before christ|before common era|anno domini|common era)/i
    };
    var parseEraPatterns$h = {
      any: [/^b/i, /^(a|c)/i]
    };
    var matchQuarterPatterns$h = {
      narrow: /^[1234]/i,
      abbreviated: /^q[1234]/i,
      wide: /^[1234](th|st|nd|rd)? quarter/i
    };
    var parseQuarterPatterns$h = {
      any: [/1/i, /2/i, /3/i, /4/i]
    };
    var matchMonthPatterns$h = {
      narrow: /^[jfmasond]/i,
      abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
      wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
    };
    var parseMonthPatterns$h = {
      narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
      any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
    };
    var matchDayPatterns$h = {
      narrow: /^[smtwf]/i,
      short: /^(su|mo|tu|we|th|fr|sa)/i,
      abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
      wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
    };
    var parseDayPatterns$h = {
      narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
      any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
    };
    var matchDayPeriodPatterns$h = {
      narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
      any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
    };
    var parseDayPeriodPatterns$h = {
      any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^mi/i,
        noon: /^no/i,
        morning: /morning/i,
        afternoon: /afternoon/i,
        evening: /evening/i,
        night: /night/i
      }
    };
    var match$i = {
      ordinalNumber: buildMatchPatternFn$1({
        matchPattern: matchOrdinalNumberPattern$h,
        parsePattern: parseOrdinalNumberPattern$h,
        valueCallback: function (value) {
          return parseInt(value, 10);
        }
      }),
      era: buildMatchFn$1({
        matchPatterns: matchEraPatterns$h,
        defaultMatchWidth: 'wide',
        parsePatterns: parseEraPatterns$h,
        defaultParseWidth: 'any'
      }),
      quarter: buildMatchFn$1({
        matchPatterns: matchQuarterPatterns$h,
        defaultMatchWidth: 'wide',
        parsePatterns: parseQuarterPatterns$h,
        defaultParseWidth: 'any',
        valueCallback: function (index) {
          return index + 1;
        }
      }),
      month: buildMatchFn$1({
        matchPatterns: matchMonthPatterns$h,
        defaultMatchWidth: 'wide',
        parsePatterns: parseMonthPatterns$h,
        defaultParseWidth: 'any'
      }),
      day: buildMatchFn$1({
        matchPatterns: matchDayPatterns$h,
        defaultMatchWidth: 'wide',
        parsePatterns: parseDayPatterns$h,
        defaultParseWidth: 'any'
      }),
      dayPeriod: buildMatchFn$1({
        matchPatterns: matchDayPeriodPatterns$h,
        defaultMatchWidth: 'any',
        parsePatterns: parseDayPeriodPatterns$h,
        defaultParseWidth: 'any'
      })
    };

    /**
     * @type {Locale}
     * @category Locales
     * @summary English locale (United States).
     * @language English
     * @iso-639-2 eng
     * @author Sasha Koss [@kossnocorp]{@link https://github.com/kossnocorp}
     * @author Lesha Koss [@leshakoss]{@link https://github.com/leshakoss}
     */

    var locale$i = {
      code: 'en-US',
      formatDistance: formatDistance$i,
      formatLong: formatLong$j,
      formatRelative: formatRelative$i,
      localize: localize$i,
      match: match$i,
      options: {
        weekStartsOn: 0
        /* Sunday */
        ,
        firstWeekContainsDate: 1
      }
    };
    var defaultLocale$1 = locale$i;

    const dateEnUs = {
      name: "en-US",
      locale: defaultLocale$1
    };
    var dateEnUS = dateEnUs;

    function declension$3(scheme, count) {
      // scheme for count=1 exists
      if (scheme.one !== undefined && count === 1) {
        return scheme.one;
      }

      var rem10 = count % 10;
      var rem100 = count % 100; // 1, 21, 31, ...

      if (rem10 === 1 && rem100 !== 11) {
        return scheme.singularNominative.replace('{{count}}', String(count)); // 2, 3, 4, 22, 23, 24, 32 ...
      } else if (rem10 >= 2 && rem10 <= 4 && (rem100 < 10 || rem100 > 20)) {
        return scheme.singularGenitive.replace('{{count}}', String(count)); // 5, 6, 7, 8, 9, 10, 11, ...
      } else {
        return scheme.pluralGenitive.replace('{{count}}', String(count));
      }
    }

    function buildLocalizeTokenFn$1(scheme) {
      return function (count, options) {
        if (options !== null && options !== void 0 && options.addSuffix) {
          if (options.comparison && options.comparison > 0) {
            if (scheme.future) {
              return declension$3(scheme.future, count);
            } else {
              return 'через ' + declension$3(scheme.regular, count);
            }
          } else {
            if (scheme.past) {
              return declension$3(scheme.past, count);
            } else {
              return declension$3(scheme.regular, count) + ' назад';
            }
          }
        } else {
          return declension$3(scheme.regular, count);
        }
      };
    }

    var formatDistanceLocale$g = {
      lessThanXSeconds: buildLocalizeTokenFn$1({
        regular: {
          one: 'меньше секунды',
          singularNominative: 'меньше {{count}} секунды',
          singularGenitive: 'меньше {{count}} секунд',
          pluralGenitive: 'меньше {{count}} секунд'
        },
        future: {
          one: 'меньше, чем через секунду',
          singularNominative: 'меньше, чем через {{count}} секунду',
          singularGenitive: 'меньше, чем через {{count}} секунды',
          pluralGenitive: 'меньше, чем через {{count}} секунд'
        }
      }),
      xSeconds: buildLocalizeTokenFn$1({
        regular: {
          singularNominative: '{{count}} секунда',
          singularGenitive: '{{count}} секунды',
          pluralGenitive: '{{count}} секунд'
        },
        past: {
          singularNominative: '{{count}} секунду назад',
          singularGenitive: '{{count}} секунды назад',
          pluralGenitive: '{{count}} секунд назад'
        },
        future: {
          singularNominative: 'через {{count}} секунду',
          singularGenitive: 'через {{count}} секунды',
          pluralGenitive: 'через {{count}} секунд'
        }
      }),
      halfAMinute: function (_count, options) {
        if (options !== null && options !== void 0 && options.addSuffix) {
          if (options.comparison && options.comparison > 0) {
            return 'через полминуты';
          } else {
            return 'полминуты назад';
          }
        }

        return 'полминуты';
      },
      lessThanXMinutes: buildLocalizeTokenFn$1({
        regular: {
          one: 'меньше минуты',
          singularNominative: 'меньше {{count}} минуты',
          singularGenitive: 'меньше {{count}} минут',
          pluralGenitive: 'меньше {{count}} минут'
        },
        future: {
          one: 'меньше, чем через минуту',
          singularNominative: 'меньше, чем через {{count}} минуту',
          singularGenitive: 'меньше, чем через {{count}} минуты',
          pluralGenitive: 'меньше, чем через {{count}} минут'
        }
      }),
      xMinutes: buildLocalizeTokenFn$1({
        regular: {
          singularNominative: '{{count}} минута',
          singularGenitive: '{{count}} минуты',
          pluralGenitive: '{{count}} минут'
        },
        past: {
          singularNominative: '{{count}} минуту назад',
          singularGenitive: '{{count}} минуты назад',
          pluralGenitive: '{{count}} минут назад'
        },
        future: {
          singularNominative: 'через {{count}} минуту',
          singularGenitive: 'через {{count}} минуты',
          pluralGenitive: 'через {{count}} минут'
        }
      }),
      aboutXHours: buildLocalizeTokenFn$1({
        regular: {
          singularNominative: 'около {{count}} часа',
          singularGenitive: 'около {{count}} часов',
          pluralGenitive: 'около {{count}} часов'
        },
        future: {
          singularNominative: 'приблизительно через {{count}} час',
          singularGenitive: 'приблизительно через {{count}} часа',
          pluralGenitive: 'приблизительно через {{count}} часов'
        }
      }),
      xHours: buildLocalizeTokenFn$1({
        regular: {
          singularNominative: '{{count}} час',
          singularGenitive: '{{count}} часа',
          pluralGenitive: '{{count}} часов'
        }
      }),
      xDays: buildLocalizeTokenFn$1({
        regular: {
          singularNominative: '{{count}} день',
          singularGenitive: '{{count}} дня',
          pluralGenitive: '{{count}} дней'
        }
      }),
      aboutXWeeks: buildLocalizeTokenFn$1({
        regular: {
          singularNominative: 'около {{count}} недели',
          singularGenitive: 'около {{count}} недель',
          pluralGenitive: 'около {{count}} недель'
        },
        future: {
          singularNominative: 'приблизительно через {{count}} неделю',
          singularGenitive: 'приблизительно через {{count}} недели',
          pluralGenitive: 'приблизительно через {{count}} недель'
        }
      }),
      xWeeks: buildLocalizeTokenFn$1({
        regular: {
          singularNominative: '{{count}} неделя',
          singularGenitive: '{{count}} недели',
          pluralGenitive: '{{count}} недель'
        }
      }),
      aboutXMonths: buildLocalizeTokenFn$1({
        regular: {
          singularNominative: 'около {{count}} месяца',
          singularGenitive: 'около {{count}} месяцев',
          pluralGenitive: 'около {{count}} месяцев'
        },
        future: {
          singularNominative: 'приблизительно через {{count}} месяц',
          singularGenitive: 'приблизительно через {{count}} месяца',
          pluralGenitive: 'приблизительно через {{count}} месяцев'
        }
      }),
      xMonths: buildLocalizeTokenFn$1({
        regular: {
          singularNominative: '{{count}} месяц',
          singularGenitive: '{{count}} месяца',
          pluralGenitive: '{{count}} месяцев'
        }
      }),
      aboutXYears: buildLocalizeTokenFn$1({
        regular: {
          singularNominative: 'около {{count}} года',
          singularGenitive: 'около {{count}} лет',
          pluralGenitive: 'около {{count}} лет'
        },
        future: {
          singularNominative: 'приблизительно через {{count}} год',
          singularGenitive: 'приблизительно через {{count}} года',
          pluralGenitive: 'приблизительно через {{count}} лет'
        }
      }),
      xYears: buildLocalizeTokenFn$1({
        regular: {
          singularNominative: '{{count}} год',
          singularGenitive: '{{count}} года',
          pluralGenitive: '{{count}} лет'
        }
      }),
      overXYears: buildLocalizeTokenFn$1({
        regular: {
          singularNominative: 'больше {{count}} года',
          singularGenitive: 'больше {{count}} лет',
          pluralGenitive: 'больше {{count}} лет'
        },
        future: {
          singularNominative: 'больше, чем через {{count}} год',
          singularGenitive: 'больше, чем через {{count}} года',
          pluralGenitive: 'больше, чем через {{count}} лет'
        }
      }),
      almostXYears: buildLocalizeTokenFn$1({
        regular: {
          singularNominative: 'почти {{count}} год',
          singularGenitive: 'почти {{count}} года',
          pluralGenitive: 'почти {{count}} лет'
        },
        future: {
          singularNominative: 'почти через {{count}} год',
          singularGenitive: 'почти через {{count}} года',
          pluralGenitive: 'почти через {{count}} лет'
        }
      })
    };

    var formatDistance$h = function (token, count, options) {
      return formatDistanceLocale$g[token](count, options);
    };

    var dateFormats$h = {
      full: "EEEE, d MMMM y 'г.'",
      long: "d MMMM y 'г.'",
      medium: "d MMM y 'г.'",
      short: 'dd.MM.y'
    };
    var timeFormats$h = {
      full: 'H:mm:ss zzzz',
      long: 'H:mm:ss z',
      medium: 'H:mm:ss',
      short: 'H:mm'
    };
    var dateTimeFormats$h = {
      any: '{{date}}, {{time}}'
    };
    var formatLong$i = {
      date: buildFormatLongFn$1({
        formats: dateFormats$h,
        defaultWidth: 'full'
      }),
      time: buildFormatLongFn$1({
        formats: timeFormats$h,
        defaultWidth: 'full'
      }),
      dateTime: buildFormatLongFn$1({
        formats: dateTimeFormats$h,
        defaultWidth: 'any'
      })
    };

    var accusativeWeekdays$2 = ['воскресенье', 'понедельник', 'вторник', 'среду', 'четверг', 'пятницу', 'субботу'];

    function lastWeek$3(day) {
      var weekday = accusativeWeekdays$2[day];

      switch (day) {
        case 0:
          return "'в прошлое " + weekday + " в' p";

        case 1:
        case 2:
        case 4:
          return "'в прошлый " + weekday + " в' p";

        case 3:
        case 5:
        case 6:
          return "'в прошлую " + weekday + " в' p";
      }
    }

    function thisWeek$3(day) {
      var weekday = accusativeWeekdays$2[day];

      if (day === 2
      /* Tue */
      ) {
        return "'во " + weekday + " в' p";
      } else {
        return "'в " + weekday + " в' p";
      }
    }

    function nextWeek$3(day) {
      var weekday = accusativeWeekdays$2[day];

      switch (day) {
        case 0:
          return "'в следующее " + weekday + " в' p";

        case 1:
        case 2:
        case 4:
          return "'в следующий " + weekday + " в' p";

        case 3:
        case 5:
        case 6:
          return "'в следующую " + weekday + " в' p";
      }
    }

    var formatRelativeLocale$g = {
      lastWeek: function (date, baseDate, options) {
        var day = date.getUTCDay();

        if (isSameUTCWeek(date, baseDate, options)) {
          return thisWeek$3(day);
        } else {
          return lastWeek$3(day);
        }
      },
      yesterday: "'вчера в' p",
      today: "'сегодня в' p",
      tomorrow: "'завтра в' p",
      nextWeek: function (date, baseDate, options) {
        var day = date.getUTCDay();

        if (isSameUTCWeek(date, baseDate, options)) {
          return thisWeek$3(day);
        } else {
          return nextWeek$3(day);
        }
      },
      other: 'P'
    };

    var formatRelative$h = function (token, date, baseDate, options) {
      var format = formatRelativeLocale$g[token];

      if (typeof format === 'function') {
        return format(date, baseDate, options);
      }

      return format;
    };

    var eraValues$g = {
      narrow: ['до н.э.', 'н.э.'],
      abbreviated: ['до н. э.', 'н. э.'],
      wide: ['до нашей эры', 'нашей эры']
    };
    var quarterValues$g = {
      narrow: ['1', '2', '3', '4'],
      abbreviated: ['1-й кв.', '2-й кв.', '3-й кв.', '4-й кв.'],
      wide: ['1-й квартал', '2-й квартал', '3-й квартал', '4-й квартал']
    };
    var monthValues$g = {
      narrow: ['Я', 'Ф', 'М', 'А', 'М', 'И', 'И', 'А', 'С', 'О', 'Н', 'Д'],
      abbreviated: ['янв.', 'фев.', 'март', 'апр.', 'май', 'июнь', 'июль', 'авг.', 'сент.', 'окт.', 'нояб.', 'дек.'],
      wide: ['январь', 'февраль', 'март', 'апрель', 'май', 'июнь', 'июль', 'август', 'сентябрь', 'октябрь', 'ноябрь', 'декабрь']
    };
    var formattingMonthValues$4 = {
      narrow: ['Я', 'Ф', 'М', 'А', 'М', 'И', 'И', 'А', 'С', 'О', 'Н', 'Д'],
      abbreviated: ['янв.', 'фев.', 'мар.', 'апр.', 'мая', 'июн.', 'июл.', 'авг.', 'сент.', 'окт.', 'нояб.', 'дек.'],
      wide: ['января', 'февраля', 'марта', 'апреля', 'мая', 'июня', 'июля', 'августа', 'сентября', 'октября', 'ноября', 'декабря']
    };
    var dayValues$g = {
      narrow: ['В', 'П', 'В', 'С', 'Ч', 'П', 'С'],
      short: ['вс', 'пн', 'вт', 'ср', 'чт', 'пт', 'сб'],
      abbreviated: ['вск', 'пнд', 'втр', 'срд', 'чтв', 'птн', 'суб'],
      wide: ['воскресенье', 'понедельник', 'вторник', 'среда', 'четверг', 'пятница', 'суббота']
    };
    var dayPeriodValues$g = {
      narrow: {
        am: 'ДП',
        pm: 'ПП',
        midnight: 'полн.',
        noon: 'полд.',
        morning: 'утро',
        afternoon: 'день',
        evening: 'веч.',
        night: 'ночь'
      },
      abbreviated: {
        am: 'ДП',
        pm: 'ПП',
        midnight: 'полн.',
        noon: 'полд.',
        morning: 'утро',
        afternoon: 'день',
        evening: 'веч.',
        night: 'ночь'
      },
      wide: {
        am: 'ДП',
        pm: 'ПП',
        midnight: 'полночь',
        noon: 'полдень',
        morning: 'утро',
        afternoon: 'день',
        evening: 'вечер',
        night: 'ночь'
      }
    };
    var formattingDayPeriodValues$b = {
      narrow: {
        am: 'ДП',
        pm: 'ПП',
        midnight: 'полн.',
        noon: 'полд.',
        morning: 'утра',
        afternoon: 'дня',
        evening: 'веч.',
        night: 'ночи'
      },
      abbreviated: {
        am: 'ДП',
        pm: 'ПП',
        midnight: 'полн.',
        noon: 'полд.',
        morning: 'утра',
        afternoon: 'дня',
        evening: 'веч.',
        night: 'ночи'
      },
      wide: {
        am: 'ДП',
        pm: 'ПП',
        midnight: 'полночь',
        noon: 'полдень',
        morning: 'утра',
        afternoon: 'дня',
        evening: 'вечера',
        night: 'ночи'
      }
    };

    var ordinalNumber$g = function (dirtyNumber, options) {
      var number = Number(dirtyNumber);
      var unit = options === null || options === void 0 ? void 0 : options.unit;
      var suffix;

      if (unit === 'date') {
        suffix = '-е';
      } else if (unit === 'week' || unit === 'minute' || unit === 'second') {
        suffix = '-я';
      } else {
        suffix = '-й';
      }

      return number + suffix;
    };

    var localize$h = {
      ordinalNumber: ordinalNumber$g,
      era: buildLocalizeFn$1({
        values: eraValues$g,
        defaultWidth: 'wide'
      }),
      quarter: buildLocalizeFn$1({
        values: quarterValues$g,
        defaultWidth: 'wide',
        argumentCallback: function (quarter) {
          return quarter - 1;
        }
      }),
      month: buildLocalizeFn$1({
        values: monthValues$g,
        defaultWidth: 'wide',
        formattingValues: formattingMonthValues$4,
        defaultFormattingWidth: 'wide'
      }),
      day: buildLocalizeFn$1({
        values: dayValues$g,
        defaultWidth: 'wide'
      }),
      dayPeriod: buildLocalizeFn$1({
        values: dayPeriodValues$g,
        defaultWidth: 'any',
        formattingValues: formattingDayPeriodValues$b,
        defaultFormattingWidth: 'wide'
      })
    };

    var matchOrdinalNumberPattern$g = /^(\d+)(-?(е|я|й|ое|ье|ая|ья|ый|ой|ий|ый))?/i;
    var parseOrdinalNumberPattern$g = /\d+/i;
    var matchEraPatterns$g = {
      narrow: /^((до )?н\.?\s?э\.?)/i,
      abbreviated: /^((до )?н\.?\s?э\.?)/i,
      wide: /^(до нашей эры|нашей эры|наша эра)/i
    };
    var parseEraPatterns$g = {
      any: [/^д/i, /^н/i]
    };
    var matchQuarterPatterns$g = {
      narrow: /^[1234]/i,
      abbreviated: /^[1234](-?[ыои]?й?)? кв.?/i,
      wide: /^[1234](-?[ыои]?й?)? квартал/i
    };
    var parseQuarterPatterns$g = {
      any: [/1/i, /2/i, /3/i, /4/i]
    };
    var matchMonthPatterns$g = {
      narrow: /^[яфмаисонд]/i,
      abbreviated: /^(янв|фев|март?|апр|ма[йя]|июн[ья]?|июл[ья]?|авг|сент?|окт|нояб?|дек)\.?/i,
      wide: /^(январ[ья]|феврал[ья]|марта?|апрел[ья]|ма[йя]|июн[ья]|июл[ья]|августа?|сентябр[ья]|октябр[ья]|октябр[ья]|ноябр[ья]|декабр[ья])/i
    };
    var parseMonthPatterns$g = {
      narrow: [/^я/i, /^ф/i, /^м/i, /^а/i, /^м/i, /^и/i, /^и/i, /^а/i, /^с/i, /^о/i, /^н/i, /^я/i],
      any: [/^я/i, /^ф/i, /^мар/i, /^ап/i, /^ма[йя]/i, /^июн/i, /^июл/i, /^ав/i, /^с/i, /^о/i, /^н/i, /^д/i]
    };
    var matchDayPatterns$g = {
      narrow: /^[впсч]/i,
      short: /^(вс|во|пн|по|вт|ср|чт|че|пт|пя|сб|су)\.?/i,
      abbreviated: /^(вск|вос|пнд|пон|втр|вто|срд|сре|чтв|чет|птн|пят|суб).?/i,
      wide: /^(воскресень[ея]|понедельника?|вторника?|сред[аы]|четверга?|пятниц[аы]|суббот[аы])/i
    };
    var parseDayPatterns$g = {
      narrow: [/^в/i, /^п/i, /^в/i, /^с/i, /^ч/i, /^п/i, /^с/i],
      any: [/^в[ос]/i, /^п[он]/i, /^в/i, /^ср/i, /^ч/i, /^п[ят]/i, /^с[уб]/i]
    };
    var matchDayPeriodPatterns$g = {
      narrow: /^([дп]п|полн\.?|полд\.?|утр[оа]|день|дня|веч\.?|ноч[ьи])/i,
      abbreviated: /^([дп]п|полн\.?|полд\.?|утр[оа]|день|дня|веч\.?|ноч[ьи])/i,
      wide: /^([дп]п|полночь|полдень|утр[оа]|день|дня|вечера?|ноч[ьи])/i
    };
    var parseDayPeriodPatterns$g = {
      any: {
        am: /^дп/i,
        pm: /^пп/i,
        midnight: /^полн/i,
        noon: /^полд/i,
        morning: /^у/i,
        afternoon: /^д[ен]/i,
        evening: /^в/i,
        night: /^н/i
      }
    };
    var match$h = {
      ordinalNumber: buildMatchPatternFn$1({
        matchPattern: matchOrdinalNumberPattern$g,
        parsePattern: parseOrdinalNumberPattern$g,
        valueCallback: function (value) {
          return parseInt(value, 10);
        }
      }),
      era: buildMatchFn$1({
        matchPatterns: matchEraPatterns$g,
        defaultMatchWidth: 'wide',
        parsePatterns: parseEraPatterns$g,
        defaultParseWidth: 'any'
      }),
      quarter: buildMatchFn$1({
        matchPatterns: matchQuarterPatterns$g,
        defaultMatchWidth: 'wide',
        parsePatterns: parseQuarterPatterns$g,
        defaultParseWidth: 'any',
        valueCallback: function (index) {
          return index + 1;
        }
      }),
      month: buildMatchFn$1({
        matchPatterns: matchMonthPatterns$g,
        defaultMatchWidth: 'wide',
        parsePatterns: parseMonthPatterns$g,
        defaultParseWidth: 'any'
      }),
      day: buildMatchFn$1({
        matchPatterns: matchDayPatterns$g,
        defaultMatchWidth: 'wide',
        parsePatterns: parseDayPatterns$g,
        defaultParseWidth: 'any'
      }),
      dayPeriod: buildMatchFn$1({
        matchPatterns: matchDayPeriodPatterns$g,
        defaultMatchWidth: 'wide',
        parsePatterns: parseDayPeriodPatterns$g,
        defaultParseWidth: 'any'
      })
    };

    /**
     * @type {Locale}
     * @category Locales
     * @summary Russian locale.
     * @language Russian
     * @iso-639-2 rus
     * @author Sasha Koss [@kossnocorp]{@link https://github.com/kossnocorp}
     * @author Lesha Koss [@leshakoss]{@link https://github.com/leshakoss}
     */

    var locale$h = {
      code: 'ru',
      formatDistance: formatDistance$h,
      formatLong: formatLong$i,
      formatRelative: formatRelative$h,
      localize: localize$h,
      match: match$h,
      options: {
        weekStartsOn: 1
        /* Monday */
        ,
        firstWeekContainsDate: 1
      }
    };

    const dateRuRU = {
      name: "ru-RU",
      locale: locale$h
    };
    var dateRuRU$1 = dateRuRU;

    function declension$2(scheme, count) {
      // scheme for count=1 exists
      if (scheme.one !== undefined && count === 1) {
        return scheme.one;
      }

      var rem10 = count % 10;
      var rem100 = count % 100; // 1, 21, 31, ...

      if (rem10 === 1 && rem100 !== 11) {
        return scheme.singularNominative.replace('{{count}}', String(count)); // 2, 3, 4, 22, 23, 24, 32 ...
      } else if (rem10 >= 2 && rem10 <= 4 && (rem100 < 10 || rem100 > 20)) {
        return scheme.singularGenitive.replace('{{count}}', String(count)); // 5, 6, 7, 8, 9, 10, 11, ...
      } else {
        return scheme.pluralGenitive.replace('{{count}}', String(count));
      }
    }

    function buildLocalizeTokenFn(scheme) {
      return function (count, options) {
        if (options && options.addSuffix) {
          if (options.comparison && options.comparison > 0) {
            if (scheme.future) {
              return declension$2(scheme.future, count);
            } else {
              return 'за ' + declension$2(scheme.regular, count);
            }
          } else {
            if (scheme.past) {
              return declension$2(scheme.past, count);
            } else {
              return declension$2(scheme.regular, count) + ' тому';
            }
          }
        } else {
          return declension$2(scheme.regular, count);
        }
      };
    }

    var halfAtMinute = function (_, options) {
      if (options && options.addSuffix) {
        if (options.comparison && options.comparison > 0) {
          return 'за півхвилини';
        } else {
          return 'півхвилини тому';
        }
      }

      return 'півхвилини';
    };

    var formatDistanceLocale$f = {
      lessThanXSeconds: buildLocalizeTokenFn({
        regular: {
          one: 'менше секунди',
          singularNominative: 'менше {{count}} секунди',
          singularGenitive: 'менше {{count}} секунд',
          pluralGenitive: 'менше {{count}} секунд'
        },
        future: {
          one: 'менше, ніж за секунду',
          singularNominative: 'менше, ніж за {{count}} секунду',
          singularGenitive: 'менше, ніж за {{count}} секунди',
          pluralGenitive: 'менше, ніж за {{count}} секунд'
        }
      }),
      xSeconds: buildLocalizeTokenFn({
        regular: {
          singularNominative: '{{count}} секунда',
          singularGenitive: '{{count}} секунди',
          pluralGenitive: '{{count}} секунд'
        },
        past: {
          singularNominative: '{{count}} секунду тому',
          singularGenitive: '{{count}} секунди тому',
          pluralGenitive: '{{count}} секунд тому'
        },
        future: {
          singularNominative: 'за {{count}} секунду',
          singularGenitive: 'за {{count}} секунди',
          pluralGenitive: 'за {{count}} секунд'
        }
      }),
      halfAMinute: halfAtMinute,
      lessThanXMinutes: buildLocalizeTokenFn({
        regular: {
          one: 'менше хвилини',
          singularNominative: 'менше {{count}} хвилини',
          singularGenitive: 'менше {{count}} хвилин',
          pluralGenitive: 'менше {{count}} хвилин'
        },
        future: {
          one: 'менше, ніж за хвилину',
          singularNominative: 'менше, ніж за {{count}} хвилину',
          singularGenitive: 'менше, ніж за {{count}} хвилини',
          pluralGenitive: 'менше, ніж за {{count}} хвилин'
        }
      }),
      xMinutes: buildLocalizeTokenFn({
        regular: {
          singularNominative: '{{count}} хвилина',
          singularGenitive: '{{count}} хвилини',
          pluralGenitive: '{{count}} хвилин'
        },
        past: {
          singularNominative: '{{count}} хвилину тому',
          singularGenitive: '{{count}} хвилини тому',
          pluralGenitive: '{{count}} хвилин тому'
        },
        future: {
          singularNominative: 'за {{count}} хвилину',
          singularGenitive: 'за {{count}} хвилини',
          pluralGenitive: 'за {{count}} хвилин'
        }
      }),
      aboutXHours: buildLocalizeTokenFn({
        regular: {
          singularNominative: 'близько {{count}} години',
          singularGenitive: 'близько {{count}} годин',
          pluralGenitive: 'близько {{count}} годин'
        },
        future: {
          singularNominative: 'приблизно за {{count}} годину',
          singularGenitive: 'приблизно за {{count}} години',
          pluralGenitive: 'приблизно за {{count}} годин'
        }
      }),
      xHours: buildLocalizeTokenFn({
        regular: {
          singularNominative: '{{count}} годину',
          singularGenitive: '{{count}} години',
          pluralGenitive: '{{count}} годин'
        }
      }),
      xDays: buildLocalizeTokenFn({
        regular: {
          singularNominative: '{{count}} день',
          singularGenitive: '{{count}} дня',
          pluralGenitive: '{{count}} днів'
        }
      }),
      aboutXWeeks: buildLocalizeTokenFn({
        regular: {
          singularNominative: 'близько {{count}} тижня',
          singularGenitive: 'близько {{count}} тижнів',
          pluralGenitive: 'близько {{count}} тижнів'
        },
        future: {
          singularNominative: 'приблизно за {{count}} тиждень',
          singularGenitive: 'приблизно за {{count}} тижні',
          pluralGenitive: 'приблизно за {{count}} тижні'
        }
      }),
      xWeeks: buildLocalizeTokenFn({
        regular: {
          singularNominative: '{{count}} тиждень',
          singularGenitive: '{{count}} тижня',
          pluralGenitive: '{{count}} тижні'
        }
      }),
      aboutXMonths: buildLocalizeTokenFn({
        regular: {
          singularNominative: 'близько {{count}} місяця',
          singularGenitive: 'близько {{count}} місяців',
          pluralGenitive: 'близько {{count}} місяців'
        },
        future: {
          singularNominative: 'приблизно за {{count}} місяць',
          singularGenitive: 'приблизно за {{count}} місяця',
          pluralGenitive: 'приблизно за {{count}} місяців'
        }
      }),
      xMonths: buildLocalizeTokenFn({
        regular: {
          singularNominative: '{{count}} місяць',
          singularGenitive: '{{count}} місяця',
          pluralGenitive: '{{count}} місяців'
        }
      }),
      aboutXYears: buildLocalizeTokenFn({
        regular: {
          singularNominative: 'близько {{count}} року',
          singularGenitive: 'близько {{count}} років',
          pluralGenitive: 'близько {{count}} років'
        },
        future: {
          singularNominative: 'приблизно за {{count}} рік',
          singularGenitive: 'приблизно за {{count}} роки',
          pluralGenitive: 'приблизно за {{count}} років'
        }
      }),
      xYears: buildLocalizeTokenFn({
        regular: {
          singularNominative: '{{count}} рік',
          singularGenitive: '{{count}} роки',
          pluralGenitive: '{{count}} років'
        }
      }),
      overXYears: buildLocalizeTokenFn({
        regular: {
          singularNominative: 'більше {{count}} року',
          singularGenitive: 'більше {{count}} років',
          pluralGenitive: 'більше {{count}} років'
        },
        future: {
          singularNominative: 'більше, ніж за {{count}} рік',
          singularGenitive: 'більше, ніж за {{count}} роки',
          pluralGenitive: 'більше, ніж за {{count}} років'
        }
      }),
      almostXYears: buildLocalizeTokenFn({
        regular: {
          singularNominative: 'майже {{count}} рік',
          singularGenitive: 'майже {{count}} роки',
          pluralGenitive: 'майже {{count}} років'
        },
        future: {
          singularNominative: 'майже за {{count}} рік',
          singularGenitive: 'майже за {{count}} роки',
          pluralGenitive: 'майже за {{count}} років'
        }
      })
    };

    var formatDistance$g = function (token, count, options) {
      options = options || {};
      return formatDistanceLocale$f[token](count, options);
    };

    var dateFormats$g = {
      full: "EEEE, do MMMM y 'р.'",
      long: "do MMMM y 'р.'",
      medium: "d MMM y 'р.'",
      short: 'dd.MM.y'
    };
    var timeFormats$g = {
      full: 'H:mm:ss zzzz',
      long: 'H:mm:ss z',
      medium: 'H:mm:ss',
      short: 'H:mm'
    };
    var dateTimeFormats$g = {
      full: "{{date}} 'о' {{time}}",
      long: "{{date}} 'о' {{time}}",
      medium: '{{date}}, {{time}}',
      short: '{{date}}, {{time}}'
    };
    var formatLong$h = {
      date: buildFormatLongFn$1({
        formats: dateFormats$g,
        defaultWidth: 'full'
      }),
      time: buildFormatLongFn$1({
        formats: timeFormats$g,
        defaultWidth: 'full'
      }),
      dateTime: buildFormatLongFn$1({
        formats: dateTimeFormats$g,
        defaultWidth: 'full'
      })
    };

    /**
     * @name addDays
     * @category Day Helpers
     * @summary Add the specified number of days to the given date.
     *
     * @description
     * Add the specified number of days to the given date.
     *
     * @param {Date|Number} date - the date to be changed
     * @param {Number} amount - the amount of days to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
     * @returns {Date} - the new date with the days added
     * @throws {TypeError} - 2 arguments required
     *
     * @example
     * // Add 10 days to 1 September 2014:
     * const result = addDays(new Date(2014, 8, 1), 10)
     * //=> Thu Sep 11 2014 00:00:00
     */

    function addDays(dirtyDate, dirtyAmount) {
      requiredArgs$1(2, arguments);
      var date = toDate$2(dirtyDate);
      var amount = toInteger$1(dirtyAmount);

      if (isNaN(amount)) {
        return new Date(NaN);
      }

      if (!amount) {
        // If 0 days, no-op to avoid changing times in the hour before end of DST
        return date;
      }

      date.setDate(date.getDate() + amount);
      return date;
    }

    /**
     * @name addMonths
     * @category Month Helpers
     * @summary Add the specified number of months to the given date.
     *
     * @description
     * Add the specified number of months to the given date.
     *
     * @param {Date|Number} date - the date to be changed
     * @param {Number} amount - the amount of months to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
     * @returns {Date} the new date with the months added
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // Add 5 months to 1 September 2014:
     * const result = addMonths(new Date(2014, 8, 1), 5)
     * //=> Sun Feb 01 2015 00:00:00
     */

    function addMonths(dirtyDate, dirtyAmount) {
      requiredArgs$1(2, arguments);
      var date = toDate$2(dirtyDate);
      var amount = toInteger$1(dirtyAmount);

      if (isNaN(amount)) {
        return new Date(NaN);
      }

      if (!amount) {
        // If 0 months, no-op to avoid changing times in the hour before end of DST
        return date;
      }

      var dayOfMonth = date.getDate(); // The JS Date object supports date math by accepting out-of-bounds values for
      // month, day, etc. For example, new Date(2020, 0, 0) returns 31 Dec 2019 and
      // new Date(2020, 13, 1) returns 1 Feb 2021.  This is *almost* the behavior we
      // want except that dates will wrap around the end of a month, meaning that
      // new Date(2020, 13, 31) will return 3 Mar 2021 not 28 Feb 2021 as desired. So
      // we'll default to the end of the desired month by adding 1 to the desired
      // month and using a date of 0 to back up one day to the end of the desired
      // month.

      var endOfDesiredMonth = new Date(date.getTime());
      endOfDesiredMonth.setMonth(date.getMonth() + amount + 1, 0);
      var daysInMonth = endOfDesiredMonth.getDate();

      if (dayOfMonth >= daysInMonth) {
        // If we're already at the end of the month, then this is the correct date
        // and we're done.
        return endOfDesiredMonth;
      } else {
        // Otherwise, we now know that setting the original day-of-month value won't
        // cause an overflow, so set the desired day-of-month. Note that we can't
        // just set the date of `endOfDesiredMonth` because that object may have had
        // its time changed in the unusual case where where a DST transition was on
        // the last day of the month and its local time was in the hour skipped or
        // repeated next to a DST transition.  So we use `date` instead which is
        // guaranteed to still have the original time.
        date.setFullYear(endOfDesiredMonth.getFullYear(), endOfDesiredMonth.getMonth(), dayOfMonth);
        return date;
      }
    }

    /**
     * @name addMilliseconds
     * @category Millisecond Helpers
     * @summary Add the specified number of milliseconds to the given date.
     *
     * @description
     * Add the specified number of milliseconds to the given date.
     *
     * @param {Date|Number} date - the date to be changed
     * @param {Number} amount - the amount of milliseconds to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
     * @returns {Date} the new date with the milliseconds added
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // Add 750 milliseconds to 10 July 2014 12:45:30.000:
     * const result = addMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
     * //=> Thu Jul 10 2014 12:45:30.750
     */

    function addMilliseconds$1(dirtyDate, dirtyAmount) {
      requiredArgs$1(2, arguments);
      var timestamp = toDate$2(dirtyDate).getTime();
      var amount = toInteger$1(dirtyAmount);
      return new Date(timestamp + amount);
    }

    /**
     * Google Chrome as of 67.0.3396.87 introduced timezones with offset that includes seconds.
     * They usually appear for dates that denote time before the timezones were introduced
     * (e.g. for 'Europe/Prague' timezone the offset is GMT+00:57:44 before 1 October 1891
     * and GMT+01:00:00 after that date)
     *
     * Date#getTimezoneOffset returns the offset in minutes and would return 57 for the example above,
     * which would lead to incorrect calculations.
     *
     * This function returns the timezone offset in milliseconds that takes seconds in account.
     */
    function getTimezoneOffsetInMilliseconds$1(date) {
      var utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
      utcDate.setUTCFullYear(date.getFullYear());
      return date.getTime() - utcDate.getTime();
    }

    /**
     * @name startOfDay
     * @category Day Helpers
     * @summary Return the start of a day for the given date.
     *
     * @description
     * Return the start of a day for the given date.
     * The result will be in the local timezone.
     *
     * @param {Date|Number} date - the original date
     * @returns {Date} the start of a day
     * @throws {TypeError} 1 argument required
     *
     * @example
     * // The start of a day for 2 September 2014 11:55:00:
     * const result = startOfDay(new Date(2014, 8, 2, 11, 55, 0))
     * //=> Tue Sep 02 2014 00:00:00
     */

    function startOfDay(dirtyDate) {
      requiredArgs$1(1, arguments);
      var date = toDate$2(dirtyDate);
      date.setHours(0, 0, 0, 0);
      return date;
    }

    /**
     * @name addQuarters
     * @category Quarter Helpers
     * @summary Add the specified number of year quarters to the given date.
     *
     * @description
     * Add the specified number of year quarters to the given date.
     *
     * @param {Date|Number} date - the date to be changed
     * @param {Number} amount - the amount of quarters to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
     * @returns {Date} the new date with the quarters added
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // Add 1 quarter to 1 September 2014:
     * const result = addQuarters(new Date(2014, 8, 1), 1)
     * //=> Mon Dec 01 2014 00:00:00
     */

    function addQuarters(dirtyDate, dirtyAmount) {
      requiredArgs$1(2, arguments);
      var amount = toInteger$1(dirtyAmount);
      var months = amount * 3;
      return addMonths(dirtyDate, months);
    }

    /**
     * @name addYears
     * @category Year Helpers
     * @summary Add the specified number of years to the given date.
     *
     * @description
     * Add the specified number of years to the given date.
     *
     * @param {Date|Number} date - the date to be changed
     * @param {Number} amount - the amount of years to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
     * @returns {Date} the new date with the years added
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // Add 5 years to 1 September 2014:
     * const result = addYears(new Date(2014, 8, 1), 5)
     * //=> Sun Sep 01 2019 00:00:00
     */

    function addYears(dirtyDate, dirtyAmount) {
      requiredArgs$1(2, arguments);
      var amount = toInteger$1(dirtyAmount);
      return addMonths(dirtyDate, amount * 12);
    }

    /**
     * @name compareAsc
     * @category Common Helpers
     * @summary Compare the two dates and return -1, 0 or 1.
     *
     * @description
     * Compare the two dates and return 1 if the first date is after the second,
     * -1 if the first date is before the second or 0 if dates are equal.
     *
     * @param {Date|Number} dateLeft - the first date to compare
     * @param {Date|Number} dateRight - the second date to compare
     * @returns {Number} the result of the comparison
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // Compare 11 February 1987 and 10 July 1989:
     * const result = compareAsc(new Date(1987, 1, 11), new Date(1989, 6, 10))
     * //=> -1
     *
     * @example
     * // Sort the array of dates:
     * const result = [
     *   new Date(1995, 6, 2),
     *   new Date(1987, 1, 11),
     *   new Date(1989, 6, 10)
     * ].sort(compareAsc)
     * //=> [
     * //   Wed Feb 11 1987 00:00:00,
     * //   Mon Jul 10 1989 00:00:00,
     * //   Sun Jul 02 1995 00:00:00
     * // ]
     */

    function compareAsc(dirtyDateLeft, dirtyDateRight) {
      requiredArgs$1(2, arguments);
      var dateLeft = toDate$2(dirtyDateLeft);
      var dateRight = toDate$2(dirtyDateRight);
      var diff = dateLeft.getTime() - dateRight.getTime();

      if (diff < 0) {
        return -1;
      } else if (diff > 0) {
        return 1; // Return 0 if diff is 0; return NaN if diff is NaN
      } else {
        return diff;
      }
    }

    /**
     * Days in 1 week.
     *
     * @name daysInWeek
     * @constant
     * @type {number}
     * @default
     */
    /**
     * Milliseconds in 1 minute
     *
     * @name millisecondsInMinute
     * @constant
     * @type {number}
     * @default
     */

    var millisecondsInMinute = 60000;
    /**
     * Milliseconds in 1 hour
     *
     * @name millisecondsInHour
     * @constant
     * @type {number}
     * @default
     */

    var millisecondsInHour = 3600000;
    /**
     * Milliseconds in 1 second
     *
     * @name millisecondsInSecond
     * @constant
     * @type {number}
     * @default
     */

    var millisecondsInSecond = 1000;

    /**
     * @name isSameDay
     * @category Day Helpers
     * @summary Are the given dates in the same day (and year and month)?
     *
     * @description
     * Are the given dates in the same day (and year and month)?
     *
     * @param {Date|Number} dateLeft - the first date to check
     * @param {Date|Number} dateRight - the second date to check
     * @returns {Boolean} the dates are in the same day (and year and month)
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // Are 4 September 06:00:00 and 4 September 18:00:00 in the same day?
     * const result = isSameDay(new Date(2014, 8, 4, 6, 0), new Date(2014, 8, 4, 18, 0))
     * //=> true
     *
     * @example
     * // Are 4 September and 4 October in the same day?
     * const result = isSameDay(new Date(2014, 8, 4), new Date(2014, 9, 4))
     * //=> false
     *
     * @example
     * // Are 4 September, 2014 and 4 September, 2015 in the same day?
     * const result = isSameDay(new Date(2014, 8, 4), new Date(2015, 8, 4))
     * //=> false
     */

    function isSameDay(dirtyDateLeft, dirtyDateRight) {
      requiredArgs$1(2, arguments);
      var dateLeftStartOfDay = startOfDay(dirtyDateLeft);
      var dateRightStartOfDay = startOfDay(dirtyDateRight);
      return dateLeftStartOfDay.getTime() === dateRightStartOfDay.getTime();
    }

    /**
     * @name isDate
     * @category Common Helpers
     * @summary Is the given value a date?
     *
     * @description
     * Returns true if the given value is an instance of Date. The function works for dates transferred across iframes.
     *
     * @param {*} value - the value to check
     * @returns {boolean} true if the given value is a date
     * @throws {TypeError} 1 arguments required
     *
     * @example
     * // For a valid date:
     * const result = isDate(new Date())
     * //=> true
     *
     * @example
     * // For an invalid date:
     * const result = isDate(new Date(NaN))
     * //=> true
     *
     * @example
     * // For some value:
     * const result = isDate('2014-02-31')
     * //=> false
     *
     * @example
     * // For an object:
     * const result = isDate({})
     * //=> false
     */

    function isDate$1(value) {
      requiredArgs$1(1, arguments);
      return value instanceof Date || typeof value === 'object' && Object.prototype.toString.call(value) === '[object Date]';
    }

    /**
     * @name isValid
     * @category Common Helpers
     * @summary Is the given date valid?
     *
     * @description
     * Returns false if argument is Invalid Date and true otherwise.
     * Argument is converted to Date using `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
     * Invalid Date is a Date, whose time value is NaN.
     *
     * Time value of Date: http://es5.github.io/#x15.9.1.1
     *
     * @param {*} date - the date to check
     * @returns {Boolean} the date is valid
     * @throws {TypeError} 1 argument required
     *
     * @example
     * // For the valid date:
     * const result = isValid(new Date(2014, 1, 31))
     * //=> true
     *
     * @example
     * // For the value, convertable into a date:
     * const result = isValid(1393804800000)
     * //=> true
     *
     * @example
     * // For the invalid date:
     * const result = isValid(new Date(''))
     * //=> false
     */

    function isValid$1(dirtyDate) {
      requiredArgs$1(1, arguments);

      if (!isDate$1(dirtyDate) && typeof dirtyDate !== 'number') {
        return false;
      }

      var date = toDate$2(dirtyDate);
      return !isNaN(Number(date));
    }

    /**
     * @name getQuarter
     * @category Quarter Helpers
     * @summary Get the year quarter of the given date.
     *
     * @description
     * Get the year quarter of the given date.
     *
     * @param {Date|Number} date - the given date
     * @returns {Number} the quarter
     * @throws {TypeError} 1 argument required
     *
     * @example
     * // Which quarter is 2 July 2014?
     * const result = getQuarter(new Date(2014, 6, 2))
     * //=> 3
     */

    function getQuarter(dirtyDate) {
      requiredArgs$1(1, arguments);
      var date = toDate$2(dirtyDate);
      var quarter = Math.floor(date.getMonth() / 3) + 1;
      return quarter;
    }

    /**
     * @name startOfMinute
     * @category Minute Helpers
     * @summary Return the start of a minute for the given date.
     *
     * @description
     * Return the start of a minute for the given date.
     * The result will be in the local timezone.
     *
     * @param {Date|Number} date - the original date
     * @returns {Date} the start of a minute
     * @throws {TypeError} 1 argument required
     *
     * @example
     * // The start of a minute for 1 December 2014 22:15:45.400:
     * const result = startOfMinute(new Date(2014, 11, 1, 22, 15, 45, 400))
     * //=> Mon Dec 01 2014 22:15:00
     */

    function startOfMinute(dirtyDate) {
      requiredArgs$1(1, arguments);
      var date = toDate$2(dirtyDate);
      date.setSeconds(0, 0);
      return date;
    }

    /**
     * @name startOfQuarter
     * @category Quarter Helpers
     * @summary Return the start of a year quarter for the given date.
     *
     * @description
     * Return the start of a year quarter for the given date.
     * The result will be in the local timezone.
     *
     * @param {Date|Number} date - the original date
     * @returns {Date} the start of a quarter
     * @throws {TypeError} 1 argument required
     *
     * @example
     * // The start of a quarter for 2 September 2014 11:55:00:
     * const result = startOfQuarter(new Date(2014, 8, 2, 11, 55, 0))
     * //=> Tue Jul 01 2014 00:00:00
     */

    function startOfQuarter(dirtyDate) {
      requiredArgs$1(1, arguments);
      var date = toDate$2(dirtyDate);
      var currentMonth = date.getMonth();
      var month = currentMonth - currentMonth % 3;
      date.setMonth(month, 1);
      date.setHours(0, 0, 0, 0);
      return date;
    }

    /**
     * @name startOfMonth
     * @category Month Helpers
     * @summary Return the start of a month for the given date.
     *
     * @description
     * Return the start of a month for the given date.
     * The result will be in the local timezone.
     *
     * @param {Date|Number} date - the original date
     * @returns {Date} the start of a month
     * @throws {TypeError} 1 argument required
     *
     * @example
     * // The start of a month for 2 September 2014 11:55:00:
     * const result = startOfMonth(new Date(2014, 8, 2, 11, 55, 0))
     * //=> Mon Sep 01 2014 00:00:00
     */

    function startOfMonth(dirtyDate) {
      requiredArgs$1(1, arguments);
      var date = toDate$2(dirtyDate);
      date.setDate(1);
      date.setHours(0, 0, 0, 0);
      return date;
    }

    /**
     * @name startOfYear
     * @category Year Helpers
     * @summary Return the start of a year for the given date.
     *
     * @description
     * Return the start of a year for the given date.
     * The result will be in the local timezone.
     *
     * @param {Date|Number} date - the original date
     * @returns {Date} the start of a year
     * @throws {TypeError} 1 argument required
     *
     * @example
     * // The start of a year for 2 September 2014 11:55:00:
     * const result = startOfYear(new Date(2014, 8, 2, 11, 55, 00))
     * //=> Wed Jan 01 2014 00:00:00
     */

    function startOfYear(dirtyDate) {
      requiredArgs$1(1, arguments);
      var cleanDate = toDate$2(dirtyDate);
      var date = new Date(0);
      date.setFullYear(cleanDate.getFullYear(), 0, 1);
      date.setHours(0, 0, 0, 0);
      return date;
    }

    /**
     * @name subMilliseconds
     * @category Millisecond Helpers
     * @summary Subtract the specified number of milliseconds from the given date.
     *
     * @description
     * Subtract the specified number of milliseconds from the given date.
     *
     * @param {Date|Number} date - the date to be changed
     * @param {Number} amount - the amount of milliseconds to be subtracted. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
     * @returns {Date} the new date with the milliseconds subtracted
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // Subtract 750 milliseconds from 10 July 2014 12:45:30.000:
     * const result = subMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
     * //=> Thu Jul 10 2014 12:45:29.250
     */

    function subMilliseconds$1(dirtyDate, dirtyAmount) {
      requiredArgs$1(2, arguments);
      var amount = toInteger$1(dirtyAmount);
      return addMilliseconds$1(dirtyDate, -amount);
    }

    var MILLISECONDS_IN_DAY = 86400000;
    function getUTCDayOfYear$1(dirtyDate) {
      requiredArgs$1(1, arguments);
      var date = toDate$2(dirtyDate);
      var timestamp = date.getTime();
      date.setUTCMonth(0, 1);
      date.setUTCHours(0, 0, 0, 0);
      var startOfYearTimestamp = date.getTime();
      var difference = timestamp - startOfYearTimestamp;
      return Math.floor(difference / MILLISECONDS_IN_DAY) + 1;
    }

    function startOfUTCISOWeek$1(dirtyDate) {
      requiredArgs$1(1, arguments);
      var weekStartsOn = 1;
      var date = toDate$2(dirtyDate);
      var day = date.getUTCDay();
      var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
      date.setUTCDate(date.getUTCDate() - diff);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }

    function getUTCISOWeekYear$1(dirtyDate) {
      requiredArgs$1(1, arguments);
      var date = toDate$2(dirtyDate);
      var year = date.getUTCFullYear();
      var fourthOfJanuaryOfNextYear = new Date(0);
      fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
      fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
      var startOfNextYear = startOfUTCISOWeek$1(fourthOfJanuaryOfNextYear);
      var fourthOfJanuaryOfThisYear = new Date(0);
      fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
      fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
      var startOfThisYear = startOfUTCISOWeek$1(fourthOfJanuaryOfThisYear);

      if (date.getTime() >= startOfNextYear.getTime()) {
        return year + 1;
      } else if (date.getTime() >= startOfThisYear.getTime()) {
        return year;
      } else {
        return year - 1;
      }
    }

    function startOfUTCISOWeekYear$1(dirtyDate) {
      requiredArgs$1(1, arguments);
      var year = getUTCISOWeekYear$1(dirtyDate);
      var fourthOfJanuary = new Date(0);
      fourthOfJanuary.setUTCFullYear(year, 0, 4);
      fourthOfJanuary.setUTCHours(0, 0, 0, 0);
      var date = startOfUTCISOWeek$1(fourthOfJanuary);
      return date;
    }

    var MILLISECONDS_IN_WEEK$1 = 604800000;
    function getUTCISOWeek$1(dirtyDate) {
      requiredArgs$1(1, arguments);
      var date = toDate$2(dirtyDate);
      var diff = startOfUTCISOWeek$1(date).getTime() - startOfUTCISOWeekYear$1(date).getTime(); // Round the number of days to the nearest integer
      // because the number of milliseconds in a week is not constant
      // (e.g. it's different in the week of the daylight saving time clock shift)

      return Math.round(diff / MILLISECONDS_IN_WEEK$1) + 1;
    }

    function getUTCWeekYear$1(dirtyDate, options) {
      var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;

      requiredArgs$1(1, arguments);
      var date = toDate$2(dirtyDate);
      var year = date.getUTCFullYear();
      var defaultOptions = getDefaultOptions$1();
      var firstWeekContainsDate = toInteger$1((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN

      if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
        throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
      }

      var firstWeekOfNextYear = new Date(0);
      firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
      firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
      var startOfNextYear = startOfUTCWeek$1(firstWeekOfNextYear, options);
      var firstWeekOfThisYear = new Date(0);
      firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
      firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
      var startOfThisYear = startOfUTCWeek$1(firstWeekOfThisYear, options);

      if (date.getTime() >= startOfNextYear.getTime()) {
        return year + 1;
      } else if (date.getTime() >= startOfThisYear.getTime()) {
        return year;
      } else {
        return year - 1;
      }
    }

    function startOfUTCWeekYear$1(dirtyDate, options) {
      var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;

      requiredArgs$1(1, arguments);
      var defaultOptions = getDefaultOptions$1();
      var firstWeekContainsDate = toInteger$1((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
      var year = getUTCWeekYear$1(dirtyDate, options);
      var firstWeek = new Date(0);
      firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
      firstWeek.setUTCHours(0, 0, 0, 0);
      var date = startOfUTCWeek$1(firstWeek, options);
      return date;
    }

    var MILLISECONDS_IN_WEEK = 604800000;
    function getUTCWeek$1(dirtyDate, options) {
      requiredArgs$1(1, arguments);
      var date = toDate$2(dirtyDate);
      var diff = startOfUTCWeek$1(date, options).getTime() - startOfUTCWeekYear$1(date, options).getTime(); // Round the number of days to the nearest integer
      // because the number of milliseconds in a week is not constant
      // (e.g. it's different in the week of the daylight saving time clock shift)

      return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
    }

    function addLeadingZeros$1(number, targetLength) {
      var sign = number < 0 ? '-' : '';
      var output = Math.abs(number).toString();

      while (output.length < targetLength) {
        output = '0' + output;
      }

      return sign + output;
    }

    /*
     * |     | Unit                           |     | Unit                           |
     * |-----|--------------------------------|-----|--------------------------------|
     * |  a  | AM, PM                         |  A* |                                |
     * |  d  | Day of month                   |  D  |                                |
     * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
     * |  m  | Minute                         |  M  | Month                          |
     * |  s  | Second                         |  S  | Fraction of second             |
     * |  y  | Year (abs)                     |  Y  |                                |
     *
     * Letters marked by * are not implemented but reserved by Unicode standard.
     */

    var formatters$4 = {
      // Year
      y: function (date, token) {
        // From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_tokens
        // | Year     |     y | yy |   yyy |  yyyy | yyyyy |
        // |----------|-------|----|-------|-------|-------|
        // | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
        // | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
        // | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
        // | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
        // | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |
        var signedYear = date.getUTCFullYear(); // Returns 1 for 1 BC (which is year 0 in JavaScript)

        var year = signedYear > 0 ? signedYear : 1 - signedYear;
        return addLeadingZeros$1(token === 'yy' ? year % 100 : year, token.length);
      },
      // Month
      M: function (date, token) {
        var month = date.getUTCMonth();
        return token === 'M' ? String(month + 1) : addLeadingZeros$1(month + 1, 2);
      },
      // Day of the month
      d: function (date, token) {
        return addLeadingZeros$1(date.getUTCDate(), token.length);
      },
      // AM or PM
      a: function (date, token) {
        var dayPeriodEnumValue = date.getUTCHours() / 12 >= 1 ? 'pm' : 'am';

        switch (token) {
          case 'a':
          case 'aa':
            return dayPeriodEnumValue.toUpperCase();

          case 'aaa':
            return dayPeriodEnumValue;

          case 'aaaaa':
            return dayPeriodEnumValue[0];

          case 'aaaa':
          default:
            return dayPeriodEnumValue === 'am' ? 'a.m.' : 'p.m.';
        }
      },
      // Hour [1-12]
      h: function (date, token) {
        return addLeadingZeros$1(date.getUTCHours() % 12 || 12, token.length);
      },
      // Hour [0-23]
      H: function (date, token) {
        return addLeadingZeros$1(date.getUTCHours(), token.length);
      },
      // Minute
      m: function (date, token) {
        return addLeadingZeros$1(date.getUTCMinutes(), token.length);
      },
      // Second
      s: function (date, token) {
        return addLeadingZeros$1(date.getUTCSeconds(), token.length);
      },
      // Fraction of second
      S: function (date, token) {
        var numberOfDigits = token.length;
        var milliseconds = date.getUTCMilliseconds();
        var fractionalSeconds = Math.floor(milliseconds * Math.pow(10, numberOfDigits - 3));
        return addLeadingZeros$1(fractionalSeconds, token.length);
      }
    };

    var dayPeriodEnum = {
      am: 'am',
      pm: 'pm',
      midnight: 'midnight',
      noon: 'noon',
      morning: 'morning',
      afternoon: 'afternoon',
      evening: 'evening',
      night: 'night'
    };
    /*
     * |     | Unit                           |     | Unit                           |
     * |-----|--------------------------------|-----|--------------------------------|
     * |  a  | AM, PM                         |  A* | Milliseconds in day            |
     * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |
     * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |
     * |  d  | Day of month                   |  D  | Day of year                    |
     * |  e  | Local day of week              |  E  | Day of week                    |
     * |  f  |                                |  F* | Day of week in month           |
     * |  g* | Modified Julian day            |  G  | Era                            |
     * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
     * |  i! | ISO day of week                |  I! | ISO week of year               |
     * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |
     * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |
     * |  l* | (deprecated)                   |  L  | Stand-alone month              |
     * |  m  | Minute                         |  M  | Month                          |
     * |  n  |                                |  N  |                                |
     * |  o! | Ordinal number modifier        |  O  | Timezone (GMT)                 |
     * |  p! | Long localized time            |  P! | Long localized date            |
     * |  q  | Stand-alone quarter            |  Q  | Quarter                        |
     * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |
     * |  s  | Second                         |  S  | Fraction of second             |
     * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |
     * |  u  | Extended year                  |  U* | Cyclic year                    |
     * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |
     * |  w  | Local week of year             |  W* | Week of month                  |
     * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |
     * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |
     * |  z  | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |
     *
     * Letters marked by * are not implemented but reserved by Unicode standard.
     *
     * Letters marked by ! are non-standard, but implemented by date-fns:
     * - `o` modifies the previous token to turn it into an ordinal (see `format` docs)
     * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,
     *   i.e. 7 for Sunday, 1 for Monday, etc.
     * - `I` is ISO week of year, as opposed to `w` which is local week of year.
     * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.
     *   `R` is supposed to be used in conjunction with `I` and `i`
     *   for universal ISO week-numbering date, whereas
     *   `Y` is supposed to be used in conjunction with `w` and `e`
     *   for week-numbering date specific to the locale.
     * - `P` is long localized date format
     * - `p` is long localized time format
     */

    var formatters$2 = {
      // Era
      G: function (date, token, localize) {
        var era = date.getUTCFullYear() > 0 ? 1 : 0;

        switch (token) {
          // AD, BC
          case 'G':
          case 'GG':
          case 'GGG':
            return localize.era(era, {
              width: 'abbreviated'
            });
          // A, B

          case 'GGGGG':
            return localize.era(era, {
              width: 'narrow'
            });
          // Anno Domini, Before Christ

          case 'GGGG':
          default:
            return localize.era(era, {
              width: 'wide'
            });
        }
      },
      // Year
      y: function (date, token, localize) {
        // Ordinal number
        if (token === 'yo') {
          var signedYear = date.getUTCFullYear(); // Returns 1 for 1 BC (which is year 0 in JavaScript)

          var year = signedYear > 0 ? signedYear : 1 - signedYear;
          return localize.ordinalNumber(year, {
            unit: 'year'
          });
        }

        return formatters$4.y(date, token);
      },
      // Local week-numbering year
      Y: function (date, token, localize, options) {
        var signedWeekYear = getUTCWeekYear$1(date, options); // Returns 1 for 1 BC (which is year 0 in JavaScript)

        var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear; // Two digit year

        if (token === 'YY') {
          var twoDigitYear = weekYear % 100;
          return addLeadingZeros$1(twoDigitYear, 2);
        } // Ordinal number


        if (token === 'Yo') {
          return localize.ordinalNumber(weekYear, {
            unit: 'year'
          });
        } // Padding


        return addLeadingZeros$1(weekYear, token.length);
      },
      // ISO week-numbering year
      R: function (date, token) {
        var isoWeekYear = getUTCISOWeekYear$1(date); // Padding

        return addLeadingZeros$1(isoWeekYear, token.length);
      },
      // Extended year. This is a single number designating the year of this calendar system.
      // The main difference between `y` and `u` localizers are B.C. years:
      // | Year | `y` | `u` |
      // |------|-----|-----|
      // | AC 1 |   1 |   1 |
      // | BC 1 |   1 |   0 |
      // | BC 2 |   2 |  -1 |
      // Also `yy` always returns the last two digits of a year,
      // while `uu` pads single digit years to 2 characters and returns other years unchanged.
      u: function (date, token) {
        var year = date.getUTCFullYear();
        return addLeadingZeros$1(year, token.length);
      },
      // Quarter
      Q: function (date, token, localize) {
        var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);

        switch (token) {
          // 1, 2, 3, 4
          case 'Q':
            return String(quarter);
          // 01, 02, 03, 04

          case 'QQ':
            return addLeadingZeros$1(quarter, 2);
          // 1st, 2nd, 3rd, 4th

          case 'Qo':
            return localize.ordinalNumber(quarter, {
              unit: 'quarter'
            });
          // Q1, Q2, Q3, Q4

          case 'QQQ':
            return localize.quarter(quarter, {
              width: 'abbreviated',
              context: 'formatting'
            });
          // 1, 2, 3, 4 (narrow quarter; could be not numerical)

          case 'QQQQQ':
            return localize.quarter(quarter, {
              width: 'narrow',
              context: 'formatting'
            });
          // 1st quarter, 2nd quarter, ...

          case 'QQQQ':
          default:
            return localize.quarter(quarter, {
              width: 'wide',
              context: 'formatting'
            });
        }
      },
      // Stand-alone quarter
      q: function (date, token, localize) {
        var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);

        switch (token) {
          // 1, 2, 3, 4
          case 'q':
            return String(quarter);
          // 01, 02, 03, 04

          case 'qq':
            return addLeadingZeros$1(quarter, 2);
          // 1st, 2nd, 3rd, 4th

          case 'qo':
            return localize.ordinalNumber(quarter, {
              unit: 'quarter'
            });
          // Q1, Q2, Q3, Q4

          case 'qqq':
            return localize.quarter(quarter, {
              width: 'abbreviated',
              context: 'standalone'
            });
          // 1, 2, 3, 4 (narrow quarter; could be not numerical)

          case 'qqqqq':
            return localize.quarter(quarter, {
              width: 'narrow',
              context: 'standalone'
            });
          // 1st quarter, 2nd quarter, ...

          case 'qqqq':
          default:
            return localize.quarter(quarter, {
              width: 'wide',
              context: 'standalone'
            });
        }
      },
      // Month
      M: function (date, token, localize) {
        var month = date.getUTCMonth();

        switch (token) {
          case 'M':
          case 'MM':
            return formatters$4.M(date, token);
          // 1st, 2nd, ..., 12th

          case 'Mo':
            return localize.ordinalNumber(month + 1, {
              unit: 'month'
            });
          // Jan, Feb, ..., Dec

          case 'MMM':
            return localize.month(month, {
              width: 'abbreviated',
              context: 'formatting'
            });
          // J, F, ..., D

          case 'MMMMM':
            return localize.month(month, {
              width: 'narrow',
              context: 'formatting'
            });
          // January, February, ..., December

          case 'MMMM':
          default:
            return localize.month(month, {
              width: 'wide',
              context: 'formatting'
            });
        }
      },
      // Stand-alone month
      L: function (date, token, localize) {
        var month = date.getUTCMonth();

        switch (token) {
          // 1, 2, ..., 12
          case 'L':
            return String(month + 1);
          // 01, 02, ..., 12

          case 'LL':
            return addLeadingZeros$1(month + 1, 2);
          // 1st, 2nd, ..., 12th

          case 'Lo':
            return localize.ordinalNumber(month + 1, {
              unit: 'month'
            });
          // Jan, Feb, ..., Dec

          case 'LLL':
            return localize.month(month, {
              width: 'abbreviated',
              context: 'standalone'
            });
          // J, F, ..., D

          case 'LLLLL':
            return localize.month(month, {
              width: 'narrow',
              context: 'standalone'
            });
          // January, February, ..., December

          case 'LLLL':
          default:
            return localize.month(month, {
              width: 'wide',
              context: 'standalone'
            });
        }
      },
      // Local week of year
      w: function (date, token, localize, options) {
        var week = getUTCWeek$1(date, options);

        if (token === 'wo') {
          return localize.ordinalNumber(week, {
            unit: 'week'
          });
        }

        return addLeadingZeros$1(week, token.length);
      },
      // ISO week of year
      I: function (date, token, localize) {
        var isoWeek = getUTCISOWeek$1(date);

        if (token === 'Io') {
          return localize.ordinalNumber(isoWeek, {
            unit: 'week'
          });
        }

        return addLeadingZeros$1(isoWeek, token.length);
      },
      // Day of the month
      d: function (date, token, localize) {
        if (token === 'do') {
          return localize.ordinalNumber(date.getUTCDate(), {
            unit: 'date'
          });
        }

        return formatters$4.d(date, token);
      },
      // Day of year
      D: function (date, token, localize) {
        var dayOfYear = getUTCDayOfYear$1(date);

        if (token === 'Do') {
          return localize.ordinalNumber(dayOfYear, {
            unit: 'dayOfYear'
          });
        }

        return addLeadingZeros$1(dayOfYear, token.length);
      },
      // Day of week
      E: function (date, token, localize) {
        var dayOfWeek = date.getUTCDay();

        switch (token) {
          // Tue
          case 'E':
          case 'EE':
          case 'EEE':
            return localize.day(dayOfWeek, {
              width: 'abbreviated',
              context: 'formatting'
            });
          // T

          case 'EEEEE':
            return localize.day(dayOfWeek, {
              width: 'narrow',
              context: 'formatting'
            });
          // Tu

          case 'EEEEEE':
            return localize.day(dayOfWeek, {
              width: 'short',
              context: 'formatting'
            });
          // Tuesday

          case 'EEEE':
          default:
            return localize.day(dayOfWeek, {
              width: 'wide',
              context: 'formatting'
            });
        }
      },
      // Local day of week
      e: function (date, token, localize, options) {
        var dayOfWeek = date.getUTCDay();
        var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;

        switch (token) {
          // Numerical value (Nth day of week with current locale or weekStartsOn)
          case 'e':
            return String(localDayOfWeek);
          // Padded numerical value

          case 'ee':
            return addLeadingZeros$1(localDayOfWeek, 2);
          // 1st, 2nd, ..., 7th

          case 'eo':
            return localize.ordinalNumber(localDayOfWeek, {
              unit: 'day'
            });

          case 'eee':
            return localize.day(dayOfWeek, {
              width: 'abbreviated',
              context: 'formatting'
            });
          // T

          case 'eeeee':
            return localize.day(dayOfWeek, {
              width: 'narrow',
              context: 'formatting'
            });
          // Tu

          case 'eeeeee':
            return localize.day(dayOfWeek, {
              width: 'short',
              context: 'formatting'
            });
          // Tuesday

          case 'eeee':
          default:
            return localize.day(dayOfWeek, {
              width: 'wide',
              context: 'formatting'
            });
        }
      },
      // Stand-alone local day of week
      c: function (date, token, localize, options) {
        var dayOfWeek = date.getUTCDay();
        var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;

        switch (token) {
          // Numerical value (same as in `e`)
          case 'c':
            return String(localDayOfWeek);
          // Padded numerical value

          case 'cc':
            return addLeadingZeros$1(localDayOfWeek, token.length);
          // 1st, 2nd, ..., 7th

          case 'co':
            return localize.ordinalNumber(localDayOfWeek, {
              unit: 'day'
            });

          case 'ccc':
            return localize.day(dayOfWeek, {
              width: 'abbreviated',
              context: 'standalone'
            });
          // T

          case 'ccccc':
            return localize.day(dayOfWeek, {
              width: 'narrow',
              context: 'standalone'
            });
          // Tu

          case 'cccccc':
            return localize.day(dayOfWeek, {
              width: 'short',
              context: 'standalone'
            });
          // Tuesday

          case 'cccc':
          default:
            return localize.day(dayOfWeek, {
              width: 'wide',
              context: 'standalone'
            });
        }
      },
      // ISO day of week
      i: function (date, token, localize) {
        var dayOfWeek = date.getUTCDay();
        var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;

        switch (token) {
          // 2
          case 'i':
            return String(isoDayOfWeek);
          // 02

          case 'ii':
            return addLeadingZeros$1(isoDayOfWeek, token.length);
          // 2nd

          case 'io':
            return localize.ordinalNumber(isoDayOfWeek, {
              unit: 'day'
            });
          // Tue

          case 'iii':
            return localize.day(dayOfWeek, {
              width: 'abbreviated',
              context: 'formatting'
            });
          // T

          case 'iiiii':
            return localize.day(dayOfWeek, {
              width: 'narrow',
              context: 'formatting'
            });
          // Tu

          case 'iiiiii':
            return localize.day(dayOfWeek, {
              width: 'short',
              context: 'formatting'
            });
          // Tuesday

          case 'iiii':
          default:
            return localize.day(dayOfWeek, {
              width: 'wide',
              context: 'formatting'
            });
        }
      },
      // AM or PM
      a: function (date, token, localize) {
        var hours = date.getUTCHours();
        var dayPeriodEnumValue = hours / 12 >= 1 ? 'pm' : 'am';

        switch (token) {
          case 'a':
          case 'aa':
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'abbreviated',
              context: 'formatting'
            });

          case 'aaa':
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'abbreviated',
              context: 'formatting'
            }).toLowerCase();

          case 'aaaaa':
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'narrow',
              context: 'formatting'
            });

          case 'aaaa':
          default:
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'wide',
              context: 'formatting'
            });
        }
      },
      // AM, PM, midnight, noon
      b: function (date, token, localize) {
        var hours = date.getUTCHours();
        var dayPeriodEnumValue;

        if (hours === 12) {
          dayPeriodEnumValue = dayPeriodEnum.noon;
        } else if (hours === 0) {
          dayPeriodEnumValue = dayPeriodEnum.midnight;
        } else {
          dayPeriodEnumValue = hours / 12 >= 1 ? 'pm' : 'am';
        }

        switch (token) {
          case 'b':
          case 'bb':
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'abbreviated',
              context: 'formatting'
            });

          case 'bbb':
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'abbreviated',
              context: 'formatting'
            }).toLowerCase();

          case 'bbbbb':
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'narrow',
              context: 'formatting'
            });

          case 'bbbb':
          default:
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'wide',
              context: 'formatting'
            });
        }
      },
      // in the morning, in the afternoon, in the evening, at night
      B: function (date, token, localize) {
        var hours = date.getUTCHours();
        var dayPeriodEnumValue;

        if (hours >= 17) {
          dayPeriodEnumValue = dayPeriodEnum.evening;
        } else if (hours >= 12) {
          dayPeriodEnumValue = dayPeriodEnum.afternoon;
        } else if (hours >= 4) {
          dayPeriodEnumValue = dayPeriodEnum.morning;
        } else {
          dayPeriodEnumValue = dayPeriodEnum.night;
        }

        switch (token) {
          case 'B':
          case 'BB':
          case 'BBB':
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'abbreviated',
              context: 'formatting'
            });

          case 'BBBBB':
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'narrow',
              context: 'formatting'
            });

          case 'BBBB':
          default:
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'wide',
              context: 'formatting'
            });
        }
      },
      // Hour [1-12]
      h: function (date, token, localize) {
        if (token === 'ho') {
          var hours = date.getUTCHours() % 12;
          if (hours === 0) hours = 12;
          return localize.ordinalNumber(hours, {
            unit: 'hour'
          });
        }

        return formatters$4.h(date, token);
      },
      // Hour [0-23]
      H: function (date, token, localize) {
        if (token === 'Ho') {
          return localize.ordinalNumber(date.getUTCHours(), {
            unit: 'hour'
          });
        }

        return formatters$4.H(date, token);
      },
      // Hour [0-11]
      K: function (date, token, localize) {
        var hours = date.getUTCHours() % 12;

        if (token === 'Ko') {
          return localize.ordinalNumber(hours, {
            unit: 'hour'
          });
        }

        return addLeadingZeros$1(hours, token.length);
      },
      // Hour [1-24]
      k: function (date, token, localize) {
        var hours = date.getUTCHours();
        if (hours === 0) hours = 24;

        if (token === 'ko') {
          return localize.ordinalNumber(hours, {
            unit: 'hour'
          });
        }

        return addLeadingZeros$1(hours, token.length);
      },
      // Minute
      m: function (date, token, localize) {
        if (token === 'mo') {
          return localize.ordinalNumber(date.getUTCMinutes(), {
            unit: 'minute'
          });
        }

        return formatters$4.m(date, token);
      },
      // Second
      s: function (date, token, localize) {
        if (token === 'so') {
          return localize.ordinalNumber(date.getUTCSeconds(), {
            unit: 'second'
          });
        }

        return formatters$4.s(date, token);
      },
      // Fraction of second
      S: function (date, token) {
        return formatters$4.S(date, token);
      },
      // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
      X: function (date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timezoneOffset = originalDate.getTimezoneOffset();

        if (timezoneOffset === 0) {
          return 'Z';
        }

        switch (token) {
          // Hours and optional minutes
          case 'X':
            return formatTimezoneWithOptionalMinutes(timezoneOffset);
          // Hours, minutes and optional seconds without `:` delimiter
          // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
          // so this token always has the same output as `XX`

          case 'XXXX':
          case 'XX':
            // Hours and minutes without `:` delimiter
            return formatTimezone(timezoneOffset);
          // Hours, minutes and optional seconds with `:` delimiter
          // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
          // so this token always has the same output as `XXX`

          case 'XXXXX':
          case 'XXX': // Hours and minutes with `:` delimiter

          default:
            return formatTimezone(timezoneOffset, ':');
        }
      },
      // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
      x: function (date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timezoneOffset = originalDate.getTimezoneOffset();

        switch (token) {
          // Hours and optional minutes
          case 'x':
            return formatTimezoneWithOptionalMinutes(timezoneOffset);
          // Hours, minutes and optional seconds without `:` delimiter
          // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
          // so this token always has the same output as `xx`

          case 'xxxx':
          case 'xx':
            // Hours and minutes without `:` delimiter
            return formatTimezone(timezoneOffset);
          // Hours, minutes and optional seconds with `:` delimiter
          // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
          // so this token always has the same output as `xxx`

          case 'xxxxx':
          case 'xxx': // Hours and minutes with `:` delimiter

          default:
            return formatTimezone(timezoneOffset, ':');
        }
      },
      // Timezone (GMT)
      O: function (date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timezoneOffset = originalDate.getTimezoneOffset();

        switch (token) {
          // Short
          case 'O':
          case 'OO':
          case 'OOO':
            return 'GMT' + formatTimezoneShort(timezoneOffset, ':');
          // Long

          case 'OOOO':
          default:
            return 'GMT' + formatTimezone(timezoneOffset, ':');
        }
      },
      // Timezone (specific non-location)
      z: function (date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timezoneOffset = originalDate.getTimezoneOffset();

        switch (token) {
          // Short
          case 'z':
          case 'zz':
          case 'zzz':
            return 'GMT' + formatTimezoneShort(timezoneOffset, ':');
          // Long

          case 'zzzz':
          default:
            return 'GMT' + formatTimezone(timezoneOffset, ':');
        }
      },
      // Seconds timestamp
      t: function (date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timestamp = Math.floor(originalDate.getTime() / 1000);
        return addLeadingZeros$1(timestamp, token.length);
      },
      // Milliseconds timestamp
      T: function (date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timestamp = originalDate.getTime();
        return addLeadingZeros$1(timestamp, token.length);
      }
    };

    function formatTimezoneShort(offset, dirtyDelimiter) {
      var sign = offset > 0 ? '-' : '+';
      var absOffset = Math.abs(offset);
      var hours = Math.floor(absOffset / 60);
      var minutes = absOffset % 60;

      if (minutes === 0) {
        return sign + String(hours);
      }

      var delimiter = dirtyDelimiter || '';
      return sign + String(hours) + delimiter + addLeadingZeros$1(minutes, 2);
    }

    function formatTimezoneWithOptionalMinutes(offset, dirtyDelimiter) {
      if (offset % 60 === 0) {
        var sign = offset > 0 ? '-' : '+';
        return sign + addLeadingZeros$1(Math.abs(offset) / 60, 2);
      }

      return formatTimezone(offset, dirtyDelimiter);
    }

    function formatTimezone(offset, dirtyDelimiter) {
      var delimiter = dirtyDelimiter || '';
      var sign = offset > 0 ? '-' : '+';
      var absOffset = Math.abs(offset);
      var hours = addLeadingZeros$1(Math.floor(absOffset / 60), 2);
      var minutes = addLeadingZeros$1(absOffset % 60, 2);
      return sign + hours + delimiter + minutes;
    }

    var formatters$3 = formatters$2;

    var dateLongFormatter = function (pattern, formatLong) {
      switch (pattern) {
        case 'P':
          return formatLong.date({
            width: 'short'
          });

        case 'PP':
          return formatLong.date({
            width: 'medium'
          });

        case 'PPP':
          return formatLong.date({
            width: 'long'
          });

        case 'PPPP':
        default:
          return formatLong.date({
            width: 'full'
          });
      }
    };

    var timeLongFormatter = function (pattern, formatLong) {
      switch (pattern) {
        case 'p':
          return formatLong.time({
            width: 'short'
          });

        case 'pp':
          return formatLong.time({
            width: 'medium'
          });

        case 'ppp':
          return formatLong.time({
            width: 'long'
          });

        case 'pppp':
        default:
          return formatLong.time({
            width: 'full'
          });
      }
    };

    var dateTimeLongFormatter = function (pattern, formatLong) {
      var matchResult = pattern.match(/(P+)(p+)?/) || [];
      var datePattern = matchResult[1];
      var timePattern = matchResult[2];

      if (!timePattern) {
        return dateLongFormatter(pattern, formatLong);
      }

      var dateTimeFormat;

      switch (datePattern) {
        case 'P':
          dateTimeFormat = formatLong.dateTime({
            width: 'short'
          });
          break;

        case 'PP':
          dateTimeFormat = formatLong.dateTime({
            width: 'medium'
          });
          break;

        case 'PPP':
          dateTimeFormat = formatLong.dateTime({
            width: 'long'
          });
          break;

        case 'PPPP':
        default:
          dateTimeFormat = formatLong.dateTime({
            width: 'full'
          });
          break;
      }

      return dateTimeFormat.replace('{{date}}', dateLongFormatter(datePattern, formatLong)).replace('{{time}}', timeLongFormatter(timePattern, formatLong));
    };

    var longFormatters$1 = {
      p: timeLongFormatter,
      P: dateTimeLongFormatter
    };
    var longFormatters$2 = longFormatters$1;

    var protectedDayOfYearTokens$1 = ['D', 'DD'];
    var protectedWeekYearTokens$1 = ['YY', 'YYYY'];
    function isProtectedDayOfYearToken$1(token) {
      return protectedDayOfYearTokens$1.indexOf(token) !== -1;
    }
    function isProtectedWeekYearToken$1(token) {
      return protectedWeekYearTokens$1.indexOf(token) !== -1;
    }
    function throwProtectedError$1(token, format, input) {
      if (token === 'YYYY') {
        throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(format, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
      } else if (token === 'YY') {
        throw new RangeError("Use `yy` instead of `YY` (in `".concat(format, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
      } else if (token === 'D') {
        throw new RangeError("Use `d` instead of `D` (in `".concat(format, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
      } else if (token === 'DD') {
        throw new RangeError("Use `dd` instead of `DD` (in `".concat(format, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
      }
    }

    // - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token
    //   (one of the certain letters followed by `o`)
    // - (\w)\1* matches any sequences of the same letter
    // - '' matches two quote characters in a row
    // - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
    //   except a single quote symbol, which ends the sequence.
    //   Two quote characters do not end the sequence.
    //   If there is no matching single quote
    //   then the sequence will continue until the end of the string.
    // - . matches any single character unmatched by previous parts of the RegExps

    var formattingTokensRegExp$1 = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g; // This RegExp catches symbols escaped by quotes, and also
    // sequences of symbols P, p, and the combinations like `PPPPPPPppppp`

    var longFormattingTokensRegExp$1 = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
    var escapedStringRegExp$1 = /^'([^]*?)'?$/;
    var doubleQuoteRegExp$1 = /''/g;
    var unescapedLatinCharacterRegExp$1 = /[a-zA-Z]/;
    /**
     * @name format
     * @category Common Helpers
     * @summary Format the date.
     *
     * @description
     * Return the formatted date string in the given format. The result may vary by locale.
     *
     * > ⚠️ Please note that the `format` tokens differ from Moment.js and other libraries.
     * > See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
     *
     * The characters wrapped between two single quotes characters (') are escaped.
     * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
     * (see the last example)
     *
     * Format of the string is based on Unicode Technical Standard #35:
     * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
     * with a few additions (see note 7 below the table).
     *
     * Accepted patterns:
     * | Unit                            | Pattern | Result examples                   | Notes |
     * |---------------------------------|---------|-----------------------------------|-------|
     * | Era                             | G..GGG  | AD, BC                            |       |
     * |                                 | GGGG    | Anno Domini, Before Christ        | 2     |
     * |                                 | GGGGG   | A, B                              |       |
     * | Calendar year                   | y       | 44, 1, 1900, 2017                 | 5     |
     * |                                 | yo      | 44th, 1st, 0th, 17th              | 5,7   |
     * |                                 | yy      | 44, 01, 00, 17                    | 5     |
     * |                                 | yyy     | 044, 001, 1900, 2017              | 5     |
     * |                                 | yyyy    | 0044, 0001, 1900, 2017            | 5     |
     * |                                 | yyyyy   | ...                               | 3,5   |
     * | Local week-numbering year       | Y       | 44, 1, 1900, 2017                 | 5     |
     * |                                 | Yo      | 44th, 1st, 1900th, 2017th         | 5,7   |
     * |                                 | YY      | 44, 01, 00, 17                    | 5,8   |
     * |                                 | YYY     | 044, 001, 1900, 2017              | 5     |
     * |                                 | YYYY    | 0044, 0001, 1900, 2017            | 5,8   |
     * |                                 | YYYYY   | ...                               | 3,5   |
     * | ISO week-numbering year         | R       | -43, 0, 1, 1900, 2017             | 5,7   |
     * |                                 | RR      | -43, 00, 01, 1900, 2017           | 5,7   |
     * |                                 | RRR     | -043, 000, 001, 1900, 2017        | 5,7   |
     * |                                 | RRRR    | -0043, 0000, 0001, 1900, 2017     | 5,7   |
     * |                                 | RRRRR   | ...                               | 3,5,7 |
     * | Extended year                   | u       | -43, 0, 1, 1900, 2017             | 5     |
     * |                                 | uu      | -43, 01, 1900, 2017               | 5     |
     * |                                 | uuu     | -043, 001, 1900, 2017             | 5     |
     * |                                 | uuuu    | -0043, 0001, 1900, 2017           | 5     |
     * |                                 | uuuuu   | ...                               | 3,5   |
     * | Quarter (formatting)            | Q       | 1, 2, 3, 4                        |       |
     * |                                 | Qo      | 1st, 2nd, 3rd, 4th                | 7     |
     * |                                 | QQ      | 01, 02, 03, 04                    |       |
     * |                                 | QQQ     | Q1, Q2, Q3, Q4                    |       |
     * |                                 | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
     * |                                 | QQQQQ   | 1, 2, 3, 4                        | 4     |
     * | Quarter (stand-alone)           | q       | 1, 2, 3, 4                        |       |
     * |                                 | qo      | 1st, 2nd, 3rd, 4th                | 7     |
     * |                                 | qq      | 01, 02, 03, 04                    |       |
     * |                                 | qqq     | Q1, Q2, Q3, Q4                    |       |
     * |                                 | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
     * |                                 | qqqqq   | 1, 2, 3, 4                        | 4     |
     * | Month (formatting)              | M       | 1, 2, ..., 12                     |       |
     * |                                 | Mo      | 1st, 2nd, ..., 12th               | 7     |
     * |                                 | MM      | 01, 02, ..., 12                   |       |
     * |                                 | MMM     | Jan, Feb, ..., Dec                |       |
     * |                                 | MMMM    | January, February, ..., December  | 2     |
     * |                                 | MMMMM   | J, F, ..., D                      |       |
     * | Month (stand-alone)             | L       | 1, 2, ..., 12                     |       |
     * |                                 | Lo      | 1st, 2nd, ..., 12th               | 7     |
     * |                                 | LL      | 01, 02, ..., 12                   |       |
     * |                                 | LLL     | Jan, Feb, ..., Dec                |       |
     * |                                 | LLLL    | January, February, ..., December  | 2     |
     * |                                 | LLLLL   | J, F, ..., D                      |       |
     * | Local week of year              | w       | 1, 2, ..., 53                     |       |
     * |                                 | wo      | 1st, 2nd, ..., 53th               | 7     |
     * |                                 | ww      | 01, 02, ..., 53                   |       |
     * | ISO week of year                | I       | 1, 2, ..., 53                     | 7     |
     * |                                 | Io      | 1st, 2nd, ..., 53th               | 7     |
     * |                                 | II      | 01, 02, ..., 53                   | 7     |
     * | Day of month                    | d       | 1, 2, ..., 31                     |       |
     * |                                 | do      | 1st, 2nd, ..., 31st               | 7     |
     * |                                 | dd      | 01, 02, ..., 31                   |       |
     * | Day of year                     | D       | 1, 2, ..., 365, 366               | 9     |
     * |                                 | Do      | 1st, 2nd, ..., 365th, 366th       | 7     |
     * |                                 | DD      | 01, 02, ..., 365, 366             | 9     |
     * |                                 | DDD     | 001, 002, ..., 365, 366           |       |
     * |                                 | DDDD    | ...                               | 3     |
     * | Day of week (formatting)        | E..EEE  | Mon, Tue, Wed, ..., Sun           |       |
     * |                                 | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
     * |                                 | EEEEE   | M, T, W, T, F, S, S               |       |
     * |                                 | EEEEEE  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
     * | ISO day of week (formatting)    | i       | 1, 2, 3, ..., 7                   | 7     |
     * |                                 | io      | 1st, 2nd, ..., 7th                | 7     |
     * |                                 | ii      | 01, 02, ..., 07                   | 7     |
     * |                                 | iii     | Mon, Tue, Wed, ..., Sun           | 7     |
     * |                                 | iiii    | Monday, Tuesday, ..., Sunday      | 2,7   |
     * |                                 | iiiii   | M, T, W, T, F, S, S               | 7     |
     * |                                 | iiiiii  | Mo, Tu, We, Th, Fr, Sa, Su        | 7     |
     * | Local day of week (formatting)  | e       | 2, 3, 4, ..., 1                   |       |
     * |                                 | eo      | 2nd, 3rd, ..., 1st                | 7     |
     * |                                 | ee      | 02, 03, ..., 01                   |       |
     * |                                 | eee     | Mon, Tue, Wed, ..., Sun           |       |
     * |                                 | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
     * |                                 | eeeee   | M, T, W, T, F, S, S               |       |
     * |                                 | eeeeee  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
     * | Local day of week (stand-alone) | c       | 2, 3, 4, ..., 1                   |       |
     * |                                 | co      | 2nd, 3rd, ..., 1st                | 7     |
     * |                                 | cc      | 02, 03, ..., 01                   |       |
     * |                                 | ccc     | Mon, Tue, Wed, ..., Sun           |       |
     * |                                 | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
     * |                                 | ccccc   | M, T, W, T, F, S, S               |       |
     * |                                 | cccccc  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
     * | AM, PM                          | a..aa   | AM, PM                            |       |
     * |                                 | aaa     | am, pm                            |       |
     * |                                 | aaaa    | a.m., p.m.                        | 2     |
     * |                                 | aaaaa   | a, p                              |       |
     * | AM, PM, noon, midnight          | b..bb   | AM, PM, noon, midnight            |       |
     * |                                 | bbb     | am, pm, noon, midnight            |       |
     * |                                 | bbbb    | a.m., p.m., noon, midnight        | 2     |
     * |                                 | bbbbb   | a, p, n, mi                       |       |
     * | Flexible day period             | B..BBB  | at night, in the morning, ...     |       |
     * |                                 | BBBB    | at night, in the morning, ...     | 2     |
     * |                                 | BBBBB   | at night, in the morning, ...     |       |
     * | Hour [1-12]                     | h       | 1, 2, ..., 11, 12                 |       |
     * |                                 | ho      | 1st, 2nd, ..., 11th, 12th         | 7     |
     * |                                 | hh      | 01, 02, ..., 11, 12               |       |
     * | Hour [0-23]                     | H       | 0, 1, 2, ..., 23                  |       |
     * |                                 | Ho      | 0th, 1st, 2nd, ..., 23rd          | 7     |
     * |                                 | HH      | 00, 01, 02, ..., 23               |       |
     * | Hour [0-11]                     | K       | 1, 2, ..., 11, 0                  |       |
     * |                                 | Ko      | 1st, 2nd, ..., 11th, 0th          | 7     |
     * |                                 | KK      | 01, 02, ..., 11, 00               |       |
     * | Hour [1-24]                     | k       | 24, 1, 2, ..., 23                 |       |
     * |                                 | ko      | 24th, 1st, 2nd, ..., 23rd         | 7     |
     * |                                 | kk      | 24, 01, 02, ..., 23               |       |
     * | Minute                          | m       | 0, 1, ..., 59                     |       |
     * |                                 | mo      | 0th, 1st, ..., 59th               | 7     |
     * |                                 | mm      | 00, 01, ..., 59                   |       |
     * | Second                          | s       | 0, 1, ..., 59                     |       |
     * |                                 | so      | 0th, 1st, ..., 59th               | 7     |
     * |                                 | ss      | 00, 01, ..., 59                   |       |
     * | Fraction of second              | S       | 0, 1, ..., 9                      |       |
     * |                                 | SS      | 00, 01, ..., 99                   |       |
     * |                                 | SSS     | 000, 001, ..., 999                |       |
     * |                                 | SSSS    | ...                               | 3     |
     * | Timezone (ISO-8601 w/ Z)        | X       | -08, +0530, Z                     |       |
     * |                                 | XX      | -0800, +0530, Z                   |       |
     * |                                 | XXX     | -08:00, +05:30, Z                 |       |
     * |                                 | XXXX    | -0800, +0530, Z, +123456          | 2     |
     * |                                 | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
     * | Timezone (ISO-8601 w/o Z)       | x       | -08, +0530, +00                   |       |
     * |                                 | xx      | -0800, +0530, +0000               |       |
     * |                                 | xxx     | -08:00, +05:30, +00:00            | 2     |
     * |                                 | xxxx    | -0800, +0530, +0000, +123456      |       |
     * |                                 | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
     * | Timezone (GMT)                  | O...OOO | GMT-8, GMT+5:30, GMT+0            |       |
     * |                                 | OOOO    | GMT-08:00, GMT+05:30, GMT+00:00   | 2     |
     * | Timezone (specific non-locat.)  | z...zzz | GMT-8, GMT+5:30, GMT+0            | 6     |
     * |                                 | zzzz    | GMT-08:00, GMT+05:30, GMT+00:00   | 2,6   |
     * | Seconds timestamp               | t       | 512969520                         | 7     |
     * |                                 | tt      | ...                               | 3,7   |
     * | Milliseconds timestamp          | T       | 512969520900                      | 7     |
     * |                                 | TT      | ...                               | 3,7   |
     * | Long localized date             | P       | 04/29/1453                        | 7     |
     * |                                 | PP      | Apr 29, 1453                      | 7     |
     * |                                 | PPP     | April 29th, 1453                  | 7     |
     * |                                 | PPPP    | Friday, April 29th, 1453          | 2,7   |
     * | Long localized time             | p       | 12:00 AM                          | 7     |
     * |                                 | pp      | 12:00:00 AM                       | 7     |
     * |                                 | ppp     | 12:00:00 AM GMT+2                 | 7     |
     * |                                 | pppp    | 12:00:00 AM GMT+02:00             | 2,7   |
     * | Combination of date and time    | Pp      | 04/29/1453, 12:00 AM              | 7     |
     * |                                 | PPpp    | Apr 29, 1453, 12:00:00 AM         | 7     |
     * |                                 | PPPppp  | April 29th, 1453 at ...           | 7     |
     * |                                 | PPPPpppp| Friday, April 29th, 1453 at ...   | 2,7   |
     * Notes:
     * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
     *    are the same as "stand-alone" units, but are different in some languages.
     *    "Formatting" units are declined according to the rules of the language
     *    in the context of a date. "Stand-alone" units are always nominative singular:
     *
     *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
     *
     *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
     *
     * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
     *    the single quote characters (see below).
     *    If the sequence is longer than listed in table (e.g. `EEEEEEEEEEE`)
     *    the output will be the same as default pattern for this unit, usually
     *    the longest one (in case of ISO weekdays, `EEEE`). Default patterns for units
     *    are marked with "2" in the last column of the table.
     *
     *    `format(new Date(2017, 10, 6), 'MMM') //=> 'Nov'`
     *
     *    `format(new Date(2017, 10, 6), 'MMMM') //=> 'November'`
     *
     *    `format(new Date(2017, 10, 6), 'MMMMM') //=> 'N'`
     *
     *    `format(new Date(2017, 10, 6), 'MMMMMM') //=> 'November'`
     *
     *    `format(new Date(2017, 10, 6), 'MMMMMMM') //=> 'November'`
     *
     * 3. Some patterns could be unlimited length (such as `yyyyyyyy`).
     *    The output will be padded with zeros to match the length of the pattern.
     *
     *    `format(new Date(2017, 10, 6), 'yyyyyyyy') //=> '00002017'`
     *
     * 4. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
     *    These tokens represent the shortest form of the quarter.
     *
     * 5. The main difference between `y` and `u` patterns are B.C. years:
     *
     *    | Year | `y` | `u` |
     *    |------|-----|-----|
     *    | AC 1 |   1 |   1 |
     *    | BC 1 |   1 |   0 |
     *    | BC 2 |   2 |  -1 |
     *
     *    Also `yy` always returns the last two digits of a year,
     *    while `uu` pads single digit years to 2 characters and returns other years unchanged:
     *
     *    | Year | `yy` | `uu` |
     *    |------|------|------|
     *    | 1    |   01 |   01 |
     *    | 14   |   14 |   14 |
     *    | 376  |   76 |  376 |
     *    | 1453 |   53 | 1453 |
     *
     *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
     *    except local week-numbering years are dependent on `options.weekStartsOn`
     *    and `options.firstWeekContainsDate` (compare [getISOWeekYear]{@link https://date-fns.org/docs/getISOWeekYear}
     *    and [getWeekYear]{@link https://date-fns.org/docs/getWeekYear}).
     *
     * 6. Specific non-location timezones are currently unavailable in `date-fns`,
     *    so right now these tokens fall back to GMT timezones.
     *
     * 7. These patterns are not in the Unicode Technical Standard #35:
     *    - `i`: ISO day of week
     *    - `I`: ISO week of year
     *    - `R`: ISO week-numbering year
     *    - `t`: seconds timestamp
     *    - `T`: milliseconds timestamp
     *    - `o`: ordinal number modifier
     *    - `P`: long localized date
     *    - `p`: long localized time
     *
     * 8. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
     *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
     *
     * 9. `D` and `DD` tokens represent days of the year but they are often confused with days of the month.
     *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
     *
     * @param {Date|Number} date - the original date
     * @param {String} format - the string of tokens
     * @param {Object} [options] - an object with options.
     * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
     * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
     * @param {Number} [options.firstWeekContainsDate=1] - the day of January, which is
     * @param {Boolean} [options.useAdditionalWeekYearTokens=false] - if true, allows usage of the week-numbering year tokens `YY` and `YYYY`;
     *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
     * @param {Boolean} [options.useAdditionalDayOfYearTokens=false] - if true, allows usage of the day of year tokens `D` and `DD`;
     *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
     * @returns {String} the formatted date string
     * @throws {TypeError} 2 arguments required
     * @throws {RangeError} `date` must not be Invalid Date
     * @throws {RangeError} `options.locale` must contain `localize` property
     * @throws {RangeError} `options.locale` must contain `formatLong` property
     * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
     * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
     * @throws {RangeError} use `yyyy` instead of `YYYY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
     * @throws {RangeError} use `yy` instead of `YY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
     * @throws {RangeError} use `d` instead of `D` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
     * @throws {RangeError} use `dd` instead of `DD` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
     * @throws {RangeError} format string contains an unescaped latin alphabet character
     *
     * @example
     * // Represent 11 February 2014 in middle-endian format:
     * const result = format(new Date(2014, 1, 11), 'MM/dd/yyyy')
     * //=> '02/11/2014'
     *
     * @example
     * // Represent 2 July 2014 in Esperanto:
     * import { eoLocale } from 'date-fns/locale/eo'
     * const result = format(new Date(2014, 6, 2), "do 'de' MMMM yyyy", {
     *   locale: eoLocale
     * })
     * //=> '2-a de julio 2014'
     *
     * @example
     * // Escape string by single quote characters:
     * const result = format(new Date(2014, 6, 2, 15), "h 'o''clock'")
     * //=> "3 o'clock"
     */

    function format$4(dirtyDate, dirtyFormatStr, options) {
      var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;

      requiredArgs$1(2, arguments);
      var formatStr = String(dirtyFormatStr);
      var defaultOptions = getDefaultOptions$1();
      var locale = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions.locale) !== null && _ref !== void 0 ? _ref : defaultLocale$1;
      var firstWeekContainsDate = toInteger$1((_ref2 = (_ref3 = (_ref4 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale2 = options.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.firstWeekContainsDate) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN

      if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
        throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
      }

      var weekStartsOn = toInteger$1((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale3 = options.locale) === null || _options$locale3 === void 0 ? void 0 : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === void 0 ? void 0 : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

      if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
        throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
      }

      if (!locale.localize) {
        throw new RangeError('locale must contain localize property');
      }

      if (!locale.formatLong) {
        throw new RangeError('locale must contain formatLong property');
      }

      var originalDate = toDate$2(dirtyDate);

      if (!isValid$1(originalDate)) {
        throw new RangeError('Invalid time value');
      } // Convert the date in system timezone to the same date in UTC+00:00 timezone.
      // This ensures that when UTC functions will be implemented, locales will be compatible with them.
      // See an issue about UTC functions: https://github.com/date-fns/date-fns/issues/376


      var timezoneOffset = getTimezoneOffsetInMilliseconds$1(originalDate);
      var utcDate = subMilliseconds$1(originalDate, timezoneOffset);
      var formatterOptions = {
        firstWeekContainsDate: firstWeekContainsDate,
        weekStartsOn: weekStartsOn,
        locale: locale,
        _originalDate: originalDate
      };
      var result = formatStr.match(longFormattingTokensRegExp$1).map(function (substring) {
        var firstCharacter = substring[0];

        if (firstCharacter === 'p' || firstCharacter === 'P') {
          var longFormatter = longFormatters$2[firstCharacter];
          return longFormatter(substring, locale.formatLong);
        }

        return substring;
      }).join('').match(formattingTokensRegExp$1).map(function (substring) {
        // Replace two single quote characters with one single quote character
        if (substring === "''") {
          return "'";
        }

        var firstCharacter = substring[0];

        if (firstCharacter === "'") {
          return cleanEscapedString$1(substring);
        }

        var formatter = formatters$3[firstCharacter];

        if (formatter) {
          if (!(options !== null && options !== void 0 && options.useAdditionalWeekYearTokens) && isProtectedWeekYearToken$1(substring)) {
            throwProtectedError$1(substring, dirtyFormatStr, String(dirtyDate));
          }

          if (!(options !== null && options !== void 0 && options.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken$1(substring)) {
            throwProtectedError$1(substring, dirtyFormatStr, String(dirtyDate));
          }

          return formatter(utcDate, substring, locale.localize, formatterOptions);
        }

        if (firstCharacter.match(unescapedLatinCharacterRegExp$1)) {
          throw new RangeError('Format string contains an unescaped latin alphabet character `' + firstCharacter + '`');
        }

        return substring;
      }).join('');
      return result;
    }

    function cleanEscapedString$1(input) {
      var matched = input.match(escapedStringRegExp$1);

      if (!matched) {
        return input;
      }

      return matched[1].replace(doubleQuoteRegExp$1, "'");
    }

    function assign$1(target, object) {
      if (target == null) {
        throw new TypeError('assign requires that input parameter not be null or undefined');
      }

      for (var property in object) {
        if (Object.prototype.hasOwnProperty.call(object, property)) {
          target[property] = object[property];
        }
      }

      return target;
    }

    function cloneObject$1(object) {
      return assign$1({}, object);
    }

    var MILLISECONDS_IN_MINUTE = 1000 * 60;
    var MINUTES_IN_DAY = 60 * 24;
    var MINUTES_IN_MONTH = MINUTES_IN_DAY * 30;
    var MINUTES_IN_YEAR = MINUTES_IN_DAY * 365;
    /**
     * @name formatDistanceStrict
     * @category Common Helpers
     * @summary Return the distance between the given dates in words.
     *
     * @description
     * Return the distance between the given dates in words, using strict units.
     * This is like `formatDistance`, but does not use helpers like 'almost', 'over',
     * 'less than' and the like.
     *
     * | Distance between dates | Result              |
     * |------------------------|---------------------|
     * | 0 ... 59 secs          | [0..59] seconds     |
     * | 1 ... 59 mins          | [1..59] minutes     |
     * | 1 ... 23 hrs           | [1..23] hours       |
     * | 1 ... 29 days          | [1..29] days        |
     * | 1 ... 11 months        | [1..11] months      |
     * | 1 ... N years          | [1..N]  years       |
     *
     * @param {Date|Number} date - the date
     * @param {Date|Number} baseDate - the date to compare with
     * @param {Object} [options] - an object with options.
     * @param {Boolean} [options.addSuffix=false] - result indicates if the second date is earlier or later than the first
     * @param {'second'|'minute'|'hour'|'day'|'month'|'year'} [options.unit] - if specified, will force a unit
     * @param {'floor'|'ceil'|'round'} [options.roundingMethod='round'] - which way to round partial units
     * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
     * @returns {String} the distance in words
     * @throws {TypeError} 2 arguments required
     * @throws {RangeError} `date` must not be Invalid Date
     * @throws {RangeError} `baseDate` must not be Invalid Date
     * @throws {RangeError} `options.roundingMethod` must be 'floor', 'ceil' or 'round'
     * @throws {RangeError} `options.unit` must be 'second', 'minute', 'hour', 'day', 'month' or 'year'
     * @throws {RangeError} `options.locale` must contain `formatDistance` property
     *
     * @example
     * // What is the distance between 2 July 2014 and 1 January 2015?
     * const result = formatDistanceStrict(new Date(2014, 6, 2), new Date(2015, 0, 2))
     * //=> '6 months'
     *
     * @example
     * // What is the distance between 1 January 2015 00:00:15
     * // and 1 January 2015 00:00:00?
     * const result = formatDistanceStrict(
     *   new Date(2015, 0, 1, 0, 0, 15),
     *   new Date(2015, 0, 1, 0, 0, 0)
     * )
     * //=> '15 seconds'
     *
     * @example
     * // What is the distance from 1 January 2016
     * // to 1 January 2015, with a suffix?
     * const result = formatDistanceStrict(new Date(2015, 0, 1), new Date(2016, 0, 1), {
     *   addSuffix: true
     * })
     * //=> '1 year ago'
     *
     * @example
     * // What is the distance from 1 January 2016
     * // to 1 January 2015, in minutes?
     * const result = formatDistanceStrict(new Date(2016, 0, 1), new Date(2015, 0, 1), {
     *   unit: 'minute'
     * })
     * //=> '525600 minutes'
     *
     * @example
     * // What is the distance from 1 January 2015
     * // to 28 January 2015, in months, rounded up?
     * const result = formatDistanceStrict(new Date(2015, 0, 28), new Date(2015, 0, 1), {
     *   unit: 'month',
     *   roundingMethod: 'ceil'
     * })
     * //=> '1 month'
     *
     * @example
     * // What is the distance between 1 August 2016 and 1 January 2015 in Esperanto?
     * import { eoLocale } from 'date-fns/locale/eo'
     * const result = formatDistanceStrict(new Date(2016, 7, 1), new Date(2015, 0, 1), {
     *   locale: eoLocale
     * })
     * //=> '1 jaro'
     */

    function formatDistanceStrict(dirtyDate, dirtyBaseDate, options) {
      var _ref, _options$locale, _options$roundingMeth;

      requiredArgs$1(2, arguments);
      var defaultOptions = getDefaultOptions$1();
      var locale = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions.locale) !== null && _ref !== void 0 ? _ref : defaultLocale$1;

      if (!locale.formatDistance) {
        throw new RangeError('locale must contain localize.formatDistance property');
      }

      var comparison = compareAsc(dirtyDate, dirtyBaseDate);

      if (isNaN(comparison)) {
        throw new RangeError('Invalid time value');
      }

      var localizeOptions = assign$1(cloneObject$1(options), {
        addSuffix: Boolean(options === null || options === void 0 ? void 0 : options.addSuffix),
        comparison: comparison
      });
      var dateLeft;
      var dateRight;

      if (comparison > 0) {
        dateLeft = toDate$2(dirtyBaseDate);
        dateRight = toDate$2(dirtyDate);
      } else {
        dateLeft = toDate$2(dirtyDate);
        dateRight = toDate$2(dirtyBaseDate);
      }

      var roundingMethod = String((_options$roundingMeth = options === null || options === void 0 ? void 0 : options.roundingMethod) !== null && _options$roundingMeth !== void 0 ? _options$roundingMeth : 'round');
      var roundingMethodFn;

      if (roundingMethod === 'floor') {
        roundingMethodFn = Math.floor;
      } else if (roundingMethod === 'ceil') {
        roundingMethodFn = Math.ceil;
      } else if (roundingMethod === 'round') {
        roundingMethodFn = Math.round;
      } else {
        throw new RangeError("roundingMethod must be 'floor', 'ceil' or 'round'");
      }

      var milliseconds = dateRight.getTime() - dateLeft.getTime();
      var minutes = milliseconds / MILLISECONDS_IN_MINUTE;
      var timezoneOffset = getTimezoneOffsetInMilliseconds$1(dateRight) - getTimezoneOffsetInMilliseconds$1(dateLeft); // Use DST-normalized difference in minutes for years, months and days;
      // use regular difference in minutes for hours, minutes and seconds.

      var dstNormalizedMinutes = (milliseconds - timezoneOffset) / MILLISECONDS_IN_MINUTE;
      var defaultUnit = options === null || options === void 0 ? void 0 : options.unit;
      var unit;

      if (!defaultUnit) {
        if (minutes < 1) {
          unit = 'second';
        } else if (minutes < 60) {
          unit = 'minute';
        } else if (minutes < MINUTES_IN_DAY) {
          unit = 'hour';
        } else if (dstNormalizedMinutes < MINUTES_IN_MONTH) {
          unit = 'day';
        } else if (dstNormalizedMinutes < MINUTES_IN_YEAR) {
          unit = 'month';
        } else {
          unit = 'year';
        }
      } else {
        unit = String(defaultUnit);
      } // 0 up to 60 seconds


      if (unit === 'second') {
        var seconds = roundingMethodFn(milliseconds / 1000);
        return locale.formatDistance('xSeconds', seconds, localizeOptions); // 1 up to 60 mins
      } else if (unit === 'minute') {
        var roundedMinutes = roundingMethodFn(minutes);
        return locale.formatDistance('xMinutes', roundedMinutes, localizeOptions); // 1 up to 24 hours
      } else if (unit === 'hour') {
        var hours = roundingMethodFn(minutes / 60);
        return locale.formatDistance('xHours', hours, localizeOptions); // 1 up to 30 days
      } else if (unit === 'day') {
        var days = roundingMethodFn(dstNormalizedMinutes / MINUTES_IN_DAY);
        return locale.formatDistance('xDays', days, localizeOptions); // 1 up to 12 months
      } else if (unit === 'month') {
        var months = roundingMethodFn(dstNormalizedMinutes / MINUTES_IN_MONTH);
        return months === 12 && defaultUnit !== 'month' ? locale.formatDistance('xYears', 1, localizeOptions) : locale.formatDistance('xMonths', months, localizeOptions); // 1 year up to max Date
      } else if (unit === 'year') {
        var years = roundingMethodFn(dstNormalizedMinutes / MINUTES_IN_YEAR);
        return locale.formatDistance('xYears', years, localizeOptions);
      }

      throw new RangeError("unit must be 'second', 'minute', 'hour', 'day', 'month' or 'year'");
    }

    /**
     * @name fromUnixTime
     * @category Timestamp Helpers
     * @summary Create a date from a Unix timestamp.
     *
     * @description
     * Create a date from a Unix timestamp (in seconds). Decimal values will be discarded.
     *
     * @param {Number} unixTime - the given Unix timestamp (in seconds)
     * @returns {Date} the date
     * @throws {TypeError} 1 argument required
     *
     * @example
     * // Create the date 29 February 2012 11:45:05:
     * const result = fromUnixTime(1330515905)
     * //=> Wed Feb 29 2012 11:45:05
     */

    function fromUnixTime(dirtyUnixTime) {
      requiredArgs$1(1, arguments);
      var unixTime = toInteger$1(dirtyUnixTime);
      return toDate$2(unixTime * 1000);
    }

    /**
     * @name getDate
     * @category Day Helpers
     * @summary Get the day of the month of the given date.
     *
     * @description
     * Get the day of the month of the given date.
     *
     * @param {Date|Number} date - the given date
     * @returns {Number} the day of month
     * @throws {TypeError} 1 argument required
     *
     * @example
     * // Which day of the month is 29 February 2012?
     * const result = getDate(new Date(2012, 1, 29))
     * //=> 29
     */

    function getDate(dirtyDate) {
      requiredArgs$1(1, arguments);
      var date = toDate$2(dirtyDate);
      var dayOfMonth = date.getDate();
      return dayOfMonth;
    }

    /**
     * @name getDay
     * @category Weekday Helpers
     * @summary Get the day of the week of the given date.
     *
     * @description
     * Get the day of the week of the given date.
     *
     * @param {Date|Number} date - the given date
     * @returns {0|1|2|3|4|5|6} the day of week, 0 represents Sunday
     * @throws {TypeError} 1 argument required
     *
     * @example
     * // Which day of the week is 29 February 2012?
     * const result = getDay(new Date(2012, 1, 29))
     * //=> 3
     */

    function getDay(dirtyDate) {
      requiredArgs$1(1, arguments);
      var date = toDate$2(dirtyDate);
      var day = date.getDay();
      return day;
    }

    /**
     * @name getDaysInMonth
     * @category Month Helpers
     * @summary Get the number of days in a month of the given date.
     *
     * @description
     * Get the number of days in a month of the given date.
     *
     * @param {Date|Number} date - the given date
     * @returns {Number} the number of days in a month
     * @throws {TypeError} 1 argument required
     *
     * @example
     * // How many days are in February 2000?
     * const result = getDaysInMonth(new Date(2000, 1))
     * //=> 29
     */

    function getDaysInMonth(dirtyDate) {
      requiredArgs$1(1, arguments);
      var date = toDate$2(dirtyDate);
      var year = date.getFullYear();
      var monthIndex = date.getMonth();
      var lastDayOfMonth = new Date(0);
      lastDayOfMonth.setFullYear(year, monthIndex + 1, 0);
      lastDayOfMonth.setHours(0, 0, 0, 0);
      return lastDayOfMonth.getDate();
    }

    /**
     * @name getHours
     * @category Hour Helpers
     * @summary Get the hours of the given date.
     *
     * @description
     * Get the hours of the given date.
     *
     * @param {Date|Number} date - the given date
     * @returns {Number} the hours
     * @throws {TypeError} 1 argument required
     *
     * @example
     * // Get the hours of 29 February 2012 11:45:00:
     * const result = getHours(new Date(2012, 1, 29, 11, 45))
     * //=> 11
     */

    function getHours(dirtyDate) {
      requiredArgs$1(1, arguments);
      var date = toDate$2(dirtyDate);
      var hours = date.getHours();
      return hours;
    }

    /**
     * @name getMinutes
     * @category Minute Helpers
     * @summary Get the minutes of the given date.
     *
     * @description
     * Get the minutes of the given date.
     *
     * @param {Date|Number} date - the given date
     * @returns {Number} the minutes
     * @throws {TypeError} 1 argument required
     *
     * @example
     * // Get the minutes of 29 February 2012 11:45:05:
     * const result = getMinutes(new Date(2012, 1, 29, 11, 45, 5))
     * //=> 45
     */

    function getMinutes(dirtyDate) {
      requiredArgs$1(1, arguments);
      var date = toDate$2(dirtyDate);
      var minutes = date.getMinutes();
      return minutes;
    }

    /**
     * @name getMonth
     * @category Month Helpers
     * @summary Get the month of the given date.
     *
     * @description
     * Get the month of the given date.
     *
     * @param {Date|Number} date - the given date
     * @returns {Number} the month
     * @throws {TypeError} 1 argument required
     *
     * @example
     * // Which month is 29 February 2012?
     * const result = getMonth(new Date(2012, 1, 29))
     * //=> 1
     */

    function getMonth(dirtyDate) {
      requiredArgs$1(1, arguments);
      var date = toDate$2(dirtyDate);
      var month = date.getMonth();
      return month;
    }

    /**
     * @name getSeconds
     * @category Second Helpers
     * @summary Get the seconds of the given date.
     *
     * @description
     * Get the seconds of the given date.
     *
     * @param {Date|Number} date - the given date
     * @returns {Number} the seconds
     * @throws {TypeError} 1 argument required
     *
     * @example
     * // Get the seconds of 29 February 2012 11:45:05.123:
     * const result = getSeconds(new Date(2012, 1, 29, 11, 45, 5, 123))
     * //=> 5
     */

    function getSeconds(dirtyDate) {
      requiredArgs$1(1, arguments);
      var date = toDate$2(dirtyDate);
      var seconds = date.getSeconds();
      return seconds;
    }

    /**
     * @name getTime
     * @category Timestamp Helpers
     * @summary Get the milliseconds timestamp of the given date.
     *
     * @description
     * Get the milliseconds timestamp of the given date.
     *
     * @param {Date|Number} date - the given date
     * @returns {Number} the timestamp
     * @throws {TypeError} 1 argument required
     *
     * @example
     * // Get the timestamp of 29 February 2012 11:45:05.123:
     * const result = getTime(new Date(2012, 1, 29, 11, 45, 5, 123))
     * //=> 1330515905123
     */

    function getTime(dirtyDate) {
      requiredArgs$1(1, arguments);
      var date = toDate$2(dirtyDate);
      var timestamp = date.getTime();
      return timestamp;
    }

    /**
     * @name getYear
     * @category Year Helpers
     * @summary Get the year of the given date.
     *
     * @description
     * Get the year of the given date.
     *
     * @param {Date|Number} date - the given date
     * @returns {Number} the year
     * @throws {TypeError} 1 argument required
     *
     * @example
     * // Which year is 2 July 2014?
     * const result = getYear(new Date(2014, 6, 2))
     * //=> 2014
     */

    function getYear(dirtyDate) {
      requiredArgs$1(1, arguments);
      return toDate$2(dirtyDate).getFullYear();
    }

    function _defineProperty$w(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }

    var TIMEZONE_UNIT_PRIORITY = 10;
    class Setter {
      constructor() {
        _defineProperty$w(this, "priority", void 0);

        _defineProperty$w(this, "subPriority", 0);
      }

      validate(_utcDate, _options) {
        return true;
      }

    }
    class ValueSetter extends Setter {
      constructor(value, validateValue, setValue, priority, subPriority) {
        super();
        this.value = value;
        this.validateValue = validateValue;
        this.setValue = setValue;
        this.priority = priority;

        if (subPriority) {
          this.subPriority = subPriority;
        }
      }

      validate(utcDate, options) {
        return this.validateValue(utcDate, this.value, options);
      }

      set(utcDate, flags, options) {
        return this.setValue(utcDate, flags, this.value, options);
      }

    }
    class DateToSystemTimezoneSetter extends Setter {
      constructor() {
        super(...arguments);

        _defineProperty$w(this, "priority", TIMEZONE_UNIT_PRIORITY);

        _defineProperty$w(this, "subPriority", -1);
      }

      set(date, flags) {
        if (flags.timestampIsSet) {
          return date;
        }

        var convertedDate = new Date(0);
        convertedDate.setFullYear(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
        convertedDate.setHours(date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());
        return convertedDate;
      }

    }

    function _defineProperty$v(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }
    class Parser {
      constructor() {
        _defineProperty$v(this, "incompatibleTokens", void 0);

        _defineProperty$v(this, "priority", void 0);

        _defineProperty$v(this, "subPriority", void 0);
      }

      run(dateString, token, match, options) {
        var result = this.parse(dateString, token, match, options);

        if (!result) {
          return null;
        }

        return {
          setter: new ValueSetter(result.value, this.validate, this.set, this.priority, this.subPriority),
          rest: result.rest
        };
      }

      validate(_utcDate, _value, _options) {
        return true;
      }

    }

    function _defineProperty$u(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }
    class EraParser extends Parser {
      constructor() {
        super(...arguments);

        _defineProperty$u(this, "priority", 140);

        _defineProperty$u(this, "incompatibleTokens", ['R', 'u', 't', 'T']);
      }

      parse(dateString, token, match) {
        switch (token) {
          // AD, BC
          case 'G':
          case 'GG':
          case 'GGG':
            return match.era(dateString, {
              width: 'abbreviated'
            }) || match.era(dateString, {
              width: 'narrow'
            });
          // A, B

          case 'GGGGG':
            return match.era(dateString, {
              width: 'narrow'
            });
          // Anno Domini, Before Christ

          case 'GGGG':
          default:
            return match.era(dateString, {
              width: 'wide'
            }) || match.era(dateString, {
              width: 'abbreviated'
            }) || match.era(dateString, {
              width: 'narrow'
            });
        }
      }

      set(date, flags, value) {
        flags.era = value;
        date.setUTCFullYear(value, 0, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }

    }

    var numericPatterns = {
      month: /^(1[0-2]|0?\d)/,
      // 0 to 12
      date: /^(3[0-1]|[0-2]?\d)/,
      // 0 to 31
      dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
      // 0 to 366
      week: /^(5[0-3]|[0-4]?\d)/,
      // 0 to 53
      hour23h: /^(2[0-3]|[0-1]?\d)/,
      // 0 to 23
      hour24h: /^(2[0-4]|[0-1]?\d)/,
      // 0 to 24
      hour11h: /^(1[0-1]|0?\d)/,
      // 0 to 11
      hour12h: /^(1[0-2]|0?\d)/,
      // 0 to 12
      minute: /^[0-5]?\d/,
      // 0 to 59
      second: /^[0-5]?\d/,
      // 0 to 59
      singleDigit: /^\d/,
      // 0 to 9
      twoDigits: /^\d{1,2}/,
      // 0 to 99
      threeDigits: /^\d{1,3}/,
      // 0 to 999
      fourDigits: /^\d{1,4}/,
      // 0 to 9999
      anyDigitsSigned: /^-?\d+/,
      singleDigitSigned: /^-?\d/,
      // 0 to 9, -0 to -9
      twoDigitsSigned: /^-?\d{1,2}/,
      // 0 to 99, -0 to -99
      threeDigitsSigned: /^-?\d{1,3}/,
      // 0 to 999, -0 to -999
      fourDigitsSigned: /^-?\d{1,4}/ // 0 to 9999, -0 to -9999

    };
    var timezonePatterns = {
      basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
      basic: /^([+-])(\d{2})(\d{2})|Z/,
      basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
      extended: /^([+-])(\d{2}):(\d{2})|Z/,
      extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
    };

    function mapValue(parseFnResult, mapFn) {
      if (!parseFnResult) {
        return parseFnResult;
      }

      return {
        value: mapFn(parseFnResult.value),
        rest: parseFnResult.rest
      };
    }
    function parseNumericPattern(pattern, dateString) {
      var matchResult = dateString.match(pattern);

      if (!matchResult) {
        return null;
      }

      return {
        value: parseInt(matchResult[0], 10),
        rest: dateString.slice(matchResult[0].length)
      };
    }
    function parseTimezonePattern(pattern, dateString) {
      var matchResult = dateString.match(pattern);

      if (!matchResult) {
        return null;
      } // Input is 'Z'


      if (matchResult[0] === 'Z') {
        return {
          value: 0,
          rest: dateString.slice(1)
        };
      }

      var sign = matchResult[1] === '+' ? 1 : -1;
      var hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
      var minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
      var seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
      return {
        value: sign * (hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * millisecondsInSecond),
        rest: dateString.slice(matchResult[0].length)
      };
    }
    function parseAnyDigitsSigned(dateString) {
      return parseNumericPattern(numericPatterns.anyDigitsSigned, dateString);
    }
    function parseNDigits(n, dateString) {
      switch (n) {
        case 1:
          return parseNumericPattern(numericPatterns.singleDigit, dateString);

        case 2:
          return parseNumericPattern(numericPatterns.twoDigits, dateString);

        case 3:
          return parseNumericPattern(numericPatterns.threeDigits, dateString);

        case 4:
          return parseNumericPattern(numericPatterns.fourDigits, dateString);

        default:
          return parseNumericPattern(new RegExp('^\\d{1,' + n + '}'), dateString);
      }
    }
    function parseNDigitsSigned(n, dateString) {
      switch (n) {
        case 1:
          return parseNumericPattern(numericPatterns.singleDigitSigned, dateString);

        case 2:
          return parseNumericPattern(numericPatterns.twoDigitsSigned, dateString);

        case 3:
          return parseNumericPattern(numericPatterns.threeDigitsSigned, dateString);

        case 4:
          return parseNumericPattern(numericPatterns.fourDigitsSigned, dateString);

        default:
          return parseNumericPattern(new RegExp('^-?\\d{1,' + n + '}'), dateString);
      }
    }
    function dayPeriodEnumToHours(dayPeriod) {
      switch (dayPeriod) {
        case 'morning':
          return 4;

        case 'evening':
          return 17;

        case 'pm':
        case 'noon':
        case 'afternoon':
          return 12;

        case 'am':
        case 'midnight':
        case 'night':
        default:
          return 0;
      }
    }
    function normalizeTwoDigitYear(twoDigitYear, currentYear) {
      var isCommonEra = currentYear > 0; // Absolute number of the current year:
      // 1 -> 1 AC
      // 0 -> 1 BC
      // -1 -> 2 BC

      var absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
      var result;

      if (absCurrentYear <= 50) {
        result = twoDigitYear || 100;
      } else {
        var rangeEnd = absCurrentYear + 50;
        var rangeEndCentury = Math.floor(rangeEnd / 100) * 100;
        var isPreviousCentury = twoDigitYear >= rangeEnd % 100;
        result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
      }

      return isCommonEra ? result : 1 - result;
    }
    function isLeapYearIndex(year) {
      return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
    }

    function _defineProperty$t(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }
    // | Year     |     y | yy |   yyy |  yyyy | yyyyy |
    // |----------|-------|----|-------|-------|-------|
    // | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
    // | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
    // | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
    // | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
    // | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |

    class YearParser extends Parser {
      constructor() {
        super(...arguments);

        _defineProperty$t(this, "priority", 130);

        _defineProperty$t(this, "incompatibleTokens", ['Y', 'R', 'u', 'w', 'I', 'i', 'e', 'c', 't', 'T']);
      }

      parse(dateString, token, match) {
        var valueCallback = function (year) {
          return {
            year: year,
            isTwoDigitYear: token === 'yy'
          };
        };

        switch (token) {
          case 'y':
            return mapValue(parseNDigits(4, dateString), valueCallback);

          case 'yo':
            return mapValue(match.ordinalNumber(dateString, {
              unit: 'year'
            }), valueCallback);

          default:
            return mapValue(parseNDigits(token.length, dateString), valueCallback);
        }
      }

      validate(_date, value) {
        return value.isTwoDigitYear || value.year > 0;
      }

      set(date, flags, value) {
        var currentYear = date.getUTCFullYear();

        if (value.isTwoDigitYear) {
          var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
          date.setUTCFullYear(normalizedTwoDigitYear, 0, 1);
          date.setUTCHours(0, 0, 0, 0);
          return date;
        }

        var year = !('era' in flags) || flags.era === 1 ? value.year : 1 - value.year;
        date.setUTCFullYear(year, 0, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }

    }

    function _defineProperty$s(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }

    class LocalWeekYearParser extends Parser {
      constructor() {
        super(...arguments);

        _defineProperty$s(this, "priority", 130);

        _defineProperty$s(this, "incompatibleTokens", ['y', 'R', 'u', 'Q', 'q', 'M', 'L', 'I', 'd', 'D', 'i', 't', 'T']);
      }

      parse(dateString, token, match) {
        var valueCallback = function (year) {
          return {
            year: year,
            isTwoDigitYear: token === 'YY'
          };
        };

        switch (token) {
          case 'Y':
            return mapValue(parseNDigits(4, dateString), valueCallback);

          case 'Yo':
            return mapValue(match.ordinalNumber(dateString, {
              unit: 'year'
            }), valueCallback);

          default:
            return mapValue(parseNDigits(token.length, dateString), valueCallback);
        }
      }

      validate(_date, value) {
        return value.isTwoDigitYear || value.year > 0;
      }

      set(date, flags, value, options) {
        var currentYear = getUTCWeekYear$1(date, options);

        if (value.isTwoDigitYear) {
          var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
          date.setUTCFullYear(normalizedTwoDigitYear, 0, options.firstWeekContainsDate);
          date.setUTCHours(0, 0, 0, 0);
          return startOfUTCWeek$1(date, options);
        }

        var year = !('era' in flags) || flags.era === 1 ? value.year : 1 - value.year;
        date.setUTCFullYear(year, 0, options.firstWeekContainsDate);
        date.setUTCHours(0, 0, 0, 0);
        return startOfUTCWeek$1(date, options);
      }

    }

    function _defineProperty$r(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }

    class ISOWeekYearParser extends Parser {
      constructor() {
        super(...arguments);

        _defineProperty$r(this, "priority", 130);

        _defineProperty$r(this, "incompatibleTokens", ['G', 'y', 'Y', 'u', 'Q', 'q', 'M', 'L', 'w', 'd', 'D', 'e', 'c', 't', 'T']);
      }

      parse(dateString, token) {
        if (token === 'R') {
          return parseNDigitsSigned(4, dateString);
        }

        return parseNDigitsSigned(token.length, dateString);
      }

      set(_date, _flags, value) {
        var firstWeekOfYear = new Date(0);
        firstWeekOfYear.setUTCFullYear(value, 0, 4);
        firstWeekOfYear.setUTCHours(0, 0, 0, 0);
        return startOfUTCISOWeek$1(firstWeekOfYear);
      }

    }

    function _defineProperty$q(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }
    class ExtendedYearParser extends Parser {
      constructor() {
        super(...arguments);

        _defineProperty$q(this, "priority", 130);

        _defineProperty$q(this, "incompatibleTokens", ['G', 'y', 'Y', 'R', 'w', 'I', 'i', 'e', 'c', 't', 'T']);
      }

      parse(dateString, token) {
        if (token === 'u') {
          return parseNDigitsSigned(4, dateString);
        }

        return parseNDigitsSigned(token.length, dateString);
      }

      set(date, _flags, value) {
        date.setUTCFullYear(value, 0, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }

    }

    function _defineProperty$p(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }
    class QuarterParser extends Parser {
      constructor() {
        super(...arguments);

        _defineProperty$p(this, "priority", 120);

        _defineProperty$p(this, "incompatibleTokens", ['Y', 'R', 'q', 'M', 'L', 'w', 'I', 'd', 'D', 'i', 'e', 'c', 't', 'T']);
      }

      parse(dateString, token, match) {
        switch (token) {
          // 1, 2, 3, 4
          case 'Q':
          case 'QQ':
            // 01, 02, 03, 04
            return parseNDigits(token.length, dateString);
          // 1st, 2nd, 3rd, 4th

          case 'Qo':
            return match.ordinalNumber(dateString, {
              unit: 'quarter'
            });
          // Q1, Q2, Q3, Q4

          case 'QQQ':
            return match.quarter(dateString, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.quarter(dateString, {
              width: 'narrow',
              context: 'formatting'
            });
          // 1, 2, 3, 4 (narrow quarter; could be not numerical)

          case 'QQQQQ':
            return match.quarter(dateString, {
              width: 'narrow',
              context: 'formatting'
            });
          // 1st quarter, 2nd quarter, ...

          case 'QQQQ':
          default:
            return match.quarter(dateString, {
              width: 'wide',
              context: 'formatting'
            }) || match.quarter(dateString, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.quarter(dateString, {
              width: 'narrow',
              context: 'formatting'
            });
        }
      }

      validate(_date, value) {
        return value >= 1 && value <= 4;
      }

      set(date, _flags, value) {
        date.setUTCMonth((value - 1) * 3, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }

    }

    function _defineProperty$o(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }
    class StandAloneQuarterParser extends Parser {
      constructor() {
        super(...arguments);

        _defineProperty$o(this, "priority", 120);

        _defineProperty$o(this, "incompatibleTokens", ['Y', 'R', 'Q', 'M', 'L', 'w', 'I', 'd', 'D', 'i', 'e', 'c', 't', 'T']);
      }

      parse(dateString, token, match) {
        switch (token) {
          // 1, 2, 3, 4
          case 'q':
          case 'qq':
            // 01, 02, 03, 04
            return parseNDigits(token.length, dateString);
          // 1st, 2nd, 3rd, 4th

          case 'qo':
            return match.ordinalNumber(dateString, {
              unit: 'quarter'
            });
          // Q1, Q2, Q3, Q4

          case 'qqq':
            return match.quarter(dateString, {
              width: 'abbreviated',
              context: 'standalone'
            }) || match.quarter(dateString, {
              width: 'narrow',
              context: 'standalone'
            });
          // 1, 2, 3, 4 (narrow quarter; could be not numerical)

          case 'qqqqq':
            return match.quarter(dateString, {
              width: 'narrow',
              context: 'standalone'
            });
          // 1st quarter, 2nd quarter, ...

          case 'qqqq':
          default:
            return match.quarter(dateString, {
              width: 'wide',
              context: 'standalone'
            }) || match.quarter(dateString, {
              width: 'abbreviated',
              context: 'standalone'
            }) || match.quarter(dateString, {
              width: 'narrow',
              context: 'standalone'
            });
        }
      }

      validate(_date, value) {
        return value >= 1 && value <= 4;
      }

      set(date, _flags, value) {
        date.setUTCMonth((value - 1) * 3, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }

    }

    function _defineProperty$n(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }
    class MonthParser extends Parser {
      constructor() {
        super(...arguments);

        _defineProperty$n(this, "incompatibleTokens", ['Y', 'R', 'q', 'Q', 'L', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']);

        _defineProperty$n(this, "priority", 110);
      }

      parse(dateString, token, match) {
        var valueCallback = function (value) {
          return value - 1;
        };

        switch (token) {
          // 1, 2, ..., 12
          case 'M':
            return mapValue(parseNumericPattern(numericPatterns.month, dateString), valueCallback);
          // 01, 02, ..., 12

          case 'MM':
            return mapValue(parseNDigits(2, dateString), valueCallback);
          // 1st, 2nd, ..., 12th

          case 'Mo':
            return mapValue(match.ordinalNumber(dateString, {
              unit: 'month'
            }), valueCallback);
          // Jan, Feb, ..., Dec

          case 'MMM':
            return match.month(dateString, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.month(dateString, {
              width: 'narrow',
              context: 'formatting'
            });
          // J, F, ..., D

          case 'MMMMM':
            return match.month(dateString, {
              width: 'narrow',
              context: 'formatting'
            });
          // January, February, ..., December

          case 'MMMM':
          default:
            return match.month(dateString, {
              width: 'wide',
              context: 'formatting'
            }) || match.month(dateString, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.month(dateString, {
              width: 'narrow',
              context: 'formatting'
            });
        }
      }

      validate(_date, value) {
        return value >= 0 && value <= 11;
      }

      set(date, _flags, value) {
        date.setUTCMonth(value, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }

    }

    function _defineProperty$m(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }
    class StandAloneMonthParser extends Parser {
      constructor() {
        super(...arguments);

        _defineProperty$m(this, "priority", 110);

        _defineProperty$m(this, "incompatibleTokens", ['Y', 'R', 'q', 'Q', 'M', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']);
      }

      parse(dateString, token, match) {
        var valueCallback = function (value) {
          return value - 1;
        };

        switch (token) {
          // 1, 2, ..., 12
          case 'L':
            return mapValue(parseNumericPattern(numericPatterns.month, dateString), valueCallback);
          // 01, 02, ..., 12

          case 'LL':
            return mapValue(parseNDigits(2, dateString), valueCallback);
          // 1st, 2nd, ..., 12th

          case 'Lo':
            return mapValue(match.ordinalNumber(dateString, {
              unit: 'month'
            }), valueCallback);
          // Jan, Feb, ..., Dec

          case 'LLL':
            return match.month(dateString, {
              width: 'abbreviated',
              context: 'standalone'
            }) || match.month(dateString, {
              width: 'narrow',
              context: 'standalone'
            });
          // J, F, ..., D

          case 'LLLLL':
            return match.month(dateString, {
              width: 'narrow',
              context: 'standalone'
            });
          // January, February, ..., December

          case 'LLLL':
          default:
            return match.month(dateString, {
              width: 'wide',
              context: 'standalone'
            }) || match.month(dateString, {
              width: 'abbreviated',
              context: 'standalone'
            }) || match.month(dateString, {
              width: 'narrow',
              context: 'standalone'
            });
        }
      }

      validate(_date, value) {
        return value >= 0 && value <= 11;
      }

      set(date, _flags, value) {
        date.setUTCMonth(value, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }

    }

    function setUTCWeek(dirtyDate, dirtyWeek, options) {
      requiredArgs$1(2, arguments);
      var date = toDate$2(dirtyDate);
      var week = toInteger$1(dirtyWeek);
      var diff = getUTCWeek$1(date, options) - week;
      date.setUTCDate(date.getUTCDate() - diff * 7);
      return date;
    }

    function _defineProperty$l(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }

    class LocalWeekParser extends Parser {
      constructor() {
        super(...arguments);

        _defineProperty$l(this, "priority", 100);

        _defineProperty$l(this, "incompatibleTokens", ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'i', 't', 'T']);
      }

      parse(dateString, token, match) {
        switch (token) {
          case 'w':
            return parseNumericPattern(numericPatterns.week, dateString);

          case 'wo':
            return match.ordinalNumber(dateString, {
              unit: 'week'
            });

          default:
            return parseNDigits(token.length, dateString);
        }
      }

      validate(_date, value) {
        return value >= 1 && value <= 53;
      }

      set(date, _flags, value, options) {
        return startOfUTCWeek$1(setUTCWeek(date, value, options), options);
      }

    }

    function setUTCISOWeek(dirtyDate, dirtyISOWeek) {
      requiredArgs$1(2, arguments);
      var date = toDate$2(dirtyDate);
      var isoWeek = toInteger$1(dirtyISOWeek);
      var diff = getUTCISOWeek$1(date) - isoWeek;
      date.setUTCDate(date.getUTCDate() - diff * 7);
      return date;
    }

    function _defineProperty$k(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }

    class ISOWeekParser extends Parser {
      constructor() {
        super(...arguments);

        _defineProperty$k(this, "priority", 100);

        _defineProperty$k(this, "incompatibleTokens", ['y', 'Y', 'u', 'q', 'Q', 'M', 'L', 'w', 'd', 'D', 'e', 'c', 't', 'T']);
      }

      parse(dateString, token, match) {
        switch (token) {
          case 'I':
            return parseNumericPattern(numericPatterns.week, dateString);

          case 'Io':
            return match.ordinalNumber(dateString, {
              unit: 'week'
            });

          default:
            return parseNDigits(token.length, dateString);
        }
      }

      validate(_date, value) {
        return value >= 1 && value <= 53;
      }

      set(date, _flags, value) {
        return startOfUTCISOWeek$1(setUTCISOWeek(date, value));
      }

    }

    function _defineProperty$j(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }
    var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    var DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; // Day of the month

    class DateParser extends Parser {
      constructor() {
        super(...arguments);

        _defineProperty$j(this, "priority", 90);

        _defineProperty$j(this, "subPriority", 1);

        _defineProperty$j(this, "incompatibleTokens", ['Y', 'R', 'q', 'Q', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']);
      }

      parse(dateString, token, match) {
        switch (token) {
          case 'd':
            return parseNumericPattern(numericPatterns.date, dateString);

          case 'do':
            return match.ordinalNumber(dateString, {
              unit: 'date'
            });

          default:
            return parseNDigits(token.length, dateString);
        }
      }

      validate(date, value) {
        var year = date.getUTCFullYear();
        var isLeapYear = isLeapYearIndex(year);
        var month = date.getUTCMonth();

        if (isLeapYear) {
          return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR[month];
        } else {
          return value >= 1 && value <= DAYS_IN_MONTH[month];
        }
      }

      set(date, _flags, value) {
        date.setUTCDate(value);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }

    }

    function _defineProperty$i(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }
    class DayOfYearParser extends Parser {
      constructor() {
        super(...arguments);

        _defineProperty$i(this, "priority", 90);

        _defineProperty$i(this, "subpriority", 1);

        _defineProperty$i(this, "incompatibleTokens", ['Y', 'R', 'q', 'Q', 'M', 'L', 'w', 'I', 'd', 'E', 'i', 'e', 'c', 't', 'T']);
      }

      parse(dateString, token, match) {
        switch (token) {
          case 'D':
          case 'DD':
            return parseNumericPattern(numericPatterns.dayOfYear, dateString);

          case 'Do':
            return match.ordinalNumber(dateString, {
              unit: 'date'
            });

          default:
            return parseNDigits(token.length, dateString);
        }
      }

      validate(date, value) {
        var year = date.getUTCFullYear();
        var isLeapYear = isLeapYearIndex(year);

        if (isLeapYear) {
          return value >= 1 && value <= 366;
        } else {
          return value >= 1 && value <= 365;
        }
      }

      set(date, _flags, value) {
        date.setUTCMonth(0, value);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }

    }

    function setUTCDay(dirtyDate, dirtyDay, options) {
      var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;

      requiredArgs$1(2, arguments);
      var defaultOptions = getDefaultOptions$1();
      var weekStartsOn = toInteger$1((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

      if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
        throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
      }

      var date = toDate$2(dirtyDate);
      var day = toInteger$1(dirtyDay);
      var currentDay = date.getUTCDay();
      var remainder = day % 7;
      var dayIndex = (remainder + 7) % 7;
      var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
      date.setUTCDate(date.getUTCDate() + diff);
      return date;
    }

    function _defineProperty$h(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }

    class DayParser extends Parser {
      constructor() {
        super(...arguments);

        _defineProperty$h(this, "priority", 90);

        _defineProperty$h(this, "incompatibleTokens", ['D', 'i', 'e', 'c', 't', 'T']);
      }

      parse(dateString, token, match) {
        switch (token) {
          // Tue
          case 'E':
          case 'EE':
          case 'EEE':
            return match.day(dateString, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.day(dateString, {
              width: 'short',
              context: 'formatting'
            }) || match.day(dateString, {
              width: 'narrow',
              context: 'formatting'
            });
          // T

          case 'EEEEE':
            return match.day(dateString, {
              width: 'narrow',
              context: 'formatting'
            });
          // Tu

          case 'EEEEEE':
            return match.day(dateString, {
              width: 'short',
              context: 'formatting'
            }) || match.day(dateString, {
              width: 'narrow',
              context: 'formatting'
            });
          // Tuesday

          case 'EEEE':
          default:
            return match.day(dateString, {
              width: 'wide',
              context: 'formatting'
            }) || match.day(dateString, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.day(dateString, {
              width: 'short',
              context: 'formatting'
            }) || match.day(dateString, {
              width: 'narrow',
              context: 'formatting'
            });
        }
      }

      validate(_date, value) {
        return value >= 0 && value <= 6;
      }

      set(date, _flags, value, options) {
        date = setUTCDay(date, value, options);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }

    }

    function _defineProperty$g(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }

    class LocalDayParser extends Parser {
      constructor() {
        super(...arguments);

        _defineProperty$g(this, "priority", 90);

        _defineProperty$g(this, "incompatibleTokens", ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'E', 'i', 'c', 't', 'T']);
      }

      parse(dateString, token, match, options) {
        var valueCallback = function (value) {
          var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
          return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
        };

        switch (token) {
          // 3
          case 'e':
          case 'ee':
            // 03
            return mapValue(parseNDigits(token.length, dateString), valueCallback);
          // 3rd

          case 'eo':
            return mapValue(match.ordinalNumber(dateString, {
              unit: 'day'
            }), valueCallback);
          // Tue

          case 'eee':
            return match.day(dateString, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.day(dateString, {
              width: 'short',
              context: 'formatting'
            }) || match.day(dateString, {
              width: 'narrow',
              context: 'formatting'
            });
          // T

          case 'eeeee':
            return match.day(dateString, {
              width: 'narrow',
              context: 'formatting'
            });
          // Tu

          case 'eeeeee':
            return match.day(dateString, {
              width: 'short',
              context: 'formatting'
            }) || match.day(dateString, {
              width: 'narrow',
              context: 'formatting'
            });
          // Tuesday

          case 'eeee':
          default:
            return match.day(dateString, {
              width: 'wide',
              context: 'formatting'
            }) || match.day(dateString, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.day(dateString, {
              width: 'short',
              context: 'formatting'
            }) || match.day(dateString, {
              width: 'narrow',
              context: 'formatting'
            });
        }
      }

      validate(_date, value) {
        return value >= 0 && value <= 6;
      }

      set(date, _flags, value, options) {
        date = setUTCDay(date, value, options);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }

    }

    function _defineProperty$f(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }

    class StandAloneLocalDayParser extends Parser {
      constructor() {
        super(...arguments);

        _defineProperty$f(this, "priority", 90);

        _defineProperty$f(this, "incompatibleTokens", ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'E', 'i', 'e', 't', 'T']);
      }

      parse(dateString, token, match, options) {
        var valueCallback = function (value) {
          var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
          return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
        };

        switch (token) {
          // 3
          case 'c':
          case 'cc':
            // 03
            return mapValue(parseNDigits(token.length, dateString), valueCallback);
          // 3rd

          case 'co':
            return mapValue(match.ordinalNumber(dateString, {
              unit: 'day'
            }), valueCallback);
          // Tue

          case 'ccc':
            return match.day(dateString, {
              width: 'abbreviated',
              context: 'standalone'
            }) || match.day(dateString, {
              width: 'short',
              context: 'standalone'
            }) || match.day(dateString, {
              width: 'narrow',
              context: 'standalone'
            });
          // T

          case 'ccccc':
            return match.day(dateString, {
              width: 'narrow',
              context: 'standalone'
            });
          // Tu

          case 'cccccc':
            return match.day(dateString, {
              width: 'short',
              context: 'standalone'
            }) || match.day(dateString, {
              width: 'narrow',
              context: 'standalone'
            });
          // Tuesday

          case 'cccc':
          default:
            return match.day(dateString, {
              width: 'wide',
              context: 'standalone'
            }) || match.day(dateString, {
              width: 'abbreviated',
              context: 'standalone'
            }) || match.day(dateString, {
              width: 'short',
              context: 'standalone'
            }) || match.day(dateString, {
              width: 'narrow',
              context: 'standalone'
            });
        }
      }

      validate(_date, value) {
        return value >= 0 && value <= 6;
      }

      set(date, _flags, value, options) {
        date = setUTCDay(date, value, options);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }

    }

    function setUTCISODay(dirtyDate, dirtyDay) {
      requiredArgs$1(2, arguments);
      var day = toInteger$1(dirtyDay);

      if (day % 7 === 0) {
        day = day - 7;
      }

      var weekStartsOn = 1;
      var date = toDate$2(dirtyDate);
      var currentDay = date.getUTCDay();
      var remainder = day % 7;
      var dayIndex = (remainder + 7) % 7;
      var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
      date.setUTCDate(date.getUTCDate() + diff);
      return date;
    }

    function _defineProperty$e(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }

    class ISODayParser extends Parser {
      constructor() {
        super(...arguments);

        _defineProperty$e(this, "priority", 90);

        _defineProperty$e(this, "incompatibleTokens", ['y', 'Y', 'u', 'q', 'Q', 'M', 'L', 'w', 'd', 'D', 'E', 'e', 'c', 't', 'T']);
      }

      parse(dateString, token, match) {
        var valueCallback = function (value) {
          if (value === 0) {
            return 7;
          }

          return value;
        };

        switch (token) {
          // 2
          case 'i':
          case 'ii':
            // 02
            return parseNDigits(token.length, dateString);
          // 2nd

          case 'io':
            return match.ordinalNumber(dateString, {
              unit: 'day'
            });
          // Tue

          case 'iii':
            return mapValue(match.day(dateString, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.day(dateString, {
              width: 'short',
              context: 'formatting'
            }) || match.day(dateString, {
              width: 'narrow',
              context: 'formatting'
            }), valueCallback);
          // T

          case 'iiiii':
            return mapValue(match.day(dateString, {
              width: 'narrow',
              context: 'formatting'
            }), valueCallback);
          // Tu

          case 'iiiiii':
            return mapValue(match.day(dateString, {
              width: 'short',
              context: 'formatting'
            }) || match.day(dateString, {
              width: 'narrow',
              context: 'formatting'
            }), valueCallback);
          // Tuesday

          case 'iiii':
          default:
            return mapValue(match.day(dateString, {
              width: 'wide',
              context: 'formatting'
            }) || match.day(dateString, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.day(dateString, {
              width: 'short',
              context: 'formatting'
            }) || match.day(dateString, {
              width: 'narrow',
              context: 'formatting'
            }), valueCallback);
        }
      }

      validate(_date, value) {
        return value >= 1 && value <= 7;
      }

      set(date, _flags, value) {
        date = setUTCISODay(date, value);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }

    }

    function _defineProperty$d(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }
    class AMPMParser extends Parser {
      constructor() {
        super(...arguments);

        _defineProperty$d(this, "priority", 80);

        _defineProperty$d(this, "incompatibleTokens", ['b', 'B', 'H', 'k', 't', 'T']);
      }

      parse(dateString, token, match) {
        switch (token) {
          case 'a':
          case 'aa':
          case 'aaa':
            return match.dayPeriod(dateString, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.dayPeriod(dateString, {
              width: 'narrow',
              context: 'formatting'
            });

          case 'aaaaa':
            return match.dayPeriod(dateString, {
              width: 'narrow',
              context: 'formatting'
            });

          case 'aaaa':
          default:
            return match.dayPeriod(dateString, {
              width: 'wide',
              context: 'formatting'
            }) || match.dayPeriod(dateString, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.dayPeriod(dateString, {
              width: 'narrow',
              context: 'formatting'
            });
        }
      }

      set(date, _flags, value) {
        date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
        return date;
      }

    }

    function _defineProperty$c(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }
    class AMPMMidnightParser extends Parser {
      constructor() {
        super(...arguments);

        _defineProperty$c(this, "priority", 80);

        _defineProperty$c(this, "incompatibleTokens", ['a', 'B', 'H', 'k', 't', 'T']);
      }

      parse(dateString, token, match) {
        switch (token) {
          case 'b':
          case 'bb':
          case 'bbb':
            return match.dayPeriod(dateString, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.dayPeriod(dateString, {
              width: 'narrow',
              context: 'formatting'
            });

          case 'bbbbb':
            return match.dayPeriod(dateString, {
              width: 'narrow',
              context: 'formatting'
            });

          case 'bbbb':
          default:
            return match.dayPeriod(dateString, {
              width: 'wide',
              context: 'formatting'
            }) || match.dayPeriod(dateString, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.dayPeriod(dateString, {
              width: 'narrow',
              context: 'formatting'
            });
        }
      }

      set(date, _flags, value) {
        date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
        return date;
      }

    }

    function _defineProperty$b(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }

    class DayPeriodParser extends Parser {
      constructor() {
        super(...arguments);

        _defineProperty$b(this, "priority", 80);

        _defineProperty$b(this, "incompatibleTokens", ['a', 'b', 't', 'T']);
      }

      parse(dateString, token, match) {
        switch (token) {
          case 'B':
          case 'BB':
          case 'BBB':
            return match.dayPeriod(dateString, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.dayPeriod(dateString, {
              width: 'narrow',
              context: 'formatting'
            });

          case 'BBBBB':
            return match.dayPeriod(dateString, {
              width: 'narrow',
              context: 'formatting'
            });

          case 'BBBB':
          default:
            return match.dayPeriod(dateString, {
              width: 'wide',
              context: 'formatting'
            }) || match.dayPeriod(dateString, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.dayPeriod(dateString, {
              width: 'narrow',
              context: 'formatting'
            });
        }
      }

      set(date, _flags, value) {
        date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
        return date;
      }

    }

    function _defineProperty$a(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }
    class Hour1to12Parser extends Parser {
      constructor() {
        super(...arguments);

        _defineProperty$a(this, "priority", 70);

        _defineProperty$a(this, "incompatibleTokens", ['H', 'K', 'k', 't', 'T']);
      }

      parse(dateString, token, match) {
        switch (token) {
          case 'h':
            return parseNumericPattern(numericPatterns.hour12h, dateString);

          case 'ho':
            return match.ordinalNumber(dateString, {
              unit: 'hour'
            });

          default:
            return parseNDigits(token.length, dateString);
        }
      }

      validate(_date, value) {
        return value >= 1 && value <= 12;
      }

      set(date, _flags, value) {
        var isPM = date.getUTCHours() >= 12;

        if (isPM && value < 12) {
          date.setUTCHours(value + 12, 0, 0, 0);
        } else if (!isPM && value === 12) {
          date.setUTCHours(0, 0, 0, 0);
        } else {
          date.setUTCHours(value, 0, 0, 0);
        }

        return date;
      }

    }

    function _defineProperty$9(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }
    class Hour0to23Parser extends Parser {
      constructor() {
        super(...arguments);

        _defineProperty$9(this, "priority", 70);

        _defineProperty$9(this, "incompatibleTokens", ['a', 'b', 'h', 'K', 'k', 't', 'T']);
      }

      parse(dateString, token, match) {
        switch (token) {
          case 'H':
            return parseNumericPattern(numericPatterns.hour23h, dateString);

          case 'Ho':
            return match.ordinalNumber(dateString, {
              unit: 'hour'
            });

          default:
            return parseNDigits(token.length, dateString);
        }
      }

      validate(_date, value) {
        return value >= 0 && value <= 23;
      }

      set(date, _flags, value) {
        date.setUTCHours(value, 0, 0, 0);
        return date;
      }

    }

    function _defineProperty$8(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }
    class Hour0To11Parser extends Parser {
      constructor() {
        super(...arguments);

        _defineProperty$8(this, "priority", 70);

        _defineProperty$8(this, "incompatibleTokens", ['h', 'H', 'k', 't', 'T']);
      }

      parse(dateString, token, match) {
        switch (token) {
          case 'K':
            return parseNumericPattern(numericPatterns.hour11h, dateString);

          case 'Ko':
            return match.ordinalNumber(dateString, {
              unit: 'hour'
            });

          default:
            return parseNDigits(token.length, dateString);
        }
      }

      validate(_date, value) {
        return value >= 0 && value <= 11;
      }

      set(date, _flags, value) {
        var isPM = date.getUTCHours() >= 12;

        if (isPM && value < 12) {
          date.setUTCHours(value + 12, 0, 0, 0);
        } else {
          date.setUTCHours(value, 0, 0, 0);
        }

        return date;
      }

    }

    function _defineProperty$7(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }
    class Hour1To24Parser extends Parser {
      constructor() {
        super(...arguments);

        _defineProperty$7(this, "priority", 70);

        _defineProperty$7(this, "incompatibleTokens", ['a', 'b', 'h', 'H', 'K', 't', 'T']);
      }

      parse(dateString, token, match) {
        switch (token) {
          case 'k':
            return parseNumericPattern(numericPatterns.hour24h, dateString);

          case 'ko':
            return match.ordinalNumber(dateString, {
              unit: 'hour'
            });

          default:
            return parseNDigits(token.length, dateString);
        }
      }

      validate(_date, value) {
        return value >= 1 && value <= 24;
      }

      set(date, _flags, value) {
        var hours = value <= 24 ? value % 24 : value;
        date.setUTCHours(hours, 0, 0, 0);
        return date;
      }

    }

    function _defineProperty$6(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }
    class MinuteParser extends Parser {
      constructor() {
        super(...arguments);

        _defineProperty$6(this, "priority", 60);

        _defineProperty$6(this, "incompatibleTokens", ['t', 'T']);
      }

      parse(dateString, token, match) {
        switch (token) {
          case 'm':
            return parseNumericPattern(numericPatterns.minute, dateString);

          case 'mo':
            return match.ordinalNumber(dateString, {
              unit: 'minute'
            });

          default:
            return parseNDigits(token.length, dateString);
        }
      }

      validate(_date, value) {
        return value >= 0 && value <= 59;
      }

      set(date, _flags, value) {
        date.setUTCMinutes(value, 0, 0);
        return date;
      }

    }

    function _defineProperty$5(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }
    class SecondParser extends Parser {
      constructor() {
        super(...arguments);

        _defineProperty$5(this, "priority", 50);

        _defineProperty$5(this, "incompatibleTokens", ['t', 'T']);
      }

      parse(dateString, token, match) {
        switch (token) {
          case 's':
            return parseNumericPattern(numericPatterns.second, dateString);

          case 'so':
            return match.ordinalNumber(dateString, {
              unit: 'second'
            });

          default:
            return parseNDigits(token.length, dateString);
        }
      }

      validate(_date, value) {
        return value >= 0 && value <= 59;
      }

      set(date, _flags, value) {
        date.setUTCSeconds(value, 0);
        return date;
      }

    }

    function _defineProperty$4(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }
    class FractionOfSecondParser extends Parser {
      constructor() {
        super(...arguments);

        _defineProperty$4(this, "priority", 30);

        _defineProperty$4(this, "incompatibleTokens", ['t', 'T']);
      }

      parse(dateString, token) {
        var valueCallback = function (value) {
          return Math.floor(value * Math.pow(10, -token.length + 3));
        };

        return mapValue(parseNDigits(token.length, dateString), valueCallback);
      }

      set(date, _flags, value) {
        date.setUTCMilliseconds(value);
        return date;
      }

    }

    function _defineProperty$3(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }

    class ISOTimezoneWithZParser extends Parser {
      constructor() {
        super(...arguments);

        _defineProperty$3(this, "priority", 10);

        _defineProperty$3(this, "incompatibleTokens", ['t', 'T', 'x']);
      }

      parse(dateString, token) {
        switch (token) {
          case 'X':
            return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, dateString);

          case 'XX':
            return parseTimezonePattern(timezonePatterns.basic, dateString);

          case 'XXXX':
            return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, dateString);

          case 'XXXXX':
            return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, dateString);

          case 'XXX':
          default:
            return parseTimezonePattern(timezonePatterns.extended, dateString);
        }
      }

      set(date, flags, value) {
        if (flags.timestampIsSet) {
          return date;
        }

        return new Date(date.getTime() - value);
      }

    }

    function _defineProperty$2(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }

    class ISOTimezoneParser extends Parser {
      constructor() {
        super(...arguments);

        _defineProperty$2(this, "priority", 10);

        _defineProperty$2(this, "incompatibleTokens", ['t', 'T', 'X']);
      }

      parse(dateString, token) {
        switch (token) {
          case 'x':
            return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, dateString);

          case 'xx':
            return parseTimezonePattern(timezonePatterns.basic, dateString);

          case 'xxxx':
            return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, dateString);

          case 'xxxxx':
            return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, dateString);

          case 'xxx':
          default:
            return parseTimezonePattern(timezonePatterns.extended, dateString);
        }
      }

      set(date, flags, value) {
        if (flags.timestampIsSet) {
          return date;
        }

        return new Date(date.getTime() - value);
      }

    }

    function _defineProperty$1(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }
    class TimestampSecondsParser extends Parser {
      constructor() {
        super(...arguments);

        _defineProperty$1(this, "priority", 40);

        _defineProperty$1(this, "incompatibleTokens", '*');
      }

      parse(dateString) {
        return parseAnyDigitsSigned(dateString);
      }

      set(_date, _flags, value) {
        return [new Date(value * 1000), {
          timestampIsSet: true
        }];
      }

    }

    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }
    class TimestampMillisecondsParser extends Parser {
      constructor() {
        super(...arguments);

        _defineProperty(this, "priority", 20);

        _defineProperty(this, "incompatibleTokens", '*');
      }

      parse(dateString) {
        return parseAnyDigitsSigned(dateString);
      }

      set(_date, _flags, value) {
        return [new Date(value), {
          timestampIsSet: true
        }];
      }

    }

    /*
     * |     | Unit                           |     | Unit                           |
     * |-----|--------------------------------|-----|--------------------------------|
     * |  a  | AM, PM                         |  A* | Milliseconds in day            |
     * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |
     * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |
     * |  d  | Day of month                   |  D  | Day of year                    |
     * |  e  | Local day of week              |  E  | Day of week                    |
     * |  f  |                                |  F* | Day of week in month           |
     * |  g* | Modified Julian day            |  G  | Era                            |
     * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
     * |  i! | ISO day of week                |  I! | ISO week of year               |
     * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |
     * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |
     * |  l* | (deprecated)                   |  L  | Stand-alone month              |
     * |  m  | Minute                         |  M  | Month                          |
     * |  n  |                                |  N  |                                |
     * |  o! | Ordinal number modifier        |  O* | Timezone (GMT)                 |
     * |  p  |                                |  P  |                                |
     * |  q  | Stand-alone quarter            |  Q  | Quarter                        |
     * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |
     * |  s  | Second                         |  S  | Fraction of second             |
     * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |
     * |  u  | Extended year                  |  U* | Cyclic year                    |
     * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |
     * |  w  | Local week of year             |  W* | Week of month                  |
     * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |
     * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |
     * |  z* | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |
     *
     * Letters marked by * are not implemented but reserved by Unicode standard.
     *
     * Letters marked by ! are non-standard, but implemented by date-fns:
     * - `o` modifies the previous token to turn it into an ordinal (see `parse` docs)
     * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,
     *   i.e. 7 for Sunday, 1 for Monday, etc.
     * - `I` is ISO week of year, as opposed to `w` which is local week of year.
     * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.
     *   `R` is supposed to be used in conjunction with `I` and `i`
     *   for universal ISO week-numbering date, whereas
     *   `Y` is supposed to be used in conjunction with `w` and `e`
     *   for week-numbering date specific to the locale.
     */

    var parsers = {
      G: new EraParser(),
      y: new YearParser(),
      Y: new LocalWeekYearParser(),
      R: new ISOWeekYearParser(),
      u: new ExtendedYearParser(),
      Q: new QuarterParser(),
      q: new StandAloneQuarterParser(),
      M: new MonthParser(),
      L: new StandAloneMonthParser(),
      w: new LocalWeekParser(),
      I: new ISOWeekParser(),
      d: new DateParser(),
      D: new DayOfYearParser(),
      E: new DayParser(),
      e: new LocalDayParser(),
      c: new StandAloneLocalDayParser(),
      i: new ISODayParser(),
      a: new AMPMParser(),
      b: new AMPMMidnightParser(),
      B: new DayPeriodParser(),
      h: new Hour1to12Parser(),
      H: new Hour0to23Parser(),
      K: new Hour0To11Parser(),
      k: new Hour1To24Parser(),
      m: new MinuteParser(),
      s: new SecondParser(),
      S: new FractionOfSecondParser(),
      X: new ISOTimezoneWithZParser(),
      x: new ISOTimezoneParser(),
      t: new TimestampSecondsParser(),
      T: new TimestampMillisecondsParser()
    };

    // - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token
    //   (one of the certain letters followed by `o`)
    // - (\w)\1* matches any sequences of the same letter
    // - '' matches two quote characters in a row
    // - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
    //   except a single quote symbol, which ends the sequence.
    //   Two quote characters do not end the sequence.
    //   If there is no matching single quote
    //   then the sequence will continue until the end of the string.
    // - . matches any single character unmatched by previous parts of the RegExps

    var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g; // This RegExp catches symbols escaped by quotes, and also
    // sequences of symbols P, p, and the combinations like `PPPPPPPppppp`

    var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
    var escapedStringRegExp = /^'([^]*?)'?$/;
    var doubleQuoteRegExp = /''/g;
    var notWhitespaceRegExp = /\S/;
    var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
    /**
     * @name parse
     * @category Common Helpers
     * @summary Parse the date.
     *
     * @description
     * Return the date parsed from string using the given format string.
     *
     * > ⚠️ Please note that the `format` tokens differ from Moment.js and other libraries.
     * > See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
     *
     * The characters in the format string wrapped between two single quotes characters (') are escaped.
     * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
     *
     * Format of the format string is based on Unicode Technical Standard #35:
     * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
     * with a few additions (see note 5 below the table).
     *
     * Not all tokens are compatible. Combinations that don't make sense or could lead to bugs are prohibited
     * and will throw `RangeError`. For example usage of 24-hour format token with AM/PM token will throw an exception:
     *
     * ```javascript
     * parse('23 AM', 'HH a', new Date())
     * //=> RangeError: The format string mustn't contain `HH` and `a` at the same time
     * ```
     *
     * See the compatibility table: https://docs.google.com/spreadsheets/d/e/2PACX-1vQOPU3xUhplll6dyoMmVUXHKl_8CRDs6_ueLmex3SoqwhuolkuN3O05l4rqx5h1dKX8eb46Ul-CCSrq/pubhtml?gid=0&single=true
     *
     * Accepted format string patterns:
     * | Unit                            |Prior| Pattern | Result examples                   | Notes |
     * |---------------------------------|-----|---------|-----------------------------------|-------|
     * | Era                             | 140 | G..GGG  | AD, BC                            |       |
     * |                                 |     | GGGG    | Anno Domini, Before Christ        | 2     |
     * |                                 |     | GGGGG   | A, B                              |       |
     * | Calendar year                   | 130 | y       | 44, 1, 1900, 2017, 9999           | 4     |
     * |                                 |     | yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
     * |                                 |     | yy      | 44, 01, 00, 17                    | 4     |
     * |                                 |     | yyy     | 044, 001, 123, 999                | 4     |
     * |                                 |     | yyyy    | 0044, 0001, 1900, 2017            | 4     |
     * |                                 |     | yyyyy   | ...                               | 2,4   |
     * | Local week-numbering year       | 130 | Y       | 44, 1, 1900, 2017, 9000           | 4     |
     * |                                 |     | Yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
     * |                                 |     | YY      | 44, 01, 00, 17                    | 4,6   |
     * |                                 |     | YYY     | 044, 001, 123, 999                | 4     |
     * |                                 |     | YYYY    | 0044, 0001, 1900, 2017            | 4,6   |
     * |                                 |     | YYYYY   | ...                               | 2,4   |
     * | ISO week-numbering year         | 130 | R       | -43, 1, 1900, 2017, 9999, -9999   | 4,5   |
     * |                                 |     | RR      | -43, 01, 00, 17                   | 4,5   |
     * |                                 |     | RRR     | -043, 001, 123, 999, -999         | 4,5   |
     * |                                 |     | RRRR    | -0043, 0001, 2017, 9999, -9999    | 4,5   |
     * |                                 |     | RRRRR   | ...                               | 2,4,5 |
     * | Extended year                   | 130 | u       | -43, 1, 1900, 2017, 9999, -999    | 4     |
     * |                                 |     | uu      | -43, 01, 99, -99                  | 4     |
     * |                                 |     | uuu     | -043, 001, 123, 999, -999         | 4     |
     * |                                 |     | uuuu    | -0043, 0001, 2017, 9999, -9999    | 4     |
     * |                                 |     | uuuuu   | ...                               | 2,4   |
     * | Quarter (formatting)            | 120 | Q       | 1, 2, 3, 4                        |       |
     * |                                 |     | Qo      | 1st, 2nd, 3rd, 4th                | 5     |
     * |                                 |     | QQ      | 01, 02, 03, 04                    |       |
     * |                                 |     | QQQ     | Q1, Q2, Q3, Q4                    |       |
     * |                                 |     | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
     * |                                 |     | QQQQQ   | 1, 2, 3, 4                        | 4     |
     * | Quarter (stand-alone)           | 120 | q       | 1, 2, 3, 4                        |       |
     * |                                 |     | qo      | 1st, 2nd, 3rd, 4th                | 5     |
     * |                                 |     | qq      | 01, 02, 03, 04                    |       |
     * |                                 |     | qqq     | Q1, Q2, Q3, Q4                    |       |
     * |                                 |     | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
     * |                                 |     | qqqqq   | 1, 2, 3, 4                        | 3     |
     * | Month (formatting)              | 110 | M       | 1, 2, ..., 12                     |       |
     * |                                 |     | Mo      | 1st, 2nd, ..., 12th               | 5     |
     * |                                 |     | MM      | 01, 02, ..., 12                   |       |
     * |                                 |     | MMM     | Jan, Feb, ..., Dec                |       |
     * |                                 |     | MMMM    | January, February, ..., December  | 2     |
     * |                                 |     | MMMMM   | J, F, ..., D                      |       |
     * | Month (stand-alone)             | 110 | L       | 1, 2, ..., 12                     |       |
     * |                                 |     | Lo      | 1st, 2nd, ..., 12th               | 5     |
     * |                                 |     | LL      | 01, 02, ..., 12                   |       |
     * |                                 |     | LLL     | Jan, Feb, ..., Dec                |       |
     * |                                 |     | LLLL    | January, February, ..., December  | 2     |
     * |                                 |     | LLLLL   | J, F, ..., D                      |       |
     * | Local week of year              | 100 | w       | 1, 2, ..., 53                     |       |
     * |                                 |     | wo      | 1st, 2nd, ..., 53th               | 5     |
     * |                                 |     | ww      | 01, 02, ..., 53                   |       |
     * | ISO week of year                | 100 | I       | 1, 2, ..., 53                     | 5     |
     * |                                 |     | Io      | 1st, 2nd, ..., 53th               | 5     |
     * |                                 |     | II      | 01, 02, ..., 53                   | 5     |
     * | Day of month                    |  90 | d       | 1, 2, ..., 31                     |       |
     * |                                 |     | do      | 1st, 2nd, ..., 31st               | 5     |
     * |                                 |     | dd      | 01, 02, ..., 31                   |       |
     * | Day of year                     |  90 | D       | 1, 2, ..., 365, 366               | 7     |
     * |                                 |     | Do      | 1st, 2nd, ..., 365th, 366th       | 5     |
     * |                                 |     | DD      | 01, 02, ..., 365, 366             | 7     |
     * |                                 |     | DDD     | 001, 002, ..., 365, 366           |       |
     * |                                 |     | DDDD    | ...                               | 2     |
     * | Day of week (formatting)        |  90 | E..EEE  | Mon, Tue, Wed, ..., Sun           |       |
     * |                                 |     | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
     * |                                 |     | EEEEE   | M, T, W, T, F, S, S               |       |
     * |                                 |     | EEEEEE  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
     * | ISO day of week (formatting)    |  90 | i       | 1, 2, 3, ..., 7                   | 5     |
     * |                                 |     | io      | 1st, 2nd, ..., 7th                | 5     |
     * |                                 |     | ii      | 01, 02, ..., 07                   | 5     |
     * |                                 |     | iii     | Mon, Tue, Wed, ..., Sun           | 5     |
     * |                                 |     | iiii    | Monday, Tuesday, ..., Sunday      | 2,5   |
     * |                                 |     | iiiii   | M, T, W, T, F, S, S               | 5     |
     * |                                 |     | iiiiii  | Mo, Tu, We, Th, Fr, Sa, Su        | 5     |
     * | Local day of week (formatting)  |  90 | e       | 2, 3, 4, ..., 1                   |       |
     * |                                 |     | eo      | 2nd, 3rd, ..., 1st                | 5     |
     * |                                 |     | ee      | 02, 03, ..., 01                   |       |
     * |                                 |     | eee     | Mon, Tue, Wed, ..., Sun           |       |
     * |                                 |     | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
     * |                                 |     | eeeee   | M, T, W, T, F, S, S               |       |
     * |                                 |     | eeeeee  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
     * | Local day of week (stand-alone) |  90 | c       | 2, 3, 4, ..., 1                   |       |
     * |                                 |     | co      | 2nd, 3rd, ..., 1st                | 5     |
     * |                                 |     | cc      | 02, 03, ..., 01                   |       |
     * |                                 |     | ccc     | Mon, Tue, Wed, ..., Sun           |       |
     * |                                 |     | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
     * |                                 |     | ccccc   | M, T, W, T, F, S, S               |       |
     * |                                 |     | cccccc  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
     * | AM, PM                          |  80 | a..aaa  | AM, PM                            |       |
     * |                                 |     | aaaa    | a.m., p.m.                        | 2     |
     * |                                 |     | aaaaa   | a, p                              |       |
     * | AM, PM, noon, midnight          |  80 | b..bbb  | AM, PM, noon, midnight            |       |
     * |                                 |     | bbbb    | a.m., p.m., noon, midnight        | 2     |
     * |                                 |     | bbbbb   | a, p, n, mi                       |       |
     * | Flexible day period             |  80 | B..BBB  | at night, in the morning, ...     |       |
     * |                                 |     | BBBB    | at night, in the morning, ...     | 2     |
     * |                                 |     | BBBBB   | at night, in the morning, ...     |       |
     * | Hour [1-12]                     |  70 | h       | 1, 2, ..., 11, 12                 |       |
     * |                                 |     | ho      | 1st, 2nd, ..., 11th, 12th         | 5     |
     * |                                 |     | hh      | 01, 02, ..., 11, 12               |       |
     * | Hour [0-23]                     |  70 | H       | 0, 1, 2, ..., 23                  |       |
     * |                                 |     | Ho      | 0th, 1st, 2nd, ..., 23rd          | 5     |
     * |                                 |     | HH      | 00, 01, 02, ..., 23               |       |
     * | Hour [0-11]                     |  70 | K       | 1, 2, ..., 11, 0                  |       |
     * |                                 |     | Ko      | 1st, 2nd, ..., 11th, 0th          | 5     |
     * |                                 |     | KK      | 01, 02, ..., 11, 00               |       |
     * | Hour [1-24]                     |  70 | k       | 24, 1, 2, ..., 23                 |       |
     * |                                 |     | ko      | 24th, 1st, 2nd, ..., 23rd         | 5     |
     * |                                 |     | kk      | 24, 01, 02, ..., 23               |       |
     * | Minute                          |  60 | m       | 0, 1, ..., 59                     |       |
     * |                                 |     | mo      | 0th, 1st, ..., 59th               | 5     |
     * |                                 |     | mm      | 00, 01, ..., 59                   |       |
     * | Second                          |  50 | s       | 0, 1, ..., 59                     |       |
     * |                                 |     | so      | 0th, 1st, ..., 59th               | 5     |
     * |                                 |     | ss      | 00, 01, ..., 59                   |       |
     * | Seconds timestamp               |  40 | t       | 512969520                         |       |
     * |                                 |     | tt      | ...                               | 2     |
     * | Fraction of second              |  30 | S       | 0, 1, ..., 9                      |       |
     * |                                 |     | SS      | 00, 01, ..., 99                   |       |
     * |                                 |     | SSS     | 000, 001, ..., 999                |       |
     * |                                 |     | SSSS    | ...                               | 2     |
     * | Milliseconds timestamp          |  20 | T       | 512969520900                      |       |
     * |                                 |     | TT      | ...                               | 2     |
     * | Timezone (ISO-8601 w/ Z)        |  10 | X       | -08, +0530, Z                     |       |
     * |                                 |     | XX      | -0800, +0530, Z                   |       |
     * |                                 |     | XXX     | -08:00, +05:30, Z                 |       |
     * |                                 |     | XXXX    | -0800, +0530, Z, +123456          | 2     |
     * |                                 |     | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
     * | Timezone (ISO-8601 w/o Z)       |  10 | x       | -08, +0530, +00                   |       |
     * |                                 |     | xx      | -0800, +0530, +0000               |       |
     * |                                 |     | xxx     | -08:00, +05:30, +00:00            | 2     |
     * |                                 |     | xxxx    | -0800, +0530, +0000, +123456      |       |
     * |                                 |     | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
     * | Long localized date             |  NA | P       | 05/29/1453                        | 5,8   |
     * |                                 |     | PP      | May 29, 1453                      |       |
     * |                                 |     | PPP     | May 29th, 1453                    |       |
     * |                                 |     | PPPP    | Sunday, May 29th, 1453            | 2,5,8 |
     * | Long localized time             |  NA | p       | 12:00 AM                          | 5,8   |
     * |                                 |     | pp      | 12:00:00 AM                       |       |
     * | Combination of date and time    |  NA | Pp      | 05/29/1453, 12:00 AM              |       |
     * |                                 |     | PPpp    | May 29, 1453, 12:00:00 AM         |       |
     * |                                 |     | PPPpp   | May 29th, 1453 at ...             |       |
     * |                                 |     | PPPPpp  | Sunday, May 29th, 1453 at ...     | 2,5,8 |
     * Notes:
     * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
     *    are the same as "stand-alone" units, but are different in some languages.
     *    "Formatting" units are declined according to the rules of the language
     *    in the context of a date. "Stand-alone" units are always nominative singular.
     *    In `format` function, they will produce different result:
     *
     *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
     *
     *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
     *
     *    `parse` will try to match both formatting and stand-alone units interchangably.
     *
     * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
     *    the single quote characters (see below).
     *    If the sequence is longer than listed in table:
     *    - for numerical units (`yyyyyyyy`) `parse` will try to match a number
     *      as wide as the sequence
     *    - for text units (`MMMMMMMM`) `parse` will try to match the widest variation of the unit.
     *      These variations are marked with "2" in the last column of the table.
     *
     * 3. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
     *    These tokens represent the shortest form of the quarter.
     *
     * 4. The main difference between `y` and `u` patterns are B.C. years:
     *
     *    | Year | `y` | `u` |
     *    |------|-----|-----|
     *    | AC 1 |   1 |   1 |
     *    | BC 1 |   1 |   0 |
     *    | BC 2 |   2 |  -1 |
     *
     *    Also `yy` will try to guess the century of two digit year by proximity with `referenceDate`:
     *
     *    `parse('50', 'yy', new Date(2018, 0, 1)) //=> Sat Jan 01 2050 00:00:00`
     *
     *    `parse('75', 'yy', new Date(2018, 0, 1)) //=> Wed Jan 01 1975 00:00:00`
     *
     *    while `uu` will just assign the year as is:
     *
     *    `parse('50', 'uu', new Date(2018, 0, 1)) //=> Sat Jan 01 0050 00:00:00`
     *
     *    `parse('75', 'uu', new Date(2018, 0, 1)) //=> Tue Jan 01 0075 00:00:00`
     *
     *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
     *    except local week-numbering years are dependent on `options.weekStartsOn`
     *    and `options.firstWeekContainsDate` (compare [setISOWeekYear]{@link https://date-fns.org/docs/setISOWeekYear}
     *    and [setWeekYear]{@link https://date-fns.org/docs/setWeekYear}).
     *
     * 5. These patterns are not in the Unicode Technical Standard #35:
     *    - `i`: ISO day of week
     *    - `I`: ISO week of year
     *    - `R`: ISO week-numbering year
     *    - `o`: ordinal number modifier
     *    - `P`: long localized date
     *    - `p`: long localized time
     *
     * 6. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
     *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
     *
     * 7. `D` and `DD` tokens represent days of the year but they are ofthen confused with days of the month.
     *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
     *
     * 8. `P+` tokens do not have a defined priority since they are merely aliases to other tokens based
     *    on the given locale.
     *
     *    using `en-US` locale: `P` => `MM/dd/yyyy`
     *    using `en-US` locale: `p` => `hh:mm a`
     *    using `pt-BR` locale: `P` => `dd/MM/yyyy`
     *    using `pt-BR` locale: `p` => `HH:mm`
     *
     * Values will be assigned to the date in the descending order of its unit's priority.
     * Units of an equal priority overwrite each other in the order of appearance.
     *
     * If no values of higher priority are parsed (e.g. when parsing string 'January 1st' without a year),
     * the values will be taken from 3rd argument `referenceDate` which works as a context of parsing.
     *
     * `referenceDate` must be passed for correct work of the function.
     * If you're not sure which `referenceDate` to supply, create a new instance of Date:
     * `parse('02/11/2014', 'MM/dd/yyyy', new Date())`
     * In this case parsing will be done in the context of the current date.
     * If `referenceDate` is `Invalid Date` or a value not convertible to valid `Date`,
     * then `Invalid Date` will be returned.
     *
     * The result may vary by locale.
     *
     * If `formatString` matches with `dateString` but does not provides tokens, `referenceDate` will be returned.
     *
     * If parsing failed, `Invalid Date` will be returned.
     * Invalid Date is a Date, whose time value is NaN.
     * Time value of Date: http://es5.github.io/#x15.9.1.1
     *
     * @param {String} dateString - the string to parse
     * @param {String} formatString - the string of tokens
     * @param {Date|Number} referenceDate - defines values missing from the parsed dateString
     * @param {Object} [options] - an object with options.
     * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
     * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
     * @param {1|2|3|4|5|6|7} [options.firstWeekContainsDate=1] - the day of January, which is always in the first week of the year
     * @param {Boolean} [options.useAdditionalWeekYearTokens=false] - if true, allows usage of the week-numbering year tokens `YY` and `YYYY`;
     *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
     * @param {Boolean} [options.useAdditionalDayOfYearTokens=false] - if true, allows usage of the day of year tokens `D` and `DD`;
     *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
     * @returns {Date} the parsed date
     * @throws {TypeError} 3 arguments required
     * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
     * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
     * @throws {RangeError} `options.locale` must contain `match` property
     * @throws {RangeError} use `yyyy` instead of `YYYY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
     * @throws {RangeError} use `yy` instead of `YY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
     * @throws {RangeError} use `d` instead of `D` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
     * @throws {RangeError} use `dd` instead of `DD` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
     * @throws {RangeError} format string contains an unescaped latin alphabet character
     *
     * @example
     * // Parse 11 February 2014 from middle-endian format:
     * var result = parse('02/11/2014', 'MM/dd/yyyy', new Date())
     * //=> Tue Feb 11 2014 00:00:00
     *
     * @example
     * // Parse 28th of February in Esperanto locale in the context of 2010 year:
     * import eo from 'date-fns/locale/eo'
     * var result = parse('28-a de februaro', "do 'de' MMMM", new Date(2010, 0, 1), {
     *   locale: eo
     * })
     * //=> Sun Feb 28 2010 00:00:00
     */

    function parse$1(dirtyDateString, dirtyFormatString, dirtyReferenceDate, options) {
      var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;

      requiredArgs$1(3, arguments);
      var dateString = String(dirtyDateString);
      var formatString = String(dirtyFormatString);
      var defaultOptions = getDefaultOptions$1();
      var locale = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions.locale) !== null && _ref !== void 0 ? _ref : defaultLocale$1;

      if (!locale.match) {
        throw new RangeError('locale must contain match property');
      }

      var firstWeekContainsDate = toInteger$1((_ref2 = (_ref3 = (_ref4 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale2 = options.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.firstWeekContainsDate) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN

      if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
        throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
      }

      var weekStartsOn = toInteger$1((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale3 = options.locale) === null || _options$locale3 === void 0 ? void 0 : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === void 0 ? void 0 : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

      if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
        throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
      }

      if (formatString === '') {
        if (dateString === '') {
          return toDate$2(dirtyReferenceDate);
        } else {
          return new Date(NaN);
        }
      }

      var subFnOptions = {
        firstWeekContainsDate: firstWeekContainsDate,
        weekStartsOn: weekStartsOn,
        locale: locale
      }; // If timezone isn't specified, it will be set to the system timezone

      var setters = [new DateToSystemTimezoneSetter()];
      var tokens = formatString.match(longFormattingTokensRegExp).map(function (substring) {
        var firstCharacter = substring[0];

        if (firstCharacter in longFormatters$2) {
          var longFormatter = longFormatters$2[firstCharacter];
          return longFormatter(substring, locale.formatLong);
        }

        return substring;
      }).join('').match(formattingTokensRegExp);
      var usedTokens = [];

      var _loop = function (_token) {
        if (!(options !== null && options !== void 0 && options.useAdditionalWeekYearTokens) && isProtectedWeekYearToken$1(_token)) {
          throwProtectedError$1(_token, formatString, dirtyDateString);
        }

        if (!(options !== null && options !== void 0 && options.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken$1(_token)) {
          throwProtectedError$1(_token, formatString, dirtyDateString);
        }

        var firstCharacter = _token[0];
        var parser = parsers[firstCharacter];

        if (parser) {
          var incompatibleTokens = parser.incompatibleTokens;

          if (Array.isArray(incompatibleTokens)) {
            var incompatibleToken = usedTokens.find(function (usedToken) {
              return incompatibleTokens.includes(usedToken.token) || usedToken.token === firstCharacter;
            });

            if (incompatibleToken) {
              throw new RangeError("The format string mustn't contain `".concat(incompatibleToken.fullToken, "` and `").concat(_token, "` at the same time"));
            }
          } else if (parser.incompatibleTokens === '*' && usedTokens.length > 0) {
            throw new RangeError("The format string mustn't contain `".concat(_token, "` and any other token at the same time"));
          }

          usedTokens.push({
            token: firstCharacter,
            fullToken: _token
          });
          var parseResult = parser.run(dateString, _token, locale.match, subFnOptions);

          if (!parseResult) {
            token = _token;
            return {
              v: new Date(NaN)
            };
          }

          setters.push(parseResult.setter);
          dateString = parseResult.rest;
        } else {
          if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
            throw new RangeError('Format string contains an unescaped latin alphabet character `' + firstCharacter + '`');
          } // Replace two single quote characters with one single quote character


          if (_token === "''") {
            _token = "'";
          } else if (firstCharacter === "'") {
            _token = cleanEscapedString(_token);
          } // Cut token from string, or, if string doesn't match the token, return Invalid Date


          if (dateString.indexOf(_token) === 0) {
            dateString = dateString.slice(_token.length);
          } else {
            token = _token;
            return {
              v: new Date(NaN)
            };
          }
        }

        token = _token;
      };

      for (var token of tokens) {
        var _ret = _loop(token);

        if (typeof _ret === "object") return _ret.v;
      } // Check if the remaining input contains something other than whitespace


      if (dateString.length > 0 && notWhitespaceRegExp.test(dateString)) {
        return new Date(NaN);
      }

      var uniquePrioritySetters = setters.map(function (setter) {
        return setter.priority;
      }).sort(function (a, b) {
        return b - a;
      }).filter(function (priority, index, array) {
        return array.indexOf(priority) === index;
      }).map(function (priority) {
        return setters.filter(function (setter) {
          return setter.priority === priority;
        }).sort(function (a, b) {
          return b.subPriority - a.subPriority;
        });
      }).map(function (setterArray) {
        return setterArray[0];
      });
      var date = toDate$2(dirtyReferenceDate);

      if (isNaN(date.getTime())) {
        return new Date(NaN);
      } // Convert the date in system timezone to the same date in UTC+00:00 timezone.


      var utcDate = subMilliseconds$1(date, getTimezoneOffsetInMilliseconds$1(date));
      var flags = {};

      for (var setter of uniquePrioritySetters) {
        if (!setter.validate(utcDate, subFnOptions)) {
          return new Date(NaN);
        }

        var result = setter.set(utcDate, flags, subFnOptions); // Result is tuple (date, flags)

        if (Array.isArray(result)) {
          utcDate = result[0];
          assign$1(flags, result[1]); // Result is date
        } else {
          utcDate = result;
        }
      }

      return utcDate;
    }

    function cleanEscapedString(input) {
      return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
    }

    /**
     * @name startOfHour
     * @category Hour Helpers
     * @summary Return the start of an hour for the given date.
     *
     * @description
     * Return the start of an hour for the given date.
     * The result will be in the local timezone.
     *
     * @param {Date|Number} date - the original date
     * @returns {Date} the start of an hour
     * @throws {TypeError} 1 argument required
     *
     * @example
     * // The start of an hour for 2 September 2014 11:55:00:
     * const result = startOfHour(new Date(2014, 8, 2, 11, 55))
     * //=> Tue Sep 02 2014 11:00:00
     */

    function startOfHour(dirtyDate) {
      requiredArgs$1(1, arguments);
      var date = toDate$2(dirtyDate);
      date.setMinutes(0, 0, 0);
      return date;
    }

    /**
     * @name isSameMonth
     * @category Month Helpers
     * @summary Are the given dates in the same month (and year)?
     *
     * @description
     * Are the given dates in the same month (and year)?
     *
     * @param {Date|Number} dateLeft - the first date to check
     * @param {Date|Number} dateRight - the second date to check
     * @returns {Boolean} the dates are in the same month (and year)
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // Are 2 September 2014 and 25 September 2014 in the same month?
     * const result = isSameMonth(new Date(2014, 8, 2), new Date(2014, 8, 25))
     * //=> true
     *
     * @example
     * // Are 2 September 2014 and 25 September 2015 in the same month?
     * const result = isSameMonth(new Date(2014, 8, 2), new Date(2015, 8, 25))
     * //=> false
     */

    function isSameMonth(dirtyDateLeft, dirtyDateRight) {
      requiredArgs$1(2, arguments);
      var dateLeft = toDate$2(dirtyDateLeft);
      var dateRight = toDate$2(dirtyDateRight);
      return dateLeft.getFullYear() === dateRight.getFullYear() && dateLeft.getMonth() === dateRight.getMonth();
    }

    /**
     * @name isSameQuarter
     * @category Quarter Helpers
     * @summary Are the given dates in the same quarter (and year)?
     *
     * @description
     * Are the given dates in the same quarter (and year)?
     *
     * @param {Date|Number} dateLeft - the first date to check
     * @param {Date|Number} dateRight - the second date to check
     * @returns {Boolean} the dates are in the same quarter (and year)
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // Are 1 January 2014 and 8 March 2014 in the same quarter?
     * const result = isSameQuarter(new Date(2014, 0, 1), new Date(2014, 2, 8))
     * //=> true
     *
     * @example
     * // Are 1 January 2014 and 1 January 2015 in the same quarter?
     * const result = isSameQuarter(new Date(2014, 0, 1), new Date(2015, 0, 1))
     * //=> false
     */

    function isSameQuarter(dirtyDateLeft, dirtyDateRight) {
      requiredArgs$1(2, arguments);
      var dateLeftStartOfQuarter = startOfQuarter(dirtyDateLeft);
      var dateRightStartOfQuarter = startOfQuarter(dirtyDateRight);
      return dateLeftStartOfQuarter.getTime() === dateRightStartOfQuarter.getTime();
    }

    /**
     * @name startOfSecond
     * @category Second Helpers
     * @summary Return the start of a second for the given date.
     *
     * @description
     * Return the start of a second for the given date.
     * The result will be in the local timezone.
     *
     * @param {Date|Number} date - the original date
     * @returns {Date} the start of a second
     * @throws {TypeError} 1 argument required
     *
     * @example
     * // The start of a second for 1 December 2014 22:15:45.400:
     * const result = startOfSecond(new Date(2014, 11, 1, 22, 15, 45, 400))
     * //=> Mon Dec 01 2014 22:15:45.000
     */

    function startOfSecond(dirtyDate) {
      requiredArgs$1(1, arguments);
      var date = toDate$2(dirtyDate);
      date.setMilliseconds(0);
      return date;
    }

    /**
     * @name isSameYear
     * @category Year Helpers
     * @summary Are the given dates in the same year?
     *
     * @description
     * Are the given dates in the same year?
     *
     * @param {Date|Number} dateLeft - the first date to check
     * @param {Date|Number} dateRight - the second date to check
     * @returns {Boolean} the dates are in the same year
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // Are 2 September 2014 and 25 September 2014 in the same year?
     * const result = isSameYear(new Date(2014, 8, 2), new Date(2014, 8, 25))
     * //=> true
     */

    function isSameYear(dirtyDateLeft, dirtyDateRight) {
      requiredArgs$1(2, arguments);
      var dateLeft = toDate$2(dirtyDateLeft);
      var dateRight = toDate$2(dirtyDateRight);
      return dateLeft.getFullYear() === dateRight.getFullYear();
    }

    /**
     * @name setMonth
     * @category Month Helpers
     * @summary Set the month to the given date.
     *
     * @description
     * Set the month to the given date.
     *
     * @param {Date|Number} date - the date to be changed
     * @param {Number} month - the month of the new date
     * @returns {Date} the new date with the month set
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // Set February to 1 September 2014:
     * const result = setMonth(new Date(2014, 8, 1), 1)
     * //=> Sat Feb 01 2014 00:00:00
     */

    function setMonth(dirtyDate, dirtyMonth) {
      requiredArgs$1(2, arguments);
      var date = toDate$2(dirtyDate);
      var month = toInteger$1(dirtyMonth);
      var year = date.getFullYear();
      var day = date.getDate();
      var dateWithDesiredMonth = new Date(0);
      dateWithDesiredMonth.setFullYear(year, month, 15);
      dateWithDesiredMonth.setHours(0, 0, 0, 0);
      var daysInMonth = getDaysInMonth(dateWithDesiredMonth); // Set the last day of the new month
      // if the original date was the last day of the longer month

      date.setMonth(month, Math.min(day, daysInMonth));
      return date;
    }

    /**
     * @name set
     * @category Common Helpers
     * @summary Set date values to a given date.
     *
     * @description
     * Set date values to a given date.
     *
     * Sets time values to date from object `values`.
     * A value is not set if it is undefined or null or doesn't exist in `values`.
     *
     * Note about bundle size: `set` does not internally use `setX` functions from date-fns but instead opts
     * to use native `Date#setX` methods. If you use this function, you may not want to include the
     * other `setX` functions that date-fns provides if you are concerned about the bundle size.
     *
     * @param {Date|Number} date - the date to be changed
     * @param {Object} values - an object with options
     * @param {Number} [values.year] - the number of years to be set
     * @param {Number} [values.month] - the number of months to be set
     * @param {Number} [values.date] - the number of days to be set
     * @param {Number} [values.hours] - the number of hours to be set
     * @param {Number} [values.minutes] - the number of minutes to be set
     * @param {Number} [values.seconds] - the number of seconds to be set
     * @param {Number} [values.milliseconds] - the number of milliseconds to be set
     * @returns {Date} the new date with options set
     * @throws {TypeError} 2 arguments required
     * @throws {RangeError} `values` must be an object
     *
     * @example
     * // Transform 1 September 2014 into 20 October 2015 in a single line:
     * const result = set(new Date(2014, 8, 20), { year: 2015, month: 9, date: 20 })
     * //=> Tue Oct 20 2015 00:00:00
     *
     * @example
     * // Set 12 PM to 1 September 2014 01:23:45 to 1 September 2014 12:00:00:
     * const result = set(new Date(2014, 8, 1, 1, 23, 45), { hours: 12 })
     * //=> Mon Sep 01 2014 12:23:45
     */

    function set(dirtyDate, values) {
      requiredArgs$1(2, arguments);

      if (typeof values !== 'object' || values === null) {
        throw new RangeError('values parameter must be an object');
      }

      var date = toDate$2(dirtyDate); // Check if date is Invalid Date because Date.prototype.setFullYear ignores the value of Invalid Date

      if (isNaN(date.getTime())) {
        return new Date(NaN);
      }

      if (values.year != null) {
        date.setFullYear(values.year);
      }

      if (values.month != null) {
        date = setMonth(date, values.month);
      }

      if (values.date != null) {
        date.setDate(toInteger$1(values.date));
      }

      if (values.hours != null) {
        date.setHours(toInteger$1(values.hours));
      }

      if (values.minutes != null) {
        date.setMinutes(toInteger$1(values.minutes));
      }

      if (values.seconds != null) {
        date.setSeconds(toInteger$1(values.seconds));
      }

      if (values.milliseconds != null) {
        date.setMilliseconds(toInteger$1(values.milliseconds));
      }

      return date;
    }

    /**
     * @name setHours
     * @category Hour Helpers
     * @summary Set the hours to the given date.
     *
     * @description
     * Set the hours to the given date.
     *
     * @param {Date|Number} date - the date to be changed
     * @param {Number} hours - the hours of the new date
     * @returns {Date} the new date with the hours set
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // Set 4 hours to 1 September 2014 11:30:00:
     * const result = setHours(new Date(2014, 8, 1, 11, 30), 4)
     * //=> Mon Sep 01 2014 04:30:00
     */

    function setHours(dirtyDate, dirtyHours) {
      requiredArgs$1(2, arguments);
      var date = toDate$2(dirtyDate);
      var hours = toInteger$1(dirtyHours);
      date.setHours(hours);
      return date;
    }

    /**
     * @name setMinutes
     * @category Minute Helpers
     * @summary Set the minutes to the given date.
     *
     * @description
     * Set the minutes to the given date.
     *
     * @param {Date|Number} date - the date to be changed
     * @param {Number} minutes - the minutes of the new date
     * @returns {Date} the new date with the minutes set
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // Set 45 minutes to 1 September 2014 11:30:40:
     * const result = setMinutes(new Date(2014, 8, 1, 11, 30, 40), 45)
     * //=> Mon Sep 01 2014 11:45:40
     */

    function setMinutes(dirtyDate, dirtyMinutes) {
      requiredArgs$1(2, arguments);
      var date = toDate$2(dirtyDate);
      var minutes = toInteger$1(dirtyMinutes);
      date.setMinutes(minutes);
      return date;
    }

    /**
     * @name setQuarter
     * @category Quarter Helpers
     * @summary Set the year quarter to the given date.
     *
     * @description
     * Set the year quarter to the given date.
     *
     * @param {Date|Number} date - the date to be changed
     * @param {Number} quarter - the quarter of the new date
     * @returns {Date} the new date with the quarter set
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // Set the 2nd quarter to 2 July 2014:
     * const result = setQuarter(new Date(2014, 6, 2), 2)
     * //=> Wed Apr 02 2014 00:00:00
     */

    function setQuarter(dirtyDate, dirtyQuarter) {
      requiredArgs$1(2, arguments);
      var date = toDate$2(dirtyDate);
      var quarter = toInteger$1(dirtyQuarter);
      var oldQuarter = Math.floor(date.getMonth() / 3) + 1;
      var diff = quarter - oldQuarter;
      return setMonth(date, date.getMonth() + diff * 3);
    }

    /**
     * @name setSeconds
     * @category Second Helpers
     * @summary Set the seconds to the given date.
     *
     * @description
     * Set the seconds to the given date.
     *
     * @param {Date|Number} date - the date to be changed
     * @param {Number} seconds - the seconds of the new date
     * @returns {Date} the new date with the seconds set
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // Set 45 seconds to 1 September 2014 11:30:40:
     * const result = setSeconds(new Date(2014, 8, 1, 11, 30, 40), 45)
     * //=> Mon Sep 01 2014 11:30:45
     */

    function setSeconds(dirtyDate, dirtySeconds) {
      requiredArgs$1(2, arguments);
      var date = toDate$2(dirtyDate);
      var seconds = toInteger$1(dirtySeconds);
      date.setSeconds(seconds);
      return date;
    }

    /**
     * @name setYear
     * @category Year Helpers
     * @summary Set the year to the given date.
     *
     * @description
     * Set the year to the given date.
     *
     * @param {Date|Number} date - the date to be changed
     * @param {Number} year - the year of the new date
     * @returns {Date} the new date with the year set
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // Set year 2013 to 1 September 2014:
     * const result = setYear(new Date(2014, 8, 1), 2013)
     * //=> Sun Sep 01 2013 00:00:00
     */

    function setYear(dirtyDate, dirtyYear) {
      requiredArgs$1(2, arguments);
      var date = toDate$2(dirtyDate);
      var year = toInteger$1(dirtyYear); // Check if date is Invalid Date because Date.prototype.setFullYear ignores the value of Invalid Date

      if (isNaN(date.getTime())) {
        return new Date(NaN);
      }

      date.setFullYear(year);
      return date;
    }

    var accusativeWeekdays$1 = ['неділю', 'понеділок', 'вівторок', 'середу', 'четвер', 'п’ятницю', 'суботу'];

    function lastWeek$2(day) {
      var weekday = accusativeWeekdays$1[day];

      switch (day) {
        case 0:
        case 3:
        case 5:
        case 6:
          return "'у минулу " + weekday + " о' p";

        case 1:
        case 2:
        case 4:
          return "'у минулий " + weekday + " о' p";
      }
    }

    function thisWeek$2(day) {
      var weekday = accusativeWeekdays$1[day];
      return "'у " + weekday + " о' p";
    }

    function nextWeek$2(day) {
      var weekday = accusativeWeekdays$1[day];

      switch (day) {
        case 0:
        case 3:
        case 5:
        case 6:
          return "'у наступну " + weekday + " о' p";

        case 1:
        case 2:
        case 4:
          return "'у наступний " + weekday + " о' p";
      }
    }

    var lastWeekFormat = function (dirtyDate, baseDate, options) {
      var date = toDate$2(dirtyDate);
      var day = date.getUTCDay();

      if (isSameUTCWeek(date, baseDate, options)) {
        return thisWeek$2(day);
      } else {
        return lastWeek$2(day);
      }
    };

    var nextWeekFormat = function (dirtyDate, baseDate, options) {
      var date = toDate$2(dirtyDate);
      var day = date.getUTCDay();

      if (isSameUTCWeek(date, baseDate, options)) {
        return thisWeek$2(day);
      } else {
        return nextWeek$2(day);
      }
    };

    var formatRelativeLocale$f = {
      lastWeek: lastWeekFormat,
      yesterday: "'вчора о' p",
      today: "'сьогодні о' p",
      tomorrow: "'завтра о' p",
      nextWeek: nextWeekFormat,
      other: 'P'
    };

    var formatRelative$g = function (token, date, baseDate, options) {
      var format = formatRelativeLocale$f[token];

      if (typeof format === 'function') {
        return format(date, baseDate, options);
      }

      return format;
    };

    var eraValues$f = {
      narrow: ['до н.е.', 'н.е.'],
      abbreviated: ['до н. е.', 'н. е.'],
      wide: ['до нашої ери', 'нашої ери']
    };
    var quarterValues$f = {
      narrow: ['1', '2', '3', '4'],
      abbreviated: ['1-й кв.', '2-й кв.', '3-й кв.', '4-й кв.'],
      wide: ['1-й квартал', '2-й квартал', '3-й квартал', '4-й квартал']
    };
    var monthValues$f = {
      // ДСТУ 3582:2013
      narrow: ['С', 'Л', 'Б', 'К', 'Т', 'Ч', 'Л', 'С', 'В', 'Ж', 'Л', 'Г'],
      abbreviated: ['січ.', 'лют.', 'берез.', 'квіт.', 'трав.', 'черв.', 'лип.', 'серп.', 'верес.', 'жовт.', 'листоп.', 'груд.'],
      wide: ['січень', 'лютий', 'березень', 'квітень', 'травень', 'червень', 'липень', 'серпень', 'вересень', 'жовтень', 'листопад', 'грудень']
    };
    var formattingMonthValues$3 = {
      narrow: ['С', 'Л', 'Б', 'К', 'Т', 'Ч', 'Л', 'С', 'В', 'Ж', 'Л', 'Г'],
      abbreviated: ['січ.', 'лют.', 'берез.', 'квіт.', 'трав.', 'черв.', 'лип.', 'серп.', 'верес.', 'жовт.', 'листоп.', 'груд.'],
      wide: ['січня', 'лютого', 'березня', 'квітня', 'травня', 'червня', 'липня', 'серпня', 'вересня', 'жовтня', 'листопада', 'грудня']
    };
    var dayValues$f = {
      narrow: ['Н', 'П', 'В', 'С', 'Ч', 'П', 'С'],
      short: ['нд', 'пн', 'вт', 'ср', 'чт', 'пт', 'сб'],
      abbreviated: ['нед', 'пон', 'вів', 'сер', 'чтв', 'птн', 'суб'],
      wide: ['неділя', 'понеділок', 'вівторок', 'середа', 'четвер', 'п’ятниця', 'субота']
    };
    var dayPeriodValues$f = {
      narrow: {
        am: 'ДП',
        pm: 'ПП',
        midnight: 'півн.',
        noon: 'пол.',
        morning: 'ранок',
        afternoon: 'день',
        evening: 'веч.',
        night: 'ніч'
      },
      abbreviated: {
        am: 'ДП',
        pm: 'ПП',
        midnight: 'півн.',
        noon: 'пол.',
        morning: 'ранок',
        afternoon: 'день',
        evening: 'веч.',
        night: 'ніч'
      },
      wide: {
        am: 'ДП',
        pm: 'ПП',
        midnight: 'північ',
        noon: 'полудень',
        morning: 'ранок',
        afternoon: 'день',
        evening: 'вечір',
        night: 'ніч'
      }
    };
    var formattingDayPeriodValues$a = {
      narrow: {
        am: 'ДП',
        pm: 'ПП',
        midnight: 'півн.',
        noon: 'пол.',
        morning: 'ранку',
        afternoon: 'дня',
        evening: 'веч.',
        night: 'ночі'
      },
      abbreviated: {
        am: 'ДП',
        pm: 'ПП',
        midnight: 'півн.',
        noon: 'пол.',
        morning: 'ранку',
        afternoon: 'дня',
        evening: 'веч.',
        night: 'ночі'
      },
      wide: {
        am: 'ДП',
        pm: 'ПП',
        midnight: 'північ',
        noon: 'полудень',
        morning: 'ранку',
        afternoon: 'дня',
        evening: 'веч.',
        night: 'ночі'
      }
    };

    var ordinalNumber$f = function (dirtyNumber, options) {
      var unit = String(options === null || options === void 0 ? void 0 : options.unit);
      var number = Number(dirtyNumber);
      var suffix;

      if (unit === 'date') {
        if (number === 3 || number === 23) {
          suffix = '-є';
        } else {
          suffix = '-е';
        }
      } else if (unit === 'minute' || unit === 'second' || unit === 'hour') {
        suffix = '-а';
      } else {
        suffix = '-й';
      }

      return number + suffix;
    };

    var localize$g = {
      ordinalNumber: ordinalNumber$f,
      era: buildLocalizeFn$1({
        values: eraValues$f,
        defaultWidth: 'wide'
      }),
      quarter: buildLocalizeFn$1({
        values: quarterValues$f,
        defaultWidth: 'wide',
        argumentCallback: function (quarter) {
          return quarter - 1;
        }
      }),
      month: buildLocalizeFn$1({
        values: monthValues$f,
        defaultWidth: 'wide',
        formattingValues: formattingMonthValues$3,
        defaultFormattingWidth: 'wide'
      }),
      day: buildLocalizeFn$1({
        values: dayValues$f,
        defaultWidth: 'wide'
      }),
      dayPeriod: buildLocalizeFn$1({
        values: dayPeriodValues$f,
        defaultWidth: 'any',
        formattingValues: formattingDayPeriodValues$a,
        defaultFormattingWidth: 'wide'
      })
    };

    var matchOrdinalNumberPattern$f = /^(\d+)(-?(е|й|є|а|я))?/i;
    var parseOrdinalNumberPattern$f = /\d+/i;
    var matchEraPatterns$f = {
      narrow: /^((до )?н\.?\s?е\.?)/i,
      abbreviated: /^((до )?н\.?\s?е\.?)/i,
      wide: /^(до нашої ери|нашої ери|наша ера)/i
    };
    var parseEraPatterns$f = {
      any: [/^д/i, /^н/i]
    };
    var matchQuarterPatterns$f = {
      narrow: /^[1234]/i,
      abbreviated: /^[1234](-?[иі]?й?)? кв.?/i,
      wide: /^[1234](-?[иі]?й?)? квартал/i
    };
    var parseQuarterPatterns$f = {
      any: [/1/i, /2/i, /3/i, /4/i]
    };
    var matchMonthPatterns$f = {
      narrow: /^[слбктчвжг]/i,
      abbreviated: /^(січ|лют|бер(ез)?|квіт|трав|черв|лип|серп|вер(ес)?|жовт|лис(топ)?|груд)\.?/i,
      wide: /^(січень|січня|лютий|лютого|березень|березня|квітень|квітня|травень|травня|червня|червень|липень|липня|серпень|серпня|вересень|вересня|жовтень|жовтня|листопад[а]?|грудень|грудня)/i
    };
    var parseMonthPatterns$f = {
      narrow: [/^с/i, /^л/i, /^б/i, /^к/i, /^т/i, /^ч/i, /^л/i, /^с/i, /^в/i, /^ж/i, /^л/i, /^г/i],
      any: [/^сі/i, /^лю/i, /^б/i, /^к/i, /^т/i, /^ч/i, /^лип/i, /^се/i, /^в/i, /^ж/i, /^лис/i, /^г/i]
    };
    var matchDayPatterns$f = {
      narrow: /^[нпвсч]/i,
      short: /^(нд|пн|вт|ср|чт|пт|сб)\.?/i,
      abbreviated: /^(нед|пон|вів|сер|че?тв|птн?|суб)\.?/i,
      wide: /^(неділ[яі]|понеділ[ок][ка]|вівтор[ок][ка]|серед[аи]|четвер(га)?|п\W*?ятниц[яі]|субот[аи])/i
    };
    var parseDayPatterns$f = {
      narrow: [/^н/i, /^п/i, /^в/i, /^с/i, /^ч/i, /^п/i, /^с/i],
      any: [/^н/i, /^п[он]/i, /^в/i, /^с[ер]/i, /^ч/i, /^п\W*?[ят]/i, /^с[уб]/i]
    };
    var matchDayPeriodPatterns$f = {
      narrow: /^([дп]п|півн\.?|пол\.?|ранок|ранку|день|дня|веч\.?|ніч|ночі)/i,
      abbreviated: /^([дп]п|півн\.?|пол\.?|ранок|ранку|день|дня|веч\.?|ніч|ночі)/i,
      wide: /^([дп]п|північ|полудень|ранок|ранку|день|дня|вечір|вечора|ніч|ночі)/i
    };
    var parseDayPeriodPatterns$f = {
      any: {
        am: /^дп/i,
        pm: /^пп/i,
        midnight: /^півн/i,
        noon: /^пол/i,
        morning: /^р/i,
        afternoon: /^д[ен]/i,
        evening: /^в/i,
        night: /^н/i
      }
    };
    var match$g = {
      ordinalNumber: buildMatchPatternFn$1({
        matchPattern: matchOrdinalNumberPattern$f,
        parsePattern: parseOrdinalNumberPattern$f,
        valueCallback: function (value) {
          return parseInt(value, 10);
        }
      }),
      era: buildMatchFn$1({
        matchPatterns: matchEraPatterns$f,
        defaultMatchWidth: 'wide',
        parsePatterns: parseEraPatterns$f,
        defaultParseWidth: 'any'
      }),
      quarter: buildMatchFn$1({
        matchPatterns: matchQuarterPatterns$f,
        defaultMatchWidth: 'wide',
        parsePatterns: parseQuarterPatterns$f,
        defaultParseWidth: 'any',
        valueCallback: function (index) {
          return index + 1;
        }
      }),
      month: buildMatchFn$1({
        matchPatterns: matchMonthPatterns$f,
        defaultMatchWidth: 'wide',
        parsePatterns: parseMonthPatterns$f,
        defaultParseWidth: 'any'
      }),
      day: buildMatchFn$1({
        matchPatterns: matchDayPatterns$f,
        defaultMatchWidth: 'wide',
        parsePatterns: parseDayPatterns$f,
        defaultParseWidth: 'any'
      }),
      dayPeriod: buildMatchFn$1({
        matchPatterns: matchDayPeriodPatterns$f,
        defaultMatchWidth: 'wide',
        parsePatterns: parseDayPeriodPatterns$f,
        defaultParseWidth: 'any'
      })
    };

    /**
     * @type {Locale}
     * @category Locales
     * @summary Ukrainian locale.
     * @language Ukrainian
     * @iso-639-2 ukr
     * @author Andrii Korzh [@korzhyk]{@link https://github.com/korzhyk}
     * @author Andriy Shcherbyak [@shcherbyakdev]{@link https://github.com/shcherbyakdev}
     */

    var locale$g = {
      code: 'uk',
      formatDistance: formatDistance$g,
      formatLong: formatLong$h,
      formatRelative: formatRelative$g,
      localize: localize$g,
      match: match$g,
      options: {
        weekStartsOn: 1
        /* Monday */
        ,
        firstWeekContainsDate: 1
      }
    };

    const dateUkUA = {
      name: "uk-UA",
      locale: locale$g
    };
    var dateUkUA$1 = dateUkUA;

    var formatDistanceLocale$e = {
      lessThanXSeconds: {
        one: '1秒未満',
        other: '{{count}}秒未満',
        oneWithSuffix: '約1秒',
        otherWithSuffix: '約{{count}}秒'
      },
      xSeconds: {
        one: '1秒',
        other: '{{count}}秒'
      },
      halfAMinute: '30秒',
      lessThanXMinutes: {
        one: '1分未満',
        other: '{{count}}分未満',
        oneWithSuffix: '約1分',
        otherWithSuffix: '約{{count}}分'
      },
      xMinutes: {
        one: '1分',
        other: '{{count}}分'
      },
      aboutXHours: {
        one: '約1時間',
        other: '約{{count}}時間'
      },
      xHours: {
        one: '1時間',
        other: '{{count}}時間'
      },
      xDays: {
        one: '1日',
        other: '{{count}}日'
      },
      aboutXWeeks: {
        one: '約1週間',
        other: '約{{count}}週間'
      },
      xWeeks: {
        one: '1週間',
        other: '{{count}}週間'
      },
      aboutXMonths: {
        one: '約1か月',
        other: '約{{count}}か月'
      },
      xMonths: {
        one: '1か月',
        other: '{{count}}か月'
      },
      aboutXYears: {
        one: '約1年',
        other: '約{{count}}年'
      },
      xYears: {
        one: '1年',
        other: '{{count}}年'
      },
      overXYears: {
        one: '1年以上',
        other: '{{count}}年以上'
      },
      almostXYears: {
        one: '1年近く',
        other: '{{count}}年近く'
      }
    };

    var formatDistance$f = function (token, count, options) {
      options = options || {};
      var result;
      var tokenValue = formatDistanceLocale$e[token];

      if (typeof tokenValue === 'string') {
        result = tokenValue;
      } else if (count === 1) {
        if (options.addSuffix && tokenValue.oneWithSuffix) {
          result = tokenValue.oneWithSuffix;
        } else {
          result = tokenValue.one;
        }
      } else {
        if (options.addSuffix && tokenValue.otherWithSuffix) {
          result = tokenValue.otherWithSuffix.replace('{{count}}', String(count));
        } else {
          result = tokenValue.other.replace('{{count}}', String(count));
        }
      }

      if (options.addSuffix) {
        if (options.comparison && options.comparison > 0) {
          return result + '後';
        } else {
          return result + '前';
        }
      }

      return result;
    };

    var dateFormats$f = {
      full: 'y年M月d日EEEE',
      long: 'y年M月d日',
      medium: 'y/MM/dd',
      short: 'y/MM/dd'
    };
    var timeFormats$f = {
      full: 'H時mm分ss秒 zzzz',
      long: 'H:mm:ss z',
      medium: 'H:mm:ss',
      short: 'H:mm'
    };
    var dateTimeFormats$f = {
      full: '{{date}} {{time}}',
      long: '{{date}} {{time}}',
      medium: '{{date}} {{time}}',
      short: '{{date}} {{time}}'
    };
    var formatLong$g = {
      date: buildFormatLongFn$1({
        formats: dateFormats$f,
        defaultWidth: 'full'
      }),
      time: buildFormatLongFn$1({
        formats: timeFormats$f,
        defaultWidth: 'full'
      }),
      dateTime: buildFormatLongFn$1({
        formats: dateTimeFormats$f,
        defaultWidth: 'full'
      })
    };

    var formatRelativeLocale$e = {
      lastWeek: '先週のeeeeのp',
      yesterday: '昨日のp',
      today: '今日のp',
      tomorrow: '明日のp',
      nextWeek: '翌週のeeeeのp',
      other: 'P'
    };

    var formatRelative$f = function (token, _date, _baseDate, _options) {
      return formatRelativeLocale$e[token];
    };

    var eraValues$e = {
      narrow: ['BC', 'AC'],
      abbreviated: ['紀元前', '西暦'],
      wide: ['紀元前', '西暦']
    };
    var quarterValues$e = {
      narrow: ['1', '2', '3', '4'],
      abbreviated: ['Q1', 'Q2', 'Q3', 'Q4'],
      wide: ['第1四半期', '第2四半期', '第3四半期', '第4四半期']
    };
    var monthValues$e = {
      narrow: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'],
      abbreviated: ['1月', '2月', '3月', '4月', '5月', '6月', '7月', '8月', '9月', '10月', '11月', '12月'],
      wide: ['1月', '2月', '3月', '4月', '5月', '6月', '7月', '8月', '9月', '10月', '11月', '12月']
    };
    var dayValues$e = {
      narrow: ['日', '月', '火', '水', '木', '金', '土'],
      short: ['日', '月', '火', '水', '木', '金', '土'],
      abbreviated: ['日', '月', '火', '水', '木', '金', '土'],
      wide: ['日曜日', '月曜日', '火曜日', '水曜日', '木曜日', '金曜日', '土曜日']
    };
    var dayPeriodValues$e = {
      narrow: {
        am: '午前',
        pm: '午後',
        midnight: '深夜',
        noon: '正午',
        morning: '朝',
        afternoon: '午後',
        evening: '夜',
        night: '深夜'
      },
      abbreviated: {
        am: '午前',
        pm: '午後',
        midnight: '深夜',
        noon: '正午',
        morning: '朝',
        afternoon: '午後',
        evening: '夜',
        night: '深夜'
      },
      wide: {
        am: '午前',
        pm: '午後',
        midnight: '深夜',
        noon: '正午',
        morning: '朝',
        afternoon: '午後',
        evening: '夜',
        night: '深夜'
      }
    };
    var formattingDayPeriodValues$9 = {
      narrow: {
        am: '午前',
        pm: '午後',
        midnight: '深夜',
        noon: '正午',
        morning: '朝',
        afternoon: '午後',
        evening: '夜',
        night: '深夜'
      },
      abbreviated: {
        am: '午前',
        pm: '午後',
        midnight: '深夜',
        noon: '正午',
        morning: '朝',
        afternoon: '午後',
        evening: '夜',
        night: '深夜'
      },
      wide: {
        am: '午前',
        pm: '午後',
        midnight: '深夜',
        noon: '正午',
        morning: '朝',
        afternoon: '午後',
        evening: '夜',
        night: '深夜'
      }
    };

    var ordinalNumber$e = function (dirtyNumber, options) {
      var number = Number(dirtyNumber);
      var unit = String(options === null || options === void 0 ? void 0 : options.unit);

      switch (unit) {
        case 'year':
          return "".concat(number, "\u5E74");

        case 'quarter':
          return "\u7B2C".concat(number, "\u56DB\u534A\u671F");

        case 'month':
          return "".concat(number, "\u6708");

        case 'week':
          return "\u7B2C".concat(number, "\u9031");

        case 'date':
          return "".concat(number, "\u65E5");

        case 'hour':
          return "".concat(number, "\u6642");

        case 'minute':
          return "".concat(number, "\u5206");

        case 'second':
          return "".concat(number, "\u79D2");

        default:
          return "".concat(number);
      }
    };

    var localize$f = {
      ordinalNumber: ordinalNumber$e,
      era: buildLocalizeFn$1({
        values: eraValues$e,
        defaultWidth: 'wide'
      }),
      quarter: buildLocalizeFn$1({
        values: quarterValues$e,
        defaultWidth: 'wide',
        argumentCallback: function (quarter) {
          return Number(quarter) - 1;
        }
      }),
      month: buildLocalizeFn$1({
        values: monthValues$e,
        defaultWidth: 'wide'
      }),
      day: buildLocalizeFn$1({
        values: dayValues$e,
        defaultWidth: 'wide'
      }),
      dayPeriod: buildLocalizeFn$1({
        values: dayPeriodValues$e,
        defaultWidth: 'wide',
        formattingValues: formattingDayPeriodValues$9,
        defaultFormattingWidth: 'wide'
      })
    };

    var matchOrdinalNumberPattern$e = /^第?\d+(年|四半期|月|週|日|時|分|秒)?/i;
    var parseOrdinalNumberPattern$e = /\d+/i;
    var matchEraPatterns$e = {
      narrow: /^(B\.?C\.?|A\.?D\.?)/i,
      abbreviated: /^(紀元[前後]|西暦)/i,
      wide: /^(紀元[前後]|西暦)/i
    };
    var parseEraPatterns$e = {
      narrow: [/^B/i, /^A/i],
      any: [/^(紀元前)/i, /^(西暦|紀元後)/i]
    };
    var matchQuarterPatterns$e = {
      narrow: /^[1234]/i,
      abbreviated: /^Q[1234]/i,
      wide: /^第[1234一二三四１２３４]四半期/i
    };
    var parseQuarterPatterns$e = {
      any: [/(1|一|１)/i, /(2|二|２)/i, /(3|三|３)/i, /(4|四|４)/i]
    };
    var matchMonthPatterns$e = {
      narrow: /^([123456789]|1[012])/,
      abbreviated: /^([123456789]|1[012])月/i,
      wide: /^([123456789]|1[012])月/i
    };
    var parseMonthPatterns$e = {
      any: [/^1\D/, /^2/, /^3/, /^4/, /^5/, /^6/, /^7/, /^8/, /^9/, /^10/, /^11/, /^12/]
    };
    var matchDayPatterns$e = {
      narrow: /^[日月火水木金土]/,
      short: /^[日月火水木金土]/,
      abbreviated: /^[日月火水木金土]/,
      wide: /^[日月火水木金土]曜日/
    };
    var parseDayPatterns$e = {
      any: [/^日/, /^月/, /^火/, /^水/, /^木/, /^金/, /^土/]
    };
    var matchDayPeriodPatterns$e = {
      any: /^(AM|PM|午前|午後|正午|深夜|真夜中|夜|朝)/i
    };
    var parseDayPeriodPatterns$e = {
      any: {
        am: /^(A|午前)/i,
        pm: /^(P|午後)/i,
        midnight: /^深夜|真夜中/i,
        noon: /^正午/i,
        morning: /^朝/i,
        afternoon: /^午後/i,
        evening: /^夜/i,
        night: /^深夜/i
      }
    };
    var match$f = {
      ordinalNumber: buildMatchPatternFn$1({
        matchPattern: matchOrdinalNumberPattern$e,
        parsePattern: parseOrdinalNumberPattern$e,
        valueCallback: function (value) {
          return parseInt(value, 10);
        }
      }),
      era: buildMatchFn$1({
        matchPatterns: matchEraPatterns$e,
        defaultMatchWidth: 'wide',
        parsePatterns: parseEraPatterns$e,
        defaultParseWidth: 'any'
      }),
      quarter: buildMatchFn$1({
        matchPatterns: matchQuarterPatterns$e,
        defaultMatchWidth: 'wide',
        parsePatterns: parseQuarterPatterns$e,
        defaultParseWidth: 'any',
        valueCallback: function (index) {
          return index + 1;
        }
      }),
      month: buildMatchFn$1({
        matchPatterns: matchMonthPatterns$e,
        defaultMatchWidth: 'wide',
        parsePatterns: parseMonthPatterns$e,
        defaultParseWidth: 'any'
      }),
      day: buildMatchFn$1({
        matchPatterns: matchDayPatterns$e,
        defaultMatchWidth: 'wide',
        parsePatterns: parseDayPatterns$e,
        defaultParseWidth: 'any'
      }),
      dayPeriod: buildMatchFn$1({
        matchPatterns: matchDayPeriodPatterns$e,
        defaultMatchWidth: 'any',
        parsePatterns: parseDayPeriodPatterns$e,
        defaultParseWidth: 'any'
      })
    };

    /**
     * @type {Locale}
     * @category Locales
     * @summary Japanese locale.
     * @language Japanese
     * @iso-639-2 jpn
     * @author Thomas Eilmsteiner [@DeMuu]{@link https://github.com/DeMuu}
     * @author Yamagishi Kazutoshi [@ykzts]{@link https://github.com/ykzts}
     * @author Luca Ban [@mesqueeb]{@link https://github.com/mesqueeb}
     * @author Terrence Lam [@skyuplam]{@link https://github.com/skyuplam}
     * @author Taiki IKeda [@so99ynoodles]{@link https://github.com/so99ynoodles}
     */

    var locale$f = {
      code: 'ja',
      formatDistance: formatDistance$f,
      formatLong: formatLong$g,
      formatRelative: formatRelative$f,
      localize: localize$f,
      match: match$f,
      options: {
        weekStartsOn: 0
        /* Sunday */
        ,
        firstWeekContainsDate: 1
      }
    };

    const dateJaJP = {
      name: "ja-JP",
      locale: locale$f
    };
    var dateJaJP$1 = dateJaJP;

    var formatDistanceLocale$d = {
      lessThanXSeconds: {
        one: '1초 미만',
        other: '{{count}}초 미만'
      },
      xSeconds: {
        one: '1초',
        other: '{{count}}초'
      },
      halfAMinute: '30초',
      lessThanXMinutes: {
        one: '1분 미만',
        other: '{{count}}분 미만'
      },
      xMinutes: {
        one: '1분',
        other: '{{count}}분'
      },
      aboutXHours: {
        one: '약 1시간',
        other: '약 {{count}}시간'
      },
      xHours: {
        one: '1시간',
        other: '{{count}}시간'
      },
      xDays: {
        one: '1일',
        other: '{{count}}일'
      },
      aboutXWeeks: {
        one: '약 1주',
        other: '약 {{count}}주'
      },
      xWeeks: {
        one: '1주',
        other: '{{count}}주'
      },
      aboutXMonths: {
        one: '약 1개월',
        other: '약 {{count}}개월'
      },
      xMonths: {
        one: '1개월',
        other: '{{count}}개월'
      },
      aboutXYears: {
        one: '약 1년',
        other: '약 {{count}}년'
      },
      xYears: {
        one: '1년',
        other: '{{count}}년'
      },
      overXYears: {
        one: '1년 이상',
        other: '{{count}}년 이상'
      },
      almostXYears: {
        one: '거의 1년',
        other: '거의 {{count}}년'
      }
    };

    var formatDistance$e = function (token, count, options) {
      var result;
      var tokenValue = formatDistanceLocale$d[token];

      if (typeof tokenValue === 'string') {
        result = tokenValue;
      } else if (count === 1) {
        result = tokenValue.one;
      } else {
        result = tokenValue.other.replace('{{count}}', count.toString());
      }

      if (options !== null && options !== void 0 && options.addSuffix) {
        if (options.comparison && options.comparison > 0) {
          return result + ' 후';
        } else {
          return result + ' 전';
        }
      }

      return result;
    };

    var dateFormats$e = {
      full: 'y년 M월 d일 EEEE',
      long: 'y년 M월 d일',
      medium: 'y.MM.dd',
      short: 'y.MM.dd'
    };
    var timeFormats$e = {
      full: 'a H시 mm분 ss초 zzzz',
      long: 'a H:mm:ss z',
      medium: 'HH:mm:ss',
      short: 'HH:mm'
    };
    var dateTimeFormats$e = {
      full: '{{date}} {{time}}',
      long: '{{date}} {{time}}',
      medium: '{{date}} {{time}}',
      short: '{{date}} {{time}}'
    };
    var formatLong$f = {
      date: buildFormatLongFn$1({
        formats: dateFormats$e,
        defaultWidth: 'full'
      }),
      time: buildFormatLongFn$1({
        formats: timeFormats$e,
        defaultWidth: 'full'
      }),
      dateTime: buildFormatLongFn$1({
        formats: dateTimeFormats$e,
        defaultWidth: 'full'
      })
    };

    var formatRelativeLocale$d = {
      lastWeek: "'지난' eeee p",
      yesterday: "'어제' p",
      today: "'오늘' p",
      tomorrow: "'내일' p",
      nextWeek: "'다음' eeee p",
      other: 'P'
    };

    var formatRelative$e = function (token, _date, _baseDate, _options) {
      return formatRelativeLocale$d[token];
    };

    var eraValues$d = {
      narrow: ['BC', 'AD'],
      abbreviated: ['BC', 'AD'],
      wide: ['기원전', '서기']
    };
    var quarterValues$d = {
      narrow: ['1', '2', '3', '4'],
      abbreviated: ['Q1', 'Q2', 'Q3', 'Q4'],
      wide: ['1분기', '2분기', '3분기', '4분기']
    };
    var monthValues$d = {
      narrow: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'],
      abbreviated: ['1월', '2월', '3월', '4월', '5월', '6월', '7월', '8월', '9월', '10월', '11월', '12월'],
      wide: ['1월', '2월', '3월', '4월', '5월', '6월', '7월', '8월', '9월', '10월', '11월', '12월']
    };
    var dayValues$d = {
      narrow: ['일', '월', '화', '수', '목', '금', '토'],
      short: ['일', '월', '화', '수', '목', '금', '토'],
      abbreviated: ['일', '월', '화', '수', '목', '금', '토'],
      wide: ['일요일', '월요일', '화요일', '수요일', '목요일', '금요일', '토요일']
    };
    var dayPeriodValues$d = {
      narrow: {
        am: '오전',
        pm: '오후',
        midnight: '자정',
        noon: '정오',
        morning: '아침',
        afternoon: '오후',
        evening: '저녁',
        night: '밤'
      },
      abbreviated: {
        am: '오전',
        pm: '오후',
        midnight: '자정',
        noon: '정오',
        morning: '아침',
        afternoon: '오후',
        evening: '저녁',
        night: '밤'
      },
      wide: {
        am: '오전',
        pm: '오후',
        midnight: '자정',
        noon: '정오',
        morning: '아침',
        afternoon: '오후',
        evening: '저녁',
        night: '밤'
      }
    };
    var formattingDayPeriodValues$8 = {
      narrow: {
        am: '오전',
        pm: '오후',
        midnight: '자정',
        noon: '정오',
        morning: '아침',
        afternoon: '오후',
        evening: '저녁',
        night: '밤'
      },
      abbreviated: {
        am: '오전',
        pm: '오후',
        midnight: '자정',
        noon: '정오',
        morning: '아침',
        afternoon: '오후',
        evening: '저녁',
        night: '밤'
      },
      wide: {
        am: '오전',
        pm: '오후',
        midnight: '자정',
        noon: '정오',
        morning: '아침',
        afternoon: '오후',
        evening: '저녁',
        night: '밤'
      }
    };

    var ordinalNumber$d = function (dirtyNumber, options) {
      var number = Number(dirtyNumber);
      var unit = String(options === null || options === void 0 ? void 0 : options.unit);

      switch (unit) {
        case 'minute':
        case 'second':
          return String(number);

        case 'date':
          return number + '일';

        default:
          return number + '번째';
      }
    };

    var localize$e = {
      ordinalNumber: ordinalNumber$d,
      era: buildLocalizeFn$1({
        values: eraValues$d,
        defaultWidth: 'wide'
      }),
      quarter: buildLocalizeFn$1({
        values: quarterValues$d,
        defaultWidth: 'wide',
        argumentCallback: function (quarter) {
          return quarter - 1;
        }
      }),
      month: buildLocalizeFn$1({
        values: monthValues$d,
        defaultWidth: 'wide'
      }),
      day: buildLocalizeFn$1({
        values: dayValues$d,
        defaultWidth: 'wide'
      }),
      dayPeriod: buildLocalizeFn$1({
        values: dayPeriodValues$d,
        defaultWidth: 'wide',
        formattingValues: formattingDayPeriodValues$8,
        defaultFormattingWidth: 'wide'
      })
    };

    var matchOrdinalNumberPattern$d = /^(\d+)(일|번째)?/i;
    var parseOrdinalNumberPattern$d = /\d+/i;
    var matchEraPatterns$d = {
      narrow: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
      abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
      wide: /^(기원전|서기)/i
    };
    var parseEraPatterns$d = {
      any: [/^(bc|기원전)/i, /^(ad|서기)/i]
    };
    var matchQuarterPatterns$d = {
      narrow: /^[1234]/i,
      abbreviated: /^q[1234]/i,
      wide: /^[1234]사?분기/i
    };
    var parseQuarterPatterns$d = {
      any: [/1/i, /2/i, /3/i, /4/i]
    };
    var matchMonthPatterns$d = {
      narrow: /^(1[012]|[123456789])/,
      abbreviated: /^(1[012]|[123456789])월/i,
      wide: /^(1[012]|[123456789])월/i
    };
    var parseMonthPatterns$d = {
      any: [/^1월?$/, /^2/, /^3/, /^4/, /^5/, /^6/, /^7/, /^8/, /^9/, /^10/, /^11/, /^12/]
    };
    var matchDayPatterns$d = {
      narrow: /^[일월화수목금토]/,
      short: /^[일월화수목금토]/,
      abbreviated: /^[일월화수목금토]/,
      wide: /^[일월화수목금토]요일/
    };
    var parseDayPatterns$d = {
      any: [/^일/, /^월/, /^화/, /^수/, /^목/, /^금/, /^토/]
    };
    var matchDayPeriodPatterns$d = {
      any: /^(am|pm|오전|오후|자정|정오|아침|저녁|밤)/i
    };
    var parseDayPeriodPatterns$d = {
      any: {
        am: /^(am|오전)/i,
        pm: /^(pm|오후)/i,
        midnight: /^자정/i,
        noon: /^정오/i,
        morning: /^아침/i,
        afternoon: /^오후/i,
        evening: /^저녁/i,
        night: /^밤/i
      }
    };
    var match$e = {
      ordinalNumber: buildMatchPatternFn$1({
        matchPattern: matchOrdinalNumberPattern$d,
        parsePattern: parseOrdinalNumberPattern$d,
        valueCallback: function (value) {
          return parseInt(value, 10);
        }
      }),
      era: buildMatchFn$1({
        matchPatterns: matchEraPatterns$d,
        defaultMatchWidth: 'wide',
        parsePatterns: parseEraPatterns$d,
        defaultParseWidth: 'any'
      }),
      quarter: buildMatchFn$1({
        matchPatterns: matchQuarterPatterns$d,
        defaultMatchWidth: 'wide',
        parsePatterns: parseQuarterPatterns$d,
        defaultParseWidth: 'any',
        valueCallback: function (index) {
          return index + 1;
        }
      }),
      month: buildMatchFn$1({
        matchPatterns: matchMonthPatterns$d,
        defaultMatchWidth: 'wide',
        parsePatterns: parseMonthPatterns$d,
        defaultParseWidth: 'any'
      }),
      day: buildMatchFn$1({
        matchPatterns: matchDayPatterns$d,
        defaultMatchWidth: 'wide',
        parsePatterns: parseDayPatterns$d,
        defaultParseWidth: 'any'
      }),
      dayPeriod: buildMatchFn$1({
        matchPatterns: matchDayPeriodPatterns$d,
        defaultMatchWidth: 'any',
        parsePatterns: parseDayPeriodPatterns$d,
        defaultParseWidth: 'any'
      })
    };

    /**
     * @type {Locale}
     * @category Locales
     * @summary Korean locale.
     * @language Korean
     * @iso-639-2 kor
     * @author Hong Chulju [@angdev]{@link https://github.com/angdev}
     * @author Lee Seoyoen [@iamssen]{@link https://github.com/iamssen}
     * @author Taiki IKeda [@so99ynoodles]{@link https://github.com/so99ynoodles}
     */

    var locale$e = {
      code: 'ko',
      formatDistance: formatDistance$e,
      formatLong: formatLong$f,
      formatRelative: formatRelative$e,
      localize: localize$e,
      match: match$e,
      options: {
        weekStartsOn: 0
        /* Sunday */
        ,
        firstWeekContainsDate: 1
      }
    };

    const dateKoKR = {
      name: "ko-KR",
      locale: locale$e
    };
    var dateKoKR$1 = dateKoKR;

    var formatDistanceLocale$c = {
      lessThanXSeconds: {
        one: 'kurang dari 1 detik',
        other: 'kurang dari {{count}} detik'
      },
      xSeconds: {
        one: '1 detik',
        other: '{{count}} detik'
      },
      halfAMinute: 'setengah menit',
      lessThanXMinutes: {
        one: 'kurang dari 1 menit',
        other: 'kurang dari {{count}} menit'
      },
      xMinutes: {
        one: '1 menit',
        other: '{{count}} menit'
      },
      aboutXHours: {
        one: 'sekitar 1 jam',
        other: 'sekitar {{count}} jam'
      },
      xHours: {
        one: '1 jam',
        other: '{{count}} jam'
      },
      xDays: {
        one: '1 hari',
        other: '{{count}} hari'
      },
      aboutXWeeks: {
        one: 'sekitar 1 minggu',
        other: 'sekitar {{count}} minggu'
      },
      xWeeks: {
        one: '1 minggu',
        other: '{{count}} minggu'
      },
      aboutXMonths: {
        one: 'sekitar 1 bulan',
        other: 'sekitar {{count}} bulan'
      },
      xMonths: {
        one: '1 bulan',
        other: '{{count}} bulan'
      },
      aboutXYears: {
        one: 'sekitar 1 tahun',
        other: 'sekitar {{count}} tahun'
      },
      xYears: {
        one: '1 tahun',
        other: '{{count}} tahun'
      },
      overXYears: {
        one: 'lebih dari 1 tahun',
        other: 'lebih dari {{count}} tahun'
      },
      almostXYears: {
        one: 'hampir 1 tahun',
        other: 'hampir {{count}} tahun'
      }
    };

    var formatDistance$d = function (token, count, options) {
      var result;
      var tokenValue = formatDistanceLocale$c[token];

      if (typeof tokenValue === 'string') {
        result = tokenValue;
      } else if (count === 1) {
        result = tokenValue.one;
      } else {
        result = tokenValue.other.replace('{{count}}', count.toString());
      }

      if (options !== null && options !== void 0 && options.addSuffix) {
        if (options.comparison && options.comparison > 0) {
          return 'dalam waktu ' + result;
        } else {
          return result + ' yang lalu';
        }
      }

      return result;
    };

    var dateFormats$d = {
      full: 'EEEE, d MMMM yyyy',
      long: 'd MMMM yyyy',
      medium: 'd MMM yyyy',
      short: 'd/M/yyyy'
    };
    var timeFormats$d = {
      full: 'HH.mm.ss',
      long: 'HH.mm.ss',
      medium: 'HH.mm',
      short: 'HH.mm'
    };
    var dateTimeFormats$d = {
      full: "{{date}} 'pukul' {{time}}",
      long: "{{date}} 'pukul' {{time}}",
      medium: '{{date}}, {{time}}',
      short: '{{date}}, {{time}}'
    };
    var formatLong$e = {
      date: buildFormatLongFn$1({
        formats: dateFormats$d,
        defaultWidth: 'full'
      }),
      time: buildFormatLongFn$1({
        formats: timeFormats$d,
        defaultWidth: 'full'
      }),
      dateTime: buildFormatLongFn$1({
        formats: dateTimeFormats$d,
        defaultWidth: 'full'
      })
    };

    var formatRelativeLocale$c = {
      lastWeek: "eeee 'lalu pukul' p",
      yesterday: "'Kemarin pukul' p",
      today: "'Hari ini pukul' p",
      tomorrow: "'Besok pukul' p",
      nextWeek: "eeee 'pukul' p",
      other: 'P'
    };

    var formatRelative$d = function (token, _date, _baseDate, _options) {
      return formatRelativeLocale$c[token];
    };

    // https://www.unicode.org/cldr/charts/32/summary/id.html

    var eraValues$c = {
      narrow: ['SM', 'M'],
      abbreviated: ['SM', 'M'],
      wide: ['Sebelum Masehi', 'Masehi']
    };
    var quarterValues$c = {
      narrow: ['1', '2', '3', '4'],
      abbreviated: ['K1', 'K2', 'K3', 'K4'],
      wide: ['Kuartal ke-1', 'Kuartal ke-2', 'Kuartal ke-3', 'Kuartal ke-4']
    }; // Note: in Indonesian, the names of days of the week and months are capitalized.
    // If you are making a new locale based on this one, check if the same is true for the language you're working on.
    // Generally, formatted dates should look like they are in the middle of a sentence,
    // e.g. in Spanish language the weekdays and months should be in the lowercase.

    var monthValues$c = {
      narrow: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
      abbreviated: ['Jan', 'Feb', 'Mar', 'Apr', 'Mei', 'Jun', 'Jul', 'Agt', 'Sep', 'Okt', 'Nov', 'Des'],
      wide: ['Januari', 'Februari', 'Maret', 'April', 'Mei', 'Juni', 'Juli', 'Agustus', 'September', 'Oktober', 'November', 'Desember']
    };
    var dayValues$c = {
      narrow: ['M', 'S', 'S', 'R', 'K', 'J', 'S'],
      short: ['Min', 'Sen', 'Sel', 'Rab', 'Kam', 'Jum', 'Sab'],
      abbreviated: ['Min', 'Sen', 'Sel', 'Rab', 'Kam', 'Jum', 'Sab'],
      wide: ['Minggu', 'Senin', 'Selasa', 'Rabu', 'Kamis', 'Jumat', 'Sabtu']
    };
    var dayPeriodValues$c = {
      narrow: {
        am: 'AM',
        pm: 'PM',
        midnight: 'tengah malam',
        noon: 'tengah hari',
        morning: 'pagi',
        afternoon: 'siang',
        evening: 'sore',
        night: 'malam'
      },
      abbreviated: {
        am: 'AM',
        pm: 'PM',
        midnight: 'tengah malam',
        noon: 'tengah hari',
        morning: 'pagi',
        afternoon: 'siang',
        evening: 'sore',
        night: 'malam'
      },
      wide: {
        am: 'AM',
        pm: 'PM',
        midnight: 'tengah malam',
        noon: 'tengah hari',
        morning: 'pagi',
        afternoon: 'siang',
        evening: 'sore',
        night: 'malam'
      }
    };
    var formattingDayPeriodValues$7 = {
      narrow: {
        am: 'AM',
        pm: 'PM',
        midnight: 'tengah malam',
        noon: 'tengah hari',
        morning: 'pagi',
        afternoon: 'siang',
        evening: 'sore',
        night: 'malam'
      },
      abbreviated: {
        am: 'AM',
        pm: 'PM',
        midnight: 'tengah malam',
        noon: 'tengah hari',
        morning: 'pagi',
        afternoon: 'siang',
        evening: 'sore',
        night: 'malam'
      },
      wide: {
        am: 'AM',
        pm: 'PM',
        midnight: 'tengah malam',
        noon: 'tengah hari',
        morning: 'pagi',
        afternoon: 'siang',
        evening: 'sore',
        night: 'malam'
      }
    };

    var ordinalNumber$c = function (dirtyNumber, _options) {
      var number = Number(dirtyNumber); // Can't use "pertama", "kedua" because can't be parsed

      return 'ke-' + number;
    };

    var localize$d = {
      ordinalNumber: ordinalNumber$c,
      era: buildLocalizeFn$1({
        values: eraValues$c,
        defaultWidth: 'wide'
      }),
      quarter: buildLocalizeFn$1({
        values: quarterValues$c,
        defaultWidth: 'wide',
        argumentCallback: function (quarter) {
          return quarter - 1;
        }
      }),
      month: buildLocalizeFn$1({
        values: monthValues$c,
        defaultWidth: 'wide'
      }),
      day: buildLocalizeFn$1({
        values: dayValues$c,
        defaultWidth: 'wide'
      }),
      dayPeriod: buildLocalizeFn$1({
        values: dayPeriodValues$c,
        defaultWidth: 'wide',
        formattingValues: formattingDayPeriodValues$7,
        defaultFormattingWidth: 'wide'
      })
    };

    var matchOrdinalNumberPattern$c = /^ke-(\d+)?/i;
    var parseOrdinalNumberPattern$c = /\d+/i;
    var matchEraPatterns$c = {
      narrow: /^(sm|m)/i,
      abbreviated: /^(s\.?\s?m\.?|s\.?\s?e\.?\s?u\.?|m\.?|e\.?\s?u\.?)/i,
      wide: /^(sebelum masehi|sebelum era umum|masehi|era umum)/i
    };
    var parseEraPatterns$c = {
      any: [/^s/i, /^(m|e)/i]
    };
    var matchQuarterPatterns$c = {
      narrow: /^[1234]/i,
      abbreviated: /^K-?\s[1234]/i,
      wide: /^Kuartal ke-?\s?[1234]/i
    };
    var parseQuarterPatterns$c = {
      any: [/1/i, /2/i, /3/i, /4/i]
    };
    var matchMonthPatterns$c = {
      narrow: /^[jfmasond]/i,
      abbreviated: /^(jan|feb|mar|apr|mei|jun|jul|agt|sep|okt|nov|des)/i,
      wide: /^(januari|februari|maret|april|mei|juni|juli|agustus|september|oktober|november|desember)/i
    };
    var parseMonthPatterns$c = {
      narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
      any: [/^ja/i, /^f/i, /^ma/i, /^ap/i, /^me/i, /^jun/i, /^jul/i, /^ag/i, /^s/i, /^o/i, /^n/i, /^d/i]
    };
    var matchDayPatterns$c = {
      narrow: /^[srkjm]/i,
      short: /^(min|sen|sel|rab|kam|jum|sab)/i,
      abbreviated: /^(min|sen|sel|rab|kam|jum|sab)/i,
      wide: /^(minggu|senin|selasa|rabu|kamis|jumat|sabtu)/i
    };
    var parseDayPatterns$c = {
      narrow: [/^m/i, /^s/i, /^s/i, /^r/i, /^k/i, /^j/i, /^s/i],
      any: [/^m/i, /^sen/i, /^sel/i, /^r/i, /^k/i, /^j/i, /^sa/i]
    };
    var matchDayPeriodPatterns$c = {
      narrow: /^(a|p|tengah m|tengah h|(di(\swaktu)?) (pagi|siang|sore|malam))/i,
      any: /^([ap]\.?\s?m\.?|tengah malam|tengah hari|(di(\swaktu)?) (pagi|siang|sore|malam))/i
    };
    var parseDayPeriodPatterns$c = {
      any: {
        am: /^a/i,
        pm: /^pm/i,
        midnight: /^tengah m/i,
        noon: /^tengah h/i,
        morning: /pagi/i,
        afternoon: /siang/i,
        evening: /sore/i,
        night: /malam/i
      }
    };
    var match$d = {
      ordinalNumber: buildMatchPatternFn$1({
        matchPattern: matchOrdinalNumberPattern$c,
        parsePattern: parseOrdinalNumberPattern$c,
        valueCallback: function (value) {
          return parseInt(value, 10);
        }
      }),
      era: buildMatchFn$1({
        matchPatterns: matchEraPatterns$c,
        defaultMatchWidth: 'wide',
        parsePatterns: parseEraPatterns$c,
        defaultParseWidth: 'any'
      }),
      quarter: buildMatchFn$1({
        matchPatterns: matchQuarterPatterns$c,
        defaultMatchWidth: 'wide',
        parsePatterns: parseQuarterPatterns$c,
        defaultParseWidth: 'any',
        valueCallback: function (index) {
          return index + 1;
        }
      }),
      month: buildMatchFn$1({
        matchPatterns: matchMonthPatterns$c,
        defaultMatchWidth: 'wide',
        parsePatterns: parseMonthPatterns$c,
        defaultParseWidth: 'any'
      }),
      day: buildMatchFn$1({
        matchPatterns: matchDayPatterns$c,
        defaultMatchWidth: 'wide',
        parsePatterns: parseDayPatterns$c,
        defaultParseWidth: 'any'
      }),
      dayPeriod: buildMatchFn$1({
        matchPatterns: matchDayPeriodPatterns$c,
        defaultMatchWidth: 'any',
        parsePatterns: parseDayPeriodPatterns$c,
        defaultParseWidth: 'any'
      })
    };

    /**
     * @type {Locale}
     * @category Locales
     * @summary Indonesian locale.
     * @language Indonesian
     * @iso-639-2 ind
     * @author Rahmat Budiharso [@rbudiharso]{@link https://github.com/rbudiharso}
     * @author Benget Nata [@bentinata]{@link https://github.com/bentinata}
     * @author Budi Irawan [@deerawan]{@link https://github.com/deerawan}
     * @author Try Ajitiono [@imballinst]{@link https://github.com/imballinst}
     */

    var locale$d = {
      code: 'id',
      formatDistance: formatDistance$d,
      formatLong: formatLong$e,
      formatRelative: formatRelative$d,
      localize: localize$d,
      match: match$d,
      options: {
        weekStartsOn: 1
        /* Monday */
        ,
        firstWeekContainsDate: 1
      }
    };

    const dateIdID = {
      name: "id-ID",
      locale: locale$d
    };
    var dateIdID$1 = dateIdID;

    var formatDistanceLocale$b = {
      lessThanXSeconds: {
        standalone: {
          one: 'weniger als 1 Sekunde',
          other: 'weniger als {{count}} Sekunden'
        },
        withPreposition: {
          one: 'weniger als 1 Sekunde',
          other: 'weniger als {{count}} Sekunden'
        }
      },
      xSeconds: {
        standalone: {
          one: '1 Sekunde',
          other: '{{count}} Sekunden'
        },
        withPreposition: {
          one: '1 Sekunde',
          other: '{{count}} Sekunden'
        }
      },
      halfAMinute: {
        standalone: 'halbe Minute',
        withPreposition: 'halben Minute'
      },
      lessThanXMinutes: {
        standalone: {
          one: 'weniger als 1 Minute',
          other: 'weniger als {{count}} Minuten'
        },
        withPreposition: {
          one: 'weniger als 1 Minute',
          other: 'weniger als {{count}} Minuten'
        }
      },
      xMinutes: {
        standalone: {
          one: '1 Minute',
          other: '{{count}} Minuten'
        },
        withPreposition: {
          one: '1 Minute',
          other: '{{count}} Minuten'
        }
      },
      aboutXHours: {
        standalone: {
          one: 'etwa 1 Stunde',
          other: 'etwa {{count}} Stunden'
        },
        withPreposition: {
          one: 'etwa 1 Stunde',
          other: 'etwa {{count}} Stunden'
        }
      },
      xHours: {
        standalone: {
          one: '1 Stunde',
          other: '{{count}} Stunden'
        },
        withPreposition: {
          one: '1 Stunde',
          other: '{{count}} Stunden'
        }
      },
      xDays: {
        standalone: {
          one: '1 Tag',
          other: '{{count}} Tage'
        },
        withPreposition: {
          one: '1 Tag',
          other: '{{count}} Tagen'
        }
      },
      aboutXWeeks: {
        standalone: {
          one: 'etwa 1 Woche',
          other: 'etwa {{count}} Wochen'
        },
        withPreposition: {
          one: 'etwa 1 Woche',
          other: 'etwa {{count}} Wochen'
        }
      },
      xWeeks: {
        standalone: {
          one: '1 Woche',
          other: '{{count}} Wochen'
        },
        withPreposition: {
          one: '1 Woche',
          other: '{{count}} Wochen'
        }
      },
      aboutXMonths: {
        standalone: {
          one: 'etwa 1 Monat',
          other: 'etwa {{count}} Monate'
        },
        withPreposition: {
          one: 'etwa 1 Monat',
          other: 'etwa {{count}} Monaten'
        }
      },
      xMonths: {
        standalone: {
          one: '1 Monat',
          other: '{{count}} Monate'
        },
        withPreposition: {
          one: '1 Monat',
          other: '{{count}} Monaten'
        }
      },
      aboutXYears: {
        standalone: {
          one: 'etwa 1 Jahr',
          other: 'etwa {{count}} Jahre'
        },
        withPreposition: {
          one: 'etwa 1 Jahr',
          other: 'etwa {{count}} Jahren'
        }
      },
      xYears: {
        standalone: {
          one: '1 Jahr',
          other: '{{count}} Jahre'
        },
        withPreposition: {
          one: '1 Jahr',
          other: '{{count}} Jahren'
        }
      },
      overXYears: {
        standalone: {
          one: 'mehr als 1 Jahr',
          other: 'mehr als {{count}} Jahre'
        },
        withPreposition: {
          one: 'mehr als 1 Jahr',
          other: 'mehr als {{count}} Jahren'
        }
      },
      almostXYears: {
        standalone: {
          one: 'fast 1 Jahr',
          other: 'fast {{count}} Jahre'
        },
        withPreposition: {
          one: 'fast 1 Jahr',
          other: 'fast {{count}} Jahren'
        }
      }
    };

    var formatDistance$c = function (token, count, options) {
      var result;
      var tokenValue = options !== null && options !== void 0 && options.addSuffix ? formatDistanceLocale$b[token].withPreposition : formatDistanceLocale$b[token].standalone;

      if (typeof tokenValue === 'string') {
        result = tokenValue;
      } else if (count === 1) {
        result = tokenValue.one;
      } else {
        result = tokenValue.other.replace('{{count}}', String(count));
      }

      if (options !== null && options !== void 0 && options.addSuffix) {
        if (options.comparison && options.comparison > 0) {
          return 'in ' + result;
        } else {
          return 'vor ' + result;
        }
      }

      return result;
    };

    var dateFormats$c = {
      full: 'EEEE, do MMMM y',
      // Montag, 7. Januar 2018
      long: 'do MMMM y',
      // 7. Januar 2018
      medium: 'do MMM y',
      // 7. Jan. 2018
      short: 'dd.MM.y' // 07.01.2018

    };
    var timeFormats$c = {
      full: 'HH:mm:ss zzzz',
      long: 'HH:mm:ss z',
      medium: 'HH:mm:ss',
      short: 'HH:mm'
    };
    var dateTimeFormats$c = {
      full: "{{date}} 'um' {{time}}",
      long: "{{date}} 'um' {{time}}",
      medium: '{{date}} {{time}}',
      short: '{{date}} {{time}}'
    };
    var formatLong$d = {
      date: buildFormatLongFn$1({
        formats: dateFormats$c,
        defaultWidth: 'full'
      }),
      time: buildFormatLongFn$1({
        formats: timeFormats$c,
        defaultWidth: 'full'
      }),
      dateTime: buildFormatLongFn$1({
        formats: dateTimeFormats$c,
        defaultWidth: 'full'
      })
    };

    var formatRelativeLocale$b = {
      lastWeek: "'letzten' eeee 'um' p",
      yesterday: "'gestern um' p",
      today: "'heute um' p",
      tomorrow: "'morgen um' p",
      nextWeek: "eeee 'um' p",
      other: 'P'
    };

    var formatRelative$c = function (token, _date, _baseDate, _options) {
      return formatRelativeLocale$b[token];
    };

    var eraValues$b = {
      narrow: ['v.Chr.', 'n.Chr.'],
      abbreviated: ['v.Chr.', 'n.Chr.'],
      wide: ['vor Christus', 'nach Christus']
    };
    var quarterValues$b = {
      narrow: ['1', '2', '3', '4'],
      abbreviated: ['Q1', 'Q2', 'Q3', 'Q4'],
      wide: ['1. Quartal', '2. Quartal', '3. Quartal', '4. Quartal']
    }; // Note: in German, the names of days of the week and months are capitalized.
    // If you are making a new locale based on this one, check if the same is true for the language you're working on.
    // Generally, formatted dates should look like they are in the middle of a sentence,
    // e.g. in Spanish language the weekdays and months should be in the lowercase.

    var monthValues$b = {
      narrow: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
      abbreviated: ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'],
      wide: ['Januar', 'Februar', 'März', 'April', 'Mai', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember']
    }; // https://st.unicode.org/cldr-apps/v#/de/Gregorian/

    var formattingMonthValues$2 = {
      narrow: monthValues$b.narrow,
      abbreviated: ['Jan.', 'Feb.', 'März', 'Apr.', 'Mai', 'Juni', 'Juli', 'Aug.', 'Sep.', 'Okt.', 'Nov.', 'Dez.'],
      wide: monthValues$b.wide
    };
    var dayValues$b = {
      narrow: ['S', 'M', 'D', 'M', 'D', 'F', 'S'],
      short: ['So', 'Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa'],
      abbreviated: ['So.', 'Mo.', 'Di.', 'Mi.', 'Do.', 'Fr.', 'Sa.'],
      wide: ['Sonntag', 'Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag', 'Samstag']
    }; // https://www.unicode.org/cldr/charts/32/summary/de.html#1881

    var dayPeriodValues$b = {
      narrow: {
        am: 'vm.',
        pm: 'nm.',
        midnight: 'Mitternacht',
        noon: 'Mittag',
        morning: 'Morgen',
        afternoon: 'Nachm.',
        evening: 'Abend',
        night: 'Nacht'
      },
      abbreviated: {
        am: 'vorm.',
        pm: 'nachm.',
        midnight: 'Mitternacht',
        noon: 'Mittag',
        morning: 'Morgen',
        afternoon: 'Nachmittag',
        evening: 'Abend',
        night: 'Nacht'
      },
      wide: {
        am: 'vormittags',
        pm: 'nachmittags',
        midnight: 'Mitternacht',
        noon: 'Mittag',
        morning: 'Morgen',
        afternoon: 'Nachmittag',
        evening: 'Abend',
        night: 'Nacht'
      }
    };
    var formattingDayPeriodValues$6 = {
      narrow: {
        am: 'vm.',
        pm: 'nm.',
        midnight: 'Mitternacht',
        noon: 'Mittag',
        morning: 'morgens',
        afternoon: 'nachm.',
        evening: 'abends',
        night: 'nachts'
      },
      abbreviated: {
        am: 'vorm.',
        pm: 'nachm.',
        midnight: 'Mitternacht',
        noon: 'Mittag',
        morning: 'morgens',
        afternoon: 'nachmittags',
        evening: 'abends',
        night: 'nachts'
      },
      wide: {
        am: 'vormittags',
        pm: 'nachmittags',
        midnight: 'Mitternacht',
        noon: 'Mittag',
        morning: 'morgens',
        afternoon: 'nachmittags',
        evening: 'abends',
        night: 'nachts'
      }
    };

    var ordinalNumber$b = function (dirtyNumber) {
      var number = Number(dirtyNumber);
      return number + '.';
    };

    var localize$c = {
      ordinalNumber: ordinalNumber$b,
      era: buildLocalizeFn$1({
        values: eraValues$b,
        defaultWidth: 'wide'
      }),
      quarter: buildLocalizeFn$1({
        values: quarterValues$b,
        defaultWidth: 'wide',
        argumentCallback: function (quarter) {
          return quarter - 1;
        }
      }),
      month: buildLocalizeFn$1({
        values: monthValues$b,
        formattingValues: formattingMonthValues$2,
        defaultWidth: 'wide'
      }),
      day: buildLocalizeFn$1({
        values: dayValues$b,
        defaultWidth: 'wide'
      }),
      dayPeriod: buildLocalizeFn$1({
        values: dayPeriodValues$b,
        defaultWidth: 'wide',
        formattingValues: formattingDayPeriodValues$6,
        defaultFormattingWidth: 'wide'
      })
    };

    var matchOrdinalNumberPattern$b = /^(\d+)(\.)?/i;
    var parseOrdinalNumberPattern$b = /\d+/i;
    var matchEraPatterns$b = {
      narrow: /^(v\.? ?Chr\.?|n\.? ?Chr\.?)/i,
      abbreviated: /^(v\.? ?Chr\.?|n\.? ?Chr\.?)/i,
      wide: /^(vor Christus|vor unserer Zeitrechnung|nach Christus|unserer Zeitrechnung)/i
    };
    var parseEraPatterns$b = {
      any: [/^v/i, /^n/i]
    };
    var matchQuarterPatterns$b = {
      narrow: /^[1234]/i,
      abbreviated: /^q[1234]/i,
      wide: /^[1234](\.)? Quartal/i
    };
    var parseQuarterPatterns$b = {
      any: [/1/i, /2/i, /3/i, /4/i]
    };
    var matchMonthPatterns$b = {
      narrow: /^[jfmasond]/i,
      abbreviated: /^(j[aä]n|feb|mär[z]?|apr|mai|jun[i]?|jul[i]?|aug|sep|okt|nov|dez)\.?/i,
      wide: /^(januar|februar|märz|april|mai|juni|juli|august|september|oktober|november|dezember)/i
    };
    var parseMonthPatterns$b = {
      narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
      any: [/^j[aä]/i, /^f/i, /^mär/i, /^ap/i, /^mai/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
    };
    var matchDayPatterns$b = {
      narrow: /^[smdmf]/i,
      short: /^(so|mo|di|mi|do|fr|sa)/i,
      abbreviated: /^(son?|mon?|die?|mit?|don?|fre?|sam?)\.?/i,
      wide: /^(sonntag|montag|dienstag|mittwoch|donnerstag|freitag|samstag)/i
    };
    var parseDayPatterns$b = {
      any: [/^so/i, /^mo/i, /^di/i, /^mi/i, /^do/i, /^f/i, /^sa/i]
    };
    var matchDayPeriodPatterns$b = {
      narrow: /^(vm\.?|nm\.?|Mitternacht|Mittag|morgens|nachm\.?|abends|nachts)/i,
      abbreviated: /^(vorm\.?|nachm\.?|Mitternacht|Mittag|morgens|nachm\.?|abends|nachts)/i,
      wide: /^(vormittags|nachmittags|Mitternacht|Mittag|morgens|nachmittags|abends|nachts)/i
    };
    var parseDayPeriodPatterns$b = {
      any: {
        am: /^v/i,
        pm: /^n/i,
        midnight: /^Mitte/i,
        noon: /^Mitta/i,
        morning: /morgens/i,
        afternoon: /nachmittags/i,
        // will never be matched. Afternoon is matched by `pm`
        evening: /abends/i,
        night: /nachts/i // will never be matched. Night is matched by `pm`

      }
    };
    var match$c = {
      ordinalNumber: buildMatchPatternFn$1({
        matchPattern: matchOrdinalNumberPattern$b,
        parsePattern: parseOrdinalNumberPattern$b,
        valueCallback: function (value) {
          return parseInt(value);
        }
      }),
      era: buildMatchFn$1({
        matchPatterns: matchEraPatterns$b,
        defaultMatchWidth: 'wide',
        parsePatterns: parseEraPatterns$b,
        defaultParseWidth: 'any'
      }),
      quarter: buildMatchFn$1({
        matchPatterns: matchQuarterPatterns$b,
        defaultMatchWidth: 'wide',
        parsePatterns: parseQuarterPatterns$b,
        defaultParseWidth: 'any',
        valueCallback: function (index) {
          return index + 1;
        }
      }),
      month: buildMatchFn$1({
        matchPatterns: matchMonthPatterns$b,
        defaultMatchWidth: 'wide',
        parsePatterns: parseMonthPatterns$b,
        defaultParseWidth: 'any'
      }),
      day: buildMatchFn$1({
        matchPatterns: matchDayPatterns$b,
        defaultMatchWidth: 'wide',
        parsePatterns: parseDayPatterns$b,
        defaultParseWidth: 'any'
      }),
      dayPeriod: buildMatchFn$1({
        matchPatterns: matchDayPeriodPatterns$b,
        defaultMatchWidth: 'wide',
        parsePatterns: parseDayPeriodPatterns$b,
        defaultParseWidth: 'any'
      })
    };

    /**
     * @type {Locale}
     * @category Locales
     * @summary German locale.
     * @language German
     * @iso-639-2 deu
     * @author Thomas Eilmsteiner [@DeMuu]{@link https://github.com/DeMuu}
     * @author Asia [@asia-t]{@link https://github.com/asia-t}
     * @author Van Vuong Ngo [@vanvuongngo]{@link https://github.com/vanvuongngo}
     * @author RomanErnst [@pex]{@link https://github.com/pex}
     * @author Philipp Keck [@Philipp91]{@link https://github.com/Philipp91}
     */

    var locale$c = {
      code: 'de',
      formatDistance: formatDistance$c,
      formatLong: formatLong$d,
      formatRelative: formatRelative$c,
      localize: localize$c,
      match: match$c,
      options: {
        weekStartsOn: 1
        /* Monday */
        ,
        firstWeekContainsDate: 4
      }
    };

    const dateDeDE = {
      name: "de-DE",
      locale: locale$c
    };
    var dateDeDE$1 = dateDeDE;

    var formatDistanceLocale$a = {
      lessThanXSeconds: {
        one: 'mindre enn ett sekund',
        other: 'mindre enn {{count}} sekunder'
      },
      xSeconds: {
        one: 'ett sekund',
        other: '{{count}} sekunder'
      },
      halfAMinute: 'et halvt minutt',
      lessThanXMinutes: {
        one: 'mindre enn ett minutt',
        other: 'mindre enn {{count}} minutter'
      },
      xMinutes: {
        one: 'ett minutt',
        other: '{{count}} minutter'
      },
      aboutXHours: {
        one: 'omtrent en time',
        other: 'omtrent {{count}} timer'
      },
      xHours: {
        one: 'en time',
        other: '{{count}} timer'
      },
      xDays: {
        one: 'en dag',
        other: '{{count}} dager'
      },
      aboutXWeeks: {
        one: 'omtrent en uke',
        other: 'omtrent {{count}} uker'
      },
      xWeeks: {
        one: 'en uke',
        other: '{{count}} uker'
      },
      aboutXMonths: {
        one: 'omtrent en måned',
        other: 'omtrent {{count}} måneder'
      },
      xMonths: {
        one: 'en måned',
        other: '{{count}} måneder'
      },
      aboutXYears: {
        one: 'omtrent ett år',
        other: 'omtrent {{count}} år'
      },
      xYears: {
        one: 'ett år',
        other: '{{count}} år'
      },
      overXYears: {
        one: 'over ett år',
        other: 'over {{count}} år'
      },
      almostXYears: {
        one: 'nesten ett år',
        other: 'nesten {{count}} år'
      }
    };

    var formatDistance$b = function (token, count, options) {
      var result;
      var tokenValue = formatDistanceLocale$a[token];

      if (typeof tokenValue === 'string') {
        result = tokenValue;
      } else if (count === 1) {
        result = tokenValue.one;
      } else {
        result = tokenValue.other.replace('{{count}}', String(count));
      }

      if (options !== null && options !== void 0 && options.addSuffix) {
        if (options.comparison && options.comparison > 0) {
          return 'om ' + result;
        } else {
          return result + ' siden';
        }
      }

      return result;
    };

    var dateFormats$b = {
      full: 'EEEE d. MMMM y',
      long: 'd. MMMM y',
      medium: 'd. MMM y',
      short: 'dd.MM.y'
    };
    var timeFormats$b = {
      full: "'kl'. HH:mm:ss zzzz",
      long: 'HH:mm:ss z',
      medium: 'HH:mm:ss',
      short: 'HH:mm'
    };
    var dateTimeFormats$b = {
      full: "{{date}} 'kl.' {{time}}",
      long: "{{date}} 'kl.' {{time}}",
      medium: '{{date}} {{time}}',
      short: '{{date}} {{time}}'
    };
    var formatLong$c = {
      date: buildFormatLongFn$1({
        formats: dateFormats$b,
        defaultWidth: 'full'
      }),
      time: buildFormatLongFn$1({
        formats: timeFormats$b,
        defaultWidth: 'full'
      }),
      dateTime: buildFormatLongFn$1({
        formats: dateTimeFormats$b,
        defaultWidth: 'full'
      })
    };

    var formatRelativeLocale$a = {
      lastWeek: "'forrige' eeee 'kl.' p",
      yesterday: "'i går kl.' p",
      today: "'i dag kl.' p",
      tomorrow: "'i morgen kl.' p",
      nextWeek: "EEEE 'kl.' p",
      other: 'P'
    };

    var formatRelative$b = function (token, _date, _baseDate, _options) {
      return formatRelativeLocale$a[token];
    };

    var eraValues$a = {
      narrow: ['f.Kr.', 'e.Kr.'],
      abbreviated: ['f.Kr.', 'e.Kr.'],
      wide: ['før Kristus', 'etter Kristus']
    };
    var quarterValues$a = {
      narrow: ['1', '2', '3', '4'],
      abbreviated: ['Q1', 'Q2', 'Q3', 'Q4'],
      wide: ['1. kvartal', '2. kvartal', '3. kvartal', '4. kvartal']
    };
    var monthValues$a = {
      narrow: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
      abbreviated: ['jan.', 'feb.', 'mars', 'apr.', 'mai', 'juni', 'juli', 'aug.', 'sep.', 'okt.', 'nov.', 'des.'],
      wide: ['januar', 'februar', 'mars', 'april', 'mai', 'juni', 'juli', 'august', 'september', 'oktober', 'november', 'desember']
    };
    var dayValues$a = {
      narrow: ['S', 'M', 'T', 'O', 'T', 'F', 'L'],
      short: ['sø', 'ma', 'ti', 'on', 'to', 'fr', 'lø'],
      abbreviated: ['søn', 'man', 'tir', 'ons', 'tor', 'fre', 'lør'],
      wide: ['søndag', 'mandag', 'tirsdag', 'onsdag', 'torsdag', 'fredag', 'lørdag']
    };
    var dayPeriodValues$a = {
      narrow: {
        am: 'a',
        pm: 'p',
        midnight: 'midnatt',
        noon: 'middag',
        morning: 'på morg.',
        afternoon: 'på etterm.',
        evening: 'på kvelden',
        night: 'på natten'
      },
      abbreviated: {
        am: 'a.m.',
        pm: 'p.m.',
        midnight: 'midnatt',
        noon: 'middag',
        morning: 'på morg.',
        afternoon: 'på etterm.',
        evening: 'på kvelden',
        night: 'på natten'
      },
      wide: {
        am: 'a.m.',
        pm: 'p.m.',
        midnight: 'midnatt',
        noon: 'middag',
        morning: 'på morgenen',
        afternoon: 'på ettermiddagen',
        evening: 'på kvelden',
        night: 'på natten'
      }
    };

    var ordinalNumber$a = function (dirtyNumber, _options) {
      var number = Number(dirtyNumber);
      return number + '.';
    };

    var localize$b = {
      ordinalNumber: ordinalNumber$a,
      era: buildLocalizeFn$1({
        values: eraValues$a,
        defaultWidth: 'wide'
      }),
      quarter: buildLocalizeFn$1({
        values: quarterValues$a,
        defaultWidth: 'wide',
        argumentCallback: function (quarter) {
          return quarter - 1;
        }
      }),
      month: buildLocalizeFn$1({
        values: monthValues$a,
        defaultWidth: 'wide'
      }),
      day: buildLocalizeFn$1({
        values: dayValues$a,
        defaultWidth: 'wide'
      }),
      dayPeriod: buildLocalizeFn$1({
        values: dayPeriodValues$a,
        defaultWidth: 'wide'
      })
    };

    var matchOrdinalNumberPattern$a = /^(\d+)\.?/i;
    var parseOrdinalNumberPattern$a = /\d+/i;
    var matchEraPatterns$a = {
      narrow: /^(f\.? ?Kr\.?|fvt\.?|e\.? ?Kr\.?|evt\.?)/i,
      abbreviated: /^(f\.? ?Kr\.?|fvt\.?|e\.? ?Kr\.?|evt\.?)/i,
      wide: /^(før Kristus|før vår tid|etter Kristus|vår tid)/i
    };
    var parseEraPatterns$a = {
      any: [/^f/i, /^e/i]
    };
    var matchQuarterPatterns$a = {
      narrow: /^[1234]/i,
      abbreviated: /^q[1234]/i,
      wide: /^[1234](\.)? kvartal/i
    };
    var parseQuarterPatterns$a = {
      any: [/1/i, /2/i, /3/i, /4/i]
    };
    var matchMonthPatterns$a = {
      narrow: /^[jfmasond]/i,
      abbreviated: /^(jan|feb|mars?|apr|mai|juni?|juli?|aug|sep|okt|nov|des)\.?/i,
      wide: /^(januar|februar|mars|april|mai|juni|juli|august|september|oktober|november|desember)/i
    };
    var parseMonthPatterns$a = {
      narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
      any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^mai/i, /^jun/i, /^jul/i, /^aug/i, /^s/i, /^o/i, /^n/i, /^d/i]
    };
    var matchDayPatterns$a = {
      narrow: /^[smtofl]/i,
      short: /^(sø|ma|ti|on|to|fr|lø)/i,
      abbreviated: /^(søn|man|tir|ons|tor|fre|lør)/i,
      wide: /^(søndag|mandag|tirsdag|onsdag|torsdag|fredag|lørdag)/i
    };
    var parseDayPatterns$a = {
      any: [/^s/i, /^m/i, /^ti/i, /^o/i, /^to/i, /^f/i, /^l/i]
    };
    var matchDayPeriodPatterns$a = {
      narrow: /^(midnatt|middag|(på) (morgenen|ettermiddagen|kvelden|natten)|[ap])/i,
      any: /^([ap]\.?\s?m\.?|midnatt|middag|(på) (morgenen|ettermiddagen|kvelden|natten))/i
    };
    var parseDayPeriodPatterns$a = {
      any: {
        am: /^a(\.?\s?m\.?)?$/i,
        pm: /^p(\.?\s?m\.?)?$/i,
        midnight: /^midn/i,
        noon: /^midd/i,
        morning: /morgen/i,
        afternoon: /ettermiddag/i,
        evening: /kveld/i,
        night: /natt/i
      }
    };
    var match$b = {
      ordinalNumber: buildMatchPatternFn$1({
        matchPattern: matchOrdinalNumberPattern$a,
        parsePattern: parseOrdinalNumberPattern$a,
        valueCallback: function (value) {
          return parseInt(value, 10);
        }
      }),
      era: buildMatchFn$1({
        matchPatterns: matchEraPatterns$a,
        defaultMatchWidth: 'wide',
        parsePatterns: parseEraPatterns$a,
        defaultParseWidth: 'any'
      }),
      quarter: buildMatchFn$1({
        matchPatterns: matchQuarterPatterns$a,
        defaultMatchWidth: 'wide',
        parsePatterns: parseQuarterPatterns$a,
        defaultParseWidth: 'any',
        valueCallback: function (index) {
          return index + 1;
        }
      }),
      month: buildMatchFn$1({
        matchPatterns: matchMonthPatterns$a,
        defaultMatchWidth: 'wide',
        parsePatterns: parseMonthPatterns$a,
        defaultParseWidth: 'any'
      }),
      day: buildMatchFn$1({
        matchPatterns: matchDayPatterns$a,
        defaultMatchWidth: 'wide',
        parsePatterns: parseDayPatterns$a,
        defaultParseWidth: 'any'
      }),
      dayPeriod: buildMatchFn$1({
        matchPatterns: matchDayPeriodPatterns$a,
        defaultMatchWidth: 'any',
        parsePatterns: parseDayPeriodPatterns$a,
        defaultParseWidth: 'any'
      })
    };

    /**
     * @type {Locale}
     * @category Locales
     * @summary Norwegian Bokmål locale.
     * @language Norwegian Bokmål
     * @iso-639-2 nob
     * @author Hans-Kristian Koren [@Hanse]{@link https://github.com/Hanse}
     * @author Mikolaj Grzyb [@mikolajgrzyb]{@link https://github.com/mikolajgrzyb}
     * @author Dag Stuan [@dagstuan]{@link https://github.com/dagstuan}
     */

    var locale$b = {
      code: 'nb',
      formatDistance: formatDistance$b,
      formatLong: formatLong$c,
      formatRelative: formatRelative$b,
      localize: localize$b,
      match: match$b,
      options: {
        weekStartsOn: 1
        /* Monday */
        ,
        firstWeekContainsDate: 4
      }
    };

    const dateNbNO = {
      name: "nb-NO",
      locale: locale$b
    };
    var dateNbNO$1 = dateNbNO;

    var formatDistanceLocale$9 = {
      lessThanXSeconds: {
        one: 'minder dan een seconde',
        other: 'minder dan {{count}} seconden'
      },
      xSeconds: {
        one: '1 seconde',
        other: '{{count}} seconden'
      },
      halfAMinute: 'een halve minuut',
      lessThanXMinutes: {
        one: 'minder dan een minuut',
        other: 'minder dan {{count}} minuten'
      },
      xMinutes: {
        one: 'een minuut',
        other: '{{count}} minuten'
      },
      aboutXHours: {
        one: 'ongeveer 1 uur',
        other: 'ongeveer {{count}} uur'
      },
      xHours: {
        one: '1 uur',
        other: '{{count}} uur'
      },
      xDays: {
        one: '1 dag',
        other: '{{count}} dagen'
      },
      aboutXWeeks: {
        one: 'ongeveer 1 week',
        other: 'ongeveer {{count}} weken'
      },
      xWeeks: {
        one: '1 week',
        other: '{{count}} weken'
      },
      aboutXMonths: {
        one: 'ongeveer 1 maand',
        other: 'ongeveer {{count}} maanden'
      },
      xMonths: {
        one: '1 maand',
        other: '{{count}} maanden'
      },
      aboutXYears: {
        one: 'ongeveer 1 jaar',
        other: 'ongeveer {{count}} jaar'
      },
      xYears: {
        one: '1 jaar',
        other: '{{count}} jaar'
      },
      overXYears: {
        one: 'meer dan 1 jaar',
        other: 'meer dan {{count}} jaar'
      },
      almostXYears: {
        one: 'bijna 1 jaar',
        other: 'bijna {{count}} jaar'
      }
    };

    var formatDistance$a = function (token, count, options) {
      var result;
      var tokenValue = formatDistanceLocale$9[token];

      if (typeof tokenValue === 'string') {
        result = tokenValue;
      } else if (count === 1) {
        result = tokenValue.one;
      } else {
        result = tokenValue.other.replace('{{count}}', String(count));
      }

      if (options !== null && options !== void 0 && options.addSuffix) {
        if (options.comparison && options.comparison > 0) {
          return 'over ' + result;
        } else {
          return result + ' geleden';
        }
      }

      return result;
    };

    var dateFormats$a = {
      full: 'EEEE d MMMM y',
      long: 'd MMMM y',
      medium: 'd MMM y',
      short: 'dd-MM-y'
    };
    var timeFormats$a = {
      full: 'HH:mm:ss zzzz',
      long: 'HH:mm:ss z',
      medium: 'HH:mm:ss',
      short: 'HH:mm'
    };
    var dateTimeFormats$a = {
      full: "{{date}} 'om' {{time}}",
      long: "{{date}} 'om' {{time}}",
      medium: '{{date}}, {{time}}',
      short: '{{date}}, {{time}}'
    };
    var formatLong$b = {
      date: buildFormatLongFn$1({
        formats: dateFormats$a,
        defaultWidth: 'full'
      }),
      time: buildFormatLongFn$1({
        formats: timeFormats$a,
        defaultWidth: 'full'
      }),
      dateTime: buildFormatLongFn$1({
        formats: dateTimeFormats$a,
        defaultWidth: 'full'
      })
    };

    var formatRelativeLocale$9 = {
      lastWeek: "'afgelopen' eeee 'om' p",
      yesterday: "'gisteren om' p",
      today: "'vandaag om' p",
      tomorrow: "'morgen om' p",
      nextWeek: "eeee 'om' p",
      other: 'P'
    };

    var formatRelative$a = function (token, _date, _baseDate, _options) {
      return formatRelativeLocale$9[token];
    };

    var eraValues$9 = {
      narrow: ['v.C.', 'n.C.'],
      abbreviated: ['v.Chr.', 'n.Chr.'],
      wide: ['voor Christus', 'na Christus']
    };
    var quarterValues$9 = {
      narrow: ['1', '2', '3', '4'],
      abbreviated: ['K1', 'K2', 'K3', 'K4'],
      wide: ['1e kwartaal', '2e kwartaal', '3e kwartaal', '4e kwartaal']
    };
    var monthValues$9 = {
      narrow: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
      abbreviated: ['jan.', 'feb.', 'mrt.', 'apr.', 'mei', 'jun.', 'jul.', 'aug.', 'sep.', 'okt.', 'nov.', 'dec.'],
      wide: ['januari', 'februari', 'maart', 'april', 'mei', 'juni', 'juli', 'augustus', 'september', 'oktober', 'november', 'december']
    };
    var dayValues$9 = {
      narrow: ['Z', 'M', 'D', 'W', 'D', 'V', 'Z'],
      short: ['zo', 'ma', 'di', 'wo', 'do', 'vr', 'za'],
      abbreviated: ['zon', 'maa', 'din', 'woe', 'don', 'vri', 'zat'],
      wide: ['zondag', 'maandag', 'dinsdag', 'woensdag', 'donderdag', 'vrijdag', 'zaterdag']
    };
    var dayPeriodValues$9 = {
      narrow: {
        am: 'AM',
        pm: 'PM',
        midnight: 'middernacht',
        noon: 'het middaguur',
        morning: "'s ochtends",
        afternoon: "'s middags",
        evening: "'s avonds",
        night: "'s nachts"
      },
      abbreviated: {
        am: 'AM',
        pm: 'PM',
        midnight: 'middernacht',
        noon: 'het middaguur',
        morning: "'s ochtends",
        afternoon: "'s middags",
        evening: "'s avonds",
        night: "'s nachts"
      },
      wide: {
        am: 'AM',
        pm: 'PM',
        midnight: 'middernacht',
        noon: 'het middaguur',
        morning: "'s ochtends",
        afternoon: "'s middags",
        evening: "'s avonds",
        night: "'s nachts"
      }
    };

    var ordinalNumber$9 = function (dirtyNumber, _options) {
      var number = Number(dirtyNumber);
      return number + 'e';
    };

    var localize$a = {
      ordinalNumber: ordinalNumber$9,
      era: buildLocalizeFn$1({
        values: eraValues$9,
        defaultWidth: 'wide'
      }),
      quarter: buildLocalizeFn$1({
        values: quarterValues$9,
        defaultWidth: 'wide',
        argumentCallback: function (quarter) {
          return quarter - 1;
        }
      }),
      month: buildLocalizeFn$1({
        values: monthValues$9,
        defaultWidth: 'wide'
      }),
      day: buildLocalizeFn$1({
        values: dayValues$9,
        defaultWidth: 'wide'
      }),
      dayPeriod: buildLocalizeFn$1({
        values: dayPeriodValues$9,
        defaultWidth: 'wide'
      })
    };

    var matchOrdinalNumberPattern$9 = /^(\d+)e?/i;
    var parseOrdinalNumberPattern$9 = /\d+/i;
    var matchEraPatterns$9 = {
      narrow: /^([vn]\.? ?C\.?)/,
      abbreviated: /^([vn]\. ?Chr\.?)/,
      wide: /^((voor|na) Christus)/
    };
    var parseEraPatterns$9 = {
      any: [/^v/, /^n/]
    };
    var matchQuarterPatterns$9 = {
      narrow: /^[1234]/i,
      abbreviated: /^K[1234]/i,
      wide: /^[1234]e kwartaal/i
    };
    var parseQuarterPatterns$9 = {
      any: [/1/i, /2/i, /3/i, /4/i]
    };
    var matchMonthPatterns$9 = {
      narrow: /^[jfmasond]/i,
      abbreviated: /^(jan.|feb.|mrt.|apr.|mei|jun.|jul.|aug.|sep.|okt.|nov.|dec.)/i,
      wide: /^(januari|februari|maart|april|mei|juni|juli|augustus|september|oktober|november|december)/i
    };
    var parseMonthPatterns$9 = {
      narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
      any: [/^jan/i, /^feb/i, /^m(r|a)/i, /^apr/i, /^mei/i, /^jun/i, /^jul/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i]
    };
    var matchDayPatterns$9 = {
      narrow: /^[zmdwv]/i,
      short: /^(zo|ma|di|wo|do|vr|za)/i,
      abbreviated: /^(zon|maa|din|woe|don|vri|zat)/i,
      wide: /^(zondag|maandag|dinsdag|woensdag|donderdag|vrijdag|zaterdag)/i
    };
    var parseDayPatterns$9 = {
      narrow: [/^z/i, /^m/i, /^d/i, /^w/i, /^d/i, /^v/i, /^z/i],
      any: [/^zo/i, /^ma/i, /^di/i, /^wo/i, /^do/i, /^vr/i, /^za/i]
    };
    var matchDayPeriodPatterns$9 = {
      any: /^(am|pm|middernacht|het middaguur|'s (ochtends|middags|avonds|nachts))/i
    };
    var parseDayPeriodPatterns$9 = {
      any: {
        am: /^am/i,
        pm: /^pm/i,
        midnight: /^middernacht/i,
        noon: /^het middaguur/i,
        morning: /ochtend/i,
        afternoon: /middag/i,
        evening: /avond/i,
        night: /nacht/i
      }
    };
    var match$a = {
      ordinalNumber: buildMatchPatternFn$1({
        matchPattern: matchOrdinalNumberPattern$9,
        parsePattern: parseOrdinalNumberPattern$9,
        valueCallback: function (value) {
          return parseInt(value, 10);
        }
      }),
      era: buildMatchFn$1({
        matchPatterns: matchEraPatterns$9,
        defaultMatchWidth: 'wide',
        parsePatterns: parseEraPatterns$9,
        defaultParseWidth: 'any'
      }),
      quarter: buildMatchFn$1({
        matchPatterns: matchQuarterPatterns$9,
        defaultMatchWidth: 'wide',
        parsePatterns: parseQuarterPatterns$9,
        defaultParseWidth: 'any',
        valueCallback: function (index) {
          return index + 1;
        }
      }),
      month: buildMatchFn$1({
        matchPatterns: matchMonthPatterns$9,
        defaultMatchWidth: 'wide',
        parsePatterns: parseMonthPatterns$9,
        defaultParseWidth: 'any'
      }),
      day: buildMatchFn$1({
        matchPatterns: matchDayPatterns$9,
        defaultMatchWidth: 'wide',
        parsePatterns: parseDayPatterns$9,
        defaultParseWidth: 'any'
      }),
      dayPeriod: buildMatchFn$1({
        matchPatterns: matchDayPeriodPatterns$9,
        defaultMatchWidth: 'any',
        parsePatterns: parseDayPeriodPatterns$9,
        defaultParseWidth: 'any'
      })
    };

    /**
     * @type {Locale}
     * @category Locales
     * @summary Dutch locale.
     * @language Dutch
     * @iso-639-2 nld
     * @author Jorik Tangelder [@jtangelder]{@link https://github.com/jtangelder}
     * @author Ruben Stolk [@rubenstolk]{@link https://github.com/rubenstolk}
     * @author Lode Vanhove [@bitcrumb]{@link https://github.com/bitcrumb}
     * @author Edo Rivai [@edorivai]{@link https://github.com/edorivai}
     * @author Niels Keurentjes [@curry684]{@link https://github.com/curry684}
     * @author Stefan Vermaas [@stefanvermaas]{@link https://github.com/stefanvermaas}
     */

    var locale$a = {
      code: 'nl',
      formatDistance: formatDistance$a,
      formatLong: formatLong$b,
      formatRelative: formatRelative$a,
      localize: localize$a,
      match: match$a,
      options: {
        weekStartsOn: 1
        /* Monday */
        ,
        firstWeekContainsDate: 4
      }
    };

    const dateNlNL = {
      name: "nl-NL",
      locale: locale$a
    };
    var dateNlNL$1 = dateNlNL;

    var formatDistanceLocale$8 = {
      lessThanXSeconds: {
        one: 'moins d’une seconde',
        other: 'moins de {{count}} secondes'
      },
      xSeconds: {
        one: '1 seconde',
        other: '{{count}} secondes'
      },
      halfAMinute: '30 secondes',
      lessThanXMinutes: {
        one: 'moins d’une minute',
        other: 'moins de {{count}} minutes'
      },
      xMinutes: {
        one: '1 minute',
        other: '{{count}} minutes'
      },
      aboutXHours: {
        one: 'environ 1 heure',
        other: 'environ {{count}} heures'
      },
      xHours: {
        one: '1 heure',
        other: '{{count}} heures'
      },
      xDays: {
        one: '1 jour',
        other: '{{count}} jours'
      },
      aboutXWeeks: {
        one: 'environ 1 semaine',
        other: 'environ {{count}} semaines'
      },
      xWeeks: {
        one: '1 semaine',
        other: '{{count}} semaines'
      },
      aboutXMonths: {
        one: 'environ 1 mois',
        other: 'environ {{count}} mois'
      },
      xMonths: {
        one: '1 mois',
        other: '{{count}} mois'
      },
      aboutXYears: {
        one: 'environ 1 an',
        other: 'environ {{count}} ans'
      },
      xYears: {
        one: '1 an',
        other: '{{count}} ans'
      },
      overXYears: {
        one: 'plus d’un an',
        other: 'plus de {{count}} ans'
      },
      almostXYears: {
        one: 'presqu’un an',
        other: 'presque {{count}} ans'
      }
    };

    var formatDistance$9 = function (token, count, options) {
      var result;
      var form = formatDistanceLocale$8[token];

      if (typeof form === 'string') {
        result = form;
      } else if (count === 1) {
        result = form.one;
      } else {
        result = form.other.replace('{{count}}', String(count));
      }

      if (options !== null && options !== void 0 && options.addSuffix) {
        if (options.comparison && options.comparison > 0) {
          return 'dans ' + result;
        } else {
          return 'il y a ' + result;
        }
      }

      return result;
    };

    var dateFormats$9 = {
      full: 'EEEE d MMMM y',
      long: 'd MMMM y',
      medium: 'd MMM y',
      short: 'dd/MM/y'
    };
    var timeFormats$9 = {
      full: 'HH:mm:ss zzzz',
      long: 'HH:mm:ss z',
      medium: 'HH:mm:ss',
      short: 'HH:mm'
    };
    var dateTimeFormats$9 = {
      full: "{{date}} 'à' {{time}}",
      long: "{{date}} 'à' {{time}}",
      medium: '{{date}}, {{time}}',
      short: '{{date}}, {{time}}'
    };
    var formatLong$a = {
      date: buildFormatLongFn$1({
        formats: dateFormats$9,
        defaultWidth: 'full'
      }),
      time: buildFormatLongFn$1({
        formats: timeFormats$9,
        defaultWidth: 'full'
      }),
      dateTime: buildFormatLongFn$1({
        formats: dateTimeFormats$9,
        defaultWidth: 'full'
      })
    };

    var formatRelativeLocale$8 = {
      lastWeek: "eeee 'dernier à' p",
      yesterday: "'hier à' p",
      today: "'aujourd’hui à' p",
      tomorrow: "'demain à' p'",
      nextWeek: "eeee 'prochain à' p",
      other: 'P'
    };

    var formatRelative$9 = function (token, _date, _baseDate, _options) {
      return formatRelativeLocale$8[token];
    };

    var eraValues$8 = {
      narrow: ['av. J.-C', 'ap. J.-C'],
      abbreviated: ['av. J.-C', 'ap. J.-C'],
      wide: ['avant Jésus-Christ', 'après Jésus-Christ']
    };
    var quarterValues$8 = {
      narrow: ['T1', 'T2', 'T3', 'T4'],
      abbreviated: ['1er trim.', '2ème trim.', '3ème trim.', '4ème trim.'],
      wide: ['1er trimestre', '2ème trimestre', '3ème trimestre', '4ème trimestre']
    };
    var monthValues$8 = {
      narrow: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
      abbreviated: ['janv.', 'févr.', 'mars', 'avr.', 'mai', 'juin', 'juil.', 'août', 'sept.', 'oct.', 'nov.', 'déc.'],
      wide: ['janvier', 'février', 'mars', 'avril', 'mai', 'juin', 'juillet', 'août', 'septembre', 'octobre', 'novembre', 'décembre']
    };
    var dayValues$8 = {
      narrow: ['D', 'L', 'M', 'M', 'J', 'V', 'S'],
      short: ['di', 'lu', 'ma', 'me', 'je', 've', 'sa'],
      abbreviated: ['dim.', 'lun.', 'mar.', 'mer.', 'jeu.', 'ven.', 'sam.'],
      wide: ['dimanche', 'lundi', 'mardi', 'mercredi', 'jeudi', 'vendredi', 'samedi']
    };
    var dayPeriodValues$8 = {
      narrow: {
        am: 'AM',
        pm: 'PM',
        midnight: 'minuit',
        noon: 'midi',
        morning: 'mat.',
        afternoon: 'ap.m.',
        evening: 'soir',
        night: 'mat.'
      },
      abbreviated: {
        am: 'AM',
        pm: 'PM',
        midnight: 'minuit',
        noon: 'midi',
        morning: 'matin',
        afternoon: 'après-midi',
        evening: 'soir',
        night: 'matin'
      },
      wide: {
        am: 'AM',
        pm: 'PM',
        midnight: 'minuit',
        noon: 'midi',
        morning: 'du matin',
        afternoon: 'de l’après-midi',
        evening: 'du soir',
        night: 'du matin'
      }
    };

    var ordinalNumber$8 = function (dirtyNumber, options) {
      var number = Number(dirtyNumber);
      var unit = options === null || options === void 0 ? void 0 : options.unit;
      if (number === 0) return '0';
      var feminineUnits = ['year', 'week', 'hour', 'minute', 'second'];
      var suffix;

      if (number === 1) {
        suffix = unit && feminineUnits.includes(unit) ? 'ère' : 'er';
      } else {
        suffix = 'ème';
      }

      return number + suffix;
    };

    var localize$9 = {
      ordinalNumber: ordinalNumber$8,
      era: buildLocalizeFn$1({
        values: eraValues$8,
        defaultWidth: 'wide'
      }),
      quarter: buildLocalizeFn$1({
        values: quarterValues$8,
        defaultWidth: 'wide',
        argumentCallback: function (quarter) {
          return quarter - 1;
        }
      }),
      month: buildLocalizeFn$1({
        values: monthValues$8,
        defaultWidth: 'wide'
      }),
      day: buildLocalizeFn$1({
        values: dayValues$8,
        defaultWidth: 'wide'
      }),
      dayPeriod: buildLocalizeFn$1({
        values: dayPeriodValues$8,
        defaultWidth: 'wide'
      })
    };

    var matchOrdinalNumberPattern$8 = /^(\d+)(ième|ère|ème|er|e)?/i;
    var parseOrdinalNumberPattern$8 = /\d+/i;
    var matchEraPatterns$8 = {
      narrow: /^(av\.J\.C|ap\.J\.C|ap\.J\.-C)/i,
      abbreviated: /^(av\.J\.-C|av\.J-C|apr\.J\.-C|apr\.J-C|ap\.J-C)/i,
      wide: /^(avant Jésus-Christ|après Jésus-Christ)/i
    };
    var parseEraPatterns$8 = {
      any: [/^av/i, /^ap/i]
    };
    var matchQuarterPatterns$8 = {
      narrow: /^T?[1234]/i,
      abbreviated: /^[1234](er|ème|e)? trim\.?/i,
      wide: /^[1234](er|ème|e)? trimestre/i
    };
    var parseQuarterPatterns$8 = {
      any: [/1/i, /2/i, /3/i, /4/i]
    };
    var matchMonthPatterns$8 = {
      narrow: /^[jfmasond]/i,
      abbreviated: /^(janv|févr|mars|avr|mai|juin|juill|juil|août|sept|oct|nov|déc)\.?/i,
      wide: /^(janvier|février|mars|avril|mai|juin|juillet|août|septembre|octobre|novembre|décembre)/i
    };
    var parseMonthPatterns$8 = {
      narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
      any: [/^ja/i, /^f/i, /^mar/i, /^av/i, /^ma/i, /^juin/i, /^juil/i, /^ao/i, /^s/i, /^o/i, /^n/i, /^d/i]
    };
    var matchDayPatterns$8 = {
      narrow: /^[lmjvsd]/i,
      short: /^(di|lu|ma|me|je|ve|sa)/i,
      abbreviated: /^(dim|lun|mar|mer|jeu|ven|sam)\.?/i,
      wide: /^(dimanche|lundi|mardi|mercredi|jeudi|vendredi|samedi)/i
    };
    var parseDayPatterns$8 = {
      narrow: [/^d/i, /^l/i, /^m/i, /^m/i, /^j/i, /^v/i, /^s/i],
      any: [/^di/i, /^lu/i, /^ma/i, /^me/i, /^je/i, /^ve/i, /^sa/i]
    };
    var matchDayPeriodPatterns$8 = {
      narrow: /^(a|p|minuit|midi|mat\.?|ap\.?m\.?|soir|nuit)/i,
      any: /^([ap]\.?\s?m\.?|du matin|de l'après[-\s]midi|du soir|de la nuit)/i
    };
    var parseDayPeriodPatterns$8 = {
      any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^min/i,
        noon: /^mid/i,
        morning: /mat/i,
        afternoon: /ap/i,
        evening: /soir/i,
        night: /nuit/i
      }
    };
    var match$9 = {
      ordinalNumber: buildMatchPatternFn$1({
        matchPattern: matchOrdinalNumberPattern$8,
        parsePattern: parseOrdinalNumberPattern$8,
        valueCallback: function (value) {
          return parseInt(value);
        }
      }),
      era: buildMatchFn$1({
        matchPatterns: matchEraPatterns$8,
        defaultMatchWidth: 'wide',
        parsePatterns: parseEraPatterns$8,
        defaultParseWidth: 'any'
      }),
      quarter: buildMatchFn$1({
        matchPatterns: matchQuarterPatterns$8,
        defaultMatchWidth: 'wide',
        parsePatterns: parseQuarterPatterns$8,
        defaultParseWidth: 'any',
        valueCallback: function (index) {
          return index + 1;
        }
      }),
      month: buildMatchFn$1({
        matchPatterns: matchMonthPatterns$8,
        defaultMatchWidth: 'wide',
        parsePatterns: parseMonthPatterns$8,
        defaultParseWidth: 'any'
      }),
      day: buildMatchFn$1({
        matchPatterns: matchDayPatterns$8,
        defaultMatchWidth: 'wide',
        parsePatterns: parseDayPatterns$8,
        defaultParseWidth: 'any'
      }),
      dayPeriod: buildMatchFn$1({
        matchPatterns: matchDayPeriodPatterns$8,
        defaultMatchWidth: 'any',
        parsePatterns: parseDayPeriodPatterns$8,
        defaultParseWidth: 'any'
      })
    };

    /**
     * @type {Locale}
     * @category Locales
     * @summary French locale.
     * @language French
     * @iso-639-2 fra
     * @author Jean Dupouy [@izeau]{@link https://github.com/izeau}
     * @author François B [@fbonzon]{@link https://github.com/fbonzon}
     */

    var locale$9 = {
      code: 'fr',
      formatDistance: formatDistance$9,
      formatLong: formatLong$a,
      formatRelative: formatRelative$9,
      localize: localize$9,
      match: match$9,
      options: {
        weekStartsOn: 1
        /* Monday */
        ,
        firstWeekContainsDate: 4
      }
    };

    const dateFrFR = {
      name: "fr-FR",
      locale: locale$9
    };
    var dateFrFR$1 = dateFrFR;

    var formatDistanceLocale$7 = {
      lessThanXSeconds: {
        one: 'menos de un segundo',
        other: 'menos de {{count}} segundos'
      },
      xSeconds: {
        one: '1 segundo',
        other: '{{count}} segundos'
      },
      halfAMinute: 'medio minuto',
      lessThanXMinutes: {
        one: 'menos de un minuto',
        other: 'menos de {{count}} minutos'
      },
      xMinutes: {
        one: '1 minuto',
        other: '{{count}} minutos'
      },
      aboutXHours: {
        one: 'alrededor de 1 hora',
        other: 'alrededor de {{count}} horas'
      },
      xHours: {
        one: '1 hora',
        other: '{{count}} horas'
      },
      xDays: {
        one: '1 día',
        other: '{{count}} días'
      },
      aboutXWeeks: {
        one: 'alrededor de 1 semana',
        other: 'alrededor de {{count}} semanas'
      },
      xWeeks: {
        one: '1 semana',
        other: '{{count}} semanas'
      },
      aboutXMonths: {
        one: 'alrededor de 1 mes',
        other: 'alrededor de {{count}} meses'
      },
      xMonths: {
        one: '1 mes',
        other: '{{count}} meses'
      },
      aboutXYears: {
        one: 'alrededor de 1 año',
        other: 'alrededor de {{count}} años'
      },
      xYears: {
        one: '1 año',
        other: '{{count}} años'
      },
      overXYears: {
        one: 'más de 1 año',
        other: 'más de {{count}} años'
      },
      almostXYears: {
        one: 'casi 1 año',
        other: 'casi {{count}} años'
      }
    };

    var formatDistance$8 = function (token, count, options) {
      var result;
      var tokenValue = formatDistanceLocale$7[token];

      if (typeof tokenValue === 'string') {
        result = tokenValue;
      } else if (count === 1) {
        result = tokenValue.one;
      } else {
        result = tokenValue.other.replace('{{count}}', count.toString());
      }

      if (options !== null && options !== void 0 && options.addSuffix) {
        if (options.comparison && options.comparison > 0) {
          return 'en ' + result;
        } else {
          return 'hace ' + result;
        }
      }

      return result;
    };

    var dateFormats$8 = {
      full: "EEEE, d 'de' MMMM 'de' y",
      long: "d 'de' MMMM 'de' y",
      medium: 'd MMM y',
      short: 'dd/MM/y'
    };
    var timeFormats$8 = {
      full: 'HH:mm:ss zzzz',
      long: 'HH:mm:ss z',
      medium: 'HH:mm:ss',
      short: 'HH:mm'
    };
    var dateTimeFormats$8 = {
      full: "{{date}} 'a las' {{time}}",
      long: "{{date}} 'a las' {{time}}",
      medium: '{{date}}, {{time}}',
      short: '{{date}}, {{time}}'
    };
    var formatLong$9 = {
      date: buildFormatLongFn$1({
        formats: dateFormats$8,
        defaultWidth: 'full'
      }),
      time: buildFormatLongFn$1({
        formats: timeFormats$8,
        defaultWidth: 'full'
      }),
      dateTime: buildFormatLongFn$1({
        formats: dateTimeFormats$8,
        defaultWidth: 'full'
      })
    };

    var formatRelativeLocale$7 = {
      lastWeek: "'el' eeee 'pasado a la' p",
      yesterday: "'ayer a la' p",
      today: "'hoy a la' p",
      tomorrow: "'mañana a la' p",
      nextWeek: "eeee 'a la' p",
      other: 'P'
    };
    var formatRelativeLocalePlural = {
      lastWeek: "'el' eeee 'pasado a las' p",
      yesterday: "'ayer a las' p",
      today: "'hoy a las' p",
      tomorrow: "'mañana a las' p",
      nextWeek: "eeee 'a las' p",
      other: 'P'
    };

    var formatRelative$8 = function (token, date, _baseDate, _options) {
      if (date.getUTCHours() !== 1) {
        return formatRelativeLocalePlural[token];
      } else {
        return formatRelativeLocale$7[token];
      }
    };

    var eraValues$7 = {
      narrow: ['AC', 'DC'],
      abbreviated: ['AC', 'DC'],
      wide: ['antes de cristo', 'después de cristo']
    };
    var quarterValues$7 = {
      narrow: ['1', '2', '3', '4'],
      abbreviated: ['T1', 'T2', 'T3', 'T4'],
      wide: ['1º trimestre', '2º trimestre', '3º trimestre', '4º trimestre']
    };
    var monthValues$7 = {
      narrow: ['e', 'f', 'm', 'a', 'm', 'j', 'j', 'a', 's', 'o', 'n', 'd'],
      abbreviated: ['ene', 'feb', 'mar', 'abr', 'may', 'jun', 'jul', 'ago', 'sep', 'oct', 'nov', 'dic'],
      wide: ['enero', 'febrero', 'marzo', 'abril', 'mayo', 'junio', 'julio', 'agosto', 'septiembre', 'octubre', 'noviembre', 'diciembre']
    };
    var dayValues$7 = {
      narrow: ['d', 'l', 'm', 'm', 'j', 'v', 's'],
      short: ['do', 'lu', 'ma', 'mi', 'ju', 'vi', 'sá'],
      abbreviated: ['dom', 'lun', 'mar', 'mié', 'jue', 'vie', 'sáb'],
      wide: ['domingo', 'lunes', 'martes', 'miércoles', 'jueves', 'viernes', 'sábado']
    };
    var dayPeriodValues$7 = {
      narrow: {
        am: 'a',
        pm: 'p',
        midnight: 'mn',
        noon: 'md',
        morning: 'mañana',
        afternoon: 'tarde',
        evening: 'tarde',
        night: 'noche'
      },
      abbreviated: {
        am: 'AM',
        pm: 'PM',
        midnight: 'medianoche',
        noon: 'mediodia',
        morning: 'mañana',
        afternoon: 'tarde',
        evening: 'tarde',
        night: 'noche'
      },
      wide: {
        am: 'a.m.',
        pm: 'p.m.',
        midnight: 'medianoche',
        noon: 'mediodia',
        morning: 'mañana',
        afternoon: 'tarde',
        evening: 'tarde',
        night: 'noche'
      }
    };
    var formattingDayPeriodValues$5 = {
      narrow: {
        am: 'a',
        pm: 'p',
        midnight: 'mn',
        noon: 'md',
        morning: 'de la mañana',
        afternoon: 'de la tarde',
        evening: 'de la tarde',
        night: 'de la noche'
      },
      abbreviated: {
        am: 'AM',
        pm: 'PM',
        midnight: 'medianoche',
        noon: 'mediodia',
        morning: 'de la mañana',
        afternoon: 'de la tarde',
        evening: 'de la tarde',
        night: 'de la noche'
      },
      wide: {
        am: 'a.m.',
        pm: 'p.m.',
        midnight: 'medianoche',
        noon: 'mediodia',
        morning: 'de la mañana',
        afternoon: 'de la tarde',
        evening: 'de la tarde',
        night: 'de la noche'
      }
    };

    var ordinalNumber$7 = function (dirtyNumber, _options) {
      var number = Number(dirtyNumber);
      return number + 'º';
    };

    var localize$8 = {
      ordinalNumber: ordinalNumber$7,
      era: buildLocalizeFn$1({
        values: eraValues$7,
        defaultWidth: 'wide'
      }),
      quarter: buildLocalizeFn$1({
        values: quarterValues$7,
        defaultWidth: 'wide',
        argumentCallback: function (quarter) {
          return Number(quarter) - 1;
        }
      }),
      month: buildLocalizeFn$1({
        values: monthValues$7,
        defaultWidth: 'wide'
      }),
      day: buildLocalizeFn$1({
        values: dayValues$7,
        defaultWidth: 'wide'
      }),
      dayPeriod: buildLocalizeFn$1({
        values: dayPeriodValues$7,
        defaultWidth: 'wide',
        formattingValues: formattingDayPeriodValues$5,
        defaultFormattingWidth: 'wide'
      })
    };

    var matchOrdinalNumberPattern$7 = /^(\d+)(º)?/i;
    var parseOrdinalNumberPattern$7 = /\d+/i;
    var matchEraPatterns$7 = {
      narrow: /^(ac|dc|a|d)/i,
      abbreviated: /^(a\.?\s?c\.?|a\.?\s?e\.?\s?c\.?|d\.?\s?c\.?|e\.?\s?c\.?)/i,
      wide: /^(antes de cristo|antes de la era com[uú]n|despu[eé]s de cristo|era com[uú]n)/i
    };
    var parseEraPatterns$7 = {
      any: [/^ac/i, /^dc/i],
      wide: [/^(antes de cristo|antes de la era com[uú]n)/i, /^(despu[eé]s de cristo|era com[uú]n)/i]
    };
    var matchQuarterPatterns$7 = {
      narrow: /^[1234]/i,
      abbreviated: /^T[1234]/i,
      wide: /^[1234](º)? trimestre/i
    };
    var parseQuarterPatterns$7 = {
      any: [/1/i, /2/i, /3/i, /4/i]
    };
    var matchMonthPatterns$7 = {
      narrow: /^[efmajsond]/i,
      abbreviated: /^(ene|feb|mar|abr|may|jun|jul|ago|sep|oct|nov|dic)/i,
      wide: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i
    };
    var parseMonthPatterns$7 = {
      narrow: [/^e/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
      any: [/^en/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i]
    };
    var matchDayPatterns$7 = {
      narrow: /^[dlmjvs]/i,
      short: /^(do|lu|ma|mi|ju|vi|s[áa])/i,
      abbreviated: /^(dom|lun|mar|mi[ée]|jue|vie|s[áa]b)/i,
      wide: /^(domingo|lunes|martes|mi[ée]rcoles|jueves|viernes|s[áa]bado)/i
    };
    var parseDayPatterns$7 = {
      narrow: [/^d/i, /^l/i, /^m/i, /^m/i, /^j/i, /^v/i, /^s/i],
      any: [/^do/i, /^lu/i, /^ma/i, /^mi/i, /^ju/i, /^vi/i, /^sa/i]
    };
    var matchDayPeriodPatterns$7 = {
      narrow: /^(a|p|mn|md|(de la|a las) (mañana|tarde|noche))/i,
      any: /^([ap]\.?\s?m\.?|medianoche|mediodia|(de la|a las) (mañana|tarde|noche))/i
    };
    var parseDayPeriodPatterns$7 = {
      any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^mn/i,
        noon: /^md/i,
        morning: /mañana/i,
        afternoon: /tarde/i,
        evening: /tarde/i,
        night: /noche/i
      }
    };
    var match$8 = {
      ordinalNumber: buildMatchPatternFn$1({
        matchPattern: matchOrdinalNumberPattern$7,
        parsePattern: parseOrdinalNumberPattern$7,
        valueCallback: function (value) {
          return parseInt(value, 10);
        }
      }),
      era: buildMatchFn$1({
        matchPatterns: matchEraPatterns$7,
        defaultMatchWidth: 'wide',
        parsePatterns: parseEraPatterns$7,
        defaultParseWidth: 'any'
      }),
      quarter: buildMatchFn$1({
        matchPatterns: matchQuarterPatterns$7,
        defaultMatchWidth: 'wide',
        parsePatterns: parseQuarterPatterns$7,
        defaultParseWidth: 'any',
        valueCallback: function (index) {
          return index + 1;
        }
      }),
      month: buildMatchFn$1({
        matchPatterns: matchMonthPatterns$7,
        defaultMatchWidth: 'wide',
        parsePatterns: parseMonthPatterns$7,
        defaultParseWidth: 'any'
      }),
      day: buildMatchFn$1({
        matchPatterns: matchDayPatterns$7,
        defaultMatchWidth: 'wide',
        parsePatterns: parseDayPatterns$7,
        defaultParseWidth: 'any'
      }),
      dayPeriod: buildMatchFn$1({
        matchPatterns: matchDayPeriodPatterns$7,
        defaultMatchWidth: 'any',
        parsePatterns: parseDayPeriodPatterns$7,
        defaultParseWidth: 'any'
      })
    };

    /**
     * @type {Locale}
     * @category Locales
     * @summary Spanish locale.
     * @language Spanish
     * @iso-639-2 spa
     * @author Juan Angosto [@juanangosto]{@link https://github.com/juanangosto}
     * @author Guillermo Grau [@guigrpa]{@link https://github.com/guigrpa}
     * @author Fernando Agüero [@fjaguero]{@link https://github.com/fjaguero}
     * @author Gastón Haro [@harogaston]{@link https://github.com/harogaston}
     * @author Yago Carballo [@YagoCarballo]{@link https://github.com/YagoCarballo}
     */

    var locale$8 = {
      code: 'es',
      formatDistance: formatDistance$8,
      formatLong: formatLong$9,
      formatRelative: formatRelative$8,
      localize: localize$8,
      match: match$8,
      options: {
        weekStartsOn: 1
        /* Monday */
        ,
        firstWeekContainsDate: 1
      }
    };

    const dateEsAR = {
      name: "es-AR",
      locale: locale$8
    };
    var dateEsAR$1 = dateEsAR;

    var formatDistanceLocale$6 = {
      lessThanXSeconds: {
        one: 'meno di un secondo',
        other: 'meno di {{count}} secondi'
      },
      xSeconds: {
        one: 'un secondo',
        other: '{{count}} secondi'
      },
      halfAMinute: 'alcuni secondi',
      lessThanXMinutes: {
        one: 'meno di un minuto',
        other: 'meno di {{count}} minuti'
      },
      xMinutes: {
        one: 'un minuto',
        other: '{{count}} minuti'
      },
      aboutXHours: {
        one: "circa un'ora",
        other: 'circa {{count}} ore'
      },
      xHours: {
        one: "un'ora",
        other: '{{count}} ore'
      },
      xDays: {
        one: 'un giorno',
        other: '{{count}} giorni'
      },
      aboutXWeeks: {
        one: 'circa una settimana',
        other: 'circa {{count}} settimane'
      },
      xWeeks: {
        one: 'una settimana',
        other: '{{count}} settimane'
      },
      aboutXMonths: {
        one: 'circa un mese',
        other: 'circa {{count}} mesi'
      },
      xMonths: {
        one: 'un mese',
        other: '{{count}} mesi'
      },
      aboutXYears: {
        one: 'circa un anno',
        other: 'circa {{count}} anni'
      },
      xYears: {
        one: 'un anno',
        other: '{{count}} anni'
      },
      overXYears: {
        one: 'più di un anno',
        other: 'più di {{count}} anni'
      },
      almostXYears: {
        one: 'quasi un anno',
        other: 'quasi {{count}} anni'
      }
    };

    var formatDistance$7 = function (token, count, options) {
      var result;
      var tokenValue = formatDistanceLocale$6[token];

      if (typeof tokenValue === 'string') {
        result = tokenValue;
      } else if (count === 1) {
        result = tokenValue.one;
      } else {
        result = tokenValue.other.replace('{{count}}', count.toString());
      }

      if (options !== null && options !== void 0 && options.addSuffix) {
        if (options.comparison && options.comparison > 0) {
          return 'tra ' + result;
        } else {
          return result + ' fa';
        }
      }

      return result;
    };

    var dateFormats$7 = {
      full: 'EEEE d MMMM y',
      long: 'd MMMM y',
      medium: 'd MMM y',
      short: 'dd/MM/y'
    };
    var timeFormats$7 = {
      full: 'HH:mm:ss zzzz',
      long: 'HH:mm:ss z',
      medium: 'HH:mm:ss',
      short: 'HH:mm'
    };
    var dateTimeFormats$7 = {
      full: '{{date}} {{time}}',
      long: '{{date}} {{time}}',
      medium: '{{date}} {{time}}',
      short: '{{date}} {{time}}'
    };
    var formatLong$8 = {
      date: buildFormatLongFn$1({
        formats: dateFormats$7,
        defaultWidth: 'full'
      }),
      time: buildFormatLongFn$1({
        formats: timeFormats$7,
        defaultWidth: 'full'
      }),
      dateTime: buildFormatLongFn$1({
        formats: dateTimeFormats$7,
        defaultWidth: 'full'
      })
    };

    var weekdays = ['domenica', 'lunedì', 'martedì', 'mercoledì', 'giovedì', 'venerdì', 'sabato'];

    function lastWeek$1(day) {
      switch (day) {
        case 0:
          return "'domenica scorsa alle' p";

        default:
          return "'" + weekdays[day] + " scorso alle' p";
      }
    }

    function thisWeek$1(day) {
      return "'" + weekdays[day] + " alle' p";
    }

    function nextWeek$1(day) {
      switch (day) {
        case 0:
          return "'domenica prossima alle' p";

        default:
          return "'" + weekdays[day] + " prossimo alle' p";
      }
    }

    var formatRelativeLocale$6 = {
      lastWeek: function (date, baseDate, options) {
        var day = date.getUTCDay();

        if (isSameUTCWeek(date, baseDate, options)) {
          return thisWeek$1(day);
        } else {
          return lastWeek$1(day);
        }
      },
      yesterday: "'ieri alle' p",
      today: "'oggi alle' p",
      tomorrow: "'domani alle' p",
      nextWeek: function (date, baseDate, options) {
        var day = date.getUTCDay();

        if (isSameUTCWeek(date, baseDate, options)) {
          return thisWeek$1(day);
        } else {
          return nextWeek$1(day);
        }
      },
      other: 'P'
    };

    var formatRelative$7 = function (token, date, baseDate, options) {
      var format = formatRelativeLocale$6[token];

      if (typeof format === 'function') {
        return format(date, baseDate, options);
      }

      return format;
    };

    var eraValues$6 = {
      narrow: ['aC', 'dC'],
      abbreviated: ['a.C.', 'd.C.'],
      wide: ['avanti Cristo', 'dopo Cristo']
    };
    var quarterValues$6 = {
      narrow: ['1', '2', '3', '4'],
      abbreviated: ['T1', 'T2', 'T3', 'T4'],
      wide: ['1º trimestre', '2º trimestre', '3º trimestre', '4º trimestre']
    };
    var monthValues$6 = {
      narrow: ['G', 'F', 'M', 'A', 'M', 'G', 'L', 'A', 'S', 'O', 'N', 'D'],
      abbreviated: ['gen', 'feb', 'mar', 'apr', 'mag', 'giu', 'lug', 'ago', 'set', 'ott', 'nov', 'dic'],
      wide: ['gennaio', 'febbraio', 'marzo', 'aprile', 'maggio', 'giugno', 'luglio', 'agosto', 'settembre', 'ottobre', 'novembre', 'dicembre']
    };
    var dayValues$6 = {
      narrow: ['D', 'L', 'M', 'M', 'G', 'V', 'S'],
      short: ['dom', 'lun', 'mar', 'mer', 'gio', 'ven', 'sab'],
      abbreviated: ['dom', 'lun', 'mar', 'mer', 'gio', 'ven', 'sab'],
      wide: ['domenica', 'lunedì', 'martedì', 'mercoledì', 'giovedì', 'venerdì', 'sabato']
    };
    var dayPeriodValues$6 = {
      narrow: {
        am: 'm.',
        pm: 'p.',
        midnight: 'mezzanotte',
        noon: 'mezzogiorno',
        morning: 'mattina',
        afternoon: 'pomeriggio',
        evening: 'sera',
        night: 'notte'
      },
      abbreviated: {
        am: 'AM',
        pm: 'PM',
        midnight: 'mezzanotte',
        noon: 'mezzogiorno',
        morning: 'mattina',
        afternoon: 'pomeriggio',
        evening: 'sera',
        night: 'notte'
      },
      wide: {
        am: 'AM',
        pm: 'PM',
        midnight: 'mezzanotte',
        noon: 'mezzogiorno',
        morning: 'mattina',
        afternoon: 'pomeriggio',
        evening: 'sera',
        night: 'notte'
      }
    };
    var formattingDayPeriodValues$4 = {
      narrow: {
        am: 'm.',
        pm: 'p.',
        midnight: 'mezzanotte',
        noon: 'mezzogiorno',
        morning: 'di mattina',
        afternoon: 'del pomeriggio',
        evening: 'di sera',
        night: 'di notte'
      },
      abbreviated: {
        am: 'AM',
        pm: 'PM',
        midnight: 'mezzanotte',
        noon: 'mezzogiorno',
        morning: 'di mattina',
        afternoon: 'del pomeriggio',
        evening: 'di sera',
        night: 'di notte'
      },
      wide: {
        am: 'AM',
        pm: 'PM',
        midnight: 'mezzanotte',
        noon: 'mezzogiorno',
        morning: 'di mattina',
        afternoon: 'del pomeriggio',
        evening: 'di sera',
        night: 'di notte'
      }
    };

    var ordinalNumber$6 = function (dirtyNumber, _options) {
      var number = Number(dirtyNumber);
      return String(number);
    };

    var localize$7 = {
      ordinalNumber: ordinalNumber$6,
      era: buildLocalizeFn$1({
        values: eraValues$6,
        defaultWidth: 'wide'
      }),
      quarter: buildLocalizeFn$1({
        values: quarterValues$6,
        defaultWidth: 'wide',
        argumentCallback: function (quarter) {
          return quarter - 1;
        }
      }),
      month: buildLocalizeFn$1({
        values: monthValues$6,
        defaultWidth: 'wide'
      }),
      day: buildLocalizeFn$1({
        values: dayValues$6,
        defaultWidth: 'wide'
      }),
      dayPeriod: buildLocalizeFn$1({
        values: dayPeriodValues$6,
        defaultWidth: 'wide',
        formattingValues: formattingDayPeriodValues$4,
        defaultFormattingWidth: 'wide'
      })
    };

    var matchOrdinalNumberPattern$6 = /^(\d+)(º)?/i;
    var parseOrdinalNumberPattern$6 = /\d+/i;
    var matchEraPatterns$6 = {
      narrow: /^(aC|dC)/i,
      abbreviated: /^(a\.?\s?C\.?|a\.?\s?e\.?\s?v\.?|d\.?\s?C\.?|e\.?\s?v\.?)/i,
      wide: /^(avanti Cristo|avanti Era Volgare|dopo Cristo|Era Volgare)/i
    };
    var parseEraPatterns$6 = {
      any: [/^a/i, /^(d|e)/i]
    };
    var matchQuarterPatterns$6 = {
      narrow: /^[1234]/i,
      abbreviated: /^t[1234]/i,
      wide: /^[1234](º)? trimestre/i
    };
    var parseQuarterPatterns$6 = {
      any: [/1/i, /2/i, /3/i, /4/i]
    };
    var matchMonthPatterns$6 = {
      narrow: /^[gfmalsond]/i,
      abbreviated: /^(gen|feb|mar|apr|mag|giu|lug|ago|set|ott|nov|dic)/i,
      wide: /^(gennaio|febbraio|marzo|aprile|maggio|giugno|luglio|agosto|settembre|ottobre|novembre|dicembre)/i
    };
    var parseMonthPatterns$6 = {
      narrow: [/^g/i, /^f/i, /^m/i, /^a/i, /^m/i, /^g/i, /^l/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
      any: [/^ge/i, /^f/i, /^mar/i, /^ap/i, /^mag/i, /^gi/i, /^l/i, /^ag/i, /^s/i, /^o/i, /^n/i, /^d/i]
    };
    var matchDayPatterns$6 = {
      narrow: /^[dlmgvs]/i,
      short: /^(do|lu|ma|me|gi|ve|sa)/i,
      abbreviated: /^(dom|lun|mar|mer|gio|ven|sab)/i,
      wide: /^(domenica|luned[i|ì]|marted[i|ì]|mercoled[i|ì]|gioved[i|ì]|venerd[i|ì]|sabato)/i
    };
    var parseDayPatterns$6 = {
      narrow: [/^d/i, /^l/i, /^m/i, /^m/i, /^g/i, /^v/i, /^s/i],
      any: [/^d/i, /^l/i, /^ma/i, /^me/i, /^g/i, /^v/i, /^s/i]
    };
    var matchDayPeriodPatterns$6 = {
      narrow: /^(a|m\.|p|mezzanotte|mezzogiorno|(di|del) (mattina|pomeriggio|sera|notte))/i,
      any: /^([ap]\.?\s?m\.?|mezzanotte|mezzogiorno|(di|del) (mattina|pomeriggio|sera|notte))/i
    };
    var parseDayPeriodPatterns$6 = {
      any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^mezza/i,
        noon: /^mezzo/i,
        morning: /mattina/i,
        afternoon: /pomeriggio/i,
        evening: /sera/i,
        night: /notte/i
      }
    };
    var match$7 = {
      ordinalNumber: buildMatchPatternFn$1({
        matchPattern: matchOrdinalNumberPattern$6,
        parsePattern: parseOrdinalNumberPattern$6,
        valueCallback: function (value) {
          return parseInt(value, 10);
        }
      }),
      era: buildMatchFn$1({
        matchPatterns: matchEraPatterns$6,
        defaultMatchWidth: 'wide',
        parsePatterns: parseEraPatterns$6,
        defaultParseWidth: 'any'
      }),
      quarter: buildMatchFn$1({
        matchPatterns: matchQuarterPatterns$6,
        defaultMatchWidth: 'wide',
        parsePatterns: parseQuarterPatterns$6,
        defaultParseWidth: 'any',
        valueCallback: function (index) {
          return index + 1;
        }
      }),
      month: buildMatchFn$1({
        matchPatterns: matchMonthPatterns$6,
        defaultMatchWidth: 'wide',
        parsePatterns: parseMonthPatterns$6,
        defaultParseWidth: 'any'
      }),
      day: buildMatchFn$1({
        matchPatterns: matchDayPatterns$6,
        defaultMatchWidth: 'wide',
        parsePatterns: parseDayPatterns$6,
        defaultParseWidth: 'any'
      }),
      dayPeriod: buildMatchFn$1({
        matchPatterns: matchDayPeriodPatterns$6,
        defaultMatchWidth: 'any',
        parsePatterns: parseDayPeriodPatterns$6,
        defaultParseWidth: 'any'
      })
    };

    /**
     * @type {Locale}
     * @category Locales
     * @summary Italian locale.
     * @language Italian
     * @iso-639-2 ita
     * @author Alberto Restifo [@albertorestifo]{@link https://github.com/albertorestifo}
     * @author Giovanni Polimeni [@giofilo]{@link https://github.com/giofilo}
     * @author Vincenzo Carrese [@vin-car]{@link https://github.com/vin-car}
     */

    var locale$7 = {
      code: 'it',
      formatDistance: formatDistance$7,
      formatLong: formatLong$8,
      formatRelative: formatRelative$7,
      localize: localize$7,
      match: match$7,
      options: {
        weekStartsOn: 1
        /* Monday */
        ,
        firstWeekContainsDate: 4
      }
    };

    const dateItIT = {
      name: "it-IT",
      locale: locale$7
    };
    var dateItIT$1 = dateItIT;

    function declensionGroup$1(scheme, count) {
      if (count === 1 && scheme.one) {
        return scheme.one;
      }

      if (count >= 2 && count <= 4 && scheme.twoFour) {
        return scheme.twoFour;
      } // if count === null || count === 0 || count >= 5


      return scheme.other;
    }

    function declension$1(scheme, count, time) {
      var group = declensionGroup$1(scheme, count);
      var finalText = group[time];
      return finalText.replace('{{count}}', String(count));
    }

    function extractPreposition(token) {
      var result = ['lessThan', 'about', 'over', 'almost'].filter(function (preposition) {
        return !!token.match(new RegExp('^' + preposition));
      });
      return result[0];
    }

    function prefixPreposition(preposition) {
      var translation = '';

      if (preposition === 'almost') {
        translation = 'takmer';
      }

      if (preposition === 'about') {
        translation = 'približne';
      }

      return translation.length > 0 ? translation + ' ' : '';
    }

    function suffixPreposition(preposition) {
      var translation = '';

      if (preposition === 'lessThan') {
        translation = 'menej než';
      }

      if (preposition === 'over') {
        translation = 'viac než';
      }

      return translation.length > 0 ? translation + ' ' : '';
    }

    function lowercaseFirstLetter(string) {
      return string.charAt(0).toLowerCase() + string.slice(1);
    }

    var formatDistanceLocale$5 = {
      xSeconds: {
        one: {
          present: 'sekunda',
          past: 'sekundou',
          future: 'sekundu'
        },
        twoFour: {
          present: '{{count}} sekundy',
          past: '{{count}} sekundami',
          future: '{{count}} sekundy'
        },
        other: {
          present: '{{count}} sekúnd',
          past: '{{count}} sekundami',
          future: '{{count}} sekúnd'
        }
      },
      halfAMinute: {
        other: {
          present: 'pol minúty',
          past: 'pol minútou',
          future: 'pol minúty'
        }
      },
      xMinutes: {
        one: {
          present: 'minúta',
          past: 'minútou',
          future: 'minútu'
        },
        twoFour: {
          present: '{{count}} minúty',
          past: '{{count}} minútami',
          future: '{{count}} minúty'
        },
        other: {
          present: '{{count}} minút',
          past: '{{count}} minútami',
          future: '{{count}} minút'
        }
      },
      xHours: {
        one: {
          present: 'hodina',
          past: 'hodinou',
          future: 'hodinu'
        },
        twoFour: {
          present: '{{count}} hodiny',
          past: '{{count}} hodinami',
          future: '{{count}} hodiny'
        },
        other: {
          present: '{{count}} hodín',
          past: '{{count}} hodinami',
          future: '{{count}} hodín'
        }
      },
      xDays: {
        one: {
          present: 'deň',
          past: 'dňom',
          future: 'deň'
        },
        twoFour: {
          present: '{{count}} dni',
          past: '{{count}} dňami',
          future: '{{count}} dni'
        },
        other: {
          present: '{{count}} dní',
          past: '{{count}} dňami',
          future: '{{count}} dní'
        }
      },
      xWeeks: {
        one: {
          present: 'týždeň',
          past: 'týždňom',
          future: 'týždeň'
        },
        twoFour: {
          present: '{{count}} týždne',
          past: '{{count}} týždňami',
          future: '{{count}} týždne'
        },
        other: {
          present: '{{count}} týždňov',
          past: '{{count}} týždňami',
          future: '{{count}} týždňov'
        }
      },
      xMonths: {
        one: {
          present: 'mesiac',
          past: 'mesiacom',
          future: 'mesiac'
        },
        twoFour: {
          present: '{{count}} mesiace',
          past: '{{count}} mesiacmi',
          future: '{{count}} mesiace'
        },
        other: {
          present: '{{count}} mesiacov',
          past: '{{count}} mesiacmi',
          future: '{{count}} mesiacov'
        }
      },
      xYears: {
        one: {
          present: 'rok',
          past: 'rokom',
          future: 'rok'
        },
        twoFour: {
          present: '{{count}} roky',
          past: '{{count}} rokmi',
          future: '{{count}} roky'
        },
        other: {
          present: '{{count}} rokov',
          past: '{{count}} rokmi',
          future: '{{count}} rokov'
        }
      }
    };

    var formatDistance$6 = function (token, count, options) {
      var preposition = extractPreposition(token) || '';
      var key = lowercaseFirstLetter(token.substring(preposition.length));
      var scheme = formatDistanceLocale$5[key];

      if (!(options !== null && options !== void 0 && options.addSuffix)) {
        return prefixPreposition(preposition) + suffixPreposition(preposition) + declension$1(scheme, count, 'present');
      }

      if (options.comparison && options.comparison > 0) {
        return prefixPreposition(preposition) + 'o ' + suffixPreposition(preposition) + declension$1(scheme, count, 'future');
      } else {
        return prefixPreposition(preposition) + 'pred ' + suffixPreposition(preposition) + declension$1(scheme, count, 'past');
      }
    };

    var dateFormats$6 = {
      full: 'EEEE d. MMMM y',
      long: 'd. MMMM y',
      medium: 'd. M. y',
      short: 'd. M. y'
    }; // https://www.unicode.org/cldr/charts/32/summary/sk.html?hide#2149

    var timeFormats$6 = {
      full: 'H:mm:ss zzzz',
      long: 'H:mm:ss z',
      medium: 'H:mm:ss',
      short: 'H:mm'
    }; // https://www.unicode.org/cldr/charts/32/summary/sk.html?hide#1994

    var dateTimeFormats$6 = {
      full: '{{date}}, {{time}}',
      long: '{{date}}, {{time}}',
      medium: '{{date}}, {{time}}',
      short: '{{date}} {{time}}'
    };
    var formatLong$7 = {
      date: buildFormatLongFn$1({
        formats: dateFormats$6,
        defaultWidth: 'full'
      }),
      time: buildFormatLongFn$1({
        formats: timeFormats$6,
        defaultWidth: 'full'
      }),
      dateTime: buildFormatLongFn$1({
        formats: dateTimeFormats$6,
        defaultWidth: 'full'
      })
    };

    var accusativeWeekdays = ['nedeľu', 'pondelok', 'utorok', 'stredu', 'štvrtok', 'piatok', 'sobotu'];

    function lastWeek(day) {
      var weekday = accusativeWeekdays[day];

      switch (day) {
        case 0:
        /* Sun */

        case 3:
        /* Wed */

        case 6
        /* Sat */
        :
          return "'minulú " + weekday + " o' p";

        default:
          return "'minulý' eeee 'o' p";
      }
    }

    function thisWeek(day) {
      var weekday = accusativeWeekdays[day];

      if (day === 4
      /* Thu */
      ) {
        return "'vo' eeee 'o' p";
      } else {
        return "'v " + weekday + " o' p";
      }
    }

    function nextWeek(day) {
      var weekday = accusativeWeekdays[day];

      switch (day) {
        case 0:
        /* Sun */

        case 4:
        /* Wed */

        case 6
        /* Sat */
        :
          return "'budúcu " + weekday + " o' p";

        default:
          return "'budúci' eeee 'o' p";
      }
    }

    var formatRelativeLocale$5 = {
      lastWeek: function (date, baseDate, options) {
        var day = date.getUTCDay();

        if (isSameUTCWeek(date, baseDate, options)) {
          return thisWeek(day);
        } else {
          return lastWeek(day);
        }
      },
      yesterday: "'včera o' p",
      today: "'dnes o' p",
      tomorrow: "'zajtra o' p",
      nextWeek: function (date, baseDate, options) {
        var day = date.getUTCDay();

        if (isSameUTCWeek(date, baseDate, options)) {
          return thisWeek(day);
        } else {
          return nextWeek(day);
        }
      },
      other: 'P'
    };

    var formatRelative$6 = function (token, date, baseDate, options) {
      var format = formatRelativeLocale$5[token];

      if (typeof format === 'function') {
        return format(date, baseDate, options);
      }

      return format;
    };

    var eraValues$5 = {
      narrow: ['pred Kr.', 'po Kr.'],
      abbreviated: ['pred Kr.', 'po Kr.'],
      wide: ['pred Kristom', 'po Kristovi']
    }; // https://www.unicode.org/cldr/charts/32/summary/sk.html#1780

    var quarterValues$5 = {
      narrow: ['1', '2', '3', '4'],
      abbreviated: ['Q1', 'Q2', 'Q3', 'Q4'],
      wide: ['1. štvrťrok', '2. štvrťrok', '3. štvrťrok', '4. štvrťrok']
    }; // https://www.unicode.org/cldr/charts/32/summary/sk.html#1804

    var monthValues$5 = {
      narrow: ['j', 'f', 'm', 'a', 'm', 'j', 'j', 'a', 's', 'o', 'n', 'd'],
      abbreviated: ['jan', 'feb', 'mar', 'apr', 'máj', 'jún', 'júl', 'aug', 'sep', 'okt', 'nov', 'dec'],
      wide: ['január', 'február', 'marec', 'apríl', 'máj', 'jún', 'júl', 'august', 'september', 'október', 'november', 'december']
    };
    var formattingMonthValues$1 = {
      narrow: ['j', 'f', 'm', 'a', 'm', 'j', 'j', 'a', 's', 'o', 'n', 'd'],
      abbreviated: ['jan', 'feb', 'mar', 'apr', 'máj', 'jún', 'júl', 'aug', 'sep', 'okt', 'nov', 'dec'],
      wide: ['januára', 'februára', 'marca', 'apríla', 'mája', 'júna', 'júla', 'augusta', 'septembra', 'októbra', 'novembra', 'decembra']
    }; // https://www.unicode.org/cldr/charts/32/summary/sk.html#1876

    var dayValues$5 = {
      narrow: ['n', 'p', 'u', 's', 'š', 'p', 's'],
      short: ['ne', 'po', 'ut', 'st', 'št', 'pi', 'so'],
      abbreviated: ['ne', 'po', 'ut', 'st', 'št', 'pi', 'so'],
      wide: ['nedeľa', 'pondelok', 'utorok', 'streda', 'štvrtok', 'piatok', 'sobota']
    }; // https://www.unicode.org/cldr/charts/32/summary/sk.html#1932

    var dayPeriodValues$5 = {
      narrow: {
        am: 'AM',
        pm: 'PM',
        midnight: 'poln.',
        noon: 'pol.',
        morning: 'ráno',
        afternoon: 'pop.',
        evening: 'več.',
        night: 'noc'
      },
      abbreviated: {
        am: 'AM',
        pm: 'PM',
        midnight: 'poln.',
        noon: 'pol.',
        morning: 'ráno',
        afternoon: 'popol.',
        evening: 'večer',
        night: 'noc'
      },
      wide: {
        am: 'AM',
        pm: 'PM',
        midnight: 'polnoc',
        noon: 'poludnie',
        morning: 'ráno',
        afternoon: 'popoludnie',
        evening: 'večer',
        night: 'noc'
      }
    };
    var formattingDayPeriodValues$3 = {
      narrow: {
        am: 'AM',
        pm: 'PM',
        midnight: 'o poln.',
        noon: 'nap.',
        morning: 'ráno',
        afternoon: 'pop.',
        evening: 'več.',
        night: 'v n.'
      },
      abbreviated: {
        am: 'AM',
        pm: 'PM',
        midnight: 'o poln.',
        noon: 'napol.',
        morning: 'ráno',
        afternoon: 'popol.',
        evening: 'večer',
        night: 'v noci'
      },
      wide: {
        am: 'AM',
        pm: 'PM',
        midnight: 'o polnoci',
        noon: 'napoludnie',
        morning: 'ráno',
        afternoon: 'popoludní',
        evening: 'večer',
        night: 'v noci'
      }
    };

    var ordinalNumber$5 = function (dirtyNumber, _options) {
      var number = Number(dirtyNumber);
      return number + '.';
    };

    var localize$6 = {
      ordinalNumber: ordinalNumber$5,
      era: buildLocalizeFn$1({
        values: eraValues$5,
        defaultWidth: 'wide'
      }),
      quarter: buildLocalizeFn$1({
        values: quarterValues$5,
        defaultWidth: 'wide',
        argumentCallback: function (quarter) {
          return quarter - 1;
        }
      }),
      month: buildLocalizeFn$1({
        values: monthValues$5,
        defaultWidth: 'wide',
        formattingValues: formattingMonthValues$1,
        defaultFormattingWidth: 'wide'
      }),
      day: buildLocalizeFn$1({
        values: dayValues$5,
        defaultWidth: 'wide'
      }),
      dayPeriod: buildLocalizeFn$1({
        values: dayPeriodValues$5,
        defaultWidth: 'wide',
        formattingValues: formattingDayPeriodValues$3,
        defaultFormattingWidth: 'wide'
      })
    };

    var matchOrdinalNumberPattern$5 = /^(\d+)\.?/i;
    var parseOrdinalNumberPattern$5 = /\d+/i;
    var matchEraPatterns$5 = {
      narrow: /^(pred Kr\.|pred n\. l\.|po Kr\.|n\. l\.)/i,
      abbreviated: /^(pred Kr\.|pred n\. l\.|po Kr\.|n\. l\.)/i,
      wide: /^(pred Kristom|pred na[šs][íi]m letopo[čc]tom|po Kristovi|n[áa][šs]ho letopo[čc]tu)/i
    };
    var parseEraPatterns$5 = {
      any: [/^pr/i, /^(po|n)/i]
    };
    var matchQuarterPatterns$5 = {
      narrow: /^[1234]/i,
      abbreviated: /^q[1234]/i,
      wide: /^[1234]\. [šs]tvr[ťt]rok/i
    };
    var parseQuarterPatterns$5 = {
      any: [/1/i, /2/i, /3/i, /4/i]
    };
    var matchMonthPatterns$5 = {
      narrow: /^[jfmasond]/i,
      abbreviated: /^(jan|feb|mar|apr|m[áa]j|j[úu]n|j[úu]l|aug|sep|okt|nov|dec)/i,
      wide: /^(janu[áa]ra?|febru[áa]ra?|(marec|marca)|apr[íi]la?|m[áa]ja?|j[úu]na?|j[úu]la?|augusta?|(september|septembra)|(okt[óo]ber|okt[óo]bra)|(november|novembra)|(december|decembra))/i
    };
    var parseMonthPatterns$5 = {
      narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
      any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^m[áa]j/i, /^j[úu]n/i, /^j[úu]l/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
    };
    var matchDayPatterns$5 = {
      narrow: /^[npusšp]/i,
      short: /^(ne|po|ut|st|št|pi|so)/i,
      abbreviated: /^(ne|po|ut|st|št|pi|so)/i,
      wide: /^(nede[ľl]a|pondelok|utorok|streda|[šs]tvrtok|piatok|sobota])/i
    };
    var parseDayPatterns$5 = {
      narrow: [/^n/i, /^p/i, /^u/i, /^s/i, /^š/i, /^p/i, /^s/i],
      any: [/^n/i, /^po/i, /^u/i, /^st/i, /^(št|stv)/i, /^pi/i, /^so/i]
    };
    var matchDayPeriodPatterns$5 = {
      narrow: /^(am|pm|(o )?poln\.?|(nap\.?|pol\.?)|r[áa]no|pop\.?|ve[čc]\.?|(v n\.?|noc))/i,
      abbreviated: /^(am|pm|(o )?poln\.?|(napol\.?|pol\.?)|r[áa]no|pop\.?|ve[čc]er|(v )?noci?)/i,
      any: /^(am|pm|(o )?polnoci?|(na)?poludnie|r[áa]no|popoludn(ie|í|i)|ve[čc]er|(v )?noci?)/i
    };
    var parseDayPeriodPatterns$5 = {
      any: {
        am: /^am/i,
        pm: /^pm/i,
        midnight: /poln/i,
        noon: /^(nap|(na)?pol(\.|u))/i,
        morning: /^r[áa]no/i,
        afternoon: /^pop/i,
        evening: /^ve[čc]/i,
        night: /^(noc|v n\.)/i
      }
    };
    var match$6 = {
      ordinalNumber: buildMatchPatternFn$1({
        matchPattern: matchOrdinalNumberPattern$5,
        parsePattern: parseOrdinalNumberPattern$5,
        valueCallback: function (value) {
          return parseInt(value, 10);
        }
      }),
      era: buildMatchFn$1({
        matchPatterns: matchEraPatterns$5,
        defaultMatchWidth: 'wide',
        parsePatterns: parseEraPatterns$5,
        defaultParseWidth: 'any'
      }),
      quarter: buildMatchFn$1({
        matchPatterns: matchQuarterPatterns$5,
        defaultMatchWidth: 'wide',
        parsePatterns: parseQuarterPatterns$5,
        defaultParseWidth: 'any',
        valueCallback: function (index) {
          return index + 1;
        }
      }),
      month: buildMatchFn$1({
        matchPatterns: matchMonthPatterns$5,
        defaultMatchWidth: 'wide',
        parsePatterns: parseMonthPatterns$5,
        defaultParseWidth: 'any'
      }),
      day: buildMatchFn$1({
        matchPatterns: matchDayPatterns$5,
        defaultMatchWidth: 'wide',
        parsePatterns: parseDayPatterns$5,
        defaultParseWidth: 'any'
      }),
      dayPeriod: buildMatchFn$1({
        matchPatterns: matchDayPeriodPatterns$5,
        defaultMatchWidth: 'any',
        parsePatterns: parseDayPeriodPatterns$5,
        defaultParseWidth: 'any'
      })
    };

    /**
     * @type {Locale}
     * @category Locales
     * @summary Slovak locale.
     * @language Slovak
     * @iso-639-2 slk
     * @author Marek Suscak [@mareksuscak]{@link https://github.com/mareksuscak}
     */

    var locale$6 = {
      code: 'sk',
      formatDistance: formatDistance$6,
      formatLong: formatLong$7,
      formatRelative: formatRelative$6,
      localize: localize$6,
      match: match$6,
      options: {
        weekStartsOn: 1
        /* Monday */
        ,
        firstWeekContainsDate: 4
      }
    };

    const dateSkSK = {
      name: "sk-SK",
      locale: locale$6
    };
    var dateSkSK$1 = dateSkSK;

    var dateFormats$5 = {
      full: 'EEEE, d MMMM yyyy',
      long: 'd MMMM yyyy',
      medium: 'd MMM yyyy',
      short: 'dd/MM/yyyy'
    };
    var timeFormats$5 = {
      full: 'HH:mm:ss zzzz',
      long: 'HH:mm:ss z',
      medium: 'HH:mm:ss',
      short: 'HH:mm'
    };
    var dateTimeFormats$5 = {
      full: "{{date}} 'at' {{time}}",
      long: "{{date}} 'at' {{time}}",
      medium: '{{date}}, {{time}}',
      short: '{{date}}, {{time}}'
    };
    var formatLong$6 = {
      date: buildFormatLongFn$1({
        formats: dateFormats$5,
        defaultWidth: 'full'
      }),
      time: buildFormatLongFn$1({
        formats: timeFormats$5,
        defaultWidth: 'full'
      }),
      dateTime: buildFormatLongFn$1({
        formats: dateTimeFormats$5,
        defaultWidth: 'full'
      })
    };

    /**
     * @type {Locale}
     * @category Locales
     * @summary English locale (United Kingdom).
     * @language English
     * @iso-639-2 eng
     * @author Alex [@glintik]{@link https://github.com/glintik}
     */

    var locale$5 = {
      code: 'en-GB',
      formatDistance: formatDistance$i,
      formatLong: formatLong$6,
      formatRelative: formatRelative$i,
      localize: localize$i,
      match: match$i,
      options: {
        weekStartsOn: 1
        /* Monday */
        ,
        firstWeekContainsDate: 4
      }
    };

    const dateEnGB = {
      name: "en-GB",
      locale: locale$5
    };
    var dateEnGB$1 = dateEnGB;

    var formatDistanceLocale$4 = {
      lessThanXSeconds: {
        one: {
          regular: 'mniej niż sekunda',
          past: 'mniej niż sekundę',
          future: 'mniej niż sekundę'
        },
        twoFour: 'mniej niż {{count}} sekundy',
        other: 'mniej niż {{count}} sekund'
      },
      xSeconds: {
        one: {
          regular: 'sekunda',
          past: 'sekundę',
          future: 'sekundę'
        },
        twoFour: '{{count}} sekundy',
        other: '{{count}} sekund'
      },
      halfAMinute: {
        one: 'pół minuty',
        twoFour: 'pół minuty',
        other: 'pół minuty'
      },
      lessThanXMinutes: {
        one: {
          regular: 'mniej niż minuta',
          past: 'mniej niż minutę',
          future: 'mniej niż minutę'
        },
        twoFour: 'mniej niż {{count}} minuty',
        other: 'mniej niż {{count}} minut'
      },
      xMinutes: {
        one: {
          regular: 'minuta',
          past: 'minutę',
          future: 'minutę'
        },
        twoFour: '{{count}} minuty',
        other: '{{count}} minut'
      },
      aboutXHours: {
        one: {
          regular: 'około godziny',
          past: 'około godziny',
          future: 'około godzinę'
        },
        twoFour: 'około {{count}} godziny',
        other: 'około {{count}} godzin'
      },
      xHours: {
        one: {
          regular: 'godzina',
          past: 'godzinę',
          future: 'godzinę'
        },
        twoFour: '{{count}} godziny',
        other: '{{count}} godzin'
      },
      xDays: {
        one: {
          regular: 'dzień',
          past: 'dzień',
          future: '1 dzień'
        },
        twoFour: '{{count}} dni',
        other: '{{count}} dni'
      },
      aboutXWeeks: {
        one: 'około tygodnia',
        twoFour: 'około {{count}} tygodni',
        other: 'około {{count}} tygodni'
      },
      xWeeks: {
        one: 'tydzień',
        twoFour: '{{count}} tygodnie',
        other: '{{count}} tygodni'
      },
      aboutXMonths: {
        one: 'około miesiąc',
        twoFour: 'około {{count}} miesiące',
        other: 'około {{count}} miesięcy'
      },
      xMonths: {
        one: 'miesiąc',
        twoFour: '{{count}} miesiące',
        other: '{{count}} miesięcy'
      },
      aboutXYears: {
        one: 'około rok',
        twoFour: 'około {{count}} lata',
        other: 'około {{count}} lat'
      },
      xYears: {
        one: 'rok',
        twoFour: '{{count}} lata',
        other: '{{count}} lat'
      },
      overXYears: {
        one: 'ponad rok',
        twoFour: 'ponad {{count}} lata',
        other: 'ponad {{count}} lat'
      },
      almostXYears: {
        one: 'prawie rok',
        twoFour: 'prawie {{count}} lata',
        other: 'prawie {{count}} lat'
      }
    };

    function declensionGroup(scheme, count) {
      if (count === 1) {
        return scheme.one;
      }

      var rem100 = count % 100; // ends with 11-20

      if (rem100 <= 20 && rem100 > 10) {
        return scheme.other;
      }

      var rem10 = rem100 % 10; // ends with 2, 3, 4

      if (rem10 >= 2 && rem10 <= 4) {
        return scheme.twoFour;
      }

      return scheme.other;
    }

    function declension(scheme, count, time) {
      var group = declensionGroup(scheme, count);
      var finalText = typeof group === 'string' ? group : group[time];
      return finalText.replace('{{count}}', String(count));
    }

    var formatDistance$5 = function (token, count, options) {
      var scheme = formatDistanceLocale$4[token];

      if (!(options !== null && options !== void 0 && options.addSuffix)) {
        return declension(scheme, count, 'regular');
      }

      if (options.comparison && options.comparison > 0) {
        return 'za ' + declension(scheme, count, 'future');
      } else {
        return declension(scheme, count, 'past') + ' temu';
      }
    };

    var dateFormats$4 = {
      full: 'EEEE, do MMMM y',
      long: 'do MMMM y',
      medium: 'do MMM y',
      short: 'dd.MM.y'
    };
    var timeFormats$4 = {
      full: 'HH:mm:ss zzzz',
      long: 'HH:mm:ss z',
      medium: 'HH:mm:ss',
      short: 'HH:mm'
    };
    var dateTimeFormats$4 = {
      full: '{{date}} {{time}}',
      long: '{{date}} {{time}}',
      medium: '{{date}}, {{time}}',
      short: '{{date}}, {{time}}'
    };
    var formatLong$5 = {
      date: buildFormatLongFn$1({
        formats: dateFormats$4,
        defaultWidth: 'full'
      }),
      time: buildFormatLongFn$1({
        formats: timeFormats$4,
        defaultWidth: 'full'
      }),
      dateTime: buildFormatLongFn$1({
        formats: dateTimeFormats$4,
        defaultWidth: 'full'
      })
    };

    var adjectivesLastWeek = {
      masculine: 'ostatni',
      feminine: 'ostatnia'
    };
    var adjectivesThisWeek = {
      masculine: 'ten',
      feminine: 'ta'
    };
    var adjectivesNextWeek = {
      masculine: 'następny',
      feminine: 'następna'
    };
    var dayGrammaticalGender = {
      0: 'feminine',
      1: 'masculine',
      2: 'masculine',
      3: 'feminine',
      4: 'masculine',
      5: 'masculine',
      6: 'feminine'
    };

    function dayAndTimeWithAdjective(token, date, baseDate, options) {
      var adjectives;

      if (isSameUTCWeek(date, baseDate, options)) {
        adjectives = adjectivesThisWeek;
      } else if (token === 'lastWeek') {
        adjectives = adjectivesLastWeek;
      } else if (token === 'nextWeek') {
        adjectives = adjectivesNextWeek;
      } else {
        throw new Error("Cannot determine adjectives for token ".concat(token));
      }

      var day = date.getUTCDay();
      var grammaticalGender = dayGrammaticalGender[day];
      var adjective = adjectives[grammaticalGender];
      return "'".concat(adjective, "' eeee 'o' p");
    }

    var formatRelativeLocale$4 = {
      lastWeek: dayAndTimeWithAdjective,
      yesterday: "'wczoraj o' p",
      today: "'dzisiaj o' p",
      tomorrow: "'jutro o' p",
      nextWeek: dayAndTimeWithAdjective,
      other: 'P'
    };

    var formatRelative$5 = function (token, date, baseDate, options) {
      var format = formatRelativeLocale$4[token];

      if (typeof format === 'function') {
        return format(token, date, baseDate, options);
      }

      return format;
    };

    var eraValues$4 = {
      narrow: ['p.n.e.', 'n.e.'],
      abbreviated: ['p.n.e.', 'n.e.'],
      wide: ['przed naszą erą', 'naszej ery']
    };
    var quarterValues$4 = {
      narrow: ['1', '2', '3', '4'],
      abbreviated: ['I kw.', 'II kw.', 'III kw.', 'IV kw.'],
      wide: ['I kwartał', 'II kwartał', 'III kwartał', 'IV kwartał']
    };
    var monthValues$4 = {
      narrow: ['S', 'L', 'M', 'K', 'M', 'C', 'L', 'S', 'W', 'P', 'L', 'G'],
      abbreviated: ['sty', 'lut', 'mar', 'kwi', 'maj', 'cze', 'lip', 'sie', 'wrz', 'paź', 'lis', 'gru'],
      wide: ['styczeń', 'luty', 'marzec', 'kwiecień', 'maj', 'czerwiec', 'lipiec', 'sierpień', 'wrzesień', 'październik', 'listopad', 'grudzień']
    };
    var monthFormattingValues = {
      narrow: ['s', 'l', 'm', 'k', 'm', 'c', 'l', 's', 'w', 'p', 'l', 'g'],
      abbreviated: ['sty', 'lut', 'mar', 'kwi', 'maj', 'cze', 'lip', 'sie', 'wrz', 'paź', 'lis', 'gru'],
      wide: ['stycznia', 'lutego', 'marca', 'kwietnia', 'maja', 'czerwca', 'lipca', 'sierpnia', 'września', 'października', 'listopada', 'grudnia']
    };
    var dayValues$4 = {
      narrow: ['N', 'P', 'W', 'Ś', 'C', 'P', 'S'],
      short: ['nie', 'pon', 'wto', 'śro', 'czw', 'pią', 'sob'],
      abbreviated: ['niedz.', 'pon.', 'wt.', 'śr.', 'czw.', 'pt.', 'sob.'],
      wide: ['niedziela', 'poniedziałek', 'wtorek', 'środa', 'czwartek', 'piątek', 'sobota']
    };
    var dayFormattingValues = {
      narrow: ['n', 'p', 'w', 'ś', 'c', 'p', 's'],
      short: ['nie', 'pon', 'wto', 'śro', 'czw', 'pią', 'sob'],
      abbreviated: ['niedz.', 'pon.', 'wt.', 'śr.', 'czw.', 'pt.', 'sob.'],
      wide: ['niedziela', 'poniedziałek', 'wtorek', 'środa', 'czwartek', 'piątek', 'sobota']
    };
    var dayPeriodValues$4 = {
      narrow: {
        am: 'a',
        pm: 'p',
        midnight: 'półn.',
        noon: 'poł',
        morning: 'rano',
        afternoon: 'popoł.',
        evening: 'wiecz.',
        night: 'noc'
      },
      abbreviated: {
        am: 'AM',
        pm: 'PM',
        midnight: 'północ',
        noon: 'południe',
        morning: 'rano',
        afternoon: 'popołudnie',
        evening: 'wieczór',
        night: 'noc'
      },
      wide: {
        am: 'AM',
        pm: 'PM',
        midnight: 'północ',
        noon: 'południe',
        morning: 'rano',
        afternoon: 'popołudnie',
        evening: 'wieczór',
        night: 'noc'
      }
    };
    var dayPeriodFormattingValues = {
      narrow: {
        am: 'a',
        pm: 'p',
        midnight: 'o półn.',
        noon: 'w poł.',
        morning: 'rano',
        afternoon: 'po poł.',
        evening: 'wiecz.',
        night: 'w nocy'
      },
      abbreviated: {
        am: 'AM',
        pm: 'PM',
        midnight: 'o północy',
        noon: 'w południe',
        morning: 'rano',
        afternoon: 'po południu',
        evening: 'wieczorem',
        night: 'w nocy'
      },
      wide: {
        am: 'AM',
        pm: 'PM',
        midnight: 'o północy',
        noon: 'w południe',
        morning: 'rano',
        afternoon: 'po południu',
        evening: 'wieczorem',
        night: 'w nocy'
      }
    };

    var ordinalNumber$4 = function (dirtyNumber, _options) {
      return String(dirtyNumber);
    };

    var localize$5 = {
      ordinalNumber: ordinalNumber$4,
      era: buildLocalizeFn$1({
        values: eraValues$4,
        defaultWidth: 'wide'
      }),
      quarter: buildLocalizeFn$1({
        values: quarterValues$4,
        defaultWidth: 'wide',
        argumentCallback: function (quarter) {
          return quarter - 1;
        }
      }),
      month: buildLocalizeFn$1({
        values: monthValues$4,
        defaultWidth: 'wide',
        formattingValues: monthFormattingValues,
        defaultFormattingWidth: 'wide'
      }),
      day: buildLocalizeFn$1({
        values: dayValues$4,
        defaultWidth: 'wide',
        formattingValues: dayFormattingValues,
        defaultFormattingWidth: 'wide'
      }),
      dayPeriod: buildLocalizeFn$1({
        values: dayPeriodValues$4,
        defaultWidth: 'wide',
        formattingValues: dayPeriodFormattingValues,
        defaultFormattingWidth: 'wide'
      })
    };

    var matchOrdinalNumberPattern$4 = /^(\d+)?/i;
    var parseOrdinalNumberPattern$4 = /\d+/i;
    var matchEraPatterns$4 = {
      narrow: /^(p\.?\s*n\.?\s*e\.?\s*|n\.?\s*e\.?\s*)/i,
      abbreviated: /^(p\.?\s*n\.?\s*e\.?\s*|n\.?\s*e\.?\s*)/i,
      wide: /^(przed\s*nasz(ą|a)\s*er(ą|a)|naszej\s*ery)/i
    };
    var parseEraPatterns$4 = {
      any: [/^p/i, /^n/i]
    };
    var matchQuarterPatterns$4 = {
      narrow: /^[1234]/i,
      abbreviated: /^(I|II|III|IV)\s*kw\.?/i,
      wide: /^(I|II|III|IV)\s*kwarta(ł|l)/i
    };
    var parseQuarterPatterns$4 = {
      narrow: [/1/i, /2/i, /3/i, /4/i],
      any: [/^I kw/i, /^II kw/i, /^III kw/i, /^IV kw/i]
    };
    var matchMonthPatterns$4 = {
      narrow: /^[slmkcwpg]/i,
      abbreviated: /^(sty|lut|mar|kwi|maj|cze|lip|sie|wrz|pa(ź|z)|lis|gru)/i,
      wide: /^(stycznia|stycze(ń|n)|lutego|luty|marca|marzec|kwietnia|kwiecie(ń|n)|maja|maj|czerwca|czerwiec|lipca|lipiec|sierpnia|sierpie(ń|n)|wrze(ś|s)nia|wrzesie(ń|n)|pa(ź|z)dziernika|pa(ź|z)dziernik|listopada|listopad|grudnia|grudzie(ń|n))/i
    };
    var parseMonthPatterns$4 = {
      narrow: [/^s/i, /^l/i, /^m/i, /^k/i, /^m/i, /^c/i, /^l/i, /^s/i, /^w/i, /^p/i, /^l/i, /^g/i],
      any: [/^st/i, /^lu/i, /^mar/i, /^k/i, /^maj/i, /^c/i, /^lip/i, /^si/i, /^w/i, /^p/i, /^lis/i, /^g/i]
    };
    var matchDayPatterns$4 = {
      narrow: /^[npwścs]/i,
      short: /^(nie|pon|wto|(ś|s)ro|czw|pi(ą|a)|sob)/i,
      abbreviated: /^(niedz|pon|wt|(ś|s)r|czw|pt|sob)\.?/i,
      wide: /^(niedziela|poniedzia(ł|l)ek|wtorek|(ś|s)roda|czwartek|pi(ą|a)tek|sobota)/i
    };
    var parseDayPatterns$4 = {
      narrow: [/^n/i, /^p/i, /^w/i, /^ś/i, /^c/i, /^p/i, /^s/i],
      abbreviated: [/^n/i, /^po/i, /^w/i, /^(ś|s)r/i, /^c/i, /^pt/i, /^so/i],
      any: [/^n/i, /^po/i, /^w/i, /^(ś|s)r/i, /^c/i, /^pi/i, /^so/i]
    };
    var matchDayPeriodPatterns$4 = {
      narrow: /^(^a$|^p$|pó(ł|l)n\.?|o\s*pó(ł|l)n\.?|po(ł|l)\.?|w\s*po(ł|l)\.?|po\s*po(ł|l)\.?|rano|wiecz\.?|noc|w\s*nocy)/i,
      any: /^(am|pm|pó(ł|l)noc|o\s*pó(ł|l)nocy|po(ł|l)udnie|w\s*po(ł|l)udnie|popo(ł|l)udnie|po\s*po(ł|l)udniu|rano|wieczór|wieczorem|noc|w\s*nocy)/i
    };
    var parseDayPeriodPatterns$4 = {
      narrow: {
        am: /^a$/i,
        pm: /^p$/i,
        midnight: /pó(ł|l)n/i,
        noon: /po(ł|l)/i,
        morning: /rano/i,
        afternoon: /po\s*po(ł|l)/i,
        evening: /wiecz/i,
        night: /noc/i
      },
      any: {
        am: /^am/i,
        pm: /^pm/i,
        midnight: /pó(ł|l)n/i,
        noon: /po(ł|l)/i,
        morning: /rano/i,
        afternoon: /po\s*po(ł|l)/i,
        evening: /wiecz/i,
        night: /noc/i
      }
    };
    var match$5 = {
      ordinalNumber: buildMatchPatternFn$1({
        matchPattern: matchOrdinalNumberPattern$4,
        parsePattern: parseOrdinalNumberPattern$4,
        valueCallback: function (value) {
          return parseInt(value, 10);
        }
      }),
      era: buildMatchFn$1({
        matchPatterns: matchEraPatterns$4,
        defaultMatchWidth: 'wide',
        parsePatterns: parseEraPatterns$4,
        defaultParseWidth: 'any'
      }),
      quarter: buildMatchFn$1({
        matchPatterns: matchQuarterPatterns$4,
        defaultMatchWidth: 'wide',
        parsePatterns: parseQuarterPatterns$4,
        defaultParseWidth: 'any',
        valueCallback: function (index) {
          return index + 1;
        }
      }),
      month: buildMatchFn$1({
        matchPatterns: matchMonthPatterns$4,
        defaultMatchWidth: 'wide',
        parsePatterns: parseMonthPatterns$4,
        defaultParseWidth: 'any'
      }),
      day: buildMatchFn$1({
        matchPatterns: matchDayPatterns$4,
        defaultMatchWidth: 'wide',
        parsePatterns: parseDayPatterns$4,
        defaultParseWidth: 'any'
      }),
      dayPeriod: buildMatchFn$1({
        matchPatterns: matchDayPeriodPatterns$4,
        defaultMatchWidth: 'any',
        parsePatterns: parseDayPeriodPatterns$4,
        defaultParseWidth: 'any'
      })
    };

    /**
     * @type {Locale}
     * @category Locales
     * @summary Polish locale.
     * @language Polish
     * @iso-639-2 pol
     * @author Mateusz Derks [@ertrzyiks]{@link https://github.com/ertrzyiks}
     * @author Just RAG [@justrag]{@link https://github.com/justrag}
     * @author Mikolaj Grzyb [@mikolajgrzyb]{@link https://github.com/mikolajgrzyb}
     * @author Mateusz Tokarski [@mutisz]{@link https://github.com/mutisz}
     */

    var locale$4 = {
      code: 'pl',
      formatDistance: formatDistance$5,
      formatLong: formatLong$5,
      formatRelative: formatRelative$5,
      localize: localize$5,
      match: match$5,
      options: {
        weekStartsOn: 1
        /* Monday */
        ,
        firstWeekContainsDate: 4
      }
    };

    const datePlPL = {
      name: "pl-PL",
      locale: locale$4
    };
    var datePlPL$1 = datePlPL;

    var formatDistanceLocale$3 = {
      lessThanXSeconds: {
        one: 'menos de um segundo',
        other: 'menos de {{count}} segundos'
      },
      xSeconds: {
        one: '1 segundo',
        other: '{{count}} segundos'
      },
      halfAMinute: 'meio minuto',
      lessThanXMinutes: {
        one: 'menos de um minuto',
        other: 'menos de {{count}} minutos'
      },
      xMinutes: {
        one: '1 minuto',
        other: '{{count}} minutos'
      },
      aboutXHours: {
        one: 'cerca de 1 hora',
        other: 'cerca de {{count}} horas'
      },
      xHours: {
        one: '1 hora',
        other: '{{count}} horas'
      },
      xDays: {
        one: '1 dia',
        other: '{{count}} dias'
      },
      aboutXWeeks: {
        one: 'cerca de 1 semana',
        other: 'cerca de {{count}} semanas'
      },
      xWeeks: {
        one: '1 semana',
        other: '{{count}} semanas'
      },
      aboutXMonths: {
        one: 'cerca de 1 mês',
        other: 'cerca de {{count}} meses'
      },
      xMonths: {
        one: '1 mês',
        other: '{{count}} meses'
      },
      aboutXYears: {
        one: 'cerca de 1 ano',
        other: 'cerca de {{count}} anos'
      },
      xYears: {
        one: '1 ano',
        other: '{{count}} anos'
      },
      overXYears: {
        one: 'mais de 1 ano',
        other: 'mais de {{count}} anos'
      },
      almostXYears: {
        one: 'quase 1 ano',
        other: 'quase {{count}} anos'
      }
    };

    var formatDistance$4 = function (token, count, options) {
      var result;
      var tokenValue = formatDistanceLocale$3[token];

      if (typeof tokenValue === 'string') {
        result = tokenValue;
      } else if (count === 1) {
        result = tokenValue.one;
      } else {
        result = tokenValue.other.replace('{{count}}', String(count));
      }

      if (options !== null && options !== void 0 && options.addSuffix) {
        if (options.comparison && options.comparison > 0) {
          return 'em ' + result;
        } else {
          return 'há ' + result;
        }
      }

      return result;
    };

    var dateFormats$3 = {
      full: "EEEE, d 'de' MMMM 'de' y",
      long: "d 'de' MMMM 'de' y",
      medium: 'd MMM y',
      short: 'dd/MM/yyyy'
    };
    var timeFormats$3 = {
      full: 'HH:mm:ss zzzz',
      long: 'HH:mm:ss z',
      medium: 'HH:mm:ss',
      short: 'HH:mm'
    };
    var dateTimeFormats$3 = {
      full: "{{date}} 'às' {{time}}",
      long: "{{date}} 'às' {{time}}",
      medium: '{{date}}, {{time}}',
      short: '{{date}}, {{time}}'
    };
    var formatLong$4 = {
      date: buildFormatLongFn$1({
        formats: dateFormats$3,
        defaultWidth: 'full'
      }),
      time: buildFormatLongFn$1({
        formats: timeFormats$3,
        defaultWidth: 'full'
      }),
      dateTime: buildFormatLongFn$1({
        formats: dateTimeFormats$3,
        defaultWidth: 'full'
      })
    };

    var formatRelativeLocale$3 = {
      lastWeek: function (date) {
        var weekday = date.getUTCDay();
        var last = weekday === 0 || weekday === 6 ? 'último' : 'última';
        return "'" + last + "' eeee 'às' p";
      },
      yesterday: "'ontem às' p",
      today: "'hoje às' p",
      tomorrow: "'amanhã às' p",
      nextWeek: "eeee 'às' p",
      other: 'P'
    };

    var formatRelative$4 = function (token, date, _baseDate, _options) {
      var format = formatRelativeLocale$3[token];

      if (typeof format === 'function') {
        return format(date);
      }

      return format;
    };

    var eraValues$3 = {
      narrow: ['AC', 'DC'],
      abbreviated: ['AC', 'DC'],
      wide: ['antes de cristo', 'depois de cristo']
    };
    var quarterValues$3 = {
      narrow: ['1', '2', '3', '4'],
      abbreviated: ['T1', 'T2', 'T3', 'T4'],
      wide: ['1º trimestre', '2º trimestre', '3º trimestre', '4º trimestre']
    };
    var monthValues$3 = {
      narrow: ['j', 'f', 'm', 'a', 'm', 'j', 'j', 'a', 's', 'o', 'n', 'd'],
      abbreviated: ['jan', 'fev', 'mar', 'abr', 'mai', 'jun', 'jul', 'ago', 'set', 'out', 'nov', 'dez'],
      wide: ['janeiro', 'fevereiro', 'março', 'abril', 'maio', 'junho', 'julho', 'agosto', 'setembro', 'outubro', 'novembro', 'dezembro']
    };
    var dayValues$3 = {
      narrow: ['D', 'S', 'T', 'Q', 'Q', 'S', 'S'],
      short: ['dom', 'seg', 'ter', 'qua', 'qui', 'sex', 'sab'],
      abbreviated: ['domingo', 'segunda', 'terça', 'quarta', 'quinta', 'sexta', 'sábado'],
      wide: ['domingo', 'segunda-feira', 'terça-feira', 'quarta-feira', 'quinta-feira', 'sexta-feira', 'sábado']
    };
    var dayPeriodValues$3 = {
      narrow: {
        am: 'a',
        pm: 'p',
        midnight: 'mn',
        noon: 'md',
        morning: 'manhã',
        afternoon: 'tarde',
        evening: 'tarde',
        night: 'noite'
      },
      abbreviated: {
        am: 'AM',
        pm: 'PM',
        midnight: 'meia-noite',
        noon: 'meio-dia',
        morning: 'manhã',
        afternoon: 'tarde',
        evening: 'tarde',
        night: 'noite'
      },
      wide: {
        am: 'a.m.',
        pm: 'p.m.',
        midnight: 'meia-noite',
        noon: 'meio-dia',
        morning: 'manhã',
        afternoon: 'tarde',
        evening: 'tarde',
        night: 'noite'
      }
    };
    var formattingDayPeriodValues$2 = {
      narrow: {
        am: 'a',
        pm: 'p',
        midnight: 'mn',
        noon: 'md',
        morning: 'da manhã',
        afternoon: 'da tarde',
        evening: 'da tarde',
        night: 'da noite'
      },
      abbreviated: {
        am: 'AM',
        pm: 'PM',
        midnight: 'meia-noite',
        noon: 'meio-dia',
        morning: 'da manhã',
        afternoon: 'da tarde',
        evening: 'da tarde',
        night: 'da noite'
      },
      wide: {
        am: 'a.m.',
        pm: 'p.m.',
        midnight: 'meia-noite',
        noon: 'meio-dia',
        morning: 'da manhã',
        afternoon: 'da tarde',
        evening: 'da tarde',
        night: 'da noite'
      }
    };

    var ordinalNumber$3 = function (dirtyNumber, options) {
      var number = Number(dirtyNumber);

      if ((options === null || options === void 0 ? void 0 : options.unit) === 'week') {
        return number + 'ª';
      }

      return number + 'º';
    };

    var localize$4 = {
      ordinalNumber: ordinalNumber$3,
      era: buildLocalizeFn$1({
        values: eraValues$3,
        defaultWidth: 'wide'
      }),
      quarter: buildLocalizeFn$1({
        values: quarterValues$3,
        defaultWidth: 'wide',
        argumentCallback: function (quarter) {
          return quarter - 1;
        }
      }),
      month: buildLocalizeFn$1({
        values: monthValues$3,
        defaultWidth: 'wide'
      }),
      day: buildLocalizeFn$1({
        values: dayValues$3,
        defaultWidth: 'wide'
      }),
      dayPeriod: buildLocalizeFn$1({
        values: dayPeriodValues$3,
        defaultWidth: 'wide',
        formattingValues: formattingDayPeriodValues$2,
        defaultFormattingWidth: 'wide'
      })
    };

    var matchOrdinalNumberPattern$3 = /^(\d+)[ºªo]?/i;
    var parseOrdinalNumberPattern$3 = /\d+/i;
    var matchEraPatterns$3 = {
      narrow: /^(ac|dc|a|d)/i,
      abbreviated: /^(a\.?\s?c\.?|d\.?\s?c\.?)/i,
      wide: /^(antes de cristo|depois de cristo)/i
    };
    var parseEraPatterns$3 = {
      any: [/^ac/i, /^dc/i],
      wide: [/^antes de cristo/i, /^depois de cristo/i]
    };
    var matchQuarterPatterns$3 = {
      narrow: /^[1234]/i,
      abbreviated: /^T[1234]/i,
      wide: /^[1234](º)? trimestre/i
    };
    var parseQuarterPatterns$3 = {
      any: [/1/i, /2/i, /3/i, /4/i]
    };
    var matchMonthPatterns$3 = {
      narrow: /^[jfmajsond]/i,
      abbreviated: /^(jan|fev|mar|abr|mai|jun|jul|ago|set|out|nov|dez)/i,
      wide: /^(janeiro|fevereiro|março|abril|maio|junho|julho|agosto|setembro|outubro|novembro|dezembro)/i
    };
    var parseMonthPatterns$3 = {
      narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
      any: [/^ja/i, /^fev/i, /^mar/i, /^abr/i, /^mai/i, /^jun/i, /^jul/i, /^ago/i, /^set/i, /^out/i, /^nov/i, /^dez/i]
    };
    var matchDayPatterns$3 = {
      narrow: /^(dom|[23456]ª?|s[aá]b)/i,
      short: /^(dom|[23456]ª?|s[aá]b)/i,
      abbreviated: /^(dom|seg|ter|qua|qui|sex|s[aá]b)/i,
      wide: /^(domingo|(segunda|ter[cç]a|quarta|quinta|sexta)([- ]feira)?|s[aá]bado)/i
    };
    var parseDayPatterns$3 = {
      short: [/^d/i, /^2/i, /^3/i, /^4/i, /^5/i, /^6/i, /^s[aá]/i],
      narrow: [/^d/i, /^2/i, /^3/i, /^4/i, /^5/i, /^6/i, /^s[aá]/i],
      any: [/^d/i, /^seg/i, /^t/i, /^qua/i, /^qui/i, /^sex/i, /^s[aá]b/i]
    };
    var matchDayPeriodPatterns$3 = {
      narrow: /^(a|p|mn|md|(da) (manhã|tarde|noite))/i,
      any: /^([ap]\.?\s?m\.?|meia[-\s]noite|meio[-\s]dia|(da) (manhã|tarde|noite))/i
    };
    var parseDayPeriodPatterns$3 = {
      any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^mn|^meia[-\s]noite/i,
        noon: /^md|^meio[-\s]dia/i,
        morning: /manhã/i,
        afternoon: /tarde/i,
        evening: /tarde/i,
        night: /noite/i
      }
    };
    var match$4 = {
      ordinalNumber: buildMatchPatternFn$1({
        matchPattern: matchOrdinalNumberPattern$3,
        parsePattern: parseOrdinalNumberPattern$3,
        valueCallback: function (value) {
          return parseInt(value, 10);
        }
      }),
      era: buildMatchFn$1({
        matchPatterns: matchEraPatterns$3,
        defaultMatchWidth: 'wide',
        parsePatterns: parseEraPatterns$3,
        defaultParseWidth: 'any'
      }),
      quarter: buildMatchFn$1({
        matchPatterns: matchQuarterPatterns$3,
        defaultMatchWidth: 'wide',
        parsePatterns: parseQuarterPatterns$3,
        defaultParseWidth: 'any',
        valueCallback: function (index) {
          return index + 1;
        }
      }),
      month: buildMatchFn$1({
        matchPatterns: matchMonthPatterns$3,
        defaultMatchWidth: 'wide',
        parsePatterns: parseMonthPatterns$3,
        defaultParseWidth: 'any'
      }),
      day: buildMatchFn$1({
        matchPatterns: matchDayPatterns$3,
        defaultMatchWidth: 'wide',
        parsePatterns: parseDayPatterns$3,
        defaultParseWidth: 'any'
      }),
      dayPeriod: buildMatchFn$1({
        matchPatterns: matchDayPeriodPatterns$3,
        defaultMatchWidth: 'any',
        parsePatterns: parseDayPeriodPatterns$3,
        defaultParseWidth: 'any'
      })
    };

    /**
     * @type {Locale}
     * @category Locales
     * @summary Portuguese locale (Brazil).
     * @language Portuguese
     * @iso-639-2 por
     * @author Lucas Duailibe [@duailibe]{@link https://github.com/duailibe}
     * @author Yago Carballo [@yagocarballo]{@link https://github.com/YagoCarballo}
     */

    var locale$3 = {
      code: 'pt-BR',
      formatDistance: formatDistance$4,
      formatLong: formatLong$4,
      formatRelative: formatRelative$4,
      localize: localize$4,
      match: match$4,
      options: {
        weekStartsOn: 0
        /* Sunday */
        ,
        firstWeekContainsDate: 1
      }
    };

    const datePtBr = {
      name: "pt-BR",
      locale: locale$3
    };
    var datePtBr$1 = datePtBr;

    var formatDistanceLocale$2 = {
      lessThanXSeconds: {
        one: 'น้อยกว่า 1 วินาที',
        other: 'น้อยกว่า {{count}} วินาที'
      },
      xSeconds: {
        one: '1 วินาที',
        other: '{{count}} วินาที'
      },
      halfAMinute: 'ครึ่งนาที',
      lessThanXMinutes: {
        one: 'น้อยกว่า 1 นาที',
        other: 'น้อยกว่า {{count}} นาที'
      },
      xMinutes: {
        one: '1 นาที',
        other: '{{count}} นาที'
      },
      aboutXHours: {
        one: 'ประมาณ 1 ชั่วโมง',
        other: 'ประมาณ {{count}} ชั่วโมง'
      },
      xHours: {
        one: '1 ชั่วโมง',
        other: '{{count}} ชั่วโมง'
      },
      xDays: {
        one: '1 วัน',
        other: '{{count}} วัน'
      },
      aboutXWeeks: {
        one: 'ประมาณ 1 สัปดาห์',
        other: 'ประมาณ {{count}} สัปดาห์'
      },
      xWeeks: {
        one: '1 สัปดาห์',
        other: '{{count}} สัปดาห์'
      },
      aboutXMonths: {
        one: 'ประมาณ 1 เดือน',
        other: 'ประมาณ {{count}} เดือน'
      },
      xMonths: {
        one: '1 เดือน',
        other: '{{count}} เดือน'
      },
      aboutXYears: {
        one: 'ประมาณ 1 ปี',
        other: 'ประมาณ {{count}} ปี'
      },
      xYears: {
        one: '1 ปี',
        other: '{{count}} ปี'
      },
      overXYears: {
        one: 'มากกว่า 1 ปี',
        other: 'มากกว่า {{count}} ปี'
      },
      almostXYears: {
        one: 'เกือบ 1 ปี',
        other: 'เกือบ {{count}} ปี'
      }
    };

    var formatDistance$3 = function (token, count, options) {
      var result;
      var tokenValue = formatDistanceLocale$2[token];

      if (typeof tokenValue === 'string') {
        result = tokenValue;
      } else if (count === 1) {
        result = tokenValue.one;
      } else {
        result = tokenValue.other.replace('{{count}}', String(count));
      }

      if (options !== null && options !== void 0 && options.addSuffix) {
        if (options.comparison && options.comparison > 0) {
          if (token === 'halfAMinute') {
            return 'ใน' + result;
          } else {
            return 'ใน ' + result;
          }
        } else {
          return result + 'ที่ผ่านมา';
        }
      }

      return result;
    };

    var dateFormats$2 = {
      full: 'วันEEEEที่ do MMMM y',
      long: 'do MMMM y',
      medium: 'd MMM y',
      short: 'dd/MM/yyyy'
    };
    var timeFormats$2 = {
      full: 'H:mm:ss น. zzzz',
      long: 'H:mm:ss น. z',
      medium: 'H:mm:ss น.',
      short: 'H:mm น.'
    };
    var dateTimeFormats$2 = {
      full: "{{date}} 'เวลา' {{time}}",
      long: "{{date}} 'เวลา' {{time}}",
      medium: '{{date}}, {{time}}',
      short: '{{date}}, {{time}}'
    };
    var formatLong$3 = {
      date: buildFormatLongFn$1({
        formats: dateFormats$2,
        defaultWidth: 'full'
      }),
      time: buildFormatLongFn$1({
        formats: timeFormats$2,
        defaultWidth: 'medium'
      }),
      dateTime: buildFormatLongFn$1({
        formats: dateTimeFormats$2,
        defaultWidth: 'full'
      })
    };

    var formatRelativeLocale$2 = {
      lastWeek: "eeee'ที่แล้วเวลา' p",
      yesterday: "'เมื่อวานนี้เวลา' p",
      today: "'วันนี้เวลา' p",
      tomorrow: "'พรุ่งนี้เวลา' p",
      nextWeek: "eeee 'เวลา' p",
      other: 'P'
    };

    var formatRelative$3 = function (token, _date, _baseDate, _options) {
      return formatRelativeLocale$2[token];
    };

    var eraValues$2 = {
      narrow: ['B', 'คศ'],
      abbreviated: ['BC', 'ค.ศ.'],
      wide: ['ปีก่อนคริสตกาล', 'คริสต์ศักราช']
    };
    var quarterValues$2 = {
      narrow: ['1', '2', '3', '4'],
      abbreviated: ['Q1', 'Q2', 'Q3', 'Q4'],
      wide: ['ไตรมาสแรก', 'ไตรมาสที่สอง', 'ไตรมาสที่สาม', 'ไตรมาสที่สี่']
    };
    var dayValues$2 = {
      narrow: ['อา.', 'จ.', 'อ.', 'พ.', 'พฤ.', 'ศ.', 'ส.'],
      short: ['อา.', 'จ.', 'อ.', 'พ.', 'พฤ.', 'ศ.', 'ส.'],
      abbreviated: ['อา.', 'จ.', 'อ.', 'พ.', 'พฤ.', 'ศ.', 'ส.'],
      wide: ['อาทิตย์', 'จันทร์', 'อังคาร', 'พุธ', 'พฤหัสบดี', 'ศุกร์', 'เสาร์']
    };
    var monthValues$2 = {
      narrow: ['ม.ค.', 'ก.พ.', 'มี.ค.', 'เม.ย.', 'พ.ค.', 'มิ.ย.', 'ก.ค.', 'ส.ค.', 'ก.ย.', 'ต.ค.', 'พ.ย.', 'ธ.ค.'],
      abbreviated: ['ม.ค.', 'ก.พ.', 'มี.ค.', 'เม.ย.', 'พ.ค.', 'มิ.ย.', 'ก.ค.', 'ส.ค.', 'ก.ย.', 'ต.ค.', 'พ.ย.', 'ธ.ค.'],
      wide: ['มกราคม', 'กุมภาพันธ์', 'มีนาคม', 'เมษายน', 'พฤษภาคม', 'มิถุนายน', 'กรกฎาคม', 'สิงหาคม', 'กันยายน', 'ตุลาคม', 'พฤศจิกายน', 'ธันวาคม']
    };
    var dayPeriodValues$2 = {
      narrow: {
        am: 'ก่อนเที่ยง',
        pm: 'หลังเที่ยง',
        midnight: 'เที่ยงคืน',
        noon: 'เที่ยง',
        morning: 'เช้า',
        afternoon: 'บ่าย',
        evening: 'เย็น',
        night: 'กลางคืน'
      },
      abbreviated: {
        am: 'ก่อนเที่ยง',
        pm: 'หลังเที่ยง',
        midnight: 'เที่ยงคืน',
        noon: 'เที่ยง',
        morning: 'เช้า',
        afternoon: 'บ่าย',
        evening: 'เย็น',
        night: 'กลางคืน'
      },
      wide: {
        am: 'ก่อนเที่ยง',
        pm: 'หลังเที่ยง',
        midnight: 'เที่ยงคืน',
        noon: 'เที่ยง',
        morning: 'เช้า',
        afternoon: 'บ่าย',
        evening: 'เย็น',
        night: 'กลางคืน'
      }
    };
    var formattingDayPeriodValues$1 = {
      narrow: {
        am: 'ก่อนเที่ยง',
        pm: 'หลังเที่ยง',
        midnight: 'เที่ยงคืน',
        noon: 'เที่ยง',
        morning: 'ตอนเช้า',
        afternoon: 'ตอนกลางวัน',
        evening: 'ตอนเย็น',
        night: 'ตอนกลางคืน'
      },
      abbreviated: {
        am: 'ก่อนเที่ยง',
        pm: 'หลังเที่ยง',
        midnight: 'เที่ยงคืน',
        noon: 'เที่ยง',
        morning: 'ตอนเช้า',
        afternoon: 'ตอนกลางวัน',
        evening: 'ตอนเย็น',
        night: 'ตอนกลางคืน'
      },
      wide: {
        am: 'ก่อนเที่ยง',
        pm: 'หลังเที่ยง',
        midnight: 'เที่ยงคืน',
        noon: 'เที่ยง',
        morning: 'ตอนเช้า',
        afternoon: 'ตอนกลางวัน',
        evening: 'ตอนเย็น',
        night: 'ตอนกลางคืน'
      }
    };

    var ordinalNumber$2 = function (dirtyNumber, _options) {
      return String(dirtyNumber);
    };

    var localize$3 = {
      ordinalNumber: ordinalNumber$2,
      era: buildLocalizeFn$1({
        values: eraValues$2,
        defaultWidth: 'wide'
      }),
      quarter: buildLocalizeFn$1({
        values: quarterValues$2,
        defaultWidth: 'wide',
        argumentCallback: function (quarter) {
          return quarter - 1;
        }
      }),
      month: buildLocalizeFn$1({
        values: monthValues$2,
        defaultWidth: 'wide'
      }),
      day: buildLocalizeFn$1({
        values: dayValues$2,
        defaultWidth: 'wide'
      }),
      dayPeriod: buildLocalizeFn$1({
        values: dayPeriodValues$2,
        defaultWidth: 'wide',
        formattingValues: formattingDayPeriodValues$1,
        defaultFormattingWidth: 'wide'
      })
    };

    var matchOrdinalNumberPattern$2 = /^\d+/i;
    var parseOrdinalNumberPattern$2 = /\d+/i;
    var matchEraPatterns$2 = {
      narrow: /^([bB]|[aA]|คศ)/i,
      abbreviated: /^([bB]\.?\s?[cC]\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?|ค\.?ศ\.?)/i,
      wide: /^(ก่อนคริสตกาล|คริสต์ศักราช|คริสตกาล)/i
    };
    var parseEraPatterns$2 = {
      any: [/^[bB]/i, /^(^[aA]|ค\.?ศ\.?|คริสตกาล|คริสต์ศักราช|)/i]
    };
    var matchQuarterPatterns$2 = {
      narrow: /^[1234]/i,
      abbreviated: /^q[1234]/i,
      wide: /^ไตรมาส(ที่)? ?[1234]/i
    };
    var parseQuarterPatterns$2 = {
      any: [/(1|แรก|หนึ่ง)/i, /(2|สอง)/i, /(3|สาม)/i, /(4|สี่)/i]
    };
    var matchMonthPatterns$2 = {
      narrow: /^(ม\.?ค\.?|ก\.?พ\.?|มี\.?ค\.?|เม\.?ย\.?|พ\.?ค\.?|มิ\.?ย\.?|ก\.?ค\.?|ส\.?ค\.?|ก\.?ย\.?|ต\.?ค\.?|พ\.?ย\.?|ธ\.?ค\.?)/i,
      abbreviated: /^(ม\.?ค\.?|ก\.?พ\.?|มี\.?ค\.?|เม\.?ย\.?|พ\.?ค\.?|มิ\.?ย\.?|ก\.?ค\.?|ส\.?ค\.?|ก\.?ย\.?|ต\.?ค\.?|พ\.?ย\.?|ธ\.?ค\.?')/i,
      wide: /^(มกราคม|กุมภาพันธ์|มีนาคม|เมษายน|พฤษภาคม|มิถุนายน|กรกฎาคม|สิงหาคม|กันยายน|ตุลาคม|พฤศจิกายน|ธันวาคม)/i
    };
    var parseMonthPatterns$2 = {
      wide: [/^มก/i, /^กุม/i, /^มี/i, /^เม/i, /^พฤษ/i, /^มิ/i, /^กรก/i, /^ส/i, /^กัน/i, /^ต/i, /^พฤศ/i, /^ธ/i],
      any: [/^ม\.?ค\.?/i, /^ก\.?พ\.?/i, /^มี\.?ค\.?/i, /^เม\.?ย\.?/i, /^พ\.?ค\.?/i, /^มิ\.?ย\.?/i, /^ก\.?ค\.?/i, /^ส\.?ค\.?/i, /^ก\.?ย\.?/i, /^ต\.?ค\.?/i, /^พ\.?ย\.?/i, /^ธ\.?ค\.?/i]
    };
    var matchDayPatterns$2 = {
      narrow: /^(อา\.?|จ\.?|อ\.?|พฤ\.?|พ\.?|ศ\.?|ส\.?)/i,
      short: /^(อา\.?|จ\.?|อ\.?|พฤ\.?|พ\.?|ศ\.?|ส\.?)/i,
      abbreviated: /^(อา\.?|จ\.?|อ\.?|พฤ\.?|พ\.?|ศ\.?|ส\.?)/i,
      wide: /^(อาทิตย์|จันทร์|อังคาร|พุธ|พฤหัสบดี|ศุกร์|เสาร์)/i
    };
    var parseDayPatterns$2 = {
      wide: [/^อา/i, /^จั/i, /^อั/i, /^พุธ/i, /^พฤ/i, /^ศ/i, /^เส/i],
      any: [/^อา/i, /^จ/i, /^อ/i, /^พ(?!ฤ)/i, /^พฤ/i, /^ศ/i, /^ส/i]
    };
    var matchDayPeriodPatterns$2 = {
      any: /^(ก่อนเที่ยง|หลังเที่ยง|เที่ยงคืน|เที่ยง|(ตอน.*?)?.*(เที่ยง|เช้า|บ่าย|เย็น|กลางคืน))/i
    };
    var parseDayPeriodPatterns$2 = {
      any: {
        am: /^ก่อนเที่ยง/i,
        pm: /^หลังเที่ยง/i,
        midnight: /^เที่ยงคืน/i,
        noon: /^เที่ยง/i,
        morning: /เช้า/i,
        afternoon: /บ่าย/i,
        evening: /เย็น/i,
        night: /กลางคืน/i
      }
    };
    var match$3 = {
      ordinalNumber: buildMatchPatternFn$1({
        matchPattern: matchOrdinalNumberPattern$2,
        parsePattern: parseOrdinalNumberPattern$2,
        valueCallback: function (value) {
          return parseInt(value, 10);
        }
      }),
      era: buildMatchFn$1({
        matchPatterns: matchEraPatterns$2,
        defaultMatchWidth: 'wide',
        parsePatterns: parseEraPatterns$2,
        defaultParseWidth: 'any'
      }),
      quarter: buildMatchFn$1({
        matchPatterns: matchQuarterPatterns$2,
        defaultMatchWidth: 'wide',
        parsePatterns: parseQuarterPatterns$2,
        defaultParseWidth: 'any',
        valueCallback: function (index) {
          return index + 1;
        }
      }),
      month: buildMatchFn$1({
        matchPatterns: matchMonthPatterns$2,
        defaultMatchWidth: 'wide',
        parsePatterns: parseMonthPatterns$2,
        defaultParseWidth: 'any'
      }),
      day: buildMatchFn$1({
        matchPatterns: matchDayPatterns$2,
        defaultMatchWidth: 'wide',
        parsePatterns: parseDayPatterns$2,
        defaultParseWidth: 'any'
      }),
      dayPeriod: buildMatchFn$1({
        matchPatterns: matchDayPeriodPatterns$2,
        defaultMatchWidth: 'any',
        parsePatterns: parseDayPeriodPatterns$2,
        defaultParseWidth: 'any'
      })
    };

    /**
     * @type {Locale}
     * @category Locales
     * @summary Thai locale.
     * @language Thai
     * @iso-639-2 tha
     * @author Athiwat Hirunworawongkun [@athivvat]{@link https://github.com/athivvat}
     * @author [@hawkup]{@link https://github.com/hawkup}
     * @author  Jirawat I. [@nodtem66]{@link https://github.com/nodtem66}
     */

    var locale$2 = {
      code: 'th',
      formatDistance: formatDistance$3,
      formatLong: formatLong$3,
      formatRelative: formatRelative$3,
      localize: localize$3,
      match: match$3,
      options: {
        weekStartsOn: 0
        /* Sunday */
        ,
        firstWeekContainsDate: 1
      }
    };

    const dateThTH = {
      name: "thTH",
      locale: locale$2
    };
    var dateThTH$1 = dateThTH;

    var formatDistanceLocale$1 = {
      lessThanXSeconds: {
        one: 'malpli ol sekundo',
        other: 'malpli ol {{count}} sekundoj'
      },
      xSeconds: {
        one: '1 sekundo',
        other: '{{count}} sekundoj'
      },
      halfAMinute: 'duonminuto',
      lessThanXMinutes: {
        one: 'malpli ol minuto',
        other: 'malpli ol {{count}} minutoj'
      },
      xMinutes: {
        one: '1 minuto',
        other: '{{count}} minutoj'
      },
      aboutXHours: {
        one: 'proksimume 1 horo',
        other: 'proksimume {{count}} horoj'
      },
      xHours: {
        one: '1 horo',
        other: '{{count}} horoj'
      },
      xDays: {
        one: '1 tago',
        other: '{{count}} tagoj'
      },
      aboutXMonths: {
        one: 'proksimume 1 monato',
        other: 'proksimume {{count}} monatoj'
      },
      xWeeks: {
        one: '1 semajno',
        other: '{{count}} semajnoj'
      },
      aboutXWeeks: {
        one: 'proksimume 1 semajno',
        other: 'proksimume {{count}} semajnoj'
      },
      xMonths: {
        one: '1 monato',
        other: '{{count}} monatoj'
      },
      aboutXYears: {
        one: 'proksimume 1 jaro',
        other: 'proksimume {{count}} jaroj'
      },
      xYears: {
        one: '1 jaro',
        other: '{{count}} jaroj'
      },
      overXYears: {
        one: 'pli ol 1 jaro',
        other: 'pli ol {{count}} jaroj'
      },
      almostXYears: {
        one: 'preskaŭ 1 jaro',
        other: 'preskaŭ {{count}} jaroj'
      }
    };

    var formatDistance$2 = function (token, count, options) {
      var result;
      var tokenValue = formatDistanceLocale$1[token];

      if (typeof tokenValue === 'string') {
        result = tokenValue;
      } else if (count === 1) {
        result = tokenValue.one;
      } else {
        result = tokenValue.other.replace('{{count}}', String(count));
      }

      if (options !== null && options !== void 0 && options.addSuffix) {
        if (options !== null && options !== void 0 && options.comparison && options.comparison > 0) {
          return 'post ' + result;
        } else {
          return 'antaŭ ' + result;
        }
      }

      return result;
    };

    var dateFormats$1 = {
      full: "EEEE, do 'de' MMMM y",
      long: 'y-MMMM-dd',
      medium: 'y-MMM-dd',
      short: 'yyyy-MM-dd'
    };
    var timeFormats$1 = {
      full: "Ho 'horo kaj' m:ss zzzz",
      long: 'HH:mm:ss z',
      medium: 'HH:mm:ss',
      short: 'HH:mm'
    };
    var dateTimeFormats$1 = {
      any: '{{date}} {{time}}'
    };
    var formatLong$2 = {
      date: buildFormatLongFn$1({
        formats: dateFormats$1,
        defaultWidth: 'full'
      }),
      time: buildFormatLongFn$1({
        formats: timeFormats$1,
        defaultWidth: 'full'
      }),
      dateTime: buildFormatLongFn$1({
        formats: dateTimeFormats$1,
        defaultWidth: 'any'
      })
    };

    var formatRelativeLocale$1 = {
      lastWeek: "'pasinta' eeee 'je' p",
      yesterday: "'hieraŭ je' p",
      today: "'hodiaŭ je' p",
      tomorrow: "'morgaŭ je' p",
      nextWeek: "eeee 'je' p",
      other: 'P'
    };

    var formatRelative$2 = function (token, _date, _baseDate, _options) {
      return formatRelativeLocale$1[token];
    };

    var eraValues$1 = {
      narrow: ['aK', 'pK'],
      abbreviated: ['a.K.E.', 'p.K.E.'],
      wide: ['antaŭ Komuna Erao', 'Komuna Erao']
    };
    var quarterValues$1 = {
      narrow: ['1', '2', '3', '4'],
      abbreviated: ['K1', 'K2', 'K3', 'K4'],
      wide: ['1-a kvaronjaro', '2-a kvaronjaro', '3-a kvaronjaro', '4-a kvaronjaro']
    };
    var monthValues$1 = {
      narrow: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
      abbreviated: ['jan', 'feb', 'mar', 'apr', 'maj', 'jun', 'jul', 'aŭg', 'sep', 'okt', 'nov', 'dec'],
      wide: ['januaro', 'februaro', 'marto', 'aprilo', 'majo', 'junio', 'julio', 'aŭgusto', 'septembro', 'oktobro', 'novembro', 'decembro']
    };
    var dayValues$1 = {
      narrow: ['D', 'L', 'M', 'M', 'Ĵ', 'V', 'S'],
      short: ['di', 'lu', 'ma', 'me', 'ĵa', 've', 'sa'],
      abbreviated: ['dim', 'lun', 'mar', 'mer', 'ĵaŭ', 'ven', 'sab'],
      wide: ['dimanĉo', 'lundo', 'mardo', 'merkredo', 'ĵaŭdo', 'vendredo', 'sabato']
    };
    var dayPeriodValues$1 = {
      narrow: {
        am: 'a',
        pm: 'p',
        midnight: 'noktomezo',
        noon: 'tagmezo',
        morning: 'matene',
        afternoon: 'posttagmeze',
        evening: 'vespere',
        night: 'nokte'
      },
      abbreviated: {
        am: 'a.t.m.',
        pm: 'p.t.m.',
        midnight: 'noktomezo',
        noon: 'tagmezo',
        morning: 'matene',
        afternoon: 'posttagmeze',
        evening: 'vespere',
        night: 'nokte'
      },
      wide: {
        am: 'antaŭtagmeze',
        pm: 'posttagmeze',
        midnight: 'noktomezo',
        noon: 'tagmezo',
        morning: 'matene',
        afternoon: 'posttagmeze',
        evening: 'vespere',
        night: 'nokte'
      }
    };

    var ordinalNumber$1 = function (dirtyNumber) {
      var number = Number(dirtyNumber);
      return number + '-a';
    };

    var localize$2 = {
      ordinalNumber: ordinalNumber$1,
      era: buildLocalizeFn$1({
        values: eraValues$1,
        defaultWidth: 'wide'
      }),
      quarter: buildLocalizeFn$1({
        values: quarterValues$1,
        defaultWidth: 'wide',
        argumentCallback: function (quarter) {
          return Number(quarter) - 1;
        }
      }),
      month: buildLocalizeFn$1({
        values: monthValues$1,
        defaultWidth: 'wide'
      }),
      day: buildLocalizeFn$1({
        values: dayValues$1,
        defaultWidth: 'wide'
      }),
      dayPeriod: buildLocalizeFn$1({
        values: dayPeriodValues$1,
        defaultWidth: 'wide'
      })
    };

    var matchOrdinalNumberPattern$1 = /^(\d+)(-?a)?/i;
    var parseOrdinalNumberPattern$1 = /\d+/i;
    var matchEraPatterns$1 = {
      narrow: /^([ap]k)/i,
      abbreviated: /^([ap]\.?\s?k\.?\s?e\.?)/i,
      wide: /^((antaǔ |post )?komuna erao)/i
    };
    var parseEraPatterns$1 = {
      any: [/^a/i, /^[kp]/i]
    };
    var matchQuarterPatterns$1 = {
      narrow: /^[1234]/i,
      abbreviated: /^k[1234]/i,
      wide: /^[1234](-?a)? kvaronjaro/i
    };
    var parseQuarterPatterns$1 = {
      any: [/1/i, /2/i, /3/i, /4/i]
    };
    var matchMonthPatterns$1 = {
      narrow: /^[jfmasond]/i,
      abbreviated: /^(jan|feb|mar|apr|maj|jun|jul|a(ŭ|ux|uh|u)g|sep|okt|nov|dec)/i,
      wide: /^(januaro|februaro|marto|aprilo|majo|junio|julio|a(ŭ|ux|uh|u)gusto|septembro|oktobro|novembro|decembro)/i
    };
    var parseMonthPatterns$1 = {
      narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
      any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^maj/i, /^jun/i, /^jul/i, /^a(u|ŭ)/i, /^s/i, /^o/i, /^n/i, /^d/i]
    };
    var matchDayPatterns$1 = {
      narrow: /^[dlmĵjvs]/i,
      short: /^(di|lu|ma|me|(ĵ|jx|jh|j)a|ve|sa)/i,
      abbreviated: /^(dim|lun|mar|mer|(ĵ|jx|jh|j)a(ŭ|ux|uh|u)|ven|sab)/i,
      wide: /^(diman(ĉ|cx|ch|c)o|lundo|mardo|merkredo|(ĵ|jx|jh|j)a(ŭ|ux|uh|u)do|vendredo|sabato)/i
    };
    var parseDayPatterns$1 = {
      narrow: [/^d/i, /^l/i, /^m/i, /^m/i, /^(j|ĵ)/i, /^v/i, /^s/i],
      any: [/^d/i, /^l/i, /^ma/i, /^me/i, /^(j|ĵ)/i, /^v/i, /^s/i]
    };
    var matchDayPeriodPatterns$1 = {
      narrow: /^([ap]|(posttagmez|noktomez|tagmez|maten|vesper|nokt)[eo])/i,
      abbreviated: /^([ap][.\s]?t[.\s]?m[.\s]?|(posttagmez|noktomez|tagmez|maten|vesper|nokt)[eo])/i,
      wide: /^(anta(ŭ|ux)tagmez|posttagmez|noktomez|tagmez|maten|vesper|nokt)[eo]/i
    };
    var parseDayPeriodPatterns$1 = {
      any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^noktom/i,
        noon: /^t/i,
        morning: /^m/i,
        afternoon: /^posttagmeze/i,
        evening: /^v/i,
        night: /^n/i
      }
    };
    var match$2 = {
      ordinalNumber: buildMatchPatternFn$1({
        matchPattern: matchOrdinalNumberPattern$1,
        parsePattern: parseOrdinalNumberPattern$1,
        valueCallback: function (value) {
          return parseInt(value, 10);
        }
      }),
      era: buildMatchFn$1({
        matchPatterns: matchEraPatterns$1,
        defaultMatchWidth: 'wide',
        parsePatterns: parseEraPatterns$1,
        defaultParseWidth: 'any'
      }),
      quarter: buildMatchFn$1({
        matchPatterns: matchQuarterPatterns$1,
        defaultMatchWidth: 'wide',
        parsePatterns: parseQuarterPatterns$1,
        defaultParseWidth: 'any',
        valueCallback: function (index) {
          return index + 1;
        }
      }),
      month: buildMatchFn$1({
        matchPatterns: matchMonthPatterns$1,
        defaultMatchWidth: 'wide',
        parsePatterns: parseMonthPatterns$1,
        defaultParseWidth: 'any'
      }),
      day: buildMatchFn$1({
        matchPatterns: matchDayPatterns$1,
        defaultMatchWidth: 'wide',
        parsePatterns: parseDayPatterns$1,
        defaultParseWidth: 'any'
      }),
      dayPeriod: buildMatchFn$1({
        matchPatterns: matchDayPeriodPatterns$1,
        defaultMatchWidth: 'wide',
        parsePatterns: parseDayPeriodPatterns$1,
        defaultParseWidth: 'any'
      })
    };

    /**
     * @type {Locale}
     * @category Locales
     * @summary Esperanto locale.
     * @language Esperanto
     * @iso-639-2 epo
     * @author date-fns
     */

    var locale$1 = {
      code: 'eo',
      formatDistance: formatDistance$2,
      formatLong: formatLong$2,
      formatRelative: formatRelative$2,
      localize: localize$2,
      match: match$2,
      options: {
        weekStartsOn: 1
        /* Monday */
        ,
        firstWeekContainsDate: 4
      }
    };

    const dateEo = {
      name: "eo",
      locale: locale$1
    };
    var dateEo$1 = dateEo;

    var formatDistanceLocale = {
      lessThanXSeconds: {
        one: 'dưới 1 giây',
        other: 'dưới {{count}} giây'
      },
      xSeconds: {
        one: '1 giây',
        other: '{{count}} giây'
      },
      halfAMinute: 'nửa phút',
      lessThanXMinutes: {
        one: 'dưới 1 phút',
        other: 'dưới {{count}} phút'
      },
      xMinutes: {
        one: '1 phút',
        other: '{{count}} phút'
      },
      aboutXHours: {
        one: 'khoảng 1 giờ',
        other: 'khoảng {{count}} giờ'
      },
      xHours: {
        one: '1 giờ',
        other: '{{count}} giờ'
      },
      xDays: {
        one: '1 ngày',
        other: '{{count}} ngày'
      },
      aboutXWeeks: {
        one: 'khoảng 1 tuần',
        other: 'khoảng {{count}} tuần'
      },
      xWeeks: {
        one: '1 tuần',
        other: '{{count}} tuần'
      },
      aboutXMonths: {
        one: 'khoảng 1 tháng',
        other: 'khoảng {{count}} tháng'
      },
      xMonths: {
        one: '1 tháng',
        other: '{{count}} tháng'
      },
      aboutXYears: {
        one: 'khoảng 1 năm',
        other: 'khoảng {{count}} năm'
      },
      xYears: {
        one: '1 năm',
        other: '{{count}} năm'
      },
      overXYears: {
        one: 'hơn 1 năm',
        other: 'hơn {{count}} năm'
      },
      almostXYears: {
        one: 'gần 1 năm',
        other: 'gần {{count}} năm'
      }
    };

    var formatDistance$1 = function (token, count, options) {
      var result;
      var tokenValue = formatDistanceLocale[token];

      if (typeof tokenValue === 'string') {
        result = tokenValue;
      } else if (count === 1) {
        result = tokenValue.one;
      } else {
        result = tokenValue.other.replace('{{count}}', String(count));
      }

      if (options !== null && options !== void 0 && options.addSuffix) {
        if (options.comparison && options.comparison > 0) {
          return result + ' nữa';
        } else {
          return result + ' trước';
        }
      }

      return result;
    };

    var dateFormats = {
      // thứ Sáu, ngày 25 tháng 08 năm 2017
      full: "EEEE, 'ngày' d MMMM 'năm' y",
      // ngày 25 tháng 08 năm 2017
      long: "'ngày' d MMMM 'năm' y",
      // 25 thg 08 năm 2017
      medium: "d MMM 'năm' y",
      // 25/08/2017
      short: 'dd/MM/y'
    };
    var timeFormats = {
      full: 'HH:mm:ss zzzz',
      long: 'HH:mm:ss z',
      medium: 'HH:mm:ss',
      short: 'HH:mm'
    };
    var dateTimeFormats = {
      // thứ Sáu, ngày 25 tháng 08 năm 2017 23:25:59
      full: '{{date}} {{time}}',
      // ngày 25 tháng 08 năm 2017 23:25
      long: '{{date}} {{time}}',
      medium: '{{date}} {{time}}',
      short: '{{date}} {{time}}'
    };
    var formatLong$1 = {
      date: buildFormatLongFn$1({
        formats: dateFormats,
        defaultWidth: 'full'
      }),
      time: buildFormatLongFn$1({
        formats: timeFormats,
        defaultWidth: 'full'
      }),
      dateTime: buildFormatLongFn$1({
        formats: dateTimeFormats,
        defaultWidth: 'full'
      })
    };

    var formatRelativeLocale = {
      lastWeek: "eeee 'tuần trước vào lúc' p",
      yesterday: "'hôm qua vào lúc' p",
      today: "'hôm nay vào lúc' p",
      tomorrow: "'ngày mai vào lúc' p",
      nextWeek: "eeee 'tới vào lúc' p",
      other: 'P'
    };

    var formatRelative$1 = function (token, _date, _baseDate, _options) {
      return formatRelativeLocale[token];
    };

    // Capitalization reference: http://hcmup.edu.vn/index.php?option=com_content&view=article&id=4106%3Avit-hoa-trong-vn-bn-hanh-chinh&catid=2345%3Atham-kho&Itemid=4103&lang=vi&site=134

    var eraValues = {
      narrow: ['TCN', 'SCN'],
      abbreviated: ['trước CN', 'sau CN'],
      wide: ['trước Công Nguyên', 'sau Công Nguyên']
    };
    var quarterValues = {
      narrow: ['1', '2', '3', '4'],
      abbreviated: ['Q1', 'Q2', 'Q3', 'Q4'],
      wide: ['Quý 1', 'Quý 2', 'Quý 3', 'Quý 4']
    };
    var formattingQuarterValues = {
      narrow: ['1', '2', '3', '4'],
      abbreviated: ['Q1', 'Q2', 'Q3', 'Q4'],
      // I notice many news outlet use this "quý II/2018"
      wide: ['quý I', 'quý II', 'quý III', 'quý IV']
    }; // Note: in English, the names of days of the week and months are capitalized.
    // If you are making a new locale based on this one, check if the same is true for the language you're working on.
    // Generally, formatted dates should look like they are in the middle of a sentence,
    // e.g. in Spanish language the weekdays and months should be in the lowercase.

    var monthValues = {
      narrow: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'],
      abbreviated: ['Thg 1', 'Thg 2', 'Thg 3', 'Thg 4', 'Thg 5', 'Thg 6', 'Thg 7', 'Thg 8', 'Thg 9', 'Thg 10', 'Thg 11', 'Thg 12'],
      wide: ['Tháng Một', 'Tháng Hai', 'Tháng Ba', 'Tháng Tư', 'Tháng Năm', 'Tháng Sáu', 'Tháng Bảy', 'Tháng Tám', 'Tháng Chín', 'Tháng Mười', 'Tháng Mười Một', 'Tháng Mười Hai']
    }; // In Vietnamese date formatting, month number less than 10 expected to have leading zero

    var formattingMonthValues = {
      narrow: ['01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12'],
      abbreviated: ['thg 1', 'thg 2', 'thg 3', 'thg 4', 'thg 5', 'thg 6', 'thg 7', 'thg 8', 'thg 9', 'thg 10', 'thg 11', 'thg 12'],
      wide: ['tháng 01', 'tháng 02', 'tháng 03', 'tháng 04', 'tháng 05', 'tháng 06', 'tháng 07', 'tháng 08', 'tháng 09', 'tháng 10', 'tháng 11', 'tháng 12']
    };
    var dayValues = {
      narrow: ['CN', 'T2', 'T3', 'T4', 'T5', 'T6', 'T7'],
      short: ['CN', 'Th 2', 'Th 3', 'Th 4', 'Th 5', 'Th 6', 'Th 7'],
      abbreviated: ['CN', 'Thứ 2', 'Thứ 3', 'Thứ 4', 'Thứ 5', 'Thứ 6', 'Thứ 7'],
      wide: ['Chủ Nhật', 'Thứ Hai', 'Thứ Ba', 'Thứ Tư', 'Thứ Năm', 'Thứ Sáu', 'Thứ Bảy']
    }; // Vietnamese are used to AM/PM borrowing from English, hence `narrow` and
    // `abbreviated` are just like English but I'm leaving the `wide`
    // format being localized with abbreviations found in some systems (SÁng / CHiều);
    // however, personally, I don't think `Chiều` sounds appropriate for `PM`

    var dayPeriodValues = {
      // narrow date period is extremely rare in Vietnamese
      // I used abbreviated form for noon, morning and afternoon
      // which are regconizable by Vietnamese, others cannot be any shorter
      narrow: {
        am: 'am',
        pm: 'pm',
        midnight: 'nửa đêm',
        noon: 'tr',
        morning: 'sg',
        afternoon: 'ch',
        evening: 'tối',
        night: 'đêm'
      },
      abbreviated: {
        am: 'AM',
        pm: 'PM',
        midnight: 'nửa đêm',
        noon: 'trưa',
        morning: 'sáng',
        afternoon: 'chiều',
        evening: 'tối',
        night: 'đêm'
      },
      wide: {
        am: 'SA',
        pm: 'CH',
        midnight: 'nửa đêm',
        noon: 'trưa',
        morning: 'sáng',
        afternoon: 'chiều',
        evening: 'tối',
        night: 'đêm'
      }
    };
    var formattingDayPeriodValues = {
      narrow: {
        am: 'am',
        pm: 'pm',
        midnight: 'nửa đêm',
        noon: 'tr',
        morning: 'sg',
        afternoon: 'ch',
        evening: 'tối',
        night: 'đêm'
      },
      abbreviated: {
        am: 'AM',
        pm: 'PM',
        midnight: 'nửa đêm',
        noon: 'trưa',
        morning: 'sáng',
        afternoon: 'chiều',
        evening: 'tối',
        night: 'đêm'
      },
      wide: {
        am: 'SA',
        pm: 'CH',
        midnight: 'nửa đêm',
        noon: 'giữa trưa',
        morning: 'vào buổi sáng',
        afternoon: 'vào buổi chiều',
        evening: 'vào buổi tối',
        night: 'vào ban đêm'
      }
    };

    var ordinalNumber = function (dirtyNumber, options) {
      var number = Number(dirtyNumber);
      var unit = options === null || options === void 0 ? void 0 : options.unit;

      if (unit === 'quarter') {
        // many news outlets use "quý I"...
        switch (number) {
          case 1:
            return 'I';

          case 2:
            return 'II';

          case 3:
            return 'III';

          case 4:
            return 'IV';
        }
      } else if (unit === 'day') {
        // day of week in Vietnamese has ordinal number meaning,
        // so we should use them, else it'll sound weird
        switch (number) {
          case 1:
            return 'thứ 2';
          // meaning 2nd day but it's the first day of the week :D

          case 2:
            return 'thứ 3';
          // meaning 3rd day

          case 3:
            return 'thứ 4';
          // meaning 4th day and so on

          case 4:
            return 'thứ 5';

          case 5:
            return 'thứ 6';

          case 6:
            return 'thứ 7';

          case 7:
            return 'chủ nhật';
          // meaning Sunday, there's no 8th day :D
        }
      } else if (unit === 'week') {
        if (number === 1) {
          return 'thứ nhất';
        } else {
          return 'thứ ' + number;
        }
      } else if (unit === 'dayOfYear') {
        if (number === 1) {
          return 'đầu tiên';
        } else {
          return 'thứ ' + number;
        }
      } // there are no different forms of ordinal numbers in Vietnamese


      return String(number);
    };

    var localize$1 = {
      ordinalNumber: ordinalNumber,
      era: buildLocalizeFn$1({
        values: eraValues,
        defaultWidth: 'wide'
      }),
      quarter: buildLocalizeFn$1({
        values: quarterValues,
        defaultWidth: 'wide',
        formattingValues: formattingQuarterValues,
        defaultFormattingWidth: 'wide',
        argumentCallback: function (quarter) {
          return quarter - 1;
        }
      }),
      month: buildLocalizeFn$1({
        values: monthValues,
        defaultWidth: 'wide',
        formattingValues: formattingMonthValues,
        defaultFormattingWidth: 'wide'
      }),
      day: buildLocalizeFn$1({
        values: dayValues,
        defaultWidth: 'wide'
      }),
      dayPeriod: buildLocalizeFn$1({
        values: dayPeriodValues,
        defaultWidth: 'wide',
        formattingValues: formattingDayPeriodValues,
        defaultFormattingWidth: 'wide'
      })
    };

    var matchOrdinalNumberPattern = /^(\d+)/i;
    var parseOrdinalNumberPattern = /\d+/i;
    var matchEraPatterns = {
      narrow: /^(tcn|scn)/i,
      abbreviated: /^(trước CN|sau CN)/i,
      wide: /^(trước Công Nguyên|sau Công Nguyên)/i
    };
    var parseEraPatterns = {
      any: [/^t/i, /^s/i]
    };
    var matchQuarterPatterns = {
      narrow: /^([1234]|i{1,3}v?)/i,
      abbreviated: /^q([1234]|i{1,3}v?)/i,
      wide: /^quý ([1234]|i{1,3}v?)/i
    };
    var parseQuarterPatterns = {
      any: [/(1|i)$/i, /(2|ii)$/i, /(3|iii)$/i, /(4|iv)$/i]
    };
    var matchMonthPatterns = {
      // month number may contain leading 0, 'thg' prefix may have space, underscore or empty before number
      // note the order of '1' since it is a sub-string of '10', so must be lower priority
      narrow: /^(0?[2-9]|10|11|12|0?1)/i,
      // note the order of 'thg 1' since it is sub-string of 'thg 10', so must be lower priority
      abbreviated: /^thg[ _]?(0?[1-9](?!\d)|10|11|12)/i,
      // note the order of 'Mười' since it is sub-string of Mười Một, so must be lower priority
      wide: /^tháng ?(Một|Hai|Ba|Tư|Năm|Sáu|Bảy|Tám|Chín|Mười|Mười ?Một|Mười ?Hai|0?[1-9](?!\d)|10|11|12)/i
    };
    var parseMonthPatterns = {
      narrow: [/0?1$/i, /0?2/i, /3/, /4/, /5/, /6/, /7/, /8/, /9/, /10/, /11/, /12/],
      abbreviated: [/^thg[ _]?0?1(?!\d)/i, /^thg[ _]?0?2/i, /^thg[ _]?0?3/i, /^thg[ _]?0?4/i, /^thg[ _]?0?5/i, /^thg[ _]?0?6/i, /^thg[ _]?0?7/i, /^thg[ _]?0?8/i, /^thg[ _]?0?9/i, /^thg[ _]?10/i, /^thg[ _]?11/i, /^thg[ _]?12/i],
      wide: [/^tháng ?(Một|0?1(?!\d))/i, /^tháng ?(Hai|0?2)/i, /^tháng ?(Ba|0?3)/i, /^tháng ?(Tư|0?4)/i, /^tháng ?(Năm|0?5)/i, /^tháng ?(Sáu|0?6)/i, /^tháng ?(Bảy|0?7)/i, /^tháng ?(Tám|0?8)/i, /^tháng ?(Chín|0?9)/i, /^tháng ?(Mười|10)/i, /^tháng ?(Mười ?Một|11)/i, /^tháng ?(Mười ?Hai|12)/i]
    };
    var matchDayPatterns = {
      narrow: /^(CN|T2|T3|T4|T5|T6|T7)/i,
      short: /^(CN|Th ?2|Th ?3|Th ?4|Th ?5|Th ?6|Th ?7)/i,
      abbreviated: /^(CN|Th ?2|Th ?3|Th ?4|Th ?5|Th ?6|Th ?7)/i,
      wide: /^(Chủ ?Nhật|Chúa ?Nhật|thứ ?Hai|thứ ?Ba|thứ ?Tư|thứ ?Năm|thứ ?Sáu|thứ ?Bảy)/i
    };
    var parseDayPatterns = {
      narrow: [/CN/i, /2/i, /3/i, /4/i, /5/i, /6/i, /7/i],
      short: [/CN/i, /2/i, /3/i, /4/i, /5/i, /6/i, /7/i],
      abbreviated: [/CN/i, /2/i, /3/i, /4/i, /5/i, /6/i, /7/i],
      wide: [/(Chủ|Chúa) ?Nhật/i, /Hai/i, /Ba/i, /Tư/i, /Năm/i, /Sáu/i, /Bảy/i]
    };
    var matchDayPeriodPatterns = {
      narrow: /^(a|p|nửa đêm|trưa|(giờ) (sáng|chiều|tối|đêm))/i,
      abbreviated: /^(am|pm|nửa đêm|trưa|(giờ) (sáng|chiều|tối|đêm))/i,
      wide: /^(ch[^i]*|sa|nửa đêm|trưa|(giờ) (sáng|chiều|tối|đêm))/i
    };
    var parseDayPeriodPatterns = {
      any: {
        am: /^(a|sa)/i,
        pm: /^(p|ch[^i]*)/i,
        midnight: /nửa đêm/i,
        noon: /trưa/i,
        morning: /sáng/i,
        afternoon: /chiều/i,
        evening: /tối/i,
        night: /^đêm/i
      }
    };
    var match$1 = {
      ordinalNumber: buildMatchPatternFn$1({
        matchPattern: matchOrdinalNumberPattern,
        parsePattern: parseOrdinalNumberPattern,
        valueCallback: function (value) {
          return parseInt(value, 10);
        }
      }),
      era: buildMatchFn$1({
        matchPatterns: matchEraPatterns,
        defaultMatchWidth: 'wide',
        parsePatterns: parseEraPatterns,
        defaultParseWidth: 'any'
      }),
      quarter: buildMatchFn$1({
        matchPatterns: matchQuarterPatterns,
        defaultMatchWidth: 'wide',
        parsePatterns: parseQuarterPatterns,
        defaultParseWidth: 'any',
        valueCallback: function (index) {
          return index + 1;
        }
      }),
      month: buildMatchFn$1({
        matchPatterns: matchMonthPatterns,
        defaultMatchWidth: 'wide',
        parsePatterns: parseMonthPatterns,
        defaultParseWidth: 'wide'
      }),
      day: buildMatchFn$1({
        matchPatterns: matchDayPatterns,
        defaultMatchWidth: 'wide',
        parsePatterns: parseDayPatterns,
        defaultParseWidth: 'wide'
      }),
      dayPeriod: buildMatchFn$1({
        matchPatterns: matchDayPeriodPatterns,
        defaultMatchWidth: 'wide',
        parsePatterns: parseDayPeriodPatterns,
        defaultParseWidth: 'any'
      })
    };

    /**
     * @type {Locale}
     * @category Locales
     * @summary Vietnamese locale (Vietnam).
     * @language Vietnamese
     * @iso-639-2 vie
     * @author Thanh Tran [@trongthanh]{@link https://github.com/trongthanh}
     * @author Leroy Hopson [@lihop]{@link https://github.com/lihop}
     */

    var locale = {
      code: 'vi',
      formatDistance: formatDistance$1,
      formatLong: formatLong$1,
      formatRelative: formatRelative$1,
      localize: localize$1,
      match: match$1,
      options: {
        weekStartsOn: 1
        /* Monday */
        ,
        firstWeekContainsDate: 1
        /* First week of new year contains Jan 1st  */

      }
    };

    const dateVi = {
      name: "vi-VN",
      locale: locale
    };
    var dateVi$1 = dateVi;

    function createLocale(locale, fallbackLocale) {
      return lodash.exports.merge({}, fallbackLocale, locale);
    }

    function useLocale(ns) {
      const {
        mergedLocaleRef,
        mergedDateLocaleRef
      } = vue.inject(configProviderInjectionKey, null) || {};
      const localeRef = vue.computed(() => {
        var _mergedLocaleRef$valu;

        return (mergedLocaleRef === null || mergedLocaleRef === void 0 ? void 0 : (_mergedLocaleRef$valu = mergedLocaleRef.value) === null || _mergedLocaleRef$valu === void 0 ? void 0 : _mergedLocaleRef$valu[ns]) ?? enUS$2[ns];
      });
      const dateLocaleRef = vue.computed(() => {
        return (mergedDateLocaleRef === null || mergedDateLocaleRef === void 0 ? void 0 : mergedDateLocaleRef.value) ?? dateEnUS;
      });
      return {
        dateLocaleRef,
        localeRef
      };
    }

    function useStyle(mountId, style, clsPrefixRef) {
      if (!style) {
        throwError("use-style", "No style is specified.");
        return;
      }

      const ssrAdapter = useSsrAdapter();
      const NConfigProvider = vue.inject(configProviderInjectionKey, null);

      const mountStyle = () => {
        const clsPrefix = clsPrefixRef === null || clsPrefixRef === void 0 ? void 0 : clsPrefixRef.value;
        style.mount({
          id: clsPrefix === void 0 ? mountId : clsPrefix + mountId,
          head: true,
          anchorMetaName: cssrAnchorMetaName,
          props: {
            bPrefix: clsPrefix ? `.${clsPrefix}-` : void 0
          },
          ssr: ssrAdapter
        });

        if (!(NConfigProvider !== null && NConfigProvider !== void 0 && NConfigProvider.preflightStyleDisabled)) {
          globalStyle.mount({
            id: "n-global",
            head: true,
            anchorMetaName: cssrAnchorMetaName,
            ssr: ssrAdapter
          });
        }
      };

      if (ssrAdapter) {
        mountStyle();
      } else {
        vue.onBeforeMount(mountStyle);
      }
    }

    function useHljs(props, shouldHighlightRef) {
      const NConfigProvider = vue.inject(configProviderInjectionKey, null);

      {
        const warnHljs = () => {
          if (!props.hljs && !(NConfigProvider !== null && NConfigProvider !== void 0 && NConfigProvider.mergedHljsRef.value)) {
            warn$2("code", "hljs is not set.");
          }
        };

        if (!shouldHighlightRef) {
          warnHljs();
        } else {
          vue.watchEffect(() => {
            if (shouldHighlightRef.value) {
              warnHljs();
            }
          });
        }
      }

      return vue.computed(() => {
        return props.hljs || (NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedHljsRef.value);
      });
    }

    function useThemeClass(componentName, hashRef, cssVarsRef, props) {
      var _inject;

      if (!cssVarsRef) throwError("useThemeClass", "cssVarsRef is not passed");
      const mergedThemeHashRef = (_inject = vue.inject(configProviderInjectionKey, null)) === null || _inject === void 0 ? void 0 : _inject.mergedThemeHashRef;
      const themeClassRef = vue.ref("");
      const ssrAdapter = useSsrAdapter();
      let renderCallback;
      const hashClassPrefix = `__${componentName}`;

      const mountStyle = () => {
        let finalThemeHash = hashClassPrefix;
        const hashValue = hashRef ? hashRef.value : void 0;
        const themeHash = mergedThemeHashRef === null || mergedThemeHashRef === void 0 ? void 0 : mergedThemeHashRef.value;
        if (themeHash) finalThemeHash += "-" + themeHash;
        if (hashValue) finalThemeHash += "-" + hashValue;
        const {
          themeOverrides,
          builtinThemeOverrides
        } = props;

        if (themeOverrides) {
          finalThemeHash += "-" + murmur2(JSON.stringify(themeOverrides));
        }

        if (builtinThemeOverrides) {
          finalThemeHash += "-" + murmur2(JSON.stringify(builtinThemeOverrides));
        }

        themeClassRef.value = finalThemeHash;

        renderCallback = () => {
          const cssVars = cssVarsRef.value;
          let style = "";

          for (const key in cssVars) {
            style += `${key}: ${cssVars[key]};`;
          }

          c$1(`.${finalThemeHash}`, style).mount({
            id: finalThemeHash,
            ssr: ssrAdapter
          });
          renderCallback = void 0;
        };
      };

      vue.watchEffect(() => {
        mountStyle();
      });
      return {
        themeClass: themeClassRef,
        onRender: () => {
          var _renderCallback;

          (_renderCallback = renderCallback) === null || _renderCallback === void 0 ? void 0 : _renderCallback();
        }
      };
    }

    function useRtl(mountId, rtlStateRef, clsPrefixRef) {
      if (!rtlStateRef) return void 0;
      const ssrAdapter = useSsrAdapter();
      const componentRtlStateRef = vue.computed(() => {
        const {
          value: rtlState
        } = rtlStateRef;

        if (!rtlState) {
          return void 0;
        }

        const componentRtlState = rtlState[mountId];

        if (!componentRtlState) {
          return void 0;
        }

        return componentRtlState;
      });

      const mountStyle = () => {
        vue.watchEffect(() => {
          const {
            value: clsPrefix
          } = clsPrefixRef;
          const id = `${clsPrefix}${mountId}Rtl`;
          if (exists(id, ssrAdapter)) return;
          const {
            value: componentRtlState
          } = componentRtlStateRef;
          if (!componentRtlState) return;
          componentRtlState.style.mount({
            id,
            head: true,
            anchorMetaName: cssrAnchorMetaName,
            props: {
              bPrefix: clsPrefix ? `.${clsPrefix}-` : void 0
            },
            ssr: ssrAdapter
          });
        });
      };

      if (ssrAdapter) {
        mountStyle();
      } else {
        vue.onBeforeMount(mountStyle);
      }

      return componentRtlStateRef;
    }

    function getScrollTop(target) {
      return target instanceof HTMLElement ? target.scrollTop : window.scrollY;
    }
    function getRect(target) {
      return target instanceof HTMLElement ? target.getBoundingClientRect() : {
        top: 0,
        bottom: window.innerHeight
      };
    }

    var style$1z = cB("affix", [cM("affixed", {
      position: "fixed"
    }, [cM("absolute-positioned", {
      position: "absolute"
    })])]);

    const affixProps = {
      listenTo: [String, Object, Function],
      top: Number,
      bottom: Number,
      triggerTop: Number,
      triggerBottom: Number,
      position: {
        type: String,
        default: "fix"
      },
      offsetTop: {
        type: Number,
        validator: () => {
          {
            warn$2(
              "affix",
              "`offset-top` is deprecated, please use `trigger-top` instead."
            );
          }
          return true;
        },
        default: void 0
      },
      offsetBottom: {
        type: Number,
        validator: () => {
          {
            warn$2(
              "affix",
              "`offset-bottom` is deprecated, please use `trigger-bottom` instead."
            );
          }
          return true;
        },
        default: void 0
      },
      target: {
        type: Function,
        validator: () => {
          {
            warn$2("affix", "`target` is deprecated, please use `listen-to` instead.");
          }
          return true;
        },
        default: void 0
      }
    };
    const affixPropKeys = keysOf(affixProps);
    var NAffix = vue.defineComponent({
      name: "Affix",
      props: affixProps,
      setup(props) {
        const { mergedClsPrefixRef } = useConfig(props);
        useStyle("-affix", style$1z, mergedClsPrefixRef);
        let scrollTarget = null;
        const stickToTopRef = vue.ref(false);
        const stickToBottomRef = vue.ref(false);
        const bottomAffixedTriggerScrollTopRef = vue.ref(null);
        const topAffixedTriggerScrollTopRef = vue.ref(null);
        const affixedRef = vue.computed(() => {
          return stickToBottomRef.value || stickToTopRef.value;
        });
        const mergedOffsetTopRef = vue.computed(() => {
          return props.triggerTop ?? props.offsetTop ?? props.top;
        });
        const mergedTopRef = vue.computed(() => {
          return props.top ?? props.triggerTop ?? props.offsetTop;
        });
        const mergedBottomRef = vue.computed(() => {
          return props.bottom ?? props.triggerBottom ?? props.offsetBottom;
        });
        const mergedOffsetBottomRef = vue.computed(() => {
          return props.triggerBottom ?? props.offsetBottom ?? props.bottom;
        });
        const selfRef = vue.ref(null);
        const init = () => {
          const { target: getScrollTarget, listenTo } = props;
          if (getScrollTarget) {
            scrollTarget = getScrollTarget();
          } else if (listenTo) {
            scrollTarget = unwrapElement(listenTo);
          } else {
            scrollTarget = document;
          }
          if (scrollTarget) {
            scrollTarget.addEventListener("scroll", handleScroll);
            handleScroll();
          } else {
            warn$2("affix", "Target to be listened to is not valid.");
          }
        };
        function handleScroll() {
          beforeNextFrameOnce(_handleScroll);
        }
        function _handleScroll() {
          const { value: selfEl } = selfRef;
          if (!scrollTarget || !selfEl)
            return;
          const scrollTop = getScrollTop(scrollTarget);
          if (affixedRef.value) {
            if (scrollTop < topAffixedTriggerScrollTopRef.value) {
              stickToTopRef.value = false;
              topAffixedTriggerScrollTopRef.value = null;
            }
            if (scrollTop > bottomAffixedTriggerScrollTopRef.value) {
              stickToBottomRef.value = false;
              bottomAffixedTriggerScrollTopRef.value = null;
            }
            return;
          }
          const containerRect = getRect(scrollTarget);
          const affixRect = selfEl.getBoundingClientRect();
          const pxToTop = affixRect.top - containerRect.top;
          const pxToBottom = containerRect.bottom - affixRect.bottom;
          const mergedOffsetTop = mergedOffsetTopRef.value;
          const mergedOffsetBottom = mergedOffsetBottomRef.value;
          if (mergedOffsetTop !== void 0 && pxToTop <= mergedOffsetTop) {
            stickToTopRef.value = true;
            topAffixedTriggerScrollTopRef.value = scrollTop - (mergedOffsetTop - pxToTop);
          } else {
            stickToTopRef.value = false;
            topAffixedTriggerScrollTopRef.value = null;
          }
          if (mergedOffsetBottom !== void 0 && pxToBottom <= mergedOffsetBottom) {
            stickToBottomRef.value = true;
            bottomAffixedTriggerScrollTopRef.value = scrollTop + mergedOffsetBottom - pxToBottom;
          } else {
            stickToBottomRef.value = false;
            bottomAffixedTriggerScrollTopRef.value = null;
          }
        }
        vue.onMounted(() => {
          init();
        });
        vue.onBeforeUnmount(() => {
          if (!scrollTarget)
            return;
          scrollTarget.removeEventListener("scroll", handleScroll);
        });
        return {
          selfRef,
          affixed: affixedRef,
          mergedClsPrefix: mergedClsPrefixRef,
          mergedstyle: vue.computed(() => {
            const style2 = {};
            if (stickToTopRef.value && mergedOffsetTopRef.value !== void 0 && mergedTopRef.value !== void 0) {
              style2.top = `${mergedTopRef.value}px`;
            }
            if (stickToBottomRef.value && mergedOffsetBottomRef.value !== void 0 && mergedBottomRef.value !== void 0) {
              style2.bottom = `${mergedBottomRef.value}px`;
            }
            return style2;
          })
        };
      },
      render() {
        const { mergedClsPrefix } = this;
        return /* @__PURE__ */ vue.h("div", {
          ref: "selfRef",
          class: [
            `${mergedClsPrefix}-affix`,
            {
              [`${mergedClsPrefix}-affix--affixed`]: this.affixed,
              [`${mergedClsPrefix}-affix--absolute-positioned`]: this.position === "absolute"
            }
          ],
          style: this.mergedstyle
        }, this.$slots);
      }
    });

    var AddIcon = vue.defineComponent({
      name: "Add",
      render() {
        return /* @__PURE__ */ vue.h("svg", {
          width: "512",
          height: "512",
          viewBox: "0 0 512 512",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg"
        }, /* @__PURE__ */ vue.h("path", {
          d: "M256 112V400M400 256H112",
          stroke: "currentColor",
          "stroke-width": "32",
          "stroke-linecap": "round",
          "stroke-linejoin": "round"
        }));
      }
    });

    var ArrowDownIcon = vue.defineComponent({
      name: "ArrowDown",
      render() {
        return /* @__PURE__ */ vue.h("svg", {
          viewBox: "0 0 28 28",
          version: "1.1",
          xmlns: "http://www.w3.org/2000/svg"
        }, /* @__PURE__ */ vue.h("g", {
          stroke: "none",
          "stroke-width": "1",
          "fill-rule": "evenodd"
        }, /* @__PURE__ */ vue.h("g", {
          "fill-rule": "nonzero"
        }, /* @__PURE__ */ vue.h("path", {
          d: "M23.7916,15.2664 C24.0788,14.9679 24.0696,14.4931 23.7711,14.206 C23.4726,13.9188 22.9978,13.928 22.7106,14.2265 L14.7511,22.5007 L14.7511,3.74792 C14.7511,3.33371 14.4153,2.99792 14.0011,2.99792 C13.5869,2.99792 13.2511,3.33371 13.2511,3.74793 L13.2511,22.4998 L5.29259,14.2265 C5.00543,13.928 4.53064,13.9188 4.23213,14.206 C3.93361,14.4931 3.9244,14.9679 4.21157,15.2664 L13.2809,24.6944 C13.6743,25.1034 14.3289,25.1034 14.7223,24.6944 L23.7916,15.2664 Z"
        }))));
      }
    });

    var ArrowUpIcon = vue.defineComponent({
      name: "ArrowUp",
      render() {
        return /* @__PURE__ */ vue.h("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 20 20"
        }, /* @__PURE__ */ vue.h("g", {
          fill: "none"
        }, /* @__PURE__ */ vue.h("path", {
          d: "M3.13 9.163a.5.5 0 1 0 .74.674L9.5 3.67V17.5a.5.5 0 0 0 1 0V3.672l5.63 6.165a.5.5 0 0 0 .738-.674l-6.315-6.916a.746.746 0 0 0-.632-.24a.746.746 0 0 0-.476.24L3.131 9.163z",
          fill: "currentColor"
        })));
      }
    });

    function replaceable(name, icon) {
      return vue.defineComponent({
        name: lodash.exports.upperFirst(name),
        setup() {
          const mergedIconsRef = vue.inject(
            configProviderInjectionKey,
            null
          )?.mergedIconsRef;
          return () => {
            const iconOverride = mergedIconsRef?.value?.[name];
            return iconOverride ? iconOverride() : icon;
          };
        }
      });
    }

    var AttachIcon = replaceable(
      "attach",
      /* @__PURE__ */ vue.h("svg", {
        viewBox: "0 0 16 16",
        version: "1.1",
        xmlns: "http://www.w3.org/2000/svg"
      }, /* @__PURE__ */ vue.h("g", {
        stroke: "none",
        "stroke-width": "1",
        fill: "none",
        "fill-rule": "evenodd"
      }, /* @__PURE__ */ vue.h("g", {
        fill: "currentColor",
        "fill-rule": "nonzero"
      }, /* @__PURE__ */ vue.h("path", {
        d: "M3.25735931,8.70710678 L7.85355339,4.1109127 C8.82986412,3.13460197 10.4127766,3.13460197 11.3890873,4.1109127 C12.365398,5.08722343 12.365398,6.67013588 11.3890873,7.64644661 L6.08578644,12.9497475 C5.69526215,13.3402718 5.06209717,13.3402718 4.67157288,12.9497475 C4.28104858,12.5592232 4.28104858,11.9260582 4.67157288,11.5355339 L9.97487373,6.23223305 C10.1701359,6.0369709 10.1701359,5.72038841 9.97487373,5.52512627 C9.77961159,5.32986412 9.4630291,5.32986412 9.26776695,5.52512627 L3.96446609,10.8284271 C3.18341751,11.6094757 3.18341751,12.8758057 3.96446609,13.6568542 C4.74551468,14.4379028 6.01184464,14.4379028 6.79289322,13.6568542 L12.0961941,8.35355339 C13.4630291,6.98671837 13.4630291,4.77064094 12.0961941,3.40380592 C10.7293591,2.0369709 8.51328163,2.0369709 7.14644661,3.40380592 L2.55025253,8 C2.35499039,8.19526215 2.35499039,8.51184464 2.55025253,8.70710678 C2.74551468,8.90236893 3.06209717,8.90236893 3.25735931,8.70710678 Z"
      }))))
    );

    var BackwardIcon = vue.defineComponent({
      name: "Backward",
      render() {
        return /* @__PURE__ */ vue.h("svg", {
          viewBox: "0 0 20 20",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg"
        }, /* @__PURE__ */ vue.h("path", {
          d: "M12.2674 15.793C11.9675 16.0787 11.4927 16.0672 11.2071 15.7673L6.20572 10.5168C5.9298 10.2271 5.9298 9.7719 6.20572 9.48223L11.2071 4.23177C11.4927 3.93184 11.9675 3.92031 12.2674 4.206C12.5673 4.49169 12.5789 4.96642 12.2932 5.26634L7.78458 9.99952L12.2932 14.7327C12.5789 15.0326 12.5673 15.5074 12.2674 15.793Z",
          fill: "currentColor"
        }));
      }
    });

    var DateIcon = replaceable(
      "date",
      /* @__PURE__ */ vue.h("svg", {
        width: "28px",
        height: "28px",
        viewBox: "0 0 28 28",
        version: "1.1",
        xmlns: "http://www.w3.org/2000/svg"
      }, /* @__PURE__ */ vue.h("g", {
        stroke: "none",
        "stroke-width": "1",
        "fill-rule": "evenodd"
      }, /* @__PURE__ */ vue.h("g", {
        "fill-rule": "nonzero"
      }, /* @__PURE__ */ vue.h("path", {
        d: "M21.75,3 C23.5449254,3 25,4.45507456 25,6.25 L25,21.75 C25,23.5449254 23.5449254,25 21.75,25 L6.25,25 C4.45507456,25 3,23.5449254 3,21.75 L3,6.25 C3,4.45507456 4.45507456,3 6.25,3 L21.75,3 Z M23.5,9.503 L4.5,9.503 L4.5,21.75 C4.5,22.7164983 5.28350169,23.5 6.25,23.5 L21.75,23.5 C22.7164983,23.5 23.5,22.7164983 23.5,21.75 L23.5,9.503 Z M21.75,4.5 L6.25,4.5 C5.28350169,4.5 4.5,5.28350169 4.5,6.25 L4.5,8.003 L23.5,8.003 L23.5,6.25 C23.5,5.28350169 22.7164983,4.5 21.75,4.5 Z"
      }))))
    );

    var FinishedIcon = vue.defineComponent({
      name: "Checkmark",
      render() {
        return /* @__PURE__ */ vue.h("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 16 16"
        }, /* @__PURE__ */ vue.h("g", {
          fill: "none"
        }, /* @__PURE__ */ vue.h("path", {
          d: "M14.046 3.486a.75.75 0 0 1-.032 1.06l-7.93 7.474a.85.85 0 0 1-1.188-.022l-2.68-2.72a.75.75 0 1 1 1.068-1.053l2.234 2.267l7.468-7.038a.75.75 0 0 1 1.06.032z",
          fill: "currentColor"
        })));
      }
    });

    var ChevronLeftIcon = vue.defineComponent({
      name: "ChevronLeft",
      render() {
        return /* @__PURE__ */ vue.h("svg", {
          viewBox: "0 0 16 16",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg"
        }, /* @__PURE__ */ vue.h("path", {
          d: "M10.3536 3.14645C10.5488 3.34171 10.5488 3.65829 10.3536 3.85355L6.20711 8L10.3536 12.1464C10.5488 12.3417 10.5488 12.6583 10.3536 12.8536C10.1583 13.0488 9.84171 13.0488 9.64645 12.8536L5.14645 8.35355C4.95118 8.15829 4.95118 7.84171 5.14645 7.64645L9.64645 3.14645C9.84171 2.95118 10.1583 2.95118 10.3536 3.14645Z",
          fill: "currentColor"
        }));
      }
    });

    var ChevronRightIcon = vue.defineComponent({
      name: "ChevronRight",
      render() {
        return /* @__PURE__ */ vue.h("svg", {
          viewBox: "0 0 16 16",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg"
        }, /* @__PURE__ */ vue.h("path", {
          d: "M5.64645 3.14645C5.45118 3.34171 5.45118 3.65829 5.64645 3.85355L9.79289 8L5.64645 12.1464C5.45118 12.3417 5.45118 12.6583 5.64645 12.8536C5.84171 13.0488 6.15829 13.0488 6.35355 12.8536L10.8536 8.35355C11.0488 8.15829 11.0488 7.84171 10.8536 7.64645L6.35355 3.14645C6.15829 2.95118 5.84171 2.95118 5.64645 3.14645Z",
          fill: "currentColor"
        }));
      }
    });

    var ErrorIcon$1 = replaceable(
      "close",
      /* @__PURE__ */ vue.h("svg", {
        viewBox: "0 0 12 12",
        version: "1.1",
        xmlns: "http://www.w3.org/2000/svg",
        "aria-hidden": true
      }, /* @__PURE__ */ vue.h("g", {
        stroke: "none",
        "stroke-width": "1",
        fill: "none",
        "fill-rule": "evenodd"
      }, /* @__PURE__ */ vue.h("g", {
        fill: "currentColor",
        "fill-rule": "nonzero"
      }, /* @__PURE__ */ vue.h("path", {
        d: "M2.08859116,2.2156945 L2.14644661,2.14644661 C2.32001296,1.97288026 2.58943736,1.95359511 2.7843055,2.08859116 L2.85355339,2.14644661 L6,5.293 L9.14644661,2.14644661 C9.34170876,1.95118446 9.65829124,1.95118446 9.85355339,2.14644661 C10.0488155,2.34170876 10.0488155,2.65829124 9.85355339,2.85355339 L6.707,6 L9.85355339,9.14644661 C10.0271197,9.32001296 10.0464049,9.58943736 9.91140884,9.7843055 L9.85355339,9.85355339 C9.67998704,10.0271197 9.41056264,10.0464049 9.2156945,9.91140884 L9.14644661,9.85355339 L6,6.707 L2.85355339,9.85355339 C2.65829124,10.0488155 2.34170876,10.0488155 2.14644661,9.85355339 C1.95118446,9.65829124 1.95118446,9.34170876 2.14644661,9.14644661 L5.293,6 L2.14644661,2.85355339 C1.97288026,2.67998704 1.95359511,2.41056264 2.08859116,2.2156945 L2.14644661,2.14644661 L2.08859116,2.2156945 Z"
      }))))
    );

    var EyeIcon = vue.defineComponent({
      name: "Eye",
      render() {
        return /* @__PURE__ */ vue.h("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 512 512"
        }, /* @__PURE__ */ vue.h("path", {
          d: "M255.66 112c-77.94 0-157.89 45.11-220.83 135.33a16 16 0 0 0-.27 17.77C82.92 340.8 161.8 400 255.66 400c92.84 0 173.34-59.38 221.79-135.25a16.14 16.14 0 0 0 0-17.47C428.89 172.28 347.8 112 255.66 112z",
          fill: "none",
          stroke: "currentColor",
          "stroke-linecap": "round",
          "stroke-linejoin": "round",
          "stroke-width": "32"
        }), /* @__PURE__ */ vue.h("circle", {
          cx: "256",
          cy: "256",
          r: "80",
          fill: "none",
          stroke: "currentColor",
          "stroke-miterlimit": "10",
          "stroke-width": "32"
        }));
      }
    });

    var EyeOffIcon = vue.defineComponent({
      name: "EyeOff",
      render() {
        return /* @__PURE__ */ vue.h("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 512 512"
        }, /* @__PURE__ */ vue.h("path", {
          d: "M432 448a15.92 15.92 0 0 1-11.31-4.69l-352-352a16 16 0 0 1 22.62-22.62l352 352A16 16 0 0 1 432 448z",
          fill: "currentColor"
        }), /* @__PURE__ */ vue.h("path", {
          d: "M255.66 384c-41.49 0-81.5-12.28-118.92-36.5c-34.07-22-64.74-53.51-88.7-91v-.08c19.94-28.57 41.78-52.73 65.24-72.21a2 2 0 0 0 .14-2.94L93.5 161.38a2 2 0 0 0-2.71-.12c-24.92 21-48.05 46.76-69.08 76.92a31.92 31.92 0 0 0-.64 35.54c26.41 41.33 60.4 76.14 98.28 100.65C162 402 207.9 416 255.66 416a239.13 239.13 0 0 0 75.8-12.58a2 2 0 0 0 .77-3.31l-21.58-21.58a4 4 0 0 0-3.83-1a204.8 204.8 0 0 1-51.16 6.47z",
          fill: "currentColor"
        }), /* @__PURE__ */ vue.h("path", {
          d: "M490.84 238.6c-26.46-40.92-60.79-75.68-99.27-100.53C349 110.55 302 96 255.66 96a227.34 227.34 0 0 0-74.89 12.83a2 2 0 0 0-.75 3.31l21.55 21.55a4 4 0 0 0 3.88 1a192.82 192.82 0 0 1 50.21-6.69c40.69 0 80.58 12.43 118.55 37c34.71 22.4 65.74 53.88 89.76 91a.13.13 0 0 1 0 .16a310.72 310.72 0 0 1-64.12 72.73a2 2 0 0 0-.15 2.95l19.9 19.89a2 2 0 0 0 2.7.13a343.49 343.49 0 0 0 68.64-78.48a32.2 32.2 0 0 0-.1-34.78z",
          fill: "currentColor"
        }), /* @__PURE__ */ vue.h("path", {
          d: "M256 160a95.88 95.88 0 0 0-21.37 2.4a2 2 0 0 0-1 3.38l112.59 112.56a2 2 0 0 0 3.38-1A96 96 0 0 0 256 160z",
          fill: "currentColor"
        }), /* @__PURE__ */ vue.h("path", {
          d: "M165.78 233.66a2 2 0 0 0-3.38 1a96 96 0 0 0 115 115a2 2 0 0 0 1-3.38z",
          fill: "currentColor"
        }));
      }
    });

    var TrashIcon = replaceable(
      "trash",
      /* @__PURE__ */ vue.h("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 512 512"
      }, /* @__PURE__ */ vue.h("path", {
        d: "M432,144,403.33,419.74A32,32,0,0,1,371.55,448H140.46a32,32,0,0,1-31.78-28.26L80,144",
        style: "fill: none; stroke: currentcolor; stroke-linecap: round; stroke-linejoin: round; stroke-width: 32px;"
      }), /* @__PURE__ */ vue.h("rect", {
        x: "32",
        y: "64",
        width: "448",
        height: "80",
        rx: "16",
        ry: "16",
        style: "fill: none; stroke: currentcolor; stroke-linecap: round; stroke-linejoin: round; stroke-width: 32px;"
      }), /* @__PURE__ */ vue.h("line", {
        x1: "312",
        y1: "240",
        x2: "200",
        y2: "352",
        style: "fill: none; stroke: currentcolor; stroke-linecap: round; stroke-linejoin: round; stroke-width: 32px;"
      }), /* @__PURE__ */ vue.h("line", {
        x1: "312",
        y1: "352",
        x2: "200",
        y2: "240",
        style: "fill: none; stroke: currentcolor; stroke-linecap: round; stroke-linejoin: round; stroke-width: 32px;"
      }))
    );

    var DownloadIcon = replaceable(
      "download",
      /* @__PURE__ */ vue.h("svg", {
        viewBox: "0 0 16 16",
        version: "1.1",
        xmlns: "http://www.w3.org/2000/svg"
      }, /* @__PURE__ */ vue.h("g", {
        stroke: "none",
        "stroke-width": "1",
        fill: "none",
        "fill-rule": "evenodd"
      }, /* @__PURE__ */ vue.h("g", {
        fill: "currentColor",
        "fill-rule": "nonzero"
      }, /* @__PURE__ */ vue.h("path", {
        d: "M3.5,13 L12.5,13 C12.7761424,13 13,13.2238576 13,13.5 C13,13.7454599 12.8231248,13.9496084 12.5898756,13.9919443 L12.5,14 L3.5,14 C3.22385763,14 3,13.7761424 3,13.5 C3,13.2545401 3.17687516,13.0503916 3.41012437,13.0080557 L3.5,13 L12.5,13 L3.5,13 Z M7.91012437,1.00805567 L8,1 C8.24545989,1 8.44960837,1.17687516 8.49194433,1.41012437 L8.5,1.5 L8.5,10.292 L11.1819805,7.6109127 C11.3555469,7.43734635 11.6249713,7.4180612 11.8198394,7.55305725 L11.8890873,7.6109127 C12.0626536,7.78447906 12.0819388,8.05390346 11.9469427,8.2487716 L11.8890873,8.31801948 L8.35355339,11.8535534 C8.17998704,12.0271197 7.91056264,12.0464049 7.7156945,11.9114088 L7.64644661,11.8535534 L4.1109127,8.31801948 C3.91565056,8.12275734 3.91565056,7.80617485 4.1109127,7.6109127 C4.28447906,7.43734635 4.55390346,7.4180612 4.7487716,7.55305725 L4.81801948,7.6109127 L7.5,10.292 L7.5,1.5 C7.5,1.25454011 7.67687516,1.05039163 7.91012437,1.00805567 L8,1 L7.91012437,1.00805567 Z"
      }))))
    );

    var EmptyIcon = vue.defineComponent({
      name: "Empty",
      render() {
        return /* @__PURE__ */ vue.h("svg", {
          viewBox: "0 0 28 28",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg"
        }, /* @__PURE__ */ vue.h("path", {
          d: "M26 7.5C26 11.0899 23.0899 14 19.5 14C15.9101 14 13 11.0899 13 7.5C13 3.91015 15.9101 1 19.5 1C23.0899 1 26 3.91015 26 7.5ZM16.8536 4.14645C16.6583 3.95118 16.3417 3.95118 16.1464 4.14645C15.9512 4.34171 15.9512 4.65829 16.1464 4.85355L18.7929 7.5L16.1464 10.1464C15.9512 10.3417 15.9512 10.6583 16.1464 10.8536C16.3417 11.0488 16.6583 11.0488 16.8536 10.8536L19.5 8.20711L22.1464 10.8536C22.3417 11.0488 22.6583 11.0488 22.8536 10.8536C23.0488 10.6583 23.0488 10.3417 22.8536 10.1464L20.2071 7.5L22.8536 4.85355C23.0488 4.65829 23.0488 4.34171 22.8536 4.14645C22.6583 3.95118 22.3417 3.95118 22.1464 4.14645L19.5 6.79289L16.8536 4.14645Z",
          fill: "currentColor"
        }), /* @__PURE__ */ vue.h("path", {
          d: "M25 22.75V12.5991C24.5572 13.0765 24.053 13.4961 23.5 13.8454V16H17.5L17.3982 16.0068C17.0322 16.0565 16.75 16.3703 16.75 16.75C16.75 18.2688 15.5188 19.5 14 19.5C12.4812 19.5 11.25 18.2688 11.25 16.75L11.2432 16.6482C11.1935 16.2822 10.8797 16 10.5 16H4.5V7.25C4.5 6.2835 5.2835 5.5 6.25 5.5H12.2696C12.4146 4.97463 12.6153 4.47237 12.865 4H6.25C4.45507 4 3 5.45507 3 7.25V22.75C3 24.5449 4.45507 26 6.25 26H21.75C23.5449 26 25 24.5449 25 22.75ZM4.5 22.75V17.5H9.81597L9.85751 17.7041C10.2905 19.5919 11.9808 21 14 21L14.215 20.9947C16.2095 20.8953 17.842 19.4209 18.184 17.5H23.5V22.75C23.5 23.7165 22.7165 24.5 21.75 24.5H6.25C5.2835 24.5 4.5 23.7165 4.5 22.75Z",
          fill: "currentColor"
        }));
      }
    });

    var ErrorIcon = replaceable(
      "error",
      /* @__PURE__ */ vue.h("svg", {
        viewBox: "0 0 48 48",
        version: "1.1",
        xmlns: "http://www.w3.org/2000/svg"
      }, /* @__PURE__ */ vue.h("g", {
        stroke: "none",
        "stroke-width": "1",
        "fill-rule": "evenodd"
      }, /* @__PURE__ */ vue.h("g", {
        "fill-rule": "nonzero"
      }, /* @__PURE__ */ vue.h("path", {
        d: "M24,4 C35.045695,4 44,12.954305 44,24 C44,35.045695 35.045695,44 24,44 C12.954305,44 4,35.045695 4,24 C4,12.954305 12.954305,4 24,4 Z M17.8838835,16.1161165 L17.7823881,16.0249942 C17.3266086,15.6583353 16.6733914,15.6583353 16.2176119,16.0249942 L16.1161165,16.1161165 L16.0249942,16.2176119 C15.6583353,16.6733914 15.6583353,17.3266086 16.0249942,17.7823881 L16.1161165,17.8838835 L22.233,24 L16.1161165,30.1161165 L16.0249942,30.2176119 C15.6583353,30.6733914 15.6583353,31.3266086 16.0249942,31.7823881 L16.1161165,31.8838835 L16.2176119,31.9750058 C16.6733914,32.3416647 17.3266086,32.3416647 17.7823881,31.9750058 L17.8838835,31.8838835 L24,25.767 L30.1161165,31.8838835 L30.2176119,31.9750058 C30.6733914,32.3416647 31.3266086,32.3416647 31.7823881,31.9750058 L31.8838835,31.8838835 L31.9750058,31.7823881 C32.3416647,31.3266086 32.3416647,30.6733914 31.9750058,30.2176119 L31.8838835,30.1161165 L25.767,24 L31.8838835,17.8838835 L31.9750058,17.7823881 C32.3416647,17.3266086 32.3416647,16.6733914 31.9750058,16.2176119 L31.8838835,16.1161165 L31.7823881,16.0249942 C31.3266086,15.6583353 30.6733914,15.6583353 30.2176119,16.0249942 L30.1161165,16.1161165 L24,22.233 L17.8838835,16.1161165 L17.7823881,16.0249942 L17.8838835,16.1161165 Z"
      }))))
    );

    var FastBackwardIcon = vue.defineComponent({
      name: "FastBackward",
      render() {
        return /* @__PURE__ */ vue.h("svg", {
          viewBox: "0 0 20 20",
          version: "1.1",
          xmlns: "http://www.w3.org/2000/svg"
        }, /* @__PURE__ */ vue.h("g", {
          stroke: "none",
          "stroke-width": "1",
          fill: "none",
          "fill-rule": "evenodd"
        }, /* @__PURE__ */ vue.h("g", {
          fill: "currentColor",
          "fill-rule": "nonzero"
        }, /* @__PURE__ */ vue.h("path", {
          d: "M8.73171,16.7949 C9.03264,17.0795 9.50733,17.0663 9.79196,16.7654 C10.0766,16.4644 10.0634,15.9897 9.76243,15.7051 L4.52339,10.75 L17.2471,10.75 C17.6613,10.75 17.9971,10.4142 17.9971,10 C17.9971,9.58579 17.6613,9.25 17.2471,9.25 L4.52112,9.25 L9.76243,4.29275 C10.0634,4.00812 10.0766,3.53343 9.79196,3.2325 C9.50733,2.93156 9.03264,2.91834 8.73171,3.20297 L2.31449,9.27241 C2.14819,9.4297 2.04819,9.62981 2.01448,9.8386 C2.00308,9.89058 1.99707,9.94459 1.99707,10 C1.99707,10.0576 2.00356,10.1137 2.01585,10.1675 C2.05084,10.3733 2.15039,10.5702 2.31449,10.7254 L8.73171,16.7949 Z"
        }))));
      }
    });

    var FastForwardIcon = vue.defineComponent({
      name: "FastForward",
      render() {
        return /* @__PURE__ */ vue.h("svg", {
          viewBox: "0 0 20 20",
          version: "1.1",
          xmlns: "http://www.w3.org/2000/svg"
        }, /* @__PURE__ */ vue.h("g", {
          stroke: "none",
          "stroke-width": "1",
          fill: "none",
          "fill-rule": "evenodd"
        }, /* @__PURE__ */ vue.h("g", {
          fill: "currentColor",
          "fill-rule": "nonzero"
        }, /* @__PURE__ */ vue.h("path", {
          d: "M11.2654,3.20511 C10.9644,2.92049 10.4897,2.93371 10.2051,3.23464 C9.92049,3.53558 9.93371,4.01027 10.2346,4.29489 L15.4737,9.25 L2.75,9.25 C2.33579,9.25 2,9.58579 2,10.0000012 C2,10.4142 2.33579,10.75 2.75,10.75 L15.476,10.75 L10.2346,15.7073 C9.93371,15.9919 9.92049,16.4666 10.2051,16.7675 C10.4897,17.0684 10.9644,17.0817 11.2654,16.797 L17.6826,10.7276 C17.8489,10.5703 17.9489,10.3702 17.9826,10.1614 C17.994,10.1094 18,10.0554 18,10.0000012 C18,9.94241 17.9935,9.88633 17.9812,9.83246 C17.9462,9.62667 17.8467,9.42976 17.6826,9.27455 L11.2654,3.20511 Z"
        }))));
      }
    });

    var FilterIcon = vue.defineComponent({
      name: "Filter",
      render() {
        return /* @__PURE__ */ vue.h("svg", {
          viewBox: "0 0 28 28",
          version: "1.1",
          xmlns: "http://www.w3.org/2000/svg"
        }, /* @__PURE__ */ vue.h("g", {
          stroke: "none",
          "stroke-width": "1",
          "fill-rule": "evenodd"
        }, /* @__PURE__ */ vue.h("g", {
          "fill-rule": "nonzero"
        }, /* @__PURE__ */ vue.h("path", {
          d: "M17,19 C17.5522847,19 18,19.4477153 18,20 C18,20.5522847 17.5522847,21 17,21 L11,21 C10.4477153,21 10,20.5522847 10,20 C10,19.4477153 10.4477153,19 11,19 L17,19 Z M21,13 C21.5522847,13 22,13.4477153 22,14 C22,14.5522847 21.5522847,15 21,15 L7,15 C6.44771525,15 6,14.5522847 6,14 C6,13.4477153 6.44771525,13 7,13 L21,13 Z M24,7 C24.5522847,7 25,7.44771525 25,8 C25,8.55228475 24.5522847,9 24,9 L4,9 C3.44771525,9 3,8.55228475 3,8 C3,7.44771525 3.44771525,7 4,7 L24,7 Z"
        }))));
      }
    });

    var ForwardIcon = vue.defineComponent({
      name: "Forward",
      render() {
        return /* @__PURE__ */ vue.h("svg", {
          viewBox: "0 0 20 20",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg"
        }, /* @__PURE__ */ vue.h("path", {
          d: "M7.73271 4.20694C8.03263 3.92125 8.50737 3.93279 8.79306 4.23271L13.7944 9.48318C14.0703 9.77285 14.0703 10.2281 13.7944 10.5178L8.79306 15.7682C8.50737 16.0681 8.03263 16.0797 7.73271 15.794C7.43279 15.5083 7.42125 15.0336 7.70694 14.7336L12.2155 10.0005L7.70694 5.26729C7.42125 4.96737 7.43279 4.49264 7.73271 4.20694Z",
          fill: "currentColor"
        }));
      }
    });

    var InfoIcon = replaceable(
      "info",
      /* @__PURE__ */ vue.h("svg", {
        viewBox: "0 0 28 28",
        version: "1.1",
        xmlns: "http://www.w3.org/2000/svg"
      }, /* @__PURE__ */ vue.h("g", {
        stroke: "none",
        "stroke-width": "1",
        "fill-rule": "evenodd"
      }, /* @__PURE__ */ vue.h("g", {
        "fill-rule": "nonzero"
      }, /* @__PURE__ */ vue.h("path", {
        d: "M14,2 C20.6274,2 26,7.37258 26,14 C26,20.6274 20.6274,26 14,26 C7.37258,26 2,20.6274 2,14 C2,7.37258 7.37258,2 14,2 Z M14,11 C13.4477,11 13,11.4477 13,12 L13,12 L13,20 C13,20.5523 13.4477,21 14,21 C14.5523,21 15,20.5523 15,20 L15,20 L15,12 C15,11.4477 14.5523,11 14,11 Z M14,6.75 C13.3096,6.75 12.75,7.30964 12.75,8 C12.75,8.69036 13.3096,9.25 14,9.25 C14.6904,9.25 15.25,8.69036 15.25,8 C15.25,7.30964 14.6904,6.75 14,6.75 Z"
      }))))
    );

    var MoreIcon = vue.defineComponent({
      name: "More",
      render() {
        return /* @__PURE__ */ vue.h("svg", {
          viewBox: "0 0 16 16",
          version: "1.1",
          xmlns: "http://www.w3.org/2000/svg"
        }, /* @__PURE__ */ vue.h("g", {
          stroke: "none",
          "stroke-width": "1",
          fill: "none",
          "fill-rule": "evenodd"
        }, /* @__PURE__ */ vue.h("g", {
          fill: "currentColor",
          "fill-rule": "nonzero"
        }, /* @__PURE__ */ vue.h("path", {
          d: "M4,7 C4.55228,7 5,7.44772 5,8 C5,8.55229 4.55228,9 4,9 C3.44772,9 3,8.55229 3,8 C3,7.44772 3.44772,7 4,7 Z M8,7 C8.55229,7 9,7.44772 9,8 C9,8.55229 8.55229,9 8,9 C7.44772,9 7,8.55229 7,8 C7,7.44772 7.44772,7 8,7 Z M12,7 C12.5523,7 13,7.44772 13,8 C13,8.55229 12.5523,9 12,9 C11.4477,9 11,8.55229 11,8 C11,7.44772 11.4477,7 12,7 Z"
        }))));
      }
    });

    var RemoveIcon = vue.defineComponent({
      name: "Remove",
      render() {
        return /* @__PURE__ */ vue.h("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 512 512"
        }, /* @__PURE__ */ vue.h("line", {
          x1: "400",
          y1: "256",
          x2: "112",
          y2: "256",
          style: "\n        fill: none;\n        stroke: currentColor;\n        stroke-linecap: round;\n        stroke-linejoin: round;\n        stroke-width: 32px;\n      "
        }));
      }
    });

    var SearchIcon = vue.defineComponent({
      name: "Search",
      render() {
        return /* @__PURE__ */ vue.h("svg", {
          version: "1.1",
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 512 512",
          style: "enable-background: new 0 0 512 512"
        }, /* @__PURE__ */ vue.h("path", {
          d: "M443.5,420.2L336.7,312.4c20.9-26.2,33.5-59.4,33.5-95.5c0-84.5-68.5-153-153.1-153S64,132.5,64,217s68.5,153,153.1,153\n  c36.6,0,70.1-12.8,96.5-34.2l106.1,107.1c3.2,3.4,7.6,5.1,11.9,5.1c4.1,0,8.2-1.5,11.3-4.5C449.5,437.2,449.7,426.8,443.5,420.2z\n   M217.1,337.1c-32.1,0-62.3-12.5-85-35.2c-22.7-22.7-35.2-52.9-35.2-84.9c0-32.1,12.5-62.3,35.2-84.9c22.7-22.7,52.9-35.2,85-35.2\n  c32.1,0,62.3,12.5,85,35.2c22.7,22.7,35.2,52.9,35.2,84.9c0,32.1-12.5,62.3-35.2,84.9C279.4,324.6,249.2,337.1,217.1,337.1z"
        }));
      }
    });

    var SuccessIcon = replaceable(
      "success",
      /* @__PURE__ */ vue.h("svg", {
        viewBox: "0 0 48 48",
        version: "1.1",
        xmlns: "http://www.w3.org/2000/svg"
      }, /* @__PURE__ */ vue.h("g", {
        stroke: "none",
        "stroke-width": "1",
        "fill-rule": "evenodd"
      }, /* @__PURE__ */ vue.h("g", {
        "fill-rule": "nonzero"
      }, /* @__PURE__ */ vue.h("path", {
        d: "M24,4 C35.045695,4 44,12.954305 44,24 C44,35.045695 35.045695,44 24,44 C12.954305,44 4,35.045695 4,24 C4,12.954305 12.954305,4 24,4 Z M32.6338835,17.6161165 C32.1782718,17.1605048 31.4584514,17.1301307 30.9676119,17.5249942 L30.8661165,17.6161165 L20.75,27.732233 L17.1338835,24.1161165 C16.6457281,23.6279612 15.8542719,23.6279612 15.3661165,24.1161165 C14.9105048,24.5717282 14.8801307,25.2915486 15.2749942,25.7823881 L15.3661165,25.8838835 L19.8661165,30.3838835 C20.3217282,30.8394952 21.0415486,30.8698693 21.5323881,30.4750058 L21.6338835,30.3838835 L32.6338835,19.3838835 C33.1220388,18.8957281 33.1220388,18.1042719 32.6338835,17.6161165 Z"
      }))))
    );

    var SwitcherIcon = vue.defineComponent({
      name: "Switcher",
      render() {
        return /* @__PURE__ */ vue.h("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 32 32"
        }, /* @__PURE__ */ vue.h("path", {
          d: "M12 8l10 8l-10 8z"
        }));
      }
    });

    var TimeIcon = replaceable(
      "time",
      /* @__PURE__ */ vue.h("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 512 512"
      }, /* @__PURE__ */ vue.h("path", {
        d: "M256,64C150,64,64,150,64,256s86,192,192,192,192-86,192-192S362,64,256,64Z",
        style: "\n        fill: none;\n        stroke: currentColor;\n        stroke-miterlimit: 10;\n        stroke-width: 32px;\n      "
      }), /* @__PURE__ */ vue.h("polyline", {
        points: "256 128 256 272 352 272",
        style: "\n        fill: none;\n        stroke: currentColor;\n        stroke-linecap: round;\n        stroke-linejoin: round;\n        stroke-width: 32px;\n      "
      }))
    );

    var WarningIcon = replaceable(
      "warning",
      /* @__PURE__ */ vue.h("svg", {
        viewBox: "0 0 24 24",
        version: "1.1",
        xmlns: "http://www.w3.org/2000/svg"
      }, /* @__PURE__ */ vue.h("g", {
        stroke: "none",
        "stroke-width": "1",
        "fill-rule": "evenodd"
      }, /* @__PURE__ */ vue.h("g", {
        "fill-rule": "nonzero"
      }, /* @__PURE__ */ vue.h("path", {
        d: "M12,2 C17.523,2 22,6.478 22,12 C22,17.522 17.523,22 12,22 C6.477,22 2,17.522 2,12 C2,6.478 6.477,2 12,2 Z M12.0018002,15.0037242 C11.450254,15.0037242 11.0031376,15.4508407 11.0031376,16.0023869 C11.0031376,16.553933 11.450254,17.0010495 12.0018002,17.0010495 C12.5533463,17.0010495 13.0004628,16.553933 13.0004628,16.0023869 C13.0004628,15.4508407 12.5533463,15.0037242 12.0018002,15.0037242 Z M11.99964,7 C11.4868042,7.00018474 11.0642719,7.38637706 11.0066858,7.8837365 L11,8.00036004 L11.0018003,13.0012393 L11.00857,13.117858 C11.0665141,13.6151758 11.4893244,14.0010638 12.0021602,14.0008793 C12.514996,14.0006946 12.9375283,13.6145023 12.9951144,13.1171428 L13.0018002,13.0005193 L13,7.99964009 L12.9932303,7.8830214 C12.9352861,7.38570354 12.5124758,6.99981552 11.99964,7 Z"
      }))))
    );

    var CancelIcon = replaceable(
      "cancel",
      /* @__PURE__ */ vue.h("svg", {
        viewBox: "0 0 16 16",
        version: "1.1",
        xmlns: "http://www.w3.org/2000/svg"
      }, /* @__PURE__ */ vue.h("g", {
        stroke: "none",
        "stroke-width": "1",
        fill: "none",
        "fill-rule": "evenodd"
      }, /* @__PURE__ */ vue.h("g", {
        fill: "currentColor",
        "fill-rule": "nonzero"
      }, /* @__PURE__ */ vue.h("path", {
        d: "M2.58859116,2.7156945 L2.64644661,2.64644661 C2.82001296,2.47288026 3.08943736,2.45359511 3.2843055,2.58859116 L3.35355339,2.64644661 L8,7.293 L12.6464466,2.64644661 C12.8417088,2.45118446 13.1582912,2.45118446 13.3535534,2.64644661 C13.5488155,2.84170876 13.5488155,3.15829124 13.3535534,3.35355339 L8.707,8 L13.3535534,12.6464466 C13.5271197,12.820013 13.5464049,13.0894374 13.4114088,13.2843055 L13.3535534,13.3535534 C13.179987,13.5271197 12.9105626,13.5464049 12.7156945,13.4114088 L12.6464466,13.3535534 L8,8.707 L3.35355339,13.3535534 C3.15829124,13.5488155 2.84170876,13.5488155 2.64644661,13.3535534 C2.45118446,13.1582912 2.45118446,12.8417088 2.64644661,12.6464466 L7.293,8 L2.64644661,3.35355339 C2.47288026,3.17998704 2.45359511,2.91056264 2.58859116,2.7156945 L2.64644661,2.64644661 L2.58859116,2.7156945 Z"
      }))))
    );

    var ChevronDownIcon = vue.defineComponent({
      name: "ChevronDown",
      render() {
        return /* @__PURE__ */ vue.h("svg", {
          viewBox: "0 0 16 16",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg"
        }, /* @__PURE__ */ vue.h("path", {
          d: "M3.14645 5.64645C3.34171 5.45118 3.65829 5.45118 3.85355 5.64645L8 9.79289L12.1464 5.64645C12.3417 5.45118 12.6583 5.45118 12.8536 5.64645C13.0488 5.84171 13.0488 6.15829 12.8536 6.35355L8.35355 10.8536C8.15829 11.0488 7.84171 11.0488 7.64645 10.8536L3.14645 6.35355C2.95118 6.15829 2.95118 5.84171 3.14645 5.64645Z",
          fill: "currentColor"
        }));
      }
    });

    var ClearIcon = replaceable(
      "clear",
      /* @__PURE__ */ vue.h("svg", {
        viewBox: "0 0 16 16",
        version: "1.1",
        xmlns: "http://www.w3.org/2000/svg"
      }, /* @__PURE__ */ vue.h("g", {
        stroke: "none",
        "stroke-width": "1",
        fill: "none",
        "fill-rule": "evenodd"
      }, /* @__PURE__ */ vue.h("g", {
        fill: "currentColor",
        "fill-rule": "nonzero"
      }, /* @__PURE__ */ vue.h("path", {
        d: "M8,2 C11.3137085,2 14,4.6862915 14,8 C14,11.3137085 11.3137085,14 8,14 C4.6862915,14 2,11.3137085 2,8 C2,4.6862915 4.6862915,2 8,2 Z M6.5343055,5.83859116 C6.33943736,5.70359511 6.07001296,5.72288026 5.89644661,5.89644661 L5.89644661,5.89644661 L5.83859116,5.9656945 C5.70359511,6.16056264 5.72288026,6.42998704 5.89644661,6.60355339 L5.89644661,6.60355339 L7.293,8 L5.89644661,9.39644661 L5.83859116,9.4656945 C5.70359511,9.66056264 5.72288026,9.92998704 5.89644661,10.1035534 L5.89644661,10.1035534 L5.9656945,10.1614088 C6.16056264,10.2964049 6.42998704,10.2771197 6.60355339,10.1035534 L6.60355339,10.1035534 L8,8.707 L9.39644661,10.1035534 L9.4656945,10.1614088 C9.66056264,10.2964049 9.92998704,10.2771197 10.1035534,10.1035534 L10.1035534,10.1035534 L10.1614088,10.0343055 C10.2964049,9.83943736 10.2771197,9.57001296 10.1035534,9.39644661 L10.1035534,9.39644661 L8.707,8 L10.1035534,6.60355339 L10.1614088,6.5343055 C10.2964049,6.33943736 10.2771197,6.07001296 10.1035534,5.89644661 L10.1035534,5.89644661 L10.0343055,5.83859116 C9.83943736,5.70359511 9.57001296,5.72288026 9.39644661,5.89644661 L9.39644661,5.89644661 L8,7.293 L6.60355339,5.89644661 Z"
      }))))
    );

    var ChevronDownFilledIcon = vue.defineComponent({
      name: "ChevronDownFilled",
      render() {
        return /* @__PURE__ */ vue.h("svg", {
          viewBox: "0 0 16 16",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg"
        }, /* @__PURE__ */ vue.h("path", {
          d: "M3.20041 5.73966C3.48226 5.43613 3.95681 5.41856 4.26034 5.70041L8 9.22652L11.7397 5.70041C12.0432 5.41856 12.5177 5.43613 12.7996 5.73966C13.0815 6.0432 13.0639 6.51775 12.7603 6.7996L8.51034 10.7996C8.22258 11.0668 7.77743 11.0668 7.48967 10.7996L3.23966 6.7996C2.93613 6.51775 2.91856 6.0432 3.20041 5.73966Z",
          fill: "currentColor"
        }));
      }
    });

    var ToIcon = replaceable(
      "to",
      /* @__PURE__ */ vue.h("svg", {
        viewBox: "0 0 20 20",
        version: "1.1",
        xmlns: "http://www.w3.org/2000/svg"
      }, /* @__PURE__ */ vue.h("g", {
        stroke: "none",
        "stroke-width": "1",
        fill: "none",
        "fill-rule": "evenodd"
      }, /* @__PURE__ */ vue.h("g", {
        fill: "currentColor",
        "fill-rule": "nonzero"
      }, /* @__PURE__ */ vue.h("path", {
        d: "M11.2654,3.20511 C10.9644,2.92049 10.4897,2.93371 10.2051,3.23464 C9.92049,3.53558 9.93371,4.01027 10.2346,4.29489 L15.4737,9.25 L2.75,9.25 C2.33579,9.25 2,9.58579 2,10.0000012 C2,10.4142 2.33579,10.75 2.75,10.75 L15.476,10.75 L10.2346,15.7073 C9.93371,15.9919 9.92049,16.4666 10.2051,16.7675 C10.4897,17.0684 10.9644,17.0817 11.2654,16.797 L17.6826,10.7276 C17.8489,10.5703 17.9489,10.3702 17.9826,10.1614 C17.994,10.1094 18,10.0554 18,10.0000012 C18,9.94241 17.9935,9.88633 17.9812,9.83246 C17.9462,9.62667 17.8467,9.42976 17.6826,9.27455 L11.2654,3.20511 Z"
      }))))
    );

    var RetryIcon = replaceable(
      "retry",
      /* @__PURE__ */ vue.h("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 512 512"
      }, /* @__PURE__ */ vue.h("path", {
        d: "M320,146s24.36-12-64-12A160,160,0,1,0,416,294",
        style: "fill: none; stroke: currentcolor; stroke-linecap: round; stroke-miterlimit: 10; stroke-width: 32px;"
      }), /* @__PURE__ */ vue.h("polyline", {
        points: "256 58 336 138 256 218",
        style: "fill: none; stroke: currentcolor; stroke-linecap: round; stroke-linejoin: round; stroke-width: 32px;"
      }))
    );

    var ArrowBackIcon = vue.defineComponent({
      name: "ArrowBack",
      render() {
        return /* @__PURE__ */ vue.h("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 24 24"
        }, /* @__PURE__ */ vue.h("path", {
          d: "M0 0h24v24H0V0z",
          fill: "none"
        }), /* @__PURE__ */ vue.h("path", {
          d: "M19 11H7.83l4.88-4.88c.39-.39.39-1.03 0-1.42-.39-.39-1.02-.39-1.41 0l-6.59 6.59c-.39.39-.39 1.02 0 1.41l6.59 6.59c.39.39 1.02.39 1.41 0 .39-.39.39-1.02 0-1.41L7.83 13H19c.55 0 1-.45 1-1s-.45-1-1-1z"
        }));
      }
    });

    var RotateClockwiseIcon = replaceable(
      "rotateClockwise",
      /* @__PURE__ */ vue.h("svg", {
        viewBox: "0 0 20 20",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      }, /* @__PURE__ */ vue.h("path", {
        d: "M3 10C3 6.13401 6.13401 3 10 3C13.866 3 17 6.13401 17 10C17 12.7916 15.3658 15.2026 13 16.3265V14.5C13 14.2239 12.7761 14 12.5 14C12.2239 14 12 14.2239 12 14.5V17.5C12 17.7761 12.2239 18 12.5 18H15.5C15.7761 18 16 17.7761 16 17.5C16 17.2239 15.7761 17 15.5 17H13.8758C16.3346 15.6357 18 13.0128 18 10C18 5.58172 14.4183 2 10 2C5.58172 2 2 5.58172 2 10C2 10.2761 2.22386 10.5 2.5 10.5C2.77614 10.5 3 10.2761 3 10Z",
        fill: "currentColor"
      }), /* @__PURE__ */ vue.h("path", {
        d: "M10 12C11.1046 12 12 11.1046 12 10C12 8.89543 11.1046 8 10 8C8.89543 8 8 8.89543 8 10C8 11.1046 8.89543 12 10 12ZM10 11C9.44772 11 9 10.5523 9 10C9 9.44772 9.44772 9 10 9C10.5523 9 11 9.44772 11 10C11 10.5523 10.5523 11 10 11Z",
        fill: "currentColor"
      }))
    );

    var RotateCounterclockwiseIcon = replaceable(
      "rotateClockwise",
      /* @__PURE__ */ vue.h("svg", {
        viewBox: "0 0 20 20",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      }, /* @__PURE__ */ vue.h("path", {
        d: "M17 10C17 6.13401 13.866 3 10 3C6.13401 3 3 6.13401 3 10C3 12.7916 4.63419 15.2026 7 16.3265V14.5C7 14.2239 7.22386 14 7.5 14C7.77614 14 8 14.2239 8 14.5V17.5C8 17.7761 7.77614 18 7.5 18H4.5C4.22386 18 4 17.7761 4 17.5C4 17.2239 4.22386 17 4.5 17H6.12422C3.66539 15.6357 2 13.0128 2 10C2 5.58172 5.58172 2 10 2C14.4183 2 18 5.58172 18 10C18 10.2761 17.7761 10.5 17.5 10.5C17.2239 10.5 17 10.2761 17 10Z",
        fill: "currentColor"
      }), /* @__PURE__ */ vue.h("path", {
        d: "M10 12C8.89543 12 8 11.1046 8 10C8 8.89543 8.89543 8 10 8C11.1046 8 12 8.89543 12 10C12 11.1046 11.1046 12 10 12ZM10 11C10.5523 11 11 10.5523 11 10C11 9.44772 10.5523 9 10 9C9.44772 9 9 9.44772 9 10C9 10.5523 9.44772 11 10 11Z",
        fill: "currentColor"
      }))
    );

    var ZoomInIcon = replaceable(
      "zoomIn",
      /* @__PURE__ */ vue.h("svg", {
        viewBox: "0 0 20 20",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      }, /* @__PURE__ */ vue.h("path", {
        d: "M11.5 8.5C11.5 8.22386 11.2761 8 11 8H9V6C9 5.72386 8.77614 5.5 8.5 5.5C8.22386 5.5 8 5.72386 8 6V8H6C5.72386 8 5.5 8.22386 5.5 8.5C5.5 8.77614 5.72386 9 6 9H8V11C8 11.2761 8.22386 11.5 8.5 11.5C8.77614 11.5 9 11.2761 9 11V9H11C11.2761 9 11.5 8.77614 11.5 8.5Z",
        fill: "currentColor"
      }), /* @__PURE__ */ vue.h("path", {
        d: "M8.5 3C11.5376 3 14 5.46243 14 8.5C14 9.83879 13.5217 11.0659 12.7266 12.0196L16.8536 16.1464C17.0488 16.3417 17.0488 16.6583 16.8536 16.8536C16.68 17.0271 16.4106 17.0464 16.2157 16.9114L16.1464 16.8536L12.0196 12.7266C11.0659 13.5217 9.83879 14 8.5 14C5.46243 14 3 11.5376 3 8.5C3 5.46243 5.46243 3 8.5 3ZM8.5 4C6.01472 4 4 6.01472 4 8.5C4 10.9853 6.01472 13 8.5 13C10.9853 13 13 10.9853 13 8.5C13 6.01472 10.9853 4 8.5 4Z",
        fill: "currentColor"
      }))
    );

    var ZoomOutIcon = replaceable(
      "zoomOut",
      /* @__PURE__ */ vue.h("svg", {
        viewBox: "0 0 20 20",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      }, /* @__PURE__ */ vue.h("path", {
        d: "M11 8C11.2761 8 11.5 8.22386 11.5 8.5C11.5 8.77614 11.2761 9 11 9H6C5.72386 9 5.5 8.77614 5.5 8.5C5.5 8.22386 5.72386 8 6 8H11Z",
        fill: "currentColor"
      }), /* @__PURE__ */ vue.h("path", {
        d: "M14 8.5C14 5.46243 11.5376 3 8.5 3C5.46243 3 3 5.46243 3 8.5C3 11.5376 5.46243 14 8.5 14C9.83879 14 11.0659 13.5217 12.0196 12.7266L16.1464 16.8536L16.2157 16.9114C16.4106 17.0464 16.68 17.0271 16.8536 16.8536C17.0488 16.6583 17.0488 16.3417 16.8536 16.1464L12.7266 12.0196C13.5217 11.0659 14 9.83879 14 8.5ZM4 8.5C4 6.01472 6.01472 4 8.5 4C10.9853 4 13 6.01472 13 8.5C13 10.9853 10.9853 13 8.5 13C6.01472 13 4 10.9853 4 8.5Z",
        fill: "currentColor"
      }))
    );

    var ResizeSmallIcon = vue.defineComponent({
      name: "ResizeSmall",
      render() {
        return /* @__PURE__ */ vue.h("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 20 20"
        }, /* @__PURE__ */ vue.h("g", {
          fill: "none"
        }, /* @__PURE__ */ vue.h("path", {
          d: "M5.5 4A1.5 1.5 0 0 0 4 5.5v1a.5.5 0 0 1-1 0v-1A2.5 2.5 0 0 1 5.5 3h1a.5.5 0 0 1 0 1h-1zM16 5.5A1.5 1.5 0 0 0 14.5 4h-1a.5.5 0 0 1 0-1h1A2.5 2.5 0 0 1 17 5.5v1a.5.5 0 0 1-1 0v-1zm0 9a1.5 1.5 0 0 1-1.5 1.5h-1a.5.5 0 0 0 0 1h1a2.5 2.5 0 0 0 2.5-2.5v-1a.5.5 0 0 0-1 0v1zm-12 0A1.5 1.5 0 0 0 5.5 16h1.25a.5.5 0 0 1 0 1H5.5A2.5 2.5 0 0 1 3 14.5v-1.25a.5.5 0 0 1 1 0v1.25zM8.5 7A1.5 1.5 0 0 0 7 8.5v3A1.5 1.5 0 0 0 8.5 13h3a1.5 1.5 0 0 0 1.5-1.5v-3A1.5 1.5 0 0 0 11.5 7h-3zM8 8.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v3a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-3z",
          fill: "currentColor"
        })));
      }
    });

    var NIconSwitchTransition = vue.defineComponent({
      name: "BaseIconSwitchTransition",
      setup(_, { slots }) {
        const isMountedRef = isMounted();
        return () => /* @__PURE__ */ vue.h(vue.Transition, {
          name: "icon-switch-transition",
          appear: isMountedRef.value
        }, slots);
      }
    });

    var NFadeInExpandTransition = vue.defineComponent({
      name: "FadeInExpandTransition",
      props: {
        appear: Boolean,
        group: Boolean,
        mode: String,
        onLeave: Function,
        onAfterLeave: Function,
        onAfterEnter: Function,
        width: Boolean,
        reverse: Boolean
      },

      setup(props, _ref) {
        let {
          slots
        } = _ref;

        function handleBeforeLeave(el) {
          if (props.width) {
            el.style.maxWidth = `${el.offsetWidth}px`;
          } else {
            el.style.maxHeight = `${el.offsetHeight}px`;
          }

          void el.offsetWidth;
        }

        function handleLeave(el) {
          if (props.width) {
            el.style.maxWidth = "0";
          } else {
            el.style.maxHeight = "0";
          }

          void el.offsetWidth;
          const {
            onLeave
          } = props;
          if (onLeave) onLeave();
        }

        function handleAfterLeave(el) {
          if (props.width) {
            el.style.maxWidth = "";
          } else {
            el.style.maxHeight = "";
          }

          const {
            onAfterLeave
          } = props;
          if (onAfterLeave) onAfterLeave();
        }

        function handleEnter(el) {
          el.style.transition = "none";

          if (props.width) {
            const memorizedWidth = el.offsetWidth;
            el.style.maxWidth = "0";
            void el.offsetWidth;
            el.style.transition = "";
            el.style.maxWidth = `${memorizedWidth}px`;
          } else {
            if (props.reverse) {
              el.style.maxHeight = `${el.offsetHeight}px`;
              void el.offsetHeight;
              el.style.transition = "";
              el.style.maxHeight = "0";
            } else {
              const memorizedHeight = el.offsetHeight;
              el.style.maxHeight = "0";
              void el.offsetWidth;
              el.style.transition = "";
              el.style.maxHeight = `${memorizedHeight}px`;
            }
          }

          void el.offsetWidth;
        }

        function handleAfterEnter(el) {
          var _props$onAfterEnter;

          if (props.width) {
            el.style.maxWidth = "";
          } else {
            if (!props.reverse) {
              el.style.maxHeight = "";
            }
          }

          (_props$onAfterEnter = props.onAfterEnter) === null || _props$onAfterEnter === void 0 ? void 0 : _props$onAfterEnter.call(props);
        }

        return () => {
          const type = props.group ? vue.TransitionGroup : vue.Transition;
          return vue.h(type, {
            name: props.width ? "fade-in-width-expand-transition" : "fade-in-height-expand-transition",
            mode: props.mode,
            appear: props.appear,
            onEnter: handleEnter,
            onAfterEnter: handleAfterEnter,
            onBeforeLeave: handleBeforeLeave,
            onLeave: handleLeave,
            onAfterLeave: handleAfterLeave
          }, slots);
        };
      }

    });

    var style$1y = cB("base-icon", `
  height: 1em;
  width: 1em;
  line-height: 1em;
  text-align: center;
  display: inline-block;
  position: relative;
  fill: currentColor;
  transform: translateZ(0);
`, [c$1("svg", `
    height: 1em;
    width: 1em;
  `)]);

    var NBaseIcon = vue.defineComponent({
      name: "BaseIcon",
      props: {
        role: String,
        ariaLabel: String,
        ariaDisabled: {
          type: Boolean,
          default: void 0
        },
        ariaHidden: {
          type: Boolean,
          default: void 0
        },
        clsPrefix: {
          type: String,
          required: true
        },
        onClick: Function,
        onMousedown: Function,
        onMouseup: Function
      },
      setup(props) {
        useStyle("-base-icon", style$1y, vue.toRef(props, "clsPrefix"));
      },
      render() {
        return /* @__PURE__ */ vue.h("i", {
          class: `${this.clsPrefix}-base-icon`,
          onClick: this.onClick,
          onMousedown: this.onMousedown,
          onMouseup: this.onMouseup,
          role: this.role,
          "aria-label": this.ariaLabel,
          "aria-hidden": this.ariaHidden,
          "aria-disabled": this.ariaDisabled
        }, this.$slots);
      }
    });

    var style$1x = cB("base-close", `
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  background-color: transparent;
  color: var(--n-close-icon-color);
  border-radius: var(--n-close-border-radius);
  height: var(--n-close-size);
  width: var(--n-close-size);
  font-size: var(--n-close-icon-size);
  outline: none;
  border: none;
  position: relative;
  padding: 0;
`, [cM("absolute", `
    height: var(--n-close-icon-size);
    width: var(--n-close-icon-size);
  `), c$1("&::before", `
    content: "";
    position: absolute;
    width: var(--n-close-size);
    height: var(--n-close-size);
    left: 50%;
    top: 50%;
    transform: translateY(-50%) translateX(-50%);
    transition: inherit;
    border-radius: inherit;
  `), cNotM("disabled", [c$1("&:hover", `
      color: var(--n-close-icon-color-hover);
    `), c$1("&:hover::before", `
      background-color: var(--n-close-color-hover);
    `), c$1("&:focus::before", `
      background-color: var(--n-close-color-hover);
    `), c$1("&:active", `
      color: var(--n-close-icon-color-pressed);
    `), c$1("&:active::before", `
      background-color: var(--n-close-color-pressed);
    `)]), cM("disabled", `
    cursor: not-allowed;
    color: var(--n-close-icon-color-disabled);
    background-color: transparent;
  `), cM("round", [c$1("&::before", `
      border-radius: 50%;
    `)])]);

    var NBaseClose = vue.defineComponent({
      name: "BaseClose",
      props: {
        clsPrefix: {
          type: String,
          required: true
        },
        disabled: {
          type: Boolean,
          default: void 0
        },
        focusable: {
          type: Boolean,
          default: true
        },
        round: Boolean,
        onClick: Function,
        absolute: Boolean
      },
      setup(props) {
        useStyle("-base-close", style$1x, vue.toRef(props, "clsPrefix"));
        return () => {
          const { clsPrefix, disabled, absolute, round } = props;
          return /* @__PURE__ */ vue.h("button", {
            type: "button",
            tabindex: disabled || !props.focusable ? -1 : 0,
            "aria-disabled": disabled,
            "aria-label": "close",
            disabled,
            class: [
              `${clsPrefix}-base-close`,
              absolute && `${clsPrefix}-base-close--absolute`,
              disabled && `${clsPrefix}-base-close--disabled`,
              round && `${clsPrefix}-base-close--round`
            ],
            onMousedown: (e) => {
              if (!props.focusable) {
                e.preventDefault();
              }
            },
            onClick: props.onClick
          }, /* @__PURE__ */ vue.h(NBaseIcon, {
            clsPrefix
          }, {
            default: () => /* @__PURE__ */ vue.h(ErrorIcon$1, null)
          }));
        };
      }
    });

    var FocusDetector = vue.defineComponent({
      props: {
        onFocus: Function,
        onBlur: Function
      },
      setup(props) {
        return () => /* @__PURE__ */ vue.h("div", {
          style: "width: 0; height: 0",
          tabindex: 0,
          onFocus: props.onFocus,
          onBlur: props.onBlur
        });
      }
    });

    const {
      cubicBezierEaseInOut: cubicBezierEaseInOut$4
    } = commonVariables$m;
    function iconSwitchTransition() {
      let {
        originalTransform = "",
        left = 0,
        top = 0,
        transition = `all .3s ${cubicBezierEaseInOut$4} !important`
      } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return [c$1("&.icon-switch-transition-enter-from, &.icon-switch-transition-leave-to", {
        transform: originalTransform + " scale(0.75)",
        left,
        top,
        opacity: 0
      }), c$1("&.icon-switch-transition-enter-to, &.icon-switch-transition-leave-from", {
        transform: `scale(1) ${originalTransform}`,
        left,
        top,
        opacity: 1
      }), c$1("&.icon-switch-transition-enter-active, &.icon-switch-transition-leave-active", {
        transformOrigin: "center",
        position: "absolute",
        left,
        top,
        transition
      })];
    }

    var style$1w = c$1([c$1("@keyframes loading-container-rotate", `
    to {
      -webkit-transform: rotate(360deg);
      transform: rotate(360deg);
    }
  `), c$1("@keyframes loading-layer-rotate", `
    12.5% {
      -webkit-transform: rotate(135deg);
      transform: rotate(135deg);
    }
    25% {
      -webkit-transform: rotate(270deg);
      transform: rotate(270deg);
    }
    37.5% {
      -webkit-transform: rotate(405deg);
      transform: rotate(405deg);
    }
    50% {
      -webkit-transform: rotate(540deg);
      transform: rotate(540deg);
    }
    62.5% {
      -webkit-transform: rotate(675deg);
      transform: rotate(675deg);
    }
    75% {
      -webkit-transform: rotate(810deg);
      transform: rotate(810deg);
    }
    87.5% {
      -webkit-transform: rotate(945deg);
      transform: rotate(945deg);
    }
    100% {
      -webkit-transform: rotate(1080deg);
      transform: rotate(1080deg);
    }
  `), c$1("@keyframes loading-left-spin", `
    from {
      -webkit-transform: rotate(265deg);
      transform: rotate(265deg);
    }
    50% {
      -webkit-transform: rotate(130deg);
      transform: rotate(130deg);
    }
    to {
      -webkit-transform: rotate(265deg);
      transform: rotate(265deg);
    }
  `), c$1("@keyframes loading-right-spin", `
    from {
      -webkit-transform: rotate(-265deg);
      transform: rotate(-265deg);
    }
    50% {
      -webkit-transform: rotate(-130deg);
      transform: rotate(-130deg);
    }
    to {
      -webkit-transform: rotate(-265deg);
      transform: rotate(-265deg);
    }
  `), cB("base-loading", `
    position: relative;
    line-height: 0;
    width: 1em;
    height: 1em;
  `, [cE("transition-wrapper", `
      position: absolute;
      width: 100%;
      height: 100%;
    `, [iconSwitchTransition()]), cE("container", `
      display: inline-flex;
      position: relative;
      direction: ltr;
      line-height: 0;
      animation: loading-container-rotate 1568.2352941176ms linear infinite;
      font-size: 0;
      letter-spacing: 0;
      white-space: nowrap;
      opacity: 1;
      width: 100%;
      height: 100%;
    `, [cE("svg", `
        stroke: var(--n-text-color);
        fill: transparent;
        position: absolute;
        height: 100%;
        overflow: hidden;
      `), cE("container-layer", `
        position: absolute;
        width: 100%;
        height: 100%;
        animation: loading-layer-rotate 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both;
      `, [cE("container-layer-left", `
          display: inline-flex;
          position: relative;
          width: 50%;
          height: 100%;
          overflow: hidden;
        `, [cE("svg", `
            animation: loading-left-spin 1333ms cubic-bezier(0.4, 0, 0.2, 1) infinite both;
            width: 200%;
          `)]), cE("container-layer-patch", `
          position: absolute;
          top: 0;
          left: 47.5%;
          box-sizing: border-box;
          width: 5%;
          height: 100%;
          overflow: hidden;
        `, [cE("svg", `
            left: -900%;
            width: 2000%;
            transform: rotate(180deg);
          `)]), cE("container-layer-right", `
          display: inline-flex;
          position: relative;
          width: 50%;
          height: 100%;
          overflow: hidden;
        `, [cE("svg", `
            animation: loading-right-spin 1333ms cubic-bezier(0.4, 0, 0.2, 1) infinite both;
            left: -100%;
            width: 200%;
          `)])])]), cE("placeholder", `
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translateX(-50%) translateY(-50%);
    `, [iconSwitchTransition({
      left: "50%",
      top: "50%",
      originalTransform: "translateX(-50%) translateY(-50%)"
    })])])]);

    var NBaseLoading = vue.defineComponent({
      name: "BaseLoading",
      props: {
        clsPrefix: {
          type: String,
          required: true
        },
        scale: {
          type: Number,
          default: 1
        },
        radius: {
          type: Number,
          default: 100
        },
        strokeWidth: {
          type: Number,
          default: 28
        },
        stroke: {
          type: String,
          default: void 0
        },
        show: {
          type: Boolean,
          default: true
        }
      },
      setup(props) {
        useStyle("-base-loading", style$1w, vue.toRef(props, "clsPrefix"));
      },
      render() {
        const { clsPrefix, radius, strokeWidth, stroke, scale } = this;
        const scaledRadius = radius / scale;
        return /* @__PURE__ */ vue.h("div", {
          class: `${clsPrefix}-base-loading`,
          role: "img",
          "aria-label": "loading"
        }, /* @__PURE__ */ vue.h(NIconSwitchTransition, null, {
          default: () => this.show ? /* @__PURE__ */ vue.h("div", {
            key: "icon",
            class: `${clsPrefix}-base-loading__transition-wrapper`
          }, /* @__PURE__ */ vue.h("div", {
            class: `${clsPrefix}-base-loading__container`
          }, /* @__PURE__ */ vue.h("div", {
            class: `${clsPrefix}-base-loading__container-layer`
          }, /* @__PURE__ */ vue.h("div", {
            class: `${clsPrefix}-base-loading__container-layer-left`
          }, /* @__PURE__ */ vue.h("svg", {
            class: `${clsPrefix}-base-loading__svg`,
            viewBox: `0 0 ${2 * scaledRadius} ${2 * scaledRadius}`,
            xmlns: "http://www.w3.org/2000/svg",
            style: { color: stroke }
          }, /* @__PURE__ */ vue.h("circle", {
            fill: "none",
            stroke: "currentColor",
            "stroke-width": strokeWidth,
            "stroke-linecap": "round",
            cx: scaledRadius,
            cy: scaledRadius,
            r: radius - strokeWidth / 2,
            "stroke-dasharray": 4.91 * radius,
            "stroke-dashoffset": 2.46 * radius
          }))), /* @__PURE__ */ vue.h("div", {
            class: `${clsPrefix}-base-loading__container-layer-patch`
          }, /* @__PURE__ */ vue.h("svg", {
            class: `${clsPrefix}-base-loading__svg`,
            viewBox: `0 0 ${2 * scaledRadius} ${2 * scaledRadius}`,
            xmlns: "http://www.w3.org/2000/svg",
            style: { color: stroke }
          }, /* @__PURE__ */ vue.h("circle", {
            fill: "none",
            stroke: "currentColor",
            "stroke-width": strokeWidth,
            "stroke-linecap": "round",
            cx: scaledRadius,
            cy: scaledRadius,
            r: radius - strokeWidth / 2,
            "stroke-dasharray": 4.91 * radius,
            "stroke-dashoffset": 2.46 * radius
          }))), /* @__PURE__ */ vue.h("div", {
            class: `${clsPrefix}-base-loading__container-layer-right`
          }, /* @__PURE__ */ vue.h("svg", {
            class: `${clsPrefix}-base-loading__svg`,
            viewBox: `0 0 ${2 * scaledRadius} ${2 * scaledRadius}`,
            xmlns: "http://www.w3.org/2000/svg",
            style: { color: stroke }
          }, /* @__PURE__ */ vue.h("circle", {
            fill: "none",
            stroke: "currentColor",
            "stroke-width": strokeWidth,
            "stroke-linecap": "round",
            cx: scaledRadius,
            cy: scaledRadius,
            r: radius - strokeWidth / 2,
            "stroke-dasharray": 4.91 * radius,
            "stroke-dashoffset": 2.46 * radius
          })))))) : /* @__PURE__ */ vue.h("div", {
            key: "placeholder",
            class: `${clsPrefix}-base-loading__placeholder`
          }, this.$slots)
        }));
      }
    });

    function toArray(arg) {
      if (Array.isArray(arg)) return arg;
      return [arg];
    } // Do not use enum for lint plugin has error

    const TRAVERSE_COMMAND = {
      STOP: 'STOP'
    };
    function traverseWithCb(treeNode, callback) {
      const command = callback(treeNode);

      if (treeNode.children !== undefined && command !== TRAVERSE_COMMAND.STOP) {
        treeNode.children.forEach(childNode => traverseWithCb(childNode, callback));
      }
    }
    function getNonLeafKeys(treeNodes) {
      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      const {
        preserveGroup = false
      } = options;
      const keys = [];
      const cb = preserveGroup ? node => {
        if (!node.isLeaf) {
          keys.push(node.key);
          traverse(node.children);
        }
      } : node => {
        if (!node.isLeaf) {
          if (!node.isGroup) keys.push(node.key);
          traverse(node.children);
        }
      };

      function traverse(nodes) {
        nodes.forEach(cb);
      }

      traverse(treeNodes);
      return keys;
    }
    function isLeaf(rawNode, getChildren) {
      const {
        isLeaf
      } = rawNode;
      if (isLeaf !== undefined) return isLeaf;else if (!getChildren(rawNode)) return true;
      return false;
    }
    function defaultGetChildren(node) {
      return node.children;
    }
    function defaultGetKey(node) {
      return node.key;
    }
    function isIgnored() {
      return false;
    }
    function isShallowLoaded(rawNode, getChildren) {
      const {
        isLeaf
      } = rawNode;
      if (isLeaf === false && !Array.isArray(getChildren(rawNode))) return false;
      return true;
    }
    function isDisabled(rawNode) {
      return rawNode.disabled === true;
    }
    function isExpilicitlyNotLoaded(rawNode, getChildren) {
      return rawNode.isLeaf === false && !Array.isArray(getChildren(rawNode));
    }
    function isNodeInvalid(rawNode, getChildren) {
      if (rawNode.isLeaf === true) {
        const children = getChildren(rawNode);
        if (Array.isArray(children) && children.length > 0) return true;
      }

      return false;
    }
    function unwrapCheckedKeys(result) {
      var _a;

      if (result === undefined || result === null) return [];
      if (Array.isArray(result)) return result;
      return (_a = result.checkedKeys) !== null && _a !== void 0 ? _a : [];
    }
    function unwrapIndeterminateKeys(result) {
      var _a;

      if (result === undefined || result === null || Array.isArray(result)) {
        return [];
      }

      return (_a = result.indeterminateKeys) !== null && _a !== void 0 ? _a : [];
    }
    function merge(originalKeys, keysToAdd) {
      const set = new Set(originalKeys);
      keysToAdd.forEach(key => {
        if (!set.has(key)) {
          set.add(key);
        }
      });
      return Array.from(set);
    }
    function minus(originalKeys, keysToRemove) {
      const set = new Set(originalKeys);
      keysToRemove.forEach(key => {
        if (set.has(key)) {
          set.delete(key);
        }
      });
      return Array.from(set);
    }
    function isGroup(rawNode) {
      return (rawNode === null || rawNode === void 0 ? void 0 : rawNode.type) === 'group';
    }
    function createIndexGetter(treeNodes) {
      const map = new Map();
      treeNodes.forEach((treeNode, i) => {
        map.set(treeNode.key, i);
      });
      return key => {
        var _a;

        return (_a = map.get(key)) !== null && _a !== void 0 ? _a : null;
      };
    }

    class SubtreeNotLoadedError extends Error {
      constructor() {
        super();
        this.message = 'SubtreeNotLoadedError: checking a subtree whose required nodes are not fully loaded.';
      }

    }

    function getExtendedCheckedKeySetAfterCheck(checkKeys, currentCheckedKeys, treeMate, allowNotLoaded) {
      return getExtendedCheckedKeySet(currentCheckedKeys.concat(checkKeys), treeMate, allowNotLoaded, false);
    }

    function getAvailableAscendantNodeSet(uncheckedKeys, treeMate) {
      const visitedKeys = new Set();
      uncheckedKeys.forEach(uncheckedKey => {
        const uncheckedTreeNode = treeMate.treeNodeMap.get(uncheckedKey);

        if (uncheckedTreeNode !== undefined) {
          let nodeCursor = uncheckedTreeNode.parent;

          while (nodeCursor !== null) {
            if (nodeCursor.disabled) break;
            if (visitedKeys.has(nodeCursor.key)) break;else {
              visitedKeys.add(nodeCursor.key);
            }
            nodeCursor = nodeCursor.parent;
          }
        }
      });
      return visitedKeys;
    }

    function getExtendedCheckedKeySetAfterUncheck(uncheckedKeys, currentCheckedKeys, treeMate, allowNotLoaded) {
      const extendedCheckedKeySet = getExtendedCheckedKeySet(currentCheckedKeys, treeMate, allowNotLoaded, false);
      const extendedKeySetToUncheck = getExtendedCheckedKeySet(uncheckedKeys, treeMate, allowNotLoaded, true);
      const ascendantKeySet = getAvailableAscendantNodeSet(uncheckedKeys, treeMate);
      const keysToRemove = [];
      extendedCheckedKeySet.forEach(key => {
        if (extendedKeySetToUncheck.has(key) || ascendantKeySet.has(key)) {
          keysToRemove.push(key);
        }
      });
      keysToRemove.forEach(key => extendedCheckedKeySet.delete(key));
      return extendedCheckedKeySet;
    }

    function getCheckedKeys(options, treeMate) {
      const {
        checkedKeys,
        keysToCheck,
        keysToUncheck,
        indeterminateKeys,
        cascade,
        leafOnly,
        checkStrategy,
        allowNotLoaded
      } = options;

      if (!cascade) {
        if (keysToCheck !== undefined) {
          return {
            checkedKeys: merge(checkedKeys, keysToCheck),
            indeterminateKeys: Array.from(indeterminateKeys)
          };
        } else if (keysToUncheck !== undefined) {
          return {
            checkedKeys: minus(checkedKeys, keysToUncheck),
            indeterminateKeys: Array.from(indeterminateKeys)
          };
        } else {
          return {
            checkedKeys: Array.from(checkedKeys),
            indeterminateKeys: Array.from(indeterminateKeys)
          };
        }
      }

      const {
        levelTreeNodeMap
      } = treeMate;
      let extendedCheckedKeySet;

      if (keysToUncheck !== undefined) {
        extendedCheckedKeySet = getExtendedCheckedKeySetAfterUncheck(keysToUncheck, checkedKeys, treeMate, allowNotLoaded);
      } else if (keysToCheck !== undefined) {
        extendedCheckedKeySet = getExtendedCheckedKeySetAfterCheck(keysToCheck, checkedKeys, treeMate, allowNotLoaded);
      } else {
        extendedCheckedKeySet = getExtendedCheckedKeySet(checkedKeys, treeMate, allowNotLoaded, false);
      }

      const checkStrategyIsParent = checkStrategy === 'parent';
      const checkStrategyIsChild = checkStrategy === 'child' || leafOnly;
      const syntheticCheckedKeySet = extendedCheckedKeySet;
      const syntheticIndeterminateKeySet = new Set();
      const maxLevel = Math.max.apply(null, Array.from(levelTreeNodeMap.keys())); // cascade check
      // 1. if tree is fully loaded, it just works
      // 2. if the tree is not fully loaded, we assume that keys which is in not
      //    loaded tree are not in checked keys
      //    for example:
      //    a -- b(fully-loaded)   -- c(fully-loaded)
      //      |- d(partial-loaded) -- ?e(not-loaded)
      //    in the case, `e` is assumed not to be checked, nor we can't calc `d`'s
      //    and `a`'s status

      for (let level = maxLevel; level >= 0; level -= 1) {
        const levelIsZero = level === 0; // it should exists, nor it is a bug

        const levelTreeNodes = levelTreeNodeMap.get(level);

        for (const levelTreeNode of levelTreeNodes) {
          if (levelTreeNode.isLeaf) continue;
          const {
            key: levelTreeNodeKey,
            shallowLoaded
          } = levelTreeNode;

          if (checkStrategyIsChild && shallowLoaded) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            levelTreeNode.children.forEach(v => {
              if (!v.disabled && !v.isLeaf && v.shallowLoaded && syntheticCheckedKeySet.has(v.key)) {
                syntheticCheckedKeySet.delete(v.key);
              }
            });
          }

          if (levelTreeNode.disabled || !shallowLoaded) {
            continue;
          }

          let fullyChecked = true;
          let partialChecked = false;
          let allDisabled = true; // it is shallow loaded, so `children` must exist

          for (const childNode of levelTreeNode.children) {
            const childKey = childNode.key;
            if (childNode.disabled) continue;
            if (allDisabled) allDisabled = false;

            if (syntheticCheckedKeySet.has(childKey)) {
              partialChecked = true;
            } else if (syntheticIndeterminateKeySet.has(childKey)) {
              partialChecked = true;
              fullyChecked = false;
              break;
            } else {
              fullyChecked = false;

              if (partialChecked) {
                break;
              }
            }
          }

          if (fullyChecked && !allDisabled) {
            if (checkStrategyIsParent) {
              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
              levelTreeNode.children.forEach(v => {
                if (!v.disabled && syntheticCheckedKeySet.has(v.key)) {
                  syntheticCheckedKeySet.delete(v.key);
                }
              });
            }

            syntheticCheckedKeySet.add(levelTreeNodeKey);
          } else if (partialChecked) {
            syntheticIndeterminateKeySet.add(levelTreeNodeKey);
          }

          if (levelIsZero && checkStrategyIsChild && syntheticCheckedKeySet.has(levelTreeNodeKey)) {
            syntheticCheckedKeySet.delete(levelTreeNodeKey);
          }
        }
      }

      return {
        checkedKeys: Array.from(syntheticCheckedKeySet),
        indeterminateKeys: Array.from(syntheticIndeterminateKeySet)
      };
    } // unchecking is safe when doing cascade uncheck in async mode

    function getExtendedCheckedKeySet(checkedKeys, treeMate, allowNotLoaded, isUnchecking) {
      const {
        treeNodeMap,
        getChildren
      } = treeMate;
      const visitedKeySet = new Set();
      const extendedKeySet = new Set(checkedKeys);
      checkedKeys.forEach(checkedKey => {
        const checkedTreeNode = treeNodeMap.get(checkedKey);

        if (checkedTreeNode !== undefined) {
          traverseWithCb(checkedTreeNode, treeNode => {
            if (treeNode.disabled) {
              return TRAVERSE_COMMAND.STOP;
            }

            const {
              key
            } = treeNode;
            if (visitedKeySet.has(key)) return;
            visitedKeySet.add(key); // Adding keys before loaded check is okay, since if not valid error
            // would be thrown

            extendedKeySet.add(key);

            if (isExpilicitlyNotLoaded(treeNode.rawNode, getChildren)) {
              if (isUnchecking) {
                return TRAVERSE_COMMAND.STOP;
              } else if (!allowNotLoaded) {
                throw new SubtreeNotLoadedError();
              }
            }
          });
        }
      });
      return extendedKeySet;
    }

    function getPath(key, _ref, treeMate) {
      let {
        includeGroup = false,
        includeSelf = true
      } = _ref;

      var _a;

      const treeNodeMap = treeMate.treeNodeMap;
      let treeNode = key === null || key === undefined ? null : (_a = treeNodeMap.get(key)) !== null && _a !== void 0 ? _a : null;
      const mergedPath = {
        keyPath: [],
        treeNodePath: [],
        treeNode: treeNode
      };

      if (treeNode === null || treeNode === void 0 ? void 0 : treeNode.ignored) {
        mergedPath.treeNode = null;
        return mergedPath;
      }

      while (treeNode) {
        if (!treeNode.ignored && (includeGroup || !treeNode.isGroup)) {
          mergedPath.treeNodePath.push(treeNode);
        }

        treeNode = treeNode.parent;
      }

      mergedPath.treeNodePath.reverse();
      if (!includeSelf) mergedPath.treeNodePath.pop();
      mergedPath.keyPath = mergedPath.treeNodePath.map(treeNode => treeNode.key);
      return mergedPath;
    }

    function getFirstAvailableNode(nodes) {
      if (nodes.length === 0) return null;
      const node = nodes[0];

      if (node.isGroup || node.ignored || node.disabled) {
        return node.getNext();
      }

      return node;
    }

    function rawGetNext(node, loop) {
      const sibs = node.siblings;
      const l = sibs.length;
      const {
        index
      } = node;

      if (loop) {
        return sibs[(index + 1) % l];
      } else {
        if (index === sibs.length - 1) return null;
        return sibs[index + 1];
      }
    }

    function move(fromNode, dir) {
      let {
        loop = false,
        includeDisabled = false
      } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      const iterate = dir === 'prev' ? rawGetPrev : rawGetNext;
      const getChildOptions = {
        reverse: dir === 'prev'
      };
      let meet = false;
      let endNode = null;

      function traverse(node) {
        if (node === null) return;

        if (node === fromNode) {
          if (!meet) {
            meet = true;
          } else if (!fromNode.disabled && !fromNode.isGroup) {
            endNode = fromNode;
            return;
          }
        } else {
          if ((!node.disabled || includeDisabled) && !node.ignored && !node.isGroup) {
            endNode = node;
            return;
          }
        }

        if (node.isGroup) {
          const child = getChild(node, getChildOptions);

          if (child !== null) {
            endNode = child;
          } else {
            traverse(iterate(node, loop));
          }
        } else {
          const nextNode = iterate(node, false);

          if (nextNode !== null) {
            traverse(nextNode);
          } else {
            const parent = rawGetParent(node);

            if (parent === null || parent === void 0 ? void 0 : parent.isGroup) {
              traverse(iterate(parent, loop));
            } else if (loop) {
              traverse(iterate(node, true));
            }
          }
        }
      }

      traverse(fromNode);
      return endNode;
    }

    function rawGetPrev(node, loop) {
      const sibs = node.siblings;
      const l = sibs.length;
      const {
        index
      } = node;

      if (loop) {
        return sibs[(index - 1 + l) % l];
      } else {
        if (index === 0) return null;
        return sibs[index - 1];
      }
    }

    function rawGetParent(node) {
      return node.parent;
    }

    function getChild(node) {
      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      const {
        reverse = false
      } = options;
      const {
        children
      } = node;

      if (children) {
        const {
          length
        } = children;
        const start = reverse ? length - 1 : 0;
        const end = reverse ? -1 : length;
        const delta = reverse ? -1 : 1;

        for (let i = start; i !== end; i += delta) {
          const child = children[i];

          if (!child.disabled && !child.ignored) {
            if (child.isGroup) {
              const childInGroup = getChild(child, options);
              if (childInGroup !== null) return childInGroup;
            } else {
              return child;
            }
          }
        }
      }

      return null;
    }

    const moveMethods = {
      getChild() {
        if (this.ignored) return null;
        return getChild(this);
      },

      getParent() {
        const {
          parent
        } = this;

        if (parent === null || parent === void 0 ? void 0 : parent.isGroup) {
          return parent.getParent();
        }

        return parent;
      },

      getNext() {
        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return move(this, 'next', options);
      },

      getPrev() {
        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return move(this, 'prev', options);
      }

    };

    function flatten$1(treeNodes, expandedKeys) {
      const expandedKeySet = expandedKeys ? new Set(expandedKeys) : undefined;
      const flattenedNodes = [];

      function traverse(treeNodes) {
        treeNodes.forEach(treeNode => {
          flattenedNodes.push(treeNode);
          if (treeNode.isLeaf || !treeNode.children || treeNode.ignored) return;

          if (treeNode.isGroup) {
            // group node shouldn't be expanded
            traverse(treeNode.children);
          } else if ( // normal non-leaf node
          expandedKeySet === undefined || expandedKeySet.has(treeNode.key)) {
            traverse(treeNode.children);
          }
        });
      }

      traverse(treeNodes);
      return flattenedNodes;
    }

    function contains(parent, child) {
      const parentKey = parent.key; // eslint-disable-next-line no-unmodified-loop-condition

      while (child) {
        if (child.key === parentKey) return true;
        child = child.parent;
      }

      return false;
    }

    function createTreeNodes(rawNodes, treeNodeMap, levelTreeNodeMap, nodeProto, getChildren) {
      let parent = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
      let level = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
      const treeNodes = [];
      rawNodes.forEach((rawNode, index) => {
        var _a;

        if (isNodeInvalid(rawNode, getChildren)) {
          console.error('[treemate]: node', rawNode, 'is invalid');
        }

        const treeNode = Object.create(nodeProto);
        treeNode.rawNode = rawNode;
        treeNode.siblings = treeNodes;
        treeNode.level = level;
        treeNode.index = index;
        treeNode.isFirstChild = index === 0;
        treeNode.isLastChild = index + 1 === rawNodes.length;
        treeNode.parent = parent;

        if (!treeNode.ignored) {
          const rawChildren = getChildren(rawNode);

          if (Array.isArray(rawChildren)) {
            treeNode.children = createTreeNodes(rawChildren, treeNodeMap, levelTreeNodeMap, nodeProto, getChildren, treeNode, level + 1);
          }
        }

        treeNodes.push(treeNode);
        treeNodeMap.set(treeNode.key, treeNode);
        if (!levelTreeNodeMap.has(level)) levelTreeNodeMap.set(level, []);
        (_a = levelTreeNodeMap.get(level)) === null || _a === void 0 ? void 0 : _a.push(treeNode);
      });
      return treeNodes;
    }

    function createTreeMate(rawNodes) {
      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var _a;

      const treeNodeMap = new Map();
      const levelTreeNodeMap = new Map();
      const {
        getDisabled = isDisabled,
        getIgnored = isIgnored,
        getIsGroup = isGroup,
        getKey = defaultGetKey
      } = options;

      const _getChildren = (_a = options.getChildren) !== null && _a !== void 0 ? _a : defaultGetChildren;

      const getChildren = options.ignoreEmptyChildren ? node => {
        const children = _getChildren(node);

        if (Array.isArray(children)) {
          if (!children.length) return null;
          return children;
        }

        return children;
      } : _getChildren;
      const nodeProto = Object.assign({
        get key() {
          // do not pass parent or related things to it
          // the key need to be specified explicitly
          return getKey(this.rawNode);
        },

        get disabled() {
          return getDisabled(this.rawNode);
        },

        get isGroup() {
          return getIsGroup(this.rawNode);
        },

        get isLeaf() {
          return isLeaf(this.rawNode, getChildren);
        },

        get shallowLoaded() {
          return isShallowLoaded(this.rawNode, getChildren);
        },

        get ignored() {
          return getIgnored(this.rawNode);
        },

        contains(node) {
          return contains(this, node);
        }

      }, moveMethods);
      const treeNodes = createTreeNodes(rawNodes, treeNodeMap, levelTreeNodeMap, nodeProto, getChildren);

      function getNode(key) {
        if (key === null || key === undefined) return null;
        const tmNode = treeNodeMap.get(key);

        if (tmNode && !tmNode.isGroup && !tmNode.ignored) {
          return tmNode;
        }

        return null;
      }

      function _getNode(key) {
        if (key === null || key === undefined) return null;
        const tmNode = treeNodeMap.get(key);

        if (tmNode && !tmNode.ignored) {
          return tmNode;
        }

        return null;
      }

      function getPrev(key, options) {
        const node = _getNode(key);

        if (!node) return null;
        return node.getPrev(options);
      }

      function getNext(key, options) {
        const node = _getNode(key);

        if (!node) return null;
        return node.getNext(options);
      }

      function getParent(key) {
        const node = _getNode(key);

        if (!node) return null;
        return node.getParent();
      }

      function getChild(key) {
        const node = _getNode(key);

        if (!node) return null;
        return node.getChild();
      }

      const treemate = {
        treeNodes,
        treeNodeMap,
        levelTreeNodeMap,
        maxLevel: Math.max(...levelTreeNodeMap.keys()),
        getChildren,

        getFlattenedNodes(expandedKeys) {
          return flatten$1(treeNodes, expandedKeys);
        },

        getNode,
        getPrev,
        getNext,
        getParent,
        getChild,

        getFirstAvailableNode() {
          return getFirstAvailableNode(treeNodes);
        },

        getPath(key) {
          let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          return getPath(key, options, treemate);
        },

        getCheckedKeys(checkedKeys) {
          let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          const {
            cascade = true,
            leafOnly = false,
            checkStrategy = 'all',
            allowNotLoaded = false
          } = options;
          return getCheckedKeys({
            checkedKeys: unwrapCheckedKeys(checkedKeys),
            indeterminateKeys: unwrapIndeterminateKeys(checkedKeys),
            cascade,
            leafOnly,
            checkStrategy,
            allowNotLoaded
          }, treemate);
        },

        check(keysToCheck, checkedKeys) {
          let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
          const {
            cascade = true,
            leafOnly = false,
            checkStrategy = 'all',
            allowNotLoaded = false
          } = options;
          return getCheckedKeys({
            checkedKeys: unwrapCheckedKeys(checkedKeys),
            indeterminateKeys: unwrapIndeterminateKeys(checkedKeys),
            keysToCheck: keysToCheck === undefined || keysToCheck === null ? [] : toArray(keysToCheck),
            cascade,
            leafOnly,
            checkStrategy,
            allowNotLoaded
          }, treemate);
        },

        uncheck(keysToUncheck, checkedKeys) {
          let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
          const {
            cascade = true,
            leafOnly = false,
            checkStrategy = 'all',
            allowNotLoaded = false
          } = options;
          return getCheckedKeys({
            checkedKeys: unwrapCheckedKeys(checkedKeys),
            indeterminateKeys: unwrapIndeterminateKeys(checkedKeys),
            keysToUncheck: keysToUncheck === null || keysToUncheck === undefined ? [] : toArray(keysToUncheck),
            cascade,
            leafOnly,
            checkStrategy,
            allowNotLoaded
          }, treemate);
        },

        getNonLeafKeys() {
          let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          return getNonLeafKeys(treeNodes, options);
        }

      };
      return treemate;
    }

    const base$1 = {
      neutralBase: "#000",
      neutralInvertBase: "#fff",
      neutralTextBase: "#fff",
      neutralPopover: "rgb(72, 72, 78)",
      neutralCard: "rgb(24, 24, 28)",
      neutralModal: "rgb(44, 44, 50)",
      neutralBody: "rgb(16, 16, 20)",
      alpha1: "0.9",
      alpha2: "0.82",
      alpha3: "0.52",
      alpha4: "0.38",
      alpha5: "0.28",
      alphaClose: "0.52",
      alphaDisabled: "0.38",
      alphaDisabledInput: "0.06",
      alphaPending: "0.09",
      alphaTablePending: "0.06",
      alphaTableStriped: "0.05",
      alphaPressed: "0.05",
      alphaAvatar: "0.18",
      alphaRail: "0.2",
      alphaProgressRail: "0.12",
      alphaBorder: "0.24",
      alphaDivider: "0.09",
      alphaInput: "0.1",
      alphaAction: "0.06",
      alphaTab: "0.04",
      alphaScrollbar: "0.2",
      alphaScrollbarHover: "0.3",
      alphaCode: "0.12",
      alphaTag: "0.2",
      primaryHover: "#7fe7c4",
      primaryDefault: "#63e2b7",
      primaryActive: "#5acea7",
      primarySuppl: "rgb(42, 148, 125)",
      infoHover: "#8acbec",
      infoDefault: "#70c0e8",
      infoActive: "#66afd3",
      infoSuppl: "rgb(56, 137, 197)",
      errorHover: "#e98b8b",
      errorDefault: "#e88080",
      errorActive: "#e57272",
      errorSuppl: "rgb(208, 58, 82)",
      warningHover: "#f5d599",
      warningDefault: "#f2c97d",
      warningActive: "#e6c260",
      warningSuppl: "rgb(240, 138, 0)",
      successHover: "#7fe7c4",
      successDefault: "#63e2b7",
      successActive: "#5acea7",
      successSuppl: "rgb(42, 148, 125)"
    };
    const baseBackgroundRgb$1 = rgba(base$1.neutralBase);
    const baseInvertBackgroundRgb$1 = rgba(base$1.neutralInvertBase);
    const overlayPrefix$1 = "rgba(" + baseInvertBackgroundRgb$1.slice(0, 3).join(", ") + ", ";

    function overlay$1(alpha) {
      return overlayPrefix$1 + String(alpha) + ")";
    }

    function neutral$1(alpha) {
      const overlayRgba = Array.from(baseInvertBackgroundRgb$1);
      overlayRgba[3] = Number(alpha);
      return composite(baseBackgroundRgb$1, overlayRgba);
    }

    const derived$1 = {
      name: "common",
      ...commonVariables$m,
      baseColor: base$1.neutralBase,
      primaryColor: base$1.primaryDefault,
      primaryColorHover: base$1.primaryHover,
      primaryColorPressed: base$1.primaryActive,
      primaryColorSuppl: base$1.primarySuppl,
      infoColor: base$1.infoDefault,
      infoColorHover: base$1.infoHover,
      infoColorPressed: base$1.infoActive,
      infoColorSuppl: base$1.infoSuppl,
      successColor: base$1.successDefault,
      successColorHover: base$1.successHover,
      successColorPressed: base$1.successActive,
      successColorSuppl: base$1.successSuppl,
      warningColor: base$1.warningDefault,
      warningColorHover: base$1.warningHover,
      warningColorPressed: base$1.warningActive,
      warningColorSuppl: base$1.warningSuppl,
      errorColor: base$1.errorDefault,
      errorColorHover: base$1.errorHover,
      errorColorPressed: base$1.errorActive,
      errorColorSuppl: base$1.errorSuppl,
      textColorBase: base$1.neutralTextBase,
      textColor1: overlay$1(base$1.alpha1),
      textColor2: overlay$1(base$1.alpha2),
      textColor3: overlay$1(base$1.alpha3),
      textColorDisabled: overlay$1(base$1.alpha4),
      placeholderColor: overlay$1(base$1.alpha4),
      placeholderColorDisabled: overlay$1(base$1.alpha5),
      iconColor: overlay$1(base$1.alpha4),
      iconColorDisabled: overlay$1(base$1.alpha5),
      iconColorHover: overlay$1(Number(base$1.alpha4) * 1.25),
      iconColorPressed: overlay$1(Number(base$1.alpha4) * 0.8),
      opacity1: base$1.alpha1,
      opacity2: base$1.alpha2,
      opacity3: base$1.alpha3,
      opacity4: base$1.alpha4,
      opacity5: base$1.alpha5,
      dividerColor: overlay$1(base$1.alphaDivider),
      borderColor: overlay$1(base$1.alphaBorder),
      closeIconColorHover: overlay$1(Number(base$1.alphaClose)),
      closeIconColor: overlay$1(Number(base$1.alphaClose)),
      closeIconColorPressed: overlay$1(Number(base$1.alphaClose)),
      closeColorHover: "rgba(255, 255, 255, .12)",
      closeColorPressed: "rgba(255, 255, 255, .08)",
      clearColor: overlay$1(base$1.alpha4),
      clearColorHover: scaleColor(overlay$1(base$1.alpha4), {
        alpha: 1.25
      }),
      clearColorPressed: scaleColor(overlay$1(base$1.alpha4), {
        alpha: 0.8
      }),
      scrollbarColor: overlay$1(base$1.alphaScrollbar),
      scrollbarColorHover: overlay$1(base$1.alphaScrollbarHover),
      scrollbarWidth: "5px",
      scrollbarHeight: "5px",
      scrollbarBorderRadius: "5px",
      progressRailColor: overlay$1(base$1.alphaProgressRail),
      railColor: overlay$1(base$1.alphaRail),
      popoverColor: base$1.neutralPopover,
      tableColor: base$1.neutralCard,
      cardColor: base$1.neutralCard,
      modalColor: base$1.neutralModal,
      bodyColor: base$1.neutralBody,
      tagColor: neutral$1(base$1.alphaTag),
      avatarColor: overlay$1(base$1.alphaAvatar),
      invertedColor: base$1.neutralBase,
      inputColor: overlay$1(base$1.alphaInput),
      codeColor: overlay$1(base$1.alphaCode),
      tabColor: overlay$1(base$1.alphaTab),
      actionColor: overlay$1(base$1.alphaAction),
      tableHeaderColor: overlay$1(base$1.alphaAction),
      hoverColor: overlay$1(base$1.alphaPending),
      tableColorHover: overlay$1(base$1.alphaTablePending),
      tableColorStriped: overlay$1(base$1.alphaTableStriped),
      pressedColor: overlay$1(base$1.alphaPressed),
      opacityDisabled: base$1.alphaDisabled,
      inputColorDisabled: overlay$1(base$1.alphaDisabledInput),
      buttonColor2: "rgba(255, 255, 255, .08)",
      buttonColor2Hover: "rgba(255, 255, 255, .12)",
      buttonColor2Pressed: "rgba(255, 255, 255, .08)",
      boxShadow1: "0 1px 2px -2px rgba(0, 0, 0, .24), 0 3px 6px 0 rgba(0, 0, 0, .18), 0 5px 12px 4px rgba(0, 0, 0, .12)",
      boxShadow2: "0 3px 6px -4px rgba(0, 0, 0, .24), 0 6px 12px 0 rgba(0, 0, 0, .16), 0 9px 18px 8px rgba(0, 0, 0, .10)",
      boxShadow3: "0 6px 16px -9px rgba(0, 0, 0, .08), 0 9px 28px 0 rgba(0, 0, 0, .05), 0 12px 48px 16px rgba(0, 0, 0, .03)"
    };
    var commonDark = derived$1;

    const base = {
      neutralBase: "#FFF",
      neutralInvertBase: "#000",
      neutralTextBase: "#000",
      neutralPopover: "#fff",
      neutralCard: "#fff",
      neutralModal: "#fff",
      neutralBody: "#fff",
      alpha1: "0.82",
      alpha2: "0.72",
      alpha3: "0.38",
      alpha4: "0.24",
      alpha5: "0.18",
      alphaClose: "0.6",
      alphaDisabled: "0.5",
      alphaDisabledInput: "0.02",
      alphaPending: "0.05",
      alphaTablePending: "0.02",
      alphaPressed: "0.07",
      alphaAvatar: "0.2",
      alphaRail: "0.14",
      alphaProgressRail: ".08",
      alphaBorder: "0.12",
      alphaDivider: "0.06",
      alphaInput: "0",
      alphaAction: "0.02",
      alphaTab: "0.04",
      alphaScrollbar: "0.25",
      alphaScrollbarHover: "0.4",
      alphaCode: "0.05",
      alphaTag: "0.02",
      primaryHover: "#ff6b63",
      primaryDefault: "#ff6b63",
      primaryActive: "#0c7a43",
      primarySuppl: "#ff6b63",
      infoHover: "#4098fc",
      infoDefault: "#2080f0",
      infoActive: "#1060c9",
      infoSuppl: "#4098fc",
      errorHover: "#de576d",
      errorDefault: "#d03050",
      errorActive: "#ab1f3f",
      errorSuppl: "#de576d",
      warningHover: "#fcb040",
      warningDefault: "#f0a020",
      warningActive: "#c97c10",
      warningSuppl: "#fcb040",
      successHover: "#ff6b63",
      successDefault: "#ff6b63",
      successActive: "#0c7a43",
      successSuppl: "#ff6b63"
    };
    const baseBackgroundRgb = rgba(base.neutralBase);
    const baseInvertBackgroundRgb = rgba(base.neutralInvertBase);
    const overlayPrefix = "rgba(" + baseInvertBackgroundRgb.slice(0, 3).join(", ") + ", ";

    function overlay(alpha) {
      return overlayPrefix + String(alpha) + ")";
    }

    function neutral(alpha) {
      const overlayRgba = Array.from(baseInvertBackgroundRgb);
      overlayRgba[3] = Number(alpha);
      return composite(baseBackgroundRgb, overlayRgba);
    }

    const derived = {
      name: "common",
      ...commonVariables$m,
      baseColor: base.neutralBase,
      primaryColor: base.primaryDefault,
      primaryColorHover: base.primaryHover,
      primaryColorPressed: base.primaryActive,
      primaryColorSuppl: base.primarySuppl,
      infoColor: base.infoDefault,
      infoColorHover: base.infoHover,
      infoColorPressed: base.infoActive,
      infoColorSuppl: base.infoSuppl,
      successColor: base.successDefault,
      successColorHover: base.successHover,
      successColorPressed: base.successActive,
      successColorSuppl: base.successSuppl,
      warningColor: base.warningDefault,
      warningColorHover: base.warningHover,
      warningColorPressed: base.warningActive,
      warningColorSuppl: base.warningSuppl,
      errorColor: base.errorDefault,
      errorColorHover: base.errorHover,
      errorColorPressed: base.errorActive,
      errorColorSuppl: base.errorSuppl,
      textColorBase: base.neutralTextBase,
      textColor1: "rgb(31, 34, 37)",
      textColor2: "rgb(51, 54, 57)",
      textColor3: "rgb(118, 124, 130)",
      textColorDisabled: neutral(base.alpha4),
      placeholderColor: neutral(base.alpha4),
      placeholderColorDisabled: neutral(base.alpha5),
      iconColor: neutral(base.alpha4),
      iconColorHover: scaleColor(neutral(base.alpha4), {
        lightness: 0.75
      }),
      iconColorPressed: scaleColor(neutral(base.alpha4), {
        lightness: 0.9
      }),
      iconColorDisabled: neutral(base.alpha5),
      opacity1: base.alpha1,
      opacity2: base.alpha2,
      opacity3: base.alpha3,
      opacity4: base.alpha4,
      opacity5: base.alpha5,
      dividerColor: "rgb(239, 239, 245)",
      borderColor: "rgb(224, 224, 230)",
      closeIconColor: neutral(Number(base.alphaClose)),
      closeIconColorHover: neutral(Number(base.alphaClose)),
      closeIconColorPressed: neutral(Number(base.alphaClose)),
      closeColorHover: "rgba(0, 0, 0, .09)",
      closeColorPressed: "rgba(0, 0, 0, .13)",
      clearColor: neutral(base.alpha4),
      clearColorHover: scaleColor(neutral(base.alpha4), {
        lightness: 0.75
      }),
      clearColorPressed: scaleColor(neutral(base.alpha4), {
        lightness: 0.9
      }),
      scrollbarColor: overlay(base.alphaScrollbar),
      scrollbarColorHover: overlay(base.alphaScrollbarHover),
      scrollbarWidth: "5px",
      scrollbarHeight: "5px",
      scrollbarBorderRadius: "5px",
      progressRailColor: neutral(base.alphaProgressRail),
      railColor: "rgb(219, 219, 223)",
      popoverColor: base.neutralPopover,
      tableColor: base.neutralCard,
      cardColor: base.neutralCard,
      modalColor: base.neutralModal,
      bodyColor: base.neutralBody,
      tagColor: "#eee",
      avatarColor: neutral(base.alphaAvatar),
      invertedColor: "rgb(0, 20, 40)",
      inputColor: neutral(base.alphaInput),
      codeColor: "rgb(244, 244, 248)",
      tabColor: "rgb(247, 247, 250)",
      actionColor: "rgb(250, 250, 252)",
      tableHeaderColor: "rgb(250, 250, 252)",
      hoverColor: "rgb(243, 243, 245)",
      tableColorHover: "rgba(0, 0, 100, 0.03)",
      tableColorStriped: "rgba(0, 0, 100, 0.02)",
      pressedColor: "rgb(237, 237, 239)",
      opacityDisabled: base.alphaDisabled,
      inputColorDisabled: "rgb(250, 250, 252)",
      buttonColor2: "rgba(46, 51, 56, .05)",
      buttonColor2Hover: "rgba(46, 51, 56, .09)",
      buttonColor2Pressed: "rgba(46, 51, 56, .13)",
      boxShadow1: "0 1px 2px -2px rgba(0, 0, 0, .08), 0 3px 6px 0 rgba(0, 0, 0, .06), 0 5px 12px 4px rgba(0, 0, 0, .04)",
      boxShadow2: "0 3px 6px -4px rgba(0, 0, 0, .12), 0 6px 16px 0 rgba(0, 0, 0, .08), 0 9px 28px 8px rgba(0, 0, 0, .05)",
      boxShadow3: "0 6px 16px -9px rgba(0, 0, 0, .08), 0 9px 28px 0 rgba(0, 0, 0, .05), 0 12px 48px 16px rgba(0, 0, 0, .03)"
    };
    var commonLight = derived;

    var commonVars$c = {
      iconSizeSmall: "34px",
      iconSizeMedium: "40px",
      iconSizeLarge: "46px",
      iconSizeHuge: "52px"
    };

    const self$1b = vars => {
      const {
        textColorDisabled,
        iconColor,
        textColor2,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        fontSizeHuge
      } = vars;
      return { ...commonVars$c,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        fontSizeHuge,
        textColor: textColorDisabled,
        iconColor,
        extraTextColor: textColor2
      };
    };
    const emptyLight = {
      name: "Empty",
      common: commonLight,
      self: self$1b
    };
    var emptyLight$1 = emptyLight;

    const emptyDark = {
      name: "Empty",
      common: commonDark,
      self: self$1b
    };
    var emptyDark$1 = emptyDark;

    var style$1v = cB("empty", `
  display: flex;
  flex-direction: column;
  align-items: center;
  font-size: var(--n-font-size);
`, [cE("icon", `
    width: var(--n-icon-size);
    height: var(--n-icon-size);
    font-size: var(--n-icon-size);
    line-height: var(--n-icon-size);
    color: var(--n-icon-color);
    transition:
      color .3s var(--n-bezier);
  `, [c$1("+", [cE("description", `
        margin-top: 8px;
      `)])]), cE("description", `
    transition: color .3s var(--n-bezier);
    color: var(--n-text-color);
  `), cE("extra", `
    text-align: center;
    transition: color .3s var(--n-bezier);
    margin-top: 12px;
    color: var(--n-extra-text-color);
  `)]);

    const emptyProps = {
      ...useTheme.props,
      description: String,
      showDescription: {
        type: Boolean,
        default: true
      },
      showIcon: {
        type: Boolean,
        default: true
      },
      size: {
        type: String,
        default: "medium"
      },
      renderIcon: Function
    };
    var NEmpty = vue.defineComponent({
      name: "Empty",
      props: emptyProps,
      setup(props) {
        const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
        const themeRef = useTheme(
          "Empty",
          "-empty",
          style$1v,
          emptyLight$1,
          props,
          mergedClsPrefixRef
        );
        const { localeRef } = useLocale("Empty");
        const NConfigProvider = vue.inject(configProviderInjectionKey, null);
        const mergedDescriptionRef = vue.computed(() => {
          return props.description ?? NConfigProvider?.mergedComponentPropsRef.value?.Empty?.description;
        });
        const mergedRenderIconRef = vue.computed(
          () => NConfigProvider?.mergedComponentPropsRef.value?.Empty?.renderIcon || (() => /* @__PURE__ */ vue.h(EmptyIcon, null))
        );
        const cssVarsRef = vue.computed(() => {
          const { size } = props;
          const {
            common: { cubicBezierEaseInOut },
            self: {
              [createKey("iconSize", size)]: iconSize,
              [createKey("fontSize", size)]: fontSize,
              textColor,
              iconColor,
              extraTextColor
            }
          } = themeRef.value;
          return {
            "--n-icon-size": iconSize,
            "--n-font-size": fontSize,
            "--n-bezier": cubicBezierEaseInOut,
            "--n-text-color": textColor,
            "--n-icon-color": iconColor,
            "--n-extra-text-color": extraTextColor
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass(
          "empty",
          vue.computed(() => {
            let hash = "";
            const { size } = props;
            hash += size[0];
            return hash;
          }),
          cssVarsRef,
          props
        ) : void 0;
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          mergedRenderIcon: mergedRenderIconRef,
          localizedDescription: vue.computed(() => {
            return mergedDescriptionRef.value || localeRef.value.description;
          }),
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender
        };
      },
      render() {
        const { $slots, mergedClsPrefix, onRender } = this;
        onRender?.();
        return /* @__PURE__ */ vue.h("div", {
          class: [`${mergedClsPrefix}-empty`, this.themeClass],
          style: this.cssVars
        }, this.showIcon ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-empty__icon`
        }, $slots.icon ? $slots.icon() : /* @__PURE__ */ vue.h(NBaseIcon, {
          clsPrefix: mergedClsPrefix
        }, { default: this.mergedRenderIcon })) : null, this.showDescription ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-empty__description`
        }, $slots.default ? $slots.default() : this.localizedDescription) : null, $slots.extra ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-empty__extra`
        }, $slots.extra()) : null);
      }
    });

    const self$1a = vars => {
      const {
        scrollbarColor,
        scrollbarColorHover
      } = vars;
      return {
        color: scrollbarColor,
        colorHover: scrollbarColorHover
      };
    };
    const scrollbarLight = {
      name: "Scrollbar",
      common: commonLight,
      self: self$1a
    };
    var scrollbarLight$1 = scrollbarLight;

    const scrollbarDark = {
      name: "Scrollbar",
      common: commonDark,
      self: self$1a
    };
    var scrollbarDark$1 = scrollbarDark;

    var rtlStyle$r = cB("scrollbar", [cM("rtl", `
    direction: rtl;
  `, [c$1(">", [cB("scrollbar-rail", [cM("horizontal", [c$1(">", [cE("scrollbar", `
              left: 0;
              right: unset;
            `)])]), cM("vertical", `
          left: 4px;
          right: unset;
        `)])])])]);

    const scrollbarRtl = {
      name: "Scrollbar",
      style: rtlStyle$r
    };
    var scrollbarRtl$1 = scrollbarRtl;

    const {
      cubicBezierEaseInOut: cubicBezierEaseInOut$3
    } = commonVariables$m;
    function fadeInTransition() {
      let {
        name = "fade-in",
        enterDuration = "0.2s",
        leaveDuration = "0.2s",
        enterCubicBezier = cubicBezierEaseInOut$3,
        leaveCubicBezier = cubicBezierEaseInOut$3
      } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return [c$1(`&.${name}-transition-enter-active`, {
        transition: `all ${enterDuration} ${enterCubicBezier}!important`
      }), c$1(`&.${name}-transition-leave-active`, {
        transition: `all ${leaveDuration} ${leaveCubicBezier}!important`
      }), c$1(`&.${name}-transition-enter-from, &.${name}-transition-leave-to`, {
        opacity: 0
      }), c$1(`&.${name}-transition-leave-from, &.${name}-transition-enter-to`, {
        opacity: 1
      })];
    }

    var style$1u = cB("scrollbar", `
  overflow: hidden;
  position: relative;
  z-index: auto;
  height: 100%;
  width: 100%;
`, [c$1(">", [cB("scrollbar-container", `
      width: 100%;
      overflow: scroll;
      height: 100%;
      max-height: inherit;
      scrollbar-width: none;
    `, [c$1("&::-webkit-scrollbar, &::-webkit-scrollbar-track-piece, &::-webkit-scrollbar-thumb", `
        width: 0;
        height: 0;
        display: none;
      `), c$1(">", [cB("scrollbar-content", `
          box-sizing: border-box;
          min-width: 100%;
        `)])])]), c$1(">, +", [cB("scrollbar-rail", `
      position: absolute;
      pointer-events: none;
      user-select: none;
      -webkit-user-select: none;
    `, [cM("horizontal", `
        left: 2px;
        right: 2px;
        bottom: 4px;
        height: var(--n-scrollbar-height);
      `, [c$1(">", [cE("scrollbar", `
            height: var(--n-scrollbar-height);
            border-radius: var(--n-scrollbar-border-radius);
            right: 0;
          `)])]), cM("vertical", `
        right: 4px;
        top: 2px;
        bottom: 2px;
        width: var(--n-scrollbar-width);
      `, [c$1(">", [cE("scrollbar", `
            width: var(--n-scrollbar-width);
            border-radius: var(--n-scrollbar-border-radius);
            bottom: 0;
          `)])]), cM("disabled", [c$1(">", [cE("scrollbar", {
      pointerEvents: "none"
    })])]), c$1(">", [cE("scrollbar", `
          position: absolute;
          cursor: pointer;
          pointer-events: all;
          background-color: var(--n-scrollbar-color);
          transition: background-color .2s var(--n-scrollbar-bezier);
        `, [fadeInTransition(), c$1("&:hover", {
      backgroundColor: "var(--n-scrollbar-color-hover)"
    })])])])])]);

    const scrollbarProps$1 = {
      ...useTheme.props,
      size: {
        type: Number,
        default: 5
      },
      duration: {
        type: Number,
        default: 0
      },
      scrollable: {
        type: Boolean,
        default: true
      },
      xScrollable: Boolean,
      trigger: {
        type: String,
        default: "hover"
      },
      useUnifiedContainer: Boolean,
      triggerDisplayManually: Boolean,
      container: Function,
      content: Function,
      containerClass: String,
      containerStyle: [String, Object],
      contentClass: String,
      contentStyle: [String, Object],
      horizontalRailStyle: [String, Object],
      verticalRailStyle: [String, Object],
      onScroll: Function,
      onWheel: Function,
      onResize: Function,
      internalOnUpdateScrollLeft: Function,
      internalHoistYRail: Boolean
    };
    const Scrollbar$2 = vue.defineComponent({
      name: "Scrollbar",
      props: scrollbarProps$1,
      inheritAttrs: false,
      setup(props) {
        const { mergedClsPrefixRef, inlineThemeDisabled, mergedRtlRef } = useConfig(props);
        const rtlEnabledRef = useRtl("Scrollbar", mergedRtlRef, mergedClsPrefixRef);
        const wrapperRef = vue.ref(null);
        const containerRef = vue.ref(null);
        const contentRef = vue.ref(null);
        const yRailRef = vue.ref(null);
        const xRailRef = vue.ref(null);
        const contentHeightRef = vue.ref(null);
        const contentWidthRef = vue.ref(null);
        const containerHeightRef = vue.ref(null);
        const containerWidthRef = vue.ref(null);
        const yRailSizeRef = vue.ref(null);
        const xRailSizeRef = vue.ref(null);
        const containerScrollTopRef = vue.ref(0);
        const containerScrollLeftRef = vue.ref(0);
        const isShowXBarRef = vue.ref(false);
        const isShowYBarRef = vue.ref(false);
        let yBarPressed = false;
        let xBarPressed = false;
        let xBarVanishTimerId;
        let yBarVanishTimerId;
        let memoYTop = 0;
        let memoXLeft = 0;
        let memoMouseX = 0;
        let memoMouseY = 0;
        const isIos = useIsIos();
        const yBarSizeRef = vue.computed(() => {
          const { value: containerHeight } = containerHeightRef;
          const { value: contentHeight } = contentHeightRef;
          const { value: yRailSize } = yRailSizeRef;
          if (containerHeight === null || contentHeight === null || yRailSize === null) {
            return 0;
          } else {
            return Math.min(
              containerHeight,
              yRailSize * containerHeight / contentHeight + props.size * 1.5
            );
          }
        });
        const yBarSizePxRef = vue.computed(() => {
          return `${yBarSizeRef.value}px`;
        });
        const xBarSizeRef = vue.computed(() => {
          const { value: containerWidth } = containerWidthRef;
          const { value: contentWidth } = contentWidthRef;
          const { value: xRailSize } = xRailSizeRef;
          if (containerWidth === null || contentWidth === null || xRailSize === null) {
            return 0;
          } else {
            return xRailSize * containerWidth / contentWidth + props.size * 1.5;
          }
        });
        const xBarSizePxRef = vue.computed(() => {
          return `${xBarSizeRef.value}px`;
        });
        const yBarTopRef = vue.computed(() => {
          const { value: containerHeight } = containerHeightRef;
          const { value: containerScrollTop } = containerScrollTopRef;
          const { value: contentHeight } = contentHeightRef;
          const { value: yRailSize } = yRailSizeRef;
          if (containerHeight === null || contentHeight === null || yRailSize === null) {
            return 0;
          } else {
            const heightDiff = contentHeight - containerHeight;
            if (!heightDiff)
              return 0;
            return containerScrollTop / heightDiff * (yRailSize - yBarSizeRef.value);
          }
        });
        const yBarTopPxRef = vue.computed(() => {
          return `${yBarTopRef.value}px`;
        });
        const xBarLeftRef = vue.computed(() => {
          const { value: containerWidth } = containerWidthRef;
          const { value: containerScrollLeft } = containerScrollLeftRef;
          const { value: contentWidth } = contentWidthRef;
          const { value: xRailSize } = xRailSizeRef;
          if (containerWidth === null || contentWidth === null || xRailSize === null) {
            return 0;
          } else {
            const widthDiff = contentWidth - containerWidth;
            if (!widthDiff)
              return 0;
            return containerScrollLeft / widthDiff * (xRailSize - xBarSizeRef.value);
          }
        });
        const xBarLeftPxRef = vue.computed(() => {
          return `${xBarLeftRef.value}px`;
        });
        const needYBarRef = vue.computed(() => {
          const { value: containerHeight } = containerHeightRef;
          const { value: contentHeight } = contentHeightRef;
          return containerHeight !== null && contentHeight !== null && contentHeight > containerHeight;
        });
        const needXBarRef = vue.computed(() => {
          const { value: containerWidth } = containerWidthRef;
          const { value: contentWidth } = contentWidthRef;
          return containerWidth !== null && contentWidth !== null && contentWidth > containerWidth;
        });
        const mergedShowXBarRef = vue.computed(() => {
          const { trigger } = props;
          return trigger === "none" || isShowXBarRef.value;
        });
        const mergedShowYBarRef = vue.computed(() => {
          const { trigger } = props;
          return trigger === "none" || isShowYBarRef.value;
        });
        const mergedContainerRef = vue.computed(() => {
          const { container } = props;
          if (container)
            return container();
          return containerRef.value;
        });
        const mergedContentRef = vue.computed(() => {
          const { content } = props;
          if (content)
            return content();
          return contentRef.value;
        });
        const activateState = useReactivated(() => {
          if (!props.container) {
            scrollTo({
              top: containerScrollTopRef.value,
              left: containerScrollLeftRef.value
            });
          }
        });
        const handleContentResize = () => {
          if (activateState.isDeactivated)
            return;
          sync();
        };
        const handleContainerResize = (e) => {
          if (activateState.isDeactivated)
            return;
          const { onResize } = props;
          if (onResize)
            onResize(e);
          sync();
        };
        const scrollTo = (options, y) => {
          if (!props.scrollable)
            return;
          if (typeof options === "number") {
            scrollToPosition(y ?? 0, options, 0, false, "auto");
            return;
          }
          const {
            left,
            top,
            index,
            elSize,
            position,
            behavior,
            el,
            debounce = true
          } = options;
          if (left !== void 0 || top !== void 0) {
            scrollToPosition(left ?? 0, top ?? 0, 0, false, behavior);
          }
          if (el !== void 0) {
            scrollToPosition(0, el.offsetTop, el.offsetHeight, debounce, behavior);
          } else if (index !== void 0 && elSize !== void 0) {
            scrollToPosition(0, index * elSize, elSize, debounce, behavior);
          } else if (position === "bottom") {
            scrollToPosition(0, Number.MAX_SAFE_INTEGER, 0, false, behavior);
          } else if (position === "top") {
            scrollToPosition(0, 0, 0, false, behavior);
          }
        };
        const scrollBy = (options, y) => {
          if (!props.scrollable)
            return;
          const { value: container } = mergedContainerRef;
          if (!container)
            return;
          if (typeof options === "object") {
            container.scrollBy(options);
          } else {
            container.scrollBy(options, y || 0);
          }
        };
        function scrollToPosition(left, top, elSize, debounce, behavior) {
          const { value: container } = mergedContainerRef;
          if (!container)
            return;
          if (debounce) {
            const { scrollTop, offsetHeight } = container;
            if (top > scrollTop) {
              if (top + elSize <= scrollTop + offsetHeight) ; else {
                container.scrollTo({
                  left,
                  top: top + elSize - offsetHeight,
                  behavior
                });
              }
              return;
            }
          }
          container.scrollTo({
            left,
            top,
            behavior
          });
        }
        function handleMouseEnterWrapper() {
          showXBar();
          showYBar();
          sync();
        }
        function handleMouseLeaveWrapper() {
          hideBar();
        }
        function hideBar() {
          hideYBar();
          hideXBar();
        }
        function hideYBar() {
          if (yBarVanishTimerId !== void 0) {
            window.clearTimeout(yBarVanishTimerId);
          }
          yBarVanishTimerId = window.setTimeout(() => {
            isShowYBarRef.value = false;
          }, props.duration);
        }
        function hideXBar() {
          if (xBarVanishTimerId !== void 0) {
            window.clearTimeout(xBarVanishTimerId);
          }
          xBarVanishTimerId = window.setTimeout(() => {
            isShowXBarRef.value = false;
          }, props.duration);
        }
        function showXBar() {
          if (xBarVanishTimerId !== void 0) {
            window.clearTimeout(xBarVanishTimerId);
          }
          isShowXBarRef.value = true;
        }
        function showYBar() {
          if (yBarVanishTimerId !== void 0) {
            window.clearTimeout(yBarVanishTimerId);
          }
          isShowYBarRef.value = true;
        }
        function handleScroll(e) {
          const { onScroll } = props;
          if (onScroll)
            onScroll(e);
          syncScrollState();
        }
        function syncScrollState() {
          const { value: container } = mergedContainerRef;
          if (container) {
            containerScrollTopRef.value = container.scrollTop;
            containerScrollLeftRef.value = container.scrollLeft * (rtlEnabledRef?.value ? -1 : 1);
          }
        }
        function syncPositionState() {
          const { value: content } = mergedContentRef;
          if (content) {
            contentHeightRef.value = content.offsetHeight;
            contentWidthRef.value = content.offsetWidth;
          }
          const { value: container } = mergedContainerRef;
          if (container) {
            containerHeightRef.value = container.offsetHeight;
            containerWidthRef.value = container.offsetWidth;
          }
          const { value: xRailEl } = xRailRef;
          const { value: yRailEl } = yRailRef;
          if (xRailEl) {
            xRailSizeRef.value = xRailEl.offsetWidth;
          }
          if (yRailEl) {
            yRailSizeRef.value = yRailEl.offsetHeight;
          }
        }
        function syncUnifiedContainer() {
          const { value: container } = mergedContainerRef;
          if (container) {
            containerScrollTopRef.value = container.scrollTop;
            containerScrollLeftRef.value = container.scrollLeft * (rtlEnabledRef?.value ? -1 : 1);
            containerHeightRef.value = container.offsetHeight;
            containerWidthRef.value = container.offsetWidth;
            contentHeightRef.value = container.scrollHeight;
            contentWidthRef.value = container.scrollWidth;
          }
          const { value: xRailEl } = xRailRef;
          const { value: yRailEl } = yRailRef;
          if (xRailEl) {
            xRailSizeRef.value = xRailEl.offsetWidth;
          }
          if (yRailEl) {
            yRailSizeRef.value = yRailEl.offsetHeight;
          }
        }
        function sync() {
          if (!props.scrollable)
            return;
          if (props.useUnifiedContainer) {
            syncUnifiedContainer();
          } else {
            syncPositionState();
            syncScrollState();
          }
        }
        function isMouseUpAway(e) {
          return !wrapperRef.value?.contains(
            getPreciseEventTarget(e)
          );
        }
        function handleXScrollMouseDown(e) {
          e.preventDefault();
          e.stopPropagation();
          xBarPressed = true;
          on("mousemove", window, handleXScrollMouseMove, true);
          on("mouseup", window, handleXScrollMouseUp, true);
          memoXLeft = containerScrollLeftRef.value;
          memoMouseX = rtlEnabledRef?.value ? window.innerWidth - e.clientX : e.clientX;
        }
        function handleXScrollMouseMove(e) {
          if (!xBarPressed)
            return;
          if (xBarVanishTimerId !== void 0) {
            window.clearTimeout(xBarVanishTimerId);
          }
          if (yBarVanishTimerId !== void 0) {
            window.clearTimeout(yBarVanishTimerId);
          }
          const { value: containerWidth } = containerWidthRef;
          const { value: contentWidth } = contentWidthRef;
          const { value: xBarSize } = xBarSizeRef;
          if (containerWidth === null || contentWidth === null)
            return;
          const dX = rtlEnabledRef?.value ? window.innerWidth - e.clientX - memoMouseX : e.clientX - memoMouseX;
          const dScrollLeft = dX * (contentWidth - containerWidth) / (containerWidth - xBarSize);
          const toScrollLeftUpperBound = contentWidth - containerWidth;
          let toScrollLeft = memoXLeft + dScrollLeft;
          toScrollLeft = Math.min(toScrollLeftUpperBound, toScrollLeft);
          toScrollLeft = Math.max(toScrollLeft, 0);
          const { value: container } = mergedContainerRef;
          if (container) {
            container.scrollLeft = toScrollLeft * (rtlEnabledRef?.value ? -1 : 1);
            const { internalOnUpdateScrollLeft } = props;
            if (internalOnUpdateScrollLeft)
              internalOnUpdateScrollLeft(toScrollLeft);
          }
        }
        function handleXScrollMouseUp(e) {
          e.preventDefault();
          e.stopPropagation();
          off("mousemove", window, handleXScrollMouseMove, true);
          off("mouseup", window, handleXScrollMouseUp, true);
          xBarPressed = false;
          sync();
          if (isMouseUpAway(e)) {
            hideBar();
          }
        }
        function handleYScrollMouseDown(e) {
          e.preventDefault();
          e.stopPropagation();
          yBarPressed = true;
          on("mousemove", window, handleYScrollMouseMove, true);
          on("mouseup", window, handleYScrollMouseUp, true);
          memoYTop = containerScrollTopRef.value;
          memoMouseY = e.clientY;
        }
        function handleYScrollMouseMove(e) {
          if (!yBarPressed)
            return;
          if (xBarVanishTimerId !== void 0) {
            window.clearTimeout(xBarVanishTimerId);
          }
          if (yBarVanishTimerId !== void 0) {
            window.clearTimeout(yBarVanishTimerId);
          }
          const { value: containerHeight } = containerHeightRef;
          const { value: contentHeight } = contentHeightRef;
          const { value: yBarSize } = yBarSizeRef;
          if (containerHeight === null || contentHeight === null)
            return;
          const dY = e.clientY - memoMouseY;
          const dScrollTop = dY * (contentHeight - containerHeight) / (containerHeight - yBarSize);
          const toScrollTopUpperBound = contentHeight - containerHeight;
          let toScrollTop = memoYTop + dScrollTop;
          toScrollTop = Math.min(toScrollTopUpperBound, toScrollTop);
          toScrollTop = Math.max(toScrollTop, 0);
          const { value: container } = mergedContainerRef;
          if (container) {
            container.scrollTop = toScrollTop;
          }
        }
        function handleYScrollMouseUp(e) {
          e.preventDefault();
          e.stopPropagation();
          off("mousemove", window, handleYScrollMouseMove, true);
          off("mouseup", window, handleYScrollMouseUp, true);
          yBarPressed = false;
          sync();
          if (isMouseUpAway(e)) {
            hideBar();
          }
        }
        vue.watchEffect(() => {
          const { value: needXBar } = needXBarRef;
          const { value: needYBar } = needYBarRef;
          const { value: mergedClsPrefix } = mergedClsPrefixRef;
          const { value: xRailEl } = xRailRef;
          const { value: yRailEl } = yRailRef;
          if (xRailEl) {
            if (!needXBar) {
              xRailEl.classList.add(`${mergedClsPrefix}-scrollbar-rail--disabled`);
            } else {
              xRailEl.classList.remove(
                `${mergedClsPrefix}-scrollbar-rail--disabled`
              );
            }
          }
          if (yRailEl) {
            if (!needYBar) {
              yRailEl.classList.add(`${mergedClsPrefix}-scrollbar-rail--disabled`);
            } else {
              yRailEl.classList.remove(
                `${mergedClsPrefix}-scrollbar-rail--disabled`
              );
            }
          }
        });
        vue.onMounted(() => {
          if (props.container)
            return;
          sync();
        });
        vue.onBeforeUnmount(() => {
          if (xBarVanishTimerId !== void 0) {
            window.clearTimeout(xBarVanishTimerId);
          }
          if (yBarVanishTimerId !== void 0) {
            window.clearTimeout(yBarVanishTimerId);
          }
          off("mousemove", window, handleYScrollMouseMove, true);
          off("mouseup", window, handleYScrollMouseUp, true);
        });
        const themeRef = useTheme(
          "Scrollbar",
          "-scrollbar",
          style$1u,
          scrollbarLight$1,
          props,
          mergedClsPrefixRef
        );
        const cssVarsRef = vue.computed(() => {
          const {
            common: {
              cubicBezierEaseInOut,
              scrollbarBorderRadius,
              scrollbarHeight,
              scrollbarWidth
            },
            self: { color, colorHover }
          } = themeRef.value;
          return {
            "--n-scrollbar-bezier": cubicBezierEaseInOut,
            "--n-scrollbar-color": color,
            "--n-scrollbar-color-hover": colorHover,
            "--n-scrollbar-border-radius": scrollbarBorderRadius,
            "--n-scrollbar-width": scrollbarWidth,
            "--n-scrollbar-height": scrollbarHeight
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("scrollbar", void 0, cssVarsRef, props) : void 0;
        const exposedMethods = {
          scrollTo,
          scrollBy,
          sync,
          syncUnifiedContainer,
          handleMouseEnterWrapper,
          handleMouseLeaveWrapper
        };
        return {
          ...exposedMethods,
          mergedClsPrefix: mergedClsPrefixRef,
          rtlEnabled: rtlEnabledRef,
          containerScrollTop: containerScrollTopRef,
          wrapperRef,
          containerRef,
          contentRef,
          yRailRef,
          xRailRef,
          needYBar: needYBarRef,
          needXBar: needXBarRef,
          yBarSizePx: yBarSizePxRef,
          xBarSizePx: xBarSizePxRef,
          yBarTopPx: yBarTopPxRef,
          xBarLeftPx: xBarLeftPxRef,
          isShowXBar: mergedShowXBarRef,
          isShowYBar: mergedShowYBarRef,
          isIos,
          handleScroll,
          handleContentResize,
          handleContainerResize,
          handleYScrollMouseDown,
          handleXScrollMouseDown,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender
        };
      },
      render() {
        const {
          $slots,
          mergedClsPrefix,
          triggerDisplayManually,
          rtlEnabled,
          internalHoistYRail
        } = this;
        if (!this.scrollable)
          return $slots.default?.();
        const triggerIsNone = this.trigger === "none";
        const createYRail = () => {
          return /* @__PURE__ */ vue.h("div", {
            ref: "yRailRef",
            class: [
              `${mergedClsPrefix}-scrollbar-rail`,
              `${mergedClsPrefix}-scrollbar-rail--vertical`
            ],
            "data-scrollbar-rail": true,
            style: this.verticalRailStyle,
            "aria-hidden": true
          }, vue.h(
            triggerIsNone ? Wrapper : vue.Transition,
            triggerIsNone ? null : { name: "fade-in-transition" },
            {
              default: () => this.needYBar && this.isShowYBar && !this.isIos ? /* @__PURE__ */ vue.h("div", {
                class: `${mergedClsPrefix}-scrollbar-rail__scrollbar`,
                style: {
                  height: this.yBarSizePx,
                  top: this.yBarTopPx
                },
                onMousedown: this.handleYScrollMouseDown
              }) : null
            }
          ));
        };
        const createChildren = () => {
          this.onRender?.();
          return vue.h(
            "div",
            vue.mergeProps(this.$attrs, {
              role: "none",
              ref: "wrapperRef",
              class: [
                `${mergedClsPrefix}-scrollbar`,
                this.themeClass,
                rtlEnabled && `${mergedClsPrefix}-scrollbar--rtl`
              ],
              style: this.cssVars,
              onMouseenter: triggerDisplayManually ? void 0 : this.handleMouseEnterWrapper,
              onMouseleave: triggerDisplayManually ? void 0 : this.handleMouseLeaveWrapper
            }),
            [
              this.container ? $slots.default?.() : /* @__PURE__ */ vue.h("div", {
                role: "none",
                ref: "containerRef",
                class: [
                  `${mergedClsPrefix}-scrollbar-container`,
                  this.containerClass
                ],
                style: this.containerStyle,
                onScroll: this.handleScroll,
                onWheel: this.onWheel
              }, /* @__PURE__ */ vue.h(VResizeObserver, {
                onResize: this.handleContentResize
              }, {
                default: () => /* @__PURE__ */ vue.h("div", {
                  ref: "contentRef",
                  role: "none",
                  style: [
                    {
                      width: this.xScrollable ? "fit-content" : null
                    },
                    this.contentStyle
                  ],
                  class: [
                    `${mergedClsPrefix}-scrollbar-content`,
                    this.contentClass
                  ]
                }, $slots)
              })),
              internalHoistYRail ? null : createYRail(),
              this.xScrollable && /* @__PURE__ */ vue.h("div", {
                ref: "xRailRef",
                class: [
                  `${mergedClsPrefix}-scrollbar-rail`,
                  `${mergedClsPrefix}-scrollbar-rail--horizontal`
                ],
                style: this.horizontalRailStyle,
                "data-scrollbar-rail": true,
                "aria-hidden": true
              }, vue.h(
                triggerIsNone ? Wrapper : vue.Transition,
                triggerIsNone ? null : { name: "fade-in-transition" },
                {
                  default: () => this.needXBar && this.isShowXBar && !this.isIos ? /* @__PURE__ */ vue.h("div", {
                    class: `${mergedClsPrefix}-scrollbar-rail__scrollbar`,
                    style: {
                      width: this.xBarSizePx,
                      right: rtlEnabled ? this.xBarLeftPx : void 0,
                      left: rtlEnabled ? void 0 : this.xBarLeftPx
                    },
                    onMousedown: this.handleXScrollMouseDown
                  }) : null
                }
              ))
            ]
          );
        };
        const scrollbarNode = this.container ? createChildren() : /* @__PURE__ */ vue.h(VResizeObserver, {
          onResize: this.handleContainerResize
        }, {
          default: createChildren
        });
        if (internalHoistYRail) {
          return /* @__PURE__ */ vue.h(vue.Fragment, null, scrollbarNode, createYRail());
        } else {
          return scrollbarNode;
        }
      }
    });
    var NScrollbar = Scrollbar$2;
    const XScrollbar = Scrollbar$2;

    var commonVariables$l = {
      height: "calc(var(--n-option-height) * 7.6)",
      paddingSmall: "4px 0",
      paddingMedium: "4px 0",
      paddingLarge: "4px 0",
      paddingHuge: "4px 0",
      optionPaddingSmall: "0 12px",
      optionPaddingMedium: "0 12px",
      optionPaddingLarge: "0 12px",
      optionPaddingHuge: "0 12px",
      loadingSize: "18px"
    };

    const self$19 = vars => {
      const {
        borderRadius,
        popoverColor,
        textColor3,
        dividerColor,
        textColor2,
        primaryColorPressed,
        textColorDisabled,
        primaryColor,
        opacityDisabled,
        hoverColor,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        fontSizeHuge,
        heightSmall,
        heightMedium,
        heightLarge,
        heightHuge
      } = vars;
      return { ...commonVariables$l,
        optionFontSizeSmall: fontSizeSmall,
        optionFontSizeMedium: fontSizeMedium,
        optionFontSizeLarge: fontSizeLarge,
        optionFontSizeHuge: fontSizeHuge,
        optionHeightSmall: heightSmall,
        optionHeightMedium: heightMedium,
        optionHeightLarge: heightLarge,
        optionHeightHuge: heightHuge,
        borderRadius,
        color: popoverColor,
        groupHeaderTextColor: textColor3,
        actionDividerColor: dividerColor,
        optionTextColor: textColor2,
        optionTextColorPressed: primaryColorPressed,
        optionTextColorDisabled: textColorDisabled,
        optionTextColorActive: primaryColor,
        optionOpacityDisabled: opacityDisabled,
        optionCheckColor: primaryColor,
        optionColorPending: hoverColor,
        optionColorActive: "rgba(0, 0, 0, 0)",
        optionColorActivePending: hoverColor,
        actionTextColor: textColor2,
        loadingColor: primaryColor
      };
    };
    const internalSelectMenuLight = createTheme$1({
      name: "InternalSelectMenu",
      common: commonLight,
      peers: {
        Scrollbar: scrollbarLight$1,
        Empty: emptyLight$1
      },
      self: self$19
    });
    var internalSelectMenuLight$1 = internalSelectMenuLight;

    const internalSelectMenuDark = {
      name: "InternalSelectMenu",
      common: commonDark,
      peers: {
        Scrollbar: scrollbarDark$1,
        Empty: emptyDark$1
      },
      self: self$19
    };
    var internalSelectMenuDark$1 = internalSelectMenuDark;

    const checkMarkIcon = vue.h(FinishedIcon);
    function renderCheckMark(show, clsPrefix) {
      return /* @__PURE__ */ vue.h(vue.Transition, {
        name: "fade-in-scale-up-transition"
      }, {
        default: () => show ? /* @__PURE__ */ vue.h(NBaseIcon, {
          clsPrefix,
          class: `${clsPrefix}-base-select-option__check`
        }, {
          default: () => checkMarkIcon
        }) : null
      });
    }
    var NSelectOption = vue.defineComponent({
      name: "NBaseSelectOption",
      props: {
        clsPrefix: {
          type: String,
          required: true
        },
        tmNode: {
          type: Object,
          required: true
        }
      },
      setup(props) {
        const {
          valueRef,
          pendingTmNodeRef,
          multipleRef,
          valueSetRef,
          renderLabelRef,
          renderOptionRef,
          labelFieldRef,
          valueFieldRef,
          showCheckmarkRef,
          nodePropsRef,
          handleOptionClick,
          handleOptionMouseEnter
        } = vue.inject(internalSelectionMenuInjectionKey);
        const isPendingRef = useMemo(() => {
          const { value: pendingTmNode } = pendingTmNodeRef;
          if (!pendingTmNode)
            return false;
          return props.tmNode.key === pendingTmNode.key;
        });
        function handleClick(e) {
          const { tmNode } = props;
          if (tmNode.disabled)
            return;
          handleOptionClick(e, tmNode);
        }
        function handleMouseEnter(e) {
          const { tmNode } = props;
          if (tmNode.disabled)
            return;
          handleOptionMouseEnter(e, tmNode);
        }
        function handleMouseMove(e) {
          const { tmNode } = props;
          const { value: isPending } = isPendingRef;
          if (tmNode.disabled || isPending)
            return;
          handleOptionMouseEnter(e, tmNode);
        }
        return {
          multiple: multipleRef,
          isGrouped: useMemo(() => {
            const { tmNode } = props;
            const { parent } = tmNode;
            return parent && parent.rawNode.type === "group";
          }),
          showCheckmark: showCheckmarkRef,
          nodeProps: nodePropsRef,
          isPending: isPendingRef,
          isSelected: useMemo(() => {
            const { value } = valueRef;
            const { value: multiple } = multipleRef;
            if (value === null)
              return false;
            const optionValue = props.tmNode.rawNode[valueFieldRef.value];
            if (multiple) {
              const { value: valueSet } = valueSetRef;
              return valueSet.has(optionValue);
            } else {
              return value === optionValue;
            }
          }),
          labelField: labelFieldRef,
          renderLabel: renderLabelRef,
          renderOption: renderOptionRef,
          handleMouseMove,
          handleMouseEnter,
          handleClick
        };
      },
      render() {
        const {
          clsPrefix,
          tmNode: { rawNode },
          isSelected,
          isPending,
          isGrouped,
          showCheckmark,
          nodeProps,
          renderOption,
          renderLabel,
          handleClick,
          handleMouseEnter,
          handleMouseMove
        } = this;
        const checkmark = renderCheckMark(isSelected, clsPrefix);
        const children = renderLabel ? [renderLabel(rawNode, isSelected), showCheckmark && checkmark] : [
          render$1(
            rawNode[this.labelField],
            rawNode,
            isSelected
          ),
          showCheckmark && checkmark
        ];
        const attrs = nodeProps?.(rawNode);
        const node = /* @__PURE__ */ vue.h("div", {
          ...attrs,
          class: [
            `${clsPrefix}-base-select-option`,
            rawNode.class,
            attrs?.class,
            {
              [`${clsPrefix}-base-select-option--disabled`]: rawNode.disabled,
              [`${clsPrefix}-base-select-option--selected`]: isSelected,
              [`${clsPrefix}-base-select-option--grouped`]: isGrouped,
              [`${clsPrefix}-base-select-option--pending`]: isPending,
              [`${clsPrefix}-base-select-option--show-checkmark`]: showCheckmark
            }
          ],
          style: [attrs?.style || "", rawNode.style || ""],
          onClick: mergeEventHandlers([handleClick, attrs?.onClick]),
          onMouseenter: mergeEventHandlers([
            handleMouseEnter,
            attrs?.onMouseenter
          ]),
          onMousemove: mergeEventHandlers([handleMouseMove, attrs?.onMousemove])
        }, /* @__PURE__ */ vue.h("div", {
          class: `${clsPrefix}-base-select-option__content`
        }, children));
        return rawNode.render ? rawNode.render({ node, option: rawNode, selected: isSelected }) : renderOption ? renderOption({ node, option: rawNode, selected: isSelected }) : node;
      }
    });

    var NSelectGroupHeader = vue.defineComponent({
      name: "NBaseSelectGroupHeader",
      props: {
        clsPrefix: {
          type: String,
          required: true
        },
        tmNode: {
          type: Object,
          required: true
        }
      },
      setup() {
        const {
          renderLabelRef,
          renderOptionRef,
          labelFieldRef,
          nodePropsRef
        } = vue.inject(internalSelectionMenuInjectionKey);
        return {
          labelField: labelFieldRef,
          nodeProps: nodePropsRef,
          renderLabel: renderLabelRef,
          renderOption: renderOptionRef
        };
      },
      render() {
        const {
          clsPrefix,
          renderLabel,
          renderOption,
          nodeProps,
          tmNode: { rawNode }
        } = this;
        const attrs = nodeProps?.(rawNode);
        const children = renderLabel ? renderLabel(rawNode, false) : render$1(rawNode[this.labelField], rawNode, false);
        const node = /* @__PURE__ */ vue.h("div", {
          ...attrs,
          class: [`${clsPrefix}-base-select-group-header`, attrs?.class]
        }, children);
        return rawNode.render ? rawNode.render({ node, option: rawNode }) : renderOption ? renderOption({ node, option: rawNode, selected: false }) : node;
      }
    });

    const {
      cubicBezierEaseIn: cubicBezierEaseIn$5,
      cubicBezierEaseOut: cubicBezierEaseOut$6
    } = commonVariables$m;
    function fadeInScaleUpTransition() {
      let {
        transformOrigin = "inherit",
        duration = ".2s",
        enterScale = ".9",
        originalTransform = "",
        originalTransition = ""
      } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return [c$1("&.fade-in-scale-up-transition-leave-active", {
        transformOrigin,
        transition: `opacity ${duration} ${cubicBezierEaseIn$5}, transform ${duration} ${cubicBezierEaseIn$5} ${originalTransition && "," + originalTransition}`
      }), c$1("&.fade-in-scale-up-transition-enter-active", {
        transformOrigin,
        transition: `opacity ${duration} ${cubicBezierEaseOut$6}, transform ${duration} ${cubicBezierEaseOut$6} ${originalTransition && "," + originalTransition}`
      }), c$1("&.fade-in-scale-up-transition-enter-from, &.fade-in-scale-up-transition-leave-to", {
        opacity: 0,
        transform: `${originalTransform} scale(${enterScale})`
      }), c$1("&.fade-in-scale-up-transition-leave-from, &.fade-in-scale-up-transition-enter-to", {
        opacity: 1,
        transform: `${originalTransform} scale(1)`
      })];
    }

    var style$1t = cB("base-select-menu", `
  line-height: 1.5;
  outline: none;
  z-index: 0;
  position: relative;
  border-radius: var(--n-border-radius);
  transition:
    background-color .3s var(--n-bezier),
    box-shadow .3s var(--n-bezier);
  background-color: var(--n-color);
`, [cB("scrollbar", `
    max-height: var(--n-height);
  `), cB("virtual-list", `
    max-height: var(--n-height);
  `), cB("base-select-option", `
    min-height: var(--n-option-height);
    font-size: var(--n-option-font-size);
    display: flex;
    align-items: center;
  `, [cE("content", `
      z-index: 1;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
    `)]), cB("base-select-group-header", `
    min-height: var(--n-option-height);
    font-size: .93em;
    display: flex;
    align-items: center;
  `), cB("base-select-menu-option-wrapper", `
    position: relative;
    width: 100%;
  `), cE("loading, empty", `
    display: flex;
    padding: 12px 32px;
    flex: 1;
    justify-content: center;
  `), cE("loading", `
    color: var(--n-loading-color);
    font-size: var(--n-loading-size);
  `), cE("action", `
    padding: 8px var(--n-option-padding-left);
    font-size: var(--n-option-font-size);
    transition:
      color .3s var(--n-bezier),
      border-color .3s var(--n-bezier);
    border-top: 1px solid var(--n-action-divider-color);
    color: var(--n-action-text-color);
  `), cB("base-select-group-header", `
    position: relative;
    cursor: default;
    padding: var(--n-option-padding);
    color: var(--n-group-header-text-color);
  `), cB("base-select-option", `
    cursor: pointer;
    position: relative;
    padding: var(--n-option-padding);
    transition:
      color .3s var(--n-bezier),
      opacity .3s var(--n-bezier);
    box-sizing: border-box;
    color: var(--n-option-text-color);
    opacity: 1;
  `, [cM("show-checkmark", `
      padding-right: calc(var(--n-option-padding-right) + 20px);
    `), c$1("&::before", `
      content: "";
      position: absolute;
      left: 4px;
      right: 4px;
      top: 0;
      bottom: 0;
      border-radius: var(--n-border-radius);
      transition: background-color .3s var(--n-bezier);
    `), c$1("&:active", `
      color: var(--n-option-text-color-pressed);
    `), cM("grouped", `
      padding-left: calc(var(--n-option-padding-left) * 1.5);
    `), cM("pending", [c$1("&::before", `
        background-color: var(--n-option-color-pending);
      `)]), cM("selected", `
      color: var(--n-option-text-color-active);
    `, [c$1("&::before", `
        background-color: var(--n-option-color-active);
      `), cM("pending", [c$1("&::before", `
          background-color: var(--n-option-color-active-pending);
        `)])]), cM("disabled", `
      cursor: not-allowed;
    `, [cNotM("selected", `
        color: var(--n-option-text-color-disabled);
      `), cM("selected", `
        opacity: var(--n-option-opacity-disabled);
      `)]), cE("check", `
      font-size: 16px;
      position: absolute;
      right: calc(var(--n-option-padding-right) - 4px);
      top: calc(50% - 7px);
      color: var(--n-option-check-color);
      transition: color .3s var(--n-bezier);
    `, [fadeInScaleUpTransition({
      enterScale: "0.5"
    })])])]);

    var NInternalSelectMenu = vue.defineComponent({
      name: "InternalSelectMenu",
      props: {
        ...useTheme.props,
        clsPrefix: {
          type: String,
          required: true
        },
        scrollable: {
          type: Boolean,
          default: true
        },
        treeMate: {
          type: Object,
          required: true
        },
        multiple: Boolean,
        size: {
          type: String,
          default: "medium"
        },
        value: {
          type: [String, Number, Array],
          default: null
        },
        autoPending: Boolean,
        virtualScroll: {
          type: Boolean,
          default: true
        },
        show: {
          type: Boolean,
          default: true
        },
        labelField: {
          type: String,
          default: "label"
        },
        valueField: {
          type: String,
          default: "value"
        },
        loading: Boolean,
        focusable: Boolean,
        renderLabel: Function,
        renderOption: Function,
        nodeProps: Function,
        showCheckmark: { type: Boolean, default: true },
        onMousedown: Function,
        onScroll: Function,
        onFocus: Function,
        onBlur: Function,
        onKeyup: Function,
        onKeydown: Function,
        onTabOut: Function,
        onMouseenter: Function,
        onMouseleave: Function,
        onResize: Function,
        resetMenuOnOptionsChange: {
          type: Boolean,
          default: true
        },
        inlineThemeDisabled: Boolean,
        onToggle: Function
      },
      setup(props) {
        const themeRef = useTheme(
          "InternalSelectMenu",
          "-internal-select-menu",
          style$1t,
          internalSelectMenuLight$1,
          props,
          vue.toRef(props, "clsPrefix")
        );
        const selfRef = vue.ref(null);
        const virtualListRef = vue.ref(null);
        const scrollbarRef = vue.ref(null);
        const flattenedNodesRef = vue.computed(() => props.treeMate.getFlattenedNodes());
        const fIndexGetterRef = vue.computed(
          () => createIndexGetter(flattenedNodesRef.value)
        );
        const pendingNodeRef = vue.ref(null);
        function initPendingNode() {
          const { treeMate } = props;
          let defaultPendingNode = null;
          const { value } = props;
          if (value === null) {
            defaultPendingNode = treeMate.getFirstAvailableNode();
          } else {
            if (props.multiple) {
              defaultPendingNode = treeMate.getNode(
                (value || [])[(value || []).length - 1]
              );
            } else {
              defaultPendingNode = treeMate.getNode(value);
            }
            if (!defaultPendingNode || defaultPendingNode.disabled) {
              defaultPendingNode = treeMate.getFirstAvailableNode();
            }
          }
          if (defaultPendingNode) {
            setPendingTmNode(defaultPendingNode);
          } else {
            setPendingTmNode(null);
          }
        }
        function clearPendingNodeIfInvalid() {
          const { value: pendingNode } = pendingNodeRef;
          if (pendingNode && !props.treeMate.getNode(pendingNode.key)) {
            pendingNodeRef.value = null;
          }
        }
        let initPendingNodeWatchStopHandle;
        vue.watch(
          () => props.show,
          (show) => {
            if (show) {
              initPendingNodeWatchStopHandle = vue.watch(
                () => props.treeMate,
                () => {
                  if (props.resetMenuOnOptionsChange) {
                    if (props.autoPending) {
                      initPendingNode();
                    } else {
                      clearPendingNodeIfInvalid();
                    }
                    void vue.nextTick(scrollToPendingNode);
                  } else {
                    clearPendingNodeIfInvalid();
                  }
                },
                {
                  immediate: true
                }
              );
            } else {
              initPendingNodeWatchStopHandle?.();
            }
          },
          {
            immediate: true
          }
        );
        vue.onBeforeUnmount(() => {
          initPendingNodeWatchStopHandle?.();
        });
        const itemSizeRef = vue.computed(() => {
          return depx(themeRef.value.self[createKey("optionHeight", props.size)]);
        });
        const paddingRef = vue.computed(() => {
          return getMargin(themeRef.value.self[createKey("padding", props.size)]);
        });
        const valueSetRef = vue.computed(() => {
          if (props.multiple && Array.isArray(props.value)) {
            return new Set(props.value);
          }
          return /* @__PURE__ */ new Set();
        });
        const emptyRef = vue.computed(() => {
          const tmNodes = flattenedNodesRef.value;
          return tmNodes && tmNodes.length === 0;
        });
        function doToggle(tmNode) {
          const { onToggle } = props;
          if (onToggle)
            onToggle(tmNode);
        }
        function doScroll(e) {
          const { onScroll } = props;
          if (onScroll)
            onScroll(e);
        }
        function handleVirtualListScroll(e) {
          scrollbarRef.value?.sync();
          doScroll(e);
        }
        function handleVirtualListResize() {
          scrollbarRef.value?.sync();
        }
        function getPendingTmNode() {
          const { value: pendingTmNode } = pendingNodeRef;
          if (pendingTmNode)
            return pendingTmNode;
          return null;
        }
        function handleOptionMouseEnter(e, tmNode) {
          if (tmNode.disabled)
            return;
          setPendingTmNode(tmNode, false);
        }
        function handleOptionClick(e, tmNode) {
          if (tmNode.disabled)
            return;
          doToggle(tmNode);
        }
        function handleKeyUp(e) {
          if (happensIn(e, "action"))
            return;
          props.onKeyup?.(e);
        }
        function handleKeyDown(e) {
          if (happensIn(e, "action"))
            return;
          props.onKeydown?.(e);
        }
        function handleMouseDown(e) {
          props.onMousedown?.(e);
          if (props.focusable)
            return;
          e.preventDefault();
        }
        function next() {
          const { value: pendingTmNode } = pendingNodeRef;
          if (pendingTmNode) {
            setPendingTmNode(pendingTmNode.getNext({ loop: true }), true);
          }
        }
        function prev() {
          const { value: pendingTmNode } = pendingNodeRef;
          if (pendingTmNode) {
            setPendingTmNode(pendingTmNode.getPrev({ loop: true }), true);
          }
        }
        function setPendingTmNode(tmNode, doScroll2 = false) {
          pendingNodeRef.value = tmNode;
          if (doScroll2)
            scrollToPendingNode();
        }
        function scrollToPendingNode() {
          const tmNode = pendingNodeRef.value;
          if (!tmNode)
            return;
          const fIndex = fIndexGetterRef.value(tmNode.key);
          if (fIndex === null)
            return;
          if (props.virtualScroll) {
            virtualListRef.value?.scrollTo({ index: fIndex });
          } else {
            scrollbarRef.value?.scrollTo({
              index: fIndex,
              elSize: itemSizeRef.value
            });
          }
        }
        function handleFocusin(e) {
          if (selfRef.value?.contains(e.target)) {
            props.onFocus?.(e);
          }
        }
        function handleFocusout(e) {
          if (!selfRef.value?.contains(e.relatedTarget)) {
            props.onBlur?.(e);
          }
        }
        vue.provide(internalSelectionMenuInjectionKey, {
          handleOptionMouseEnter,
          handleOptionClick,
          valueSetRef,
          pendingTmNodeRef: pendingNodeRef,
          nodePropsRef: vue.toRef(props, "nodeProps"),
          showCheckmarkRef: vue.toRef(props, "showCheckmark"),
          multipleRef: vue.toRef(props, "multiple"),
          valueRef: vue.toRef(props, "value"),
          renderLabelRef: vue.toRef(props, "renderLabel"),
          renderOptionRef: vue.toRef(props, "renderOption"),
          labelFieldRef: vue.toRef(props, "labelField"),
          valueFieldRef: vue.toRef(props, "valueField")
        });
        vue.provide(internalSelectionMenuBodyInjectionKey, selfRef);
        vue.onMounted(() => {
          const { value } = scrollbarRef;
          if (value)
            value.sync();
        });
        const cssVarsRef = vue.computed(() => {
          const { size } = props;
          const {
            common: { cubicBezierEaseInOut },
            self: {
              height,
              borderRadius,
              color,
              groupHeaderTextColor,
              actionDividerColor,
              optionTextColorPressed,
              optionTextColor,
              optionTextColorDisabled,
              optionTextColorActive,
              optionOpacityDisabled,
              optionCheckColor,
              actionTextColor,
              optionColorPending,
              optionColorActive,
              loadingColor,
              loadingSize,
              optionColorActivePending,
              [createKey("optionFontSize", size)]: fontSize,
              [createKey("optionHeight", size)]: optionHeight,
              [createKey("optionPadding", size)]: optionPadding
            }
          } = themeRef.value;
          return {
            "--n-height": height,
            "--n-action-divider-color": actionDividerColor,
            "--n-action-text-color": actionTextColor,
            "--n-bezier": cubicBezierEaseInOut,
            "--n-border-radius": borderRadius,
            "--n-color": color,
            "--n-option-font-size": fontSize,
            "--n-group-header-text-color": groupHeaderTextColor,
            "--n-option-check-color": optionCheckColor,
            "--n-option-color-pending": optionColorPending,
            "--n-option-color-active": optionColorActive,
            "--n-option-color-active-pending": optionColorActivePending,
            "--n-option-height": optionHeight,
            "--n-option-opacity-disabled": optionOpacityDisabled,
            "--n-option-text-color": optionTextColor,
            "--n-option-text-color-active": optionTextColorActive,
            "--n-option-text-color-disabled": optionTextColorDisabled,
            "--n-option-text-color-pressed": optionTextColorPressed,
            "--n-option-padding": optionPadding,
            "--n-option-padding-left": getMargin(optionPadding, "left"),
            "--n-option-padding-right": getMargin(optionPadding, "right"),
            "--n-loading-color": loadingColor,
            "--n-loading-size": loadingSize
          };
        });
        const { inlineThemeDisabled } = props;
        const themeClassHandle = inlineThemeDisabled ? useThemeClass(
          "internal-select-menu",
          vue.computed(() => props.size[0]),
          cssVarsRef,
          props
        ) : void 0;
        const exposedProps = {
          selfRef,
          next,
          prev,
          getPendingTmNode
        };
        useOnResize(selfRef, props.onResize);
        return {
          mergedTheme: themeRef,
          virtualListRef,
          scrollbarRef,
          itemSize: itemSizeRef,
          padding: paddingRef,
          flattenedNodes: flattenedNodesRef,
          empty: emptyRef,
          virtualListContainer() {
            const { value } = virtualListRef;
            return value?.listElRef;
          },
          virtualListContent() {
            const { value } = virtualListRef;
            return value?.itemsElRef;
          },
          doScroll,
          handleFocusin,
          handleFocusout,
          handleKeyUp,
          handleKeyDown,
          handleMouseDown,
          handleVirtualListResize,
          handleVirtualListScroll,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender,
          ...exposedProps
        };
      },
      render() {
        const {
          $slots,
          virtualScroll,
          clsPrefix,
          mergedTheme,
          themeClass,
          onRender
        } = this;
        onRender?.();
        return /* @__PURE__ */ vue.h("div", {
          ref: "selfRef",
          tabindex: this.focusable ? 0 : -1,
          class: [
            `${clsPrefix}-base-select-menu`,
            themeClass,
            this.multiple && `${clsPrefix}-base-select-menu--multiple`
          ],
          style: this.cssVars,
          onFocusin: this.handleFocusin,
          onFocusout: this.handleFocusout,
          onKeyup: this.handleKeyUp,
          onKeydown: this.handleKeyDown,
          onMousedown: this.handleMouseDown,
          onMouseenter: this.onMouseenter,
          onMouseleave: this.onMouseleave
        }, this.loading ? /* @__PURE__ */ vue.h("div", {
          class: `${clsPrefix}-base-select-menu__loading`
        }, /* @__PURE__ */ vue.h(NBaseLoading, {
          clsPrefix,
          strokeWidth: 20
        })) : !this.empty ? /* @__PURE__ */ vue.h(NScrollbar, {
          ref: "scrollbarRef",
          theme: mergedTheme.peers.Scrollbar,
          themeOverrides: mergedTheme.peerOverrides.Scrollbar,
          scrollable: this.scrollable,
          container: virtualScroll ? this.virtualListContainer : void 0,
          content: virtualScroll ? this.virtualListContent : void 0,
          onScroll: virtualScroll ? void 0 : this.doScroll
        }, {
          default: () => {
            return virtualScroll ? /* @__PURE__ */ vue.h(VVirtualList, {
              ref: "virtualListRef",
              class: `${clsPrefix}-virtual-list`,
              items: this.flattenedNodes,
              itemSize: this.itemSize,
              showScrollbar: false,
              paddingTop: this.padding.top,
              paddingBottom: this.padding.bottom,
              onResize: this.handleVirtualListResize,
              onScroll: this.handleVirtualListScroll,
              itemResizable: true
            }, {
              default: ({
                item: tmNode
              }) => {
                return tmNode.isGroup ? /* @__PURE__ */ vue.h(NSelectGroupHeader, {
                  key: tmNode.key,
                  clsPrefix,
                  tmNode
                }) : tmNode.ignored ? null : /* @__PURE__ */ vue.h(NSelectOption, {
                  clsPrefix,
                  key: tmNode.key,
                  tmNode
                });
              }
            }) : /* @__PURE__ */ vue.h("div", {
              class: `${clsPrefix}-base-select-menu-option-wrapper`,
              style: {
                paddingTop: this.padding.top,
                paddingBottom: this.padding.bottom
              }
            }, this.flattenedNodes.map(
              (tmNode) => tmNode.isGroup ? /* @__PURE__ */ vue.h(NSelectGroupHeader, {
                key: tmNode.key,
                clsPrefix,
                tmNode
              }) : /* @__PURE__ */ vue.h(NSelectOption, {
                clsPrefix,
                key: tmNode.key,
                tmNode
              })
            ));
          }
        }) : /* @__PURE__ */ vue.h("div", {
          class: `${clsPrefix}-base-select-menu__empty`,
          "data-empty": true
        }, resolveSlot($slots.empty, () => [
          /* @__PURE__ */ vue.h(NEmpty, {
            theme: mergedTheme.peers.Empty,
            themeOverrides: mergedTheme.peerOverrides.Empty
          })
        ])), resolveWrappedSlot(
          $slots.action,
          (children) => children && [
            /* @__PURE__ */ vue.h("div", {
              class: `${clsPrefix}-base-select-menu__action`,
              "data-action": true,
              key: "action"
            }, children),
            /* @__PURE__ */ vue.h(FocusDetector, {
              onFocus: this.onTabOut,
              key: "focus-detector"
            })
          ]
        ));
      }
    });

    var style$1s = cB("base-wave", `
  position: absolute;
  left: 0;
  right: 0;
  top: 0;
  bottom: 0;
  border-radius: inherit;
`);

    var NBaseWave = vue.defineComponent({
      name: "BaseWave",
      props: {
        clsPrefix: {
          type: String,
          required: true
        }
      },
      setup(props) {
        useStyle("-base-wave", style$1s, vue.toRef(props, "clsPrefix"));
        const selfRef = vue.ref(null);
        const activeRef = vue.ref(false);
        let animationTimerId = null;
        vue.onBeforeUnmount(() => {
          if (animationTimerId !== null) {
            window.clearTimeout(animationTimerId);
          }
        });
        return {
          active: activeRef,
          selfRef,
          play() {
            if (animationTimerId !== null) {
              window.clearTimeout(animationTimerId);
              activeRef.value = false;
              animationTimerId = null;
            }
            void vue.nextTick(() => {
              void selfRef.value?.offsetHeight;
              activeRef.value = true;
              animationTimerId = window.setTimeout(() => {
                activeRef.value = false;
                animationTimerId = null;
              }, 1e3);
            });
          }
        };
      },
      render() {
        const { clsPrefix } = this;
        return /* @__PURE__ */ vue.h("div", {
          ref: "selfRef",
          "aria-hidden": true,
          class: [
            `${clsPrefix}-base-wave`,
            this.active && `${clsPrefix}-base-wave--active`
          ]
        });
      }
    });

    var style$1r = cB("base-menu-mask", `
  position: absolute;
  left: 0;
  right: 0;
  top: 0;
  bottom: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  text-align: center;
  padding: 14px;
  overflow: hidden;
`, [fadeInTransition()]);

    var NBaseMenuMask = vue.defineComponent({
      name: "BaseMenuMask",
      props: {
        clsPrefix: {
          type: String,
          required: true
        }
      },
      setup(props) {
        useStyle("-base-menu-mask", style$1r, vue.toRef(props, "clsPrefix"));
        const messageRef = vue.ref(null);
        let timerId = null;
        const uncontrolledShowRef = vue.ref(false);
        vue.onBeforeUnmount(() => {
          if (timerId !== null) {
            window.clearTimeout(timerId);
          }
        });
        const exposedRef = {
          showOnce(message, duration = 1500) {
            if (timerId)
              window.clearTimeout(timerId);
            uncontrolledShowRef.value = true;
            messageRef.value = message;
            timerId = window.setTimeout(() => {
              uncontrolledShowRef.value = false;
              messageRef.value = null;
            }, duration);
          }
        };
        return {
          message: messageRef,
          show: uncontrolledShowRef,
          ...exposedRef
        };
      },
      render() {
        return /* @__PURE__ */ vue.h(vue.Transition, {
          name: "fade-in-transition"
        }, {
          default: () => this.show ? /* @__PURE__ */ vue.h("div", {
            class: `${this.clsPrefix}-base-menu-mask`
          }, this.message) : null
        });
      }
    });

    var commonVariables$k = {
      space: "6px",
      spaceArrow: "10px",
      arrowOffset: "10px",
      arrowOffsetVertical: "10px",
      arrowHeight: "6px",
      padding: "8px 14px"
    };

    const self$18 = vars => {
      const {
        boxShadow2,
        popoverColor,
        textColor2,
        borderRadius,
        fontSize,
        dividerColor
      } = vars;
      return { ...commonVariables$k,
        fontSize,
        borderRadius,
        color: popoverColor,
        dividerColor,
        textColor: textColor2,
        boxShadow: boxShadow2
      };
    };
    const popoverLight = {
      name: "Popover",
      common: commonLight,
      self: self$18
    };
    var popoverLight$1 = popoverLight;

    const popoverDark = {
      name: "Popover",
      common: commonDark,
      self: self$18
    };
    var popoverDark$1 = popoverDark;

    const oppositePlacement = {
      top: "bottom",
      bottom: "top",
      left: "right",
      right: "left"
    };
    const arrowSize = "var(--n-arrow-height) * 1.414";
    var style$1q = c$1([cB("popover", `
    transition:
      box-shadow .3s var(--n-bezier),
      background-color .3s var(--n-bezier),
      color .3s var(--n-bezier);
    position: relative;
    font-size: var(--n-font-size);
    color: var(--n-text-color);
    box-shadow: var(--n-box-shadow);
  `, [c$1(">", [cB("scrollbar", `
        height: inherit;
        max-height: inherit;
      `)]), cNotM("raw", `
      background-color: var(--n-color);
      border-radius: var(--n-border-radius);
    `, [cNotM("scrollable", [cNotM("show-header-or-footer", "padding: var(--n-padding);")])]), cE("header", `
      padding: var(--n-padding);
      border-bottom: 1px solid var(--n-divider-color);
      transition: border-color .3s var(--n-bezier);
    `), cE("footer", `
      padding: var(--n-padding);
      border-top: 1px solid var(--n-divider-color);
      transition: border-color .3s var(--n-bezier);
    `), cM("scrollable, show-header-or-footer", [cE("content", `
        padding: var(--n-padding);
      `)])]), cB("popover-shared", `
    transform-origin: inherit;
  `, [cB("popover-arrow-wrapper", `
      position: absolute;
      overflow: hidden;
      pointer-events: none;
    `, [cB("popover-arrow", `
        transition: background-color .3s var(--n-bezier);
        position: absolute;
        display: block;
        width: calc(${arrowSize});
        height: calc(${arrowSize});
        box-shadow: 0 0 8px 0 rgba(0, 0, 0, .12);
        transform: rotate(45deg);
        background-color: var(--n-color);
        pointer-events: all;
      `)]), c$1("&.popover-transition-enter-from, &.popover-transition-leave-to", `
      opacity: 0;
      transform: scale(.85);
    `), c$1("&.popover-transition-enter-to, &.popover-transition-leave-from", `
      transform: scale(1);
      opacity: 1;
    `), c$1("&.popover-transition-enter-active", `
      transition:
        box-shadow .3s var(--n-bezier),
        background-color .3s var(--n-bezier),
        color .3s var(--n-bezier),
        opacity .15s var(--n-bezier-ease-out),
        transform .15s var(--n-bezier-ease-out);
    `), c$1("&.popover-transition-leave-active", `
      transition:
        box-shadow .3s var(--n-bezier),
        background-color .3s var(--n-bezier),
        color .3s var(--n-bezier),
        opacity .15s var(--n-bezier-ease-in),
        transform .15s var(--n-bezier-ease-in);
    `)]), placementStyle("top-start", `
    top: calc(${arrowSize} / -2);
    left: calc(${getArrowOffset("top-start")} - var(--v-offset-left));
  `), placementStyle("top", `
    top: calc(${arrowSize} / -2);
    transform: translateX(calc(${arrowSize} / -2)) rotate(45deg);
    left: 50%;
  `), placementStyle("top-end", `
    top: calc(${arrowSize} / -2);
    right: calc(${getArrowOffset("top-end")} + var(--v-offset-left));
  `), placementStyle("bottom-start", `
    bottom: calc(${arrowSize} / -2);
    left: calc(${getArrowOffset("bottom-start")} - var(--v-offset-left));
  `), placementStyle("bottom", `
    bottom: calc(${arrowSize} / -2);
    transform: translateX(calc(${arrowSize} / -2)) rotate(45deg);
    left: 50%;
  `), placementStyle("bottom-end", `
    bottom: calc(${arrowSize} / -2);
    right: calc(${getArrowOffset("bottom-end")} + var(--v-offset-left));
  `), placementStyle("left-start", `
    left: calc(${arrowSize} / -2);
    top: calc(${getArrowOffset("left-start")} - var(--v-offset-top));
  `), placementStyle("left", `
    left: calc(${arrowSize} / -2);
    transform: translateY(calc(${arrowSize} / -2)) rotate(45deg);
    top: 50%;
  `), placementStyle("left-end", `
    left: calc(${arrowSize} / -2);
    bottom: calc(${getArrowOffset("left-end")} + var(--v-offset-top));
  `), placementStyle("right-start", `
    right: calc(${arrowSize} / -2);
    top: calc(${getArrowOffset("right-start")} - var(--v-offset-top));
  `), placementStyle("right", `
    right: calc(${arrowSize} / -2);
    transform: translateY(calc(${arrowSize} / -2)) rotate(45deg);
    top: 50%;
  `), placementStyle("right-end", `
    right: calc(${arrowSize} / -2);
    bottom: calc(${getArrowOffset("right-end")} + var(--v-offset-top));
  `), ...lodash.exports.map({
      top: ["right-start", "left-start"],
      right: ["top-end", "bottom-end"],
      bottom: ["right-end", "left-end"],
      left: ["top-start", "bottom-start"]
    }, (placements, direction) => {
      const isVertical = ["right", "left"].includes(direction);
      const sizeType = isVertical ? "width" : "height";
      return placements.map(placement => {
        const isReverse = placement.split("-")[1] === "end";
        const targetSize = `var(--v-target-${sizeType}, 0px)`;
        const centerOffset = `calc((${targetSize} - ${arrowSize}) / 2)`;
        const offset = getArrowOffset(placement);
        return c$1(`[v-placement="${placement}"] >`, [cB("popover-shared", [cM("center-arrow", [cB("popover-arrow", `${direction}: calc(max(${centerOffset}, ${offset}) ${isReverse ? "+" : "-"} var(--v-offset-${isVertical ? "left" : "top"}));`)])])]);
      });
    })]);

    function getArrowOffset(placement) {
      return ["top", "bottom"].includes(placement.split("-")[0]) ? "var(--n-arrow-offset)" : "var(--n-arrow-offset-vertical)";
    }

    function placementStyle(placement, arrowStyleLiteral) {
      const position = placement.split("-")[0];
      const sizeStyle = ["top", "bottom"].includes(position) ? "height: var(--n-space-arrow);" : "width: var(--n-space-arrow);";
      return c$1(`[v-placement="${placement}"] >`, [cB("popover-shared", `
      margin-${oppositePlacement[position]}: var(--n-space);
    `, [cM("show-arrow", `
        margin-${oppositePlacement[position]}: var(--n-space-arrow);
      `), cM("overlap", `
        margin: 0;
      `), cCB("popover-arrow-wrapper", `
        right: 0;
        left: 0;
        top: 0;
        bottom: 0;
        ${position}: 100%;
        ${oppositePlacement[position]}: auto;
        ${sizeStyle}
      `, [cB("popover-arrow", arrowStyleLiteral)])])]);
    }

    const popoverBodyProps = {
      ...useTheme.props,
      to: useAdjustedTo.propTo,
      show: Boolean,
      trigger: String,
      showArrow: Boolean,
      delay: Number,
      duration: Number,
      raw: Boolean,
      arrowPointToCenter: Boolean,
      arrowStyle: [String, Object],
      displayDirective: String,
      x: Number,
      y: Number,
      flip: Boolean,
      overlap: Boolean,
      placement: String,
      width: [Number, String],
      keepAliveOnHover: Boolean,
      scrollable: Boolean,
      contentStyle: [Object, String],
      headerStyle: [Object, String],
      footerStyle: [Object, String],
      internalDeactivateImmediately: Boolean,
      animated: Boolean,
      onClickoutside: Function,
      internalTrapFocus: Boolean,
      internalOnAfterLeave: Function,
      minWidth: Number,
      maxWidth: Number
    };
    const renderArrow = ({
      arrowStyle,
      clsPrefix
    }) => {
      return /* @__PURE__ */ vue.h("div", {
        key: "__popover-arrow__",
        class: `${clsPrefix}-popover-arrow-wrapper`
      }, /* @__PURE__ */ vue.h("div", {
        class: `${clsPrefix}-popover-arrow`,
        style: arrowStyle
      }));
    };
    var NPopoverBody = vue.defineComponent({
      name: "PopoverBody",
      inheritAttrs: false,
      props: popoverBodyProps,
      setup(props, { slots, attrs }) {
        const { namespaceRef, mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
        const themeRef = useTheme(
          "Popover",
          "-popover",
          style$1q,
          popoverLight$1,
          props,
          mergedClsPrefixRef
        );
        const followerRef = vue.ref(null);
        const NPopover = vue.inject("NPopover");
        const bodyRef = vue.ref(null);
        const followerEnabledRef = vue.ref(props.show);
        const displayedRef = vue.ref(false);
        vue.watchEffect(() => {
          const { show } = props;
          if (show && !isJsdom() && !props.internalDeactivateImmediately) {
            displayedRef.value = true;
          }
        });
        const directivesRef = vue.computed(() => {
          const { trigger, onClickoutside } = props;
          const directives = [];
          const {
            positionManuallyRef: { value: positionManually }
          } = NPopover;
          if (!positionManually) {
            if (trigger === "click" && !onClickoutside) {
              directives.push([
                clickoutside$1,
                handleClickOutside,
                void 0,
                { capture: true }
              ]);
            }
            if (trigger === "hover") {
              directives.push([mousemoveoutside$1, handleMouseMoveOutside]);
            }
          }
          if (onClickoutside) {
            directives.push([
              clickoutside$1,
              handleClickOutside,
              void 0,
              { capture: true }
            ]);
          }
          if (props.displayDirective === "show" || props.animated && displayedRef.value) {
            directives.push([vue.vShow, props.show]);
          }
          return directives;
        });
        const styleRef = vue.computed(() => {
          const width = props.width === "trigger" ? void 0 : formatLength(props.width);
          const style2 = [];
          if (width) {
            style2.push({ width });
          }
          const { maxWidth, minWidth } = props;
          if (maxWidth) {
            style2.push({ maxWidth: formatLength(maxWidth) });
          }
          if (minWidth) {
            style2.push({ maxWidth: formatLength(minWidth) });
          }
          if (!inlineThemeDisabled) {
            style2.push(cssVarsRef.value);
          }
          return style2;
        });
        const cssVarsRef = vue.computed(() => {
          const {
            common: { cubicBezierEaseInOut, cubicBezierEaseIn, cubicBezierEaseOut },
            self: {
              space,
              spaceArrow,
              padding,
              fontSize,
              textColor,
              dividerColor,
              color,
              boxShadow,
              borderRadius,
              arrowHeight,
              arrowOffset,
              arrowOffsetVertical
            }
          } = themeRef.value;
          return {
            "--n-box-shadow": boxShadow,
            "--n-bezier": cubicBezierEaseInOut,
            "--n-bezier-ease-in": cubicBezierEaseIn,
            "--n-bezier-ease-out": cubicBezierEaseOut,
            "--n-font-size": fontSize,
            "--n-text-color": textColor,
            "--n-color": color,
            "--n-divider-color": dividerColor,
            "--n-border-radius": borderRadius,
            "--n-arrow-height": arrowHeight,
            "--n-arrow-offset": arrowOffset,
            "--n-arrow-offset-vertical": arrowOffsetVertical,
            "--n-padding": padding,
            "--n-space": space,
            "--n-space-arrow": spaceArrow
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("popover", void 0, cssVarsRef, props) : void 0;
        NPopover.setBodyInstance({
          syncPosition
        });
        vue.onBeforeUnmount(() => {
          NPopover.setBodyInstance(null);
        });
        vue.watch(vue.toRef(props, "show"), (value) => {
          if (props.animated)
            return;
          if (value) {
            followerEnabledRef.value = true;
          } else {
            followerEnabledRef.value = false;
          }
        });
        function syncPosition() {
          followerRef.value?.syncPosition();
        }
        function handleMouseEnter(e) {
          if (props.trigger === "hover" && props.keepAliveOnHover && props.show) {
            NPopover.handleMouseEnter(e);
          }
        }
        function handleMouseLeave(e) {
          if (props.trigger === "hover" && props.keepAliveOnHover) {
            NPopover.handleMouseLeave(e);
          }
        }
        function handleMouseMoveOutside(e) {
          if (props.trigger === "hover" && !getTriggerElement().contains(getPreciseEventTarget(e))) {
            NPopover.handleMouseMoveOutside(e);
          }
        }
        function handleClickOutside(e) {
          if (props.trigger === "click" && !getTriggerElement().contains(
            getPreciseEventTarget(e)
          ) || props.onClickoutside) {
            NPopover.handleClickOutside(e);
          }
        }
        function getTriggerElement() {
          return NPopover.getTriggerElement();
        }
        vue.provide(popoverBodyInjectionKey, bodyRef);
        vue.provide(drawerBodyInjectionKey, null);
        vue.provide(modalBodyInjectionKey, null);
        function renderContentNode() {
          themeClassHandle?.onRender();
          const shouldRenderDom = props.displayDirective === "show" || props.show || props.animated && displayedRef.value;
          if (!shouldRenderDom) {
            return null;
          }
          let contentNode;
          const renderBody = NPopover.internalRenderBodyRef.value;
          const { value: mergedClsPrefix } = mergedClsPrefixRef;
          if (!renderBody) {
            const { value: extraClass } = NPopover.extraClassRef;
            const { internalTrapFocus } = props;
            const hasHeaderOrFooter = !isSlotEmpty(slots.header) || !isSlotEmpty(slots.footer);
            const renderContentInnerNode = () => {
              const body = hasHeaderOrFooter ? /* @__PURE__ */ vue.h(vue.Fragment, null, resolveWrappedSlot(slots.header, (children) => {
                return children ? /* @__PURE__ */ vue.h("div", {
                  class: `${mergedClsPrefix}-popover__header`,
                  style: props.headerStyle
                }, children) : null;
              }), resolveWrappedSlot(slots.default, (children) => {
                return children ? /* @__PURE__ */ vue.h("div", {
                  class: `${mergedClsPrefix}-popover__content`,
                  style: props.contentStyle
                }, slots) : null;
              }), resolveWrappedSlot(slots.footer, (children) => {
                return children ? /* @__PURE__ */ vue.h("div", {
                  class: `${mergedClsPrefix}-popover__footer`,
                  style: props.footerStyle
                }, children) : null;
              })) : props.scrollable ? slots.default?.() : /* @__PURE__ */ vue.h("div", {
                class: `${mergedClsPrefix}-popover__content`,
                style: props.contentStyle
              }, slots);
              const maybeScrollableBody = props.scrollable ? /* @__PURE__ */ vue.h(XScrollbar, {
                contentClass: hasHeaderOrFooter ? void 0 : `${mergedClsPrefix}-popover__content`,
                contentStyle: hasHeaderOrFooter ? void 0 : props.contentStyle
              }, {
                default: () => body
              }) : body;
              const arrow = props.showArrow ? renderArrow({
                arrowStyle: props.arrowStyle,
                clsPrefix: mergedClsPrefix
              }) : null;
              return [maybeScrollableBody, arrow];
            };
            contentNode = vue.h(
              "div",
              vue.mergeProps(
                {
                  class: [
                    `${mergedClsPrefix}-popover`,
                    `${mergedClsPrefix}-popover-shared`,
                    themeClassHandle?.themeClass.value,
                    extraClass.map((v) => `${mergedClsPrefix}-${v}`),
                    {
                      [`${mergedClsPrefix}-popover--scrollable`]: props.scrollable,
                      [`${mergedClsPrefix}-popover--show-header-or-footer`]: hasHeaderOrFooter,
                      [`${mergedClsPrefix}-popover--raw`]: props.raw,
                      [`${mergedClsPrefix}-popover-shared--overlap`]: props.overlap,
                      [`${mergedClsPrefix}-popover-shared--show-arrow`]: props.showArrow,
                      [`${mergedClsPrefix}-popover-shared--center-arrow`]: props.arrowPointToCenter
                    }
                  ],
                  ref: bodyRef,
                  style: styleRef.value,
                  onKeydown: NPopover.handleKeydown,
                  onMouseenter: handleMouseEnter,
                  onMouseleave: handleMouseLeave
                },
                attrs
              ),
              internalTrapFocus ? /* @__PURE__ */ vue.h(FocusTrap, {
                active: props.show,
                autoFocus: true
              }, { default: renderContentInnerNode }) : renderContentInnerNode()
            );
          } else {
            contentNode = renderBody(
              [
                `${mergedClsPrefix}-popover-shared`,
                themeClassHandle?.themeClass.value,
                props.overlap && `${mergedClsPrefix}-popover-shared--overlap`,
                props.showArrow && `${mergedClsPrefix}-popover-shared--show-arrow`,
                props.arrowPointToCenter && `${mergedClsPrefix}-popover-shared--center-arrow`
              ],
              bodyRef,
              styleRef.value,
              handleMouseEnter,
              handleMouseLeave
            );
          }
          return vue.withDirectives(contentNode, directivesRef.value);
        }
        return {
          displayed: displayedRef,
          namespace: namespaceRef,
          isMounted: NPopover.isMountedRef,
          zIndex: NPopover.zIndexRef,
          followerRef,
          adjustedTo: useAdjustedTo(props),
          followerEnabled: followerEnabledRef,
          renderContentNode
        };
      },
      render() {
        return /* @__PURE__ */ vue.h(VFollower, {
          ref: "followerRef",
          zIndex: this.zIndex,
          show: this.show,
          enabled: this.followerEnabled,
          to: this.adjustedTo,
          x: this.x,
          y: this.y,
          flip: this.flip,
          placement: this.placement,
          containerClass: this.namespace,
          overlap: this.overlap,
          width: this.width === "trigger" ? "target" : void 0,
          teleportDisabled: this.adjustedTo === useAdjustedTo.tdkey
        }, {
          default: () => {
            return this.animated ? /* @__PURE__ */ vue.h(vue.Transition, {
              name: "popover-transition",
              appear: this.isMounted,
              onEnter: () => {
                this.followerEnabled = true;
              },
              onAfterLeave: () => {
                this.internalOnAfterLeave?.();
                this.followerEnabled = false;
                this.displayed = false;
              }
            }, {
              default: this.renderContentNode
            }) : this.renderContentNode();
          }
        });
      }
    });

    const bodyPropKeys = Object.keys(popoverBodyProps);
    const triggerEventMap = {
      focus: ["onFocus", "onBlur"],
      click: ["onClick"],
      hover: ["onMouseenter", "onMouseleave"],
      manual: [],
      nested: ["onFocus", "onBlur", "onMouseenter", "onMouseleave", "onClick"]
    };
    function appendEvents(vNode, trigger, events) {
      triggerEventMap[trigger].forEach((eventName) => {
        if (!vNode.props)
          vNode.props = {};
        else {
          vNode.props = Object.assign({}, vNode.props);
        }
        const originalHandler = vNode.props[eventName];
        const handler = events[eventName];
        if (!originalHandler)
          vNode.props[eventName] = handler;
        else {
          vNode.props[eventName] = (...args) => {
            originalHandler(...args);
            handler(...args);
          };
        }
      });
    }
    const textVNodeType = vue.createTextVNode("").type;
    const popoverBaseProps = {
      show: {
        type: Boolean,
        default: void 0
      },
      defaultShow: Boolean,
      showArrow: {
        type: Boolean,
        default: true
      },
      trigger: {
        type: String,
        default: "hover"
      },
      delay: {
        type: Number,
        default: 100
      },
      duration: {
        type: Number,
        default: 100
      },
      raw: Boolean,
      placement: {
        type: String,
        default: "top"
      },
      x: Number,
      y: Number,
      arrowPointToCenter: Boolean,
      disabled: Boolean,
      getDisabled: Function,
      displayDirective: {
        type: String,
        default: "if"
      },
      arrowStyle: [String, Object],
      flip: {
        type: Boolean,
        default: true
      },
      animated: {
        type: Boolean,
        default: true
      },
      width: {
        type: [Number, String],
        default: void 0
      },
      overlap: Boolean,
      keepAliveOnHover: {
        type: Boolean,
        default: true
      },
      zIndex: Number,
      to: useAdjustedTo.propTo,
      scrollable: Boolean,
      contentStyle: [Object, String],
      headerStyle: [Object, String],
      footerStyle: [Object, String],
      onClickoutside: Function,
      "onUpdate:show": [Function, Array],
      onUpdateShow: [Function, Array],
      internalDeactivateImmediately: Boolean,
      internalSyncTargetWithParent: Boolean,
      internalInheritedEventHandlers: {
        type: Array,
        default: () => []
      },
      internalTrapFocus: Boolean,
      internalExtraClass: {
        type: Array,
        default: () => []
      },
      onShow: [Function, Array],
      onHide: [Function, Array],
      arrow: {
        type: Boolean,
        default: void 0
      },
      minWidth: Number,
      maxWidth: Number
    };
    const popoverProps = {
      ...useTheme.props,
      ...popoverBaseProps,
      internalOnAfterLeave: Function,
      internalRenderBody: Function
    };
    var NPopover = vue.defineComponent({
      name: "Popover",
      inheritAttrs: false,
      props: popoverProps,
      __popover__: true,
      setup(props) {
        {
          vue.watchEffect(() => {
            if (props.maxWidth !== void 0) {
              warnOnce(
                "popover",
                "`max-width` is deprecated, please use `style` instead."
              );
            }
            if (props.minWidth !== void 0) {
              warnOnce(
                "popover",
                "`min-width` is deprecated, please use `style` instead."
              );
            }
            if (props.arrow !== void 0) {
              warnOnce(
                "popover",
                "`arrow` is deprecated, please use `showArrow` instead."
              );
            }
            if (props.onHide !== void 0) {
              warnOnce(
                "popover",
                "`on-hide` is deprecated, please use `on-update:show` instead."
              );
            }
            if (props.onShow !== void 0) {
              warnOnce(
                "popover",
                "`on-show` is deprecated, please use `on-update:show` instead."
              );
            }
          });
        }
        const isMountedRef = isMounted();
        const binderInstRef = vue.ref(null);
        const controlledShowRef = vue.computed(() => props.show);
        const uncontrolledShowRef = vue.ref(props.defaultShow);
        const mergedShowWithoutDisabledRef = useMergedState(
          controlledShowRef,
          uncontrolledShowRef
        );
        const mergedShowConsideringDisabledPropRef = useMemo(() => {
          if (props.disabled)
            return false;
          return mergedShowWithoutDisabledRef.value;
        });
        const getMergedDisabled = () => {
          if (props.disabled)
            return true;
          const { getDisabled } = props;
          if (getDisabled?.())
            return true;
          return false;
        };
        const getMergedShow = () => {
          if (getMergedDisabled())
            return false;
          return mergedShowWithoutDisabledRef.value;
        };
        const compatibleShowArrowRef = useCompitable(props, ["arrow", "showArrow"]);
        const mergedShowArrowRef = vue.computed(() => {
          if (props.overlap)
            return false;
          return compatibleShowArrowRef.value;
        });
        let bodyInstance = null;
        const showTimerIdRef = vue.ref(null);
        const hideTimerIdRef = vue.ref(null);
        const positionManuallyRef = useMemo(() => {
          return props.x !== void 0 && props.y !== void 0;
        });
        function doUpdateShow(value) {
          const {
            "onUpdate:show": _onUpdateShow,
            onUpdateShow,
            onShow,
            onHide
          } = props;
          uncontrolledShowRef.value = value;
          if (_onUpdateShow) {
            call(_onUpdateShow, value);
          }
          if (onUpdateShow) {
            call(onUpdateShow, value);
          }
          if (value && onShow) {
            call(onShow, true);
          }
          if (value && onHide) {
            call(onHide, false);
          }
        }
        function syncPosition() {
          if (bodyInstance) {
            bodyInstance.syncPosition();
          }
        }
        function clearShowTimer() {
          const { value: showTimerId } = showTimerIdRef;
          if (showTimerId) {
            window.clearTimeout(showTimerId);
            showTimerIdRef.value = null;
          }
        }
        function clearHideTimer() {
          const { value: hideTimerId } = hideTimerIdRef;
          if (hideTimerId) {
            window.clearTimeout(hideTimerId);
            hideTimerIdRef.value = null;
          }
        }
        function handleFocus() {
          const mergedDisabled = getMergedDisabled();
          if (props.trigger === "focus" && !mergedDisabled) {
            if (getMergedShow())
              return;
            doUpdateShow(true);
          }
        }
        function handleBlur() {
          const mergedDisabled = getMergedDisabled();
          if (props.trigger === "focus" && !mergedDisabled) {
            if (!getMergedShow())
              return;
            doUpdateShow(false);
          }
        }
        function handleMouseEnter() {
          const mergedDisabled = getMergedDisabled();
          if (props.trigger === "hover" && !mergedDisabled) {
            clearHideTimer();
            if (showTimerIdRef.value !== null)
              return;
            if (getMergedShow())
              return;
            const delayCallback = () => {
              doUpdateShow(true);
              showTimerIdRef.value = null;
            };
            const { delay } = props;
            if (delay === 0) {
              delayCallback();
            } else {
              showTimerIdRef.value = window.setTimeout(delayCallback, delay);
            }
          }
        }
        function handleMouseLeave() {
          const mergedDisabled = getMergedDisabled();
          if (props.trigger === "hover" && !mergedDisabled) {
            clearShowTimer();
            if (hideTimerIdRef.value !== null)
              return;
            if (!getMergedShow())
              return;
            const delayedCallback = () => {
              doUpdateShow(false);
              hideTimerIdRef.value = null;
            };
            const { duration } = props;
            if (duration === 0) {
              delayedCallback();
            } else {
              hideTimerIdRef.value = window.setTimeout(delayedCallback, duration);
            }
          }
        }
        function handleMouseMoveOutside() {
          handleMouseLeave();
        }
        function handleClickOutside(e) {
          if (!getMergedShow())
            return;
          if (props.trigger === "click") {
            clearShowTimer();
            clearHideTimer();
            doUpdateShow(false);
          }
          props.onClickoutside?.(e);
        }
        function handleClick() {
          if (props.trigger === "click" && !getMergedDisabled()) {
            clearShowTimer();
            clearHideTimer();
            const nextShow = !getMergedShow();
            doUpdateShow(nextShow);
          }
        }
        function handleKeydown(e) {
          if (!props.internalTrapFocus)
            return;
          if (e.key === "Escape") {
            clearShowTimer();
            clearHideTimer();
            doUpdateShow(false);
          }
        }
        function setShow(value) {
          uncontrolledShowRef.value = value;
        }
        function getTriggerElement() {
          return binderInstRef.value?.targetRef;
        }
        function setBodyInstance(value) {
          bodyInstance = value;
        }
        vue.provide("NPopover", {
          getTriggerElement,
          handleKeydown,
          handleMouseEnter,
          handleMouseLeave,
          handleClickOutside,
          handleMouseMoveOutside,
          setBodyInstance,
          positionManuallyRef,
          isMountedRef,
          zIndexRef: vue.toRef(props, "zIndex"),
          extraClassRef: vue.toRef(props, "internalExtraClass"),
          internalRenderBodyRef: vue.toRef(props, "internalRenderBody")
        });
        return {
          binderInstRef,
          positionManually: positionManuallyRef,
          mergedShowConsideringDisabledProp: mergedShowConsideringDisabledPropRef,
          uncontrolledShow: uncontrolledShowRef,
          mergedShowArrow: mergedShowArrowRef,
          getMergedShow,
          setShow,
          handleClick,
          handleMouseEnter,
          handleMouseLeave,
          handleFocus,
          handleBlur,
          syncPosition
        };
      },
      render() {
        const { positionManually, $slots: slots } = this;
        let triggerVNode;
        let popoverInside = false;
        if (!positionManually) {
          if (slots.activator) {
            triggerVNode = getFirstSlotVNode(slots, "activator");
          } else {
            triggerVNode = getFirstSlotVNode(slots, "trigger");
          }
          if (triggerVNode) {
            triggerVNode = vue.cloneVNode(triggerVNode);
            triggerVNode = triggerVNode.type === textVNodeType ? vue.h("span", [triggerVNode]) : triggerVNode;
            const handlers = {
              onClick: this.handleClick,
              onMouseenter: this.handleMouseEnter,
              onMouseleave: this.handleMouseLeave,
              onFocus: this.handleFocus,
              onBlur: this.handleBlur
            };
            if (triggerVNode.type?.__popover__) {
              popoverInside = true;
              if (!triggerVNode.props) {
                triggerVNode.props = {
                  internalSyncTargetWithParent: true,
                  internalInheritedEventHandlers: []
                };
              }
              triggerVNode.props.internalSyncTargetWithParent = true;
              if (!triggerVNode.props.internalInheritedEventHandlers) {
                triggerVNode.props.internalInheritedEventHandlers = [handlers];
              } else {
                triggerVNode.props.internalInheritedEventHandlers = [
                  handlers,
                  ...triggerVNode.props.internalInheritedEventHandlers
                ];
              }
            } else {
              const { internalInheritedEventHandlers } = this;
              const ascendantAndCurrentHandlers = [
                handlers,
                ...internalInheritedEventHandlers
              ];
              const mergedHandlers = {
                onBlur: (e) => {
                  ascendantAndCurrentHandlers.forEach((_handlers) => {
                    _handlers.onBlur(e);
                  });
                },
                onFocus: (e) => {
                  ascendantAndCurrentHandlers.forEach((_handlers) => {
                    _handlers.onFocus(e);
                  });
                },
                onClick: (e) => {
                  ascendantAndCurrentHandlers.forEach((_handlers) => {
                    _handlers.onClick(e);
                  });
                },
                onMouseenter: (e) => {
                  ascendantAndCurrentHandlers.forEach((_handlers) => {
                    _handlers.onMouseenter(e);
                  });
                },
                onMouseleave: (e) => {
                  ascendantAndCurrentHandlers.forEach((_handlers) => {
                    _handlers.onMouseleave(e);
                  });
                }
              };
              appendEvents(
                triggerVNode,
                internalInheritedEventHandlers ? "nested" : positionManually ? "manual" : this.trigger,
                mergedHandlers
              );
            }
          }
        }
        return /* @__PURE__ */ vue.h(VBinder, {
          ref: "binderInstRef",
          syncTarget: !popoverInside,
          syncTargetWithParent: this.internalSyncTargetWithParent
        }, {
          default: () => {
            void this.mergedShowConsideringDisabledProp;
            const mergedShow = this.getMergedShow();
            return [
              this.internalTrapFocus && mergedShow ? vue.withDirectives(
                /* @__PURE__ */ vue.h("div", {
                  style: { position: "fixed", inset: 0 }
                }),
                [
                  [
                    zindexable$1,
                    {
                      enabled: mergedShow,
                      zIndex: this.zIndex
                    }
                  ]
                ]
              ) : null,
              positionManually ? null : vue.h(VTarget, null, {
                default: () => triggerVNode
              }),
              vue.h(
                NPopoverBody,
                keep(this.$props, bodyPropKeys, {
                  ...this.$attrs,
                  showArrow: this.mergedShowArrow,
                  show: mergedShow
                }),
                {
                  default: () => this.$slots.default?.(),
                  header: () => this.$slots.header?.(),
                  footer: () => this.$slots.footer?.()
                }
              )
            ];
          }
        });
      }
    });

    var commonVariables$j = {
      closeIconSizeTiny: "12px",
      closeIconSizeSmall: "12px",
      closeIconSizeMedium: "14px",
      closeIconSizeLarge: "14px",
      closeSizeTiny: "16px",
      closeSizeSmall: "16px",
      closeSizeMedium: "18px",
      closeSizeLarge: "18px",
      padding: "0 7px",
      closeMargin: "0 0 0 4px",
      closeMarginRtl: "0 4px 0 0"
    };

    const tagDark = {
      name: "Tag",
      common: commonDark,

      self(vars) {
        const {
          textColor2,
          primaryColorHover,
          primaryColorPressed,
          primaryColor,
          infoColor,
          successColor,
          warningColor,
          errorColor,
          baseColor,
          borderColor,
          tagColor,
          opacityDisabled,
          closeIconColor,
          closeIconColorHover,
          closeIconColorPressed,
          closeColorHover,
          closeColorPressed,
          borderRadiusSmall: borderRadius,
          fontSizeMini,
          fontSizeTiny,
          fontSizeSmall,
          fontSizeMedium,
          heightMini,
          heightTiny,
          heightSmall,
          heightMedium,
          buttonColor2Hover,
          buttonColor2Pressed,
          fontWeightStrong
        } = vars;
        return { ...commonVariables$j,
          closeBorderRadius: borderRadius,
          heightTiny: heightMini,
          heightSmall: heightTiny,
          heightMedium: heightSmall,
          heightLarge: heightMedium,
          borderRadius,
          opacityDisabled,
          fontSizeTiny: fontSizeMini,
          fontSizeSmall: fontSizeTiny,
          fontSizeMedium: fontSizeSmall,
          fontSizeLarge: fontSizeMedium,
          fontWeightStrong,
          textColorCheckable: textColor2,
          textColorHoverCheckable: textColor2,
          textColorPressedCheckable: textColor2,
          textColorChecked: baseColor,
          colorCheckable: "#0000",
          colorHoverCheckable: buttonColor2Hover,
          colorPressedCheckable: buttonColor2Pressed,
          colorChecked: primaryColor,
          colorCheckedHover: primaryColorHover,
          colorCheckedPressed: primaryColorPressed,
          border: `1px solid ${borderColor}`,
          textColor: textColor2,
          color: tagColor,
          colorBordered: "#0000",
          closeIconColor,
          closeIconColorHover,
          closeIconColorPressed,
          closeColorHover,
          closeColorPressed,
          borderPrimary: `1px solid ${changeColor(primaryColor, {
        alpha: 0.3
      })}`,
          textColorPrimary: primaryColor,
          colorPrimary: changeColor(primaryColor, {
            alpha: 0.16
          }),
          colorBorderedPrimary: "#0000",
          closeIconColorPrimary: scaleColor(primaryColor, {
            lightness: 0.7
          }),
          closeIconColorHoverPrimary: scaleColor(primaryColor, {
            lightness: 0.7
          }),
          closeIconColorPressedPrimary: scaleColor(primaryColor, {
            lightness: 0.7
          }),
          closeColorHoverPrimary: changeColor(primaryColor, {
            alpha: 0.16
          }),
          closeColorPressedPrimary: changeColor(primaryColor, {
            alpha: 0.12
          }),
          borderInfo: `1px solid ${changeColor(infoColor, {
        alpha: 0.3
      })}`,
          textColorInfo: infoColor,
          colorInfo: changeColor(infoColor, {
            alpha: 0.16
          }),
          colorBorderedInfo: "#0000",
          closeIconColorInfo: scaleColor(infoColor, {
            alpha: 0.7
          }),
          closeIconColorHoverInfo: scaleColor(infoColor, {
            alpha: 0.7
          }),
          closeIconColorPressedInfo: scaleColor(infoColor, {
            alpha: 0.7
          }),
          closeColorHoverInfo: changeColor(infoColor, {
            alpha: 0.16
          }),
          closeColorPressedInfo: changeColor(infoColor, {
            alpha: 0.12
          }),
          borderSuccess: `1px solid ${changeColor(successColor, {
        alpha: 0.3
      })}`,
          textColorSuccess: successColor,
          colorSuccess: changeColor(successColor, {
            alpha: 0.16
          }),
          colorBorderedSuccess: "#0000",
          closeIconColorSuccess: scaleColor(successColor, {
            alpha: 0.7
          }),
          closeIconColorHoverSuccess: scaleColor(successColor, {
            alpha: 0.7
          }),
          closeIconColorPressedSuccess: scaleColor(successColor, {
            alpha: 0.7
          }),
          closeColorHoverSuccess: changeColor(successColor, {
            alpha: 0.16
          }),
          closeColorPressedSuccess: changeColor(successColor, {
            alpha: 0.12
          }),
          borderWarning: `1px solid ${changeColor(warningColor, {
        alpha: 0.3
      })}`,
          textColorWarning: warningColor,
          colorWarning: changeColor(warningColor, {
            alpha: 0.16
          }),
          colorBorderedWarning: "#0000",
          closeIconColorWarning: scaleColor(warningColor, {
            alpha: 0.7
          }),
          closeIconColorHoverWarning: scaleColor(warningColor, {
            alpha: 0.7
          }),
          closeIconColorPressedWarning: scaleColor(warningColor, {
            alpha: 0.7
          }),
          closeColorHoverWarning: changeColor(warningColor, {
            alpha: 0.16
          }),
          closeColorPressedWarning: changeColor(warningColor, {
            alpha: 0.11
          }),
          borderError: `1px solid ${changeColor(errorColor, {
        alpha: 0.3
      })}`,
          textColorError: errorColor,
          colorError: changeColor(errorColor, {
            alpha: 0.16
          }),
          colorBorderedError: "#0000",
          closeIconColorError: scaleColor(errorColor, {
            alpha: 0.7
          }),
          closeIconColorHoverError: scaleColor(errorColor, {
            alpha: 0.7
          }),
          closeIconColorPressedError: scaleColor(errorColor, {
            alpha: 0.7
          }),
          closeColorHoverError: changeColor(errorColor, {
            alpha: 0.16
          }),
          closeColorPressedError: changeColor(errorColor, {
            alpha: 0.12
          })
        };
      }

    };
    var tagDark$1 = tagDark;

    const self$17 = vars => {
      const {
        textColor2,
        primaryColorHover,
        primaryColorPressed,
        primaryColor,
        infoColor,
        successColor,
        warningColor,
        errorColor,
        baseColor,
        borderColor,
        opacityDisabled,
        tagColor,
        closeIconColor,
        closeIconColorHover,
        closeIconColorPressed,
        borderRadiusSmall: borderRadius,
        fontSizeMini,
        fontSizeTiny,
        fontSizeSmall,
        fontSizeMedium,
        heightMini,
        heightTiny,
        heightSmall,
        heightMedium,
        closeColorHover,
        closeColorPressed,
        buttonColor2Hover,
        buttonColor2Pressed,
        fontWeightStrong
      } = vars;
      return { ...commonVariables$j,
        closeBorderRadius: borderRadius,
        heightTiny: heightMini,
        heightSmall: heightTiny,
        heightMedium: heightSmall,
        heightLarge: heightMedium,
        borderRadius,
        opacityDisabled,
        fontSizeTiny: fontSizeMini,
        fontSizeSmall: fontSizeTiny,
        fontSizeMedium: fontSizeSmall,
        fontSizeLarge: fontSizeMedium,
        fontWeightStrong,
        textColorCheckable: textColor2,
        textColorHoverCheckable: textColor2,
        textColorPressedCheckable: textColor2,
        textColorChecked: baseColor,
        colorCheckable: "#0000",
        colorHoverCheckable: buttonColor2Hover,
        colorPressedCheckable: buttonColor2Pressed,
        colorChecked: primaryColor,
        colorCheckedHover: primaryColorHover,
        colorCheckedPressed: primaryColorPressed,
        border: `1px solid ${borderColor}`,
        textColor: textColor2,
        color: tagColor,
        colorBordered: "rgb(250, 250, 252)",
        closeIconColor,
        closeIconColorHover,
        closeIconColorPressed,
        closeColorHover,
        closeColorPressed,
        borderPrimary: `1px solid ${changeColor(primaryColor, {
      alpha: 0.3
    })}`,
        textColorPrimary: primaryColor,
        colorPrimary: changeColor(primaryColor, {
          alpha: 0.12
        }),
        colorBorderedPrimary: changeColor(primaryColor, {
          alpha: 0.1
        }),
        closeIconColorPrimary: primaryColor,
        closeIconColorHoverPrimary: primaryColor,
        closeIconColorPressedPrimary: primaryColor,
        closeColorHoverPrimary: changeColor(primaryColor, {
          alpha: 0.12
        }),
        closeColorPressedPrimary: changeColor(primaryColor, {
          alpha: 0.18
        }),
        borderInfo: `1px solid ${changeColor(infoColor, {
      alpha: 0.3
    })}`,
        textColorInfo: infoColor,
        colorInfo: changeColor(infoColor, {
          alpha: 0.12
        }),
        colorBorderedInfo: changeColor(infoColor, {
          alpha: 0.1
        }),
        closeIconColorInfo: infoColor,
        closeIconColorHoverInfo: infoColor,
        closeIconColorPressedInfo: infoColor,
        closeColorHoverInfo: changeColor(infoColor, {
          alpha: 0.12
        }),
        closeColorPressedInfo: changeColor(infoColor, {
          alpha: 0.18
        }),
        borderSuccess: `1px solid ${changeColor(successColor, {
      alpha: 0.3
    })}`,
        textColorSuccess: successColor,
        colorSuccess: changeColor(successColor, {
          alpha: 0.12
        }),
        colorBorderedSuccess: changeColor(successColor, {
          alpha: 0.1
        }),
        closeIconColorSuccess: successColor,
        closeIconColorHoverSuccess: successColor,
        closeIconColorPressedSuccess: successColor,
        closeColorHoverSuccess: changeColor(successColor, {
          alpha: 0.12
        }),
        closeColorPressedSuccess: changeColor(successColor, {
          alpha: 0.18
        }),
        borderWarning: `1px solid ${changeColor(warningColor, {
      alpha: 0.35
    })}`,
        textColorWarning: warningColor,
        colorWarning: changeColor(warningColor, {
          alpha: 0.15
        }),
        colorBorderedWarning: changeColor(warningColor, {
          alpha: 0.12
        }),
        closeIconColorWarning: warningColor,
        closeIconColorHoverWarning: warningColor,
        closeIconColorPressedWarning: warningColor,
        closeColorHoverWarning: changeColor(warningColor, {
          alpha: 0.12
        }),
        closeColorPressedWarning: changeColor(warningColor, {
          alpha: 0.18
        }),
        borderError: `1px solid ${changeColor(errorColor, {
      alpha: 0.23
    })}`,
        textColorError: errorColor,
        colorError: changeColor(errorColor, {
          alpha: 0.1
        }),
        colorBorderedError: changeColor(errorColor, {
          alpha: 0.08
        }),
        closeIconColorError: errorColor,
        closeIconColorHoverError: errorColor,
        closeIconColorPressedError: errorColor,
        closeColorHoverError: changeColor(errorColor, {
          alpha: 0.12
        }),
        closeColorPressedError: changeColor(errorColor, {
          alpha: 0.18
        })
      };
    };

    const tagLight = {
      name: "Tag",
      common: commonLight,
      self: self$17
    };
    var tagLight$1 = tagLight;

    var rtlStyle$q = cB("tag", [cM("rtl", `
    direction: rtl;
  `, [cE("close", `
      margin: var(--n-close-margin-rtl);
    `), cE("icon", `
      margin: 0 0 0 4px;
    `), cE("avatar", `
      margin: 0 0 0 6px;
    `), cM("round", [cE("icon", `
        margin: 0 calc((var(--n-height) - 8px) / -2) 0 4px;
      `), cE("avatar", `
        margin: 0 calc((var(--n-height) - 8px) / -2) 0 6px;
      `), cM("closable", `
        padding: 0 calc(var(--n-height) / 3) 0 calc(var(--n-height) / 4);
      `)]), cM("icon, avatar", [cM("round", `
        padding: 0 calc(var(--n-height) / 2) 0 calc(var(--n-height) / 3);
      `)])])]);

    const tagRtl = {
      name: "Tag",
      style: rtlStyle$q
    };

    var commonProps = {
      color: Object,
      type: {
        type: String,
        default: "default"
      },
      round: Boolean,
      size: {
        type: String,
        default: "medium"
      },
      closable: Boolean,
      disabled: {
        type: Boolean,
        default: void 0
      }
    };

    var style$1p = cB("tag", `
  white-space: nowrap;
  position: relative;
  box-sizing: border-box;
  cursor: default;
  display: inline-flex;
  align-items: center;
  flex-wrap: nowrap;
  padding: var(--n-padding);
  border-radius: var(--n-border-radius);
  color: var(--n-text-color);
  background-color: var(--n-color);
  transition:
    border-color .3s var(--n-bezier),
    background-color .3s var(--n-bezier),
    color .3s var(--n-bezier),
    box-shadow .3s var(--n-bezier),
    opacity .3s var(--n-bezier);
  line-height: 1;
  height: var(--n-height);
  font-size: var(--n-font-size);
`, [cM("strong", `
    font-weight: var(--n-font-weight-strong);
  `), cE("border", `
    pointer-events: none;
    position: absolute;
    left: 0;
    right: 0;
    top: 0;
    bottom: 0;
    border-radius: inherit;
    border: var(--n-border);
    transition: border-color .3s var(--n-bezier);
  `), cE("icon", `
    display: flex;
    margin: 0 4px 0 0;
    color: var(--n-text-color);
    transition: color .3s var(--n-bezier);
    font-size: var(--n-avatar-size-override);
  `), cE("avatar", `
    display: flex;
    margin: 0 6px 0 0;
  `), cE("close", `
    margin: var(--n-close-margin);
    transition:
      background-color .3s var(--n-bezier),
      color .3s var(--n-bezier);
  `), cM("round", `
    padding: 0 calc(var(--n-height) / 3);
    border-radius: calc(var(--n-height) / 2);
  `, [cE("icon", `
      margin: 0 4px 0 calc((var(--n-height) - 8px) / -2);
    `), cE("avatar", `
      margin: 0 6px 0 calc((var(--n-height) - 8px) / -2);
    `), cM("closable", `
      padding: 0 calc(var(--n-height) / 4) 0 calc(var(--n-height) / 3);
    `)]), cM("icon, avatar", [cM("round", `
      padding: 0 calc(var(--n-height) / 3) 0 calc(var(--n-height) / 2);
    `)]), cM("disabled", `
    cursor: not-allowed !important;
    opacity: var(--n-opacity-disabled);
  `), cM("checkable", `
    cursor: pointer;
    box-shadow: none;
    color: var(--n-text-color-checkable);
    background-color: var(--n-color-checkable);
  `, [cNotM("disabled", [c$1("&:hover", "background-color: var(--n-color-hover-checkable);", [cNotM("checked", "color: var(--n-text-color-hover-checkable);")]), c$1("&:active", "background-color: var(--n-color-pressed-checkable);", [cNotM("checked", "color: var(--n-text-color-pressed-checkable);")])]), cM("checked", `
      color: var(--n-text-color-checked);
      background-color: var(--n-color-checked);
    `, [cNotM("disabled", [c$1("&:hover", "background-color: var(--n-color-checked-hover);"), c$1("&:active", "background-color: var(--n-color-checked-pressed);")])])])]);

    const tagProps = {
      ...useTheme.props,
      ...commonProps,
      bordered: {
        type: Boolean,
        default: void 0
      },
      checked: Boolean,
      checkable: Boolean,
      strong: Boolean,
      triggerClickOnClose: Boolean,
      onClose: [Array, Function],
      onMouseenter: Function,
      onMouseleave: Function,
      "onUpdate:checked": Function,
      onUpdateChecked: Function,
      internalCloseFocusable: {
        type: Boolean,
        default: true
      },
      onCheckedChange: {
        type: Function,
        validator: () => {
          {
            warn$2(
              "tag",
              "`on-checked-change` is deprecated, please use `on-update:checked` instead"
            );
          }
          return true;
        },
        default: void 0
      }
    };
    const tagInjectionKey = createInjectionKey("n-tag");
    var NTag = vue.defineComponent({
      name: "Tag",
      props: tagProps,
      setup(props) {
        const contentRef = vue.ref(null);
        const {
          mergedBorderedRef,
          mergedClsPrefixRef,
          inlineThemeDisabled,
          mergedRtlRef
        } = useConfig(props);
        const themeRef = useTheme(
          "Tag",
          "-tag",
          style$1p,
          tagLight$1,
          props,
          mergedClsPrefixRef
        );
        vue.provide(tagInjectionKey, {
          roundRef: vue.toRef(props, "round")
        });
        function handleClick(e) {
          if (!props.disabled) {
            if (props.checkable) {
              const {
                checked,
                onCheckedChange,
                onUpdateChecked,
                "onUpdate:checked": _onUpdateChecked
              } = props;
              if (onUpdateChecked)
                onUpdateChecked(!checked);
              if (_onUpdateChecked)
                _onUpdateChecked(!checked);
              if (onCheckedChange)
                onCheckedChange(!checked);
            }
          }
        }
        function handleCloseClick(e) {
          if (!props.triggerClickOnClose) {
            e.stopPropagation();
          }
          if (!props.disabled) {
            const { onClose } = props;
            if (onClose)
              call(onClose, e);
          }
        }
        const tagPublicMethods = {
          setTextContent(textContent) {
            const { value } = contentRef;
            if (value)
              value.textContent = textContent;
          }
        };
        const rtlEnabledRef = useRtl("Tag", mergedRtlRef, mergedClsPrefixRef);
        const cssVarsRef = vue.computed(() => {
          const { type, size, color: { color, textColor } = {} } = props;
          const {
            common: { cubicBezierEaseInOut },
            self: {
              padding,
              closeMargin,
              closeMarginRtl,
              borderRadius,
              opacityDisabled,
              textColorCheckable,
              textColorHoverCheckable,
              textColorPressedCheckable,
              textColorChecked,
              colorCheckable,
              colorHoverCheckable,
              colorPressedCheckable,
              colorChecked,
              colorCheckedHover,
              colorCheckedPressed,
              closeBorderRadius,
              fontWeightStrong,
              [createKey("colorBordered", type)]: colorBordered,
              [createKey("closeSize", size)]: closeSize,
              [createKey("closeIconSize", size)]: closeIconSize,
              [createKey("fontSize", size)]: fontSize,
              [createKey("height", size)]: height,
              [createKey("color", type)]: typedColor,
              [createKey("textColor", type)]: typeTextColor,
              [createKey("border", type)]: border,
              [createKey("closeIconColor", type)]: closeIconColor,
              [createKey("closeIconColorHover", type)]: closeIconColorHover,
              [createKey("closeIconColorPressed", type)]: closeIconColorPressed,
              [createKey("closeColorHover", type)]: closeColorHover,
              [createKey("closeColorPressed", type)]: closeColorPressed
            }
          } = themeRef.value;
          return {
            "--n-font-weight-strong": fontWeightStrong,
            "--n-avatar-size-override": `calc(${height} - 8px)`,
            "--n-bezier": cubicBezierEaseInOut,
            "--n-border-radius": borderRadius,
            "--n-border": border,
            "--n-close-icon-size": closeIconSize,
            "--n-close-color-pressed": closeColorPressed,
            "--n-close-color-hover": closeColorHover,
            "--n-close-border-radius": closeBorderRadius,
            "--n-close-icon-color": closeIconColor,
            "--n-close-icon-color-hover": closeIconColorHover,
            "--n-close-icon-color-pressed": closeIconColorPressed,
            "--n-close-icon-color-disabled": closeIconColor,
            "--n-close-margin": closeMargin,
            "--n-close-margin-rtl": closeMarginRtl,
            "--n-close-size": closeSize,
            "--n-color": color || (mergedBorderedRef.value ? colorBordered : typedColor),
            "--n-color-checkable": colorCheckable,
            "--n-color-checked": colorChecked,
            "--n-color-checked-hover": colorCheckedHover,
            "--n-color-checked-pressed": colorCheckedPressed,
            "--n-color-hover-checkable": colorHoverCheckable,
            "--n-color-pressed-checkable": colorPressedCheckable,
            "--n-font-size": fontSize,
            "--n-height": height,
            "--n-opacity-disabled": opacityDisabled,
            "--n-padding": padding,
            "--n-text-color": textColor || typeTextColor,
            "--n-text-color-checkable": textColorCheckable,
            "--n-text-color-checked": textColorChecked,
            "--n-text-color-hover-checkable": textColorHoverCheckable,
            "--n-text-color-pressed-checkable": textColorPressedCheckable
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass(
          "tag",
          vue.computed(() => {
            let hash = "";
            const { type, size, color: { color, textColor } = {} } = props;
            hash += type[0];
            hash += size[0];
            if (color) {
              hash += `a${color2Class(color)}`;
            }
            if (textColor) {
              hash += `b${color2Class(textColor)}`;
            }
            if (mergedBorderedRef.value) {
              hash += "c";
            }
            return hash;
          }),
          cssVarsRef,
          props
        ) : void 0;
        return {
          ...tagPublicMethods,
          rtlEnabled: rtlEnabledRef,
          mergedClsPrefix: mergedClsPrefixRef,
          contentRef,
          mergedBordered: mergedBorderedRef,
          handleClick,
          handleCloseClick,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender
        };
      },
      render() {
        const {
          mergedClsPrefix,
          rtlEnabled,
          closable,
          color: { borderColor } = {},
          round,
          onRender,
          $slots
        } = this;
        onRender?.();
        const avatarNode = resolveWrappedSlot(
          $slots.avatar,
          (children) => children && /* @__PURE__ */ vue.h("div", {
            class: `${mergedClsPrefix}-tag__avatar`
          }, children)
        );
        const iconNode = resolveWrappedSlot(
          $slots.icon,
          (children) => children && /* @__PURE__ */ vue.h("div", {
            class: `${mergedClsPrefix}-tag__icon`
          }, children)
        );
        return /* @__PURE__ */ vue.h("div", {
          class: [
            `${mergedClsPrefix}-tag`,
            this.themeClass,
            {
              [`${mergedClsPrefix}-tag--rtl`]: rtlEnabled,
              [`${mergedClsPrefix}-tag--strong`]: this.strong,
              [`${mergedClsPrefix}-tag--disabled`]: this.disabled,
              [`${mergedClsPrefix}-tag--checkable`]: this.checkable,
              [`${mergedClsPrefix}-tag--checked`]: this.checkable && this.checked,
              [`${mergedClsPrefix}-tag--round`]: round,
              [`${mergedClsPrefix}-tag--avatar`]: avatarNode,
              [`${mergedClsPrefix}-tag--icon`]: iconNode,
              [`${mergedClsPrefix}-tag--closable`]: closable
            }
          ],
          style: this.cssVars,
          onClick: this.handleClick,
          onMouseenter: this.onMouseenter,
          onMouseleave: this.onMouseleave
        }, iconNode || avatarNode, /* @__PURE__ */ vue.h("span", {
          class: `${mergedClsPrefix}-tag__content`,
          ref: "contentRef"
        }, this.$slots.default?.()), !this.checkable && closable ? /* @__PURE__ */ vue.h(NBaseClose, {
          clsPrefix: mergedClsPrefix,
          class: `${mergedClsPrefix}-tag__close`,
          disabled: this.disabled,
          onClick: this.handleCloseClick,
          focusable: this.internalCloseFocusable,
          round,
          absolute: true
        }) : null, !this.checkable && this.mergedBordered ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-tag__border`,
          style: { borderColor }
        }) : null);
      }
    });

    var style$1o = cB("base-clear", `
  flex-shrink: 0;
  height: 1em;
  width: 1em;
  position: relative;
`, [c$1(">", [cE("clear", `
      font-size: var(--n-clear-size);
      height: 1em;
      width: 1em;
      cursor: pointer;
      color: var(--n-clear-color);
      transition: color .3s var(--n-bezier);
      display: flex;
    `, [c$1("&:hover", `
        color: var(--n-clear-color-hover)!important;
      `), c$1("&:active", `
        color: var(--n-clear-color-pressed)!important;
      `)]), cE("placeholder", `
      display: flex;
    `), cE("clear, placeholder", `
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translateX(-50%) translateY(-50%);
    `, [iconSwitchTransition({
      originalTransform: "translateX(-50%) translateY(-50%)",
      left: "50%",
      top: "50%"
    })])])]);

    var NBaseClear = vue.defineComponent({
      name: "BaseClear",
      props: {
        clsPrefix: {
          type: String,
          required: true
        },
        show: Boolean,
        onClear: Function
      },
      setup(props) {
        useStyle("-base-clear", style$1o, vue.toRef(props, "clsPrefix"));
        return {
          handleMouseDown(e) {
            e.preventDefault();
          }
        };
      },
      render() {
        const { clsPrefix } = this;
        return /* @__PURE__ */ vue.h("div", {
          class: `${clsPrefix}-base-clear`
        }, /* @__PURE__ */ vue.h(NIconSwitchTransition, null, {
          default: () => {
            return this.show ? /* @__PURE__ */ vue.h("div", {
              key: "dismiss",
              class: `${clsPrefix}-base-clear__clear`,
              onClick: this.onClear,
              onMousedown: this.handleMouseDown,
              "data-clear": true
            }, resolveSlot(this.$slots.icon, () => [
              /* @__PURE__ */ vue.h(NBaseIcon, {
                clsPrefix
              }, {
                default: () => /* @__PURE__ */ vue.h(ClearIcon, null)
              })
            ])) : /* @__PURE__ */ vue.h("div", {
              key: "icon",
              class: `${clsPrefix}-base-clear__placeholder`
            }, this.$slots.placeholder?.());
          }
        }));
      }
    });

    var NBaseSuffix = vue.defineComponent({
      name: "InternalSelectionSuffix",
      props: {
        clsPrefix: {
          type: String,
          required: true
        },
        showArrow: {
          type: Boolean,
          default: void 0
        },
        showClear: {
          type: Boolean,
          default: void 0
        },
        loading: {
          type: Boolean,
          default: false
        },
        onClear: Function
      },
      setup(props, { slots }) {
        return () => {
          const { clsPrefix } = props;
          return /* @__PURE__ */ vue.h(NBaseLoading, {
            clsPrefix,
            class: `${clsPrefix}-base-suffix`,
            strokeWidth: 24,
            scale: 0.85,
            show: props.loading
          }, {
            default: () => props.showArrow ? /* @__PURE__ */ vue.h(NBaseClear, {
              clsPrefix,
              show: props.showClear,
              onClear: props.onClear
            }, {
              placeholder: () => /* @__PURE__ */ vue.h(NBaseIcon, {
                clsPrefix,
                class: `${clsPrefix}-base-suffix__arrow`
              }, {
                default: () => resolveSlot(slots.default, () => [
                  /* @__PURE__ */ vue.h(ChevronDownIcon, null)
                ])
              })
            }) : null
          });
        };
      }
    });

    var commonVars$b = {
      paddingSingle: "0 26px 0 12px",
      paddingMultiple: "3px 26px 0 12px",
      clearSize: "16px",
      arrowSize: "16px"
    };

    const self$16 = vars => {
      const {
        borderRadius,
        textColor2,
        textColorDisabled,
        inputColor,
        inputColorDisabled,
        primaryColor,
        primaryColorHover,
        warningColor,
        warningColorHover,
        errorColor,
        errorColorHover,
        borderColor,
        iconColor,
        iconColorDisabled,
        clearColor,
        clearColorHover,
        clearColorPressed,
        placeholderColor,
        placeholderColorDisabled,
        fontSizeTiny,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        heightTiny,
        heightSmall,
        heightMedium,
        heightLarge
      } = vars;
      return { ...commonVars$b,
        fontSizeTiny,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        heightTiny,
        heightSmall,
        heightMedium,
        heightLarge,
        borderRadius,
        textColor: textColor2,
        textColorDisabled,
        placeholderColor,
        placeholderColorDisabled,
        color: inputColor,
        colorDisabled: inputColorDisabled,
        colorActive: inputColor,
        border: `1px solid ${borderColor}`,
        borderHover: `1px solid ${primaryColorHover}`,
        borderActive: `1px solid ${primaryColor}`,
        borderFocus: `1px solid ${primaryColorHover}`,
        boxShadowHover: "none",
        boxShadowActive: `0 0 0 2px ${changeColor(primaryColor, {
      alpha: 0.2
    })}`,
        boxShadowFocus: `0 0 0 2px ${changeColor(primaryColor, {
      alpha: 0.2
    })}`,
        caretColor: primaryColor,
        arrowColor: iconColor,
        arrowColorDisabled: iconColorDisabled,
        loadingColor: primaryColor,
        borderWarning: `1px solid ${warningColor}`,
        borderHoverWarning: `1px solid ${warningColorHover}`,
        borderActiveWarning: `1px solid ${warningColor}`,
        borderFocusWarning: `1px solid ${warningColorHover}`,
        boxShadowHoverWarning: "none",
        boxShadowActiveWarning: `0 0 0 2px ${changeColor(warningColor, {
      alpha: 0.2
    })}`,
        boxShadowFocusWarning: `0 0 0 2px ${changeColor(warningColor, {
      alpha: 0.2
    })}`,
        colorActiveWarning: inputColor,
        caretColorWarning: warningColor,
        borderError: `1px solid ${errorColor}`,
        borderHoverError: `1px solid ${errorColorHover}`,
        borderActiveError: `1px solid ${errorColor}`,
        borderFocusError: `1px solid ${errorColorHover}`,
        boxShadowHoverError: "none",
        boxShadowActiveError: `0 0 0 2px ${changeColor(errorColor, {
      alpha: 0.2
    })}`,
        boxShadowFocusError: `0 0 0 2px ${changeColor(errorColor, {
      alpha: 0.2
    })}`,
        colorActiveError: inputColor,
        caretColorError: errorColor,
        clearColor,
        clearColorHover,
        clearColorPressed
      };
    };

    const internalSelectionLight = createTheme$1({
      name: "InternalSelection",
      common: commonLight,
      peers: {
        Popover: popoverLight$1
      },
      self: self$16
    });
    var internalSelectionLight$1 = internalSelectionLight;

    const internalSelectionDark = {
      name: "InternalSelection",
      common: commonDark,
      peers: {
        Popover: popoverDark$1
      },

      self(vars) {
        const {
          borderRadius,
          textColor2,
          textColorDisabled,
          inputColor,
          inputColorDisabled,
          primaryColor,
          primaryColorHover,
          warningColor,
          warningColorHover,
          errorColor,
          errorColorHover,
          iconColor,
          iconColorDisabled,
          clearColor,
          clearColorHover,
          clearColorPressed,
          placeholderColor,
          placeholderColorDisabled,
          fontSizeTiny,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          heightTiny,
          heightSmall,
          heightMedium,
          heightLarge
        } = vars;
        return { ...commonVars$b,
          fontSizeTiny,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          heightTiny,
          heightSmall,
          heightMedium,
          heightLarge,
          borderRadius,
          textColor: textColor2,
          textColorDisabled,
          placeholderColor,
          placeholderColorDisabled,
          color: inputColor,
          colorDisabled: inputColorDisabled,
          colorActive: changeColor(primaryColor, {
            alpha: 0.1
          }),
          border: "1px solid #0000",
          borderHover: `1px solid ${primaryColorHover}`,
          borderActive: `1px solid ${primaryColor}`,
          borderFocus: `1px solid ${primaryColorHover}`,
          boxShadowHover: "none",
          boxShadowActive: `0 0 8px 0 ${changeColor(primaryColor, {
        alpha: 0.4
      })}`,
          boxShadowFocus: `0 0 8px 0 ${changeColor(primaryColor, {
        alpha: 0.4
      })}`,
          caretColor: primaryColor,
          arrowColor: iconColor,
          arrowColorDisabled: iconColorDisabled,
          loadingColor: primaryColor,
          borderWarning: `1px solid ${warningColor}`,
          borderHoverWarning: `1px solid ${warningColorHover}`,
          borderActiveWarning: `1px solid ${warningColor}`,
          borderFocusWarning: `1px solid ${warningColorHover}`,
          boxShadowHoverWarning: "none",
          boxShadowActiveWarning: `0 0 8px 0 ${changeColor(warningColor, {
        alpha: 0.4
      })}`,
          boxShadowFocusWarning: `0 0 8px 0 ${changeColor(warningColor, {
        alpha: 0.4
      })}`,
          colorActiveWarning: changeColor(warningColor, {
            alpha: 0.1
          }),
          caretColorWarning: warningColor,
          borderError: `1px solid ${errorColor}`,
          borderHoverError: `1px solid ${errorColorHover}`,
          borderActiveError: `1px solid ${errorColor}`,
          borderFocusError: `1px solid ${errorColorHover}`,
          boxShadowHoverError: "none",
          boxShadowActiveError: `0 0 8px 0 ${changeColor(errorColor, {
        alpha: 0.4
      })}`,
          boxShadowFocusError: `0 0 8px 0 ${changeColor(errorColor, {
        alpha: 0.4
      })}`,
          colorActiveError: changeColor(errorColor, {
            alpha: 0.1
          }),
          caretColorError: errorColor,
          clearColor,
          clearColorHover,
          clearColorPressed
        };
      }

    };
    var internalSelectionDark$1 = internalSelectionDark;

    var style$1n = c$1([cB("base-selection", `
    position: relative;
    z-index: auto;
    box-shadow: none;
    width: 100%;
    max-width: 100%;
    display: inline-block;
    vertical-align: bottom;
    border-radius: var(--n-border-radius);
    min-height: var(--n-height);
    line-height: 1.5;
    font-size: var(--n-font-size);
  `, [cB("base-loading", `
      color: var(--n-loading-color);
    `), cB("base-selection-tags", "min-height: var(--n-height);"), cE("border, state-border", `
      position: absolute;
      left: 0;
      right: 0;
      top: 0;
      bottom: 0;
      pointer-events: none;
      border: var(--n-border);
      border-radius: inherit;
      transition:
        box-shadow .3s var(--n-bezier),
        border-color .3s var(--n-bezier);
    `), cE("state-border", `
      z-index: 1;
      border-color: #0000;
    `), cB("base-suffix", `
      cursor: pointer;
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      right: 10px;
    `, [cE("arrow", `
        font-size: var(--n-arrow-size);
        color: var(--n-arrow-color);
        transition: color .3s var(--n-bezier);
      `)]), cB("base-selection-overlay", `
      display: flex;
      align-items: center;
      white-space: nowrap;
      pointer-events: none;
      position: absolute;
      top: 0;
      right: 0;
      bottom: 0;
      left: 0;
      padding: var(--n-padding-single);
      transition: color .3s var(--n-bezier);
    `, [cE("wrapper", `
        flex-basis: 0;
        flex-grow: 1;
        overflow: hidden;
        text-overflow: ellipsis;
      `)]), cB("base-selection-placeholder", `
      color: var(--n-placeholder-color);
    `, [cE("inner", `
        max-width: 100%;
        overflow: hidden;
      `)]), cB("base-selection-tags", `
      cursor: pointer;
      outline: none;
      box-sizing: border-box;
      position: relative;
      z-index: auto;
      display: flex;
      padding: var(--n-padding-multiple);
      flex-wrap: wrap;
      align-items: center;
      width: 100%;
      vertical-align: bottom;
      background-color: var(--n-color);
      border-radius: inherit;
      transition:
        color .3s var(--n-bezier),
        box-shadow .3s var(--n-bezier),
        background-color .3s var(--n-bezier);
    `), cB("base-selection-label", `
      height: var(--n-height);
      display: inline-flex;
      width: 100%;
      vertical-align: bottom;
      cursor: pointer;
      outline: none;
      z-index: auto;
      box-sizing: border-box;
      position: relative;
      transition:
      color .3s var(--n-bezier),
      box-shadow .3s var(--n-bezier),
      background-color .3s var(--n-bezier);
      border-radius: inherit;
      background-color: var(--n-color);
      align-items: center;
    `, [cB("base-selection-input", `
        font-size: inherit;
        line-height: inherit;
        outline: none;
        cursor: pointer;
        box-sizing: border-box;
        border:none;
        width: 100%;
        padding: var(--n-padding-single);
        background-color: #0000;
        color: var(--n-text-color);
        transition: color .3s var(--n-bezier);
        caret-color: var(--n-caret-color);
      `, [cE("content", `
          text-overflow: ellipsis;
          overflow: hidden;
          white-space: nowrap;
        `)]), cE("render-label", `
        color: var(--n-text-color);
      `)]), cNotM("disabled", [c$1("&:hover", [cE("state-border", `
          box-shadow: var(--n-box-shadow-hover);
          border: var(--n-border-hover);
        `)]), cM("focus", [cE("state-border", `
          box-shadow: var(--n-box-shadow-focus);
          border: var(--n-border-focus);
        `)]), cM("active", [cE("state-border", `
          box-shadow: var(--n-box-shadow-active);
          border: var(--n-border-active);
        `), cB("base-selection-label", "background-color: var(--n-color-active);"), cB("base-selection-tags", "background-color: var(--n-color-active);")])]), cM("disabled", "cursor: not-allowed;", [cE("arrow", `
        color: var(--n-arrow-color-disabled);
      `), cB("base-selection-label", `
        cursor: not-allowed;
        background-color: var(--n-color-disabled);
      `, [cB("base-selection-input", `
          cursor: not-allowed;
          color: var(--n-text-color-disabled);
        `), cE("render-label", `
          color: var(--n-text-color-disabled);
        `)]), cB("base-selection-tags", `
        cursor: not-allowed;
        background-color: var(--n-color-disabled);
      `), cB("base-selection-placeholder", `
        cursor: not-allowed;
        color: var(--n-placeholder-color-disabled);
      `)]), cB("base-selection-input-tag", `
      height: calc(var(--n-height) - 6px);
      line-height: calc(var(--n-height) - 6px);
      outline: none;
      display: none;
      position: relative;
      margin-bottom: 3px;
      max-width: 100%;
      vertical-align: bottom;
    `, [cE("input", `
        font-size: inherit;
        font-family: inherit;
        min-width: 1px;
        padding: 0;
        background-color: #0000;
        outline: none;
        border: none;
        max-width: 100%;
        overflow: hidden;
        width: 1em;
        line-height: inherit;
        cursor: pointer;
        color: var(--n-text-color);
        caret-color: var(--n-caret-color);
      `), cE("mirror", `
        position: absolute;
        left: 0;
        top: 0;
        white-space: pre;
        visibility: hidden;
        user-select: none;
        -webkit-user-select: none;
        opacity: 0;
      `)]), ["warning", "error"].map(status => cM(`${status}-status`, [cE("state-border", `border: var(--n-border-${status});`), cNotM("disabled", [c$1("&:hover", [cE("state-border", `
            box-shadow: var(--n-box-shadow-hover-${status});
            border: var(--n-border-hover-${status});
          `)]), cM("active", [cE("state-border", `
            box-shadow: var(--n-box-shadow-active-${status});
            border: var(--n-border-active-${status});
          `), cB("base-selection-label", `background-color: var(--n-color-active-${status});`), cB("base-selection-tags", `background-color: var(--n-color-active-${status});`)]), cM("focus", [cE("state-border", `
            box-shadow: var(--n-box-shadow-focus-${status});
            border: var(--n-border-focus-${status});
          `)])])]))]), cB("base-selection-popover", `
    margin-bottom: -3px;
    display: flex;
    flex-wrap: wrap;
    margin-right: -8px;
  `), cB("base-selection-tag-wrapper", `
    max-width: 100%;
    display: inline-flex;
    padding: 0 7px 3px 0;
  `, [c$1("&:last-child", "padding-right: 0;"), cB("tag", `
      font-size: 14px;
      max-width: 100%;
    `, [cE("content", `
        line-height: 1.25;
        text-overflow: ellipsis;
          overflow: hidden;
      `)])])]);

    var NInternalSelection = vue.defineComponent({
      name: "InternalSelection",
      props: {
        ...useTheme.props,
        clsPrefix: {
          type: String,
          required: true
        },
        bordered: {
          type: Boolean,
          default: void 0
        },
        active: Boolean,
        pattern: {
          type: String,
          default: ""
        },
        placeholder: String,
        selectedOption: {
          type: Object,
          default: null
        },
        selectedOptions: {
          type: Array,
          default: null
        },
        labelField: { type: String, default: "label" },
        valueField: {
          type: String,
          default: "value"
        },
        multiple: Boolean,
        filterable: Boolean,
        clearable: Boolean,
        disabled: Boolean,
        size: {
          type: String,
          default: "medium"
        },
        loading: Boolean,
        autofocus: Boolean,
        showArrow: {
          type: Boolean,
          default: true
        },
        inputProps: Object,
        focused: Boolean,
        renderTag: Function,
        onKeydown: Function,
        onClick: Function,
        onBlur: Function,
        onFocus: Function,
        onDeleteOption: Function,
        maxTagCount: [String, Number],
        onClear: Function,
        onPatternInput: Function,
        onPatternFocus: Function,
        onPatternBlur: Function,
        renderLabel: Function,
        status: String,
        inlineThemeDisabled: Boolean,
        onResize: Function
      },
      setup(props) {
        const patternInputMirrorRef = vue.ref(null);
        const patternInputRef = vue.ref(null);
        const selfRef = vue.ref(null);
        const multipleElRef = vue.ref(null);
        const singleElRef = vue.ref(null);
        const patternInputWrapperRef = vue.ref(null);
        const counterRef = vue.ref(null);
        const counterWrapperRef = vue.ref(null);
        const overflowRef = vue.ref(null);
        const inputTagElRef = vue.ref(null);
        const showTagsPopoverRef = vue.ref(false);
        const patternInputFocusedRef = vue.ref(false);
        const hoverRef = vue.ref(false);
        const themeRef = useTheme(
          "InternalSelection",
          "-internal-selection",
          style$1n,
          internalSelectionLight$1,
          props,
          vue.toRef(props, "clsPrefix")
        );
        const mergedClearableRef = vue.computed(() => {
          return props.clearable && !props.disabled && (hoverRef.value || props.active);
        });
        const filterablePlaceholderRef = vue.computed(() => {
          return props.selectedOption ? props.renderTag ? props.renderTag({
            option: props.selectedOption,
            handleClose: () => {
            }
          }) : props.renderLabel ? props.renderLabel(props.selectedOption, true) : render$1(
            props.selectedOption[props.labelField],
            props.selectedOption,
            true
          ) : props.placeholder;
        });
        const labelRef = vue.computed(() => {
          const option = props.selectedOption;
          if (!option)
            return void 0;
          return option[props.labelField];
        });
        const selectedRef = vue.computed(() => {
          if (props.multiple) {
            return !!(Array.isArray(props.selectedOptions) && props.selectedOptions.length);
          } else {
            return props.selectedOption !== null;
          }
        });
        function syncMirrorWidth() {
          const { value: patternInputMirrorEl } = patternInputMirrorRef;
          if (patternInputMirrorEl) {
            const { value: patternInputEl } = patternInputRef;
            if (patternInputEl) {
              patternInputEl.style.width = `${patternInputMirrorEl.offsetWidth}px`;
              if (props.maxTagCount !== "responsive") {
                overflowRef.value?.sync();
              }
            }
          }
        }
        function hideInputTag() {
          const { value: inputTagEl } = inputTagElRef;
          if (inputTagEl)
            inputTagEl.style.display = "none";
        }
        function showInputTag() {
          const { value: inputTagEl } = inputTagElRef;
          if (inputTagEl)
            inputTagEl.style.display = "inline-block";
        }
        vue.watch(vue.toRef(props, "active"), (value) => {
          if (!value)
            hideInputTag();
        });
        vue.watch(vue.toRef(props, "pattern"), () => {
          if (props.multiple) {
            void vue.nextTick(syncMirrorWidth);
          }
        });
        function doFocus(e) {
          const { onFocus } = props;
          if (onFocus)
            onFocus(e);
        }
        function doBlur(e) {
          const { onBlur } = props;
          if (onBlur)
            onBlur(e);
        }
        function doDeleteOption(value) {
          const { onDeleteOption } = props;
          if (onDeleteOption)
            onDeleteOption(value);
        }
        function doClear(e) {
          const { onClear } = props;
          if (onClear)
            onClear(e);
        }
        function doPatternInput(value) {
          const { onPatternInput } = props;
          if (onPatternInput)
            onPatternInput(value);
        }
        function handleFocusin(e) {
          if (!e.relatedTarget || !selfRef.value?.contains(e.relatedTarget)) {
            doFocus(e);
          }
        }
        function handleFocusout(e) {
          if (selfRef.value?.contains(e.relatedTarget))
            return;
          doBlur(e);
        }
        function handleClear(e) {
          doClear(e);
        }
        function handleMouseEnter() {
          hoverRef.value = true;
        }
        function handleMouseLeave() {
          hoverRef.value = false;
        }
        function handleMouseDown(e) {
          if (!props.active || !props.filterable)
            return;
          if (e.target === patternInputRef.value)
            return;
          e.preventDefault();
        }
        function handleDeleteOption(option) {
          doDeleteOption(option);
        }
        function handlePatternKeyDown(e) {
          if (e.key === "Backspace" && !isCompositingRef.value) {
            if (!props.pattern.length) {
              const { selectedOptions } = props;
              if (selectedOptions?.length) {
                handleDeleteOption(selectedOptions[selectedOptions.length - 1]);
              }
            }
          }
        }
        const isCompositingRef = vue.ref(false);
        let cachedInputEvent = null;
        function handlePatternInputInput(e) {
          const { value: patternInputMirrorEl } = patternInputMirrorRef;
          if (patternInputMirrorEl) {
            const inputText = e.target.value;
            patternInputMirrorEl.textContent = inputText;
            syncMirrorWidth();
          }
          if (!isCompositingRef.value) {
            doPatternInput(e);
          } else {
            cachedInputEvent = e;
          }
        }
        function handleCompositionStart() {
          isCompositingRef.value = true;
        }
        function handleCompositionEnd() {
          isCompositingRef.value = false;
          doPatternInput(cachedInputEvent);
          cachedInputEvent = null;
        }
        function handlePatternInputFocus(e) {
          patternInputFocusedRef.value = true;
          props.onPatternFocus?.(e);
        }
        function handlePatternInputBlur(e) {
          patternInputFocusedRef.value = false;
          props.onPatternBlur?.(e);
        }
        function blur() {
          if (props.filterable) {
            patternInputFocusedRef.value = false;
            patternInputWrapperRef.value?.blur();
            patternInputRef.value?.blur();
          } else if (props.multiple) {
            const { value: multipleEl } = multipleElRef;
            multipleEl?.blur();
          } else {
            const { value: singleEl } = singleElRef;
            singleEl?.blur();
          }
        }
        function focus() {
          if (props.filterable) {
            patternInputFocusedRef.value = false;
            patternInputWrapperRef.value?.focus();
          } else if (props.multiple) {
            multipleElRef.value?.focus();
          } else {
            singleElRef.value?.focus();
          }
        }
        function focusInput() {
          const { value: patternInputEl } = patternInputRef;
          if (patternInputEl) {
            showInputTag();
            patternInputEl.focus();
          }
        }
        function blurInput() {
          const { value: patternInputEl } = patternInputRef;
          if (patternInputEl) {
            patternInputEl.blur();
          }
        }
        function updateCounter(count) {
          const { value } = counterRef;
          if (value) {
            value.setTextContent(`+${count}`);
          }
        }
        function getCounter() {
          const { value } = counterWrapperRef;
          return value;
        }
        function getTail() {
          return patternInputRef.value;
        }
        let enterTimerId = null;
        function clearEnterTimer() {
          if (enterTimerId !== null)
            window.clearTimeout(enterTimerId);
        }
        function handleMouseEnterCounter() {
          if (props.disabled || props.active)
            return;
          clearEnterTimer();
          enterTimerId = window.setTimeout(() => {
            showTagsPopoverRef.value = true;
          }, 100);
        }
        function handleMouseLeaveCounter() {
          clearEnterTimer();
        }
        function onPopoverUpdateShow(show) {
          if (!show) {
            clearEnterTimer();
            showTagsPopoverRef.value = false;
          }
        }
        vue.onMounted(() => {
          vue.watchEffect(() => {
            const patternInputWrapperEl = patternInputWrapperRef.value;
            if (!patternInputWrapperEl)
              return;
            patternInputWrapperEl.tabIndex = props.disabled || patternInputFocusedRef.value ? -1 : 0;
          });
        });
        useOnResize(selfRef, props.onResize);
        const { inlineThemeDisabled } = props;
        const cssVarsRef = vue.computed(() => {
          const { size } = props;
          const {
            common: { cubicBezierEaseInOut },
            self: {
              borderRadius,
              color,
              placeholderColor,
              textColor,
              paddingSingle,
              paddingMultiple,
              caretColor,
              colorDisabled,
              textColorDisabled,
              placeholderColorDisabled,
              colorActive,
              boxShadowFocus,
              boxShadowActive,
              boxShadowHover,
              border,
              borderFocus,
              borderHover,
              borderActive,
              arrowColor,
              arrowColorDisabled,
              loadingColor,
              colorActiveWarning,
              boxShadowFocusWarning,
              boxShadowActiveWarning,
              boxShadowHoverWarning,
              borderWarning,
              borderFocusWarning,
              borderHoverWarning,
              borderActiveWarning,
              colorActiveError,
              boxShadowFocusError,
              boxShadowActiveError,
              boxShadowHoverError,
              borderError,
              borderFocusError,
              borderHoverError,
              borderActiveError,
              clearColor,
              clearColorHover,
              clearColorPressed,
              clearSize,
              arrowSize,
              [createKey("height", size)]: height,
              [createKey("fontSize", size)]: fontSize
            }
          } = themeRef.value;
          return {
            "--n-bezier": cubicBezierEaseInOut,
            "--n-border": border,
            "--n-border-active": borderActive,
            "--n-border-focus": borderFocus,
            "--n-border-hover": borderHover,
            "--n-border-radius": borderRadius,
            "--n-box-shadow-active": boxShadowActive,
            "--n-box-shadow-focus": boxShadowFocus,
            "--n-box-shadow-hover": boxShadowHover,
            "--n-caret-color": caretColor,
            "--n-color": color,
            "--n-color-active": colorActive,
            "--n-color-disabled": colorDisabled,
            "--n-font-size": fontSize,
            "--n-height": height,
            "--n-padding-single": paddingSingle,
            "--n-padding-multiple": paddingMultiple,
            "--n-placeholder-color": placeholderColor,
            "--n-placeholder-color-disabled": placeholderColorDisabled,
            "--n-text-color": textColor,
            "--n-text-color-disabled": textColorDisabled,
            "--n-arrow-color": arrowColor,
            "--n-arrow-color-disabled": arrowColorDisabled,
            "--n-loading-color": loadingColor,
            "--n-color-active-warning": colorActiveWarning,
            "--n-box-shadow-focus-warning": boxShadowFocusWarning,
            "--n-box-shadow-active-warning": boxShadowActiveWarning,
            "--n-box-shadow-hover-warning": boxShadowHoverWarning,
            "--n-border-warning": borderWarning,
            "--n-border-focus-warning": borderFocusWarning,
            "--n-border-hover-warning": borderHoverWarning,
            "--n-border-active-warning": borderActiveWarning,
            "--n-color-active-error": colorActiveError,
            "--n-box-shadow-focus-error": boxShadowFocusError,
            "--n-box-shadow-active-error": boxShadowActiveError,
            "--n-box-shadow-hover-error": boxShadowHoverError,
            "--n-border-error": borderError,
            "--n-border-focus-error": borderFocusError,
            "--n-border-hover-error": borderHoverError,
            "--n-border-active-error": borderActiveError,
            "--n-clear-size": clearSize,
            "--n-clear-color": clearColor,
            "--n-clear-color-hover": clearColorHover,
            "--n-clear-color-pressed": clearColorPressed,
            "--n-arrow-size": arrowSize
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass(
          "internal-selection",
          vue.computed(() => {
            return props.size[0];
          }),
          cssVarsRef,
          props
        ) : void 0;
        return {
          mergedTheme: themeRef,
          mergedClearable: mergedClearableRef,
          patternInputFocused: patternInputFocusedRef,
          filterablePlaceholder: filterablePlaceholderRef,
          label: labelRef,
          selected: selectedRef,
          showTagsPanel: showTagsPopoverRef,
          isCompositing: isCompositingRef,
          counterRef,
          counterWrapperRef,
          patternInputMirrorRef,
          patternInputRef,
          selfRef,
          multipleElRef,
          singleElRef,
          patternInputWrapperRef,
          overflowRef,
          inputTagElRef,
          handleMouseDown,
          handleFocusin,
          handleClear,
          handleMouseEnter,
          handleMouseLeave,
          handleDeleteOption,
          handlePatternKeyDown,
          handlePatternInputInput,
          handlePatternInputBlur,
          handlePatternInputFocus,
          handleMouseEnterCounter,
          handleMouseLeaveCounter,
          handleFocusout,
          handleCompositionEnd,
          handleCompositionStart,
          onPopoverUpdateShow,
          focus,
          focusInput,
          blur,
          blurInput,
          updateCounter,
          getCounter,
          getTail,
          renderLabel: props.renderLabel,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender
        };
      },
      render() {
        const {
          status,
          multiple,
          size,
          disabled,
          filterable,
          maxTagCount,
          bordered,
          clsPrefix,
          onRender,
          renderTag,
          renderLabel
        } = this;
        onRender?.();
        const maxTagCountResponsive = maxTagCount === "responsive";
        const maxTagCountNumeric = typeof maxTagCount === "number";
        const useMaxTagCount = maxTagCountResponsive || maxTagCountNumeric;
        const suffix = /* @__PURE__ */ vue.h(Wrapper, null, {
          default: () => /* @__PURE__ */ vue.h(NBaseSuffix, {
            clsPrefix,
            loading: this.loading,
            showArrow: this.showArrow,
            showClear: this.mergedClearable && this.selected,
            onClear: this.handleClear
          }, {
            default: () => this.$slots.arrow?.()
          })
        });
        let body;
        if (multiple) {
          const { labelField } = this;
          const createTag = (option) => /* @__PURE__ */ vue.h("div", {
            class: `${clsPrefix}-base-selection-tag-wrapper`,
            key: option.value
          }, renderTag ? renderTag({
            option,
            handleClose: () => this.handleDeleteOption(option)
          }) : /* @__PURE__ */ vue.h(NTag, {
            size,
            closable: !option.disabled,
            disabled,
            onClose: () => this.handleDeleteOption(option),
            internalCloseFocusable: false
          }, {
            default: () => renderLabel ? renderLabel(option, true) : render$1(option[labelField], option, true)
          }));
          const originalTags = (maxTagCountNumeric ? this.selectedOptions.slice(0, maxTagCount) : this.selectedOptions).map(createTag);
          const input = filterable ? /* @__PURE__ */ vue.h("div", {
            class: `${clsPrefix}-base-selection-input-tag`,
            ref: "inputTagElRef",
            key: "__input-tag__"
          }, /* @__PURE__ */ vue.h("input", {
            ...this.inputProps,
            ref: "patternInputRef",
            tabindex: -1,
            disabled,
            value: this.pattern,
            autofocus: this.autofocus,
            class: `${clsPrefix}-base-selection-input-tag__input`,
            onBlur: this.handlePatternInputBlur,
            onFocus: this.handlePatternInputFocus,
            onKeydown: this.handlePatternKeyDown,
            onInput: this.handlePatternInputInput,
            onCompositionstart: this.handleCompositionStart,
            onCompositionend: this.handleCompositionEnd
          }), /* @__PURE__ */ vue.h("span", {
            ref: "patternInputMirrorRef",
            class: `${clsPrefix}-base-selection-input-tag__mirror`
          }, this.pattern)) : null;
          const renderCounter = maxTagCountResponsive ? () => /* @__PURE__ */ vue.h("div", {
            class: `${clsPrefix}-base-selection-tag-wrapper`,
            ref: "counterWrapperRef"
          }, /* @__PURE__ */ vue.h(NTag, {
            size,
            ref: "counterRef",
            onMouseenter: this.handleMouseEnterCounter,
            onMouseleave: this.handleMouseLeaveCounter,
            disabled
          })) : void 0;
          let counter;
          if (maxTagCountNumeric) {
            const rest = this.selectedOptions.length - maxTagCount;
            if (rest > 0) {
              counter = /* @__PURE__ */ vue.h("div", {
                class: `${clsPrefix}-base-selection-tag-wrapper`,
                key: "__counter__"
              }, /* @__PURE__ */ vue.h(NTag, {
                size,
                ref: "counterRef",
                onMouseenter: this.handleMouseEnterCounter,
                disabled
              }, {
                default: () => `+${rest}`
              }));
            }
          }
          const tags = maxTagCountResponsive ? filterable ? /* @__PURE__ */ vue.h(VOverflow, {
            ref: "overflowRef",
            updateCounter: this.updateCounter,
            getCounter: this.getCounter,
            getTail: this.getTail,
            style: {
              width: "100%",
              display: "flex",
              overflow: "hidden"
            }
          }, {
            default: () => originalTags,
            counter: renderCounter,
            tail: () => input
          }) : /* @__PURE__ */ vue.h(VOverflow, {
            ref: "overflowRef",
            updateCounter: this.updateCounter,
            getCounter: this.getCounter,
            style: {
              width: "100%",
              display: "flex",
              overflow: "hidden"
            }
          }, {
            default: () => originalTags,
            counter: renderCounter
          }) : maxTagCountNumeric ? originalTags.concat(counter) : originalTags;
          const renderPopover = useMaxTagCount ? () => /* @__PURE__ */ vue.h("div", {
            class: `${clsPrefix}-base-selection-popover`
          }, maxTagCountResponsive ? originalTags : this.selectedOptions.map(createTag)) : void 0;
          const popoverProps = useMaxTagCount ? {
            show: this.showTagsPanel,
            trigger: "hover",
            overlap: true,
            placement: "top",
            width: "trigger",
            onUpdateShow: this.onPopoverUpdateShow,
            theme: this.mergedTheme.peers.Popover,
            themeOverrides: this.mergedTheme.peerOverrides.Popover
          } : null;
          const showPlaceholder = this.selected ? false : this.active ? !this.pattern && !this.isCompositing : true;
          const placeholder = showPlaceholder ? /* @__PURE__ */ vue.h("div", {
            class: `${clsPrefix}-base-selection-placeholder ${clsPrefix}-base-selection-overlay`
          }, /* @__PURE__ */ vue.h("div", {
            class: `${clsPrefix}-base-selection-placeholder__inner`
          }, this.placeholder)) : null;
          const popoverTrigger = filterable ? /* @__PURE__ */ vue.h("div", {
            ref: "patternInputWrapperRef",
            class: `${clsPrefix}-base-selection-tags`
          }, tags, maxTagCountResponsive ? null : input, suffix) : /* @__PURE__ */ vue.h("div", {
            ref: "multipleElRef",
            class: `${clsPrefix}-base-selection-tags`,
            tabindex: disabled ? void 0 : 0
          }, tags, suffix);
          body = /* @__PURE__ */ vue.h(vue.Fragment, null, useMaxTagCount ? /* @__PURE__ */ vue.h(NPopover, {
            ...popoverProps,
            scrollable: true,
            style: "max-height: calc(var(--v-target-height) * 6.6);"
          }, {
            trigger: () => popoverTrigger,
            default: renderPopover
          }) : popoverTrigger, placeholder);
        } else {
          if (filterable) {
            const hasInput = this.pattern || this.isCompositing;
            const showPlaceholder = this.active ? !hasInput : !this.selected;
            const showSelectedLabel = this.active ? false : this.selected;
            body = /* @__PURE__ */ vue.h("div", {
              ref: "patternInputWrapperRef",
              class: `${clsPrefix}-base-selection-label`
            }, /* @__PURE__ */ vue.h("input", {
              ...this.inputProps,
              ref: "patternInputRef",
              class: `${clsPrefix}-base-selection-input`,
              value: this.active ? this.pattern : "",
              placeholder: "",
              readonly: disabled,
              disabled,
              tabindex: -1,
              autofocus: this.autofocus,
              onFocus: this.handlePatternInputFocus,
              onBlur: this.handlePatternInputBlur,
              onInput: this.handlePatternInputInput,
              onCompositionstart: this.handleCompositionStart,
              onCompositionend: this.handleCompositionEnd
            }), showSelectedLabel ? /* @__PURE__ */ vue.h("div", {
              class: `${clsPrefix}-base-selection-label__render-label ${clsPrefix}-base-selection-overlay`,
              key: "input"
            }, /* @__PURE__ */ vue.h("div", {
              class: `${clsPrefix}-base-selection-overlay__wrapper`
            }, renderTag ? renderTag({
              option: this.selectedOption,
              handleClose: () => {
              }
            }) : renderLabel ? renderLabel(this.selectedOption, true) : render$1(this.label, this.selectedOption, true))) : null, showPlaceholder ? /* @__PURE__ */ vue.h("div", {
              class: `${clsPrefix}-base-selection-placeholder ${clsPrefix}-base-selection-overlay`,
              key: "placeholder"
            }, /* @__PURE__ */ vue.h("div", {
              class: `${clsPrefix}-base-selection-overlay__wrapper`
            }, this.filterablePlaceholder)) : null, suffix);
          } else {
            body = /* @__PURE__ */ vue.h("div", {
              ref: "singleElRef",
              class: `${clsPrefix}-base-selection-label`,
              tabindex: this.disabled ? void 0 : 0
            }, this.label !== void 0 ? /* @__PURE__ */ vue.h("div", {
              class: `${clsPrefix}-base-selection-input`,
              title: getTitleAttribute(this.label),
              key: "input"
            }, /* @__PURE__ */ vue.h("div", {
              class: `${clsPrefix}-base-selection-input__content`
            }, renderTag ? renderTag({
              option: this.selectedOption,
              handleClose: () => {
              }
            }) : renderLabel ? renderLabel(this.selectedOption, true) : render$1(this.label, this.selectedOption, true))) : /* @__PURE__ */ vue.h("div", {
              class: `${clsPrefix}-base-selection-placeholder ${clsPrefix}-base-selection-overlay`,
              key: "placeholder"
            }, /* @__PURE__ */ vue.h("div", {
              class: `${clsPrefix}-base-selection-placeholder__inner`
            }, this.placeholder)), suffix);
          }
        }
        return /* @__PURE__ */ vue.h("div", {
          ref: "selfRef",
          class: [
            `${clsPrefix}-base-selection`,
            this.themeClass,
            status && `${clsPrefix}-base-selection--${status}-status`,
            {
              [`${clsPrefix}-base-selection--active`]: this.active,
              [`${clsPrefix}-base-selection--selected`]: this.selected || this.active && this.pattern,
              [`${clsPrefix}-base-selection--disabled`]: this.disabled,
              [`${clsPrefix}-base-selection--multiple`]: this.multiple,
              [`${clsPrefix}-base-selection--focus`]: this.focused
            }
          ],
          style: this.cssVars,
          onClick: this.onClick,
          onMouseenter: this.handleMouseEnter,
          onMouseleave: this.handleMouseLeave,
          onKeydown: this.onKeydown,
          onFocusin: this.handleFocusin,
          onFocusout: this.handleFocusout,
          onMousedown: this.handleMouseDown
        }, body, bordered ? /* @__PURE__ */ vue.h("div", {
          class: `${clsPrefix}-base-selection__border`
        }) : null, bordered ? /* @__PURE__ */ vue.h("div", {
          class: `${clsPrefix}-base-selection__state-border`
        }) : null);
      }
    });

    var SlotMachineNumber = vue.defineComponent({
      name: "SlotMachineNumber",
      props: {
        clsPrefix: {
          type: String,
          required: true
        },
        value: {
          type: [Number, String],
          required: true
        },
        oldOriginalNumber: {
          type: Number,
          default: void 0
        },
        newOriginalNumber: {
          type: Number,
          default: void 0
        }
      },
      setup(props) {
        const numberRef = vue.ref(null);
        const oldNumberRef = vue.ref(props.value);
        const newNumberRef = vue.ref(props.value);
        const scrollAnimationDirectionRef = vue.ref("up");
        const activeRef = vue.ref(false);
        const newNumberScrollAnimationClassRef = vue.computed(() => {
          return activeRef.value ? `${props.clsPrefix}-base-slot-machine-current-number--${scrollAnimationDirectionRef.value}-scroll` : null;
        });
        const oldNumberScrollAnimationClassRef = vue.computed(() => {
          return activeRef.value ? `${props.clsPrefix}-base-slot-machine-old-number--${scrollAnimationDirectionRef.value}-scroll` : null;
        });
        vue.watch(vue.toRef(props, "value"), (value, oldValue) => {
          oldNumberRef.value = oldValue;
          newNumberRef.value = value;
          void vue.nextTick(scroll);
        });
        function scroll() {
          const newOriginalNumber = props.newOriginalNumber;
          const oldOriginalNumber = props.oldOriginalNumber;
          if (oldOriginalNumber === void 0 || newOriginalNumber === void 0) {
            return;
          }
          if (newOriginalNumber > oldOriginalNumber) {
            scrollByDir("up");
          } else if (oldOriginalNumber > newOriginalNumber) {
            scrollByDir("down");
          }
        }
        function scrollByDir(dir) {
          scrollAnimationDirectionRef.value = dir;
          activeRef.value = false;
          void vue.nextTick(() => {
            void numberRef.value?.offsetWidth;
            activeRef.value = true;
          });
        }
        return () => {
          const { clsPrefix } = props;
          return /* @__PURE__ */ vue.h("span", {
            ref: numberRef,
            class: `${clsPrefix}-base-slot-machine-number`
          }, oldNumberRef.value !== null ? /* @__PURE__ */ vue.h("span", {
            class: [
              `${clsPrefix}-base-slot-machine-old-number ${clsPrefix}-base-slot-machine-old-number--top`,
              oldNumberScrollAnimationClassRef.value
            ]
          }, oldNumberRef.value) : null, /* @__PURE__ */ vue.h("span", {
            class: [
              `${clsPrefix}-base-slot-machine-current-number`,
              newNumberScrollAnimationClassRef.value
            ]
          }, /* @__PURE__ */ vue.h("span", {
            ref: "numberWrapper",
            class: [
              `${clsPrefix}-base-slot-machine-current-number__inner`,
              typeof props.value !== "number" && `${clsPrefix}-base-slot-machine-current-number__inner--not-number`
            ]
          }, newNumberRef.value)), oldNumberRef.value !== null ? /* @__PURE__ */ vue.h("span", {
            class: [
              `${clsPrefix}-base-slot-machine-old-number ${clsPrefix}-base-slot-machine-old-number--bottom`,
              oldNumberScrollAnimationClassRef.value
            ]
          }, oldNumberRef.value) : null);
        };
      }
    });

    const {
      cubicBezierEaseInOut: cubicBezierEaseInOut$2
    } = commonVariables$m;
    function fadeInWidthExpandTransition() {
      let {
        duration = ".2s",
        delay = ".1s"
      } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return [c$1("&.fade-in-width-expand-transition-leave-from, &.fade-in-width-expand-transition-enter-to", {
        opacity: 1
      }), c$1("&.fade-in-width-expand-transition-leave-to, &.fade-in-width-expand-transition-enter-from", `
      opacity: 0!important;
      margin-left: 0!important;
      margin-right: 0!important;
    `), c$1("&.fade-in-width-expand-transition-leave-active", `
      overflow: hidden;
      transition:
        opacity ${duration} ${cubicBezierEaseInOut$2},
        max-width ${duration} ${cubicBezierEaseInOut$2} ${delay},
        margin-left ${duration} ${cubicBezierEaseInOut$2} ${delay},
        margin-right ${duration} ${cubicBezierEaseInOut$2} ${delay};
    `), c$1("&.fade-in-width-expand-transition-enter-active", `
      overflow: hidden;
      transition:
        opacity ${duration} ${cubicBezierEaseInOut$2} ${delay},
        max-width ${duration} ${cubicBezierEaseInOut$2},
        margin-left ${duration} ${cubicBezierEaseInOut$2},
        margin-right ${duration} ${cubicBezierEaseInOut$2};
    `)];
    }

    const {
      cubicBezierEaseOut: cubicBezierEaseOut$5
    } = commonVariables$m;
    function fadeUpWidthExpandTransition() {
      let {
        duration = ".2s"
      } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return [c$1("&.fade-up-width-expand-transition-leave-active", {
        transition: `
        opacity ${duration} ${cubicBezierEaseOut$5},
        max-width ${duration} ${cubicBezierEaseOut$5},
        transform ${duration} ${cubicBezierEaseOut$5}
      `
      }), c$1("&.fade-up-width-expand-transition-enter-active", {
        transition: `
        opacity ${duration} ${cubicBezierEaseOut$5},
        max-width ${duration} ${cubicBezierEaseOut$5},
        transform ${duration} ${cubicBezierEaseOut$5}
      `
      }), c$1("&.fade-up-width-expand-transition-enter-to", {
        opacity: 1,
        transform: "translateX(0) translateY(0)"
      }), c$1("&.fade-up-width-expand-transition-enter-from", {
        maxWidth: "0 !important",
        opacity: 0,
        transform: "translateY(60%)"
      }), c$1("&.fade-up-width-expand-transition-leave-from", {
        opacity: 1,
        transform: "translateY(0)"
      }), c$1("&.fade-up-width-expand-transition-leave-to", {
        maxWidth: "0 !important",
        opacity: 0,
        transform: "translateY(60%)"
      })];
    }

    var style$1m = c$1([c$1("@keyframes n-base-slot-machine-fade-up-in", `
    from {
      transform: translateY(60%);
      opacity: 0;
    }
    to {
      transform: translateY(0);
      opacity: 1;
    }
  `), c$1("@keyframes n-base-slot-machine-fade-down-in", `
    from {
      transform: translateY(-60%);
      opacity: 0;
    }
    to {
      transform: translateY(0);
      opacity: 1;
    }
  `), c$1("@keyframes n-base-slot-machine-fade-up-out", `
    from {
      transform: translateY(0%);
      opacity: 1;
    }
    to {
      transform: translateY(-60%);
      opacity: 0;
    }
  `), c$1("@keyframes n-base-slot-machine-fade-down-out", `
    from {
      transform: translateY(0%);
      opacity: 1;
    }
    to {
      transform: translateY(60%);
      opacity: 0;
    }
  `), cB("base-slot-machine", `
    overflow: hidden;
    white-space: nowrap;
    display: inline-block;
    height: 18px;
    line-height: 18px;
  `, [cB("base-slot-machine-number", `
      display: inline-block;
      position: relative;
      height: 18px;
      width: .6em;
      max-width: .6em;
    `, [fadeUpWidthExpandTransition({
      duration: ".2s"
    }), fadeInWidthExpandTransition({
      duration: ".2s",
      delay: "0s"
    }), cB("base-slot-machine-old-number", `
        display: inline-block;
        opacity: 0;
        position: absolute;
        left: 0;
        right: 0;
      `, [cM("top", {
      transform: "translateY(-100%)"
    }), cM("bottom", {
      transform: "translateY(100%)"
    }), cM("down-scroll", {
      animation: "n-base-slot-machine-fade-down-out .2s cubic-bezier(0, 0, .2, 1)",
      animationIterationCount: 1
    }), cM("up-scroll", {
      animation: "n-base-slot-machine-fade-up-out .2s cubic-bezier(0, 0, .2, 1)",
      animationIterationCount: 1
    })]), cB("base-slot-machine-current-number", `
        display: inline-block;
        position: absolute;
        left: 0;
        top: 0;
        bottom: 0;
        right: 0;
        opacity: 1;
        transform: translateY(0);
        width: .6em;
      `, [cM("down-scroll", {
      animation: "n-base-slot-machine-fade-down-in .2s cubic-bezier(0, 0, .2, 1)",
      animationIterationCount: 1
    }), cM("up-scroll", {
      animation: "n-base-slot-machine-fade-up-in .2s cubic-bezier(0, 0, .2, 1)",
      animationIterationCount: 1
    }), cE("inner", `
            display: inline-block;
            position: absolute;
            right: 0;
            top: 0;
            width: .6em;
          `, [cM("not-number", `
            right: unset;
            left: 0;
          `)])])])])]);

    var NBaseSlotMachine = vue.defineComponent({
      name: "BaseSlotMachine",
      props: {
        clsPrefix: {
          type: String,
          required: true
        },
        value: {
          type: [Number, String],
          default: 0
        },
        max: {
          type: Number,
          default: void 0
        },
        appeared: {
          type: Boolean,
          required: true
        }
      },
      setup(props) {
        useStyle("-base-slot-machine", style$1m, vue.toRef(props, "clsPrefix"));
        const oldValueRef = vue.ref();
        const newValueRef = vue.ref();
        const numbersRef = vue.computed(() => {
          if (typeof props.value === "string")
            return [];
          if (props.value < 1)
            return [0];
          const numbers = [];
          let value = props.value;
          if (props.max !== void 0) {
            value = Math.min(props.max, value);
          }
          while (value >= 1) {
            numbers.push(value % 10);
            value /= 10;
            value = Math.floor(value);
          }
          numbers.reverse();
          return numbers;
        });
        vue.watch(vue.toRef(props, "value"), (value, oldValue) => {
          if (typeof value === "string") {
            newValueRef.value = void 0;
            oldValueRef.value = void 0;
          } else {
            if (typeof oldValue === "string") {
              newValueRef.value = value;
              oldValueRef.value = void 0;
            } else {
              newValueRef.value = value;
              oldValueRef.value = oldValue;
            }
          }
        });
        return () => {
          const { value, clsPrefix } = props;
          return typeof value === "number" ? /* @__PURE__ */ vue.h("span", {
            class: `${clsPrefix}-base-slot-machine`
          }, /* @__PURE__ */ vue.h(vue.TransitionGroup, {
            name: "fade-up-width-expand-transition",
            tag: "span"
          }, {
            default: () => numbersRef.value.map((number, i) => /* @__PURE__ */ vue.h(SlotMachineNumber, {
              clsPrefix,
              key: numbersRef.value.length - i - 1,
              oldOriginalNumber: oldValueRef.value,
              newOriginalNumber: newValueRef.value,
              value: number
            }))
          }), /* @__PURE__ */ vue.h(NFadeInExpandTransition, {
            key: "+",
            width: true
          }, {
            default: () => props.max !== void 0 && props.max < value ? /* @__PURE__ */ vue.h(SlotMachineNumber, {
              clsPrefix,
              value: "+"
            }) : null
          })) : /* @__PURE__ */ vue.h("span", {
            class: `${clsPrefix}-base-slot-machine`
          }, value);
        };
      }
    });

    var commonVars$a = {
      iconMargin: "11px 8px 0 12px",
      iconMarginRtl: "11px 12px 0 8px",
      iconSize: "24px",
      closeIconSize: "16px",
      closeSize: "20px",
      closeMargin: "13px 14px 0 0",
      closeMarginRtl: "13px 0 0 14px",
      padding: "13px"
    };

    const alertDark = {
      name: "Alert",
      common: commonDark,

      self(vars) {
        const {
          lineHeight,
          borderRadius,
          fontWeightStrong,
          dividerColor,
          inputColor,
          textColor1,
          textColor2,
          closeColorHover,
          closeColorPressed,
          closeIconColor,
          closeIconColorHover,
          closeIconColorPressed,
          infoColorSuppl,
          successColorSuppl,
          warningColorSuppl,
          errorColorSuppl,
          fontSize
        } = vars;
        return { ...commonVars$a,
          fontSize,
          lineHeight,
          titleFontWeight: fontWeightStrong,
          borderRadius,
          border: `1px solid ${dividerColor}`,
          color: inputColor,
          titleTextColor: textColor1,
          iconColor: textColor2,
          contentTextColor: textColor2,
          closeBorderRadius: borderRadius,
          closeColorHover,
          closeColorPressed,
          closeIconColor,
          closeIconColorHover,
          closeIconColorPressed,
          borderInfo: `1px solid ${changeColor(infoColorSuppl, {
        alpha: 0.35
      })}`,
          colorInfo: changeColor(infoColorSuppl, {
            alpha: 0.25
          }),
          titleTextColorInfo: textColor1,
          iconColorInfo: infoColorSuppl,
          contentTextColorInfo: textColor2,
          closeColorHoverInfo: closeColorHover,
          closeColorPressedInfo: closeColorPressed,
          closeIconColorInfo: closeIconColor,
          closeIconColorHoverInfo: closeIconColorHover,
          closeIconColorPressedInfo: closeIconColorPressed,
          borderSuccess: `1px solid ${changeColor(successColorSuppl, {
        alpha: 0.35
      })}`,
          colorSuccess: changeColor(successColorSuppl, {
            alpha: 0.25
          }),
          titleTextColorSuccess: textColor1,
          iconColorSuccess: successColorSuppl,
          contentTextColorSuccess: textColor2,
          closeColorHoverSuccess: closeColorHover,
          closeColorPressedSuccess: closeColorPressed,
          closeIconColorSuccess: closeIconColor,
          closeIconColorHoverSuccess: closeIconColorHover,
          closeIconColorPressedSuccess: closeIconColorPressed,
          borderWarning: `1px solid ${changeColor(warningColorSuppl, {
        alpha: 0.35
      })}`,
          colorWarning: changeColor(warningColorSuppl, {
            alpha: 0.25
          }),
          titleTextColorWarning: textColor1,
          iconColorWarning: warningColorSuppl,
          contentTextColorWarning: textColor2,
          closeColorHoverWarning: closeColorHover,
          closeColorPressedWarning: closeColorPressed,
          closeIconColorWarning: closeIconColor,
          closeIconColorHoverWarning: closeIconColorHover,
          closeIconColorPressedWarning: closeIconColorPressed,
          borderError: `1px solid ${changeColor(errorColorSuppl, {
        alpha: 0.35
      })}`,
          colorError: changeColor(errorColorSuppl, {
            alpha: 0.25
          }),
          titleTextColorError: textColor1,
          iconColorError: errorColorSuppl,
          contentTextColorError: textColor2,
          closeColorHoverError: closeColorHover,
          closeColorPressedError: closeColorPressed,
          closeIconColorError: closeIconColor,
          closeIconColorHoverError: closeIconColorHover,
          closeIconColorPressedError: closeIconColorPressed
        };
      }

    };
    var alertDark$1 = alertDark;

    const self$15 = vars => {
      const {
        lineHeight,
        borderRadius,
        fontWeightStrong,
        baseColor,
        dividerColor,
        actionColor,
        textColor1,
        textColor2,
        closeColorHover,
        closeColorPressed,
        closeIconColor,
        closeIconColorHover,
        closeIconColorPressed,
        infoColor,
        successColor,
        warningColor,
        errorColor,
        fontSize
      } = vars;
      return { ...commonVars$a,
        fontSize,
        lineHeight,
        titleFontWeight: fontWeightStrong,
        borderRadius,
        border: `1px solid ${dividerColor}`,
        color: actionColor,
        titleTextColor: textColor1,
        iconColor: textColor2,
        contentTextColor: textColor2,
        closeBorderRadius: borderRadius,
        closeColorHover,
        closeColorPressed,
        closeIconColor,
        closeIconColorHover,
        closeIconColorPressed,
        borderInfo: `1px solid ${composite(baseColor, changeColor(infoColor, {
      alpha: 0.25
    }))}`,
        colorInfo: composite(baseColor, changeColor(infoColor, {
          alpha: 0.08
        })),
        titleTextColorInfo: textColor1,
        iconColorInfo: infoColor,
        contentTextColorInfo: textColor2,
        closeColorHoverInfo: closeColorHover,
        closeColorPressedInfo: closeColorPressed,
        closeIconColorInfo: closeIconColor,
        closeIconColorHoverInfo: closeIconColorHover,
        closeIconColorPressedInfo: closeIconColorPressed,
        borderSuccess: `1px solid ${composite(baseColor, changeColor(successColor, {
      alpha: 0.25
    }))}`,
        colorSuccess: composite(baseColor, changeColor(successColor, {
          alpha: 0.08
        })),
        titleTextColorSuccess: textColor1,
        iconColorSuccess: successColor,
        contentTextColorSuccess: textColor2,
        closeColorHoverSuccess: closeColorHover,
        closeColorPressedSuccess: closeColorPressed,
        closeIconColorSuccess: closeIconColor,
        closeIconColorHoverSuccess: closeIconColorHover,
        closeIconColorPressedSuccess: closeIconColorPressed,
        borderWarning: `1px solid ${composite(baseColor, changeColor(warningColor, {
      alpha: 0.33
    }))}`,
        colorWarning: composite(baseColor, changeColor(warningColor, {
          alpha: 0.08
        })),
        titleTextColorWarning: textColor1,
        iconColorWarning: warningColor,
        contentTextColorWarning: textColor2,
        closeColorHoverWarning: closeColorHover,
        closeColorPressedWarning: closeColorPressed,
        closeIconColorWarning: closeIconColor,
        closeIconColorHoverWarning: closeIconColorHover,
        closeIconColorPressedWarning: closeIconColorPressed,
        borderError: `1px solid ${composite(baseColor, changeColor(errorColor, {
      alpha: 0.25
    }))}`,
        colorError: composite(baseColor, changeColor(errorColor, {
          alpha: 0.08
        })),
        titleTextColorError: textColor1,
        iconColorError: errorColor,
        contentTextColorError: textColor2,
        closeColorHoverError: closeColorHover,
        closeColorPressedError: closeColorPressed,
        closeIconColorError: closeIconColor,
        closeIconColorHoverError: closeIconColorHover,
        closeIconColorPressedError: closeIconColorPressed
      };
    };

    const alertLight = {
      name: "Alert",
      common: commonLight,
      self: self$15
    };
    var alertLight$1 = alertLight;

    var rtlStyle$p = cB("alert", [cM("rtl", `
    direction: rtl;
  `, [cE("icon", `
      left: unset;
      right: 0;
      margin: var(--n-icon-margin-rtl);
    `), cM("show-icon", [cB("alert-body", `
        padding-left: var(--n-padding);
        padding-right: calc(var(--n-icon-margin-left) + var(--n-icon-size) + var(--n-icon-margin-right));
      `)]), cE("close", `
      position: absolute;
      right: unset;
      left: 0;
      margin: var(--n-close-margin-rtl);
    `)])]);

    const alertRtl = {
      name: "Alert",
      style: rtlStyle$p
    };

    const {
      cubicBezierEaseInOut: cubicBezierEaseInOut$1,
      cubicBezierEaseOut: cubicBezierEaseOut$4,
      cubicBezierEaseIn: cubicBezierEaseIn$4
    } = commonVariables$m;
    function fadeInHeightExpandTransition() {
      let {
        overflow = "hidden",
        duration = ".3s",
        originalTransition = "",
        leavingDelay = "0s",
        foldPadding = false,
        enterToProps = void 0,
        leaveToProps = void 0,
        reverse = false
      } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      const enterClass = reverse ? "leave" : "enter";
      const leaveClass = reverse ? "enter" : "leave";
      return [c$1(`&.fade-in-height-expand-transition-${leaveClass}-from,
      &.fade-in-height-expand-transition-${enterClass}-to`, { ...enterToProps,
        opacity: 1
      }), c$1(`&.fade-in-height-expand-transition-${leaveClass}-to,
      &.fade-in-height-expand-transition-${enterClass}-from`, { ...leaveToProps,
        opacity: 0,
        marginTop: "0 !important",
        marginBottom: "0 !important",
        paddingTop: foldPadding ? "0 !important" : void 0,
        paddingBottom: foldPadding ? "0 !important" : void 0
      }), c$1(`&.fade-in-height-expand-transition-${leaveClass}-active`, `
      overflow: ${overflow};
      transition:
        max-height ${duration} ${cubicBezierEaseInOut$1} ${leavingDelay},
        opacity ${duration} ${cubicBezierEaseOut$4} ${leavingDelay},
        margin-top ${duration} ${cubicBezierEaseInOut$1} ${leavingDelay},
        margin-bottom ${duration} ${cubicBezierEaseInOut$1} ${leavingDelay},
        padding-top ${duration} ${cubicBezierEaseInOut$1} ${leavingDelay},
        padding-bottom ${duration} ${cubicBezierEaseInOut$1} ${leavingDelay}
        ${originalTransition ? "," + originalTransition : ""}
    `), c$1(`&.fade-in-height-expand-transition-${enterClass}-active`, `
      overflow: ${overflow};
      transition:
        max-height ${duration} ${cubicBezierEaseInOut$1},
        opacity ${duration} ${cubicBezierEaseIn$4},
        margin-top ${duration} ${cubicBezierEaseInOut$1},
        margin-bottom ${duration} ${cubicBezierEaseInOut$1},
        padding-top ${duration} ${cubicBezierEaseInOut$1},
        padding-bottom ${duration} ${cubicBezierEaseInOut$1}
        ${originalTransition ? "," + originalTransition : ""}
    `)];
    }

    var style$1l = cB("alert", `
  line-height: var(--n-line-height);
  border-radius: var(--n-border-radius);
  position: relative;
  transition: background-color .3s var(--n-bezier);
  background-color: var(--n-color);
  text-align: start;
  word-break: break-word;
`, [cE("border", `
    border-radius: inherit;
    position: absolute;
    left: 0;
    right: 0;
    top: 0;
    bottom: 0;
    transition: border-color .3s var(--n-bezier);
    border: var(--n-border);
    pointer-events: none;
  `), cM("closable", [cB("alert-body", [cE("title", `
        padding-right: 24px;
      `)])]), cE("icon", {
      color: "var(--n-icon-color)"
    }), cB("alert-body", {
      padding: "var(--n-padding)"
    }, [cE("title", {
      color: "var(--n-title-text-color)"
    }), cE("content", {
      color: "var(--n-content-text-color)"
    })]), fadeInHeightExpandTransition({
      originalTransition: "transform .3s var(--n-bezier)",
      enterToProps: {
        transform: "scale(1)"
      },
      leaveToProps: {
        transform: "scale(0.9)"
      }
    }), cE("icon", `
    position: absolute;
    left: 0;
    top: 0;
    align-items: center;
    justify-content: center;
    display: flex;
    width: var(--n-icon-size);
    height: var(--n-icon-size);
    font-size: var(--n-icon-size);
    margin: var(--n-icon-margin);
  `), cE("close", `
    transition:
      color .3s var(--n-bezier),
      background-color .3s var(--n-bezier);
    position: absolute;
    right: 0;
    top: 0;
    margin: var(--n-close-margin);
  `), cM("show-icon", [cB("alert-body", {
      paddingLeft: "calc(var(--n-icon-margin-left) + var(--n-icon-size) + var(--n-icon-margin-right))"
    })]), cB("alert-body", `
    border-radius: var(--n-border-radius);
    transition: border-color .3s var(--n-bezier);
  `, [cE("title", `
      transition: color .3s var(--n-bezier);
      font-size: 16px;
      line-height: 19px;
      font-weight: var(--n-title-font-weight);
    `, [c$1("& +", [cE("content", {
      marginTop: "9px"
    })])]), cE("content", {
      transition: "color .3s var(--n-bezier)",
      fontSize: "var(--n-font-size)"
    })]), cE("icon", {
      transition: "color .3s var(--n-bezier)"
    })]);

    const alertProps = {
      ...useTheme.props,
      title: String,
      showIcon: {
        type: Boolean,
        default: true
      },
      type: {
        type: String,
        default: "default"
      },
      bordered: {
        type: Boolean,
        default: true
      },
      closable: Boolean,
      onClose: Function,
      onAfterLeave: Function,
      onAfterHide: Function
    };
    var Alert = vue.defineComponent({
      name: "Alert",
      inheritAttrs: false,
      props: alertProps,
      setup(props) {
        {
          vue.watchEffect(() => {
            if (props.onAfterHide !== void 0) {
              warnOnce(
                "alert",
                "`on-after-hide` is deprecated, please use `on-after-leave` instead."
              );
            }
          });
        }
        const {
          mergedClsPrefixRef,
          mergedBorderedRef,
          inlineThemeDisabled,
          mergedRtlRef
        } = useConfig(props);
        const themeRef = useTheme(
          "Alert",
          "-alert",
          style$1l,
          alertLight$1,
          props,
          mergedClsPrefixRef
        );
        const rtlEnabledRef = useRtl("Alert", mergedRtlRef, mergedClsPrefixRef);
        const cssVarsRef = vue.computed(() => {
          const {
            common: { cubicBezierEaseInOut },
            self
          } = themeRef.value;
          const {
            fontSize,
            borderRadius,
            titleFontWeight,
            lineHeight,
            iconSize,
            iconMargin,
            iconMarginRtl,
            closeIconSize,
            closeBorderRadius,
            closeSize,
            closeMargin,
            closeMarginRtl,
            padding
          } = self;
          const { type } = props;
          const { left, right } = getMargin(iconMargin);
          return {
            "--n-bezier": cubicBezierEaseInOut,
            "--n-color": self[createKey("color", type)],
            "--n-close-icon-size": closeIconSize,
            "--n-close-border-radius": closeBorderRadius,
            "--n-close-color-hover": self[createKey("closeColorHover", type)],
            "--n-close-color-pressed": self[createKey("closeColorPressed", type)],
            "--n-close-icon-color": self[createKey("closeIconColor", type)],
            "--n-close-icon-color-hover": self[createKey("closeIconColorHover", type)],
            "--n-close-icon-color-pressed": self[createKey("closeIconColorPressed", type)],
            "--n-icon-color": self[createKey("iconColor", type)],
            "--n-border": self[createKey("border", type)],
            "--n-title-text-color": self[createKey("titleTextColor", type)],
            "--n-content-text-color": self[createKey("contentTextColor", type)],
            "--n-line-height": lineHeight,
            "--n-border-radius": borderRadius,
            "--n-font-size": fontSize,
            "--n-title-font-weight": titleFontWeight,
            "--n-icon-size": iconSize,
            "--n-icon-margin": iconMargin,
            "--n-icon-margin-rtl": iconMarginRtl,
            "--n-close-size": closeSize,
            "--n-close-margin": closeMargin,
            "--n-close-margin-rtl": closeMarginRtl,
            "--n-padding": padding,
            "--n-icon-margin-left": left,
            "--n-icon-margin-right": right
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass(
          "alert",
          vue.computed(() => {
            return props.type[0];
          }),
          cssVarsRef,
          props
        ) : void 0;
        const visibleRef = vue.ref(true);
        const doAfterLeave = () => {
          const {
            onAfterLeave,
            onAfterHide
          } = props;
          if (onAfterLeave)
            onAfterLeave();
          if (onAfterHide)
            onAfterHide();
        };
        const handleCloseClick = () => {
          void Promise.resolve(props.onClose?.()).then((result) => {
            if (result === false)
              return;
            visibleRef.value = false;
          });
        };
        const handleAfterLeave = () => {
          doAfterLeave();
        };
        return {
          rtlEnabled: rtlEnabledRef,
          mergedClsPrefix: mergedClsPrefixRef,
          mergedBordered: mergedBorderedRef,
          visible: visibleRef,
          handleCloseClick,
          handleAfterLeave,
          mergedTheme: themeRef,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender
        };
      },
      render() {
        this.onRender?.();
        return /* @__PURE__ */ vue.h(NFadeInExpandTransition, {
          onAfterLeave: this.handleAfterLeave
        }, {
          default: () => {
            const { mergedClsPrefix, $slots } = this;
            const attrs = {
              class: [
                `${mergedClsPrefix}-alert`,
                this.themeClass,
                this.closable && `${mergedClsPrefix}-alert--closable`,
                this.showIcon && `${mergedClsPrefix}-alert--show-icon`,
                this.rtlEnabled && `${mergedClsPrefix}-alert--rtl`
              ],
              style: this.cssVars,
              role: "alert"
            };
            return this.visible ? /* @__PURE__ */ vue.h("div", {
              ...vue.mergeProps(this.$attrs, attrs)
            }, this.closable && /* @__PURE__ */ vue.h(NBaseClose, {
              clsPrefix: mergedClsPrefix,
              class: `${mergedClsPrefix}-alert__close`,
              onClick: this.handleCloseClick
            }), this.bordered && /* @__PURE__ */ vue.h("div", {
              class: `${mergedClsPrefix}-alert__border`
            }), this.showIcon && /* @__PURE__ */ vue.h("div", {
              class: `${mergedClsPrefix}-alert__icon`,
              "aria-hidden": "true"
            }, resolveSlot($slots.icon, () => [
              /* @__PURE__ */ vue.h(NBaseIcon, {
                clsPrefix: mergedClsPrefix
              }, {
                default: () => {
                  switch (this.type) {
                    case "success":
                      return /* @__PURE__ */ vue.h(SuccessIcon, null);
                    case "info":
                      return /* @__PURE__ */ vue.h(InfoIcon, null);
                    case "warning":
                      return /* @__PURE__ */ vue.h(WarningIcon, null);
                    case "error":
                      return /* @__PURE__ */ vue.h(ErrorIcon, null);
                    default:
                      return null;
                  }
                }
              })
            ])), /* @__PURE__ */ vue.h("div", {
              class: [
                `${mergedClsPrefix}-alert-body`,
                this.mergedBordered && `${mergedClsPrefix}-alert-body--bordered`
              ]
            }, resolveWrappedSlot($slots.header, (children) => {
              const mergedChildren = children || this.title;
              return mergedChildren ? /* @__PURE__ */ vue.h("div", {
                class: `${mergedClsPrefix}-alert-body__title`
              }, mergedChildren) : null;
            }), $slots.default && /* @__PURE__ */ vue.h("div", {
              class: `${mergedClsPrefix}-alert-body__content`
            }, $slots))) : null;
          }
        });
      }
    });

    var commonVars$9 = {
      linkFontSize: "13px",
      linkPadding: "0 0 0 16px",
      railWidth: "4px"
    };

    const self$14 = vars => {
      const {
        borderRadius,
        railColor,
        primaryColor,
        primaryColorHover,
        primaryColorPressed,
        textColor2
      } = vars;
      return { ...commonVars$9,
        borderRadius,
        railColor,
        railColorActive: primaryColor,
        linkColor: changeColor(primaryColor, {
          alpha: 0.15
        }),
        linkTextColor: textColor2,
        linkTextColorHover: primaryColorHover,
        linkTextColorPressed: primaryColorPressed,
        linkTextColorActive: primaryColor
      };
    };
    const anchorLight = {
      name: "Anchor",
      common: commonLight,
      self: self$14
    };
    var anchorLight$1 = anchorLight;

    const anchorDark = {
      name: "Anchor",
      common: commonDark,
      self: self$14
    };
    var anchorDark$1 = anchorDark;

    var style$1k = cB("anchor", `
  position: relative;
`, [cNotM("block", `
    padding-left: var(--n-rail-width);
  `, [cB("anchor-link", [c$1("+, >", [cB("anchor-link", `
          margin-top: .5em;
        `)])]), cB("anchor-link-background", `
      max-width: 0;
      border-top-right-radius: 10.5px;
      border-bottom-right-radius: 10.5px;
    `), cNotM("show-rail", [c$1(">", [cB("anchor-link", "padding-left: 0;")])])]), cM("block", [cB("anchor-link", `
      margin-bottom: 4px;
      padding: 2px 8px;
      transition: background-color .3s var(--n-bezier);
      background-color: transparent;
      border-radius: var(--n-link-border-radius);
    `, [cM("active", `
        background-color: var(--n-link-color);
      `)])]), cB("anchor-link-background", `
    position: absolute;
    left: calc(var(--n-rail-width) / 2);
    width: 100%;
    background-color: var(--n-link-color);
    transition:
      top .15s var(--n-bezier),
      max-width .15s var(--n-bezier),
      background-color .3s var(--n-bezier);
  `), cB("anchor-rail", `
    position: absolute;
    left: 0;
    top: 0;
    bottom: 0;
    width: var(--n-rail-width);
    border-radius: calc(var(--n-rail-width) / 2);
    overflow: hidden;
    transition: background-color .3s var(--n-bezier);
    background-color: var(--n-rail-color);
  `, [cE("bar", `
      position: absolute;
      left: 0;
      width: var(--n-rail-width);
      height: 21px;
      background-color: #0000;
      transition:
        top .15s var(--n-bezier),
        background-color .3s var(--n-bezier);
    `, [cM("active", {
      backgroundColor: "var(--n-rail-color-active)"
    })])]), cB("anchor-link", `
    padding: var(--n-link-padding);
    position: relative;
    line-height: 1.5;
    font-size: var(--n-link-font-size);
    min-height: 1.5em;
    display: flex;
    flex-direction: column;
  `, [cM("active", [c$1(">", [cE("title", `
          color: var(--n-link-text-color-active);
        `)])]), cE("title", `
      outline: none;
      max-width: 100%;
      text-decoration: none;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
      cursor: pointer;
      display: inline-block;
      padding-right: 16px;
      transition: color .3s var(--n-bezier);
      color: var(--n-link-text-color);
    `, [c$1("&:hover, &:focus", `
        color: var(--n-link-text-color-hover);
      `), c$1("&:active", `
        color: var(--n-link-text-color-pressed);
      `)])])]);

    const anchorInjectionKey = createInjectionKey("n-anchor");
    const anchorLinkProps = {
      title: String,
      href: String
    };
    var Link = vue.defineComponent({
      name: "AnchorLink",
      props: anchorLinkProps,
      setup(props, { slots }) {
        const titleRef = vue.ref(null);
        const NAnchor = vue.inject(anchorInjectionKey);
        const hrefRef = vue.toRef(props, "href");
        const activeRef = useMemo(() => {
          return hrefRef.value && hrefRef.value === NAnchor.activeHref.value;
        });
        useInjectionCollection(anchorInjectionKey, "collectedLinkHrefs", hrefRef);
        useInjectionElementCollection(
          anchorInjectionKey,
          "titleEls",
          () => titleRef.value
        );
        vue.watch(activeRef, (value) => {
          if (value && titleRef.value) {
            NAnchor.updateBarPosition(titleRef.value);
          }
        });
        function handleClick() {
          if (props.href !== void 0) {
            NAnchor.setActiveHref(props.href);
          }
        }
        return () => {
          const { value: mergedClsPrefix } = NAnchor.mergedClsPrefix;
          return /* @__PURE__ */ vue.h("div", {
            class: [
              `${mergedClsPrefix}-anchor-link`,
              activeRef.value && `${mergedClsPrefix}-anchor-link--active`
            ]
          }, /* @__PURE__ */ vue.h("a", {
            ref: titleRef,
            class: [`${mergedClsPrefix}-anchor-link__title`],
            href: props.href,
            title: getTitleAttribute(props.title),
            onClick: handleClick
          }, props.title), slots.default?.());
        };
      }
    });

    function getOffset(el, scrollTarget) {
      const {
        top: elTop,
        height
      } = el.getBoundingClientRect();
      const scrollTargetTop = scrollTarget instanceof HTMLElement ? scrollTarget.getBoundingClientRect().top : 0;
      return {
        top: elTop - scrollTargetTop,
        height
      };
    }

    const baseAnchorProps = {
      type: {
        type: String,
        default: "rail"
      },
      showRail: {
        type: Boolean,
        default: true
      },
      showBackground: {
        type: Boolean,
        default: true
      },
      bound: {
        type: Number,
        default: 12
      },
      internalScrollable: Boolean,
      ignoreGap: Boolean,
      offsetTarget: [String, Object, Function]
    };
    const baseAnchorPropKeys = keysOf(baseAnchorProps);
    var NBaseAnchor = vue.defineComponent({
      name: "BaseAnchor",
      props: {
        ...baseAnchorProps,
        mergedClsPrefix: {
          type: String,
          required: true
        }
      },
      setup(props) {
        const collectedLinkHrefs = [];
        const titleEls = [];
        const activeHrefRef = vue.ref(null);
        const slotRef = vue.ref(null);
        const barRef = vue.ref(null);
        const selfRef = vue.ref(null);
        const isBlockTypeRef = vue.computed(() => {
          return props.type === "block";
        });
        const mergedShowRailRef = vue.computed(() => {
          return !isBlockTypeRef.value && props.showRail;
        });
        function disableTransitionOneTick() {
          const { value: barEl } = barRef;
          const { value: slotEl } = slotRef;
          if (barEl) {
            barEl.style.transition = "none";
          }
          if (slotEl) {
            slotEl.style.transition = "none";
          }
          if (titleEls) {
            titleEls.forEach((titleEl) => {
              titleEl.style.transition = "none";
            });
          }
          void vue.nextTick(() => {
            const { value: nextBarEl } = barRef;
            const { value: nextSlotEl } = slotRef;
            if (nextBarEl) {
              void nextBarEl.offsetWidth;
              nextBarEl.style.transition = "";
            }
            if (nextSlotEl) {
              void nextSlotEl.offsetWidth;
              nextSlotEl.style.transition = "";
            }
            if (titleEls) {
              titleEls.forEach((titleEl) => {
                void titleEl.offsetWidth;
                titleEl.style.transition = "";
              });
            }
          });
        }
        function updateBarPosition(linkTitleEl, transition = true) {
          const { value: barEl } = barRef;
          const { value: slotEl } = slotRef;
          const { value: selfEl } = selfRef;
          if (!selfEl || !barEl)
            return;
          if (!transition) {
            barEl.style.transition = "none";
            if (slotEl)
              slotEl.style.transition = "none";
          }
          const { offsetHeight, offsetWidth } = linkTitleEl;
          const { top: linkTitleClientTop, left: linkTitleClientLeft } = linkTitleEl.getBoundingClientRect();
          const { top: anchorClientTop, left: anchorClientLeft } = selfEl.getBoundingClientRect();
          const offsetTop = linkTitleClientTop - anchorClientTop;
          const offsetLeft = linkTitleClientLeft - anchorClientLeft;
          barEl.style.top = `${offsetTop}px`;
          barEl.style.height = `${offsetHeight}px`;
          if (slotEl) {
            slotEl.style.top = `${offsetTop}px`;
            slotEl.style.height = `${offsetHeight}px`;
            slotEl.style.maxWidth = `${offsetWidth + offsetLeft}px`;
          }
          void barEl.offsetHeight;
          if (slotEl)
            void slotEl.offsetHeight;
          if (!transition) {
            barEl.style.transition = "";
            if (slotEl)
              slotEl.style.transition = "";
          }
        }
        function setActiveHref(href, transition = true) {
          const idMatchResult = /^#([^#]+)$/.exec(href);
          if (!idMatchResult)
            return;
          const linkEl = document.getElementById(idMatchResult[1]);
          if (!linkEl)
            return;
          activeHrefRef.value = href;
          linkEl.scrollIntoView();
          if (!transition) {
            disableTransitionOneTick();
          }
          handleScroll();
        }
        const handleScroll = lodash.exports.throttle(() => _handleScroll(true), 128);
        function _handleScroll(transition = true) {
          const links = [];
          const offsetTarget = unwrapElement(props.offsetTarget ?? document);
          collectedLinkHrefs.forEach((href) => {
            const idMatchResult = /#([^#]+)$/.exec(href);
            if (!idMatchResult)
              return;
            const linkEl = document.getElementById(idMatchResult[1]);
            if (linkEl && offsetTarget) {
              const { top, height } = getOffset(linkEl, offsetTarget);
              links.push({
                top,
                height,
                href
              });
            }
          });
          links.sort((a, b) => {
            if (a.top > b.top) {
              return 1;
            } else if (a.top === b.top && a.height < b.height) {
              return -1;
            }
            return -1;
          });
          const currentActiveHref = activeHrefRef.value;
          const { bound, ignoreGap } = props;
          const activeLink = links.reduce((prevLink, link) => {
            if (link.top + link.height < 0) {
              if (ignoreGap) {
                return link;
              } else {
                return prevLink;
              }
            }
            if (link.top <= bound) {
              if (prevLink === null) {
                return link;
              } else if (link.top === prevLink.top) {
                if (link.href === currentActiveHref) {
                  return link;
                } else
                  return prevLink;
              } else if (link.top > prevLink.top) {
                return link;
              } else {
                return prevLink;
              }
            }
            return prevLink;
          }, null);
          if (!transition)
            disableTransitionOneTick();
          if (activeLink) {
            activeHrefRef.value = activeLink.href;
          } else {
            activeHrefRef.value = null;
          }
        }
        vue.provide(anchorInjectionKey, {
          activeHref: activeHrefRef,
          mergedClsPrefix: vue.toRef(props, "mergedClsPrefix"),
          updateBarPosition,
          setActiveHref,
          collectedLinkHrefs,
          titleEls
        });
        vue.onMounted(() => {
          document.addEventListener("scroll", handleScroll, true);
          setActiveHref(window.location.hash);
          _handleScroll(false);
        });
        onFontsReady(() => {
          setActiveHref(window.location.hash);
          _handleScroll(false);
        });
        vue.onBeforeUnmount(() => {
          document.removeEventListener("scroll", handleScroll, true);
        });
        vue.watch(activeHrefRef, (value) => {
          if (value === null) {
            const { value: slotEl } = slotRef;
            if (slotEl && !isBlockTypeRef.value) {
              slotEl.style.maxWidth = "0";
            }
          }
        });
        return {
          selfRef,
          barRef,
          slotRef,
          setActiveHref,
          activeHref: activeHrefRef,
          isBlockType: isBlockTypeRef,
          mergedShowRail: mergedShowRailRef
        };
      },
      render() {
        const { mergedClsPrefix, mergedShowRail, isBlockType, $slots } = this;
        const Anchor = /* @__PURE__ */ vue.h("div", {
          class: [
            `${mergedClsPrefix}-anchor`,
            isBlockType && `${mergedClsPrefix}-anchor--block`,
            mergedShowRail && `${mergedClsPrefix}-anchor--show-rail`
          ],
          ref: "selfRef"
        }, mergedShowRail && this.showBackground ? /* @__PURE__ */ vue.h("div", {
          ref: "slotRef",
          class: `${mergedClsPrefix}-anchor-link-background`
        }) : null, mergedShowRail ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-anchor-rail`
        }, /* @__PURE__ */ vue.h("div", {
          ref: "barRef",
          class: [
            `${mergedClsPrefix}-anchor-rail__bar`,
            this.activeHref !== null && `${mergedClsPrefix}-anchor-rail__bar--active`
          ]
        })) : null, $slots.default?.());
        return this.internalScrollable ? /* @__PURE__ */ vue.h(NScrollbar, null, {
          default: () => Anchor
        }) : Anchor;
      }
    });

    const anchorProps = {
      ...useTheme.props,
      affix: Boolean,
      ...affixProps,
      ...baseAnchorProps
    };
    var AnchorAdapter = vue.defineComponent({
      name: "Anchor",
      props: anchorProps,
      setup(props, { slots }) {
        const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
        const themeRef = useTheme(
          "Anchor",
          "-anchor",
          style$1k,
          anchorLight$1,
          props,
          mergedClsPrefixRef
        );
        const anchorRef = vue.ref(null);
        const cssVarsRef = vue.computed(() => {
          const {
            self: {
              railColor,
              linkColor,
              railColorActive,
              linkTextColor,
              linkTextColorHover,
              linkTextColorPressed,
              linkTextColorActive,
              linkFontSize,
              railWidth,
              linkPadding,
              borderRadius
            },
            common: { cubicBezierEaseInOut }
          } = themeRef.value;
          return {
            "--n-link-border-radius": borderRadius,
            "--n-link-color": linkColor,
            "--n-link-font-size": linkFontSize,
            "--n-link-text-color": linkTextColor,
            "--n-link-text-color-hover": linkTextColorHover,
            "--n-link-text-color-active": linkTextColorActive,
            "--n-link-text-color-pressed": linkTextColorPressed,
            "--n-link-padding": linkPadding,
            "--n-bezier": cubicBezierEaseInOut,
            "--n-rail-color": railColor,
            "--n-rail-color-active": railColorActive,
            "--n-rail-width": railWidth
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("anchor", void 0, cssVarsRef, props) : void 0;
        return {
          scrollTo(href) {
            anchorRef.value?.setActiveHref(href);
          },
          renderAnchor: () => {
            themeClassHandle?.onRender();
            return /* @__PURE__ */ vue.h(NBaseAnchor, {
              ref: anchorRef,
              style: inlineThemeDisabled ? void 0 : cssVarsRef.value,
              class: themeClassHandle?.themeClass.value,
              ...keep(props, baseAnchorPropKeys),
              mergedClsPrefix: mergedClsPrefixRef.value
            }, slots);
          }
        };
      },
      render() {
        return !this.affix ? this.renderAnchor() : /* @__PURE__ */ vue.h(NAffix, {
          ...keep(this, affixPropKeys)
        }, { default: this.renderAnchor });
      }
    });

    function getIsGroup(option) {
      return option.type === "group";
    }
    function getIgnored(option) {
      return option.type === "ignored";
    }
    function patternMatched(pattern, value) {
      try {
        return !!(1 + value.toString().toLowerCase().indexOf(pattern.trim().toLowerCase()));
      } catch (err) {
        return false;
      }
    }
    function createTmOptions(valueField, childrenField) {
      const options = {
        getIsGroup,
        getIgnored,

        getKey(option) {
          if (getIsGroup(option)) {
            return option.name || option.key || "key-required";
          }

          return option[valueField];
        },

        getChildren(option) {
          return option[childrenField];
        }

      };
      return options;
    }
    function filterOptions(originalOpts, filter, pattern, childrenField) {
      if (!filter) return originalOpts;

      function traverse(options) {
        if (!Array.isArray(options)) return [];
        const filteredOptions = [];

        for (const option of options) {
          if (getIsGroup(option)) {
            const children = traverse(option[childrenField]);

            if (children.length) {
              filteredOptions.push(Object.assign({}, option, {
                [childrenField]: children
              }));
            }
          } else if (getIgnored(option)) {
            continue;
          } else if (filter(pattern, option)) {
            filteredOptions.push(option);
          }
        }

        return filteredOptions;
      }

      return traverse(originalOpts);
    }
    function createValOptMap(options, valueField, childrenField) {
      const valOptMap = /* @__PURE__ */new Map();
      options.forEach(option => {
        if (getIsGroup(option)) {
          option[childrenField].forEach(selectGroupOption => {
            valOptMap.set(selectGroupOption[valueField], selectGroupOption);
          });
        } else {
          valOptMap.set(option[valueField], option);
        }
      });
      return valOptMap;
    }

    const isChrome = isBrowser$2 && "chrome" in window;
    isBrowser$2 && navigator.userAgent.includes("Firefox");
    const isSafari = isBrowser$2 && navigator.userAgent.includes("Safari") && !isChrome;

    var commonVariables$i = {
      paddingTiny: "0 8px",
      paddingSmall: "0 10px",
      paddingMedium: "0 12px",
      paddingLarge: "0 14px",
      clearSize: "16px"
    };

    const inputDark = {
      name: "Input",
      common: commonDark,

      self(vars) {
        const {
          textColor2,
          textColor3,
          textColorDisabled,
          primaryColor,
          primaryColorHover,
          inputColor,
          inputColorDisabled,
          warningColor,
          warningColorHover,
          errorColor,
          errorColorHover,
          borderRadius,
          lineHeight,
          fontSizeTiny,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          heightTiny,
          heightSmall,
          heightMedium,
          heightLarge,
          clearColor,
          clearColorHover,
          clearColorPressed,
          placeholderColor,
          placeholderColorDisabled,
          iconColor,
          iconColorDisabled,
          iconColorHover,
          iconColorPressed
        } = vars;
        return { ...commonVariables$i,
          countTextColorDisabled: textColorDisabled,
          countTextColor: textColor3,
          heightTiny,
          heightSmall,
          heightMedium,
          heightLarge,
          fontSizeTiny,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          lineHeight,
          lineHeightTextarea: lineHeight,
          borderRadius,
          iconSize: "16px",
          groupLabelColor: inputColor,
          textColor: textColor2,
          textColorDisabled,
          textDecorationColor: textColor2,
          groupLabelTextColor: textColor2,
          caretColor: primaryColor,
          placeholderColor,
          placeholderColorDisabled,
          color: inputColor,
          colorDisabled: inputColorDisabled,
          colorFocus: changeColor(primaryColor, {
            alpha: 0.1
          }),
          groupLabelBorder: "1px solid #0000",
          border: "1px solid #0000",
          borderHover: `1px solid ${primaryColorHover}`,
          borderDisabled: "1px solid #0000",
          borderFocus: `1px solid ${primaryColorHover}`,
          boxShadowFocus: `0 0 8px 0 ${changeColor(primaryColor, {
        alpha: 0.3
      })}`,
          loadingColor: primaryColor,
          loadingColorWarning: warningColor,
          borderWarning: `1px solid ${warningColor}`,
          borderHoverWarning: `1px solid ${warningColorHover}`,
          colorFocusWarning: changeColor(warningColor, {
            alpha: 0.1
          }),
          borderFocusWarning: `1px solid ${warningColorHover}`,
          boxShadowFocusWarning: `0 0 8px 0 ${changeColor(warningColor, {
        alpha: 0.3
      })}`,
          caretColorWarning: warningColor,
          loadingColorError: errorColor,
          borderError: `1px solid ${errorColor}`,
          borderHoverError: `1px solid ${errorColorHover}`,
          colorFocusError: changeColor(errorColor, {
            alpha: 0.1
          }),
          borderFocusError: `1px solid ${errorColorHover}`,
          boxShadowFocusError: `0 0 8px 0 ${changeColor(errorColor, {
        alpha: 0.3
      })}`,
          caretColorError: errorColor,
          clearColor,
          clearColorHover,
          clearColorPressed,
          iconColor,
          iconColorDisabled,
          iconColorHover,
          iconColorPressed,
          suffixTextColor: textColor2
        };
      }

    };
    var inputDark$1 = inputDark;

    const self$13 = vars => {
      const {
        textColor2,
        textColor3,
        textColorDisabled,
        primaryColor,
        primaryColorHover,
        inputColor,
        inputColorDisabled,
        borderColor,
        warningColor,
        warningColorHover,
        errorColor,
        errorColorHover,
        borderRadius,
        lineHeight,
        fontSizeTiny,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        heightTiny,
        heightSmall,
        heightMedium,
        heightLarge,
        actionColor,
        clearColor,
        clearColorHover,
        clearColorPressed,
        placeholderColor,
        placeholderColorDisabled,
        iconColor,
        iconColorDisabled,
        iconColorHover,
        iconColorPressed
      } = vars;
      return { ...commonVariables$i,
        countTextColorDisabled: textColorDisabled,
        countTextColor: textColor3,
        heightTiny,
        heightSmall,
        heightMedium,
        heightLarge,
        fontSizeTiny,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        lineHeight,
        lineHeightTextarea: lineHeight,
        borderRadius,
        iconSize: "16px",
        groupLabelColor: actionColor,
        groupLabelTextColor: textColor2,
        textColor: textColor2,
        textColorDisabled,
        textDecorationColor: textColor2,
        caretColor: primaryColor,
        placeholderColor,
        placeholderColorDisabled,
        color: inputColor,
        colorDisabled: inputColorDisabled,
        colorFocus: inputColor,
        groupLabelBorder: `1px solid ${borderColor}`,
        border: `1px solid ${borderColor}`,
        borderHover: `1px solid ${primaryColorHover}`,
        borderDisabled: `1px solid ${borderColor}`,
        borderFocus: `1px solid ${primaryColorHover}`,
        boxShadowFocus: `0 0 0 2px ${changeColor(primaryColor, {
      alpha: 0.2
    })}`,
        loadingColor: primaryColor,
        loadingColorWarning: warningColor,
        borderWarning: `1px solid ${warningColor}`,
        borderHoverWarning: `1px solid ${warningColorHover}`,
        colorFocusWarning: inputColor,
        borderFocusWarning: `1px solid ${warningColorHover}`,
        boxShadowFocusWarning: `0 0 0 2px ${changeColor(warningColor, {
      alpha: 0.2
    })}`,
        caretColorWarning: warningColor,
        loadingColorError: errorColor,
        borderError: `1px solid ${errorColor}`,
        borderHoverError: `1px solid ${errorColorHover}`,
        colorFocusError: inputColor,
        borderFocusError: `1px solid ${errorColorHover}`,
        boxShadowFocusError: `0 0 0 2px ${changeColor(errorColor, {
      alpha: 0.2
    })}`,
        caretColorError: errorColor,
        clearColor,
        clearColorHover,
        clearColorPressed,
        iconColor,
        iconColorDisabled,
        iconColorHover,
        iconColorPressed,
        suffixTextColor: textColor2
      };
    };

    const inputLight = {
      name: "Input",
      common: commonLight,
      self: self$13
    };
    var inputLight$1 = inputLight;

    var rtlStyle$o = cB("input", [cM("rtl", `
    direction: rtl;
  `, [cE("prefix", {
      marginRight: 0,
      marginLeft: "4px"
    }), cE("suffix", {
      marginRight: "4px",
      marginLeft: 0
    }), cM("textarea", "width: 100%;", [cB("input-word-count", `
      left: var(--n-padding-right);
      right: unset;
    `)]), cB("input-word-count", `
      margin-left: 0;
      margin-right: 4px;
    `)])]);

    const inputRtl = {
      name: "Input",
      style: rtlStyle$o
    };

    const inputInjectionKey = createInjectionKey("n-input");

    function len(s) {
      let count = 0;

      for (const _ of s) {
        count++;
      }

      return count;
    }
    function isEmptyInputValue(value) {
      return value === "" || value == null;
    }
    function useCursor(inputElRef) {
      const selectionRef = vue.ref(null);

      function recordCursor() {
        const {
          value: input
        } = inputElRef;

        if (!input || !input.focus) {
          reset();
          return;
        }

        const {
          selectionStart,
          selectionEnd,
          value
        } = input;

        if (selectionStart == null || selectionEnd == null) {
          reset();
          return;
        }

        selectionRef.value = {
          start: selectionStart,
          end: selectionEnd,
          beforeText: value.slice(0, selectionStart),
          afterText: value.slice(selectionEnd)
        };
      }

      function restoreCursor() {
        var _inputEl$setSelection;

        const {
          value: selection
        } = selectionRef;
        const {
          value: inputEl
        } = inputElRef;

        if (!selection || !inputEl) {
          return;
        }

        const {
          value
        } = inputEl;
        const {
          start,
          beforeText,
          afterText
        } = selection;
        let startPos = value.length;

        if (value.endsWith(afterText)) {
          startPos = value.length - afterText.length;
        } else if (value.startsWith(beforeText)) {
          startPos = beforeText.length;
        } else {
          const beforeLastChar = beforeText[start - 1];
          const newIndex = value.indexOf(beforeLastChar, start - 1);

          if (newIndex !== -1) {
            startPos = newIndex + 1;
          }
        }

        (_inputEl$setSelection = inputEl.setSelectionRange) === null || _inputEl$setSelection === void 0 ? void 0 : _inputEl$setSelection.call(inputEl, startPos, startPos);
      }

      function reset() {
        selectionRef.value = null;
      }

      vue.watch(inputElRef, reset);
      return {
        recordCursor,
        restoreCursor
      };
    }

    var WordCount = vue.defineComponent({
      name: "InputWordCount",
      setup(_, { slots }) {
        const { mergedValueRef, maxlengthRef, mergedClsPrefixRef } = vue.inject(inputInjectionKey);
        const wordCountRef = vue.computed(() => {
          const { value: mergedValue } = mergedValueRef;
          if (mergedValue === null || Array.isArray(mergedValue))
            return 0;
          return len(mergedValue);
        });
        return () => {
          const { value: maxlength } = maxlengthRef;
          const { value: mergedValue } = mergedValueRef;
          return /* @__PURE__ */ vue.h("span", {
            class: `${mergedClsPrefixRef.value}-input-word-count`
          }, resolveSlotWithProps(
            slots.default,
            {
              value: mergedValue === null || Array.isArray(mergedValue) ? "" : mergedValue
            },
            () => [
              maxlength === void 0 ? wordCountRef.value : `${wordCountRef.value} / ${maxlength}`
            ]
          ));
        };
      }
    });

    var style$1j = cB("input", `
  max-width: 100%;
  cursor: text;
  line-height: 1.5;
  z-index: auto;
  outline: none;
  box-sizing: border-box;
  position: relative;
  display: inline-flex;
  border-radius: var(--n-border-radius);
  background-color: var(--n-color);
  transition: background-color .3s var(--n-bezier);
  font-size: var(--n-font-size);
  --n-padding-vertical: calc((var(--n-height) - 1.5 * var(--n-font-size)) / 2);
`, [cE("input, textarea", `
    overflow: hidden;
    flex-grow: 1;
    position: relative;
  `), cE("input-el, textarea-el, input-mirror, textarea-mirror, separator, placeholder", `
    box-sizing: border-box;
    font-size: inherit;
    line-height: 1.5;
    font-family: inherit;
    border: none;
    outline: none;
    background-color: #0000;
    text-align: inherit;
    transition:
      -webkit-text-fill-color .3s var(--n-bezier),
      caret-color .3s var(--n-bezier),
      color .3s var(--n-bezier),
      text-decoration-color .3s var(--n-bezier);
  `), cE("input-el, textarea-el", `
    -webkit-appearance: none;
    scrollbar-width: none;
    width: 100%;
    min-width: 0;
    text-decoration-color: var(--n-text-decoration-color);
    color: var(--n-text-color);
    caret-color: var(--n-caret-color);
    background-color: transparent;
  `, [c$1("&::-webkit-scrollbar, &::-webkit-scrollbar-track-piece, &::-webkit-scrollbar-thumb", `
      width: 0;
      height: 0;
      display: none;
    `), c$1("&::placeholder", `
      color: #0000;
      -webkit-text-fill-color: transparent !important;
    `), c$1("&:-webkit-autofill ~", [cE("placeholder", "display: none;")])]), cM("round", [cNotM("textarea", "border-radius: calc(var(--n-height) / 2);")]), cE("placeholder", `
    pointer-events: none;
    position: absolute;
    left: 0;
    right: 0;
    top: 0;
    bottom: 0;
    overflow: hidden;
    color: var(--n-placeholder-color);
  `, [c$1("span", `
      width: 100%;
      display: inline-block;
    `)]), cM("textarea", [cE("placeholder", "overflow: visible;")]), cNotM("autosize", "width: 100%;"), cM("autosize", [cE("textarea-el, input-el", `
      position: absolute;
      top: 0;
      left: 0;
      height: 100%;
    `)]), cB("input-wrapper", `
    overflow: hidden;
    display: inline-flex;
    flex-grow: 1;
    position: relative;
    padding-left: var(--n-padding-left);
    padding-right: var(--n-padding-right);
  `), cE("input-mirror", `
    padding: 0;
    height: var(--n-height);
    overflow: hidden;
    visibility: hidden;
    position: static;
    white-space: nowrap;
    pointer-events: none;
  `), cE("input-el", `
    padding: 0;
    height: var(--n-height);
    line-height: var(--n-height);
  `, [c$1("+", [cE("placeholder", `
        display: flex;
        align-items: center;
      `)])]), cNotM("textarea", [cE("placeholder", "white-space: nowrap;")]), cE("eye", `
    transition: color .3s var(--n-bezier);
  `), cM("textarea", "width: 100%;", [cB("input-word-count", `
      position: absolute;
      right: var(--n-padding-right);
      bottom: var(--n-padding-vertical);
    `), cM("resizable", [cB("input-wrapper", `
        resize: vertical;
        min-height: var(--n-height);
      `)]), cE("textarea-el, textarea-mirror, placeholder", `
      height: 100%;
      padding-left: 0;
      padding-right: 0;
      padding-top: var(--n-padding-vertical);
      padding-bottom: var(--n-padding-vertical);
      word-break: break-word;
      display: inline-block;
      vertical-align: bottom;
      box-sizing: border-box;
      line-height: var(--n-line-height-textarea);
      margin: 0;
      resize: none;
      white-space: pre-wrap;
    `), cE("textarea-mirror", `
      width: 100%;
      pointer-events: none;
      overflow: hidden;
      visibility: hidden;
      position: static;
      white-space: pre-wrap;
      overflow-wrap: break-word;
    `)]), cM("pair", [cE("input-el, placeholder", "text-align: center;"), cE("separator", `
      display: flex;
      align-items: center;
      transition: color .3s var(--n-bezier);
      color: var(--n-text-color);
      white-space: nowrap;
    `, [cB("icon", `
        color: var(--n-icon-color);
      `), cB("base-icon", `
        color: var(--n-icon-color);
      `)])]), cM("disabled", `
    cursor: not-allowed;
    background-color: var(--n-color-disabled);
  `, [cE("border", "border: var(--n-border-disabled);"), cE("input-el, textarea-el", `
      cursor: not-allowed;
      color: var(--n-text-color-disabled);
      text-decoration-color: var(--n-text-color-disabled);
    `), cE("placeholder", "color: var(--n-placeholder-color-disabled);"), cE("separator", "color: var(--n-text-color-disabled);", [cB("icon", `
        color: var(--n-icon-color-disabled);
      `), cB("base-icon", `
        color: var(--n-icon-color-disabled);
      `)]), cB("input-word-count", `
      color: var(--n-count-text-color-disabled);
    `), cE("suffix, prefix", "color: var(--n-text-color-disabled);", [cB("icon", `
        color: var(--n-icon-color-disabled);
      `), cB("internal-icon", `
        color: var(--n-icon-color-disabled);
      `)])]), cNotM("disabled", [cE("eye", `
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--n-icon-color);
      cursor: pointer;
    `, [c$1("&:hover", `
        color: var(--n-icon-color-hover);
      `), c$1("&:active", `
        color: var(--n-icon-color-pressed);
      `)]), c$1("&:hover", [cE("state-border", "border: var(--n-border-hover);")]), cM("focus", "background-color: var(--n-color-focus);", [cE("state-border", `
        border: var(--n-border-focus);
        box-shadow: var(--n-box-shadow-focus);
      `)])]), cE("border, state-border", `
    box-sizing: border-box;
    position: absolute;
    left: 0;
    right: 0;
    top: 0;
    bottom: 0;
    pointer-events: none;
    border-radius: inherit;
    border: var(--n-border);
    transition:
      box-shadow .3s var(--n-bezier),
      border-color .3s var(--n-bezier);
  `), cE("state-border", `
    border-color: #0000;
    z-index: 1;
  `), cE("prefix", "margin-right: 4px;"), cE("suffix", `
    margin-left: 4px;
  `), cE("suffix, prefix", `
    transition: color .3s var(--n-bezier);
    flex-wrap: nowrap;
    flex-shrink: 0;
    line-height: var(--n-height);
    white-space: nowrap;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    color: var(--n-suffix-text-color);
  `, [cB("base-loading", `
      font-size: var(--n-icon-size);
      margin: 0 2px;
      color: var(--n-loading-color);
    `), cB("base-clear", `
      font-size: var(--n-icon-size);
    `, [cE("placeholder", [cB("base-icon", `
          transition: color .3s var(--n-bezier);
          color: var(--n-icon-color);
          font-size: var(--n-icon-size);
        `)])]), c$1(">", [cB("icon", `
        transition: color .3s var(--n-bezier);
        color: var(--n-icon-color);
        font-size: var(--n-icon-size);
      `)]), cB("base-icon", `
      font-size: var(--n-icon-size);
    `)]), cB("input-word-count", `
    pointer-events: none;
    line-height: 1.5;
    font-size: .85em;
    color: var(--n-count-text-color);
    transition: color .3s var(--n-bezier);
    margin-left: 4px;
    font-variant: tabular-nums;
  `), ["warning", "error"].map(status => cM(`${status}-status`, [cNotM("disabled", [cB("base-loading", `
        color: var(--n-loading-color-${status})
      `), cE("input-el, textarea-el", `
        caret-color: var(--n-caret-color-${status});
      `), cE("state-border", `
        border: var(--n-border-${status});
      `), c$1("&:hover", [cE("state-border", `
          border: var(--n-border-hover-${status});
        `)]), c$1("&:focus", `
        background-color: var(--n-color-focus-${status});
      `, [cE("state-border", `
          box-shadow: var(--n-box-shadow-focus-${status});
          border: var(--n-border-focus-${status});
        `)]), cM("focus", `
        background-color: var(--n-color-focus-${status});
      `, [cE("state-border", `
          box-shadow: var(--n-box-shadow-focus-${status});
          border: var(--n-border-focus-${status});
        `)])])]))]);
    const safariStyle = cB("input", [cM("disabled", [cE("input-el, textarea-el", `
      -webkit-text-fill-color: var(--n-text-color-disabled);
    `)])]);

    const inputProps = {
      ...useTheme.props,
      bordered: {
        type: Boolean,
        default: void 0
      },
      type: {
        type: String,
        default: "text"
      },
      placeholder: [Array, String],
      defaultValue: {
        type: [String, Array],
        default: null
      },
      value: [String, Array],
      disabled: {
        type: Boolean,
        default: void 0
      },
      size: String,
      rows: {
        type: [Number, String],
        default: 3
      },
      round: Boolean,
      minlength: [String, Number],
      maxlength: [String, Number],
      clearable: Boolean,
      autosize: {
        type: [Boolean, Object],
        default: false
      },
      pair: Boolean,
      separator: String,
      readonly: {
        type: [String, Boolean],
        default: false
      },
      passivelyActivated: Boolean,
      showPasswordOn: String,
      stateful: {
        type: Boolean,
        default: true
      },
      autofocus: Boolean,
      inputProps: Object,
      resizable: {
        type: Boolean,
        default: true
      },
      showCount: Boolean,
      loading: {
        type: Boolean,
        default: void 0
      },
      allowInput: Function,
      renderCount: Function,
      onMousedown: Function,
      onKeydown: Function,
      onKeyup: Function,
      onInput: [Function, Array],
      onFocus: [Function, Array],
      onBlur: [Function, Array],
      onClick: [Function, Array],
      onChange: [Function, Array],
      onClear: [Function, Array],
      status: String,
      "onUpdate:value": [Function, Array],
      onUpdateValue: [Function, Array],
      textDecoration: [String, Array],
      attrSize: {
        type: Number,
        default: 20
      },
      onInputBlur: [Function, Array],
      onInputFocus: [Function, Array],
      onDeactivate: [Function, Array],
      onActivate: [Function, Array],
      onWrapperFocus: [Function, Array],
      onWrapperBlur: [Function, Array],
      internalDeactivateOnEnter: Boolean,
      internalForceFocus: Boolean,
      internalLoadingBeforeSuffix: Boolean,
      showPasswordToggle: Boolean
    };
    var NInput = vue.defineComponent({
      name: "Input",
      props: inputProps,
      setup(props) {
        {
          vue.watchEffect(() => {
            if (props.showPasswordToggle) {
              warnOnce(
                "input",
                '`show-password-toggle` is deprecated, please use `showPasswordOn="click"` instead'
              );
            }
          });
        }
        const {
          mergedClsPrefixRef,
          mergedBorderedRef,
          inlineThemeDisabled,
          mergedRtlRef
        } = useConfig(props);
        const themeRef = useTheme(
          "Input",
          "-input",
          style$1j,
          inputLight$1,
          props,
          mergedClsPrefixRef
        );
        if (isSafari) {
          useStyle("-input-safari", safariStyle, mergedClsPrefixRef);
        }
        const wrapperElRef = vue.ref(null);
        const textareaElRef = vue.ref(null);
        const textareaMirrorElRef = vue.ref(null);
        const inputMirrorElRef = vue.ref(null);
        const inputElRef = vue.ref(null);
        const inputEl2Ref = vue.ref(null);
        const currentFocusedInputRef = vue.ref(null);
        const focusedInputCursorControl = useCursor(currentFocusedInputRef);
        const textareaScrollbarInstRef = vue.ref(null);
        const { localeRef } = useLocale("Input");
        const uncontrolledValueRef = vue.ref(props.defaultValue);
        const controlledValueRef = vue.toRef(props, "value");
        const mergedValueRef = useMergedState(
          controlledValueRef,
          uncontrolledValueRef
        );
        const formItem = useFormItem(props);
        const { mergedSizeRef, mergedDisabledRef, mergedStatusRef } = formItem;
        const focusedRef = vue.ref(false);
        const hoverRef = vue.ref(false);
        const isComposingRef = vue.ref(false);
        const activatedRef = vue.ref(false);
        let syncSource = null;
        const mergedPlaceholderRef = vue.computed(() => {
          const { placeholder, pair } = props;
          if (pair) {
            if (Array.isArray(placeholder)) {
              return placeholder;
            } else if (placeholder === void 0) {
              return ["", ""];
            }
            return [placeholder, placeholder];
          } else if (placeholder === void 0) {
            return [localeRef.value.placeholder];
          } else {
            return [placeholder];
          }
        });
        const showPlaceholder1Ref = vue.computed(() => {
          const { value: isComposing } = isComposingRef;
          const { value: mergedValue } = mergedValueRef;
          const { value: mergedPlaceholder } = mergedPlaceholderRef;
          return !isComposing && (isEmptyInputValue(mergedValue) || Array.isArray(mergedValue) && isEmptyInputValue(mergedValue[0])) && mergedPlaceholder[0];
        });
        const showPlaceholder2Ref = vue.computed(() => {
          const { value: isComposing } = isComposingRef;
          const { value: mergedValue } = mergedValueRef;
          const { value: mergedPlaceholder } = mergedPlaceholderRef;
          return !isComposing && mergedPlaceholder[1] && (isEmptyInputValue(mergedValue) || Array.isArray(mergedValue) && isEmptyInputValue(mergedValue[1]));
        });
        const mergedFocusRef = useMemo(() => {
          return props.internalForceFocus || focusedRef.value;
        });
        const showClearButton = useMemo(() => {
          if (mergedDisabledRef.value || props.readonly || !props.clearable || !mergedFocusRef.value && !hoverRef.value) {
            return false;
          }
          const { value: mergedValue } = mergedValueRef;
          const { value: mergedFocus } = mergedFocusRef;
          if (props.pair) {
            return !!(Array.isArray(mergedValue) && (mergedValue[0] || mergedValue[1])) && (hoverRef.value || mergedFocus);
          } else {
            return !!mergedValue && (hoverRef.value || mergedFocus);
          }
        });
        const mergedShowPasswordOnRef = vue.computed(() => {
          const { showPasswordOn } = props;
          if (showPasswordOn) {
            return showPasswordOn;
          }
          if (props.showPasswordToggle)
            return "click";
          return void 0;
        });
        const passwordVisibleRef = vue.ref(false);
        const textDecorationStyleRef = vue.computed(() => {
          const { textDecoration } = props;
          if (!textDecoration)
            return ["", ""];
          if (Array.isArray(textDecoration)) {
            return textDecoration.map((v) => ({
              textDecoration: v
            }));
          }
          return [
            {
              textDecoration
            }
          ];
        });
        const textAreaScrollContainerWidthRef = vue.ref(void 0);
        const updateTextAreaStyle = () => {
          if (props.type === "textarea") {
            const { autosize } = props;
            if (autosize) {
              textAreaScrollContainerWidthRef.value = textareaScrollbarInstRef.value?.$el?.offsetWidth;
            }
            if (!textareaElRef.value)
              return;
            if (typeof autosize === "boolean")
              return;
            const {
              paddingTop: stylePaddingTop,
              paddingBottom: stylePaddingBottom,
              lineHeight: styleLineHeight
            } = window.getComputedStyle(textareaElRef.value);
            const paddingTop = Number(stylePaddingTop.slice(0, -2));
            const paddingBottom = Number(stylePaddingBottom.slice(0, -2));
            const lineHeight = Number(styleLineHeight.slice(0, -2));
            const { value: textareaMirrorEl } = textareaMirrorElRef;
            if (!textareaMirrorEl)
              return;
            if (autosize.minRows) {
              const minRows = Math.max(autosize.minRows, 1);
              const styleMinHeight = `${paddingTop + paddingBottom + lineHeight * minRows}px`;
              textareaMirrorEl.style.minHeight = styleMinHeight;
            }
            if (autosize.maxRows) {
              const styleMaxHeight = `${paddingTop + paddingBottom + lineHeight * autosize.maxRows}px`;
              textareaMirrorEl.style.maxHeight = styleMaxHeight;
            }
          }
        };
        const maxlengthRef = vue.computed(() => {
          const { maxlength } = props;
          return maxlength === void 0 ? void 0 : Number(maxlength);
        });
        vue.onMounted(() => {
          const { value } = mergedValueRef;
          if (!Array.isArray(value)) {
            syncMirror(value);
          }
        });
        const vm = vue.getCurrentInstance().proxy;
        function doUpdateValue(value) {
          const { onUpdateValue, "onUpdate:value": _onUpdateValue, onInput } = props;
          const { nTriggerFormInput } = formItem;
          if (onUpdateValue)
            call(onUpdateValue, value);
          if (_onUpdateValue)
            call(_onUpdateValue, value);
          if (onInput)
            call(onInput, value);
          uncontrolledValueRef.value = value;
          nTriggerFormInput();
        }
        function doChange(value) {
          const { onChange } = props;
          const { nTriggerFormChange } = formItem;
          if (onChange)
            call(onChange, value);
          uncontrolledValueRef.value = value;
          nTriggerFormChange();
        }
        function doBlur(e) {
          const { onBlur } = props;
          const { nTriggerFormBlur } = formItem;
          if (onBlur)
            call(onBlur, e);
          nTriggerFormBlur();
        }
        function doFocus(e) {
          const { onFocus } = props;
          const { nTriggerFormFocus } = formItem;
          if (onFocus)
            call(onFocus, e);
          nTriggerFormFocus();
        }
        function doClear(e) {
          const { onClear } = props;
          if (onClear)
            call(onClear, e);
        }
        function doUpdateValueBlur(e) {
          const { onInputBlur } = props;
          if (onInputBlur)
            call(onInputBlur, e);
        }
        function doUpdateValueFocus(e) {
          const { onInputFocus } = props;
          if (onInputFocus)
            call(onInputFocus, e);
        }
        function doDeactivate() {
          const { onDeactivate } = props;
          if (onDeactivate)
            call(onDeactivate);
        }
        function doActivate() {
          const { onActivate } = props;
          if (onActivate)
            call(onActivate);
        }
        function doClick(e) {
          const { onClick } = props;
          if (onClick)
            call(onClick, e);
        }
        function doWrapperFocus(e) {
          const { onWrapperFocus } = props;
          if (onWrapperFocus)
            call(onWrapperFocus, e);
        }
        function doWrapperBlur(e) {
          const { onWrapperBlur } = props;
          if (onWrapperBlur)
            call(onWrapperBlur, e);
        }
        function handleCompositionStart() {
          isComposingRef.value = true;
        }
        function handleCompositionEnd(e) {
          isComposingRef.value = false;
          if (e.target === inputEl2Ref.value) {
            handleInput(e, 1);
          } else {
            handleInput(e, 0);
          }
        }
        function handleInput(e, index = 0, event = "input") {
          const targetValue = e.target.value;
          syncMirror(targetValue);
          if (e instanceof InputEvent && !e.isComposing) {
            isComposingRef.value = false;
          }
          if (props.type === "textarea") {
            const { value: textareaScrollbarInst } = textareaScrollbarInstRef;
            if (textareaScrollbarInst) {
              textareaScrollbarInst.syncUnifiedContainer();
            }
          }
          syncSource = targetValue;
          if (isComposingRef.value)
            return;
          focusedInputCursorControl.recordCursor();
          const isIncomingValueValid = allowInput(targetValue);
          if (isIncomingValueValid) {
            if (!props.pair) {
              event === "input" ? doUpdateValue(targetValue) : doChange(targetValue);
            } else {
              let { value } = mergedValueRef;
              if (!Array.isArray(value)) {
                value = ["", ""];
              } else {
                value = [value[0], value[1]];
              }
              value[index] = targetValue;
              event === "input" ? doUpdateValue(value) : doChange(value);
            }
          }
          vm.$forceUpdate();
          if (!isIncomingValueValid) {
            void vue.nextTick(focusedInputCursorControl.restoreCursor);
          }
        }
        function allowInput(value) {
          const { allowInput: allowInput2 } = props;
          if (typeof allowInput2 === "function") {
            return allowInput2(value);
          }
          return true;
        }
        function handleInputBlur(e) {
          doUpdateValueBlur(e);
          if (e.relatedTarget === wrapperElRef.value) {
            doDeactivate();
          }
          if (!(e.relatedTarget !== null && (e.relatedTarget === inputElRef.value || e.relatedTarget === inputEl2Ref.value || e.relatedTarget === textareaElRef.value))) {
            activatedRef.value = false;
          }
          dealWithEvent(e, "blur");
          currentFocusedInputRef.value = null;
        }
        function handleInputFocus(e, index) {
          doUpdateValueFocus(e);
          focusedRef.value = true;
          activatedRef.value = true;
          doActivate();
          dealWithEvent(e, "focus");
          if (index === 0) {
            currentFocusedInputRef.value = inputElRef.value;
          } else if (index === 1) {
            currentFocusedInputRef.value = inputEl2Ref.value;
          } else if (index === 2) {
            currentFocusedInputRef.value = textareaElRef.value;
          }
        }
        function handleWrapperBlur(e) {
          if (props.passivelyActivated) {
            doWrapperBlur(e);
            dealWithEvent(e, "blur");
          }
        }
        function handleWrapperFocus(e) {
          if (props.passivelyActivated) {
            focusedRef.value = true;
            doWrapperFocus(e);
            dealWithEvent(e, "focus");
          }
        }
        function dealWithEvent(e, type) {
          if (e.relatedTarget !== null && (e.relatedTarget === inputElRef.value || e.relatedTarget === inputEl2Ref.value || e.relatedTarget === textareaElRef.value || e.relatedTarget === wrapperElRef.value)) ; else {
            if (type === "focus") {
              doFocus(e);
              focusedRef.value = true;
            } else if (type === "blur") {
              doBlur(e);
              focusedRef.value = false;
            }
          }
        }
        function handleChange(e, index) {
          handleInput(e, index, "change");
        }
        function handleClick(e) {
          doClick(e);
        }
        function handleClear(e) {
          doClear(e);
          if (props.pair) {
            doUpdateValue(["", ""]);
            doChange(["", ""]);
          } else {
            doUpdateValue("");
            doChange("");
          }
        }
        function handleMouseDown(e) {
          const { onMousedown } = props;
          if (onMousedown)
            onMousedown(e);
          const { tagName } = e.target;
          if (tagName !== "INPUT" && tagName !== "TEXTAREA") {
            if (props.resizable) {
              const { value: wrapperEl } = wrapperElRef;
              if (wrapperEl) {
                const { left, top, width, height } = wrapperEl.getBoundingClientRect();
                const resizeHandleSize = 14;
                if (left + width - resizeHandleSize < e.clientX && e.clientX < left + width && top + height - resizeHandleSize < e.clientY && e.clientY < top + height) {
                  return;
                }
              }
            }
            e.preventDefault();
            if (!focusedRef.value) {
              focus();
            }
          }
        }
        function handleMouseEnter() {
          hoverRef.value = true;
          if (props.type === "textarea") {
            textareaScrollbarInstRef.value?.handleMouseEnterWrapper();
          }
        }
        function handleMouseLeave() {
          hoverRef.value = false;
          if (props.type === "textarea") {
            textareaScrollbarInstRef.value?.handleMouseLeaveWrapper();
          }
        }
        function handlePasswordToggleClick() {
          if (mergedDisabledRef.value)
            return;
          if (mergedShowPasswordOnRef.value !== "click")
            return;
          passwordVisibleRef.value = !passwordVisibleRef.value;
        }
        function handlePasswordToggleMousedown(e) {
          if (mergedDisabledRef.value)
            return;
          e.preventDefault();
          const preventDefaultOnce = (e2) => {
            e2.preventDefault();
            off("mouseup", document, preventDefaultOnce);
          };
          on("mouseup", document, preventDefaultOnce);
          if (mergedShowPasswordOnRef.value !== "mousedown")
            return;
          passwordVisibleRef.value = true;
          const hidePassword = () => {
            passwordVisibleRef.value = false;
            off("mouseup", document, hidePassword);
          };
          on("mouseup", document, hidePassword);
        }
        function handleWrapperKeydown(e) {
          props.onKeydown?.(e);
          switch (e.key) {
            case "Escape":
              handleWrapperKeydownEsc();
              break;
            case "Enter":
              handleWrapperKeydownEnter(e);
              break;
          }
        }
        function handleWrapperKeydownEnter(e) {
          if (props.passivelyActivated) {
            const { value: focused } = activatedRef;
            if (focused) {
              if (props.internalDeactivateOnEnter) {
                handleWrapperKeydownEsc();
              }
              return;
            }
            e.preventDefault();
            if (props.type === "textarea") {
              textareaElRef.value?.focus();
            } else {
              inputElRef.value?.focus();
            }
          }
        }
        function handleWrapperKeydownEsc() {
          if (props.passivelyActivated) {
            activatedRef.value = false;
            void vue.nextTick(() => {
              wrapperElRef.value?.focus();
            });
          }
        }
        function focus() {
          if (mergedDisabledRef.value)
            return;
          if (props.passivelyActivated) {
            wrapperElRef.value?.focus();
          } else {
            textareaElRef.value?.focus();
            inputElRef.value?.focus();
          }
        }
        function blur() {
          if (wrapperElRef.value?.contains(document.activeElement)) {
            document.activeElement.blur();
          }
        }
        function select() {
          textareaElRef.value?.select();
          inputElRef.value?.select();
        }
        function activate() {
          if (mergedDisabledRef.value)
            return;
          if (textareaElRef.value)
            textareaElRef.value.focus();
          else if (inputElRef.value)
            inputElRef.value.focus();
        }
        function deactivate() {
          const { value: wrapperEl } = wrapperElRef;
          if (wrapperEl?.contains(document.activeElement) && wrapperEl !== document.activeElement) {
            handleWrapperKeydownEsc();
          }
        }
        function scrollTo(options) {
          if (props.type === "textarea") {
            const { value: textareaEl } = textareaElRef;
            textareaEl?.scrollTo(options);
          } else {
            const { value: inputEl } = inputElRef;
            inputEl?.scrollTo(options);
          }
        }
        function syncMirror(value) {
          const { type, pair, autosize } = props;
          if (!pair && autosize) {
            if (type === "textarea") {
              const { value: textareaMirrorEl } = textareaMirrorElRef;
              if (textareaMirrorEl) {
                textareaMirrorEl.textContent = (value ?? "") + "\r\n";
              }
            } else {
              const { value: inputMirrorEl } = inputMirrorElRef;
              if (inputMirrorEl) {
                if (value) {
                  inputMirrorEl.textContent = value;
                } else {
                  inputMirrorEl.innerHTML = "&nbsp;";
                }
              }
            }
          }
        }
        function handleTextAreaMirrorResize() {
          updateTextAreaStyle();
        }
        const placeholderStyleRef = vue.ref({
          top: "0"
        });
        function handleTextAreaScroll(e) {
          const { scrollTop } = e.target;
          placeholderStyleRef.value.top = `${-scrollTop}px`;
          textareaScrollbarInstRef.value?.syncUnifiedContainer();
        }
        let stopWatchMergedValue1 = null;
        vue.watchEffect(() => {
          const { autosize, type } = props;
          if (autosize && type === "textarea") {
            stopWatchMergedValue1 = vue.watch(mergedValueRef, (value) => {
              if (!Array.isArray(value) && value !== syncSource) {
                syncMirror(value);
              }
            });
          } else {
            stopWatchMergedValue1?.();
          }
        });
        let stopWatchMergedValue2 = null;
        vue.watchEffect(() => {
          if (props.type === "textarea") {
            stopWatchMergedValue2 = vue.watch(mergedValueRef, (value) => {
              if (!Array.isArray(value) && value !== syncSource) {
                textareaScrollbarInstRef.value?.syncUnifiedContainer();
              }
            });
          } else {
            stopWatchMergedValue2?.();
          }
        });
        vue.provide(inputInjectionKey, {
          mergedValueRef,
          maxlengthRef,
          mergedClsPrefixRef
        });
        const exposedProps = {
          wrapperElRef,
          inputElRef,
          textareaElRef,
          isCompositing: isComposingRef,
          focus,
          blur,
          select,
          deactivate,
          activate,
          scrollTo
        };
        const rtlEnabledRef = useRtl("Input", mergedRtlRef, mergedClsPrefixRef);
        const cssVarsRef = vue.computed(() => {
          const { value: size } = mergedSizeRef;
          const {
            common: { cubicBezierEaseInOut },
            self: {
              color,
              borderRadius,
              textColor,
              caretColor,
              caretColorError,
              caretColorWarning,
              textDecorationColor,
              border,
              borderDisabled,
              borderHover,
              borderFocus,
              placeholderColor,
              placeholderColorDisabled,
              lineHeightTextarea,
              colorDisabled,
              colorFocus,
              textColorDisabled,
              boxShadowFocus,
              iconSize,
              colorFocusWarning,
              boxShadowFocusWarning,
              borderWarning,
              borderFocusWarning,
              borderHoverWarning,
              colorFocusError,
              boxShadowFocusError,
              borderError,
              borderFocusError,
              borderHoverError,
              clearSize,
              clearColor,
              clearColorHover,
              clearColorPressed,
              iconColor,
              iconColorDisabled,
              suffixTextColor,
              countTextColor,
              countTextColorDisabled,
              iconColorHover,
              iconColorPressed,
              loadingColor,
              loadingColorError,
              loadingColorWarning,
              [createKey("padding", size)]: padding,
              [createKey("fontSize", size)]: fontSize,
              [createKey("height", size)]: height
            }
          } = themeRef.value;
          const { left: paddingLeft, right: paddingRight } = getMargin(padding);
          return {
            "--n-bezier": cubicBezierEaseInOut,
            "--n-count-text-color": countTextColor,
            "--n-count-text-color-disabled": countTextColorDisabled,
            "--n-color": color,
            "--n-font-size": fontSize,
            "--n-border-radius": borderRadius,
            "--n-height": height,
            "--n-padding-left": paddingLeft,
            "--n-padding-right": paddingRight,
            "--n-text-color": textColor,
            "--n-caret-color": caretColor,
            "--n-text-decoration-color": textDecorationColor,
            "--n-border": border,
            "--n-border-disabled": borderDisabled,
            "--n-border-hover": borderHover,
            "--n-border-focus": borderFocus,
            "--n-placeholder-color": placeholderColor,
            "--n-placeholder-color-disabled": placeholderColorDisabled,
            "--n-icon-size": iconSize,
            "--n-line-height-textarea": lineHeightTextarea,
            "--n-color-disabled": colorDisabled,
            "--n-color-focus": colorFocus,
            "--n-text-color-disabled": textColorDisabled,
            "--n-box-shadow-focus": boxShadowFocus,
            "--n-loading-color": loadingColor,
            "--n-caret-color-warning": caretColorWarning,
            "--n-color-focus-warning": colorFocusWarning,
            "--n-box-shadow-focus-warning": boxShadowFocusWarning,
            "--n-border-warning": borderWarning,
            "--n-border-focus-warning": borderFocusWarning,
            "--n-border-hover-warning": borderHoverWarning,
            "--n-loading-color-warning": loadingColorWarning,
            "--n-caret-color-error": caretColorError,
            "--n-color-focus-error": colorFocusError,
            "--n-box-shadow-focus-error": boxShadowFocusError,
            "--n-border-error": borderError,
            "--n-border-focus-error": borderFocusError,
            "--n-border-hover-error": borderHoverError,
            "--n-loading-color-error": loadingColorError,
            "--n-clear-color": clearColor,
            "--n-clear-size": clearSize,
            "--n-clear-color-hover": clearColorHover,
            "--n-clear-color-pressed": clearColorPressed,
            "--n-icon-color": iconColor,
            "--n-icon-color-hover": iconColorHover,
            "--n-icon-color-pressed": iconColorPressed,
            "--n-icon-color-disabled": iconColorDisabled,
            "--n-suffix-text-color": suffixTextColor
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass(
          "input",
          vue.computed(() => {
            const { value: size } = mergedSizeRef;
            return size[0];
          }),
          cssVarsRef,
          props
        ) : void 0;
        return {
          ...exposedProps,
          wrapperElRef,
          inputElRef,
          inputMirrorElRef,
          inputEl2Ref,
          textareaElRef,
          textareaMirrorElRef,
          textareaScrollbarInstRef,
          rtlEnabled: rtlEnabledRef,
          uncontrolledValue: uncontrolledValueRef,
          mergedValue: mergedValueRef,
          passwordVisible: passwordVisibleRef,
          mergedPlaceholder: mergedPlaceholderRef,
          showPlaceholder1: showPlaceholder1Ref,
          showPlaceholder2: showPlaceholder2Ref,
          mergedFocus: mergedFocusRef,
          isComposing: isComposingRef,
          activated: activatedRef,
          showClearButton,
          mergedSize: mergedSizeRef,
          mergedDisabled: mergedDisabledRef,
          textDecorationStyle: textDecorationStyleRef,
          mergedClsPrefix: mergedClsPrefixRef,
          mergedBordered: mergedBorderedRef,
          mergedShowPasswordOn: mergedShowPasswordOnRef,
          placeholderStyle: placeholderStyleRef,
          mergedStatus: mergedStatusRef,
          textAreaScrollContainerWidth: textAreaScrollContainerWidthRef,
          handleTextAreaScroll,
          handleCompositionStart,
          handleCompositionEnd,
          handleInput,
          handleInputBlur,
          handleInputFocus,
          handleWrapperBlur,
          handleWrapperFocus,
          handleMouseEnter,
          handleMouseLeave,
          handleMouseDown,
          handleChange,
          handleClick,
          handleClear,
          handlePasswordToggleClick,
          handlePasswordToggleMousedown,
          handleWrapperKeydown,
          handleTextAreaMirrorResize,
          getTextareaScrollContainer: () => {
            return textareaElRef.value;
          },
          mergedTheme: themeRef,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender
        };
      },
      render() {
        const { mergedClsPrefix, mergedStatus, themeClass, type, onRender } = this;
        const $slots = this.$slots;
        onRender?.();
        return /* @__PURE__ */ vue.h("div", {
          ref: "wrapperElRef",
          class: [
            `${mergedClsPrefix}-input`,
            themeClass,
            mergedStatus && `${mergedClsPrefix}-input--${mergedStatus}-status`,
            {
              [`${mergedClsPrefix}-input--rtl`]: this.rtlEnabled,
              [`${mergedClsPrefix}-input--disabled`]: this.mergedDisabled,
              [`${mergedClsPrefix}-input--textarea`]: type === "textarea",
              [`${mergedClsPrefix}-input--resizable`]: this.resizable && !this.autosize,
              [`${mergedClsPrefix}-input--autosize`]: this.autosize,
              [`${mergedClsPrefix}-input--round`]: this.round && !(type === "textarea"),
              [`${mergedClsPrefix}-input--pair`]: this.pair,
              [`${mergedClsPrefix}-input--focus`]: this.mergedFocus,
              [`${mergedClsPrefix}-input--stateful`]: this.stateful
            }
          ],
          style: this.cssVars,
          tabindex: !this.mergedDisabled && this.passivelyActivated && !this.activated ? 0 : void 0,
          onFocus: this.handleWrapperFocus,
          onBlur: this.handleWrapperBlur,
          onClick: this.handleClick,
          onMousedown: this.handleMouseDown,
          onMouseenter: this.handleMouseEnter,
          onMouseleave: this.handleMouseLeave,
          onCompositionstart: this.handleCompositionStart,
          onCompositionend: this.handleCompositionEnd,
          onKeyup: this.onKeyup,
          onKeydown: this.handleWrapperKeydown
        }, /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-input-wrapper`
        }, resolveWrappedSlot(
          $slots.prefix,
          (children) => children && /* @__PURE__ */ vue.h("div", {
            class: `${mergedClsPrefix}-input__prefix`
          }, children)
        ), type === "textarea" ? /* @__PURE__ */ vue.h(NScrollbar, {
          ref: "textareaScrollbarInstRef",
          class: `${mergedClsPrefix}-input__textarea`,
          container: this.getTextareaScrollContainer,
          triggerDisplayManually: true,
          useUnifiedContainer: true,
          internalHoistYRail: true
        }, {
          default: () => {
            const { textAreaScrollContainerWidth } = this;
            const scrollContainerWidthStyle = {
              width: this.autosize && textAreaScrollContainerWidth && `${textAreaScrollContainerWidth}px`
            };
            return /* @__PURE__ */ vue.h(vue.Fragment, null, /* @__PURE__ */ vue.h("textarea", {
              ...this.inputProps,
              ref: "textareaElRef",
              class: [
                `${mergedClsPrefix}-input__textarea-el`,
                this.inputProps?.class
              ],
              autofocus: this.autofocus,
              rows: Number(this.rows),
              placeholder: this.placeholder,
              value: this.mergedValue,
              disabled: this.mergedDisabled,
              maxlength: this.maxlength,
              minlength: this.minlength,
              readonly: this.readonly,
              tabindex: this.passivelyActivated && !this.activated ? -1 : void 0,
              style: [
                this.textDecorationStyle[0],
                this.inputProps?.style,
                scrollContainerWidthStyle
              ],
              onBlur: this.handleInputBlur,
              onFocus: (e) => this.handleInputFocus(e, 2),
              onInput: this.handleInput,
              onChange: this.handleChange,
              onScroll: this.handleTextAreaScroll
            }), this.showPlaceholder1 ? /* @__PURE__ */ vue.h("div", {
              class: `${mergedClsPrefix}-input__placeholder`,
              style: [
                this.placeholderStyle,
                scrollContainerWidthStyle
              ],
              key: "placeholder"
            }, this.mergedPlaceholder[0]) : null, this.autosize ? /* @__PURE__ */ vue.h(VResizeObserver, {
              onResize: this.handleTextAreaMirrorResize
            }, {
              default: () => /* @__PURE__ */ vue.h("div", {
                ref: "textareaMirrorElRef",
                class: `${mergedClsPrefix}-input__textarea-mirror`,
                key: "mirror"
              })
            }) : null);
          }
        }) : /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-input__input`
        }, /* @__PURE__ */ vue.h("input", {
          type: type === "password" && this.mergedShowPasswordOn && this.passwordVisible ? "text" : type,
          ...this.inputProps,
          ref: "inputElRef",
          class: [
            `${mergedClsPrefix}-input__input-el`,
            this.inputProps?.class
          ],
          style: [
            this.textDecorationStyle[0],
            this.inputProps?.style
          ],
          tabindex: this.passivelyActivated && !this.activated ? -1 : void 0,
          placeholder: this.mergedPlaceholder[0],
          disabled: this.mergedDisabled,
          maxlength: this.maxlength,
          minlength: this.minlength,
          value: Array.isArray(this.mergedValue) ? this.mergedValue[0] : this.mergedValue,
          readonly: this.readonly,
          autofocus: this.autofocus,
          size: this.attrSize,
          onBlur: this.handleInputBlur,
          onFocus: (e) => this.handleInputFocus(e, 0),
          onInput: (e) => this.handleInput(e, 0),
          onChange: (e) => this.handleChange(e, 0)
        }), this.showPlaceholder1 ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-input__placeholder`
        }, /* @__PURE__ */ vue.h("span", null, this.mergedPlaceholder[0])) : null, this.autosize ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-input__input-mirror`,
          key: "mirror",
          ref: "inputMirrorElRef"
        }, "\xA0") : null), !this.pair && resolveWrappedSlot($slots.suffix, (children) => {
          return children || this.clearable || this.showCount || this.mergedShowPasswordOn || this.loading !== void 0 ? /* @__PURE__ */ vue.h("div", {
            class: `${mergedClsPrefix}-input__suffix`
          }, [
            resolveWrappedSlot(
              $slots["clear-icon-placeholder"],
              (children2) => {
                return (this.clearable || children2) && /* @__PURE__ */ vue.h(NBaseClear, {
                  clsPrefix: mergedClsPrefix,
                  show: this.showClearButton,
                  onClear: this.handleClear
                }, {
                  placeholder: () => children2,
                  icon: () => this.$slots["clear-icon"]?.()
                });
              }
            ),
            !this.internalLoadingBeforeSuffix ? children : null,
            this.loading !== void 0 ? /* @__PURE__ */ vue.h(NBaseSuffix, {
              clsPrefix: mergedClsPrefix,
              loading: this.loading,
              showArrow: false,
              showClear: false,
              style: this.cssVars
            }) : null,
            this.internalLoadingBeforeSuffix ? children : null,
            this.showCount && this.type !== "textarea" ? /* @__PURE__ */ vue.h(WordCount, null, {
              default: (props) => $slots.count?.(props)
            }) : null,
            this.mergedShowPasswordOn && this.type === "password" ? /* @__PURE__ */ vue.h("div", {
              class: `${mergedClsPrefix}-input__eye`,
              onMousedown: this.handlePasswordToggleMousedown,
              onClick: this.handlePasswordToggleClick
            }, this.passwordVisible ? resolveSlot($slots["password-visible-icon"], () => [
              /* @__PURE__ */ vue.h(NBaseIcon, {
                clsPrefix: mergedClsPrefix
              }, { default: () => /* @__PURE__ */ vue.h(EyeIcon, null) })
            ]) : resolveSlot(
              $slots["password-invisible-icon"],
              () => [
                /* @__PURE__ */ vue.h(NBaseIcon, {
                  clsPrefix: mergedClsPrefix
                }, { default: () => /* @__PURE__ */ vue.h(EyeOffIcon, null) })
              ]
            )) : null
          ]) : null;
        })), this.pair ? /* @__PURE__ */ vue.h("span", {
          class: `${mergedClsPrefix}-input__separator`
        }, resolveSlot($slots.separator, () => [this.separator])) : null, this.pair ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-input-wrapper`
        }, /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-input__input`
        }, /* @__PURE__ */ vue.h("input", {
          ref: "inputEl2Ref",
          type: this.type,
          class: `${mergedClsPrefix}-input__input-el`,
          tabindex: this.passivelyActivated && !this.activated ? -1 : void 0,
          placeholder: this.mergedPlaceholder[1],
          disabled: this.mergedDisabled,
          maxlength: this.maxlength,
          minlength: this.minlength,
          value: Array.isArray(this.mergedValue) ? this.mergedValue[1] : void 0,
          readonly: this.readonly,
          style: this.textDecorationStyle[1],
          onBlur: this.handleInputBlur,
          onFocus: (e) => this.handleInputFocus(e, 1),
          onInput: (e) => this.handleInput(e, 1),
          onChange: (e) => this.handleChange(e, 1)
        }), this.showPlaceholder2 ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-input__placeholder`
        }, /* @__PURE__ */ vue.h("span", null, this.mergedPlaceholder[1])) : null), resolveWrappedSlot($slots.suffix, (children) => {
          return (this.clearable || children) && /* @__PURE__ */ vue.h("div", {
            class: `${mergedClsPrefix}-input__suffix`
          }, [
            this.clearable && /* @__PURE__ */ vue.h(NBaseClear, {
              clsPrefix: mergedClsPrefix,
              show: this.showClearButton,
              onClear: this.handleClear
            }, {
              icon: () => $slots["clear-icon"]?.(),
              placeholder: () => $slots["clear-icon-placeholder"]?.()
            }),
            children
          ]);
        })) : null, this.mergedBordered ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-input__border`
        }) : null, this.mergedBordered ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-input__state-border`
        }) : null, this.showCount && type === "textarea" ? /* @__PURE__ */ vue.h(WordCount, null, {
          default: (props) => {
            const { renderCount } = this;
            if (renderCount) {
              return renderCount(props);
            }
            return $slots.count?.(props);
          }
        }) : null);
      }
    });

    var style$1i = cB("input-group", `
  display: inline-flex;
  width: 100%;
  flex-wrap: nowrap;
  vertical-align: bottom;
`, [c$1(">", [cB("input", [c$1("&:not(:last-child)", `
        border-top-right-radius: 0!important;
        border-bottom-right-radius: 0!important;
      `), c$1("&:not(:first-child)", `
        border-top-left-radius: 0!important;
        border-bottom-left-radius: 0!important;
        margin-left: -1px!important;
      `)]), cB("button", [c$1("&:not(:last-child)", `
        border-top-right-radius: 0!important;
        border-bottom-right-radius: 0!important;
      `, [cE("state-border, border", `
          border-top-right-radius: 0!important;
          border-bottom-right-radius: 0!important;
        `)]), c$1("&:not(:first-child)", `
        border-top-left-radius: 0!important;
        border-bottom-left-radius: 0!important;
      `, [cE("state-border, border", `
          border-top-left-radius: 0!important;
          border-bottom-left-radius: 0!important;
        `)])]), c$1("*", [c$1("&:not(:last-child)", `
        border-top-right-radius: 0!important;
        border-bottom-right-radius: 0!important;
      `, [c$1(">", [cB("input", `
            border-top-right-radius: 0!important;
            border-bottom-right-radius: 0!important;
          `), cB("base-selection", [cB("base-selection-label", `
              border-top-right-radius: 0!important;
              border-bottom-right-radius: 0!important;
            `), cB("base-selection-tags", `
              border-top-right-radius: 0!important;
              border-bottom-right-radius: 0!important;
            `), cE("box-shadow, border, state-border", `
              border-top-right-radius: 0!important;
              border-bottom-right-radius: 0!important;
            `)])])]), c$1("&:not(:first-child)", `
        margin-left: -1px!important;
        border-top-left-radius: 0!important;
        border-bottom-left-radius: 0!important;
      `, [c$1(">", [cB("input", `
            border-top-left-radius: 0!important;
            border-bottom-left-radius: 0!important;
          `), cB("base-selection", [cB("base-selection-label", `
              border-top-left-radius: 0!important;
              border-bottom-left-radius: 0!important;
            `), cB("base-selection-tags", `
              border-top-left-radius: 0!important;
              border-bottom-left-radius: 0!important;
            `), cE("box-shadow, border, state-border", `
              border-top-left-radius: 0!important;
              border-bottom-left-radius: 0!important;
            `)])])])])])]);

    const inputGroupProps = {};
    var NInputGroup = vue.defineComponent({
      name: "InputGroup",
      props: inputGroupProps,
      setup(props) {
        const { mergedClsPrefixRef } = useConfig(props);
        useStyle("-input-group", style$1i, mergedClsPrefixRef);
        return {
          mergedClsPrefix: mergedClsPrefixRef
        };
      },
      render() {
        const { mergedClsPrefix } = this;
        return /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-input-group`
        }, this.$slots);
      }
    });

    var style$1h = cB("input-group-label", `
  position: relative;
  user-select: none;
  -webkit-user-select: none;
  box-sizing: border-box;
  padding: 0 12px;
  display: inline-block;
  border-radius: var(--n-border-radius);
  background-color: var(--n-group-label-color);
  color: var(--n-group-label-text-color);
  font-size: var(--n-font-size);
  line-height: var(--n-height);
  height: var(--n-height);
  flex-shrink: 0;
  white-space: nowrap;
  transition:
    color .3s var(--n-bezier),
    background-color .3s var(--n-bezier),
    box-shadow .3s var(--n-bezier);
`, [cE("border", `
    position: absolute;
    left: 0;
    right: 0;
    top: 0;
    bottom: 0;
    border-radius: inherit;
    border: var(--n-group-label-border);
    transition: border-color .3s var(--n-bezier);
  `)]);

    const inputGroupLabelProps = {
      ...useTheme.props,
      size: {
        type: String,
        default: "medium"
      },
      bordered: {
        type: Boolean,
        default: void 0
      }
    };
    var InputGroupLabel = vue.defineComponent({
      name: "InputGroupLabel",
      props: inputGroupLabelProps,
      setup(props) {
        const { mergedBorderedRef, mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
        const themeRef = useTheme(
          "Input",
          "-input-group-label",
          style$1h,
          inputLight$1,
          props,
          mergedClsPrefixRef
        );
        const cssVarsRef = vue.computed(() => {
          const { size } = props;
          const {
            common: { cubicBezierEaseInOut },
            self: {
              groupLabelColor,
              borderRadius,
              groupLabelTextColor,
              lineHeight,
              groupLabelBorder,
              [createKey("fontSize", size)]: fontSize,
              [createKey("height", size)]: height
            }
          } = themeRef.value;
          return {
            "--n-bezier": cubicBezierEaseInOut,
            "--n-group-label-color": groupLabelColor,
            "--n-group-label-border": groupLabelBorder,
            "--n-border-radius": borderRadius,
            "--n-group-label-text-color": groupLabelTextColor,
            "--n-font-size": fontSize,
            "--n-line-height": lineHeight,
            "--n-height": height
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass(
          "input-group-label",
          vue.computed(() => props.size[0]),
          cssVarsRef,
          props
        ) : void 0;
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          mergedBordered: mergedBorderedRef,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender
        };
      },
      render() {
        const { mergedClsPrefix } = this;
        this.onRender?.();
        return /* @__PURE__ */ vue.h("div", {
          class: [`${mergedClsPrefix}-input-group-label`, this.themeClass],
          style: this.cssVars
        }, this.$slots.default?.(), this.mergedBordered ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-input-group-label__border`
        }) : null);
      }
    });

    function self$12(vars) {
      const {
        boxShadow2
      } = vars;
      return {
        menuBoxShadow: boxShadow2
      };
    }
    const autoCompleteLight = createTheme$1({
      name: "AutoComplete",
      common: commonLight,
      peers: {
        InternalSelectMenu: internalSelectMenuLight$1,
        Input: inputLight$1
      },
      self: self$12
    });
    var autoCompleteLight$1 = autoCompleteLight;

    const autoCompleteDark = {
      name: "AutoComplete",
      common: commonDark,
      peers: {
        InternalSelectMenu: internalSelectMenuDark$1,
        Input: inputDark$1
      },
      self: self$12
    };
    var autoCompleteDark$1 = autoCompleteDark;

    function mapAutoCompleteOptionsToSelectOptions(options) {
      return options.map(convertAutoCompleteOptionToSelectOption);
    }

    function convertAutoCompleteOptionToSelectOption(option) {
      if (typeof option === "string") {
        return {
          label: option,
          value: option
        };
      } else if (option.type === "group") {
        const groupOption = {
          type: "group",
          label: option.label ?? option.name,
          value: option.value ?? option.name,
          key: option.key || option.name,
          children: option.children.map(groupOption2 => convertAutoCompleteOptionToSelectOption(groupOption2))
        };
        return groupOption;
      } else {
        return option;
      }
    }

    var style$1g = c$1([cB("auto-complete", `
    z-index: auto;
    position: relative;
    display: inline-flex;
    width: 100%;
  `), cB("auto-complete-menu", `
    margin: 4px 0;
    box-shadow: var(--n-menu-box-shadow);
  `, [fadeInScaleUpTransition({
      originalTransition: "background-color .3s var(--n-bezier), box-shadow .3s var(--n-bezier)"
    })])]);

    const autoCompleteProps = {
      ...useTheme.props,
      to: useAdjustedTo.propTo,
      menuProps: Object,
      bordered: {
        type: Boolean,
        default: void 0
      },
      clearable: {
        type: Boolean,
        default: void 0
      },
      defaultValue: {
        type: String,
        default: null
      },
      loading: {
        type: Boolean,
        default: void 0
      },
      disabled: {
        type: Boolean,
        default: void 0
      },
      placeholder: String,
      placement: {
        type: String,
        default: "bottom-start"
      },
      value: String,
      blurAfterSelect: Boolean,
      clearAfterSelect: Boolean,
      getShow: Function,
      inputProps: Object,
      renderOption: Function,
      renderLabel: Function,
      size: String,
      options: {
        type: Array,
        default: () => []
      },
      zIndex: Number,
      status: String,
      "onUpdate:value": [Function, Array],
      onUpdateValue: [Function, Array],
      onSelect: [Function, Array],
      onBlur: [Function, Array],
      onFocus: [Function, Array],
      onInput: [Function, Array]
    };
    var AutoComplete = vue.defineComponent({
      name: "AutoComplete",
      props: autoCompleteProps,
      setup(props) {
        {
          vue.watchEffect(() => {
            if (props.onInput !== void 0) {
              warnOnce(
                "auto-complete",
                "`on-input` is deprecated, please use `on-update:value` instead."
              );
            }
          });
        }
        const {
          mergedBorderedRef,
          namespaceRef,
          mergedClsPrefixRef,
          inlineThemeDisabled
        } = useConfig(props);
        const formItem = useFormItem(props);
        const { mergedSizeRef, mergedDisabledRef, mergedStatusRef } = formItem;
        const triggerElRef = vue.ref(null);
        const menuInstRef = vue.ref(null);
        const uncontrolledValueRef = vue.ref(props.defaultValue);
        const controlledValueRef = vue.toRef(props, "value");
        const mergedValueRef = useMergedState(
          controlledValueRef,
          uncontrolledValueRef
        );
        const canBeActivatedRef = vue.ref(false);
        const isComposingRef = vue.ref(false);
        const themeRef = useTheme(
          "AutoComplete",
          "-auto-complete",
          style$1g,
          autoCompleteLight$1,
          props,
          mergedClsPrefixRef
        );
        const selectOptionsRef = vue.computed(() => {
          return mapAutoCompleteOptionsToSelectOptions(props.options);
        });
        const mergedShowOptionsRef = vue.computed(() => {
          const { getShow } = props;
          if (getShow) {
            return getShow(mergedValueRef.value || "");
          }
          return !!mergedValueRef.value;
        });
        const activeRef = vue.computed(() => {
          return mergedShowOptionsRef.value && canBeActivatedRef.value && !!selectOptionsRef.value.length;
        });
        const treeMateRef = vue.computed(
          () => createTreeMate(
            selectOptionsRef.value,
            createTmOptions("value", "children")
          )
        );
        function doUpdateValue(value) {
          const { "onUpdate:value": _onUpdateValue, onUpdateValue, onInput } = props;
          const { nTriggerFormInput, nTriggerFormChange } = formItem;
          if (onUpdateValue)
            call(onUpdateValue, value);
          if (_onUpdateValue)
            call(_onUpdateValue, value);
          if (onInput)
            call(onInput, value);
          uncontrolledValueRef.value = value;
          nTriggerFormInput();
          nTriggerFormChange();
        }
        function doSelect(value) {
          const { onSelect } = props;
          const { nTriggerFormInput, nTriggerFormChange } = formItem;
          if (onSelect)
            call(onSelect, value);
          nTriggerFormInput();
          nTriggerFormChange();
        }
        function doBlur(e) {
          const { onBlur } = props;
          const { nTriggerFormBlur } = formItem;
          if (onBlur)
            call(onBlur, e);
          nTriggerFormBlur();
        }
        function doFocus(e) {
          const { onFocus } = props;
          const { nTriggerFormFocus } = formItem;
          if (onFocus)
            call(onFocus, e);
          nTriggerFormFocus();
        }
        function handleCompositionStart() {
          isComposingRef.value = true;
        }
        function handleCompositionEnd() {
          window.setTimeout(() => {
            isComposingRef.value = false;
          }, 0);
        }
        function handleKeyDown(e) {
          switch (e.key) {
            case "Enter":
              if (!isComposingRef.value) {
                const pendingOptionTmNode = menuInstRef.value?.getPendingTmNode();
                if (pendingOptionTmNode) {
                  select(pendingOptionTmNode.rawNode);
                  e.preventDefault();
                }
              }
              break;
            case "ArrowDown":
              menuInstRef.value?.next();
              break;
            case "ArrowUp":
              menuInstRef.value?.prev();
              break;
          }
        }
        function select(option) {
          if (option?.value !== void 0) {
            doSelect(option.value);
            if (props.clearAfterSelect) {
              doUpdateValue(null);
            } else if (option.label !== void 0) {
              doUpdateValue(option.label);
            }
            canBeActivatedRef.value = false;
            if (props.blurAfterSelect) {
              blur();
            }
          }
        }
        function handleClear() {
          doUpdateValue(null);
        }
        function handleFocus(e) {
          canBeActivatedRef.value = true;
          doFocus(e);
        }
        function handleBlur(e) {
          canBeActivatedRef.value = false;
          doBlur(e);
        }
        function handleInput(value) {
          canBeActivatedRef.value = true;
          doUpdateValue(value);
        }
        function handleToggle(option) {
          select(option.rawNode);
        }
        function handleClickOutsideMenu(e) {
          if (!triggerElRef.value?.contains(getPreciseEventTarget(e))) {
            canBeActivatedRef.value = false;
          }
        }
        function blur() {
          if (triggerElRef.value?.contains(document.activeElement)) {
            document.activeElement?.blur();
          }
        }
        const cssVarsRef = vue.computed(() => {
          const {
            common: { cubicBezierEaseInOut },
            self: { menuBoxShadow }
          } = themeRef.value;
          return {
            "--n-menu-box-shadow": menuBoxShadow,
            "--n-bezier": cubicBezierEaseInOut
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("auto-complete", void 0, cssVarsRef, props) : void 0;
        const inputInstRef = vue.ref(null);
        const exposedMethods = {
          focus: () => {
            inputInstRef.value?.focus();
          },
          blur: () => {
            inputInstRef.value?.blur();
          }
        };
        return {
          focus: exposedMethods.focus,
          blur: exposedMethods.blur,
          inputInstRef,
          uncontrolledValue: uncontrolledValueRef,
          mergedValue: mergedValueRef,
          isMounted: isMounted(),
          adjustedTo: useAdjustedTo(props),
          menuInstRef,
          triggerElRef,
          treeMate: treeMateRef,
          mergedSize: mergedSizeRef,
          mergedDisabled: mergedDisabledRef,
          active: activeRef,
          mergedStatus: mergedStatusRef,
          handleClear,
          handleFocus,
          handleBlur,
          handleInput,
          handleToggle,
          handleClickOutsideMenu,
          handleCompositionStart,
          handleCompositionEnd,
          handleKeyDown,
          mergedTheme: themeRef,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender,
          mergedBordered: mergedBorderedRef,
          namespace: namespaceRef,
          mergedClsPrefix: mergedClsPrefixRef
        };
      },
      render() {
        const { mergedClsPrefix } = this;
        return /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-auto-complete`,
          ref: "triggerElRef",
          onKeydown: this.handleKeyDown,
          onCompositionstart: this.handleCompositionStart,
          onCompositionend: this.handleCompositionEnd
        }, /* @__PURE__ */ vue.h(VBinder, null, {
          default: () => [
            /* @__PURE__ */ vue.h(VTarget, null, {
              default: () => {
                const defaultSlot = this.$slots.default;
                if (defaultSlot) {
                  return getFirstSlotVNode(this.$slots, "default", {
                    handleInput: this.handleInput,
                    handleFocus: this.handleFocus,
                    handleBlur: this.handleBlur,
                    value: this.mergedValue
                  });
                }
                const { mergedTheme } = this;
                return /* @__PURE__ */ vue.h(NInput, {
                  ref: "inputInstRef",
                  status: this.mergedStatus,
                  theme: mergedTheme.peers.Input,
                  themeOverrides: mergedTheme.peerOverrides.Input,
                  bordered: this.mergedBordered,
                  value: this.mergedValue,
                  placeholder: this.placeholder,
                  size: this.mergedSize,
                  disabled: this.mergedDisabled,
                  clearable: this.clearable,
                  loading: this.loading,
                  inputProps: this.inputProps,
                  onClear: this.handleClear,
                  onFocus: this.handleFocus,
                  onUpdateValue: this.handleInput,
                  onBlur: this.handleBlur
                }, {
                  suffix: () => this.$slots.suffix?.(),
                  prefix: () => this.$slots.prefix?.()
                });
              }
            }),
            /* @__PURE__ */ vue.h(VFollower, {
              show: this.active,
              to: this.adjustedTo,
              containerClass: this.namespace,
              zIndex: this.zIndex,
              teleportDisabled: this.adjustedTo === useAdjustedTo.tdkey,
              placement: this.placement,
              width: "target"
            }, {
              default: () => /* @__PURE__ */ vue.h(vue.Transition, {
                name: "fade-in-scale-up-transition",
                appear: this.isMounted
              }, {
                default: () => {
                  this.onRender?.();
                  if (!this.active)
                    return null;
                  const { menuProps } = this;
                  return vue.withDirectives(
                    /* @__PURE__ */ vue.h(NInternalSelectMenu, {
                      ...menuProps,
                      clsPrefix: mergedClsPrefix,
                      ref: "menuInstRef",
                      theme: this.mergedTheme.peers.InternalSelectMenu,
                      themeOverrides: this.mergedTheme.peerOverrides.InternalSelectMenu,
                      "auto-pending": true,
                      class: [
                        `${mergedClsPrefix}-auto-complete-menu`,
                        this.themeClass,
                        menuProps?.class
                      ],
                      style: [
                        menuProps?.style,
                        this.cssVars
                      ],
                      treeMate: this.treeMate,
                      multiple: false,
                      renderLabel: this.renderLabel,
                      renderOption: this.renderOption,
                      size: "medium",
                      onToggle: this.handleToggle
                    }),
                    [
                      [
                        clickoutside$1,
                        this.handleClickOutsideMenu,
                        void 0,
                        { capture: true }
                      ]
                    ]
                  );
                }
              })
            })
          ]
        }));
      }
    });

    const isImageSupportNativeLazy = false;

    const resolveOptionsAndHash = function () {
      let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      const {
        root = null
      } = options;
      return {
        hash: `${options.rootMargin || "0px 0px 0px 0px"}-${Array.isArray(options.threshold) ? options.threshold.join(",") : options.threshold ?? "0"}`,
        options: { ...options,
          root: (typeof root === "string" ? document.querySelector(root) : root) || document.documentElement
        }
      };
    };
    const observers = /* @__PURE__ */new WeakMap();
    const unobserveHandleMap = /* @__PURE__ */new WeakMap();
    const shouldStartLoadingRefMap = /* @__PURE__ */new WeakMap();
    const observeIntersection = (el, options, shouldStartLoadingRef) => {
      if (!el) return () => {};
      const resolvedOptionsAndHash = resolveOptionsAndHash(options);
      const {
        root
      } = resolvedOptionsAndHash.options;
      let rootObservers;

      const _rootObservers = observers.get(root);

      if (_rootObservers) {
        rootObservers = _rootObservers;
      } else {
        rootObservers = /* @__PURE__ */new Map();
        observers.set(root, rootObservers);
      }

      let observer;
      let observerAndObservedElements;

      if (rootObservers.has(resolvedOptionsAndHash.hash)) {
        observerAndObservedElements = rootObservers.get(resolvedOptionsAndHash.hash);

        if (!observerAndObservedElements[1].has(el)) {
          observer = observerAndObservedElements[0];
          observerAndObservedElements[1].add(el);
          observer.observe(el);
        }
      } else {
        observer = new IntersectionObserver(entries => {
          entries.forEach(entry => {
            if (entry.isIntersecting) {
              const _unobserve = unobserveHandleMap.get(entry.target);

              const _shouldStartLoadingRef = shouldStartLoadingRefMap.get(entry.target);

              if (_unobserve) _unobserve();

              if (_shouldStartLoadingRef) {
                _shouldStartLoadingRef.value = true;
              }
            }
          });
        }, resolvedOptionsAndHash.options);
        observer.observe(el);
        observerAndObservedElements = [observer, /* @__PURE__ */new Set([el])];
        rootObservers.set(resolvedOptionsAndHash.hash, observerAndObservedElements);
      }

      let unobservered = false;

      const unobserve = () => {
        if (unobservered) return;
        unobserveHandleMap.delete(el);
        shouldStartLoadingRefMap.delete(el);
        unobservered = true;

        if (observerAndObservedElements[1].has(el)) {
          observerAndObservedElements[0].unobserve(el);
          observerAndObservedElements[1].delete(el);
        }

        if (observerAndObservedElements[1].size <= 0) {
          rootObservers.delete(resolvedOptionsAndHash.hash);
        }

        if (!rootObservers.size) {
          observers.delete(root);
        }
      };

      unobserveHandleMap.set(el, unobserve);
      shouldStartLoadingRefMap.set(el, shouldStartLoadingRef);
      return unobserve;
    };

    const self$11 = vars => {
      const {
        borderRadius,
        avatarColor,
        cardColor,
        fontSize,
        heightTiny,
        heightSmall,
        heightMedium,
        heightLarge,
        heightHuge,
        modalColor,
        popoverColor
      } = vars;
      return {
        borderRadius,
        fontSize,
        border: `2px solid ${cardColor}`,
        heightTiny,
        heightSmall,
        heightMedium,
        heightLarge,
        heightHuge,
        color: composite(cardColor, avatarColor),
        colorModal: composite(modalColor, avatarColor),
        colorPopover: composite(popoverColor, avatarColor)
      };
    };
    const avatarLight = {
      name: "Avatar",
      common: commonLight,
      self: self$11
    };
    var avatarLight$1 = avatarLight;

    const avatarDark = {
      name: "Avatar",
      common: commonDark,
      self: self$11
    };
    var avatarDark$1 = avatarDark;

    const avatarGroupInjectionKey = createInjectionKey("n-avatar-group");

    var style$1f = cB("avatar", `
  width: var(--n-merged-size);
  height: var(--n-merged-size);
  color: #FFF;
  font-size: var(--n-font-size);
  display: inline-flex;
  position: relative;
  overflow: hidden;
  text-align: center;
  border: var(--n-border);
  border-radius: var(--n-border-radius);
  --n-merged-color: var(--n-color);
  background-color: var(--n-merged-color);
  transition:
    border-color .3s var(--n-bezier),
    background-color .3s var(--n-bezier),
    color .3s var(--n-bezier);
`, [insideModal(c$1("&", "--n-merged-color: var(--n-color-modal);")), insidePopover(c$1("&", "--n-merged-color: var(--n-color-popover);")), c$1("img", `
    width: 100%;
    height: 100%;
  `), cE("text", `
    white-space: nowrap;
    display: inline-block;
    position: absolute;
    left: 50%;
    top: 50%;
  `), cB("icon", `
    vertical-align: bottom;
    font-size: calc(var(--n-merged-size) - 6px);
  `), cE("text", "line-height: 1.25")]);

    const avatarProps = {
      ...useTheme.props,
      size: [String, Number],
      src: String,
      circle: {
        type: Boolean,
        default: void 0
      },
      objectFit: String,
      round: {
        type: Boolean,
        default: void 0
      },
      bordered: {
        type: Boolean,
        default: void 0
      },
      onError: Function,
      fallbackSrc: String,
      intersectionObserverOptions: Object,
      lazy: Boolean,
      color: String
    };
    var NAvatar = vue.defineComponent({
      name: "Avatar",
      props: avatarProps,
      setup(props) {
        const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
        const hasLoadErrorRef = vue.ref(false);
        let memoedTextHtml = null;
        const textRef = vue.ref(null);
        const selfRef = vue.ref(null);
        const fitTextTransform = () => {
          const { value: textEl } = textRef;
          if (textEl) {
            if (memoedTextHtml === null || memoedTextHtml !== textEl.innerHTML) {
              memoedTextHtml = textEl.innerHTML;
              const { value: selfEl } = selfRef;
              if (selfEl) {
                const { offsetWidth: elWidth, offsetHeight: elHeight } = selfEl;
                const { offsetWidth: textWidth, offsetHeight: textHeight } = textEl;
                const radix = 0.9;
                const ratio = Math.min(
                  elWidth / textWidth * radix,
                  elHeight / textHeight * radix,
                  1
                );
                textEl.style.transform = `translateX(-50%) translateY(-50%) scale(${ratio})`;
              }
            }
          }
        };
        const NAvatarGroup = vue.inject(avatarGroupInjectionKey, null);
        const mergedSizeRef = vue.computed(() => {
          const { size } = props;
          if (size)
            return size;
          const { size: avatarGroupSize } = NAvatarGroup || {};
          if (avatarGroupSize)
            return avatarGroupSize;
          return "medium";
        });
        const themeRef = useTheme(
          "Avatar",
          "-avatar",
          style$1f,
          avatarLight$1,
          props,
          mergedClsPrefixRef
        );
        const TagInjection = vue.inject(tagInjectionKey, null);
        const mergedRoundRef = vue.computed(() => {
          if (NAvatarGroup)
            return true;
          const { round, circle } = props;
          if (round !== void 0 || circle !== void 0)
            return round || circle;
          if (TagInjection) {
            return TagInjection.roundRef.value;
          }
          return false;
        });
        const mergedBorderedRef = vue.computed(() => {
          if (NAvatarGroup)
            return true;
          return props.bordered || false;
        });
        const handleError = (e) => {
          if (!shouldStartLoadingRef.value)
            return;
          hasLoadErrorRef.value = true;
          const { onError } = props;
          if (onError) {
            onError(e);
          }
        };
        vue.watch(
          () => props.src,
          () => hasLoadErrorRef.value = false
        );
        const cssVarsRef = vue.computed(() => {
          const size = mergedSizeRef.value;
          const round = mergedRoundRef.value;
          const bordered = mergedBorderedRef.value;
          const { color: propColor } = props;
          const {
            self: {
              borderRadius,
              fontSize,
              color,
              border,
              colorModal,
              colorPopover
            },
            common: { cubicBezierEaseInOut }
          } = themeRef.value;
          let height;
          if (typeof size === "number") {
            height = `${size}px`;
          } else {
            height = themeRef.value.self[createKey("height", size)];
          }
          return {
            "--n-font-size": fontSize,
            "--n-border": bordered ? border : "none",
            "--n-border-radius": round ? "50%" : borderRadius,
            "--n-color": propColor || color,
            "--n-color-modal": propColor || colorModal,
            "--n-color-popover": propColor || colorPopover,
            "--n-bezier": cubicBezierEaseInOut,
            "--n-merged-size": `var(--n-avatar-size-override, ${height})`
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass(
          "avatar",
          vue.computed(() => {
            const size = mergedSizeRef.value;
            const round = mergedRoundRef.value;
            const bordered = mergedBorderedRef.value;
            const { color } = props;
            let hash = "";
            if (size) {
              if (typeof size === "number") {
                hash += `a${size}`;
              } else {
                hash += size[0];
              }
            }
            if (round) {
              hash += "b";
            }
            if (bordered) {
              hash += "c";
            }
            if (color) {
              hash += color2Class(color);
            }
            return hash;
          }),
          cssVarsRef,
          props
        ) : void 0;
        const shouldStartLoadingRef = vue.ref(!props.lazy);
        vue.onMounted(() => {
          if (isImageSupportNativeLazy) {
            return;
          }
          let unobserve;
          const stopWatchHandle = vue.watchEffect(() => {
            unobserve?.();
            unobserve = void 0;
            if (props.lazy) {
              unobserve = observeIntersection(
                selfRef.value,
                props.intersectionObserverOptions,
                shouldStartLoadingRef
              );
            }
          });
          vue.onBeforeUnmount(() => {
            stopWatchHandle();
            unobserve?.();
          });
        });
        const loadedRef = vue.ref(!props.lazy);
        return {
          textRef,
          selfRef,
          mergedRoundRef,
          mergedClsPrefix: mergedClsPrefixRef,
          fitTextTransform,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender,
          hasLoadError: hasLoadErrorRef,
          handleError,
          shouldStartLoading: shouldStartLoadingRef,
          loaded: loadedRef,
          mergedOnLoad: (e) => {
            const { onLoad } = props;
            onLoad?.(e);
            loadedRef.value = true;
          }
        };
      },
      render() {
        const {
          $slots,
          src,
          mergedClsPrefix,
          lazy,
          onRender,
          mergedOnLoad,
          shouldStartLoading,
          loaded,
          hasLoadError
        } = this;
        onRender?.();
        let img;
        const placeholderNode = !loaded && !hasLoadError && this.$slots.placeholder?.();
        if (this.hasLoadError) {
          img = /* @__PURE__ */ vue.h("img", {
            src: this.fallbackSrc,
            style: { objectFit: this.objectFit }
          });
        } else {
          img = resolveWrappedSlot($slots.default, (children) => {
            if (children) {
              return /* @__PURE__ */ vue.h(VResizeObserver, {
                onResize: this.fitTextTransform
              }, {
                default: () => /* @__PURE__ */ vue.h("span", {
                  ref: "textRef",
                  class: `${mergedClsPrefix}-avatar__text`
                }, children)
              });
            } else if (src) {
              return vue.h("img", {
                loading: "eager",
                src: shouldStartLoading || loaded ? src : void 0,
                onLoad: mergedOnLoad,
                "data-image-src": src,
                onError: this.handleError,
                style: [
                  { objectFit: this.objectFit },
                  placeholderNode ? {
                    height: "0",
                    width: "0",
                    visibility: "hidden",
                    position: "absolute"
                  } : ""
                ]
              });
            }
          });
        }
        return /* @__PURE__ */ vue.h("span", {
          ref: "selfRef",
          class: [`${mergedClsPrefix}-avatar`, this.themeClass],
          style: this.cssVars
        }, img, lazy && placeholderNode);
      }
    });

    var style$1e = cB("avatar-group", `
  flex-wrap: nowrap;
  display: inline-flex;
  position: relative;
`, [cNotM("vertical", {
      flexDirection: "row"
    }, [cB("avatar", [c$1("&:not(:first-child)", `
         margin-left: -12px;
      `)])]), cM("vertical", {
      flexDirection: "column"
    }, [cB("avatar", [c$1("&:not(:first-child)", `
         margin-top: -12px;
      `)])])]);

    const avatarGroupDark = {
      name: "AvatarGroup",
      common: commonDark,
      peers: {
        Avatar: avatarDark$1
      }
    };
    var avatarGroupDark$1 = avatarGroupDark;

    const avatarGroupLight = createTheme$1({
      name: "AvatarGroup",
      common: commonLight,
      peers: {
        Avatar: avatarLight$1
      }
    });
    var avatarGroupLight$1 = avatarGroupLight;

    var rtlStyle$n = cB("avatar-group", [cM("rtl", `
    direction: rtl;
  `, [cNotM("vertical", `
      flex-direction: row;
    `, [cB("avatar", [c$1("&:not(:first-child)", `
          margin-right: -12px;
          margin-left: 0;
        `)])])])]);

    const avatarGroupRtl = {
      name: "AvatarGroup",
      style: rtlStyle$n
    };

    const avatarGroupProps = {
      ...useTheme.props,
      max: Number,
      maxStyle: [Object, String],
      options: {
        type: Array,
        default: () => []
      },
      vertical: Boolean,
      size: [String, Number]
    };
    var AvatarGroup = vue.defineComponent({
      name: "AvatarGroup",
      props: avatarGroupProps,
      setup(props) {
        const { mergedClsPrefixRef, mergedRtlRef } = useConfig(props);
        const mergedThemeRef = useTheme(
          "AvatarGroup",
          "-avatar-group",
          style$1e,
          avatarGroupLight$1,
          props,
          mergedClsPrefixRef
        );
        vue.provide(avatarGroupInjectionKey, props);
        const rtlEnabledRef = useRtl(
          "AvatarGroup",
          mergedRtlRef,
          mergedClsPrefixRef
        );
        const restOptionsRef = vue.computed(() => {
          const { max } = props;
          if (max === void 0)
            return void 0;
          const { options } = props;
          if (options.length > max)
            return options.slice(max - 1, options.length);
          return [];
        });
        const displayedOptionsRef = vue.computed(() => {
          const { options, max } = props;
          if (max === void 0)
            return options;
          if (options.length > max)
            return options.slice(0, max - 1);
          if (options.length === max)
            return options.slice(0, max);
          return options;
        });
        return {
          mergedTheme: mergedThemeRef,
          rtlEnabled: rtlEnabledRef,
          mergedClsPrefix: mergedClsPrefixRef,
          restOptions: restOptionsRef,
          displayedOptions: displayedOptionsRef
        };
      },
      render() {
        const {
          mergedClsPrefix,
          displayedOptions,
          restOptions,
          mergedTheme,
          $slots
        } = this;
        return /* @__PURE__ */ vue.h("div", {
          class: [
            `${mergedClsPrefix}-avatar-group`,
            this.rtlEnabled && `${mergedClsPrefix}-avatar-group--rtl`,
            this.vertical && `${mergedClsPrefix}-avatar-group--vertical`
          ],
          role: "group"
        }, displayedOptions.map((option) => {
          return $slots.avatar ? $slots.avatar({ option }) : /* @__PURE__ */ vue.h(NAvatar, {
            src: option.src,
            theme: mergedTheme.peers.Avatar,
            themeOverrides: mergedTheme.peerOverrides.Avatar
          });
        }), restOptions !== void 0 && restOptions.length > 0 && ($slots.rest ? $slots.rest({ options: restOptions, rest: restOptions.length }) : /* @__PURE__ */ vue.h(NAvatar, {
          style: this.maxStyle,
          theme: mergedTheme.peers.Avatar,
          themeOverrides: mergedTheme.peerOverrides.Avatar
        }, {
          default: () => `+${restOptions.length}`
        })));
      }
    });

    var commonVariables$h = {
      width: "44px",
      height: "44px",
      borderRadius: "22px",
      iconSize: "26px"
    };

    const backTopDark = {
      name: "BackTop",
      common: commonDark,

      self(vars) {
        const {
          popoverColor,
          textColor2,
          primaryColorHover,
          primaryColorPressed
        } = vars;
        return { ...commonVariables$h,
          color: popoverColor,
          textColor: textColor2,
          iconColor: textColor2,
          iconColorHover: primaryColorHover,
          iconColorPressed: primaryColorPressed,
          boxShadow: "0 2px 8px 0px rgba(0, 0, 0, .12)",
          boxShadowHover: "0 2px 12px 0px rgba(0, 0, 0, .18)",
          boxShadowPressed: "0 2px 12px 0px rgba(0, 0, 0, .18)"
        };
      }

    };
    var backTopDark$1 = backTopDark;

    const self$10 = vars => {
      const {
        popoverColor,
        textColor2,
        primaryColorHover,
        primaryColorPressed
      } = vars;
      return { ...commonVariables$h,
        color: popoverColor,
        textColor: textColor2,
        iconColor: textColor2,
        iconColorHover: primaryColorHover,
        iconColorPressed: primaryColorPressed,
        boxShadow: "0 2px 8px 0px rgba(0, 0, 0, .12)",
        boxShadowHover: "0 2px 12px 0px rgba(0, 0, 0, .18)",
        boxShadowPressed: "0 2px 12px 0px rgba(0, 0, 0, .18)"
      };
    };

    const backTopLight = {
      name: "BackTop",
      common: commonLight,
      self: self$10
    };
    var backTopLight$1 = backTopLight;

    var BackTopIcon = /* @__PURE__ */ vue.h("svg", {
      viewBox: "0 0 24 24",
      version: "1.1",
      xmlns: "http://www.w3.org/2000/svg",
      xlinkHref: "http://www.w3.org/1999/xlink"
    }, /* @__PURE__ */ vue.h("g", {
      stroke: "none",
      "stroke-width": "1",
      "fill-rule": "evenodd"
    }, /* @__PURE__ */ vue.h("g", {
      transform: "translate(-139.000000, -4423.000000)",
      "fill-rule": "nonzero"
    }, /* @__PURE__ */ vue.h("g", {
      transform: "translate(120.000000, 4285.000000)"
    }, /* @__PURE__ */ vue.h("g", {
      transform: "translate(7.000000, 126.000000)"
    }, /* @__PURE__ */ vue.h("g", {
      transform: "translate(24.000000, 24.000000) scale(1, -1) translate(-24.000000, -24.000000) translate(12.000000, 12.000000)"
    }, /* @__PURE__ */ vue.h("g", {
      transform: "translate(4.000000, 2.000000)"
    }, /* @__PURE__ */ vue.h("path", {
      d: "M8,0 C8.51283584,0 8.93550716,0.38604019 8.99327227,0.883378875 L9,1 L9,10.584 L12.2928932,7.29289322 C12.6834175,6.90236893 13.3165825,6.90236893 13.7071068,7.29289322 C14.0675907,7.65337718 14.0953203,8.22060824 13.7902954,8.61289944 L13.7071068,8.70710678 L8.70710678,13.7071068 L8.62544899,13.7803112 L8.618,13.784 L8.59530661,13.8036654 L8.4840621,13.8753288 L8.37133602,13.9287745 L8.22929083,13.9735893 L8.14346259,13.9897165 L8.03324678,13.9994506 L7.9137692,13.9962979 L7.77070917,13.9735893 L7.6583843,13.9401293 L7.57677845,13.9063266 L7.47929125,13.8540045 L7.4048407,13.8036865 L7.38131006,13.7856883 C7.35030318,13.7612383 7.32077858,13.7349921 7.29289322,13.7071068 L2.29289322,8.70710678 L2.20970461,8.61289944 C1.90467972,8.22060824 1.93240926,7.65337718 2.29289322,7.29289322 C2.65337718,6.93240926 3.22060824,6.90467972 3.61289944,7.20970461 L3.70710678,7.29289322 L7,10.585 L7,1 L7.00672773,0.883378875 C7.06449284,0.38604019 7.48716416,0 8,0 Z"
    }), /* @__PURE__ */ vue.h("path", {
      d: "M14.9333333,15.9994506 C15.5224371,15.9994506 16,16.4471659 16,16.9994506 C16,17.5122865 15.5882238,17.9349578 15.0577292,17.9927229 L14.9333333,17.9994506 L1.06666667,17.9994506 C0.477562934,17.9994506 0,17.5517354 0,16.9994506 C0,16.4866148 0.411776203,16.0639435 0.9422708,16.0061783 L1.06666667,15.9994506 L14.9333333,15.9994506 Z"
    }))))))));

    var style$1d = cB("back-top", `
  position: fixed;
  right: 40px;
  bottom: 40px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--n-text-color);
  transition:
    color .3s var(--n-bezier),
    box-shadow .3s var(--n-bezier),
    background-color .3s var(--n-bezier);
  border-radius: var(--n-border-radius);
  height: var(--n-height);
  min-width: var(--n-width);
  box-shadow: var(--n-box-shadow);
  background-color: var(--n-color);
`, [fadeInScaleUpTransition(), cM("transition-disabled", {
      transition: "none !important"
    }), cB("base-icon", `
    font-size: var(--n-icon-size);
    color: var(--n-icon-color);
    transition: color .3s var(--n-bezier);
  `), c$1("svg", {
      pointerEvents: "none"
    }), c$1("&:hover", {
      boxShadow: "var(--n-box-shadow-hover)"
    }, [cB("base-icon", {
      color: "var(--n-icon-color-hover)"
    })]), c$1("&:active", {
      boxShadow: "var(--n-box-shadow-pressed)"
    }, [cB("base-icon", {
      color: "var(--n-icon-color-pressed)"
    })])]);

    const backTopProps = {
      ...useTheme.props,
      show: {
        type: Boolean,
        default: void 0
      },
      right: {
        type: [Number, String],
        default: 40
      },
      bottom: {
        type: [Number, String],
        default: 40
      },
      to: {
        type: [String, Object],
        default: "body"
      },
      visibilityHeight: {
        type: Number,
        default: 180
      },
      listenTo: [String, Object, Function],
      "onUpdate:show": {
        type: Function,
        default: () => {
        }
      },
      target: Function,
      onShow: Function,
      onHide: Function
    };
    var BackTop = vue.defineComponent({
      name: "BackTop",
      inheritAttrs: false,
      props: backTopProps,
      setup(props) {
        {
          vue.watchEffect(() => {
            if (props.target !== void 0) {
              warnOnce(
                "back-top",
                "`target` is deprecated, please use `listen-to` instead."
              );
            }
            if (props.onShow !== void 0) {
              warnOnce(
                "back-top",
                "`on-show` is deprecated, please use `on-update:show` instead."
              );
            }
            if (props.onHide !== void 0) {
              warnOnce(
                "back-top",
                "`on-hide` is deprecated, please use `on-update:show` instead."
              );
            }
          });
        }
        const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
        const scrollTopRef = vue.ref(null);
        const uncontrolledShowRef = vue.ref(false);
        vue.watchEffect(() => {
          const { value: scrollTop } = scrollTopRef;
          if (scrollTop === null) {
            uncontrolledShowRef.value = false;
            return;
          }
          uncontrolledShowRef.value = scrollTop >= props.visibilityHeight;
        });
        const DomInfoReadyRef = vue.ref(false);
        vue.watch(uncontrolledShowRef, (value) => {
          if (DomInfoReadyRef.value) {
            props["onUpdate:show"]?.(value);
          }
        });
        const controlledShowRef = vue.toRef(props, "show");
        const mergedShowRef = useMergedState(controlledShowRef, uncontrolledShowRef);
        const transitionDisabledRef = vue.ref(true);
        const placeholderRef = vue.ref(null);
        const styleRef = vue.computed(
          () => {
            return {
              right: `calc(${formatLength(props.right)} + ${lockHtmlScrollRightCompensationRef.value})`,
              bottom: formatLength(props.bottom)
            };
          }
        );
        let scrollElement;
        let scrollListenerRegistered;
        vue.watch(mergedShowRef, (value) => {
          if (DomInfoReadyRef.value) {
            if (value) {
              props.onShow?.();
            }
            props.onHide?.();
          }
        });
        const themeRef = useTheme(
          "BackTop",
          "-back-top",
          style$1d,
          backTopLight$1,
          props,
          mergedClsPrefixRef
        );
        function init() {
          if (scrollListenerRegistered)
            return;
          scrollListenerRegistered = true;
          const scrollEl = props.target?.() || unwrapElement(props.listenTo) || getScrollParent$1(placeholderRef.value);
          if (!scrollEl) {
            {
              warn$2(
                "back-top",
                "Container of back-top element is not found. This could be a bug of naive-ui."
              );
            }
            return;
          }
          scrollElement = scrollEl === document.documentElement ? document : scrollEl;
          const { to } = props;
          const target = typeof to === "string" ? document.querySelector(to) : to;
          if (!target) {
            warn$2("back-top", "Target is not found.");
          }
          scrollElement.addEventListener("scroll", handleScroll);
          handleScroll();
        }
        function handleClick() {
          (isDocument(scrollElement) ? document.documentElement : scrollElement).scrollTo({
            top: 0,
            behavior: "smooth"
          });
        }
        function handleScroll() {
          scrollTopRef.value = (isDocument(scrollElement) ? document.documentElement : scrollElement).scrollTop;
          if (!DomInfoReadyRef.value) {
            void vue.nextTick(() => {
              DomInfoReadyRef.value = true;
            });
          }
        }
        function handleAfterEnter() {
          transitionDisabledRef.value = false;
        }
        vue.onMounted(() => {
          init();
          transitionDisabledRef.value = mergedShowRef.value;
        });
        vue.onBeforeUnmount(() => {
          if (scrollElement) {
            scrollElement.removeEventListener("scroll", handleScroll);
          }
        });
        const cssVarsRef = vue.computed(() => {
          const {
            self: {
              color,
              boxShadow,
              boxShadowHover,
              boxShadowPressed,
              iconColor,
              iconColorHover,
              iconColorPressed,
              width,
              height,
              iconSize,
              borderRadius,
              textColor
            },
            common: { cubicBezierEaseInOut }
          } = themeRef.value;
          return {
            "--n-bezier": cubicBezierEaseInOut,
            "--n-border-radius": borderRadius,
            "--n-height": height,
            "--n-width": width,
            "--n-box-shadow": boxShadow,
            "--n-box-shadow-hover": boxShadowHover,
            "--n-box-shadow-pressed": boxShadowPressed,
            "--n-color": color,
            "--n-icon-size": iconSize,
            "--n-icon-color": iconColor,
            "--n-icon-color-hover": iconColorHover,
            "--n-icon-color-pressed": iconColorPressed,
            "--n-text-color": textColor
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("back-top", void 0, cssVarsRef, props) : void 0;
        return {
          placeholderRef,
          style: styleRef,
          mergedShow: mergedShowRef,
          isMounted: isMounted(),
          scrollElement: vue.ref(null),
          scrollTop: scrollTopRef,
          DomInfoReady: DomInfoReadyRef,
          transitionDisabled: transitionDisabledRef,
          mergedClsPrefix: mergedClsPrefixRef,
          handleAfterEnter,
          handleScroll,
          handleClick,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender
        };
      },
      render() {
        const { mergedClsPrefix } = this;
        return /* @__PURE__ */ vue.h("div", {
          ref: "placeholderRef",
          class: `${mergedClsPrefix}-back-top-placeholder`,
          style: "display: none",
          "aria-hidden": true
        }, /* @__PURE__ */ vue.h(LazyTeleport, {
          to: this.to,
          show: this.mergedShow
        }, {
          default: () => /* @__PURE__ */ vue.h(vue.Transition, {
            name: "fade-in-scale-up-transition",
            appear: this.isMounted,
            onAfterEnter: this.handleAfterEnter
          }, {
            default: () => {
              this.onRender?.();
              return this.mergedShow ? vue.h(
                "div",
                vue.mergeProps(this.$attrs, {
                  class: [
                    `${mergedClsPrefix}-back-top`,
                    this.themeClass,
                    this.transitionDisabled && `${mergedClsPrefix}-back-top--transition-disabled`
                  ],
                  style: [this.style, this.cssVars],
                  onClick: this.handleClick
                }),
                resolveSlot(this.$slots.default, () => [
                  /* @__PURE__ */ vue.h(NBaseIcon, {
                    clsPrefix: mergedClsPrefix
                  }, { default: () => BackTopIcon })
                ])
              ) : null;
            }
          })
        }));
      }
    });

    const badgeDark = {
      name: "Badge",
      common: commonDark,

      self(vars) {
        const {
          errorColorSuppl,
          infoColorSuppl,
          successColorSuppl,
          warningColorSuppl,
          fontFamily
        } = vars;
        return {
          color: errorColorSuppl,
          colorInfo: infoColorSuppl,
          colorSuccess: successColorSuppl,
          colorError: errorColorSuppl,
          colorWarning: warningColorSuppl,
          fontSize: "12px",
          fontFamily
        };
      }

    };
    var badgeDark$1 = badgeDark;

    const self$$ = vars => {
      const {
        errorColor,
        infoColor,
        successColor,
        warningColor,
        fontFamily
      } = vars;
      return {
        color: errorColor,
        colorInfo: infoColor,
        colorSuccess: successColor,
        colorError: errorColor,
        colorWarning: warningColor,
        fontSize: "12px",
        fontFamily
      };
    };

    const badgeLight = {
      name: "Badge",
      common: commonLight,
      self: self$$
    };
    var badgeLight$1 = badgeLight;

    var rtlStyle$m = cB("badge", [cM("rtl", `
    direction: rtl;
  `, [cB("badge-sup", `
      right: 100%;
      left: unset;
      transform: translateX(50%);
      direction: initial;
    `)])]);

    const badgeRtl = {
      name: "Badge",
      style: rtlStyle$m
    };

    var style$1c = c$1([c$1("@keyframes badge-wave-spread", {
      from: {
        boxShadow: "0 0 0.5px 0px var(--n-ripple-color)",
        opacity: 0.6
      },
      to: {
        boxShadow: "0 0 0.5px 4.5px var(--n-ripple-color)",
        opacity: 0
      }
    }), cB("badge", `
    display: inline-flex;
    position: relative;
    vertical-align: middle;
    color: var(--n-color);
    font-family: var(--n-font-family);
  `, [cM("as-is", [cB("badge-sup", {
      position: "static",
      transform: "translateX(0)"
    }, [fadeInScaleUpTransition({
      transformOrigin: "left bottom",
      originalTransform: "translateX(0)"
    })])]), cM("dot", [cB("badge-sup", `
        height: 8px;
        width: 8px;
        padding: 0;
        min-width: 8px;
        left: 100%;
        bottom: calc(100% - 4px);
      `, [c$1("::before", "border-radius: 4px;")])]), cB("badge-sup", `
      background: var(--n-color);
      transition:
        background-color .3s var(--n-bezier),
        color .3s var(--n-bezier);
      color: #FFF;
      position: absolute;
      height: 18px;
      line-height: 18px;
      border-radius: 9px;
      padding: 0 6px;
      text-align: center;
      font-size: var(--n-font-size);
      transform: translateX(-50%);
      left: 100%;
      bottom: calc(100% - 9px);
      font-variant-numeric: tabular-nums;
      z-index: 1;
      display: flex;
      align-items: center;
    `, [fadeInScaleUpTransition({
      transformOrigin: "left bottom",
      originalTransform: "translateX(-50%)"
    }), cB("base-wave", {
      zIndex: 1,
      animationDuration: "2s",
      animationIterationCount: "infinite",
      animationDelay: "1s",
      animationTimingFunction: "var(--n-ripple-bezier)",
      animationName: "badge-wave-spread"
    }), c$1("&::before", `
        opacity: 0;
        transform: scale(1);
        border-radius: 9px;
        content: "";
        position: absolute;
        left: 0;
        right: 0;
        top: 0;
        bottom: 0;
      `)])])]);

    const badgeProps = {
      ...useTheme.props,
      value: [String, Number],
      max: Number,
      dot: Boolean,
      type: {
        type: String,
        default: "default"
      },
      show: {
        type: Boolean,
        default: true
      },
      showZero: Boolean,
      processing: Boolean,
      color: String
    };
    var Badge = vue.defineComponent({
      name: "Badge",
      props: badgeProps,
      setup(props, { slots }) {
        const { mergedClsPrefixRef, inlineThemeDisabled, mergedRtlRef } = useConfig(props);
        const themeRef = useTheme(
          "Badge",
          "-badge",
          style$1c,
          badgeLight$1,
          props,
          mergedClsPrefixRef
        );
        const appearedRef = vue.ref(false);
        const handleAfterEnter = () => {
          appearedRef.value = true;
        };
        const handleAfterLeave = () => {
          appearedRef.value = false;
        };
        const showBadgeRef = vue.computed(() => {
          return props.show && (props.dot || props.value !== void 0 && !(!props.showZero && props.value <= 0) || !isSlotEmpty(slots.value));
        });
        vue.onMounted(() => {
          if (showBadgeRef.value)
            appearedRef.value = true;
        });
        const rtlEnabledRef = useRtl("Badge", mergedRtlRef, mergedClsPrefixRef);
        const cssVarsRef = vue.computed(() => {
          const { type, color: propColor } = props;
          const {
            common: { cubicBezierEaseInOut, cubicBezierEaseOut },
            self: { [createKey("color", type)]: color, fontFamily, fontSize }
          } = themeRef.value;
          return {
            "--n-font-size": fontSize,
            "--n-font-family": fontFamily,
            "--n-color": propColor || color,
            "--n-ripple-color": propColor || color,
            "--n-bezier": cubicBezierEaseInOut,
            "--n-ripple-bezier": cubicBezierEaseOut
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass(
          "badge",
          vue.computed(() => {
            let hash = "";
            const { type, color } = props;
            if (type) {
              hash += type[0];
            }
            if (color) {
              hash += color2Class(color);
            }
            return hash;
          }),
          cssVarsRef,
          props
        ) : void 0;
        return {
          rtlEnabled: rtlEnabledRef,
          mergedClsPrefix: mergedClsPrefixRef,
          appeared: appearedRef,
          showBadge: showBadgeRef,
          handleAfterEnter,
          handleAfterLeave,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender
        };
      },
      render() {
        const { mergedClsPrefix, onRender, themeClass, $slots } = this;
        onRender?.();
        const children = $slots.default?.();
        return /* @__PURE__ */ vue.h("div", {
          class: [
            `${mergedClsPrefix}-badge`,
            this.rtlEnabled && `${mergedClsPrefix}-badge--rtl`,
            themeClass,
            {
              [`${mergedClsPrefix}-badge--dot`]: this.dot,
              [`${mergedClsPrefix}-badge--as-is`]: !children
            }
          ],
          style: this.cssVars
        }, children, /* @__PURE__ */ vue.h(vue.Transition, {
          name: "fade-in-scale-up-transition",
          onAfterEnter: this.handleAfterEnter,
          onAfterLeave: this.handleAfterLeave
        }, {
          default: () => this.showBadge ? /* @__PURE__ */ vue.h("sup", {
            class: `${mergedClsPrefix}-badge-sup`,
            title: getTitleAttribute(this.value)
          }, resolveSlot($slots.value, () => [
            !this.dot ? /* @__PURE__ */ vue.h(NBaseSlotMachine, {
              clsPrefix: mergedClsPrefix,
              appeared: this.appeared,
              max: this.max,
              value: this.value
            }) : null
          ]), this.processing ? /* @__PURE__ */ vue.h(NBaseWave, {
            clsPrefix: mergedClsPrefix
          }) : null) : null
        }));
      }
    });

    var commonVariables$g = {
      fontWeightActive: "400"
    };

    const self$_ = vars => {
      const {
        fontSize,
        textColor3,
        textColor2,
        borderRadius,
        buttonColor2Hover,
        buttonColor2Pressed
      } = vars;
      return { ...commonVariables$g,
        fontSize,
        itemLineHeight: "1.25",
        itemTextColor: textColor3,
        itemTextColorHover: textColor2,
        itemTextColorPressed: textColor2,
        itemTextColorActive: textColor2,
        itemBorderRadius: borderRadius,
        itemColorHover: buttonColor2Hover,
        itemColorPressed: buttonColor2Pressed,
        separatorColor: textColor3
      };
    };
    const breadcrumbLight = {
      name: "Breadcrumb",
      common: commonLight,
      self: self$_
    };
    var breadcrumbLight$1 = breadcrumbLight;

    const breadcrumbDark = {
      name: "Breadcrumb",
      common: commonDark,
      self: self$_
    };
    var breadcrumbDark$1 = breadcrumbDark;

    var style$1b = cB("breadcrumb", `
  white-space: nowrap;
  cursor: default;
  line-height: var(--n-item-line-height);
`, [c$1("ul", `
    list-style: none;
    padding: 0;
    margin: 0;
  `), c$1("a", `
    color: inherit;
    text-decoration: inherit;
  `), cB("breadcrumb-item", `
    font-size: var(--n-font-size);
    transition: color .3s var(--n-bezier);
    display: inline-flex;
    align-items: center;
  `, [cB("icon", `
      font-size: 18px;
      vertical-align: -.2em;
      transition: color .3s var(--n-bezier);
      color: var(--n-item-text-color);
    `), c$1("&:not(:last-child)", [cM("clickable", [cE("link", `
          cursor: pointer;
        `, [c$1("&:hover", `
            background-color: var(--n-item-color-hover);
          `), c$1("&:active", `
            background-color: var(--n-item-color-pressed);
          `)])])]), cE("link", `
      padding: 4px;
      border-radius: var(--n-item-border-radius);
      transition:
        background-color .3s var(--n-bezier),
        color .3s var(--n-bezier);
      color: var(--n-item-text-color);
      position: relative;
    `, [c$1("&:hover", `
        color: var(--n-item-text-color-hover);
      `, [cB("icon", `
          color: var(--n-item-text-color-hover);
        `)]), c$1("&:active", `
        color: var(--n-item-text-color-pressed);
      `, [cB("icon", `
          color: var(--n-item-text-color-pressed);
        `)])]), cE("separator", `
      margin: 0 8px;
      color: var(--n-separator-color);
      transition: color .3s var(--n-bezier);
      user-select: none;
      -webkit-user-select: none;
    `), c$1("&:last-child", [cE("link", `
        font-weight: var(--n-font-weight-active);
        cursor: unset;
        color: var(--n-item-text-color-active);
      `, [cB("icon", `
          color: var(--n-item-text-color-active);
        `)]), cE("separator", `
        display: none;
      `)])])]);

    const breadcrumbInjectionKey = createInjectionKey("n-breadcrumb");
    const breadcrumbProps = {
      ...useTheme.props,
      separator: {
        type: String,
        default: "/"
      }
    };
    var Breadcrumb = vue.defineComponent({
      name: "Breadcrumb",
      props: breadcrumbProps,
      setup(props) {
        const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
        const themeRef = useTheme(
          "Breadcrumb",
          "-breadcrumb",
          style$1b,
          breadcrumbLight$1,
          props,
          mergedClsPrefixRef
        );
        vue.provide(breadcrumbInjectionKey, {
          separatorRef: vue.toRef(props, "separator"),
          mergedClsPrefixRef
        });
        const cssVarsRef = vue.computed(() => {
          const {
            common: { cubicBezierEaseInOut },
            self: {
              separatorColor,
              itemTextColor,
              itemTextColorHover,
              itemTextColorPressed,
              itemTextColorActive,
              fontSize,
              fontWeightActive,
              itemBorderRadius,
              itemColorHover,
              itemColorPressed,
              itemLineHeight
            }
          } = themeRef.value;
          return {
            "--n-font-size": fontSize,
            "--n-bezier": cubicBezierEaseInOut,
            "--n-item-text-color": itemTextColor,
            "--n-item-text-color-hover": itemTextColorHover,
            "--n-item-text-color-pressed": itemTextColorPressed,
            "--n-item-text-color-active": itemTextColorActive,
            "--n-separator-color": separatorColor,
            "--n-item-color-hover": itemColorHover,
            "--n-item-color-pressed": itemColorPressed,
            "--n-item-border-radius": itemBorderRadius,
            "--n-font-weight-active": fontWeightActive,
            "--n-item-line-height": itemLineHeight
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("breadcrumb", void 0, cssVarsRef, props) : void 0;
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender
        };
      },
      render() {
        this.onRender?.();
        return /* @__PURE__ */ vue.h("nav", {
          class: [`${this.mergedClsPrefix}-breadcrumb`, this.themeClass],
          style: this.cssVars,
          "aria-label": "Breadcrumb"
        }, /* @__PURE__ */ vue.h("ul", null, this.$slots));
      }
    });

    const defaultWindow = isBrowser$2 ? window : null;
    const useBrowserLocation = function () {
      let customWindow = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultWindow;

      const getWindowLocation = () => {
        const {
          hash,
          host,
          hostname,
          href,
          origin,
          pathname,
          port,
          protocol,
          search
        } = (customWindow === null || customWindow === void 0 ? void 0 : customWindow.location) || {};
        return {
          hash,
          host,
          hostname,
          href,
          origin,
          pathname,
          port,
          protocol,
          search
        };
      };

      const updateLocation = () => {
        locationState.value = getWindowLocation();
      };

      const locationState = vue.ref(getWindowLocation());
      vue.onMounted(() => {
        if (customWindow) {
          customWindow.addEventListener("popstate", updateLocation);
          customWindow.addEventListener("hashchange", updateLocation);
        }
      });
      vue.onUnmounted(() => {
        if (customWindow) {
          customWindow.removeEventListener("popstate", updateLocation);
          customWindow.removeEventListener("hashchange", updateLocation);
        }
      });
      return locationState;
    };

    const breadcrumbItemProps = {
      separator: String,
      href: String,
      clickable: {
        type: Boolean,
        default: true
      },
      onClick: Function
    };
    var BreadcrumbItem = vue.defineComponent({
      name: "BreadcrumbItem",
      props: breadcrumbItemProps,
      setup(props, { slots }) {
        const NBreadcrumb = vue.inject(breadcrumbInjectionKey, null);
        if (!NBreadcrumb) {
          {
            warn$2(
              "breadcrumb",
              "`n-breadcrumb-item` must be placed inside `n-breadcrumb`."
            );
          }
          return () => null;
        }
        const { separatorRef, mergedClsPrefixRef } = NBreadcrumb;
        const browserLocationRef = useBrowserLocation();
        const htmlTagRef = vue.computed(() => props.href ? "a" : "span");
        const ariaCurrentRef = vue.computed(
          () => browserLocationRef.value.href === props.href ? "location" : null
        );
        return () => {
          const { value: mergedClsPrefix } = mergedClsPrefixRef;
          return /* @__PURE__ */ vue.h("li", {
            class: [
              `${mergedClsPrefix}-breadcrumb-item`,
              props.clickable && `${mergedClsPrefix}-breadcrumb-item--clickable`
            ]
          }, vue.h(
            htmlTagRef.value,
            {
              class: `${mergedClsPrefix}-breadcrumb-item__link`,
              "aria-current": ariaCurrentRef.value,
              href: props.href,
              onClick: props.onClick
            },
            slots
          ), /* @__PURE__ */ vue.h("span", {
            class: `${mergedClsPrefix}-breadcrumb-item__separator`,
            "aria-hidden": "true"
          }, resolveSlot(slots.separator, () => [
            props.separator ?? separatorRef.value
          ])));
        };
      }
    });

    function createHoverColor(rgb) {
      return composite(rgb, [255, 255, 255, 0.16]);
    }
    function createPressedColor(rgb) {
      return composite(rgb, [0, 0, 0, 0.12]);
    }

    const buttonGroupInjectionKey = createInjectionKey("n-button-group");

    var commonVariables$f = {
      paddingTiny: "0 6px",
      paddingSmall: "0 10px",
      paddingMedium: "0 14px",
      paddingLarge: "0 18px",
      paddingRoundTiny: "0 10px",
      paddingRoundSmall: "0 14px",
      paddingRoundMedium: "0 18px",
      paddingRoundLarge: "0 22px",
      iconMarginTiny: "6px",
      iconMarginSmall: "6px",
      iconMarginMedium: "6px",
      iconMarginLarge: "6px",
      iconSizeTiny: "14px",
      iconSizeSmall: "18px",
      iconSizeMedium: "18px",
      iconSizeLarge: "20px",
      rippleDuration: ".6s"
    };

    const self$Z = vars => {
      const {
        heightTiny,
        heightSmall,
        heightMedium,
        heightLarge,
        borderRadius,
        fontSizeTiny,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        opacityDisabled,
        textColor2,
        textColor3,
        primaryColorHover,
        primaryColorPressed,
        borderColor,
        primaryColor,
        baseColor,
        infoColor,
        infoColorHover,
        infoColorPressed,
        successColor,
        successColorHover,
        successColorPressed,
        warningColor,
        warningColorHover,
        warningColorPressed,
        errorColor,
        errorColorHover,
        errorColorPressed,
        fontWeight,
        buttonColor2,
        buttonColor2Hover,
        buttonColor2Pressed,
        fontWeightStrong
      } = vars;
      return { ...commonVariables$f,
        heightTiny,
        heightSmall,
        heightMedium,
        heightLarge,
        borderRadiusTiny: borderRadius,
        borderRadiusSmall: borderRadius,
        borderRadiusMedium: borderRadius,
        borderRadiusLarge: borderRadius,
        fontSizeTiny,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        opacityDisabled,
        colorOpacitySecondary: "0.16",
        colorOpacitySecondaryHover: "0.22",
        colorOpacitySecondaryPressed: "0.28",
        colorSecondary: buttonColor2,
        colorSecondaryHover: buttonColor2Hover,
        colorSecondaryPressed: buttonColor2Pressed,
        colorTertiary: buttonColor2,
        colorTertiaryHover: buttonColor2Hover,
        colorTertiaryPressed: buttonColor2Pressed,
        colorQuaternary: "#0000",
        colorQuaternaryHover: buttonColor2Hover,
        colorQuaternaryPressed: buttonColor2Pressed,
        color: "#0000",
        colorHover: "#0000",
        colorPressed: "#0000",
        colorFocus: "#0000",
        colorDisabled: "#0000",
        textColor: textColor2,
        textColorTertiary: textColor3,
        textColorHover: primaryColorHover,
        textColorPressed: primaryColorPressed,
        textColorFocus: primaryColorHover,
        textColorDisabled: textColor2,
        textColorText: textColor2,
        textColorTextHover: primaryColorHover,
        textColorTextPressed: primaryColorPressed,
        textColorTextFocus: primaryColorHover,
        textColorTextDisabled: textColor2,
        textColorGhost: textColor2,
        textColorGhostHover: primaryColorHover,
        textColorGhostPressed: primaryColorPressed,
        textColorGhostFocus: primaryColorHover,
        textColorGhostDisabled: textColor2,
        border: `1px solid ${borderColor}`,
        borderHover: `1px solid ${primaryColorHover}`,
        borderPressed: `1px solid ${primaryColorPressed}`,
        borderFocus: `1px solid ${primaryColorHover}`,
        borderDisabled: `1px solid ${borderColor}`,
        rippleColor: primaryColor,
        colorPrimary: primaryColor,
        colorHoverPrimary: primaryColorHover,
        colorPressedPrimary: primaryColorPressed,
        colorFocusPrimary: primaryColorHover,
        colorDisabledPrimary: primaryColor,
        textColorPrimary: baseColor,
        textColorHoverPrimary: baseColor,
        textColorPressedPrimary: baseColor,
        textColorFocusPrimary: baseColor,
        textColorDisabledPrimary: baseColor,
        textColorTextPrimary: primaryColor,
        textColorTextHoverPrimary: primaryColorHover,
        textColorTextPressedPrimary: primaryColorPressed,
        textColorTextFocusPrimary: primaryColorHover,
        textColorTextDisabledPrimary: textColor2,
        textColorGhostPrimary: primaryColor,
        textColorGhostHoverPrimary: primaryColorHover,
        textColorGhostPressedPrimary: primaryColorPressed,
        textColorGhostFocusPrimary: primaryColorHover,
        textColorGhostDisabledPrimary: primaryColor,
        borderPrimary: `1px solid ${primaryColor}`,
        borderHoverPrimary: `1px solid ${primaryColorHover}`,
        borderPressedPrimary: `1px solid ${primaryColorPressed}`,
        borderFocusPrimary: `1px solid ${primaryColorHover}`,
        borderDisabledPrimary: `1px solid ${primaryColor}`,
        rippleColorPrimary: primaryColor,
        colorInfo: infoColor,
        colorHoverInfo: infoColorHover,
        colorPressedInfo: infoColorPressed,
        colorFocusInfo: infoColorHover,
        colorDisabledInfo: infoColor,
        textColorInfo: baseColor,
        textColorHoverInfo: baseColor,
        textColorPressedInfo: baseColor,
        textColorFocusInfo: baseColor,
        textColorDisabledInfo: baseColor,
        textColorTextInfo: infoColor,
        textColorTextHoverInfo: infoColorHover,
        textColorTextPressedInfo: infoColorPressed,
        textColorTextFocusInfo: infoColorHover,
        textColorTextDisabledInfo: textColor2,
        textColorGhostInfo: infoColor,
        textColorGhostHoverInfo: infoColorHover,
        textColorGhostPressedInfo: infoColorPressed,
        textColorGhostFocusInfo: infoColorHover,
        textColorGhostDisabledInfo: infoColor,
        borderInfo: `1px solid ${infoColor}`,
        borderHoverInfo: `1px solid ${infoColorHover}`,
        borderPressedInfo: `1px solid ${infoColorPressed}`,
        borderFocusInfo: `1px solid ${infoColorHover}`,
        borderDisabledInfo: `1px solid ${infoColor}`,
        rippleColorInfo: infoColor,
        colorSuccess: successColor,
        colorHoverSuccess: successColorHover,
        colorPressedSuccess: successColorPressed,
        colorFocusSuccess: successColorHover,
        colorDisabledSuccess: successColor,
        textColorSuccess: baseColor,
        textColorHoverSuccess: baseColor,
        textColorPressedSuccess: baseColor,
        textColorFocusSuccess: baseColor,
        textColorDisabledSuccess: baseColor,
        textColorTextSuccess: successColor,
        textColorTextHoverSuccess: successColorHover,
        textColorTextPressedSuccess: successColorPressed,
        textColorTextFocusSuccess: successColorHover,
        textColorTextDisabledSuccess: textColor2,
        textColorGhostSuccess: successColor,
        textColorGhostHoverSuccess: successColorHover,
        textColorGhostPressedSuccess: successColorPressed,
        textColorGhostFocusSuccess: successColorHover,
        textColorGhostDisabledSuccess: successColor,
        borderSuccess: `1px solid ${successColor}`,
        borderHoverSuccess: `1px solid ${successColorHover}`,
        borderPressedSuccess: `1px solid ${successColorPressed}`,
        borderFocusSuccess: `1px solid ${successColorHover}`,
        borderDisabledSuccess: `1px solid ${successColor}`,
        rippleColorSuccess: successColor,
        colorWarning: warningColor,
        colorHoverWarning: warningColorHover,
        colorPressedWarning: warningColorPressed,
        colorFocusWarning: warningColorHover,
        colorDisabledWarning: warningColor,
        textColorWarning: baseColor,
        textColorHoverWarning: baseColor,
        textColorPressedWarning: baseColor,
        textColorFocusWarning: baseColor,
        textColorDisabledWarning: baseColor,
        textColorTextWarning: warningColor,
        textColorTextHoverWarning: warningColorHover,
        textColorTextPressedWarning: warningColorPressed,
        textColorTextFocusWarning: warningColorHover,
        textColorTextDisabledWarning: textColor2,
        textColorGhostWarning: warningColor,
        textColorGhostHoverWarning: warningColorHover,
        textColorGhostPressedWarning: warningColorPressed,
        textColorGhostFocusWarning: warningColorHover,
        textColorGhostDisabledWarning: warningColor,
        borderWarning: `1px solid ${warningColor}`,
        borderHoverWarning: `1px solid ${warningColorHover}`,
        borderPressedWarning: `1px solid ${warningColorPressed}`,
        borderFocusWarning: `1px solid ${warningColorHover}`,
        borderDisabledWarning: `1px solid ${warningColor}`,
        rippleColorWarning: warningColor,
        colorError: errorColor,
        colorHoverError: errorColorHover,
        colorPressedError: errorColorPressed,
        colorFocusError: errorColorHover,
        colorDisabledError: errorColor,
        textColorError: baseColor,
        textColorHoverError: baseColor,
        textColorPressedError: baseColor,
        textColorFocusError: baseColor,
        textColorDisabledError: baseColor,
        textColorTextError: errorColor,
        textColorTextHoverError: errorColorHover,
        textColorTextPressedError: errorColorPressed,
        textColorTextFocusError: errorColorHover,
        textColorTextDisabledError: textColor2,
        textColorGhostError: errorColor,
        textColorGhostHoverError: errorColorHover,
        textColorGhostPressedError: errorColorPressed,
        textColorGhostFocusError: errorColorHover,
        textColorGhostDisabledError: errorColor,
        borderError: `1px solid ${errorColor}`,
        borderHoverError: `1px solid ${errorColorHover}`,
        borderPressedError: `1px solid ${errorColorPressed}`,
        borderFocusError: `1px solid ${errorColorHover}`,
        borderDisabledError: `1px solid ${errorColor}`,
        rippleColorError: errorColor,
        waveOpacity: "0.6",
        fontWeight,
        fontWeightStrong
      };
    };
    const buttonLight = {
      name: "Button",
      common: commonLight,
      self: self$Z
    };
    var buttonLight$1 = buttonLight;

    const buttonDark = {
      name: "Button",
      common: commonDark,

      self(vars) {
        const commonSelf = self$Z(vars);
        commonSelf.waveOpacity = "0.8";
        commonSelf.colorOpacitySecondary = "0.16";
        commonSelf.colorOpacitySecondaryHover = "0.2";
        commonSelf.colorOpacitySecondaryPressed = "0.12";
        return commonSelf;
      }

    };
    var buttonDark$1 = buttonDark;

    var rtlStyle$l = cB("button", [cM("rtl", `
    direction: rtl;
  `, [cE("icon", {
      margin: "var(--n-icon-margin)",
      marginRight: 0
    }), cE("content", [c$1("~", [cE("icon", {
      margin: "var(--n-icon-margin)",
      marginLeft: 0
    })])])])]);

    const buttonRtl = {
      name: "Button",
      style: rtlStyle$l
    };

    var style$1a = c$1([cB("button", `
    margin: 0;
    font-weight: var(--n-font-weight);
    line-height: 1;
    font-family: inherit;
    padding: var(--n-padding);
    height: var(--n-height);
    font-size: var(--n-font-size);
    border-radius: var(--n-border-radius);
    color: var(--n-text-color);
    background-color: var(--n-color);
    width: var(--n-width);
    white-space: nowrap;
    outline: none;
    position: relative;
    z-index: auto;
    border: none;
    display: inline-flex;
    flex-wrap: nowrap;
    flex-shrink: 0;
    align-items: center;
    justify-content: center;
    user-select: none;
    -webkit-user-select: none;
    text-align: center;
    cursor: pointer;
    text-decoration: none;
    transition:
      color .3s var(--n-bezier),
      background-color .3s var(--n-bezier),
      opacity .3s var(--n-bezier),
      border-color .3s var(--n-bezier);
  `, [cM("color", [cE("border", {
      borderColor: "var(--n-border-color)"
    }), cM("disabled", [cE("border", {
      borderColor: "var(--n-border-color-disabled)"
    })]), cNotM("disabled", [c$1("&:focus", [cE("state-border", {
      borderColor: "var(--n-border-color-focus)"
    })]), c$1("&:hover", [cE("state-border", {
      borderColor: "var(--n-border-color-hover)"
    })]), c$1("&:active", [cE("state-border", {
      borderColor: "var(--n-border-color-pressed)"
    })]), cM("pressed", [cE("state-border", {
      borderColor: "var(--n-border-color-pressed)"
    })])])]), cM("disabled", {
      backgroundColor: "var(--n-color-disabled)",
      color: "var(--n-text-color-disabled)"
    }, [cE("border", {
      border: "var(--n-border-disabled)"
    })]), cNotM("disabled", [c$1("&:focus", {
      backgroundColor: "var(--n-color-focus)",
      color: "var(--n-text-color-focus)"
    }, [cE("state-border", {
      border: "var(--n-border-focus)"
    })]), c$1("&:hover", {
      backgroundColor: "var(--n-color-hover)",
      color: "var(--n-text-color-hover)"
    }, [cE("state-border", {
      border: "var(--n-border-hover)"
    })]), c$1("&:active", {
      backgroundColor: "var(--n-color-pressed)",
      color: "var(--n-text-color-pressed)"
    }, [cE("state-border", {
      border: "var(--n-border-pressed)"
    })]), cM("pressed", {
      backgroundColor: "var(--n-color-pressed)",
      color: "var(--n-text-color-pressed)"
    }, [cE("state-border", {
      border: "var(--n-border-pressed)"
    })])]), cM("loading", "cursor: wait;"), cB("base-wave", `
      pointer-events: none;
      top: 0;
      right: 0;
      bottom: 0;
      left: 0;
      animation-iteration-count: 1;
      animation-duration: var(--n-ripple-duration);
      animation-timing-function: var(--n-bezier-ease-out), var(--n-bezier-ease-out);
    `, [cM("active", {
      zIndex: 1,
      animationName: "button-wave-spread, button-wave-opacity"
    })]), isBrowser$2 && "MozBoxSizing" in document.createElement("div").style ? c$1("&::moz-focus-inner", {
      border: 0
    }) : null, cE("border, state-border", `
      position: absolute;
      left: 0;
      top: 0;
      right: 0;
      bottom: 0;
      border-radius: inherit;
      transition: border-color .3s var(--n-bezier);
      pointer-events: none;
    `), cE("border", {
      border: "var(--n-border)"
    }), cE("state-border", {
      border: "var(--n-border)",
      borderColor: "#0000",
      zIndex: 1
    }), cE("icon", `
      margin: var(--n-icon-margin);
      margin-left: 0;
      height: var(--n-icon-size);
      width: var(--n-icon-size);
      max-width: var(--n-icon-size);
      font-size: var(--n-icon-size);
      position: relative;
      flex-shrink: 0;
    `, [cB("icon-slot", `
        height: var(--n-icon-size);
        width: var(--n-icon-size);
        position: absolute;
        left: 0;
        top: 50%;
        transform: translateY(-50%);
        display: flex;
        align-items: center;
        justify-content: center;
      `, [iconSwitchTransition({
      top: "50%",
      originalTransform: "translateY(-50%)"
    })]), fadeInWidthExpandTransition()]), cE("content", `
      display: flex;
      align-items: center;
      flex-wrap: nowrap;
      min-width: 0;
    `, [c$1("~", [cE("icon", {
      margin: "var(--n-icon-margin)",
      marginRight: 0
    })])]), cM("block", `
      display: flex;
      width: 100%;
    `), cM("dashed", [cE("border, state-border", {
      borderStyle: "dashed !important"
    })]), cM("disabled", {
      cursor: "not-allowed",
      opacity: "var(--n-opacity-disabled)"
    })]), c$1("@keyframes button-wave-spread", {
      from: {
        boxShadow: "0 0 0.5px 0 var(--n-ripple-color)"
      },
      to: {
        boxShadow: "0 0 0.5px 4.5px var(--n-ripple-color)"
      }
    }), c$1("@keyframes button-wave-opacity", {
      from: {
        opacity: "var(--n-wave-opacity)"
      },
      to: {
        opacity: 0
      }
    })]);

    const buttonProps = {
      ...useTheme.props,
      color: String,
      textColor: String,
      text: Boolean,
      block: Boolean,
      loading: Boolean,
      disabled: Boolean,
      circle: Boolean,
      size: String,
      ghost: Boolean,
      round: Boolean,
      secondary: Boolean,
      tertiary: Boolean,
      quaternary: Boolean,
      strong: Boolean,
      focusable: {
        type: Boolean,
        default: true
      },
      keyboard: {
        type: Boolean,
        default: true
      },
      tag: {
        type: String,
        default: "button"
      },
      type: {
        type: String,
        default: "default"
      },
      dashed: Boolean,
      iconPlacement: {
        type: String,
        default: "left"
      },
      attrType: {
        type: String,
        default: "button"
      },
      bordered: {
        type: Boolean,
        default: true
      },
      onClick: [Function, Array],
      nativeFocusBehavior: {
        type: Boolean,
        default: !isSafari
      }
    };
    const Button = vue.defineComponent({
      name: "Button",
      props: buttonProps,
      setup(props) {
        {
          vue.watchEffect(() => {
            const { dashed, ghost, text, secondary, tertiary, quaternary } = props;
            if ((dashed || ghost || text) && (secondary || tertiary || quaternary)) {
              warnOnce(
                "button",
                "`dashed`, `ghost` and `text` props can't be used along with `secondary`, `tertiary` and `quaterary` props."
              );
            }
          });
        }
        const selfElRef = vue.ref(null);
        const waveElRef = vue.ref(null);
        const enterPressedRef = vue.ref(false);
        const showBorderRef = useMemo(() => {
          return !props.quaternary && !props.tertiary && !props.secondary && !props.text && (!props.color || props.ghost || props.dashed) && props.bordered;
        });
        const NButtonGroup = vue.inject(buttonGroupInjectionKey, {});
        const { mergedSizeRef } = useFormItem(
          {},
          {
            defaultSize: "medium",
            mergedSize: (NFormItem) => {
              const { size } = props;
              if (size)
                return size;
              const { size: buttonGroupSize } = NButtonGroup;
              if (buttonGroupSize)
                return buttonGroupSize;
              const { mergedSize: formItemSize } = NFormItem || {};
              if (formItemSize) {
                return formItemSize.value;
              }
              return "medium";
            }
          }
        );
        const mergedFocusableRef = vue.computed(() => {
          return props.focusable && !props.disabled;
        });
        const handleMousedown = (e) => {
          if (!mergedFocusableRef.value) {
            e.preventDefault();
          }
          if (props.nativeFocusBehavior) {
            return;
          }
          e.preventDefault();
          if (props.disabled) {
            return;
          }
          if (mergedFocusableRef.value) {
            selfElRef.value?.focus({ preventScroll: true });
          }
        };
        const handleClick = (e) => {
          if (!props.disabled && !props.loading) {
            const { onClick } = props;
            if (onClick)
              call(onClick, e);
            if (!props.text) {
              waveElRef.value?.play();
            }
          }
        };
        const handleKeyup = (e) => {
          switch (e.key) {
            case "Enter":
              if (!props.keyboard) {
                return;
              }
              enterPressedRef.value = false;
          }
        };
        const handleKeydown = (e) => {
          switch (e.key) {
            case "Enter":
              if (!props.keyboard || props.loading) {
                e.preventDefault();
                return;
              }
              enterPressedRef.value = true;
          }
        };
        const handleBlur = () => {
          enterPressedRef.value = false;
        };
        const { inlineThemeDisabled, mergedClsPrefixRef, mergedRtlRef } = useConfig(props);
        const themeRef = useTheme(
          "Button",
          "-button",
          style$1a,
          buttonLight$1,
          props,
          mergedClsPrefixRef
        );
        const rtlEnabledRef = useRtl("Button", mergedRtlRef, mergedClsPrefixRef);
        const cssVarsRef = vue.computed(() => {
          const theme = themeRef.value;
          const {
            common: { cubicBezierEaseInOut, cubicBezierEaseOut },
            self
          } = theme;
          const { rippleDuration, opacityDisabled, fontWeight, fontWeightStrong } = self;
          const size = mergedSizeRef.value;
          const {
            dashed,
            type,
            ghost,
            text,
            color,
            round,
            circle,
            textColor,
            secondary,
            tertiary,
            quaternary,
            strong
          } = props;
          const fontProps = {
            "font-weight": strong ? fontWeightStrong : fontWeight
          };
          let colorProps = {
            "--n-color": "initial",
            "--n-color-hover": "initial",
            "--n-color-pressed": "initial",
            "--n-color-focus": "initial",
            "--n-color-disabled": "initial",
            "--n-ripple-color": "initial",
            "--n-text-color": "initial",
            "--n-text-color-hover": "initial",
            "--n-text-color-pressed": "initial",
            "--n-text-color-focus": "initial",
            "--n-text-color-disabled": "initial"
          };
          const typeIsTertiary = type === "tertiary";
          const typeIsDefault = type === "default";
          const mergedType = typeIsTertiary ? "default" : type;
          if (text) {
            const propTextColor = textColor || color;
            const mergedTextColor = propTextColor || self[createKey("textColorText", mergedType)];
            colorProps = {
              "--n-color": "#0000",
              "--n-color-hover": "#0000",
              "--n-color-pressed": "#0000",
              "--n-color-focus": "#0000",
              "--n-color-disabled": "#0000",
              "--n-ripple-color": "#0000",
              "--n-text-color": mergedTextColor,
              "--n-text-color-hover": propTextColor ? createHoverColor(propTextColor) : self[createKey("textColorTextHover", mergedType)],
              "--n-text-color-pressed": propTextColor ? createPressedColor(propTextColor) : self[createKey("textColorTextPressed", mergedType)],
              "--n-text-color-focus": propTextColor ? createHoverColor(propTextColor) : self[createKey("textColorTextHover", mergedType)],
              "--n-text-color-disabled": propTextColor || self[createKey("textColorTextDisabled", mergedType)]
            };
          } else if (ghost || dashed) {
            const mergedTextColor = textColor || color;
            colorProps = {
              "--n-color": "#0000",
              "--n-color-hover": "#0000",
              "--n-color-pressed": "#0000",
              "--n-color-focus": "#0000",
              "--n-color-disabled": "#0000",
              "--n-ripple-color": color || self[createKey("rippleColor", mergedType)],
              "--n-text-color": mergedTextColor || self[createKey("textColorGhost", mergedType)],
              "--n-text-color-hover": mergedTextColor ? createHoverColor(mergedTextColor) : self[createKey("textColorGhostHover", mergedType)],
              "--n-text-color-pressed": mergedTextColor ? createPressedColor(mergedTextColor) : self[createKey("textColorGhostPressed", mergedType)],
              "--n-text-color-focus": mergedTextColor ? createHoverColor(mergedTextColor) : self[createKey("textColorGhostHover", mergedType)],
              "--n-text-color-disabled": mergedTextColor || self[createKey("textColorGhostDisabled", mergedType)]
            };
          } else if (secondary) {
            const typeTextColor = typeIsDefault ? self.textColor : typeIsTertiary ? self.textColorTertiary : self[createKey("color", mergedType)];
            const mergedTextColor = color || typeTextColor;
            const isColoredType = type !== "default" && type !== "tertiary";
            colorProps = {
              "--n-color": isColoredType ? changeColor(mergedTextColor, {
                alpha: Number(self.colorOpacitySecondary)
              }) : self.colorSecondary,
              "--n-color-hover": isColoredType ? changeColor(mergedTextColor, {
                alpha: Number(self.colorOpacitySecondaryHover)
              }) : self.colorSecondaryHover,
              "--n-color-pressed": isColoredType ? changeColor(mergedTextColor, {
                alpha: Number(self.colorOpacitySecondaryPressed)
              }) : self.colorSecondaryPressed,
              "--n-color-focus": isColoredType ? changeColor(mergedTextColor, {
                alpha: Number(self.colorOpacitySecondaryHover)
              }) : self.colorSecondaryHover,
              "--n-color-disabled": self.colorSecondary,
              "--n-ripple-color": "#0000",
              "--n-text-color": mergedTextColor,
              "--n-text-color-hover": mergedTextColor,
              "--n-text-color-pressed": mergedTextColor,
              "--n-text-color-focus": mergedTextColor,
              "--n-text-color-disabled": mergedTextColor
            };
          } else if (tertiary || quaternary) {
            const typeColor = typeIsDefault ? self.textColor : typeIsTertiary ? self.textColorTertiary : self[createKey("color", mergedType)];
            const mergedColor = color || typeColor;
            if (tertiary) {
              colorProps["--n-color"] = self.colorTertiary;
              colorProps["--n-color-hover"] = self.colorTertiaryHover;
              colorProps["--n-color-pressed"] = self.colorTertiaryPressed;
              colorProps["--n-color-focus"] = self.colorSecondaryHover;
              colorProps["--n-color-disabled"] = self.colorTertiary;
            } else {
              colorProps["--n-color"] = self.colorQuaternary;
              colorProps["--n-color-hover"] = self.colorQuaternaryHover;
              colorProps["--n-color-pressed"] = self.colorQuaternaryPressed;
              colorProps["--n-color-focus"] = self.colorQuaternaryHover;
              colorProps["--n-color-disabled"] = self.colorQuaternary;
            }
            colorProps["--n-ripple-color"] = "#0000";
            colorProps["--n-text-color"] = mergedColor;
            colorProps["--n-text-color-hover"] = mergedColor;
            colorProps["--n-text-color-pressed"] = mergedColor;
            colorProps["--n-text-color-focus"] = mergedColor;
            colorProps["--n-text-color-disabled"] = mergedColor;
          } else {
            colorProps = {
              "--n-color": color || self[createKey("color", mergedType)],
              "--n-color-hover": color ? createHoverColor(color) : self[createKey("colorHover", mergedType)],
              "--n-color-pressed": color ? createPressedColor(color) : self[createKey("colorPressed", mergedType)],
              "--n-color-focus": color ? createHoverColor(color) : self[createKey("colorFocus", mergedType)],
              "--n-color-disabled": color || self[createKey("colorDisabled", mergedType)],
              "--n-ripple-color": color || self[createKey("rippleColor", mergedType)],
              "--n-text-color": textColor || (color ? self.textColorPrimary : typeIsTertiary ? self.textColorTertiary : self[createKey("textColor", mergedType)]),
              "--n-text-color-hover": textColor || (color ? self.textColorHoverPrimary : self[createKey("textColorHover", mergedType)]),
              "--n-text-color-pressed": textColor || (color ? self.textColorPressedPrimary : self[createKey("textColorPressed", mergedType)]),
              "--n-text-color-focus": textColor || (color ? self.textColorFocusPrimary : self[createKey("textColorFocus", mergedType)]),
              "--n-text-color-disabled": textColor || (color ? self.textColorDisabledPrimary : self[createKey("textColorDisabled", mergedType)])
            };
          }
          let borderProps = {
            "--n-border": "initial",
            "--n-border-hover": "initial",
            "--n-border-pressed": "initial",
            "--n-border-focus": "initial",
            "--n-border-disabled": "initial"
          };
          if (text) {
            borderProps = {
              "--n-border": "none",
              "--n-border-hover": "none",
              "--n-border-pressed": "none",
              "--n-border-focus": "none",
              "--n-border-disabled": "none"
            };
          } else {
            borderProps = {
              "--n-border": self[createKey("border", mergedType)],
              "--n-border-hover": self[createKey("borderHover", mergedType)],
              "--n-border-pressed": self[createKey("borderPressed", mergedType)],
              "--n-border-focus": self[createKey("borderFocus", mergedType)],
              "--n-border-disabled": self[createKey("borderDisabled", mergedType)]
            };
          }
          const {
            [createKey("height", size)]: height,
            [createKey("fontSize", size)]: fontSize,
            [createKey("padding", size)]: padding,
            [createKey("paddingRound", size)]: paddingRound,
            [createKey("iconSize", size)]: iconSize,
            [createKey("borderRadius", size)]: borderRadius,
            [createKey("iconMargin", size)]: iconMargin,
            waveOpacity
          } = self;
          const sizeProps = {
            "--n-width": circle && !text ? height : "initial",
            "--n-height": text ? "initial" : height,
            "--n-font-size": fontSize,
            "--n-padding": circle ? "initial" : text ? "initial" : round ? paddingRound : padding,
            "--n-icon-size": iconSize,
            "--n-icon-margin": iconMargin,
            "--n-border-radius": text ? "initial" : circle || round ? height : borderRadius
          };
          return {
            "--n-bezier": cubicBezierEaseInOut,
            "--n-bezier-ease-out": cubicBezierEaseOut,
            "--n-ripple-duration": rippleDuration,
            "--n-opacity-disabled": opacityDisabled,
            "--n-wave-opacity": waveOpacity,
            ...fontProps,
            ...colorProps,
            ...borderProps,
            ...sizeProps
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass(
          "button",
          vue.computed(() => {
            let hash = "";
            const {
              dashed,
              type,
              ghost,
              text,
              color,
              round,
              circle,
              textColor,
              secondary,
              tertiary,
              quaternary,
              strong
            } = props;
            if (dashed)
              hash += "a";
            if (ghost)
              hash += "b";
            if (text)
              hash += "c";
            if (round)
              hash += "d";
            if (circle)
              hash += "e";
            if (secondary)
              hash += "f";
            if (tertiary)
              hash += "g";
            if (quaternary)
              hash += "h";
            if (strong)
              hash += "i";
            if (color)
              hash += "j" + color2Class(color);
            if (textColor)
              hash += "k" + color2Class(textColor);
            const { value: size } = mergedSizeRef;
            hash += "l" + size[0];
            hash += "m" + type[0];
            return hash;
          }),
          cssVarsRef,
          props
        ) : void 0;
        return {
          selfElRef,
          waveElRef,
          mergedClsPrefix: mergedClsPrefixRef,
          mergedFocusable: mergedFocusableRef,
          mergedSize: mergedSizeRef,
          showBorder: showBorderRef,
          enterPressed: enterPressedRef,
          rtlEnabled: rtlEnabledRef,
          handleMousedown,
          handleKeydown,
          handleBlur,
          handleKeyup,
          handleClick,
          customColorCssVars: vue.computed(() => {
            const { color } = props;
            if (!color)
              return null;
            const hoverColor = createHoverColor(color);
            return {
              "--n-border-color": color,
              "--n-border-color-hover": hoverColor,
              "--n-border-color-pressed": createPressedColor(color),
              "--n-border-color-focus": hoverColor,
              "--n-border-color-disabled": color
            };
          }),
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender
        };
      },
      render() {
        const { mergedClsPrefix, tag: Component, onRender } = this;
        onRender?.();
        const children = resolveWrappedSlot(
          this.$slots.default,
          (children2) => children2 && /* @__PURE__ */ vue.h("span", {
            class: `${mergedClsPrefix}-button__content`
          }, children2)
        );
        return /* @__PURE__ */ vue.h(Component, {
          ref: "selfElRef",
          class: [
            this.themeClass,
            `${mergedClsPrefix}-button`,
            `${mergedClsPrefix}-button--${this.type}-type`,
            `${mergedClsPrefix}-button--${this.mergedSize}-type`,
            this.rtlEnabled && `${mergedClsPrefix}-button--rtl`,
            this.disabled && `${mergedClsPrefix}-button--disabled`,
            this.block && `${mergedClsPrefix}-button--block`,
            this.enterPressed && `${mergedClsPrefix}-button--pressed`,
            !this.text && this.dashed && `${mergedClsPrefix}-button--dashed`,
            this.color && `${mergedClsPrefix}-button--color`,
            this.secondary && `${mergedClsPrefix}-button--secondary`,
            this.loading && `${mergedClsPrefix}-button--loading`,
            this.ghost && `${mergedClsPrefix}-button--ghost`
          ],
          tabindex: this.mergedFocusable ? 0 : -1,
          type: this.attrType,
          style: this.cssVars,
          disabled: this.disabled,
          onClick: this.handleClick,
          onBlur: this.handleBlur,
          onMousedown: this.handleMousedown,
          onKeyup: this.handleKeyup,
          onKeydown: this.handleKeydown
        }, this.iconPlacement === "right" && children, /* @__PURE__ */ vue.h(NFadeInExpandTransition, {
          width: true
        }, {
          default: () => resolveWrappedSlot(
            this.$slots.icon,
            (children2) => (this.loading || children2) && /* @__PURE__ */ vue.h("span", {
              class: `${mergedClsPrefix}-button__icon`,
              style: {
                margin: isSlotEmpty(this.$slots.default) ? "0" : ""
              }
            }, /* @__PURE__ */ vue.h(NIconSwitchTransition, null, {
              default: () => this.loading ? /* @__PURE__ */ vue.h(NBaseLoading, {
                clsPrefix: mergedClsPrefix,
                key: "loading",
                class: `${mergedClsPrefix}-icon-slot`,
                strokeWidth: 20
              }) : /* @__PURE__ */ vue.h("div", {
                key: "icon",
                class: `${mergedClsPrefix}-icon-slot`,
                role: "none"
              }, children2)
            }))
          )
        }), this.iconPlacement === "left" && children, !this.text ? /* @__PURE__ */ vue.h(NBaseWave, {
          ref: "waveElRef",
          clsPrefix: mergedClsPrefix
        }) : null, this.showBorder ? /* @__PURE__ */ vue.h("div", {
          "aria-hidden": true,
          class: `${mergedClsPrefix}-button__border`,
          style: this.customColorCssVars
        }) : null, this.showBorder ? /* @__PURE__ */ vue.h("div", {
          "aria-hidden": true,
          class: `${mergedClsPrefix}-button__state-border`,
          style: this.customColorCssVars
        }) : null);
      }
    });
    var NButton = Button;
    const XButton = Button;

    const zero = "0!important";
    const n1 = "-1px!important";

    function createLeftBorderStyle(type) {
      return cM(type + "-type", [c$1("& +", [cB("button", {}, [cM(type + "-type", [cE("border", {
        borderLeftWidth: zero
      }), cE("state-border", {
        left: n1
      })])])])]);
    }

    function createTopBorderStyle(type) {
      return cM(type + "-type", [c$1("& +", [cB("button", [cM(type + "-type", [cE("border", {
        borderTopWidth: zero
      }), cE("state-border", {
        top: n1
      })])])])]);
    }

    var style$19 = cB("button-group", `
  flex-wrap: nowrap;
  display: inline-flex;
  position: relative;
`, [cNotM("vertical", {
      flexDirection: "row"
    }, [cNotM("rtl", [cB("button", [c$1("&:first-child:not(:last-child)", `
          margin-right: ${zero};
          border-top-right-radius: ${zero};
          border-bottom-right-radius: ${zero};
        `), c$1("&:last-child:not(:first-child)", `
          margin-left: ${zero};
          border-top-left-radius: ${zero};
          border-bottom-left-radius: ${zero};
        `), c$1("&:not(:first-child):not(:last-child)", `
          margin-left: ${zero};
          margin-right: ${zero};
          border-radius: ${zero};
        `), createLeftBorderStyle("default"), cM("ghost", [createLeftBorderStyle("primary"), createLeftBorderStyle("info"), createLeftBorderStyle("success"), createLeftBorderStyle("warning"), createLeftBorderStyle("error")])])])]), cM("vertical", {
      flexDirection: "column"
    }, [cB("button", [c$1("&:first-child:not(:last-child)", `
        margin-bottom: ${zero};
        margin-left: ${zero};
        margin-right: ${zero};
        border-bottom-left-radius: ${zero};
        border-bottom-right-radius: ${zero};
      `), c$1("&:last-child:not(:first-child)", `
        margin-top: ${zero};
        margin-left: ${zero};
        margin-right: ${zero};
        border-top-left-radius: ${zero};
        border-top-right-radius: ${zero};
      `), c$1("&:not(:first-child):not(:last-child)", `
        margin: ${zero};
        border-radius: ${zero};
      `), createTopBorderStyle("default"), cM("ghost", [createTopBorderStyle("primary"), createTopBorderStyle("info"), createTopBorderStyle("success"), createTopBorderStyle("warning"), createTopBorderStyle("error")])])])]);

    const buttonGroupProps = {
      size: {
        type: String,
        default: void 0
      },
      vertical: Boolean
    };
    var NButtonGroup = vue.defineComponent({
      name: "ButtonGroup",
      props: buttonGroupProps,
      setup(props) {
        const { mergedClsPrefixRef, mergedRtlRef } = useConfig(props);
        useStyle("-button-group", style$19, mergedClsPrefixRef);
        vue.provide(buttonGroupInjectionKey, props);
        const rtlEnabledRef = useRtl(
          "ButtonGroup",
          mergedRtlRef,
          mergedClsPrefixRef
        );
        return {
          rtlEnabled: rtlEnabledRef,
          mergedClsPrefix: mergedClsPrefixRef
        };
      },
      render() {
        const { mergedClsPrefix } = this;
        return /* @__PURE__ */ vue.h("div", {
          class: [
            `${mergedClsPrefix}-button-group`,
            this.rtlEnabled && `${mergedClsPrefix}-button-group--rtl`,
            this.vertical && `${mergedClsPrefix}-button-group--vertical`
          ],
          role: "group"
        }, this.$slots);
      }
    });

    const START_YEAR = 1901;
    const MONTH_ITEM_HEIGHT = 40;

    const matcherMap = {
      date: isSameDay,
      month: isSameMonth,
      year: isSameYear,
      quarter: isSameQuarter
    };

    function matchDate(sourceTime, patternTime, type) {
      const matcher = matcherMap[type];

      if (Array.isArray(sourceTime)) {
        return sourceTime.some(time => matcher(time, patternTime));
      } else {
        return matcher(sourceTime, patternTime);
      }
    }

    function dateItem(time, monthTs, valueTs, currentTs) {
      let inSpan = false;
      let startOfSpan = false;
      let endOfSpan = false;

      if (Array.isArray(valueTs)) {
        if (valueTs[0] < time && time < valueTs[1]) {
          inSpan = true;
        }

        if (matchDate(valueTs[0], time, "date")) startOfSpan = true;
        if (matchDate(valueTs[1], time, "date")) endOfSpan = true;
      }

      const selected = valueTs !== null && (Array.isArray(valueTs) ? matchDate(valueTs[0], time, "date") || matchDate(valueTs[1], time, "date") : matchDate(valueTs, time, "date"));
      return {
        type: "date",
        dateObject: {
          date: getDate(time),
          month: getMonth(time),
          year: getYear(time)
        },
        inCurrentMonth: isSameMonth(time, monthTs),
        isCurrentDate: matchDate(currentTs, time, "date"),
        inSpan,
        startOfSpan,
        endOfSpan,
        selected,
        ts: getTime(time)
      };
    }

    function monthItem(monthTs, valueTs, currentTs) {
      return {
        type: "month",
        dateObject: {
          month: getMonth(monthTs),
          year: getYear(monthTs)
        },
        isCurrent: isSameMonth(currentTs, monthTs),
        selected: valueTs !== null && matchDate(valueTs, monthTs, "month"),
        ts: getTime(monthTs)
      };
    }

    function yearItem(yearTs, valueTs, currentTs) {
      return {
        type: "year",
        dateObject: {
          year: getYear(yearTs)
        },
        isCurrent: isSameYear(currentTs, yearTs),
        selected: valueTs !== null && matchDate(valueTs, yearTs, "year"),
        ts: getTime(yearTs)
      };
    }

    function quarterItem(quarterTs, valueTs, currentTs) {
      return {
        type: "quarter",
        dateObject: {
          quarter: getQuarter(quarterTs),
          year: getYear(quarterTs)
        },
        isCurrent: isSameQuarter(currentTs, quarterTs),
        selected: valueTs !== null && matchDate(valueTs, quarterTs, "quarter"),
        ts: getTime(quarterTs)
      };
    }

    function dateArray(monthTs, valueTs, currentTs, startDay) {
      let strip = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
      const displayMonth = getMonth(monthTs);
      let displayMonthIterator = getTime(startOfMonth(monthTs));
      let lastMonthIterator = getTime(addDays(displayMonthIterator, -1));
      const calendarDays = [];
      let protectLastMonthDateIsShownFlag = !strip;

      while (getDay(lastMonthIterator) !== startDay || protectLastMonthDateIsShownFlag) {
        calendarDays.unshift(dateItem(lastMonthIterator, monthTs, valueTs, currentTs));
        lastMonthIterator = getTime(addDays(lastMonthIterator, -1));
        protectLastMonthDateIsShownFlag = false;
      }

      while (getMonth(displayMonthIterator) === displayMonth) {
        calendarDays.push(dateItem(displayMonthIterator, monthTs, valueTs, currentTs));
        displayMonthIterator = getTime(addDays(displayMonthIterator, 1));
      }

      const endIndex = strip ? calendarDays.length <= 28 ? 28 : calendarDays.length <= 35 ? 35 : 42 : 42;

      while (calendarDays.length < endIndex) {
        calendarDays.push(dateItem(displayMonthIterator, monthTs, valueTs, currentTs));
        displayMonthIterator = getTime(addDays(displayMonthIterator, 1));
      }

      return calendarDays;
    }

    function monthArray(yearAnchorTs, valueTs, currentTs) {
      const calendarMonths = [];
      const yearStart = startOfYear(yearAnchorTs);

      for (let i = 0; i < 12; i++) {
        calendarMonths.push(monthItem(getTime(addMonths(yearStart, i)), valueTs, currentTs));
      }

      return calendarMonths;
    }

    function quarterArray(yearAnchorTs, valueTs, currentTs) {
      const calendarQuarters = [];
      const yearStart = startOfYear(yearAnchorTs);

      for (let i = 0; i < 4; i++) {
        calendarQuarters.push(quarterItem(getTime(addQuarters(yearStart, i)), valueTs, currentTs));
      }

      return calendarQuarters;
    }

    function yearArray(valueTs, currentTs) {
      const calendarYears = [];
      const time1900 = new Date(START_YEAR, 0, 1);

      for (let i = 0; i < 200; i++) {
        calendarYears.push(yearItem(getTime(addYears(time1900, i)), valueTs, currentTs));
      }

      return calendarYears;
    }

    function strictParse(string, pattern, backup, option) {
      const result = parse$1(string, pattern, backup, option);
      if (!isValid$1(result)) return result;else if (format$4(result, pattern, option) === string) return result;else return new Date(NaN);
    }

    function getDefaultTime(timeValue) {
      if (timeValue === void 0) {
        return void 0;
      }

      if (typeof timeValue === "number") {
        return timeValue;
      }

      const [hour, minute, second] = timeValue.split(":");
      return {
        hours: Number(hour),
        minutes: Number(minute),
        seconds: Number(second)
      };
    }

    function pluckValueFromRange(value, type) {
      return Array.isArray(value) ? value[type === "start" ? 0 : 1] : null;
    }

    var commonVariables$e = {
      titleFontSize: "22px"
    };

    const self$Y = vars => {
      const {
        borderRadius,
        fontSize,
        lineHeight,
        textColor2,
        textColor1,
        textColorDisabled,
        dividerColor,
        fontWeightStrong,
        primaryColor,
        baseColor,
        hoverColor,
        cardColor,
        modalColor,
        popoverColor
      } = vars;
      return { ...commonVariables$e,
        borderRadius,
        borderColor: composite(cardColor, dividerColor),
        borderColorModal: composite(modalColor, dividerColor),
        borderColorPopover: composite(popoverColor, dividerColor),
        textColor: textColor2,
        titleFontWeight: fontWeightStrong,
        titleTextColor: textColor1,
        dayTextColor: textColorDisabled,
        fontSize,
        lineHeight,
        dateColorCurrent: primaryColor,
        dateTextColorCurrent: baseColor,
        cellColorHover: composite(cardColor, hoverColor),
        cellColorHoverModal: composite(modalColor, hoverColor),
        cellColorHoverPopover: composite(popoverColor, hoverColor),
        cellColor: cardColor,
        cellColorModal: modalColor,
        cellColorPopover: popoverColor,
        barColor: primaryColor
      };
    };
    const calendarLight = createTheme$1({
      name: "Calendar",
      common: commonLight,
      peers: {
        Button: buttonLight$1
      },
      self: self$Y
    });
    var calendarLight$1 = calendarLight;

    const calendarDark = {
      name: "Calendar",
      common: commonDark,
      peers: {
        Button: buttonDark$1
      },
      self: self$Y
    };
    var calendarDark$1 = calendarDark;

    var style$18 = c$1([cB("calendar", `
    line-height: var(--n-line-height);
    font-size: var(--n-font-size);
    color: var(--n-text-color);
    height: 720px;
    display: flex;
    flex-direction: column;
  `, [cB("calendar-prev-btn", `
      cursor: pointer;
    `), cB("calendar-next-btn", `
      cursor: pointer;
    `), cB("calendar-header", `
      display: flex;
      align-items: center;
      line-height: 1;
      font-size: var(--n-title-font-size);
      padding: 0 0 18px 0;
      justify-content: space-between;
    `, [cE("title", `
        color: var(--n-title-text-color);
        font-weight: var(--n-title-font-weight);
        transition: color .3s var(--n-bezier);
      `), cE("extra", `
        display: flex;
        align-items: center;
      `)]), cB("calendar-dates", `
      display: grid;
      grid-template-columns: repeat(7, minmax(0, 1fr));
      grid-auto-rows: 1fr;
      border-radius: var(--n-border-radius);
      flex: 1;
      border-top: 1px solid;
      border-left: 1px solid;
      border-color: var(--n-border-color);
      transition: border-color .3s var(--n-bezier);
    `), cB("calendar-cell", `
      box-sizing: border-box;
      padding: 10px;
      border-right: 1px solid;
      border-bottom: 1px solid;
      border-color: var(--n-border-color);
      cursor: pointer;
      position: relative;
      transition:
        color .3s var(--n-bezier),
        border-color .3s var(--n-bezier),
        background-color .3s var(--n-bezier);
    `, [c$1("&:nth-child(7)", `
        border-top-right-radius: var(--n-border-radius);
      `), c$1("&:nth-last-child(7)", `
        border-bottom-left-radius: var(--n-border-radius);
      `), c$1("&:last-child", `
        border-bottom-right-radius: var(--n-border-radius);
      `), c$1("&:hover", `
        background-color: var(--n-cell-color-hover);
      `), cE("bar", `
        position: absolute;
        left: 0;
        right: 0;
        bottom: -1px;
        height: 3px;
        background-color: #0000;
        transition: background-color .3s var(--n-bezier);
      `), cM("selected", [cE("bar", `
          background-color: var(--n-bar-color);
        `)]), cB("calendar-date", `
        transition:
          color .3s var(--n-bezier),
          border-color .3s var(--n-bezier),
          background-color .3s var(--n-bezier);
        color: var(--n-text-color);
      `, [cE("date", `
          color: var(--n-text-color);
        `)]), cM("disabled, other-month", `
        color: var(--n-day-text-color);
      `, [cB("calendar-date", [cE("date", `
            color: var(--n-day-text-color);
          `)])]), cM("disabled", `
        cursor: not-allowed;
      `), cM("current", [cB("calendar-date", [cE("date", `
            color: var(--n-date-text-color-current);
            background-color: var(--n-date-color-current);
          `)])]), cB("calendar-date", `
        position: relative;
        line-height: 1;
        display: flex;
        align-items: center;
        height: 1em;
        justify-content: space-between;
        padding-bottom: .75em;
      `, [cE("date", `
          border-radius: 50%;
          display: flex;
          align-items: center;
          justify-content: center;
          margin-left: -0.4em;
          width: 1.8em;
          height: 1.8em;
          transition:
            color .3s var(--n-bezier),
            background-color .3s var(--n-bezier);
        `), cE("day", `
          color: var(--n-day-text-color);
          transition: color .3s var(--n-bezier);
        `)])])]), insideModal(cB("calendar", [cB("calendar-dates", `
      border-color: var(--n-border-color-modal);
    `), cB("calendar-cell", `
      border-color: var(--n-border-color-modal);
    `, [c$1("&:hover", `
        background-color: var(--n-cell-color-hover-modal);
      `)])])), insidePopover(cB("calendar", [cB("calendar-dates", `
      border-color: var(--n-border-color-popover);
    `), cB("calendar-cell", `
      border-color: var(--n-border-color-popover);
    `, [c$1("&:hover", `
        background-color: var(--n-cell-color-hover-popover);
      `)])]))]);

    const calendarProps = {
      ...useTheme.props,
      isDateDisabled: Function,
      value: Number,
      defaultValue: {
        type: Number,
        default: null
      },
      onPanelChange: Function,
      "onUpdate:value": [Function, Array],
      onUpdateValue: [Function, Array]
    };
    var Calendar = vue.defineComponent({
      name: "Calendar",
      props: calendarProps,
      setup(props) {
        const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
        const themeRef = useTheme(
          "Calendar",
          "-calendar",
          style$18,
          calendarLight$1,
          props,
          mergedClsPrefixRef
        );
        const { localeRef, dateLocaleRef } = useLocale("DatePicker");
        const now = Date.now();
        const monthTsRef = vue.ref(startOfMonth(now).valueOf());
        const uncontrolledValueRef = vue.ref(props.defaultValue || null);
        const mergedValueRef = useMergedState(
          vue.toRef(props, "value"),
          uncontrolledValueRef
        );
        function doUpdateValue(value, time) {
          const { onUpdateValue, "onUpdate:value": _onUpdateValue } = props;
          if (onUpdateValue) {
            call(onUpdateValue, value, time);
          }
          if (_onUpdateValue) {
            call(_onUpdateValue, value, time);
          }
          uncontrolledValueRef.value = value;
        }
        function handlePrevClick() {
          const monthTs = addMonths(monthTsRef.value, -1).valueOf();
          monthTsRef.value = monthTs;
          props.onPanelChange?.({
            year: getYear(monthTs),
            month: getMonth(monthTs) + 1
          });
        }
        function handleNextClick() {
          const monthTs = addMonths(monthTsRef.value, 1).valueOf();
          monthTsRef.value = monthTs;
          props.onPanelChange?.({
            year: getYear(monthTs),
            month: getMonth(monthTs) + 1
          });
        }
        function handleTodayClick() {
          const { value: monthTs } = monthTsRef;
          const oldYear = getYear(monthTs);
          const oldMonth = getMonth(monthTs);
          const newMonthTs = startOfMonth(now).valueOf();
          monthTsRef.value = newMonthTs;
          const newYear = getYear(newMonthTs);
          const newMonth = getMonth(newMonthTs);
          if (oldYear !== newYear || oldMonth !== newMonth) {
            props.onPanelChange?.({
              year: newYear,
              month: newMonth + 1
            });
          }
        }
        const cssVarsRef = vue.computed(() => {
          const {
            common: { cubicBezierEaseInOut },
            self: {
              borderColor,
              borderColorModal,
              borderColorPopover,
              borderRadius,
              titleFontSize,
              textColor,
              titleFontWeight,
              titleTextColor,
              dayTextColor,
              fontSize,
              lineHeight,
              dateColorCurrent,
              dateTextColorCurrent,
              cellColorHover,
              cellColor,
              cellColorModal,
              barColor,
              cellColorPopover,
              cellColorHoverModal,
              cellColorHoverPopover
            }
          } = themeRef.value;
          return {
            "--n-bezier": cubicBezierEaseInOut,
            "--n-border-color": borderColor,
            "--n-border-color-modal": borderColorModal,
            "--n-border-color-popover": borderColorPopover,
            "--n-border-radius": borderRadius,
            "--n-text-color": textColor,
            "--n-title-font-weight": titleFontWeight,
            "--n-title-font-size": titleFontSize,
            "--n-title-text-color": titleTextColor,
            "--n-day-text-color": dayTextColor,
            "--n-font-size": fontSize,
            "--n-line-height": lineHeight,
            "--n-date-color-current": dateColorCurrent,
            "--n-date-text-color-current": dateTextColorCurrent,
            "--n-cell-color": cellColor,
            "--n-cell-color-modal": cellColorModal,
            "--n-cell-color-popover": cellColorPopover,
            "--n-cell-color-hover": cellColorHover,
            "--n-cell-color-hover-modal": cellColorHoverModal,
            "--n-cell-color-hover-popover": cellColorHoverPopover,
            "--n-bar-color": barColor
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("calendar", void 0, cssVarsRef, props) : void 0;
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          locale: localeRef,
          dateLocale: dateLocaleRef,
          now,
          mergedValue: mergedValueRef,
          monthTs: monthTsRef,
          dateItems: vue.computed(() => {
            return dateArray(
              monthTsRef.value,
              mergedValueRef.value,
              now,
              localeRef.value.firstDayOfWeek,
              true
            );
          }),
          doUpdateValue,
          handleTodayClick,
          handlePrevClick,
          handleNextClick,
          mergedTheme: themeRef,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender
        };
      },
      render() {
        const {
          isDateDisabled,
          mergedClsPrefix,
          monthTs,
          cssVars,
          mergedValue,
          mergedTheme,
          $slots,
          locale: { monthBeforeYear, today },
          dateLocale: { locale },
          handleTodayClick,
          handlePrevClick,
          handleNextClick,
          onRender
        } = this;
        onRender?.();
        const normalizedValue = mergedValue && startOfDay(mergedValue).valueOf();
        const year = getYear(monthTs);
        const calendarMonth = getMonth(monthTs) + 1;
        return /* @__PURE__ */ vue.h("div", {
          class: [`${mergedClsPrefix}-calendar`, this.themeClass],
          style: cssVars
        }, /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-calendar-header`
        }, /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-calendar-header__title`
        }, resolveSlotWithProps(
          $slots.header,
          { year, month: calendarMonth },
          () => {
            const localeMonth = format$4(monthTs, "MMMM", { locale });
            return [
              monthBeforeYear ? `${localeMonth} ${year}` : `${year} ${localeMonth}`
            ];
          }
        )), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-calendar-header__extra`
        }, /* @__PURE__ */ vue.h(NButtonGroup, null, {
          default: () => /* @__PURE__ */ vue.h(vue.Fragment, null, /* @__PURE__ */ vue.h(NButton, {
            size: "small",
            onClick: handlePrevClick,
            theme: mergedTheme.peers.Button,
            themeOverrides: mergedTheme.peerOverrides.Button
          }, {
            icon: () => /* @__PURE__ */ vue.h(NBaseIcon, {
              clsPrefix: mergedClsPrefix,
              class: `${mergedClsPrefix}-calendar-prev-btn`
            }, { default: () => /* @__PURE__ */ vue.h(ChevronLeftIcon, null) })
          }), /* @__PURE__ */ vue.h(NButton, {
            size: "small",
            onClick: handleTodayClick,
            theme: mergedTheme.peers.Button,
            themeOverrides: mergedTheme.peerOverrides.Button
          }, { default: () => today }), /* @__PURE__ */ vue.h(NButton, {
            size: "small",
            onClick: handleNextClick,
            theme: mergedTheme.peers.Button,
            themeOverrides: mergedTheme.peerOverrides.Button
          }, {
            icon: () => /* @__PURE__ */ vue.h(NBaseIcon, {
              clsPrefix: mergedClsPrefix,
              class: `${mergedClsPrefix}-calendar-next-btn`
            }, { default: () => /* @__PURE__ */ vue.h(ChevronRightIcon, null) })
          }))
        }))), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-calendar-dates`
        }, this.dateItems.map(
          ({ dateObject, ts, inCurrentMonth, isCurrentDate }, index) => {
            const { year: year2, month, date } = dateObject;
            const fullDate = format$4(ts, "yyyy-MM-dd");
            const notInCurrentMonth = !inCurrentMonth;
            const disabled = isDateDisabled?.(ts) === true;
            const selected = normalizedValue === startOfDay(ts).valueOf();
            return /* @__PURE__ */ vue.h("div", {
              key: `${calendarMonth}-${index}`,
              class: [
                `${mergedClsPrefix}-calendar-cell`,
                disabled && `${mergedClsPrefix}-calendar-cell--disabled`,
                notInCurrentMonth && `${mergedClsPrefix}-calendar-cell--other-month`,
                disabled && `${mergedClsPrefix}-calendar-cell--not-allowed`,
                isCurrentDate && `${mergedClsPrefix}-calendar-cell--current`,
                selected && `${mergedClsPrefix}-calendar-cell--selected`
              ],
              onClick: () => {
                if (disabled)
                  return;
                const monthTs2 = startOfMonth(ts).valueOf();
                this.monthTs = monthTs2;
                if (notInCurrentMonth) {
                  this.onPanelChange?.({
                    year: getYear(monthTs2),
                    month: getMonth(monthTs2) + 1
                  });
                }
                this.doUpdateValue(ts, {
                  year: year2,
                  month: month + 1,
                  date
                });
              }
            }, /* @__PURE__ */ vue.h("div", {
              class: `${mergedClsPrefix}-calendar-date`
            }, /* @__PURE__ */ vue.h("div", {
              class: `${mergedClsPrefix}-calendar-date__date`,
              title: fullDate
            }, date), index < 7 && /* @__PURE__ */ vue.h("div", {
              class: `${mergedClsPrefix}-calendar-date__day`,
              title: fullDate
            }, format$4(ts, "EEE", {
              locale
            }))), $slots.default?.({
              year: year2,
              month: month + 1,
              date
            }), /* @__PURE__ */ vue.h("div", {
              class: `${mergedClsPrefix}-calendar-cell__bar`
            }));
          }
        )));
      }
    });

    const self$X = vars => {
      const {
        fontSize,
        boxShadow2,
        popoverColor,
        textColor2,
        borderRadius,
        borderColor,
        heightSmall,
        heightMedium,
        heightLarge,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        dividerColor
      } = vars;
      return {
        panelFontSize: fontSize,
        boxShadow: boxShadow2,
        color: popoverColor,
        textColor: textColor2,
        borderRadius,
        border: `1px solid ${borderColor}`,
        heightSmall,
        heightMedium,
        heightLarge,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        dividerColor
      };
    };
    const colorPickerLight = createTheme$1({
      name: "ColorPicker",
      common: commonLight,
      peers: {
        Input: inputLight$1,
        Button: buttonLight$1
      },
      self: self$X
    });
    var colorPickerLight$1 = colorPickerLight;

    const colorPickerDark = {
      name: "ColorPicker",
      common: commonDark,
      peers: {
        Input: inputDark$1,
        Button: buttonDark$1
      },
      self: self$X
    };
    var colorPickerDark$1 = colorPickerDark;

    function deriveDefaultValue(modes, showAlpha) {
      const mode = modes[0];

      switch (mode) {
        case "hex":
          return showAlpha ? "#000000FF" : "#000000";

        case "rgb":
          return showAlpha ? "rgba(0, 0, 0, 1)" : "rgb(0, 0, 0)";

        case "hsl":
          return showAlpha ? "hsla(0, 0%, 0%, 1)" : "hsl(0, 0%, 0%)";

        case "hsv":
          return showAlpha ? "hsva(0, 0%, 0%, 1)" : "hsv(0, 0%, 0%)";
      }

      warn$2("color-picker", "props.modes is invalid.");
      return "#000000";
    }
    function getModeFromValue(color) {
      if (color === null) return null;
      if (/^ *#/.test(color)) return "hex";
      if (color.includes("rgb")) return "rgb";
      if (color.includes("hsl")) return "hsl";
      if (color.includes("hsv")) return "hsv";
      return null;
    }
    function normalizeHue(hue) {
      hue = Math.round(hue);
      return hue >= 360 ? 359 : hue < 0 ? 0 : hue;
    }
    function normalizeAlpha(alpha) {
      alpha = Math.round(alpha * 100) / 100;
      return alpha > 1 ? 1 : alpha < 0 ? 0 : alpha;
    }
    const convert = {
      rgb: {
        hex(value) {
          return toHexaString(rgba(value));
        },

        hsl(value) {
          const [r, g, b, a] = rgba(value);
          return toHslaString([...rgb2hsl(r, g, b), a]);
        },

        hsv(value) {
          const [r, g, b, a] = rgba(value);
          return toHsvaString([...rgb2hsv(r, g, b), a]);
        }

      },
      hex: {
        rgb(value) {
          return toRgbaString(rgba(value));
        },

        hsl(value) {
          const [r, g, b, a] = rgba(value);
          return toHslaString([...rgb2hsl(r, g, b), a]);
        },

        hsv(value) {
          const [r, g, b, a] = rgba(value);
          return toHsvaString([...rgb2hsv(r, g, b), a]);
        }

      },
      hsl: {
        hex(value) {
          const [h, s, l, a] = hsla(value);
          return toHexaString([...hsl2rgb(h, s, l), a]);
        },

        rgb(value) {
          const [h, s, l, a] = hsla(value);
          return toRgbaString([...hsl2rgb(h, s, l), a]);
        },

        hsv(value) {
          const [h, s, l, a] = hsla(value);
          return toHsvaString([...hsl2hsv(h, s, l), a]);
        }

      },
      hsv: {
        hex(value) {
          const [h, s, v, a] = hsva(value);
          return toHexaString([...hsv2rgb(h, s, v), a]);
        },

        rgb(value) {
          const [h, s, v, a] = hsva(value);
          return toRgbaString([...hsv2rgb(h, s, v), a]);
        },

        hsl(value) {
          const [h, s, v, a] = hsva(value);
          return toHslaString([...hsv2hsl(h, s, v), a]);
        }

      }
    };
    function convertColor(value, mode, originalMode) {
      originalMode = originalMode || getModeFromValue(value);
      if (!originalMode) return null;
      if (originalMode === mode) return value;
      const conversions = convert[originalMode];
      return conversions[mode](value);
    }

    const HANDLE_SIZE$2 = "12px";
    const HANDLE_SIZE_NUM$1 = 12;
    const RADIUS$2 = "6px";
    const RADIUS_NUM = 6;
    const GRADIENT = "linear-gradient(90deg,red,#ff0 16.66%,#0f0 33.33%,#0ff 50%,#00f 66.66%,#f0f 83.33%,red)";
    var HueSlider = vue.defineComponent({
      name: "HueSlider",
      props: {
        clsPrefix: {
          type: String,
          required: true
        },
        hue: {
          type: Number,
          required: true
        },
        onUpdateHue: {
          type: Function,
          required: true
        },
        onComplete: Function
      },
      setup(props) {
        const railRef = vue.ref(null);
        function handleMouseDown(e) {
          if (!railRef.value)
            return;
          on("mousemove", document, handleMouseMove);
          on("mouseup", document, handleMouseUp);
          handleMouseMove(e);
        }
        function handleMouseMove(e) {
          const { value: railEl } = railRef;
          if (!railEl)
            return;
          const { width, left } = railEl.getBoundingClientRect();
          const newHue = normalizeHue(
            (e.clientX - left - RADIUS_NUM) / (width - HANDLE_SIZE_NUM$1) * 360
          );
          props.onUpdateHue(newHue);
        }
        function handleMouseUp() {
          off("mousemove", document, handleMouseMove);
          off("mouseup", document, handleMouseUp);
          props.onComplete?.();
        }
        return {
          railRef,
          handleMouseDown
        };
      },
      render() {
        const { clsPrefix } = this;
        return /* @__PURE__ */ vue.h("div", {
          class: `${clsPrefix}-color-picker-slider`,
          style: {
            height: HANDLE_SIZE$2,
            borderRadius: RADIUS$2
          }
        }, /* @__PURE__ */ vue.h("div", {
          ref: "railRef",
          style: {
            boxShadow: "inset 0 0 2px 0 rgba(0, 0, 0, .24)",
            boxSizing: "border-box",
            backgroundImage: GRADIENT,
            height: HANDLE_SIZE$2,
            borderRadius: RADIUS$2,
            position: "relative"
          },
          onMousedown: this.handleMouseDown
        }, /* @__PURE__ */ vue.h("div", {
          style: {
            position: "absolute",
            left: RADIUS$2,
            right: RADIUS$2,
            top: 0,
            bottom: 0
          }
        }, /* @__PURE__ */ vue.h("div", {
          class: `${clsPrefix}-color-picker-handle`,
          style: {
            left: `calc((${this.hue}%) / 359 * 100 - ${RADIUS$2})`,
            borderRadius: RADIUS$2,
            width: HANDLE_SIZE$2,
            height: HANDLE_SIZE$2
          }
        }, /* @__PURE__ */ vue.h("div", {
          class: `${clsPrefix}-color-picker-handle__fill`,
          style: {
            backgroundColor: `hsl(${this.hue}, 100%, 50%)`,
            borderRadius: RADIUS$2,
            width: HANDLE_SIZE$2,
            height: HANDLE_SIZE$2
          }
        })))));
      }
    });

    const HANDLE_SIZE$1 = "12px";
    const HANDLE_SIZE_NUM = 12;
    const RADIUS$1 = "6px";
    var AlphaSlider = vue.defineComponent({
      name: "AlphaSlider",
      props: {
        clsPrefix: {
          type: String,
          required: true
        },
        rgba: {
          type: Array,
          default: null
        },
        alpha: {
          type: Number,
          default: 0
        },
        onUpdateAlpha: {
          type: Function,
          required: true
        },
        onComplete: Function
      },
      setup(props) {
        const railRef = vue.ref(null);
        function handleMouseDown(e) {
          if (!railRef.value || !props.rgba)
            return;
          on("mousemove", document, handleMouseMove);
          on("mouseup", document, handleMouseUp);
          handleMouseMove(e);
        }
        function handleMouseMove(e) {
          const { value: railEl } = railRef;
          if (!railEl)
            return;
          const { width, left } = railEl.getBoundingClientRect();
          const newAlpha = (e.clientX - left) / (width - HANDLE_SIZE_NUM);
          props.onUpdateAlpha(normalizeAlpha(newAlpha));
        }
        function handleMouseUp() {
          off("mousemove", document, handleMouseMove);
          off("mouseup", document, handleMouseUp);
          props.onComplete?.();
        }
        return {
          railRef,
          railBackgroundImage: vue.computed(() => {
            const { rgba } = props;
            if (!rgba)
              return "";
            return `linear-gradient(to right, rgba(${rgba[0]}, ${rgba[1]}, ${rgba[2]}, 0) 0%, rgba(${rgba[0]}, ${rgba[1]}, ${rgba[2]}, 1) 100%)`;
          }),
          handleMouseDown
        };
      },
      render() {
        const { clsPrefix } = this;
        return /* @__PURE__ */ vue.h("div", {
          class: `${clsPrefix}-color-picker-slider`,
          ref: "railRef",
          style: {
            height: HANDLE_SIZE$1,
            borderRadius: RADIUS$1
          },
          onMousedown: this.handleMouseDown
        }, /* @__PURE__ */ vue.h("div", {
          style: {
            borderRadius: RADIUS$1,
            position: "absolute",
            left: 0,
            right: 0,
            top: 0,
            bottom: 0,
            overflow: "hidden"
          }
        }, /* @__PURE__ */ vue.h("div", {
          class: `${clsPrefix}-color-picker-checkboard`
        }), /* @__PURE__ */ vue.h("div", {
          class: `${clsPrefix}-color-picker-slider__image`,
          style: {
            backgroundImage: this.railBackgroundImage
          }
        })), this.rgba && /* @__PURE__ */ vue.h("div", {
          style: {
            position: "absolute",
            left: RADIUS$1,
            right: RADIUS$1,
            top: 0,
            bottom: 0
          }
        }, /* @__PURE__ */ vue.h("div", {
          class: `${clsPrefix}-color-picker-handle`,
          style: {
            left: `calc(${this.alpha * 100}% - ${RADIUS$1})`,
            borderRadius: RADIUS$1,
            width: HANDLE_SIZE$1,
            height: HANDLE_SIZE$1
          }
        }, /* @__PURE__ */ vue.h("div", {
          class: `${clsPrefix}-color-picker-handle__fill`,
          style: {
            backgroundColor: toRgbaString(this.rgba),
            borderRadius: RADIUS$1,
            width: HANDLE_SIZE$1,
            height: HANDLE_SIZE$1
          }
        }))));
      }
    });

    const HANDLE_SIZE = "12px";
    const RADIUS = "6px";
    var Pallete = vue.defineComponent({
      name: "Pallete",
      props: {
        clsPrefix: {
          type: String,
          required: true
        },
        rgba: {
          type: Array,
          default: null
        },
        displayedHue: {
          type: Number,
          required: true
        },
        displayedSv: {
          type: Array,
          required: true
        },
        onUpdateSV: {
          type: Function,
          required: true
        },
        onComplete: Function
      },
      setup(props) {
        const palleteRef = vue.ref(null);
        function handleMouseDown(e) {
          if (!palleteRef.value)
            return;
          on("mousemove", document, handleMouseMove);
          on("mouseup", document, handleMouseUp);
          handleMouseMove(e);
        }
        function handleMouseMove(e) {
          const { value: palleteEl } = palleteRef;
          if (!palleteEl)
            return;
          const { width, height, left, bottom } = palleteEl.getBoundingClientRect();
          const newV = (bottom - e.clientY) / height;
          const newS = (e.clientX - left) / width;
          const normalizedNewS = 100 * (newS > 1 ? 1 : newS < 0 ? 0 : newS);
          const normalizedNewV = 100 * (newV > 1 ? 1 : newV < 0 ? 0 : newV);
          props.onUpdateSV(normalizedNewS, normalizedNewV);
        }
        function handleMouseUp() {
          off("mousemove", document, handleMouseMove);
          off("mouseup", document, handleMouseUp);
          props.onComplete?.();
        }
        return {
          palleteRef,
          handleColor: vue.computed(() => {
            const { rgba } = props;
            if (!rgba)
              return "";
            return `rgb(${rgba[0]}, ${rgba[1]}, ${rgba[2]})`;
          }),
          handleMouseDown
        };
      },
      render() {
        const { clsPrefix } = this;
        return /* @__PURE__ */ vue.h("div", {
          class: `${clsPrefix}-color-picker-pallete`,
          onMousedown: this.handleMouseDown,
          ref: "palleteRef"
        }, /* @__PURE__ */ vue.h("div", {
          class: `${clsPrefix}-color-picker-pallete__layer`,
          style: {
            backgroundImage: `linear-gradient(90deg, white, hsl(${this.displayedHue}, 100%, 50%))`
          }
        }), /* @__PURE__ */ vue.h("div", {
          class: `${clsPrefix}-color-picker-pallete__layer ${clsPrefix}-color-picker-pallete__layer--shadowed`,
          style: {
            backgroundImage: "linear-gradient(180deg, rgba(0, 0, 0, 0%), rgba(0, 0, 0, 100%))"
          }
        }), this.rgba && /* @__PURE__ */ vue.h("div", {
          class: `${clsPrefix}-color-picker-handle`,
          style: {
            width: HANDLE_SIZE,
            height: HANDLE_SIZE,
            borderRadius: RADIUS,
            left: `calc(${this.displayedSv[0]}% - ${RADIUS})`,
            bottom: `calc(${this.displayedSv[1]}% - ${RADIUS})`
          }
        }, /* @__PURE__ */ vue.h("div", {
          class: `${clsPrefix}-color-picker-handle__fill`,
          style: {
            backgroundColor: this.handleColor,
            borderRadius: RADIUS,
            width: HANDLE_SIZE,
            height: HANDLE_SIZE
          }
        })));
      }
    });

    const colorPickerInjectionKey = createInjectionKey("n-color-picker");

    function normalizeRgbUnit(value) {
      if (/^\d{1,3}\.?\d*$/.test(value.trim())) {
        return Math.max(0, Math.min(parseInt(value), 255));
      }
      return false;
    }
    function normalizeHueUnit(value) {
      if (/^\d{1,3}\.?\d*$/.test(value.trim())) {
        return Math.max(0, Math.min(parseInt(value), 360));
      }
      return false;
    }
    function normalizeSlvUnit(value) {
      if (/^\d{1,3}\.?\d*$/.test(value.trim())) {
        return Math.max(0, Math.min(parseInt(value), 100));
      }
      return false;
    }
    function normalizeHexaUnit(value) {
      const trimmedValue = value.trim();
      if (/^#[0-9a-fA-F]+$/.test(trimmedValue)) {
        return [4, 5, 7, 9].includes(trimmedValue.length);
      }
      return false;
    }
    function normalizeAlphaUnit(value) {
      if (/^\d{1,3}\.?\d*%$/.test(value.trim())) {
        return Math.max(0, Math.min(parseInt(value) / 100, 100));
      }
      return false;
    }
    const inputThemeOverrides = {
      paddingSmall: "0 4px"
    };
    var ColorInputUnit = vue.defineComponent({
      name: "ColorInputUnit",
      props: {
        label: {
          type: String,
          required: true
        },
        value: {
          type: [Number, String],
          default: null
        },
        showAlpha: Boolean,
        onUpdateValue: {
          type: Function,
          required: true
        }
      },
      setup(props) {
        const inputValueRef = vue.ref("");
        const { themeRef } = vue.inject(colorPickerInjectionKey, null);
        vue.watchEffect(() => {
          inputValueRef.value = getInputString();
        });
        function getInputString() {
          const { value } = props;
          if (value === null)
            return "";
          const { label } = props;
          if (label === "HEX") {
            return value;
          }
          if (label === "A") {
            return `${Math.floor(value * 100)}%`;
          }
          return String(Math.floor(value));
        }
        function handleInputUpdateValue(value) {
          inputValueRef.value = value;
        }
        function handleInputChange(value) {
          let unit;
          let valid;
          switch (props.label) {
            case "HEX":
              valid = normalizeHexaUnit(value);
              if (valid) {
                props.onUpdateValue(value);
              }
              inputValueRef.value = getInputString();
              break;
            case "H":
              unit = normalizeHueUnit(value);
              if (unit === false) {
                inputValueRef.value = getInputString();
              } else {
                props.onUpdateValue(unit);
              }
              break;
            case "S":
            case "L":
            case "V":
              unit = normalizeSlvUnit(value);
              if (unit === false) {
                inputValueRef.value = getInputString();
              } else {
                props.onUpdateValue(unit);
              }
              break;
            case "A":
              unit = normalizeAlphaUnit(value);
              if (unit === false) {
                inputValueRef.value = getInputString();
              } else {
                props.onUpdateValue(unit);
              }
              break;
            case "R":
            case "G":
            case "B":
              unit = normalizeRgbUnit(value);
              if (unit === false) {
                inputValueRef.value = getInputString();
              } else {
                props.onUpdateValue(unit);
              }
              break;
          }
        }
        return {
          mergedTheme: themeRef,
          inputValue: inputValueRef,
          handleInputChange,
          handleInputUpdateValue
        };
      },
      render() {
        const { mergedTheme } = this;
        return /* @__PURE__ */ vue.h(NInput, {
          size: "small",
          placeholder: this.label,
          theme: mergedTheme.peers.Input,
          themeOverrides: mergedTheme.peerOverrides.Input,
          builtinThemeOverrides: inputThemeOverrides,
          value: this.inputValue,
          onUpdateValue: this.handleInputUpdateValue,
          onChange: this.handleInputChange,
          style: this.label === "A" ? "flex-grow: 1.25;" : ""
        });
      }
    });

    var ColorInput = vue.defineComponent({
      name: "ColorInput",
      props: {
        clsPrefix: {
          type: String,
          required: true
        },
        mode: {
          type: String,
          required: true
        },
        modes: {
          type: Array,
          required: true
        },
        showAlpha: {
          type: Boolean,
          required: true
        },
        value: {
          type: String,
          default: null
        },
        valueArr: {
          type: Array,
          default: null
        },
        onUpdateValue: {
          type: Function,
          required: true
        },
        onUpdateMode: {
          type: Function,
          required: true
        }
      },
      setup(props) {
        return {
          handleUnitUpdateValue(index, value) {
            const { showAlpha } = props;
            if (props.mode === "hex") {
              props.onUpdateValue(
                (showAlpha ? toHexaString : toHexString)(value)
              );
              return;
            }
            let nextValueArr;
            if (props.valueArr === null) {
              nextValueArr = [0, 0, 0, 0];
            } else {
              nextValueArr = Array.from(props.valueArr);
            }
            switch (props.mode) {
              case "hsv":
                nextValueArr[index] = value;
                props.onUpdateValue(
                  (showAlpha ? toHsvaString : toHsvString)(nextValueArr)
                );
                break;
              case "rgb":
                nextValueArr[index] = value;
                props.onUpdateValue(
                  (showAlpha ? toRgbaString : toRgbString)(nextValueArr)
                );
                break;
              case "hsl":
                nextValueArr[index] = value;
                props.onUpdateValue(
                  (showAlpha ? toHslaString : toHslString)(nextValueArr)
                );
                break;
            }
          }
        };
      },
      render() {
        const { clsPrefix, modes } = this;
        return /* @__PURE__ */ vue.h("div", {
          class: `${clsPrefix}-color-picker-input`
        }, /* @__PURE__ */ vue.h("div", {
          class: `${clsPrefix}-color-picker-input__mode`,
          onClick: this.onUpdateMode,
          style: {
            cursor: modes.length === 1 ? "" : "pointer"
          }
        }, this.mode.toUpperCase() + (this.showAlpha ? "A" : "")), /* @__PURE__ */ vue.h(NInputGroup, null, {
          default: () => {
            const { mode, valueArr, showAlpha } = this;
            if (mode === "hex") {
              let hexValue = null;
              try {
                hexValue = valueArr === null ? null : (showAlpha ? toHexaString : toHexString)(
                  valueArr
                );
              } catch {
              }
              return /* @__PURE__ */ vue.h(ColorInputUnit, {
                label: "HEX",
                showAlpha,
                value: hexValue,
                onUpdateValue: (unitValue) => {
                  this.handleUnitUpdateValue(0, unitValue);
                }
              });
            }
            return (mode + (showAlpha ? "a" : "")).split("").map((v, i) => /* @__PURE__ */ vue.h(ColorInputUnit, {
              label: v.toUpperCase(),
              value: valueArr === null ? null : valueArr[i],
              onUpdateValue: (unitValue) => {
                this.handleUnitUpdateValue(i, unitValue);
              }
            }));
          }
        }));
      }
    });

    var ColorPickerTrigger = vue.defineComponent({
      name: "ColorPickerTrigger",
      props: {
        clsPrefix: {
          type: String,
          required: true
        },
        value: {
          type: String,
          default: null
        },
        hsla: {
          type: Array,
          default: null
        },
        disabled: Boolean,
        onClick: Function
      },
      setup(props) {
        const { colorPickerSlots, renderLabelRef } = vue.inject(
          colorPickerInjectionKey,
          null
        );
        return () => {
          const { hsla, value, clsPrefix, onClick, disabled } = props;
          const renderLabel = colorPickerSlots.label || renderLabelRef.value;
          return /* @__PURE__ */ vue.h("div", {
            class: [
              `${clsPrefix}-color-picker-trigger`,
              disabled && `${clsPrefix}-color-picker-trigger--disabled`
            ],
            onClick: disabled ? void 0 : onClick
          }, /* @__PURE__ */ vue.h("div", {
            class: `${clsPrefix}-color-picker-trigger__fill`
          }, /* @__PURE__ */ vue.h("div", {
            class: `${clsPrefix}-color-picker-checkboard`
          }), /* @__PURE__ */ vue.h("div", {
            style: {
              position: "absolute",
              left: 0,
              right: 0,
              top: 0,
              bottom: 0,
              backgroundColor: hsla ? toHslaString(hsla) : ""
            }
          }), value && hsla ? /* @__PURE__ */ vue.h("div", {
            class: `${clsPrefix}-color-picker-trigger__value`,
            style: {
              color: hsla[2] > 50 || hsla[3] < 0.5 ? "black" : "white"
            }
          }, renderLabel ? renderLabel(value) : value) : null));
        };
      }
    });

    function normalizeColor(color, mode) {
      if (mode === "hsv") {
        const [h2, s, v, a] = hsva(color);
        return toRgbaString([...hsv2rgb(h2, s, v), a]);
      }
      return color;
    }
    function getHexFromName(color) {
      const ctx = document.createElement("canvas").getContext("2d");
      ctx.fillStyle = color;
      return ctx.fillStyle;
    }
    var ColorPickerSwatches = vue.defineComponent({
      name: "ColorPickerSwatches",
      props: {
        clsPrefix: {
          type: String,
          required: true
        },
        mode: {
          type: String,
          required: true
        },
        swatches: {
          type: Array,
          required: true
        },
        onUpdateColor: {
          type: Function,
          required: true
        }
      },
      setup(props) {
        const parsedSwatchesRef = vue.computed(
          () => props.swatches.map((value) => {
            const mode = getModeFromValue(value);
            return {
              value,
              mode,
              legalValue: normalizeColor(value, mode)
            };
          })
        );
        function normalizeOutput(parsed) {
          const { mode: modeProp } = props;
          let { value, mode: swatchColorMode } = parsed;
          if (!swatchColorMode) {
            swatchColorMode = "hex";
            if (/^[a-zA-Z]+$/.test(value)) {
              value = getHexFromName(value);
            } else {
              warn$2("color-picker", `color ${value} in swatches is invalid.`);
              value = "#000000";
            }
          }
          if (swatchColorMode === modeProp)
            return value;
          return convertColor(value, modeProp, swatchColorMode);
        }
        function handleSwatchSelect(parsed) {
          props.onUpdateColor(normalizeOutput(parsed));
        }
        function handleSwatchKeyDown(e, parsed) {
          if (e.key === "Enter")
            handleSwatchSelect(parsed);
        }
        return {
          parsedSwatchesRef,
          handleSwatchSelect,
          handleSwatchKeyDown
        };
      },
      render() {
        const { clsPrefix } = this;
        return /* @__PURE__ */ vue.h("div", {
          class: `${clsPrefix}-color-picker-swatches`
        }, this.parsedSwatchesRef.map((swatch) => /* @__PURE__ */ vue.h("div", {
          class: `${clsPrefix}-color-picker-swatch`,
          tabindex: 0,
          onClick: () => this.handleSwatchSelect(swatch),
          onKeydown: (e) => this.handleSwatchKeyDown(e, swatch)
        }, /* @__PURE__ */ vue.h("div", {
          class: `${clsPrefix}-color-picker-swatch__fill`,
          style: { background: swatch.legalValue }
        }))));
      }
    });

    var ColorPreview = vue.defineComponent({
      name: "ColorPreview",
      props: {
        clsPrefix: {
          type: String,
          required: true
        },
        mode: {
          type: String,
          required: true
        },
        color: {
          type: String,
          default: null,
          validator: (value) => {
            const mode = getModeFromValue(value);
            return Boolean(!value || mode && mode !== "hsv");
          }
        },
        onUpdateColor: {
          type: Function,
          required: true
        }
      },
      setup(props) {
        function handleChange(e) {
          const value = e.target.value;
          props.onUpdateColor?.(
            convertColor(value.toUpperCase(), props.mode, "hex")
          );
          e.stopPropagation();
        }
        return {
          handleChange
        };
      },
      render() {
        const { clsPrefix } = this;
        return /* @__PURE__ */ vue.h("div", {
          class: `${clsPrefix}-color-picker-preview__preview`
        }, /* @__PURE__ */ vue.h("span", {
          class: `${clsPrefix}-color-picker-preview__fill`,
          style: {
            background: this.color || "#000000"
          }
        }), /* @__PURE__ */ vue.h("input", {
          class: `${clsPrefix}-color-picker-preview__input`,
          type: "color",
          value: this.color,
          onChange: this.handleChange
        }));
      }
    });

    var style$17 = c$1([cB("color-picker", `
    display: inline-block;
    box-sizing: border-box;
    height: var(--n-height);
    font-size: var(--n-font-size);
    width: 100%;
    position: relative;
  `), cB("color-picker-panel", `
    margin: 4px 0;
    width: 240px;
    font-size: var(--n-panel-font-size);
    color: var(--n-text-color);
    background-color: var(--n-color);
    transition:
      box-shadow .3s var(--n-bezier),
      color .3s var(--n-bezier),
      background-color .3s var(--n-bezier);
    border-radius: var(--n-border-radius);
    box-shadow: var(--n-box-shadow);
  `, [fadeInScaleUpTransition(), cB("input", `
      text-align: center;
    `)]), cB("color-picker-checkboard", `
    background: white;
    position: absolute;
    left: 0;
    right: 0;
    top: 0;
    bottom: 0;
  `, [c$1("&::after", `
      background-image: linear-gradient(45deg, #DDD 25%, #0000 25%), linear-gradient(-45deg, #DDD 25%, #0000 25%), linear-gradient(45deg, #0000 75%, #DDD 75%), linear-gradient(-45deg, #0000 75%, #DDD 75%);
      background-size: 12px 12px;
      background-position: 0 0, 0 6px, 6px -6px, -6px 0px;
      background-repeat: repeat;
      content: "";
      position: absolute;
      left: 0;
      right: 0;
      top: 0;
      bottom: 0;
    `)]), cB("color-picker-slider", `
    margin-bottom: 8px;
    position: relative;
    box-sizing: border-box;
  `, [cE("image", `
      position: absolute;
      left: 0;
      right: 0;
      top: 0;
      bottom: 0;
    `), c$1("&::after", `
      content: "";
      position: absolute;
      border-radius: inherit;
      left: 0;
      right: 0;
      top: 0;
      bottom: 0;
      box-shadow: inset 0 0 2px 0 rgba(0, 0, 0, .24);
      pointer-events: none;
    `)]), cB("color-picker-handle", `
    z-index: 1;
    box-shadow: 0 0 2px 0 rgba(0, 0, 0, .45);
    position: absolute;
    background-color: white;
    overflow: hidden;
  `, [cE("fill", `
      box-sizing: border-box;
      border: 2px solid white;
    `)]), cB("color-picker-pallete", `
    height: 180px;
    position: relative;
    margin-bottom: 8px;
    cursor: crosshair;
  `, [cE("layer", `
      position: absolute;
      left: 0;
      right: 0;
      top: 0;
      bottom: 0;
    `, [cM("shadowed", `
        box-shadow: inset 0 0 2px 0 rgba(0, 0, 0, .24);
      `)])]), cB("color-picker-preview", `
    display: flex;
  `, [cE("sliders", `
      flex: 1 0 auto;
    `), cE("preview", `
      position: relative;
      height: 30px;
      width: 30px;
      margin: 0 0 8px 6px;
      border-radius: 50%;
      box-shadow: rgba(0, 0, 0, .15) 0px 0px 0px 1px inset;
      overflow: hidden;
    `), cE("fill", `
      display: block;
      width: 30px;
      height: 30px;
    `), cE("input", `
      position: absolute;
      top: 0;
      left: 0;
      width: 30px;
      height: 30px;
      opacity: 0;
      z-index: 1;
    `)]), cB("color-picker-input", `
    display: flex;
    align-items: center;
  `, [cB("input", `
      flex-grow: 1;
      flex-basis: 0;
    `), cE("mode", `
      width: 72px;
      text-align: center;
    `)]), cB("color-picker-control", `
    padding: 12px;
  `), cB("color-picker-action", `
    display: flex;
    margin-top: -4px;
    border-top: 1px solid var(--n-divider-color);
    padding: 8px 12px;
    justify-content: flex-end;
  `, [cB("button", "margin-left: 8px;")]), cB("color-picker-trigger", `
    border: var(--n-border);
    height: 100%;
    box-sizing: border-box;
    border-radius: var(--n-border-radius);
    transition: border-color .3s var(--n-bezier);
    cursor: pointer;
  `, [cE("value", `
      white-space: nowrap;
      position: relative;
    `), cE("fill", `
      border-radius: var(--n-border-radius);
      position: absolute;
      display: flex;
      align-items: center;
      justify-content: center;
      left: 4px;
      right: 4px;
      top: 4px;
      bottom: 4px;
    `), cM("disabled", "cursor: not-allowed"), cB("color-picker-checkboard", `
      border-radius: var(--n-border-radius);
    `, [c$1("&::after", `
        --n-block-size: calc((var(--n-height) - 8px) / 3);
        background-size: calc(var(--n-block-size) * 2) calc(var(--n-block-size) * 2);
        background-position: 0 0, 0 var(--n-block-size), var(--n-block-size) calc(-1 * var(--n-block-size)), calc(-1 * var(--n-block-size)) 0px;
      `)])]), cB("color-picker-swatches", `
    display: grid;
    grid-gap: 8px;
    flex-wrap: wrap;
    position: relative;
    grid-template-columns: repeat(auto-fill, 18px);
    margin-top: 10px;
  `, [cB("color-picker-swatch", `
      width: 18px;
      height: 18px;
      background-image: linear-gradient(45deg, #DDD 25%, #0000 25%), linear-gradient(-45deg, #DDD 25%, #0000 25%), linear-gradient(45deg, #0000 75%, #DDD 75%), linear-gradient(-45deg, #0000 75%, #DDD 75%);
      background-size: 8px 8px;
      background-position: 0px 0, 0px 4px, 4px -4px, -4px 0px;
      background-repeat: repeat;
    `, [cE("fill", `
        position: relative;
        width: 100%;
        height: 100%;
        border-radius: 3px;
        box-shadow: rgba(0, 0, 0, .15) 0px 0px 0px 1px inset;
        cursor: pointer;
      `), c$1("&:focus", `
        outline: none;
      `, [cE("fill", [c$1("&::after", `
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            left: 0;
            background: inherit;
            filter: blur(2px);
            content: "";
          `)])])])])]);

    const colorPickerProps = {
      ...useTheme.props,
      value: String,
      show: {
        type: Boolean,
        default: void 0
      },
      defaultShow: Boolean,
      defaultValue: String,
      modes: {
        type: Array,
        default: () => ["rgb", "hex", "hsl"]
      },
      placement: {
        type: String,
        default: "bottom-start"
      },
      to: useAdjustedTo.propTo,
      showAlpha: {
        type: Boolean,
        default: true
      },
      showPreview: Boolean,
      swatches: Array,
      disabled: {
        type: Boolean,
        default: void 0
      },
      actions: {
        type: Array,
        default: null
      },
      internalActions: Array,
      size: String,
      renderLabel: Function,
      onComplete: Function,
      onConfirm: Function,
      "onUpdate:show": [Function, Array],
      onUpdateShow: [Function, Array],
      "onUpdate:value": [Function, Array],
      onUpdateValue: [Function, Array]
    };
    var NColorPicker = vue.defineComponent({
      name: "ColorPicker",
      props: colorPickerProps,
      setup(props, { slots }) {
        const selfRef = vue.ref(null);
        let upcomingValue = null;
        const formItem = useFormItem(props);
        const { mergedSizeRef, mergedDisabledRef } = formItem;
        const { localeRef } = useLocale("global");
        const { mergedClsPrefixRef, namespaceRef, inlineThemeDisabled } = useConfig(props);
        const themeRef = useTheme(
          "ColorPicker",
          "-color-picker",
          style$17,
          colorPickerLight$1,
          props,
          mergedClsPrefixRef
        );
        vue.provide(colorPickerInjectionKey, {
          themeRef,
          renderLabelRef: vue.toRef(props, "renderLabel"),
          colorPickerSlots: slots
        });
        const uncontrolledShowRef = vue.ref(props.defaultShow);
        const mergedShowRef = useMergedState(
          vue.toRef(props, "show"),
          uncontrolledShowRef
        );
        function doUpdateShow(value) {
          const { onUpdateShow, "onUpdate:show": _onUpdateShow } = props;
          if (onUpdateShow)
            call(onUpdateShow, value);
          if (_onUpdateShow)
            call(_onUpdateShow, value);
          uncontrolledShowRef.value = value;
        }
        const { defaultValue } = props;
        const uncontrolledValueRef = vue.ref(
          defaultValue === void 0 ? deriveDefaultValue(props.modes, props.showAlpha) : defaultValue
        );
        const mergedValueRef = useMergedState(
          vue.toRef(props, "value"),
          uncontrolledValueRef
        );
        const undoStackRef = vue.ref([mergedValueRef.value]);
        const valueIndexRef = vue.ref(0);
        const valueModeRef = vue.computed(() => getModeFromValue(mergedValueRef.value));
        const { modes } = props;
        const displayedModeRef = vue.ref(
          getModeFromValue(mergedValueRef.value) || modes[0] || "rgb"
        );
        function handleUpdateDisplayedMode() {
          const { modes: modes2 } = props;
          const { value: displayedMode } = displayedModeRef;
          const currentModeIndex = modes2.findIndex((mode) => mode === displayedMode);
          if (~currentModeIndex) {
            displayedModeRef.value = modes2[(currentModeIndex + 1) % modes2.length];
          } else {
            displayedModeRef.value = "rgb";
          }
        }
        let _h, s, l, v, r, g, b, a;
        const hsvaRef = vue.computed(() => {
          const { value: mergedValue } = mergedValueRef;
          if (!mergedValue)
            return null;
          switch (valueModeRef.value) {
            case "hsv":
              return hsva(mergedValue);
            case "hsl":
              [_h, s, l, a] = hsla(mergedValue);
              return [...hsl2hsv(_h, s, l), a];
            case "rgb":
            case "hex":
              [r, g, b, a] = rgba(mergedValue);
              return [...rgb2hsv(r, g, b), a];
          }
        });
        const rgbaRef = vue.computed(() => {
          const { value: mergedValue } = mergedValueRef;
          if (!mergedValue)
            return null;
          switch (valueModeRef.value) {
            case "rgb":
            case "hex":
              return rgba(mergedValue);
            case "hsv":
              [_h, s, v, a] = hsva(mergedValue);
              return [...hsv2rgb(_h, s, v), a];
            case "hsl":
              [_h, s, l, a] = hsla(mergedValue);
              return [...hsl2rgb(_h, s, l), a];
          }
        });
        const hslaRef = vue.computed(() => {
          const { value: mergedValue } = mergedValueRef;
          if (!mergedValue)
            return null;
          switch (valueModeRef.value) {
            case "hsl":
              return hsla(mergedValue);
            case "hsv":
              [_h, s, v, a] = hsva(mergedValue);
              return [...hsv2hsl(_h, s, v), a];
            case "rgb":
            case "hex":
              [r, g, b, a] = rgba(mergedValue);
              return [...rgb2hsl(r, g, b), a];
          }
        });
        const mergedValueArrRef = vue.computed(() => {
          switch (displayedModeRef.value) {
            case "rgb":
            case "hex":
              return rgbaRef.value;
            case "hsv":
              return hsvaRef.value;
            case "hsl":
              return hslaRef.value;
          }
        });
        const displayedHueRef = vue.ref(0);
        const displayedAlphaRef = vue.ref(1);
        const displayedSvRef = vue.ref([0, 0]);
        function handleUpdateSv(s2, v2) {
          const { value: hsvaArr } = hsvaRef;
          const hue = displayedHueRef.value;
          const alpha = hsvaArr ? hsvaArr[3] : 1;
          displayedSvRef.value = [s2, v2];
          const { showAlpha } = props;
          switch (displayedModeRef.value) {
            case "hsv":
              doUpdateValue(
                (showAlpha ? toHsvaString : toHsvString)([hue, s2, v2, alpha]),
                "cursor"
              );
              break;
            case "hsl":
              doUpdateValue(
                (showAlpha ? toHslaString : toHslString)([
                  ...hsv2hsl(hue, s2, v2),
                  alpha
                ]),
                "cursor"
              );
              break;
            case "rgb":
              doUpdateValue(
                (showAlpha ? toRgbaString : toRgbString)([
                  ...hsv2rgb(hue, s2, v2),
                  alpha
                ]),
                "cursor"
              );
              break;
            case "hex":
              doUpdateValue(
                (showAlpha ? toHexaString : toHexString)([
                  ...hsv2rgb(hue, s2, v2),
                  alpha
                ]),
                "cursor"
              );
              break;
          }
        }
        function handleUpdateHue(hue) {
          displayedHueRef.value = hue;
          const { value: hsvaArr } = hsvaRef;
          if (!hsvaArr) {
            return;
          }
          const [, s2, v2, a2] = hsvaArr;
          const { showAlpha } = props;
          switch (displayedModeRef.value) {
            case "hsv":
              doUpdateValue(
                (showAlpha ? toHsvaString : toHsvString)([hue, s2, v2, a2]),
                "cursor"
              );
              break;
            case "rgb":
              doUpdateValue(
                (showAlpha ? toRgbaString : toRgbString)([
                  ...hsv2rgb(hue, s2, v2),
                  a2
                ]),
                "cursor"
              );
              break;
            case "hex":
              doUpdateValue(
                (showAlpha ? toHexaString : toHexString)([
                  ...hsv2rgb(hue, s2, v2),
                  a2
                ]),
                "cursor"
              );
              break;
            case "hsl":
              doUpdateValue(
                (showAlpha ? toHslaString : toHslString)([
                  ...hsv2hsl(hue, s2, v2),
                  a2
                ]),
                "cursor"
              );
              break;
          }
        }
        function handleUpdateAlpha(alpha) {
          switch (displayedModeRef.value) {
            case "hsv":
              [_h, s, v] = hsvaRef.value;
              doUpdateValue(toHsvaString([_h, s, v, alpha]), "cursor");
              break;
            case "rgb":
              [r, g, b] = rgbaRef.value;
              doUpdateValue(toRgbaString([r, g, b, alpha]), "cursor");
              break;
            case "hex":
              [r, g, b] = rgbaRef.value;
              doUpdateValue(toHexaString([r, g, b, alpha]), "cursor");
              break;
            case "hsl":
              [_h, s, l] = hslaRef.value;
              doUpdateValue(toHslaString([_h, s, l, alpha]), "cursor");
              break;
          }
          displayedAlphaRef.value = alpha;
        }
        function doUpdateValue(value, updateSource) {
          if (updateSource === "cursor") {
            upcomingValue = value;
          } else {
            upcomingValue = null;
          }
          const { nTriggerFormChange, nTriggerFormInput } = formItem;
          const { onUpdateValue, "onUpdate:value": _onUpdateValue } = props;
          if (onUpdateValue)
            call(onUpdateValue, value);
          if (_onUpdateValue)
            call(_onUpdateValue, value);
          nTriggerFormChange();
          nTriggerFormInput();
          uncontrolledValueRef.value = value;
        }
        function handleInputUpdateValue(value) {
          doUpdateValue(value, "input");
          void vue.nextTick(handleComplete);
        }
        function handleComplete(pushStack = true) {
          const { value } = mergedValueRef;
          if (value) {
            const { nTriggerFormChange, nTriggerFormInput } = formItem;
            const { onComplete } = props;
            if (onComplete) {
              onComplete(value);
            }
            const { value: undoStack } = undoStackRef;
            const { value: valueIndex } = valueIndexRef;
            if (pushStack) {
              undoStack.splice(valueIndex + 1, undoStack.length, value);
              valueIndexRef.value = valueIndex + 1;
            }
            nTriggerFormChange();
            nTriggerFormInput();
          }
        }
        function undo() {
          const { value: valueIndex } = valueIndexRef;
          if (valueIndex - 1 < 0)
            return;
          doUpdateValue(undoStackRef.value[valueIndex - 1], "input");
          handleComplete(false);
          valueIndexRef.value = valueIndex - 1;
        }
        function redo() {
          const { value: valueIndex } = valueIndexRef;
          if (valueIndex < 0 || valueIndex + 1 >= undoStackRef.value.length)
            return;
          doUpdateValue(undoStackRef.value[valueIndex + 1], "input");
          handleComplete(false);
          valueIndexRef.value = valueIndex + 1;
        }
        function handleConfirm() {
          const { value } = mergedValueRef;
          const { onConfirm } = props;
          if (onConfirm) {
            onConfirm(value);
          }
          doUpdateShow(false);
        }
        const undoableRef = vue.computed(() => valueIndexRef.value >= 1);
        const redoableRef = vue.computed(() => {
          const { value: undoStack } = undoStackRef;
          return undoStack.length > 1 && valueIndexRef.value < undoStack.length - 1;
        });
        vue.watch(mergedShowRef, (value) => {
          if (!value) {
            undoStackRef.value = [mergedValueRef.value];
            valueIndexRef.value = 0;
          }
        });
        vue.watchEffect(() => {
          if (upcomingValue && upcomingValue === mergedValueRef.value) ; else {
            const { value } = hsvaRef;
            if (value) {
              displayedHueRef.value = value[0];
              displayedAlphaRef.value = value[3];
              displayedSvRef.value = [value[1], value[2]];
            }
          }
          upcomingValue = null;
        });
        const cssVarsRef = vue.computed(() => {
          const { value: mergedSize } = mergedSizeRef;
          const {
            common: { cubicBezierEaseInOut },
            self: {
              textColor,
              color,
              panelFontSize,
              boxShadow,
              border,
              borderRadius,
              dividerColor,
              [createKey("height", mergedSize)]: height,
              [createKey("fontSize", mergedSize)]: fontSize
            }
          } = themeRef.value;
          return {
            "--n-bezier": cubicBezierEaseInOut,
            "--n-text-color": textColor,
            "--n-color": color,
            "--n-panel-font-size": panelFontSize,
            "--n-font-size": fontSize,
            "--n-box-shadow": boxShadow,
            "--n-border": border,
            "--n-border-radius": borderRadius,
            "--n-height": height,
            "--n-divider-color": dividerColor
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass(
          "color-picker",
          vue.computed(() => {
            return mergedSizeRef.value[0];
          }),
          cssVarsRef,
          props
        ) : void 0;
        function renderPanel() {
          const { value: rgba2 } = rgbaRef;
          const { value: displayedHue } = displayedHueRef;
          const { internalActions, modes: modes2, actions } = props;
          const { value: mergedTheme } = themeRef;
          const { value: mergedClsPrefix } = mergedClsPrefixRef;
          return /* @__PURE__ */ vue.h("div", {
            class: [
              `${mergedClsPrefix}-color-picker-panel`,
              themeClassHandle?.themeClass.value
            ],
            onDragstart: (e) => {
              e.preventDefault();
            },
            style: inlineThemeDisabled ? void 0 : cssVarsRef.value
          }, /* @__PURE__ */ vue.h("div", {
            class: `${mergedClsPrefix}-color-picker-control`
          }, /* @__PURE__ */ vue.h(Pallete, {
            clsPrefix: mergedClsPrefix,
            rgba: rgba2,
            displayedHue,
            displayedSv: displayedSvRef.value,
            onUpdateSV: handleUpdateSv,
            onComplete: handleComplete
          }), /* @__PURE__ */ vue.h("div", {
            class: `${mergedClsPrefix}-color-picker-preview`
          }, /* @__PURE__ */ vue.h("div", {
            class: `${mergedClsPrefix}-color-picker-preview__sliders`
          }, /* @__PURE__ */ vue.h(HueSlider, {
            clsPrefix: mergedClsPrefix,
            hue: displayedHue,
            onUpdateHue: handleUpdateHue,
            onComplete: handleComplete
          }), props.showAlpha ? /* @__PURE__ */ vue.h(AlphaSlider, {
            clsPrefix: mergedClsPrefix,
            rgba: rgba2,
            alpha: displayedAlphaRef.value,
            onUpdateAlpha: handleUpdateAlpha,
            onComplete: handleComplete
          }) : null), props.showPreview ? /* @__PURE__ */ vue.h(ColorPreview, {
            clsPrefix: mergedClsPrefix,
            mode: displayedModeRef.value,
            color: rgbaRef.value && toHexString(rgbaRef.value),
            onUpdateColor: (color) => doUpdateValue(color, "input")
          }) : null), /* @__PURE__ */ vue.h(ColorInput, {
            clsPrefix: mergedClsPrefix,
            showAlpha: props.showAlpha,
            mode: displayedModeRef.value,
            modes: modes2,
            onUpdateMode: handleUpdateDisplayedMode,
            value: mergedValueRef.value,
            valueArr: mergedValueArrRef.value,
            onUpdateValue: handleInputUpdateValue
          }), props.swatches?.length && /* @__PURE__ */ vue.h(ColorPickerSwatches, {
            clsPrefix: mergedClsPrefix,
            mode: displayedModeRef.value,
            swatches: props.swatches,
            onUpdateColor: (color) => doUpdateValue(color, "input")
          })), actions?.length ? /* @__PURE__ */ vue.h("div", {
            class: `${mergedClsPrefix}-color-picker-action`
          }, actions.includes("confirm") && /* @__PURE__ */ vue.h(NButton, {
            size: "small",
            onClick: handleConfirm,
            theme: mergedTheme.peers.Button,
            themeOverrides: mergedTheme.peerOverrides.Button
          }, { default: () => localeRef.value.confirm })) : null, slots.action ? /* @__PURE__ */ vue.h("div", {
            class: `${mergedClsPrefix}-color-picker-action`
          }, { default: slots.action }) : internalActions ? /* @__PURE__ */ vue.h("div", {
            class: `${mergedClsPrefix}-color-picker-action`
          }, internalActions.includes("undo") && /* @__PURE__ */ vue.h(NButton, {
            size: "small",
            onClick: undo,
            disabled: !undoableRef.value,
            theme: mergedTheme.peers.Button,
            themeOverrides: mergedTheme.peerOverrides.Button
          }, { default: () => localeRef.value.undo }), internalActions.includes("redo") && /* @__PURE__ */ vue.h(NButton, {
            size: "small",
            onClick: redo,
            disabled: !redoableRef.value,
            theme: mergedTheme.peers.Button,
            themeOverrides: mergedTheme.peerOverrides.Button
          }, { default: () => localeRef.value.redo })) : null);
        }
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          namespace: namespaceRef,
          selfRef,
          hsla: hslaRef,
          rgba: rgbaRef,
          mergedShow: mergedShowRef,
          mergedDisabled: mergedDisabledRef,
          isMounted: isMounted(),
          adjustedTo: useAdjustedTo(props),
          mergedValue: mergedValueRef,
          handleTriggerClick() {
            doUpdateShow(true);
          },
          handleClickOutside(e) {
            if (selfRef.value?.contains(getPreciseEventTarget(e))) {
              return;
            }
            doUpdateShow(false);
          },
          renderPanel,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender
        };
      },
      render() {
        const { $slots, mergedClsPrefix, onRender } = this;
        onRender?.();
        return /* @__PURE__ */ vue.h("div", {
          class: [this.themeClass, `${mergedClsPrefix}-color-picker`],
          ref: "selfRef",
          style: this.cssVars
        }, /* @__PURE__ */ vue.h(VBinder, null, {
          default: () => [
            /* @__PURE__ */ vue.h(VTarget, null, {
              default: () => /* @__PURE__ */ vue.h(ColorPickerTrigger, {
                clsPrefix: mergedClsPrefix,
                value: this.mergedValue,
                hsla: this.hsla,
                disabled: this.mergedDisabled,
                onClick: this.handleTriggerClick
              }, {
                label: $slots.label
              })
            }),
            /* @__PURE__ */ vue.h(VFollower, {
              placement: this.placement,
              show: this.mergedShow,
              containerClass: this.namespace,
              teleportDisabled: this.adjustedTo === useAdjustedTo.tdkey,
              to: this.adjustedTo
            }, {
              default: () => /* @__PURE__ */ vue.h(vue.Transition, {
                name: "fade-in-scale-up-transition",
                appear: this.isMounted
              }, {
                default: () => this.mergedShow ? vue.withDirectives(this.renderPanel(), [
                  [
                    clickoutside$1,
                    this.handleClickOutside,
                    void 0,
                    { capture: true }
                  ]
                ]) : null
              })
            })
          ]
        }));
      }
    });

    var commonVariables$d = {
      paddingSmall: "12px 16px 12px",
      paddingMedium: "19px 24px 20px",
      paddingLarge: "23px 32px 24px",
      paddingHuge: "27px 40px 28px",
      titleFontSizeSmall: "16px",
      titleFontSizeMedium: "18px",
      titleFontSizeLarge: "18px",
      titleFontSizeHuge: "18px",
      closeIconSize: "18px",
      closeSize: "22px"
    };

    const self$W = vars => {
      const {
        primaryColor,
        borderRadius,
        lineHeight,
        fontSize,
        cardColor,
        textColor2,
        textColor1,
        dividerColor,
        fontWeightStrong,
        closeIconColor,
        closeIconColorHover,
        closeIconColorPressed,
        closeColorHover,
        closeColorPressed,
        modalColor,
        boxShadow1,
        popoverColor,
        actionColor
      } = vars;
      return { ...commonVariables$d,
        lineHeight,
        color: cardColor,
        colorModal: modalColor,
        colorPopover: popoverColor,
        colorTarget: primaryColor,
        colorEmbedded: actionColor,
        textColor: textColor2,
        titleTextColor: textColor1,
        borderColor: dividerColor,
        actionColor,
        titleFontWeight: fontWeightStrong,
        closeColorHover,
        closeColorPressed,
        closeBorderRadius: borderRadius,
        closeIconColor,
        closeIconColorHover,
        closeIconColorPressed,
        fontSizeSmall: fontSize,
        fontSizeMedium: fontSize,
        fontSizeLarge: fontSize,
        fontSizeHuge: fontSize,
        boxShadow: boxShadow1,
        borderRadius
      };
    };
    const cardLight = {
      name: "Card",
      common: commonLight,
      self: self$W
    };
    var cardLight$1 = cardLight;

    const cardDark = {
      name: "Card",
      common: commonDark,

      self(vars) {
        const commonSelf = self$W(vars);
        const {
          cardColor
        } = vars;
        commonSelf.colorEmbedded = cardColor;
        return commonSelf;
      }

    };
    var cardDark$1 = cardDark;

    var rtlStyle$k = cB("card", [cM("rtl", `
    direction: rtl;
  `), c$1(">", [cB("card-header", [c$1(">", [cE("close", `
          margin: 0 8px 0 0;
        `)])])])]);

    const cardRtl = {
      name: "Card",
      style: rtlStyle$k
    };

    var style$16 = c$1([cB("card", `
    font-size: var(--n-font-size);
    line-height: var(--n-line-height);
    display: flex;
    flex-direction: column;
    width: 100%;
    box-sizing: border-box;
    position: relative;
    border-radius: var(--n-border-radius);
    background-color: var(--n-color);
    color: var(--n-text-color);
    word-break: break-word;
    transition:
      color .3s var(--n-bezier),
      background-color .3s var(--n-bezier),
      box-shadow .3s var(--n-bezier),
      border-color .3s var(--n-bezier);
  `, [cM("hoverable", [c$1("&:hover", "box-shadow: var(--n-box-shadow);")]), cM("content-segmented", [c$1(">", [cE("content", {
      paddingTop: "var(--n-padding-bottom)"
    })])]), cM("content-soft-segmented", [c$1(">", [cE("content", `
          margin: 0 var(--n-padding-left);
          padding: var(--n-padding-bottom) 0;
        `)])]), cM("footer-segmented", [c$1(">", [cE("footer", {
      paddingTop: "var(--n-padding-bottom)"
    })])]), cM("footer-soft-segmented", [c$1(">", [cE("footer", `
          padding: var(--n-padding-bottom) 0;
          margin: 0 var(--n-padding-left);
        `)])]), c$1(">", [cB("card-header", `
        box-sizing: border-box;
        display: flex;
        align-items: center;
        font-size: var(--n-title-font-size);
        padding:
          var(--n-padding-top)
          var(--n-padding-left)
          var(--n-padding-bottom)
          var(--n-padding-left);
      `, [cE("main", `
          font-weight: var(--n-title-font-weight);
          transition: color .3s var(--n-bezier);
          flex: 1;
          color: var(--n-title-text-color);
        `), cE("extra", `
          display: flex;
          align-items: center;
          font-size: var(--n-font-size);
          font-weight: 400;
          transition: color .3s var(--n-bezier);
          color: var(--n-text-color);
        `), cE("close", `
          margin: 0 0 0 8px;
          transition:
            background-color .3s var(--n-bezier),
            color .3s var(--n-bezier);
        `)]), cE("action", `
        box-sizing: border-box;
        transition:
          background-color .3s var(--n-bezier),
          border-color .3s var(--n-bezier);
        background-clip: padding-box;
        background-color: var(--n-action-color);
      `), cE("content", "flex: 1;"), cE("content, footer", `
        box-sizing: border-box;
        padding: 0 var(--n-padding-left) var(--n-padding-bottom) var(--n-padding-left);
        font-size: var(--n-font-size);
      `, [c$1("&:first-child", {
      paddingTop: "var(--n-padding-bottom)"
    })]), cE("action", `
        background-color: var(--n-action-color);
        padding: var(--n-padding-bottom) var(--n-padding-left);
        border-bottom-left-radius: var(--n-border-radius);
        border-bottom-right-radius: var(--n-border-radius);
      `)]), cB("card-cover", `
      overflow: hidden;
      width: 100%;
      border-radius: var(--n-border-radius) var(--n-border-radius) 0 0;
    `, [c$1("img", `
        display: block;
        width: 100%;
      `)]), cM("bordered", `
      border: 1px solid var(--n-border-color);
    `, [c$1("&:target", "border-color: var(--n-color-target);")]), cM("action-segmented", [c$1(">", [cE("action", [c$1("&:not(:first-child)", {
      borderTop: "1px solid var(--n-border-color)"
    })])])]), cM("content-segmented, content-soft-segmented", [c$1(">", [cE("content", {
      transition: "border-color 0.3s var(--n-bezier)"
    }, [c$1("&:not(:first-child)", {
      borderTop: "1px solid var(--n-border-color)"
    })])])]), cM("footer-segmented, footer-soft-segmented", [c$1(">", [cE("footer", {
      transition: "border-color 0.3s var(--n-bezier)"
    }, [c$1("&:not(:first-child)", {
      borderTop: "1px solid var(--n-border-color)"
    })])])])]), insideModal(cB("card", {
      background: "var(--n-color-modal)"
    })), insidePopover(cB("card", {
      background: "var(--n-color-popover)"
    })), cB("card", [asModal({
      background: "var(--n-color-modal)"
    })])]);

    const cardBaseProps = {
      title: String,
      contentStyle: [Object, String],
      headerStyle: [Object, String],
      headerExtraStyle: [Object, String],
      footerStyle: [Object, String],
      embedded: Boolean,
      segmented: {
        type: [Boolean, Object],
        default: false
      },
      size: {
        type: String,
        default: "medium"
      },
      bordered: {
        type: Boolean,
        default: true
      },
      closable: {
        type: Boolean,
        default: false
      },
      hoverable: Boolean,
      role: String,
      onClose: [Function, Array]
    };
    const cardBasePropKeys = keysOf(cardBaseProps);
    const cardProps = {
      ...useTheme.props,
      ...cardBaseProps
    };
    var NCard = vue.defineComponent({
      name: "Card",
      props: cardProps,
      setup(props) {
        const handleCloseClick = () => {
          const { onClose } = props;
          if (onClose)
            call(onClose);
        };
        const { inlineThemeDisabled, mergedClsPrefixRef, mergedRtlRef } = useConfig(props);
        const themeRef = useTheme(
          "Card",
          "-card",
          style$16,
          cardLight$1,
          props,
          mergedClsPrefixRef
        );
        const rtlEnabledRef = useRtl("Card", mergedRtlRef, mergedClsPrefixRef);
        const cssVarsRef = vue.computed(() => {
          const { size } = props;
          const {
            self: {
              color,
              colorModal,
              colorTarget,
              textColor,
              titleTextColor,
              titleFontWeight,
              borderColor,
              actionColor,
              borderRadius,
              lineHeight,
              closeIconColor,
              closeIconColorHover,
              closeIconColorPressed,
              closeColorHover,
              closeColorPressed,
              closeBorderRadius,
              closeIconSize,
              closeSize,
              boxShadow,
              colorPopover,
              colorEmbedded,
              [createKey("padding", size)]: padding,
              [createKey("fontSize", size)]: fontSize,
              [createKey("titleFontSize", size)]: titleFontSize
            },
            common: { cubicBezierEaseInOut }
          } = themeRef.value;
          const {
            top: paddingTop,
            left: paddingLeft,
            bottom: paddingBottom
          } = getMargin(padding);
          return {
            "--n-bezier": cubicBezierEaseInOut,
            "--n-border-radius": borderRadius,
            "--n-color": props.embedded ? colorEmbedded : color,
            "--n-color-modal": colorModal,
            "--n-color-popover": colorPopover,
            "--n-color-target": colorTarget,
            "--n-text-color": textColor,
            "--n-line-height": lineHeight,
            "--n-action-color": actionColor,
            "--n-title-text-color": titleTextColor,
            "--n-title-font-weight": titleFontWeight,
            "--n-close-icon-color": closeIconColor,
            "--n-close-icon-color-hover": closeIconColorHover,
            "--n-close-icon-color-pressed": closeIconColorPressed,
            "--n-close-color-hover": closeColorHover,
            "--n-close-color-pressed": closeColorPressed,
            "--n-border-color": borderColor,
            "--n-box-shadow": boxShadow,
            "--n-padding-top": paddingTop,
            "--n-padding-bottom": paddingBottom,
            "--n-padding-left": paddingLeft,
            "--n-font-size": fontSize,
            "--n-title-font-size": titleFontSize,
            "--n-close-size": closeSize,
            "--n-close-icon-size": closeIconSize,
            "--n-close-border-radius": closeBorderRadius
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass(
          "card",
          vue.computed(() => {
            return props.size[0];
          }),
          cssVarsRef,
          props
        ) : void 0;
        return {
          rtlEnabled: rtlEnabledRef,
          mergedClsPrefix: mergedClsPrefixRef,
          mergedTheme: themeRef,
          handleCloseClick,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender
        };
      },
      render() {
        const {
          segmented,
          bordered,
          hoverable,
          mergedClsPrefix,
          rtlEnabled,
          onRender,
          $slots
        } = this;
        onRender?.();
        return /* @__PURE__ */ vue.h("div", {
          class: [
            `${mergedClsPrefix}-card`,
            this.themeClass,
            {
              [`${mergedClsPrefix}-card--rtl`]: rtlEnabled,
              [`${mergedClsPrefix}-card--content${typeof segmented !== "boolean" && segmented.content === "soft" ? "-soft" : ""}-segmented`]: segmented === true || segmented !== false && segmented.content,
              [`${mergedClsPrefix}-card--footer${typeof segmented !== "boolean" && segmented.footer === "soft" ? "-soft" : ""}-segmented`]: segmented === true || segmented !== false && segmented.footer,
              [`${mergedClsPrefix}-card--action-segmented`]: segmented === true || segmented !== false && segmented.action,
              [`${mergedClsPrefix}-card--bordered`]: bordered,
              [`${mergedClsPrefix}-card--hoverable`]: hoverable
            }
          ],
          style: this.cssVars,
          role: this.role
        }, resolveWrappedSlot(
          $slots.cover,
          (children) => children && /* @__PURE__ */ vue.h("div", {
            class: `${mergedClsPrefix}-card-cover`,
            role: "none"
          }, children)
        ), resolveWrappedSlot($slots.header, (children) => {
          return children || this.title || this.closable ? /* @__PURE__ */ vue.h("div", {
            class: `${mergedClsPrefix}-card-header`,
            style: this.headerStyle
          }, /* @__PURE__ */ vue.h("div", {
            class: `${mergedClsPrefix}-card-header__main`,
            role: "heading"
          }, children || [this.title]), resolveWrappedSlot(
            $slots["header-extra"],
            (children2) => children2 && /* @__PURE__ */ vue.h("div", {
              class: `${mergedClsPrefix}-card-header__extra`,
              style: this.headerExtraStyle
            }, children2)
          ), this.closable ? /* @__PURE__ */ vue.h(NBaseClose, {
            clsPrefix: mergedClsPrefix,
            class: `${mergedClsPrefix}-card-header__close`,
            onClick: this.handleCloseClick,
            absolute: true
          }) : null) : null;
        }), resolveWrappedSlot(
          $slots.default,
          (children) => children && /* @__PURE__ */ vue.h("div", {
            class: `${mergedClsPrefix}-card__content`,
            style: this.contentStyle,
            role: "none"
          }, children)
        ), resolveWrappedSlot(
          $slots.footer,
          (children) => children && [
            /* @__PURE__ */ vue.h("div", {
              class: `${mergedClsPrefix}-card__footer`,
              style: this.footerStyle,
              role: "none"
            }, children)
          ]
        ), resolveWrappedSlot(
          $slots.action,
          (children) => children && /* @__PURE__ */ vue.h("div", {
            class: `${mergedClsPrefix}-card__action`,
            role: "none"
          }, children)
        ));
      }
    });

    const self$V = vars => {
      return {
        dotSize: "8px",
        dotColor: "rgba(255, 255, 255, .3)",
        dotColorActive: "rgba(255, 255, 255, 1)",
        dotColorFocus: "rgba(255, 255, 255, .5)",
        dotLineWidth: "16px",
        dotLineWidthActive: "24px",
        arrowColor: "#eee"
      };
    };
    const carouselLight = {
      name: "Carousel",
      common: commonLight,
      self: self$V
    };
    var carouselLight$1 = carouselLight;

    const carouselDark = {
      name: "Carousel",
      common: commonDark,
      self: self$V
    };
    var carouselDark$1 = carouselDark;

    function addDuplicateSlides(slides) {
      const {
        length
      } = slides;

      if (length > 1) {
        slides.push(duplicateSlide(slides[0], 0, "append"));
        slides.unshift(duplicateSlide(slides[length - 1], length - 1, "prepend"));
        return slides;
      }

      return slides;
    }

    function duplicateSlide(child, index, position) {
      return vue.cloneVNode(child, {
        key: `carousel-item-duplicate-${index}-${position}`
      });
    }

    function getDisplayIndex(current, length, duplicatedable) {
      return !duplicatedable ? current : current === 0 ? length - 3 : current === length - 1 ? 0 : current - 1;
    }
    function getRealIndex(current, duplicatedable) {
      return !duplicatedable ? current : current + 1;
    }
    function getPrevIndex(current, length, duplicatedable) {
      if (current < 0) return null;
      return current === 0 ? duplicatedable ? length - 1 : null : current - 1;
    }
    function getNextIndex(current, length, duplicatedable) {
      if (current > length - 1) return null;
      return current === length - 1 ? duplicatedable ? 0 : null : current + 1;
    }
    function getDisplayTotalView(total, duplicatedable) {
      return duplicatedable && total > 3 ? total - 2 : total;
    }

    function isTouchEvent$1(e) {
      return window.TouchEvent && e instanceof window.TouchEvent;
    }

    function calculateSize(element, innerOnly) {
      let {
        width,
        height
      } = element.getBoundingClientRect();

      if (innerOnly) {
        const style = getComputedStyle(element);
        width = width - parseFloat(style.getPropertyValue("padding-left")) - parseFloat(style.getPropertyValue("padding-right"));
        height = height - parseFloat(style.getPropertyValue("padding-top")) - parseFloat(style.getPropertyValue("padding-bottom"));
      }

      return {
        width,
        height
      };
    }
    function clampValue(value, min, max) {
      return value < min ? min : value > max ? max : value;
    }
    function resolveSpeed(value) {
      if (value === void 0) return 0;
      if (typeof value === "number") return value;
      const timeRE = /^((\d+)?\.?\d+?)(ms|s)?$/;
      const match = value.match(timeRE);

      if (match) {
        const [, number,, unit = "ms"] = match;
        return Number(number) * (unit === "ms" ? 1 : 1e3);
      }

      return 0;
    }

    const carouselMethodsInjectionKey = createInjectionKey("n-carousel-methods");
    const provideCarouselContext = contextValue => vue.provide(carouselMethodsInjectionKey, contextValue);
    const useCarouselContext = function () {
      let location = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "unknown";
      let component = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "component";
      const CarouselContext = vue.inject(carouselMethodsInjectionKey);

      if (!CarouselContext) {
        throwError(location, `\`${component}\` must be placed inside \`n-carousel\`.`);
      }

      return CarouselContext;
    };

    const carouselDotsProps = {
      total: {
        type: Number,
        default: 0
      },
      currentIndex: {
        type: Number,
        default: 0
      },
      dotType: {
        type: String,
        default: "dot"
      },
      trigger: {
        type: String,
        default: "click"
      },
      keyboard: Boolean
    };
    var NCarouselDots = vue.defineComponent({
      name: "CarouselDots",
      props: carouselDotsProps,
      setup(props) {
        const { mergedClsPrefixRef } = useConfig(props);
        const dotElsRef = vue.ref([]);
        const NCarousel = useCarouselContext();
        function handleKeydown(e, current) {
          switch (e.key) {
            case "Enter":
            case " ":
              e.preventDefault();
              NCarousel.to(current);
              return;
          }
          if (props.keyboard) {
            handleKeyboard(e);
          }
        }
        function handleMouseenter(current) {
          if (props.trigger === "hover") {
            NCarousel.to(current);
          }
        }
        function handleClick(current) {
          if (props.trigger === "click") {
            NCarousel.to(current);
          }
        }
        function handleKeyboard(e) {
          if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {
            return;
          }
          const nodeName = document.activeElement?.nodeName.toLowerCase();
          if (nodeName === "input" || nodeName === "textarea") {
            return;
          }
          const { code: keycode } = e;
          const isVerticalNext = keycode === "PageUp" || keycode === "ArrowUp";
          const isVerticalPrev = keycode === "PageDown" || keycode === "ArrowDown";
          const isHorizontalNext = keycode === "PageUp" || keycode === "ArrowRight";
          const isHorizontalPrev = keycode === "PageDown" || keycode === "ArrowLeft";
          const vertical = NCarousel.isVertical();
          const wantToNext = vertical ? isVerticalNext : isHorizontalNext;
          const wantToPrev = vertical ? isVerticalPrev : isHorizontalPrev;
          if (!wantToNext && !wantToPrev) {
            return;
          }
          e.preventDefault();
          if (wantToNext && !NCarousel.isNextDisabled()) {
            NCarousel.next();
            focusDot(NCarousel.currentIndexRef.value);
          } else if (wantToPrev && !NCarousel.isPrevDisabled()) {
            NCarousel.prev();
            focusDot(NCarousel.currentIndexRef.value);
          }
        }
        function focusDot(index) {
          dotElsRef.value[index]?.focus();
        }
        vue.onBeforeUpdate(() => dotElsRef.value.length = 0);
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          dotEls: dotElsRef,
          handleKeydown,
          handleMouseenter,
          handleClick
        };
      },
      render() {
        const { mergedClsPrefix, dotEls } = this;
        return /* @__PURE__ */ vue.h("div", {
          class: [
            `${mergedClsPrefix}-carousel__dots`,
            `${mergedClsPrefix}-carousel__dots--${this.dotType}`
          ],
          role: "tablist"
        }, indexMap(this.total, (i) => {
          const selected = i === this.currentIndex;
          return /* @__PURE__ */ vue.h("div", {
            "aria-selected": selected,
            ref: (el) => dotEls.push(el),
            role: "button",
            tabindex: "0",
            class: [
              `${mergedClsPrefix}-carousel__dot`,
              selected && `${mergedClsPrefix}-carousel__dot--active`
            ],
            key: i,
            onClick: () => this.handleClick(i),
            onMouseenter: () => this.handleMouseenter(i),
            onKeydown: (e) => this.handleKeydown(e, i)
          });
        }));
      }
    });

    const backwardIcon = /* @__PURE__ */ vue.h("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 16 16"
    }, /* @__PURE__ */ vue.h("g", {
      fill: "none"
    }, /* @__PURE__ */ vue.h("path", {
      d: "M10.26 3.2a.75.75 0 0 1 .04 1.06L6.773 8l3.527 3.74a.75.75 0 1 1-1.1 1.02l-4-4.25a.75.75 0 0 1 0-1.02l4-4.25a.75.75 0 0 1 1.06-.04z",
      fill: "currentColor"
    })));
    const forwardIcon = /* @__PURE__ */ vue.h("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 16 16"
    }, /* @__PURE__ */ vue.h("g", {
      fill: "none"
    }, /* @__PURE__ */ vue.h("path", {
      d: "M5.74 3.2a.75.75 0 0 0-.04 1.06L9.227 8L5.7 11.74a.75.75 0 1 0 1.1 1.02l4-4.25a.75.75 0 0 0 0-1.02l-4-4.25a.75.75 0 0 0-1.06-.04z",
      fill: "currentColor"
    })));
    var NCarouselArrow = vue.defineComponent({
      name: "CarouselArrow",
      setup(props) {
        const { mergedClsPrefixRef } = useConfig(props);
        const { isVertical, isPrevDisabled, isNextDisabled, prev, next } = useCarouselContext();
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          isVertical,
          isPrevDisabled,
          isNextDisabled,
          prev,
          next
        };
      },
      render() {
        const { mergedClsPrefix } = this;
        return /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-carousel__arrow-group`
        }, /* @__PURE__ */ vue.h("div", {
          class: [
            `${mergedClsPrefix}-carousel__arrow`,
            this.isPrevDisabled() && `${mergedClsPrefix}-carousel__arrow--disabled`
          ],
          role: "button",
          onClick: this.prev
        }, backwardIcon), /* @__PURE__ */ vue.h("div", {
          class: [
            `${mergedClsPrefix}-carousel__arrow`,
            this.isNextDisabled() && `${mergedClsPrefix}-carousel__arrow--disabled`
          ],
          role: "button",
          onClick: this.next
        }, forwardIcon));
      }
    });

    const CarouselItemName = "CarouselItem";
    const isCarouselItem = (child) => child.type?.name === CarouselItemName;
    var NCarouselItem = vue.defineComponent({
      name: CarouselItemName,
      setup(props) {
        const { mergedClsPrefixRef } = useConfig(props);
        const NCarousel = useCarouselContext(
          lodash.exports.camelCase(CarouselItemName),
          `n-${lodash.exports.camelCase(CarouselItemName)}`
        );
        const selfElRef = vue.ref();
        const indexRef = vue.computed(() => {
          const { value: selfEl } = selfElRef;
          return selfEl ? NCarousel.getSlideIndex(selfEl) : -1;
        });
        const isPrevRef = vue.computed(() => NCarousel.isPrev(indexRef.value));
        const isNextRef = vue.computed(() => NCarousel.isNext(indexRef.value));
        const isActiveRef = vue.computed(() => NCarousel.isActive(indexRef.value));
        const styleRef = vue.computed(() => NCarousel.getSlideStyle(indexRef.value));
        vue.onMounted(() => NCarousel.addSlide(selfElRef.value));
        vue.onBeforeUnmount(() => {
          NCarousel.removeSlide(selfElRef.value);
        });
        function handleClick(event) {
          const { value: index } = indexRef;
          if (index !== void 0) {
            NCarousel?.onCarouselItemClick(index, event);
          }
        }
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          selfElRef,
          isPrev: isPrevRef,
          isNext: isNextRef,
          isActive: isActiveRef,
          index: indexRef,
          style: styleRef,
          handleClick
        };
      },
      render() {
        const {
          $slots: slots,
          mergedClsPrefix,
          isPrev,
          isNext,
          isActive,
          index,
          style
        } = this;
        const className = [
          `${mergedClsPrefix}-carousel__slide`,
          {
            [`${mergedClsPrefix}-carousel__slide--current`]: isActive,
            [`${mergedClsPrefix}-carousel__slide--prev`]: isPrev,
            [`${mergedClsPrefix}-carousel__slide--next`]: isNext
          }
        ];
        return /* @__PURE__ */ vue.h("div", {
          ref: "selfElRef",
          class: className,
          role: "option",
          tabindex: "-1",
          "data-index": index,
          "aria-hidden": !isActive,
          style,
          onClickCapture: this.handleClick
        }, slots.default?.({
          isPrev,
          isNext,
          isActive,
          index
        }));
      }
    });

    var style$15 = cB("carousel", `
  position: relative;
  width: 100%;
  height: 100%;
  touch-action: pan-y;
  overflow: hidden;
`, [cE("slides", `
    display: flex;
    width: 100%;
    height: 100%;
    transition-timing-function: var(--n-bezier);
    transition-property: transform;
  `, [cE("slide", `
      flex-shrink: 0;
      position: relative;
      width: 100%;
      height: 100%;
      outline: none;
      overflow: hidden;
    `, [c$1("> img", `
        display: block;
      `)])]), cE("dots", `
    position: absolute;
    display: flex;
    flex-wrap: nowrap;
  `, [cM("dot", [cE("dot", `
        height: var(--n-dot-size);
        width: var(--n-dot-size);
        background-color: var(--n-dot-color);
        border-radius: 50%;
        cursor: pointer;
        transition:
          box-shadow .3s var(--n-bezier),
          background-color .3s var(--n-bezier);
        outline: none;
      `, [c$1("&:focus", `
          background-color: var(--n-dot-color-focus);
        `), cM("active", `
          background-color: var(--n-dot-color-active);
        `)])]), cM("line", [cE("dot", `
        border-radius: 9999px;
        width: var(--n-dot-line-width);
        height: 4px;
        background-color: var(--n-dot-color);
        cursor: pointer;
        transition:
          width .3s var(--n-bezier),
          box-shadow .3s var(--n-bezier),
          background-color .3s var(--n-bezier);
        outline: none;
      `, [c$1("&:focus", `
          background-color: var(--n-dot-color-focus);
        `), cM("active", `
          width: var(--n-dot-line-width-active);
          background-color: var(--n-dot-color-active);
        `)])])]), cE("arrow", `
    transition: background-color .3s var(--n-bezier);
    cursor: pointer;
    height: 28px;
    width: 28px;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: rgba(255, 255, 255, .2);
    color: var(--n-arrow-color);
    border-radius: 8px;
    user-select: none;
    -webkit-user-select: none;
    font-size: 18px;
  `, [c$1("svg", `
      height: 1em;
      width: 1em;
    `), c$1("&:hover", `
      background-color: rgba(255, 255, 255, .3);
    `)]), cM("vertical", `
    touch-action: pan-x;
  `, [cE("slides", `
      flex-direction: column;
    `), cM("fade", [cE("slide", `
        top: 50%;
        left: unset;
        transform: translateY(-50%);
      `)]), cM("card", [cE("slide", `
        top: 50%;
        left: unset;
        transform: translateY(-50%) translateZ(-400px);
      `, [cM("current", `
          transform: translateY(-50%) translateZ(0);
        `), cM("prev", `
          transform: translateY(-100%) translateZ(-200px);
        `), cM("next", `
          transform: translateY(0%) translateZ(-200px);
        `)])])]), cM("usercontrol", [cE("slides", [c$1(">", [c$1("div", `
          position: absolute;
          top: 50%;
          left: 50%;
          width: 100%;
          height: 100%;
          transform: translate(-50%, -50%);
        `)])])]), cM("left", [cE("dots", `
      transform: translateY(-50%);
      top: 50%;
      left: 12px;
      flex-direction: column;
    `, [cM("line", [cE("dot", `
          width: 4px;
          height: var(--n-dot-line-width);
          margin: 4px 0;
          transition:
            height .3s var(--n-bezier),
            box-shadow .3s var(--n-bezier),
            background-color .3s var(--n-bezier);
          outline: none;
        `, [cM("active", `
            height: var(--n-dot-line-width-active);
          `)])])]), cE("dot", `
      margin: 4px 0;
    `)]), cE("arrow-group", `
    position: absolute;
    display: flex;
    flex-wrap: nowrap;
  `), cM("vertical", [cE("arrow", `
      transform: rotate(90deg);
    `)]), cM("show-arrow", [cM("bottom", [cE("dots", `
        transform: translateX(0);
        bottom: 18px;
        left: 18px;
      `)]), cM("top", [cE("dots", `
        transform: translateX(0);
        top: 18px;
        left: 18px;
      `)]), cM("left", [cE("dots", `
        transform: translateX(0);
        top: 18px;
        left: 18px;
      `)]), cM("right", [cE("dots", `
        transform: translateX(0);
        top: 18px;
        right: 18px;
      `)])]), cM("left", [cE("arrow-group", `
      bottom: 12px;
      left: 12px;
      flex-direction: column;
    `, [c$1("> *:first-child", `
        margin-bottom: 12px;
      `)])]), cM("right", [cE("dots", `
      transform: translateY(-50%);
      top: 50%;
      right: 12px;
      flex-direction: column;
    `, [cM("line", [cE("dot", `
          width: 4px;
          height: var(--n-dot-line-width);
          margin: 4px 0;
          transition:
            height .3s var(--n-bezier),
            box-shadow .3s var(--n-bezier),
            background-color .3s var(--n-bezier);
          outline: none;
        `, [cM("active", `
            height: var(--n-dot-line-width-active);
          `)])])]), cE("dot", `
      margin: 4px 0;
    `), cE("arrow-group", `
      bottom: 12px;
      right: 12px;
      flex-direction: column;
    `, [c$1("> *:first-child", `
        margin-bottom: 12px;
      `)])]), cM("top", [cE("dots", `
      transform: translateX(-50%);
      top: 12px;
      left: 50%;
    `, [cM("line", [cE("dot", `
          margin: 0 4px;
        `)])]), cE("dot", `
      margin: 0 4px;
    `), cE("arrow-group", `
      top: 12px;
      right: 12px;
    `, [c$1("> *:first-child", `
        margin-right: 12px;
      `)])]), cM("bottom", [cE("dots", `
      transform: translateX(-50%);
      bottom: 12px;
      left: 50%;
    `, [cM("line", [cE("dot", `
          margin: 0 4px;
        `)])]), cE("dot", `
      margin: 0 4px;
    `), cE("arrow-group", `
      bottom: 12px;
      right: 12px;
    `, [c$1("> *:first-child", `
        margin-right: 12px;
      `)])]), cM("fade", [cE("slide", `
      position: absolute;
      opacity: 0;
      transition-property: opacity;
      pointer-events: none;
    `, [cM("current", `
        opacity: 1;
        pointer-events: auto;
      `)])]), cM("card", [cE("slides", `
      perspective: 1000px;
    `), cE("slide", `
      position: absolute;
      left: 50%;
      opacity: 0;
      transform: translateX(-50%) translateZ(-400px);
      transition-property: opacity, transform;
    `, [cM("current", `
        opacity: 1;
        transform: translateX(-50%) translateZ(0);
        z-index: 1;
      `), cM("prev", `
        opacity: 0.4;
        transform: translateX(-100%) translateZ(-200px);
      `), cM("next", `
        opacity: 0.4;
        transform: translateX(0%) translateZ(-200px);
      `)])])]);

    const transitionProperties = [
      "transitionDuration",
      "transitionTimingFunction"
    ];
    const carouselProps = {
      ...useTheme.props,
      defaultIndex: {
        type: Number,
        default: 0
      },
      currentIndex: Number,
      showArrow: Boolean,
      dotType: {
        type: String,
        default: "dot"
      },
      dotPlacement: {
        type: String,
        default: "bottom"
      },
      slidesPerView: {
        type: [Number, String],
        default: 1
      },
      spaceBetween: {
        type: Number,
        default: 0
      },
      centeredSlides: Boolean,
      direction: {
        type: String,
        default: "horizontal"
      },
      autoplay: Boolean,
      interval: {
        type: Number,
        default: 5e3
      },
      loop: {
        type: Boolean,
        default: true
      },
      effect: {
        type: String,
        default: "slide"
      },
      showDots: {
        type: Boolean,
        default: true
      },
      trigger: {
        type: String,
        default: "click"
      },
      transitionStyle: {
        type: Object,
        default: () => ({
          transitionDuration: "300ms"
        })
      },
      transitionProps: Object,
      draggable: Boolean,
      prevSlideStyle: [Object, String],
      nextSlideStyle: [Object, String],
      touchable: {
        type: Boolean,
        default: true
      },
      mousewheel: Boolean,
      keyboard: Boolean,
      "onUpdate:currentIndex": Function,
      onUpdateCurrentIndex: Function
    };
    let globalDragging = false;
    var Carousel = vue.defineComponent({
      name: "Carousel",
      props: carouselProps,
      setup(props) {
        const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
        const selfElRef = vue.ref(null);
        const slidesElRef = vue.ref(null);
        const slideElsRef = vue.ref([]);
        const slideVNodesRef = { value: [] };
        const verticalRef = vue.computed(() => props.direction === "vertical");
        const sizeAxisRef = vue.computed(() => verticalRef.value ? "height" : "width");
        const spaceAxisRef = vue.computed(
          () => verticalRef.value ? "bottom" : "right"
        );
        const sequenceLayoutRef = vue.computed(() => props.effect === "slide");
        const duplicatedableRef = vue.computed(
          () => props.loop && props.slidesPerView === 1 && sequenceLayoutRef.value
        );
        const userWantsControlRef = vue.computed(() => props.effect === "custom");
        const displaySlidesPerViewRef = vue.computed(
          () => !sequenceLayoutRef.value || props.centeredSlides ? 1 : props.slidesPerView
        );
        const realSlidesPerViewRef = vue.computed(
          () => userWantsControlRef.value ? 1 : props.slidesPerView
        );
        const autoSlideSizeRef = vue.computed(
          () => displaySlidesPerViewRef.value === "auto" || props.slidesPerView === "auto" && props.centeredSlides
        );
        const perViewSizeRef = vue.ref({ width: 0, height: 0 });
        const slideSizesRef = vue.computed(() => {
          const { value: slidesEls } = slideElsRef;
          if (!slidesEls.length)
            return [];
          const { value: autoSlideSize } = autoSlideSizeRef;
          if (autoSlideSize) {
            return slidesEls.map((slide) => calculateSize(slide));
          }
          const { value: slidesPerView } = realSlidesPerViewRef;
          const { value: perViewSize } = perViewSizeRef;
          const { value: axis } = sizeAxisRef;
          let axisSize = perViewSize[axis];
          if (slidesPerView !== "auto") {
            const { spaceBetween } = props;
            const remaining = axisSize - (slidesPerView - 1) * spaceBetween;
            const percentage = 1 / Math.max(1, slidesPerView);
            axisSize = remaining * percentage;
          }
          const slideSize = { ...perViewSize, [axis]: axisSize };
          return slidesEls.map(() => slideSize);
        });
        const slideTranlatesRef = vue.computed(() => {
          const { value: slideSizes } = slideSizesRef;
          if (!slideSizes.length)
            return [];
          const { centeredSlides, spaceBetween } = props;
          const { value: axis } = sizeAxisRef;
          const { [axis]: perViewSize } = perViewSizeRef.value;
          let previousTranslate2 = 0;
          return slideSizes.map(({ [axis]: slideSize }) => {
            let translate = previousTranslate2;
            if (centeredSlides) {
              translate += (slideSize - perViewSize) / 2;
            }
            previousTranslate2 += slideSize + spaceBetween;
            return translate;
          });
        });
        const isMountedRef = vue.ref(false);
        const transitionStyleRef = vue.computed(() => {
          const { transitionStyle } = props;
          return transitionStyle ? keep(transitionStyle, transitionProperties) : {};
        });
        const speedRef = vue.computed(
          () => userWantsControlRef.value ? 0 : resolveSpeed(transitionStyleRef.value.transitionDuration)
        );
        const slideStylesRef = vue.computed(() => {
          const { value: slidesEls } = slideElsRef;
          if (!slidesEls.length)
            return [];
          const useComputedSize = !(autoSlideSizeRef.value || realSlidesPerViewRef.value === 1);
          const getSlideSize = (index) => {
            if (useComputedSize) {
              const { value: axis } = sizeAxisRef;
              return {
                [axis]: `${slideSizesRef.value[index][axis]}px`
              };
            }
          };
          if (userWantsControlRef.value) {
            return slidesEls.map((_, i) => getSlideSize(i));
          }
          const { effect, spaceBetween } = props;
          const { value: spaceAxis } = spaceAxisRef;
          return slidesEls.reduce((styles, _, i) => {
            const style2 = {
              ...getSlideSize(i),
              [`margin-${spaceAxis}`]: `${spaceBetween}px`
            };
            styles.push(style2);
            if (isMountedRef.value && (effect === "fade" || effect === "card")) {
              Object.assign(style2, transitionStyleRef.value);
            }
            return styles;
          }, []);
        });
        const totalViewRef = vue.computed(() => {
          const { value: slidesPerView } = displaySlidesPerViewRef;
          const { length: totalSlides } = slideElsRef.value;
          if (slidesPerView !== "auto") {
            return Math.max(totalSlides - slidesPerView, 0) + 1;
          } else {
            const { value: slideSizes } = slideSizesRef;
            const { length } = slideSizes;
            if (!length)
              return totalSlides;
            const { value: translates } = slideTranlatesRef;
            const { value: axis } = sizeAxisRef;
            const perViewSize = perViewSizeRef.value[axis];
            let lastViewSize = slideSizes[slideSizes.length - 1][axis];
            let i = length;
            while (i > 1 && lastViewSize < perViewSize) {
              i--;
              lastViewSize += translates[i] - translates[i - 1];
            }
            return clampValue(i + 1, 1, length);
          }
        });
        const displayTotalViewRef = vue.computed(
          () => getDisplayTotalView(totalViewRef.value, duplicatedableRef.value)
        );
        const defaultRealIndex = getRealIndex(
          props.defaultIndex,
          duplicatedableRef.value
        );
        const uncontrolledDisplayIndexRef = vue.ref(
          getDisplayIndex(
            defaultRealIndex,
            totalViewRef.value,
            duplicatedableRef.value
          )
        );
        const mergedDisplayIndexRef = useMergedState(
          vue.toRef(props, "currentIndex"),
          uncontrolledDisplayIndexRef
        );
        const realIndexRef = vue.computed(
          () => getRealIndex(mergedDisplayIndexRef.value, duplicatedableRef.value)
        );
        function toRealIndex(index) {
          index = clampValue(index, 0, totalViewRef.value - 1);
          const displayIndex = getDisplayIndex(
            index,
            totalViewRef.value,
            duplicatedableRef.value
          );
          const { value: lastDisplayIndex } = mergedDisplayIndexRef;
          if (displayIndex !== mergedDisplayIndexRef.value) {
            uncontrolledDisplayIndexRef.value = displayIndex;
            props["onUpdate:currentIndex"]?.(displayIndex, lastDisplayIndex);
            props.onUpdateCurrentIndex?.(displayIndex, lastDisplayIndex);
          }
        }
        function getRealPrevIndex(index = realIndexRef.value) {
          return getPrevIndex(index, totalViewRef.value, props.loop);
        }
        function getRealNextIndex(index = realIndexRef.value) {
          return getNextIndex(index, totalViewRef.value, props.loop);
        }
        function isRealPrev(slideOrIndex) {
          const index = getSlideIndex(slideOrIndex);
          return index !== null && getRealPrevIndex() === index;
        }
        function isRealNext(slideOrIndex) {
          const index = getSlideIndex(slideOrIndex);
          return index !== null && getRealNextIndex() === index;
        }
        function isRealActive(slideOrIndex) {
          return realIndexRef.value === getSlideIndex(slideOrIndex);
        }
        function isDisplayActive(index) {
          return mergedDisplayIndexRef.value === index;
        }
        function isPrevDisabled() {
          return getRealPrevIndex() === null;
        }
        function isNextDisabled() {
          return getRealNextIndex() === null;
        }
        function to(index) {
          const realIndex = clampValue(
            getRealIndex(index, duplicatedableRef.value),
            0,
            totalViewRef.value
          );
          if (index !== mergedDisplayIndexRef.value || realIndex !== realIndexRef.value) {
            toRealIndex(realIndex);
          }
        }
        function prev() {
          const prevIndex = getRealPrevIndex();
          if (prevIndex !== null)
            toRealIndex(prevIndex);
        }
        function next() {
          const nextIndex = getRealNextIndex();
          if (nextIndex !== null)
            toRealIndex(nextIndex);
        }
        function prevIfSlideTransitionEnd() {
          if (!inTransition || !duplicatedableRef.value)
            prev();
        }
        function nextIfSlideTransitionEnd() {
          if (!inTransition || !duplicatedableRef.value)
            next();
        }
        let inTransition = false;
        let previousTranslate = 0;
        const translateStyleRef = vue.ref({});
        function updateTranslate(translate, speed = 0) {
          translateStyleRef.value = Object.assign({}, transitionStyleRef.value, {
            transform: verticalRef.value ? `translateY(${-translate}px)` : `translateX(${-translate}px)`,
            transitionDuration: `${speed}ms`
          });
        }
        function fixTranslate(speed = 0) {
          if (sequenceLayoutRef.value) {
            translateTo(realIndexRef.value, speed);
          } else if (previousTranslate !== 0) {
            if (!inTransition && speed > 0) {
              inTransition = true;
            }
            updateTranslate(previousTranslate = 0, speed);
          }
        }
        function translateTo(index, speed) {
          const translate = getTranslate(index);
          if (translate !== previousTranslate && speed > 0) {
            inTransition = true;
          }
          previousTranslate = getTranslate(realIndexRef.value);
          updateTranslate(translate, speed);
        }
        function getTranslate(index) {
          let translate;
          if (index >= totalViewRef.value - 1) {
            translate = getLastViewTranslate();
          } else {
            translate = slideTranlatesRef.value[index] || 0;
          }
          return translate;
        }
        function getLastViewTranslate() {
          if (displaySlidesPerViewRef.value === "auto") {
            const { value: axis } = sizeAxisRef;
            const { [axis]: perViewSize } = perViewSizeRef.value;
            const { value: translates } = slideTranlatesRef;
            const lastTranslate = translates[translates.length - 1];
            let overallSize;
            if (lastTranslate === void 0) {
              overallSize = perViewSize;
            } else {
              const { value: slideSizes } = slideSizesRef;
              overallSize = lastTranslate + slideSizes[slideSizes.length - 1][axis];
            }
            return overallSize - perViewSize;
          } else {
            const { value: translates } = slideTranlatesRef;
            return translates[totalViewRef.value - 1] || 0;
          }
        }
        const carouselContext = {
          currentIndexRef: mergedDisplayIndexRef,
          to,
          prev: prevIfSlideTransitionEnd,
          next: nextIfSlideTransitionEnd,
          isVertical: () => verticalRef.value,
          isHorizontal: () => !verticalRef.value,
          isPrev: isRealPrev,
          isNext: isRealNext,
          isActive: isRealActive,
          isPrevDisabled,
          isNextDisabled,
          getSlideIndex,
          getSlideStyle,
          addSlide,
          removeSlide,
          onCarouselItemClick
        };
        provideCarouselContext(carouselContext);
        function addSlide(slide) {
          if (!slide)
            return;
          slideElsRef.value.push(slide);
        }
        function removeSlide(slide) {
          if (!slide)
            return;
          const index = getSlideIndex(slide);
          if (index !== -1) {
            slideElsRef.value.splice(index, 1);
          }
        }
        function getSlideIndex(slideOrIndex) {
          return typeof slideOrIndex === "number" ? slideOrIndex : slideOrIndex ? slideElsRef.value.indexOf(slideOrIndex) : -1;
        }
        function getSlideStyle(slide) {
          const index = getSlideIndex(slide);
          if (index !== -1) {
            const styles = [slideStylesRef.value[index]];
            const isPrev = carouselContext.isPrev(index);
            const isNext = carouselContext.isNext(index);
            if (isPrev) {
              styles.push(props.prevSlideStyle || "");
            }
            if (isNext) {
              styles.push(props.nextSlideStyle || "");
            }
            return vue.normalizeStyle(styles);
          }
        }
        function onCarouselItemClick(index, event) {
          let allowClick = !inTransition && !dragging && !isEffectiveDrag;
          if (props.effect === "card" && allowClick && !isRealActive(index)) {
            to(index);
            allowClick = false;
          }
          if (!allowClick) {
            event.preventDefault();
            event.stopPropagation();
          }
        }
        let autoplayTimer = null;
        function stopAutoplay() {
          if (autoplayTimer) {
            clearInterval(autoplayTimer);
            autoplayTimer = null;
          }
        }
        function resetAutoplay() {
          stopAutoplay();
          const disabled = !props.autoplay || displayTotalViewRef.value < 2;
          if (!disabled) {
            autoplayTimer = window.setInterval(next, props.interval);
          }
        }
        let dragStartX = 0;
        let dragStartY = 0;
        let dragOffset = 0;
        let dragStartTime = 0;
        let dragging = false;
        let isEffectiveDrag = false;
        function handleTouchstart(event) {
          if (globalDragging)
            return;
          if (!slidesElRef.value?.contains(
            getPreciseEventTarget(event)
          )) {
            return;
          }
          globalDragging = true;
          dragging = true;
          isEffectiveDrag = false;
          dragStartTime = Date.now();
          stopAutoplay();
          if (event.type !== "touchstart" && !event.target.isContentEditable) {
            event.preventDefault();
          }
          const touchEvent = isTouchEvent$1(event) ? event.touches[0] : event;
          if (verticalRef.value) {
            dragStartY = touchEvent.clientY;
          } else {
            dragStartX = touchEvent.clientX;
          }
          if (props.touchable) {
            on("touchmove", document, handleTouchmove, { passive: true });
            on("touchend", document, handleTouchend);
            on("touchcancel", document, handleTouchend);
          }
          if (props.draggable) {
            on("mousemove", document, handleTouchmove);
            on("mouseup", document, handleTouchend);
          }
        }
        function handleTouchmove(event) {
          const { value: vertical } = verticalRef;
          const { value: axis } = sizeAxisRef;
          const touchEvent = isTouchEvent$1(event) ? event.touches[0] : event;
          const offset = vertical ? touchEvent.clientY - dragStartY : touchEvent.clientX - dragStartX;
          const perViewSize = perViewSizeRef.value[axis];
          dragOffset = clampValue(offset, -perViewSize, perViewSize);
          if (event.cancelable) {
            event.preventDefault();
          }
          if (sequenceLayoutRef.value) {
            updateTranslate(previousTranslate - dragOffset, 0);
          }
        }
        function handleTouchend() {
          const { value: realIndex } = realIndexRef;
          let currentIndex = realIndex;
          if (!inTransition && dragOffset !== 0 && sequenceLayoutRef.value) {
            const currentTranslate = previousTranslate - dragOffset;
            const translates = [
              ...slideTranlatesRef.value.slice(0, totalViewRef.value - 1),
              getLastViewTranslate()
            ];
            let prevOffset = null;
            for (let i = 0; i < translates.length; i++) {
              const offset = Math.abs(translates[i] - currentTranslate);
              if (prevOffset !== null && prevOffset < offset) {
                break;
              }
              prevOffset = offset;
              currentIndex = i;
            }
          }
          if (currentIndex === realIndex) {
            const timeElapsed = Date.now() - dragStartTime;
            const { value: axis } = sizeAxisRef;
            const perViewSize = perViewSizeRef.value[axis];
            if (dragOffset > perViewSize / 2 || dragOffset / timeElapsed > 0.4) {
              currentIndex = getRealPrevIndex(realIndex);
            } else if (dragOffset < -perViewSize / 2 || dragOffset / timeElapsed < -0.4) {
              currentIndex = getRealNextIndex(realIndex);
            }
          }
          if (currentIndex !== null && currentIndex !== realIndex) {
            isEffectiveDrag = true;
            toRealIndex(currentIndex);
            void vue.nextTick(() => {
              if (!duplicatedableRef.value || uncontrolledDisplayIndexRef.value !== mergedDisplayIndexRef.value) {
                fixTranslate(speedRef.value);
              }
            });
          } else {
            fixTranslate(speedRef.value);
          }
          resetDragStatus();
          resetAutoplay();
        }
        function resetDragStatus() {
          if (dragging) {
            globalDragging = false;
          }
          dragging = false;
          dragStartX = 0;
          dragStartY = 0;
          dragOffset = 0;
          dragStartTime = 0;
          off("touchmove", document, handleTouchmove);
          off("touchend", document, handleTouchend);
          off("touchcancel", document, handleTouchend);
          off("mousemove", document, handleTouchmove);
          off("mouseup", document, handleTouchend);
        }
        function handleTransitionEnd() {
          if (sequenceLayoutRef.value && inTransition) {
            const { value: realIndex } = realIndexRef;
            translateTo(realIndex, 0);
          } else {
            resetAutoplay();
          }
          if (sequenceLayoutRef.value) {
            translateStyleRef.value.transitionDuration = "0ms";
          }
          inTransition = false;
        }
        function handleMousewheel(event) {
          event.preventDefault();
          if (inTransition)
            return;
          let { deltaX, deltaY } = event;
          if (event.shiftKey && !deltaX) {
            deltaX = deltaY;
          }
          const prevMultiplier = -1;
          const nextMultiplier = 1;
          const m = (deltaX || deltaY) > 0 ? nextMultiplier : prevMultiplier;
          let rx = 0;
          let ry = 0;
          if (verticalRef.value) {
            ry = m;
          } else {
            rx = m;
          }
          const responseStep = 10;
          if (ry * deltaY >= responseStep || rx * deltaX >= responseStep) {
            if (m === nextMultiplier && !isNextDisabled()) {
              next();
            } else if (m === prevMultiplier && !isPrevDisabled()) {
              prev();
            }
          }
        }
        function handleResize() {
          perViewSizeRef.value = calculateSize(selfElRef.value, true);
          resetAutoplay();
        }
        function handleSlideResize() {
          if (autoSlideSizeRef.value) {
            slideSizesRef.effect.scheduler?.();
            slideSizesRef.effect.run();
          }
        }
        function handleMouseenter() {
          if (props.autoplay) {
            stopAutoplay();
          }
        }
        function handleMouseleave() {
          if (props.autoplay) {
            resetAutoplay();
          }
        }
        vue.onMounted(() => {
          vue.watchEffect(resetAutoplay);
          requestAnimationFrame(() => isMountedRef.value = true);
        });
        vue.onBeforeUnmount(() => {
          resetDragStatus();
          stopAutoplay();
        });
        vue.onUpdated(() => {
          const { value: slidesEls } = slideElsRef;
          const { value: slideVNodes } = slideVNodesRef;
          const indexMap = /* @__PURE__ */ new Map();
          const getDisplayIndex2 = (el) => indexMap.has(el) ? indexMap.get(el) : -1;
          let isChanged = false;
          for (let i = 0; i < slidesEls.length; i++) {
            const index = slideVNodes.findIndex((v) => v.el === slidesEls[i]);
            if (index !== i) {
              isChanged = true;
            }
            indexMap.set(slidesEls[i], index);
          }
          if (isChanged) {
            slidesEls.sort((a, b) => getDisplayIndex2(a) - getDisplayIndex2(b));
          }
        });
        vue.watch(
          realIndexRef,
          (realIndex, lastRealIndex) => {
            if (realIndex === lastRealIndex)
              return;
            resetAutoplay();
            if (sequenceLayoutRef.value) {
              if (duplicatedableRef.value && displayTotalViewRef.value > 2) {
                const { value: length } = totalViewRef;
                if (realIndex === length - 2 && lastRealIndex === 1) {
                  realIndex = 0;
                } else if (realIndex === 1 && lastRealIndex === length - 2) {
                  realIndex = length - 1;
                }
              }
              translateTo(realIndex, speedRef.value);
            } else {
              fixTranslate();
            }
          },
          { immediate: true }
        );
        vue.watch(
          [duplicatedableRef, displaySlidesPerViewRef],
          () => void vue.nextTick(() => toRealIndex(realIndexRef.value))
        );
        vue.watch(slideTranlatesRef, () => sequenceLayoutRef.value && fixTranslate(), {
          deep: true
        });
        vue.watch(sequenceLayoutRef, (value) => {
          if (!value) {
            inTransition = false;
            updateTranslate(previousTranslate = 0);
          } else {
            fixTranslate();
          }
        });
        const slidesControlListenersRef = vue.computed(() => {
          return {
            onTouchstartPassive: props.touchable ? handleTouchstart : void 0,
            onMousedown: props.draggable ? handleTouchstart : void 0,
            onWheel: props.mousewheel ? handleMousewheel : void 0
          };
        });
        const arrowSlotPropsRef = vue.computed(() => ({
          ...keep(carouselContext, [
            "to",
            "prev",
            "next",
            "isPrevDisabled",
            "isNextDisabled"
          ]),
          total: displayTotalViewRef.value,
          currentIndex: mergedDisplayIndexRef.value
        }));
        const dotSlotPropsRef = vue.computed(() => ({
          total: displayTotalViewRef.value,
          currentIndex: mergedDisplayIndexRef.value,
          to: carouselContext.to
        }));
        const caroulseExposedMethod = {
          getCurrentIndex: () => mergedDisplayIndexRef.value,
          to,
          prev,
          next
        };
        const themeRef = useTheme(
          "Carousel",
          "-carousel",
          style$15,
          carouselLight$1,
          props,
          mergedClsPrefixRef
        );
        const cssVarsRef = vue.computed(() => {
          const {
            common: { cubicBezierEaseInOut },
            self: {
              dotSize,
              dotColor,
              dotColorActive,
              dotColorFocus,
              dotLineWidth,
              dotLineWidthActive,
              arrowColor
            }
          } = themeRef.value;
          return {
            "--n-bezier": cubicBezierEaseInOut,
            "--n-dot-color": dotColor,
            "--n-dot-color-focus": dotColorFocus,
            "--n-dot-color-active": dotColorActive,
            "--n-dot-size": dotSize,
            "--n-dot-line-width": dotLineWidth,
            "--n-dot-line-width-active": dotLineWidthActive,
            "--n-arrow-color": arrowColor
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("carousel", void 0, cssVarsRef, props) : void 0;
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          selfElRef,
          slidesElRef,
          slideVNodes: slideVNodesRef,
          duplicatedable: duplicatedableRef,
          userWantsControl: userWantsControlRef,
          autoSlideSize: autoSlideSizeRef,
          displayIndex: mergedDisplayIndexRef,
          realIndex: realIndexRef,
          slideStyles: slideStylesRef,
          translateStyle: translateStyleRef,
          slidesControlListeners: slidesControlListenersRef,
          handleTransitionEnd,
          handleResize,
          handleSlideResize,
          handleMouseenter,
          handleMouseleave,
          isActive: isDisplayActive,
          arrowSlotProps: arrowSlotPropsRef,
          dotSlotProps: dotSlotPropsRef,
          ...caroulseExposedMethod,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender
        };
      },
      render() {
        const {
          mergedClsPrefix,
          showArrow,
          userWantsControl,
          slideStyles,
          dotType,
          dotPlacement,
          slidesControlListeners,
          transitionProps = {},
          arrowSlotProps,
          dotSlotProps,
          $slots: { default: defaultSlot, dots: dotsSlot, arrow: arrowSlot }
        } = this;
        const children = defaultSlot && flatten$3(defaultSlot()) || [];
        let slides = filterCarouselItem(children);
        if (!slides.length) {
          slides = children.map((ch) => /* @__PURE__ */ vue.h(NCarouselItem, null, {
            default: () => vue.cloneVNode(ch)
          }));
        }
        if (this.duplicatedable) {
          slides = addDuplicateSlides(slides);
        }
        this.slideVNodes.value = slides;
        if (this.autoSlideSize) {
          slides = slides.map((slide) => /* @__PURE__ */ vue.h(VResizeObserver, {
            onResize: this.handleSlideResize
          }, {
            default: () => slide
          }));
        }
        this.onRender?.();
        return /* @__PURE__ */ vue.h("div", {
          ref: "selfElRef",
          class: [
            this.themeClass,
            `${mergedClsPrefix}-carousel`,
            this.direction === "vertical" && `${mergedClsPrefix}-carousel--vertical`,
            this.showArrow && `${mergedClsPrefix}-carousel--show-arrow`,
            `${mergedClsPrefix}-carousel--${dotPlacement}`,
            `${mergedClsPrefix}-carousel--${this.direction}`,
            `${mergedClsPrefix}-carousel--${this.effect}`,
            userWantsControl && `${mergedClsPrefix}-carousel--usercontrol`
          ],
          style: this.cssVars,
          ...slidesControlListeners,
          onMouseenter: this.handleMouseenter,
          onMouseleave: this.handleMouseleave
        }, /* @__PURE__ */ vue.h(VResizeObserver, {
          onResize: this.handleResize
        }, {
          default: () => /* @__PURE__ */ vue.h("div", {
            ref: "slidesElRef",
            class: `${mergedClsPrefix}-carousel__slides`,
            role: "listbox",
            style: this.translateStyle,
            onTransitionend: this.handleTransitionEnd
          }, userWantsControl ? slides.map((slide, i) => /* @__PURE__ */ vue.h("div", {
            style: slideStyles[i],
            key: i
          }, vue.withDirectives(
            /* @__PURE__ */ vue.h(vue.Transition, {
              ...transitionProps
            }, {
              default: () => slide
            }),
            [[vue.vShow, this.isActive(i)]]
          ))) : slides)
        }), this.showDots && dotSlotProps.total > 1 && resolveSlotWithProps(dotsSlot, dotSlotProps, () => [
          /* @__PURE__ */ vue.h(NCarouselDots, {
            key: dotType + dotPlacement,
            total: dotSlotProps.total,
            currentIndex: dotSlotProps.currentIndex,
            dotType,
            trigger: this.trigger,
            keyboard: this.keyboard
          })
        ]), showArrow && resolveSlotWithProps(arrowSlot, arrowSlotProps, () => [
          /* @__PURE__ */ vue.h(NCarouselArrow, null)
        ]));
      }
    });
    function filterCarouselItem(vnodes) {
      return vnodes.reduce((carouselItems, vnode) => {
        if (isCarouselItem(vnode)) {
          carouselItems.push(vnode);
        }
        return carouselItems;
      }, []);
    }

    var commonVariables$c = {
      sizeSmall: "14px",
      sizeMedium: "16px",
      sizeLarge: "18px",
      labelPadding: "0 8px"
    };

    const self$U = vars => {
      const {
        baseColor,
        inputColorDisabled,
        cardColor,
        modalColor,
        popoverColor,
        textColorDisabled,
        borderColor,
        primaryColor,
        textColor2,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        borderRadiusSmall,
        lineHeight
      } = vars;
      return { ...commonVariables$c,
        labelLineHeight: lineHeight,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        borderRadius: borderRadiusSmall,
        color: baseColor,
        colorChecked: primaryColor,
        colorDisabled: inputColorDisabled,
        colorDisabledChecked: inputColorDisabled,
        colorTableHeader: cardColor,
        colorTableHeaderModal: modalColor,
        colorTableHeaderPopover: popoverColor,
        checkMarkColor: baseColor,
        checkMarkColorDisabled: textColorDisabled,
        checkMarkColorDisabledChecked: textColorDisabled,
        border: `1px solid ${borderColor}`,
        borderDisabled: `1px solid ${borderColor}`,
        borderDisabledChecked: `1px solid ${borderColor}`,
        borderChecked: `1px solid ${primaryColor}`,
        borderFocus: `1px solid ${primaryColor}`,
        boxShadowFocus: `0 0 0 2px ${changeColor(primaryColor, {
      alpha: 0.3
    })}`,
        textColor: textColor2,
        textColorDisabled
      };
    };
    const checkboxLight = {
      name: "Checkbox",
      common: commonLight,
      self: self$U
    };
    var checkboxLight$1 = checkboxLight;

    const checkboxDark = {
      name: "Checkbox",
      common: commonDark,

      self(vars) {
        const {
          cardColor
        } = vars;
        const commonSelf = self$U(vars);
        commonSelf.color = "#0000";
        commonSelf.checkMarkColor = cardColor;
        return commonSelf;
      }

    };
    var checkboxDark$1 = checkboxDark;

    var rtlStyle$j = cB("checkbox", [cM("rtl", `
    direction: rtl;
  `)]);

    const checkboxRtl = {
      name: "Checkbox",
      style: rtlStyle$j
    };

    const self$T = vars => {
      const {
        borderRadius,
        boxShadow2,
        popoverColor,
        textColor2,
        textColor3,
        primaryColor,
        textColorDisabled,
        dividerColor,
        hoverColor,
        fontSizeMedium,
        heightMedium
      } = vars;
      return {
        menuBorderRadius: borderRadius,
        menuColor: popoverColor,
        menuBoxShadow: boxShadow2,
        menuDividerColor: dividerColor,
        menuHeight: "calc(var(--n-option-height) * 6.6)",
        optionArrowColor: textColor3,
        optionHeight: heightMedium,
        optionFontSize: fontSizeMedium,
        optionColorHover: hoverColor,
        optionTextColor: textColor2,
        optionTextColorActive: primaryColor,
        optionTextColorDisabled: textColorDisabled,
        optionCheckMarkColor: primaryColor,
        loadingColor: primaryColor,
        columnWidth: "180px"
      };
    };
    const cascaderLight = createTheme$1({
      name: "Cascader",
      common: commonLight,
      peers: {
        InternalSelectMenu: internalSelectMenuLight$1,
        InternalSelection: internalSelectionLight$1,
        Scrollbar: scrollbarLight$1,
        Checkbox: checkboxLight$1,
        Empty: emptyLight$1
      },
      self: self$T
    });
    var cascaderLight$1 = cascaderLight;

    const cascaderDark = {
      name: "Cascader",
      common: commonDark,
      peers: {
        InternalSelectMenu: internalSelectMenuDark$1,
        InternalSelection: internalSelectionDark$1,
        Scrollbar: scrollbarDark$1,
        Checkbox: checkboxDark$1,
        Empty: emptyLight$1
      },
      self: self$T
    };
    var cascaderDark$1 = cascaderDark;

    function getRawNodePath(tmNodes) {
      if (!tmNodes) return null;
      return tmNodes.map(tmNode => tmNode.rawNode);
    }

    function createSelectOptions(tmNodes, checkStrategyIsChild, labelField, separator) {
      const selectOptions = [];
      const path = [];

      function traverse(_tmNodes) {
        for (const tmNode of _tmNodes) {
          if (tmNode.disabled) continue;
          const {
            rawNode
          } = tmNode;
          path.push(rawNode);

          if (tmNode.isLeaf || !checkStrategyIsChild) {
            selectOptions.push({
              label: getPathLabel(tmNode, separator, labelField),
              value: tmNode.key,
              rawNode: tmNode.rawNode,
              path: Array.from(path)
            });
          }

          if (!tmNode.isLeaf && tmNode.children) {
            traverse(tmNode.children);
          }

          path.pop();
        }
      }

      traverse(tmNodes);
      return selectOptions;
    }

    function getPathLabel(node, separator, labelField) {
      const path = [];

      while (node) {
        path.push(node.rawNode[labelField]);
        node = node.parent;
      }

      return path.reverse().join(separator);
    }

    var CheckMark = /* @__PURE__ */ vue.h("svg", {
      viewBox: "0 0 64 64",
      class: "check-icon"
    }, /* @__PURE__ */ vue.h("path", {
      d: "M50.42,16.76L22.34,39.45l-8.1-11.46c-1.12-1.58-3.3-1.96-4.88-0.84c-1.58,1.12-1.95,3.3-0.84,4.88l10.26,14.51  c0.56,0.79,1.42,1.31,2.38,1.45c0.16,0.02,0.32,0.03,0.48,0.03c0.8,0,1.57-0.27,2.2-0.78l30.99-25.03c1.5-1.21,1.74-3.42,0.52-4.92  C54.13,15.78,51.93,15.55,50.42,16.76z"
    }));

    var LineMark = /* @__PURE__ */ vue.h("svg", {
      viewBox: "0 0 100 100",
      class: "line-icon"
    }, /* @__PURE__ */ vue.h("path", {
      d: "M80.2,55.5H21.4c-2.8,0-5.1-2.5-5.1-5.5l0,0c0-3,2.3-5.5,5.1-5.5h58.7c2.8,0,5.1,2.5,5.1,5.5l0,0C85.2,53.1,82.9,55.5,80.2,55.5z"
    }));

    const checkboxGroupInjectionKey = createInjectionKey("n-checkbox-group");
    const checkboxGroupProps = {
      min: Number,
      max: Number,
      size: String,
      value: Array,
      defaultValue: {
        type: Array,
        default: null
      },
      disabled: {
        type: Boolean,
        default: void 0
      },
      "onUpdate:value": [Function, Array],
      onUpdateValue: [Function, Array],
      onChange: [Function, Array]
    };
    var NCheckboxGroup = vue.defineComponent({
      name: "CheckboxGroup",
      props: checkboxGroupProps,
      setup(props) {
        {
          vue.watchEffect(() => {
            if (props.onChange !== void 0) {
              warnOnce(
                "checkbox-group",
                "`on-change` is deprecated, please use `on-update:value` instead."
              );
            }
          });
        }
        const { mergedClsPrefixRef } = useConfig(props);
        const formItem = useFormItem(props);
        const { mergedSizeRef, mergedDisabledRef } = formItem;
        const uncontrolledValueRef = vue.ref(props.defaultValue);
        const controlledValueRef = vue.computed(() => props.value);
        const mergedValueRef = useMergedState(
          controlledValueRef,
          uncontrolledValueRef
        );
        const checkedCount = vue.computed(() => {
          return mergedValueRef.value?.length || 0;
        });
        const valueSetRef = vue.computed(() => {
          if (Array.isArray(mergedValueRef.value)) {
            return new Set(mergedValueRef.value);
          }
          return /* @__PURE__ */ new Set();
        });
        function toggleCheckbox(checked, checkboxValue) {
          const { nTriggerFormInput, nTriggerFormChange } = formItem;
          const {
            onChange,
            "onUpdate:value": _onUpdateValue,
            onUpdateValue
          } = props;
          if (Array.isArray(mergedValueRef.value)) {
            const groupValue = Array.from(mergedValueRef.value);
            const index = groupValue.findIndex((value) => value === checkboxValue);
            if (checked) {
              if (!~index) {
                groupValue.push(checkboxValue);
                if (onUpdateValue) {
                  call(onUpdateValue, groupValue, {
                    actionType: "check",
                    value: checkboxValue
                  });
                }
                if (_onUpdateValue) {
                  call(_onUpdateValue, groupValue, {
                    actionType: "check",
                    value: checkboxValue
                  });
                }
                nTriggerFormInput();
                nTriggerFormChange();
                uncontrolledValueRef.value = groupValue;
                if (onChange)
                  call(onChange, groupValue);
              }
            } else {
              if (~index) {
                groupValue.splice(index, 1);
                if (onUpdateValue) {
                  call(onUpdateValue, groupValue, {
                    actionType: "uncheck",
                    value: checkboxValue
                  });
                }
                if (_onUpdateValue) {
                  call(_onUpdateValue, groupValue, {
                    actionType: "uncheck",
                    value: checkboxValue
                  });
                }
                if (onChange)
                  call(onChange, groupValue);
                uncontrolledValueRef.value = groupValue;
                nTriggerFormInput();
                nTriggerFormChange();
              }
            }
          } else {
            if (checked) {
              if (onUpdateValue) {
                call(onUpdateValue, [checkboxValue], {
                  actionType: "check",
                  value: checkboxValue
                });
              }
              if (_onUpdateValue) {
                call(_onUpdateValue, [checkboxValue], {
                  actionType: "check",
                  value: checkboxValue
                });
              }
              if (onChange)
                call(onChange, [checkboxValue]);
              uncontrolledValueRef.value = [checkboxValue];
              nTriggerFormInput();
              nTriggerFormChange();
            } else {
              if (onUpdateValue) {
                call(onUpdateValue, [], {
                  actionType: "uncheck",
                  value: checkboxValue
                });
              }
              if (_onUpdateValue) {
                call(_onUpdateValue, [], {
                  actionType: "uncheck",
                  value: checkboxValue
                });
              }
              if (onChange)
                call(onChange, []);
              uncontrolledValueRef.value = [];
              nTriggerFormInput();
              nTriggerFormChange();
            }
          }
        }
        vue.provide(checkboxGroupInjectionKey, {
          checkedCountRef: checkedCount,
          maxRef: vue.toRef(props, "max"),
          minRef: vue.toRef(props, "min"),
          valueSetRef,
          disabledRef: mergedDisabledRef,
          mergedSizeRef,
          toggleCheckbox
        });
        return {
          mergedClsPrefix: mergedClsPrefixRef
        };
      },
      render() {
        return /* @__PURE__ */ vue.h("div", {
          class: `${this.mergedClsPrefix}-checkbox-group`,
          role: "group"
        }, this.$slots);
      }
    });

    var style$14 = c$1([cB("checkbox", `
    line-height: var(--n-label-line-height);
    font-size: var(--n-font-size);
    outline: none;
    cursor: pointer;
    display: inline-flex;
    flex-wrap: nowrap;
    align-items: flex-start;
    word-break: break-word;
    --n-merged-color-table: var(--n-color-table);
  `, [c$1("&:hover", [cB("checkbox-box", [cE("border", {
      border: "var(--n-border-checked)"
    })])]), c$1("&:focus:not(:active)", [cB("checkbox-box", [cE("border", `
          border: var(--n-border-focus);
          box-shadow: var(--n-box-shadow-focus);
        `)])]), cM("inside-table", [cB("checkbox-box", `
        background-color: var(--n-merged-color-table);
      `)]), cM("checked", [cB("checkbox-box", `
        background-color: var(--n-color-checked);
      `, [cB("checkbox-icon", [c$1(".check-icon", `
            opacity: 1;
            transform: scale(1);
          `)])])]), cM("indeterminate", [cB("checkbox-box", [cB("checkbox-icon", [c$1(".check-icon", `
            opacity: 0;
            transform: scale(.5);
          `), c$1(".line-icon", `
            opacity: 1;
            transform: scale(1);
          `)])])]), cM("checked, indeterminate", [c$1("&:focus:not(:active)", [cB("checkbox-box", [cE("border", `
            border: var(--n-border-checked);
            box-shadow: var(--n-box-shadow-focus);
          `)])]), cB("checkbox-box", `
        background-color: var(--n-color-checked);
        border-left: 0;
        border-top: 0;
      `, [cE("border", {
      border: "var(--n-border-checked)"
    })])]), cM("disabled", {
      cursor: "not-allowed"
    }, [cM("checked", [cB("checkbox-box", `
          background-color: var(--n-color-disabled-checked);
        `, [cE("border", {
      border: "var(--n-border-disabled-checked)"
    }), cB("checkbox-icon", [c$1(".check-icon, .line-icon", {
      fill: "var(--n-check-mark-color-disabled-checked)"
    })])])]), cB("checkbox-box", `
        background-color: var(--n-color-disabled);
      `, [cE("border", {
      border: "var(--n-border-disabled)"
    }), cB("checkbox-icon", [c$1(".check-icon, .line-icon", {
      fill: "var(--n-check-mark-color-disabled)"
    })])]), cE("label", {
      color: "var(--n-text-color-disabled)"
    })]), cB("checkbox-box-wrapper", `
      position: relative;
      width: var(--n-size);
      flex-shrink: 0;
      flex-grow: 0;
      user-select: none;
      -webkit-user-select: none;
    `), cB("checkbox-box", `
      position: absolute;
      left: 0;
      top: 50%;
      transform: translateY(-50%);
      height: var(--n-size);
      width: var(--n-size);
      display: inline-block;
      box-sizing: border-box;
      border-radius: var(--n-border-radius);
      background-color: var(--n-color);
      transition: background-color 0.3s var(--n-bezier);
    `, [cE("border", `
        transition:
          border-color .3s var(--n-bezier),
          box-shadow .3s var(--n-bezier);
        border-radius: inherit;
        position: absolute;
        left: 0;
        right: 0;
        top: 0;
        bottom: 0;
        border: var(--n-border);
      `), cB("checkbox-icon", `
        display: flex;
        align-items: center;
        justify-content: center;
        position: absolute;
        left: 1px;
        right: 1px;
        top: 1px;
        bottom: 1px;
      `, [c$1(".check-icon, .line-icon", `
          width: 100%;
          fill: var(--n-check-mark-color);
          opacity: 0;
          transform: scale(0.5);
          transform-origin: center;
          transition:
            fill 0.3s var(--n-bezier),
            transform 0.3s var(--n-bezier),
            opacity 0.3s var(--n-bezier),
            border-color 0.3s var(--n-bezier);
        `), iconSwitchTransition({
      left: "1px",
      top: "1px"
    })])]), cE("label", `
      color: var(--n-text-color);
      transition: color .3s var(--n-bezier);
      user-select: none;
      -webkit-user-select: none;
      padding: var(--n-label-padding);
    `, [c$1("&:empty", {
      display: "none"
    })])]), insideModal(cB("checkbox", `
      --n-merged-color-table: var(--n-color-table-modal);
    `)), insidePopover(cB("checkbox", `
      --n-merged-color-table: var(--n-color-table-popover);
    `))]);

    const checkboxProps = {
      ...useTheme.props,
      size: String,
      checked: {
        type: [Boolean, String, Number],
        default: void 0
      },
      defaultChecked: {
        type: [Boolean, String, Number],
        default: false
      },
      value: [String, Number],
      disabled: {
        type: Boolean,
        default: void 0
      },
      indeterminate: Boolean,
      label: String,
      focusable: {
        type: Boolean,
        default: true
      },
      checkedValue: {
        type: [Boolean, String, Number],
        default: true
      },
      uncheckedValue: {
        type: [Boolean, String, Number],
        default: false
      },
      "onUpdate:checked": [Function, Array],
      onUpdateChecked: [Function, Array],
      privateInsideTable: Boolean,
      onChange: [Function, Array]
    };
    var NCheckbox = vue.defineComponent({
      name: "Checkbox",
      props: checkboxProps,
      setup(props) {
        {
          vue.watchEffect(() => {
            if (props.onChange) {
              warnOnce(
                "checkbox",
                "`on-change` is deprecated, please use `on-update:checked` instead."
              );
            }
          });
        }
        const selfRef = vue.ref(null);
        const { mergedClsPrefixRef, inlineThemeDisabled, mergedRtlRef } = useConfig(props);
        const formItem = useFormItem(props, {
          mergedSize(NFormItem) {
            const { size } = props;
            if (size !== void 0)
              return size;
            if (NCheckboxGroup) {
              const { value: mergedSize } = NCheckboxGroup.mergedSizeRef;
              if (mergedSize !== void 0) {
                return mergedSize;
              }
            }
            if (NFormItem) {
              const { mergedSize } = NFormItem;
              if (mergedSize !== void 0)
                return mergedSize.value;
            }
            return "medium";
          },
          mergedDisabled(NFormItem) {
            const { disabled } = props;
            if (disabled !== void 0)
              return disabled;
            if (NCheckboxGroup) {
              if (NCheckboxGroup.disabledRef.value)
                return true;
              const {
                maxRef: { value: max },
                checkedCountRef
              } = NCheckboxGroup;
              if (max !== void 0 && checkedCountRef.value >= max && !renderedCheckedRef.value) {
                return true;
              }
              const {
                minRef: { value: min }
              } = NCheckboxGroup;
              if (min !== void 0 && checkedCountRef.value <= min && renderedCheckedRef.value) {
                return true;
              }
            }
            if (NFormItem) {
              return NFormItem.disabled.value;
            }
            return false;
          }
        });
        const { mergedDisabledRef, mergedSizeRef } = formItem;
        const NCheckboxGroup = vue.inject(checkboxGroupInjectionKey, null);
        const uncontrolledCheckedRef = vue.ref(props.defaultChecked);
        const controlledCheckedRef = vue.toRef(props, "checked");
        const mergedCheckedRef = useMergedState(
          controlledCheckedRef,
          uncontrolledCheckedRef
        );
        const renderedCheckedRef = useMemo(() => {
          if (NCheckboxGroup) {
            const groupValueSet = NCheckboxGroup.valueSetRef.value;
            if (groupValueSet && props.value !== void 0) {
              return groupValueSet.has(props.value);
            }
            return false;
          } else {
            return mergedCheckedRef.value === props.checkedValue;
          }
        });
        const themeRef = useTheme(
          "Checkbox",
          "-checkbox",
          style$14,
          checkboxLight$1,
          props,
          mergedClsPrefixRef
        );
        function toggle(e) {
          if (NCheckboxGroup && props.value !== void 0) {
            NCheckboxGroup.toggleCheckbox(!renderedCheckedRef.value, props.value);
          } else {
            const {
              onChange,
              "onUpdate:checked": _onUpdateCheck,
              onUpdateChecked
            } = props;
            const { nTriggerFormInput, nTriggerFormChange } = formItem;
            const nextChecked = renderedCheckedRef.value ? props.uncheckedValue : props.checkedValue;
            if (_onUpdateCheck) {
              call(_onUpdateCheck, nextChecked, e);
            }
            if (onUpdateChecked) {
              call(onUpdateChecked, nextChecked, e);
            }
            if (onChange)
              call(onChange, nextChecked, e);
            nTriggerFormInput();
            nTriggerFormChange();
            uncontrolledCheckedRef.value = nextChecked;
          }
        }
        function handleClick(e) {
          if (!mergedDisabledRef.value) {
            toggle(e);
          }
        }
        function handleKeyUp(e) {
          if (mergedDisabledRef.value)
            return;
          switch (e.key) {
            case " ":
            case "Enter":
              toggle(e);
          }
        }
        function handleKeyDown(e) {
          switch (e.key) {
            case " ":
              e.preventDefault();
          }
        }
        const exposedMethods = {
          focus: () => {
            selfRef.value?.focus();
          },
          blur: () => {
            selfRef.value?.blur();
          }
        };
        const rtlEnabledRef = useRtl("Checkbox", mergedRtlRef, mergedClsPrefixRef);
        const cssVarsRef = vue.computed(() => {
          const { value: mergedSize } = mergedSizeRef;
          const {
            common: { cubicBezierEaseInOut },
            self: {
              borderRadius,
              color,
              colorChecked,
              colorDisabled,
              colorTableHeader,
              colorTableHeaderModal,
              colorTableHeaderPopover,
              checkMarkColor,
              checkMarkColorDisabled,
              border,
              borderFocus,
              borderDisabled,
              borderChecked,
              boxShadowFocus,
              textColor,
              textColorDisabled,
              checkMarkColorDisabledChecked,
              colorDisabledChecked,
              borderDisabledChecked,
              labelPadding,
              labelLineHeight,
              [createKey("fontSize", mergedSize)]: fontSize,
              [createKey("size", mergedSize)]: size
            }
          } = themeRef.value;
          return {
            "--n-label-line-height": labelLineHeight,
            "--n-size": size,
            "--n-bezier": cubicBezierEaseInOut,
            "--n-border-radius": borderRadius,
            "--n-border": border,
            "--n-border-checked": borderChecked,
            "--n-border-focus": borderFocus,
            "--n-border-disabled": borderDisabled,
            "--n-border-disabled-checked": borderDisabledChecked,
            "--n-box-shadow-focus": boxShadowFocus,
            "--n-color": color,
            "--n-color-checked": colorChecked,
            "--n-color-table": colorTableHeader,
            "--n-color-table-modal": colorTableHeaderModal,
            "--n-color-table-popover": colorTableHeaderPopover,
            "--n-color-disabled": colorDisabled,
            "--n-color-disabled-checked": colorDisabledChecked,
            "--n-text-color": textColor,
            "--n-text-color-disabled": textColorDisabled,
            "--n-check-mark-color": checkMarkColor,
            "--n-check-mark-color-disabled": checkMarkColorDisabled,
            "--n-check-mark-color-disabled-checked": checkMarkColorDisabledChecked,
            "--n-font-size": fontSize,
            "--n-label-padding": labelPadding
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass(
          "checkbox",
          vue.computed(() => mergedSizeRef.value[0]),
          cssVarsRef,
          props
        ) : void 0;
        return Object.assign(formItem, exposedMethods, {
          rtlEnabled: rtlEnabledRef,
          selfRef,
          mergedClsPrefix: mergedClsPrefixRef,
          mergedDisabled: mergedDisabledRef,
          renderedChecked: renderedCheckedRef,
          mergedTheme: themeRef,
          labelId: createId(),
          handleClick,
          handleKeyUp,
          handleKeyDown,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender
        });
      },
      render() {
        const {
          $slots,
          renderedChecked,
          mergedDisabled,
          indeterminate,
          privateInsideTable,
          cssVars,
          labelId,
          label,
          mergedClsPrefix,
          focusable,
          handleKeyUp,
          handleKeyDown,
          handleClick
        } = this;
        this.onRender?.();
        return /* @__PURE__ */ vue.h("div", {
          ref: "selfRef",
          class: [
            `${mergedClsPrefix}-checkbox`,
            this.themeClass,
            this.rtlEnabled && `${mergedClsPrefix}-checkbox--rtl`,
            renderedChecked && `${mergedClsPrefix}-checkbox--checked`,
            mergedDisabled && `${mergedClsPrefix}-checkbox--disabled`,
            indeterminate && `${mergedClsPrefix}-checkbox--indeterminate`,
            privateInsideTable && `${mergedClsPrefix}-checkbox--inside-table`
          ],
          tabindex: mergedDisabled || !focusable ? void 0 : 0,
          role: "checkbox",
          "aria-checked": indeterminate ? "mixed" : renderedChecked,
          "aria-labelledby": labelId,
          style: cssVars,
          onKeyup: handleKeyUp,
          onKeydown: handleKeyDown,
          onClick: handleClick,
          onMousedown: () => {
            on(
              "selectstart",
              window,
              (e) => {
                e.preventDefault();
              },
              {
                once: true
              }
            );
          }
        }, /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-checkbox-box-wrapper`
        }, "\xA0", /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-checkbox-box`
        }, /* @__PURE__ */ vue.h(NIconSwitchTransition, null, {
          default: () => this.indeterminate ? /* @__PURE__ */ vue.h("div", {
            key: "indeterminate",
            class: `${mergedClsPrefix}-checkbox-icon`
          }, LineMark) : /* @__PURE__ */ vue.h("div", {
            key: "check",
            class: `${mergedClsPrefix}-checkbox-icon`
          }, CheckMark)
        }), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-checkbox-box__border`
        }))), label !== null || $slots.default ? /* @__PURE__ */ vue.h("span", {
          class: `${mergedClsPrefix}-checkbox__label`,
          id: labelId
        }, $slots.default ? $slots.default() : label) : null);
      }
    });

    const cascaderInjectionKey = createInjectionKey("n-cascader");

    var NCascaderOption = vue.defineComponent({
      name: "NCascaderOption",
      props: {
        tmNode: {
          type: Object,
          required: true
        }
      },
      setup(props) {
        const {
          expandTriggerRef,
          remoteRef,
          multipleRef,
          mergedValueRef,
          checkedKeysRef,
          indeterminateKeysRef,
          hoverKeyPathRef,
          keyboardKeyRef,
          loadingKeySetRef,
          cascadeRef,
          mergedCheckStrategyRef,
          onLoadRef,
          mergedClsPrefixRef,
          mergedThemeRef,
          labelFieldRef,
          updateHoverKey,
          updateKeyboardKey,
          addLoadingKey,
          deleteLoadingKey,
          closeMenu,
          doCheck,
          doUncheck,
          renderLabelRef
        } = vue.inject(cascaderInjectionKey);
        const valueRef = vue.computed(() => props.tmNode.key);
        const useHoverTriggerRef = vue.computed(() => {
          const { value: expandTrigger } = expandTriggerRef;
          const { value: remote } = remoteRef;
          return !remote && expandTrigger === "hover";
        });
        const mergedHandleMouseEnterRef = vue.computed(() => {
          if (useHoverTriggerRef.value) {
            return handleMouseEnter;
          }
          return void 0;
        });
        const mergedHandleMouseMoveRef = vue.computed(() => {
          if (useHoverTriggerRef.value) {
            return handleMouseMove;
          }
          return void 0;
        });
        const checkedRef = useMemo(() => {
          const { value: multiple } = multipleRef;
          if (!multiple)
            return mergedValueRef.value === valueRef.value;
          return checkedKeysRef.value.includes(valueRef.value);
        });
        const indeterminateRef = useMemo(() => {
          if (!multipleRef.value)
            return false;
          return indeterminateKeysRef.value.includes(valueRef.value);
        });
        const hoverPendingRef = useMemo(() => {
          return hoverKeyPathRef.value.includes(valueRef.value);
        });
        const keyboardPendingRef = useMemo(() => {
          const { value: keyboardKey } = keyboardKeyRef;
          if (keyboardKey === null)
            return false;
          return keyboardKey === valueRef.value;
        });
        const isLoadingRef = useMemo(() => {
          if (remoteRef.value) {
            return loadingKeySetRef.value.has(valueRef.value);
          }
          return false;
        });
        const showCheckboxRef = vue.computed(() => {
          if (multipleRef.value && cascadeRef.value)
            return true;
          if (mergedCheckStrategyRef.value !== "child")
            return true;
        });
        const isLeafRef = vue.computed(() => props.tmNode.isLeaf);
        const disabledRef = vue.computed(() => props.tmNode.disabled);
        const labelRef = vue.computed(
          () => props.tmNode.rawNode[labelFieldRef.value]
        );
        const isShallowLoadedRef = vue.computed(() => {
          return props.tmNode.shallowLoaded;
        });
        function handleClick(e) {
          if (disabledRef.value)
            return;
          const { value: remote } = remoteRef;
          const { value: loadingKeySet } = loadingKeySetRef;
          const { value: onLoad } = onLoadRef;
          const { value } = valueRef;
          const { value: isLeaf } = isLeafRef;
          const { value: isShallowLoaded } = isShallowLoadedRef;
          if (!happensIn(e, "checkbox")) {
            if (remote && !isShallowLoaded && !loadingKeySet.has(value) && onLoad) {
              addLoadingKey(value);
              onLoad(props.tmNode.rawNode).then(() => {
                deleteLoadingKey(value);
              }).catch(() => {
                deleteLoadingKey(value);
              });
            }
            updateHoverKey(value);
            updateKeyboardKey(value);
          }
          if (isLeaf) {
            toggleCheckbox();
          }
        }
        function handleMouseEnter() {
          if (!useHoverTriggerRef.value || disabledRef.value)
            return;
          const { value } = valueRef;
          updateHoverKey(value);
          updateKeyboardKey(value);
        }
        function handleMouseMove() {
          if (!useHoverTriggerRef.value)
            return;
          handleMouseEnter();
        }
        function handleCheckboxUpdateValue() {
          const { value: isLeaf } = isLeafRef;
          if (!isLeaf)
            toggleCheckbox();
        }
        function toggleCheckbox() {
          const { value: multiple } = multipleRef;
          const { value } = valueRef;
          if (multiple) {
            if (indeterminateRef.value || checkedRef.value) {
              doUncheck(value);
            } else {
              doCheck(value);
            }
          } else {
            doCheck(value);
            closeMenu(true);
          }
        }
        return {
          checkStrategy: mergedCheckStrategyRef,
          multiple: multipleRef,
          cascade: cascadeRef,
          checked: checkedRef,
          indeterminate: indeterminateRef,
          hoverPending: hoverPendingRef,
          keyboardPending: keyboardPendingRef,
          isLoading: isLoadingRef,
          showCheckbox: showCheckboxRef,
          isLeaf: isLeafRef,
          disabled: disabledRef,
          label: labelRef,
          mergedClsPrefix: mergedClsPrefixRef,
          mergedTheme: mergedThemeRef,
          handleClick,
          handleCheckboxUpdateValue,
          mergedHandleMouseEnter: mergedHandleMouseEnterRef,
          mergedHandleMouseMove: mergedHandleMouseMoveRef,
          renderLabel: renderLabelRef
        };
      },
      render() {
        const { mergedClsPrefix, renderLabel } = this;
        return /* @__PURE__ */ vue.h("div", {
          class: [
            `${mergedClsPrefix}-cascader-option`,
            {
              [`${mergedClsPrefix}-cascader-option--pending`]: this.keyboardPending || this.hoverPending,
              [`${mergedClsPrefix}-cascader-option--disabled`]: this.disabled,
              [`${mergedClsPrefix}-cascader-option--show-prefix`]: this.showCheckbox
            }
          ],
          onMouseenter: this.mergedHandleMouseEnter,
          onMousemove: this.mergedHandleMouseMove,
          onClick: this.handleClick
        }, this.showCheckbox ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-cascader-option__prefix`
        }, /* @__PURE__ */ vue.h(NCheckbox, {
          focusable: false,
          "data-checkbox": true,
          disabled: this.disabled,
          checked: this.checked,
          indeterminate: this.indeterminate,
          theme: this.mergedTheme.peers.Checkbox,
          themeOverrides: this.mergedTheme.peerOverrides.Checkbox,
          onUpdateChecked: this.handleCheckboxUpdateValue
        })) : null, /* @__PURE__ */ vue.h("span", {
          class: `${mergedClsPrefix}-cascader-option__label`
        }, renderLabel ? renderLabel(this.tmNode.rawNode, this.checked) : this.label), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-cascader-option__suffix`
        }, /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-cascader-option-icon-placeholder`
        }, !this.isLeaf ? /* @__PURE__ */ vue.h(NBaseLoading, {
          clsPrefix: mergedClsPrefix,
          scale: 0.85,
          strokeWidth: 24,
          show: this.isLoading,
          class: `${mergedClsPrefix}-cascader-option-icon`
        }, {
          default: () => /* @__PURE__ */ vue.h(NBaseIcon, {
            clsPrefix: mergedClsPrefix,
            key: "arrow",
            class: `${mergedClsPrefix}-cascader-option-icon ${mergedClsPrefix}-cascader-option-icon--arrow`
          }, {
            default: () => /* @__PURE__ */ vue.h(ChevronRightIcon, null)
          })
        }) : this.checkStrategy === "child" && !(this.multiple && this.cascade) ? /* @__PURE__ */ vue.h(vue.Transition, {
          name: "fade-in-scale-up-transition"
        }, {
          default: () => this.checked ? /* @__PURE__ */ vue.h(NBaseIcon, {
            clsPrefix: mergedClsPrefix,
            class: `${mergedClsPrefix}-cascader-option-icon ${mergedClsPrefix}-cascader-option-icon--checkmark`
          }, { default: () => /* @__PURE__ */ vue.h(FinishedIcon, null) }) : null
        }) : null)));
      }
    });

    var NCascaderSubmenu = vue.defineComponent({
      name: "CascaderSubmenu",
      props: {
        depth: {
          type: Number,
          required: true
        },
        tmNodes: {
          type: Array,
          required: true
        }
      },
      setup() {
        const {
          virtualScrollRef,
          mergedClsPrefixRef,
          mergedThemeRef,
          optionHeightRef
        } = vue.inject(cascaderInjectionKey);
        const scrollbarInstRef = vue.ref(null);
        const vlInstRef = vue.ref(null);
        const inst = {
          scroll(index, elSize) {
            if (virtualScrollRef.value) {
              vlInstRef.value?.scrollTo({
                index
              });
            } else {
              scrollbarInstRef.value?.scrollTo({
                index,
                elSize
              });
            }
          }
        };
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          mergedTheme: mergedThemeRef,
          scrollbarInstRef,
          vlInstRef,
          virtualScroll: virtualScrollRef,
          itemSize: vue.computed(() => depx(optionHeightRef.value)),
          handleVlScroll: () => {
            scrollbarInstRef.value?.sync();
          },
          getVlContainer: () => {
            return vlInstRef.value?.listElRef;
          },
          getVlContent: () => {
            return vlInstRef.value?.itemsElRef;
          },
          ...inst
        };
      },
      render() {
        const { mergedClsPrefix, mergedTheme, virtualScroll } = this;
        return /* @__PURE__ */ vue.h("div", {
          class: [
            virtualScroll && `${mergedClsPrefix}-cascader-submenu--virtual`,
            `${mergedClsPrefix}-cascader-submenu`
          ]
        }, /* @__PURE__ */ vue.h(NScrollbar, {
          ref: "scrollbarInstRef",
          theme: mergedTheme.peers.Scrollbar,
          themeOverrides: mergedTheme.peerOverrides.Scrollbar,
          container: virtualScroll ? this.getVlContainer : void 0,
          content: virtualScroll ? this.getVlContent : void 0
        }, {
          default: () => virtualScroll ? /* @__PURE__ */ vue.h(VVirtualList, {
            items: this.tmNodes,
            itemSize: this.itemSize,
            onScroll: this.handleVlScroll,
            showScrollbar: false,
            ref: "vlInstRef"
          }, {
            default: ({ item: tmNode }) => /* @__PURE__ */ vue.h(NCascaderOption, {
              key: tmNode.key,
              tmNode
            })
          }) : this.tmNodes.map((tmNode) => /* @__PURE__ */ vue.h(NCascaderOption, {
            key: tmNode.key,
            tmNode
          }))
        }));
      }
    });

    var CascaderMenu = vue.defineComponent({
      name: "NCascaderMenu",
      props: {
        value: [String, Number, Array],
        placement: {
          type: String,
          default: "bottom-start"
        },
        show: Boolean,
        menuModel: {
          type: Array,
          required: true
        },
        loading: Boolean,
        onFocus: {
          type: Function,
          required: true
        },
        onBlur: {
          type: Function,
          required: true
        },
        onKeydown: {
          type: Function,
          required: true
        },
        onMousedown: {
          type: Function,
          required: true
        },
        onTabout: {
          type: Function,
          required: true
        }
      },
      setup(props) {
        const {
          localeRef,
          isMountedRef,
          mergedClsPrefixRef,
          syncCascaderMenuPosition,
          handleCascaderMenuClickOutside,
          mergedThemeRef
        } = vue.inject(cascaderInjectionKey);
        const submenuInstRefs = [];
        const maskInstRef = vue.ref(null);
        const selfElRef = vue.ref(null);
        function handleResize() {
          syncCascaderMenuPosition();
        }
        useOnResize(selfElRef, handleResize);
        function showErrorMessage(label) {
          const {
            value: { loadingRequiredMessage }
          } = localeRef;
          maskInstRef.value?.showOnce(loadingRequiredMessage(label));
        }
        function handleClickOutside(e) {
          handleCascaderMenuClickOutside(e);
        }
        function handleFocusin(e) {
          const { value: selfEl } = selfElRef;
          if (!selfEl)
            return;
          if (!selfEl.contains(e.relatedTarget)) {
            props.onFocus(e);
          }
        }
        function handleFocusout(e) {
          const { value: selfEl } = selfElRef;
          if (!selfEl)
            return;
          if (!selfEl.contains(e.relatedTarget)) {
            props.onBlur(e);
          }
        }
        const exposedRef = {
          scroll(depth, index, elSize) {
            const submenuInst = submenuInstRefs[depth];
            if (submenuInst) {
              submenuInst.scroll(index, elSize);
            }
          },
          showErrorMessage
        };
        return {
          isMounted: isMountedRef,
          mergedClsPrefix: mergedClsPrefixRef,
          selfElRef,
          submenuInstRefs,
          maskInstRef,
          mergedTheme: mergedThemeRef,
          handleFocusin,
          handleFocusout,
          handleClickOutside,
          ...exposedRef
        };
      },
      render() {
        const { submenuInstRefs, mergedClsPrefix, mergedTheme } = this;
        return /* @__PURE__ */ vue.h(vue.Transition, {
          name: "fade-in-scale-up-transition",
          appear: this.isMounted
        }, {
          default: () => {
            if (!this.show)
              return null;
            return vue.withDirectives(
              /* @__PURE__ */ vue.h("div", {
                tabindex: "0",
                ref: "selfElRef",
                class: `${mergedClsPrefix}-cascader-menu`,
                onMousedown: this.onMousedown,
                onFocusin: this.handleFocusin,
                onFocusout: this.handleFocusout,
                onKeydown: this.onKeydown
              }, this.menuModel[0].length ? /* @__PURE__ */ vue.h("div", {
                class: `${mergedClsPrefix}-cascader-submenu-wrapper`
              }, this.menuModel.map((submenuOptions, index) => /* @__PURE__ */ vue.h(NCascaderSubmenu, {
                ref: (instance) => {
                  if (instance) {
                    submenuInstRefs[index] = instance;
                  }
                },
                key: index,
                tmNodes: submenuOptions,
                depth: index + 1
              })), /* @__PURE__ */ vue.h(NBaseMenuMask, {
                clsPrefix: mergedClsPrefix,
                ref: "maskInstRef"
              })) : /* @__PURE__ */ vue.h("div", {
                class: `${mergedClsPrefix}-cascader-menu__empty`
              }, resolveSlot(this.$slots.empty, () => [
                /* @__PURE__ */ vue.h(NEmpty, {
                  theme: mergedTheme.peers.Empty,
                  themeOverrides: mergedTheme.peerOverrides.Empty
                })
              ])), resolveWrappedSlot(
                this.$slots.action,
                (children) => children && /* @__PURE__ */ vue.h("div", {
                  class: `${mergedClsPrefix}-cascader-menu-action`,
                  "data-action": true
                }, children)
              ), /* @__PURE__ */ vue.h(FocusDetector, {
                onFocus: this.onTabout
              })),
              [
                [
                  clickoutside$1,
                  this.handleClickOutside,
                  void 0,
                  { capture: true }
                ]
              ]
            );
          }
        });
      }
    });

    var CascaderSelectMenu = vue.defineComponent({
      name: "NCascaderSelectMenu",
      props: {
        value: {
          type: [String, Number, Array],
          default: null
        },
        show: Boolean,
        pattern: {
          type: String,
          default: ""
        },
        multiple: Boolean,
        tmNodes: {
          type: Array,
          default: () => []
        },
        filter: Function,
        labelField: {
          type: String,
          required: true
        },
        separator: {
          type: String,
          required: true
        }
      },
      setup(props) {
        const {
          isMountedRef,
          mergedValueRef,
          mergedClsPrefixRef,
          mergedThemeRef,
          mergedCheckStrategyRef,
          syncSelectMenuPosition,
          closeMenu,
          handleSelectMenuClickOutside,
          doUncheck: cascaderDoUncheck,
          doCheck: cascaderDoCheck,
          clearPattern
        } = vue.inject(cascaderInjectionKey);
        const menuInstRef = vue.ref(null);
        const selectOptionsRef = vue.computed(() => {
          return createSelectOptions(
            props.tmNodes,
            mergedCheckStrategyRef.value === "child",
            props.labelField,
            props.separator
          );
        });
        const mergedFilterRef = vue.computed(() => {
          const { filter } = props;
          if (filter)
            return filter;
          const { labelField } = props;
          return (pattern, _, path) => path.some(
            (option) => option[labelField] && ~option[labelField].indexOf(pattern)
          );
        });
        const filteredSelectOptionsRef = vue.computed(() => {
          const { pattern } = props;
          const { value: mergedFilter } = mergedFilterRef;
          return (pattern ? selectOptionsRef.value.filter((option) => {
            return mergedFilter(pattern, option.rawNode, option.path);
          }) : selectOptionsRef.value).map((option) => ({
            value: option.value,
            label: option.label
          }));
        });
        const selectTreeMateRef = vue.computed(() => {
          return createTreeMate(filteredSelectOptionsRef.value, createTmOptions("value", "children"));
        });
        function handleResize() {
          syncSelectMenuPosition();
        }
        function handleToggle(tmNode) {
          doCheck(tmNode);
        }
        function doCheck(tmNode) {
          if (props.multiple) {
            const { value: mergedValue } = mergedValueRef;
            if (Array.isArray(mergedValue)) {
              if (!mergedValue.includes(tmNode.key)) {
                cascaderDoCheck(tmNode.key);
              } else {
                cascaderDoUncheck(tmNode.key);
              }
            } else if (mergedValue === null) {
              cascaderDoCheck(tmNode.key);
            }
            clearPattern();
          } else {
            cascaderDoCheck(tmNode.key);
            closeMenu(true);
          }
        }
        function prev() {
          menuInstRef.value?.prev();
        }
        function next() {
          menuInstRef.value?.next();
        }
        function enter() {
          if (menuInstRef) {
            const pendingOptionTmNode = menuInstRef.value?.getPendingTmNode();
            if (pendingOptionTmNode) {
              doCheck(pendingOptionTmNode);
            }
            return true;
          }
          return false;
        }
        function handleClickOutside(e) {
          handleSelectMenuClickOutside(e);
        }
        const exposedRef = {
          prev,
          next,
          enter
        };
        return {
          isMounted: isMountedRef,
          mergedTheme: mergedThemeRef,
          mergedClsPrefix: mergedClsPrefixRef,
          menuInstRef,
          selectTreeMate: selectTreeMateRef,
          handleResize,
          handleToggle,
          handleClickOutside,
          ...exposedRef
        };
      },
      render() {
        const { mergedClsPrefix, isMounted, mergedTheme } = this;
        return /* @__PURE__ */ vue.h(vue.Transition, {
          name: "fade-in-scale-up-transition",
          appear: isMounted
        }, {
          default: () => this.show ? vue.withDirectives(
            /* @__PURE__ */ vue.h(NInternalSelectMenu, {
              ref: "menuInstRef",
              onResize: this.handleResize,
              clsPrefix: mergedClsPrefix,
              class: `${mergedClsPrefix}-cascader-menu`,
              autoPending: true,
              themeOverrides: mergedTheme.peerOverrides.InternalSelectMenu,
              theme: mergedTheme.peers.InternalSelectMenu,
              treeMate: this.selectTreeMate,
              multiple: this.multiple,
              value: this.value,
              onToggle: this.handleToggle
            }),
            [
              [
                clickoutside$1,
                this.handleClickOutside,
                void 0,
                { capture: true }
              ]
            ]
          ) : null
        });
      }
    });

    var style$13 = c$1([cB("cascader-menu", `
    outline: none;
    position: relative;
    margin: 4px 0;
    display: flex;
    flex-flow: column nowrap;
    border-radius: var(--n-menu-border-radius);
    overflow: hidden;
    box-shadow: var(--n-menu-box-shadow);
    color: var(--n-option-text-color);
    background-color: var(--n-menu-color);
  `, [fadeInScaleUpTransition({
      transformOrigin: "inherit",
      duration: "0.2s"
    }), cE("empty", `
      display: flex;
      padding: 12px 32px;
      flex: 1;
      justify-content: center;
    `), cB("scrollbar", {
      width: "100%"
    }), cB("base-menu-mask", {
      backgroundColor: "var(--n-menu-mask-color)"
    }), cB("base-loading", {
      color: "var(--n-loading-color)"
    }), cB("cascader-submenu-wrapper", `
      position: relative;
      display: flex;
      flex-wrap: nowrap;
    `), cB("cascader-submenu", `
      height: var(--n-menu-height);
      min-width: var(--n-column-width);
      position: relative;
    `, [cM("virtual", `
        width: var(--n-column-width);
      `), cB("scrollbar-content", {
      position: "relative"
    }), c$1("&:first-child", `
        border-top-left-radius: var(--n-menu-border-radius);
        border-bottom-left-radius: var(--n-menu-border-radius);
      `), c$1("&:last-child", `
        border-top-right-radius: var(--n-menu-border-radius);
        border-bottom-right-radius: var(--n-menu-border-radius);
      `), c$1("&:not(:first-child)", `
        border-left: 1px solid var(--n-menu-divider-color);
      `)]), cB("cascader-menu-action", `
      box-sizing: border-box;
      padding: 8px;
      border-top: 1px solid var(--n-menu-divider-color);
    `), cB("cascader-option", `
      height: var(--n-option-height);
      line-height: var(--n-option-height);
      font-size: var(--n-option-font-size);
      padding: 0 0 0 18px;
      box-sizing: border-box;
      min-width: 182px;
      background-color: #0000;
      display: flex;
      align-items: center;
      white-space: nowrap;
      position: relative;
      cursor: pointer;
      transition:
        background-color .2s var(--n-bezier),
        color 0.2s var(--n-bezier);
    `, [cM("show-prefix", {
      paddingLeft: 0
    }), cE("label", `
        flex: 1 0 0;
        overflow: hidden;
        text-overflow: ellipsis;
      `), cE("prefix", {
      width: "32px",
      display: "flex",
      alignItems: "center",
      justifyContent: "center"
    }), cE("suffix", {
      width: "32px",
      display: "flex",
      alignItems: "center",
      justifyContent: "center"
    }), cB("cascader-option-icon-placeholder", {
      lineHeight: 0,
      position: "relative",
      width: "16px",
      height: "16px",
      fontSize: "16px"
    }, [cB("cascader-option-icon", [cM("checkmark", {
      color: "var(--n-option-check-mark-color)"
    }, [fadeInScaleUpTransition({
      originalTransition: "background-color .3s var(--n-bezier), box-shadow .3s var(--n-bezier)"
    })]), cM("arrow", {
      color: "var(--n-option-arrow-color)"
    })])]), cM("selected", {
      color: "var(--n-option-text-color-active)"
    }), cM("active", {
      color: "var(--n-option-text-color-active)",
      backgroundColor: "var(--n-option-color-hover)"
    }), cM("pending", {
      backgroundColor: "var(--n-option-color-hover)"
    }), c$1("&:hover", {
      backgroundColor: "var(--n-option-color-hover)"
    }), cM("disabled", `
        color: var(--n-option-text-color-disabled);
        background-color: #0000;
        cursor: not-allowed;
      `, [cB("cascader-option-icon", [cM("arrow", {
      color: "var(--n-option-text-color-disabled)"
    })])])])]), cB("cascader", `
    z-index: auto;
    position: relative;
    width: 100%;
  `)]);

    const cascaderProps = {
      ...useTheme.props,
      allowCheckingNotLoaded: Boolean,
      to: useAdjustedTo.propTo,
      bordered: {
        type: Boolean,
        default: void 0
      },
      options: {
        type: Array,
        default: () => []
      },
      value: [String, Number, Array],
      defaultValue: {
        type: [String, Number, Array],
        default: null
      },
      placeholder: String,
      multiple: Boolean,
      size: String,
      filterable: Boolean,
      disabled: {
        type: Boolean,
        default: void 0
      },
      disabledField: {
        type: String,
        default: "disabled"
      },
      expandTrigger: {
        type: String,
        default: "click"
      },
      clearable: Boolean,
      clearFilterAfterSelect: {
        type: Boolean,
        default: true
      },
      remote: Boolean,
      onLoad: Function,
      separator: {
        type: String,
        default: " / "
      },
      filter: Function,
      placement: {
        type: String,
        default: "bottom-start"
      },
      cascade: {
        type: Boolean,
        default: true
      },
      leafOnly: Boolean,
      showPath: {
        type: Boolean,
        default: true
      },
      show: {
        type: Boolean,
        default: void 0
      },
      maxTagCount: [String, Number],
      menuProps: Object,
      filterMenuProps: Object,
      virtualScroll: {
        type: Boolean,
        default: true
      },
      checkStrategy: {
        type: String,
        default: "all"
      },
      valueField: {
        type: String,
        default: "value"
      },
      labelField: {
        type: String,
        default: "label"
      },
      childrenField: {
        type: String,
        default: "children"
      },
      renderLabel: Function,
      status: String,
      "onUpdate:value": [Function, Array],
      onUpdateValue: [Function, Array],
      "onUpdate:show": [Function, Array],
      onUpdateShow: [Function, Array],
      onBlur: Function,
      onFocus: Function,
      onChange: [Function, Array]
    };
    var Cascader = vue.defineComponent({
      name: "Cascader",
      props: cascaderProps,
      setup(props) {
        {
          vue.watchEffect(() => {
            if (props.leafOnly) {
              warnOnce(
                "cascader",
                '`leaf-only` is deprecated, please use `check-strategy="child"` instead'
              );
            }
            if (props.onChange !== void 0) {
              warnOnce(
                "cascader",
                "`on-change` is deprecated, please use `on-update:value` instead."
              );
            }
          });
        }
        const {
          mergedBorderedRef,
          mergedClsPrefixRef,
          namespaceRef,
          inlineThemeDisabled
        } = useConfig(props);
        const themeRef = useTheme(
          "Cascader",
          "-cascader",
          style$13,
          cascaderLight$1,
          props,
          mergedClsPrefixRef
        );
        const { localeRef } = useLocale("Cascader");
        const uncontrolledValueRef = vue.ref(props.defaultValue);
        const controlledValueRef = vue.computed(() => props.value);
        const mergedValueRef = useMergedState(
          controlledValueRef,
          uncontrolledValueRef
        );
        const mergedCheckStrategyRef = vue.computed(() => {
          return props.leafOnly ? "child" : props.checkStrategy;
        });
        const patternRef = vue.ref("");
        const formItem = useFormItem(props);
        const { mergedSizeRef, mergedDisabledRef, mergedStatusRef } = formItem;
        const cascaderMenuInstRef = vue.ref(null);
        const selectMenuInstRef = vue.ref(null);
        const triggerInstRef = vue.ref(null);
        const keyboardKeyRef = vue.ref(null);
        const hoverKeyRef = vue.ref(null);
        const loadingKeySetRef = vue.ref(/* @__PURE__ */ new Set());
        const selectMenuFollowerRef = vue.ref(null);
        const cascaderMenuFollowerRef = vue.ref(null);
        const adjustedToRef = useAdjustedTo(props);
        const focusedRef = vue.ref(false);
        const addLoadingKey = (key) => {
          loadingKeySetRef.value.add(key);
        };
        const deleteLoadingKey = (key) => {
          loadingKeySetRef.value.delete(key);
        };
        const treeMateRef = vue.computed(() => {
          const { valueField, childrenField, disabledField } = props;
          return createTreeMate(props.options, {
            getDisabled(node) {
              return node[disabledField];
            },
            getKey(node) {
              return node[valueField];
            },
            getChildren(node) {
              return node[childrenField];
            }
          });
        });
        const mergedKeysRef = vue.computed(() => {
          const { cascade, multiple } = props;
          if (multiple && Array.isArray(mergedValueRef.value)) {
            return treeMateRef.value.getCheckedKeys(mergedValueRef.value, {
              cascade,
              allowNotLoaded: props.allowCheckingNotLoaded
            });
          } else {
            return {
              checkedKeys: [],
              indeterminateKeys: []
            };
          }
        });
        const checkedKeysRef = vue.computed(() => mergedKeysRef.value.checkedKeys);
        const indeterminateKeysRef = vue.computed(
          () => mergedKeysRef.value.indeterminateKeys
        );
        const menuModelRef = vue.computed(() => {
          const { treeNodePath, treeNode } = treeMateRef.value.getPath(
            hoverKeyRef.value
          );
          let ret;
          if (treeNode === null) {
            ret = [treeMateRef.value.treeNodes];
          } else {
            ret = treeNodePath.map((treeNode2) => treeNode2.siblings);
            if (!treeNode.isLeaf && !loadingKeySetRef.value.has(treeNode.key) && treeNode.children) {
              ret.push(treeNode.children);
            }
          }
          return ret;
        });
        const hoverKeyPathRef = vue.computed(() => {
          const { keyPath } = treeMateRef.value.getPath(hoverKeyRef.value);
          return keyPath;
        });
        const optionHeightRef = vue.computed(() => {
          return themeRef.value.self.optionHeight;
        });
        if (vue.isReactive(props.options)) {
          vue.watch(props.options, (value, oldValue) => {
            if (!(value === oldValue)) {
              hoverKeyRef.value = null;
              keyboardKeyRef.value = null;
            }
          });
        }
        function doUpdateShow(value) {
          const { onUpdateShow, "onUpdate:show": _onUpdateShow } = props;
          if (onUpdateShow) {
            call(onUpdateShow, value);
          }
          if (_onUpdateShow) {
            call(_onUpdateShow, value);
          }
          uncontrolledShowRef.value = value;
        }
        function doUpdateValue(value, option, optionPath) {
          const {
            onUpdateValue,
            "onUpdate:value": _onUpdateValue,
            onChange
          } = props;
          const { nTriggerFormInput, nTriggerFormChange } = formItem;
          if (onUpdateValue) {
            call(onUpdateValue, value, option, optionPath);
          }
          if (_onUpdateValue) {
            call(_onUpdateValue, value, option, optionPath);
          }
          if (onChange) {
            call(onChange, value, option, optionPath);
          }
          uncontrolledValueRef.value = value;
          nTriggerFormInput();
          nTriggerFormChange();
        }
        function updateKeyboardKey(key) {
          keyboardKeyRef.value = key;
        }
        function updateHoverKey(key) {
          hoverKeyRef.value = key;
        }
        function doCheck(key) {
          const { cascade, multiple, filterable } = props;
          const {
            value: { check, getNode, getPath }
          } = treeMateRef;
          if (multiple) {
            try {
              const { checkedKeys } = check(key, mergedKeysRef.value.checkedKeys, {
                cascade,
                checkStrategy: mergedCheckStrategyRef.value,
                allowNotLoaded: props.allowCheckingNotLoaded
              });
              doUpdateValue(
                checkedKeys,
                checkedKeys.map(
                  (checkedKey) => getNode(checkedKey)?.rawNode || null
                ),
                checkedKeys.map(
                  (checkedKey) => getRawNodePath(getPath(checkedKey)?.treeNodePath)
                )
              );
              if (filterable)
                focusSelectionInput();
              keyboardKeyRef.value = key;
              hoverKeyRef.value = key;
            } catch (err) {
              if (err instanceof SubtreeNotLoadedError) {
                if (cascaderMenuInstRef.value) {
                  const tmNode = getNode(key);
                  if (tmNode !== null) {
                    cascaderMenuInstRef.value.showErrorMessage(
                      tmNode.rawNode[props.labelField]
                    );
                  }
                }
              } else {
                throw err;
              }
            }
          } else {
            if (mergedCheckStrategyRef.value === "child") {
              const tmNode = getNode(key);
              if (tmNode?.isLeaf) {
                doUpdateValue(
                  key,
                  tmNode.rawNode,
                  getRawNodePath(getPath(key).treeNodePath)
                );
              } else {
                return false;
              }
            } else {
              const tmNode = getNode(key);
              doUpdateValue(
                key,
                tmNode?.rawNode || null,
                getRawNodePath(getPath(key)?.treeNodePath)
              );
            }
          }
          return true;
        }
        function doUncheck(key) {
          const { cascade, multiple } = props;
          if (multiple) {
            const {
              value: { uncheck, getNode, getPath }
            } = treeMateRef;
            const { checkedKeys } = uncheck(key, mergedKeysRef.value.checkedKeys, {
              cascade,
              checkStrategy: mergedCheckStrategyRef.value,
              allowNotLoaded: props.allowCheckingNotLoaded
            });
            doUpdateValue(
              checkedKeys,
              checkedKeys.map((checkedKey) => getNode(checkedKey)?.rawNode || null),
              checkedKeys.map(
                (checkedKey) => getRawNodePath(getPath(checkedKey)?.treeNodePath)
              )
            );
            keyboardKeyRef.value = key;
            hoverKeyRef.value = key;
          }
        }
        const selectedOptionsRef = vue.computed(() => {
          if (props.multiple) {
            const { showPath, separator, labelField, cascade } = props;
            const { getCheckedKeys, getNode } = treeMateRef.value;
            const value = getCheckedKeys(checkedKeysRef.value, {
              cascade,
              checkStrategy: mergedCheckStrategyRef.value,
              allowNotLoaded: props.allowCheckingNotLoaded
            }).checkedKeys;
            return value.map((key) => {
              const node = getNode(key);
              if (node === null) {
                return {
                  label: String(key),
                  value: key
                };
              } else {
                return {
                  label: showPath ? getPathLabel(node, separator, labelField) : node.rawNode[labelField],
                  value: node.key
                };
              }
            });
          } else
            return [];
        });
        const selectedOptionRef = vue.computed(() => {
          const { multiple, showPath, separator, labelField } = props;
          const { value } = mergedValueRef;
          if (!multiple && !Array.isArray(value)) {
            const { getNode } = treeMateRef.value;
            if (value === null) {
              return null;
            }
            const node = getNode(value);
            if (node === null) {
              return {
                label: String(value),
                value
              };
            } else {
              return {
                label: showPath ? getPathLabel(node, separator, labelField) : node.rawNode[labelField],
                value: node.key
              };
            }
          } else
            return null;
        });
        const uncontrolledShowRef = vue.ref(false);
        const controlledShowRef = vue.toRef(props, "show");
        const mergedShowRef = useMergedState(controlledShowRef, uncontrolledShowRef);
        const localizedPlaceholderRef = vue.computed(() => {
          const { placeholder } = props;
          if (placeholder !== void 0)
            return placeholder;
          return localeRef.value.placeholder;
        });
        const showSelectMenuRef = vue.computed(() => {
          return !!(props.filterable && patternRef.value);
        });
        vue.watch(
          mergedShowRef,
          (show) => {
            if (!show)
              return;
            if (props.multiple)
              return;
            const { value } = mergedValueRef;
            if (!Array.isArray(value) && value !== null) {
              keyboardKeyRef.value = value;
              hoverKeyRef.value = value;
              void vue.nextTick(() => {
                if (!mergedShowRef.value)
                  return;
                const { value: hoverKey } = hoverKeyRef;
                if (mergedValueRef.value !== null) {
                  const node = treeMateRef.value.getNode(hoverKey);
                  if (node) {
                    cascaderMenuInstRef.value?.scroll(
                      node.level,
                      node.index,
                      depx(optionHeightRef.value)
                    );
                  }
                }
              });
            } else {
              keyboardKeyRef.value = null;
              hoverKeyRef.value = null;
            }
          },
          {
            immediate: true
          }
        );
        function doBlur(e) {
          const { onBlur } = props;
          const { nTriggerFormBlur } = formItem;
          if (onBlur)
            call(onBlur, e);
          nTriggerFormBlur();
        }
        function doFocus(e) {
          const { onFocus } = props;
          const { nTriggerFormFocus } = formItem;
          if (onFocus)
            call(onFocus, e);
          nTriggerFormFocus();
        }
        function focusSelectionInput() {
          triggerInstRef.value?.focusInput();
        }
        function focusSelection() {
          triggerInstRef.value?.focus();
        }
        function openMenu() {
          if (!mergedDisabledRef.value) {
            patternRef.value = "";
            doUpdateShow(true);
            if (props.filterable) {
              focusSelectionInput();
            }
          }
        }
        function closeMenu(returnFocus = false) {
          if (returnFocus) {
            focusSelection();
          }
          doUpdateShow(false);
          patternRef.value = "";
        }
        function handleCascaderMenuClickOutside(e) {
          if (showSelectMenuRef.value)
            return;
          if (mergedShowRef.value) {
            if (!triggerInstRef.value?.$el.contains(
              getPreciseEventTarget(e)
            )) {
              closeMenu();
            }
          }
        }
        function handleSelectMenuClickOutside(e) {
          if (!showSelectMenuRef.value)
            return;
          handleCascaderMenuClickOutside(e);
        }
        function clearPattern() {
          if (props.clearFilterAfterSelect)
            patternRef.value = "";
        }
        function move(direction) {
          const { value: keyboardKey } = keyboardKeyRef;
          const { value: treeMate } = treeMateRef;
          switch (direction) {
            case "prev":
              if (keyboardKey !== null) {
                const node = treeMate.getPrev(keyboardKey, { loop: true });
                if (node !== null) {
                  updateKeyboardKey(node.key);
                  cascaderMenuInstRef.value?.scroll(
                    node.level,
                    node.index,
                    depx(optionHeightRef.value)
                  );
                }
              }
              break;
            case "next":
              if (keyboardKey === null) {
                const node = treeMate.getFirstAvailableNode();
                if (node !== null) {
                  updateKeyboardKey(node.key);
                  cascaderMenuInstRef.value?.scroll(
                    node.level,
                    node.index,
                    depx(optionHeightRef.value)
                  );
                }
              } else {
                const node = treeMate.getNext(keyboardKey, { loop: true });
                if (node !== null) {
                  updateKeyboardKey(node.key);
                  cascaderMenuInstRef.value?.scroll(
                    node.level,
                    node.index,
                    depx(optionHeightRef.value)
                  );
                }
              }
              break;
            case "child":
              if (keyboardKey !== null) {
                const currentNode = treeMate.getNode(keyboardKey);
                if (currentNode !== null) {
                  if (currentNode.shallowLoaded) {
                    const node = treeMate.getChild(keyboardKey);
                    if (node !== null) {
                      updateHoverKey(keyboardKey);
                      updateKeyboardKey(node.key);
                    }
                  } else {
                    const { value: loadingKeySet } = loadingKeySetRef;
                    if (!loadingKeySet.has(keyboardKey)) {
                      addLoadingKey(keyboardKey);
                      updateHoverKey(keyboardKey);
                      const { onLoad } = props;
                      if (onLoad) {
                        onLoad(currentNode.rawNode).then(() => {
                          deleteLoadingKey(keyboardKey);
                        }).catch(() => {
                          deleteLoadingKey(keyboardKey);
                        });
                      }
                    }
                  }
                }
              }
              break;
            case "parent":
              if (keyboardKey !== null) {
                const node = treeMate.getParent(keyboardKey);
                if (node !== null) {
                  updateKeyboardKey(node.key);
                  const parentNode = node.getParent();
                  if (parentNode === null) {
                    updateHoverKey(null);
                  } else {
                    updateHoverKey(parentNode.key);
                  }
                }
              }
              break;
          }
        }
        function handleKeydown(e) {
          switch (e.key) {
            case " ":
            case "ArrowDown":
            case "ArrowUp":
              if (props.filterable && mergedShowRef.value) {
                break;
              }
              e.preventDefault();
              break;
          }
          if (happensIn(e, "action"))
            return;
          switch (e.key) {
            case " ":
              if (props.filterable)
                return;
            case "Enter":
              if (!mergedShowRef.value) {
                openMenu();
              } else {
                const { value: showSelectMenu } = showSelectMenuRef;
                const { value: keyboardKey } = keyboardKeyRef;
                if (!showSelectMenu) {
                  if (keyboardKey !== null) {
                    if (checkedKeysRef.value.includes(keyboardKey) || indeterminateKeysRef.value.includes(keyboardKey)) {
                      doUncheck(keyboardKey);
                    } else {
                      const checkIsValid = doCheck(keyboardKey);
                      if (!props.multiple && checkIsValid) {
                        closeMenu(true);
                      }
                    }
                  }
                } else {
                  if (selectMenuInstRef.value) {
                    const hasCorrespondingOption = selectMenuInstRef.value.enter();
                    if (hasCorrespondingOption)
                      clearPattern();
                  }
                }
              }
              break;
            case "ArrowUp":
              e.preventDefault();
              if (mergedShowRef.value) {
                if (showSelectMenuRef.value) {
                  selectMenuInstRef.value?.prev();
                } else {
                  move("prev");
                }
              }
              break;
            case "ArrowDown":
              e.preventDefault();
              if (mergedShowRef.value) {
                if (showSelectMenuRef.value) {
                  selectMenuInstRef.value?.next();
                } else {
                  move("next");
                }
              } else {
                openMenu();
              }
              break;
            case "ArrowLeft":
              e.preventDefault();
              if (mergedShowRef.value && !showSelectMenuRef.value) {
                move("parent");
              }
              break;
            case "ArrowRight":
              e.preventDefault();
              if (mergedShowRef.value && !showSelectMenuRef.value) {
                move("child");
              }
              break;
            case "Escape":
              if (mergedShowRef.value) {
                markEventEffectPerformed(e);
                closeMenu(true);
              }
          }
        }
        function handleMenuKeydown(e) {
          handleKeydown(e);
        }
        function handleClear(e) {
          e.stopPropagation();
          if (props.multiple) {
            doUpdateValue([], [], []);
          } else {
            doUpdateValue(null, null, null);
          }
        }
        function handleTriggerFocus(e) {
          if (!cascaderMenuInstRef.value?.$el.contains(e.relatedTarget)) {
            focusedRef.value = true;
            doFocus(e);
          }
        }
        function handleTriggerBlur(e) {
          if (!cascaderMenuInstRef.value?.$el.contains(e.relatedTarget)) {
            focusedRef.value = false;
            doBlur(e);
            closeMenu();
          }
        }
        function handleMenuFocus(e) {
          if (!triggerInstRef.value?.$el.contains(e.relatedTarget)) {
            focusedRef.value = true;
            doFocus(e);
          }
        }
        function handleMenuBlur(e) {
          if (!triggerInstRef.value?.$el.contains(e.relatedTarget)) {
            focusedRef.value = false;
            doBlur(e);
          }
        }
        function handleMenuMousedown(e) {
          if (!happensIn(e, "action")) {
            if (props.multiple && props.filter) {
              e.preventDefault();
              focusSelectionInput();
            }
          }
        }
        function handleMenuTabout() {
          closeMenu(true);
        }
        function handleTriggerClick() {
          if (props.filterable) {
            openMenu();
          } else {
            if (mergedShowRef.value) {
              closeMenu(true);
            } else {
              openMenu();
            }
          }
        }
        function handlePatternInput(e) {
          patternRef.value = e.target.value;
        }
        function handleDeleteOption(option) {
          const { multiple } = props;
          const { value: mergedValue } = mergedValueRef;
          if (multiple && Array.isArray(mergedValue) && option.value !== void 0) {
            doUncheck(option.value);
          } else {
            doUpdateValue(null, null, null);
          }
        }
        function syncSelectMenuPosition() {
          selectMenuFollowerRef.value?.syncPosition();
        }
        function syncCascaderMenuPosition() {
          cascaderMenuFollowerRef.value?.syncPosition();
        }
        function handleTriggerResize() {
          if (mergedShowRef.value) {
            if (showSelectMenuRef.value) {
              syncSelectMenuPosition();
            } else {
              syncCascaderMenuPosition();
            }
          }
        }
        vue.provide(cascaderInjectionKey, {
          mergedClsPrefixRef,
          mergedThemeRef: themeRef,
          mergedValueRef,
          checkedKeysRef,
          indeterminateKeysRef,
          hoverKeyPathRef,
          mergedCheckStrategyRef,
          cascadeRef: vue.toRef(props, "cascade"),
          multipleRef: vue.toRef(props, "multiple"),
          keyboardKeyRef,
          hoverKeyRef,
          remoteRef: vue.toRef(props, "remote"),
          loadingKeySetRef,
          expandTriggerRef: vue.toRef(props, "expandTrigger"),
          isMountedRef: isMounted(),
          onLoadRef: vue.toRef(props, "onLoad"),
          virtualScrollRef: vue.toRef(props, "virtualScroll"),
          optionHeightRef,
          localeRef,
          labelFieldRef: vue.toRef(props, "labelField"),
          renderLabelRef: vue.toRef(props, "renderLabel"),
          syncCascaderMenuPosition,
          syncSelectMenuPosition,
          updateKeyboardKey,
          updateHoverKey,
          addLoadingKey,
          deleteLoadingKey,
          doCheck,
          doUncheck,
          closeMenu,
          handleSelectMenuClickOutside,
          handleCascaderMenuClickOutside,
          clearPattern
        });
        const exposedMethods = {
          focus: () => {
            triggerInstRef.value?.focus();
          },
          blur: () => {
            triggerInstRef.value?.blur();
          }
        };
        const cssVarsRef = vue.computed(() => {
          const {
            self: {
              optionArrowColor,
              optionTextColor,
              optionTextColorActive,
              optionTextColorDisabled,
              optionCheckMarkColor,
              menuColor,
              menuBoxShadow,
              menuDividerColor,
              menuBorderRadius,
              menuHeight,
              optionColorHover,
              optionHeight,
              optionFontSize,
              loadingColor,
              columnWidth
            },
            common: { cubicBezierEaseInOut }
          } = themeRef.value;
          return {
            "--n-bezier": cubicBezierEaseInOut,
            "--n-menu-border-radius": menuBorderRadius,
            "--n-menu-box-shadow": menuBoxShadow,
            "--n-menu-height": menuHeight,
            "--n-column-width": columnWidth,
            "--n-menu-color": menuColor,
            "--n-menu-divider-color": menuDividerColor,
            "--n-option-height": optionHeight,
            "--n-option-font-size": optionFontSize,
            "--n-option-text-color": optionTextColor,
            "--n-option-text-color-disabled": optionTextColorDisabled,
            "--n-option-text-color-active": optionTextColorActive,
            "--n-option-color-hover": optionColorHover,
            "--n-option-check-mark-color": optionCheckMarkColor,
            "--n-option-arrow-color": optionArrowColor,
            "--n-menu-mask-color": changeColor(menuColor, { alpha: 0.75 }),
            "--n-loading-color": loadingColor
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("cascader", void 0, cssVarsRef, props) : void 0;
        return {
          ...exposedMethods,
          handleTriggerResize,
          mergedStatus: mergedStatusRef,
          selectMenuFollowerRef,
          cascaderMenuFollowerRef,
          triggerInstRef,
          selectMenuInstRef,
          cascaderMenuInstRef,
          mergedBordered: mergedBorderedRef,
          mergedClsPrefix: mergedClsPrefixRef,
          namespace: namespaceRef,
          mergedValue: mergedValueRef,
          mergedShow: mergedShowRef,
          showSelectMenu: showSelectMenuRef,
          pattern: patternRef,
          treeMate: treeMateRef,
          mergedSize: mergedSizeRef,
          mergedDisabled: mergedDisabledRef,
          localizedPlaceholder: localizedPlaceholderRef,
          selectedOption: selectedOptionRef,
          selectedOptions: selectedOptionsRef,
          adjustedTo: adjustedToRef,
          menuModel: menuModelRef,
          handleMenuTabout,
          handleMenuFocus,
          handleMenuBlur,
          handleMenuKeydown,
          handleMenuMousedown,
          handleTriggerFocus,
          handleTriggerBlur,
          handleTriggerClick,
          handleClear,
          handleDeleteOption,
          handlePatternInput,
          handleKeydown,
          focused: focusedRef,
          optionHeight: optionHeightRef,
          mergedTheme: themeRef,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender
        };
      },
      render() {
        const { mergedClsPrefix } = this;
        return /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-cascader`
        }, /* @__PURE__ */ vue.h(VBinder, null, {
          default: () => [
            /* @__PURE__ */ vue.h(VTarget, null, {
              default: () => /* @__PURE__ */ vue.h(NInternalSelection, {
                onResize: this.handleTriggerResize,
                ref: "triggerInstRef",
                status: this.mergedStatus,
                clsPrefix: mergedClsPrefix,
                maxTagCount: this.maxTagCount,
                bordered: this.mergedBordered,
                size: this.mergedSize,
                theme: this.mergedTheme.peers.InternalSelection,
                themeOverrides: this.mergedTheme.peerOverrides.InternalSelection,
                active: this.mergedShow,
                pattern: this.pattern,
                placeholder: this.localizedPlaceholder,
                selectedOption: this.selectedOption,
                selectedOptions: this.selectedOptions,
                multiple: this.multiple,
                filterable: this.filterable,
                clearable: this.clearable,
                disabled: this.mergedDisabled,
                focused: this.focused,
                onFocus: this.handleTriggerFocus,
                onBlur: this.handleTriggerBlur,
                onClick: this.handleTriggerClick,
                onClear: this.handleClear,
                onDeleteOption: this.handleDeleteOption,
                onPatternInput: this.handlePatternInput,
                onKeydown: this.handleKeydown
              }, {
                arrow: () => this.$slots.arrow?.()
              })
            }),
            /* @__PURE__ */ vue.h(VFollower, {
              key: "cascaderMenu",
              ref: "cascaderMenuFollowerRef",
              show: this.mergedShow && !this.showSelectMenu,
              containerClass: this.namespace,
              placement: this.placement,
              width: !this.options.length ? "target" : void 0,
              teleportDisabled: this.adjustedTo === useAdjustedTo.tdkey,
              to: this.adjustedTo
            }, {
              default: () => {
                this.onRender?.();
                const { menuProps } = this;
                return /* @__PURE__ */ vue.h(CascaderMenu, {
                  ...menuProps,
                  ref: "cascaderMenuInstRef",
                  class: [this.themeClass, menuProps?.class],
                  value: this.mergedValue,
                  show: this.mergedShow && !this.showSelectMenu,
                  menuModel: this.menuModel,
                  style: [
                    this.cssVars,
                    menuProps?.style
                  ],
                  onFocus: this.handleMenuFocus,
                  onBlur: this.handleMenuBlur,
                  onKeydown: this.handleMenuKeydown,
                  onMousedown: this.handleMenuMousedown,
                  onTabout: this.handleMenuTabout
                }, {
                  action: () => this.$slots.action?.(),
                  empty: () => this.$slots.empty?.()
                });
              }
            }),
            /* @__PURE__ */ vue.h(VFollower, {
              key: "selectMenu",
              ref: "selectMenuFollowerRef",
              show: this.mergedShow && this.showSelectMenu,
              containerClass: this.namespace,
              width: "target",
              placement: this.placement,
              to: this.adjustedTo,
              teleportDisabled: this.adjustedTo === useAdjustedTo.tdkey
            }, {
              default: () => {
                this.onRender?.();
                const { filterMenuProps } = this;
                return /* @__PURE__ */ vue.h(CascaderSelectMenu, {
                  ...filterMenuProps,
                  ref: "selectMenuInstRef",
                  class: [this.themeClass, filterMenuProps?.class],
                  value: this.mergedValue,
                  show: this.mergedShow && this.showSelectMenu,
                  pattern: this.pattern,
                  multiple: this.multiple,
                  tmNodes: this.treeMate.treeNodes,
                  filter: this.filter,
                  labelField: this.labelField,
                  separator: this.separator,
                  style: [
                    this.cssVars,
                    filterMenuProps?.style
                  ]
                });
              }
            })
          ]
        }));
      }
    });

    const codeDark = {
      name: "Code",
      common: commonDark,

      self(vars) {
        const {
          textColor2,
          fontSize,
          fontWeightStrong,
          textColor3
        } = vars;
        return {
          textColor: textColor2,
          fontSize,
          fontWeightStrong,
          "mono-3": "#5c6370",
          "hue-1": "#56b6c2",
          "hue-2": "#61aeee",
          "hue-3": "#c678dd",
          "hue-4": "#98c379",
          "hue-5": "#e06c75",
          "hue-5-2": "#be5046",
          "hue-6": "#d19a66",
          "hue-6-2": "#e6c07b",
          lineNumberTextColor: textColor3
        };
      }

    };
    var codeDark$1 = codeDark;

    const self$S = vars => {
      const {
        textColor2,
        fontSize,
        fontWeightStrong,
        textColor3
      } = vars;
      return {
        textColor: textColor2,
        fontSize,
        fontWeightStrong,
        "mono-3": "#a0a1a7",
        "hue-1": "#0184bb",
        "hue-2": "#4078f2",
        "hue-3": "#a626a4",
        "hue-4": "#50a14f",
        "hue-5": "#e45649",
        "hue-5-2": "#c91243",
        "hue-6": "#986801",
        "hue-6-2": "#c18401",
        lineNumberTextColor: textColor3
      };
    };

    const codeLight = {
      name: "Code",
      common: commonLight,
      self: self$S
    };
    var codeLight$1 = codeLight;

    var style$12 = c$1([cB("code", `
    font-size: var(--n-font-size);
    font-family: var(--n-font-family);
  `, [cM("show-line-numbers", `
      display: flex;
    `), cE("line-numbers", `
      user-select: none;
      padding-right: 12px;
      text-align: right;
      transition: color .3s var(--n-bezier);
      color: var(--n-line-number-text-color);
    `), cM("word-wrap", [c$1("pre", `
        white-space: pre-wrap;
        word-break: break-all;
      `)]), c$1("pre", `
      margin: 0;
      line-height: inherit;
      font-size: inherit;
      font-family: inherit;
    `), c$1("[class^=hljs]", `
      color: var(--n-text-color);
      transition:
        color .3s var(--n-bezier),
        background-color .3s var(--n-bezier);
    `)]), _ref => {
      let {
        props
      } = _ref;
      const codeClass = `${props.bPrefix}code`;
      return [`${codeClass} .hljs-comment,
      ${codeClass} .hljs-quote {
        color: var(--n-mono-3);
        font-style: italic;
      }`, `${codeClass} .hljs-doctag,
      ${codeClass} .hljs-keyword,
      ${codeClass} .hljs-formula {
        color: var(--n-hue-3);
      }`, `${codeClass} .hljs-section,
      ${codeClass} .hljs-name,
      ${codeClass} .hljs-selector-tag,
      ${codeClass} .hljs-deletion,
      ${codeClass} .hljs-subst {
        color: var(--n-hue-5);
      }`, `${codeClass} .hljs-literal {
        color: var(--n-hue-1);
      }`, `${codeClass} .hljs-string,
      ${codeClass} .hljs-regexp,
      ${codeClass} .hljs-addition,
      ${codeClass} .hljs-attribute,
      ${codeClass} .hljs-meta-string {
        color: var(--n-hue-4);
      }`, `${codeClass} .hljs-built_in,
      ${codeClass} .hljs-class .hljs-title {
        color: var(--n-hue-6-2);
      }`, `${codeClass} .hljs-attr,
      ${codeClass} .hljs-variable,
      ${codeClass} .hljs-template-variable,
      ${codeClass} .hljs-type,
      ${codeClass} .hljs-selector-class,
      ${codeClass} .hljs-selector-attr,
      ${codeClass} .hljs-selector-pseudo,
      ${codeClass} .hljs-number {
        color: var(--n-hue-6);
      }`, `${codeClass} .hljs-symbol,
      ${codeClass} .hljs-bullet,
      ${codeClass} .hljs-link,
      ${codeClass} .hljs-meta,
      ${codeClass} .hljs-selector-id,
      ${codeClass} .hljs-title {
        color: var(--n-hue-2);
      }`, `${codeClass} .hljs-emphasis {
        font-style: italic;
      }`, `${codeClass} .hljs-strong {
        font-weight: var(--n-font-weight-strong);
      }`, `${codeClass} .hljs-link {
        text-decoration: underline;
      }`];
    }]);

    const codeProps = {
      ...useTheme.props,
      language: String,
      code: {
        type: String,
        default: ""
      },
      trim: {
        type: Boolean,
        default: true
      },
      hljs: Object,
      uri: Boolean,
      inline: Boolean,
      wordWrap: Boolean,
      showLineNumbers: Boolean,
      internalFontSize: Number,
      internalNoHighlight: Boolean
    };
    var NCode = vue.defineComponent({
      name: "Code",
      props: codeProps,
      setup(props, { slots }) {
        const { internalNoHighlight } = props;
        const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig();
        const codeRef = vue.ref(null);
        const hljsRef = internalNoHighlight ? { value: void 0 } : useHljs(props);
        const createCodeHtml = (language, code, trim) => {
          const { value: hljs } = hljsRef;
          if (!hljs) {
            return null;
          }
          if (!(language && hljs.getLanguage(language))) {
            return null;
          }
          return hljs.highlight(trim ? code.trim() : code, {
            language
          }).value;
        };
        const mergedShowLineNumbersRef = vue.computed(() => {
          if (props.inline || props.wordWrap)
            return false;
          return props.showLineNumbers;
        });
        const setCode = () => {
          if (slots.default)
            return;
          const { value: codeEl } = codeRef;
          if (!codeEl)
            return;
          const { language } = props;
          const code = props.uri ? window.decodeURIComponent(props.code) : props.code;
          if (language) {
            const html = createCodeHtml(language, code, props.trim);
            if (html !== null) {
              if (props.inline) {
                codeEl.innerHTML = html;
              } else {
                const prevPreEl = codeEl.querySelector(".__code__");
                if (prevPreEl)
                  codeEl.removeChild(prevPreEl);
                const preEl = document.createElement("pre");
                preEl.className = "__code__";
                preEl.innerHTML = html;
                codeEl.appendChild(preEl);
              }
              return;
            }
          }
          if (props.inline) {
            codeEl.textContent = code;
            return;
          }
          const maybePreEl = codeEl.querySelector(".__code__");
          if (maybePreEl) {
            maybePreEl.textContent = code;
          } else {
            const wrap = document.createElement("pre");
            wrap.className = "__code__";
            wrap.textContent = code;
            codeEl.innerHTML = "";
            codeEl.appendChild(wrap);
          }
        };
        vue.onMounted(setCode);
        vue.watch(vue.toRef(props, "language"), setCode);
        vue.watch(vue.toRef(props, "code"), setCode);
        if (!internalNoHighlight)
          vue.watch(hljsRef, setCode);
        const themeRef = useTheme(
          "Code",
          "-code",
          style$12,
          codeLight$1,
          props,
          mergedClsPrefixRef
        );
        const cssVarsRef = vue.computed(() => {
          const {
            common: { cubicBezierEaseInOut, fontFamilyMono },
            self: {
              textColor,
              fontSize,
              fontWeightStrong,
              lineNumberTextColor,
              "mono-3": $1,
              "hue-1": $2,
              "hue-2": $3,
              "hue-3": $4,
              "hue-4": $5,
              "hue-5": $6,
              "hue-5-2": $7,
              "hue-6": $8,
              "hue-6-2": $9
            }
          } = themeRef.value;
          const { internalFontSize } = props;
          return {
            "--n-font-size": internalFontSize ? `${internalFontSize}px` : fontSize,
            "--n-font-family": fontFamilyMono,
            "--n-font-weight-strong": fontWeightStrong,
            "--n-bezier": cubicBezierEaseInOut,
            "--n-text-color": textColor,
            "--n-mono-3": $1,
            "--n-hue-1": $2,
            "--n-hue-2": $3,
            "--n-hue-3": $4,
            "--n-hue-4": $5,
            "--n-hue-5": $6,
            "--n-hue-5-2": $7,
            "--n-hue-6": $8,
            "--n-hue-6-2": $9,
            "--n-line-number-text-color": lineNumberTextColor
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass(
          "code",
          vue.computed(() => {
            return `${props.internalFontSize || "a"}`;
          }),
          cssVarsRef,
          props
        ) : void 0;
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          codeRef,
          mergedShowLineNumbers: mergedShowLineNumbersRef,
          lineNumbers: vue.computed(() => {
            let number = 1;
            const numbers = [];
            let lastIsLineWrap = false;
            for (const char of props.code) {
              if (char === "\n") {
                lastIsLineWrap = true;
                numbers.push(number++);
              } else {
                lastIsLineWrap = false;
              }
            }
            if (!lastIsLineWrap) {
              numbers.push(number++);
            }
            return numbers.join("\n");
          }),
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender
        };
      },
      render() {
        const { mergedClsPrefix, wordWrap, mergedShowLineNumbers, onRender } = this;
        onRender?.();
        return /* @__PURE__ */ vue.h("code", {
          class: [
            `${mergedClsPrefix}-code`,
            this.themeClass,
            wordWrap && `${mergedClsPrefix}-code--word-wrap`,
            mergedShowLineNumbers && `${mergedClsPrefix}-code--show-line-numbers`
          ],
          style: this.cssVars,
          ref: "codeRef"
        }, mergedShowLineNumbers ? /* @__PURE__ */ vue.h("pre", {
          class: `${mergedClsPrefix}-code__line-numbers`
        }, this.lineNumbers) : null, this.$slots.default?.());
      }
    });

    const self$R = vars => {
      const {
        fontWeight,
        textColor1,
        textColor2,
        textColorDisabled,
        dividerColor,
        fontSize
      } = vars;
      return {
        titleFontSize: fontSize,
        titleFontWeight: fontWeight,
        dividerColor,
        titleTextColor: textColor1,
        titleTextColorDisabled: textColorDisabled,
        fontSize,
        textColor: textColor2,
        arrowColor: textColor2,
        arrowColorDisabled: textColorDisabled
      };
    };
    const collapseLight = {
      name: "Collapse",
      common: commonLight,
      self: self$R
    };
    var collapseLight$1 = collapseLight;

    const collapseDark = {
      name: "Collapse",
      common: commonDark,
      self: self$R
    };
    var collapseDark$1 = collapseDark;

    var rtlStyle$i = cB("collapse", [cM("rtl", `
    direction: rtl;
  `, [cB("collapse-item", [cB("collapse-item", {
      marginRight: "32px",
      marginLeft: 0
    }), cM("left-arrow-placement", [cE("header", [cB("collapse-item-arrow", {
      marginRight: 0,
      marginLeft: "4px"
    })])]), cM("right-arrow-placement", [cE("header", [cB("collapse-item-arrow", {
      marginLeft: 0,
      marginRight: "4px"
    })])]), cM("active", [cE("header", [cM("active", [cB("collapse-item-arrow", {
      transform: "rotate(-90deg)"
    })])])])])])]);

    const collapseRtl = {
      name: "Collapse",
      style: rtlStyle$i
    };

    var style$11 = cB("collapse", "width: 100%;", [cB("collapse-item", `
    font-size: var(--n-font-size);
    color: var(--n-text-color);
    transition:
      color .3s var(--n-bezier),
      border-color .3s var(--n-bezier);
    margin: 16px 0 0 0;
  `, [cM("disabled", [cE("header", "cursor: not-allowed;", [cE("header-main", `
          color: var(--n-title-text-color-disabled);
        `), cB("collapse-item-arrow", `
          color: var(--n-arrow-color-disabled);
        `)])]), cB("collapse-item", "margin-left: 32px;"), c$1("&:first-child", "margin-top: 0;"), c$1("&:first-child >", [cE("header", "padding-top: 0;")]), cM("left-arrow-placement", [cE("header", [cB("collapse-item-arrow", "margin-right: 4px;")])]), cM("right-arrow-placement", [cE("header", [cB("collapse-item-arrow", "margin-left: 4px;")])]), cE("content-wrapper", [cE("content-inner", "padding-top: 16px;"), fadeInHeightExpandTransition({
      duration: "0.15s"
    })]), cM("active", [cE("header", [cM("active", [cB("collapse-item-arrow", "transform: rotate(90deg);")])])]), c$1("&:not(:first-child)", "border-top: 1px solid var(--n-divider-color);"), cE("header", `
      font-size: var(--n-title-font-size);
      display: flex;
      flex-wrap: nowrap;
      align-items: center;
      transition: color .3s var(--n-bezier);
      position: relative;
      padding: 16px 0 0 0;
      color: var(--n-title-text-color);
      cursor: pointer;
    `, [cE("header-main", `
        display: flex;
        flex-wrap: nowrap;
        align-items: center;
        font-weight: var(--n-title-font-weight);
        transition: color .3s var(--n-bezier);
        flex: 1;
        color: var(--n-title-text-color);
      `), cE("header-extra", `
        display: flex;
        align-items: center;
        transition: color .3s var(--n-bezier);
        color: var(--n-text-color);
      `), cB("collapse-item-arrow", `
        display: flex;
        transition:
          transform .15s var(--n-bezier),
          color .3s var(--n-bezier);
        font-size: 18px;
        color: var(--n-arrow-color);
      `)])])]);

    const collapseProps = {
      ...useTheme.props,
      defaultExpandedNames: {
        type: [Array, String],
        default: null
      },
      expandedNames: [Array, String],
      arrowPlacement: {
        type: String,
        default: "left"
      },
      accordion: {
        type: Boolean,
        default: false
      },
      displayDirective: {
        type: String,
        default: "if"
      },
      onItemHeaderClick: [Function, Array],
      "onUpdate:expandedNames": [Function, Array],
      onUpdateExpandedNames: [Function, Array],
      onExpandedNamesChange: {
        type: [Function, Array],
        validator: () => {
          {
            warn$2(
              "collapse",
              "`on-expanded-names-change` is deprecated, please use `on-update:expanded-names` instead."
            );
          }
          return true;
        },
        default: void 0
      }
    };
    const collapseInjectionKey = createInjectionKey("n-collapse");
    var NCollapse = vue.defineComponent({
      name: "Collapse",
      props: collapseProps,
      setup(props, { slots }) {
        const { mergedClsPrefixRef, inlineThemeDisabled, mergedRtlRef } = useConfig(props);
        const uncontrolledExpandedNamesRef = vue.ref(props.defaultExpandedNames);
        const controlledExpandedNamesRef = vue.computed(() => props.expandedNames);
        const mergedExpandedNamesRef = useMergedState(
          controlledExpandedNamesRef,
          uncontrolledExpandedNamesRef
        );
        const themeRef = useTheme(
          "Collapse",
          "-collapse",
          style$11,
          collapseLight$1,
          props,
          mergedClsPrefixRef
        );
        function doUpdateExpandedNames(names) {
          const {
            "onUpdate:expandedNames": _onUpdateExpandedNames,
            onUpdateExpandedNames,
            onExpandedNamesChange
          } = props;
          if (onUpdateExpandedNames) {
            call(onUpdateExpandedNames, names);
          }
          if (_onUpdateExpandedNames) {
            call(_onUpdateExpandedNames, names);
          }
          if (onExpandedNamesChange) {
            call(onExpandedNamesChange, names);
          }
          uncontrolledExpandedNamesRef.value = names;
        }
        function doItemHeaderClick(info) {
          const { onItemHeaderClick } = props;
          if (onItemHeaderClick) {
            call(onItemHeaderClick, info);
          }
        }
        function toggleItem(collapse, name, event) {
          const { accordion } = props;
          const { value: expandedNames } = mergedExpandedNamesRef;
          if (accordion) {
            if (collapse) {
              doUpdateExpandedNames([name]);
              doItemHeaderClick({ name, expanded: true, event });
            } else {
              doUpdateExpandedNames([]);
              doItemHeaderClick({ name, expanded: false, event });
            }
          } else {
            if (!Array.isArray(expandedNames)) {
              doUpdateExpandedNames([name]);
              doItemHeaderClick({ name, expanded: true, event });
            } else {
              const activeNames = expandedNames.slice();
              const index = activeNames.findIndex(
                (activeName) => name === activeName
              );
              if (~index) {
                activeNames.splice(index, 1);
                doUpdateExpandedNames(activeNames);
                doItemHeaderClick({ name, expanded: false, event });
              } else {
                activeNames.push(name);
                doUpdateExpandedNames(activeNames);
                doItemHeaderClick({ name, expanded: true, event });
              }
            }
          }
        }
        vue.provide(collapseInjectionKey, {
          props,
          mergedClsPrefixRef,
          expandedNamesRef: mergedExpandedNamesRef,
          slots,
          toggleItem
        });
        const rtlEnabledRef = useRtl("Collapse", mergedRtlRef, mergedClsPrefixRef);
        const cssVarsRef = vue.computed(() => {
          const {
            common: { cubicBezierEaseInOut },
            self: {
              titleFontWeight,
              dividerColor,
              titleTextColor,
              titleTextColorDisabled,
              textColor,
              arrowColor,
              fontSize,
              titleFontSize,
              arrowColorDisabled
            }
          } = themeRef.value;
          return {
            "--n-font-size": fontSize,
            "--n-bezier": cubicBezierEaseInOut,
            "--n-text-color": textColor,
            "--n-divider-color": dividerColor,
            "--n-title-font-size": titleFontSize,
            "--n-title-text-color": titleTextColor,
            "--n-title-text-color-disabled": titleTextColorDisabled,
            "--n-title-font-weight": titleFontWeight,
            "--n-arrow-color": arrowColor,
            "--n-arrow-color-disabled": arrowColorDisabled
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("collapse", void 0, cssVarsRef, props) : void 0;
        return {
          rtlEnabled: rtlEnabledRef,
          mergedTheme: themeRef,
          mergedClsPrefix: mergedClsPrefixRef,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender
        };
      },
      render() {
        this.onRender?.();
        return /* @__PURE__ */ vue.h("div", {
          class: [
            `${this.mergedClsPrefix}-collapse`,
            this.rtlEnabled && `${this.mergedClsPrefix}-collapse--rtl`,
            this.themeClass
          ],
          style: this.cssVars
        }, this.$slots);
      }
    });

    var NCollapseItemContent = vue.defineComponent({
      name: "CollapseItemContent",
      props: {
        displayDirective: {
          type: String,
          required: true
        },
        show: Boolean,
        clsPrefix: {
          type: String,
          required: true
        }
      },
      setup(props) {
        const onceTrueRef = useFalseUntilTruthy(vue.toRef(props, "show"));
        return {
          onceTrue: onceTrueRef
        };
      },
      render() {
        return /* @__PURE__ */ vue.h(NFadeInExpandTransition, null, {
          default: () => {
            const { show, displayDirective, onceTrue, clsPrefix } = this;
            const useVShow = displayDirective === "show" && onceTrue;
            const contentNode = /* @__PURE__ */ vue.h("div", {
              class: `${clsPrefix}-collapse-item__content-wrapper`
            }, /* @__PURE__ */ vue.h("div", {
              class: `${clsPrefix}-collapse-item__content-inner`
            }, this.$slots));
            return useVShow ? vue.withDirectives(contentNode, [[vue.vShow, show]]) : show ? contentNode : null;
          }
        });
      }
    });

    const collapseItemProps = {
      title: String,
      name: [String, Number],
      disabled: Boolean,
      displayDirective: String
    };
    var NCollapseItem = vue.defineComponent({
      name: "CollapseItem",
      props: collapseItemProps,
      setup(props) {
        const { mergedRtlRef } = useConfig(props);
        const randomName = createId();
        const mergedNameRef = useMemo(() => {
          return props.name ?? randomName;
        });
        const NCollapse = vue.inject(collapseInjectionKey);
        if (!NCollapse) {
          throwError(
            "collapse-item",
            "`n-collapse-item` must be placed inside `n-collapse`."
          );
        }
        const {
          expandedNamesRef,
          props: collapseProps,
          mergedClsPrefixRef,
          slots: collapseSlots
        } = NCollapse;
        const collapsedRef = vue.computed(() => {
          const { value: expandedNames } = expandedNamesRef;
          if (Array.isArray(expandedNames)) {
            const { value: name } = mergedNameRef;
            return !~expandedNames.findIndex(
              (expandedName) => expandedName === name
            );
          } else if (expandedNames) {
            const { value: name } = mergedNameRef;
            return name !== expandedNames;
          }
          return true;
        });
        const rtlEnabledRef = useRtl("Collapse", mergedRtlRef, mergedClsPrefixRef);
        return {
          rtlEnabled: rtlEnabledRef,
          collapseSlots,
          randomName,
          mergedClsPrefix: mergedClsPrefixRef,
          collapsed: collapsedRef,
          mergedDisplayDirective: vue.computed(() => {
            const { displayDirective } = props;
            if (displayDirective) {
              return displayDirective;
            } else {
              return collapseProps.displayDirective;
            }
          }),
          arrowPlacement: vue.computed(() => {
            return collapseProps.arrowPlacement;
          }),
          handleClick(e) {
            if (NCollapse && !props.disabled) {
              NCollapse.toggleItem(collapsedRef.value, mergedNameRef.value, e);
            }
          }
        };
      },
      render() {
        const {
          collapseSlots,
          $slots,
          arrowPlacement,
          collapsed,
          mergedDisplayDirective,
          mergedClsPrefix,
          disabled
        } = this;
        const headerNode = $slots.header ? $slots.header() : this.title;
        const headerExtraSlot = $slots["header-extra"] || collapseSlots["header-extra"];
        const arrowSlot = $slots.arrow || collapseSlots.arrow;
        return /* @__PURE__ */ vue.h("div", {
          class: [
            `${mergedClsPrefix}-collapse-item`,
            `${mergedClsPrefix}-collapse-item--${arrowPlacement}-arrow-placement`,
            disabled && `${mergedClsPrefix}-collapse-item--disabled`,
            !collapsed && `${mergedClsPrefix}-collapse-item--active`
          ]
        }, /* @__PURE__ */ vue.h("div", {
          class: [
            `${mergedClsPrefix}-collapse-item__header`,
            !collapsed && `${mergedClsPrefix}-collapse-item__header--active`
          ]
        }, /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-collapse-item__header-main`,
          onClick: this.handleClick
        }, arrowPlacement === "right" && headerNode, /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-collapse-item-arrow`,
          key: this.rtlEnabled ? 0 : 1
        }, arrowSlot ? arrowSlot({ collapsed }) : /* @__PURE__ */ vue.h(NBaseIcon, {
          clsPrefix: mergedClsPrefix
        }, {
          default: collapseSlots.expandIcon ?? (() => this.rtlEnabled ? /* @__PURE__ */ vue.h(ChevronLeftIcon, null) : /* @__PURE__ */ vue.h(ChevronRightIcon, null))
        })), arrowPlacement === "left" && headerNode), headerExtraSlot && /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-collapse-item__header-extra`,
          onClick: this.handleClick
        }, { default: headerExtraSlot })), /* @__PURE__ */ vue.h(NCollapseItemContent, {
          clsPrefix: mergedClsPrefix,
          displayDirective: mergedDisplayDirective,
          show: !collapsed
        }, $slots));
      }
    });

    var style$10 = cB("collapse-transition", {
      width: "100%"
    }, [fadeInHeightExpandTransition()]);

    const self$Q = vars => {
      const {
        cubicBezierEaseInOut
      } = vars;
      return {
        bezier: cubicBezierEaseInOut
      };
    };
    const collapseTransitionLight = {
      name: "CollapseTransition",
      common: commonLight,
      self: self$Q
    };
    var collapseTransitionLight$1 = collapseTransitionLight;

    const collapseTransitionDark = {
      name: "CollapseTransition",
      common: commonDark,
      self: self$Q
    };
    var collapseTransitionDark$1 = collapseTransitionDark;

    var rtlStyle$h = cB("collapse-transition", [cM("rtl", `
    direction: rtl;
    text-align: right;
  `)]);

    const collapseTransitionRtl = {
      name: "CollapseTransition",
      style: rtlStyle$h
    };

    const collapseTransitionProps = {
      ...useTheme.props,
      show: {
        type: Boolean,
        default: true
      },
      appear: Boolean,
      collapsed: {
        type: Boolean,
        default: void 0
      }
    };
    var CollapseTransition = vue.defineComponent({
      name: "CollapseTransition",
      props: collapseTransitionProps,
      inheritAttrs: false,
      setup(props) {
        {
          vue.watchEffect(() => {
            if (props.collapsed !== void 0) {
              warnOnce(
                "collapse-transition",
                "`collapsed` is deprecated, please use `show` instead"
              );
            }
          });
        }
        const { mergedClsPrefixRef, inlineThemeDisabled, mergedRtlRef } = useConfig(props);
        const mergedThemeRef = useTheme(
          "CollapseTransition",
          "-collapse-transition",
          style$10,
          collapseTransitionLight$1,
          props,
          mergedClsPrefixRef
        );
        const rtlEnabledRef = useRtl(
          "CollapseTransition",
          mergedRtlRef,
          mergedClsPrefixRef
        );
        const mergedShowRef = vue.computed(() => {
          if (props.collapsed !== void 0) {
            return props.collapsed;
          }
          return props.show;
        });
        const cssVarsRef = vue.computed(() => {
          const {
            self: { bezier }
          } = mergedThemeRef.value;
          return {
            "--n-bezier": bezier
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("collapse-transition", void 0, cssVarsRef, props) : void 0;
        return {
          rtlEnabled: rtlEnabledRef,
          mergedShow: mergedShowRef,
          mergedClsPrefix: mergedClsPrefixRef,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender
        };
      },
      render() {
        return /* @__PURE__ */ vue.h(NFadeInExpandTransition, {
          appear: this.appear
        }, {
          default: () => {
            if (!this.mergedShow)
              return;
            this.onRender?.();
            return vue.h(
              "div",
              vue.mergeProps(
                {
                  class: [
                    `${this.mergedClsPrefix}-collapse-transition`,
                    this.rtlEnabled && `${this.mergedClsPrefix}-collapse-transition--rtl`,
                    this.themeClass
                  ],
                  style: this.cssVars
                },
                this.$attrs
              ),
              this.$slots
            );
          }
        });
      }
    });

    const configProviderProps = {
      abstract: Boolean,
      bordered: {
        type: Boolean,
        default: void 0
      },
      clsPrefix: String,
      locale: Object,
      dateLocale: Object,
      namespace: String,
      rtl: Array,
      tag: {
        type: String,
        default: "div"
      },
      hljs: Object,
      theme: Object,
      themeOverrides: Object,
      componentOptions: Object,
      icons: Object,
      breakpoints: Object,
      preflightStyleDisabled: Boolean,
      inlineThemeDisabled: {
        type: Boolean,
        default: void 0
      },
      as: {
        type: String,
        validator: () => {
          warn$2("config-provider", "`as` is deprecated, please use `tag` instead.");
          return true;
        },
        default: void 0
      }
    };
    var NConfigProvider = vue.defineComponent({
      name: "ConfigProvider",
      alias: ["App"],
      props: configProviderProps,

      setup(props) {
        const NConfigProvider = vue.inject(configProviderInjectionKey, null);
        const mergedThemeRef = vue.computed(() => {
          const {
            theme
          } = props;
          if (theme === null) return void 0;
          const inheritedTheme = NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedThemeRef.value;
          return theme === void 0 ? inheritedTheme : inheritedTheme === void 0 ? theme : Object.assign({}, inheritedTheme, theme);
        });
        const mergedThemeOverridesRef = vue.computed(() => {
          const {
            themeOverrides
          } = props;
          if (themeOverrides === null) return void 0;

          if (themeOverrides === void 0) {
            return NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedThemeOverridesRef.value;
          } else {
            const inheritedThemeOverrides = NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedThemeOverridesRef.value;

            if (inheritedThemeOverrides === void 0) {
              return themeOverrides;
            } else {
              return lodash.exports.merge({}, inheritedThemeOverrides, themeOverrides);
            }
          }
        });
        const mergedNamespaceRef = useMemo(() => {
          const {
            namespace
          } = props;
          return namespace === void 0 ? NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedNamespaceRef.value : namespace;
        });
        const mergedBorderedRef = useMemo(() => {
          const {
            bordered
          } = props;
          return bordered === void 0 ? NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedBorderedRef.value : bordered;
        });
        const mergedIconsRef = vue.computed(() => {
          const {
            icons
          } = props;
          return icons === void 0 ? NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedIconsRef.value : icons;
        });
        const mergedComponentPropsRef = vue.computed(() => {
          const {
            componentOptions
          } = props;
          if (componentOptions !== void 0) return componentOptions;
          return NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedComponentPropsRef.value;
        });
        const mergedClsPrefixRef = vue.computed(() => {
          const {
            clsPrefix
          } = props;
          if (clsPrefix !== void 0) return clsPrefix;
          return NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedClsPrefixRef.value;
        });
        const mergedRtlRef = vue.computed(() => {
          const {
            rtl
          } = props;

          if (rtl === void 0) {
            return NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedRtlRef.value;
          }

          const rtlEnabledState = {};

          for (const rtlInfo of rtl) {
            var _rtlInfo$peers;

            rtlEnabledState[rtlInfo.name] = vue.markRaw(rtlInfo);
            (_rtlInfo$peers = rtlInfo.peers) === null || _rtlInfo$peers === void 0 ? void 0 : _rtlInfo$peers.forEach(peerRtlInfo => {
              if (!(peerRtlInfo.name in rtlEnabledState)) {
                rtlEnabledState[peerRtlInfo.name] = vue.markRaw(peerRtlInfo);
              }
            });
          }

          return rtlEnabledState;
        });
        const mergedBreakpointsRef = vue.computed(() => {
          return props.breakpoints || (NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedBreakpointsRef.value);
        });
        const inlineThemeDisabled = props.inlineThemeDisabled || (NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.inlineThemeDisabled);
        const preflightStyleDisabled = props.preflightStyleDisabled || (NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.preflightStyleDisabled);
        const mergedThemeHashRef = vue.computed(() => {
          const {
            value: theme
          } = mergedThemeRef;
          const {
            value: mergedThemeOverrides
          } = mergedThemeOverridesRef;
          const hasThemeOverrides = mergedThemeOverrides && Object.keys(mergedThemeOverrides).length !== 0;
          const themeName = theme === null || theme === void 0 ? void 0 : theme.name;

          if (themeName) {
            if (hasThemeOverrides) {
              return `${themeName}-${murmur2(JSON.stringify(mergedThemeOverridesRef.value))}`;
            }

            return themeName;
          } else {
            if (hasThemeOverrides) {
              return murmur2(JSON.stringify(mergedThemeOverridesRef.value));
            }

            return "";
          }
        });
        vue.provide(configProviderInjectionKey, {
          mergedThemeHashRef,
          mergedBreakpointsRef,
          mergedRtlRef,
          mergedIconsRef,
          mergedComponentPropsRef,
          mergedBorderedRef,
          mergedNamespaceRef,
          mergedClsPrefixRef,
          mergedLocaleRef: vue.computed(() => {
            const {
              locale
            } = props;
            if (locale === null) return void 0;
            return locale === void 0 ? NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedLocaleRef.value : locale;
          }),
          mergedDateLocaleRef: vue.computed(() => {
            const {
              dateLocale
            } = props;
            if (dateLocale === null) return void 0;
            return dateLocale === void 0 ? NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedDateLocaleRef.value : dateLocale;
          }),
          mergedHljsRef: vue.computed(() => {
            const {
              hljs
            } = props;
            return hljs === void 0 ? NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedHljsRef.value : hljs;
          }),
          mergedThemeRef,
          mergedThemeOverridesRef,
          inlineThemeDisabled: inlineThemeDisabled || false,
          preflightStyleDisabled: preflightStyleDisabled || false
        });
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          mergedBordered: mergedBorderedRef,
          mergedNamespace: mergedNamespaceRef,
          mergedTheme: mergedThemeRef,
          mergedThemeOverrides: mergedThemeOverridesRef
        };
      },

      render() {
        var _this$$slots$default, _this$$slots, _this$$slots$default2, _this$$slots2;

        return !this.abstract ? vue.h(this.as || this.tag, {
          class: `${this.mergedClsPrefix || defaultClsPrefix}-config-provider`
        }, (_this$$slots$default = (_this$$slots = this.$slots).default) === null || _this$$slots$default === void 0 ? void 0 : _this$$slots$default.call(_this$$slots)) : (_this$$slots$default2 = (_this$$slots2 = this.$slots).default) === null || _this$$slots$default2 === void 0 ? void 0 : _this$$slots$default2.call(_this$$slots2);
      }

    });

    const countdownProps = {
      duration: {
        type: Number,
        default: 0
      },
      active: {
        type: Boolean,
        default: true
      },
      precision: {
        type: Number,
        default: 0
      },
      render: Function,
      onFinish: Function
    };
    var Countdown = vue.defineComponent({
      name: "Countdown",
      props: countdownProps,
      setup(props) {
        let timerId = null;
        let elapsed = 0;
        let finished = false;
        const distanceRef = vue.ref(0);
        vue.watchEffect(() => {
          distanceRef.value = props.duration;
        });
        let pnow = -1;
        function getDistance(time) {
          return props.duration - elapsed + pnow - time;
        }
        function getTimeInfo(distance) {
          const hours = Math.floor(distance / 36e5);
          const minutes = Math.floor(distance % 36e5 / 6e4);
          const seconds = Math.floor(distance % 6e4 / 1e3);
          const milliseconds = Math.floor(distance % 1e3);
          return {
            hours,
            minutes,
            seconds,
            milliseconds
          };
        }
        function getDisplayValue(info) {
          const { hours, minutes, seconds, milliseconds } = info;
          const { precision } = props;
          switch (precision) {
            case 0:
              return `${String(hours).padStart(2, "0")}:${String(minutes).padStart(
            2,
            "0"
          )}:${String(seconds).padStart(2, "0")}`;
            default:
              return `${String(hours).padStart(2, "0")}:${String(minutes).padStart(
            2,
            "0"
          )}:${String(seconds).padStart(2, "0")}.${String(
            Math.floor(
              milliseconds / (precision === 1 ? 100 : precision === 2 ? 10 : 1)
            )
          ).padStart(precision, "0")}`;
          }
        }
        const frame = () => {
          const { precision } = props;
          const distance = getDistance(performance.now());
          if (distance <= 0) {
            distanceRef.value = 0;
            stopTimer();
            if (!finished) {
              finished = true;
              props.onFinish?.();
            }
            return;
          }
          let leftTime;
          switch (precision) {
            case 3:
            case 2:
              leftTime = distance % 34;
              break;
            case 1:
              leftTime = distance % 100;
              break;
            default:
              leftTime = distance % 1e3;
          }
          distanceRef.value = distance;
          timerId = window.setTimeout(() => {
            frame();
          }, leftTime);
        };
        const stopTimer = () => {
          if (timerId !== null) {
            window.clearTimeout(timerId);
            timerId = null;
          }
        };
        vue.onMounted(() => {
          vue.watchEffect(() => {
            if (props.active) {
              pnow = performance.now();
              frame();
            } else {
              const now = performance.now();
              if (pnow !== -1) {
                elapsed += now - pnow;
              }
              stopTimer();
            }
          });
        });
        vue.onBeforeUnmount(() => {
          stopTimer();
        });
        function reset() {
          distanceRef.value = props.duration;
          elapsed = 0;
          pnow = performance.now();
          if (props.active && finished) {
            frame();
          }
          finished = false;
        }
        const countdownExposedMethod = {
          reset
        };
        return Object.assign(countdownExposedMethod, {
          distance: distanceRef,
          getTimeInfo,
          getDisplayValue
        });
      },
      render() {
        const { render, precision, distance, getTimeInfo, getDisplayValue } = this;
        let timeInfo;
        switch (precision) {
          case 0:
            timeInfo = getTimeInfo(distance + 999);
            timeInfo.milliseconds = 0;
            break;
          case 1:
            timeInfo = getTimeInfo(distance + 99);
            timeInfo.milliseconds = Math.floor(timeInfo.milliseconds / 100) * 100;
            break;
          case 2:
            timeInfo = getTimeInfo(distance + 9);
            timeInfo.milliseconds = Math.floor(timeInfo.milliseconds / 10) * 10;
            break;
          case 3:
            timeInfo = getTimeInfo(distance);
        }
        if (render) {
          return render(timeInfo);
        } else {
          return getDisplayValue(timeInfo);
        }
      }
    });

    const easeOut = t => 1 - Math.pow(1 - t, 5);

    function tween(props) {
      const {
        from,
        to,
        duration,
        onUpdate,
        onFinish
      } = props;

      const tick = () => {
        const current = performance.now();
        const elapsedTime = Math.min(current - startTime, duration);
        const currentValue = from + (to - from) * easeOut(elapsedTime / duration);

        if (elapsedTime === duration) {
          onFinish();
          return;
        }

        onUpdate(currentValue);
        requestAnimationFrame(tick);
      };

      const startTime = performance.now();
      tick();
    }

    const numberAnimationProps = {
      to: {
        type: Number,
        default: 0
      },
      precision: {
        type: Number,
        default: 0
      },
      showSeparator: Boolean,
      locale: String,
      from: { type: Number, default: 0 },
      active: {
        type: Boolean,
        default: true
      },
      duration: {
        type: Number,
        default: 2e3
      },
      onFinish: Function
    };
    var NumberAnimation = vue.defineComponent({
      name: "NumberAnimation",
      props: numberAnimationProps,
      setup(props) {
        const { localeRef } = useLocale("name");
        const { duration } = props;
        const displayedValueRef = vue.ref(props.from);
        const mergedLocaleRef = vue.computed(() => {
          const { locale } = props;
          if (locale !== void 0)
            return locale;
          return localeRef.value;
        });
        let animating = false;
        const onUpdate = (currentValue) => {
          displayedValueRef.value = currentValue;
        };
        const onFinish = () => {
          displayedValueRef.value = props.to;
          animating = false;
          props.onFinish?.();
        };
        const animate = (from = props.from, to = props.to) => {
          animating = true;
          displayedValueRef.value = props.from;
          if (from !== to) {
            tween({
              from,
              to,
              duration,
              onUpdate,
              onFinish
            });
          }
        };
        const formattedValueRef = vue.computed(() => {
          const formatted = lodash.exports.round(
            displayedValueRef.value,
            props.precision
          ).toFixed(props.precision);
          const splitValue = formatted.split(".");
          const numberFormatter = new Intl.NumberFormat(mergedLocaleRef.value);
          const decimalSeparator = numberFormatter.formatToParts(0.5).find((part) => part.type === "decimal")?.value;
          const integer = props.showSeparator ? numberFormatter.format(Number(splitValue[0])) : splitValue[0];
          const decimal = splitValue[1];
          return {
            integer,
            decimal,
            decimalSeparator
          };
        });
        function play() {
          if (animating)
            return;
          animate();
        }
        vue.onMounted(() => {
          vue.watchEffect(() => {
            if (props.active)
              animate();
          });
        });
        const exposedMethods = { play };
        return {
          formattedValue: formattedValueRef,
          ...exposedMethods
        };
      },
      render() {
        const {
          formattedValue: { integer, decimal, decimalSeparator }
        } = this;
        return [integer, decimal ? decimalSeparator : null, decimal];
      }
    });

    const popselect = {
      name: "Popselect",
      common: commonDark,
      peers: {
        Popover: popoverDark$1,
        InternalSelectMenu: internalSelectMenuDark$1
      }
    };
    var popselectDark = popselect;

    function self$P(vars) {
      const {
        boxShadow2
      } = vars;
      return {
        menuBoxShadow: boxShadow2
      };
    }
    const popselectLight = createTheme$1({
      name: "Popselect",
      common: commonLight,
      peers: {
        Popover: popoverLight$1,
        InternalSelectMenu: internalSelectMenuLight$1
      },
      self: self$P
    });
    var popselectLight$1 = popselectLight;

    const popselectInjectionKey = createInjectionKey("n-popselect");

    var style$$ = cB("popselect-menu", `
  box-shadow: var(--n-menu-box-shadow);
`);

    const panelProps$1 = {
      multiple: Boolean,
      value: {
        type: [String, Number, Array],
        default: null
      },
      cancelable: Boolean,
      options: {
        type: Array,
        default: () => []
      },
      size: {
        type: String,
        default: "medium"
      },
      scrollable: Boolean,
      "onUpdate:value": [Function, Array],
      onUpdateValue: [Function, Array],
      onMouseenter: Function,
      onMouseleave: Function,
      renderLabel: Function,
      internalShowCheckmark: {
        type: Boolean,
        default: void 0
      },
      nodeProps: Function,
      virtualScroll: Boolean,
      onChange: [Function, Array]
    };
    const panelPropKeys$1 = keysOf(panelProps$1);
    var NPopselectPanel = vue.defineComponent({
      name: "PopselectPanel",
      props: panelProps$1,
      setup(props) {
        {
          vue.watchEffect(() => {
            if (props.onChange !== void 0) {
              warn$2(
                "popselect",
                "`on-change` is deprecated, please use `on-update:value` instead."
              );
            }
          });
        }
        const NPopselect = vue.inject(popselectInjectionKey);
        const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
        const themeRef = useTheme(
          "Popselect",
          "-pop-select",
          style$$,
          popselectLight$1,
          NPopselect.props,
          mergedClsPrefixRef
        );
        const treeMateRef = vue.computed(() => {
          return createTreeMate(props.options, createTmOptions("value", "children"));
        });
        function doUpdateValue(value, option) {
          const {
            onUpdateValue,
            "onUpdate:value": _onUpdateValue,
            onChange
          } = props;
          if (onUpdateValue)
            call(onUpdateValue, value, option);
          if (_onUpdateValue) {
            call(_onUpdateValue, value, option);
          }
          if (onChange)
            call(onChange, value, option);
        }
        function handleToggle(tmNode) {
          toggle(tmNode.key);
        }
        function handleMenuMousedown(e) {
          if (!happensIn(e, "action"))
            e.preventDefault();
        }
        function toggle(value) {
          const {
            value: { getNode }
          } = treeMateRef;
          if (props.multiple) {
            if (Array.isArray(props.value)) {
              const newValue = [];
              const newOptions = [];
              let shouldAddValue = true;
              props.value.forEach((v) => {
                if (v === value) {
                  shouldAddValue = false;
                  return;
                }
                const tmNode = getNode(v);
                if (tmNode) {
                  newValue.push(tmNode.key);
                  newOptions.push(tmNode.rawNode);
                }
              });
              if (shouldAddValue) {
                newValue.push(value);
                newOptions.push(getNode(value).rawNode);
              }
              doUpdateValue(newValue, newOptions);
            } else {
              const tmNode = getNode(value);
              if (tmNode) {
                doUpdateValue([value], [tmNode.rawNode]);
              }
            }
          } else {
            if (props.value === value && props.cancelable) {
              doUpdateValue(null, null);
            } else {
              const tmNode = getNode(value);
              if (tmNode) {
                doUpdateValue(value, tmNode.rawNode);
              }
              const { "onUpdate:show": _onUpdateShow, onUpdateShow } = NPopselect.props;
              if (_onUpdateShow)
                call(_onUpdateShow, false);
              if (onUpdateShow)
                call(onUpdateShow, false);
              NPopselect.setShow(false);
            }
          }
          void vue.nextTick(() => {
            NPopselect.syncPosition();
          });
        }
        vue.watch(vue.toRef(props, "options"), () => {
          void vue.nextTick(() => {
            NPopselect.syncPosition();
          });
        });
        const cssVarsRef = vue.computed(() => {
          const {
            self: { menuBoxShadow }
          } = themeRef.value;
          return {
            "--n-menu-box-shadow": menuBoxShadow
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("select", void 0, cssVarsRef, NPopselect.props) : void 0;
        return {
          mergedTheme: NPopselect.mergedThemeRef,
          mergedClsPrefix: mergedClsPrefixRef,
          treeMate: treeMateRef,
          handleToggle,
          handleMenuMousedown,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender
        };
      },
      render() {
        this.onRender?.();
        return /* @__PURE__ */ vue.h(NInternalSelectMenu, {
          clsPrefix: this.mergedClsPrefix,
          focusable: true,
          nodeProps: this.nodeProps,
          class: [`${this.mergedClsPrefix}-popselect-menu`, this.themeClass],
          style: this.cssVars,
          theme: this.mergedTheme.peers.InternalSelectMenu,
          themeOverrides: this.mergedTheme.peerOverrides.InternalSelectMenu,
          multiple: this.multiple,
          treeMate: this.treeMate,
          size: this.size,
          value: this.value,
          virtualScroll: this.virtualScroll,
          scrollable: this.scrollable,
          renderLabel: this.renderLabel,
          onToggle: this.handleToggle,
          onMouseenter: this.onMouseenter,
          onMouseleave: this.onMouseenter,
          onMousedown: this.handleMenuMousedown,
          showCheckmark: this.internalShowCheckmark
        }, {
          action: () => this.$slots.action?.() || [],
          empty: () => this.$slots.empty?.() || []
        });
      }
    });

    const popselectProps = {
      ...useTheme.props,
      ...omit(popoverBaseProps, ["showArrow", "arrow"]),
      placement: {
        ...popoverBaseProps.placement,
        default: "bottom"
      },
      trigger: {
        type: String,
        default: "hover"
      },
      ...panelProps$1
    };
    var NPopselect = vue.defineComponent({
      name: "Popselect",
      props: popselectProps,
      inheritAttrs: false,
      __popover__: true,
      setup(props) {
        const themeRef = useTheme(
          "Popselect",
          "-popselect",
          void 0,
          popselectLight$1,
          props
        );
        const popoverInstRef = vue.ref(null);
        function syncPosition() {
          popoverInstRef.value?.syncPosition();
        }
        function setShow(value) {
          popoverInstRef.value?.setShow(value);
        }
        vue.provide(popselectInjectionKey, {
          props,
          mergedThemeRef: themeRef,
          syncPosition,
          setShow
        });
        const exposedMethods = {
          syncPosition,
          setShow
        };
        return {
          ...exposedMethods,
          popoverInstRef,
          mergedTheme: themeRef
        };
      },
      render() {
        const { mergedTheme } = this;
        const popoverProps = {
          theme: mergedTheme.peers.Popover,
          themeOverrides: mergedTheme.peerOverrides.Popover,
          builtinThemeOverrides: {
            padding: "0"
          },
          ref: "popoverInstRef",
          internalRenderBody: (className, ref2, style, onMouseenter, onMouseleave) => {
            const { $attrs } = this;
            return /* @__PURE__ */ vue.h(NPopselectPanel, {
              ...$attrs,
              class: [$attrs.class, className],
              style: [$attrs.style, style],
              ...keep(this.$props, panelPropKeys$1),
              ref: createRefSetter(ref2),
              onMouseenter: mergeEventHandlers([
                onMouseenter,
                $attrs.onMouseenter
              ]),
              onMouseleave: mergeEventHandlers([
                onMouseleave,
                $attrs.onMouseleave
              ])
            }, {
              action: () => this.$slots.action?.(),
              empty: () => this.$slots.empty?.()
            });
          }
        };
        return /* @__PURE__ */ vue.h(NPopover, {
          ...omit(this.$props, panelPropKeys$1),
          ...popoverProps,
          internalDeactivateImmediately: true
        }, {
          trigger: () => this.$slots.default?.()
        });
      }
    });

    function self$O(vars) {
      const {
        boxShadow2
      } = vars;
      return {
        menuBoxShadow: boxShadow2
      };
    }
    const selectLight = createTheme$1({
      name: "Select",
      common: commonLight,
      peers: {
        InternalSelection: internalSelectionLight$1,
        InternalSelectMenu: internalSelectMenuLight$1
      },
      self: self$O
    });
    var selectLight$1 = selectLight;

    const selectDark = {
      name: "Select",
      common: commonDark,
      peers: {
        InternalSelection: internalSelectionDark$1,
        InternalSelectMenu: internalSelectMenuDark$1
      },
      self: self$O
    };
    var selectDark$1 = selectDark;

    var style$_ = c$1([cB("select", `
    z-index: auto;
    outline: none;
    width: 100%;
    position: relative;
  `), cB("select-menu", `
    margin: 4px 0;
    box-shadow: var(--n-menu-box-shadow);
  `, [fadeInScaleUpTransition({
      originalTransition: "background-color .3s var(--n-bezier), box-shadow .3s var(--n-bezier)"
    })])]);

    const selectProps = {
      ...useTheme.props,
      to: useAdjustedTo.propTo,
      bordered: {
        type: Boolean,
        default: void 0
      },
      clearable: Boolean,
      clearFilterAfterSelect: {
        type: Boolean,
        default: true
      },
      options: {
        type: Array,
        default: () => []
      },
      defaultValue: {
        type: [String, Number, Array],
        default: null
      },
      value: [String, Number, Array],
      placeholder: String,
      menuProps: Object,
      multiple: Boolean,
      size: String,
      filterable: Boolean,
      disabled: {
        type: Boolean,
        default: void 0
      },
      remote: Boolean,
      loading: Boolean,
      filter: Function,
      placement: {
        type: String,
        default: "bottom-start"
      },
      widthMode: {
        type: String,
        default: "trigger"
      },
      tag: Boolean,
      onCreate: Function,
      fallbackOption: {
        type: [Function, Boolean],
        default: void 0
      },
      show: {
        type: Boolean,
        default: void 0
      },
      showArrow: {
        type: Boolean,
        default: true
      },
      maxTagCount: [Number, String],
      consistentMenuWidth: {
        type: Boolean,
        default: true
      },
      virtualScroll: {
        type: Boolean,
        default: true
      },
      labelField: {
        type: String,
        default: "label"
      },
      valueField: {
        type: String,
        default: "value"
      },
      childrenField: {
        type: String,
        default: "children"
      },
      renderLabel: Function,
      renderOption: Function,
      renderTag: Function,
      "onUpdate:value": [Function, Array],
      inputProps: Object,
      nodeProps: Function,
      onUpdateValue: [Function, Array],
      onBlur: [Function, Array],
      onClear: [Function, Array],
      onFocus: [Function, Array],
      onScroll: [Function, Array],
      onSearch: [Function, Array],
      onUpdateShow: [Function, Array],
      "onUpdate:show": [Function, Array],
      displayDirective: {
        type: String,
        default: "show"
      },
      resetMenuOnOptionsChange: {
        type: Boolean,
        default: true
      },
      status: String,
      internalShowCheckmark: {
        type: Boolean,
        default: true
      },
      onChange: [Function, Array],
      items: Array
    };
    var NSelect = vue.defineComponent({
      name: "Select",
      props: selectProps,
      setup(props) {
        {
          vue.watchEffect(() => {
            if (props.items !== void 0) {
              warnOnce(
                "select",
                "`items` is deprecated, please use `options` instead."
              );
            }
            if (props.onChange !== void 0) {
              warnOnce(
                "select",
                "`on-change` is deprecated, please use `on-update:value` instead."
              );
            }
          });
        }
        const {
          mergedClsPrefixRef,
          mergedBorderedRef,
          namespaceRef,
          inlineThemeDisabled
        } = useConfig(props);
        const themeRef = useTheme(
          "Select",
          "-select",
          style$_,
          selectLight$1,
          props,
          mergedClsPrefixRef
        );
        const uncontrolledValueRef = vue.ref(props.defaultValue);
        const controlledValueRef = vue.toRef(props, "value");
        const mergedValueRef = useMergedState(
          controlledValueRef,
          uncontrolledValueRef
        );
        const focusedRef = vue.ref(false);
        const patternRef = vue.ref("");
        const treeMateRef = vue.computed(() => {
          const { valueField, childrenField } = props;
          const options = createTmOptions(valueField, childrenField);
          return createTreeMate(filteredOptionsRef.value, options);
        });
        const valOptMapRef = vue.computed(
          () => createValOptMap(
            localOptionsRef.value,
            props.valueField,
            props.childrenField
          )
        );
        const uncontrolledShowRef = vue.ref(false);
        const mergedShowRef = useMergedState(
          vue.toRef(props, "show"),
          uncontrolledShowRef
        );
        const triggerRef = vue.ref(null);
        const followerRef = vue.ref(null);
        const menuRef = vue.ref(null);
        const { localeRef } = useLocale("Select");
        const localizedPlaceholderRef = vue.computed(() => {
          return props.placeholder ?? localeRef.value.placeholder;
        });
        const compitableOptionsRef = useCompitable(props, ["items", "options"]);
        const emptyArray = [];
        const createdOptionsRef = vue.ref([]);
        const beingCreatedOptionsRef = vue.ref([]);
        const memoValOptMapRef = vue.ref(/* @__PURE__ */ new Map());
        const wrappedFallbackOptionRef = vue.computed(() => {
          const { fallbackOption } = props;
          if (fallbackOption === void 0) {
            const { labelField, valueField } = props;
            return (value) => ({
              [labelField]: String(value),
              [valueField]: value
            });
          }
          if (fallbackOption === false)
            return false;
          return (value) => {
            return Object.assign(
              fallbackOption(value),
              {
                value
              }
            );
          };
        });
        const localOptionsRef = vue.computed(() => {
          return beingCreatedOptionsRef.value.concat(
            createdOptionsRef.value
          ).concat(compitableOptionsRef.value);
        });
        const resolvedFilterRef = vue.computed(() => {
          const { filter } = props;
          if (filter)
            return filter;
          const { labelField, valueField } = props;
          return (pattern, option) => {
            if (!option)
              return false;
            const label = option[labelField];
            if (typeof label === "string") {
              return patternMatched(pattern, label);
            }
            const value = option[valueField];
            if (typeof value === "string") {
              return patternMatched(pattern, value);
            }
            if (typeof value === "number") {
              return patternMatched(pattern, String(value));
            }
            return false;
          };
        });
        const filteredOptionsRef = vue.computed(() => {
          if (props.remote) {
            return compitableOptionsRef.value;
          } else {
            const { value: localOptions } = localOptionsRef;
            const { value: pattern } = patternRef;
            if (!pattern.length || !props.filterable) {
              return localOptions;
            } else {
              return filterOptions(
                localOptions,
                resolvedFilterRef.value,
                pattern,
                props.childrenField
              );
            }
          }
        });
        function getMergedOptions(values) {
          const remote = props.remote;
          const { value: memoValOptMap } = memoValOptMapRef;
          const { value: valOptMap } = valOptMapRef;
          const { value: wrappedFallbackOption } = wrappedFallbackOptionRef;
          const options = [];
          values.forEach((value) => {
            if (valOptMap.has(value)) {
              options.push(valOptMap.get(value));
            } else if (remote && memoValOptMap.has(value)) {
              options.push(memoValOptMap.get(value));
            } else if (wrappedFallbackOption) {
              const option = wrappedFallbackOption(value);
              if (option) {
                options.push(option);
              }
            }
          });
          return options;
        }
        const selectedOptionsRef = vue.computed(() => {
          if (props.multiple) {
            const { value: values } = mergedValueRef;
            if (!Array.isArray(values))
              return [];
            return getMergedOptions(values);
          }
          return null;
        });
        const selectedOptionRef = vue.computed(() => {
          const { value: mergedValue } = mergedValueRef;
          if (!props.multiple && !Array.isArray(mergedValue)) {
            if (mergedValue === null)
              return null;
            return getMergedOptions([mergedValue])[0] || null;
          }
          return null;
        });
        const formItem = useFormItem(props);
        const { mergedSizeRef, mergedDisabledRef, mergedStatusRef } = formItem;
        function doUpdateValue(value, option) {
          const {
            onChange,
            "onUpdate:value": _onUpdateValue,
            onUpdateValue
          } = props;
          const { nTriggerFormChange, nTriggerFormInput } = formItem;
          if (onChange)
            call(onChange, value, option);
          if (onUpdateValue)
            call(onUpdateValue, value, option);
          if (_onUpdateValue) {
            call(_onUpdateValue, value, option);
          }
          uncontrolledValueRef.value = value;
          nTriggerFormChange();
          nTriggerFormInput();
        }
        function doBlur(e) {
          const { onBlur } = props;
          const { nTriggerFormBlur } = formItem;
          if (onBlur)
            call(onBlur, e);
          nTriggerFormBlur();
        }
        function doClear() {
          const { onClear } = props;
          if (onClear)
            call(onClear);
        }
        function doFocus(e) {
          const { onFocus } = props;
          const { nTriggerFormFocus } = formItem;
          if (onFocus)
            call(onFocus, e);
          nTriggerFormFocus();
        }
        function doSearch(value) {
          const { onSearch } = props;
          if (onSearch)
            call(onSearch, value);
        }
        function doScroll(e) {
          const { onScroll } = props;
          if (onScroll)
            call(onScroll, e);
        }
        function updateMemorizedOptions() {
          const { remote, multiple } = props;
          if (remote) {
            const { value: memoValOptMap } = memoValOptMapRef;
            if (multiple) {
              const { valueField } = props;
              selectedOptionsRef.value?.forEach((option) => {
                memoValOptMap.set(
                  option[valueField],
                  option
                );
              });
            } else {
              const option = selectedOptionRef.value;
              if (option) {
                memoValOptMap.set(
                  option[props.valueField],
                  option
                );
              }
            }
          }
        }
        function doUpdateShow(value) {
          const { onUpdateShow, "onUpdate:show": _onUpdateShow } = props;
          if (onUpdateShow)
            call(onUpdateShow, value);
          if (_onUpdateShow)
            call(_onUpdateShow, value);
          uncontrolledShowRef.value = value;
        }
        function openMenu() {
          if (!mergedDisabledRef.value) {
            doUpdateShow(true);
            uncontrolledShowRef.value = true;
            if (props.filterable) {
              focusSelectionInput();
            }
          }
        }
        function closeMenu() {
          doUpdateShow(false);
        }
        function handleMenuAfterLeave() {
          patternRef.value = "";
          beingCreatedOptionsRef.value = emptyArray;
        }
        const activeWithoutMenuOpenRef = vue.ref(false);
        function onTriggerInputFocus() {
          if (props.filterable) {
            activeWithoutMenuOpenRef.value = true;
          }
        }
        function onTriggerInputBlur() {
          if (props.filterable) {
            activeWithoutMenuOpenRef.value = false;
            if (!mergedShowRef.value) {
              handleMenuAfterLeave();
            }
          }
        }
        function handleTriggerClick() {
          if (mergedDisabledRef.value)
            return;
          if (!mergedShowRef.value) {
            openMenu();
          } else {
            if (!props.filterable) {
              closeMenu();
            } else {
              focusSelectionInput();
            }
          }
        }
        function handleTriggerBlur(e) {
          if (menuRef.value?.selfRef?.contains(e.relatedTarget)) {
            return;
          }
          focusedRef.value = false;
          doBlur(e);
          closeMenu();
        }
        function handleTriggerFocus(e) {
          doFocus(e);
          focusedRef.value = true;
        }
        function handleMenuFocus(e) {
          focusedRef.value = true;
        }
        function handleMenuBlur(e) {
          if (triggerRef.value?.$el.contains(e.relatedTarget))
            return;
          focusedRef.value = false;
          doBlur(e);
          closeMenu();
        }
        function handleMenuTabOut() {
          triggerRef.value?.focus();
          closeMenu();
        }
        function handleMenuClickOutside(e) {
          if (mergedShowRef.value) {
            if (!triggerRef.value?.$el.contains(
              getPreciseEventTarget(e)
            )) {
              closeMenu();
            }
          }
        }
        function createClearedMultipleSelectValue(value) {
          if (!Array.isArray(value))
            return [];
          if (wrappedFallbackOptionRef.value) {
            return Array.from(value);
          } else {
            const { remote } = props;
            const { value: valOptMap } = valOptMapRef;
            if (remote) {
              const { value: memoValOptMap } = memoValOptMapRef;
              return value.filter((v) => valOptMap.has(v) || memoValOptMap.has(v));
            } else {
              return value.filter((v) => valOptMap.has(v));
            }
          }
        }
        function handleToggleByTmNode(tmNode) {
          handleToggleByOption(tmNode.rawNode);
        }
        function handleToggleByOption(option) {
          if (mergedDisabledRef.value)
            return;
          const { tag, remote, clearFilterAfterSelect, valueField } = props;
          if (tag && !remote) {
            const { value: beingCreatedOptions } = beingCreatedOptionsRef;
            const beingCreatedOption = beingCreatedOptions[0] || null;
            if (beingCreatedOption) {
              const createdOptions = createdOptionsRef.value;
              if (!createdOptions.length) {
                createdOptionsRef.value = [beingCreatedOption];
              } else {
                createdOptions.push(beingCreatedOption);
              }
              beingCreatedOptionsRef.value = emptyArray;
            }
          }
          if (remote) {
            memoValOptMapRef.value.set(
              option[valueField],
              option
            );
          }
          if (props.multiple) {
            const changedValue = createClearedMultipleSelectValue(
              mergedValueRef.value
            );
            const index = changedValue.findIndex(
              (value) => value === option[valueField]
            );
            if (~index) {
              changedValue.splice(index, 1);
              if (tag && !remote) {
                const createdOptionIndex = getCreatedOptionIndex(
                  option[valueField]
                );
                if (~createdOptionIndex) {
                  createdOptionsRef.value.splice(createdOptionIndex, 1);
                  if (clearFilterAfterSelect)
                    patternRef.value = "";
                }
              }
            } else {
              changedValue.push(
                option[valueField]
              );
              if (clearFilterAfterSelect)
                patternRef.value = "";
            }
            doUpdateValue(changedValue, getMergedOptions(changedValue));
          } else {
            if (tag && !remote) {
              const createdOptionIndex = getCreatedOptionIndex(
                option[valueField]
              );
              if (~createdOptionIndex) {
                createdOptionsRef.value = [
                  createdOptionsRef.value[createdOptionIndex]
                ];
              } else {
                createdOptionsRef.value = emptyArray;
              }
            }
            focusSelection();
            closeMenu();
            doUpdateValue(
              option[valueField],
              option
            );
          }
        }
        function getCreatedOptionIndex(optionValue) {
          const createdOptions = createdOptionsRef.value;
          return createdOptions.findIndex(
            (createdOption) => createdOption[props.valueField] === optionValue
          );
        }
        function handlePatternInput(e) {
          if (!mergedShowRef.value) {
            openMenu();
          }
          const { value } = e.target;
          patternRef.value = value;
          const { tag, remote } = props;
          doSearch(value);
          if (tag && !remote) {
            if (!value) {
              beingCreatedOptionsRef.value = emptyArray;
              return;
            }
            const { onCreate } = props;
            const optionBeingCreated = onCreate ? onCreate(value) : { [props.labelField]: value, [props.valueField]: value };
            const { valueField } = props;
            if (compitableOptionsRef.value.some(
              (option) => option[valueField] === optionBeingCreated[valueField]
            ) || createdOptionsRef.value.some(
              (option) => option[valueField] === optionBeingCreated[valueField]
            )) {
              beingCreatedOptionsRef.value = emptyArray;
            } else {
              beingCreatedOptionsRef.value = [optionBeingCreated];
            }
          }
        }
        function handleClear(e) {
          e.stopPropagation();
          const { multiple } = props;
          if (!multiple && props.filterable) {
            closeMenu();
          }
          doClear();
          if (multiple) {
            doUpdateValue([], []);
          } else {
            doUpdateValue(null, null);
          }
        }
        function handleMenuMousedown(e) {
          if (!happensIn(e, "action") && !happensIn(e, "empty"))
            e.preventDefault();
        }
        function handleMenuScroll(e) {
          doScroll(e);
        }
        function handleKeydown(e) {
          switch (e.key) {
            case " ":
              if (props.filterable)
                break;
              else {
                e.preventDefault();
              }
            case "Enter":
              if (!triggerRef.value?.isCompositing) {
                if (mergedShowRef.value) {
                  const pendingTmNode = menuRef.value?.getPendingTmNode();
                  if (pendingTmNode) {
                    handleToggleByTmNode(pendingTmNode);
                  } else if (!props.filterable) {
                    closeMenu();
                    focusSelection();
                  }
                } else {
                  openMenu();
                  if (props.tag && activeWithoutMenuOpenRef.value) {
                    const beingCreatedOption = beingCreatedOptionsRef.value[0];
                    if (beingCreatedOption) {
                      const optionValue = beingCreatedOption[props.valueField];
                      const { value: mergedValue } = mergedValueRef;
                      if (props.multiple) {
                        if (Array.isArray(mergedValue) && mergedValue.some((value) => value === optionValue)) ; else {
                          handleToggleByOption(beingCreatedOption);
                        }
                      } else {
                        handleToggleByOption(beingCreatedOption);
                      }
                    }
                  }
                }
              }
              e.preventDefault();
              break;
            case "ArrowUp":
              e.preventDefault();
              if (props.loading)
                return;
              if (mergedShowRef.value) {
                menuRef.value?.prev();
              }
              break;
            case "ArrowDown":
              e.preventDefault();
              if (props.loading)
                return;
              if (mergedShowRef.value) {
                menuRef.value?.next();
              } else {
                openMenu();
              }
              break;
            case "Escape":
              if (mergedShowRef.value) {
                markEventEffectPerformed(e);
                closeMenu();
              }
              triggerRef.value?.focus();
              break;
          }
        }
        function focusSelection() {
          triggerRef.value?.focus();
        }
        function focusSelectionInput() {
          triggerRef.value?.focusInput();
        }
        function handleTriggerOrMenuResize() {
          if (!mergedShowRef.value)
            return;
          followerRef.value?.syncPosition();
        }
        updateMemorizedOptions();
        vue.watch(vue.toRef(props, "options"), updateMemorizedOptions);
        const exposedMethods = {
          focus: () => {
            triggerRef.value?.focus();
          },
          blur: () => {
            triggerRef.value?.blur();
          }
        };
        const cssVarsRef = vue.computed(() => {
          const {
            self: { menuBoxShadow }
          } = themeRef.value;
          return {
            "--n-menu-box-shadow": menuBoxShadow
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("select", void 0, cssVarsRef, props) : void 0;
        return {
          ...exposedMethods,
          mergedStatus: mergedStatusRef,
          mergedClsPrefix: mergedClsPrefixRef,
          mergedBordered: mergedBorderedRef,
          namespace: namespaceRef,
          treeMate: treeMateRef,
          isMounted: isMounted(),
          triggerRef,
          menuRef,
          pattern: patternRef,
          uncontrolledShow: uncontrolledShowRef,
          mergedShow: mergedShowRef,
          adjustedTo: useAdjustedTo(props),
          uncontrolledValue: uncontrolledValueRef,
          mergedValue: mergedValueRef,
          followerRef,
          localizedPlaceholder: localizedPlaceholderRef,
          selectedOption: selectedOptionRef,
          selectedOptions: selectedOptionsRef,
          mergedSize: mergedSizeRef,
          mergedDisabled: mergedDisabledRef,
          focused: focusedRef,
          activeWithoutMenuOpen: activeWithoutMenuOpenRef,
          inlineThemeDisabled,
          onTriggerInputFocus,
          onTriggerInputBlur,
          handleTriggerOrMenuResize,
          handleMenuFocus,
          handleMenuBlur,
          handleMenuTabOut,
          handleTriggerClick,
          handleToggle: handleToggleByTmNode,
          handleDeleteOption: handleToggleByOption,
          handlePatternInput,
          handleClear,
          handleTriggerBlur,
          handleTriggerFocus,
          handleKeydown,
          handleMenuAfterLeave,
          handleMenuClickOutside,
          handleMenuScroll,
          handleMenuKeydown: handleKeydown,
          handleMenuMousedown,
          mergedTheme: themeRef,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender
        };
      },
      render() {
        return /* @__PURE__ */ vue.h("div", {
          class: `${this.mergedClsPrefix}-select`
        }, /* @__PURE__ */ vue.h(VBinder, null, {
          default: () => [
            /* @__PURE__ */ vue.h(VTarget, null, {
              default: () => /* @__PURE__ */ vue.h(NInternalSelection, {
                ref: "triggerRef",
                inlineThemeDisabled: this.inlineThemeDisabled,
                status: this.mergedStatus,
                inputProps: this.inputProps,
                clsPrefix: this.mergedClsPrefix,
                showArrow: this.showArrow,
                maxTagCount: this.maxTagCount,
                bordered: this.mergedBordered,
                active: this.activeWithoutMenuOpen || this.mergedShow,
                pattern: this.pattern,
                placeholder: this.localizedPlaceholder,
                selectedOption: this.selectedOption,
                selectedOptions: this.selectedOptions,
                multiple: this.multiple,
                renderTag: this.renderTag,
                renderLabel: this.renderLabel,
                filterable: this.filterable,
                clearable: this.clearable,
                disabled: this.mergedDisabled,
                size: this.mergedSize,
                theme: this.mergedTheme.peers.InternalSelection,
                labelField: this.labelField,
                valueField: this.valueField,
                themeOverrides: this.mergedTheme.peerOverrides.InternalSelection,
                loading: this.loading,
                focused: this.focused,
                onClick: this.handleTriggerClick,
                onDeleteOption: this.handleDeleteOption,
                onPatternInput: this.handlePatternInput,
                onClear: this.handleClear,
                onBlur: this.handleTriggerBlur,
                onFocus: this.handleTriggerFocus,
                onKeydown: this.handleKeydown,
                onPatternBlur: this.onTriggerInputBlur,
                onPatternFocus: this.onTriggerInputFocus,
                onResize: this.handleTriggerOrMenuResize
              }, {
                arrow: () => [this.$slots.arrow?.()]
              })
            }),
            /* @__PURE__ */ vue.h(VFollower, {
              ref: "followerRef",
              show: this.mergedShow,
              to: this.adjustedTo,
              teleportDisabled: this.adjustedTo === useAdjustedTo.tdkey,
              containerClass: this.namespace,
              width: this.consistentMenuWidth ? "target" : void 0,
              minWidth: "target",
              placement: this.placement
            }, {
              default: () => /* @__PURE__ */ vue.h(vue.Transition, {
                name: "fade-in-scale-up-transition",
                appear: this.isMounted,
                onAfterLeave: this.handleMenuAfterLeave
              }, {
                default: () => {
                  if (!(this.mergedShow || this.displayDirective === "show")) {
                    return null;
                  }
                  this.onRender?.();
                  return vue.withDirectives(
                    /* @__PURE__ */ vue.h(NInternalSelectMenu, {
                      ...this.menuProps,
                      ref: "menuRef",
                      onResize: this.handleTriggerOrMenuResize,
                      inlineThemeDisabled: this.inlineThemeDisabled,
                      virtualScroll: this.consistentMenuWidth && this.virtualScroll,
                      class: [
                        `${this.mergedClsPrefix}-select-menu`,
                        this.themeClass,
                        this.menuProps?.class
                      ],
                      clsPrefix: this.mergedClsPrefix,
                      focusable: true,
                      labelField: this.labelField,
                      valueField: this.valueField,
                      autoPending: true,
                      nodeProps: this.nodeProps,
                      theme: this.mergedTheme.peers.InternalSelectMenu,
                      themeOverrides: this.mergedTheme.peerOverrides.InternalSelectMenu,
                      treeMate: this.treeMate,
                      multiple: this.multiple,
                      size: "medium",
                      renderOption: this.renderOption,
                      renderLabel: this.renderLabel,
                      value: this.mergedValue,
                      style: [this.menuProps?.style, this.cssVars],
                      onToggle: this.handleToggle,
                      onScroll: this.handleMenuScroll,
                      onFocus: this.handleMenuFocus,
                      onBlur: this.handleMenuBlur,
                      onKeydown: this.handleMenuKeydown,
                      onTabOut: this.handleMenuTabOut,
                      onMousedown: this.handleMenuMousedown,
                      show: this.mergedShow,
                      showCheckmark: this.internalShowCheckmark,
                      resetMenuOnOptionsChange: this.resetMenuOnOptionsChange
                    }, {
                      empty: () => [this.$slots.empty?.()],
                      action: () => [this.$slots.action?.()]
                    }),
                    this.displayDirective === "show" ? [
                      [vue.vShow, this.mergedShow],
                      [
                        clickoutside$1,
                        this.handleMenuClickOutside,
                        void 0,
                        { capture: true }
                      ]
                    ] : [
                      [
                        clickoutside$1,
                        this.handleMenuClickOutside,
                        void 0,
                        { capture: true }
                      ]
                    ]
                  );
                }
              })
            })
          ]
        }));
      }
    });

    var commonVariables$b = {
      itemPaddingSmall: "0 4px",
      itemMarginSmall: "0 0 0 8px",
      itemMarginSmallRtl: "0 8px 0 0",
      itemPaddingMedium: "0 4px",
      itemMarginMedium: "0 0 0 8px",
      itemMarginMediumRtl: "0 8px 0 0",
      itemPaddingLarge: "0 4px",
      itemMarginLarge: "0 0 0 8px",
      itemMarginLargeRtl: "0 8px 0 0",
      buttonIconSizeSmall: "14px",
      buttonIconSizeMedium: "16px",
      buttonIconSizeLarge: "18px",
      inputWidthSmall: "60px",
      selectWidthSmall: "unset",
      inputMarginSmall: "0 0 0 8px",
      inputMarginSmallRtl: "0 8px 0 0",
      selectMarginSmall: "0 0 0 8px",
      prefixMarginSmall: "0 8px 0 0",
      suffixMarginSmall: "0 0 0 8px",
      inputWidthMedium: "60px",
      selectWidthMedium: "unset",
      inputMarginMedium: "0 0 0 8px",
      inputMarginMediumRtl: "0 8px 0 0",
      selectMarginMedium: "0 0 0 8px",
      prefixMarginMedium: "0 8px 0 0",
      suffixMarginMedium: "0 0 0 8px",
      inputWidthLarge: "60px",
      selectWidthLarge: "unset",
      inputMarginLarge: "0 0 0 8px",
      inputMarginLargeRtl: "0 8px 0 0",
      selectMarginLarge: "0 0 0 8px",
      prefixMarginLarge: "0 8px 0 0",
      suffixMarginLarge: "0 0 0 8px"
    };

    const self$N = vars => {
      const {
        textColor2,
        primaryColor,
        primaryColorHover,
        primaryColorPressed,
        inputColorDisabled,
        textColorDisabled,
        borderColor,
        borderRadius,
        fontSizeTiny,
        fontSizeSmall,
        fontSizeMedium,
        heightTiny,
        heightSmall,
        heightMedium
      } = vars;
      return { ...commonVariables$b,
        buttonColor: "#0000",
        buttonColorHover: "#0000",
        buttonColorPressed: "#0000",
        buttonBorder: `1px solid ${borderColor}`,
        buttonBorderHover: `1px solid ${borderColor}`,
        buttonBorderPressed: `1px solid ${borderColor}`,
        buttonIconColor: textColor2,
        buttonIconColorHover: textColor2,
        buttonIconColorPressed: textColor2,
        itemTextColor: textColor2,
        itemTextColorHover: primaryColorHover,
        itemTextColorPressed: primaryColorPressed,
        itemTextColorActive: primaryColor,
        itemTextColorDisabled: textColorDisabled,
        itemColor: "#0000",
        itemColorHover: "#0000",
        itemColorPressed: "#0000",
        itemColorActive: "#0000",
        itemColorActiveHover: "#0000",
        itemColorDisabled: inputColorDisabled,
        itemBorder: "1px solid #0000",
        itemBorderHover: "1px solid #0000",
        itemBorderPressed: "1px solid #0000",
        itemBorderActive: `1px solid ${primaryColor}`,
        itemBorderDisabled: `1px solid ${borderColor}`,
        itemBorderRadius: borderRadius,
        itemSizeSmall: heightTiny,
        itemSizeMedium: heightSmall,
        itemSizeLarge: heightMedium,
        itemFontSizeSmall: fontSizeTiny,
        itemFontSizeMedium: fontSizeSmall,
        itemFontSizeLarge: fontSizeMedium,
        jumperFontSizeSmall: fontSizeTiny,
        jumperFontSizeMedium: fontSizeSmall,
        jumperFontSizeLarge: fontSizeMedium,
        jumperTextColor: textColor2,
        jumperTextColorDisabled: textColorDisabled
      };
    };
    const paginationLight = createTheme$1({
      name: "Pagination",
      common: commonLight,
      peers: {
        Select: selectLight$1,
        Input: inputLight$1,
        Popselect: popselectLight$1
      },
      self: self$N
    });
    var paginationLight$1 = paginationLight;

    const paginationDark = {
      name: "Pagination",
      common: commonDark,
      peers: {
        Select: selectDark$1,
        Input: inputDark$1,
        Popselect: popselectDark
      },

      self(vars) {
        const {
          primaryColor,
          opacity3
        } = vars;
        const borderColorActive = changeColor(primaryColor, {
          alpha: Number(opacity3)
        });
        const commonSelf = self$N(vars);
        commonSelf.itemBorderActive = `1px solid ${borderColorActive}`;
        commonSelf.itemBorderDisabled = "1px solid #0000";
        return commonSelf;
      }

    };
    var paginationDark$1 = paginationDark;

    var rtlStyle$g = cB("pagination", [cM("rtl", `
    direction: rtl;
  `, [c$1("> *:not(:first-child)", `
      margin: var(--n-item-margin-rtl);
    `), cB("pagination-quick-jumper", [cB("input", `
        margin: var(--n-input-margin-rtl);
      `)])])]);

    const paginationRtl = {
      name: "Pagination",
      style: rtlStyle$g,
      peers: [inputRtl]
    };

    function createPageItemsInfo(currentPage, pageCount, pageSlot) {
      let hasFastBackward = false;
      let hasFastForward = false;
      let fastBackwardTo = 1;
      let fastForwardTo = pageCount;

      if (pageCount === 1) {
        return {
          hasFastBackward: false,
          hasFastForward: false,
          fastForwardTo,
          fastBackwardTo,
          items: [{
            type: "page",
            label: 1,
            active: currentPage === 1,
            mayBeFastBackward: false,
            mayBeFastForward: false
          }]
        };
      }

      if (pageCount === 2) {
        return {
          hasFastBackward: false,
          hasFastForward: false,
          fastForwardTo,
          fastBackwardTo,
          items: [{
            type: "page",
            label: 1,
            active: currentPage === 1,
            mayBeFastBackward: false,
            mayBeFastForward: false
          }, {
            type: "page",
            label: 2,
            active: currentPage === 2,
            mayBeFastBackward: true,
            mayBeFastForward: false
          }]
        };
      }

      const firstPage = 1;
      const lastPage = pageCount;
      let middleStart = currentPage;
      let middleEnd = currentPage;
      const middleDelta = (pageSlot - 5) / 2;
      middleEnd += Math.ceil(middleDelta);
      middleEnd = Math.min(Math.max(middleEnd, firstPage + pageSlot - 3), lastPage - 2);
      middleStart -= Math.floor(middleDelta);
      middleStart = Math.max(Math.min(middleStart, lastPage - pageSlot + 3), firstPage + 2);
      let leftSplit = false;
      let rightSplit = false;
      if (middleStart > firstPage + 2) leftSplit = true;
      if (middleEnd < lastPage - 2) rightSplit = true;
      const items = [];
      items.push({
        type: "page",
        label: 1,
        active: currentPage === 1,
        mayBeFastBackward: false,
        mayBeFastForward: false
      });

      if (leftSplit) {
        hasFastBackward = true;
        fastBackwardTo = middleStart - 1;
        items.push({
          type: "fast-backward",
          active: false,
          label: void 0,
          options: createRange(firstPage + 1, middleStart - 1)
        });
      } else if (lastPage >= firstPage + 1) {
        items.push({
          type: "page",
          label: firstPage + 1,
          mayBeFastBackward: true,
          mayBeFastForward: false,
          active: currentPage === firstPage + 1
        });
      }

      for (let i = middleStart; i <= middleEnd; ++i) {
        items.push({
          type: "page",
          label: i,
          mayBeFastBackward: false,
          mayBeFastForward: false,
          active: currentPage === i
        });
      }

      if (rightSplit) {
        hasFastForward = true;
        fastForwardTo = middleEnd + 1;
        items.push({
          type: "fast-forward",
          active: false,
          label: void 0,
          options: createRange(middleEnd + 1, lastPage - 1)
        });
      } else if (middleEnd === lastPage - 2 && items[items.length - 1].label !== lastPage - 1) {
        items.push({
          type: "page",
          mayBeFastForward: true,
          mayBeFastBackward: false,
          label: lastPage - 1,
          active: currentPage === lastPage - 1
        });
      }

      if (items[items.length - 1].label !== lastPage) {
        items.push({
          type: "page",
          mayBeFastForward: false,
          mayBeFastBackward: false,
          label: lastPage,
          active: currentPage === lastPage
        });
      }

      return {
        hasFastBackward,
        hasFastForward,
        fastBackwardTo,
        fastForwardTo,
        items
      };
    }

    function createRange(from, to) {
      const range = [];

      for (let i = from; i <= to; ++i) {
        range.push({
          label: `${i}`,
          value: i
        });
      }

      return range;
    }

    const hoverStyleProps = `
  background: var(--n-item-color-hover);
  color: var(--n-item-text-color-hover);
  border: var(--n-item-border-hover);
`;
    const hoverStyleChildren$1 = [cM("button", `
    background: var(--n-button-color-hover);
    border: var(--n-button-border-hover);
    color: var(--n-button-icon-color-hover);
  `)];
    var style$Z = cB("pagination", `
  display: flex;
  vertical-align: middle;
  font-size: var(--n-item-font-size);
  flex-wrap: nowrap;
`, [cB("pagination-prefix", `
    display: flex;
    align-items: center;
    margin: var(--n-prefix-margin);
  `), cB("pagination-suffix", `
    display: flex;
    align-items: center;
    margin: var(--n-suffix-margin);
  `), c$1("> *:not(:first-child)", `
    margin: var(--n-item-margin);
  `), cB("select", `
    width: var(--n-select-width);
  `), c$1("&.transition-disabled", [cB("pagination-item", "transition: none!important;")]), cB("pagination-quick-jumper", `
    white-space: nowrap;
    display: flex;
    color: var(--n-jumper-text-color);
    transition: color .3s var(--n-bezier);
    align-items: center;
    font-size: var(--n-jumper-font-size);
  `, [cB("input", `
      margin: var(--n-input-margin);
      width: var(--n-input-width);
    `)]), cB("pagination-item", `
    position: relative;
    cursor: pointer;
    user-select: none;
    -webkit-user-select: none;
    display: flex;
    align-items: center;
    justify-content: center;
    box-sizing: border-box;
    min-width: var(--n-item-size);
    height: var(--n-item-size);
    padding: var(--n-item-padding);
    background-color: var(--n-item-color);
    color: var(--n-item-text-color);
    border-radius: var(--n-item-border-radius);
    border: var(--n-item-border);
    fill: var(--n-button-icon-color);
    transition:
      color .3s var(--n-bezier),
      border-color .3s var(--n-bezier),
      background-color .3s var(--n-bezier),
      fill .3s var(--n-bezier);
  `, [cM("button", `
      background: var(--n-button-color);
      color: var(--n-button-icon-color);
      border: var(--n-button-border);
      padding: 0;
    `, [cB("base-icon", `
        font-size: var(--n-button-icon-size);
      `)]), cNotM("disabled", [cM("hover", hoverStyleProps, hoverStyleChildren$1), c$1("&:hover", hoverStyleProps, hoverStyleChildren$1), c$1("&:active", `
        background: var(--n-item-color-pressed);
        color: var(--n-item-text-color-pressed);
        border: var(--n-item-border-pressed);
      `, [cM("button", `
          background: var(--n-button-color-pressed);
          border: var(--n-button-border-pressed);
          color: var(--n-button-icon-color-pressed);
        `)]), cM("active", `
        background: var(--n-item-color-active);
        color: var(--n-item-text-color-active);
        border: var(--n-item-border-active);
      `, [c$1("&:hover", `
          background: var(--n-item-color-active-hover);
        `)])]), cM("disabled", `
      cursor: not-allowed;
      color: var(--n-item-text-color-disabled);
    `, [cM("active, button", `
        background-color: var(--n-item-color-disabled);
        border: var(--n-item-border-disabled);
      `)])]), cM("disabled", `
    cursor: not-allowed;
  `, [cB("pagination-quick-jumper", `
      color: var(--n-jumper-text-color-disabled);
    `)]), cM("simple", `
    display: flex;
    align-items: center;
    flex-wrap: nowrap;
  `, [cB("pagination-quick-jumper", [cB("input", `
        margin: 0;
      `)])])]);

    const paginationProps = {
      ...useTheme.props,
      simple: Boolean,
      page: Number,
      defaultPage: {
        type: Number,
        default: 1
      },
      itemCount: Number,
      pageCount: Number,
      defaultPageCount: {
        type: Number,
        default: 1
      },
      showSizePicker: Boolean,
      pageSize: Number,
      defaultPageSize: Number,
      pageSizes: {
        type: Array,
        default() {
          return [10];
        }
      },
      showQuickJumper: Boolean,
      size: {
        type: String,
        default: "medium"
      },
      disabled: Boolean,
      pageSlot: {
        type: Number,
        default: 9
      },
      prev: Function,
      next: Function,
      prefix: Function,
      suffix: Function,
      label: Function,
      displayOrder: {
        type: Array,
        default: ["pages", "size-picker", "quick-jumper"]
      },
      "onUpdate:page": [Function, Array],
      onUpdatePage: [Function, Array],
      "onUpdate:pageSize": [Function, Array],
      onUpdatePageSize: [Function, Array],
      onPageSizeChange: [Function, Array],
      onChange: [Function, Array]
    };
    var NPagination = vue.defineComponent({
      name: "Pagination",
      props: paginationProps,
      setup(props) {
        {
          vue.watchEffect(() => {
            if (props.pageCount !== void 0 && props.itemCount !== void 0) {
              warn$2(
                "pagination",
                "`page-count` and `item-count` should't be specified together. Only `item-count` will take effect."
              );
            }
            if (props.onPageSizeChange) {
              warnOnce(
                "pagination",
                "`on-page-size-change` is deprecated, please use `on-update:page-size` instead."
              );
            }
            if (props.onChange) {
              warnOnce(
                "pagination",
                "`on-change` is deprecated, please use `on-update:page` instead."
              );
            }
          });
        }
        const {
          mergedComponentPropsRef,
          mergedClsPrefixRef,
          inlineThemeDisabled,
          mergedRtlRef
        } = useConfig(props);
        const themeRef = useTheme(
          "Pagination",
          "-pagination",
          style$Z,
          paginationLight$1,
          props,
          mergedClsPrefixRef
        );
        const { localeRef } = useLocale("Pagination");
        const selfRef = vue.ref(null);
        const uncontrolledPageRef = vue.ref(props.defaultPage);
        const getDefaultPageSize = () => {
          const { defaultPageSize } = props;
          if (defaultPageSize !== void 0)
            return defaultPageSize;
          const pageSizeOption = props.pageSizes[0];
          if (typeof pageSizeOption === "number")
            return pageSizeOption;
          return pageSizeOption.value || 10;
        };
        const uncontrolledPageSizeRef = vue.ref(getDefaultPageSize());
        const mergedPageRef = useMergedState(
          vue.toRef(props, "page"),
          uncontrolledPageRef
        );
        const mergedPageSizeRef = useMergedState(
          vue.toRef(props, "pageSize"),
          uncontrolledPageSizeRef
        );
        const mergedPageCountRef = vue.computed(() => {
          const { itemCount } = props;
          if (itemCount !== void 0) {
            return Math.max(1, Math.ceil(itemCount / mergedPageSizeRef.value));
          }
          const { pageCount } = props;
          if (pageCount !== void 0)
            return Math.max(pageCount, 1);
          return 1;
        });
        const jumperValueRef = vue.ref("");
        vue.watchEffect(() => {
          void props.simple;
          jumperValueRef.value = String(mergedPageRef.value);
        });
        const fastForwardActiveRef = vue.ref(false);
        const fastBackwardActiveRef = vue.ref(false);
        const showFastForwardMenuRef = vue.ref(false);
        const showFastBackwardMenuRef = vue.ref(false);
        const handleFastForwardMouseenter = () => {
          fastForwardActiveRef.value = true;
          disableTransitionOneTick();
        };
        const handleFastForwardMouseleave = () => {
          fastForwardActiveRef.value = false;
          disableTransitionOneTick();
        };
        const handleFastBackwardMouseenter = () => {
          fastBackwardActiveRef.value = true;
          disableTransitionOneTick();
        };
        const handleFastBackwardMouseleave = () => {
          fastBackwardActiveRef.value = false;
          disableTransitionOneTick();
        };
        const handleMenuSelect = (value) => {
          doUpdatePage(value);
        };
        const pageItemsInfo = vue.computed(
          () => createPageItemsInfo(
            mergedPageRef.value,
            mergedPageCountRef.value,
            props.pageSlot
          )
        );
        vue.watchEffect(() => {
          if (!pageItemsInfo.value.hasFastBackward) {
            fastBackwardActiveRef.value = false;
            showFastBackwardMenuRef.value = false;
          } else if (!pageItemsInfo.value.hasFastForward) {
            fastForwardActiveRef.value = false;
            showFastForwardMenuRef.value = false;
          }
        });
        const pageSizeOptionsRef = vue.computed(() => {
          const suffix = localeRef.value.selectionSuffix;
          return props.pageSizes.map((size) => {
            if (typeof size === "number") {
              return {
                label: `${size} / ${suffix}`,
                value: size
              };
            } else {
              return size;
            }
          });
        });
        const inputSizeRef = vue.computed(() => {
          return mergedComponentPropsRef?.value?.Pagination?.inputSize || smallerSize(props.size);
        });
        const selectSizeRef = vue.computed(() => {
          return mergedComponentPropsRef?.value?.Pagination?.selectSize || smallerSize(props.size);
        });
        const startIndexRef = vue.computed(() => {
          return (mergedPageRef.value - 1) * mergedPageSizeRef.value;
        });
        const endIndexRef = vue.computed(() => {
          const endIndex = mergedPageRef.value * mergedPageSizeRef.value - 1;
          const { itemCount } = props;
          if (itemCount !== void 0) {
            return endIndex > itemCount ? itemCount : endIndex;
          }
          return endIndex;
        });
        const mergedItemCountRef = vue.computed(() => {
          const { itemCount } = props;
          if (itemCount !== void 0)
            return itemCount;
          return (props.pageCount || 1) * mergedPageSizeRef.value;
        });
        const rtlEnabledRef = useRtl("Pagination", mergedRtlRef, mergedClsPrefixRef);
        const disableTransitionOneTick = () => {
          void vue.nextTick(() => {
            const { value: selfEl } = selfRef;
            if (!selfEl)
              return;
            selfEl.classList.add("transition-disabled");
            void selfRef.value?.offsetWidth;
            selfEl.classList.remove("transition-disabled");
          });
        };
        function doUpdatePage(page) {
          if (page === mergedPageRef.value)
            return;
          const {
            "onUpdate:page": _onUpdatePage,
            onUpdatePage,
            onChange,
            simple
          } = props;
          if (_onUpdatePage)
            call(_onUpdatePage, page);
          if (onUpdatePage)
            call(onUpdatePage, page);
          if (onChange)
            call(onChange, page);
          uncontrolledPageRef.value = page;
          if (simple) {
            jumperValueRef.value = String(page);
          }
        }
        function doUpdatePageSize(pageSize) {
          if (pageSize === mergedPageSizeRef.value)
            return;
          const {
            "onUpdate:pageSize": _onUpdatePageSize,
            onUpdatePageSize,
            onPageSizeChange
          } = props;
          if (_onUpdatePageSize)
            call(_onUpdatePageSize, pageSize);
          if (onUpdatePageSize)
            call(onUpdatePageSize, pageSize);
          if (onPageSizeChange)
            call(onPageSizeChange, pageSize);
          uncontrolledPageSizeRef.value = pageSize;
          if (mergedPageCountRef.value < mergedPageRef.value) {
            doUpdatePage(mergedPageCountRef.value);
          }
        }
        function forward() {
          if (props.disabled)
            return;
          const page = Math.min(mergedPageRef.value + 1, mergedPageCountRef.value);
          doUpdatePage(page);
        }
        function backward() {
          if (props.disabled)
            return;
          const page = Math.max(mergedPageRef.value - 1, 1);
          doUpdatePage(page);
        }
        function fastForward() {
          if (props.disabled)
            return;
          const page = Math.min(
            pageItemsInfo.value.fastForwardTo,
            mergedPageCountRef.value
          );
          doUpdatePage(page);
        }
        function fastBackward() {
          if (props.disabled)
            return;
          const page = Math.max(pageItemsInfo.value.fastBackwardTo, 1);
          doUpdatePage(page);
        }
        function handleSizePickerChange(value) {
          doUpdatePageSize(value);
        }
        function doQuickJump() {
          const page = parseInt(jumperValueRef.value);
          if (Number.isNaN(page))
            return;
          doUpdatePage(Math.max(1, Math.min(page, mergedPageCountRef.value)));
          if (!props.simple) {
            jumperValueRef.value = "";
          }
        }
        function handleQuickJumperChange() {
          doQuickJump();
        }
        function handlePageItemClick(pageItem) {
          if (props.disabled)
            return;
          switch (pageItem.type) {
            case "page":
              doUpdatePage(pageItem.label);
              break;
            case "fast-backward":
              fastBackward();
              break;
            case "fast-forward":
              fastForward();
              break;
          }
        }
        function handleJumperInput(value) {
          jumperValueRef.value = value.replace(/\D+/g, "");
        }
        vue.watchEffect(() => {
          void mergedPageRef.value;
          void mergedPageSizeRef.value;
          disableTransitionOneTick();
        });
        const cssVarsRef = vue.computed(() => {
          const { size } = props;
          const {
            self: {
              buttonBorder,
              buttonBorderHover,
              buttonBorderPressed,
              buttonIconColor,
              buttonIconColorHover,
              buttonIconColorPressed,
              itemTextColor,
              itemTextColorHover,
              itemTextColorPressed,
              itemTextColorActive,
              itemTextColorDisabled,
              itemColor,
              itemColorHover,
              itemColorPressed,
              itemColorActive,
              itemColorActiveHover,
              itemColorDisabled,
              itemBorder,
              itemBorderHover,
              itemBorderPressed,
              itemBorderActive,
              itemBorderDisabled,
              itemBorderRadius,
              jumperTextColor,
              jumperTextColorDisabled,
              buttonColor,
              buttonColorHover,
              buttonColorPressed,
              [createKey("itemPadding", size)]: itemPadding,
              [createKey("itemMargin", size)]: itemMargin,
              [createKey("inputWidth", size)]: inputWidth,
              [createKey("selectWidth", size)]: selectWidth,
              [createKey("inputMargin", size)]: inputMargin,
              [createKey("selectMargin", size)]: selectMargin,
              [createKey("jumperFontSize", size)]: jumperFontSize,
              [createKey("prefixMargin", size)]: prefixMargin,
              [createKey("suffixMargin", size)]: suffixMargin,
              [createKey("itemSize", size)]: itemSize,
              [createKey("buttonIconSize", size)]: buttonIconSize,
              [createKey("itemFontSize", size)]: itemFontSize,
              [`${createKey("itemMargin", size)}Rtl`]: itemMarginRtl,
              [`${createKey("inputMargin", size)}Rtl`]: inputMarginRtl
            },
            common: { cubicBezierEaseInOut }
          } = themeRef.value;
          return {
            "--n-prefix-margin": prefixMargin,
            "--n-suffix-margin": suffixMargin,
            "--n-item-font-size": itemFontSize,
            "--n-select-width": selectWidth,
            "--n-select-margin": selectMargin,
            "--n-input-width": inputWidth,
            "--n-input-margin": inputMargin,
            "--n-input-margin-rtl": inputMarginRtl,
            "--n-item-size": itemSize,
            "--n-item-text-color": itemTextColor,
            "--n-item-text-color-disabled": itemTextColorDisabled,
            "--n-item-text-color-hover": itemTextColorHover,
            "--n-item-text-color-active": itemTextColorActive,
            "--n-item-text-color-pressed": itemTextColorPressed,
            "--n-item-color": itemColor,
            "--n-item-color-hover": itemColorHover,
            "--n-item-color-disabled": itemColorDisabled,
            "--n-item-color-active": itemColorActive,
            "--n-item-color-active-hover": itemColorActiveHover,
            "--n-item-color-pressed": itemColorPressed,
            "--n-item-border": itemBorder,
            "--n-item-border-hover": itemBorderHover,
            "--n-item-border-disabled": itemBorderDisabled,
            "--n-item-border-active": itemBorderActive,
            "--n-item-border-pressed": itemBorderPressed,
            "--n-item-padding": itemPadding,
            "--n-item-border-radius": itemBorderRadius,
            "--n-bezier": cubicBezierEaseInOut,
            "--n-jumper-font-size": jumperFontSize,
            "--n-jumper-text-color": jumperTextColor,
            "--n-jumper-text-color-disabled": jumperTextColorDisabled,
            "--n-item-margin": itemMargin,
            "--n-item-margin-rtl": itemMarginRtl,
            "--n-button-icon-size": buttonIconSize,
            "--n-button-icon-color": buttonIconColor,
            "--n-button-icon-color-hover": buttonIconColorHover,
            "--n-button-icon-color-pressed": buttonIconColorPressed,
            "--n-button-color-hover": buttonColorHover,
            "--n-button-color": buttonColor,
            "--n-button-color-pressed": buttonColorPressed,
            "--n-button-border": buttonBorder,
            "--n-button-border-hover": buttonBorderHover,
            "--n-button-border-pressed": buttonBorderPressed
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass(
          "pagination",
          vue.computed(() => {
            let hash = "";
            const { size } = props;
            hash += size[0];
            return hash;
          }),
          cssVarsRef,
          props
        ) : void 0;
        return {
          rtlEnabled: rtlEnabledRef,
          mergedClsPrefix: mergedClsPrefixRef,
          locale: localeRef,
          selfRef,
          mergedPage: mergedPageRef,
          pageItems: vue.computed(() => {
            return pageItemsInfo.value.items;
          }),
          mergedItemCount: mergedItemCountRef,
          jumperValue: jumperValueRef,
          pageSizeOptions: pageSizeOptionsRef,
          mergedPageSize: mergedPageSizeRef,
          inputSize: inputSizeRef,
          selectSize: selectSizeRef,
          mergedTheme: themeRef,
          mergedPageCount: mergedPageCountRef,
          startIndex: startIndexRef,
          endIndex: endIndexRef,
          showFastForwardMenu: showFastForwardMenuRef,
          showFastBackwardMenu: showFastBackwardMenuRef,
          fastForwardActive: fastForwardActiveRef,
          fastBackwardActive: fastBackwardActiveRef,
          handleMenuSelect,
          handleFastForwardMouseenter,
          handleFastForwardMouseleave,
          handleFastBackwardMouseenter,
          handleFastBackwardMouseleave,
          handleJumperInput,
          handleBackwardClick: backward,
          handleForwardClick: forward,
          handlePageItemClick,
          handleSizePickerChange,
          handleQuickJumperChange,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender
        };
      },
      render() {
        const {
          $slots,
          mergedClsPrefix,
          disabled,
          cssVars,
          mergedPage,
          mergedPageCount,
          pageItems,
          showSizePicker,
          showQuickJumper,
          mergedTheme,
          locale,
          inputSize,
          selectSize,
          mergedPageSize,
          pageSizeOptions,
          jumperValue,
          simple,
          prev,
          next,
          prefix,
          suffix,
          label,
          handleJumperInput,
          handleSizePickerChange,
          handleBackwardClick,
          handlePageItemClick,
          handleForwardClick,
          handleQuickJumperChange,
          onRender
        } = this;
        onRender?.();
        const renderPrefix = $slots.prefix || prefix;
        const renderSuffix = $slots.suffix || suffix;
        const renderPrev = prev || $slots.prev;
        const renderNext = next || $slots.next;
        const renderLabel = label || $slots.label;
        return /* @__PURE__ */ vue.h("div", {
          ref: "selfRef",
          class: [
            `${mergedClsPrefix}-pagination`,
            this.themeClass,
            this.rtlEnabled && `${mergedClsPrefix}-pagination--rtl`,
            disabled && `${mergedClsPrefix}-pagination--disabled`,
            simple && `${mergedClsPrefix}-pagination--simple`
          ],
          style: cssVars
        }, renderPrefix ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-pagination-prefix`
        }, renderPrefix({
          page: mergedPage,
          pageSize: mergedPageSize,
          pageCount: mergedPageCount,
          startIndex: this.startIndex,
          endIndex: this.endIndex,
          itemCount: this.mergedItemCount
        })) : null, this.displayOrder.map((part) => {
          switch (part) {
            case "pages":
              return /* @__PURE__ */ vue.h(vue.Fragment, null, /* @__PURE__ */ vue.h("div", {
                class: [
                  `${mergedClsPrefix}-pagination-item`,
                  !renderPrev && `${mergedClsPrefix}-pagination-item--button`,
                  (mergedPage <= 1 || mergedPage > mergedPageCount || disabled) && `${mergedClsPrefix}-pagination-item--disabled`
                ],
                onClick: handleBackwardClick
              }, renderPrev ? renderPrev({
                page: mergedPage,
                pageSize: mergedPageSize,
                pageCount: mergedPageCount,
                startIndex: this.startIndex,
                endIndex: this.endIndex,
                itemCount: this.mergedItemCount
              }) : /* @__PURE__ */ vue.h(NBaseIcon, {
                clsPrefix: mergedClsPrefix
              }, {
                default: () => this.rtlEnabled ? /* @__PURE__ */ vue.h(ForwardIcon, null) : /* @__PURE__ */ vue.h(BackwardIcon, null)
              })), simple ? /* @__PURE__ */ vue.h(vue.Fragment, null, /* @__PURE__ */ vue.h("div", {
                class: `${mergedClsPrefix}-pagination-quick-jumper`
              }, /* @__PURE__ */ vue.h(NInput, {
                value: jumperValue,
                onUpdateValue: handleJumperInput,
                size: inputSize,
                placeholder: "",
                disabled,
                theme: mergedTheme.peers.Input,
                themeOverrides: mergedTheme.peerOverrides.Input,
                onChange: handleQuickJumperChange
              })), "\xA0/ ", mergedPageCount) : pageItems.map((pageItem, index) => {
                let contentNode;
                let onMouseenter;
                let onMouseleave;
                const { type } = pageItem;
                switch (type) {
                  case "page":
                    const pageNode = pageItem.label;
                    if (renderLabel) {
                      contentNode = renderLabel({
                        type: "page",
                        node: pageNode,
                        active: pageItem.active
                      });
                    } else {
                      contentNode = pageNode;
                    }
                    break;
                  case "fast-forward":
                    const fastForwardNode = this.fastForwardActive ? /* @__PURE__ */ vue.h(NBaseIcon, {
                      clsPrefix: mergedClsPrefix
                    }, {
                      default: () => this.rtlEnabled ? /* @__PURE__ */ vue.h(FastBackwardIcon, null) : /* @__PURE__ */ vue.h(FastForwardIcon, null)
                    }) : /* @__PURE__ */ vue.h(NBaseIcon, {
                      clsPrefix: mergedClsPrefix
                    }, { default: () => /* @__PURE__ */ vue.h(MoreIcon, null) });
                    if (renderLabel) {
                      contentNode = renderLabel({
                        type: "fast-forward",
                        node: fastForwardNode,
                        active: this.fastForwardActive || this.showFastForwardMenu
                      });
                    } else {
                      contentNode = fastForwardNode;
                    }
                    onMouseenter = this.handleFastForwardMouseenter;
                    onMouseleave = this.handleFastForwardMouseleave;
                    break;
                  case "fast-backward":
                    const fastBackwardNode = this.fastBackwardActive ? /* @__PURE__ */ vue.h(NBaseIcon, {
                      clsPrefix: mergedClsPrefix
                    }, {
                      default: () => this.rtlEnabled ? /* @__PURE__ */ vue.h(FastForwardIcon, null) : /* @__PURE__ */ vue.h(FastBackwardIcon, null)
                    }) : /* @__PURE__ */ vue.h(NBaseIcon, {
                      clsPrefix: mergedClsPrefix
                    }, { default: () => /* @__PURE__ */ vue.h(MoreIcon, null) });
                    if (renderLabel) {
                      contentNode = renderLabel({
                        type: "fast-backward",
                        node: fastBackwardNode,
                        active: this.fastBackwardActive || this.showFastBackwardMenu
                      });
                    } else {
                      contentNode = fastBackwardNode;
                    }
                    onMouseenter = this.handleFastBackwardMouseenter;
                    onMouseleave = this.handleFastBackwardMouseleave;
                    break;
                }
                const itemNode = /* @__PURE__ */ vue.h("div", {
                  key: index,
                  class: [
                    `${mergedClsPrefix}-pagination-item`,
                    pageItem.active && `${mergedClsPrefix}-pagination-item--active`,
                    type !== "page" && (type === "fast-backward" && this.showFastBackwardMenu || type === "fast-forward" && this.showFastForwardMenu) && `${mergedClsPrefix}-pagination-item--hover`,
                    disabled && `${mergedClsPrefix}-pagination-item--disabled`,
                    type === "page" && `${mergedClsPrefix}-pagination-item--clickable`
                  ],
                  onClick: () => handlePageItemClick(pageItem),
                  onMouseenter,
                  onMouseleave
                }, contentNode);
                if (type === "page" && !pageItem.mayBeFastBackward && !pageItem.mayBeFastForward) {
                  return itemNode;
                } else {
                  const key = pageItem.type === "page" ? pageItem.mayBeFastBackward ? "fast-backward" : "fast-forward" : pageItem.type;
                  return /* @__PURE__ */ vue.h(NPopselect, {
                    key,
                    trigger: "hover",
                    virtualScroll: true,
                    style: { width: "60px" },
                    theme: mergedTheme.peers.Popselect,
                    themeOverrides: mergedTheme.peerOverrides.Popselect,
                    builtinThemeOverrides: {
                      peers: {
                        InternalSelectMenu: {
                          height: "calc(var(--n-option-height) * 4.6)"
                        }
                      }
                    },
                    nodeProps: () => ({
                      style: {
                        justifyContent: "center"
                      }
                    }),
                    show: type === "page" ? false : type === "fast-backward" ? this.showFastBackwardMenu : this.showFastForwardMenu,
                    onUpdateShow: (value) => {
                      if (type === "page")
                        return;
                      if (value) {
                        if (type === "fast-backward") {
                          this.showFastBackwardMenu = value;
                        } else {
                          this.showFastForwardMenu = value;
                        }
                      } else {
                        this.showFastBackwardMenu = false;
                        this.showFastForwardMenu = false;
                      }
                    },
                    options: pageItem.type !== "page" ? pageItem.options : [],
                    onUpdateValue: this.handleMenuSelect,
                    scrollable: true,
                    internalShowCheckmark: false
                  }, { default: () => itemNode });
                }
              }), /* @__PURE__ */ vue.h("div", {
                class: [
                  `${mergedClsPrefix}-pagination-item`,
                  !renderNext && `${mergedClsPrefix}-pagination-item--button`,
                  {
                    [`${mergedClsPrefix}-pagination-item--disabled`]: mergedPage < 1 || mergedPage >= mergedPageCount || disabled
                  }
                ],
                onClick: handleForwardClick
              }, renderNext ? renderNext({
                page: mergedPage,
                pageSize: mergedPageSize,
                pageCount: mergedPageCount,
                itemCount: this.mergedItemCount,
                startIndex: this.startIndex,
                endIndex: this.endIndex
              }) : /* @__PURE__ */ vue.h(NBaseIcon, {
                clsPrefix: mergedClsPrefix
              }, {
                default: () => this.rtlEnabled ? /* @__PURE__ */ vue.h(BackwardIcon, null) : /* @__PURE__ */ vue.h(ForwardIcon, null)
              })));
            case "size-picker": {
              return !simple && showSizePicker ? /* @__PURE__ */ vue.h(NSelect, {
                internalShowCheckmark: false,
                size: selectSize,
                placeholder: "",
                options: pageSizeOptions,
                value: mergedPageSize,
                disabled,
                theme: mergedTheme.peers.Select,
                themeOverrides: mergedTheme.peerOverrides.Select,
                onUpdateValue: handleSizePickerChange
              }) : null;
            }
            case "quick-jumper":
              return !simple && showQuickJumper ? /* @__PURE__ */ vue.h("div", {
                class: `${mergedClsPrefix}-pagination-quick-jumper`
              }, resolveSlot(this.$slots.goto, () => [locale.goto]), /* @__PURE__ */ vue.h(NInput, {
                value: jumperValue,
                onUpdateValue: handleJumperInput,
                size: inputSize,
                placeholder: "",
                disabled,
                theme: mergedTheme.peers.Input,
                themeOverrides: mergedTheme.peerOverrides.Input,
                onChange: handleQuickJumperChange
              })) : null;
            default:
              return null;
          }
        }), renderSuffix ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-pagination-suffix`
        }, renderSuffix({
          page: mergedPage,
          pageSize: mergedPageSize,
          pageCount: mergedPageCount,
          startIndex: this.startIndex,
          endIndex: this.endIndex,
          itemCount: this.mergedItemCount
        })) : null);
      }
    });

    var commonVars$8 = {
      padding: "8px 14px"
    };

    const tooltipDark = {
      name: "Tooltip",
      common: commonDark,
      peers: {
        Popover: popoverDark$1
      },

      self(vars) {
        const {
          borderRadius,
          boxShadow2,
          popoverColor,
          textColor2
        } = vars;
        return { ...commonVars$8,
          borderRadius,
          boxShadow: boxShadow2,
          color: popoverColor,
          textColor: textColor2
        };
      }

    };
    var tooltipDark$1 = tooltipDark;

    const self$M = vars => {
      const {
        borderRadius,
        boxShadow2,
        baseColor
      } = vars;
      return { ...commonVars$8,
        borderRadius,
        boxShadow: boxShadow2,
        color: composite(baseColor, "rgba(0, 0, 0, .85)"),
        textColor: baseColor
      };
    };

    const tooltipLight = createTheme$1({
      name: "Tooltip",
      common: commonLight,
      peers: {
        Popover: popoverLight$1
      },
      self: self$M
    });
    var tooltipLight$1 = tooltipLight;

    const ellipsisDark = {
      name: "Ellipsis",
      common: commonDark,
      peers: {
        Tooltip: tooltipDark$1
      }
    };
    var ellipsisDark$1 = ellipsisDark;

    const ellipsisLight = createTheme$1({
      name: "Ellipsis",
      common: commonLight,
      peers: {
        Tooltip: tooltipLight$1
      }
    });
    var ellipsisLight$1 = ellipsisLight;

    var commonVariables$a = {
      radioSizeSmall: "14px",
      radioSizeMedium: "16px",
      radioSizeLarge: "18px",
      labelPadding: "0 8px"
    };

    const radioDark = {
      name: "Radio",
      common: commonDark,

      self(vars) {
        const {
          borderColor,
          primaryColor,
          baseColor,
          textColorDisabled,
          inputColorDisabled,
          textColor2,
          opacityDisabled,
          borderRadius,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          heightSmall,
          heightMedium,
          heightLarge,
          lineHeight
        } = vars;
        return { ...commonVariables$a,
          labelLineHeight: lineHeight,
          buttonHeightSmall: heightSmall,
          buttonHeightMedium: heightMedium,
          buttonHeightLarge: heightLarge,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          boxShadow: `inset 0 0 0 1px ${borderColor}`,
          boxShadowActive: `inset 0 0 0 1px ${primaryColor}`,
          boxShadowFocus: `inset 0 0 0 1px ${primaryColor}, 0 0 0 2px ${changeColor(primaryColor, {
        alpha: 0.3
      })}`,
          boxShadowHover: `inset 0 0 0 1px ${primaryColor}`,
          boxShadowDisabled: `inset 0 0 0 1px ${borderColor}`,
          color: "#0000",
          colorDisabled: inputColorDisabled,
          textColor: textColor2,
          textColorDisabled,
          dotColorActive: primaryColor,
          dotColorDisabled: borderColor,
          buttonBorderColor: borderColor,
          buttonBorderColorActive: primaryColor,
          buttonBorderColorHover: primaryColor,
          buttonColor: "#0000",
          buttonColorActive: primaryColor,
          buttonTextColor: textColor2,
          buttonTextColorActive: baseColor,
          buttonTextColorHover: primaryColor,
          opacityDisabled,
          buttonBoxShadowFocus: `inset 0 0 0 1px ${primaryColor}, 0 0 0 2px ${changeColor(primaryColor, {
        alpha: 0.3
      })}`,
          buttonBoxShadowHover: `inset 0 0 0 1px ${primaryColor}`,
          buttonBoxShadow: "inset 0 0 0 1px #0000",
          buttonBorderRadius: borderRadius
        };
      }

    };
    var radioDark$1 = radioDark;

    const self$L = vars => {
      const {
        borderColor,
        primaryColor,
        baseColor,
        textColorDisabled,
        inputColorDisabled,
        textColor2,
        opacityDisabled,
        borderRadius,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        heightSmall,
        heightMedium,
        heightLarge,
        lineHeight
      } = vars;
      return { ...commonVariables$a,
        labelLineHeight: lineHeight,
        buttonHeightSmall: heightSmall,
        buttonHeightMedium: heightMedium,
        buttonHeightLarge: heightLarge,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        boxShadow: `inset 0 0 0 1px ${borderColor}`,
        boxShadowActive: `inset 0 0 0 1px ${primaryColor}`,
        boxShadowFocus: `inset 0 0 0 1px ${primaryColor}, 0 0 0 2px ${changeColor(primaryColor, {
      alpha: 0.2
    })}`,
        boxShadowHover: `inset 0 0 0 1px ${primaryColor}`,
        boxShadowDisabled: `inset 0 0 0 1px ${borderColor}`,
        color: baseColor,
        colorDisabled: inputColorDisabled,
        textColor: textColor2,
        textColorDisabled,
        dotColorActive: primaryColor,
        dotColorDisabled: borderColor,
        buttonBorderColor: borderColor,
        buttonBorderColorActive: primaryColor,
        buttonBorderColorHover: borderColor,
        buttonColor: baseColor,
        buttonColorActive: baseColor,
        buttonTextColor: textColor2,
        buttonTextColorActive: primaryColor,
        buttonTextColorHover: primaryColor,
        opacityDisabled,
        buttonBoxShadowFocus: `inset 0 0 0 1px ${primaryColor}, 0 0 0 2px ${changeColor(primaryColor, {
      alpha: 0.3
    })}`,
        buttonBoxShadowHover: "inset 0 0 0 1px #0000",
        buttonBoxShadow: "inset 0 0 0 1px #0000",
        buttonBorderRadius: borderRadius
      };
    };

    const radioLight = {
      name: "Radio",
      common: commonLight,
      self: self$L
    };
    var radioLight$1 = radioLight;

    var rtlStyle$f = c$1([cB("radio", [cM("rtl", `
      direction: rtl;
    `)]), cB("radio-group", [cM("rtl", `
      direction: rtl;
    `, [cB("radio-button", [c$1("&:first-child", `
          border-radius: 0 var(--n-button-border-radius) var(--n-button-border-radius) 0;
          border-right: 1px solid var(--n-button-border-color);
          border-left: 0;
        `, [cE("state-border", `
            border-radius: 0 var(--n-button-border-radius) var(--n-button-border-radius) 0;
          `)]), c$1("&:last-child", `
          border-radius: var(--n-button-border-radius) 0 0 var(--n-button-border-radius);
          border-left: 1px solid var(--n-button-border-color);
          border-right: 0;
        `, [cE("state-border", `
            border-radius: var(--n-button-border-radius) 0 0 var(--n-button-border-radius);
          `)]), cM("checked", `
          border-color: var(--n-button-border-color-active);
        `)])])])]);

    const radioRtl = {
      name: "Radio",
      style: rtlStyle$f
    };

    var commonVariables$9 = {
      thPaddingSmall: "8px",
      thPaddingMedium: "12px",
      thPaddingLarge: "12px",
      tdPaddingSmall: "8px",
      tdPaddingMedium: "12px",
      tdPaddingLarge: "12px",
      sorterSize: "15px",
      filterSize: "15px",
      paginationMargin: "12px 0 0 0",
      emptyPadding: "48px 0",
      actionPadding: "8px 12px",
      actionButtonMargin: "0 8px 0 0"
    };

    const self$K = vars => {
      const {
        cardColor,
        modalColor,
        popoverColor,
        textColor2,
        textColor1,
        tableHeaderColor,
        tableColorHover,
        iconColor,
        primaryColor,
        fontWeightStrong,
        borderRadius,
        lineHeight,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        dividerColor,
        heightSmall,
        opacityDisabled,
        tableColorStriped
      } = vars;
      return { ...commonVariables$9,
        actionDividerColor: dividerColor,
        lineHeight,
        borderRadius,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        borderColor: composite(cardColor, dividerColor),
        tdColorHover: composite(cardColor, tableColorHover),
        tdColorStriped: composite(cardColor, tableColorStriped),
        thColor: composite(cardColor, tableHeaderColor),
        thColorHover: composite(composite(cardColor, tableHeaderColor), tableColorHover),
        tdColor: cardColor,
        tdTextColor: textColor2,
        thTextColor: textColor1,
        thFontWeight: fontWeightStrong,
        thButtonColorHover: tableColorHover,
        thIconColor: iconColor,
        thIconColorActive: primaryColor,
        borderColorModal: composite(modalColor, dividerColor),
        tdColorHoverModal: composite(modalColor, tableColorHover),
        tdColorStripedModal: composite(modalColor, tableColorStriped),
        thColorModal: composite(modalColor, tableHeaderColor),
        thColorHoverModal: composite(composite(modalColor, tableHeaderColor), tableColorHover),
        tdColorModal: modalColor,
        borderColorPopover: composite(popoverColor, dividerColor),
        tdColorHoverPopover: composite(popoverColor, tableColorHover),
        tdColorStripedPopover: composite(popoverColor, tableColorStriped),
        thColorPopover: composite(popoverColor, tableHeaderColor),
        thColorHoverPopover: composite(composite(popoverColor, tableHeaderColor), tableColorHover),
        tdColorPopover: popoverColor,
        boxShadowBefore: "inset -12px 0 8px -12px rgba(0, 0, 0, .18)",
        boxShadowAfter: "inset 12px 0 8px -12px rgba(0, 0, 0, .18)",
        loadingColor: primaryColor,
        loadingSize: heightSmall,
        opacityLoading: opacityDisabled
      };
    };
    const dataTableLight = createTheme$1({
      name: "DataTable",
      common: commonLight,
      peers: {
        Button: buttonLight$1,
        Checkbox: checkboxLight$1,
        Radio: radioLight$1,
        Pagination: paginationLight$1,
        Scrollbar: scrollbarLight$1,
        Empty: emptyLight$1,
        Popover: popoverLight$1,
        Ellipsis: ellipsisLight$1
      },
      self: self$K
    });
    var dataTableLight$1 = dataTableLight;

    const dataTableDark = {
      name: "DataTable",
      common: commonDark,
      peers: {
        Button: buttonDark$1,
        Checkbox: checkboxDark$1,
        Radio: radioDark$1,
        Pagination: paginationDark$1,
        Scrollbar: scrollbarDark$1,
        Empty: emptyDark$1,
        Popover: popoverDark$1,
        Ellipsis: ellipsisDark$1
      },

      self(vars) {
        const commonSelf = self$K(vars);
        commonSelf.boxShadowAfter = "inset 12px 0 8px -12px rgba(0, 0, 0, .36)";
        commonSelf.boxShadowBefore = "inset -12px 0 8px -12px rgba(0, 0, 0, .36)";
        return commonSelf;
      }

    };
    var dataTableDark$1 = dataTableDark;

    const tooltipProps = { ...popoverBaseProps,
      ...useTheme.props
    };
    var NTooltip = vue.defineComponent({
      name: "Tooltip",
      props: tooltipProps,
      __popover__: true,

      setup(props) {
        const themeRef = useTheme("Tooltip", "-tooltip", void 0, tooltipLight$1, props);
        const popoverRef = vue.ref(null);
        const tooltipExposedMethod = {
          syncPosition() {
            popoverRef.value.syncPosition();
          },

          setShow(show) {
            popoverRef.value.setShow(show);
          }

        };
        return { ...tooltipExposedMethod,
          popoverRef,
          mergedTheme: themeRef,
          popoverThemeOverrides: vue.computed(() => {
            return themeRef.value.self;
          })
        };
      },

      render() {
        const {
          mergedTheme,
          internalExtraClass
        } = this;
        return vue.h(NPopover, { ...this.$props,
          theme: mergedTheme.peers.Popover,
          themeOverrides: mergedTheme.peerOverrides.Popover,
          builtinThemeOverrides: this.popoverThemeOverrides,
          internalExtraClass: internalExtraClass.concat("tooltip"),
          ref: "popoverRef"
        }, this.$slots);
      }

    });

    var style$Y = cB("ellipsis", {
      overflow: "hidden"
    }, [cNotM("line-clamp", `
    white-space: nowrap;
    display: inline-block;
    vertical-align: bottom;
    max-width: 100%;
  `), cM("line-clamp", `
    display: -webkit-inline-box;
    -webkit-box-orient: vertical;
  `), cM("cursor-pointer", `
    cursor: pointer;
  `)]);

    function createLineClampClass(clsPrefix) {
      return `${clsPrefix}-ellipsis--line-clamp`;
    }
    function createCursorClass(clsPrefix, cursor) {
      return `${clsPrefix}-ellipsis--cursor-${cursor}`;
    }
    const ellipsisProps = {
      ...useTheme.props,
      expandTrigger: String,
      lineClamp: [Number, String],
      tooltip: {
        type: [Boolean, Object],
        default: true
      }
    };
    var NEllipsis = vue.defineComponent({
      name: "Ellipsis",
      inheritAttrs: false,
      props: ellipsisProps,
      setup(props, { slots, attrs }) {
        const { mergedClsPrefixRef } = useConfig(props);
        const mergedTheme = useTheme(
          "Ellipsis",
          "-ellipsis",
          style$Y,
          ellipsisLight$1,
          props,
          mergedClsPrefixRef
        );
        const triggerRef = vue.ref(null);
        const triggerInnerRef = vue.ref(null);
        const tooltipRef = vue.ref(null);
        const expandedRef = vue.ref(false);
        const ellipsisStyleRef = vue.computed(() => {
          const { lineClamp } = props;
          const { value: expanded } = expandedRef;
          if (lineClamp !== void 0) {
            return {
              textOverflow: "",
              "-webkit-line-clamp": expanded ? "" : lineClamp
            };
          } else {
            return {
              textOverflow: expanded ? "" : "ellipsis",
              "-webkit-line-clamp": ""
            };
          }
        });
        function getTooltipDisabled() {
          let tooltipDisabled = false;
          const { value: expanded } = expandedRef;
          if (expanded)
            return true;
          const { value: trigger } = triggerRef;
          if (trigger) {
            const { lineClamp } = props;
            syncEllipsisStyle(trigger);
            if (lineClamp !== void 0) {
              tooltipDisabled = trigger.scrollHeight <= trigger.offsetHeight;
            } else {
              const { value: triggerInner } = triggerInnerRef;
              if (triggerInner) {
                tooltipDisabled = triggerInner.getBoundingClientRect().width <= trigger.getBoundingClientRect().width;
              }
            }
            syncCursorStyle(trigger, tooltipDisabled);
          }
          return tooltipDisabled;
        }
        const handleClickRef = vue.computed(() => {
          return props.expandTrigger === "click" ? () => {
            const { value: expanded } = expandedRef;
            if (expanded) {
              tooltipRef.value?.setShow(false);
            }
            expandedRef.value = !expanded;
          } : void 0;
        });
        const renderTrigger = () => /* @__PURE__ */ vue.h("span", {
          ...vue.mergeProps(attrs, {
            class: [
              `${mergedClsPrefixRef.value}-ellipsis`,
              props.lineClamp !== void 0 ? createLineClampClass(mergedClsPrefixRef.value) : void 0,
              props.expandTrigger === "click" ? createCursorClass(mergedClsPrefixRef.value, "pointer") : void 0
            ],
            style: ellipsisStyleRef.value
          }),
          ref: "triggerRef",
          onClick: handleClickRef.value,
          onMouseenter: props.expandTrigger === "click" ? getTooltipDisabled : void 0
        }, props.lineClamp ? slots : /* @__PURE__ */ vue.h("span", {
          ref: "triggerInnerRef"
        }, slots));
        function syncEllipsisStyle(trigger) {
          if (!trigger)
            return;
          const latestStyle = ellipsisStyleRef.value;
          const lineClampClass = createLineClampClass(mergedClsPrefixRef.value);
          if (props.lineClamp !== void 0) {
            syncTriggerClass(trigger, lineClampClass, "add");
          } else {
            syncTriggerClass(trigger, lineClampClass, "remove");
          }
          for (const key in latestStyle) {
            if (trigger.style[key] !== latestStyle[key]) {
              trigger.style[key] = latestStyle[key];
            }
          }
        }
        function syncCursorStyle(trigger, tooltipDisabled) {
          const cursorClass = createCursorClass(mergedClsPrefixRef.value, "pointer");
          if (props.expandTrigger === "click" && !tooltipDisabled) {
            syncTriggerClass(trigger, cursorClass, "add");
          } else {
            syncTriggerClass(trigger, cursorClass, "remove");
          }
        }
        function syncTriggerClass(trigger, styleClass, action) {
          if (action === "add") {
            if (!trigger.classList.contains(styleClass)) {
              trigger.classList.add(styleClass);
            }
          } else {
            if (trigger.classList.contains(styleClass)) {
              trigger.classList.remove(styleClass);
            }
          }
        }
        return {
          mergedTheme,
          triggerRef,
          triggerInnerRef,
          tooltipRef,
          handleClick: handleClickRef,
          renderTrigger,
          getTooltipDisabled
        };
      },
      render() {
        const { tooltip, renderTrigger, $slots } = this;
        if (tooltip) {
          const { mergedTheme } = this;
          return /* @__PURE__ */ vue.h(NTooltip, {
            ref: "tooltipRef",
            placement: "top",
            ...tooltip,
            getDisabled: this.getTooltipDisabled,
            theme: mergedTheme.peers.Tooltip,
            themeOverrides: mergedTheme.peerOverrides.Tooltip
          }, {
            trigger: renderTrigger,
            default: $slots.tooltip ?? $slots.default
          });
        } else
          return renderTrigger();
      }
    });

    var RenderSorter = vue.defineComponent({
      name: "DataTableRenderSorter",
      props: {
        render: {
          type: Function,
          required: true
        },
        order: {
          type: [String, Boolean],
          default: false
        }
      },

      render() {
        const {
          render,
          order
        } = this;
        return render({
          order
        });
      }

    });

    const dataTableInjectionKey = createInjectionKey("n-data-table");

    var SortButton = vue.defineComponent({
      name: "SortIcon",
      props: {
        column: {
          type: Object,
          required: true
        }
      },
      setup(props) {
        const { mergedComponentPropsRef } = useConfig();
        const { mergedSortStateRef, mergedClsPrefixRef } = vue.inject(
          dataTableInjectionKey
        );
        const sortStateRef = vue.computed(
          () => mergedSortStateRef.value.find(
            (state) => state.columnKey === props.column.key
          )
        );
        const activeRef = vue.computed(() => {
          return sortStateRef.value !== void 0;
        });
        const mergedSortOrderRef = vue.computed(() => {
          const { value: sortState } = sortStateRef;
          if (sortState && activeRef.value) {
            return sortState.order;
          }
          return false;
        });
        const mergedRenderSorterRef = vue.computed(() => {
          return mergedComponentPropsRef?.value?.DataTable?.renderSorter || props.column.renderSorter;
        });
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          active: activeRef,
          mergedSortOrder: mergedSortOrderRef,
          mergedRenderSorter: mergedRenderSorterRef
        };
      },
      render() {
        const { mergedRenderSorter, mergedSortOrder, mergedClsPrefix } = this;
        const { renderSorterIcon } = this.column;
        return mergedRenderSorter ? /* @__PURE__ */ vue.h(RenderSorter, {
          render: mergedRenderSorter,
          order: mergedSortOrder
        }) : /* @__PURE__ */ vue.h("span", {
          class: [
            `${mergedClsPrefix}-data-table-sorter`,
            mergedSortOrder === "ascend" && `${mergedClsPrefix}-data-table-sorter--asc`,
            mergedSortOrder === "descend" && `${mergedClsPrefix}-data-table-sorter--desc`
          ]
        }, renderSorterIcon ? renderSorterIcon({ order: mergedSortOrder }) : /* @__PURE__ */ vue.h(NBaseIcon, {
          clsPrefix: mergedClsPrefix
        }, { default: () => /* @__PURE__ */ vue.h(ArrowDownIcon, null) }));
      }
    });

    var RenderFilter = vue.defineComponent({
      name: "DataTableRenderFilter",
      props: {
        render: {
          type: Function,
          required: true
        },
        active: {
          type: Boolean,
          default: false
        },
        show: {
          type: Boolean,
          default: false
        }
      },

      render() {
        const {
          render,
          active,
          show
        } = this;
        return render({
          active,
          show
        });
      }

    });

    const radioProps$1 = {
      name: String,
      value: {
        type: [String, Number],
        default: "on"
      },
      checked: {
        type: Boolean,
        default: void 0
      },
      defaultChecked: Boolean,
      disabled: {
        type: Boolean,
        default: void 0
      },
      label: String,
      size: String,
      onUpdateChecked: [Function, Array],
      "onUpdate:checked": [Function, Array],
      checkedValue: {
        type: Boolean,
        validator: () => {
          warn$2("radio", "`checked-value` is deprecated, please use `checked` instead.");
          return true;
        },
        default: void 0
      }
    };
    const radioGroupInjectionKey = createInjectionKey("n-radio-group");

    function setup(props) {
      const formItem = useFormItem(props, {
        mergedSize(NFormItem) {
          const {
            size
          } = props;
          if (size !== void 0) return size;

          if (NRadioGroup) {
            const {
              mergedSizeRef: {
                value: mergedSize
              }
            } = NRadioGroup;

            if (mergedSize !== void 0) {
              return mergedSize;
            }
          }

          if (NFormItem) {
            return NFormItem.mergedSize.value;
          }

          return "medium";
        },

        mergedDisabled(NFormItem) {
          if (props.disabled) return true;
          if (NRadioGroup !== null && NRadioGroup !== void 0 && NRadioGroup.disabledRef.value) return true;
          if (NFormItem !== null && NFormItem !== void 0 && NFormItem.disabled.value) return true;
          return false;
        }

      });
      const {
        mergedSizeRef,
        mergedDisabledRef
      } = formItem;
      const inputRef = vue.ref(null);
      const labelRef = vue.ref(null);
      const NRadioGroup = vue.inject(radioGroupInjectionKey, null);
      const uncontrolledCheckedRef = vue.ref(props.defaultChecked);
      const controlledCheckedRef = vue.toRef(props, "checked");
      const mergedCheckedRef = useMergedState(controlledCheckedRef, uncontrolledCheckedRef);
      const renderSafeCheckedRef = useMemo(() => {
        if (NRadioGroup) return NRadioGroup.valueRef.value === props.value;
        return mergedCheckedRef.value;
      });
      const mergedNameRef = useMemo(() => {
        const {
          name
        } = props;
        if (name !== void 0) return name;
        if (NRadioGroup) return NRadioGroup.nameRef.value;
      });
      const focusRef = vue.ref(false);

      function doUpdateChecked() {
        if (NRadioGroup) {
          const {
            doUpdateValue
          } = NRadioGroup;
          const {
            value
          } = props;
          call(doUpdateValue, value);
        } else {
          const {
            onUpdateChecked,
            "onUpdate:checked": _onUpdateChecked
          } = props;
          const {
            nTriggerFormInput,
            nTriggerFormChange
          } = formItem;
          if (onUpdateChecked) call(onUpdateChecked, true);
          if (_onUpdateChecked) call(_onUpdateChecked, true);
          nTriggerFormInput();
          nTriggerFormChange();
          uncontrolledCheckedRef.value = true;
        }
      }

      function toggle() {
        if (mergedDisabledRef.value) return;

        if (!renderSafeCheckedRef.value) {
          doUpdateChecked();
        }
      }

      function handleRadioInputChange() {
        toggle();
      }

      function handleRadioInputBlur() {
        focusRef.value = false;
      }

      function handleRadioInputFocus() {
        focusRef.value = true;
      }

      return {
        mergedClsPrefix: NRadioGroup ? NRadioGroup.mergedClsPrefixRef : useConfig(props).mergedClsPrefixRef,
        inputRef,
        labelRef,
        mergedName: mergedNameRef,
        mergedDisabled: mergedDisabledRef,
        uncontrolledChecked: uncontrolledCheckedRef,
        renderSafeChecked: renderSafeCheckedRef,
        focus: focusRef,
        mergedSize: mergedSizeRef,
        handleRadioInputChange,
        handleRadioInputBlur,
        handleRadioInputFocus
      };
    }

    setup.props = radioProps$1;

    var style$X = cB("radio", `
  line-height: var(--n-label-line-height);
  outline: none;
  position: relative;
  user-select: none;
  -webkit-user-select: none;
  display: inline-flex;
  align-items: flex-start;
  flex-wrap: nowrap;
  font-size: var(--n-font-size);
  word-break: break-word;
`, [cE("dot-wrapper", `
    position: relative;
    flex-shrink: 0;
    flex-grow: 0;
    width: var(--n-radio-size);
  `), cB("radio-input", `
    position: absolute;
    border: 0;
    border-radius: inherit;
    left: 0;
    right: 0;
    top: 0;
    bottom: 0;
    opacity: 0;
    z-index: 1;
    cursor: pointer;
  `), cE("dot", `
    position: absolute;
    top: 50%;
    left: 0;
    transform: translateY(-50%);
    height: var(--n-radio-size);
    width: var(--n-radio-size);
    background: var(--n-color);
    box-shadow: var(--n-box-shadow);
    border-radius: 50%;
    transition:
      background-color .3s var(--n-bezier),
      box-shadow .3s var(--n-bezier);
  `, [c$1("&::before", `
      content: "";
      opacity: 0;
      position: absolute;
      left: 4px;
      top: 4px;
      height: calc(100% - 8px);
      width: calc(100% - 8px);
      border-radius: 50%;
      transform: scale(.8);
      background: var(--n-dot-color-active);
      transition:
        opacity .3s var(--n-bezier),
        background-color .3s var(--n-bezier),
        transform .3s var(--n-bezier);
    `), cM("checked", {
      boxShadow: "var(--n-box-shadow-active)"
    }, [c$1("&::before", `
        opacity: 1;
        transform: scale(1);
      `)])]), cE("label", `
    color: var(--n-text-color);
    padding: var(--n-label-padding);
    display: inline-block;
    transition: color .3s var(--n-bezier);
  `), cNotM("disabled", `
    cursor: pointer;
  `, [c$1("&:hover", [cE("dot", {
      boxShadow: "var(--n-box-shadow-hover)"
    })]), cM("focus", [c$1("&:not(:active)", [cE("dot", {
      boxShadow: "var(--n-box-shadow-focus)"
    })])])]), cM("disabled", `
    cursor: not-allowed;
  `, [cE("dot", {
      boxShadow: "var(--n-box-shadow-disabled)",
      backgroundColor: "var(--n-color-disabled)"
    }, [c$1("&::before", {
      backgroundColor: "var(--n-dot-color-disabled)"
    }), cM("checked", `
        opacity: 1;
      `)]), cE("label", {
      color: "var(--n-text-color-disabled)"
    }), cB("radio-input", `
      cursor: not-allowed;
    `)])]);

    const radioProps = setup.props;
    var NRadio = vue.defineComponent({
      name: "Radio",
      props: {
        ...useTheme.props,
        ...setup.props
      },
      setup(props) {
        const radio = setup(props);
        const themeRef = useTheme(
          "Radio",
          "-radio",
          style$X,
          radioLight$1,
          props,
          radio.mergedClsPrefix
        );
        const cssVarsRef = vue.computed(() => {
          const {
            mergedSize: { value: size }
          } = radio;
          const {
            common: { cubicBezierEaseInOut },
            self: {
              boxShadow,
              boxShadowActive,
              boxShadowDisabled,
              boxShadowFocus,
              boxShadowHover,
              color,
              colorDisabled,
              textColor,
              textColorDisabled,
              dotColorActive,
              dotColorDisabled,
              labelPadding,
              labelLineHeight,
              [createKey("fontSize", size)]: fontSize,
              [createKey("radioSize", size)]: radioSize
            }
          } = themeRef.value;
          return {
            "--n-bezier": cubicBezierEaseInOut,
            "--n-label-line-height": labelLineHeight,
            "--n-box-shadow": boxShadow,
            "--n-box-shadow-active": boxShadowActive,
            "--n-box-shadow-disabled": boxShadowDisabled,
            "--n-box-shadow-focus": boxShadowFocus,
            "--n-box-shadow-hover": boxShadowHover,
            "--n-color": color,
            "--n-color-disabled": colorDisabled,
            "--n-dot-color-active": dotColorActive,
            "--n-dot-color-disabled": dotColorDisabled,
            "--n-font-size": fontSize,
            "--n-radio-size": radioSize,
            "--n-text-color": textColor,
            "--n-text-color-disabled": textColorDisabled,
            "--n-label-padding": labelPadding
          };
        });
        const { inlineThemeDisabled, mergedClsPrefixRef, mergedRtlRef } = useConfig(props);
        const rtlEnabledRef = useRtl("Radio", mergedRtlRef, mergedClsPrefixRef);
        const themeClassHandle = inlineThemeDisabled ? useThemeClass(
          "radio",
          vue.computed(() => radio.mergedSize.value[0]),
          cssVarsRef,
          props
        ) : void 0;
        return Object.assign(radio, {
          rtlEnabled: rtlEnabledRef,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender
        });
      },
      render() {
        const { $slots, mergedClsPrefix, onRender, label } = this;
        onRender?.();
        return /* @__PURE__ */ vue.h("label", {
          class: [
            `${mergedClsPrefix}-radio`,
            this.themeClass,
            {
              [`${mergedClsPrefix}-radio--rtl`]: this.rtlEnabled,
              [`${mergedClsPrefix}-radio--disabled`]: this.mergedDisabled,
              [`${mergedClsPrefix}-radio--checked`]: this.renderSafeChecked,
              [`${mergedClsPrefix}-radio--focus`]: this.focus
            }
          ],
          style: this.cssVars
        }, /* @__PURE__ */ vue.h("input", {
          ref: "inputRef",
          type: "radio",
          class: `${mergedClsPrefix}-radio-input`,
          value: this.value,
          name: this.mergedName,
          checked: this.renderSafeChecked,
          disabled: this.mergedDisabled,
          onChange: this.handleRadioInputChange,
          onFocus: this.handleRadioInputFocus,
          onBlur: this.handleRadioInputBlur
        }), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-radio__dot-wrapper`
        }, "\xA0", /* @__PURE__ */ vue.h("div", {
          class: [
            `${mergedClsPrefix}-radio__dot`,
            this.renderSafeChecked && `${mergedClsPrefix}-radio__dot--checked`
          ]
        })), resolveWrappedSlot($slots.default, (children) => {
          if (!children && !label)
            return null;
          return /* @__PURE__ */ vue.h("div", {
            ref: "labelRef",
            class: `${mergedClsPrefix}-radio__label`
          }, children || label);
        }));
      }
    });

    var style$W = cB("radio-group", `
  display: inline-block;
  font-size: var(--n-font-size);
`, [cE("splitor", `
    display: inline-block;
    vertical-align: bottom;
    width: 1px;
    transition:
      background-color .3s var(--n-bezier),
      opacity .3s var(--n-bezier);
    background: var(--n-button-border-color);
  `, [cM("checked", {
      backgroundColor: "var(--n-button-border-color-active)"
    }), cM("disabled", {
      opacity: "var(--n-opacity-disabled)"
    })]), cM("button-group", `
    white-space: nowrap;
    height: var(--n-height);
    line-height: var(--n-height);
  `, [cB("radio-button", {
      height: "var(--n-height)",
      lineHeight: "var(--n-height)"
    }), cE("splitor", {
      height: "var(--n-height)"
    })]), cB("radio-button", `
    vertical-align: bottom;
    outline: none;
    position: relative;
    user-select: none;
    -webkit-user-select: none;
    display: inline-block;
    box-sizing: border-box;
    padding-left: 14px;
    padding-right: 14px;
    white-space: nowrap;
    transition:
      background-color .3s var(--n-bezier),
      opacity .3s var(--n-bezier),
      border-color .3s var(--n-bezier),
      color .3s var(--n-bezier);
    color: var(--n-button-text-color);
    border-top: 1px solid var(--n-button-border-color);
    border-bottom: 1px solid var(--n-button-border-color);
  `, [cB("radio-input", `
      pointer-events: none;
      position: absolute;
      border: 0;
      border-radius: inherit;
      left: 0;
      right: 0;
      top: 0;
      bottom: 0;
      opacity: 0;
      z-index: 1;
    `), cE("state-border", `
      z-index: 1;
      pointer-events: none;
      position: absolute;
      box-shadow: var(--n-button-box-shadow);
      transition: box-shadow .3s var(--n-bezier);
      left: -1px;
      bottom: -1px;
      right: -1px;
      top: -1px;
    `), c$1("&:first-child", `
      border-top-left-radius: var(--n-button-border-radius);
      border-bottom-left-radius: var(--n-button-border-radius);
      border-left: 1px solid var(--n-button-border-color);
    `, [cE("state-border", `
        border-top-left-radius: var(--n-button-border-radius);
        border-bottom-left-radius: var(--n-button-border-radius);
      `)]), c$1("&:last-child", `
      border-top-right-radius: var(--n-button-border-radius);
      border-bottom-right-radius: var(--n-button-border-radius);
      border-right: 1px solid var(--n-button-border-color);
    `, [cE("state-border", `
        border-top-right-radius: var(--n-button-border-radius);
        border-bottom-right-radius: var(--n-button-border-radius);
      `)]), cNotM("disabled", `
      cursor: pointer;
    `, [c$1("&:hover", [cE("state-border", `
          transition: box-shadow .3s var(--n-bezier);
          box-shadow: var(--n-button-box-shadow-hover);
        `), cNotM("checked", {
      color: "var(--n-button-text-color-hover)"
    })]), cM("focus", [c$1("&:not(:active)", [cE("state-border", {
      boxShadow: "var(--n-button-box-shadow-focus)"
    })])])]), cM("checked", `
      background: var(--n-button-color-active);
      color: var(--n-button-text-color-active);
      border-color: var(--n-button-border-color-active);
    `), cM("disabled", `
      cursor: not-allowed;
      opacity: var(--n-opacity-disabled);
    `)])]);

    function mapSlot(defaultSlot, value, clsPrefix) {
      const children = [];
      let isButtonGroup = false;
      for (let i = 0; i < defaultSlot.length; ++i) {
        const wrappedInstance = defaultSlot[i];
        const name = wrappedInstance.type?.name;
        if (name === "RadioButton") {
          isButtonGroup = true;
        }
        if (isButtonGroup && name !== "RadioButton") {
          warn$2(
            "radio-group",
            "`n-radio-group` in button mode only takes `n-radio-button` as children."
          );
          continue;
        }
        const instanceProps = wrappedInstance.props;
        if (name !== "RadioButton") {
          children.push(wrappedInstance);
          continue;
        }
        if (i === 0) {
          children.push(wrappedInstance);
        } else {
          const lastInstanceProps = children[children.length - 1].props;
          const lastInstanceChecked = value === lastInstanceProps.value;
          const lastInstanceDisabled = lastInstanceProps.disabled;
          const currentInstanceChecked = value === instanceProps.value;
          const currentInstanceDisabled = instanceProps.disabled;
          const lastInstancePriority = (lastInstanceChecked ? 2 : 0) + (!lastInstanceDisabled ? 1 : 0);
          const currentInstancePriority = (currentInstanceChecked ? 2 : 0) + (!currentInstanceDisabled ? 1 : 0);
          const lastInstanceClass = {
            [`${clsPrefix}-radio-group__splitor--disabled`]: lastInstanceDisabled,
            [`${clsPrefix}-radio-group__splitor--checked`]: lastInstanceChecked
          };
          const currentInstanceClass = {
            [`${clsPrefix}-radio-group__splitor--disabled`]: currentInstanceDisabled,
            [`${clsPrefix}-radio-group__splitor--checked`]: currentInstanceChecked
          };
          const splitorClass = lastInstancePriority < currentInstancePriority ? currentInstanceClass : lastInstanceClass;
          children.push(
            /* @__PURE__ */ vue.h("div", {
              class: [`${clsPrefix}-radio-group__splitor`, splitorClass]
            }),
            wrappedInstance
          );
        }
      }
      return {
        children,
        isButtonGroup
      };
    }
    const radioGroupProps = {
      ...useTheme.props,
      name: String,
      value: [String, Number],
      defaultValue: {
        type: [String, Number],
        default: null
      },
      size: String,
      disabled: {
        type: Boolean,
        default: void 0
      },
      "onUpdate:value": [Function, Array],
      onUpdateValue: [Function, Array]
    };
    var NRadioGroup = vue.defineComponent({
      name: "RadioGroup",
      props: radioGroupProps,
      setup(props) {
        const selfElRef = vue.ref(null);
        const {
          mergedSizeRef,
          mergedDisabledRef,
          nTriggerFormChange,
          nTriggerFormInput,
          nTriggerFormBlur,
          nTriggerFormFocus
        } = useFormItem(props);
        const { mergedClsPrefixRef, inlineThemeDisabled, mergedRtlRef } = useConfig(props);
        const themeRef = useTheme(
          "Radio",
          "-radio-group",
          style$W,
          radioLight$1,
          props,
          mergedClsPrefixRef
        );
        const uncontrolledValueRef = vue.ref(props.defaultValue);
        const controlledValueRef = vue.toRef(props, "value");
        const mergedValueRef = useMergedState(
          controlledValueRef,
          uncontrolledValueRef
        );
        function doUpdateValue(value) {
          const { onUpdateValue, "onUpdate:value": _onUpdateValue } = props;
          if (onUpdateValue) {
            call(onUpdateValue, value);
          }
          if (_onUpdateValue) {
            call(_onUpdateValue, value);
          }
          uncontrolledValueRef.value = value;
          nTriggerFormChange();
          nTriggerFormInput();
        }
        function handleFocusin(e) {
          const { value: selfEl } = selfElRef;
          if (!selfEl)
            return;
          if (selfEl.contains(e.relatedTarget))
            return;
          nTriggerFormFocus();
        }
        function handleFocusout(e) {
          const { value: selfEl } = selfElRef;
          if (!selfEl)
            return;
          if (selfEl.contains(e.relatedTarget))
            return;
          nTriggerFormBlur();
        }
        vue.provide(radioGroupInjectionKey, {
          mergedClsPrefixRef,
          nameRef: vue.toRef(props, "name"),
          valueRef: mergedValueRef,
          disabledRef: mergedDisabledRef,
          mergedSizeRef,
          doUpdateValue
        });
        const rtlEnabledRef = useRtl("Radio", mergedRtlRef, mergedClsPrefixRef);
        const cssVarsRef = vue.computed(() => {
          const { value: size } = mergedSizeRef;
          const {
            common: { cubicBezierEaseInOut },
            self: {
              buttonBorderColor,
              buttonBorderColorActive,
              buttonBorderRadius,
              buttonBoxShadow,
              buttonBoxShadowFocus,
              buttonBoxShadowHover,
              buttonColorActive,
              buttonTextColor,
              buttonTextColorActive,
              buttonTextColorHover,
              opacityDisabled,
              [createKey("buttonHeight", size)]: height,
              [createKey("fontSize", size)]: fontSize
            }
          } = themeRef.value;
          return {
            "--n-font-size": fontSize,
            "--n-bezier": cubicBezierEaseInOut,
            "--n-button-border-color": buttonBorderColor,
            "--n-button-border-color-active": buttonBorderColorActive,
            "--n-button-border-radius": buttonBorderRadius,
            "--n-button-box-shadow": buttonBoxShadow,
            "--n-button-box-shadow-focus": buttonBoxShadowFocus,
            "--n-button-box-shadow-hover": buttonBoxShadowHover,
            "--n-button-color-active": buttonColorActive,
            "--n-button-text-color": buttonTextColor,
            "--n-button-text-color-hover": buttonTextColorHover,
            "--n-button-text-color-active": buttonTextColorActive,
            "--n-height": height,
            "--n-opacity-disabled": opacityDisabled
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass(
          "radio-group",
          vue.computed(() => mergedSizeRef.value[0]),
          cssVarsRef,
          props
        ) : void 0;
        return {
          selfElRef,
          rtlEnabled: rtlEnabledRef,
          mergedClsPrefix: mergedClsPrefixRef,
          mergedValue: mergedValueRef,
          handleFocusout,
          handleFocusin,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender
        };
      },
      render() {
        const { mergedValue, mergedClsPrefix, handleFocusin, handleFocusout } = this;
        const { children, isButtonGroup } = mapSlot(
          flatten$3(getSlot$1(this)),
          mergedValue,
          mergedClsPrefix
        );
        this.onRender?.();
        return /* @__PURE__ */ vue.h("div", {
          onFocusin: handleFocusin,
          onFocusout: handleFocusout,
          ref: "selfElRef",
          class: [
            `${mergedClsPrefix}-radio-group`,
            this.rtlEnabled && `${mergedClsPrefix}-radio-group--rtl`,
            this.themeClass,
            isButtonGroup && `${mergedClsPrefix}-radio-group--button-group`
          ],
          style: this.cssVars
        }, children);
      }
    });

    const radioButtonProps = setup.props;
    var RadioButton = vue.defineComponent({
      name: "RadioButton",
      props: setup.props,
      setup(props) {
        return setup(props);
      },
      render() {
        const { mergedClsPrefix } = this;
        return /* @__PURE__ */ vue.h("label", {
          class: [
            `${mergedClsPrefix}-radio-button`,
            {
              [`${mergedClsPrefix}-radio-button--disabled`]: this.mergedDisabled,
              [`${mergedClsPrefix}-radio-button--checked`]: this.renderSafeChecked,
              [`${mergedClsPrefix}-radio-button--focus`]: this.focus
            }
          ]
        }, /* @__PURE__ */ vue.h("input", {
          ref: "inputRef",
          type: "radio",
          class: `${mergedClsPrefix}-radio-input`,
          value: this.value,
          name: this.mergedName,
          checked: this.renderSafeChecked,
          disabled: this.mergedDisabled,
          onChange: this.handleRadioInputChange,
          onFocus: this.handleRadioInputFocus,
          onBlur: this.handleRadioInputBlur
        }), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-radio-button__state-border`
        }), resolveWrappedSlot(this.$slots.default, (children) => {
          if (!children && !this.label)
            return null;
          return /* @__PURE__ */ vue.h("div", {
            ref: "labelRef",
            class: `${mergedClsPrefix}-radio__label`
          }, children || this.label);
        }));
      }
    });

    const SELECTION_COL_WIDTH = 40;
    const EXPAND_COL_WIDTH = 40;
    function getNumberColWidth(col) {
      if (col.type === "selection") {
        return col.width === void 0 ? SELECTION_COL_WIDTH : depx(col.width);
      }

      if (col.type === "expand") {
        return col.width === void 0 ? EXPAND_COL_WIDTH : depx(col.width);
      }

      if ("children" in col) return void 0;

      if (typeof col.width === "string") {
        return depx(col.width);
      }

      return col.width;
    }
    function getStringColWidth(col) {
      if (col.type === "selection") {
        return formatLength(col.width ?? SELECTION_COL_WIDTH);
      }

      if (col.type === "expand") {
        return formatLength(col.width ?? EXPAND_COL_WIDTH);
      }

      if ("children" in col) {
        return void 0;
      }

      return formatLength(col.width);
    }
    function getColKey(col) {
      if (col.type === "selection") return "__n_selection__";
      if (col.type === "expand") return "__n_expand__";
      return col.key;
    }
    function createShallowClonedObject(object) {
      if (!object) return object;

      if (typeof object === "object") {
        return Object.assign({}, object);
      }

      return object;
    }
    function getFlagOfOrder(order) {
      if (order === "ascend") return 1;else if (order === "descend") return -1;
      return 0;
    }
    function createCustomWidthStyle(column) {
      const width = getStringColWidth(column);
      return {
        width,
        minWidth: formatLength(column.minWidth) || width
      };
    }
    function createRowClassName(row, index, rowClassName) {
      if (typeof rowClassName === "function") return rowClassName(row, index);
      return rowClassName || "";
    }
    function shouldUseArrayInSingleMode(column) {
      return column.filterOptionValues !== void 0 || column.filterOptionValue === void 0 && column.defaultFilterOptionValues !== void 0;
    }
    function isColumnSortable(column) {
      if ("children" in column) return false;
      return !!column.sorter;
    }
    function isColumnFilterable(column) {
      if ("children" in column) return false;
      return !!column.filter && (!!column.filterOptions || !!column.renderFilterMenu);
    }

    function getNextOrderOf(order) {
      if (!order) return "descend";else if (order === "descend") return "ascend";
      return false;
    }

    function createNextSorter(column, currentSortState) {
      if (column.sorter === void 0) return null;

      if (currentSortState === null || currentSortState.columnKey !== column.key) {
        return {
          columnKey: column.key,
          sorter: column.sorter,
          order: getNextOrderOf(false)
        };
      } else {
        return { ...currentSortState,
          order: getNextOrderOf(currentSortState.order)
        };
      }
    }
    function isColumnSorting(column, mergedSortState) {
      return mergedSortState.find(state => state.columnKey === column.key && state.order) !== void 0;
    }

    var NDataTableFilterMenu = vue.defineComponent({
      name: "DataTableFilterMenu",
      props: {
        column: {
          type: Object,
          required: true
        },
        radioGroupName: {
          type: String,
          required: true
        },
        multiple: {
          type: Boolean,
          required: true
        },
        value: {
          type: [Array, String, Number],
          default: null
        },
        options: {
          type: Array,
          required: true
        },
        onConfirm: {
          type: Function,
          required: true
        },
        onClear: {
          type: Function,
          required: true
        },
        onChange: {
          type: Function,
          required: true
        }
      },
      setup(props) {
        const {
          mergedClsPrefixRef,
          mergedThemeRef,
          localeRef
        } = vue.inject(dataTableInjectionKey);
        const temporalValueRef = vue.ref(props.value);
        const checkboxGroupValueRef = vue.computed(() => {
          const { value: temporalValue } = temporalValueRef;
          if (!Array.isArray(temporalValue))
            return null;
          return temporalValue;
        });
        const radioGroupValueRef = vue.computed(() => {
          const { value: temporalValue } = temporalValueRef;
          if (shouldUseArrayInSingleMode(props.column)) {
            return Array.isArray(temporalValue) && temporalValue.length && temporalValue[0] || null;
          }
          if (!Array.isArray(temporalValue))
            return temporalValue;
          return null;
        });
        function doChange(value) {
          props.onChange(value);
        }
        function handleChange(value) {
          if (props.multiple && Array.isArray(value)) {
            temporalValueRef.value = value;
          } else if (shouldUseArrayInSingleMode(props.column) && !Array.isArray(value)) {
            temporalValueRef.value = [value];
          } else {
            temporalValueRef.value = value;
          }
        }
        function handleConfirmClick() {
          doChange(temporalValueRef.value);
          props.onConfirm();
        }
        function handleClearClick() {
          if (props.multiple || shouldUseArrayInSingleMode(props.column)) {
            doChange([]);
          } else {
            doChange(null);
          }
          props.onClear();
        }
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          mergedTheme: mergedThemeRef,
          locale: localeRef,
          checkboxGroupValue: checkboxGroupValueRef,
          radioGroupValue: radioGroupValueRef,
          handleChange,
          handleConfirmClick,
          handleClearClick
        };
      },
      render() {
        const { mergedTheme, locale, mergedClsPrefix } = this;
        return /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-data-table-filter-menu`
        }, /* @__PURE__ */ vue.h(NScrollbar, null, {
          default: () => {
            const { checkboxGroupValue, handleChange } = this;
            return this.multiple ? /* @__PURE__ */ vue.h(NCheckboxGroup, {
              value: checkboxGroupValue,
              class: `${mergedClsPrefix}-data-table-filter-menu__group`,
              onUpdateValue: handleChange
            }, {
              default: () => this.options.map((option) => {
                return /* @__PURE__ */ vue.h(NCheckbox, {
                  key: option.value,
                  theme: mergedTheme.peers.Checkbox,
                  themeOverrides: mergedTheme.peerOverrides.Checkbox,
                  value: option.value
                }, { default: () => option.label });
              })
            }) : /* @__PURE__ */ vue.h(NRadioGroup, {
              name: this.radioGroupName,
              class: `${mergedClsPrefix}-data-table-filter-menu__group`,
              value: this.radioGroupValue,
              onUpdateValue: this.handleChange
            }, {
              default: () => this.options.map((option) => /* @__PURE__ */ vue.h(NRadio, {
                key: option.value,
                value: option.value,
                theme: mergedTheme.peers.Radio,
                themeOverrides: mergedTheme.peerOverrides.Radio
              }, { default: () => option.label }))
            });
          }
        }), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-data-table-filter-menu__action`
        }, /* @__PURE__ */ vue.h(NButton, {
          size: "tiny",
          theme: mergedTheme.peers.Button,
          themeOverrides: mergedTheme.peerOverrides.Button,
          onClick: this.handleClearClick
        }, { default: () => locale.clear }), /* @__PURE__ */ vue.h(NButton, {
          theme: mergedTheme.peers.Button,
          themeOverrides: mergedTheme.peerOverrides.Button,
          type: "primary",
          size: "tiny",
          onClick: this.handleConfirmClick
        }, { default: () => locale.confirm })));
      }
    });

    function createFilterState(currentFilterState, columnKey, mergedFilterValue) {
      const nextFilterState = Object.assign({}, currentFilterState);
      nextFilterState[columnKey] = mergedFilterValue;
      return nextFilterState;
    }
    var FilterButton = vue.defineComponent({
      name: "DataTableFilterButton",
      props: {
        column: {
          type: Object,
          required: true
        },
        options: {
          type: Array,
          default: () => []
        }
      },
      setup(props) {
        const { mergedComponentPropsRef } = useConfig();
        const {
          mergedThemeRef,
          mergedClsPrefixRef,
          mergedFilterStateRef,
          filterMenuCssVarsRef,
          paginationBehaviorOnFilterRef,
          doUpdatePage,
          doUpdateFilters
        } = vue.inject(dataTableInjectionKey);
        const showPopoverRef = vue.ref(false);
        const filterStateRef = mergedFilterStateRef;
        const filterMultipleRef = vue.computed(() => {
          return props.column.filterMultiple !== false;
        });
        const mergedFilterValueRef = vue.computed(() => {
          const filterValue = filterStateRef.value[props.column.key];
          if (filterValue === void 0) {
            const { value: multiple } = filterMultipleRef;
            if (multiple)
              return [];
            else
              return null;
          }
          return filterValue;
        });
        const activeRef = vue.computed(() => {
          const { value: filterValue } = mergedFilterValueRef;
          if (Array.isArray(filterValue)) {
            return filterValue.length > 0;
          }
          return filterValue !== null;
        });
        const mergedRenderFilterRef = vue.computed(() => {
          return mergedComponentPropsRef?.value?.DataTable?.renderFilter || props.column.renderFilter;
        });
        function handleFilterChange(mergedFilterValue) {
          const nextFilterState = createFilterState(
            filterStateRef.value,
            props.column.key,
            mergedFilterValue
          );
          doUpdateFilters(nextFilterState, props.column);
          if (paginationBehaviorOnFilterRef.value === "first") {
            doUpdatePage(1);
          }
        }
        function handleFilterMenuCancel() {
          showPopoverRef.value = false;
        }
        function handleFilterMenuConfirm() {
          showPopoverRef.value = false;
        }
        return {
          mergedTheme: mergedThemeRef,
          mergedClsPrefix: mergedClsPrefixRef,
          active: activeRef,
          showPopover: showPopoverRef,
          mergedRenderFilter: mergedRenderFilterRef,
          filterMultiple: filterMultipleRef,
          mergedFilterValue: mergedFilterValueRef,
          filterMenuCssVars: filterMenuCssVarsRef,
          handleFilterChange,
          handleFilterMenuConfirm,
          handleFilterMenuCancel
        };
      },
      render() {
        const { mergedTheme, mergedClsPrefix, handleFilterMenuCancel } = this;
        return /* @__PURE__ */ vue.h(NPopover, {
          show: this.showPopover,
          onUpdateShow: (v) => this.showPopover = v,
          trigger: "click",
          theme: mergedTheme.peers.Popover,
          themeOverrides: mergedTheme.peerOverrides.Popover,
          placement: "bottom",
          style: { padding: 0 }
        }, {
          trigger: () => {
            const { mergedRenderFilter } = this;
            if (mergedRenderFilter) {
              return /* @__PURE__ */ vue.h(RenderFilter, {
                "data-data-table-filter": true,
                render: mergedRenderFilter,
                active: this.active,
                show: this.showPopover
              });
            }
            const { renderFilterIcon } = this.column;
            return /* @__PURE__ */ vue.h("div", {
              "data-data-table-filter": true,
              class: [
                `${mergedClsPrefix}-data-table-filter`,
                {
                  [`${mergedClsPrefix}-data-table-filter--active`]: this.active,
                  [`${mergedClsPrefix}-data-table-filter--show`]: this.showPopover
                }
              ]
            }, renderFilterIcon ? renderFilterIcon({
              active: this.active,
              show: this.showPopover
            }) : /* @__PURE__ */ vue.h(NBaseIcon, {
              clsPrefix: mergedClsPrefix
            }, { default: () => /* @__PURE__ */ vue.h(FilterIcon, null) }));
          },
          default: () => {
            const { renderFilterMenu } = this.column;
            return renderFilterMenu ? renderFilterMenu({ hide: handleFilterMenuCancel }) : /* @__PURE__ */ vue.h(NDataTableFilterMenu, {
              style: this.filterMenuCssVars,
              radioGroupName: String(this.column.key),
              multiple: this.filterMultiple,
              value: this.mergedFilterValue,
              options: this.options,
              column: this.column,
              onChange: this.handleFilterChange,
              onClear: this.handleFilterMenuCancel,
              onConfirm: this.handleFilterMenuConfirm
            });
          }
        });
      }
    });

    var commonVariables$8 = {
      padding: "4px 0",
      optionIconSizeSmall: "14px",
      optionIconSizeMedium: "16px",
      optionIconSizeLarge: "16px",
      optionIconSizeHuge: "18px",
      optionSuffixWidthSmall: "14px",
      optionSuffixWidthMedium: "14px",
      optionSuffixWidthLarge: "16px",
      optionSuffixWidthHuge: "16px",
      optionIconSuffixWidthSmall: "32px",
      optionIconSuffixWidthMedium: "32px",
      optionIconSuffixWidthLarge: "36px",
      optionIconSuffixWidthHuge: "36px",
      optionPrefixWidthSmall: "14px",
      optionPrefixWidthMedium: "14px",
      optionPrefixWidthLarge: "16px",
      optionPrefixWidthHuge: "16px",
      optionIconPrefixWidthSmall: "36px",
      optionIconPrefixWidthMedium: "36px",
      optionIconPrefixWidthLarge: "40px",
      optionIconPrefixWidthHuge: "40px"
    };

    const self$J = vars => {
      const {
        primaryColor,
        textColor2,
        dividerColor,
        hoverColor,
        popoverColor,
        invertedColor,
        borderRadius,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        fontSizeHuge,
        heightSmall,
        heightMedium,
        heightLarge,
        heightHuge,
        textColor3,
        opacityDisabled
      } = vars;
      return { ...commonVariables$8,
        optionHeightSmall: heightSmall,
        optionHeightMedium: heightMedium,
        optionHeightLarge: heightLarge,
        optionHeightHuge: heightHuge,
        borderRadius,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        fontSizeHuge,
        optionTextColor: textColor2,
        optionTextColorHover: textColor2,
        optionTextColorActive: primaryColor,
        optionTextColorChildActive: primaryColor,
        color: popoverColor,
        dividerColor,
        suffixColor: textColor2,
        prefixColor: textColor2,
        optionColorHover: hoverColor,
        optionColorActive: changeColor(primaryColor, {
          alpha: 0.1
        }),
        groupHeaderTextColor: textColor3,
        optionTextColorInverted: "#BBB",
        optionTextColorHoverInverted: "#FFF",
        optionTextColorActiveInverted: "#FFF",
        optionTextColorChildActiveInverted: "#FFF",
        colorInverted: invertedColor,
        dividerColorInverted: "#BBB",
        suffixColorInverted: "#BBB",
        prefixColorInverted: "#BBB",
        optionColorHoverInverted: primaryColor,
        optionColorActiveInverted: primaryColor,
        groupHeaderTextColorInverted: "#AAA",
        optionOpacityDisabled: opacityDisabled
      };
    };
    const dropdownLight = createTheme$1({
      name: "Dropdown",
      common: commonLight,
      peers: {
        Popover: popoverLight$1
      },
      self: self$J
    });
    var dropdownLight$1 = dropdownLight;

    const dropdownDark = {
      name: "Dropdown",
      common: commonDark,
      peers: {
        Popover: popoverDark$1
      },

      self(vars) {
        const {
          primaryColorSuppl,
          primaryColor,
          popoverColor
        } = vars;
        const commonSelf = self$J(vars);
        commonSelf.colorInverted = popoverColor;
        commonSelf.optionColorActive = changeColor(primaryColor, {
          alpha: 0.15
        });
        commonSelf.optionColorActiveInverted = primaryColorSuppl;
        commonSelf.optionColorHoverInverted = primaryColorSuppl;
        return commonSelf;
      }

    };
    var dropdownDark$1 = dropdownDark;

    var NDropdownDivider = vue.defineComponent({
      name: "DropdownDivider",
      props: {
        clsPrefix: {
          type: String,
          required: true
        }
      },
      render() {
        return /* @__PURE__ */ vue.h("div", {
          class: `${this.clsPrefix}-dropdown-divider`
        });
      }
    });

    const self$I = vars => {
      const {
        textColorBase,
        opacity1,
        opacity2,
        opacity3,
        opacity4,
        opacity5
      } = vars;
      return {
        color: textColorBase,
        opacity1Depth: opacity1,
        opacity2Depth: opacity2,
        opacity3Depth: opacity3,
        opacity4Depth: opacity4,
        opacity5Depth: opacity5
      };
    };
    const iconLight = {
      name: "Icon",
      common: commonLight,
      self: self$I
    };
    var iconLight$1 = iconLight;

    const iconDark$1 = {
      name: "Icon",
      common: commonDark,
      self: self$I
    };
    var iconDark$2 = iconDark$1;

    var style$V = cB("icon", `
  height: 1em;
  width: 1em;
  line-height: 1em;
  text-align: center;
  display: inline-block;
  position: relative;
  fill: currentColor;
  transform: translateZ(0);
`, [cM("color-transition", {
      transition: "color .3s var(--n-bezier)"
    }), cM("depth", {
      color: "var(--n-color)"
    }, [c$1("svg", {
      opacity: "var(--n-opacity)",
      transition: "opacity .3s var(--n-bezier)"
    })]), c$1("svg", {
      height: "1em",
      width: "1em"
    })]);

    const iconProps = { ...useTheme.props,
      depth: [String, Number],
      size: [Number, String],
      color: String,
      component: Object
    };
    const NIcon = vue.defineComponent({
      _n_icon__: true,
      name: "Icon",
      inheritAttrs: false,
      props: iconProps,

      setup(props) {
        const {
          mergedClsPrefixRef,
          inlineThemeDisabled
        } = useConfig(props);
        const themeRef = useTheme("Icon", "-icon", style$V, iconLight$1, props, mergedClsPrefixRef);
        const cssVarsRef = vue.computed(() => {
          const {
            depth
          } = props;
          const {
            common: {
              cubicBezierEaseInOut
            },
            self
          } = themeRef.value;

          if (depth !== void 0) {
            const {
              color,
              [`opacity${depth}Depth`]: opacity
            } = self;
            return {
              "--n-bezier": cubicBezierEaseInOut,
              "--n-color": color,
              "--n-opacity": opacity
            };
          }

          return {
            "--n-bezier": cubicBezierEaseInOut,
            "--n-color": "",
            "--n-opacity": ""
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("icon", vue.computed(() => `${props.depth || "d"}`), cssVarsRef, props) : void 0;
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          mergedStyle: vue.computed(() => {
            const {
              size,
              color
            } = props;
            return {
              fontSize: formatLength(size),
              color
            };
          }),
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
          onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
        };
      },

      render() {
        var _$parent$$options;

        const {
          $parent,
          depth,
          mergedClsPrefix,
          component,
          onRender,
          themeClass
        } = this;

        if ($parent !== null && $parent !== void 0 && (_$parent$$options = $parent.$options) !== null && _$parent$$options !== void 0 && _$parent$$options._n_icon__) {
          warn$2("icon", "don't wrap `n-icon` inside `n-icon`");
        }

        onRender === null || onRender === void 0 ? void 0 : onRender();
        return vue.h("i", vue.mergeProps(this.$attrs, {
          role: "img",
          class: [`${mergedClsPrefix}-icon`, themeClass, {
            [`${mergedClsPrefix}-icon--depth`]: depth,
            [`${mergedClsPrefix}-icon--color-transition`]: depth !== void 0
          }],
          style: [this.cssVars, this.mergedStyle]
        }), component ? vue.h(component) : this.$slots);
      }

    });

    const dropdownMenuInjectionKey = createInjectionKey("n-dropdown-menu");
    const dropdownInjectionKey = createInjectionKey("n-dropdown");
    const dropdownOptionInjectionKey = createInjectionKey("n-dropdown-option");

    function isSubmenuNode(rawNode, childrenField) {
      return rawNode.type === "submenu" || rawNode.type === void 0 && rawNode[childrenField] !== void 0;
    }
    function isGroupNode(rawNode) {
      return rawNode.type === "group";
    }
    function isDividerNode$1(rawNode) {
      return rawNode.type === "divider";
    }
    function isRenderNode(rawNode) {
      return rawNode.type === "render";
    }

    var NDropdownOption = vue.defineComponent({
      name: "DropdownOption",
      props: {
        clsPrefix: {
          type: String,
          required: true
        },
        tmNode: {
          type: Object,
          required: true
        },
        parentKey: {
          type: [String, Number],
          default: null
        },
        placement: {
          type: String,
          default: "right-start"
        },
        props: Object,
        scrollable: Boolean
      },
      setup(props) {
        const NDropdown = vue.inject(dropdownInjectionKey);
        const {
          hoverKeyRef,
          keyboardKeyRef,
          lastToggledSubmenuKeyRef,
          pendingKeyPathRef,
          activeKeyPathRef,
          animatedRef,
          mergedShowRef,
          renderLabelRef,
          renderIconRef,
          labelFieldRef,
          childrenFieldRef,
          renderOptionRef,
          nodePropsRef,
          menuPropsRef
        } = NDropdown;
        const NDropdownOption = vue.inject(dropdownOptionInjectionKey, null);
        const NDropdownMenu2 = vue.inject(dropdownMenuInjectionKey);
        const NPopoverBody = vue.inject(popoverBodyInjectionKey);
        const rawNodeRef = vue.computed(() => props.tmNode.rawNode);
        const hasSubmenuRef = vue.computed(() => {
          const { value: childrenField } = childrenFieldRef;
          return isSubmenuNode(props.tmNode.rawNode, childrenField);
        });
        const mergedDisabledRef = vue.computed(() => {
          const { disabled } = props.tmNode;
          return disabled;
        });
        const showSubmenuRef = vue.computed(() => {
          if (!hasSubmenuRef.value)
            return false;
          const { key, disabled } = props.tmNode;
          if (disabled)
            return false;
          const { value: hoverKey } = hoverKeyRef;
          const { value: keyboardKey } = keyboardKeyRef;
          const { value: lastToggledSubmenuKey } = lastToggledSubmenuKeyRef;
          const { value: pendingKeyPath } = pendingKeyPathRef;
          if (hoverKey !== null)
            return pendingKeyPath.includes(key);
          if (keyboardKey !== null) {
            return pendingKeyPath.includes(key) && pendingKeyPath[pendingKeyPath.length - 1] !== key;
          }
          if (lastToggledSubmenuKey !== null)
            return pendingKeyPath.includes(key);
          return false;
        });
        const shouldDelayRef = vue.computed(() => {
          return keyboardKeyRef.value === null && !animatedRef.value;
        });
        const deferredShowSubmenuRef = useDeferredTrue(
          showSubmenuRef,
          300,
          shouldDelayRef
        );
        const parentEnteringSubmenuRef = vue.computed(() => {
          return !!NDropdownOption?.enteringSubmenuRef.value;
        });
        const enteringSubmenuRef = vue.ref(false);
        vue.provide(dropdownOptionInjectionKey, {
          enteringSubmenuRef
        });
        function handleSubmenuBeforeEnter() {
          enteringSubmenuRef.value = true;
        }
        function handleSubmenuAfterEnter() {
          enteringSubmenuRef.value = false;
        }
        function handleMouseEnter() {
          const { parentKey, tmNode } = props;
          if (tmNode.disabled)
            return;
          if (!mergedShowRef.value)
            return;
          lastToggledSubmenuKeyRef.value = parentKey;
          keyboardKeyRef.value = null;
          hoverKeyRef.value = tmNode.key;
        }
        function handleMouseMove() {
          const { tmNode } = props;
          if (tmNode.disabled)
            return;
          if (!mergedShowRef.value)
            return;
          if (hoverKeyRef.value === tmNode.key)
            return;
          handleMouseEnter();
        }
        function handleMouseLeave(e) {
          if (props.tmNode.disabled)
            return;
          if (!mergedShowRef.value)
            return;
          const { relatedTarget } = e;
          if (relatedTarget && !happensIn({ target: relatedTarget }, "dropdownOption") && !happensIn({ target: relatedTarget }, "scrollbarRail")) {
            hoverKeyRef.value = null;
          }
        }
        function handleClick() {
          const { value: hasSubmenu } = hasSubmenuRef;
          const { tmNode } = props;
          if (!mergedShowRef.value)
            return;
          if (!hasSubmenu && !tmNode.disabled) {
            NDropdown.doSelect(
              tmNode.key,
              tmNode.rawNode
            );
            NDropdown.doUpdateShow(false);
          }
        }
        return {
          labelField: labelFieldRef,
          renderLabel: renderLabelRef,
          renderIcon: renderIconRef,
          siblingHasIcon: NDropdownMenu2.showIconRef,
          siblingHasSubmenu: NDropdownMenu2.hasSubmenuRef,
          menuProps: menuPropsRef,
          popoverBody: NPopoverBody,
          animated: animatedRef,
          mergedShowSubmenu: vue.computed(() => {
            return deferredShowSubmenuRef.value && !parentEnteringSubmenuRef.value;
          }),
          rawNode: rawNodeRef,
          hasSubmenu: hasSubmenuRef,
          pending: useMemo(() => {
            const { value: pendingKeyPath } = pendingKeyPathRef;
            const { key } = props.tmNode;
            return pendingKeyPath.includes(key);
          }),
          childActive: useMemo(() => {
            const { value: activeKeyPath } = activeKeyPathRef;
            const { key } = props.tmNode;
            const index = activeKeyPath.findIndex((k) => key === k);
            if (index === -1)
              return false;
            return index < activeKeyPath.length - 1;
          }),
          active: useMemo(() => {
            const { value: activeKeyPath } = activeKeyPathRef;
            const { key } = props.tmNode;
            const index = activeKeyPath.findIndex((k) => key === k);
            if (index === -1)
              return false;
            return index === activeKeyPath.length - 1;
          }),
          mergedDisabled: mergedDisabledRef,
          renderOption: renderOptionRef,
          nodeProps: nodePropsRef,
          handleClick,
          handleMouseMove,
          handleMouseEnter,
          handleMouseLeave,
          handleSubmenuBeforeEnter,
          handleSubmenuAfterEnter
        };
      },
      render() {
        const {
          animated,
          rawNode,
          mergedShowSubmenu,
          clsPrefix,
          siblingHasIcon,
          siblingHasSubmenu,
          renderLabel,
          renderIcon,
          renderOption,
          nodeProps,
          props,
          scrollable
        } = this;
        let submenuVNode = null;
        if (mergedShowSubmenu) {
          const submenuNodeProps = this.menuProps?.(
            rawNode,
            rawNode.children
          );
          submenuVNode = /* @__PURE__ */ vue.h(NDropdownMenu, {
            ...submenuNodeProps,
            clsPrefix,
            scrollable: this.scrollable,
            tmNodes: this.tmNode.children,
            parentKey: this.tmNode.key
          });
        }
        const builtinProps = {
          class: [
            `${clsPrefix}-dropdown-option-body`,
            this.pending && `${clsPrefix}-dropdown-option-body--pending`,
            this.active && `${clsPrefix}-dropdown-option-body--active`,
            this.childActive && `${clsPrefix}-dropdown-option-body--child-active`,
            this.mergedDisabled && `${clsPrefix}-dropdown-option-body--disabled`
          ],
          onMousemove: this.handleMouseMove,
          onMouseenter: this.handleMouseEnter,
          onMouseleave: this.handleMouseLeave,
          onClick: this.handleClick
        };
        const optionNodeProps = nodeProps?.(rawNode);
        const node = /* @__PURE__ */ vue.h("div", {
          class: [`${clsPrefix}-dropdown-option`, optionNodeProps?.class],
          "data-dropdown-option": true,
          ...optionNodeProps
        }, vue.h("div", vue.mergeProps(builtinProps, props), [
          /* @__PURE__ */ vue.h("div", {
            class: [
              `${clsPrefix}-dropdown-option-body__prefix`,
              siblingHasIcon && `${clsPrefix}-dropdown-option-body__prefix--show-icon`
            ]
          }, [renderIcon ? renderIcon(rawNode) : render$1(rawNode.icon)]),
          /* @__PURE__ */ vue.h("div", {
            "data-dropdown-option": true,
            class: `${clsPrefix}-dropdown-option-body__label`
          }, renderLabel ? renderLabel(rawNode) : render$1(rawNode[this.labelField] ?? rawNode.title)),
          /* @__PURE__ */ vue.h("div", {
            "data-dropdown-option": true,
            class: [
              `${clsPrefix}-dropdown-option-body__suffix`,
              siblingHasSubmenu && `${clsPrefix}-dropdown-option-body__suffix--has-submenu`
            ]
          }, this.hasSubmenu ? /* @__PURE__ */ vue.h(NIcon, null, {
            default: () => /* @__PURE__ */ vue.h(ChevronRightIcon, null)
          }) : null)
        ]), this.hasSubmenu ? /* @__PURE__ */ vue.h(VBinder, null, {
          default: () => [
            /* @__PURE__ */ vue.h(VTarget, null, {
              default: () => /* @__PURE__ */ vue.h("div", {
                class: `${clsPrefix}-dropdown-offset-container`
              }, /* @__PURE__ */ vue.h(VFollower, {
                show: this.mergedShowSubmenu,
                placement: this.placement,
                to: scrollable ? this.popoverBody || void 0 : void 0,
                teleportDisabled: !scrollable
              }, {
                default: () => {
                  return /* @__PURE__ */ vue.h("div", {
                    class: `${clsPrefix}-dropdown-menu-wrapper`
                  }, animated ? /* @__PURE__ */ vue.h(vue.Transition, {
                    onBeforeEnter: this.handleSubmenuBeforeEnter,
                    onAfterEnter: this.handleSubmenuAfterEnter,
                    name: "fade-in-scale-up-transition",
                    appear: true
                  }, {
                    default: () => submenuVNode
                  }) : submenuVNode);
                }
              }))
            })
          ]
        }) : null);
        if (renderOption) {
          return renderOption({ node, option: rawNode });
        }
        return node;
      }
    });

    var NDropdownGroupHeader = vue.defineComponent({
      name: "DropdownGroupHeader",
      props: {
        clsPrefix: {
          type: String,
          required: true
        },
        tmNode: {
          type: Object,
          required: true
        }
      },
      setup() {
        const {
          showIconRef,
          hasSubmenuRef
        } = vue.inject(dropdownMenuInjectionKey);
        const { renderLabelRef, labelFieldRef, nodePropsRef, renderOptionRef } = vue.inject(dropdownInjectionKey);
        return {
          labelField: labelFieldRef,
          showIcon: showIconRef,
          hasSubmenu: hasSubmenuRef,
          renderLabel: renderLabelRef,
          nodeProps: nodePropsRef,
          renderOption: renderOptionRef
        };
      },
      render() {
        const {
          clsPrefix,
          hasSubmenu,
          showIcon,
          nodeProps,
          renderLabel,
          renderOption
        } = this;
        const { rawNode } = this.tmNode;
        const node = /* @__PURE__ */ vue.h("div", {
          class: `${clsPrefix}-dropdown-option`,
          ...nodeProps?.(rawNode)
        }, /* @__PURE__ */ vue.h("div", {
          class: `${clsPrefix}-dropdown-option-body ${clsPrefix}-dropdown-option-body--group`
        }, /* @__PURE__ */ vue.h("div", {
          "data-dropdown-option": true,
          class: [
            `${clsPrefix}-dropdown-option-body__prefix`,
            showIcon && `${clsPrefix}-dropdown-option-body__prefix--show-icon`
          ]
        }, render$1(rawNode.icon)), /* @__PURE__ */ vue.h("div", {
          class: `${clsPrefix}-dropdown-option-body__label`,
          "data-dropdown-option": true
        }, renderLabel ? renderLabel(rawNode) : render$1(rawNode.title ?? rawNode[this.labelField])), /* @__PURE__ */ vue.h("div", {
          class: [
            `${clsPrefix}-dropdown-option-body__suffix`,
            hasSubmenu && `${clsPrefix}-dropdown-option-body__suffix--has-submenu`
          ],
          "data-dropdown-option": true
        })));
        if (renderOption) {
          return renderOption({ node, option: rawNode });
        }
        return node;
      }
    });

    var NDropdownGroup = vue.defineComponent({
      name: "NDropdownGroup",
      props: {
        clsPrefix: {
          type: String,
          required: true
        },
        tmNode: {
          type: Object,
          required: true
        },
        parentKey: {
          type: [String, Number],
          default: null
        }
      },
      render() {
        const { tmNode, parentKey, clsPrefix } = this;
        const { children } = tmNode;
        return /* @__PURE__ */ vue.h(vue.Fragment, null, /* @__PURE__ */ vue.h(NDropdownGroupHeader, {
          clsPrefix,
          tmNode,
          key: tmNode.key
        }), children?.map((child) => {
          if (isDividerNode$1(child.rawNode)) {
            return vue.h(NDropdownDivider, {
              clsPrefix,
              key: child.key
            });
          }
          if (child.isGroup) {
            warn$2(
              "dropdown",
              "`group` node is not allowed to be put in `group` node."
            );
            return null;
          }
          return /* @__PURE__ */ vue.h(NDropdownOption, {
            clsPrefix,
            tmNode: child,
            parentKey,
            key: child.key
          });
        }));
      }
    });

    var NDropdownRenderOption = vue.defineComponent({
      name: "DropdownRenderOption",
      props: {
        tmNode: {
          type: Object,
          required: true
        }
      },
      render() {
        const {
          rawNode: { render, props }
        } = this.tmNode;
        return vue.h("div", props, [render?.()]);
      }
    });

    var NDropdownMenu = vue.defineComponent({
      name: "DropdownMenu",
      props: {
        scrollable: Boolean,
        showArrow: Boolean,
        arrowStyle: [String, Object],
        clsPrefix: {
          type: String,
          required: true
        },
        tmNodes: {
          type: Array,
          default: () => []
        },
        parentKey: {
          type: [String, Number],
          default: null
        }
      },
      setup(props) {
        const { renderIconRef, childrenFieldRef } = vue.inject(dropdownInjectionKey);
        vue.provide(dropdownMenuInjectionKey, {
          showIconRef: vue.computed(() => {
            const renderIcon = renderIconRef.value;
            return props.tmNodes.some((tmNode) => {
              if (tmNode.isGroup) {
                return tmNode.children?.some(
                  ({ rawNode: rawChild }) => renderIcon ? renderIcon(rawChild) : rawChild.icon
                );
              }
              const { rawNode } = tmNode;
              return renderIcon ? renderIcon(rawNode) : rawNode.icon;
            });
          }),
          hasSubmenuRef: vue.computed(() => {
            const { value: childrenField } = childrenFieldRef;
            return props.tmNodes.some((tmNode) => {
              if (tmNode.isGroup) {
                return tmNode.children?.some(
                  ({ rawNode: rawChild }) => isSubmenuNode(rawChild, childrenField)
                );
              }
              const { rawNode } = tmNode;
              return isSubmenuNode(rawNode, childrenField);
            });
          })
        });
        const bodyRef = vue.ref(null);
        vue.provide(modalBodyInjectionKey, null);
        vue.provide(drawerBodyInjectionKey, null);
        vue.provide(popoverBodyInjectionKey, bodyRef);
        return {
          bodyRef
        };
      },
      render() {
        const { parentKey, clsPrefix, scrollable } = this;
        const menuOptionsNode = this.tmNodes.map((tmNode) => {
          const { rawNode } = tmNode;
          if (isRenderNode(rawNode)) {
            return /* @__PURE__ */ vue.h(NDropdownRenderOption, {
              tmNode,
              key: tmNode.key
            });
          }
          if (isDividerNode$1(rawNode)) {
            return /* @__PURE__ */ vue.h(NDropdownDivider, {
              clsPrefix,
              key: tmNode.key
            });
          }
          if (isGroupNode(rawNode)) {
            return /* @__PURE__ */ vue.h(NDropdownGroup, {
              clsPrefix,
              tmNode,
              parentKey,
              key: tmNode.key
            });
          }
          return /* @__PURE__ */ vue.h(NDropdownOption, {
            clsPrefix,
            tmNode,
            parentKey,
            key: tmNode.key,
            props: rawNode.props,
            scrollable
          });
        });
        return /* @__PURE__ */ vue.h("div", {
          class: [
            `${clsPrefix}-dropdown-menu`,
            scrollable && `${clsPrefix}-dropdown-menu--scrollable`
          ],
          ref: "bodyRef"
        }, scrollable ? /* @__PURE__ */ vue.h(XScrollbar, {
          contentClass: `${clsPrefix}-dropdown-menu__content`
        }, {
          default: () => menuOptionsNode
        }) : menuOptionsNode, this.showArrow ? renderArrow({
          clsPrefix,
          arrowStyle: this.arrowStyle
        }) : null);
      }
    });

    var style$U = cB("dropdown-menu", `
  transform-origin: var(--v-transform-origin);
  background-color: var(--n-color);
  border-radius: var(--n-border-radius);
  box-shadow: var(--n-box-shadow);
  position: relative;
  transition:
    background-color .3s var(--n-bezier),
    box-shadow .3s var(--n-bezier);
`, [fadeInScaleUpTransition(), cB("dropdown-option", `
    position: relative;
  `, [c$1("a", `
      text-decoration: none;
      color: inherit;
      outline: none;
    `, [c$1("&::before", `
        content: "";
        position: absolute;
        left: 0;
        right: 0;
        top: 0;
        bottom: 0;
      `)]), cB("dropdown-option-body", `
      display: flex;
      cursor: pointer;
      position: relative;
      height: var(--n-option-height);
      line-height: var(--n-option-height);
      font-size: var(--n-font-size);
      color: var(--n-option-text-color);
      transition: color .3s var(--n-bezier);
    `, [c$1("&::before", `
        content: "";
        position: absolute;
        top: 0;
        bottom: 0;
        left: 4px;
        right: 4px;
        transition: background-color .3s var(--n-bezier);
        border-radius: var(--n-border-radius);
      `), cNotM("disabled", [cM("pending", `
          color: var(--n-option-text-color-hover);
        `, [cE("prefix, suffix", `
            color: var(--n-option-text-color-hover);
          `), c$1("&::before", "background-color: var(--n-option-color-hover);")]), cM("active", `
          color: var(--n-option-text-color-active);
        `, [cE("prefix, suffix", `
            color: var(--n-option-text-color-active);
          `), c$1("&::before", "background-color: var(--n-option-color-active);")]), cM("child-active", `
          color: var(--n-option-text-color-child-active);
        `, [cE("prefix, suffix", `
            color: var(--n-option-text-color-child-active);
          `)])]), cM("disabled", `
        cursor: not-allowed;
        opacity: var(--n-option-opacity-disabled);
      `), cM("group", `
        font-size: calc(var(--n-font-size) - 1px);
        color: var(--n-group-header-text-color);
      `, [cE("prefix", `
          width: calc(var(--n-option-prefix-width) / 2);
        `, [cM("show-icon", `
            width: calc(var(--n-option-icon-prefix-width) / 2);
          `)])]), cE("prefix", `
        width: var(--n-option-prefix-width);
        display: flex;
        justify-content: center;
        align-items: center;
        color: var(--n-prefix-color);
        transition: color .3s var(--n-bezier);
        z-index: 1;
      `, [cM("show-icon", `
          width: var(--n-option-icon-prefix-width);
        `), cB("icon", `
          font-size: var(--n-option-icon-size);
        `)]), cE("label", `
        white-space: nowrap;
        flex: 1;
        z-index: 1;
      `), cE("suffix", `
        box-sizing: border-box;
        flex-grow: 0;
        flex-shrink: 0;
        display: flex;
        justify-content: flex-end;
        align-items: center;
        min-width: var(--n-option-suffix-width);
        padding: 0 8px;
        transition: color .3s var(--n-bezier);
        color: var(--n-suffix-color);
        z-index: 1;
      `, [cM("has-submenu", `
          width: var(--n-option-icon-suffix-width);
        `), cB("icon", `
          font-size: var(--n-option-icon-size);
        `)]), cB("dropdown-menu", "pointer-events: all;")]), cB("dropdown-offset-container", `
      pointer-events: none;
      position: absolute;
      left: 0;
      right: 0;
      top: -4px;
      bottom: -4px;
    `)]), cB("dropdown-divider", `
    transition: background-color .3s var(--n-bezier);
    background-color: var(--n-divider-color);
    height: 1px;
    margin: 4px 0;
  `), cB("dropdown-menu-wrapper", `
    transform-origin: var(--v-transform-origin);
    width: fit-content;
  `), c$1(">", [cB("scrollbar", `
      height: inherit;
      max-height: inherit;
    `)]), cNotM("scrollable", `
    padding: var(--n-padding);
  `), cM("scrollable", [cE("content", `
      padding: var(--n-padding);
    `)])]);

    const dropdownBaseProps = {
      animated: {
        type: Boolean,
        default: true
      },
      keyboard: {
        type: Boolean,
        default: true
      },
      size: {
        type: String,
        default: "medium"
      },
      inverted: Boolean,
      placement: {
        type: String,
        default: "bottom"
      },
      onSelect: [Function, Array],
      options: {
        type: Array,
        default: () => []
      },
      menuProps: Function,
      showArrow: Boolean,
      renderLabel: Function,
      renderIcon: Function,
      renderOption: Function,
      nodeProps: Function,
      labelField: {
        type: String,
        default: "label"
      },
      keyField: {
        type: String,
        default: "key"
      },
      childrenField: {
        type: String,
        default: "children"
      },
      value: [String, Number]
    };
    const popoverPropKeys = Object.keys(popoverBaseProps);
    const dropdownProps = {
      ...popoverBaseProps,
      ...dropdownBaseProps,
      ...useTheme.props
    };
    var NDropdown = vue.defineComponent({
      name: "Dropdown",
      inheritAttrs: false,
      props: dropdownProps,
      setup(props) {
        const uncontrolledShowRef = vue.ref(false);
        const mergedShowRef = useMergedState(
          vue.toRef(props, "show"),
          uncontrolledShowRef
        );
        const treemateRef = vue.computed(() => {
          const { keyField, childrenField } = props;
          return createTreeMate(props.options, {
            getKey(node) {
              return node[keyField];
            },
            getDisabled(node) {
              return node.disabled === true;
            },
            getIgnored(node) {
              return node.type === "divider" || node.type === "render";
            },
            getChildren(node) {
              return node[childrenField];
            }
          });
        });
        const tmNodesRef = vue.computed(() => {
          return treemateRef.value.treeNodes;
        });
        const hoverKeyRef = vue.ref(null);
        const keyboardKeyRef = vue.ref(null);
        const lastToggledSubmenuKeyRef = vue.ref(null);
        const pendingKeyRef = vue.computed(() => {
          return hoverKeyRef.value ?? keyboardKeyRef.value ?? lastToggledSubmenuKeyRef.value ?? null;
        });
        const pendingKeyPathRef = vue.computed(
          () => treemateRef.value.getPath(pendingKeyRef.value).keyPath
        );
        const activeKeyPathRef = vue.computed(
          () => treemateRef.value.getPath(props.value).keyPath
        );
        const keyboardEnabledRef = useMemo(() => {
          return props.keyboard && mergedShowRef.value;
        });
        useKeyboard$1(
          {
            keydown: {
              ArrowUp: {
                prevent: true,
                handler: handleKeyDownUp
              },
              ArrowRight: {
                prevent: true,
                handler: handleKeyDownRight
              },
              ArrowDown: {
                prevent: true,
                handler: handleKeyDownDown
              },
              ArrowLeft: {
                prevent: true,
                handler: handleKeyDownLeft
              },
              Escape: handleKeyDownEsc
            },
            keyup: {
              Enter: handleKeyUpEnter
            }
          },
          keyboardEnabledRef
        );
        const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
        const themeRef = useTheme(
          "Dropdown",
          "-dropdown",
          style$U,
          dropdownLight$1,
          props,
          mergedClsPrefixRef
        );
        vue.provide(dropdownInjectionKey, {
          labelFieldRef: vue.toRef(props, "labelField"),
          childrenFieldRef: vue.toRef(props, "childrenField"),
          renderLabelRef: vue.toRef(props, "renderLabel"),
          renderIconRef: vue.toRef(props, "renderIcon"),
          hoverKeyRef,
          keyboardKeyRef,
          lastToggledSubmenuKeyRef,
          pendingKeyPathRef,
          activeKeyPathRef,
          animatedRef: vue.toRef(props, "animated"),
          mergedShowRef,
          nodePropsRef: vue.toRef(props, "nodeProps"),
          renderOptionRef: vue.toRef(props, "renderOption"),
          menuPropsRef: vue.toRef(props, "menuProps"),
          doSelect,
          doUpdateShow
        });
        vue.watch(mergedShowRef, (value) => {
          if (!props.animated && !value) {
            clearPendingState();
          }
        });
        function doSelect(key, node) {
          const { onSelect } = props;
          if (onSelect)
            call(onSelect, key, node);
        }
        function doUpdateShow(value) {
          const { "onUpdate:show": _onUpdateShow, onUpdateShow } = props;
          if (_onUpdateShow)
            call(_onUpdateShow, value);
          if (onUpdateShow)
            call(onUpdateShow, value);
          uncontrolledShowRef.value = value;
        }
        function clearPendingState() {
          hoverKeyRef.value = null;
          keyboardKeyRef.value = null;
          lastToggledSubmenuKeyRef.value = null;
        }
        function handleKeyDownEsc() {
          doUpdateShow(false);
        }
        function handleKeyDownLeft() {
          handleKeyDown("left");
        }
        function handleKeyDownRight() {
          handleKeyDown("right");
        }
        function handleKeyDownUp() {
          handleKeyDown("up");
        }
        function handleKeyDownDown() {
          handleKeyDown("down");
        }
        function handleKeyUpEnter() {
          const pendingNode = getPendingNode();
          if (pendingNode?.isLeaf) {
            doSelect(pendingNode.key, pendingNode.rawNode);
            doUpdateShow(false);
          }
        }
        function getPendingNode() {
          const { value: treeMate } = treemateRef;
          const { value: pendingKey } = pendingKeyRef;
          if (!treeMate || pendingKey === null)
            return null;
          return treeMate.getNode(pendingKey) ?? null;
        }
        function handleKeyDown(direction) {
          const { value: pendingKey } = pendingKeyRef;
          const {
            value: { getFirstAvailableNode }
          } = treemateRef;
          let nextKeyboardKey = null;
          if (pendingKey === null) {
            const firstNode = getFirstAvailableNode();
            if (firstNode !== null) {
              nextKeyboardKey = firstNode.key;
            }
          } else {
            const currentNode = getPendingNode();
            if (currentNode) {
              let nextNode;
              switch (direction) {
                case "down":
                  nextNode = currentNode.getNext();
                  break;
                case "up":
                  nextNode = currentNode.getPrev();
                  break;
                case "right":
                  nextNode = currentNode.getChild();
                  break;
                case "left":
                  nextNode = currentNode.getParent();
                  break;
              }
              if (nextNode)
                nextKeyboardKey = nextNode.key;
            }
          }
          if (nextKeyboardKey !== null) {
            hoverKeyRef.value = null;
            keyboardKeyRef.value = nextKeyboardKey;
          }
        }
        const cssVarsRef = vue.computed(() => {
          const { size, inverted } = props;
          const {
            common: { cubicBezierEaseInOut },
            self
          } = themeRef.value;
          const {
            padding,
            dividerColor,
            borderRadius,
            optionOpacityDisabled,
            [createKey("optionIconSuffixWidth", size)]: optionIconSuffixWidth,
            [createKey("optionSuffixWidth", size)]: optionSuffixWidth,
            [createKey("optionIconPrefixWidth", size)]: optionIconPrefixWidth,
            [createKey("optionPrefixWidth", size)]: optionPrefixWidth,
            [createKey("fontSize", size)]: fontSize,
            [createKey("optionHeight", size)]: optionHeight,
            [createKey("optionIconSize", size)]: optionIconSize
          } = self;
          const vars = {
            "--n-bezier": cubicBezierEaseInOut,
            "--n-font-size": fontSize,
            "--n-padding": padding,
            "--n-border-radius": borderRadius,
            "--n-option-height": optionHeight,
            "--n-option-prefix-width": optionPrefixWidth,
            "--n-option-icon-prefix-width": optionIconPrefixWidth,
            "--n-option-suffix-width": optionSuffixWidth,
            "--n-option-icon-suffix-width": optionIconSuffixWidth,
            "--n-option-icon-size": optionIconSize,
            "--n-divider-color": dividerColor,
            "--n-option-opacity-disabled": optionOpacityDisabled
          };
          if (inverted) {
            vars["--n-color"] = self.colorInverted;
            vars["--n-option-color-hover"] = self.optionColorHoverInverted;
            vars["--n-option-color-active"] = self.optionColorActiveInverted;
            vars["--n-option-text-color"] = self.optionTextColorInverted;
            vars["--n-option-text-color-hover"] = self.optionTextColorHoverInverted;
            vars["--n-option-text-color-active"] = self.optionTextColorActiveInverted;
            vars["--n-option-text-color-child-active"] = self.optionTextColorChildActiveInverted;
            vars["--n-prefix-color"] = self.prefixColorInverted;
            vars["--n-suffix-color"] = self.suffixColorInverted;
            vars["--n-group-header-text-color"] = self.groupHeaderTextColorInverted;
          } else {
            vars["--n-color"] = self.color;
            vars["--n-option-color-hover"] = self.optionColorHover;
            vars["--n-option-color-active"] = self.optionColorActive;
            vars["--n-option-text-color"] = self.optionTextColor;
            vars["--n-option-text-color-hover"] = self.optionTextColorHover;
            vars["--n-option-text-color-active"] = self.optionTextColorActive;
            vars["--n-option-text-color-child-active"] = self.optionTextColorChildActive;
            vars["--n-prefix-color"] = self.prefixColor;
            vars["--n-suffix-color"] = self.suffixColor;
            vars["--n-group-header-text-color"] = self.groupHeaderTextColor;
          }
          return vars;
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass(
          "dropdown",
          vue.computed(() => `${props.size[0]}${props.inverted ? "i" : ""}`),
          cssVarsRef,
          props
        ) : void 0;
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          mergedTheme: themeRef,
          tmNodes: tmNodesRef,
          mergedShow: mergedShowRef,
          handleAfterLeave: () => {
            if (!props.animated)
              return;
            clearPendingState();
          },
          doUpdateShow,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender
        };
      },
      render() {
        const renderPopoverBody = (className, ref2, style2, onMouseenter, onMouseleave) => {
          const { mergedClsPrefix, menuProps } = this;
          this.onRender?.();
          const menuNodeProps = menuProps?.(
            void 0,
            this.tmNodes.map((v) => v.rawNode)
          ) || {};
          const dropdownProps2 = {
            ref: createRefSetter(ref2),
            class: [className, `${mergedClsPrefix}-dropdown`, this.themeClass],
            clsPrefix: mergedClsPrefix,
            tmNodes: this.tmNodes,
            style: [style2, this.cssVars],
            showArrow: this.showArrow,
            arrowStyle: this.arrowStyle,
            scrollable: this.scrollable,
            onMouseenter,
            onMouseleave
          };
          return vue.h(
            NDropdownMenu,
            vue.mergeProps(
              this.$attrs,
              dropdownProps2,
              menuNodeProps
            )
          );
        };
        const { mergedTheme } = this;
        const popoverProps = {
          show: this.mergedShow,
          theme: mergedTheme.peers.Popover,
          themeOverrides: mergedTheme.peerOverrides.Popover,
          internalOnAfterLeave: this.handleAfterLeave,
          internalRenderBody: renderPopoverBody,
          onUpdateShow: this.doUpdateShow,
          "onUpdate:show": void 0
        };
        return /* @__PURE__ */ vue.h(NPopover, {
          ...keep(this.$props, popoverPropKeys),
          ...popoverProps
        }, {
          trigger: () => this.$slots.default?.()
        });
      }
    });

    const allKey = "_n_all__";
    const noneKey = "_n_none__";
    function createSelectHandler(options, rawPaginatedDataRef, doCheckAll, doUncheckAll) {
      if (!options)
        return () => {
        };
      return (key) => {
        for (const option of options) {
          switch (key) {
            case allKey:
              doCheckAll(true);
              return;
            case noneKey:
              doUncheckAll(true);
              return;
            default:
              if (typeof option === "object" && option.key === key) {
                option.onSelect(rawPaginatedDataRef.value);
                return;
              }
          }
        }
      };
    }
    function createDropdownOptions(options, localeRef) {
      if (!options)
        return [];
      return options.map((option) => {
        switch (option) {
          case "all":
            return {
              label: localeRef.checkTableAll,
              key: allKey
            };
          case "none":
            return {
              label: localeRef.uncheckTableAll,
              key: noneKey
            };
          default:
            return option;
        }
      });
    }
    var SelectionMenu = vue.defineComponent({
      name: "DataTableSelectionMenu",
      props: {
        clsPrefix: {
          type: String,
          required: true
        }
      },
      setup() {
        const {
          localeRef,
          checkOptionsRef,
          rawPaginatedDataRef,
          doCheckAll,
          doUncheckAll
        } = vue.inject(dataTableInjectionKey);
        return {
          handleSelect: vue.computed(
            () => createSelectHandler(
              checkOptionsRef.value,
              rawPaginatedDataRef,
              doCheckAll,
              doUncheckAll
            )
          ),
          options: vue.computed(
            () => createDropdownOptions(checkOptionsRef.value, localeRef.value)
          )
        };
      },
      render() {
        const { clsPrefix } = this;
        return /* @__PURE__ */ vue.h(NDropdown, {
          options: this.options,
          onSelect: this.handleSelect
        }, {
          default: () => /* @__PURE__ */ vue.h(NBaseIcon, {
            clsPrefix,
            class: `${clsPrefix}-data-table-check-extra`
          }, {
            default: () => /* @__PURE__ */ vue.h(ChevronDownIcon, null)
          })
        });
      }
    });

    function renderTitle(column) {
      return typeof column.title === "function" ? column.title(column) : column.title;
    }
    var TableHeader = vue.defineComponent({
      name: "DataTableHeader",
      props: {
        discrete: {
          type: Boolean,
          default: true
        }
      },
      setup() {
        const {
          mergedClsPrefixRef,
          scrollXRef,
          fixedColumnLeftMapRef,
          fixedColumnRightMapRef,
          mergedCurrentPageRef,
          allRowsCheckedRef,
          someRowsCheckedRef,
          rowsRef,
          colsRef,
          mergedThemeRef,
          checkOptionsRef,
          mergedSortStateRef,
          componentId,
          scrollPartRef,
          mergedTableLayoutRef,
          headerCheckboxDisabledRef,
          handleTableHeaderScroll,
          deriveNextSorter,
          doUncheckAll,
          doCheckAll
        } = vue.inject(dataTableInjectionKey);
        function handleCheckboxUpdateChecked() {
          if (allRowsCheckedRef.value) {
            doUncheckAll();
          } else {
            doCheckAll();
          }
        }
        function handleColHeaderClick(e, column) {
          if (happensIn(e, "dataTableFilter"))
            return;
          if (!isColumnSortable(column))
            return;
          const activeSorter = mergedSortStateRef.value.find(
            (state) => state.columnKey === column.key
          ) || null;
          const nextSorter = createNextSorter(column, activeSorter);
          deriveNextSorter(nextSorter);
        }
        function handleMouseenter() {
          scrollPartRef.value = "head";
        }
        function handleMouseleave() {
          scrollPartRef.value = "body";
        }
        return {
          componentId,
          mergedSortState: mergedSortStateRef,
          mergedClsPrefix: mergedClsPrefixRef,
          scrollX: scrollXRef,
          fixedColumnLeftMap: fixedColumnLeftMapRef,
          fixedColumnRightMap: fixedColumnRightMapRef,
          currentPage: mergedCurrentPageRef,
          allRowsChecked: allRowsCheckedRef,
          someRowsChecked: someRowsCheckedRef,
          rows: rowsRef,
          cols: colsRef,
          mergedTheme: mergedThemeRef,
          checkOptions: checkOptionsRef,
          mergedTableLayout: mergedTableLayoutRef,
          headerCheckboxDisabled: headerCheckboxDisabledRef,
          handleMouseenter,
          handleMouseleave,
          handleCheckboxUpdateChecked,
          handleColHeaderClick,
          handleTableHeaderScroll
        };
      },
      render() {
        const {
          mergedClsPrefix,
          fixedColumnLeftMap,
          fixedColumnRightMap,
          currentPage,
          allRowsChecked,
          someRowsChecked,
          rows,
          cols,
          mergedTheme,
          checkOptions,
          componentId,
          discrete,
          mergedTableLayout,
          headerCheckboxDisabled,
          mergedSortState,
          handleColHeaderClick,
          handleCheckboxUpdateChecked
        } = this;
        const theadVNode = /* @__PURE__ */ vue.h("thead", {
          class: `${mergedClsPrefix}-data-table-thead`,
          "data-n-id": componentId
        }, rows.map((row) => {
          return /* @__PURE__ */ vue.h("tr", {
            class: `${mergedClsPrefix}-data-table-tr`
          }, row.map(({ column, colSpan, rowSpan, isLast }) => {
            const key = getColKey(column);
            const { ellipsis } = column;
            const leftFixed = key in fixedColumnLeftMap;
            const rightFixed = key in fixedColumnRightMap;
            return /* @__PURE__ */ vue.h("th", {
              key,
              style: {
                textAlign: column.align,
                left: pxfy(fixedColumnLeftMap[key]?.start),
                right: pxfy(fixedColumnRightMap[key]?.start)
              },
              colspan: colSpan,
              rowspan: rowSpan,
              "data-col-key": key,
              class: [
                `${mergedClsPrefix}-data-table-th`,
                (leftFixed || rightFixed) && `${mergedClsPrefix}-data-table-th--fixed-${leftFixed ? "left" : "right"}`,
                {
                  [`${mergedClsPrefix}-data-table-th--hover`]: isColumnSorting(column, mergedSortState),
                  [`${mergedClsPrefix}-data-table-th--filterable`]: isColumnFilterable(column),
                  [`${mergedClsPrefix}-data-table-th--sortable`]: isColumnSortable(column),
                  [`${mergedClsPrefix}-data-table-th--selection`]: column.type === "selection",
                  [`${mergedClsPrefix}-data-table-th--last`]: isLast
                },
                column.className
              ],
              onClick: column.type !== "selection" && column.type !== "expand" && !("children" in column) ? (e) => {
                handleColHeaderClick(e, column);
              } : void 0
            }, column.type === "selection" ? column.multiple !== false ? /* @__PURE__ */ vue.h(vue.Fragment, null, /* @__PURE__ */ vue.h(NCheckbox, {
              key: currentPage,
              privateInsideTable: true,
              checked: allRowsChecked,
              indeterminate: someRowsChecked,
              disabled: headerCheckboxDisabled,
              onUpdateChecked: handleCheckboxUpdateChecked
            }), checkOptions ? /* @__PURE__ */ vue.h(SelectionMenu, {
              clsPrefix: mergedClsPrefix
            }) : null) : null : ellipsis === true || ellipsis && !ellipsis.tooltip ? /* @__PURE__ */ vue.h("div", {
              class: `${mergedClsPrefix}-data-table-th__ellipsis`
            }, renderTitle(column)) : ellipsis && typeof ellipsis === "object" ? /* @__PURE__ */ vue.h(NEllipsis, {
              ...ellipsis,
              theme: mergedTheme.peers.Ellipsis,
              themeOverrides: mergedTheme.peerOverrides.Ellipsis
            }, {
              default: () => renderTitle(column)
            }) : renderTitle(column), isColumnSortable(column) ? /* @__PURE__ */ vue.h(SortButton, {
              column
            }) : null, isColumnFilterable(column) ? /* @__PURE__ */ vue.h(FilterButton, {
              column,
              options: column.filterOptions
            }) : null);
          }));
        }));
        if (!discrete) {
          return theadVNode;
        }
        const {
          handleTableHeaderScroll,
          handleMouseenter,
          handleMouseleave,
          scrollX
        } = this;
        return /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-data-table-base-table-header`,
          onScroll: handleTableHeaderScroll,
          onMouseenter: handleMouseenter,
          onMouseleave: handleMouseleave
        }, /* @__PURE__ */ vue.h("table", {
          ref: "body",
          class: `${mergedClsPrefix}-data-table-table`,
          style: {
            minWidth: formatLength(scrollX),
            tableLayout: mergedTableLayout
          }
        }, /* @__PURE__ */ vue.h("colgroup", null, cols.map((col) => /* @__PURE__ */ vue.h("col", {
          key: col.key,
          style: col.style
        }))), theadVNode));
      }
    });

    var Cell = vue.defineComponent({
      name: "DataTableCell",
      props: {
        clsPrefix: {
          type: String,
          required: true
        },
        row: {
          type: Object,
          required: true
        },
        index: {
          type: Number,
          required: true
        },
        column: {
          type: Object,
          required: true
        },
        isSummary: Boolean,
        mergedTheme: {
          type: Object,
          required: true
        },
        renderCell: Function
      },
      render() {
        const { isSummary, column, row, renderCell } = this;
        let cell;
        const { render, key, ellipsis } = column;
        if (render && !isSummary) {
          cell = render(row, this.index);
        } else {
          if (isSummary) {
            cell = row[key].value;
          } else {
            cell = renderCell ? renderCell(lodash.exports.get(row, key), row, column) : lodash.exports.get(row, key);
          }
        }
        if (ellipsis) {
          if (typeof ellipsis === "object") {
            const { mergedTheme } = this;
            return /* @__PURE__ */ vue.h(NEllipsis, {
              ...ellipsis,
              theme: mergedTheme.peers.Ellipsis,
              themeOverrides: mergedTheme.peerOverrides.Ellipsis
            }, { default: () => cell });
          } else {
            return /* @__PURE__ */ vue.h("span", {
              class: `${this.clsPrefix}-data-table-td__ellipsis`
            }, cell);
          }
        }
        return cell;
      }
    });

    var ExpandTrigger = vue.defineComponent({
      name: "DataTableExpandTrigger",
      props: {
        clsPrefix: {
          type: String,
          required: true
        },
        expanded: Boolean,
        loading: Boolean,
        onClick: {
          type: Function,
          required: true
        },
        renderExpandIcon: {
          type: Function
        }
      },
      render() {
        const { clsPrefix } = this;
        return /* @__PURE__ */ vue.h("div", {
          class: [
            `${clsPrefix}-data-table-expand-trigger`,
            this.expanded && `${clsPrefix}-data-table-expand-trigger--expanded`
          ],
          onClick: this.onClick
        }, /* @__PURE__ */ vue.h(NIconSwitchTransition, null, {
          default: () => {
            return this.loading ? /* @__PURE__ */ vue.h(NBaseLoading, {
              key: "loading",
              clsPrefix: this.clsPrefix,
              radius: 85,
              strokeWidth: 15,
              scale: 0.88
            }) : this.renderExpandIcon ? this.renderExpandIcon() : /* @__PURE__ */ vue.h(NBaseIcon, {
              clsPrefix,
              key: "base-icon"
            }, {
              default: () => /* @__PURE__ */ vue.h(ChevronRightIcon, null)
            });
          }
        }));
      }
    });

    var RenderSafeCheckbox = vue.defineComponent({
      name: "DataTableBodyCheckbox",
      props: {
        rowKey: {
          type: [String, Number],
          required: true
        },
        disabled: {
          type: Boolean,
          required: true
        },
        onUpdateChecked: {
          type: Function,
          required: true
        }
      },
      setup(props) {
        const {
          mergedCheckedRowKeySetRef,
          mergedInderminateRowKeySetRef
        } = vue.inject(dataTableInjectionKey);
        return () => {
          const { rowKey } = props;
          return /* @__PURE__ */ vue.h(NCheckbox, {
            privateInsideTable: true,
            disabled: props.disabled,
            indeterminate: mergedInderminateRowKeySetRef.value.has(rowKey),
            checked: mergedCheckedRowKeySetRef.value.has(rowKey),
            onUpdateChecked: props.onUpdateChecked
          });
        };
      }
    });

    var RenderSafeRadio = vue.defineComponent({
      name: "DataTableBodyRadio",
      props: {
        rowKey: {
          type: [String, Number],
          required: true
        },
        disabled: {
          type: Boolean,
          required: true
        },
        onUpdateChecked: {
          type: Function,
          required: true
        }
      },
      setup(props) {
        const {
          mergedCheckedRowKeySetRef,
          componentId
        } = vue.inject(dataTableInjectionKey);
        return () => {
          const { rowKey } = props;
          return /* @__PURE__ */ vue.h(NRadio, {
            name: componentId,
            disabled: props.disabled,
            checked: mergedCheckedRowKeySetRef.value.has(rowKey),
            onUpdateChecked: props.onUpdateChecked
          });
        };
      }
    });

    function flatten(rowInfos, expandedRowKeys) {
      const fRows = [];
      function traverse(rs, rootIndex) {
        rs.forEach((r) => {
          if (r.children && expandedRowKeys.has(r.key)) {
            fRows.push({
              tmNode: r,
              striped: false,
              key: r.key,
              index: rootIndex
            });
            traverse(r.children, rootIndex);
          } else {
            fRows.push({
              key: r.key,
              tmNode: r,
              striped: false,
              index: rootIndex
            });
          }
        });
      }
      rowInfos.forEach((rowInfo) => {
        fRows.push(rowInfo);
        const { children } = rowInfo.tmNode;
        if (children && expandedRowKeys.has(rowInfo.key)) {
          traverse(children, rowInfo.index);
        }
      });
      return fRows;
    }
    const VirtualListItemWrapper = vue.defineComponent({
      props: {
        clsPrefix: {
          type: String,
          required: true
        },
        id: {
          type: String,
          required: true
        },
        cols: {
          type: Array,
          required: true
        },
        onMouseenter: Function,
        onMouseleave: Function
      },
      render() {
        const { clsPrefix, id, cols, onMouseenter, onMouseleave } = this;
        return /* @__PURE__ */ vue.h("table", {
          style: { tableLayout: "fixed" },
          class: `${clsPrefix}-data-table-table`,
          onMouseenter,
          onMouseleave
        }, /* @__PURE__ */ vue.h("colgroup", null, cols.map((col) => /* @__PURE__ */ vue.h("col", {
          key: col.key,
          style: col.style
        }))), /* @__PURE__ */ vue.h("tbody", {
          "data-n-id": id,
          class: `${clsPrefix}-data-table-tbody`
        }, this.$slots));
      }
    });
    var TableBody = vue.defineComponent({
      name: "DataTableBody",
      props: {
        onResize: Function,
        showHeader: Boolean,
        flexHeight: Boolean,
        bodyStyle: Object
      },
      setup(props) {
        const {
          slots: dataTableSlots,
          bodyWidthRef,
          mergedExpandedRowKeysRef,
          mergedClsPrefixRef,
          mergedThemeRef,
          scrollXRef,
          colsRef,
          paginatedDataRef,
          rawPaginatedDataRef,
          fixedColumnLeftMapRef,
          fixedColumnRightMapRef,
          mergedCurrentPageRef,
          rowClassNameRef,
          leftActiveFixedColKeyRef,
          leftActiveFixedChildrenColKeysRef,
          rightActiveFixedColKeyRef,
          rightActiveFixedChildrenColKeysRef,
          renderExpandRef,
          hoverKeyRef,
          summaryRef,
          mergedSortStateRef,
          virtualScrollRef,
          componentId,
          scrollPartRef,
          mergedTableLayoutRef,
          childTriggerColIndexRef,
          indentRef,
          rowPropsRef,
          maxHeightRef,
          stripedRef,
          loadingRef,
          onLoadRef,
          loadingKeySetRef,
          expandableRef,
          stickyExpandedRowsRef,
          renderExpandIconRef,
          setHeaderScrollLeft,
          doUpdateExpandedRowKeys,
          handleTableBodyScroll,
          doCheck,
          doUncheck,
          renderCell
        } = vue.inject(dataTableInjectionKey);
        const scrollbarInstRef = vue.ref(null);
        const virtualListRef = vue.ref(null);
        const emptyElRef = vue.ref(null);
        const emptyRef = useMemo(() => paginatedDataRef.value.length === 0);
        const shouldDisplaySomeTablePartRef = useMemo(
          () => props.showHeader || !emptyRef.value
        );
        const bodyShowHeaderOnlyRef = useMemo(() => {
          return props.showHeader || emptyRef.value;
        });
        let lastSelectedKey = "";
        const mergedExpandedRowKeySetRef = vue.computed(() => {
          return new Set(mergedExpandedRowKeysRef.value);
        });
        function handleCheckboxUpdateChecked(tmNode, checked, shiftKey) {
          if (shiftKey) {
            const lastIndex = paginatedDataRef.value.findIndex(
              (item) => item.key === lastSelectedKey
            );
            if (lastIndex !== -1) {
              const currentIndex = paginatedDataRef.value.findIndex(
                (item) => item.key === tmNode.key
              );
              const start = Math.min(lastIndex, currentIndex);
              const end = Math.max(lastIndex, currentIndex);
              const rowKeysToCheck = [];
              paginatedDataRef.value.slice(start, end + 1).forEach((r) => {
                if (!r.disabled) {
                  rowKeysToCheck.push(r.key);
                }
              });
              if (checked) {
                doCheck(rowKeysToCheck, false);
              } else {
                doUncheck(rowKeysToCheck);
              }
              lastSelectedKey = tmNode.key;
              return;
            }
          }
          if (checked) {
            doCheck(tmNode.key, false);
          } else {
            doUncheck(tmNode.key);
          }
          lastSelectedKey = tmNode.key;
        }
        function handleRadioUpdateChecked(tmNode) {
          doCheck(tmNode.key, true);
        }
        function getScrollContainer() {
          if (!shouldDisplaySomeTablePartRef.value) {
            const { value: emptyEl } = emptyElRef;
            if (emptyEl) {
              return emptyEl;
            } else {
              return null;
            }
          }
          if (virtualScrollRef.value) {
            return virtualListContainer();
          }
          const { value } = scrollbarInstRef;
          if (value)
            return value.containerRef;
          return null;
        }
        function handleUpdateExpanded(key, tmNode) {
          if (loadingKeySetRef.value.has(key))
            return;
          const { value: mergedExpandedRowKeys } = mergedExpandedRowKeysRef;
          const index = mergedExpandedRowKeys.indexOf(key);
          const nextExpandedKeys = Array.from(mergedExpandedRowKeys);
          if (~index) {
            nextExpandedKeys.splice(index, 1);
            doUpdateExpandedRowKeys(nextExpandedKeys);
          } else {
            if (tmNode && !tmNode.isLeaf && !tmNode.shallowLoaded) {
              loadingKeySetRef.value.add(key);
              void onLoadRef.value?.(tmNode.rawNode).then(() => {
                const { value: futureMergedExpandedRowKeys } = mergedExpandedRowKeysRef;
                const futureNextExpandedKeys = Array.from(
                  futureMergedExpandedRowKeys
                );
                const index2 = futureNextExpandedKeys.indexOf(key);
                if (!~index2) {
                  futureNextExpandedKeys.push(key);
                }
                doUpdateExpandedRowKeys(futureNextExpandedKeys);
              }).finally(() => {
                loadingKeySetRef.value.delete(key);
              });
            } else {
              nextExpandedKeys.push(key);
              doUpdateExpandedRowKeys(nextExpandedKeys);
            }
          }
        }
        function handleMouseleaveTable() {
          hoverKeyRef.value = null;
        }
        function handleMouseenterTable() {
          scrollPartRef.value = "body";
        }
        function virtualListContainer() {
          const { value } = virtualListRef;
          return value?.listElRef;
        }
        function virtualListContent() {
          const { value } = virtualListRef;
          return value?.itemsElRef;
        }
        function handleVirtualListScroll(e) {
          handleTableBodyScroll(e);
          scrollbarInstRef.value?.sync();
        }
        function handleVirtualListResize(e) {
          const { onResize } = props;
          if (onResize)
            onResize(e);
          scrollbarInstRef.value?.sync();
        }
        const exposedMethods = {
          getScrollContainer,
          scrollTo(arg0, arg1) {
            if (virtualScrollRef.value) {
              virtualListRef.value?.scrollTo(arg0, arg1);
            } else {
              scrollbarInstRef.value?.scrollTo(arg0, arg1);
            }
          }
        };
        const style = c$1([
          ({ props: cProps }) => {
            const createActiveLeftFixedStyle = (leftActiveFixedColKey) => {
              if (leftActiveFixedColKey === null)
                return null;
              return c$1(
                `[data-n-id="${cProps.componentId}"] [data-col-key="${leftActiveFixedColKey}"]::after`,
                { boxShadow: "var(--n-box-shadow-after)" }
              );
            };
            const createActiveRightFixedStyle = (rightActiveFixedColKey) => {
              if (rightActiveFixedColKey === null)
                return null;
              return c$1(
                `[data-n-id="${cProps.componentId}"] [data-col-key="${rightActiveFixedColKey}"]::before`,
                { boxShadow: "var(--n-box-shadow-before)" }
              );
            };
            return c$1([
              createActiveLeftFixedStyle(cProps.leftActiveFixedColKey),
              createActiveRightFixedStyle(cProps.rightActiveFixedColKey),
              cProps.leftActiveFixedChildrenColKeys.map(
                (leftActiveFixedColKey) => createActiveLeftFixedStyle(leftActiveFixedColKey)
              ),
              cProps.rightActiveFixedChildrenColKeys.map(
                (rightActiveFixedColKey) => createActiveRightFixedStyle(rightActiveFixedColKey)
              )
            ]);
          }
        ]);
        let fixedStyleMounted = false;
        vue.watchEffect(() => {
          const { value: leftActiveFixedColKey } = leftActiveFixedColKeyRef;
          const { value: leftActiveFixedChildrenColKeys } = leftActiveFixedChildrenColKeysRef;
          const { value: rightActiveFixedColKey } = rightActiveFixedColKeyRef;
          const { value: rightActiveFixedChildrenColKeys } = rightActiveFixedChildrenColKeysRef;
          if (!fixedStyleMounted && leftActiveFixedColKey === null && rightActiveFixedColKey === null) {
            return;
          }
          const cProps = {
            leftActiveFixedColKey,
            leftActiveFixedChildrenColKeys,
            rightActiveFixedColKey,
            rightActiveFixedChildrenColKeys,
            componentId
          };
          style.mount({
            id: `n-${componentId}`,
            force: true,
            props: cProps,
            anchorMetaName: cssrAnchorMetaName
          });
          fixedStyleMounted = true;
        });
        vue.onUnmounted(() => {
          style.unmount({
            id: `n-${componentId}`
          });
        });
        return {
          bodyWidth: bodyWidthRef,
          dataTableSlots,
          componentId,
          scrollbarInstRef,
          virtualListRef,
          emptyElRef,
          summary: summaryRef,
          mergedClsPrefix: mergedClsPrefixRef,
          mergedTheme: mergedThemeRef,
          scrollX: scrollXRef,
          cols: colsRef,
          loading: loadingRef,
          bodyShowHeaderOnly: bodyShowHeaderOnlyRef,
          shouldDisplaySomeTablePart: shouldDisplaySomeTablePartRef,
          empty: emptyRef,
          paginatedDataAndInfo: vue.computed(() => {
            const { value: striped } = stripedRef;
            let hasChildren = false;
            const data = paginatedDataRef.value.map(
              striped ? (tmNode, index) => {
                if (!tmNode.isLeaf)
                  hasChildren = true;
                return {
                  tmNode,
                  key: tmNode.key,
                  striped: index % 2 === 1,
                  index
                };
              } : (tmNode, index) => {
                if (!tmNode.isLeaf)
                  hasChildren = true;
                return {
                  tmNode,
                  key: tmNode.key,
                  striped: false,
                  index
                };
              }
            );
            return {
              data,
              hasChildren
            };
          }),
          rawPaginatedData: rawPaginatedDataRef,
          fixedColumnLeftMap: fixedColumnLeftMapRef,
          fixedColumnRightMap: fixedColumnRightMapRef,
          currentPage: mergedCurrentPageRef,
          rowClassName: rowClassNameRef,
          renderExpand: renderExpandRef,
          mergedExpandedRowKeySet: mergedExpandedRowKeySetRef,
          hoverKey: hoverKeyRef,
          mergedSortState: mergedSortStateRef,
          virtualScroll: virtualScrollRef,
          mergedTableLayout: mergedTableLayoutRef,
          childTriggerColIndex: childTriggerColIndexRef,
          indent: indentRef,
          rowProps: rowPropsRef,
          maxHeight: maxHeightRef,
          loadingKeySet: loadingKeySetRef,
          expandable: expandableRef,
          stickyExpandedRows: stickyExpandedRowsRef,
          renderExpandIcon: renderExpandIconRef,
          setHeaderScrollLeft,
          handleMouseenterTable,
          handleVirtualListScroll,
          handleVirtualListResize,
          handleMouseleaveTable,
          virtualListContainer,
          virtualListContent,
          handleTableBodyScroll,
          handleCheckboxUpdateChecked,
          handleRadioUpdateChecked,
          handleUpdateExpanded,
          renderCell,
          ...exposedMethods
        };
      },
      render() {
        const {
          mergedTheme,
          scrollX,
          mergedClsPrefix,
          virtualScroll,
          maxHeight,
          mergedTableLayout,
          flexHeight,
          loadingKeySet,
          onResize,
          setHeaderScrollLeft
        } = this;
        const scrollable = scrollX !== void 0 || maxHeight !== void 0 || flexHeight;
        const isBasicAutoLayout = !scrollable && mergedTableLayout === "auto";
        const xScrollable = scrollX !== void 0 || isBasicAutoLayout;
        const contentStyle = {
          minWidth: formatLength(scrollX) || "100%"
        };
        if (scrollX)
          contentStyle.width = "100%";
        const tableNode = /* @__PURE__ */ vue.h(NScrollbar, {
          ref: "scrollbarInstRef",
          scrollable: scrollable || isBasicAutoLayout,
          class: `${mergedClsPrefix}-data-table-base-table-body`,
          style: this.bodyStyle,
          theme: mergedTheme.peers.Scrollbar,
          themeOverrides: mergedTheme.peerOverrides.Scrollbar,
          contentStyle,
          container: virtualScroll ? this.virtualListContainer : void 0,
          content: virtualScroll ? this.virtualListContent : void 0,
          horizontalRailStyle: { zIndex: 3 },
          verticalRailStyle: { zIndex: 3 },
          xScrollable,
          onScroll: virtualScroll ? void 0 : this.handleTableBodyScroll,
          internalOnUpdateScrollLeft: setHeaderScrollLeft,
          onResize
        }, {
          default: () => {
            const cordToPass = {};
            const cordKey = {};
            const {
              cols,
              paginatedDataAndInfo,
              mergedTheme: mergedTheme2,
              fixedColumnLeftMap,
              fixedColumnRightMap,
              currentPage,
              rowClassName,
              mergedSortState,
              mergedExpandedRowKeySet,
              stickyExpandedRows,
              componentId,
              childTriggerColIndex,
              expandable,
              rowProps,
              handleMouseenterTable,
              handleMouseleaveTable,
              renderExpand,
              summary,
              handleCheckboxUpdateChecked,
              handleRadioUpdateChecked,
              handleUpdateExpanded
            } = this;
            const { length: colCount } = cols;
            let mergedData;
            const { data: paginatedData, hasChildren } = paginatedDataAndInfo;
            const mergedPaginationData = hasChildren ? flatten(paginatedData, mergedExpandedRowKeySet) : paginatedData;
            if (summary) {
              const summaryRows = summary(this.rawPaginatedData);
              if (Array.isArray(summaryRows)) {
                mergedData = [
                  ...mergedPaginationData,
                  ...summaryRows.map((row, i) => ({
                    isSummaryRow: true,
                    key: `__n_summary__${i}`,
                    tmNode: {
                      rawNode: row,
                      disabled: true
                    },
                    index: -1
                  }))
                ];
              } else {
                mergedData = [
                  ...mergedPaginationData,
                  {
                    isSummaryRow: true,
                    key: "__n_summary__",
                    tmNode: {
                      rawNode: summaryRows,
                      disabled: true
                    },
                    index: -1
                  }
                ];
              }
            } else {
              mergedData = mergedPaginationData;
            }
            const indentStyle = hasChildren ? { width: pxfy(this.indent) } : void 0;
            const displayedData = [];
            mergedData.forEach((rowInfo) => {
              if (renderExpand && mergedExpandedRowKeySet.has(rowInfo.key) && (!expandable || expandable(rowInfo.tmNode.rawNode))) {
                displayedData.push(rowInfo, {
                  isExpandedRow: true,
                  key: `${rowInfo.key}-expand`,
                  tmNode: rowInfo.tmNode,
                  index: rowInfo.index
                });
              } else {
                displayedData.push(rowInfo);
              }
            });
            const { length: rowCount } = displayedData;
            const rowIndexToKey = {};
            paginatedData.forEach(({ tmNode }, rowIndex) => {
              rowIndexToKey[rowIndex] = tmNode.key;
            });
            const bodyWidth = stickyExpandedRows ? this.bodyWidth : null;
            const bodyWidthPx = bodyWidth === null ? void 0 : `${bodyWidth}px`;
            const renderRow = (rowInfo, displayedRowIndex, isVirtual) => {
              const { index: actualRowIndex } = rowInfo;
              if ("isExpandedRow" in rowInfo) {
                const {
                  tmNode: { key, rawNode }
                } = rowInfo;
                return /* @__PURE__ */ vue.h("tr", {
                  class: `${mergedClsPrefix}-data-table-tr`,
                  key: `${key}__expand`
                }, /* @__PURE__ */ vue.h("td", {
                  class: [
                    `${mergedClsPrefix}-data-table-td`,
                    `${mergedClsPrefix}-data-table-td--last-col`,
                    displayedRowIndex + 1 === rowCount && `${mergedClsPrefix}-data-table-td--last-row`
                  ],
                  colspan: colCount
                }, stickyExpandedRows ? /* @__PURE__ */ vue.h("div", {
                  class: `${mergedClsPrefix}-data-table-expand`,
                  style: {
                    width: bodyWidthPx
                  }
                }, renderExpand(rawNode, actualRowIndex)) : renderExpand(rawNode, actualRowIndex)));
              }
              const isSummary = "isSummaryRow" in rowInfo;
              const striped = !isSummary && rowInfo.striped;
              const { tmNode, key: rowKey } = rowInfo;
              const { rawNode: rowData } = tmNode;
              const expanded = mergedExpandedRowKeySet.has(rowKey);
              const props = rowProps ? rowProps(rowData, actualRowIndex) : void 0;
              const mergedRowClassName = typeof rowClassName === "string" ? rowClassName : createRowClassName(rowData, actualRowIndex, rowClassName);
              const row = /* @__PURE__ */ vue.h("tr", {
                onMouseenter: () => {
                  this.hoverKey = rowKey;
                },
                key: rowKey,
                class: [
                  `${mergedClsPrefix}-data-table-tr`,
                  isSummary && `${mergedClsPrefix}-data-table-tr--summary`,
                  striped && `${mergedClsPrefix}-data-table-tr--striped`,
                  mergedRowClassName
                ],
                ...props
              }, cols.map((col, colIndex) => {
                if (displayedRowIndex in cordToPass) {
                  const cordOfRowToPass = cordToPass[displayedRowIndex];
                  const indexInCordOfRowToPass = cordOfRowToPass.indexOf(colIndex);
                  if (~indexInCordOfRowToPass) {
                    cordOfRowToPass.splice(indexInCordOfRowToPass, 1);
                    return null;
                  }
                }
                const { column } = col;
                const colKey = getColKey(col);
                const { rowSpan, colSpan } = column;
                const mergedColSpan = isSummary ? rowInfo.tmNode.rawNode[colKey]?.colSpan || 1 : colSpan ? colSpan(rowData, actualRowIndex) : 1;
                const mergedRowSpan = isSummary ? rowInfo.tmNode.rawNode[colKey]?.rowSpan || 1 : rowSpan ? rowSpan(rowData, actualRowIndex) : 1;
                const isLastCol = colIndex + mergedColSpan === colCount;
                const isLastRow = displayedRowIndex + mergedRowSpan === rowCount;
                const isCrossRowTd = mergedRowSpan > 1;
                if (isCrossRowTd) {
                  cordKey[displayedRowIndex] = {
                    [colIndex]: []
                  };
                }
                if (mergedColSpan > 1 || isCrossRowTd) {
                  for (let i = displayedRowIndex; i < displayedRowIndex + mergedRowSpan; ++i) {
                    if (isCrossRowTd) {
                      cordKey[displayedRowIndex][colIndex].push(
                        rowIndexToKey[i]
                      );
                    }
                    for (let j = colIndex; j < colIndex + mergedColSpan; ++j) {
                      if (i === displayedRowIndex && j === colIndex) {
                        continue;
                      }
                      if (!(i in cordToPass)) {
                        cordToPass[i] = [j];
                      } else {
                        cordToPass[i].push(j);
                      }
                    }
                  }
                }
                const hoverKey = isCrossRowTd ? this.hoverKey : null;
                const { cellProps } = column;
                const resolvedCellProps = cellProps?.(
                  rowData,
                  actualRowIndex
                );
                return /* @__PURE__ */ vue.h("td", {
                  ...resolvedCellProps,
                  key: colKey,
                  style: [
                    {
                      textAlign: column.align || void 0,
                      left: pxfy(fixedColumnLeftMap[colKey]?.start),
                      right: pxfy(fixedColumnRightMap[colKey]?.start)
                    },
                    resolvedCellProps?.style || ""
                  ],
                  colspan: mergedColSpan,
                  rowspan: isVirtual ? void 0 : mergedRowSpan,
                  "data-col-key": colKey,
                  class: [
                    `${mergedClsPrefix}-data-table-td`,
                    column.className,
                    resolvedCellProps?.class,
                    isSummary && `${mergedClsPrefix}-data-table-td--summary`,
                    (hoverKey !== null && cordKey[displayedRowIndex][colIndex].includes(
                      hoverKey
                    ) || isColumnSorting(column, mergedSortState)) && `${mergedClsPrefix}-data-table-td--hover`,
                    column.fixed && `${mergedClsPrefix}-data-table-td--fixed-${column.fixed}`,
                    column.align && `${mergedClsPrefix}-data-table-td--${column.align}-align`,
                    column.type === "selection" && `${mergedClsPrefix}-data-table-td--selection`,
                    column.type === "expand" && `${mergedClsPrefix}-data-table-td--expand`,
                    isLastCol && `${mergedClsPrefix}-data-table-td--last-col`,
                    isLastRow && `${mergedClsPrefix}-data-table-td--last-row`
                  ]
                }, hasChildren && colIndex === childTriggerColIndex ? [
                  repeat(
                    isSummary ? 0 : rowInfo.tmNode.level,
                    /* @__PURE__ */ vue.h("div", {
                      class: `${mergedClsPrefix}-data-table-indent`,
                      style: indentStyle
                    })
                  ),
                  isSummary || rowInfo.tmNode.isLeaf ? /* @__PURE__ */ vue.h("div", {
                    class: `${mergedClsPrefix}-data-table-expand-placeholder`
                  }) : /* @__PURE__ */ vue.h(ExpandTrigger, {
                    class: `${mergedClsPrefix}-data-table-expand-trigger`,
                    clsPrefix: mergedClsPrefix,
                    expanded,
                    renderExpandIcon: this.renderExpandIcon,
                    loading: loadingKeySet.has(rowInfo.key),
                    onClick: () => {
                      handleUpdateExpanded(rowKey, rowInfo.tmNode);
                    }
                  })
                ] : null, column.type === "selection" ? !isSummary ? column.multiple === false ? /* @__PURE__ */ vue.h(RenderSafeRadio, {
                  key: currentPage,
                  rowKey,
                  disabled: rowInfo.tmNode.disabled,
                  onUpdateChecked: () => handleRadioUpdateChecked(rowInfo.tmNode)
                }) : /* @__PURE__ */ vue.h(RenderSafeCheckbox, {
                  key: currentPage,
                  rowKey,
                  disabled: rowInfo.tmNode.disabled,
                  onUpdateChecked: (checked, e) => handleCheckboxUpdateChecked(
                    rowInfo.tmNode,
                    checked,
                    e.shiftKey
                  )
                }) : null : column.type === "expand" ? !isSummary ? !column.expandable || column.expandable?.(rowData) ? /* @__PURE__ */ vue.h(ExpandTrigger, {
                  clsPrefix: mergedClsPrefix,
                  expanded,
                  renderExpandIcon: this.renderExpandIcon,
                  onClick: () => handleUpdateExpanded(rowKey, null)
                }) : null : null : /* @__PURE__ */ vue.h(Cell, {
                  clsPrefix: mergedClsPrefix,
                  index: actualRowIndex,
                  row: rowData,
                  column,
                  isSummary,
                  mergedTheme: mergedTheme2,
                  renderCell: this.renderCell
                }));
              }));
              return row;
            };
            if (!virtualScroll) {
              return /* @__PURE__ */ vue.h("table", {
                class: `${mergedClsPrefix}-data-table-table`,
                onMouseleave: handleMouseleaveTable,
                onMouseenter: handleMouseenterTable,
                style: {
                  tableLayout: this.mergedTableLayout
                }
              }, /* @__PURE__ */ vue.h("colgroup", null, cols.map((col) => /* @__PURE__ */ vue.h("col", {
                key: col.key,
                style: col.style
              }))), this.showHeader ? /* @__PURE__ */ vue.h(TableHeader, {
                discrete: false
              }) : null, !this.empty ? /* @__PURE__ */ vue.h("tbody", {
                "data-n-id": componentId,
                class: `${mergedClsPrefix}-data-table-tbody`
              }, displayedData.map((rowInfo, displayedRowIndex) => {
                return renderRow(rowInfo, displayedRowIndex, false);
              })) : null);
            } else {
              return /* @__PURE__ */ vue.h(VVirtualList, {
                ref: "virtualListRef",
                items: displayedData,
                itemSize: 28,
                visibleItemsTag: VirtualListItemWrapper,
                visibleItemsProps: {
                  clsPrefix: mergedClsPrefix,
                  id: componentId,
                  cols,
                  onMouseenter: handleMouseenterTable,
                  onMouseleave: handleMouseleaveTable
                },
                showScrollbar: false,
                onResize: this.handleVirtualListResize,
                onScroll: this.handleVirtualListScroll,
                itemsStyle: contentStyle,
                itemResizable: true
              }, {
                default: ({
                  item,
                  index
                }) => renderRow(item, index, true)
              });
            }
          }
        });
        if (this.empty) {
          const createEmptyNode = () => /* @__PURE__ */ vue.h("div", {
            class: [
              `${mergedClsPrefix}-data-table-empty`,
              this.loading && `${mergedClsPrefix}-data-table-empty--hide`
            ],
            style: this.bodyStyle,
            ref: "emptyElRef"
          }, resolveSlot(this.dataTableSlots.empty, () => [
            /* @__PURE__ */ vue.h(NEmpty, {
              theme: this.mergedTheme.peers.Empty,
              themeOverrides: this.mergedTheme.peerOverrides.Empty
            })
          ]));
          if (this.shouldDisplaySomeTablePart) {
            return /* @__PURE__ */ vue.h(vue.Fragment, null, tableNode, createEmptyNode());
          } else {
            return /* @__PURE__ */ vue.h(VResizeObserver, {
              onResize: this.onResize
            }, { default: createEmptyNode });
          }
        }
        return tableNode;
      }
    });

    var MainTable = vue.defineComponent({
      setup() {
        const {
          mergedClsPrefixRef,
          rightFixedColumnsRef,
          leftFixedColumnsRef,
          bodyWidthRef,
          maxHeightRef,
          minHeightRef,
          flexHeightRef,
          syncScrollState
        } = vue.inject(dataTableInjectionKey);
        const headerInstRef = vue.ref(null);
        const bodyInstRef = vue.ref(null);
        const selfElRef = vue.ref(null);
        const fixedStateInitializedRef = vue.ref(
          !(leftFixedColumnsRef.value.length || rightFixedColumnsRef.value.length)
        );
        const bodyStyleRef = vue.computed(() => {
          return {
            maxHeight: formatLength(maxHeightRef.value),
            minHeight: formatLength(minHeightRef.value)
          };
        });
        function handleBodyResize(entry) {
          bodyWidthRef.value = entry.contentRect.width;
          syncScrollState();
          if (!fixedStateInitializedRef.value) {
            fixedStateInitializedRef.value = true;
          }
        }
        function getHeaderElement() {
          const { value } = headerInstRef;
          if (value) {
            return value.$el;
          }
          return null;
        }
        function getBodyElement() {
          const { value } = bodyInstRef;
          if (value) {
            return value.getScrollContainer();
          }
          return null;
        }
        const exposedMethods = {
          getBodyElement,
          getHeaderElement,
          scrollTo(arg0, arg1) {
            bodyInstRef.value?.scrollTo(arg0, arg1);
          }
        };
        vue.watchEffect(() => {
          const { value: selfEl } = selfElRef;
          if (!selfEl)
            return;
          const transitionDisabledClass = `${mergedClsPrefixRef.value}-data-table-base-table--transition-disabled`;
          if (fixedStateInitializedRef.value) {
            setTimeout(() => {
              selfEl.classList.remove(transitionDisabledClass);
            }, 0);
          } else {
            selfEl.classList.add(transitionDisabledClass);
          }
        });
        return {
          maxHeight: maxHeightRef,
          mergedClsPrefix: mergedClsPrefixRef,
          selfElRef,
          headerInstRef,
          bodyInstRef,
          bodyStyle: bodyStyleRef,
          flexHeight: flexHeightRef,
          handleBodyResize,
          ...exposedMethods
        };
      },
      render() {
        const { mergedClsPrefix, maxHeight, flexHeight } = this;
        const headerInBody = maxHeight === void 0 && !flexHeight;
        return /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-data-table-base-table`,
          ref: "selfElRef"
        }, headerInBody ? null : /* @__PURE__ */ vue.h(TableHeader, {
          ref: "headerInstRef"
        }), /* @__PURE__ */ vue.h(TableBody, {
          ref: "bodyInstRef",
          bodyStyle: this.bodyStyle,
          showHeader: headerInBody,
          flexHeight,
          onResize: this.handleBodyResize
        }));
      }
    });

    function useCheck(props, data) {
      const {
        paginatedDataRef,
        treeMateRef,
        selectionColumnRef
      } = data;
      const uncontrolledCheckedRowKeysRef = vue.ref(props.defaultCheckedRowKeys);
      const mergedCheckState = vue.computed(() => {
        var _selectionColumnRef$v;

        const {
          checkedRowKeys
        } = props;
        const sourceKeys = checkedRowKeys === void 0 ? uncontrolledCheckedRowKeysRef.value : checkedRowKeys;

        if (((_selectionColumnRef$v = selectionColumnRef.value) === null || _selectionColumnRef$v === void 0 ? void 0 : _selectionColumnRef$v.multiple) === false) {
          return {
            checkedKeys: sourceKeys.slice(0, 1),
            indeterminateKeys: []
          };
        }

        return treeMateRef.value.getCheckedKeys(sourceKeys, {
          cascade: props.cascade,
          allowNotLoaded: props.allowCheckingNotLoaded
        });
      });
      const mergedCheckedRowKeysRef = vue.computed(() => mergedCheckState.value.checkedKeys);
      const mergedInderminateRowKeysRef = vue.computed(() => mergedCheckState.value.indeterminateKeys);
      const mergedCheckedRowKeySetRef = vue.computed(() => {
        return new Set(mergedCheckedRowKeysRef.value);
      });
      const mergedInderminateRowKeySetRef = vue.computed(() => {
        return new Set(mergedInderminateRowKeysRef.value);
      });
      const countOfCurrentPageCheckedRowsRef = vue.computed(() => {
        const {
          value: mergedCheckedRowKeySet
        } = mergedCheckedRowKeySetRef;
        return paginatedDataRef.value.reduce((total, tmNode) => {
          const {
            key,
            disabled
          } = tmNode;
          return total + (!disabled && mergedCheckedRowKeySet.has(key) ? 1 : 0);
        }, 0);
      });
      const countOfCurrentPageDisabledRowsRef = vue.computed(() => {
        return paginatedDataRef.value.filter(item => item.disabled).length;
      });
      const someRowsCheckedRef = vue.computed(() => {
        const {
          length
        } = paginatedDataRef.value;
        const {
          value: mergedInderminateRowKeySet
        } = mergedInderminateRowKeySetRef;
        return countOfCurrentPageCheckedRowsRef.value > 0 && countOfCurrentPageCheckedRowsRef.value < length - countOfCurrentPageDisabledRowsRef.value || paginatedDataRef.value.some(rowData => mergedInderminateRowKeySet.has(rowData.key));
      });
      const allRowsCheckedRef = vue.computed(() => {
        const {
          length
        } = paginatedDataRef.value;
        return countOfCurrentPageCheckedRowsRef.value !== 0 && countOfCurrentPageCheckedRowsRef.value === length - countOfCurrentPageDisabledRowsRef.value;
      });
      const headerCheckboxDisabledRef = vue.computed(() => {
        return paginatedDataRef.value.length === 0;
      });

      function doUpdateCheckedRowKeys(keys) {
        const {
          "onUpdate:checkedRowKeys": _onUpdateCheckedRowKeys,
          onUpdateCheckedRowKeys,
          onCheckedRowKeysChange
        } = props;
        const rows = [];
        const {
          value: {
            getNode
          }
        } = treeMateRef;
        keys.forEach(key => {
          var _getNode;

          const row = (_getNode = getNode(key)) === null || _getNode === void 0 ? void 0 : _getNode.rawNode;
          rows.push(row);
        });
        if (_onUpdateCheckedRowKeys) call(_onUpdateCheckedRowKeys, keys, rows);
        if (onUpdateCheckedRowKeys) call(onUpdateCheckedRowKeys, keys, rows);
        if (onCheckedRowKeysChange) call(onCheckedRowKeysChange, keys, rows);
        uncontrolledCheckedRowKeysRef.value = keys;
      }

      function doCheck(rowKey) {
        let single = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        if (props.loading) return;

        if (single) {
          doUpdateCheckedRowKeys(Array.isArray(rowKey) ? rowKey.slice(0, 1) : [rowKey]);
          return;
        }

        doUpdateCheckedRowKeys(treeMateRef.value.check(rowKey, mergedCheckedRowKeysRef.value, {
          cascade: props.cascade,
          allowNotLoaded: props.allowCheckingNotLoaded
        }).checkedKeys);
      }

      function doUncheck(rowKey) {
        if (props.loading) return;
        doUpdateCheckedRowKeys(treeMateRef.value.uncheck(rowKey, mergedCheckedRowKeysRef.value, {
          cascade: props.cascade,
          allowNotLoaded: props.allowCheckingNotLoaded
        }).checkedKeys);
      }

      function doCheckAll() {
        let checkWholeTable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        const {
          value: column
        } = selectionColumnRef;
        if (!column || props.loading) return;
        const rowKeysToCheck = [];
        (checkWholeTable ? treeMateRef.value.treeNodes : paginatedDataRef.value).forEach(tmNode => {
          if (!tmNode.disabled) {
            rowKeysToCheck.push(tmNode.key);
          }
        });
        doUpdateCheckedRowKeys(treeMateRef.value.check(rowKeysToCheck, mergedCheckedRowKeysRef.value, {
          cascade: true,
          allowNotLoaded: props.allowCheckingNotLoaded
        }).checkedKeys);
      }

      function doUncheckAll() {
        let checkWholeTable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        const {
          value: column
        } = selectionColumnRef;
        if (!column || props.loading) return;
        const rowKeysToUncheck = [];
        (checkWholeTable ? treeMateRef.value.treeNodes : paginatedDataRef.value).forEach(tmNode => {
          if (!tmNode.disabled) {
            rowKeysToUncheck.push(tmNode.key);
          }
        });
        doUpdateCheckedRowKeys(treeMateRef.value.uncheck(rowKeysToUncheck, mergedCheckedRowKeysRef.value, {
          cascade: true,
          allowNotLoaded: props.allowCheckingNotLoaded
        }).checkedKeys);
      }

      return {
        mergedCheckedRowKeySetRef,
        mergedCheckedRowKeysRef,
        mergedInderminateRowKeySetRef,
        someRowsCheckedRef,
        allRowsCheckedRef,
        headerCheckboxDisabledRef,
        doUpdateCheckedRowKeys,
        doCheckAll,
        doUncheckAll,
        doCheck,
        doUncheck
      };
    }

    function getMultiplePriority(sorter) {
      if (typeof sorter === "object" && typeof sorter.multiple === "number") {
        return sorter.multiple;
      }

      return false;
    }

    function getSortFunction(sorter, columnKey) {
      if (columnKey && (sorter === void 0 || sorter === "default" || typeof sorter === "object" && sorter.compare === "default")) {
        return getDefaultSorterFn(columnKey);
      }

      if (typeof sorter === "function") {
        return sorter;
      }

      if (sorter && typeof sorter === "object" && sorter.compare && sorter.compare !== "default") {
        return sorter.compare;
      }

      return false;
    }

    function getDefaultSorterFn(columnKey) {
      return (row1, row2) => {
        const value1 = row1[columnKey];
        const value2 = row2[columnKey];

        if (typeof value1 === "number" && typeof value2 === "number") {
          return value1 - value2;
        } else if (typeof value1 === "string" && typeof value2 === "string") {
          return value1.localeCompare(value2);
        }

        return 0;
      };
    }

    function useSorter(props, _ref) {
      let {
        dataRelatedColsRef,
        filteredDataRef
      } = _ref;
      const defaultSortState = [];
      dataRelatedColsRef.value.forEach(column => {
        if (column.sorter !== void 0) {
          updateSortStatesByNewSortState(defaultSortState, {
            columnKey: column.key,
            sorter: column.sorter,
            order: column.defaultSortOrder ?? false
          });
        }
      });
      const uncontrolledSortStateRef = vue.ref(defaultSortState);
      const mergedSortStateRef = vue.computed(() => {
        const columnsWithControlledSortOrder = dataRelatedColsRef.value.filter(column => column.type !== "selection" && column.sorter !== void 0 && (column.sortOrder === "ascend" || column.sortOrder === "descend" || column.sortOrder === false));
        const columnToSort = columnsWithControlledSortOrder.filter(col => col.sortOrder !== false);

        if (columnToSort.length) {
          return columnToSort.map(column => {
            return {
              columnKey: column.key,
              order: column.sortOrder,
              sorter: column.sorter
            };
          });
        }

        if (columnsWithControlledSortOrder.length) return [];
        const {
          value: uncontrolledSortState
        } = uncontrolledSortStateRef;

        if (Array.isArray(uncontrolledSortState)) {
          return uncontrolledSortState;
        } else if (uncontrolledSortState) {
          return [uncontrolledSortState];
        } else {
          return [];
        }
      });
      const sortedDataRef = vue.computed(() => {
        const activeSorters = mergedSortStateRef.value.slice().sort((a, b) => {
          const item1Priority = getMultiplePriority(a.sorter) || 0;
          const item2Priority = getMultiplePriority(b.sorter) || 0;
          return item2Priority - item1Priority;
        });

        if (activeSorters.length) {
          const filteredData = filteredDataRef.value.slice();
          return filteredData.sort((tmNode1, tmNode2) => {
            let compareResult = 0;
            activeSorters.some(sorterState => {
              const {
                columnKey,
                sorter,
                order
              } = sorterState;
              const compareFn = getSortFunction(sorter, columnKey);

              if (compareFn && order) {
                compareResult = compareFn(tmNode1.rawNode, tmNode2.rawNode);

                if (compareResult !== 0) {
                  compareResult = compareResult * getFlagOfOrder(order);
                  return true;
                }
              }

              return false;
            });
            return compareResult;
          });
        }

        return filteredDataRef.value;
      });

      function getUpdatedSorterState(sortState) {
        let currentSortState = mergedSortStateRef.value.slice();

        if (sortState && getMultiplePriority(sortState.sorter) !== false) {
          currentSortState = currentSortState.filter(sortState2 => getMultiplePriority(sortState2.sorter) !== false);
          updateSortStatesByNewSortState(currentSortState, sortState);
          return currentSortState;
        } else if (sortState) {
          return sortState;
        }

        return null;
      }

      function deriveNextSorter(sortState) {
        const nextSorterState = getUpdatedSorterState(sortState);
        doUpdateSorter(nextSorterState);
      }

      function doUpdateSorter(sortState) {
        const {
          "onUpdate:sorter": _onUpdateSorter,
          onUpdateSorter,
          onSorterChange
        } = props;

        if (_onUpdateSorter) {
          call(_onUpdateSorter, sortState);
        }

        if (onUpdateSorter) {
          call(onUpdateSorter, sortState);
        }

        if (onSorterChange) {
          call(onSorterChange, sortState);
        }

        uncontrolledSortStateRef.value = sortState;
      }

      function sort(columnKey) {
        let order = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "ascend";

        if (!columnKey) {
          clearSorter();
        } else {
          const columnToSort = dataRelatedColsRef.value.find(column => column.type !== "selection" && column.type !== "expand" && column.key === columnKey);
          if (!columnToSort || !columnToSort.sorter) return;
          const sorter = columnToSort.sorter;
          deriveNextSorter({
            columnKey,
            sorter,
            order
          });
        }
      }

      function clearSorter() {
        doUpdateSorter(null);
      }

      function updateSortStatesByNewSortState(sortStates, sortState) {
        const index = sortStates.findIndex(state => (sortState === null || sortState === void 0 ? void 0 : sortState.columnKey) && state.columnKey === sortState.columnKey);

        if (index !== void 0 && index >= 0) {
          sortStates[index] = sortState;
        } else {
          sortStates.push(sortState);
        }
      }

      return {
        clearSorter,
        sort,
        sortedDataRef,
        mergedSortStateRef,
        deriveNextSorter
      };
    }

    function useTableData(props, _ref) {
      let {
        dataRelatedColsRef
      } = _ref;
      const selectionColumnRef = vue.computed(() => {
        const getSelectionColumn = cols => {
          for (let i = 0; i < cols.length; ++i) {
            const col = cols[i];

            if ("children" in col) {
              return getSelectionColumn(col.children);
            } else if (col.type === "selection") {
              return col;
            }
          }

          return null;
        };

        return getSelectionColumn(props.columns);
      });
      const treeMateRef = vue.computed(() => {
        const {
          childrenKey
        } = props;
        return createTreeMate(props.data, {
          ignoreEmptyChildren: true,
          getKey: props.rowKey,
          getChildren: rowData => rowData[childrenKey],
          getDisabled: rowData => {
            var _selectionColumnRef$v, _selectionColumnRef$v2;

            if ((_selectionColumnRef$v = selectionColumnRef.value) !== null && _selectionColumnRef$v !== void 0 && (_selectionColumnRef$v2 = _selectionColumnRef$v.disabled) !== null && _selectionColumnRef$v2 !== void 0 && _selectionColumnRef$v2.call(_selectionColumnRef$v, rowData)) {
              return true;
            }

            return false;
          }
        });
      });
      const childTriggerColIndexRef = useMemo(() => {
        const {
          columns
        } = props;
        const {
          length
        } = columns;
        let firstContentfulColIndex = null;

        for (let i = 0; i < length; ++i) {
          const col = columns[i];

          if (!col.type && firstContentfulColIndex === null) {
            firstContentfulColIndex = i;
          }

          if ("tree" in col && col.tree) {
            return i;
          }
        }

        return firstContentfulColIndex || 0;
      });
      const uncontrolledFilterStateRef = vue.ref({});
      const uncontrolledCurrentPageRef = vue.ref(1);
      const uncontrolledPageSizeRef = vue.ref(10);
      const mergedFilterStateRef = vue.computed(() => {
        const columnsWithControlledFilter = dataRelatedColsRef.value.filter(column => {
          return column.filterOptionValues !== void 0 || column.filterOptionValue !== void 0;
        });
        const controlledFilterState = {};
        columnsWithControlledFilter.forEach(column => {
          if (column.type === "selection" || column.type === "expand") return;

          if (column.filterOptionValues === void 0) {
            controlledFilterState[column.key] = column.filterOptionValue ?? null;
          } else {
            controlledFilterState[column.key] = column.filterOptionValues;
          }
        });
        const activeFilters = Object.assign(createShallowClonedObject(uncontrolledFilterStateRef.value), controlledFilterState);
        return activeFilters;
      });
      const filteredDataRef = vue.computed(() => {
        const mergedFilterState = mergedFilterStateRef.value;
        const {
          columns
        } = props;

        function createDefaultFilter(columnKey) {
          return (filterOptionValue, row) => !!~String(row[columnKey]).indexOf(String(filterOptionValue));
        }

        const {
          value: {
            treeNodes: data
          }
        } = treeMateRef;
        const columnEntries = [];
        columns.forEach(column => {
          if (column.type === "selection" || column.type === "expand" || "children" in column) {
            return;
          }

          columnEntries.push([column.key, column]);
        });
        return data ? data.filter(tmNode => {
          const {
            rawNode: row
          } = tmNode;

          for (const [columnKey, column] of columnEntries) {
            let activeFilterOptionValues = mergedFilterState[columnKey];
            if (activeFilterOptionValues == null) continue;

            if (!Array.isArray(activeFilterOptionValues)) {
              activeFilterOptionValues = [activeFilterOptionValues];
            }

            if (!activeFilterOptionValues.length) continue;
            const filter2 = column.filter === "default" ? createDefaultFilter(columnKey) : column.filter;

            if (column && typeof filter2 === "function") {
              if (column.filterMode === "and") {
                if (activeFilterOptionValues.some(filterOptionValue => !filter2(filterOptionValue, row))) {
                  return false;
                }
              } else {
                if (activeFilterOptionValues.some(filterOptionValue => filter2(filterOptionValue, row))) {
                  continue;
                } else {
                  return false;
                }
              }
            }
          }

          return true;
        }) : [];
      });
      const {
        sortedDataRef,
        deriveNextSorter,
        mergedSortStateRef,
        sort,
        clearSorter
      } = useSorter(props, {
        dataRelatedColsRef,
        filteredDataRef
      });
      dataRelatedColsRef.value.forEach(column => {
        if (column.filter) {
          const defaultFilterOptionValues = column.defaultFilterOptionValues;

          if (column.filterMultiple) {
            uncontrolledFilterStateRef.value[column.key] = defaultFilterOptionValues || [];
          } else if (defaultFilterOptionValues !== void 0) {
            uncontrolledFilterStateRef.value[column.key] = defaultFilterOptionValues === null ? [] : defaultFilterOptionValues;
          } else {
            uncontrolledFilterStateRef.value[column.key] = column.defaultFilterOptionValue ?? null;
          }
        }
      });
      const controlledCurrentPageRef = vue.computed(() => {
        const {
          pagination
        } = props;
        if (pagination === false) return void 0;
        return pagination.page;
      });
      const controlledPageSizeRef = vue.computed(() => {
        const {
          pagination
        } = props;
        if (pagination === false) return void 0;
        return pagination.pageSize;
      });

      const _mergedCurrentPageRef = useMergedState(controlledCurrentPageRef, uncontrolledCurrentPageRef);

      const mergedPageSizeRef = useMergedState(controlledPageSizeRef, uncontrolledPageSizeRef);
      const boundedMergedCurrentPageRef = useMemo(() => {
        const page2 = _mergedCurrentPageRef.value;
        return props.remote ? page2 : Math.max(1, Math.min(Math.ceil(filteredDataRef.value.length / mergedPageSizeRef.value), page2));
      });
      const mergedPageCountRef = vue.computed(() => {
        const {
          pagination
        } = props;

        if (pagination) {
          const {
            pageCount
          } = pagination;
          if (pageCount !== void 0) return pageCount;
        }

        return void 0;
      });
      const paginatedDataRef = vue.computed(() => {
        if (props.remote) return treeMateRef.value.treeNodes;
        if (!props.pagination) return sortedDataRef.value;
        const pageSize = mergedPageSizeRef.value;
        const startIndex = (boundedMergedCurrentPageRef.value - 1) * pageSize;
        return sortedDataRef.value.slice(startIndex, startIndex + pageSize);
      });
      const rawPaginatedDataRef = vue.computed(() => {
        return paginatedDataRef.value.map(tmNode => tmNode.rawNode);
      });

      function mergedOnUpdatePage(page2) {
        const {
          pagination
        } = props;

        if (pagination) {
          const {
            onChange,
            "onUpdate:page": _onUpdatePage,
            onUpdatePage
          } = pagination;
          if (onChange) call(onChange, page2);
          if (onUpdatePage) call(onUpdatePage, page2);
          if (_onUpdatePage) call(_onUpdatePage, page2);
          doUpdatePage(page2);
        }
      }

      function mergedOnUpdatePageSize(pageSize) {
        const {
          pagination
        } = props;

        if (pagination) {
          const {
            onPageSizeChange,
            "onUpdate:pageSize": _onUpdatePageSize,
            onUpdatePageSize
          } = pagination;
          if (onPageSizeChange) call(onPageSizeChange, pageSize);
          if (onUpdatePageSize) call(onUpdatePageSize, pageSize);
          if (_onUpdatePageSize) call(_onUpdatePageSize, pageSize);
          doUpdatePageSize(pageSize);
        }
      }

      const mergedItemCountRef = vue.computed(() => {
        if (props.remote) {
          const {
            pagination
          } = props;

          if (pagination) {
            const {
              itemCount
            } = pagination;
            if (itemCount !== void 0) return itemCount;
          }

          return void 0;
        }

        return filteredDataRef.value.length;
      });
      const mergedPaginationRef = vue.computed(() => {
        return { ...props.pagination,
          onChange: void 0,
          onUpdatePage: void 0,
          onUpdatePageSize: void 0,
          onPageSizeChange: void 0,
          "onUpdate:page": mergedOnUpdatePage,
          "onUpdate:pageSize": mergedOnUpdatePageSize,
          page: boundedMergedCurrentPageRef.value,
          pageSize: mergedPageSizeRef.value,
          pageCount: mergedItemCountRef.value === void 0 ? mergedPageCountRef.value : void 0,
          itemCount: mergedItemCountRef.value
        };
      });

      function doUpdatePage(page2) {
        const {
          "onUpdate:page": _onUpdatePage,
          onPageChange,
          onUpdatePage
        } = props;
        if (onUpdatePage) call(onUpdatePage, page2);
        if (_onUpdatePage) call(_onUpdatePage, page2);
        if (onPageChange) call(onPageChange, page2);
        uncontrolledCurrentPageRef.value = page2;
      }

      function doUpdatePageSize(pageSize) {
        const {
          "onUpdate:pageSize": _onUpdatePageSize,
          onPageSizeChange,
          onUpdatePageSize
        } = props;
        if (onPageSizeChange) call(onPageSizeChange, pageSize);
        if (onUpdatePageSize) call(onUpdatePageSize, pageSize);
        if (_onUpdatePageSize) call(_onUpdatePageSize, pageSize);
        uncontrolledPageSizeRef.value = pageSize;
      }

      function doUpdateFilters(filters2, sourceColumn) {
        const {
          onUpdateFilters,
          "onUpdate:filters": _onUpdateFilters,
          onFiltersChange
        } = props;
        if (onUpdateFilters) call(onUpdateFilters, filters2, sourceColumn);
        if (_onUpdateFilters) call(_onUpdateFilters, filters2, sourceColumn);
        if (onFiltersChange) call(onFiltersChange, filters2, sourceColumn);
        uncontrolledFilterStateRef.value = filters2;
      }

      function page(page2) {
        doUpdatePage(page2);
      }

      function clearFilter() {
        clearFilters();
      }

      function clearFilters() {
        filters({});
      }

      function filters(filters2) {
        filter(filters2);
      }

      function filter(filters2) {
        if (!filters2) {
          uncontrolledFilterStateRef.value = {};
        } else if (filters2) {
          uncontrolledFilterStateRef.value = createShallowClonedObject(filters2);
        } else {
          warn$2("data-table", "`filters` is not an object");
        }
      }

      return {
        treeMateRef,
        mergedCurrentPageRef: boundedMergedCurrentPageRef,
        mergedPaginationRef,
        paginatedDataRef,
        rawPaginatedDataRef,
        mergedFilterStateRef,
        mergedSortStateRef,
        hoverKeyRef: vue.ref(null),
        selectionColumnRef,
        childTriggerColIndexRef,
        doUpdateFilters,
        deriveNextSorter,
        doUpdatePageSize,
        doUpdatePage,
        filter,
        filters,
        clearFilter,
        clearFilters,
        clearSorter,
        page,
        sort
      };
    }

    function useScroll(props, _ref) {
      let {
        mainTableInstRef,
        mergedCurrentPageRef,
        bodyWidthRef,
        scrollPartRef
      } = _ref;
      let scrollLeft = 0;
      const leftActiveFixedColKeyRef = vue.ref(null);
      const leftActiveFixedChildrenColKeysRef = vue.ref([]);
      const rightActiveFixedColKeyRef = vue.ref(null);
      const rightActiveFixedChildrenColKeysRef = vue.ref([]);
      const styleScrollXRef = vue.computed(() => {
        return formatLength(props.scrollX);
      });
      const leftFixedColumnsRef = vue.computed(() => {
        return props.columns.filter(column => column.fixed === "left");
      });
      const rightFixedColumnsRef = vue.computed(() => {
        return props.columns.filter(column => column.fixed === "right");
      });
      const fixedColumnLeftMapRef = vue.computed(() => {
        const columns = {};
        let left = 0;

        function traverse(cols) {
          cols.forEach(col => {
            const positionInfo = {
              start: left,
              end: 0
            };
            columns[getColKey(col)] = positionInfo;

            if ("children" in col) {
              traverse(col.children);
              positionInfo.end = left;
            } else {
              left += getNumberColWidth(col) || 0;
              positionInfo.end = left;
            }
          });
        }

        traverse(leftFixedColumnsRef.value);
        return columns;
      });
      const fixedColumnRightMapRef = vue.computed(() => {
        const columns = {};
        let right = 0;

        function traverse(cols) {
          for (let i = cols.length - 1; i >= 0; --i) {
            const col = cols[i];
            const positionInfo = {
              start: right,
              end: 0
            };
            columns[getColKey(col)] = positionInfo;

            if ("children" in col) {
              traverse(col.children);
              positionInfo.end = right;
            } else {
              right += getNumberColWidth(col) || 0;
              positionInfo.end = right;
            }
          }
        }

        traverse(rightFixedColumnsRef.value);
        return columns;
      });

      function deriveActiveLeftFixedColumn() {
        const {
          value: leftFixedColumns
        } = leftFixedColumnsRef;
        let leftWidth = 0;
        const {
          value: fixedColumnLeftMap
        } = fixedColumnLeftMapRef;
        let leftActiveFixedColKey = null;

        for (let i = 0; i < leftFixedColumns.length; ++i) {
          var _fixedColumnLeftMap$k;

          const key = getColKey(leftFixedColumns[i]);

          if (scrollLeft > (((_fixedColumnLeftMap$k = fixedColumnLeftMap[key]) === null || _fixedColumnLeftMap$k === void 0 ? void 0 : _fixedColumnLeftMap$k.start) || 0) - leftWidth) {
            var _fixedColumnLeftMap$k2;

            leftActiveFixedColKey = key;
            leftWidth = ((_fixedColumnLeftMap$k2 = fixedColumnLeftMap[key]) === null || _fixedColumnLeftMap$k2 === void 0 ? void 0 : _fixedColumnLeftMap$k2.end) || 0;
          } else {
            break;
          }
        }

        leftActiveFixedColKeyRef.value = leftActiveFixedColKey;
      }

      function deriveActiveLeftFixedChildrenColumns() {
        leftActiveFixedChildrenColKeysRef.value = [];
        let activeLeftFixedColumn = props.columns.find(col => getColKey(col) === leftActiveFixedColKeyRef.value);

        while (activeLeftFixedColumn && "children" in activeLeftFixedColumn) {
          const length = activeLeftFixedColumn.children.length;
          if (length === 0) break;
          const nextActiveLeftFixedColumn = activeLeftFixedColumn.children[length - 1];
          leftActiveFixedChildrenColKeysRef.value.push(getColKey(nextActiveLeftFixedColumn));
          activeLeftFixedColumn = nextActiveLeftFixedColumn;
        }
      }

      function deriveActiveRightFixedColumn() {
        const {
          value: rightFixedColumns
        } = rightFixedColumnsRef;
        const scrollWidth = Number(props.scrollX);
        const {
          value: tableWidth
        } = bodyWidthRef;
        if (tableWidth === null) return;
        let rightWidth = 0;
        let rightActiveFixedColKey = null;
        const {
          value: fixedColumnRightMap
        } = fixedColumnRightMapRef;

        for (let i = rightFixedColumns.length - 1; i >= 0; --i) {
          var _fixedColumnRightMap$;

          const key = getColKey(rightFixedColumns[i]);

          if (Math.round(scrollLeft + (((_fixedColumnRightMap$ = fixedColumnRightMap[key]) === null || _fixedColumnRightMap$ === void 0 ? void 0 : _fixedColumnRightMap$.start) || 0) + tableWidth - rightWidth) < scrollWidth) {
            var _fixedColumnRightMap$2;

            rightActiveFixedColKey = key;
            rightWidth = ((_fixedColumnRightMap$2 = fixedColumnRightMap[key]) === null || _fixedColumnRightMap$2 === void 0 ? void 0 : _fixedColumnRightMap$2.end) || 0;
          } else {
            break;
          }
        }

        rightActiveFixedColKeyRef.value = rightActiveFixedColKey;
      }

      function deriveActiveRightFixedChildrenColumns() {
        rightActiveFixedChildrenColKeysRef.value = [];
        let activeRightFixedColumn = props.columns.find(col => getColKey(col) === rightActiveFixedColKeyRef.value);

        while (activeRightFixedColumn && "children" in activeRightFixedColumn && activeRightFixedColumn.children.length) {
          const nextActiveRightFixedColumn = activeRightFixedColumn.children[0];
          rightActiveFixedChildrenColKeysRef.value.push(getColKey(nextActiveRightFixedColumn));
          activeRightFixedColumn = nextActiveRightFixedColumn;
        }
      }

      function getScrollElements() {
        const header = mainTableInstRef.value ? mainTableInstRef.value.getHeaderElement() : null;
        const body = mainTableInstRef.value ? mainTableInstRef.value.getBodyElement() : null;
        return {
          header,
          body
        };
      }

      function scrollMainTableBodyToTop() {
        const {
          body
        } = getScrollElements();

        if (body) {
          body.scrollTop = 0;
        }
      }

      function handleTableHeaderScroll() {
        if (scrollPartRef.value === "head") {
          beforeNextFrameOnce(syncScrollState);
        }
      }

      function handleTableBodyScroll(e) {
        var _props$onScroll;

        (_props$onScroll = props.onScroll) === null || _props$onScroll === void 0 ? void 0 : _props$onScroll.call(props, e);

        if (scrollPartRef.value === "body") {
          beforeNextFrameOnce(syncScrollState);
        }
      }

      function syncScrollState() {
        const {
          header,
          body
        } = getScrollElements();
        if (!body) return;
        const {
          value: tableWidth
        } = bodyWidthRef;
        if (tableWidth === null) return;
        const {
          value: scrollPart
        } = scrollPartRef;

        if (props.maxHeight || props.flexHeight) {
          if (!header) return;

          if (scrollPart === "head") {
            scrollLeft = header.scrollLeft;
            body.scrollLeft = scrollLeft;
          } else {
            scrollLeft = body.scrollLeft;
            header.scrollLeft = scrollLeft;
          }
        } else {
          scrollLeft = body.scrollLeft;
        }

        deriveActiveLeftFixedColumn();
        deriveActiveLeftFixedChildrenColumns();
        deriveActiveRightFixedColumn();
        deriveActiveRightFixedChildrenColumns();
      }

      function setHeaderScrollLeft(left) {
        const {
          header
        } = getScrollElements();
        if (!header) return;
        header.scrollLeft = left;
        syncScrollState();
      }

      vue.watch(mergedCurrentPageRef, () => {
        scrollMainTableBodyToTop();
      });
      return {
        styleScrollXRef,
        fixedColumnLeftMapRef,
        fixedColumnRightMapRef,
        leftFixedColumnsRef,
        rightFixedColumnsRef,
        leftActiveFixedColKeyRef,
        leftActiveFixedChildrenColKeysRef,
        rightActiveFixedColKeyRef,
        rightActiveFixedChildrenColKeysRef,
        syncScrollState,
        handleTableBodyScroll,
        handleTableHeaderScroll,
        setHeaderScrollLeft
      };
    }

    function getRowsAndCols(columns) {
      const rows = [];
      const cols = [];
      const dataRelatedCols = [];
      const rowItemMap = /* @__PURE__ */new WeakMap();
      let maxDepth = -1;
      let totalRowSpan = 0;
      let hasEllipsis = false;

      function ensureMaxDepth(columns2, currentDepth) {
        if (currentDepth > maxDepth) {
          rows[currentDepth] = [];
          maxDepth = currentDepth;
        }

        for (const column of columns2) {
          if ("children" in column) {
            ensureMaxDepth(column.children, currentDepth + 1);
          } else {
            cols.push({
              key: getColKey(column),
              style: createCustomWidthStyle(column),
              column
            });
            totalRowSpan += 1;

            if (!hasEllipsis) {
              hasEllipsis = !!column.ellipsis;
            }

            dataRelatedCols.push(column);
          }
        }
      }

      ensureMaxDepth(columns, 0);
      let currentLeafIndex = 0;

      function ensureColLayout(columns2, currentDepth) {
        let hideUntilIndex = 0;
        columns2.forEach((column, index) => {
          if ("children" in column) {
            const cachedCurrentLeafIndex = currentLeafIndex;
            const rowItem = {
              column,
              colSpan: 0,
              rowSpan: 1,
              isLast: false
            };
            ensureColLayout(column.children, currentDepth + 1);
            column.children.forEach(childColumn => {
              var _rowItemMap$get;

              rowItem.colSpan += ((_rowItemMap$get = rowItemMap.get(childColumn)) === null || _rowItemMap$get === void 0 ? void 0 : _rowItemMap$get.colSpan) ?? 0;
            });

            if (cachedCurrentLeafIndex + rowItem.colSpan === totalRowSpan) {
              rowItem.isLast = true;
            }

            rowItemMap.set(column, rowItem);
            rows[currentDepth].push(rowItem);
          } else {
            if (currentLeafIndex < hideUntilIndex) {
              currentLeafIndex += 1;
              return;
            }

            let colSpan = 1;

            if ("titleColSpan" in column) {
              colSpan = column.titleColSpan ?? 1;
            }

            if (colSpan > 1) {
              hideUntilIndex = currentLeafIndex + colSpan;
            }

            const isLast = currentLeafIndex + colSpan === totalRowSpan;
            const rowItem = {
              column,
              colSpan,
              rowSpan: maxDepth - currentDepth + 1,
              isLast
            };
            rowItemMap.set(column, rowItem);
            rows[currentDepth].push(rowItem);
            currentLeafIndex += 1;
          }
        });
      }

      ensureColLayout(columns, 0);
      return {
        hasEllipsis,
        rows,
        cols,
        dataRelatedCols
      };
    }

    function useGroupHeader(props) {
      const rowsAndCols = vue.computed(() => getRowsAndCols(props.columns));
      return {
        rowsRef: vue.computed(() => rowsAndCols.value.rows),
        colsRef: vue.computed(() => rowsAndCols.value.cols),
        hasEllipsisRef: vue.computed(() => rowsAndCols.value.hasEllipsis),
        dataRelatedColsRef: vue.computed(() => rowsAndCols.value.dataRelatedCols)
      };
    }

    function useExpand(props, treeMateRef) {
      const renderExpandRef = useMemo(() => {
        for (const col of props.columns) {
          if (col.type === "expand") {
            if (!col.renderExpand) {
              warn$2("data-table", "column with type `expand` has no `renderExpand` prop.");
            }

            return col.renderExpand;
          }
        }
      });
      const expandableRef = useMemo(() => {
        let expandable;

        for (const col of props.columns) {
          if (col.type === "expand") {
            expandable = col.expandable;
            break;
          }
        }

        return expandable;
      });
      const uncontrolledExpandedRowKeysRef = vue.ref(props.defaultExpandAll ? renderExpandRef !== null && renderExpandRef !== void 0 && renderExpandRef.value ? (() => {
        const expandedKeys = [];
        treeMateRef.value.treeNodes.forEach(tmNode => {
          var _expandableRef$value;

          if ((_expandableRef$value = expandableRef.value) !== null && _expandableRef$value !== void 0 && _expandableRef$value.call(expandableRef, tmNode.rawNode)) {
            expandedKeys.push(tmNode.key);
          }
        });
        return expandedKeys;
      })() : treeMateRef.value.getNonLeafKeys() : props.defaultExpandedRowKeys);
      const controlledExpandedRowKeysRef = vue.toRef(props, "expandedRowKeys");
      const stickyExpandedRowsRef = vue.toRef(props, "stickyExpandedRows");
      const mergedExpandedRowKeysRef = useMergedState(controlledExpandedRowKeysRef, uncontrolledExpandedRowKeysRef);

      function doUpdateExpandedRowKeys(expandedKeys) {
        const {
          onUpdateExpandedRowKeys,
          "onUpdate:expandedRowKeys": _onUpdateExpandedRowKeys
        } = props;

        if (onUpdateExpandedRowKeys) {
          call(onUpdateExpandedRowKeys, expandedKeys);
        }

        if (_onUpdateExpandedRowKeys) {
          call(_onUpdateExpandedRowKeys, expandedKeys);
        }

        uncontrolledExpandedRowKeysRef.value = expandedKeys;
      }

      return {
        stickyExpandedRowsRef,
        mergedExpandedRowKeysRef,
        renderExpandRef,
        expandableRef,
        doUpdateExpandedRowKeys
      };
    }

    const fixedColumnStyle = createFixedColumnStyle();
    var style$T = c$1([cB("data-table", `
    width: 100%;
    font-size: var(--n-font-size);
    display: flex;
    flex-direction: column;
    position: relative;
    --n-merged-th-color: var(--n-th-color);
    --n-merged-td-color: var(--n-td-color);
    --n-merged-border-color: var(--n-border-color);
    --n-merged-th-color-hover: var(--n-th-color-hover);
    --n-merged-td-color-hover: var(--n-td-color-hover);
    --n-merged-td-color-striped: var(--n-td-color-striped);
  `, [cB("data-table-wrapper", `
      flex-grow: 1;
      display: flex;
      flex-direction: column;
    `), cM("flex-height", [c$1(">", [cB("data-table-wrapper", [c$1(">", [cB("data-table-base-table", `
              display: flex;
              flex-direction: column;
              flex-grow: 1;
            `, [c$1(">", [cB("data-table-base-table-body", "flex-basis: 0;", [c$1("&:last-child", "flex-grow: 1;")])])])])])])]), c$1(">", [cB("base-loading", `
        color: var(--n-loading-color);
        font-size: var(--n-loading-size);
        position: absolute;
        left: 50%;
        top: 50%;
        transform: translateX(-50%) translateY(-50%);
        transition: color .3s var(--n-bezier);
      `, [fadeInScaleUpTransition({
      originalTransform: "translateX(-50%) translateY(-50%)"
    })])]), cB("data-table-expand-placeholder", `
      margin-right: 8px;
      display: inline-block;
      width: 16px;
      height: 1px;
    `), cB("data-table-indent", `
      display: inline-block;
      height: 1px;
    `), cB("data-table-expand-trigger", `
      display: inline-flex;
      margin-right: 8px;
      cursor: pointer;
      font-size: 16px;
      vertical-align: -0.2em;
      position: relative;
      width: 16px;
      height: 16px;
      color: var(--n-td-text-color);
      transition: color .3s var(--n-bezier);
    `, [cM("expanded", [cB("icon", "transform: rotate(90deg);", [iconSwitchTransition({
      originalTransform: "rotate(90deg)"
    })]), cB("base-icon", "transform: rotate(90deg);", [iconSwitchTransition({
      originalTransform: "rotate(90deg)"
    })])]), cB("base-loading", `
        color: var(--n-loading-color);
        transition: color .3s var(--n-bezier);
        position: absolute;
        left: 0;
        right: 0;
        top: 0;
        bottom: 0;
      `, [iconSwitchTransition()]), cB("icon", `
        position: absolute;
        left: 0;
        right: 0;
        top: 0;
        bottom: 0;
      `, [iconSwitchTransition()]), cB("base-icon", `
        position: absolute;
        left: 0;
        right: 0;
        top: 0;
        bottom: 0;
      `, [iconSwitchTransition()])]), cB("data-table-thead", `
      transition: background-color .3s var(--n-bezier);
      background-color: var(--n-merged-th-color);
    `), cB("data-table-tr", `
      box-sizing: border-box;
      background-clip: padding-box;
      transition: background-color .3s var(--n-bezier);
    `, [cB("data-table-expand", `
        position: sticky;
        left: 0;
        overflow: hidden;
        margin: calc(var(--n-th-padding) * -1);
        padding: var(--n-th-padding);
        box-sizing: border-box;
      `), cM("striped", "background-color: var(--n-merged-td-color-striped);", [cB("data-table-td", "background-color: var(--n-merged-td-color-striped);")]), cNotM("summary", [c$1("&:hover", "background-color: var(--n-merged-td-color-hover);", [cB("data-table-td", "background-color: var(--n-merged-td-color-hover);")])])]), cB("data-table-th", `
      padding: var(--n-th-padding);
      position: relative;
      text-align: start;
      box-sizing: border-box;
      background-color: var(--n-merged-th-color);
      border-color: var(--n-merged-border-color);
      border-bottom: 1px solid var(--n-merged-border-color);
      color: var(--n-th-text-color);
      transition:
        border-color .3s var(--n-bezier),
        color .3s var(--n-bezier),
        background-color .3s var(--n-bezier);
      font-weight: var(--n-th-font-weight);
    `, [cM("filterable", {
      paddingRight: "36px"
    }), fixedColumnStyle, cM("selection", `
        padding: 0;
        text-align: center;
        line-height: 0;
        z-index: 3;
      `), cE("ellipsis", `
        display: inline-block;
        vertical-align: bottom;
        text-overflow: ellipsis;
        overflow: hidden;
        white-space: nowrap;
        max-width: 100%;
      `), cM("hover", {
      backgroundColor: "var(--n-merged-th-color-hover)"
    }), cM("sortable", {
      cursor: "pointer"
    }, [cE("ellipsis", {
      maxWidth: "calc(100% - 18px)"
    }), c$1("&:hover", {
      backgroundColor: "var(--n-merged-th-color-hover)"
    })]), cB("data-table-sorter", `
        height: var(--n-sorter-size);
        width: var(--n-sorter-size);
        margin-left: 4px;
        position: relative;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        vertical-align: -0.2em;
        color: var(--n-th-icon-color);
        transition: color .3s var(--n-bezier);
      `, [cB("base-icon", "transition: transform .3s var(--n-bezier)"), cM("desc", [cB("base-icon", {
      transform: "rotate(0deg)"
    })]), cM("asc", [cB("base-icon", {
      transform: "rotate(-180deg)"
    })]), cM("asc, desc", {
      color: "var(--n-th-icon-color-active)"
    })]), cB("data-table-filter", `
        position: absolute;
        z-index: auto;
        right: 0;
        width: 36px;
        top: 0;
        bottom: 0;
        cursor: pointer;
        display: flex;
        justify-content: center;
        align-items: center;
        transition:
          background-color .3s var(--n-bezier),
          color .3s var(--n-bezier);
        font-size: var(--n-filter-size);
        color: var(--n-th-icon-color);
      `, [c$1("&:hover", `
          background-color: var(--n-th-button-color-hover);
        `), cM("show", `
          background-color: var(--n-th-button-color-hover);
        `), cM("active", `
          background-color: var(--n-th-button-color-hover);
          color: var(--n-th-icon-color-active);
        `)])]), cB("data-table-td", `
      padding: var(--n-td-padding);
      text-align: start;
      box-sizing: border-box;
      border: none;
      background-color: var(--n-merged-td-color);
      color: var(--n-td-text-color);
      border-bottom: 1px solid var(--n-merged-border-color);
      transition:
        box-shadow .3s var(--n-bezier),
        background-color .3s var(--n-bezier),
        border-color .3s var(--n-bezier),
        color .3s var(--n-bezier);
    `, [cM("expand", [cB("data-table-expand-trigger", `
          margin-right: 0;
        `)]), cM("last-row", {
      borderBottom: "0 solid var(--n-merged-border-color)"
    }, [c$1("&::after", {
      bottom: "0 !important"
    }), c$1("&::before", {
      bottom: "0 !important"
    })]), cM("summary", `
        background-color: var(--n-merged-th-color);
      `), cM("hover", {
      backgroundColor: "var(--n-merged-td-color-hover)"
    }), cE("ellipsis", `
        display: inline-block;
        text-overflow: ellipsis;
        overflow: hidden;
        white-space: nowrap;
        max-width: 100%;
        vertical-align: bottom;
      `), cM("selection, expand", `
        text-align: center;
        padding: 0;
        line-height: 0;
      `), fixedColumnStyle]), cB("data-table-empty", `
      box-sizing: border-box;
      padding: var(--n-empty-padding);
      flex-grow: 1;
      flex-shrink: 0;
      opacity: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: opacity .3s var(--n-bezier);
    `, [cM("hide", {
      opacity: 0
    })]), cE("pagination", `
      margin: var(--n-pagination-margin);
      display: flex;
      justify-content: flex-end;
    `), cB("data-table-wrapper", `
      position: relative;
      opacity: 1;
      transition: opacity .3s var(--n-bezier), border-color .3s var(--n-bezier);
      border-top-left-radius: var(--n-border-radius);
      border-top-right-radius: var(--n-border-radius);
      line-height: var(--n-line-height);
    `), cM("loading", [cB("data-table-wrapper", `
        opacity: var(--n-opacity-loading);
        pointer-events: none;
      `)]), cM("single-column", [cB("data-table-td", {
      borderBottom: "0 solid var(--n-merged-border-color)"
    }, [c$1("&::after, &::before", {
      bottom: "0 !important"
    })])]), cNotM("single-line", [cB("data-table-th", {
      borderRight: "1px solid var(--n-merged-border-color)"
    }, [cM("last", {
      borderRight: "0 solid var(--n-merged-border-color)"
    })]), cB("data-table-td", {
      borderRight: "1px solid var(--n-merged-border-color)"
    }, [cM("last-col", {
      borderRight: "0 solid var(--n-merged-border-color)"
    })])]), cM("bordered", [cB("data-table-wrapper", `
        border: 1px solid var(--n-merged-border-color);
        border-bottom-left-radius: var(--n-border-radius);
        border-bottom-right-radius: var(--n-border-radius);
        overflow: hidden;
      `)]), cB("data-table-base-table", [cM("transition-disabled", [cB("data-table-th", [c$1("&::after, &::before", {
      transition: "none"
    })]), cB("data-table-td", [c$1("&::after, &::before", {
      transition: "none"
    })])])]), cM("bottom-bordered", [cB("data-table-td", [cM("last-row", {
      borderBottom: "1px solid var(--n-merged-border-color)"
    })])]), cB("data-table-table", `
      font-variant-numeric: tabular-nums;
      width: 100%;
      word-break: break-word;
      transition: background-color .3s var(--n-bezier);
      border-collapse: separate;
      border-spacing: 0;
      background-color: var(--n-merged-td-color);
    `), cB("data-table-base-table-header", `
      border-top-left-radius: calc(var(--n-border-radius) - 1px);
      border-top-right-radius: calc(var(--n-border-radius) - 1px);
      z-index: 3;
      overflow: scroll;
      flex-shrink: 0;
      transition: border-color .3s var(--n-bezier);
      scrollbar-width: none;
    `, [c$1("&::-webkit-scrollbar", {
      width: 0,
      height: 0
    })]), cB("data-table-check-extra", `
      transition: color .3s var(--n-bezier);
      color: var(--n-th-icon-color);
      position: absolute;
      font-size: 14px;
      right: -4px;
      top: 50%;
      transform: translateY(-50%);
      z-index: 1;
    `)]), cB("data-table-filter-menu", [cB("scrollbar", {
      maxHeight: "240px"
    }), cE("group", {
      display: "flex",
      flexDirection: "column",
      padding: "12px 12px 0 12px"
    }, [cB("checkbox", {
      marginBottom: "12px",
      marginRight: 0
    }), cB("radio", {
      marginBottom: "12px",
      marginRight: 0
    })]), cE("action", `
      padding: var(--n-action-padding);
      display: flex;
      flex-wrap: nowrap;
      justify-content: space-evenly;
      border-top: 1px solid var(--n-action-divider-color);
    `, [cB("button", [c$1("&:not(:last-child)", {
      margin: "var(--n-action-button-margin)"
    }), c$1("&:last-child", {
      marginRight: 0
    })])]), cB("divider", {
      margin: "0!important"
    })]), insideModal(cB("data-table", `
    --n-merged-th-color: var(--n-th-color-modal);
    --n-merged-td-color: var(--n-td-color-modal);
    --n-merged-border-color: var(--n-border-color-modal);
    --n-merged-th-color-hover: var(--n-th-color-hover-modal);
    --n-merged-td-color-hover: var(--n-td-color-hover-modal);
    --n-merged-td-color-striped: var(--n-td-color-striped-modal);
  `)), insidePopover(cB("data-table", `
    --n-merged-th-color: var(--n-th-color-popover);
    --n-merged-td-color: var(--n-td-color-popover);
    --n-merged-border-color: var(--n-border-color-popover);
    --n-merged-th-color-hover: var(--n-th-color-hover-popover);
    --n-merged-td-color-hover: var(--n-td-color-hover-popover);
    --n-merged-td-color-striped: var(--n-td-color-striped-popover);
  `))]);

    function createFixedColumnStyle() {
      return [cM("fixed-left", `
      left: 0;
      position: sticky;
      z-index: 2;
    `, [c$1("&::after", `
        pointer-events: none;
        content: "";
        width: 36px;
        display: inline-block;
        position: absolute;
        top: 0;
        bottom: -1px;
        transition: box-shadow .2s var(--n-bezier);
        right: -36px;
      `)]), cM("fixed-right", {
        right: 0,
        position: "sticky",
        zIndex: 1
      }, [c$1("&::before", `
        pointer-events: none;
        content: "";
        width: 36px;
        display: inline-block;
        position: absolute;
        top: 0;
        bottom: -1px;
        transition: box-shadow .2s var(--n-bezier);
        left: -36px;
      `)])];
    }

    const dataTableProps = {
      ...useTheme.props,
      pagination: {
        type: [Object, Boolean],
        default: false
      },
      paginateSinglePage: {
        type: Boolean,
        default: true
      },
      minHeight: [Number, String],
      maxHeight: [Number, String],
      columns: {
        type: Array,
        default: () => []
      },
      rowClassName: [String, Function],
      rowProps: Function,
      rowKey: Function,
      summary: [Function],
      data: {
        type: Array,
        default: () => []
      },
      loading: Boolean,
      bordered: {
        type: Boolean,
        default: void 0
      },
      bottomBordered: {
        type: Boolean,
        default: void 0
      },
      striped: Boolean,
      scrollX: [Number, String],
      defaultCheckedRowKeys: {
        type: Array,
        default: () => []
      },
      checkedRowKeys: Array,
      singleLine: {
        type: Boolean,
        default: true
      },
      singleColumn: Boolean,
      size: {
        type: String,
        default: "medium"
      },
      remote: Boolean,
      defaultExpandedRowKeys: {
        type: Array,
        default: []
      },
      defaultExpandAll: Boolean,
      expandedRowKeys: Array,
      stickyExpandedRows: Boolean,
      virtualScroll: Boolean,
      tableLayout: {
        type: String,
        default: "auto"
      },
      allowCheckingNotLoaded: Boolean,
      cascade: {
        type: Boolean,
        default: true
      },
      childrenKey: {
        type: String,
        default: "children"
      },
      indent: {
        type: Number,
        default: 16
      },
      flexHeight: Boolean,
      paginationBehaviorOnFilter: {
        type: String,
        default: "current"
      },
      renderCell: Function,
      renderExpandIcon: Function,
      onLoad: Function,
      "onUpdate:page": [Function, Array],
      onUpdatePage: [Function, Array],
      "onUpdate:pageSize": [Function, Array],
      onUpdatePageSize: [Function, Array],
      "onUpdate:sorter": [Function, Array],
      onUpdateSorter: [Function, Array],
      "onUpdate:filters": [Function, Array],
      onUpdateFilters: [Function, Array],
      "onUpdate:checkedRowKeys": [Function, Array],
      onUpdateCheckedRowKeys: [Function, Array],
      "onUpdate:expandedRowKeys": [Function, Array],
      onUpdateExpandedRowKeys: [Function, Array],
      onScroll: Function,
      onPageChange: [Function, Array],
      onPageSizeChange: [Function, Array],
      onSorterChange: [Function, Array],
      onFiltersChange: [Function, Array],
      onCheckedRowKeysChange: [Function, Array]
    };
    var DataTable = vue.defineComponent({
      name: "DataTable",
      alias: ["AdvancedTable"],
      props: dataTableProps,
      setup(props, { slots }) {
        {
          vue.watchEffect(() => {
            if (props.onPageChange !== void 0) {
              warnOnce(
                "data-table",
                "`on-page-change` is deprecated, please use `on-update:page` instead."
              );
            }
            if (props.onPageSizeChange !== void 0) {
              warnOnce(
                "data-table",
                "`on-page-size-change` is deprecated, please use `on-update:page-size` instead."
              );
            }
            if (props.onSorterChange !== void 0) {
              warnOnce(
                "data-table",
                "`on-sorter-change` is deprecated, please use `on-update:sorter` instead."
              );
            }
            if (props.onFiltersChange !== void 0) {
              warnOnce(
                "data-table",
                "`on-filters-change` is deprecated, please use `on-update:filters` instead."
              );
            }
            if (props.onCheckedRowKeysChange !== void 0) {
              warnOnce(
                "data-table",
                "`on-checked-row-keys-change` is deprecated, please use `on-update:checked-row-keys` instead."
              );
            }
          });
        }
        const { mergedBorderedRef, mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
        const mergedBottomBorderedRef = vue.computed(() => {
          const { bottomBordered } = props;
          if (mergedBorderedRef.value)
            return false;
          if (bottomBordered !== void 0)
            return bottomBordered;
          return true;
        });
        const themeRef = useTheme(
          "DataTable",
          "-data-table",
          style$T,
          dataTableLight$1,
          props,
          mergedClsPrefixRef
        );
        const bodyWidthRef = vue.ref(null);
        const scrollPartRef = vue.ref("body");
        vue.onDeactivated(() => {
          scrollPartRef.value = "body";
        });
        const mainTableInstRef = vue.ref(null);
        const { rowsRef, colsRef, dataRelatedColsRef, hasEllipsisRef } = useGroupHeader(props);
        const {
          treeMateRef,
          mergedCurrentPageRef,
          paginatedDataRef,
          rawPaginatedDataRef,
          selectionColumnRef,
          hoverKeyRef,
          mergedPaginationRef,
          mergedFilterStateRef,
          mergedSortStateRef,
          childTriggerColIndexRef,
          doUpdatePage,
          doUpdateFilters,
          deriveNextSorter,
          filter,
          filters,
          clearFilter,
          clearFilters,
          clearSorter,
          page,
          sort
        } = useTableData(props, { dataRelatedColsRef });
        const {
          doCheckAll,
          doUncheckAll,
          doCheck,
          doUncheck,
          headerCheckboxDisabledRef,
          someRowsCheckedRef,
          allRowsCheckedRef,
          mergedCheckedRowKeySetRef,
          mergedInderminateRowKeySetRef
        } = useCheck(props, {
          selectionColumnRef,
          treeMateRef,
          paginatedDataRef
        });
        const {
          stickyExpandedRowsRef,
          mergedExpandedRowKeysRef,
          renderExpandRef,
          expandableRef,
          doUpdateExpandedRowKeys
        } = useExpand(props, treeMateRef);
        const {
          handleTableBodyScroll,
          handleTableHeaderScroll,
          syncScrollState,
          setHeaderScrollLeft,
          leftActiveFixedColKeyRef,
          leftActiveFixedChildrenColKeysRef,
          rightActiveFixedColKeyRef,
          rightActiveFixedChildrenColKeysRef,
          leftFixedColumnsRef,
          rightFixedColumnsRef,
          fixedColumnLeftMapRef,
          fixedColumnRightMapRef
        } = useScroll(props, {
          scrollPartRef,
          bodyWidthRef,
          mainTableInstRef,
          mergedCurrentPageRef
        });
        const { localeRef } = useLocale("DataTable");
        const mergedTableLayoutRef = vue.computed(() => {
          if (props.virtualScroll || props.flexHeight || props.maxHeight !== void 0 || hasEllipsisRef.value) {
            return "fixed";
          }
          return props.tableLayout;
        });
        vue.provide(dataTableInjectionKey, {
          renderExpandIconRef: vue.toRef(props, "renderExpandIcon"),
          loadingKeySetRef: vue.ref(/* @__PURE__ */ new Set()),
          slots,
          indentRef: vue.toRef(props, "indent"),
          childTriggerColIndexRef,
          bodyWidthRef,
          componentId: createId(),
          hoverKeyRef,
          mergedClsPrefixRef,
          mergedThemeRef: themeRef,
          scrollXRef: vue.computed(() => props.scrollX),
          rowsRef,
          colsRef,
          paginatedDataRef,
          leftActiveFixedColKeyRef,
          leftActiveFixedChildrenColKeysRef,
          rightActiveFixedColKeyRef,
          rightActiveFixedChildrenColKeysRef,
          leftFixedColumnsRef,
          rightFixedColumnsRef,
          fixedColumnLeftMapRef,
          fixedColumnRightMapRef,
          mergedCurrentPageRef,
          someRowsCheckedRef,
          allRowsCheckedRef,
          mergedSortStateRef,
          mergedFilterStateRef,
          loadingRef: vue.toRef(props, "loading"),
          rowClassNameRef: vue.toRef(props, "rowClassName"),
          mergedCheckedRowKeySetRef,
          mergedExpandedRowKeysRef,
          mergedInderminateRowKeySetRef,
          localeRef,
          scrollPartRef,
          expandableRef,
          stickyExpandedRowsRef,
          rowKeyRef: vue.toRef(props, "rowKey"),
          renderExpandRef,
          summaryRef: vue.toRef(props, "summary"),
          virtualScrollRef: vue.toRef(props, "virtualScroll"),
          rowPropsRef: vue.toRef(props, "rowProps"),
          stripedRef: vue.toRef(props, "striped"),
          checkOptionsRef: vue.computed(() => {
            const { value: selectionColumn } = selectionColumnRef;
            return selectionColumn?.options;
          }),
          rawPaginatedDataRef,
          filterMenuCssVarsRef: vue.computed(() => {
            const {
              self: { actionDividerColor, actionPadding, actionButtonMargin }
            } = themeRef.value;
            return {
              "--n-action-padding": actionPadding,
              "--n-action-button-margin": actionButtonMargin,
              "--n-action-divider-color": actionDividerColor
            };
          }),
          onLoadRef: vue.toRef(props, "onLoad"),
          mergedTableLayoutRef,
          maxHeightRef: vue.toRef(props, "maxHeight"),
          minHeightRef: vue.toRef(props, "minHeight"),
          flexHeightRef: vue.toRef(props, "flexHeight"),
          headerCheckboxDisabledRef,
          paginationBehaviorOnFilterRef: vue.toRef(props, "paginationBehaviorOnFilter"),
          syncScrollState,
          doUpdatePage,
          doUpdateFilters,
          deriveNextSorter,
          doCheck,
          doUncheck,
          doCheckAll,
          doUncheckAll,
          doUpdateExpandedRowKeys,
          handleTableHeaderScroll,
          handleTableBodyScroll,
          setHeaderScrollLeft,
          renderCell: vue.toRef(props, "renderCell")
        });
        const exposedMethods = {
          filter,
          filters,
          clearFilters,
          clearSorter,
          page,
          sort,
          clearFilter,
          scrollTo: (arg0, arg1) => {
            mainTableInstRef.value?.scrollTo(arg0, arg1);
          }
        };
        const cssVarsRef = vue.computed(() => {
          const { size } = props;
          const {
            common: { cubicBezierEaseInOut },
            self: {
              borderColor,
              tdColorHover,
              thColor,
              thColorHover,
              tdColor,
              tdTextColor,
              thTextColor,
              thFontWeight,
              thButtonColorHover,
              thIconColor,
              thIconColorActive,
              filterSize,
              borderRadius,
              lineHeight,
              tdColorModal,
              thColorModal,
              borderColorModal,
              thColorHoverModal,
              tdColorHoverModal,
              borderColorPopover,
              thColorPopover,
              tdColorPopover,
              tdColorHoverPopover,
              thColorHoverPopover,
              paginationMargin,
              emptyPadding,
              boxShadowAfter,
              boxShadowBefore,
              sorterSize,
              loadingColor,
              loadingSize,
              opacityLoading,
              tdColorStriped,
              tdColorStripedModal,
              tdColorStripedPopover,
              [createKey("fontSize", size)]: fontSize,
              [createKey("thPadding", size)]: thPadding,
              [createKey("tdPadding", size)]: tdPadding
            }
          } = themeRef.value;
          return {
            "--n-font-size": fontSize,
            "--n-th-padding": thPadding,
            "--n-td-padding": tdPadding,
            "--n-bezier": cubicBezierEaseInOut,
            "--n-border-radius": borderRadius,
            "--n-line-height": lineHeight,
            "--n-border-color": borderColor,
            "--n-border-color-modal": borderColorModal,
            "--n-border-color-popover": borderColorPopover,
            "--n-th-color": thColor,
            "--n-th-color-hover": thColorHover,
            "--n-th-color-modal": thColorModal,
            "--n-th-color-hover-modal": thColorHoverModal,
            "--n-th-color-popover": thColorPopover,
            "--n-th-color-hover-popover": thColorHoverPopover,
            "--n-td-color": tdColor,
            "--n-td-color-hover": tdColorHover,
            "--n-td-color-modal": tdColorModal,
            "--n-td-color-hover-modal": tdColorHoverModal,
            "--n-td-color-popover": tdColorPopover,
            "--n-td-color-hover-popover": tdColorHoverPopover,
            "--n-th-text-color": thTextColor,
            "--n-td-text-color": tdTextColor,
            "--n-th-font-weight": thFontWeight,
            "--n-th-button-color-hover": thButtonColorHover,
            "--n-th-icon-color": thIconColor,
            "--n-th-icon-color-active": thIconColorActive,
            "--n-filter-size": filterSize,
            "--n-pagination-margin": paginationMargin,
            "--n-empty-padding": emptyPadding,
            "--n-box-shadow-before": boxShadowBefore,
            "--n-box-shadow-after": boxShadowAfter,
            "--n-sorter-size": sorterSize,
            "--n-loading-size": loadingSize,
            "--n-loading-color": loadingColor,
            "--n-opacity-loading": opacityLoading,
            "--n-td-color-striped": tdColorStriped,
            "--n-td-color-striped-modal": tdColorStripedModal,
            "--n-td-color-striped-popover": tdColorStripedPopover
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass(
          "data-table",
          vue.computed(() => props.size[0]),
          cssVarsRef,
          props
        ) : void 0;
        const mergedShowPaginationRef = vue.computed(() => {
          if (!props.pagination)
            return false;
          if (props.paginateSinglePage)
            return true;
          const mergedPagination = mergedPaginationRef.value;
          const { pageCount } = mergedPagination;
          if (pageCount !== void 0)
            return pageCount > 1;
          return mergedPagination.itemCount && mergedPagination.pageSize && mergedPagination.itemCount > mergedPagination.pageSize;
        });
        return {
          mainTableInstRef,
          mergedClsPrefix: mergedClsPrefixRef,
          mergedTheme: themeRef,
          paginatedData: paginatedDataRef,
          mergedBordered: mergedBorderedRef,
          mergedBottomBordered: mergedBottomBorderedRef,
          mergedPagination: mergedPaginationRef,
          mergedShowPagination: mergedShowPaginationRef,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender,
          ...exposedMethods
        };
      },
      render() {
        const { mergedClsPrefix, themeClass, onRender } = this;
        onRender?.();
        return /* @__PURE__ */ vue.h("div", {
          class: [
            `${mergedClsPrefix}-data-table`,
            themeClass,
            {
              [`${mergedClsPrefix}-data-table--bordered`]: this.mergedBordered,
              [`${mergedClsPrefix}-data-table--bottom-bordered`]: this.mergedBottomBordered,
              [`${mergedClsPrefix}-data-table--single-line`]: this.singleLine,
              [`${mergedClsPrefix}-data-table--single-column`]: this.singleColumn,
              [`${mergedClsPrefix}-data-table--loading`]: this.loading,
              [`${mergedClsPrefix}-data-table--flex-height`]: this.flexHeight
            }
          ],
          style: this.cssVars
        }, /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-data-table-wrapper`
        }, /* @__PURE__ */ vue.h(MainTable, {
          ref: "mainTableInstRef"
        })), this.mergedShowPagination ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-data-table__pagination`
        }, /* @__PURE__ */ vue.h(NPagination, {
          theme: this.mergedTheme.peers.Pagination,
          themeOverrides: this.mergedTheme.peerOverrides.Pagination,
          disabled: this.loading,
          ...this.mergedPagination
        })) : null, /* @__PURE__ */ vue.h(vue.Transition, {
          name: "fade-in-scale-up-transition"
        }, {
          default: () => {
            return this.loading ? /* @__PURE__ */ vue.h(NBaseLoading, {
              clsPrefix: mergedClsPrefix,
              strokeWidth: 20
            }) : null;
          }
        }));
      }
    });

    var commonVars$7 = {
      itemFontSize: "12px",
      itemHeight: "36px",
      itemWidth: "52px",
      panelActionPadding: "8px 0"
    };

    const self$H = vars => {
      const {
        popoverColor,
        textColor2,
        primaryColor,
        hoverColor,
        dividerColor,
        opacityDisabled,
        boxShadow2,
        borderRadius,
        iconColor,
        iconColorDisabled
      } = vars;
      return { ...commonVars$7,
        panelColor: popoverColor,
        panelBoxShadow: boxShadow2,
        panelDividerColor: dividerColor,
        itemTextColor: textColor2,
        itemTextColorActive: primaryColor,
        itemColorHover: hoverColor,
        itemOpacityDisabled: opacityDisabled,
        itemBorderRadius: borderRadius,
        borderRadius,
        iconColor,
        iconColorDisabled
      };
    };
    const timePickerLight = createTheme$1({
      name: "TimePicker",
      common: commonLight,
      peers: {
        Scrollbar: scrollbarLight$1,
        Button: buttonLight$1,
        Input: inputLight$1
      },
      self: self$H
    });
    var timePickerLight$1 = timePickerLight;

    const timePickerDark = {
      name: "TimePicker",
      common: commonDark,
      peers: {
        Scrollbar: scrollbarDark$1,
        Button: buttonDark$1,
        Input: inputDark$1
      },
      self: self$H
    };
    var timePickerDark$1 = timePickerDark;

    var commonVars$6 = {
      itemSize: "24px",
      itemCellWidth: "38px",
      itemCellHeight: "32px",
      scrollItemWidth: "80px",
      scrollItemHeight: "40px",
      panelExtraFooterPadding: "8px 12px",
      panelActionPadding: "8px 12px",
      calendarTitlePadding: "0",
      calendarTitleHeight: "28px",
      arrowSize: "14px",
      panelHeaderPadding: "8px 12px",
      calendarDaysHeight: "32px",
      calendarTitleGridTempateColumns: "28px 28px 1fr 28px 28px",
      calendarLeftPaddingDate: "6px 12px 4px 12px",
      calendarLeftPaddingDatetime: "4px 12px",
      calendarLeftPaddingDaterange: "6px 12px 4px 12px",
      calendarLeftPaddingDatetimerange: "4px 12px",
      calendarLeftPaddingMonth: "0",
      calendarLeftPaddingYear: "0",
      calendarLeftPaddingQuarter: "0",
      calendarLeftPaddingMonthrange: "0",
      calendarLeftPaddingQuarterrange: "0",
      calendarLeftPaddingYearrange: "0",
      calendarRightPaddingDate: "6px 12px 4px 12px",
      calendarRightPaddingDatetime: "4px 12px",
      calendarRightPaddingDaterange: "6px 12px 4px 12px",
      calendarRightPaddingDatetimerange: "4px 12px",
      calendarRightPaddingMonth: "0",
      calendarRightPaddingYear: "0",
      calendarRightPaddingQuarter: "0",
      calendarRightPaddingMonthrange: "0",
      calendarRightPaddingQuarterrange: "0",
      calendarRightPaddingYearrange: "0"
    };

    const self$G = vars => {
      const {
        hoverColor,
        fontSize,
        textColor2,
        textColorDisabled,
        popoverColor,
        primaryColor,
        borderRadiusSmall,
        iconColor,
        iconColorDisabled,
        textColor1,
        dividerColor,
        boxShadow2,
        borderRadius,
        fontWeightStrong
      } = vars;
      return { ...commonVars$6,
        itemFontSize: fontSize,
        calendarDaysFontSize: fontSize,
        calendarTitleFontSize: fontSize,
        itemTextColor: textColor2,
        itemTextColorDisabled: textColorDisabled,
        itemTextColorActive: popoverColor,
        itemTextColorCurrent: primaryColor,
        itemColorIncluded: changeColor(primaryColor, {
          alpha: 0.1
        }),
        itemColorHover: hoverColor,
        itemColorDisabled: hoverColor,
        itemColorActive: primaryColor,
        itemBorderRadius: borderRadiusSmall,
        panelColor: popoverColor,
        panelTextColor: textColor2,
        arrowColor: iconColor,
        calendarTitleTextColor: textColor1,
        calendarTitleColorHover: hoverColor,
        calendarDaysTextColor: textColor2,
        panelHeaderDividerColor: dividerColor,
        calendarDaysDividerColor: dividerColor,
        calendarDividerColor: dividerColor,
        panelActionDividerColor: dividerColor,
        panelBoxShadow: boxShadow2,
        panelBorderRadius: borderRadius,
        calendarTitleFontWeight: fontWeightStrong,
        scrollItemBorderRadius: borderRadius,
        iconColor,
        iconColorDisabled
      };
    };
    const datePickerLight = createTheme$1({
      name: "DatePicker",
      common: commonLight,
      peers: {
        Input: inputLight$1,
        Button: buttonLight$1,
        TimePicker: timePickerLight$1,
        Scrollbar: scrollbarLight$1
      },
      self: self$G
    });
    var datePickerLight$1 = datePickerLight;

    const datePickerDark = {
      name: "DatePicker",
      common: commonDark,
      peers: {
        Input: inputDark$1,
        Button: buttonDark$1,
        TimePicker: timePickerDark$1,
        Scrollbar: scrollbarDark$1
      },

      self(vars) {
        const {
          popoverColor,
          hoverColor,
          primaryColor
        } = vars;
        const commonSelf = self$G(vars);
        commonSelf.itemColorDisabled = composite(popoverColor, hoverColor);
        commonSelf.itemColorIncluded = changeColor(primaryColor, {
          alpha: 0.15
        });
        commonSelf.itemColorHover = composite(popoverColor, hoverColor);
        return commonSelf;
      }

    };
    var datePickerDark$1 = datePickerDark;

    function uniCalendarValidation(props, mergedValueRef) {
      const timePickerValidatorRef = vue.computed(() => {
        const {
          isTimeDisabled
        } = props;
        const {
          value
        } = mergedValueRef;
        if (value === null || Array.isArray(value)) return void 0;
        return isTimeDisabled === null || isTimeDisabled === void 0 ? void 0 : isTimeDisabled(value);
      });
      const isHourDisabledRef = vue.computed(() => {
        var _timePickerValidatorR;

        return (_timePickerValidatorR = timePickerValidatorRef.value) === null || _timePickerValidatorR === void 0 ? void 0 : _timePickerValidatorR.isHourDisabled;
      });
      const isMinuteDisabledRef = vue.computed(() => {
        var _timePickerValidatorR2;

        return (_timePickerValidatorR2 = timePickerValidatorRef.value) === null || _timePickerValidatorR2 === void 0 ? void 0 : _timePickerValidatorR2.isMinuteDisabled;
      });
      const isSecondDisabledRef = vue.computed(() => {
        var _timePickerValidatorR3;

        return (_timePickerValidatorR3 = timePickerValidatorRef.value) === null || _timePickerValidatorR3 === void 0 ? void 0 : _timePickerValidatorR3.isSecondDisabled;
      });
      const isDateInvalidRef = vue.computed(() => {
        const {
          type,
          isDateDisabled
        } = props;
        const {
          value
        } = mergedValueRef;

        if (value === null || Array.isArray(value) || !["date", "datetime"].includes(type) || !isDateDisabled) {
          return false;
        }

        return isDateDisabled(value);
      });
      const isTimeInvalidRef = vue.computed(() => {
        const {
          type
        } = props;
        const {
          value
        } = mergedValueRef;

        if (value === null || !(type !== "datetime") || Array.isArray(value)) {
          return false;
        }

        const time = new Date(value);
        const hour = time.getHours();
        const minute = time.getMinutes();
        const second = time.getMinutes();
        return (isHourDisabledRef.value ? isHourDisabledRef.value(hour) : false) || (isMinuteDisabledRef.value ? isMinuteDisabledRef.value(minute, hour) : false) || (isSecondDisabledRef.value ? isSecondDisabledRef.value(second, minute, hour) : false);
      });
      const isDateTimeInvalidRef = vue.computed(() => {
        return isDateInvalidRef.value || isTimeInvalidRef.value;
      });
      const isValueInvalidRef = vue.computed(() => {
        const {
          type
        } = props;
        if (type === "date") return isDateInvalidRef.value;
        if (type === "datetime") return isDateTimeInvalidRef.value;
        return false;
      });
      return {
        isValueInvalidRef,
        isDateInvalidRef,
        isTimeInvalidRef,
        isDateTimeInvalidRef,
        isHourDisabledRef,
        isMinuteDisabledRef,
        isSecondDisabledRef
      };
    }
    function dualCalendarValidation(props, mergedValueRef) {
      const timePickerValidatorRef = vue.computed(() => {
        const {
          isTimeDisabled
        } = props;
        const {
          value
        } = mergedValueRef;

        if (!Array.isArray(value) || !isTimeDisabled) {
          return [void 0, void 0];
        }

        return [isTimeDisabled === null || isTimeDisabled === void 0 ? void 0 : isTimeDisabled(value[0], "start", value), isTimeDisabled === null || isTimeDisabled === void 0 ? void 0 : isTimeDisabled(value[1], "end", value)];
      });
      const timeValidator = {
        isStartHourDisabledRef: vue.computed(() => {
          var _timePickerValidatorR4;

          return (_timePickerValidatorR4 = timePickerValidatorRef.value[0]) === null || _timePickerValidatorR4 === void 0 ? void 0 : _timePickerValidatorR4.isHourDisabled;
        }),
        isEndHourDisabledRef: vue.computed(() => {
          var _timePickerValidatorR5;

          return (_timePickerValidatorR5 = timePickerValidatorRef.value[1]) === null || _timePickerValidatorR5 === void 0 ? void 0 : _timePickerValidatorR5.isHourDisabled;
        }),
        isStartMinuteDisabledRef: vue.computed(() => {
          var _timePickerValidatorR6;

          return (_timePickerValidatorR6 = timePickerValidatorRef.value[0]) === null || _timePickerValidatorR6 === void 0 ? void 0 : _timePickerValidatorR6.isMinuteDisabled;
        }),
        isEndMinuteDisabledRef: vue.computed(() => {
          var _timePickerValidatorR7;

          return (_timePickerValidatorR7 = timePickerValidatorRef.value[1]) === null || _timePickerValidatorR7 === void 0 ? void 0 : _timePickerValidatorR7.isMinuteDisabled;
        }),
        isStartSecondDisabledRef: vue.computed(() => {
          var _timePickerValidatorR8;

          return (_timePickerValidatorR8 = timePickerValidatorRef.value[0]) === null || _timePickerValidatorR8 === void 0 ? void 0 : _timePickerValidatorR8.isSecondDisabled;
        }),
        isEndSecondDisabledRef: vue.computed(() => {
          var _timePickerValidatorR9;

          return (_timePickerValidatorR9 = timePickerValidatorRef.value[1]) === null || _timePickerValidatorR9 === void 0 ? void 0 : _timePickerValidatorR9.isSecondDisabled;
        })
      };
      const isStartDateInvalidRef = vue.computed(() => {
        const {
          type,
          isDateDisabled
        } = props;
        const {
          value
        } = mergedValueRef;

        if (value === null || !Array.isArray(value) || !["daterange", "datetimerange"].includes(type) || !isDateDisabled) {
          return false;
        }

        return isDateDisabled(value[0], "start", value);
      });
      const isEndDateInvalidRef = vue.computed(() => {
        const {
          type,
          isDateDisabled
        } = props;
        const {
          value
        } = mergedValueRef;

        if (value === null || !Array.isArray(value) || !["daterange", "datetimerange"].includes(type) || !isDateDisabled) {
          return false;
        }

        return isDateDisabled(value[1], "end", value);
      });
      const isStartTimeInvalidRef = vue.computed(() => {
        const {
          type
        } = props;
        const {
          value
        } = mergedValueRef;

        if (value === null || !Array.isArray(value) || type !== "datetimerange") {
          return false;
        }

        const startHours = getHours(value[0]);
        const startMinutes = getMinutes(value[0]);
        const startSeconds = getSeconds(value[0]);
        const {
          isStartHourDisabledRef,
          isStartMinuteDisabledRef,
          isStartSecondDisabledRef
        } = timeValidator;
        const startTimeInvalid = (isStartHourDisabledRef.value ? isStartHourDisabledRef.value(startHours) : false) || (isStartMinuteDisabledRef.value ? isStartMinuteDisabledRef.value(startMinutes, startHours) : false) || (isStartSecondDisabledRef.value ? isStartSecondDisabledRef.value(startSeconds, startMinutes, startHours) : false);
        return startTimeInvalid;
      });
      const isEndTimeInvalidRef = vue.computed(() => {
        const {
          type
        } = props;
        const {
          value
        } = mergedValueRef;

        if (value === null || !Array.isArray(value) || type !== "datetimerange") {
          return false;
        }

        const endHours = getHours(value[1]);
        const endMinutes = getMinutes(value[1]);
        const endSeconds = getSeconds(value[1]);
        const {
          isEndHourDisabledRef,
          isEndMinuteDisabledRef,
          isEndSecondDisabledRef
        } = timeValidator;
        const endTimeInvalid = (isEndHourDisabledRef.value ? isEndHourDisabledRef.value(endHours) : false) || (isEndMinuteDisabledRef.value ? isEndMinuteDisabledRef.value(endMinutes, endHours) : false) || (isEndSecondDisabledRef.value ? isEndSecondDisabledRef.value(endSeconds, endMinutes, endHours) : false);
        return endTimeInvalid;
      });
      const isStartValueInvalidRef = vue.computed(() => {
        return isStartDateInvalidRef.value || isStartTimeInvalidRef.value;
      });
      const isEndValueInvalidRef = vue.computed(() => {
        return isEndDateInvalidRef.value || isEndTimeInvalidRef.value;
      });
      const isRangeInvalidRef = vue.computed(() => {
        return isStartValueInvalidRef.value || isEndValueInvalidRef.value;
      });
      return { ...timeValidator,
        isStartDateInvalidRef,
        isEndDateInvalidRef,
        isStartTimeInvalidRef,
        isEndTimeInvalidRef,
        isStartValueInvalidRef,
        isEndValueInvalidRef,
        isRangeInvalidRef
      };
    }

    const datePickerInjectionKey = createInjectionKey("n-date-picker");

    var formatInTimeZone$1 = {exports: {}};

    var cloneObject = {exports: {}};

    var assign = {exports: {}};

    (function (module, exports) {

    	Object.defineProperty(exports, "__esModule", {
    	  value: true
    	});
    	exports.default = assign;

    	function assign(target, object) {
    	  if (target == null) {
    	    throw new TypeError('assign requires that input parameter not be null or undefined');
    	  }

    	  for (var property in object) {
    	    if (Object.prototype.hasOwnProperty.call(object, property)) {
    	      target[property] = object[property];
    	    }
    	  }

    	  return target;
    	}

    	module.exports = exports.default;
    } (assign, assign.exports));

    (function (module, exports) {

    	Object.defineProperty(exports, "__esModule", {
    	  value: true
    	});
    	exports.default = cloneObject;

    	var _index = _interopRequireDefault(assign.exports);

    	function _interopRequireDefault(obj) {
    	  return obj && obj.__esModule ? obj : {
    	    default: obj
    	  };
    	}

    	function cloneObject(object) {
    	  return (0, _index.default)({}, object);
    	}

    	module.exports = exports.default;
    } (cloneObject, cloneObject.exports));

    var format$3 = {exports: {}};

    var format$2 = {exports: {}};

    var isValid = {exports: {}};

    var isDate = {exports: {}};

    var requiredArgs = {exports: {}};

    (function (module, exports) {

    	Object.defineProperty(exports, "__esModule", {
    	  value: true
    	});
    	exports.default = requiredArgs;

    	function requiredArgs(required, args) {
    	  if (args.length < required) {
    	    throw new TypeError(required + ' argument' + (required > 1 ? 's' : '') + ' required, but only ' + args.length + ' present');
    	  }
    	}

    	module.exports = exports.default;
    } (requiredArgs, requiredArgs.exports));

    (function (module, exports) {

    	Object.defineProperty(exports, "__esModule", {
    	  value: true
    	});
    	exports.default = isDate;

    	var _index = _interopRequireDefault(requiredArgs.exports);

    	function _interopRequireDefault(obj) {
    	  return obj && obj.__esModule ? obj : {
    	    default: obj
    	  };
    	}
    	/**
    	 * @name isDate
    	 * @category Common Helpers
    	 * @summary Is the given value a date?
    	 *
    	 * @description
    	 * Returns true if the given value is an instance of Date. The function works for dates transferred across iframes.
    	 *
    	 * @param {*} value - the value to check
    	 * @returns {boolean} true if the given value is a date
    	 * @throws {TypeError} 1 arguments required
    	 *
    	 * @example
    	 * // For a valid date:
    	 * const result = isDate(new Date())
    	 * //=> true
    	 *
    	 * @example
    	 * // For an invalid date:
    	 * const result = isDate(new Date(NaN))
    	 * //=> true
    	 *
    	 * @example
    	 * // For some value:
    	 * const result = isDate('2014-02-31')
    	 * //=> false
    	 *
    	 * @example
    	 * // For an object:
    	 * const result = isDate({})
    	 * //=> false
    	 */


    	function isDate(value) {
    	  (0, _index.default)(1, arguments);
    	  return value instanceof Date || typeof value === 'object' && Object.prototype.toString.call(value) === '[object Date]';
    	}

    	module.exports = exports.default;
    } (isDate, isDate.exports));

    var toDate$1 = {exports: {}};

    (function (module, exports) {

    	Object.defineProperty(exports, "__esModule", {
    	  value: true
    	});
    	exports.default = toDate;

    	var _index = _interopRequireDefault(requiredArgs.exports);

    	function _interopRequireDefault(obj) {
    	  return obj && obj.__esModule ? obj : {
    	    default: obj
    	  };
    	}
    	/**
    	 * @name toDate
    	 * @category Common Helpers
    	 * @summary Convert the given argument to an instance of Date.
    	 *
    	 * @description
    	 * Convert the given argument to an instance of Date.
    	 *
    	 * If the argument is an instance of Date, the function returns its clone.
    	 *
    	 * If the argument is a number, it is treated as a timestamp.
    	 *
    	 * If the argument is none of the above, the function returns Invalid Date.
    	 *
    	 * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
    	 *
    	 * @param {Date|Number} argument - the value to convert
    	 * @returns {Date} the parsed date in the local time zone
    	 * @throws {TypeError} 1 argument required
    	 *
    	 * @example
    	 * // Clone the date:
    	 * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))
    	 * //=> Tue Feb 11 2014 11:30:30
    	 *
    	 * @example
    	 * // Convert the timestamp to date:
    	 * const result = toDate(1392098430000)
    	 * //=> Tue Feb 11 2014 11:30:30
    	 */


    	function toDate(argument) {
    	  (0, _index.default)(1, arguments);
    	  var argStr = Object.prototype.toString.call(argument); // Clone the date

    	  if (argument instanceof Date || typeof argument === 'object' && argStr === '[object Date]') {
    	    // Prevent the date to lose the milliseconds when passed to new Date() in IE10
    	    return new Date(argument.getTime());
    	  } else if (typeof argument === 'number' || argStr === '[object Number]') {
    	    return new Date(argument);
    	  } else {
    	    if ((typeof argument === 'string' || argStr === '[object String]') && typeof console !== 'undefined') {
    	      // eslint-disable-next-line no-console
    	      console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments"); // eslint-disable-next-line no-console

    	      console.warn(new Error().stack);
    	    }

    	    return new Date(NaN);
    	  }
    	}

    	module.exports = exports.default;
    } (toDate$1, toDate$1.exports));

    (function (module, exports) {

    	Object.defineProperty(exports, "__esModule", {
    	  value: true
    	});
    	exports.default = isValid;

    	var _index = _interopRequireDefault(isDate.exports);

    	var _index2 = _interopRequireDefault(toDate$1.exports);

    	var _index3 = _interopRequireDefault(requiredArgs.exports);

    	function _interopRequireDefault(obj) {
    	  return obj && obj.__esModule ? obj : {
    	    default: obj
    	  };
    	}
    	/**
    	 * @name isValid
    	 * @category Common Helpers
    	 * @summary Is the given date valid?
    	 *
    	 * @description
    	 * Returns false if argument is Invalid Date and true otherwise.
    	 * Argument is converted to Date using `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
    	 * Invalid Date is a Date, whose time value is NaN.
    	 *
    	 * Time value of Date: http://es5.github.io/#x15.9.1.1
    	 *
    	 * @param {*} date - the date to check
    	 * @returns {Boolean} the date is valid
    	 * @throws {TypeError} 1 argument required
    	 *
    	 * @example
    	 * // For the valid date:
    	 * const result = isValid(new Date(2014, 1, 31))
    	 * //=> true
    	 *
    	 * @example
    	 * // For the value, convertable into a date:
    	 * const result = isValid(1393804800000)
    	 * //=> true
    	 *
    	 * @example
    	 * // For the invalid date:
    	 * const result = isValid(new Date(''))
    	 * //=> false
    	 */


    	function isValid(dirtyDate) {
    	  (0, _index3.default)(1, arguments);

    	  if (!(0, _index.default)(dirtyDate) && typeof dirtyDate !== 'number') {
    	    return false;
    	  }

    	  var date = (0, _index2.default)(dirtyDate);
    	  return !isNaN(Number(date));
    	}

    	module.exports = exports.default;
    } (isValid, isValid.exports));

    var subMilliseconds = {exports: {}};

    var addMilliseconds = {exports: {}};

    var toInteger = {exports: {}};

    (function (module, exports) {

    	Object.defineProperty(exports, "__esModule", {
    	  value: true
    	});
    	exports.default = toInteger;

    	function toInteger(dirtyNumber) {
    	  if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
    	    return NaN;
    	  }

    	  var number = Number(dirtyNumber);

    	  if (isNaN(number)) {
    	    return number;
    	  }

    	  return number < 0 ? Math.ceil(number) : Math.floor(number);
    	}

    	module.exports = exports.default;
    } (toInteger, toInteger.exports));

    (function (module, exports) {

    	Object.defineProperty(exports, "__esModule", {
    	  value: true
    	});
    	exports.default = addMilliseconds;

    	var _index = _interopRequireDefault(toInteger.exports);

    	var _index2 = _interopRequireDefault(toDate$1.exports);

    	var _index3 = _interopRequireDefault(requiredArgs.exports);

    	function _interopRequireDefault(obj) {
    	  return obj && obj.__esModule ? obj : {
    	    default: obj
    	  };
    	}
    	/**
    	 * @name addMilliseconds
    	 * @category Millisecond Helpers
    	 * @summary Add the specified number of milliseconds to the given date.
    	 *
    	 * @description
    	 * Add the specified number of milliseconds to the given date.
    	 *
    	 * @param {Date|Number} date - the date to be changed
    	 * @param {Number} amount - the amount of milliseconds to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
    	 * @returns {Date} the new date with the milliseconds added
    	 * @throws {TypeError} 2 arguments required
    	 *
    	 * @example
    	 * // Add 750 milliseconds to 10 July 2014 12:45:30.000:
    	 * const result = addMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
    	 * //=> Thu Jul 10 2014 12:45:30.750
    	 */


    	function addMilliseconds(dirtyDate, dirtyAmount) {
    	  (0, _index3.default)(2, arguments);
    	  var timestamp = (0, _index2.default)(dirtyDate).getTime();
    	  var amount = (0, _index.default)(dirtyAmount);
    	  return new Date(timestamp + amount);
    	}

    	module.exports = exports.default;
    } (addMilliseconds, addMilliseconds.exports));

    (function (module, exports) {

    	Object.defineProperty(exports, "__esModule", {
    	  value: true
    	});
    	exports.default = subMilliseconds;

    	var _index = _interopRequireDefault(addMilliseconds.exports);

    	var _index2 = _interopRequireDefault(requiredArgs.exports);

    	var _index3 = _interopRequireDefault(toInteger.exports);

    	function _interopRequireDefault(obj) {
    	  return obj && obj.__esModule ? obj : {
    	    default: obj
    	  };
    	}
    	/**
    	 * @name subMilliseconds
    	 * @category Millisecond Helpers
    	 * @summary Subtract the specified number of milliseconds from the given date.
    	 *
    	 * @description
    	 * Subtract the specified number of milliseconds from the given date.
    	 *
    	 * @param {Date|Number} date - the date to be changed
    	 * @param {Number} amount - the amount of milliseconds to be subtracted. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
    	 * @returns {Date} the new date with the milliseconds subtracted
    	 * @throws {TypeError} 2 arguments required
    	 *
    	 * @example
    	 * // Subtract 750 milliseconds from 10 July 2014 12:45:30.000:
    	 * const result = subMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
    	 * //=> Thu Jul 10 2014 12:45:29.250
    	 */


    	function subMilliseconds(dirtyDate, dirtyAmount) {
    	  (0, _index2.default)(2, arguments);
    	  var amount = (0, _index3.default)(dirtyAmount);
    	  return (0, _index.default)(dirtyDate, -amount);
    	}

    	module.exports = exports.default;
    } (subMilliseconds, subMilliseconds.exports));

    var formatters$1 = {exports: {}};

    var getUTCDayOfYear = {exports: {}};

    (function (module, exports) {

    	Object.defineProperty(exports, "__esModule", {
    	  value: true
    	});
    	exports.default = getUTCDayOfYear;

    	var _index = _interopRequireDefault(toDate$1.exports);

    	var _index2 = _interopRequireDefault(requiredArgs.exports);

    	function _interopRequireDefault(obj) {
    	  return obj && obj.__esModule ? obj : {
    	    default: obj
    	  };
    	}

    	var MILLISECONDS_IN_DAY = 86400000;

    	function getUTCDayOfYear(dirtyDate) {
    	  (0, _index2.default)(1, arguments);
    	  var date = (0, _index.default)(dirtyDate);
    	  var timestamp = date.getTime();
    	  date.setUTCMonth(0, 1);
    	  date.setUTCHours(0, 0, 0, 0);
    	  var startOfYearTimestamp = date.getTime();
    	  var difference = timestamp - startOfYearTimestamp;
    	  return Math.floor(difference / MILLISECONDS_IN_DAY) + 1;
    	}

    	module.exports = exports.default;
    } (getUTCDayOfYear, getUTCDayOfYear.exports));

    var getUTCISOWeek = {exports: {}};

    var startOfUTCISOWeek = {exports: {}};

    (function (module, exports) {

    	Object.defineProperty(exports, "__esModule", {
    	  value: true
    	});
    	exports.default = startOfUTCISOWeek;

    	var _index = _interopRequireDefault(toDate$1.exports);

    	var _index2 = _interopRequireDefault(requiredArgs.exports);

    	function _interopRequireDefault(obj) {
    	  return obj && obj.__esModule ? obj : {
    	    default: obj
    	  };
    	}

    	function startOfUTCISOWeek(dirtyDate) {
    	  (0, _index2.default)(1, arguments);
    	  var weekStartsOn = 1;
    	  var date = (0, _index.default)(dirtyDate);
    	  var day = date.getUTCDay();
    	  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
    	  date.setUTCDate(date.getUTCDate() - diff);
    	  date.setUTCHours(0, 0, 0, 0);
    	  return date;
    	}

    	module.exports = exports.default;
    } (startOfUTCISOWeek, startOfUTCISOWeek.exports));

    var startOfUTCISOWeekYear = {exports: {}};

    var getUTCISOWeekYear = {exports: {}};

    (function (module, exports) {

    	Object.defineProperty(exports, "__esModule", {
    	  value: true
    	});
    	exports.default = getUTCISOWeekYear;

    	var _index = _interopRequireDefault(toDate$1.exports);

    	var _index2 = _interopRequireDefault(requiredArgs.exports);

    	var _index3 = _interopRequireDefault(startOfUTCISOWeek.exports);

    	function _interopRequireDefault(obj) {
    	  return obj && obj.__esModule ? obj : {
    	    default: obj
    	  };
    	}

    	function getUTCISOWeekYear(dirtyDate) {
    	  (0, _index2.default)(1, arguments);
    	  var date = (0, _index.default)(dirtyDate);
    	  var year = date.getUTCFullYear();
    	  var fourthOfJanuaryOfNextYear = new Date(0);
    	  fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
    	  fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
    	  var startOfNextYear = (0, _index3.default)(fourthOfJanuaryOfNextYear);
    	  var fourthOfJanuaryOfThisYear = new Date(0);
    	  fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
    	  fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
    	  var startOfThisYear = (0, _index3.default)(fourthOfJanuaryOfThisYear);

    	  if (date.getTime() >= startOfNextYear.getTime()) {
    	    return year + 1;
    	  } else if (date.getTime() >= startOfThisYear.getTime()) {
    	    return year;
    	  } else {
    	    return year - 1;
    	  }
    	}

    	module.exports = exports.default;
    } (getUTCISOWeekYear, getUTCISOWeekYear.exports));

    (function (module, exports) {

    	Object.defineProperty(exports, "__esModule", {
    	  value: true
    	});
    	exports.default = startOfUTCISOWeekYear;

    	var _index = _interopRequireDefault(getUTCISOWeekYear.exports);

    	var _index2 = _interopRequireDefault(startOfUTCISOWeek.exports);

    	var _index3 = _interopRequireDefault(requiredArgs.exports);

    	function _interopRequireDefault(obj) {
    	  return obj && obj.__esModule ? obj : {
    	    default: obj
    	  };
    	}

    	function startOfUTCISOWeekYear(dirtyDate) {
    	  (0, _index3.default)(1, arguments);
    	  var year = (0, _index.default)(dirtyDate);
    	  var fourthOfJanuary = new Date(0);
    	  fourthOfJanuary.setUTCFullYear(year, 0, 4);
    	  fourthOfJanuary.setUTCHours(0, 0, 0, 0);
    	  var date = (0, _index2.default)(fourthOfJanuary);
    	  return date;
    	}

    	module.exports = exports.default;
    } (startOfUTCISOWeekYear, startOfUTCISOWeekYear.exports));

    (function (module, exports) {

    	Object.defineProperty(exports, "__esModule", {
    	  value: true
    	});
    	exports.default = getUTCISOWeek;

    	var _index = _interopRequireDefault(toDate$1.exports);

    	var _index2 = _interopRequireDefault(startOfUTCISOWeek.exports);

    	var _index3 = _interopRequireDefault(startOfUTCISOWeekYear.exports);

    	var _index4 = _interopRequireDefault(requiredArgs.exports);

    	function _interopRequireDefault(obj) {
    	  return obj && obj.__esModule ? obj : {
    	    default: obj
    	  };
    	}

    	var MILLISECONDS_IN_WEEK = 604800000;

    	function getUTCISOWeek(dirtyDate) {
    	  (0, _index4.default)(1, arguments);
    	  var date = (0, _index.default)(dirtyDate);
    	  var diff = (0, _index2.default)(date).getTime() - (0, _index3.default)(date).getTime(); // Round the number of days to the nearest integer
    	  // because the number of milliseconds in a week is not constant
    	  // (e.g. it's different in the week of the daylight saving time clock shift)

    	  return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
    	}

    	module.exports = exports.default;
    } (getUTCISOWeek, getUTCISOWeek.exports));

    var getUTCWeek = {exports: {}};

    var startOfUTCWeek = {exports: {}};

    var defaultOptions$1 = {};

    Object.defineProperty(defaultOptions$1, "__esModule", {
      value: true
    });
    defaultOptions$1.getDefaultOptions = getDefaultOptions;
    defaultOptions$1.setDefaultOptions = setDefaultOptions;
    var defaultOptions = {};

    function getDefaultOptions() {
      return defaultOptions;
    }

    function setDefaultOptions(newOptions) {
      defaultOptions = newOptions;
    }

    (function (module, exports) {

    	Object.defineProperty(exports, "__esModule", {
    	  value: true
    	});
    	exports.default = startOfUTCWeek;

    	var _index = _interopRequireDefault(toDate$1.exports);

    	var _index2 = _interopRequireDefault(requiredArgs.exports);

    	var _index3 = _interopRequireDefault(toInteger.exports);

    	var _index4 = defaultOptions$1;

    	function _interopRequireDefault(obj) {
    	  return obj && obj.__esModule ? obj : {
    	    default: obj
    	  };
    	}

    	function startOfUTCWeek(dirtyDate, options) {
    	  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;

    	  (0, _index2.default)(1, arguments);
    	  var defaultOptions = (0, _index4.getDefaultOptions)();
    	  var weekStartsOn = (0, _index3.default)((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

    	  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    	    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
    	  }

    	  var date = (0, _index.default)(dirtyDate);
    	  var day = date.getUTCDay();
    	  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
    	  date.setUTCDate(date.getUTCDate() - diff);
    	  date.setUTCHours(0, 0, 0, 0);
    	  return date;
    	}

    	module.exports = exports.default;
    } (startOfUTCWeek, startOfUTCWeek.exports));

    var startOfUTCWeekYear = {exports: {}};

    var getUTCWeekYear = {exports: {}};

    (function (module, exports) {

    	Object.defineProperty(exports, "__esModule", {
    	  value: true
    	});
    	exports.default = getUTCWeekYear;

    	var _index = _interopRequireDefault(toDate$1.exports);

    	var _index2 = _interopRequireDefault(requiredArgs.exports);

    	var _index3 = _interopRequireDefault(startOfUTCWeek.exports);

    	var _index4 = _interopRequireDefault(toInteger.exports);

    	var _index5 = defaultOptions$1;

    	function _interopRequireDefault(obj) {
    	  return obj && obj.__esModule ? obj : {
    	    default: obj
    	  };
    	}

    	function getUTCWeekYear(dirtyDate, options) {
    	  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;

    	  (0, _index2.default)(1, arguments);
    	  var date = (0, _index.default)(dirtyDate);
    	  var year = date.getUTCFullYear();
    	  var defaultOptions = (0, _index5.getDefaultOptions)();
    	  var firstWeekContainsDate = (0, _index4.default)((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN

    	  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    	    throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
    	  }

    	  var firstWeekOfNextYear = new Date(0);
    	  firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
    	  firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
    	  var startOfNextYear = (0, _index3.default)(firstWeekOfNextYear, options);
    	  var firstWeekOfThisYear = new Date(0);
    	  firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
    	  firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
    	  var startOfThisYear = (0, _index3.default)(firstWeekOfThisYear, options);

    	  if (date.getTime() >= startOfNextYear.getTime()) {
    	    return year + 1;
    	  } else if (date.getTime() >= startOfThisYear.getTime()) {
    	    return year;
    	  } else {
    	    return year - 1;
    	  }
    	}

    	module.exports = exports.default;
    } (getUTCWeekYear, getUTCWeekYear.exports));

    (function (module, exports) {

    	Object.defineProperty(exports, "__esModule", {
    	  value: true
    	});
    	exports.default = startOfUTCWeekYear;

    	var _index = _interopRequireDefault(getUTCWeekYear.exports);

    	var _index2 = _interopRequireDefault(requiredArgs.exports);

    	var _index3 = _interopRequireDefault(startOfUTCWeek.exports);

    	var _index4 = _interopRequireDefault(toInteger.exports);

    	var _index5 = defaultOptions$1;

    	function _interopRequireDefault(obj) {
    	  return obj && obj.__esModule ? obj : {
    	    default: obj
    	  };
    	}

    	function startOfUTCWeekYear(dirtyDate, options) {
    	  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;

    	  (0, _index2.default)(1, arguments);
    	  var defaultOptions = (0, _index5.getDefaultOptions)();
    	  var firstWeekContainsDate = (0, _index4.default)((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
    	  var year = (0, _index.default)(dirtyDate, options);
    	  var firstWeek = new Date(0);
    	  firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
    	  firstWeek.setUTCHours(0, 0, 0, 0);
    	  var date = (0, _index3.default)(firstWeek, options);
    	  return date;
    	}

    	module.exports = exports.default;
    } (startOfUTCWeekYear, startOfUTCWeekYear.exports));

    (function (module, exports) {

    	Object.defineProperty(exports, "__esModule", {
    	  value: true
    	});
    	exports.default = getUTCWeek;

    	var _index = _interopRequireDefault(toDate$1.exports);

    	var _index2 = _interopRequireDefault(startOfUTCWeek.exports);

    	var _index3 = _interopRequireDefault(startOfUTCWeekYear.exports);

    	var _index4 = _interopRequireDefault(requiredArgs.exports);

    	function _interopRequireDefault(obj) {
    	  return obj && obj.__esModule ? obj : {
    	    default: obj
    	  };
    	}

    	var MILLISECONDS_IN_WEEK = 604800000;

    	function getUTCWeek(dirtyDate, options) {
    	  (0, _index4.default)(1, arguments);
    	  var date = (0, _index.default)(dirtyDate);
    	  var diff = (0, _index2.default)(date, options).getTime() - (0, _index3.default)(date, options).getTime(); // Round the number of days to the nearest integer
    	  // because the number of milliseconds in a week is not constant
    	  // (e.g. it's different in the week of the daylight saving time clock shift)

    	  return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
    	}

    	module.exports = exports.default;
    } (getUTCWeek, getUTCWeek.exports));

    var addLeadingZeros = {exports: {}};

    (function (module, exports) {

    	Object.defineProperty(exports, "__esModule", {
    	  value: true
    	});
    	exports.default = addLeadingZeros;

    	function addLeadingZeros(number, targetLength) {
    	  var sign = number < 0 ? '-' : '';
    	  var output = Math.abs(number).toString();

    	  while (output.length < targetLength) {
    	    output = '0' + output;
    	  }

    	  return sign + output;
    	}

    	module.exports = exports.default;
    } (addLeadingZeros, addLeadingZeros.exports));

    var lightFormatters = {exports: {}};

    (function (module, exports) {

    	Object.defineProperty(exports, "__esModule", {
    	  value: true
    	});
    	exports.default = void 0;

    	var _index = _interopRequireDefault(addLeadingZeros.exports);

    	function _interopRequireDefault(obj) {
    	  return obj && obj.__esModule ? obj : {
    	    default: obj
    	  };
    	}
    	/*
    	 * |     | Unit                           |     | Unit                           |
    	 * |-----|--------------------------------|-----|--------------------------------|
    	 * |  a  | AM, PM                         |  A* |                                |
    	 * |  d  | Day of month                   |  D  |                                |
    	 * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
    	 * |  m  | Minute                         |  M  | Month                          |
    	 * |  s  | Second                         |  S  | Fraction of second             |
    	 * |  y  | Year (abs)                     |  Y  |                                |
    	 *
    	 * Letters marked by * are not implemented but reserved by Unicode standard.
    	 */


    	var formatters = {
    	  // Year
    	  y: function (date, token) {
    	    // From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_tokens
    	    // | Year     |     y | yy |   yyy |  yyyy | yyyyy |
    	    // |----------|-------|----|-------|-------|-------|
    	    // | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
    	    // | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
    	    // | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
    	    // | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
    	    // | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |
    	    var signedYear = date.getUTCFullYear(); // Returns 1 for 1 BC (which is year 0 in JavaScript)

    	    var year = signedYear > 0 ? signedYear : 1 - signedYear;
    	    return (0, _index.default)(token === 'yy' ? year % 100 : year, token.length);
    	  },
    	  // Month
    	  M: function (date, token) {
    	    var month = date.getUTCMonth();
    	    return token === 'M' ? String(month + 1) : (0, _index.default)(month + 1, 2);
    	  },
    	  // Day of the month
    	  d: function (date, token) {
    	    return (0, _index.default)(date.getUTCDate(), token.length);
    	  },
    	  // AM or PM
    	  a: function (date, token) {
    	    var dayPeriodEnumValue = date.getUTCHours() / 12 >= 1 ? 'pm' : 'am';

    	    switch (token) {
    	      case 'a':
    	      case 'aa':
    	        return dayPeriodEnumValue.toUpperCase();

    	      case 'aaa':
    	        return dayPeriodEnumValue;

    	      case 'aaaaa':
    	        return dayPeriodEnumValue[0];

    	      case 'aaaa':
    	      default:
    	        return dayPeriodEnumValue === 'am' ? 'a.m.' : 'p.m.';
    	    }
    	  },
    	  // Hour [1-12]
    	  h: function (date, token) {
    	    return (0, _index.default)(date.getUTCHours() % 12 || 12, token.length);
    	  },
    	  // Hour [0-23]
    	  H: function (date, token) {
    	    return (0, _index.default)(date.getUTCHours(), token.length);
    	  },
    	  // Minute
    	  m: function (date, token) {
    	    return (0, _index.default)(date.getUTCMinutes(), token.length);
    	  },
    	  // Second
    	  s: function (date, token) {
    	    return (0, _index.default)(date.getUTCSeconds(), token.length);
    	  },
    	  // Fraction of second
    	  S: function (date, token) {
    	    var numberOfDigits = token.length;
    	    var milliseconds = date.getUTCMilliseconds();
    	    var fractionalSeconds = Math.floor(milliseconds * Math.pow(10, numberOfDigits - 3));
    	    return (0, _index.default)(fractionalSeconds, token.length);
    	  }
    	};
    	var _default = formatters;
    	exports.default = _default;
    	module.exports = exports.default;
    } (lightFormatters, lightFormatters.exports));

    (function (module, exports) {

    	Object.defineProperty(exports, "__esModule", {
    	  value: true
    	});
    	exports.default = void 0;

    	var _index = _interopRequireDefault(getUTCDayOfYear.exports);

    	var _index2 = _interopRequireDefault(getUTCISOWeek.exports);

    	var _index3 = _interopRequireDefault(getUTCISOWeekYear.exports);

    	var _index4 = _interopRequireDefault(getUTCWeek.exports);

    	var _index5 = _interopRequireDefault(getUTCWeekYear.exports);

    	var _index6 = _interopRequireDefault(addLeadingZeros.exports);

    	var _index7 = _interopRequireDefault(lightFormatters.exports);

    	function _interopRequireDefault(obj) {
    	  return obj && obj.__esModule ? obj : {
    	    default: obj
    	  };
    	}

    	var dayPeriodEnum = {
    	  am: 'am',
    	  pm: 'pm',
    	  midnight: 'midnight',
    	  noon: 'noon',
    	  morning: 'morning',
    	  afternoon: 'afternoon',
    	  evening: 'evening',
    	  night: 'night'
    	};
    	/*
    	 * |     | Unit                           |     | Unit                           |
    	 * |-----|--------------------------------|-----|--------------------------------|
    	 * |  a  | AM, PM                         |  A* | Milliseconds in day            |
    	 * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |
    	 * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |
    	 * |  d  | Day of month                   |  D  | Day of year                    |
    	 * |  e  | Local day of week              |  E  | Day of week                    |
    	 * |  f  |                                |  F* | Day of week in month           |
    	 * |  g* | Modified Julian day            |  G  | Era                            |
    	 * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
    	 * |  i! | ISO day of week                |  I! | ISO week of year               |
    	 * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |
    	 * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |
    	 * |  l* | (deprecated)                   |  L  | Stand-alone month              |
    	 * |  m  | Minute                         |  M  | Month                          |
    	 * |  n  |                                |  N  |                                |
    	 * |  o! | Ordinal number modifier        |  O  | Timezone (GMT)                 |
    	 * |  p! | Long localized time            |  P! | Long localized date            |
    	 * |  q  | Stand-alone quarter            |  Q  | Quarter                        |
    	 * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |
    	 * |  s  | Second                         |  S  | Fraction of second             |
    	 * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |
    	 * |  u  | Extended year                  |  U* | Cyclic year                    |
    	 * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |
    	 * |  w  | Local week of year             |  W* | Week of month                  |
    	 * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |
    	 * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |
    	 * |  z  | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |
    	 *
    	 * Letters marked by * are not implemented but reserved by Unicode standard.
    	 *
    	 * Letters marked by ! are non-standard, but implemented by date-fns:
    	 * - `o` modifies the previous token to turn it into an ordinal (see `format` docs)
    	 * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,
    	 *   i.e. 7 for Sunday, 1 for Monday, etc.
    	 * - `I` is ISO week of year, as opposed to `w` which is local week of year.
    	 * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.
    	 *   `R` is supposed to be used in conjunction with `I` and `i`
    	 *   for universal ISO week-numbering date, whereas
    	 *   `Y` is supposed to be used in conjunction with `w` and `e`
    	 *   for week-numbering date specific to the locale.
    	 * - `P` is long localized date format
    	 * - `p` is long localized time format
    	 */

    	var formatters = {
    	  // Era
    	  G: function (date, token, localize) {
    	    var era = date.getUTCFullYear() > 0 ? 1 : 0;

    	    switch (token) {
    	      // AD, BC
    	      case 'G':
    	      case 'GG':
    	      case 'GGG':
    	        return localize.era(era, {
    	          width: 'abbreviated'
    	        });
    	      // A, B

    	      case 'GGGGG':
    	        return localize.era(era, {
    	          width: 'narrow'
    	        });
    	      // Anno Domini, Before Christ

    	      case 'GGGG':
    	      default:
    	        return localize.era(era, {
    	          width: 'wide'
    	        });
    	    }
    	  },
    	  // Year
    	  y: function (date, token, localize) {
    	    // Ordinal number
    	    if (token === 'yo') {
    	      var signedYear = date.getUTCFullYear(); // Returns 1 for 1 BC (which is year 0 in JavaScript)

    	      var year = signedYear > 0 ? signedYear : 1 - signedYear;
    	      return localize.ordinalNumber(year, {
    	        unit: 'year'
    	      });
    	    }

    	    return _index7.default.y(date, token);
    	  },
    	  // Local week-numbering year
    	  Y: function (date, token, localize, options) {
    	    var signedWeekYear = (0, _index5.default)(date, options); // Returns 1 for 1 BC (which is year 0 in JavaScript)

    	    var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear; // Two digit year

    	    if (token === 'YY') {
    	      var twoDigitYear = weekYear % 100;
    	      return (0, _index6.default)(twoDigitYear, 2);
    	    } // Ordinal number


    	    if (token === 'Yo') {
    	      return localize.ordinalNumber(weekYear, {
    	        unit: 'year'
    	      });
    	    } // Padding


    	    return (0, _index6.default)(weekYear, token.length);
    	  },
    	  // ISO week-numbering year
    	  R: function (date, token) {
    	    var isoWeekYear = (0, _index3.default)(date); // Padding

    	    return (0, _index6.default)(isoWeekYear, token.length);
    	  },
    	  // Extended year. This is a single number designating the year of this calendar system.
    	  // The main difference between `y` and `u` localizers are B.C. years:
    	  // | Year | `y` | `u` |
    	  // |------|-----|-----|
    	  // | AC 1 |   1 |   1 |
    	  // | BC 1 |   1 |   0 |
    	  // | BC 2 |   2 |  -1 |
    	  // Also `yy` always returns the last two digits of a year,
    	  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
    	  u: function (date, token) {
    	    var year = date.getUTCFullYear();
    	    return (0, _index6.default)(year, token.length);
    	  },
    	  // Quarter
    	  Q: function (date, token, localize) {
    	    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);

    	    switch (token) {
    	      // 1, 2, 3, 4
    	      case 'Q':
    	        return String(quarter);
    	      // 01, 02, 03, 04

    	      case 'QQ':
    	        return (0, _index6.default)(quarter, 2);
    	      // 1st, 2nd, 3rd, 4th

    	      case 'Qo':
    	        return localize.ordinalNumber(quarter, {
    	          unit: 'quarter'
    	        });
    	      // Q1, Q2, Q3, Q4

    	      case 'QQQ':
    	        return localize.quarter(quarter, {
    	          width: 'abbreviated',
    	          context: 'formatting'
    	        });
    	      // 1, 2, 3, 4 (narrow quarter; could be not numerical)

    	      case 'QQQQQ':
    	        return localize.quarter(quarter, {
    	          width: 'narrow',
    	          context: 'formatting'
    	        });
    	      // 1st quarter, 2nd quarter, ...

    	      case 'QQQQ':
    	      default:
    	        return localize.quarter(quarter, {
    	          width: 'wide',
    	          context: 'formatting'
    	        });
    	    }
    	  },
    	  // Stand-alone quarter
    	  q: function (date, token, localize) {
    	    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);

    	    switch (token) {
    	      // 1, 2, 3, 4
    	      case 'q':
    	        return String(quarter);
    	      // 01, 02, 03, 04

    	      case 'qq':
    	        return (0, _index6.default)(quarter, 2);
    	      // 1st, 2nd, 3rd, 4th

    	      case 'qo':
    	        return localize.ordinalNumber(quarter, {
    	          unit: 'quarter'
    	        });
    	      // Q1, Q2, Q3, Q4

    	      case 'qqq':
    	        return localize.quarter(quarter, {
    	          width: 'abbreviated',
    	          context: 'standalone'
    	        });
    	      // 1, 2, 3, 4 (narrow quarter; could be not numerical)

    	      case 'qqqqq':
    	        return localize.quarter(quarter, {
    	          width: 'narrow',
    	          context: 'standalone'
    	        });
    	      // 1st quarter, 2nd quarter, ...

    	      case 'qqqq':
    	      default:
    	        return localize.quarter(quarter, {
    	          width: 'wide',
    	          context: 'standalone'
    	        });
    	    }
    	  },
    	  // Month
    	  M: function (date, token, localize) {
    	    var month = date.getUTCMonth();

    	    switch (token) {
    	      case 'M':
    	      case 'MM':
    	        return _index7.default.M(date, token);
    	      // 1st, 2nd, ..., 12th

    	      case 'Mo':
    	        return localize.ordinalNumber(month + 1, {
    	          unit: 'month'
    	        });
    	      // Jan, Feb, ..., Dec

    	      case 'MMM':
    	        return localize.month(month, {
    	          width: 'abbreviated',
    	          context: 'formatting'
    	        });
    	      // J, F, ..., D

    	      case 'MMMMM':
    	        return localize.month(month, {
    	          width: 'narrow',
    	          context: 'formatting'
    	        });
    	      // January, February, ..., December

    	      case 'MMMM':
    	      default:
    	        return localize.month(month, {
    	          width: 'wide',
    	          context: 'formatting'
    	        });
    	    }
    	  },
    	  // Stand-alone month
    	  L: function (date, token, localize) {
    	    var month = date.getUTCMonth();

    	    switch (token) {
    	      // 1, 2, ..., 12
    	      case 'L':
    	        return String(month + 1);
    	      // 01, 02, ..., 12

    	      case 'LL':
    	        return (0, _index6.default)(month + 1, 2);
    	      // 1st, 2nd, ..., 12th

    	      case 'Lo':
    	        return localize.ordinalNumber(month + 1, {
    	          unit: 'month'
    	        });
    	      // Jan, Feb, ..., Dec

    	      case 'LLL':
    	        return localize.month(month, {
    	          width: 'abbreviated',
    	          context: 'standalone'
    	        });
    	      // J, F, ..., D

    	      case 'LLLLL':
    	        return localize.month(month, {
    	          width: 'narrow',
    	          context: 'standalone'
    	        });
    	      // January, February, ..., December

    	      case 'LLLL':
    	      default:
    	        return localize.month(month, {
    	          width: 'wide',
    	          context: 'standalone'
    	        });
    	    }
    	  },
    	  // Local week of year
    	  w: function (date, token, localize, options) {
    	    var week = (0, _index4.default)(date, options);

    	    if (token === 'wo') {
    	      return localize.ordinalNumber(week, {
    	        unit: 'week'
    	      });
    	    }

    	    return (0, _index6.default)(week, token.length);
    	  },
    	  // ISO week of year
    	  I: function (date, token, localize) {
    	    var isoWeek = (0, _index2.default)(date);

    	    if (token === 'Io') {
    	      return localize.ordinalNumber(isoWeek, {
    	        unit: 'week'
    	      });
    	    }

    	    return (0, _index6.default)(isoWeek, token.length);
    	  },
    	  // Day of the month
    	  d: function (date, token, localize) {
    	    if (token === 'do') {
    	      return localize.ordinalNumber(date.getUTCDate(), {
    	        unit: 'date'
    	      });
    	    }

    	    return _index7.default.d(date, token);
    	  },
    	  // Day of year
    	  D: function (date, token, localize) {
    	    var dayOfYear = (0, _index.default)(date);

    	    if (token === 'Do') {
    	      return localize.ordinalNumber(dayOfYear, {
    	        unit: 'dayOfYear'
    	      });
    	    }

    	    return (0, _index6.default)(dayOfYear, token.length);
    	  },
    	  // Day of week
    	  E: function (date, token, localize) {
    	    var dayOfWeek = date.getUTCDay();

    	    switch (token) {
    	      // Tue
    	      case 'E':
    	      case 'EE':
    	      case 'EEE':
    	        return localize.day(dayOfWeek, {
    	          width: 'abbreviated',
    	          context: 'formatting'
    	        });
    	      // T

    	      case 'EEEEE':
    	        return localize.day(dayOfWeek, {
    	          width: 'narrow',
    	          context: 'formatting'
    	        });
    	      // Tu

    	      case 'EEEEEE':
    	        return localize.day(dayOfWeek, {
    	          width: 'short',
    	          context: 'formatting'
    	        });
    	      // Tuesday

    	      case 'EEEE':
    	      default:
    	        return localize.day(dayOfWeek, {
    	          width: 'wide',
    	          context: 'formatting'
    	        });
    	    }
    	  },
    	  // Local day of week
    	  e: function (date, token, localize, options) {
    	    var dayOfWeek = date.getUTCDay();
    	    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;

    	    switch (token) {
    	      // Numerical value (Nth day of week with current locale or weekStartsOn)
    	      case 'e':
    	        return String(localDayOfWeek);
    	      // Padded numerical value

    	      case 'ee':
    	        return (0, _index6.default)(localDayOfWeek, 2);
    	      // 1st, 2nd, ..., 7th

    	      case 'eo':
    	        return localize.ordinalNumber(localDayOfWeek, {
    	          unit: 'day'
    	        });

    	      case 'eee':
    	        return localize.day(dayOfWeek, {
    	          width: 'abbreviated',
    	          context: 'formatting'
    	        });
    	      // T

    	      case 'eeeee':
    	        return localize.day(dayOfWeek, {
    	          width: 'narrow',
    	          context: 'formatting'
    	        });
    	      // Tu

    	      case 'eeeeee':
    	        return localize.day(dayOfWeek, {
    	          width: 'short',
    	          context: 'formatting'
    	        });
    	      // Tuesday

    	      case 'eeee':
    	      default:
    	        return localize.day(dayOfWeek, {
    	          width: 'wide',
    	          context: 'formatting'
    	        });
    	    }
    	  },
    	  // Stand-alone local day of week
    	  c: function (date, token, localize, options) {
    	    var dayOfWeek = date.getUTCDay();
    	    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;

    	    switch (token) {
    	      // Numerical value (same as in `e`)
    	      case 'c':
    	        return String(localDayOfWeek);
    	      // Padded numerical value

    	      case 'cc':
    	        return (0, _index6.default)(localDayOfWeek, token.length);
    	      // 1st, 2nd, ..., 7th

    	      case 'co':
    	        return localize.ordinalNumber(localDayOfWeek, {
    	          unit: 'day'
    	        });

    	      case 'ccc':
    	        return localize.day(dayOfWeek, {
    	          width: 'abbreviated',
    	          context: 'standalone'
    	        });
    	      // T

    	      case 'ccccc':
    	        return localize.day(dayOfWeek, {
    	          width: 'narrow',
    	          context: 'standalone'
    	        });
    	      // Tu

    	      case 'cccccc':
    	        return localize.day(dayOfWeek, {
    	          width: 'short',
    	          context: 'standalone'
    	        });
    	      // Tuesday

    	      case 'cccc':
    	      default:
    	        return localize.day(dayOfWeek, {
    	          width: 'wide',
    	          context: 'standalone'
    	        });
    	    }
    	  },
    	  // ISO day of week
    	  i: function (date, token, localize) {
    	    var dayOfWeek = date.getUTCDay();
    	    var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;

    	    switch (token) {
    	      // 2
    	      case 'i':
    	        return String(isoDayOfWeek);
    	      // 02

    	      case 'ii':
    	        return (0, _index6.default)(isoDayOfWeek, token.length);
    	      // 2nd

    	      case 'io':
    	        return localize.ordinalNumber(isoDayOfWeek, {
    	          unit: 'day'
    	        });
    	      // Tue

    	      case 'iii':
    	        return localize.day(dayOfWeek, {
    	          width: 'abbreviated',
    	          context: 'formatting'
    	        });
    	      // T

    	      case 'iiiii':
    	        return localize.day(dayOfWeek, {
    	          width: 'narrow',
    	          context: 'formatting'
    	        });
    	      // Tu

    	      case 'iiiiii':
    	        return localize.day(dayOfWeek, {
    	          width: 'short',
    	          context: 'formatting'
    	        });
    	      // Tuesday

    	      case 'iiii':
    	      default:
    	        return localize.day(dayOfWeek, {
    	          width: 'wide',
    	          context: 'formatting'
    	        });
    	    }
    	  },
    	  // AM or PM
    	  a: function (date, token, localize) {
    	    var hours = date.getUTCHours();
    	    var dayPeriodEnumValue = hours / 12 >= 1 ? 'pm' : 'am';

    	    switch (token) {
    	      case 'a':
    	      case 'aa':
    	        return localize.dayPeriod(dayPeriodEnumValue, {
    	          width: 'abbreviated',
    	          context: 'formatting'
    	        });

    	      case 'aaa':
    	        return localize.dayPeriod(dayPeriodEnumValue, {
    	          width: 'abbreviated',
    	          context: 'formatting'
    	        }).toLowerCase();

    	      case 'aaaaa':
    	        return localize.dayPeriod(dayPeriodEnumValue, {
    	          width: 'narrow',
    	          context: 'formatting'
    	        });

    	      case 'aaaa':
    	      default:
    	        return localize.dayPeriod(dayPeriodEnumValue, {
    	          width: 'wide',
    	          context: 'formatting'
    	        });
    	    }
    	  },
    	  // AM, PM, midnight, noon
    	  b: function (date, token, localize) {
    	    var hours = date.getUTCHours();
    	    var dayPeriodEnumValue;

    	    if (hours === 12) {
    	      dayPeriodEnumValue = dayPeriodEnum.noon;
    	    } else if (hours === 0) {
    	      dayPeriodEnumValue = dayPeriodEnum.midnight;
    	    } else {
    	      dayPeriodEnumValue = hours / 12 >= 1 ? 'pm' : 'am';
    	    }

    	    switch (token) {
    	      case 'b':
    	      case 'bb':
    	        return localize.dayPeriod(dayPeriodEnumValue, {
    	          width: 'abbreviated',
    	          context: 'formatting'
    	        });

    	      case 'bbb':
    	        return localize.dayPeriod(dayPeriodEnumValue, {
    	          width: 'abbreviated',
    	          context: 'formatting'
    	        }).toLowerCase();

    	      case 'bbbbb':
    	        return localize.dayPeriod(dayPeriodEnumValue, {
    	          width: 'narrow',
    	          context: 'formatting'
    	        });

    	      case 'bbbb':
    	      default:
    	        return localize.dayPeriod(dayPeriodEnumValue, {
    	          width: 'wide',
    	          context: 'formatting'
    	        });
    	    }
    	  },
    	  // in the morning, in the afternoon, in the evening, at night
    	  B: function (date, token, localize) {
    	    var hours = date.getUTCHours();
    	    var dayPeriodEnumValue;

    	    if (hours >= 17) {
    	      dayPeriodEnumValue = dayPeriodEnum.evening;
    	    } else if (hours >= 12) {
    	      dayPeriodEnumValue = dayPeriodEnum.afternoon;
    	    } else if (hours >= 4) {
    	      dayPeriodEnumValue = dayPeriodEnum.morning;
    	    } else {
    	      dayPeriodEnumValue = dayPeriodEnum.night;
    	    }

    	    switch (token) {
    	      case 'B':
    	      case 'BB':
    	      case 'BBB':
    	        return localize.dayPeriod(dayPeriodEnumValue, {
    	          width: 'abbreviated',
    	          context: 'formatting'
    	        });

    	      case 'BBBBB':
    	        return localize.dayPeriod(dayPeriodEnumValue, {
    	          width: 'narrow',
    	          context: 'formatting'
    	        });

    	      case 'BBBB':
    	      default:
    	        return localize.dayPeriod(dayPeriodEnumValue, {
    	          width: 'wide',
    	          context: 'formatting'
    	        });
    	    }
    	  },
    	  // Hour [1-12]
    	  h: function (date, token, localize) {
    	    if (token === 'ho') {
    	      var hours = date.getUTCHours() % 12;
    	      if (hours === 0) hours = 12;
    	      return localize.ordinalNumber(hours, {
    	        unit: 'hour'
    	      });
    	    }

    	    return _index7.default.h(date, token);
    	  },
    	  // Hour [0-23]
    	  H: function (date, token, localize) {
    	    if (token === 'Ho') {
    	      return localize.ordinalNumber(date.getUTCHours(), {
    	        unit: 'hour'
    	      });
    	    }

    	    return _index7.default.H(date, token);
    	  },
    	  // Hour [0-11]
    	  K: function (date, token, localize) {
    	    var hours = date.getUTCHours() % 12;

    	    if (token === 'Ko') {
    	      return localize.ordinalNumber(hours, {
    	        unit: 'hour'
    	      });
    	    }

    	    return (0, _index6.default)(hours, token.length);
    	  },
    	  // Hour [1-24]
    	  k: function (date, token, localize) {
    	    var hours = date.getUTCHours();
    	    if (hours === 0) hours = 24;

    	    if (token === 'ko') {
    	      return localize.ordinalNumber(hours, {
    	        unit: 'hour'
    	      });
    	    }

    	    return (0, _index6.default)(hours, token.length);
    	  },
    	  // Minute
    	  m: function (date, token, localize) {
    	    if (token === 'mo') {
    	      return localize.ordinalNumber(date.getUTCMinutes(), {
    	        unit: 'minute'
    	      });
    	    }

    	    return _index7.default.m(date, token);
    	  },
    	  // Second
    	  s: function (date, token, localize) {
    	    if (token === 'so') {
    	      return localize.ordinalNumber(date.getUTCSeconds(), {
    	        unit: 'second'
    	      });
    	    }

    	    return _index7.default.s(date, token);
    	  },
    	  // Fraction of second
    	  S: function (date, token) {
    	    return _index7.default.S(date, token);
    	  },
    	  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
    	  X: function (date, token, _localize, options) {
    	    var originalDate = options._originalDate || date;
    	    var timezoneOffset = originalDate.getTimezoneOffset();

    	    if (timezoneOffset === 0) {
    	      return 'Z';
    	    }

    	    switch (token) {
    	      // Hours and optional minutes
    	      case 'X':
    	        return formatTimezoneWithOptionalMinutes(timezoneOffset);
    	      // Hours, minutes and optional seconds without `:` delimiter
    	      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
    	      // so this token always has the same output as `XX`

    	      case 'XXXX':
    	      case 'XX':
    	        // Hours and minutes without `:` delimiter
    	        return formatTimezone(timezoneOffset);
    	      // Hours, minutes and optional seconds with `:` delimiter
    	      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
    	      // so this token always has the same output as `XXX`

    	      case 'XXXXX':
    	      case 'XXX': // Hours and minutes with `:` delimiter

    	      default:
    	        return formatTimezone(timezoneOffset, ':');
    	    }
    	  },
    	  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
    	  x: function (date, token, _localize, options) {
    	    var originalDate = options._originalDate || date;
    	    var timezoneOffset = originalDate.getTimezoneOffset();

    	    switch (token) {
    	      // Hours and optional minutes
    	      case 'x':
    	        return formatTimezoneWithOptionalMinutes(timezoneOffset);
    	      // Hours, minutes and optional seconds without `:` delimiter
    	      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
    	      // so this token always has the same output as `xx`

    	      case 'xxxx':
    	      case 'xx':
    	        // Hours and minutes without `:` delimiter
    	        return formatTimezone(timezoneOffset);
    	      // Hours, minutes and optional seconds with `:` delimiter
    	      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
    	      // so this token always has the same output as `xxx`

    	      case 'xxxxx':
    	      case 'xxx': // Hours and minutes with `:` delimiter

    	      default:
    	        return formatTimezone(timezoneOffset, ':');
    	    }
    	  },
    	  // Timezone (GMT)
    	  O: function (date, token, _localize, options) {
    	    var originalDate = options._originalDate || date;
    	    var timezoneOffset = originalDate.getTimezoneOffset();

    	    switch (token) {
    	      // Short
    	      case 'O':
    	      case 'OO':
    	      case 'OOO':
    	        return 'GMT' + formatTimezoneShort(timezoneOffset, ':');
    	      // Long

    	      case 'OOOO':
    	      default:
    	        return 'GMT' + formatTimezone(timezoneOffset, ':');
    	    }
    	  },
    	  // Timezone (specific non-location)
    	  z: function (date, token, _localize, options) {
    	    var originalDate = options._originalDate || date;
    	    var timezoneOffset = originalDate.getTimezoneOffset();

    	    switch (token) {
    	      // Short
    	      case 'z':
    	      case 'zz':
    	      case 'zzz':
    	        return 'GMT' + formatTimezoneShort(timezoneOffset, ':');
    	      // Long

    	      case 'zzzz':
    	      default:
    	        return 'GMT' + formatTimezone(timezoneOffset, ':');
    	    }
    	  },
    	  // Seconds timestamp
    	  t: function (date, token, _localize, options) {
    	    var originalDate = options._originalDate || date;
    	    var timestamp = Math.floor(originalDate.getTime() / 1000);
    	    return (0, _index6.default)(timestamp, token.length);
    	  },
    	  // Milliseconds timestamp
    	  T: function (date, token, _localize, options) {
    	    var originalDate = options._originalDate || date;
    	    var timestamp = originalDate.getTime();
    	    return (0, _index6.default)(timestamp, token.length);
    	  }
    	};

    	function formatTimezoneShort(offset, dirtyDelimiter) {
    	  var sign = offset > 0 ? '-' : '+';
    	  var absOffset = Math.abs(offset);
    	  var hours = Math.floor(absOffset / 60);
    	  var minutes = absOffset % 60;

    	  if (minutes === 0) {
    	    return sign + String(hours);
    	  }

    	  var delimiter = dirtyDelimiter || '';
    	  return sign + String(hours) + delimiter + (0, _index6.default)(minutes, 2);
    	}

    	function formatTimezoneWithOptionalMinutes(offset, dirtyDelimiter) {
    	  if (offset % 60 === 0) {
    	    var sign = offset > 0 ? '-' : '+';
    	    return sign + (0, _index6.default)(Math.abs(offset) / 60, 2);
    	  }

    	  return formatTimezone(offset, dirtyDelimiter);
    	}

    	function formatTimezone(offset, dirtyDelimiter) {
    	  var delimiter = dirtyDelimiter || '';
    	  var sign = offset > 0 ? '-' : '+';
    	  var absOffset = Math.abs(offset);
    	  var hours = (0, _index6.default)(Math.floor(absOffset / 60), 2);
    	  var minutes = (0, _index6.default)(absOffset % 60, 2);
    	  return sign + hours + delimiter + minutes;
    	}

    	var _default = formatters;
    	exports.default = _default;
    	module.exports = exports.default;
    } (formatters$1, formatters$1.exports));

    var longFormatters = {exports: {}};

    (function (module, exports) {

    	Object.defineProperty(exports, "__esModule", {
    	  value: true
    	});
    	exports.default = void 0;

    	var dateLongFormatter = function (pattern, formatLong) {
    	  switch (pattern) {
    	    case 'P':
    	      return formatLong.date({
    	        width: 'short'
    	      });

    	    case 'PP':
    	      return formatLong.date({
    	        width: 'medium'
    	      });

    	    case 'PPP':
    	      return formatLong.date({
    	        width: 'long'
    	      });

    	    case 'PPPP':
    	    default:
    	      return formatLong.date({
    	        width: 'full'
    	      });
    	  }
    	};

    	var timeLongFormatter = function (pattern, formatLong) {
    	  switch (pattern) {
    	    case 'p':
    	      return formatLong.time({
    	        width: 'short'
    	      });

    	    case 'pp':
    	      return formatLong.time({
    	        width: 'medium'
    	      });

    	    case 'ppp':
    	      return formatLong.time({
    	        width: 'long'
    	      });

    	    case 'pppp':
    	    default:
    	      return formatLong.time({
    	        width: 'full'
    	      });
    	  }
    	};

    	var dateTimeLongFormatter = function (pattern, formatLong) {
    	  var matchResult = pattern.match(/(P+)(p+)?/) || [];
    	  var datePattern = matchResult[1];
    	  var timePattern = matchResult[2];

    	  if (!timePattern) {
    	    return dateLongFormatter(pattern, formatLong);
    	  }

    	  var dateTimeFormat;

    	  switch (datePattern) {
    	    case 'P':
    	      dateTimeFormat = formatLong.dateTime({
    	        width: 'short'
    	      });
    	      break;

    	    case 'PP':
    	      dateTimeFormat = formatLong.dateTime({
    	        width: 'medium'
    	      });
    	      break;

    	    case 'PPP':
    	      dateTimeFormat = formatLong.dateTime({
    	        width: 'long'
    	      });
    	      break;

    	    case 'PPPP':
    	    default:
    	      dateTimeFormat = formatLong.dateTime({
    	        width: 'full'
    	      });
    	      break;
    	  }

    	  return dateTimeFormat.replace('{{date}}', dateLongFormatter(datePattern, formatLong)).replace('{{time}}', timeLongFormatter(timePattern, formatLong));
    	};

    	var longFormatters = {
    	  p: timeLongFormatter,
    	  P: dateTimeLongFormatter
    	};
    	var _default = longFormatters;
    	exports.default = _default;
    	module.exports = exports.default;
    } (longFormatters, longFormatters.exports));

    var getTimezoneOffsetInMilliseconds = {exports: {}};

    (function (module, exports) {

    	Object.defineProperty(exports, "__esModule", {
    	  value: true
    	});
    	exports.default = getTimezoneOffsetInMilliseconds;
    	/**
    	 * Google Chrome as of 67.0.3396.87 introduced timezones with offset that includes seconds.
    	 * They usually appear for dates that denote time before the timezones were introduced
    	 * (e.g. for 'Europe/Prague' timezone the offset is GMT+00:57:44 before 1 October 1891
    	 * and GMT+01:00:00 after that date)
    	 *
    	 * Date#getTimezoneOffset returns the offset in minutes and would return 57 for the example above,
    	 * which would lead to incorrect calculations.
    	 *
    	 * This function returns the timezone offset in milliseconds that takes seconds in account.
    	 */

    	function getTimezoneOffsetInMilliseconds(date) {
    	  var utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
    	  utcDate.setUTCFullYear(date.getFullYear());
    	  return date.getTime() - utcDate.getTime();
    	}

    	module.exports = exports.default;
    } (getTimezoneOffsetInMilliseconds, getTimezoneOffsetInMilliseconds.exports));

    var protectedTokens = {};

    Object.defineProperty(protectedTokens, "__esModule", {
      value: true
    });
    protectedTokens.isProtectedDayOfYearToken = isProtectedDayOfYearToken;
    protectedTokens.isProtectedWeekYearToken = isProtectedWeekYearToken;
    protectedTokens.throwProtectedError = throwProtectedError;
    var protectedDayOfYearTokens = ['D', 'DD'];
    var protectedWeekYearTokens = ['YY', 'YYYY'];

    function isProtectedDayOfYearToken(token) {
      return protectedDayOfYearTokens.indexOf(token) !== -1;
    }

    function isProtectedWeekYearToken(token) {
      return protectedWeekYearTokens.indexOf(token) !== -1;
    }

    function throwProtectedError(token, format, input) {
      if (token === 'YYYY') {
        throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(format, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
      } else if (token === 'YY') {
        throw new RangeError("Use `yy` instead of `YY` (in `".concat(format, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
      } else if (token === 'D') {
        throw new RangeError("Use `d` instead of `D` (in `".concat(format, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
      } else if (token === 'DD') {
        throw new RangeError("Use `dd` instead of `DD` (in `".concat(format, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
      }
    }

    var defaultLocale = {exports: {}};

    var enUS = {exports: {}};

    var formatDistance = {exports: {}};

    (function (module, exports) {

    	Object.defineProperty(exports, "__esModule", {
    	  value: true
    	});
    	exports.default = void 0;
    	var formatDistanceLocale = {
    	  lessThanXSeconds: {
    	    one: 'less than a second',
    	    other: 'less than {{count}} seconds'
    	  },
    	  xSeconds: {
    	    one: '1 second',
    	    other: '{{count}} seconds'
    	  },
    	  halfAMinute: 'half a minute',
    	  lessThanXMinutes: {
    	    one: 'less than a minute',
    	    other: 'less than {{count}} minutes'
    	  },
    	  xMinutes: {
    	    one: '1 minute',
    	    other: '{{count}} minutes'
    	  },
    	  aboutXHours: {
    	    one: 'about 1 hour',
    	    other: 'about {{count}} hours'
    	  },
    	  xHours: {
    	    one: '1 hour',
    	    other: '{{count}} hours'
    	  },
    	  xDays: {
    	    one: '1 day',
    	    other: '{{count}} days'
    	  },
    	  aboutXWeeks: {
    	    one: 'about 1 week',
    	    other: 'about {{count}} weeks'
    	  },
    	  xWeeks: {
    	    one: '1 week',
    	    other: '{{count}} weeks'
    	  },
    	  aboutXMonths: {
    	    one: 'about 1 month',
    	    other: 'about {{count}} months'
    	  },
    	  xMonths: {
    	    one: '1 month',
    	    other: '{{count}} months'
    	  },
    	  aboutXYears: {
    	    one: 'about 1 year',
    	    other: 'about {{count}} years'
    	  },
    	  xYears: {
    	    one: '1 year',
    	    other: '{{count}} years'
    	  },
    	  overXYears: {
    	    one: 'over 1 year',
    	    other: 'over {{count}} years'
    	  },
    	  almostXYears: {
    	    one: 'almost 1 year',
    	    other: 'almost {{count}} years'
    	  }
    	};

    	var formatDistance = function (token, count, options) {
    	  var result;
    	  var tokenValue = formatDistanceLocale[token];

    	  if (typeof tokenValue === 'string') {
    	    result = tokenValue;
    	  } else if (count === 1) {
    	    result = tokenValue.one;
    	  } else {
    	    result = tokenValue.other.replace('{{count}}', count.toString());
    	  }

    	  if (options !== null && options !== void 0 && options.addSuffix) {
    	    if (options.comparison && options.comparison > 0) {
    	      return 'in ' + result;
    	    } else {
    	      return result + ' ago';
    	    }
    	  }

    	  return result;
    	};

    	var _default = formatDistance;
    	exports.default = _default;
    	module.exports = exports.default;
    } (formatDistance, formatDistance.exports));

    var formatLong = {exports: {}};

    var buildFormatLongFn = {exports: {}};

    (function (module, exports) {

    	Object.defineProperty(exports, "__esModule", {
    	  value: true
    	});
    	exports.default = buildFormatLongFn;

    	function buildFormatLongFn(args) {
    	  return function () {
    	    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}; // TODO: Remove String()

    	    var width = options.width ? String(options.width) : args.defaultWidth;
    	    var format = args.formats[width] || args.formats[args.defaultWidth];
    	    return format;
    	  };
    	}

    	module.exports = exports.default;
    } (buildFormatLongFn, buildFormatLongFn.exports));

    (function (module, exports) {

    	Object.defineProperty(exports, "__esModule", {
    	  value: true
    	});
    	exports.default = void 0;

    	var _index = _interopRequireDefault(buildFormatLongFn.exports);

    	function _interopRequireDefault(obj) {
    	  return obj && obj.__esModule ? obj : {
    	    default: obj
    	  };
    	}

    	var dateFormats = {
    	  full: 'EEEE, MMMM do, y',
    	  long: 'MMMM do, y',
    	  medium: 'MMM d, y',
    	  short: 'MM/dd/yyyy'
    	};
    	var timeFormats = {
    	  full: 'h:mm:ss a zzzz',
    	  long: 'h:mm:ss a z',
    	  medium: 'h:mm:ss a',
    	  short: 'h:mm a'
    	};
    	var dateTimeFormats = {
    	  full: "{{date}} 'at' {{time}}",
    	  long: "{{date}} 'at' {{time}}",
    	  medium: '{{date}}, {{time}}',
    	  short: '{{date}}, {{time}}'
    	};
    	var formatLong = {
    	  date: (0, _index.default)({
    	    formats: dateFormats,
    	    defaultWidth: 'full'
    	  }),
    	  time: (0, _index.default)({
    	    formats: timeFormats,
    	    defaultWidth: 'full'
    	  }),
    	  dateTime: (0, _index.default)({
    	    formats: dateTimeFormats,
    	    defaultWidth: 'full'
    	  })
    	};
    	var _default = formatLong;
    	exports.default = _default;
    	module.exports = exports.default;
    } (formatLong, formatLong.exports));

    var formatRelative = {exports: {}};

    (function (module, exports) {

    	Object.defineProperty(exports, "__esModule", {
    	  value: true
    	});
    	exports.default = void 0;
    	var formatRelativeLocale = {
    	  lastWeek: "'last' eeee 'at' p",
    	  yesterday: "'yesterday at' p",
    	  today: "'today at' p",
    	  tomorrow: "'tomorrow at' p",
    	  nextWeek: "eeee 'at' p",
    	  other: 'P'
    	};

    	var formatRelative = function (token, _date, _baseDate, _options) {
    	  return formatRelativeLocale[token];
    	};

    	var _default = formatRelative;
    	exports.default = _default;
    	module.exports = exports.default;
    } (formatRelative, formatRelative.exports));

    var localize = {exports: {}};

    var buildLocalizeFn = {exports: {}};

    (function (module, exports) {

    	Object.defineProperty(exports, "__esModule", {
    	  value: true
    	});
    	exports.default = buildLocalizeFn;

    	function buildLocalizeFn(args) {
    	  return function (dirtyIndex, options) {
    	    var context = options !== null && options !== void 0 && options.context ? String(options.context) : 'standalone';
    	    var valuesArray;

    	    if (context === 'formatting' && args.formattingValues) {
    	      var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
    	      var width = options !== null && options !== void 0 && options.width ? String(options.width) : defaultWidth;
    	      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    	    } else {
    	      var _defaultWidth = args.defaultWidth;

    	      var _width = options !== null && options !== void 0 && options.width ? String(options.width) : args.defaultWidth;

    	      valuesArray = args.values[_width] || args.values[_defaultWidth];
    	    }

    	    var index = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex; // @ts-ignore: For some reason TypeScript just don't want to match it, no matter how hard we try. I challenge you to try to remove it!

    	    return valuesArray[index];
    	  };
    	}

    	module.exports = exports.default;
    } (buildLocalizeFn, buildLocalizeFn.exports));

    (function (module, exports) {

    	Object.defineProperty(exports, "__esModule", {
    	  value: true
    	});
    	exports.default = void 0;

    	var _index = _interopRequireDefault(buildLocalizeFn.exports);

    	function _interopRequireDefault(obj) {
    	  return obj && obj.__esModule ? obj : {
    	    default: obj
    	  };
    	}

    	var eraValues = {
    	  narrow: ['B', 'A'],
    	  abbreviated: ['BC', 'AD'],
    	  wide: ['Before Christ', 'Anno Domini']
    	};
    	var quarterValues = {
    	  narrow: ['1', '2', '3', '4'],
    	  abbreviated: ['Q1', 'Q2', 'Q3', 'Q4'],
    	  wide: ['1st quarter', '2nd quarter', '3rd quarter', '4th quarter']
    	}; // Note: in English, the names of days of the week and months are capitalized.
    	// If you are making a new locale based on this one, check if the same is true for the language you're working on.
    	// Generally, formatted dates should look like they are in the middle of a sentence,
    	// e.g. in Spanish language the weekdays and months should be in the lowercase.

    	var monthValues = {
    	  narrow: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
    	  abbreviated: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
    	  wide: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
    	};
    	var dayValues = {
    	  narrow: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
    	  short: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
    	  abbreviated: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
    	  wide: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
    	};
    	var dayPeriodValues = {
    	  narrow: {
    	    am: 'a',
    	    pm: 'p',
    	    midnight: 'mi',
    	    noon: 'n',
    	    morning: 'morning',
    	    afternoon: 'afternoon',
    	    evening: 'evening',
    	    night: 'night'
    	  },
    	  abbreviated: {
    	    am: 'AM',
    	    pm: 'PM',
    	    midnight: 'midnight',
    	    noon: 'noon',
    	    morning: 'morning',
    	    afternoon: 'afternoon',
    	    evening: 'evening',
    	    night: 'night'
    	  },
    	  wide: {
    	    am: 'a.m.',
    	    pm: 'p.m.',
    	    midnight: 'midnight',
    	    noon: 'noon',
    	    morning: 'morning',
    	    afternoon: 'afternoon',
    	    evening: 'evening',
    	    night: 'night'
    	  }
    	};
    	var formattingDayPeriodValues = {
    	  narrow: {
    	    am: 'a',
    	    pm: 'p',
    	    midnight: 'mi',
    	    noon: 'n',
    	    morning: 'in the morning',
    	    afternoon: 'in the afternoon',
    	    evening: 'in the evening',
    	    night: 'at night'
    	  },
    	  abbreviated: {
    	    am: 'AM',
    	    pm: 'PM',
    	    midnight: 'midnight',
    	    noon: 'noon',
    	    morning: 'in the morning',
    	    afternoon: 'in the afternoon',
    	    evening: 'in the evening',
    	    night: 'at night'
    	  },
    	  wide: {
    	    am: 'a.m.',
    	    pm: 'p.m.',
    	    midnight: 'midnight',
    	    noon: 'noon',
    	    morning: 'in the morning',
    	    afternoon: 'in the afternoon',
    	    evening: 'in the evening',
    	    night: 'at night'
    	  }
    	};

    	var ordinalNumber = function (dirtyNumber, _options) {
    	  var number = Number(dirtyNumber); // If ordinal numbers depend on context, for example,
    	  // if they are different for different grammatical genders,
    	  // use `options.unit`.
    	  //
    	  // `unit` can be 'year', 'quarter', 'month', 'week', 'date', 'dayOfYear',
    	  // 'day', 'hour', 'minute', 'second'.

    	  var rem100 = number % 100;

    	  if (rem100 > 20 || rem100 < 10) {
    	    switch (rem100 % 10) {
    	      case 1:
    	        return number + 'st';

    	      case 2:
    	        return number + 'nd';

    	      case 3:
    	        return number + 'rd';
    	    }
    	  }

    	  return number + 'th';
    	};

    	var localize = {
    	  ordinalNumber: ordinalNumber,
    	  era: (0, _index.default)({
    	    values: eraValues,
    	    defaultWidth: 'wide'
    	  }),
    	  quarter: (0, _index.default)({
    	    values: quarterValues,
    	    defaultWidth: 'wide',
    	    argumentCallback: function (quarter) {
    	      return quarter - 1;
    	    }
    	  }),
    	  month: (0, _index.default)({
    	    values: monthValues,
    	    defaultWidth: 'wide'
    	  }),
    	  day: (0, _index.default)({
    	    values: dayValues,
    	    defaultWidth: 'wide'
    	  }),
    	  dayPeriod: (0, _index.default)({
    	    values: dayPeriodValues,
    	    defaultWidth: 'wide',
    	    formattingValues: formattingDayPeriodValues,
    	    defaultFormattingWidth: 'wide'
    	  })
    	};
    	var _default = localize;
    	exports.default = _default;
    	module.exports = exports.default;
    } (localize, localize.exports));

    var match = {exports: {}};

    var buildMatchFn = {exports: {}};

    (function (module, exports) {

    	Object.defineProperty(exports, "__esModule", {
    	  value: true
    	});
    	exports.default = buildMatchFn;

    	function buildMatchFn(args) {
    	  return function (string) {
    	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    	    var width = options.width;
    	    var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    	    var matchResult = string.match(matchPattern);

    	    if (!matchResult) {
    	      return null;
    	    }

    	    var matchedString = matchResult[0];
    	    var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    	    var key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, function (pattern) {
    	      return pattern.test(matchedString);
    	    }) : findKey(parsePatterns, function (pattern) {
    	      return pattern.test(matchedString);
    	    });
    	    var value;
    	    value = args.valueCallback ? args.valueCallback(key) : key;
    	    value = options.valueCallback ? options.valueCallback(value) : value;
    	    var rest = string.slice(matchedString.length);
    	    return {
    	      value: value,
    	      rest: rest
    	    };
    	  };
    	}

    	function findKey(object, predicate) {
    	  for (var key in object) {
    	    if (object.hasOwnProperty(key) && predicate(object[key])) {
    	      return key;
    	    }
    	  }

    	  return undefined;
    	}

    	function findIndex(array, predicate) {
    	  for (var key = 0; key < array.length; key++) {
    	    if (predicate(array[key])) {
    	      return key;
    	    }
    	  }

    	  return undefined;
    	}

    	module.exports = exports.default;
    } (buildMatchFn, buildMatchFn.exports));

    var buildMatchPatternFn = {exports: {}};

    (function (module, exports) {

    	Object.defineProperty(exports, "__esModule", {
    	  value: true
    	});
    	exports.default = buildMatchPatternFn;

    	function buildMatchPatternFn(args) {
    	  return function (string) {
    	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    	    var matchResult = string.match(args.matchPattern);
    	    if (!matchResult) return null;
    	    var matchedString = matchResult[0];
    	    var parseResult = string.match(args.parsePattern);
    	    if (!parseResult) return null;
    	    var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    	    value = options.valueCallback ? options.valueCallback(value) : value;
    	    var rest = string.slice(matchedString.length);
    	    return {
    	      value: value,
    	      rest: rest
    	    };
    	  };
    	}

    	module.exports = exports.default;
    } (buildMatchPatternFn, buildMatchPatternFn.exports));

    (function (module, exports) {

    	Object.defineProperty(exports, "__esModule", {
    	  value: true
    	});
    	exports.default = void 0;

    	var _index = _interopRequireDefault(buildMatchFn.exports);

    	var _index2 = _interopRequireDefault(buildMatchPatternFn.exports);

    	function _interopRequireDefault(obj) {
    	  return obj && obj.__esModule ? obj : {
    	    default: obj
    	  };
    	}

    	var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
    	var parseOrdinalNumberPattern = /\d+/i;
    	var matchEraPatterns = {
    	  narrow: /^(b|a)/i,
    	  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
    	  wide: /^(before christ|before common era|anno domini|common era)/i
    	};
    	var parseEraPatterns = {
    	  any: [/^b/i, /^(a|c)/i]
    	};
    	var matchQuarterPatterns = {
    	  narrow: /^[1234]/i,
    	  abbreviated: /^q[1234]/i,
    	  wide: /^[1234](th|st|nd|rd)? quarter/i
    	};
    	var parseQuarterPatterns = {
    	  any: [/1/i, /2/i, /3/i, /4/i]
    	};
    	var matchMonthPatterns = {
    	  narrow: /^[jfmasond]/i,
    	  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
    	  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
    	};
    	var parseMonthPatterns = {
    	  narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
    	  any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
    	};
    	var matchDayPatterns = {
    	  narrow: /^[smtwf]/i,
    	  short: /^(su|mo|tu|we|th|fr|sa)/i,
    	  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
    	  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
    	};
    	var parseDayPatterns = {
    	  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
    	  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
    	};
    	var matchDayPeriodPatterns = {
    	  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
    	  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
    	};
    	var parseDayPeriodPatterns = {
    	  any: {
    	    am: /^a/i,
    	    pm: /^p/i,
    	    midnight: /^mi/i,
    	    noon: /^no/i,
    	    morning: /morning/i,
    	    afternoon: /afternoon/i,
    	    evening: /evening/i,
    	    night: /night/i
    	  }
    	};
    	var match = {
    	  ordinalNumber: (0, _index2.default)({
    	    matchPattern: matchOrdinalNumberPattern,
    	    parsePattern: parseOrdinalNumberPattern,
    	    valueCallback: function (value) {
    	      return parseInt(value, 10);
    	    }
    	  }),
    	  era: (0, _index.default)({
    	    matchPatterns: matchEraPatterns,
    	    defaultMatchWidth: 'wide',
    	    parsePatterns: parseEraPatterns,
    	    defaultParseWidth: 'any'
    	  }),
    	  quarter: (0, _index.default)({
    	    matchPatterns: matchQuarterPatterns,
    	    defaultMatchWidth: 'wide',
    	    parsePatterns: parseQuarterPatterns,
    	    defaultParseWidth: 'any',
    	    valueCallback: function (index) {
    	      return index + 1;
    	    }
    	  }),
    	  month: (0, _index.default)({
    	    matchPatterns: matchMonthPatterns,
    	    defaultMatchWidth: 'wide',
    	    parsePatterns: parseMonthPatterns,
    	    defaultParseWidth: 'any'
    	  }),
    	  day: (0, _index.default)({
    	    matchPatterns: matchDayPatterns,
    	    defaultMatchWidth: 'wide',
    	    parsePatterns: parseDayPatterns,
    	    defaultParseWidth: 'any'
    	  }),
    	  dayPeriod: (0, _index.default)({
    	    matchPatterns: matchDayPeriodPatterns,
    	    defaultMatchWidth: 'any',
    	    parsePatterns: parseDayPeriodPatterns,
    	    defaultParseWidth: 'any'
    	  })
    	};
    	var _default = match;
    	exports.default = _default;
    	module.exports = exports.default;
    } (match, match.exports));

    (function (module, exports) {

    	Object.defineProperty(exports, "__esModule", {
    	  value: true
    	});
    	exports.default = void 0;

    	var _index = _interopRequireDefault(formatDistance.exports);

    	var _index2 = _interopRequireDefault(formatLong.exports);

    	var _index3 = _interopRequireDefault(formatRelative.exports);

    	var _index4 = _interopRequireDefault(localize.exports);

    	var _index5 = _interopRequireDefault(match.exports);

    	function _interopRequireDefault(obj) {
    	  return obj && obj.__esModule ? obj : {
    	    default: obj
    	  };
    	}
    	/**
    	 * @type {Locale}
    	 * @category Locales
    	 * @summary English locale (United States).
    	 * @language English
    	 * @iso-639-2 eng
    	 * @author Sasha Koss [@kossnocorp]{@link https://github.com/kossnocorp}
    	 * @author Lesha Koss [@leshakoss]{@link https://github.com/leshakoss}
    	 */


    	var locale = {
    	  code: 'en-US',
    	  formatDistance: _index.default,
    	  formatLong: _index2.default,
    	  formatRelative: _index3.default,
    	  localize: _index4.default,
    	  match: _index5.default,
    	  options: {
    	    weekStartsOn: 0
    	    /* Sunday */
    	    ,
    	    firstWeekContainsDate: 1
    	  }
    	};
    	var _default = locale;
    	exports.default = _default;
    	module.exports = exports.default;
    } (enUS, enUS.exports));

    (function (module, exports) {

    	Object.defineProperty(exports, "__esModule", {
    	  value: true
    	});
    	exports.default = void 0;

    	var _index = _interopRequireDefault(enUS.exports);

    	function _interopRequireDefault(obj) {
    	  return obj && obj.__esModule ? obj : {
    	    default: obj
    	  };
    	}

    	var _default = _index.default;
    	exports.default = _default;
    	module.exports = exports.default;
    } (defaultLocale, defaultLocale.exports));

    (function (module, exports) {

    	Object.defineProperty(exports, "__esModule", {
    	  value: true
    	});
    	exports.default = format;

    	var _index = _interopRequireDefault(isValid.exports);

    	var _index2 = _interopRequireDefault(subMilliseconds.exports);

    	var _index3 = _interopRequireDefault(toDate$1.exports);

    	var _index4 = _interopRequireDefault(formatters$1.exports);

    	var _index5 = _interopRequireDefault(longFormatters.exports);

    	var _index6 = _interopRequireDefault(getTimezoneOffsetInMilliseconds.exports);

    	var _index7 = protectedTokens;

    	var _index8 = _interopRequireDefault(toInteger.exports);

    	var _index9 = _interopRequireDefault(requiredArgs.exports);

    	var _index10 = defaultOptions$1;

    	var _index11 = _interopRequireDefault(defaultLocale.exports);

    	function _interopRequireDefault(obj) {
    	  return obj && obj.__esModule ? obj : {
    	    default: obj
    	  };
    	} // This RegExp consists of three parts separated by `|`:
    	// - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token
    	//   (one of the certain letters followed by `o`)
    	// - (\w)\1* matches any sequences of the same letter
    	// - '' matches two quote characters in a row
    	// - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
    	//   except a single quote symbol, which ends the sequence.
    	//   Two quote characters do not end the sequence.
    	//   If there is no matching single quote
    	//   then the sequence will continue until the end of the string.
    	// - . matches any single character unmatched by previous parts of the RegExps


    	var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g; // This RegExp catches symbols escaped by quotes, and also
    	// sequences of symbols P, p, and the combinations like `PPPPPPPppppp`

    	var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
    	var escapedStringRegExp = /^'([^]*?)'?$/;
    	var doubleQuoteRegExp = /''/g;
    	var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
    	/**
    	 * @name format
    	 * @category Common Helpers
    	 * @summary Format the date.
    	 *
    	 * @description
    	 * Return the formatted date string in the given format. The result may vary by locale.
    	 *
    	 * > ⚠️ Please note that the `format` tokens differ from Moment.js and other libraries.
    	 * > See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
    	 *
    	 * The characters wrapped between two single quotes characters (') are escaped.
    	 * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
    	 * (see the last example)
    	 *
    	 * Format of the string is based on Unicode Technical Standard #35:
    	 * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
    	 * with a few additions (see note 7 below the table).
    	 *
    	 * Accepted patterns:
    	 * | Unit                            | Pattern | Result examples                   | Notes |
    	 * |---------------------------------|---------|-----------------------------------|-------|
    	 * | Era                             | G..GGG  | AD, BC                            |       |
    	 * |                                 | GGGG    | Anno Domini, Before Christ        | 2     |
    	 * |                                 | GGGGG   | A, B                              |       |
    	 * | Calendar year                   | y       | 44, 1, 1900, 2017                 | 5     |
    	 * |                                 | yo      | 44th, 1st, 0th, 17th              | 5,7   |
    	 * |                                 | yy      | 44, 01, 00, 17                    | 5     |
    	 * |                                 | yyy     | 044, 001, 1900, 2017              | 5     |
    	 * |                                 | yyyy    | 0044, 0001, 1900, 2017            | 5     |
    	 * |                                 | yyyyy   | ...                               | 3,5   |
    	 * | Local week-numbering year       | Y       | 44, 1, 1900, 2017                 | 5     |
    	 * |                                 | Yo      | 44th, 1st, 1900th, 2017th         | 5,7   |
    	 * |                                 | YY      | 44, 01, 00, 17                    | 5,8   |
    	 * |                                 | YYY     | 044, 001, 1900, 2017              | 5     |
    	 * |                                 | YYYY    | 0044, 0001, 1900, 2017            | 5,8   |
    	 * |                                 | YYYYY   | ...                               | 3,5   |
    	 * | ISO week-numbering year         | R       | -43, 0, 1, 1900, 2017             | 5,7   |
    	 * |                                 | RR      | -43, 00, 01, 1900, 2017           | 5,7   |
    	 * |                                 | RRR     | -043, 000, 001, 1900, 2017        | 5,7   |
    	 * |                                 | RRRR    | -0043, 0000, 0001, 1900, 2017     | 5,7   |
    	 * |                                 | RRRRR   | ...                               | 3,5,7 |
    	 * | Extended year                   | u       | -43, 0, 1, 1900, 2017             | 5     |
    	 * |                                 | uu      | -43, 01, 1900, 2017               | 5     |
    	 * |                                 | uuu     | -043, 001, 1900, 2017             | 5     |
    	 * |                                 | uuuu    | -0043, 0001, 1900, 2017           | 5     |
    	 * |                                 | uuuuu   | ...                               | 3,5   |
    	 * | Quarter (formatting)            | Q       | 1, 2, 3, 4                        |       |
    	 * |                                 | Qo      | 1st, 2nd, 3rd, 4th                | 7     |
    	 * |                                 | QQ      | 01, 02, 03, 04                    |       |
    	 * |                                 | QQQ     | Q1, Q2, Q3, Q4                    |       |
    	 * |                                 | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
    	 * |                                 | QQQQQ   | 1, 2, 3, 4                        | 4     |
    	 * | Quarter (stand-alone)           | q       | 1, 2, 3, 4                        |       |
    	 * |                                 | qo      | 1st, 2nd, 3rd, 4th                | 7     |
    	 * |                                 | qq      | 01, 02, 03, 04                    |       |
    	 * |                                 | qqq     | Q1, Q2, Q3, Q4                    |       |
    	 * |                                 | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
    	 * |                                 | qqqqq   | 1, 2, 3, 4                        | 4     |
    	 * | Month (formatting)              | M       | 1, 2, ..., 12                     |       |
    	 * |                                 | Mo      | 1st, 2nd, ..., 12th               | 7     |
    	 * |                                 | MM      | 01, 02, ..., 12                   |       |
    	 * |                                 | MMM     | Jan, Feb, ..., Dec                |       |
    	 * |                                 | MMMM    | January, February, ..., December  | 2     |
    	 * |                                 | MMMMM   | J, F, ..., D                      |       |
    	 * | Month (stand-alone)             | L       | 1, 2, ..., 12                     |       |
    	 * |                                 | Lo      | 1st, 2nd, ..., 12th               | 7     |
    	 * |                                 | LL      | 01, 02, ..., 12                   |       |
    	 * |                                 | LLL     | Jan, Feb, ..., Dec                |       |
    	 * |                                 | LLLL    | January, February, ..., December  | 2     |
    	 * |                                 | LLLLL   | J, F, ..., D                      |       |
    	 * | Local week of year              | w       | 1, 2, ..., 53                     |       |
    	 * |                                 | wo      | 1st, 2nd, ..., 53th               | 7     |
    	 * |                                 | ww      | 01, 02, ..., 53                   |       |
    	 * | ISO week of year                | I       | 1, 2, ..., 53                     | 7     |
    	 * |                                 | Io      | 1st, 2nd, ..., 53th               | 7     |
    	 * |                                 | II      | 01, 02, ..., 53                   | 7     |
    	 * | Day of month                    | d       | 1, 2, ..., 31                     |       |
    	 * |                                 | do      | 1st, 2nd, ..., 31st               | 7     |
    	 * |                                 | dd      | 01, 02, ..., 31                   |       |
    	 * | Day of year                     | D       | 1, 2, ..., 365, 366               | 9     |
    	 * |                                 | Do      | 1st, 2nd, ..., 365th, 366th       | 7     |
    	 * |                                 | DD      | 01, 02, ..., 365, 366             | 9     |
    	 * |                                 | DDD     | 001, 002, ..., 365, 366           |       |
    	 * |                                 | DDDD    | ...                               | 3     |
    	 * | Day of week (formatting)        | E..EEE  | Mon, Tue, Wed, ..., Sun           |       |
    	 * |                                 | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
    	 * |                                 | EEEEE   | M, T, W, T, F, S, S               |       |
    	 * |                                 | EEEEEE  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
    	 * | ISO day of week (formatting)    | i       | 1, 2, 3, ..., 7                   | 7     |
    	 * |                                 | io      | 1st, 2nd, ..., 7th                | 7     |
    	 * |                                 | ii      | 01, 02, ..., 07                   | 7     |
    	 * |                                 | iii     | Mon, Tue, Wed, ..., Sun           | 7     |
    	 * |                                 | iiii    | Monday, Tuesday, ..., Sunday      | 2,7   |
    	 * |                                 | iiiii   | M, T, W, T, F, S, S               | 7     |
    	 * |                                 | iiiiii  | Mo, Tu, We, Th, Fr, Sa, Su        | 7     |
    	 * | Local day of week (formatting)  | e       | 2, 3, 4, ..., 1                   |       |
    	 * |                                 | eo      | 2nd, 3rd, ..., 1st                | 7     |
    	 * |                                 | ee      | 02, 03, ..., 01                   |       |
    	 * |                                 | eee     | Mon, Tue, Wed, ..., Sun           |       |
    	 * |                                 | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
    	 * |                                 | eeeee   | M, T, W, T, F, S, S               |       |
    	 * |                                 | eeeeee  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
    	 * | Local day of week (stand-alone) | c       | 2, 3, 4, ..., 1                   |       |
    	 * |                                 | co      | 2nd, 3rd, ..., 1st                | 7     |
    	 * |                                 | cc      | 02, 03, ..., 01                   |       |
    	 * |                                 | ccc     | Mon, Tue, Wed, ..., Sun           |       |
    	 * |                                 | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
    	 * |                                 | ccccc   | M, T, W, T, F, S, S               |       |
    	 * |                                 | cccccc  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
    	 * | AM, PM                          | a..aa   | AM, PM                            |       |
    	 * |                                 | aaa     | am, pm                            |       |
    	 * |                                 | aaaa    | a.m., p.m.                        | 2     |
    	 * |                                 | aaaaa   | a, p                              |       |
    	 * | AM, PM, noon, midnight          | b..bb   | AM, PM, noon, midnight            |       |
    	 * |                                 | bbb     | am, pm, noon, midnight            |       |
    	 * |                                 | bbbb    | a.m., p.m., noon, midnight        | 2     |
    	 * |                                 | bbbbb   | a, p, n, mi                       |       |
    	 * | Flexible day period             | B..BBB  | at night, in the morning, ...     |       |
    	 * |                                 | BBBB    | at night, in the morning, ...     | 2     |
    	 * |                                 | BBBBB   | at night, in the morning, ...     |       |
    	 * | Hour [1-12]                     | h       | 1, 2, ..., 11, 12                 |       |
    	 * |                                 | ho      | 1st, 2nd, ..., 11th, 12th         | 7     |
    	 * |                                 | hh      | 01, 02, ..., 11, 12               |       |
    	 * | Hour [0-23]                     | H       | 0, 1, 2, ..., 23                  |       |
    	 * |                                 | Ho      | 0th, 1st, 2nd, ..., 23rd          | 7     |
    	 * |                                 | HH      | 00, 01, 02, ..., 23               |       |
    	 * | Hour [0-11]                     | K       | 1, 2, ..., 11, 0                  |       |
    	 * |                                 | Ko      | 1st, 2nd, ..., 11th, 0th          | 7     |
    	 * |                                 | KK      | 01, 02, ..., 11, 00               |       |
    	 * | Hour [1-24]                     | k       | 24, 1, 2, ..., 23                 |       |
    	 * |                                 | ko      | 24th, 1st, 2nd, ..., 23rd         | 7     |
    	 * |                                 | kk      | 24, 01, 02, ..., 23               |       |
    	 * | Minute                          | m       | 0, 1, ..., 59                     |       |
    	 * |                                 | mo      | 0th, 1st, ..., 59th               | 7     |
    	 * |                                 | mm      | 00, 01, ..., 59                   |       |
    	 * | Second                          | s       | 0, 1, ..., 59                     |       |
    	 * |                                 | so      | 0th, 1st, ..., 59th               | 7     |
    	 * |                                 | ss      | 00, 01, ..., 59                   |       |
    	 * | Fraction of second              | S       | 0, 1, ..., 9                      |       |
    	 * |                                 | SS      | 00, 01, ..., 99                   |       |
    	 * |                                 | SSS     | 000, 001, ..., 999                |       |
    	 * |                                 | SSSS    | ...                               | 3     |
    	 * | Timezone (ISO-8601 w/ Z)        | X       | -08, +0530, Z                     |       |
    	 * |                                 | XX      | -0800, +0530, Z                   |       |
    	 * |                                 | XXX     | -08:00, +05:30, Z                 |       |
    	 * |                                 | XXXX    | -0800, +0530, Z, +123456          | 2     |
    	 * |                                 | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
    	 * | Timezone (ISO-8601 w/o Z)       | x       | -08, +0530, +00                   |       |
    	 * |                                 | xx      | -0800, +0530, +0000               |       |
    	 * |                                 | xxx     | -08:00, +05:30, +00:00            | 2     |
    	 * |                                 | xxxx    | -0800, +0530, +0000, +123456      |       |
    	 * |                                 | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
    	 * | Timezone (GMT)                  | O...OOO | GMT-8, GMT+5:30, GMT+0            |       |
    	 * |                                 | OOOO    | GMT-08:00, GMT+05:30, GMT+00:00   | 2     |
    	 * | Timezone (specific non-locat.)  | z...zzz | GMT-8, GMT+5:30, GMT+0            | 6     |
    	 * |                                 | zzzz    | GMT-08:00, GMT+05:30, GMT+00:00   | 2,6   |
    	 * | Seconds timestamp               | t       | 512969520                         | 7     |
    	 * |                                 | tt      | ...                               | 3,7   |
    	 * | Milliseconds timestamp          | T       | 512969520900                      | 7     |
    	 * |                                 | TT      | ...                               | 3,7   |
    	 * | Long localized date             | P       | 04/29/1453                        | 7     |
    	 * |                                 | PP      | Apr 29, 1453                      | 7     |
    	 * |                                 | PPP     | April 29th, 1453                  | 7     |
    	 * |                                 | PPPP    | Friday, April 29th, 1453          | 2,7   |
    	 * | Long localized time             | p       | 12:00 AM                          | 7     |
    	 * |                                 | pp      | 12:00:00 AM                       | 7     |
    	 * |                                 | ppp     | 12:00:00 AM GMT+2                 | 7     |
    	 * |                                 | pppp    | 12:00:00 AM GMT+02:00             | 2,7   |
    	 * | Combination of date and time    | Pp      | 04/29/1453, 12:00 AM              | 7     |
    	 * |                                 | PPpp    | Apr 29, 1453, 12:00:00 AM         | 7     |
    	 * |                                 | PPPppp  | April 29th, 1453 at ...           | 7     |
    	 * |                                 | PPPPpppp| Friday, April 29th, 1453 at ...   | 2,7   |
    	 * Notes:
    	 * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
    	 *    are the same as "stand-alone" units, but are different in some languages.
    	 *    "Formatting" units are declined according to the rules of the language
    	 *    in the context of a date. "Stand-alone" units are always nominative singular:
    	 *
    	 *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
    	 *
    	 *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
    	 *
    	 * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
    	 *    the single quote characters (see below).
    	 *    If the sequence is longer than listed in table (e.g. `EEEEEEEEEEE`)
    	 *    the output will be the same as default pattern for this unit, usually
    	 *    the longest one (in case of ISO weekdays, `EEEE`). Default patterns for units
    	 *    are marked with "2" in the last column of the table.
    	 *
    	 *    `format(new Date(2017, 10, 6), 'MMM') //=> 'Nov'`
    	 *
    	 *    `format(new Date(2017, 10, 6), 'MMMM') //=> 'November'`
    	 *
    	 *    `format(new Date(2017, 10, 6), 'MMMMM') //=> 'N'`
    	 *
    	 *    `format(new Date(2017, 10, 6), 'MMMMMM') //=> 'November'`
    	 *
    	 *    `format(new Date(2017, 10, 6), 'MMMMMMM') //=> 'November'`
    	 *
    	 * 3. Some patterns could be unlimited length (such as `yyyyyyyy`).
    	 *    The output will be padded with zeros to match the length of the pattern.
    	 *
    	 *    `format(new Date(2017, 10, 6), 'yyyyyyyy') //=> '00002017'`
    	 *
    	 * 4. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
    	 *    These tokens represent the shortest form of the quarter.
    	 *
    	 * 5. The main difference between `y` and `u` patterns are B.C. years:
    	 *
    	 *    | Year | `y` | `u` |
    	 *    |------|-----|-----|
    	 *    | AC 1 |   1 |   1 |
    	 *    | BC 1 |   1 |   0 |
    	 *    | BC 2 |   2 |  -1 |
    	 *
    	 *    Also `yy` always returns the last two digits of a year,
    	 *    while `uu` pads single digit years to 2 characters and returns other years unchanged:
    	 *
    	 *    | Year | `yy` | `uu` |
    	 *    |------|------|------|
    	 *    | 1    |   01 |   01 |
    	 *    | 14   |   14 |   14 |
    	 *    | 376  |   76 |  376 |
    	 *    | 1453 |   53 | 1453 |
    	 *
    	 *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
    	 *    except local week-numbering years are dependent on `options.weekStartsOn`
    	 *    and `options.firstWeekContainsDate` (compare [getISOWeekYear]{@link https://date-fns.org/docs/getISOWeekYear}
    	 *    and [getWeekYear]{@link https://date-fns.org/docs/getWeekYear}).
    	 *
    	 * 6. Specific non-location timezones are currently unavailable in `date-fns`,
    	 *    so right now these tokens fall back to GMT timezones.
    	 *
    	 * 7. These patterns are not in the Unicode Technical Standard #35:
    	 *    - `i`: ISO day of week
    	 *    - `I`: ISO week of year
    	 *    - `R`: ISO week-numbering year
    	 *    - `t`: seconds timestamp
    	 *    - `T`: milliseconds timestamp
    	 *    - `o`: ordinal number modifier
    	 *    - `P`: long localized date
    	 *    - `p`: long localized time
    	 *
    	 * 8. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
    	 *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
    	 *
    	 * 9. `D` and `DD` tokens represent days of the year but they are often confused with days of the month.
    	 *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
    	 *
    	 * @param {Date|Number} date - the original date
    	 * @param {String} format - the string of tokens
    	 * @param {Object} [options] - an object with options.
    	 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
    	 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
    	 * @param {Number} [options.firstWeekContainsDate=1] - the day of January, which is
    	 * @param {Boolean} [options.useAdditionalWeekYearTokens=false] - if true, allows usage of the week-numbering year tokens `YY` and `YYYY`;
    	 *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
    	 * @param {Boolean} [options.useAdditionalDayOfYearTokens=false] - if true, allows usage of the day of year tokens `D` and `DD`;
    	 *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
    	 * @returns {String} the formatted date string
    	 * @throws {TypeError} 2 arguments required
    	 * @throws {RangeError} `date` must not be Invalid Date
    	 * @throws {RangeError} `options.locale` must contain `localize` property
    	 * @throws {RangeError} `options.locale` must contain `formatLong` property
    	 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
    	 * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
    	 * @throws {RangeError} use `yyyy` instead of `YYYY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
    	 * @throws {RangeError} use `yy` instead of `YY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
    	 * @throws {RangeError} use `d` instead of `D` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
    	 * @throws {RangeError} use `dd` instead of `DD` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
    	 * @throws {RangeError} format string contains an unescaped latin alphabet character
    	 *
    	 * @example
    	 * // Represent 11 February 2014 in middle-endian format:
    	 * const result = format(new Date(2014, 1, 11), 'MM/dd/yyyy')
    	 * //=> '02/11/2014'
    	 *
    	 * @example
    	 * // Represent 2 July 2014 in Esperanto:
    	 * import { eoLocale } from 'date-fns/locale/eo'
    	 * const result = format(new Date(2014, 6, 2), "do 'de' MMMM yyyy", {
    	 *   locale: eoLocale
    	 * })
    	 * //=> '2-a de julio 2014'
    	 *
    	 * @example
    	 * // Escape string by single quote characters:
    	 * const result = format(new Date(2014, 6, 2, 15), "h 'o''clock'")
    	 * //=> "3 o'clock"
    	 */

    	function format(dirtyDate, dirtyFormatStr, options) {
    	  var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;

    	  (0, _index9.default)(2, arguments);
    	  var formatStr = String(dirtyFormatStr);
    	  var defaultOptions = (0, _index10.getDefaultOptions)();
    	  var locale = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions.locale) !== null && _ref !== void 0 ? _ref : _index11.default;
    	  var firstWeekContainsDate = (0, _index8.default)((_ref2 = (_ref3 = (_ref4 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale2 = options.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.firstWeekContainsDate) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN

    	  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    	    throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
    	  }

    	  var weekStartsOn = (0, _index8.default)((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale3 = options.locale) === null || _options$locale3 === void 0 ? void 0 : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === void 0 ? void 0 : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

    	  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    	    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
    	  }

    	  if (!locale.localize) {
    	    throw new RangeError('locale must contain localize property');
    	  }

    	  if (!locale.formatLong) {
    	    throw new RangeError('locale must contain formatLong property');
    	  }

    	  var originalDate = (0, _index3.default)(dirtyDate);

    	  if (!(0, _index.default)(originalDate)) {
    	    throw new RangeError('Invalid time value');
    	  } // Convert the date in system timezone to the same date in UTC+00:00 timezone.
    	  // This ensures that when UTC functions will be implemented, locales will be compatible with them.
    	  // See an issue about UTC functions: https://github.com/date-fns/date-fns/issues/376


    	  var timezoneOffset = (0, _index6.default)(originalDate);
    	  var utcDate = (0, _index2.default)(originalDate, timezoneOffset);
    	  var formatterOptions = {
    	    firstWeekContainsDate: firstWeekContainsDate,
    	    weekStartsOn: weekStartsOn,
    	    locale: locale,
    	    _originalDate: originalDate
    	  };
    	  var result = formatStr.match(longFormattingTokensRegExp).map(function (substring) {
    	    var firstCharacter = substring[0];

    	    if (firstCharacter === 'p' || firstCharacter === 'P') {
    	      var longFormatter = _index5.default[firstCharacter];
    	      return longFormatter(substring, locale.formatLong);
    	    }

    	    return substring;
    	  }).join('').match(formattingTokensRegExp).map(function (substring) {
    	    // Replace two single quote characters with one single quote character
    	    if (substring === "''") {
    	      return "'";
    	    }

    	    var firstCharacter = substring[0];

    	    if (firstCharacter === "'") {
    	      return cleanEscapedString(substring);
    	    }

    	    var formatter = _index4.default[firstCharacter];

    	    if (formatter) {
    	      if (!(options !== null && options !== void 0 && options.useAdditionalWeekYearTokens) && (0, _index7.isProtectedWeekYearToken)(substring)) {
    	        (0, _index7.throwProtectedError)(substring, dirtyFormatStr, String(dirtyDate));
    	      }

    	      if (!(options !== null && options !== void 0 && options.useAdditionalDayOfYearTokens) && (0, _index7.isProtectedDayOfYearToken)(substring)) {
    	        (0, _index7.throwProtectedError)(substring, dirtyFormatStr, String(dirtyDate));
    	      }

    	      return formatter(utcDate, substring, locale.localize, formatterOptions);
    	    }

    	    if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
    	      throw new RangeError('Format string contains an unescaped latin alphabet character `' + firstCharacter + '`');
    	    }

    	    return substring;
    	  }).join('');
    	  return result;
    	}

    	function cleanEscapedString(input) {
    	  var matched = input.match(escapedStringRegExp);

    	  if (!matched) {
    	    return input;
    	  }

    	  return matched[1].replace(doubleQuoteRegExp, "'");
    	}

    	module.exports = exports.default;
    } (format$2, format$2.exports));

    var formatters = {exports: {}};

    var tzIntlTimeZoneName = {exports: {}};

    (function (module, exports) {

    	Object.defineProperty(exports, "__esModule", {
    	  value: true
    	});
    	exports.default = tzIntlTimeZoneName;
    	/**
    	 * Returns the formatted time zone name of the provided `timeZone` or the current
    	 * system time zone if omitted, accounting for DST according to the UTC value of
    	 * the date.
    	 */

    	function tzIntlTimeZoneName(length, date, options) {
    	  var dtf = getDTF(length, options.timeZone, options.locale);
    	  return dtf.formatToParts ? partsTimeZone(dtf, date) : hackyTimeZone(dtf, date);
    	}

    	function partsTimeZone(dtf, date) {
    	  var formatted = dtf.formatToParts(date);
    	  return formatted[formatted.length - 1].value;
    	}

    	function hackyTimeZone(dtf, date) {
    	  var formatted = dtf.format(date).replace(/\u200E/g, '');
    	  var tzNameMatch = / [\w-+ ]+$/.exec(formatted);
    	  return tzNameMatch ? tzNameMatch[0].substr(1) : '';
    	} // If a locale has been provided `en-US` is used as a fallback in case it is an
    	// invalid locale, otherwise the locale is left undefined to use the system locale.


    	function getDTF(length, timeZone, locale) {
    	  if (locale && !locale.code) {
    	    throw new Error("date-fns-tz error: Please set a language code on the locale object imported from date-fns, e.g. `locale.code = 'en-US'`");
    	  }

    	  return new Intl.DateTimeFormat(locale ? [locale.code, 'en-US'] : undefined, {
    	    timeZone: timeZone,
    	    timeZoneName: length
    	  });
    	}

    	module.exports = exports.default;
    } (tzIntlTimeZoneName, tzIntlTimeZoneName.exports));

    var tzParseTimezone = {exports: {}};

    var tzTokenizeDate = {exports: {}};

    (function (module, exports) {

    	Object.defineProperty(exports, "__esModule", {
    	  value: true
    	});
    	exports.default = tzTokenizeDate;
    	/**
    	 * Returns the [year, month, day, hour, minute, seconds] tokens of the provided
    	 * `date` as it will be rendered in the `timeZone`.
    	 */

    	function tzTokenizeDate(date, timeZone) {
    	  var dtf = getDateTimeFormat(timeZone);
    	  return dtf.formatToParts ? partsOffset(dtf, date) : hackyOffset(dtf, date);
    	}

    	var typeToPos = {
    	  year: 0,
    	  month: 1,
    	  day: 2,
    	  hour: 3,
    	  minute: 4,
    	  second: 5
    	};

    	function partsOffset(dtf, date) {
    	  try {
    	    var formatted = dtf.formatToParts(date);
    	    var filled = [];

    	    for (var i = 0; i < formatted.length; i++) {
    	      var pos = typeToPos[formatted[i].type];

    	      if (pos >= 0) {
    	        filled[pos] = parseInt(formatted[i].value, 10);
    	      }
    	    }

    	    return filled;
    	  } catch (error) {
    	    if (error instanceof RangeError) {
    	      return [NaN];
    	    }

    	    throw error;
    	  }
    	}

    	function hackyOffset(dtf, date) {
    	  var formatted = dtf.format(date).replace(/\u200E/g, '');
    	  var parsed = /(\d+)\/(\d+)\/(\d+),? (\d+):(\d+):(\d+)/.exec(formatted); // var [, fMonth, fDay, fYear, fHour, fMinute, fSecond] = parsed
    	  // return [fYear, fMonth, fDay, fHour, fMinute, fSecond]

    	  return [parsed[3], parsed[1], parsed[2], parsed[4], parsed[5], parsed[6]];
    	} // Get a cached Intl.DateTimeFormat instance for the IANA `timeZone`. This can be used
    	// to get deterministic local date/time output according to the `en-US` locale which
    	// can be used to extract local time parts as necessary.


    	var dtfCache = {};

    	function getDateTimeFormat(timeZone) {
    	  if (!dtfCache[timeZone]) {
    	    // New browsers use `hourCycle`, IE and Chrome <73 does not support it and uses `hour12`
    	    var testDateFormatted = new Intl.DateTimeFormat('en-US', {
    	      hour12: false,
    	      timeZone: 'America/New_York',
    	      year: 'numeric',
    	      month: '2-digit',
    	      day: '2-digit',
    	      hour: '2-digit',
    	      minute: '2-digit',
    	      second: '2-digit'
    	    }).format(new Date('2014-06-25T04:00:00.123Z'));
    	    var hourCycleSupported = testDateFormatted === '06/25/2014, 00:00:00' || testDateFormatted === '‎06‎/‎25‎/‎2014‎ ‎00‎:‎00‎:‎00';
    	    dtfCache[timeZone] = hourCycleSupported ? new Intl.DateTimeFormat('en-US', {
    	      hour12: false,
    	      timeZone: timeZone,
    	      year: 'numeric',
    	      month: '2-digit',
    	      day: '2-digit',
    	      hour: '2-digit',
    	      minute: '2-digit',
    	      second: '2-digit'
    	    }) : new Intl.DateTimeFormat('en-US', {
    	      hourCycle: 'h23',
    	      timeZone: timeZone,
    	      year: 'numeric',
    	      month: '2-digit',
    	      day: '2-digit',
    	      hour: '2-digit',
    	      minute: '2-digit',
    	      second: '2-digit'
    	    });
    	  }

    	  return dtfCache[timeZone];
    	}

    	module.exports = exports.default;
    } (tzTokenizeDate, tzTokenizeDate.exports));

    var newDateUTC = {exports: {}};

    (function (module, exports) {

    	Object.defineProperty(exports, "__esModule", {
    	  value: true
    	});
    	exports.default = newDateUTC;
    	/**
    	 * Use instead of `new Date(Date.UTC(...))` to support years below 100 which doesn't work
    	 * otherwise due to the nature of the
    	 * [`Date` constructor](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date#interpretation_of_two-digit_years.
    	 *
    	 * For `Date.UTC(...)`, use `newDateUTC(...).getTime()`.
    	 */

    	function newDateUTC(fullYear, month, day, hour, minute, second, millisecond) {
    	  var utcDate = new Date(0);
    	  utcDate.setUTCFullYear(fullYear, month, day);
    	  utcDate.setUTCHours(hour, minute, second, millisecond);
    	  return utcDate;
    	}

    	module.exports = exports.default;
    } (newDateUTC, newDateUTC.exports));

    (function (module, exports) {

    	Object.defineProperty(exports, "__esModule", {
    	  value: true
    	});
    	exports.default = tzParseTimezone;

    	var _index = _interopRequireDefault(tzTokenizeDate.exports);

    	var _index2 = _interopRequireDefault(newDateUTC.exports);

    	function _interopRequireDefault(obj) {
    	  return obj && obj.__esModule ? obj : {
    	    default: obj
    	  };
    	}

    	var MILLISECONDS_IN_HOUR = 3600000;
    	var MILLISECONDS_IN_MINUTE = 60000;
    	var patterns = {
    	  timezone: /([Z+-].*)$/,
    	  timezoneZ: /^(Z)$/,
    	  timezoneHH: /^([+-]\d{2})$/,
    	  timezoneHHMM: /^([+-]\d{2}):?(\d{2})$/
    	}; // Parse various time zone offset formats to an offset in milliseconds

    	function tzParseTimezone(timezoneString, date, isUtcDate) {
    	  var token;
    	  var absoluteOffset; // Empty string

    	  if (timezoneString === '') {
    	    return 0;
    	  } // Z


    	  token = patterns.timezoneZ.exec(timezoneString);

    	  if (token) {
    	    return 0;
    	  }

    	  var hours; // ±hh

    	  token = patterns.timezoneHH.exec(timezoneString);

    	  if (token) {
    	    hours = parseInt(token[1], 10);

    	    if (!validateTimezone(hours)) {
    	      return NaN;
    	    }

    	    return -(hours * MILLISECONDS_IN_HOUR);
    	  } // ±hh:mm or ±hhmm


    	  token = patterns.timezoneHHMM.exec(timezoneString);

    	  if (token) {
    	    hours = parseInt(token[1], 10);
    	    var minutes = parseInt(token[2], 10);

    	    if (!validateTimezone(hours, minutes)) {
    	      return NaN;
    	    }

    	    absoluteOffset = Math.abs(hours) * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE;
    	    return hours > 0 ? -absoluteOffset : absoluteOffset;
    	  } // IANA time zone


    	  if (isValidTimezoneIANAString(timezoneString)) {
    	    date = new Date(date || Date.now());
    	    var utcDate = isUtcDate ? date : toUtcDate(date);
    	    var offset = calcOffset(utcDate, timezoneString);
    	    var fixedOffset = isUtcDate ? offset : fixOffset(date, offset, timezoneString);
    	    return -fixedOffset;
    	  }

    	  return NaN;
    	}

    	function toUtcDate(date) {
    	  return (0, _index2.default)(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
    	}

    	function calcOffset(date, timezoneString) {
    	  var tokens = (0, _index.default)(date, timezoneString); // ms dropped because it's not provided by tzTokenizeDate

    	  var asUTC = (0, _index2.default)(tokens[0], tokens[1] - 1, tokens[2], tokens[3] % 24, tokens[4], tokens[5], 0).getTime();
    	  var asTS = date.getTime();
    	  var over = asTS % 1000;
    	  asTS -= over >= 0 ? over : 1000 + over;
    	  return asUTC - asTS;
    	}

    	function fixOffset(date, offset, timezoneString) {
    	  var localTS = date.getTime(); // Our UTC time is just a guess because our offset is just a guess

    	  var utcGuess = localTS - offset; // Test whether the zone matches the offset for this ts

    	  var o2 = calcOffset(new Date(utcGuess), timezoneString); // If so, offset didn't change, and we're done

    	  if (offset === o2) {
    	    return offset;
    	  } // If not, change the ts by the difference in the offset


    	  utcGuess -= o2 - offset; // If that gives us the local time we want, we're done

    	  var o3 = calcOffset(new Date(utcGuess), timezoneString);

    	  if (o2 === o3) {
    	    return o2;
    	  } // If it's different, we're in a hole time. The offset has changed, but we don't adjust the time


    	  return Math.max(o2, o3);
    	}

    	function validateTimezone(hours, minutes) {
    	  return -23 <= hours && hours <= 23 && (minutes == null || 0 <= minutes && minutes <= 59);
    	}

    	var validIANATimezoneCache = {};

    	function isValidTimezoneIANAString(timeZoneString) {
    	  if (validIANATimezoneCache[timeZoneString]) return true;

    	  try {
    	    new Intl.DateTimeFormat(undefined, {
    	      timeZone: timeZoneString
    	    });
    	    validIANATimezoneCache[timeZoneString] = true;
    	    return true;
    	  } catch (error) {
    	    return false;
    	  }
    	}

    	module.exports = exports.default;
    } (tzParseTimezone, tzParseTimezone.exports));

    (function (module, exports) {

    	Object.defineProperty(exports, "__esModule", {
    	  value: true
    	});
    	exports.default = void 0;

    	var _index = _interopRequireDefault(tzIntlTimeZoneName.exports);

    	var _index2 = _interopRequireDefault(tzParseTimezone.exports);

    	function _interopRequireDefault(obj) {
    	  return obj && obj.__esModule ? obj : {
    	    default: obj
    	  };
    	}

    	var MILLISECONDS_IN_MINUTE = 60 * 1000;
    	var formatters = {
    	  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
    	  X: function (date, token, localize, options) {
    	    var timezoneOffset = getTimeZoneOffset(options.timeZone, options._originalDate || date);

    	    if (timezoneOffset === 0) {
    	      return 'Z';
    	    }

    	    switch (token) {
    	      // Hours and optional minutes
    	      case 'X':
    	        return formatTimezoneWithOptionalMinutes(timezoneOffset);
    	      // Hours, minutes and optional seconds without `:` delimeter
    	      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
    	      // so this token always has the same output as `XX`

    	      case 'XXXX':
    	      case 'XX':
    	        // Hours and minutes without `:` delimeter
    	        return formatTimezone(timezoneOffset);
    	      // Hours, minutes and optional seconds with `:` delimeter
    	      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
    	      // so this token always has the same output as `XXX`

    	      case 'XXXXX':
    	      case 'XXX': // Hours and minutes with `:` delimeter

    	      default:
    	        return formatTimezone(timezoneOffset, ':');
    	    }
    	  },
    	  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
    	  x: function (date, token, localize, options) {
    	    var timezoneOffset = getTimeZoneOffset(options.timeZone, options._originalDate || date);

    	    switch (token) {
    	      // Hours and optional minutes
    	      case 'x':
    	        return formatTimezoneWithOptionalMinutes(timezoneOffset);
    	      // Hours, minutes and optional seconds without `:` delimeter
    	      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
    	      // so this token always has the same output as `xx`

    	      case 'xxxx':
    	      case 'xx':
    	        // Hours and minutes without `:` delimeter
    	        return formatTimezone(timezoneOffset);
    	      // Hours, minutes and optional seconds with `:` delimeter
    	      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
    	      // so this token always has the same output as `xxx`

    	      case 'xxxxx':
    	      case 'xxx': // Hours and minutes with `:` delimeter

    	      default:
    	        return formatTimezone(timezoneOffset, ':');
    	    }
    	  },
    	  // Timezone (GMT)
    	  O: function (date, token, localize, options) {
    	    var timezoneOffset = getTimeZoneOffset(options.timeZone, options._originalDate || date);

    	    switch (token) {
    	      // Short
    	      case 'O':
    	      case 'OO':
    	      case 'OOO':
    	        return 'GMT' + formatTimezoneShort(timezoneOffset, ':');
    	      // Long

    	      case 'OOOO':
    	      default:
    	        return 'GMT' + formatTimezone(timezoneOffset, ':');
    	    }
    	  },
    	  // Timezone (specific non-location)
    	  z: function (date, token, localize, options) {
    	    var originalDate = options._originalDate || date;

    	    switch (token) {
    	      // Short
    	      case 'z':
    	      case 'zz':
    	      case 'zzz':
    	        return (0, _index.default)('short', originalDate, options);
    	      // Long

    	      case 'zzzz':
    	      default:
    	        return (0, _index.default)('long', originalDate, options);
    	    }
    	  }
    	};

    	function getTimeZoneOffset(timeZone, originalDate) {
    	  var timeZoneOffset = timeZone ? (0, _index2.default)(timeZone, originalDate, true) / MILLISECONDS_IN_MINUTE : originalDate.getTimezoneOffset();

    	  if (Number.isNaN(timeZoneOffset)) {
    	    throw new RangeError('Invalid time zone specified: ' + timeZone);
    	  }

    	  return timeZoneOffset;
    	}

    	function addLeadingZeros(number, targetLength) {
    	  var sign = number < 0 ? '-' : '';
    	  var output = Math.abs(number).toString();

    	  while (output.length < targetLength) {
    	    output = '0' + output;
    	  }

    	  return sign + output;
    	}

    	function formatTimezone(offset, dirtyDelimeter) {
    	  var delimeter = dirtyDelimeter || '';
    	  var sign = offset > 0 ? '-' : '+';
    	  var absOffset = Math.abs(offset);
    	  var hours = addLeadingZeros(Math.floor(absOffset / 60), 2);
    	  var minutes = addLeadingZeros(Math.floor(absOffset % 60), 2);
    	  return sign + hours + delimeter + minutes;
    	}

    	function formatTimezoneWithOptionalMinutes(offset, dirtyDelimeter) {
    	  if (offset % 60 === 0) {
    	    var sign = offset > 0 ? '-' : '+';
    	    return sign + addLeadingZeros(Math.abs(offset) / 60, 2);
    	  }

    	  return formatTimezone(offset, dirtyDelimeter);
    	}

    	function formatTimezoneShort(offset, dirtyDelimeter) {
    	  var sign = offset > 0 ? '-' : '+';
    	  var absOffset = Math.abs(offset);
    	  var hours = Math.floor(absOffset / 60);
    	  var minutes = absOffset % 60;

    	  if (minutes === 0) {
    	    return sign + String(hours);
    	  }

    	  var delimeter = dirtyDelimeter || '';
    	  return sign + String(hours) + delimeter + addLeadingZeros(minutes, 2);
    	}

    	var _default = formatters;
    	exports.default = _default;
    	module.exports = exports.default;
    } (formatters, formatters.exports));

    var toDate = {exports: {}};

    var tzPattern = {exports: {}};

    (function (module, exports) {

    	Object.defineProperty(exports, "__esModule", {
    	  value: true
    	});
    	exports.default = void 0;
    	/** Regex to identify the presence of a time zone specifier in a date string */

    	var tzPattern = /(Z|[+-]\d{2}(?::?\d{2})?| UTC| [a-zA-Z]+\/[a-zA-Z_]+(?:\/[a-zA-Z_]+)?)$/;
    	var _default = tzPattern;
    	exports.default = _default;
    	module.exports = exports.default;
    } (tzPattern, tzPattern.exports));

    (function (module, exports) {

    	Object.defineProperty(exports, "__esModule", {
    	  value: true
    	});
    	exports.default = toDate;

    	var _index = _interopRequireDefault(toInteger.exports);

    	var _index2 = _interopRequireDefault(getTimezoneOffsetInMilliseconds.exports);

    	var _index3 = _interopRequireDefault(tzParseTimezone.exports);

    	var _index4 = _interopRequireDefault(tzPattern.exports);

    	function _interopRequireDefault(obj) {
    	  return obj && obj.__esModule ? obj : {
    	    default: obj
    	  };
    	}

    	var MILLISECONDS_IN_HOUR = 3600000;
    	var MILLISECONDS_IN_MINUTE = 60000;
    	var DEFAULT_ADDITIONAL_DIGITS = 2;
    	var patterns = {
    	  dateTimePattern: /^([0-9W+-]+)(T| )(.*)/,
    	  datePattern: /^([0-9W+-]+)(.*)/,
    	  plainTime: /:/,
    	  // year tokens
    	  YY: /^(\d{2})$/,
    	  YYY: [/^([+-]\d{2})$/, // 0 additional digits
    	  /^([+-]\d{3})$/, // 1 additional digit
    	  /^([+-]\d{4})$/ // 2 additional digits
    	  ],
    	  YYYY: /^(\d{4})/,
    	  YYYYY: [/^([+-]\d{4})/, // 0 additional digits
    	  /^([+-]\d{5})/, // 1 additional digit
    	  /^([+-]\d{6})/ // 2 additional digits
    	  ],
    	  // date tokens
    	  MM: /^-(\d{2})$/,
    	  DDD: /^-?(\d{3})$/,
    	  MMDD: /^-?(\d{2})-?(\d{2})$/,
    	  Www: /^-?W(\d{2})$/,
    	  WwwD: /^-?W(\d{2})-?(\d{1})$/,
    	  HH: /^(\d{2}([.,]\d*)?)$/,
    	  HHMM: /^(\d{2}):?(\d{2}([.,]\d*)?)$/,
    	  HHMMSS: /^(\d{2}):?(\d{2}):?(\d{2}([.,]\d*)?)$/,
    	  // time zone tokens (to identify the presence of a tz)
    	  timeZone: _index4.default
    	};
    	/**
    	 * @name toDate
    	 * @category Common Helpers
    	 * @summary Convert the given argument to an instance of Date.
    	 *
    	 * @description
    	 * Convert the given argument to an instance of Date.
    	 *
    	 * If the argument is an instance of Date, the function returns its clone.
    	 *
    	 * If the argument is a number, it is treated as a timestamp.
    	 *
    	 * If an argument is a string, the function tries to parse it.
    	 * Function accepts complete ISO 8601 formats as well as partial implementations.
    	 * ISO 8601: http://en.wikipedia.org/wiki/ISO_8601
    	 * If the function cannot parse the string or the values are invalid, it returns Invalid Date.
    	 *
    	 * If the argument is none of the above, the function returns Invalid Date.
    	 *
    	 * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
    	 * All *date-fns* functions will throw `RangeError` if `options.additionalDigits` is not 0, 1, 2 or undefined.
    	 *
    	 * @param {Date|String|Number} argument - the value to convert
    	 * @param {OptionsWithTZ} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}
    	 * @param {0|1|2} [options.additionalDigits=2] - the additional number of digits in the extended year format
    	 * @param {String} [options.timeZone=''] - used to specify the IANA time zone offset of a date String.
    	 * @returns {Date} the parsed date in the local time zone
    	 * @throws {TypeError} 1 argument required
    	 * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
    	 *
    	 * @example
    	 * // Convert string '2014-02-11T11:30:30' to date:
    	 * var result = toDate('2014-02-11T11:30:30')
    	 * //=> Tue Feb 11 2014 11:30:30
    	 *
    	 * @example
    	 * // Convert string '+02014101' to date,
    	 * // if the additional number of digits in the extended year format is 1:
    	 * var result = toDate('+02014101', {additionalDigits: 1})
    	 * //=> Fri Apr 11 2014 00:00:00
    	 */

    	function toDate(argument, dirtyOptions) {
    	  if (arguments.length < 1) {
    	    throw new TypeError('1 argument required, but only ' + arguments.length + ' present');
    	  }

    	  if (argument === null) {
    	    return new Date(NaN);
    	  }

    	  var options = dirtyOptions || {};
    	  var additionalDigits = options.additionalDigits == null ? DEFAULT_ADDITIONAL_DIGITS : (0, _index.default)(options.additionalDigits);

    	  if (additionalDigits !== 2 && additionalDigits !== 1 && additionalDigits !== 0) {
    	    throw new RangeError('additionalDigits must be 0, 1 or 2');
    	  } // Clone the date


    	  if (argument instanceof Date || typeof argument === 'object' && Object.prototype.toString.call(argument) === '[object Date]') {
    	    // Prevent the date to lose the milliseconds when passed to new Date() in IE10
    	    return new Date(argument.getTime());
    	  } else if (typeof argument === 'number' || Object.prototype.toString.call(argument) === '[object Number]') {
    	    return new Date(argument);
    	  } else if (!(typeof argument === 'string' || Object.prototype.toString.call(argument) === '[object String]')) {
    	    return new Date(NaN);
    	  }

    	  var dateStrings = splitDateString(argument);
    	  var parseYearResult = parseYear(dateStrings.date, additionalDigits);
    	  var year = parseYearResult.year;
    	  var restDateString = parseYearResult.restDateString;
    	  var date = parseDate(restDateString, year);

    	  if (isNaN(date)) {
    	    return new Date(NaN);
    	  }

    	  if (date) {
    	    var timestamp = date.getTime();
    	    var time = 0;
    	    var offset;

    	    if (dateStrings.time) {
    	      time = parseTime(dateStrings.time);

    	      if (isNaN(time)) {
    	        return new Date(NaN);
    	      }
    	    }

    	    if (dateStrings.timeZone || options.timeZone) {
    	      offset = (0, _index3.default)(dateStrings.timeZone || options.timeZone, new Date(timestamp + time));

    	      if (isNaN(offset)) {
    	        return new Date(NaN);
    	      }
    	    } else {
    	      // get offset accurate to hour in time zones that change offset
    	      offset = (0, _index2.default)(new Date(timestamp + time));
    	      offset = (0, _index2.default)(new Date(timestamp + time + offset));
    	    }

    	    return new Date(timestamp + time + offset);
    	  } else {
    	    return new Date(NaN);
    	  }
    	}

    	function splitDateString(dateString) {
    	  var dateStrings = {};
    	  var parts = patterns.dateTimePattern.exec(dateString);
    	  var timeString;

    	  if (!parts) {
    	    parts = patterns.datePattern.exec(dateString);

    	    if (parts) {
    	      dateStrings.date = parts[1];
    	      timeString = parts[2];
    	    } else {
    	      dateStrings.date = null;
    	      timeString = dateString;
    	    }
    	  } else {
    	    dateStrings.date = parts[1];
    	    timeString = parts[3];
    	  }

    	  if (timeString) {
    	    var token = patterns.timeZone.exec(timeString);

    	    if (token) {
    	      dateStrings.time = timeString.replace(token[1], '');
    	      dateStrings.timeZone = token[1].trim();
    	    } else {
    	      dateStrings.time = timeString;
    	    }
    	  }

    	  return dateStrings;
    	}

    	function parseYear(dateString, additionalDigits) {
    	  var patternYYY = patterns.YYY[additionalDigits];
    	  var patternYYYYY = patterns.YYYYY[additionalDigits];
    	  var token; // YYYY or ±YYYYY

    	  token = patterns.YYYY.exec(dateString) || patternYYYYY.exec(dateString);

    	  if (token) {
    	    var yearString = token[1];
    	    return {
    	      year: parseInt(yearString, 10),
    	      restDateString: dateString.slice(yearString.length)
    	    };
    	  } // YY or ±YYY


    	  token = patterns.YY.exec(dateString) || patternYYY.exec(dateString);

    	  if (token) {
    	    var centuryString = token[1];
    	    return {
    	      year: parseInt(centuryString, 10) * 100,
    	      restDateString: dateString.slice(centuryString.length)
    	    };
    	  } // Invalid ISO-formatted year


    	  return {
    	    year: null
    	  };
    	}

    	function parseDate(dateString, year) {
    	  // Invalid ISO-formatted year
    	  if (year === null) {
    	    return null;
    	  }

    	  var token;
    	  var date;
    	  var month;
    	  var week; // YYYY

    	  if (dateString.length === 0) {
    	    date = new Date(0);
    	    date.setUTCFullYear(year);
    	    return date;
    	  } // YYYY-MM


    	  token = patterns.MM.exec(dateString);

    	  if (token) {
    	    date = new Date(0);
    	    month = parseInt(token[1], 10) - 1;

    	    if (!validateDate(year, month)) {
    	      return new Date(NaN);
    	    }

    	    date.setUTCFullYear(year, month);
    	    return date;
    	  } // YYYY-DDD or YYYYDDD


    	  token = patterns.DDD.exec(dateString);

    	  if (token) {
    	    date = new Date(0);
    	    var dayOfYear = parseInt(token[1], 10);

    	    if (!validateDayOfYearDate(year, dayOfYear)) {
    	      return new Date(NaN);
    	    }

    	    date.setUTCFullYear(year, 0, dayOfYear);
    	    return date;
    	  } // yyyy-MM-dd or YYYYMMDD


    	  token = patterns.MMDD.exec(dateString);

    	  if (token) {
    	    date = new Date(0);
    	    month = parseInt(token[1], 10) - 1;
    	    var day = parseInt(token[2], 10);

    	    if (!validateDate(year, month, day)) {
    	      return new Date(NaN);
    	    }

    	    date.setUTCFullYear(year, month, day);
    	    return date;
    	  } // YYYY-Www or YYYYWww


    	  token = patterns.Www.exec(dateString);

    	  if (token) {
    	    week = parseInt(token[1], 10) - 1;

    	    if (!validateWeekDate(year, week)) {
    	      return new Date(NaN);
    	    }

    	    return dayOfISOWeekYear(year, week);
    	  } // YYYY-Www-D or YYYYWwwD


    	  token = patterns.WwwD.exec(dateString);

    	  if (token) {
    	    week = parseInt(token[1], 10) - 1;
    	    var dayOfWeek = parseInt(token[2], 10) - 1;

    	    if (!validateWeekDate(year, week, dayOfWeek)) {
    	      return new Date(NaN);
    	    }

    	    return dayOfISOWeekYear(year, week, dayOfWeek);
    	  } // Invalid ISO-formatted date


    	  return null;
    	}

    	function parseTime(timeString) {
    	  var token;
    	  var hours;
    	  var minutes; // hh

    	  token = patterns.HH.exec(timeString);

    	  if (token) {
    	    hours = parseFloat(token[1].replace(',', '.'));

    	    if (!validateTime(hours)) {
    	      return NaN;
    	    }

    	    return hours % 24 * MILLISECONDS_IN_HOUR;
    	  } // hh:mm or hhmm


    	  token = patterns.HHMM.exec(timeString);

    	  if (token) {
    	    hours = parseInt(token[1], 10);
    	    minutes = parseFloat(token[2].replace(',', '.'));

    	    if (!validateTime(hours, minutes)) {
    	      return NaN;
    	    }

    	    return hours % 24 * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE;
    	  } // hh:mm:ss or hhmmss


    	  token = patterns.HHMMSS.exec(timeString);

    	  if (token) {
    	    hours = parseInt(token[1], 10);
    	    minutes = parseInt(token[2], 10);
    	    var seconds = parseFloat(token[3].replace(',', '.'));

    	    if (!validateTime(hours, minutes, seconds)) {
    	      return NaN;
    	    }

    	    return hours % 24 * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE + seconds * 1000;
    	  } // Invalid ISO-formatted time


    	  return null;
    	}

    	function dayOfISOWeekYear(isoWeekYear, week, day) {
    	  week = week || 0;
    	  day = day || 0;
    	  var date = new Date(0);
    	  date.setUTCFullYear(isoWeekYear, 0, 4);
    	  var fourthOfJanuaryDay = date.getUTCDay() || 7;
    	  var diff = week * 7 + day + 1 - fourthOfJanuaryDay;
    	  date.setUTCDate(date.getUTCDate() + diff);
    	  return date;
    	} // Validation functions


    	var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    	var DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

    	function isLeapYearIndex(year) {
    	  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
    	}

    	function validateDate(year, month, date) {
    	  if (month < 0 || month > 11) {
    	    return false;
    	  }

    	  if (date != null) {
    	    if (date < 1) {
    	      return false;
    	    }

    	    var isLeapYear = isLeapYearIndex(year);

    	    if (isLeapYear && date > DAYS_IN_MONTH_LEAP_YEAR[month]) {
    	      return false;
    	    }

    	    if (!isLeapYear && date > DAYS_IN_MONTH[month]) {
    	      return false;
    	    }
    	  }

    	  return true;
    	}

    	function validateDayOfYearDate(year, dayOfYear) {
    	  if (dayOfYear < 1) {
    	    return false;
    	  }

    	  var isLeapYear = isLeapYearIndex(year);

    	  if (isLeapYear && dayOfYear > 366) {
    	    return false;
    	  }

    	  if (!isLeapYear && dayOfYear > 365) {
    	    return false;
    	  }

    	  return true;
    	}

    	function validateWeekDate(year, week, day) {
    	  if (week < 0 || week > 52) {
    	    return false;
    	  }

    	  if (day != null && (day < 0 || day > 6)) {
    	    return false;
    	  }

    	  return true;
    	}

    	function validateTime(hours, minutes, seconds) {
    	  if (hours != null && (hours < 0 || hours >= 25)) {
    	    return false;
    	  }

    	  if (minutes != null && (minutes < 0 || minutes >= 60)) {
    	    return false;
    	  }

    	  if (seconds != null && (seconds < 0 || seconds >= 60)) {
    	    return false;
    	  }

    	  return true;
    	}

    	module.exports = exports.default;
    } (toDate, toDate.exports));

    (function (module, exports) {

    	Object.defineProperty(exports, "__esModule", {
    	  value: true
    	});
    	exports.default = format;

    	var _index = _interopRequireDefault(format$2.exports);

    	var _index2 = _interopRequireDefault(formatters.exports);

    	var _index3 = _interopRequireDefault(toDate.exports);

    	function _interopRequireDefault(obj) {
    	  return obj && obj.__esModule ? obj : {
    	    default: obj
    	  };
    	}

    	var tzFormattingTokensRegExp = /([xXOz]+)|''|'(''|[^'])+('|$)/g;
    	/**
    	 * @name format
    	 * @category Common Helpers
    	 * @summary Format the date.
    	 *
    	 * @description
    	 * Return the formatted date string in the given format. The result may vary by locale.
    	 *
    	 * > ⚠️ Please note that the `format` tokens differ from Moment.js and other libraries.
    	 * > See: https://git.io/fxCyr
    	 *
    	 * The characters wrapped between two single quotes characters (') are escaped.
    	 * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
    	 * (see the last example)
    	 *
    	 * Format of the string is based on Unicode Technical Standard #35:
    	 * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
    	 * with a few additions (see note 7 below the table).
    	 *
    	 * Accepted patterns:
    	 * | Unit                            | Pattern | Result examples                   | Notes |
    	 * |---------------------------------|---------|-----------------------------------|-------|
    	 * | Era                             | G..GGG  | AD, BC                            |       |
    	 * |                                 | GGGG    | Anno Domini, Before Christ        | 2     |
    	 * |                                 | GGGGG   | A, B                              |       |
    	 * | Calendar year                   | y       | 44, 1, 1900, 2017                 | 5     |
    	 * |                                 | yo      | 44th, 1st, 0th, 17th              | 5,7   |
    	 * |                                 | yy      | 44, 01, 00, 17                    | 5     |
    	 * |                                 | yyy     | 044, 001, 1900, 2017              | 5     |
    	 * |                                 | yyyy    | 0044, 0001, 1900, 2017            | 5     |
    	 * |                                 | yyyyy   | ...                               | 3,5   |
    	 * | Local week-numbering year       | Y       | 44, 1, 1900, 2017                 | 5     |
    	 * |                                 | Yo      | 44th, 1st, 1900th, 2017th         | 5,7   |
    	 * |                                 | YY      | 44, 01, 00, 17                    | 5,8   |
    	 * |                                 | YYY     | 044, 001, 1900, 2017              | 5     |
    	 * |                                 | YYYY    | 0044, 0001, 1900, 2017            | 5,8   |
    	 * |                                 | YYYYY   | ...                               | 3,5   |
    	 * | ISO week-numbering year         | R       | -43, 0, 1, 1900, 2017             | 5,7   |
    	 * |                                 | RR      | -43, 00, 01, 1900, 2017           | 5,7   |
    	 * |                                 | RRR     | -043, 000, 001, 1900, 2017        | 5,7   |
    	 * |                                 | RRRR    | -0043, 0000, 0001, 1900, 2017     | 5,7   |
    	 * |                                 | RRRRR   | ...                               | 3,5,7 |
    	 * | Extended year                   | u       | -43, 0, 1, 1900, 2017             | 5     |
    	 * |                                 | uu      | -43, 01, 1900, 2017               | 5     |
    	 * |                                 | uuu     | -043, 001, 1900, 2017             | 5     |
    	 * |                                 | uuuu    | -0043, 0001, 1900, 2017           | 5     |
    	 * |                                 | uuuuu   | ...                               | 3,5   |
    	 * | Quarter (formatting)            | Q       | 1, 2, 3, 4                        |       |
    	 * |                                 | Qo      | 1st, 2nd, 3rd, 4th                | 7     |
    	 * |                                 | QQ      | 01, 02, 03, 04                    |       |
    	 * |                                 | QQQ     | Q1, Q2, Q3, Q4                    |       |
    	 * |                                 | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
    	 * |                                 | QQQQQ   | 1, 2, 3, 4                        | 4     |
    	 * | Quarter (stand-alone)           | q       | 1, 2, 3, 4                        |       |
    	 * |                                 | qo      | 1st, 2nd, 3rd, 4th                | 7     |
    	 * |                                 | qq      | 01, 02, 03, 04                    |       |
    	 * |                                 | qqq     | Q1, Q2, Q3, Q4                    |       |
    	 * |                                 | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
    	 * |                                 | qqqqq   | 1, 2, 3, 4                        | 4     |
    	 * | Month (formatting)              | M       | 1, 2, ..., 12                     |       |
    	 * |                                 | Mo      | 1st, 2nd, ..., 12th               | 7     |
    	 * |                                 | MM      | 01, 02, ..., 12                   |       |
    	 * |                                 | MMM     | Jan, Feb, ..., Dec                |       |
    	 * |                                 | MMMM    | January, February, ..., December  | 2     |
    	 * |                                 | MMMMM   | J, F, ..., D                      |       |
    	 * | Month (stand-alone)             | L       | 1, 2, ..., 12                     |       |
    	 * |                                 | Lo      | 1st, 2nd, ..., 12th               | 7     |
    	 * |                                 | LL      | 01, 02, ..., 12                   |       |
    	 * |                                 | LLL     | Jan, Feb, ..., Dec                |       |
    	 * |                                 | LLLL    | January, February, ..., December  | 2     |
    	 * |                                 | LLLLL   | J, F, ..., D                      |       |
    	 * | Local week of year              | w       | 1, 2, ..., 53                     |       |
    	 * |                                 | wo      | 1st, 2nd, ..., 53th               | 7     |
    	 * |                                 | ww      | 01, 02, ..., 53                   |       |
    	 * | ISO week of year                | I       | 1, 2, ..., 53                     | 7     |
    	 * |                                 | Io      | 1st, 2nd, ..., 53th               | 7     |
    	 * |                                 | II      | 01, 02, ..., 53                   | 7     |
    	 * | Day of month                    | d       | 1, 2, ..., 31                     |       |
    	 * |                                 | do      | 1st, 2nd, ..., 31st               | 7     |
    	 * |                                 | dd      | 01, 02, ..., 31                   |       |
    	 * | Day of year                     | D       | 1, 2, ..., 365, 366               | 8     |
    	 * |                                 | Do      | 1st, 2nd, ..., 365th, 366th       | 7     |
    	 * |                                 | DD      | 01, 02, ..., 365, 366             | 8     |
    	 * |                                 | DDD     | 001, 002, ..., 365, 366           |       |
    	 * |                                 | DDDD    | ...                               | 3     |
    	 * | Day of week (formatting)        | E..EEE  | Mon, Tue, Wed, ..., Su            |       |
    	 * |                                 | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
    	 * |                                 | EEEEE   | M, T, W, T, F, S, S               |       |
    	 * |                                 | EEEEEE  | Mo, Tu, We, Th, Fr, Su, Sa        |       |
    	 * | ISO day of week (formatting)    | i       | 1, 2, 3, ..., 7                   | 7     |
    	 * |                                 | io      | 1st, 2nd, ..., 7th                | 7     |
    	 * |                                 | ii      | 01, 02, ..., 07                   | 7     |
    	 * |                                 | iii     | Mon, Tue, Wed, ..., Su            | 7     |
    	 * |                                 | iiii    | Monday, Tuesday, ..., Sunday      | 2,7   |
    	 * |                                 | iiiii   | M, T, W, T, F, S, S               | 7     |
    	 * |                                 | iiiiii  | Mo, Tu, We, Th, Fr, Su, Sa        | 7     |
    	 * | Local day of week (formatting)  | e       | 2, 3, 4, ..., 1                   |       |
    	 * |                                 | eo      | 2nd, 3rd, ..., 1st                | 7     |
    	 * |                                 | ee      | 02, 03, ..., 01                   |       |
    	 * |                                 | eee     | Mon, Tue, Wed, ..., Su            |       |
    	 * |                                 | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
    	 * |                                 | eeeee   | M, T, W, T, F, S, S               |       |
    	 * |                                 | eeeeee  | Mo, Tu, We, Th, Fr, Su, Sa        |       |
    	 * | Local day of week (stand-alone) | c       | 2, 3, 4, ..., 1                   |       |
    	 * |                                 | co      | 2nd, 3rd, ..., 1st                | 7     |
    	 * |                                 | cc      | 02, 03, ..., 01                   |       |
    	 * |                                 | ccc     | Mon, Tue, Wed, ..., Su            |       |
    	 * |                                 | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
    	 * |                                 | ccccc   | M, T, W, T, F, S, S               |       |
    	 * |                                 | cccccc  | Mo, Tu, We, Th, Fr, Su, Sa        |       |
    	 * | AM, PM                          | a..aaa  | AM, PM                            |       |
    	 * |                                 | aaaa    | a.m., p.m.                        | 2     |
    	 * |                                 | aaaaa   | a, p                              |       |
    	 * | AM, PM, noon, midnight          | b..bbb  | AM, PM, noon, midnight            |       |
    	 * |                                 | bbbb    | a.m., p.m., noon, midnight        | 2     |
    	 * |                                 | bbbbb   | a, p, n, mi                       |       |
    	 * | Flexible day period             | B..BBB  | at night, in the morning, ...     |       |
    	 * |                                 | BBBB    | at night, in the morning, ...     | 2     |
    	 * |                                 | BBBBB   | at night, in the morning, ...     |       |
    	 * | Hour [1-12]                     | h       | 1, 2, ..., 11, 12                 |       |
    	 * |                                 | ho      | 1st, 2nd, ..., 11th, 12th         | 7     |
    	 * |                                 | hh      | 01, 02, ..., 11, 12               |       |
    	 * | Hour [0-23]                     | H       | 0, 1, 2, ..., 23                  |       |
    	 * |                                 | Ho      | 0th, 1st, 2nd, ..., 23rd          | 7     |
    	 * |                                 | HH      | 00, 01, 02, ..., 23               |       |
    	 * | Hour [0-11]                     | K       | 1, 2, ..., 11, 0                  |       |
    	 * |                                 | Ko      | 1st, 2nd, ..., 11th, 0th          | 7     |
    	 * |                                 | KK      | 1, 2, ..., 11, 0                  |       |
    	 * | Hour [1-24]                     | k       | 24, 1, 2, ..., 23                 |       |
    	 * |                                 | ko      | 24th, 1st, 2nd, ..., 23rd         | 7     |
    	 * |                                 | kk      | 24, 01, 02, ..., 23               |       |
    	 * | Minute                          | m       | 0, 1, ..., 59                     |       |
    	 * |                                 | mo      | 0th, 1st, ..., 59th               | 7     |
    	 * |                                 | mm      | 00, 01, ..., 59                   |       |
    	 * | Second                          | s       | 0, 1, ..., 59                     |       |
    	 * |                                 | so      | 0th, 1st, ..., 59th               | 7     |
    	 * |                                 | ss      | 00, 01, ..., 59                   |       |
    	 * | Fraction of second              | S       | 0, 1, ..., 9                      |       |
    	 * |                                 | SS      | 00, 01, ..., 99                   |       |
    	 * |                                 | SSS     | 000, 0001, ..., 999               |       |
    	 * |                                 | SSSS    | ...                               | 3     |
    	 * | Timezone (ISO-8601 w/ Z)        | X       | -08, +0530, Z                     |       |
    	 * |                                 | XX      | -0800, +0530, Z                   |       |
    	 * |                                 | XXX     | -08:00, +05:30, Z                 |       |
    	 * |                                 | XXXX    | -0800, +0530, Z, +123456          | 2     |
    	 * |                                 | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
    	 * | Timezone (ISO-8601 w/o Z)       | x       | -08, +0530, +00                   |       |
    	 * |                                 | xx      | -0800, +0530, +0000               |       |
    	 * |                                 | xxx     | -08:00, +05:30, +00:00            | 2     |
    	 * |                                 | xxxx    | -0800, +0530, +0000, +123456      |       |
    	 * |                                 | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
    	 * | Timezone (GMT)                  | O...OOO | GMT-8, GMT+5:30, GMT+0            |       |
    	 * |                                 | OOOO    | GMT-08:00, GMT+05:30, GMT+00:00   | 2     |
    	 * | Timezone (specific non-locat.)  | z...zzz | PDT, EST, CEST                    | 6     |
    	 * |                                 | zzzz    | Pacific Daylight Time             | 2,6   |
    	 * | Seconds timestamp               | t       | 512969520                         | 7     |
    	 * |                                 | tt      | ...                               | 3,7   |
    	 * | Milliseconds timestamp          | T       | 512969520900                      | 7     |
    	 * |                                 | TT      | ...                               | 3,7   |
    	 * | Long localized date             | P       | 05/29/1453                        | 7     |
    	 * |                                 | PP      | May 29, 1453                      | 7     |
    	 * |                                 | PPP     | May 29th, 1453                    | 7     |
    	 * |                                 | PPPP    | Sunday, May 29th, 1453            | 2,7   |
    	 * | Long localized time             | p       | 12:00 AM                          | 7     |
    	 * |                                 | pp      | 12:00:00 AM                       | 7     |
    	 * |                                 | ppp     | 12:00:00 AM GMT+2                 | 7     |
    	 * |                                 | pppp    | 12:00:00 AM GMT+02:00             | 2,7   |
    	 * | Combination of date and time    | Pp      | 05/29/1453, 12:00 AM              | 7     |
    	 * |                                 | PPpp    | May 29, 1453, 12:00:00 AM         | 7     |
    	 * |                                 | PPPppp  | May 29th, 1453 at ...             | 7     |
    	 * |                                 | PPPPpppp| Sunday, May 29th, 1453 at ...     | 2,7   |
    	 * Notes:
    	 * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
    	 *    are the same as "stand-alone" units, but are different in some languages.
    	 *    "Formatting" units are declined according to the rules of the language
    	 *    in the context of a date. "Stand-alone" units are always nominative singular:
    	 *
    	 *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
    	 *
    	 *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
    	 *
    	 * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
    	 *    the single quote characters (see below).
    	 *    If the sequence is longer than listed in table (e.g. `EEEEEEEEEEE`)
    	 *    the output will be the same as default pattern for this unit, usually
    	 *    the longest one (in case of ISO weekdays, `EEEE`). Default patterns for units
    	 *    are marked with "2" in the last column of the table.
    	 *
    	 *    `format(new Date(2017, 10, 6), 'MMM') //=> 'Nov'`
    	 *
    	 *    `format(new Date(2017, 10, 6), 'MMMM') //=> 'November'`
    	 *
    	 *    `format(new Date(2017, 10, 6), 'MMMMM') //=> 'N'`
    	 *
    	 *    `format(new Date(2017, 10, 6), 'MMMMMM') //=> 'November'`
    	 *
    	 *    `format(new Date(2017, 10, 6), 'MMMMMMM') //=> 'November'`
    	 *
    	 * 3. Some patterns could be unlimited length (such as `yyyyyyyy`).
    	 *    The output will be padded with zeros to match the length of the pattern.
    	 *
    	 *    `format(new Date(2017, 10, 6), 'yyyyyyyy') //=> '00002017'`
    	 *
    	 * 4. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
    	 *    These tokens represent the shortest form of the quarter.
    	 *
    	 * 5. The main difference between `y` and `u` patterns are B.C. years:
    	 *
    	 *    | Year | `y` | `u` |
    	 *    |------|-----|-----|
    	 *    | AC 1 |   1 |   1 |
    	 *    | BC 1 |   1 |   0 |
    	 *    | BC 2 |   2 |  -1 |
    	 *
    	 *    Also `yy` always returns the last two digits of a year,
    	 *    while `uu` pads single digit years to 2 characters and returns other years unchanged:
    	 *
    	 *    | Year | `yy` | `uu` |
    	 *    |------|------|------|
    	 *    | 1    |   01 |   01 |
    	 *    | 14   |   14 |   14 |
    	 *    | 376  |   76 |  376 |
    	 *    | 1453 |   53 | 1453 |
    	 *
    	 *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
    	 *    except local week-numbering years are dependent on `options.weekStartsOn`
    	 *    and `options.firstWeekContainsDate` (compare [getISOWeekYear]{@link https://date-fns.org/docs/getISOWeekYear}
    	 *    and [getWeekYear]{@link https://date-fns.org/docs/getWeekYear}).
    	 *
    	 * 6. Specific non-location timezones are created using the Intl browser API. The output is determined by the
    	 *    preferred standard of the current locale (en-US by default) which may not always give the expected result.
    	 *    For this reason it is recommended to supply a `locale` in the format options when formatting a time zone name.
    	 *
    	 * 7. These patterns are not in the Unicode Technical Standard #35:
    	 *    - `i`: ISO day of week
    	 *    - `I`: ISO week of year
    	 *    - `R`: ISO week-numbering year
    	 *    - `t`: seconds timestamp
    	 *    - `T`: milliseconds timestamp
    	 *    - `o`: ordinal number modifier
    	 *    - `P`: long localized date
    	 *    - `p`: long localized time
    	 *
    	 * 8. These tokens are often confused with others. See: https://git.io/fxCyr
    	 *
    	 *
    	 * ### v2.0.0 breaking changes:
    	 *
    	 * - [Changes that are common for the whole
    	 *   library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
    	 *
    	 * - The second argument is now required for the sake of explicitness.
    	 *
    	 *   ```javascript
    	 *   // Before v2.0.0
    	 *   format(new Date(2016, 0, 1))
    	 *
    	 *   // v2.0.0 onward
    	 *   format(new Date(2016, 0, 1), "yyyy-MM-dd'T'HH:mm:ss.SSSxxx")
    	 *   ```
    	 *
    	 * - New format string API for `format` function
    	 *   which is based on [Unicode Technical Standard
    	 *   #35](https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table). See [this
    	 *   post](https://blog.date-fns.org/post/unicode-tokens-in-date-fns-v2-sreatyki91jg) for more details.
    	 *
    	 * - Characters are now escaped using single quote symbols (`'`) instead of square brackets.
    	 *
    	 * @param {Date|String|Number} date - the original date
    	 * @param {String} format - the string of tokens
    	 * @param {OptionsWithTZ} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}
    	 * @param {0|1|2} [options.additionalDigits=2] - passed to `toDate`. See [toDate]{@link
    	 *   https://date-fns.org/docs/toDate}
    	 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
    	 * @param {Number} [options.firstWeekContainsDate=1] - the day of January, which is
    	 * @param {Locale} [options.locale=defaultLocale] - the locale object. See
    	 *   [Locale]{@link https://date-fns.org/docs/Locale}
    	 * @param {Boolean} [options.awareOfUnicodeTokens=false] - if true, allows usage of Unicode tokens causes confusion:
    	 *   - Some of the day of year tokens (`D`, `DD`) that are confused with the day of month tokens (`d`, `dd`).
    	 *   - Some of the local week-numbering year tokens (`YY`, `YYYY`) that are confused with the calendar year tokens
    	 *   (`yy`, `yyyy`). See: https://git.io/fxCyr
    	 * @param {String} [options.timeZone=''] - used to specify the IANA time zone offset of a date String.
    	 * @returns {String} the formatted date string
    	 * @throws {TypeError} 2 arguments required
    	 * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
    	 * @throws {RangeError} `options.locale` must contain `localize` property
    	 * @throws {RangeError} `options.locale` must contain `formatLong` property
    	 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
    	 * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
    	 * @throws {RangeError} `options.awareOfUnicodeTokens` must be set to `true` to use `XX` token; see:
    	 *   https://git.io/fxCyr
    	 *
    	 * @example
    	 * // Represent 11 February 2014 in middle-endian format:
    	 * var result = format(new Date(2014, 1, 11), 'MM/dd/yyyy')
    	 * //=> '02/11/2014'
    	 *
    	 * @example
    	 * // Represent 2 July 2014 in Esperanto:
    	 * import { eoLocale } from 'date-fns/locale/eo'
    	 * var result = format(new Date(2014, 6, 2), "do 'de' MMMM yyyy", {
    	 *   locale: eoLocale
    	 * })
    	 * //=> '2-a de julio 2014'
    	 *
    	 * @example
    	 * // Escape string by single quote characters:
    	 * var result = format(new Date(2014, 6, 2, 15), "h 'o''clock'")
    	 * //=> "3 o'clock"
    	 */

    	function format(dirtyDate, dirtyFormatStr, dirtyOptions) {
    	  var formatStr = String(dirtyFormatStr);
    	  var options = dirtyOptions || {};
    	  var matches = formatStr.match(tzFormattingTokensRegExp);

    	  if (matches) {
    	    var date = (0, _index3.default)(dirtyDate, options); // Work through each match and replace the tz token in the format string with the quoted
    	    // formatted time zone so the remaining tokens can be filled in by date-fns#format.

    	    formatStr = matches.reduce(function (result, token) {
    	      if (token[0] === "'") {
    	        return result; // This is a quoted portion, matched only to ensure we don't match inside it
    	      }

    	      var pos = result.indexOf(token);
    	      var precededByQuotedSection = result[pos - 1] === "'";
    	      var replaced = result.replace(token, "'" + _index2.default[token[0]](date, token, null, options) + "'"); // If the replacement results in two adjoining quoted strings, the back to back quotes
    	      // are removed, so it doesn't look like an escaped quote.

    	      return precededByQuotedSection ? replaced.substring(0, pos - 1) + replaced.substring(pos + 1) : replaced;
    	    }, formatStr);
    	  }

    	  return (0, _index.default)(dirtyDate, formatStr, options);
    	}

    	module.exports = exports.default;
    } (format$3, format$3.exports));

    var utcToZonedTime = {exports: {}};

    (function (module, exports) {

    	Object.defineProperty(exports, "__esModule", {
    	  value: true
    	});
    	exports.default = utcToZonedTime;

    	var _index = _interopRequireDefault(tzParseTimezone.exports);

    	var _index2 = _interopRequireDefault(toDate.exports);

    	function _interopRequireDefault(obj) {
    	  return obj && obj.__esModule ? obj : {
    	    default: obj
    	  };
    	}
    	/**
    	 * @name utcToZonedTime
    	 * @category Time Zone Helpers
    	 * @summary Get a date/time representing local time in a given time zone from the UTC date
    	 *
    	 * @description
    	 * Returns a date instance with values representing the local time in the time zone
    	 * specified of the UTC time from the date provided. In other words, when the new date
    	 * is formatted it will show the equivalent hours in the target time zone regardless
    	 * of the current system time zone.
    	 *
    	 * @param {Date|String|Number} date - the date with the relevant UTC time
    	 * @param {String} timeZone - the time zone to get local time for, can be an offset or IANA time zone
    	 * @param {OptionsWithTZ} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}
    	 * @param {0|1|2} [options.additionalDigits=2] - passed to `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
    	 * @returns {Date} the new date with the equivalent time in the time zone
    	 * @throws {TypeError} 2 arguments required
    	 * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
    	 *
    	 * @example
    	 * // In June 10am UTC is 6am in New York (-04:00)
    	 * const result = utcToZonedTime('2014-06-25T10:00:00.000Z', 'America/New_York')
    	 * //=> Jun 25 2014 06:00:00
    	 */


    	function utcToZonedTime(dirtyDate, timeZone, options) {
    	  var date = (0, _index2.default)(dirtyDate, options);
    	  var offsetMilliseconds = (0, _index.default)(timeZone, date, true);
    	  var d = new Date(date.getTime() - offsetMilliseconds);
    	  var resultDate = new Date(0);
    	  resultDate.setFullYear(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate());
    	  resultDate.setHours(d.getUTCHours(), d.getUTCMinutes(), d.getUTCSeconds(), d.getUTCMilliseconds());
    	  return resultDate;
    	}

    	module.exports = exports.default;
    } (utcToZonedTime, utcToZonedTime.exports));

    (function (module, exports) {

    	Object.defineProperty(exports, "__esModule", {
    	  value: true
    	});
    	exports.default = formatInTimeZone;

    	var _index = _interopRequireDefault(cloneObject.exports);

    	var _index2 = _interopRequireDefault(format$3.exports);

    	var _index3 = _interopRequireDefault(utcToZonedTime.exports);

    	function _interopRequireDefault(obj) {
    	  return obj && obj.__esModule ? obj : {
    	    default: obj
    	  };
    	}
    	/**
    	 * @name formatInTimeZone
    	 * @category Time Zone Helpers
    	 * @summary Gets the offset in milliseconds between the time zone and Universal Coordinated Time (UTC)
    	 *
    	 * @param {Date|String|Number} date - the date representing the local time / real UTC time
    	 * @param {String} timeZone - the time zone this date should be formatted for; can be an offset or IANA time zone
    	 * @param {String} formatStr - the string of tokens
    	 * @param {OptionsWithTZ} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}
    	 * @param {0|1|2} [options.additionalDigits=2] - passed to `toDate`. See [toDate]{@link
    	 *   https://date-fns.org/docs/toDate}
    	 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
    	 * @param {Number} [options.firstWeekContainsDate=1] - the day of January, which is
    	 * @param {Locale} [options.locale=defaultLocale] - the locale object. See
    	 *   [Locale]{@link https://date-fns.org/docs/Locale}
    	 * @param {Boolean} [options.awareOfUnicodeTokens=false] - if true, allows usage of Unicode tokens causes confusion:
    	 *   - Some of the day of year tokens (`D`, `DD`) that are confused with the day of month tokens (`d`, `dd`).
    	 *   - Some of the local week-numbering year tokens (`YY`, `YYYY`) that are confused with the calendar year tokens
    	 *   (`yy`, `yyyy`). See: https://git.io/fxCyr
    	 * @param {String} [options.timeZone=''] - used to specify the IANA time zone offset of a date String.
    	 * @returns {String} the formatted date string
    	 */


    	function formatInTimeZone(date, timeZone, formatStr, options) {
    	  var extendedOptions = (0, _index.default)(options);
    	  extendedOptions.timeZone = timeZone;
    	  return (0, _index2.default)((0, _index3.default)(date, timeZone), formatStr, extendedOptions);
    	}

    	module.exports = exports.default;
    } (formatInTimeZone$1, formatInTimeZone$1.exports));

    var formatInTimeZone = /*@__PURE__*/getDefaultExportFromCjs(formatInTimeZone$1.exports);

    const time = {
      amHours: ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11"],
      pmHours: ["12", "01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11"],
      hours: ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23"],
      minutes: ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59"],
      seconds: ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59"],
      period: ["AM", "PM"]
    };
    function getFixValue(value) {
      return `00${value}`.slice(-2);
    }
    function getTimeUnits(defaultValue, stepOrList, isHourWithAmPm) {
      if (Array.isArray(stepOrList)) {
        return (isHourWithAmPm === "am" ? stepOrList.filter(v => v < 12) : isHourWithAmPm === "pm" ? stepOrList.filter(v => v >= 12).map(v => v === 12 ? 12 : v - 12) : stepOrList).map(v => getFixValue(v));
      } else if (typeof stepOrList === "number") {
        if (isHourWithAmPm === "am") {
          return defaultValue.filter(hour => {
            const hourAsNumber = Number(hour);
            return hourAsNumber < 12 && hourAsNumber % stepOrList === 0;
          });
        } else if (isHourWithAmPm === "pm") {
          return defaultValue.filter(hour => {
            const hourAsNumber = Number(hour);
            return hourAsNumber >= 12 && hourAsNumber % stepOrList === 0;
          }).map(hour => {
            const hourAsNumber = Number(hour);
            return getFixValue(hourAsNumber === 12 ? 12 : hourAsNumber - 12);
          });
        }

        return defaultValue.filter(hour => {
          return Number(hour) % stepOrList === 0;
        });
      } else {
        return isHourWithAmPm === "am" ? defaultValue.filter(hour => Number(hour) < 12) : isHourWithAmPm === "pm" ? defaultValue.map(hour => Number(hour)).filter(hour => Number(hour) >= 12).map(v => getFixValue(v === 12 ? 12 : v - 12)) : defaultValue;
      }
    }
    function isTimeInStep(value, type, stepOrList) {
      if (!stepOrList) {
        return true;
      } else if (typeof stepOrList === "number") {
        return value % stepOrList === 0;
      } else {
        return stepOrList.includes(value);
      }
    }
    function findSimilarTime(value, type, stepOrList) {
      const list = getTimeUnits(time[type], stepOrList).map(Number);
      let lowerBound, upperBound;

      for (let i = 0; i < list.length; ++i) {
        const v = list[i];
        if (v === value) return v;else if (v > value) {
          upperBound = v;
          break;
        }
        lowerBound = v;
      }

      if (lowerBound === void 0) {
        if (!upperBound) {
          throwError("time-picker", "Please set 'hours' or 'minutes' or 'seconds' props");
        }

        return upperBound;
      }

      if (upperBound === void 0) {
        return lowerBound;
      }

      return upperBound - value > value - lowerBound ? lowerBound : upperBound;
    }
    function getAmPm(value) {
      return getHours(value) < 12 ? "am" : "pm";
    }

    const timePickerInjectionKey = createInjectionKey("n-time-picker");

    var PanelCol = vue.defineComponent({
      name: "TimePickerPanelCol",
      props: {
        clsPrefix: {
          type: String,
          required: true
        },
        data: {
          type: Array,
          required: true
        },
        activeValue: {
          type: Number,
          default: null
        },
        onItemClick: Function
      },
      render() {
        const { activeValue, onItemClick, clsPrefix } = this;
        return this.data.map((item) => {
          const { label, disabled, value } = item;
          const active = activeValue === value;
          return /* @__PURE__ */ vue.h("div", {
            key: label,
            "data-active": active ? "" : null,
            class: [
              `${clsPrefix}-time-picker-col__item`,
              active && `${clsPrefix}-time-picker-col__item--active`,
              disabled && `${clsPrefix}-time-picker-col__item--disabled`
            ],
            onClick: onItemClick && !disabled ? () => onItemClick(value) : void 0
          }, label);
        });
      }
    });

    const timePickerPanelProps = {
      actions: {
        type: Array,
        default: () => ["now", "confirm"]
      },
      showHour: {
        type: Boolean,
        default: true
      },
      showMinute: {
        type: Boolean,
        default: true
      },
      showSecond: {
        type: Boolean,
        default: true
      },
      showPeriod: {
        type: Boolean,
        default: true
      },
      isHourInvalid: Boolean,
      isMinuteInvalid: Boolean,
      isSecondInvalid: Boolean,
      isAmPmInvalid: Boolean,
      isValueInvalid: Boolean,
      hourValue: {
        type: Number,
        default: null
      },
      minuteValue: {
        type: Number,
        default: null
      },
      secondValue: {
        type: Number,
        default: null
      },
      amPmValue: {
        type: String,
        default: null
      },
      isHourDisabled: Function,
      isMinuteDisabled: Function,
      isSecondDisabled: Function,
      onHourClick: {
        type: Function,
        required: true
      },
      onMinuteClick: {
        type: Function,
        required: true
      },
      onSecondClick: {
        type: Function,
        required: true
      },
      onAmPmClick: {
        type: Function,
        required: true
      },
      onNowClick: Function,
      nowText: String,
      confirmText: String,
      transitionDisabled: Boolean,
      onConfirmClick: Function,
      onFocusin: Function,
      onFocusout: Function,
      onFocusDetectorFocus: Function,
      onKeydown: Function,
      hours: [Number, Array],
      minutes: [Number, Array],
      seconds: [Number, Array],
      use12Hours: Boolean
    };
    var Panel = vue.defineComponent({
      name: "TimePickerPanel",
      props: timePickerPanelProps,
      setup(props) {
        const {
          mergedThemeRef,
          mergedClsPrefixRef
        } = vue.inject(timePickerInjectionKey);
        const hoursRef = vue.computed(() => {
          const { isHourDisabled, hours, use12Hours, amPmValue } = props;
          if (!use12Hours) {
            return getTimeUnits(time.hours, hours).map((hour) => {
              return {
                label: hour,
                value: Number(hour),
                disabled: isHourDisabled ? isHourDisabled(Number(hour)) : false
              };
            });
          } else {
            const mergedAmPmValue = amPmValue ?? getAmPm(Date.now());
            return getTimeUnits(time.hours, hours, mergedAmPmValue).map((hour) => {
              const hourAs12FormattedNumber = Number(hour);
              const hourAs24FormattedNumber = mergedAmPmValue === "pm" && hourAs12FormattedNumber !== 12 ? hourAs12FormattedNumber + 12 : hourAs12FormattedNumber;
              return {
                label: hour,
                value: hourAs24FormattedNumber,
                disabled: isHourDisabled ? isHourDisabled(hourAs24FormattedNumber) : false
              };
            });
          }
        });
        const minutesRef = vue.computed(() => {
          const { isMinuteDisabled, minutes } = props;
          return getTimeUnits(time.minutes, minutes).map((minute) => {
            return {
              label: minute,
              value: Number(minute),
              disabled: isMinuteDisabled ? isMinuteDisabled(Number(minute), props.hourValue) : false
            };
          });
        });
        const secondsRef = vue.computed(() => {
          const { isSecondDisabled, seconds } = props;
          return getTimeUnits(time.seconds, seconds).map((second) => {
            return {
              label: second,
              value: Number(second),
              disabled: isSecondDisabled ? isSecondDisabled(
                Number(second),
                props.minuteValue,
                props.hourValue
              ) : false
            };
          });
        });
        const amPmRef = vue.computed(() => {
          const { isHourDisabled } = props;
          let amDisabled = true;
          let pmDisabled = true;
          for (let i = 0; i < 12; ++i) {
            if (!isHourDisabled?.(i)) {
              amDisabled = false;
              break;
            }
          }
          for (let i = 12; i < 24; ++i) {
            if (!isHourDisabled?.(i)) {
              pmDisabled = false;
              break;
            }
          }
          return [
            {
              label: "AM",
              value: "am",
              disabled: amDisabled
            },
            {
              label: "PM",
              value: "pm",
              disabled: pmDisabled
            }
          ];
        });
        return {
          mergedTheme: mergedThemeRef,
          mergedClsPrefix: mergedClsPrefixRef,
          hours: hoursRef,
          minutes: minutesRef,
          seconds: secondsRef,
          amPm: amPmRef,
          hourScrollRef: vue.ref(null),
          minuteScrollRef: vue.ref(null),
          secondScrollRef: vue.ref(null),
          amPmScrollRef: vue.ref(null)
        };
      },
      render() {
        const { mergedClsPrefix, mergedTheme } = this;
        return /* @__PURE__ */ vue.h("div", {
          tabindex: 0,
          class: `${mergedClsPrefix}-time-picker-panel`,
          onFocusin: this.onFocusin,
          onFocusout: this.onFocusout,
          onKeydown: this.onKeydown
        }, /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-time-picker-cols`
        }, this.showHour ? /* @__PURE__ */ vue.h("div", {
          class: [
            `${mergedClsPrefix}-time-picker-col`,
            this.isHourInvalid && `${mergedClsPrefix}-time-picker-col--invalid`,
            this.transitionDisabled && `${mergedClsPrefix}-time-picker-col--transition-disabled`
          ]
        }, /* @__PURE__ */ vue.h(NScrollbar, {
          ref: "hourScrollRef",
          theme: mergedTheme.peers.Scrollbar,
          themeOverrides: mergedTheme.peerOverrides.Scrollbar
        }, {
          default: () => [
            /* @__PURE__ */ vue.h(PanelCol, {
              clsPrefix: mergedClsPrefix,
              data: this.hours,
              activeValue: this.hourValue,
              onItemClick: this.onHourClick
            }),
            /* @__PURE__ */ vue.h("div", {
              class: `${mergedClsPrefix}-time-picker-col__padding`
            })
          ]
        })) : null, this.showMinute ? /* @__PURE__ */ vue.h("div", {
          class: [
            `${mergedClsPrefix}-time-picker-col`,
            this.transitionDisabled && `${mergedClsPrefix}-time-picker-col--transition-disabled`,
            this.isMinuteInvalid && `${mergedClsPrefix}-time-picker-col--invalid`
          ]
        }, /* @__PURE__ */ vue.h(NScrollbar, {
          ref: "minuteScrollRef",
          theme: mergedTheme.peers.Scrollbar,
          themeOverrides: mergedTheme.peerOverrides.Scrollbar
        }, {
          default: () => [
            /* @__PURE__ */ vue.h(PanelCol, {
              clsPrefix: mergedClsPrefix,
              data: this.minutes,
              activeValue: this.minuteValue,
              onItemClick: this.onMinuteClick
            }),
            /* @__PURE__ */ vue.h("div", {
              class: `${mergedClsPrefix}-time-picker-col__padding`
            })
          ]
        })) : null, this.showSecond ? /* @__PURE__ */ vue.h("div", {
          class: [
            `${mergedClsPrefix}-time-picker-col`,
            this.isSecondInvalid && `${mergedClsPrefix}-time-picker-col--invalid`,
            this.transitionDisabled && `${mergedClsPrefix}-time-picker-col--transition-disabled`
          ]
        }, /* @__PURE__ */ vue.h(NScrollbar, {
          ref: "secondScrollRef",
          theme: mergedTheme.peers.Scrollbar,
          themeOverrides: mergedTheme.peerOverrides.Scrollbar
        }, {
          default: () => [
            /* @__PURE__ */ vue.h(PanelCol, {
              clsPrefix: mergedClsPrefix,
              data: this.seconds,
              activeValue: this.secondValue,
              onItemClick: this.onSecondClick
            }),
            /* @__PURE__ */ vue.h("div", {
              class: `${mergedClsPrefix}-time-picker-col__padding`
            })
          ]
        })) : null, this.use12Hours ? /* @__PURE__ */ vue.h("div", {
          class: [
            `${mergedClsPrefix}-time-picker-col`,
            this.isAmPmInvalid && `${mergedClsPrefix}-time-picker-col--invalid`,
            this.transitionDisabled && `${mergedClsPrefix}-time-picker-col--transition-disabled`
          ]
        }, /* @__PURE__ */ vue.h(NScrollbar, {
          ref: "amPmScrollRef",
          theme: mergedTheme.peers.Scrollbar,
          themeOverrides: mergedTheme.peerOverrides.Scrollbar
        }, {
          default: () => [
            /* @__PURE__ */ vue.h(PanelCol, {
              clsPrefix: mergedClsPrefix,
              data: this.amPm,
              activeValue: this.amPmValue,
              onItemClick: this.onAmPmClick
            }),
            /* @__PURE__ */ vue.h("div", {
              class: `${mergedClsPrefix}-time-picker-col__padding`
            })
          ]
        })) : null), this.actions?.length ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-time-picker-actions`
        }, this.actions?.includes("now") ? /* @__PURE__ */ vue.h(NButton, {
          size: "tiny",
          theme: mergedTheme.peers.Button,
          themeOverrides: mergedTheme.peerOverrides.Button,
          onClick: this.onNowClick
        }, { default: () => this.nowText }) : null, this.actions?.includes("confirm") ? /* @__PURE__ */ vue.h(NButton, {
          size: "tiny",
          type: "primary",
          class: `${mergedClsPrefix}-time-picker-actions__confirm`,
          theme: mergedTheme.peers.Button,
          themeOverrides: mergedTheme.peerOverrides.Button,
          disabled: this.isValueInvalid,
          onClick: this.onConfirmClick
        }, { default: () => this.confirmText }) : null) : null, /* @__PURE__ */ vue.h(FocusDetector, {
          onFocus: this.onFocusDetectorFocus
        }));
      }
    });

    var style$S = c$1([cB("time-picker", `
    z-index: auto;
    position: relative;
  `, [cB("time-picker-icon", `
      color: var(--n-icon-color-override);
      transition: color .3s var(--n-bezier);
    `), cM("disabled", [cB("time-picker-icon", `
        color: var(--n-icon-color-disabled-override);
      `)])]), cB("time-picker-panel", `
    transition:
      box-shadow .3s var(--n-bezier),
      background-color .3s var(--n-bezier);
    outline: none;
    font-size: var(--n-item-font-size);
    border-radius: var(--n-border-radius);
    margin: 4px 0;
    min-width: 104px;
    overflow: hidden;
    background-color: var(--n-panel-color);
    box-shadow: var(--n-panel-box-shadow);
  `, [fadeInScaleUpTransition(), cB("time-picker-actions", `
      padding: var(--n-panel-action-padding);
      align-items: center;
      display: flex;
      justify-content: space-evenly;
    `), cB("time-picker-cols", `
      height: calc(var(--n-item-height) * 6);
      display: flex;
      position: relative;
      transition: border-color .3s var(--n-bezier);
      border-bottom: 1px solid var(--n-panel-divider-color);
    `), cB("time-picker-col", `
      flex-grow: 1;
      min-width: var(--n-item-width);
      height: calc(var(--n-item-height) * 6);
      flex-direction: column;
      transition: box-shadow .3s var(--n-bezier);
    `, [cM("transition-disabled", [cE("item", "transition: none;", [c$1("&::before", "transition: none;")])]), cE("padding", `
        height: calc(var(--n-item-height) * 5);
      `), c$1("&:first-child", "min-width: calc(var(--n-item-width) + 4px);", [cE("item", [c$1("&::before", "left: 4px;")])]), cE("item", `
        cursor: pointer;
        height: var(--n-item-height);
        display: flex;
        align-items: center;
        justify-content: center;
        transition:
          color .3s var(--n-bezier),
          background-color .3s var(--n-bezier),
          opacity .3s var(--n-bezier),
          text-decoration-color .3s var(--n-bezier);
        background: #0000;
        text-decoration-color: #0000;
        color: var(--n-item-text-color);
        z-index: 0;
        box-sizing: border-box;
        padding-top: 4px;
        position: relative;
      `, [c$1("&::before", `
          content: "";
          transition: background-color .3s var(--n-bezier);
          z-index: -1;
          position: absolute;
          left: 0;
          right: 4px;
          top: 4px;
          bottom: 0;
          border-radius: var(--n-item-border-radius);
        `), cNotM("disabled", [c$1("&:hover::before", `
            background-color: var(--n-item-color-hover);
          `)]), cM("active", `
          color: var(--n-item-text-color-active);
        `, [c$1("&::before", `
            background-color: var(--n-item-color-hover);
          `)]), cM("disabled", `
          opacity: var(--n-item-opacity-disabled);
          cursor: not-allowed;
        `)]), cM("invalid", [cE("item", [cM("active", `
            text-decoration: line-through;
            text-decoration-color: var(--n-item-text-color-active);
          `)])])])])]);

    function validateUnits(value, max) {
      if (value === void 0) {
        return true;
      }
      if (Array.isArray(value)) {
        return value.every((v) => v >= 0 && v <= max);
      } else {
        return value >= 0 && value <= max;
      }
    }
    const timePickerProps = {
      ...useTheme.props,
      to: useAdjustedTo.propTo,
      bordered: {
        type: Boolean,
        default: void 0
      },
      actions: Array,
      defaultValue: {
        type: Number,
        default: null
      },
      defaultFormattedValue: String,
      placeholder: String,
      placement: {
        type: String,
        default: "bottom-start"
      },
      value: Number,
      format: {
        type: String,
        default: "HH:mm:ss"
      },
      valueFormat: String,
      formattedValue: String,
      isHourDisabled: Function,
      size: String,
      isMinuteDisabled: Function,
      isSecondDisabled: Function,
      inputReadonly: Boolean,
      clearable: Boolean,
      status: String,
      "onUpdate:value": [Function, Array],
      onUpdateValue: [Function, Array],
      "onUpdate:show": [Function, Array],
      onUpdateShow: [Function, Array],
      onUpdateFormattedValue: [Function, Array],
      "onUpdate:formattedValue": [Function, Array],
      onBlur: [Function, Array],
      onConfirm: [Function, Array],
      onClear: Function,
      onFocus: [Function, Array],
      timeZone: String,
      showIcon: {
        type: Boolean,
        default: true
      },
      disabled: {
        type: Boolean,
        default: void 0
      },
      show: {
        type: Boolean,
        default: void 0
      },
      hours: {
        type: [Number, Array],
        validator: (value) => validateUnits(value, 23)
      },
      minutes: {
        type: [Number, Array],
        validator: (value) => validateUnits(value, 59)
      },
      seconds: {
        type: [Number, Array],
        validator: (value) => validateUnits(value, 59)
      },
      use12Hours: Boolean,
      stateful: {
        type: Boolean,
        default: true
      },
      onChange: [Function, Array]
    };
    var NTimePicker = vue.defineComponent({
      name: "TimePicker",
      props: timePickerProps,
      setup(props) {
        {
          vue.watchEffect(() => {
            if (props.onChange !== void 0) {
              warnOnce(
                "time-picker",
                "`on-change` is deprecated, please use `on-update:value` instead."
              );
            }
          });
        }
        const {
          mergedBorderedRef,
          mergedClsPrefixRef,
          namespaceRef,
          inlineThemeDisabled
        } = useConfig(props);
        const { localeRef, dateLocaleRef } = useLocale("TimePicker");
        const formItem = useFormItem(props);
        const { mergedSizeRef, mergedDisabledRef, mergedStatusRef } = formItem;
        const themeRef = useTheme(
          "TimePicker",
          "-time-picker",
          style$S,
          timePickerLight$1,
          props,
          mergedClsPrefixRef
        );
        const keyboardState = useKeyboard$1();
        const inputInstRef = vue.ref(null);
        const panelInstRef = vue.ref(null);
        const dateFnsOptionsRef = vue.computed(() => {
          return {
            locale: dateLocaleRef.value.locale
          };
        });
        function getTimestampFromFormattedValue(value) {
          if (value === null)
            return null;
          return strictParse(
            value,
            props.valueFormat || props.format,
            new Date(),
            dateFnsOptionsRef.value
          ).getTime();
        }
        const { defaultValue, defaultFormattedValue } = props;
        const uncontrolledValueRef = vue.ref(
          defaultFormattedValue !== void 0 ? getTimestampFromFormattedValue(defaultFormattedValue) : defaultValue
        );
        const mergedValueRef = vue.computed(() => {
          const { formattedValue } = props;
          if (formattedValue !== void 0) {
            return getTimestampFromFormattedValue(formattedValue);
          }
          const { value } = props;
          if (value !== void 0) {
            return value;
          }
          return uncontrolledValueRef.value;
        });
        const mergedFormatRef = vue.computed(() => {
          const { timeZone } = props;
          if (timeZone) {
            return (date, format2, options) => {
              return formatInTimeZone(date, timeZone, format2, options);
            };
          } else {
            return (date, _format, options) => {
              return format$4(date, _format, options);
            };
          }
        });
        const displayTimeStringRef = vue.ref("");
        vue.watch(
          () => props.timeZone,
          () => {
            const mergedValue = mergedValueRef.value;
            displayTimeStringRef.value = mergedValue === null ? "" : mergedFormatRef.value(
              mergedValue,
              props.format,
              dateFnsOptionsRef.value
            );
          },
          {
            immediate: true
          }
        );
        const uncontrolledShowRef = vue.ref(false);
        const controlledShowRef = vue.toRef(props, "show");
        const mergedShowRef = useMergedState(controlledShowRef, uncontrolledShowRef);
        const memorizedValueRef = vue.ref(mergedValueRef.value);
        const transitionDisabledRef = vue.ref(false);
        const localizedNowRef = vue.computed(() => {
          return localeRef.value.now;
        });
        const localizedPlaceholderRef = vue.computed(() => {
          if (props.placeholder !== void 0)
            return props.placeholder;
          return localeRef.value.placeholder;
        });
        const localizedNegativeTextRef = vue.computed(() => {
          return localeRef.value.negativeText;
        });
        const localizedPositiveTextRef = vue.computed(() => {
          return localeRef.value.positiveText;
        });
        const hourInFormatRef = vue.computed(() => {
          return /H|h|K|k/.test(props.format);
        });
        const minuteInFormatRef = vue.computed(() => {
          return props.format.includes("m");
        });
        const secondInFormatRef = vue.computed(() => {
          return props.format.includes("s");
        });
        const isHourInvalidRef = vue.computed(() => {
          const { isHourDisabled } = props;
          if (hourValueRef.value === null)
            return false;
          if (!isTimeInStep(hourValueRef.value, "hours", props.hours))
            return true;
          if (!isHourDisabled)
            return false;
          return isHourDisabled(hourValueRef.value);
        });
        const isMinuteInvalidRef = vue.computed(() => {
          const { value: minuteValue } = minuteValueRef;
          const { value: hourValue } = hourValueRef;
          if (minuteValue === null || hourValue === null)
            return false;
          if (!isTimeInStep(minuteValue, "minutes", props.minutes))
            return true;
          const { isMinuteDisabled } = props;
          if (!isMinuteDisabled)
            return false;
          return isMinuteDisabled(minuteValue, hourValue);
        });
        const isSecondInvalidRef = vue.computed(() => {
          const { value: minuteValue } = minuteValueRef;
          const { value: hourValue } = hourValueRef;
          const { value: secondValue } = secondValueRef;
          if (secondValue === null || minuteValue === null || hourValue === null) {
            return false;
          }
          if (!isTimeInStep(secondValue, "seconds", props.seconds))
            return true;
          const { isSecondDisabled } = props;
          if (!isSecondDisabled)
            return false;
          return isSecondDisabled(secondValue, minuteValue, hourValue);
        });
        const isValueInvalidRef = vue.computed(() => {
          return isHourInvalidRef.value || isMinuteInvalidRef.value || isSecondInvalidRef.value;
        });
        const mergedAttrSizeRef = vue.computed(() => {
          return props.format.length + 4;
        });
        const amPmValueRef = vue.computed(() => {
          const { value } = mergedValueRef;
          if (value === null)
            return null;
          return getHours(value) < 12 ? "am" : "pm";
        });
        const hourValueRef = vue.computed(() => {
          const { value } = mergedValueRef;
          if (value === null)
            return null;
          return Number(mergedFormatRef.value(value, "HH", dateFnsOptionsRef.value));
        });
        const minuteValueRef = vue.computed(() => {
          const { value } = mergedValueRef;
          if (value === null)
            return null;
          return Number(mergedFormatRef.value(value, "mm", dateFnsOptionsRef.value));
        });
        const secondValueRef = vue.computed(() => {
          const { value } = mergedValueRef;
          if (value === null)
            return null;
          return Number(mergedFormatRef.value(value, "ss", dateFnsOptionsRef.value));
        });
        function doUpdateFormattedValue(value, timestampValue) {
          const {
            onUpdateFormattedValue,
            "onUpdate:formattedValue": _onUpdateFormattedValue
          } = props;
          if (onUpdateFormattedValue) {
            call(
              onUpdateFormattedValue,
              value,
              timestampValue
            );
          }
          if (_onUpdateFormattedValue) {
            call(
              _onUpdateFormattedValue,
              value,
              timestampValue
            );
          }
        }
        function createFormattedValue(value) {
          return value === null ? null : mergedFormatRef.value(value, props.valueFormat || props.format);
        }
        function doUpdateValue(value) {
          const {
            onUpdateValue,
            "onUpdate:value": _onUpdateValue,
            onChange
          } = props;
          const { nTriggerFormChange, nTriggerFormInput } = formItem;
          const formattedValue = createFormattedValue(value);
          if (onUpdateValue) {
            call(onUpdateValue, value, formattedValue);
          }
          if (_onUpdateValue) {
            call(_onUpdateValue, value, formattedValue);
          }
          if (onChange)
            call(onChange, value, formattedValue);
          doUpdateFormattedValue(formattedValue, value);
          uncontrolledValueRef.value = value;
          nTriggerFormChange();
          nTriggerFormInput();
        }
        function doFocus(e) {
          const { onFocus } = props;
          const { nTriggerFormFocus } = formItem;
          if (onFocus)
            call(onFocus, e);
          nTriggerFormFocus();
        }
        function doBlur(e) {
          const { onBlur } = props;
          const { nTriggerFormBlur } = formItem;
          if (onBlur)
            call(onBlur, e);
          nTriggerFormBlur();
        }
        function doConfirm() {
          const { onConfirm } = props;
          if (onConfirm) {
            call(
              onConfirm,
              mergedValueRef.value,
              createFormattedValue(mergedValueRef.value)
            );
          }
        }
        function handleTimeInputClear(e) {
          e.stopPropagation();
          doUpdateValue(null);
          deriveInputValue(null);
          props.onClear?.();
        }
        function handleFocusDetectorFocus() {
          closePanel({
            returnFocus: true
          });
        }
        function handleInputKeydown(e) {
          if (e.key === "Escape" && mergedShowRef.value) {
            markEventEffectPerformed(e);
          }
        }
        function handleMenuKeydown(e) {
          switch (e.key) {
            case "Escape":
              if (mergedShowRef.value) {
                markEventEffectPerformed(e);
                closePanel({
                  returnFocus: true
                });
              }
              break;
            case "Tab":
              if (keyboardState.shift && e.target === panelInstRef.value?.$el) {
                e.preventDefault();
                closePanel({
                  returnFocus: true
                });
              }
              break;
          }
        }
        function disableTransitionOneTick() {
          transitionDisabledRef.value = true;
          void vue.nextTick(() => {
            transitionDisabledRef.value = false;
          });
        }
        function handleTriggerClick(e) {
          if (mergedDisabledRef.value || happensIn(e, "clear"))
            return;
          if (!mergedShowRef.value) {
            openPanel();
          }
        }
        function handleHourClick(hour) {
          if (typeof hour === "string")
            return;
          if (mergedValueRef.value === null) {
            doUpdateValue(getTime(setHours(startOfHour(new Date()), hour)));
          } else {
            doUpdateValue(getTime(setHours(mergedValueRef.value, hour)));
          }
        }
        function handleMinuteClick(minute) {
          if (typeof minute === "string")
            return;
          if (mergedValueRef.value === null) {
            doUpdateValue(getTime(setMinutes(startOfMinute(new Date()), minute)));
          } else {
            doUpdateValue(getTime(setMinutes(mergedValueRef.value, minute)));
          }
        }
        function handleSecondClick(second) {
          if (typeof second === "string")
            return;
          if (mergedValueRef.value === null) {
            doUpdateValue(getTime(setSeconds(startOfSecond(new Date()), second)));
          } else {
            doUpdateValue(getTime(setSeconds(mergedValueRef.value, second)));
          }
        }
        function handleAmPmClick(amPm) {
          const { value: mergedValue } = mergedValueRef;
          if (mergedValue === null) {
            const now = new Date();
            const hours = getHours(now);
            if (amPm === "pm" && hours < 12) {
              doUpdateValue(getTime(setHours(now, hours + 12)));
            } else if (amPm === "am" && hours >= 12) {
              doUpdateValue(getTime(setHours(now, hours - 12)));
            }
            doUpdateValue(getTime(now));
          } else {
            const hours = getHours(mergedValue);
            if (amPm === "pm" && hours < 12) {
              doUpdateValue(getTime(setHours(mergedValue, hours + 12)));
            } else if (amPm === "am" && hours >= 12) {
              doUpdateValue(getTime(setHours(mergedValue, hours - 12)));
            }
          }
        }
        function deriveInputValue(time) {
          if (time === void 0)
            time = mergedValueRef.value;
          if (time === null)
            displayTimeStringRef.value = "";
          else {
            displayTimeStringRef.value = mergedFormatRef.value(
              time,
              props.format,
              dateFnsOptionsRef.value
            );
          }
        }
        function handleTimeInputFocus(e) {
          if (isInternalFocusSwitch(e))
            return;
          doFocus(e);
        }
        function handleTimeInputBlur(e) {
          if (isInternalFocusSwitch(e))
            return;
          if (mergedShowRef.value) {
            const panelEl = panelInstRef.value?.$el;
            if (!panelEl?.contains(e.relatedTarget)) {
              deriveInputValue();
              doBlur(e);
              closePanel({
                returnFocus: false
              });
            }
          } else {
            deriveInputValue();
            doBlur(e);
          }
        }
        function handleTimeInputActivate() {
          if (mergedDisabledRef.value)
            return;
          if (!mergedShowRef.value) {
            openPanel();
          }
        }
        function handleTimeInputDeactivate() {
          if (mergedDisabledRef.value)
            return;
          deriveInputValue();
          closePanel({
            returnFocus: false
          });
        }
        function scrollTimer() {
          if (!panelInstRef.value)
            return;
          const { hourScrollRef, minuteScrollRef, secondScrollRef, amPmScrollRef } = panelInstRef.value;
          [hourScrollRef, minuteScrollRef, secondScrollRef, amPmScrollRef].forEach(
            (itemScrollRef) => {
              if (!itemScrollRef)
                return;
              const activeItemEl = itemScrollRef.contentRef?.querySelector("[data-active]");
              if (activeItemEl) {
                itemScrollRef.scrollTo({
                  top: activeItemEl.offsetTop
                });
              }
            }
          );
        }
        function doUpdateShow(value) {
          uncontrolledShowRef.value = value;
          const { onUpdateShow, "onUpdate:show": _onUpdateShow } = props;
          if (onUpdateShow)
            call(onUpdateShow, value);
          if (_onUpdateShow)
            call(_onUpdateShow, value);
        }
        function isInternalFocusSwitch(e) {
          return !!(inputInstRef.value?.wrapperElRef?.contains(e.relatedTarget) || panelInstRef.value?.$el.contains(e.relatedTarget));
        }
        function openPanel() {
          memorizedValueRef.value = mergedValueRef.value;
          doUpdateShow(true);
          void vue.nextTick(scrollTimer);
        }
        function handleClickOutside(e) {
          if (mergedShowRef.value && !inputInstRef.value?.wrapperElRef?.contains(
            getPreciseEventTarget(e)
          )) {
            closePanel({
              returnFocus: false
            });
          }
        }
        function closePanel({ returnFocus }) {
          if (mergedShowRef.value) {
            doUpdateShow(false);
            if (returnFocus) {
              inputInstRef.value?.focus();
            }
          }
        }
        function handleTimeInputUpdateValue(v) {
          if (v === "") {
            doUpdateValue(null);
            return;
          }
          const time = strictParse(
            v,
            props.format,
            new Date(),
            dateFnsOptionsRef.value
          );
          displayTimeStringRef.value = v;
          if (isValid$1(time)) {
            const { value: mergedValue } = mergedValueRef;
            if (mergedValue !== null) {
              const newTime = set(mergedValue, {
                hours: getHours(time),
                minutes: getMinutes(time),
                seconds: getSeconds(time)
              });
              doUpdateValue(getTime(newTime));
            } else {
              doUpdateValue(getTime(time));
            }
          }
        }
        function handleCancelClick() {
          doUpdateValue(memorizedValueRef.value);
          doUpdateShow(false);
        }
        function handleNowClick() {
          const now = new Date();
          const getNowTime = {
            hours: getHours,
            minutes: getMinutes,
            seconds: getSeconds
          };
          const [mergeHours, mergeMinutes, mergeSeconds] = ["hours", "minutes", "seconds"].map(
            (i) => !props[i] || isTimeInStep(getNowTime[i](now), i, props[i]) ? getNowTime[i](now) : findSimilarTime(getNowTime[i](now), i, props[i])
          );
          const newValue = setSeconds(
            setMinutes(
              setHours(
                mergedValueRef.value ? mergedValueRef.value : getTime(now),
                mergeHours
              ),
              mergeMinutes
            ),
            mergeSeconds
          );
          doUpdateValue(getTime(newValue));
        }
        function handleConfirmClick() {
          deriveInputValue();
          doConfirm();
          closePanel({
            returnFocus: true
          });
        }
        function handleMenuFocusOut(e) {
          if (isInternalFocusSwitch(e))
            return;
          deriveInputValue();
          doBlur(e);
          closePanel({
            returnFocus: false
          });
        }
        vue.watch(mergedValueRef, (value) => {
          deriveInputValue(value);
          disableTransitionOneTick();
          void vue.nextTick(scrollTimer);
        });
        vue.watch(mergedShowRef, () => {
          if (isValueInvalidRef.value) {
            doUpdateValue(memorizedValueRef.value);
          }
        });
        vue.provide(timePickerInjectionKey, {
          mergedThemeRef: themeRef,
          mergedClsPrefixRef
        });
        const exposedMethods = {
          focus: () => {
            inputInstRef.value?.focus();
          },
          blur: () => {
            inputInstRef.value?.blur();
          }
        };
        const triggerCssVarsRef = vue.computed(() => {
          const {
            common: { cubicBezierEaseInOut },
            self: { iconColor, iconColorDisabled }
          } = themeRef.value;
          return {
            "--n-icon-color-override": iconColor,
            "--n-icon-color-disabled-override": iconColorDisabled,
            "--n-bezier": cubicBezierEaseInOut
          };
        });
        const triggerThemeClassHandle = inlineThemeDisabled ? useThemeClass(
          "time-picker-trigger",
          void 0,
          triggerCssVarsRef,
          props
        ) : void 0;
        const cssVarsRef = vue.computed(() => {
          const {
            self: {
              panelColor,
              itemTextColor,
              itemTextColorActive,
              itemColorHover,
              panelDividerColor,
              panelBoxShadow,
              itemOpacityDisabled,
              borderRadius,
              itemFontSize,
              itemWidth,
              itemHeight,
              panelActionPadding,
              itemBorderRadius
            },
            common: { cubicBezierEaseInOut }
          } = themeRef.value;
          return {
            "--n-bezier": cubicBezierEaseInOut,
            "--n-border-radius": borderRadius,
            "--n-item-color-hover": itemColorHover,
            "--n-item-font-size": itemFontSize,
            "--n-item-height": itemHeight,
            "--n-item-opacity-disabled": itemOpacityDisabled,
            "--n-item-text-color": itemTextColor,
            "--n-item-text-color-active": itemTextColorActive,
            "--n-item-width": itemWidth,
            "--n-panel-action-padding": panelActionPadding,
            "--n-panel-box-shadow": panelBoxShadow,
            "--n-panel-color": panelColor,
            "--n-panel-divider-color": panelDividerColor,
            "--n-item-border-radius": itemBorderRadius
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("time-picker", void 0, cssVarsRef, props) : void 0;
        return {
          focus: exposedMethods.focus,
          blur: exposedMethods.blur,
          mergedStatus: mergedStatusRef,
          mergedBordered: mergedBorderedRef,
          mergedClsPrefix: mergedClsPrefixRef,
          namespace: namespaceRef,
          uncontrolledValue: uncontrolledValueRef,
          mergedValue: mergedValueRef,
          isMounted: isMounted(),
          inputInstRef,
          panelInstRef,
          adjustedTo: useAdjustedTo(props),
          mergedShow: mergedShowRef,
          localizedNow: localizedNowRef,
          localizedPlaceholder: localizedPlaceholderRef,
          localizedNegativeText: localizedNegativeTextRef,
          localizedPositiveText: localizedPositiveTextRef,
          hourInFormat: hourInFormatRef,
          minuteInFormat: minuteInFormatRef,
          secondInFormat: secondInFormatRef,
          mergedAttrSize: mergedAttrSizeRef,
          displayTimeString: displayTimeStringRef,
          mergedSize: mergedSizeRef,
          mergedDisabled: mergedDisabledRef,
          isValueInvalid: isValueInvalidRef,
          isHourInvalid: isHourInvalidRef,
          isMinuteInvalid: isMinuteInvalidRef,
          isSecondInvalid: isSecondInvalidRef,
          transitionDisabled: transitionDisabledRef,
          hourValue: hourValueRef,
          minuteValue: minuteValueRef,
          secondValue: secondValueRef,
          amPmValue: amPmValueRef,
          handleInputKeydown,
          handleTimeInputFocus,
          handleTimeInputBlur,
          handleNowClick,
          handleConfirmClick,
          handleTimeInputUpdateValue,
          handleMenuFocusOut,
          handleCancelClick,
          handleClickOutside,
          handleTimeInputActivate,
          handleTimeInputDeactivate,
          handleHourClick,
          handleMinuteClick,
          handleSecondClick,
          handleAmPmClick,
          handleTimeInputClear,
          handleFocusDetectorFocus,
          handleMenuKeydown,
          handleTriggerClick,
          mergedTheme: themeRef,
          triggerCssVars: inlineThemeDisabled ? void 0 : triggerCssVarsRef,
          triggerThemeClass: triggerThemeClassHandle?.themeClass,
          triggerOnRender: triggerThemeClassHandle?.onRender,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender
        };
      },
      render() {
        const { mergedClsPrefix, $slots, triggerOnRender } = this;
        triggerOnRender?.();
        return /* @__PURE__ */ vue.h("div", {
          class: [`${mergedClsPrefix}-time-picker`, this.triggerThemeClass],
          style: this.triggerCssVars
        }, /* @__PURE__ */ vue.h(VBinder, null, {
          default: () => [
            /* @__PURE__ */ vue.h(VTarget, null, {
              default: () => /* @__PURE__ */ vue.h(NInput, {
                ref: "inputInstRef",
                status: this.mergedStatus,
                value: this.displayTimeString,
                bordered: this.mergedBordered,
                passivelyActivated: true,
                attrSize: this.mergedAttrSize,
                theme: this.mergedTheme.peers.Input,
                themeOverrides: this.mergedTheme.peerOverrides.Input,
                stateful: this.stateful,
                size: this.mergedSize,
                placeholder: this.localizedPlaceholder,
                clearable: this.clearable,
                disabled: this.mergedDisabled,
                textDecoration: this.isValueInvalid ? "line-through" : void 0,
                onFocus: this.handleTimeInputFocus,
                onBlur: this.handleTimeInputBlur,
                onActivate: this.handleTimeInputActivate,
                onDeactivate: this.handleTimeInputDeactivate,
                onUpdateValue: this.handleTimeInputUpdateValue,
                onClear: this.handleTimeInputClear,
                internalDeactivateOnEnter: true,
                internalForceFocus: this.mergedShow,
                readonly: this.inputReadonly || this.mergedDisabled,
                onClick: this.handleTriggerClick,
                onKeydown: this.handleInputKeydown
              }, this.showIcon ? {
                [this.clearable ? "clear-icon-placeholder" : "suffix"]: () => /* @__PURE__ */ vue.h(NBaseIcon, {
                  clsPrefix: mergedClsPrefix,
                  class: `${mergedClsPrefix}-time-picker-icon`
                }, {
                  default: () => $slots.icon ? $slots.icon() : /* @__PURE__ */ vue.h(TimeIcon, null)
                })
              } : null)
            }),
            /* @__PURE__ */ vue.h(VFollower, {
              teleportDisabled: this.adjustedTo === useAdjustedTo.tdkey,
              show: this.mergedShow,
              to: this.adjustedTo,
              containerClass: this.namespace,
              placement: this.placement
            }, {
              default: () => /* @__PURE__ */ vue.h(vue.Transition, {
                name: "fade-in-scale-up-transition",
                appear: this.isMounted
              }, {
                default: () => {
                  if (this.mergedShow) {
                    this.onRender?.();
                    return vue.withDirectives(
                      /* @__PURE__ */ vue.h(Panel, {
                        ref: "panelInstRef",
                        actions: this.actions,
                        class: this.themeClass,
                        style: this.cssVars,
                        seconds: this.seconds,
                        minutes: this.minutes,
                        hours: this.hours,
                        transitionDisabled: this.transitionDisabled,
                        hourValue: this.hourValue,
                        showHour: this.hourInFormat,
                        isHourInvalid: this.isHourInvalid,
                        isHourDisabled: this.isHourDisabled,
                        minuteValue: this.minuteValue,
                        showMinute: this.minuteInFormat,
                        isMinuteInvalid: this.isMinuteInvalid,
                        isMinuteDisabled: this.isMinuteDisabled,
                        secondValue: this.secondValue,
                        amPmValue: this.amPmValue,
                        showSecond: this.secondInFormat,
                        isSecondInvalid: this.isSecondInvalid,
                        isSecondDisabled: this.isSecondDisabled,
                        isValueInvalid: this.isValueInvalid,
                        nowText: this.localizedNow,
                        confirmText: this.localizedPositiveText,
                        use12Hours: this.use12Hours,
                        onFocusout: this.handleMenuFocusOut,
                        onKeydown: this.handleMenuKeydown,
                        onHourClick: this.handleHourClick,
                        onMinuteClick: this.handleMinuteClick,
                        onSecondClick: this.handleSecondClick,
                        onAmPmClick: this.handleAmPmClick,
                        onNowClick: this.handleNowClick,
                        onConfirmClick: this.handleConfirmClick,
                        onFocusDetectorFocus: this.handleFocusDetectorFocus
                      }),
                      [
                        [
                          clickoutside$1,
                          this.handleClickOutside,
                          void 0,
                          { capture: true }
                        ]
                      ]
                    );
                  }
                  return null;
                }
              })
            })
          ]
        }));
      }
    });

    const TIME_FORMAT = "HH:mm:ss";
    const usePanelCommonProps = {
      active: Boolean,
      dateFormat: String,
      timeFormat: {
        type: String,
        value: TIME_FORMAT
      },
      value: {
        type: [Array, Number],
        default: null
      },
      shortcuts: Object,
      defaultTime: [Number, String, Array],
      onClear: Function,
      onConfirm: Function,
      onClose: Function,
      onTabOut: Function,
      onUpdateValue: {
        type: Function,
        required: true
      },
      themeClass: String,
      onRender: Function,
      panel: Boolean
    };

    function usePanelCommon(props) {
      const {
        dateLocaleRef,
        timePickerSizeRef,
        timePickerPropsRef,
        localeRef,
        mergedClsPrefixRef,
        mergedThemeRef
      } = vue.inject(datePickerInjectionKey);
      const dateFnsOptionsRef = vue.computed(() => {
        return {
          locale: dateLocaleRef.value.locale
        };
      });
      const selfRef = vue.ref(null);
      const keyboardState = useKeyboard$1();

      function doClear() {
        const {
          onClear
        } = props;
        if (onClear) onClear();
      }

      function doConfirm() {
        const {
          onConfirm,
          value
        } = props;
        if (onConfirm) onConfirm(value);
      }

      function doUpdateValue(value, doUpdate) {
        const {
          onUpdateValue
        } = props;
        onUpdateValue(value, doUpdate);
      }

      function doClose() {
        let disableUpdateOnClose = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        const {
          onClose
        } = props;
        if (onClose) onClose(disableUpdateOnClose);
      }

      function doTabOut() {
        const {
          onTabOut
        } = props;
        if (onTabOut) onTabOut();
      }

      function handleClearClick() {
        doUpdateValue(null, true);
        doClose(true);
        doClear();
      }

      function handleFocusDetectorFocus() {
        doTabOut();
      }

      function disableTransitionOneTick() {
        if (props.active || props.panel) {
          void vue.nextTick(() => {
            const {
              value: selfEl
            } = selfRef;
            if (!selfEl) return;
            const dateEls = selfEl.querySelectorAll("[data-n-date]");
            dateEls.forEach(el => {
              el.classList.add("transition-disabled");
            });
            void selfEl.offsetWidth;
            dateEls.forEach(el => {
              el.classList.remove("transition-disabled");
            });
          });
        }
      }

      function handlePanelKeyDown(e) {
        if (e.key === "Tab" && e.target === selfRef.value && keyboardState.shift) {
          e.preventDefault();
          doTabOut();
        }
      }

      function handlePanelFocus(e) {
        const {
          value: el
        } = selfRef;

        if (keyboardState.tab && e.target === el && el !== null && el !== void 0 && el.contains(e.relatedTarget)) {
          doTabOut();
        }
      }

      let cachedValue = null;
      let cached = false;

      function cachePendingValue() {
        cachedValue = props.value;
        cached = true;
      }

      function clearPendingValue() {
        cached = false;
      }

      function restorePendingValue() {
        if (cached) {
          doUpdateValue(cachedValue, false);
          cached = false;
        }
      }

      function getShortcutValue(shortcut) {
        if (typeof shortcut === "function") {
          return shortcut();
        }

        return shortcut;
      }

      const showMonthYearPanel = vue.ref(false);

      function handleOpenQuickSelectMonthPanel() {
        showMonthYearPanel.value = !showMonthYearPanel.value;
      }

      return {
        mergedTheme: mergedThemeRef,
        mergedClsPrefix: mergedClsPrefixRef,
        dateFnsOptions: dateFnsOptionsRef,
        timePickerSize: timePickerSizeRef,
        timePickerProps: timePickerPropsRef,
        selfRef,
        locale: localeRef,
        doConfirm,
        doClose,
        doUpdateValue,
        doTabOut,
        handleClearClick,
        handleFocusDetectorFocus,
        disableTransitionOneTick,
        handlePanelKeyDown,
        handlePanelFocus,
        cachePendingValue,
        clearPendingValue,
        restorePendingValue,
        getShortcutValue,
        handleShortcutMouseleave: restorePendingValue,
        showMonthYearPanel,
        handleOpenQuickSelectMonthPanel
      };
    }

    const useCalendarProps = { ...usePanelCommonProps,
      actions: {
        type: Array,
        default: () => ["now", "clear", "confirm"]
      }
    };

    function useCalendar(props, type) {
      const panelCommon = usePanelCommon(props);
      const {
        isValueInvalidRef,
        isDateDisabledRef,
        isDateInvalidRef,
        isTimeInvalidRef,
        isDateTimeInvalidRef,
        isHourDisabledRef,
        isMinuteDisabledRef,
        isSecondDisabledRef,
        localeRef,
        firstDayOfWeekRef,
        datePickerSlots
      } = vue.inject(datePickerInjectionKey);
      const validation = {
        isValueInvalid: isValueInvalidRef,
        isDateDisabled: isDateDisabledRef,
        isDateInvalid: isDateInvalidRef,
        isTimeInvalid: isTimeInvalidRef,
        isDateTimeInvalid: isDateTimeInvalidRef,
        isHourDisabled: isHourDisabledRef,
        isMinuteDisabled: isMinuteDisabledRef,
        isSecondDisabled: isSecondDisabledRef
      };
      const mergedDateFormatRef = vue.computed(() => props.dateFormat || localeRef.value.dateFormat);
      const dateInputValueRef = vue.ref(props.value === null || Array.isArray(props.value) ? "" : format$4(props.value, mergedDateFormatRef.value));
      const calendarValueRef = vue.ref(props.value === null || Array.isArray(props.value) ? Date.now() : props.value);
      const yearVlRef = vue.ref(null);
      const yearScrollbarRef = vue.ref(null);
      const monthScrollbarRef = vue.ref(null);
      const nowRef = vue.ref(Date.now());
      const dateArrayRef = vue.computed(() => {
        return dateArray(calendarValueRef.value, props.value, nowRef.value, firstDayOfWeekRef.value ?? localeRef.value.firstDayOfWeek);
      });
      const monthArrayRef = vue.computed(() => {
        const {
          value
        } = props;
        return monthArray(calendarValueRef.value, Array.isArray(value) ? null : value, nowRef.value);
      });
      const yearArrayRef = vue.computed(() => {
        const {
          value
        } = props;
        return yearArray(Array.isArray(value) ? null : value, nowRef.value);
      });
      const quarterArrayRef = vue.computed(() => {
        const {
          value
        } = props;
        return quarterArray(calendarValueRef.value, Array.isArray(value) ? null : value, nowRef.value);
      });
      const weekdaysRef = vue.computed(() => {
        return dateArrayRef.value.slice(0, 7).map(dateItem => {
          const {
            ts
          } = dateItem;
          return format$4(ts, localeRef.value.dayFormat, panelCommon.dateFnsOptions.value);
        });
      });
      const calendarMonthRef = vue.computed(() => {
        return format$4(calendarValueRef.value, localeRef.value.monthFormat, panelCommon.dateFnsOptions.value);
      });
      const calendarYearRef = vue.computed(() => {
        return format$4(calendarValueRef.value, localeRef.value.yearFormat, panelCommon.dateFnsOptions.value);
      });
      vue.watch(calendarValueRef, (value, oldValue) => {
        if (type === "date" || type === "datetime") {
          if (!isSameMonth(value, oldValue)) {
            panelCommon.disableTransitionOneTick();
          }
        }
      });
      vue.watch(vue.computed(() => props.value), value => {
        if (value !== null && !Array.isArray(value)) {
          dateInputValueRef.value = format$4(value, mergedDateFormatRef.value, panelCommon.dateFnsOptions.value);
          calendarValueRef.value = value;
        } else {
          dateInputValueRef.value = "";
        }
      });

      function sanitizeValue(value) {
        if (type === "datetime") return getTime(startOfSecond(value));
        if (type === "month") return getTime(startOfMonth(value));
        if (type === "year") return getTime(startOfYear(value));
        if (type === "quarter") return getTime(startOfQuarter(value));
        return getTime(startOfDay(value));
      }

      function mergedIsDateDisabled(ts) {
        const {
          isDateDisabled: {
            value: isDateDisabled
          }
        } = validation;
        if (!isDateDisabled) return false;
        return isDateDisabled(ts);
      }

      function handleDateInput(value) {
        const date = strictParse(value, mergedDateFormatRef.value, new Date(), panelCommon.dateFnsOptions.value);

        if (isValid$1(date)) {
          if (props.value === null) {
            panelCommon.doUpdateValue(getTime(sanitizeValue(Date.now())), props.panel);
          } else if (!Array.isArray(props.value)) {
            const newDateTime = set(props.value, {
              year: getYear(date),
              month: getMonth(date),
              date: getDate(date)
            });
            panelCommon.doUpdateValue(getTime(sanitizeValue(getTime(newDateTime))), props.panel);
          }
        } else {
          dateInputValueRef.value = value;
        }
      }

      function handleDateInputBlur() {
        const date = strictParse(dateInputValueRef.value, mergedDateFormatRef.value, new Date(), panelCommon.dateFnsOptions.value);

        if (isValid$1(date)) {
          if (props.value === null) {
            panelCommon.doUpdateValue(getTime(sanitizeValue(Date.now())), false);
          } else if (!Array.isArray(props.value)) {
            const newDateTime = set(props.value, {
              year: getYear(date),
              month: getMonth(date),
              date: getDate(date)
            });
            panelCommon.doUpdateValue(getTime(sanitizeValue(getTime(newDateTime))), false);
          }
        } else {
          deriveDateInputValue();
        }
      }

      function clearSelectedDateTime() {
        panelCommon.doUpdateValue(null, true);
        dateInputValueRef.value = "";
        panelCommon.doClose(true);
        panelCommon.handleClearClick();
      }

      function handleNowClick() {
        panelCommon.doUpdateValue(getTime(sanitizeValue(Date.now())), true);
        const now = Date.now();
        calendarValueRef.value = now;
        panelCommon.doClose(true);

        if (props.panel && (type === "month" || type === "quarter" || type === "year")) {
          panelCommon.disableTransitionOneTick();
          justifyColumnsScrollState(now);
        }
      }

      function handleDateClick(dateItem) {
        if (mergedIsDateDisabled(dateItem.ts)) {
          return;
        }

        let newValue;

        if (props.value !== null && !Array.isArray(props.value)) {
          newValue = props.value;
        } else {
          newValue = Date.now();
        }

        if (type === "datetime" && props.defaultTime !== null && !Array.isArray(props.defaultTime)) {
          const time = getDefaultTime(props.defaultTime);

          if (time) {
            newValue = getTime(set(newValue, time));
          }
        }

        newValue = getTime(dateItem.type === "quarter" && dateItem.dateObject.quarter ? setQuarter(setYear(newValue, dateItem.dateObject.year), dateItem.dateObject.quarter) : set(newValue, dateItem.dateObject));
        panelCommon.doUpdateValue(sanitizeValue(newValue), props.panel || type === "date" || type === "year");

        switch (type) {
          case "date":
            panelCommon.doClose();
            break;

          case "year":
            if (props.panel) {
              panelCommon.disableTransitionOneTick();
            }

            panelCommon.doClose();
            break;

          case "month":
            panelCommon.disableTransitionOneTick();
            justifyColumnsScrollState(newValue);
            break;

          case "quarter":
            panelCommon.disableTransitionOneTick();
            justifyColumnsScrollState(newValue);
            break;
        }
      }

      function handleQuickMonthClick(dateItem, updatePanelValue) {
        let newValue;

        if (props.value !== null && !Array.isArray(props.value)) {
          newValue = props.value;
        } else {
          newValue = Date.now();
        }

        newValue = getTime(dateItem.type === "month" ? setMonth(newValue, dateItem.dateObject.month) : setYear(newValue, dateItem.dateObject.year));
        updatePanelValue(newValue);
        justifyColumnsScrollState(newValue);
      }

      function onUpdateCalendarValue(value) {
        calendarValueRef.value = value;
      }

      function deriveDateInputValue(time) {
        if (props.value === null || Array.isArray(props.value)) {
          dateInputValueRef.value = "";
          return;
        }

        if (time === void 0) {
          time = props.value;
        }

        dateInputValueRef.value = format$4(time, mergedDateFormatRef.value, panelCommon.dateFnsOptions.value);
      }

      function handleConfirmClick() {
        if (validation.isDateInvalid.value || validation.isTimeInvalid.value) {
          return;
        }

        panelCommon.doConfirm();
        closeCalendar();
      }

      function closeCalendar() {
        if (props.active) {
          panelCommon.doClose();
        }
      }

      function nextYear() {
        calendarValueRef.value = getTime(addYears(calendarValueRef.value, 1));
      }

      function prevYear() {
        calendarValueRef.value = getTime(addYears(calendarValueRef.value, -1));
      }

      function nextMonth() {
        calendarValueRef.value = getTime(addMonths(calendarValueRef.value, 1));
      }

      function prevMonth() {
        calendarValueRef.value = getTime(addMonths(calendarValueRef.value, -1));
      }

      function virtualListContainer() {
        const {
          value
        } = yearVlRef;
        return value === null || value === void 0 ? void 0 : value.listElRef;
      }

      function virtualListContent() {
        const {
          value
        } = yearVlRef;
        return value === null || value === void 0 ? void 0 : value.itemsElRef;
      }

      function handleVirtualListScroll(e) {
        var _yearScrollbarRef$val;

        (_yearScrollbarRef$val = yearScrollbarRef.value) === null || _yearScrollbarRef$val === void 0 ? void 0 : _yearScrollbarRef$val.sync();
      }

      function handleTimePickerChange(value) {
        if (value === null) return;
        panelCommon.doUpdateValue(value, props.panel);
      }

      function handleSingleShortcutMouseenter(shortcut) {
        panelCommon.cachePendingValue();
        const shortcutValue = panelCommon.getShortcutValue(shortcut);
        if (typeof shortcutValue !== "number") return;
        panelCommon.doUpdateValue(shortcutValue, false);
      }

      function handleSingleShortcutClick(shortcut) {
        const shortcutValue = panelCommon.getShortcutValue(shortcut);
        if (typeof shortcutValue !== "number") return;
        panelCommon.doUpdateValue(shortcutValue, props.panel);
        panelCommon.clearPendingValue();
        handleConfirmClick();
      }

      function justifyColumnsScrollState(value) {
        const {
          value: mergedValue
        } = props;

        if (monthScrollbarRef.value) {
          const monthIndex = value === void 0 ? mergedValue === null ? getMonth(Date.now()) : getMonth(mergedValue) : getMonth(value);
          monthScrollbarRef.value.scrollTo({
            top: monthIndex * MONTH_ITEM_HEIGHT
          });
        }

        if (yearVlRef.value) {
          const yearIndex = (value === void 0 ? mergedValue === null ? getYear(Date.now()) : getYear(mergedValue) : getYear(value)) - START_YEAR;
          yearVlRef.value.scrollTo({
            top: yearIndex * MONTH_ITEM_HEIGHT
          });
        }
      }

      const childComponentRefs = {
        monthScrollbarRef,
        yearScrollbarRef,
        yearVlRef
      };
      return {
        dateArray: dateArrayRef,
        monthArray: monthArrayRef,
        yearArray: yearArrayRef,
        quarterArray: quarterArrayRef,
        calendarYear: calendarYearRef,
        calendarMonth: calendarMonthRef,
        weekdays: weekdaysRef,
        mergedIsDateDisabled,
        nextYear,
        prevYear,
        nextMonth,
        prevMonth,
        handleNowClick,
        handleConfirmClick,
        handleSingleShortcutMouseenter,
        handleSingleShortcutClick,
        ...validation,
        ...panelCommon,
        ...childComponentRefs,
        handleDateClick,
        handleDateInputBlur,
        handleDateInput,
        handleTimePickerChange,
        clearSelectedDateTime,
        virtualListContainer,
        virtualListContent,
        handleVirtualListScroll,
        timePickerSize: panelCommon.timePickerSize,
        dateInputValue: dateInputValueRef,
        datePickerSlots,
        handleQuickMonthClick,
        justifyColumnsScrollState,
        calendarValue: calendarValueRef,
        onUpdateCalendarValue
      };
    }

    var MonthPanel = vue.defineComponent({
      name: "MonthPanel",
      props: {
        ...useCalendarProps,
        type: {
          type: String,
          required: true
        },
        useAsQuickJump: Boolean
      },
      setup(props) {
        const useCalendarRef = useCalendar(props, props.type);
        const getRenderContent = (item) => {
          switch (item.type) {
            case "year":
              return item.dateObject.year;
            case "month":
              return item.dateObject.month + 1;
            case "quarter":
              return `Q${item.dateObject.quarter}`;
          }
        };
        const { useAsQuickJump } = props;
        const renderItem = (item, i, mergedClsPrefix) => {
          const { mergedIsDateDisabled, handleDateClick, handleQuickMonthClick } = useCalendarRef;
          return /* @__PURE__ */ vue.h("div", {
            "data-n-date": true,
            key: i,
            class: [
              `${mergedClsPrefix}-date-panel-month-calendar__picker-col-item`,
              {
                [`${mergedClsPrefix}-date-panel-month-calendar__picker-col-item--current`]: item.isCurrent,
                [`${mergedClsPrefix}-date-panel-month-calendar__picker-col-item--selected`]: item.selected,
                [`${mergedClsPrefix}-date-panel-month-calendar__picker-col-item--disabled`]: !useAsQuickJump && mergedIsDateDisabled(item.ts)
              }
            ],
            onClick: () => {
              useAsQuickJump ? handleQuickMonthClick(
                item,
                (value) => props.onUpdateValue(value, false)
              ) : handleDateClick(item);
            }
          }, getRenderContent(item));
        };
        vue.onMounted(() => {
          useCalendarRef.justifyColumnsScrollState();
        });
        return { ...useCalendarRef, renderItem };
      },
      render() {
        const {
          mergedClsPrefix,
          mergedTheme,
          shortcuts,
          actions,
          renderItem,
          type,
          onRender
        } = this;
        onRender?.();
        return /* @__PURE__ */ vue.h("div", {
          ref: "selfRef",
          tabindex: 0,
          class: [
            `${mergedClsPrefix}-date-panel`,
            `${mergedClsPrefix}-date-panel--month`,
            !this.panel && `${mergedClsPrefix}-date-panel--shadow`,
            this.themeClass
          ],
          onFocus: this.handlePanelFocus,
          onKeydown: this.handlePanelKeyDown
        }, /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-month-calendar`
        }, /* @__PURE__ */ vue.h(NScrollbar, {
          ref: "yearScrollbarRef",
          class: `${mergedClsPrefix}-date-panel-month-calendar__picker-col`,
          theme: mergedTheme.peers.Scrollbar,
          themeOverrides: mergedTheme.peerOverrides.Scrollbar,
          container: this.virtualListContainer,
          content: this.virtualListContent,
          horizontalRailStyle: { zIndex: 1 },
          verticalRailStyle: { zIndex: 1 }
        }, {
          default: () => /* @__PURE__ */ vue.h(VVirtualList, {
            ref: "yearVlRef",
            items: this.yearArray,
            itemSize: MONTH_ITEM_HEIGHT,
            showScrollbar: false,
            keyField: "ts",
            onScroll: this.handleVirtualListScroll,
            paddingBottom: 4
          }, {
            default: ({
              item,
              index
            }) => {
              return renderItem(item, index, mergedClsPrefix);
            }
          })
        }), type === "month" || type === "quarter" ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-month-calendar__picker-col`
        }, /* @__PURE__ */ vue.h(NScrollbar, {
          ref: "monthScrollbarRef",
          theme: mergedTheme.peers.Scrollbar,
          themeOverrides: mergedTheme.peerOverrides.Scrollbar
        }, {
          default: () => [
            (type === "month" ? this.monthArray : this.quarterArray).map((item, i) => renderItem(item, i, mergedClsPrefix)),
            /* @__PURE__ */ vue.h("div", {
              class: `${mergedClsPrefix}-date-panel-${type}-calendar__padding`
            })
          ]
        })) : null), this.datePickerSlots.footer ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-footer`
        }, {
          default: this.datePickerSlots.footer
        }) : null, actions?.length || shortcuts ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-actions`
        }, /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-actions__prefix`
        }, shortcuts && Object.keys(shortcuts).map((key) => {
          const shortcut = shortcuts[key];
          return Array.isArray(shortcut) ? null : /* @__PURE__ */ vue.h(XButton, {
            size: "tiny",
            onMouseenter: () => {
              this.handleSingleShortcutMouseenter(shortcut);
            },
            onClick: () => {
              this.handleSingleShortcutClick(shortcut);
            },
            onMouseleave: () => {
              this.handleShortcutMouseleave();
            }
          }, { default: () => key });
        })), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-actions__suffix`
        }, actions?.includes("clear") ? /* @__PURE__ */ vue.h(NButton, {
          theme: mergedTheme.peers.Button,
          themeOverrides: mergedTheme.peerOverrides.Button,
          size: "tiny",
          onClick: this.handleClearClick
        }, { default: () => this.locale.clear }) : null, actions?.includes("now") ? /* @__PURE__ */ vue.h(NButton, {
          theme: mergedTheme.peers.Button,
          themeOverrides: mergedTheme.peerOverrides.Button,
          size: "tiny",
          onClick: this.handleNowClick
        }, { default: () => this.locale.now }) : null, actions?.includes("confirm") ? /* @__PURE__ */ vue.h(NButton, {
          theme: mergedTheme.peers.Button,
          themeOverrides: mergedTheme.peerOverrides.Button,
          size: "tiny",
          type: "primary",
          disabled: this.isDateInvalid,
          onClick: this.handleConfirmClick
        }, { default: () => this.locale.confirm }) : null)) : null, /* @__PURE__ */ vue.h(FocusDetector, {
          onFocus: this.handleFocusDetectorFocus
        }));
      }
    });

    var PanelHeader = vue.defineComponent({
      props: {
        mergedClsPrefix: {
          type: String,
          required: true
        },
        value: Number,
        monthBeforeYear: {
          type: Boolean,
          required: true
        },
        calendarMonth: {
          type: String,
          required: true
        },
        calendarYear: {
          type: String,
          required: true
        },
        onUpdateValue: {
          type: Function,
          required: true
        }
      },
      setup() {
        const triggerRef = vue.ref(null);
        const monthPanelRef = vue.ref(null);
        const showRef = vue.ref(false);
        function handleClickOutside(e) {
          if (showRef.value && !triggerRef.value?.contains(getPreciseEventTarget(e))) {
            showRef.value = false;
          }
        }
        function handleHeaderClick() {
          showRef.value = !showRef.value;
        }
        return {
          show: showRef,
          triggerRef,
          monthPanelRef,
          handleHeaderClick,
          handleClickOutside
        };
      },
      render() {
        const { handleClickOutside, mergedClsPrefix } = this;
        return /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-month__month-year`,
          ref: "triggerRef"
        }, /* @__PURE__ */ vue.h(VBinder, null, {
          default: () => [
            /* @__PURE__ */ vue.h(VTarget, null, {
              default: () => /* @__PURE__ */ vue.h("div", {
                class: [
                  `${mergedClsPrefix}-date-panel-month__text`,
                  this.show && `${mergedClsPrefix}-date-panel-month__text--active`
                ],
                onClick: this.handleHeaderClick
              }, this.monthBeforeYear ? [this.calendarMonth, " ", this.calendarYear] : [this.calendarYear, " ", this.calendarMonth])
            }),
            /* @__PURE__ */ vue.h(VFollower, {
              show: this.show,
              teleportDisabled: true
            }, {
              default: () => /* @__PURE__ */ vue.h(vue.Transition, {
                name: "fade-in-scale-up-transition",
                appear: true
              }, {
                default: () => this.show ? vue.withDirectives(
                  /* @__PURE__ */ vue.h(MonthPanel, {
                    ref: "monthPanelRef",
                    onUpdateValue: this.onUpdateValue,
                    actions: [],
                    type: "month",
                    key: "month",
                    useAsQuickJump: true,
                    value: this.value
                  }),
                  [
                    [
                      clickoutside$1,
                      handleClickOutside,
                      void 0,
                      { capture: true }
                    ]
                  ]
                ) : null
              })
            })
          ]
        }));
      }
    });

    var DatetimePanel = vue.defineComponent({
      name: "DateTimePanel",
      props: useCalendarProps,
      setup(props) {
        return useCalendar(props, "datetime");
      },
      render() {
        const {
          mergedClsPrefix,
          mergedTheme,
          shortcuts,
          timePickerProps,
          onRender
        } = this;
        onRender?.();
        return /* @__PURE__ */ vue.h("div", {
          ref: "selfRef",
          tabindex: 0,
          class: [
            `${mergedClsPrefix}-date-panel`,
            `${mergedClsPrefix}-date-panel--datetime`,
            !this.panel && `${mergedClsPrefix}-date-panel--shadow`,
            this.themeClass
          ],
          onKeydown: this.handlePanelKeyDown,
          onFocus: this.handlePanelFocus
        }, /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-header`
        }, /* @__PURE__ */ vue.h(NInput, {
          value: this.dateInputValue,
          theme: mergedTheme.peers.Input,
          themeOverrides: mergedTheme.peerOverrides.Input,
          stateful: false,
          size: this.timePickerSize,
          class: `${mergedClsPrefix}-date-panel-date-input`,
          textDecoration: this.isDateInvalid ? "line-through" : "",
          placeholder: this.locale.selectDate,
          onBlur: this.handleDateInputBlur,
          onUpdateValue: this.handleDateInput
        }), /* @__PURE__ */ vue.h(NTimePicker, {
          size: this.timePickerSize,
          placeholder: this.locale.selectTime,
          format: this.timeFormat,
          ...Array.isArray(timePickerProps) ? void 0 : timePickerProps,
          showIcon: false,
          to: false,
          theme: mergedTheme.peers.TimePicker,
          themeOverrides: mergedTheme.peerOverrides.TimePicker,
          value: Array.isArray(this.value) ? null : this.value,
          isHourDisabled: this.isHourDisabled,
          isMinuteDisabled: this.isMinuteDisabled,
          isSecondDisabled: this.isSecondDisabled,
          onUpdateValue: this.handleTimePickerChange,
          stateful: false
        })), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-calendar`
        }, /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-month`
        }, /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-month__fast-prev`,
          onClick: this.prevYear
        }, /* @__PURE__ */ vue.h(FastBackwardIcon, null)), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-month__prev`,
          onClick: this.prevMonth
        }, /* @__PURE__ */ vue.h(BackwardIcon, null)), /* @__PURE__ */ vue.h(PanelHeader, {
          monthBeforeYear: this.locale.monthBeforeYear,
          value: this.calendarValue,
          onUpdateValue: this.onUpdateCalendarValue,
          mergedClsPrefix,
          calendarMonth: this.calendarMonth,
          calendarYear: this.calendarYear
        }), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-month__next`,
          onClick: this.nextMonth
        }, /* @__PURE__ */ vue.h(ForwardIcon, null)), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-month__fast-next`,
          onClick: this.nextYear
        }, /* @__PURE__ */ vue.h(FastForwardIcon, null))), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-weekdays`
        }, this.weekdays.map((weekday) => /* @__PURE__ */ vue.h("div", {
          key: weekday,
          class: `${mergedClsPrefix}-date-panel-weekdays__day`
        }, weekday))), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-dates`
        }, this.dateArray.map((dateItem, i) => /* @__PURE__ */ vue.h("div", {
          "data-n-date": true,
          key: i,
          class: [
            `${mergedClsPrefix}-date-panel-date`,
            {
              [`${mergedClsPrefix}-date-panel-date--current`]: dateItem.isCurrentDate,
              [`${mergedClsPrefix}-date-panel-date--selected`]: dateItem.selected,
              [`${mergedClsPrefix}-date-panel-date--excluded`]: !dateItem.inCurrentMonth,
              [`${mergedClsPrefix}-date-panel-date--disabled`]: this.mergedIsDateDisabled(dateItem.ts)
            }
          ],
          onClick: () => this.handleDateClick(dateItem)
        }, /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-date__trigger`
        }), dateItem.dateObject.date, dateItem.isCurrentDate ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-date__sup`
        }) : null)))), this.datePickerSlots.footer ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-footer`
        }, this.datePickerSlots.footer()) : null, this.actions?.length || shortcuts ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-actions`
        }, /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-actions__prefix`
        }, shortcuts && Object.keys(shortcuts).map((key) => {
          const shortcut = shortcuts[key];
          return Array.isArray(shortcut) ? null : /* @__PURE__ */ vue.h(XButton, {
            size: "tiny",
            onMouseenter: () => {
              this.handleSingleShortcutMouseenter(shortcut);
            },
            onClick: () => {
              this.handleSingleShortcutClick(shortcut);
            },
            onMouseleave: () => {
              this.handleShortcutMouseleave();
            }
          }, { default: () => key });
        })), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-actions__suffix`
        }, this.actions?.includes("clear") ? /* @__PURE__ */ vue.h(NButton, {
          theme: mergedTheme.peers.Button,
          themeOverrides: mergedTheme.peerOverrides.Button,
          size: "tiny",
          onClick: this.clearSelectedDateTime
        }, { default: () => this.locale.clear }) : null, this.actions?.includes("now") ? /* @__PURE__ */ vue.h(NButton, {
          theme: mergedTheme.peers.Button,
          themeOverrides: mergedTheme.peerOverrides.Button,
          size: "tiny",
          onClick: this.handleNowClick
        }, { default: () => this.locale.now }) : null, this.actions?.includes("confirm") ? /* @__PURE__ */ vue.h(NButton, {
          theme: mergedTheme.peers.Button,
          themeOverrides: mergedTheme.peerOverrides.Button,
          size: "tiny",
          type: "primary",
          disabled: this.isDateInvalid,
          onClick: this.handleConfirmClick
        }, { default: () => this.locale.confirm }) : null)) : null, /* @__PURE__ */ vue.h(FocusDetector, {
          onFocus: this.handleFocusDetectorFocus
        }));
      }
    });

    const useDualCalendarProps = { ...usePanelCommonProps,
      defaultCalendarStartTime: Number,
      defaultCalendarEndTime: Number,
      bindCalendarMonths: Boolean,
      actions: {
        type: Array,
        default: () => ["clear", "confirm"]
      }
    };

    function useDualCalendar(props, type) {
      const {
        isDateDisabledRef,
        isStartHourDisabledRef,
        isEndHourDisabledRef,
        isStartMinuteDisabledRef,
        isEndMinuteDisabledRef,
        isStartSecondDisabledRef,
        isEndSecondDisabledRef,
        isStartDateInvalidRef,
        isEndDateInvalidRef,
        isStartTimeInvalidRef,
        isEndTimeInvalidRef,
        isStartValueInvalidRef,
        isEndValueInvalidRef,
        isRangeInvalidRef,
        localeRef,
        rangesRef,
        closeOnSelectRef,
        updateValueOnCloseRef,
        firstDayOfWeekRef,
        datePickerSlots
      } = vue.inject(datePickerInjectionKey);
      const validation = {
        isDateDisabled: isDateDisabledRef,
        isStartHourDisabled: isStartHourDisabledRef,
        isEndHourDisabled: isEndHourDisabledRef,
        isStartMinuteDisabled: isStartMinuteDisabledRef,
        isEndMinuteDisabled: isEndMinuteDisabledRef,
        isStartSecondDisabled: isStartSecondDisabledRef,
        isEndSecondDisabled: isEndSecondDisabledRef,
        isStartDateInvalid: isStartDateInvalidRef,
        isEndDateInvalid: isEndDateInvalidRef,
        isStartTimeInvalid: isStartTimeInvalidRef,
        isEndTimeInvalid: isEndTimeInvalidRef,
        isStartValueInvalid: isStartValueInvalidRef,
        isEndValueInvalid: isEndValueInvalidRef,
        isRangeInvalid: isRangeInvalidRef
      };
      const panelCommon = usePanelCommon(props);
      const startDatesElRef = vue.ref(null);
      const endDatesElRef = vue.ref(null);
      const startYearScrollbarRef = vue.ref(null);
      const endYearScrollbarRef = vue.ref(null);
      const startYearVlRef = vue.ref(null);
      const endYearVlRef = vue.ref(null);
      const startMonthScrollbarRef = vue.ref(null);
      const endMonthScrollbarRef = vue.ref(null);
      const {
        value
      } = props;
      const defaultCalendarStartTime = props.defaultCalendarStartTime ?? (Array.isArray(value) && typeof value[0] === "number" ? value[0] : Date.now());
      const startCalendarDateTimeRef = vue.ref(defaultCalendarStartTime);
      const endCalendarDateTimeRef = vue.ref(props.defaultCalendarEndTime ?? (Array.isArray(value) && typeof value[1] === "number" ? value[1] : getTime(addMonths(defaultCalendarStartTime, 1))));
      adjustCalendarTimes(true);
      const nowRef = vue.ref(Date.now());
      const isSelectingRef = vue.ref(false);
      const memorizedStartDateTimeRef = vue.ref(0);
      const mergedDateFormatRef = vue.computed(() => props.dateFormat || localeRef.value.dateFormat);
      const startDateInput = vue.ref(Array.isArray(value) ? format$4(value[0], mergedDateFormatRef.value, panelCommon.dateFnsOptions.value) : "");
      const endDateInputRef = vue.ref(Array.isArray(value) ? format$4(value[1], mergedDateFormatRef.value, panelCommon.dateFnsOptions.value) : "");
      const selectingPhaseRef = vue.computed(() => {
        if (isSelectingRef.value) return "end";else return "start";
      });
      const startDateArrayRef = vue.computed(() => {
        return dateArray(startCalendarDateTimeRef.value, props.value, nowRef.value, firstDayOfWeekRef.value ?? localeRef.value.firstDayOfWeek);
      });
      const endDateArrayRef = vue.computed(() => {
        return dateArray(endCalendarDateTimeRef.value, props.value, nowRef.value, firstDayOfWeekRef.value ?? localeRef.value.firstDayOfWeek);
      });
      const weekdaysRef = vue.computed(() => {
        return startDateArrayRef.value.slice(0, 7).map(dateItem => {
          const {
            ts
          } = dateItem;
          return format$4(ts, localeRef.value.dayFormat, panelCommon.dateFnsOptions.value);
        });
      });
      const startCalendarMonthRef = vue.computed(() => {
        return format$4(startCalendarDateTimeRef.value, localeRef.value.monthFormat, panelCommon.dateFnsOptions.value);
      });
      const endCalendarMonthRef = vue.computed(() => {
        return format$4(endCalendarDateTimeRef.value, localeRef.value.monthFormat, panelCommon.dateFnsOptions.value);
      });
      const startCalendarYearRef = vue.computed(() => {
        return format$4(startCalendarDateTimeRef.value, localeRef.value.yearFormat, panelCommon.dateFnsOptions.value);
      });
      const endCalendarYearRef = vue.computed(() => {
        return format$4(endCalendarDateTimeRef.value, localeRef.value.yearFormat, panelCommon.dateFnsOptions.value);
      });
      const startTimeValueRef = vue.computed(() => {
        const {
          value: value2
        } = props;
        if (Array.isArray(value2)) return value2[0];
        return null;
      });
      const endTimeValueRef = vue.computed(() => {
        const {
          value: value2
        } = props;
        if (Array.isArray(value2)) return value2[1];
        return null;
      });
      const shortcutsRef = vue.computed(() => {
        const {
          shortcuts
        } = props;
        return shortcuts || rangesRef.value;
      });
      const startYearArrayRef = vue.computed(() => {
        return yearArray(pluckValueFromRange(props.value, "start"), nowRef.value);
      });
      const endYearArrayRef = vue.computed(() => {
        return yearArray(pluckValueFromRange(props.value, "end"), nowRef.value);
      });
      const startQuarterArrayRef = vue.computed(() => {
        const startValue = pluckValueFromRange(props.value, "start");
        return quarterArray(startValue ?? Date.now(), startValue, nowRef.value);
      });
      const endQuarterArrayRef = vue.computed(() => {
        const endValue = pluckValueFromRange(props.value, "end");
        return quarterArray(endValue ?? Date.now(), endValue, nowRef.value);
      });
      const startMonthArrayRef = vue.computed(() => {
        const startValue = pluckValueFromRange(props.value, "start");
        return monthArray(startValue ?? Date.now(), startValue, nowRef.value);
      });
      const endMonthArrayRef = vue.computed(() => {
        const endValue = pluckValueFromRange(props.value, "end");
        return monthArray(endValue ?? Date.now(), endValue, nowRef.value);
      });
      vue.watch(vue.computed(() => props.value), value2 => {
        if (value2 !== null && Array.isArray(value2)) {
          const [startMoment, endMoment] = value2;
          startDateInput.value = format$4(startMoment, mergedDateFormatRef.value, panelCommon.dateFnsOptions.value);
          endDateInputRef.value = format$4(endMoment, mergedDateFormatRef.value, panelCommon.dateFnsOptions.value);

          if (!isSelectingRef.value) {
            syncCalendarTimeWithValue(value2);
          }
        } else {
          startDateInput.value = "";
          endDateInputRef.value = "";
        }
      });

      function handleCalendarChange(value2, oldValue) {
        if (type === "daterange" || type === "datetimerange") {
          if (getYear(value2) !== getYear(oldValue) || getMonth(value2) !== getMonth(oldValue)) {
            panelCommon.disableTransitionOneTick();
          }
        }
      }

      vue.watch(startCalendarDateTimeRef, handleCalendarChange);
      vue.watch(endCalendarDateTimeRef, handleCalendarChange);

      function adjustCalendarTimes(byStartCalendarTime) {
        const startTime = startOfMonth(startCalendarDateTimeRef.value);
        const endTime = startOfMonth(endCalendarDateTimeRef.value);

        if (props.bindCalendarMonths || startTime >= endTime) {
          if (byStartCalendarTime) {
            endCalendarDateTimeRef.value = getTime(addMonths(startTime, 1));
          } else {
            startCalendarDateTimeRef.value = getTime(addMonths(endTime, -1));
          }
        }
      }

      function startCalendarNextYear() {
        startCalendarDateTimeRef.value = getTime(addMonths(startCalendarDateTimeRef.value, 12));
        adjustCalendarTimes(true);
      }

      function startCalendarPrevYear() {
        startCalendarDateTimeRef.value = getTime(addMonths(startCalendarDateTimeRef.value, -12));
        adjustCalendarTimes(true);
      }

      function startCalendarNextMonth() {
        startCalendarDateTimeRef.value = getTime(addMonths(startCalendarDateTimeRef.value, 1));
        adjustCalendarTimes(true);
      }

      function startCalendarPrevMonth() {
        startCalendarDateTimeRef.value = getTime(addMonths(startCalendarDateTimeRef.value, -1));
        adjustCalendarTimes(true);
      }

      function endCalendarNextYear() {
        endCalendarDateTimeRef.value = getTime(addMonths(endCalendarDateTimeRef.value, 12));
        adjustCalendarTimes(false);
      }

      function endCalendarPrevYear() {
        endCalendarDateTimeRef.value = getTime(addMonths(endCalendarDateTimeRef.value, -12));
        adjustCalendarTimes(false);
      }

      function endCalendarNextMonth() {
        endCalendarDateTimeRef.value = getTime(addMonths(endCalendarDateTimeRef.value, 1));
        adjustCalendarTimes(false);
      }

      function endCalendarPrevMonth() {
        endCalendarDateTimeRef.value = getTime(addMonths(endCalendarDateTimeRef.value, -1));
        adjustCalendarTimes(false);
      }

      function onUpdateStartCalendarValue(value2) {
        startCalendarDateTimeRef.value = value2;
        adjustCalendarTimes(true);
      }

      function onUpdateEndCalendarValue(value2) {
        endCalendarDateTimeRef.value = value2;
        adjustCalendarTimes(false);
      }

      function mergedIsDateDisabled(ts) {
        const isDateDisabled = isDateDisabledRef.value;
        if (!isDateDisabled) return false;
        if (!Array.isArray(props.value)) return isDateDisabled(ts, "start", null);

        if (selectingPhaseRef.value === "start") {
          return isDateDisabled(ts, "start", null);
        } else {
          const {
            value: memorizedStartDateTime
          } = memorizedStartDateTimeRef;

          if (ts < memorizedStartDateTimeRef.value) {
            return isDateDisabled(ts, "start", [memorizedStartDateTime, memorizedStartDateTime]);
          } else {
            return isDateDisabled(ts, "end", [memorizedStartDateTime, memorizedStartDateTime]);
          }
        }
      }

      function syncCalendarTimeWithValue(value2) {
        if (value2 === null) return;
        const [startMoment, endMoment] = value2;
        startCalendarDateTimeRef.value = startMoment;

        if (startOfMonth(endMoment) <= startOfMonth(startMoment)) {
          endCalendarDateTimeRef.value = getTime(startOfMonth(addMonths(startMoment, 1)));
        } else {
          endCalendarDateTimeRef.value = getTime(startOfMonth(endMoment));
        }
      }

      function handleDateClick(dateItem) {
        if (!isSelectingRef.value) {
          isSelectingRef.value = true;
          memorizedStartDateTimeRef.value = dateItem.ts;
          changeStartEndTime(dateItem.ts, dateItem.ts, "done");
        } else {
          isSelectingRef.value = false;
          const {
            value: value2
          } = props;

          if (props.panel && Array.isArray(value2)) {
            changeStartEndTime(value2[0], value2[1], "done");
          } else {
            if (closeOnSelectRef.value && type === "daterange") {
              if (updateValueOnCloseRef.value) {
                closeCalendar();
              } else {
                handleConfirmClick();
              }
            }
          }
        }
      }

      function handleDateMouseEnter(dateItem) {
        if (isSelectingRef.value) {
          if (mergedIsDateDisabled(dateItem.ts)) return;

          if (dateItem.ts >= memorizedStartDateTimeRef.value) {
            changeStartEndTime(memorizedStartDateTimeRef.value, dateItem.ts, "wipPreview");
          } else {
            changeStartEndTime(dateItem.ts, memorizedStartDateTimeRef.value, "wipPreview");
          }
        }
      }

      function handleConfirmClick() {
        if (isRangeInvalidRef.value) {
          return;
        }

        panelCommon.doConfirm();
        closeCalendar();
      }

      function closeCalendar() {
        isSelectingRef.value = false;

        if (props.active) {
          panelCommon.doClose();
        }
      }

      function changeStartDateTime(time) {
        if (typeof time !== "number") {
          time = getTime(time);
        }

        if (props.value === null) {
          panelCommon.doUpdateValue([time, time], props.panel);
        } else if (Array.isArray(props.value)) {
          panelCommon.doUpdateValue([time, Math.max(props.value[1], time)], props.panel);
        }
      }

      function changeEndDateTime(time) {
        if (typeof time !== "number") {
          time = getTime(time);
        }

        if (props.value === null) {
          panelCommon.doUpdateValue([time, time], props.panel);
        } else if (Array.isArray(props.value)) {
          panelCommon.doUpdateValue([Math.min(props.value[0], time), time], props.panel);
        }
      }

      function changeStartEndTime(startTime, endTime, source) {
        if (typeof startTime !== "number") {
          startTime = getTime(startTime);
        }

        if (source !== "shortcutPreview") {
          let startDefaultTime;
          let endDefaultTime;

          if (type === "datetimerange") {
            const {
              defaultTime
            } = props;

            if (Array.isArray(defaultTime)) {
              startDefaultTime = getDefaultTime(defaultTime[0]);
              endDefaultTime = getDefaultTime(defaultTime[1]);
            } else {
              startDefaultTime = getDefaultTime(defaultTime);
              endDefaultTime = startDefaultTime;
            }
          }

          if (startDefaultTime) {
            startTime = getTime(set(startTime, startDefaultTime));
          }

          if (endDefaultTime) {
            endTime = getTime(set(endTime, endDefaultTime));
          }
        }

        panelCommon.doUpdateValue([startTime, endTime], props.panel && source === "done");
      }

      function sanitizeValue(datetime) {
        if (type === "datetimerange") {
          return getTime(startOfSecond(datetime));
        } else if (type === "monthrange") {
          return getTime(startOfMonth(datetime));
        } else {
          return getTime(startOfDay(datetime));
        }
      }

      function handleStartDateInput(value2) {
        const date = strictParse(value2, mergedDateFormatRef.value, new Date(), panelCommon.dateFnsOptions.value);

        if (isValid$1(date)) {
          if (!props.value) {
            const newValue = set(new Date(), {
              year: getYear(date),
              month: getMonth(date),
              date: getDate(date)
            });
            changeStartDateTime(sanitizeValue(getTime(newValue)));
          } else if (Array.isArray(props.value)) {
            const newValue = set(props.value[0], {
              year: getYear(date),
              month: getMonth(date),
              date: getDate(date)
            });
            changeStartDateTime(sanitizeValue(getTime(newValue)));
          }
        } else {
          startDateInput.value = value2;
        }
      }

      function handleEndDateInput(value2) {
        const date = strictParse(value2, mergedDateFormatRef.value, new Date(), panelCommon.dateFnsOptions.value);

        if (isValid$1(date)) {
          if (props.value === null) {
            const newValue = set(new Date(), {
              year: getYear(date),
              month: getMonth(date),
              date: getDate(date)
            });
            changeEndDateTime(sanitizeValue(getTime(newValue)));
          } else if (Array.isArray(props.value)) {
            const newValue = set(props.value[1], {
              year: getYear(date),
              month: getMonth(date),
              date: getDate(date)
            });
            changeEndDateTime(sanitizeValue(getTime(newValue)));
          }
        } else {
          endDateInputRef.value = value2;
        }
      }

      function handleStartDateInputBlur() {
        const date = strictParse(startDateInput.value, mergedDateFormatRef.value, new Date(), panelCommon.dateFnsOptions.value);
        const {
          value: value2
        } = props;

        if (isValid$1(date)) {
          if (value2 === null) {
            const newValue = set(new Date(), {
              year: getYear(date),
              month: getMonth(date),
              date: getDate(date)
            });
            changeStartDateTime(sanitizeValue(getTime(newValue)));
          } else if (Array.isArray(value2)) {
            const newValue = set(value2[0], {
              year: getYear(date),
              month: getMonth(date),
              date: getDate(date)
            });
            changeStartDateTime(sanitizeValue(getTime(newValue)));
          }
        } else {
          refreshDisplayDateString();
        }
      }

      function handleEndDateInputBlur() {
        const date = strictParse(endDateInputRef.value, mergedDateFormatRef.value, new Date(), panelCommon.dateFnsOptions.value);
        const {
          value: value2
        } = props;

        if (isValid$1(date)) {
          if (value2 === null) {
            const newValue = set(new Date(), {
              year: getYear(date),
              month: getMonth(date),
              date: getDate(date)
            });
            changeEndDateTime(sanitizeValue(getTime(newValue)));
          } else if (Array.isArray(value2)) {
            const newValue = set(value2[1], {
              year: getYear(date),
              month: getMonth(date),
              date: getDate(date)
            });
            changeEndDateTime(sanitizeValue(getTime(newValue)));
          }
        } else {
          refreshDisplayDateString();
        }
      }

      function refreshDisplayDateString(times) {
        const {
          value: value2
        } = props;

        if (value2 === null || !Array.isArray(value2)) {
          startDateInput.value = "";
          endDateInputRef.value = "";
          return;
        }

        if (times === void 0) {
          times = value2;
        }

        startDateInput.value = format$4(times[0], mergedDateFormatRef.value, panelCommon.dateFnsOptions.value);
        endDateInputRef.value = format$4(times[1], mergedDateFormatRef.value, panelCommon.dateFnsOptions.value);
      }

      function handleStartTimePickerChange(value2) {
        if (value2 === null) return;
        changeStartDateTime(value2);
      }

      function handleEndTimePickerChange(value2) {
        if (value2 === null) return;
        changeEndDateTime(value2);
      }

      function handleRangeShortcutMouseenter(shortcut) {
        panelCommon.cachePendingValue();
        const shortcutValue = panelCommon.getShortcutValue(shortcut);
        if (!Array.isArray(shortcutValue)) return;
        changeStartEndTime(shortcutValue[0], shortcutValue[1], "shortcutPreview");
      }

      function handleRangeShortcutClick(shortcut) {
        const shortcutValue = panelCommon.getShortcutValue(shortcut);
        if (!Array.isArray(shortcutValue)) return;
        changeStartEndTime(shortcutValue[0], shortcutValue[1], "done");
        panelCommon.clearPendingValue();
        handleConfirmClick();
      }

      function justifyColumnsScrollState(value2, type2) {
        const mergedValue = value2 === void 0 ? props.value : value2;

        if (value2 === void 0 || type2 === "start") {
          if (startMonthScrollbarRef.value) {
            const monthIndex = !Array.isArray(mergedValue) ? getMonth(Date.now()) : getMonth(mergedValue[0]);
            startMonthScrollbarRef.value.scrollTo({
              debounce: false,
              index: monthIndex,
              elSize: MONTH_ITEM_HEIGHT
            });
          }

          if (startYearVlRef.value) {
            const yearIndex = (!Array.isArray(mergedValue) ? getYear(Date.now()) : getYear(mergedValue[0])) - START_YEAR;
            startYearVlRef.value.scrollTo({
              index: yearIndex,
              debounce: false
            });
          }
        }

        if (value2 === void 0 || type2 === "end") {
          if (endMonthScrollbarRef.value) {
            const monthIndex = !Array.isArray(mergedValue) ? getMonth(Date.now()) : getMonth(mergedValue[1]);
            endMonthScrollbarRef.value.scrollTo({
              debounce: false,
              index: monthIndex,
              elSize: MONTH_ITEM_HEIGHT
            });
          }

          if (endYearVlRef.value) {
            const yearIndex = (!Array.isArray(mergedValue) ? getYear(Date.now()) : getYear(mergedValue[1])) - START_YEAR;
            endYearVlRef.value.scrollTo({
              index: yearIndex,
              debounce: false
            });
          }
        }
      }

      function handleColItemClick(dateItem, clickType) {
        const {
          value: value2
        } = props;
        const noCurrentValue = !Array.isArray(value2);
        const itemTs = dateItem.type === "year" && type !== "yearrange" ? noCurrentValue ? set(dateItem.ts, {
          month: getMonth(type === "quarterrange" ? startOfQuarter(new Date()) : new Date())
        }).valueOf() : set(dateItem.ts, {
          month: getMonth(type === "quarterrange" ? startOfQuarter(value2[clickType === "start" ? 0 : 1]) : value2[clickType === "start" ? 0 : 1])
        }).valueOf() : dateItem.ts;

        if (noCurrentValue) {
          const partialValue = sanitizeValue(itemTs);
          const nextValue2 = [partialValue, partialValue];
          panelCommon.doUpdateValue(nextValue2, props.panel);
          justifyColumnsScrollState(nextValue2, "start");
          justifyColumnsScrollState(nextValue2, "end");
          panelCommon.disableTransitionOneTick();
          return;
        }

        const nextValue = [value2[0], value2[1]];
        let otherPartsChanged = false;

        if (clickType === "start") {
          nextValue[0] = sanitizeValue(itemTs);

          if (nextValue[0] > nextValue[1]) {
            nextValue[1] = nextValue[0];
            otherPartsChanged = true;
          }
        } else {
          nextValue[1] = sanitizeValue(itemTs);

          if (nextValue[0] > nextValue[1]) {
            nextValue[0] = nextValue[1];
            otherPartsChanged = true;
          }
        }

        panelCommon.doUpdateValue(nextValue, props.panel);

        switch (type) {
          case "monthrange":
          case "quarterrange":
            panelCommon.disableTransitionOneTick();

            if (otherPartsChanged) {
              justifyColumnsScrollState(nextValue, "start");
              justifyColumnsScrollState(nextValue, "end");
            } else {
              justifyColumnsScrollState(nextValue, clickType);
            }

            break;

          case "yearrange":
            panelCommon.disableTransitionOneTick();
            justifyColumnsScrollState(nextValue, "start");
            justifyColumnsScrollState(nextValue, "end");
        }
      }

      function handleStartYearVlScroll() {
        var _startYearScrollbarRe;

        (_startYearScrollbarRe = startYearScrollbarRef.value) === null || _startYearScrollbarRe === void 0 ? void 0 : _startYearScrollbarRe.sync();
      }

      function handleEndYearVlScroll() {
        var _endYearScrollbarRef$;

        (_endYearScrollbarRef$ = endYearScrollbarRef.value) === null || _endYearScrollbarRef$ === void 0 ? void 0 : _endYearScrollbarRef$.sync();
      }

      function virtualListContainer(type2) {
        if (type2 === "start") {
          var _startYearVlRef$value;

          return (_startYearVlRef$value = startYearVlRef.value) === null || _startYearVlRef$value === void 0 ? void 0 : _startYearVlRef$value.listElRef;
        } else {
          var _endYearVlRef$value;

          return (_endYearVlRef$value = endYearVlRef.value) === null || _endYearVlRef$value === void 0 ? void 0 : _endYearVlRef$value.listElRef;
        }
      }

      function virtualListContent(type2) {
        if (type2 === "start") {
          var _startYearVlRef$value2;

          return (_startYearVlRef$value2 = startYearVlRef.value) === null || _startYearVlRef$value2 === void 0 ? void 0 : _startYearVlRef$value2.itemsElRef;
        } else {
          var _endYearVlRef$value2;

          return (_endYearVlRef$value2 = endYearVlRef.value) === null || _endYearVlRef$value2 === void 0 ? void 0 : _endYearVlRef$value2.itemsElRef;
        }
      }

      const childComponentRefs = {
        startYearVlRef,
        endYearVlRef,
        startMonthScrollbarRef,
        endMonthScrollbarRef,
        startYearScrollbarRef,
        endYearScrollbarRef
      };
      return {
        startDatesElRef,
        endDatesElRef,
        handleDateClick,
        handleColItemClick,
        handleDateMouseEnter,
        handleConfirmClick,
        startCalendarPrevYear,
        startCalendarPrevMonth,
        startCalendarNextYear,
        startCalendarNextMonth,
        endCalendarPrevYear,
        endCalendarPrevMonth,
        endCalendarNextMonth,
        endCalendarNextYear,
        mergedIsDateDisabled,
        changeStartEndTime,
        ranges: rangesRef,
        startCalendarMonth: startCalendarMonthRef,
        startCalendarYear: startCalendarYearRef,
        endCalendarMonth: endCalendarMonthRef,
        endCalendarYear: endCalendarYearRef,
        weekdays: weekdaysRef,
        startDateArray: startDateArrayRef,
        endDateArray: endDateArrayRef,
        startYearArray: startYearArrayRef,
        startMonthArray: startMonthArrayRef,
        startQuarterArray: startQuarterArrayRef,
        endYearArray: endYearArrayRef,
        endMonthArray: endMonthArrayRef,
        endQuarterArray: endQuarterArrayRef,
        isSelecting: isSelectingRef,
        handleRangeShortcutMouseenter,
        handleRangeShortcutClick,
        ...panelCommon,
        ...validation,
        ...childComponentRefs,
        startDateDisplayString: startDateInput,
        endDateInput: endDateInputRef,
        timePickerSize: panelCommon.timePickerSize,
        startTimeValue: startTimeValueRef,
        endTimeValue: endTimeValueRef,
        datePickerSlots,
        shortcuts: shortcutsRef,
        startCalendarDateTime: startCalendarDateTimeRef,
        endCalendarDateTime: endCalendarDateTimeRef,
        justifyColumnsScrollState,
        handleFocusDetectorFocus: panelCommon.handleFocusDetectorFocus,
        handleStartTimePickerChange,
        handleEndTimePickerChange,
        handleStartDateInput,
        handleStartDateInputBlur,
        handleEndDateInput,
        handleEndDateInputBlur,
        handleStartYearVlScroll,
        handleEndYearVlScroll,
        virtualListContainer,
        virtualListContent,
        onUpdateStartCalendarValue,
        onUpdateEndCalendarValue
      };
    }

    var DatetimerangePanel = vue.defineComponent({
      name: "DateTimeRangePanel",
      props: useDualCalendarProps,
      setup(props) {
        {
          vue.watchEffect(() => {
            if (props.actions?.includes("now")) {
              warnOnce(
                "date-picker",
                "The `now` action is not supported for n-date-picker of `datetimerange` type"
              );
            }
          });
        }
        return useDualCalendar(props, "datetimerange");
      },
      render() {
        const {
          mergedClsPrefix,
          mergedTheme,
          shortcuts,
          timePickerProps,
          onRender
        } = this;
        onRender?.();
        return /* @__PURE__ */ vue.h("div", {
          ref: "selfRef",
          tabindex: 0,
          class: [
            `${mergedClsPrefix}-date-panel`,
            `${mergedClsPrefix}-date-panel--datetimerange`,
            !this.panel && `${mergedClsPrefix}-date-panel--shadow`,
            this.themeClass
          ],
          onKeydown: this.handlePanelKeyDown,
          onFocus: this.handlePanelFocus
        }, /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-header`
        }, /* @__PURE__ */ vue.h(NInput, {
          value: this.startDateDisplayString,
          theme: mergedTheme.peers.Input,
          themeOverrides: mergedTheme.peerOverrides.Input,
          size: this.timePickerSize,
          stateful: false,
          class: `${mergedClsPrefix}-date-panel-date-input`,
          textDecoration: this.isStartValueInvalid ? "line-through" : "",
          placeholder: this.locale.selectDate,
          onBlur: this.handleStartDateInputBlur,
          onUpdateValue: this.handleStartDateInput
        }), /* @__PURE__ */ vue.h(NTimePicker, {
          placeholder: this.locale.selectTime,
          format: this.timeFormat,
          size: this.timePickerSize,
          ...Array.isArray(timePickerProps) ? timePickerProps[0] : timePickerProps,
          value: this.startTimeValue,
          to: false,
          showIcon: false,
          disabled: this.isSelecting,
          theme: mergedTheme.peers.TimePicker,
          themeOverrides: mergedTheme.peerOverrides.TimePicker,
          stateful: false,
          isHourDisabled: this.isStartHourDisabled,
          isMinuteDisabled: this.isStartMinuteDisabled,
          isSecondDisabled: this.isStartSecondDisabled,
          onUpdateValue: this.handleStartTimePickerChange
        }), /* @__PURE__ */ vue.h(NInput, {
          value: this.endDateInput,
          theme: mergedTheme.peers.Input,
          themeOverrides: mergedTheme.peerOverrides.Input,
          stateful: false,
          size: this.timePickerSize,
          class: `${mergedClsPrefix}-date-panel-date-input`,
          textDecoration: this.isEndValueInvalid ? "line-through" : "",
          placeholder: this.locale.selectDate,
          onBlur: this.handleEndDateInputBlur,
          onUpdateValue: this.handleEndDateInput
        }), /* @__PURE__ */ vue.h(NTimePicker, {
          placeholder: this.locale.selectTime,
          format: this.timeFormat,
          size: this.timePickerSize,
          ...Array.isArray(timePickerProps) ? timePickerProps[1] : timePickerProps,
          disabled: this.isSelecting,
          showIcon: false,
          theme: mergedTheme.peers.TimePicker,
          themeOverrides: mergedTheme.peerOverrides.TimePicker,
          to: false,
          stateful: false,
          value: this.endTimeValue,
          isHourDisabled: this.isEndHourDisabled,
          isMinuteDisabled: this.isEndMinuteDisabled,
          isSecondDisabled: this.isEndSecondDisabled,
          onUpdateValue: this.handleEndTimePickerChange
        })), /* @__PURE__ */ vue.h("div", {
          ref: "startDatesElRef",
          class: `${mergedClsPrefix}-date-panel-calendar ${mergedClsPrefix}-date-panel-calendar--start`
        }, /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-month`
        }, /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-month__fast-prev`,
          onClick: this.startCalendarPrevYear
        }, /* @__PURE__ */ vue.h(FastBackwardIcon, null)), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-month__prev`,
          onClick: this.startCalendarPrevMonth
        }, /* @__PURE__ */ vue.h(BackwardIcon, null)), /* @__PURE__ */ vue.h(PanelHeader, {
          monthBeforeYear: this.locale.monthBeforeYear,
          value: this.startCalendarDateTime,
          onUpdateValue: this.onUpdateStartCalendarValue,
          mergedClsPrefix,
          calendarMonth: this.startCalendarMonth,
          calendarYear: this.startCalendarYear
        }), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-month__next`,
          onClick: this.startCalendarNextMonth
        }, /* @__PURE__ */ vue.h(ForwardIcon, null)), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-month__fast-next`,
          onClick: this.startCalendarNextYear
        }, /* @__PURE__ */ vue.h(FastForwardIcon, null))), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-weekdays`
        }, this.weekdays.map((weekday) => /* @__PURE__ */ vue.h("div", {
          key: weekday,
          class: `${mergedClsPrefix}-date-panel-weekdays__day`
        }, weekday))), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel__divider`
        }), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-dates`
        }, this.startDateArray.map((dateItem, i) => {
          const disabled = this.mergedIsDateDisabled(dateItem.ts);
          return /* @__PURE__ */ vue.h("div", {
            "data-n-date": true,
            key: i,
            class: [
              `${mergedClsPrefix}-date-panel-date`,
              {
                [`${mergedClsPrefix}-date-panel-date--excluded`]: !dateItem.inCurrentMonth,
                [`${mergedClsPrefix}-date-panel-date--current`]: dateItem.isCurrentDate,
                [`${mergedClsPrefix}-date-panel-date--selected`]: dateItem.selected,
                [`${mergedClsPrefix}-date-panel-date--covered`]: dateItem.inSpan,
                [`${mergedClsPrefix}-date-panel-date--start`]: dateItem.startOfSpan,
                [`${mergedClsPrefix}-date-panel-date--end`]: dateItem.endOfSpan,
                [`${mergedClsPrefix}-date-panel-date--disabled`]: disabled
              }
            ],
            onClick: disabled ? void 0 : () => this.handleDateClick(dateItem),
            onMouseenter: disabled ? void 0 : () => this.handleDateMouseEnter(dateItem)
          }, /* @__PURE__ */ vue.h("div", {
            class: `${mergedClsPrefix}-date-panel-date__trigger`
          }), dateItem.dateObject.date, dateItem.isCurrentDate ? /* @__PURE__ */ vue.h("div", {
            class: `${mergedClsPrefix}-date-panel-date__sup`
          }) : null);
        }))), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel__vertical-divider`
        }), /* @__PURE__ */ vue.h("div", {
          ref: "endDatesElRef",
          class: `${mergedClsPrefix}-date-panel-calendar ${mergedClsPrefix}-date-panel-calendar--end`
        }, /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-month`
        }, /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-month__fast-prev`,
          onClick: this.endCalendarPrevYear
        }, /* @__PURE__ */ vue.h(FastBackwardIcon, null)), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-month__prev`,
          onClick: this.endCalendarPrevMonth
        }, /* @__PURE__ */ vue.h(BackwardIcon, null)), /* @__PURE__ */ vue.h(PanelHeader, {
          monthBeforeYear: this.locale.monthBeforeYear,
          value: this.endCalendarDateTime,
          onUpdateValue: this.onUpdateEndCalendarValue,
          mergedClsPrefix,
          calendarMonth: this.endCalendarMonth,
          calendarYear: this.endCalendarYear
        }), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-month__next`,
          onClick: this.endCalendarNextMonth
        }, /* @__PURE__ */ vue.h(ForwardIcon, null)), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-month__fast-next`,
          onClick: this.endCalendarNextYear
        }, /* @__PURE__ */ vue.h(FastForwardIcon, null))), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-weekdays`
        }, this.weekdays.map((weekday) => /* @__PURE__ */ vue.h("div", {
          key: weekday,
          class: `${mergedClsPrefix}-date-panel-weekdays__day`
        }, weekday))), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel__divider`
        }), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-dates`
        }, this.endDateArray.map((dateItem, i) => {
          const disabled = this.mergedIsDateDisabled(dateItem.ts);
          return /* @__PURE__ */ vue.h("div", {
            "data-n-date": true,
            key: i,
            class: [
              `${mergedClsPrefix}-date-panel-date`,
              {
                [`${mergedClsPrefix}-date-panel-date--excluded`]: !dateItem.inCurrentMonth,
                [`${mergedClsPrefix}-date-panel-date--current`]: dateItem.isCurrentDate,
                [`${mergedClsPrefix}-date-panel-date--selected`]: dateItem.selected,
                [`${mergedClsPrefix}-date-panel-date--covered`]: dateItem.inSpan,
                [`${mergedClsPrefix}-date-panel-date--start`]: dateItem.startOfSpan,
                [`${mergedClsPrefix}-date-panel-date--end`]: dateItem.endOfSpan,
                [`${mergedClsPrefix}-date-panel-date--disabled`]: disabled
              }
            ],
            onClick: disabled ? void 0 : () => this.handleDateClick(dateItem),
            onMouseenter: disabled ? void 0 : () => this.handleDateMouseEnter(dateItem)
          }, /* @__PURE__ */ vue.h("div", {
            class: `${mergedClsPrefix}-date-panel-date__trigger`
          }), dateItem.dateObject.date, dateItem.isCurrentDate ? /* @__PURE__ */ vue.h("div", {
            class: `${mergedClsPrefix}-date-panel-date__sup`
          }) : null);
        }))), this.datePickerSlots.footer ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-footer`
        }, this.datePickerSlots.footer()) : null, this.actions?.length || shortcuts ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-actions`
        }, /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-actions__prefix`
        }, shortcuts && Object.keys(shortcuts).map((key) => {
          const shortcut = shortcuts[key];
          return Array.isArray(shortcut) || typeof shortcut === "function" ? /* @__PURE__ */ vue.h(XButton, {
            size: "tiny",
            onMouseenter: () => {
              this.handleRangeShortcutMouseenter(shortcut);
            },
            onClick: () => {
              this.handleRangeShortcutClick(shortcut);
            },
            onMouseleave: () => {
              this.handleShortcutMouseleave();
            }
          }, { default: () => key }) : null;
        })), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-actions__suffix`
        }, this.actions?.includes("clear") ? /* @__PURE__ */ vue.h(NButton, {
          theme: mergedTheme.peers.Button,
          themeOverrides: mergedTheme.peerOverrides.Button,
          size: "tiny",
          onClick: this.handleClearClick
        }, { default: () => this.locale.clear }) : null, this.actions?.includes("confirm") ? /* @__PURE__ */ vue.h(NButton, {
          theme: mergedTheme.peers.Button,
          themeOverrides: mergedTheme.peerOverrides.Button,
          size: "tiny",
          type: "primary",
          disabled: this.isRangeInvalid || this.isSelecting,
          onClick: this.handleConfirmClick
        }, { default: () => this.locale.confirm }) : null)) : null, /* @__PURE__ */ vue.h(FocusDetector, {
          onFocus: this.handleFocusDetectorFocus
        }));
      }
    });

    var DatePanel = vue.defineComponent({
      name: "DatePanel",
      props: useCalendarProps,
      setup(props) {
        {
          vue.watchEffect(() => {
            if (props.actions?.includes("confirm")) {
              warnOnce(
                "date-picker",
                "The `confirm` action is not supported for n-date-picker of `date` type"
              );
            }
          });
        }
        return useCalendar(props, "date");
      },
      render() {
        const { mergedClsPrefix, mergedTheme, shortcuts, onRender } = this;
        onRender?.();
        return /* @__PURE__ */ vue.h("div", {
          ref: "selfRef",
          tabindex: 0,
          class: [
            `${mergedClsPrefix}-date-panel`,
            `${mergedClsPrefix}-date-panel--date`,
            !this.panel && `${mergedClsPrefix}-date-panel--shadow`,
            this.themeClass
          ],
          onFocus: this.handlePanelFocus,
          onKeydown: this.handlePanelKeyDown
        }, /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-calendar`
        }, /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-month`
        }, /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-month__fast-prev`,
          onClick: this.prevYear
        }, /* @__PURE__ */ vue.h(FastBackwardIcon, null)), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-month__prev`,
          onClick: this.prevMonth
        }, /* @__PURE__ */ vue.h(BackwardIcon, null)), /* @__PURE__ */ vue.h(PanelHeader, {
          monthBeforeYear: this.locale.monthBeforeYear,
          value: this.calendarValue,
          onUpdateValue: this.onUpdateCalendarValue,
          mergedClsPrefix,
          calendarMonth: this.calendarMonth,
          calendarYear: this.calendarYear
        }), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-month__next`,
          onClick: this.nextMonth
        }, /* @__PURE__ */ vue.h(ForwardIcon, null)), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-month__fast-next`,
          onClick: this.nextYear
        }, /* @__PURE__ */ vue.h(FastForwardIcon, null))), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-weekdays`
        }, this.weekdays.map((weekday) => /* @__PURE__ */ vue.h("div", {
          key: weekday,
          class: `${mergedClsPrefix}-date-panel-weekdays__day`
        }, weekday))), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-dates`
        }, this.dateArray.map((dateItem, i) => /* @__PURE__ */ vue.h("div", {
          "data-n-date": true,
          key: i,
          class: [
            `${mergedClsPrefix}-date-panel-date`,
            {
              [`${mergedClsPrefix}-date-panel-date--current`]: dateItem.isCurrentDate,
              [`${mergedClsPrefix}-date-panel-date--selected`]: dateItem.selected,
              [`${mergedClsPrefix}-date-panel-date--excluded`]: !dateItem.inCurrentMonth,
              [`${mergedClsPrefix}-date-panel-date--disabled`]: this.mergedIsDateDisabled(dateItem.ts)
            }
          ],
          onClick: () => this.handleDateClick(dateItem)
        }, /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-date__trigger`
        }), dateItem.dateObject.date, dateItem.isCurrentDate ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-date__sup`
        }) : null)))), this.datePickerSlots.footer ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-footer`
        }, this.datePickerSlots.footer()) : null, this.actions?.length || shortcuts ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-actions`
        }, /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-actions__prefix`
        }, shortcuts && Object.keys(shortcuts).map((key) => {
          const shortcut = shortcuts[key];
          return Array.isArray(shortcut) ? null : /* @__PURE__ */ vue.h(XButton, {
            size: "tiny",
            onMouseenter: () => {
              this.handleSingleShortcutMouseenter(shortcut);
            },
            onClick: () => {
              this.handleSingleShortcutClick(shortcut);
            },
            onMouseleave: () => {
              this.handleShortcutMouseleave();
            }
          }, { default: () => key });
        })), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-actions__suffix`
        }, this.actions?.includes("clear") ? /* @__PURE__ */ vue.h(NButton, {
          theme: mergedTheme.peers.Button,
          themeOverrides: mergedTheme.peerOverrides.Button,
          size: "tiny",
          onClick: this.handleClearClick
        }, { default: () => this.locale.clear }) : null, this.actions?.includes("now") ? /* @__PURE__ */ vue.h(NButton, {
          theme: mergedTheme.peers.Button,
          themeOverrides: mergedTheme.peerOverrides.Button,
          size: "tiny",
          onClick: this.handleNowClick
        }, { default: () => this.locale.now }) : null)) : null, /* @__PURE__ */ vue.h(FocusDetector, {
          onFocus: this.handleFocusDetectorFocus
        }));
      }
    });

    var DaterangePanel = vue.defineComponent({
      name: "DateRangePanel",
      props: useDualCalendarProps,
      setup(props) {
        {
          vue.watchEffect(() => {
            if (props.actions?.includes("now")) {
              warnOnce(
                "date-picker",
                "The `now` action is not supported for n-date-picker of `daterange` type"
              );
            }
          });
        }
        return useDualCalendar(props, "daterange");
      },
      render() {
        const { mergedClsPrefix, mergedTheme, shortcuts, onRender } = this;
        onRender?.();
        return /* @__PURE__ */ vue.h("div", {
          ref: "selfRef",
          tabindex: 0,
          class: [
            `${mergedClsPrefix}-date-panel`,
            `${mergedClsPrefix}-date-panel--daterange`,
            !this.panel && `${mergedClsPrefix}-date-panel--shadow`,
            this.themeClass
          ],
          onKeydown: this.handlePanelKeyDown,
          onFocus: this.handlePanelFocus
        }, /* @__PURE__ */ vue.h("div", {
          ref: "startDatesElRef",
          class: `${mergedClsPrefix}-date-panel-calendar ${mergedClsPrefix}-date-panel-calendar--start`
        }, /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-month`
        }, /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-month__fast-prev`,
          onClick: this.startCalendarPrevYear
        }, /* @__PURE__ */ vue.h(FastBackwardIcon, null)), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-month__prev`,
          onClick: this.startCalendarPrevMonth
        }, /* @__PURE__ */ vue.h(BackwardIcon, null)), /* @__PURE__ */ vue.h(PanelHeader, {
          monthBeforeYear: this.locale.monthBeforeYear,
          value: this.startCalendarDateTime,
          onUpdateValue: this.onUpdateStartCalendarValue,
          mergedClsPrefix,
          calendarMonth: this.startCalendarMonth,
          calendarYear: this.startCalendarYear
        }), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-month__next`,
          onClick: this.startCalendarNextMonth
        }, /* @__PURE__ */ vue.h(ForwardIcon, null)), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-month__fast-next`,
          onClick: this.startCalendarNextYear
        }, /* @__PURE__ */ vue.h(FastForwardIcon, null))), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-weekdays`
        }, this.weekdays.map((weekday) => /* @__PURE__ */ vue.h("div", {
          key: weekday,
          class: `${mergedClsPrefix}-date-panel-weekdays__day`
        }, weekday))), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel__divider`
        }), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-dates`
        }, this.startDateArray.map((dateItem, i) => /* @__PURE__ */ vue.h("div", {
          "data-n-date": true,
          key: i,
          class: [
            `${mergedClsPrefix}-date-panel-date`,
            {
              [`${mergedClsPrefix}-date-panel-date--excluded`]: !dateItem.inCurrentMonth,
              [`${mergedClsPrefix}-date-panel-date--current`]: dateItem.isCurrentDate,
              [`${mergedClsPrefix}-date-panel-date--selected`]: dateItem.selected,
              [`${mergedClsPrefix}-date-panel-date--covered`]: dateItem.inSpan,
              [`${mergedClsPrefix}-date-panel-date--start`]: dateItem.startOfSpan,
              [`${mergedClsPrefix}-date-panel-date--end`]: dateItem.endOfSpan,
              [`${mergedClsPrefix}-date-panel-date--disabled`]: this.mergedIsDateDisabled(dateItem.ts)
            }
          ],
          onClick: () => this.handleDateClick(dateItem),
          onMouseenter: () => this.handleDateMouseEnter(dateItem)
        }, /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-date__trigger`
        }), dateItem.dateObject.date, dateItem.isCurrentDate ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-date__sup`
        }) : null)))), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel__vertical-divider`
        }), /* @__PURE__ */ vue.h("div", {
          ref: "endDatesElRef",
          class: `${mergedClsPrefix}-date-panel-calendar ${mergedClsPrefix}-date-panel-calendar--end`
        }, /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-month`
        }, /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-month__fast-prev`,
          onClick: this.endCalendarPrevYear
        }, /* @__PURE__ */ vue.h(FastBackwardIcon, null)), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-month__prev`,
          onClick: this.endCalendarPrevMonth
        }, /* @__PURE__ */ vue.h(BackwardIcon, null)), /* @__PURE__ */ vue.h(PanelHeader, {
          monthBeforeYear: this.locale.monthBeforeYear,
          value: this.endCalendarDateTime,
          onUpdateValue: this.onUpdateEndCalendarValue,
          mergedClsPrefix,
          calendarMonth: this.endCalendarMonth,
          calendarYear: this.endCalendarYear
        }), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-month__next`,
          onClick: this.endCalendarNextMonth
        }, /* @__PURE__ */ vue.h(ForwardIcon, null)), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-month__fast-next`,
          onClick: this.endCalendarNextYear
        }, /* @__PURE__ */ vue.h(FastForwardIcon, null))), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-weekdays`
        }, this.weekdays.map((weekday) => /* @__PURE__ */ vue.h("div", {
          key: weekday,
          class: `${mergedClsPrefix}-date-panel-weekdays__day`
        }, weekday))), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel__divider`
        }), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-dates`
        }, this.endDateArray.map((dateItem, i) => /* @__PURE__ */ vue.h("div", {
          "data-n-date": true,
          key: i,
          class: [
            `${mergedClsPrefix}-date-panel-date`,
            {
              [`${mergedClsPrefix}-date-panel-date--excluded`]: !dateItem.inCurrentMonth,
              [`${mergedClsPrefix}-date-panel-date--current`]: dateItem.isCurrentDate,
              [`${mergedClsPrefix}-date-panel-date--selected`]: dateItem.selected,
              [`${mergedClsPrefix}-date-panel-date--covered`]: dateItem.inSpan,
              [`${mergedClsPrefix}-date-panel-date--start`]: dateItem.startOfSpan,
              [`${mergedClsPrefix}-date-panel-date--end`]: dateItem.endOfSpan,
              [`${mergedClsPrefix}-date-panel-date--disabled`]: this.mergedIsDateDisabled(dateItem.ts)
            }
          ],
          onClick: () => this.handleDateClick(dateItem),
          onMouseenter: () => this.handleDateMouseEnter(dateItem)
        }, /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-date__trigger`
        }), dateItem.dateObject.date, dateItem.isCurrentDate ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-date__sup`
        }) : null)))), this.datePickerSlots.footer ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-footer`
        }, this.datePickerSlots.footer()) : null, this.actions?.length || shortcuts ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-actions`
        }, /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-actions__prefix`
        }, shortcuts && Object.keys(shortcuts).map((key) => {
          const shortcut = shortcuts[key];
          return Array.isArray(shortcut) || typeof shortcut === "function" ? /* @__PURE__ */ vue.h(XButton, {
            size: "tiny",
            onMouseenter: () => {
              this.handleRangeShortcutMouseenter(shortcut);
            },
            onClick: () => {
              this.handleRangeShortcutClick(shortcut);
            },
            onMouseleave: () => {
              this.handleShortcutMouseleave();
            }
          }, { default: () => key }) : null;
        })), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-actions__suffix`
        }, this.actions?.includes("clear") ? /* @__PURE__ */ vue.h(NButton, {
          theme: mergedTheme.peers.Button,
          themeOverrides: mergedTheme.peerOverrides.Button,
          size: "tiny",
          onClick: this.handleClearClick
        }, { default: () => this.locale.clear }) : null, this.actions?.includes("confirm") ? /* @__PURE__ */ vue.h(NButton, {
          theme: mergedTheme.peers.Button,
          themeOverrides: mergedTheme.peerOverrides.Button,
          size: "tiny",
          type: "primary",
          disabled: this.isRangeInvalid || this.isSelecting,
          onClick: this.handleConfirmClick
        }, { default: () => this.locale.confirm }) : null)) : null, /* @__PURE__ */ vue.h(FocusDetector, {
          onFocus: this.handleFocusDetectorFocus
        }));
      }
    });

    var MonthRangePanel = vue.defineComponent({
      name: "MonthRangePanel",
      props: {
        ...useDualCalendarProps,
        type: {
          type: String,
          required: true
        }
      },
      setup(props) {
        {
          vue.watchEffect(() => {
            if (props.actions?.includes("now")) {
              warnOnce(
                "date-picker",
                `The \`now\` action is not supported for n-date-picker of ${props.type}type`
              );
            }
          });
        }
        const useCalendarRef = useDualCalendar(props, props.type);
        const renderItem = (item, i, mergedClsPrefix, type) => {
          const { handleColItemClick } = useCalendarRef;
          const disabled = false;
          return /* @__PURE__ */ vue.h("div", {
            "data-n-date": true,
            key: i,
            class: [
              `${mergedClsPrefix}-date-panel-month-calendar__picker-col-item`,
              {
                [`${mergedClsPrefix}-date-panel-month-calendar__picker-col-item--current`]: item.isCurrent,
                [`${mergedClsPrefix}-date-panel-month-calendar__picker-col-item--selected`]: item.selected,
                [`${mergedClsPrefix}-date-panel-month-calendar__picker-col-item--disabled`]: disabled
              }
            ],
            onClick: () => {
              handleColItemClick(item, type);
            }
          }, item.type === "month" ? item.dateObject.month + 1 : item.type === "quarter" ? `Q${item.dateObject.quarter}` : item.dateObject.year);
        };
        vue.onMounted(() => {
          useCalendarRef.justifyColumnsScrollState();
        });
        return { ...useCalendarRef, renderItem };
      },
      render() {
        const { mergedClsPrefix, mergedTheme, shortcuts, type, renderItem } = this;
        return /* @__PURE__ */ vue.h("div", {
          ref: "selfRef",
          tabindex: 0,
          class: [
            `${mergedClsPrefix}-date-panel`,
            `${mergedClsPrefix}-date-panel--daterange`,
            !this.panel && `${mergedClsPrefix}-date-panel--shadow`
          ],
          onKeydown: this.handlePanelKeyDown,
          onFocus: this.handlePanelFocus
        }, /* @__PURE__ */ vue.h("div", {
          ref: "startDatesElRef",
          class: `${mergedClsPrefix}-date-panel-calendar ${mergedClsPrefix}-date-panel-calendar--start`
        }, /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-month-calendar`
        }, /* @__PURE__ */ vue.h(NScrollbar, {
          ref: "startYearScrollbarRef",
          class: `${mergedClsPrefix}-date-panel-month-calendar__picker-col`,
          theme: mergedTheme.peers.Scrollbar,
          themeOverrides: mergedTheme.peerOverrides.Scrollbar,
          container: () => this.virtualListContainer("start"),
          content: () => this.virtualListContent("start"),
          horizontalRailStyle: { zIndex: 1 },
          verticalRailStyle: { zIndex: 1 }
        }, {
          default: () => /* @__PURE__ */ vue.h(VVirtualList, {
            ref: "startYearVlRef",
            items: this.startYearArray,
            itemSize: MONTH_ITEM_HEIGHT,
            showScrollbar: false,
            keyField: "ts",
            onScroll: this.handleStartYearVlScroll,
            paddingBottom: 4
          }, {
            default: ({
              item,
              index
            }) => {
              return renderItem(item, index, mergedClsPrefix, "start");
            }
          })
        }), type === "monthrange" || type === "quarterrange" ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-month-calendar__picker-col`
        }, /* @__PURE__ */ vue.h(NScrollbar, {
          ref: "startMonthScrollbarRef",
          theme: mergedTheme.peers.Scrollbar,
          themeOverrides: mergedTheme.peerOverrides.Scrollbar
        }, {
          default: () => [
            (type === "monthrange" ? this.startMonthArray : this.startQuarterArray).map(
              (item, i) => renderItem(item, i, mergedClsPrefix, "start")
            ),
            type === "monthrange" && /* @__PURE__ */ vue.h("div", {
              class: `${mergedClsPrefix}-date-panel-month-calendar__padding`
            })
          ]
        })) : null)), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel__vertical-divider`
        }), /* @__PURE__ */ vue.h("div", {
          ref: "endDatesElRef",
          class: `${mergedClsPrefix}-date-panel-calendar ${mergedClsPrefix}-date-panel-calendar--end`
        }, /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-month-calendar`
        }, /* @__PURE__ */ vue.h(NScrollbar, {
          ref: "endYearScrollbarRef",
          class: `${mergedClsPrefix}-date-panel-month-calendar__picker-col`,
          theme: mergedTheme.peers.Scrollbar,
          themeOverrides: mergedTheme.peerOverrides.Scrollbar,
          container: () => this.virtualListContainer("end"),
          content: () => this.virtualListContent("end"),
          horizontalRailStyle: { zIndex: 1 },
          verticalRailStyle: { zIndex: 1 }
        }, {
          default: () => /* @__PURE__ */ vue.h(VVirtualList, {
            ref: "endYearVlRef",
            items: this.endYearArray,
            itemSize: MONTH_ITEM_HEIGHT,
            showScrollbar: false,
            keyField: "ts",
            onScroll: this.handleEndYearVlScroll,
            paddingBottom: 4
          }, {
            default: ({
              item,
              index
            }) => {
              return renderItem(item, index, mergedClsPrefix, "end");
            }
          })
        }), type === "monthrange" || type === "quarterrange" ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-month-calendar__picker-col`
        }, /* @__PURE__ */ vue.h(NScrollbar, {
          ref: "endMonthScrollbarRef",
          theme: mergedTheme.peers.Scrollbar,
          themeOverrides: mergedTheme.peerOverrides.Scrollbar
        }, {
          default: () => [
            (type === "monthrange" ? this.endMonthArray : this.endQuarterArray).map(
              (item, i) => renderItem(item, i, mergedClsPrefix, "end")
            ),
            type === "monthrange" && /* @__PURE__ */ vue.h("div", {
              class: `${mergedClsPrefix}-date-panel-month-calendar__padding`
            })
          ]
        })) : null)), this.datePickerSlots.footer ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-footer`
        }, vue.renderSlot(this.datePickerSlots, "footer")) : null, this.actions?.length || shortcuts ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-actions`
        }, /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-actions__prefix`
        }, shortcuts && Object.keys(shortcuts).map((key) => {
          const shortcut = shortcuts[key];
          return Array.isArray(shortcut) || typeof shortcut === "function" ? /* @__PURE__ */ vue.h(XButton, {
            size: "tiny",
            onMouseenter: () => {
              this.handleRangeShortcutMouseenter(shortcut);
            },
            onClick: () => {
              this.handleRangeShortcutClick(shortcut);
            },
            onMouseleave: () => {
              this.handleShortcutMouseleave();
            }
          }, { default: () => key }) : null;
        })), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-actions__suffix`
        }, this.actions?.includes("clear") ? /* @__PURE__ */ vue.h(XButton, {
          theme: mergedTheme.peers.Button,
          themeOverrides: mergedTheme.peerOverrides.Button,
          size: "tiny",
          onClick: this.handleClearClick
        }, { default: () => this.locale.clear }) : null, this.actions?.includes("confirm") ? /* @__PURE__ */ vue.h(XButton, {
          theme: mergedTheme.peers.Button,
          themeOverrides: mergedTheme.peerOverrides.Button,
          size: "tiny",
          type: "primary",
          disabled: this.isRangeInvalid,
          onClick: this.handleConfirmClick
        }, { default: () => this.locale.confirm }) : null)) : null, /* @__PURE__ */ vue.h(FocusDetector, {
          onFocus: this.handleFocusDetectorFocus
        }));
      }
    });

    var style$R = c$1([cB("date-picker", `
    position: relative;
    z-index: auto;
  `, [cB("date-picker-icon", `
      color: var(--n-icon-color-override);
      transition: color .3s var(--n-bezier);
    `), cB("icon", `
      color: var(--n-icon-color-override);
      transition: color .3s var(--n-bezier);
    `), cM("disabled", [cB("date-picker-icon", `
        color: var(--n-icon-color-disabled-override);
      `), cB("icon", `
        color: var(--n-icon-color-disabled-override);
      `)])]), cB("date-panel", `
    width: fit-content;
    outline: none;
    margin: 4px 0;
    display: grid;
    grid-template-columns: 0fr;
    border-radius: var(--n-panel-border-radius);
    background-color: var(--n-panel-color);
    color: var(--n-panel-text-color);
  `, [fadeInScaleUpTransition(), cM("shadow", `
      box-shadow: var(--n-panel-box-shadow);
    `), cB("date-panel-calendar", {
      padding: "var(--n-calendar-left-padding)",
      display: "grid",
      gridTemplateColumns: "1fr",
      gridArea: "left-calendar"
    }, [cM("end", {
      padding: "var(--n-calendar-right-padding)",
      gridArea: "right-calendar"
    })]), cB("date-panel-month-calendar", {
      display: "flex",
      gridArea: "left-calendar"
    }, [cE("picker-col", `
        min-width: var(--n-scroll-item-width);
        height: calc(var(--n-scroll-item-height) * 6);
        user-select: none;
        -webkit-user-select: none;
      `, [c$1("&:first-child", `
          min-width: calc(var(--n-scroll-item-width) + 4px);
        `, [cE("picker-col-item", [c$1("&::before", "left: 4px;")])]), cE("padding", `
          height: calc(var(--n-scroll-item-height) * 5)
        `)]), cE("picker-col-item", `
        z-index: 0;
        cursor: pointer;
        height: var(--n-scroll-item-height);
        box-sizing: border-box;
        padding-top: 4px;
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
        transition:
          color .3s var(--n-bezier),
          background-color .3s var(--n-bezier);
        background: #0000;
        color: var(--n-item-text-color);
      `, [c$1("&::before", `
          z-index: -1;
          content: "";
          position: absolute;
          left: 0;
          right: 4px;
          top: 4px;
          bottom: 0;
          border-radius: var(--n-scroll-item-border-radius);
          transition:
            background-color .3s var(--n-bezier);
        `), cNotM("disabled", [c$1("&:hover::before", `
            background-color: var(--n-item-color-hover);
          `), cM("selected", `
            color: var(--n-item-color-active);
          `, [c$1("&::before", "background-color: var(--n-item-color-hover);")])]), cM("disabled", `
          color: var(--n-item-text-color-disabled);
          cursor: not-allowed;
        `, [cM("selected", [c$1("&::before", `
              background-color: var(--n-item-color-disabled);
            `)])])])]), cM("date", {
      gridTemplateAreas: `
        "left-calendar"
        "footer"
        "action"
      `
    }), cM("daterange", {
      gridTemplateAreas: `
        "left-calendar divider right-calendar"
        "footer footer footer"
        "action action action"
      `
    }), cM("datetime", {
      gridTemplateAreas: `
        "header"
        "left-calendar"
        "footer"
        "action"
      `
    }), cM("datetimerange", {
      gridTemplateAreas: `
        "header header header"
        "left-calendar divider right-calendar"
        "footer footer footer"
        "action action action"
      `
    }), cM("month", {
      gridTemplateAreas: `
        "left-calendar"
        "footer"
        "action"
      `
    }), cB("date-panel-footer", {
      gridArea: "footer"
    }), cB("date-panel-actions", {
      gridArea: "action"
    }), cB("date-panel-header", {
      gridArea: "header"
    }), cB("date-panel-header", `
      box-sizing: border-box;
      width: 100%;
      align-items: center;
      padding: var(--n-panel-header-padding);
      display: flex;
      justify-content: space-between;
      border-bottom: 1px solid var(--n-panel-header-divider-color);
    `, [c$1(">", [c$1("*:not(:last-child)", {
      marginRight: "10px"
    }), c$1("*", {
      flex: 1,
      width: 0
    }), cB("time-picker", {
      zIndex: 1
    })])]), cB("date-panel-month", `
      box-sizing: border-box;
      display: grid;
      grid-template-columns: var(--n-calendar-title-grid-template-columns);
      align-items: center;
      justify-items: center;
      padding: var(--n-calendar-title-padding);
      height: var(--n-calendar-title-height);
    `, [cE("prev, next, fast-prev, fast-next", `
        line-height: 0;
        cursor: pointer;
        width: var(--n-arrow-size);
        height: var(--n-arrow-size);
        color: var(--n-arrow-color);
      `), cE("month-year", `
        user-select: none;
        -webkit-user-select: none;
        flex-grow: 1;
        position: relative;
      `, [cE("text", `
          font-size: var(--n-calendar-title-font-size);
          line-height: var(--n-calendar-title-font-size);
          font-weight: var(--n-calendar-title-font-weight);
          padding: 6px 8px;
          text-align: center;
          color: var(--n-calendar-title-text-color);
          cursor: pointer;
          transition: background-color .3s var(--n-bezier);
          border-radius: var(--n-panel-border-radius);
        `, [cM("active", `
            background-color: var(--n-calendar-title-color-hover);
          `), c$1("&:hover", `
            background-color: var(--n-calendar-title-color-hover);
          `)])])]), cB("date-panel-weekdays", `
      display: grid;
      margin: auto;
      grid-template-columns: repeat(7, var(--n-item-cell-width));
      grid-template-rows: repeat(1, var(--n-item-cell-height));
      align-items: center;
      justify-items: center;
      margin-bottom: 4px;
      border-bottom: 1px solid var(--n-calendar-days-divider-color);
    `, [cE("day", `
        user-select: none;
        -webkit-user-select: none;
        line-height: 15px;
        width: var(--n-item-size);
        text-align: center;
        font-size: var(--n-calendar-days-font-size);
        color: var(--n-item-text-color);
      `)]), cB("date-panel-dates", `
      margin: auto;
      display: grid;
      grid-template-columns: repeat(7, var(--n-item-cell-width));
      grid-template-rows: repeat(6, var(--n-item-cell-height));
      align-items: center;
      justify-items: center;
      flex-wrap: wrap;
    `, [cB("date-panel-date", `
        user-select: none;
        -webkit-user-select: none;
        position: relative;
        width: var(--n-item-size);
        height: var(--n-item-size);
        line-height: var(--n-item-size);
        text-align: center;
        font-size: var(--n-item-font-size);
        border-radius: var(--n-item-border-radius);
        z-index: 0;
        cursor: pointer;
        transition:
          background-color .2s var(--n-bezier),
          color .2s var(--n-bezier);
      `, [cE("trigger", `
          position: absolute;
          left: calc(var(--n-item-size) / 2 - var(--n-item-cell-width) / 2);
          top: calc(var(--n-item-size) / 2 - var(--n-item-cell-height) / 2);
          width:  var(--n-item-cell-width);
          height:  var(--n-item-cell-height);
        `), cNotM("disabled", [cNotM("selected", [c$1("&:hover", {
      backgroundColor: "var(--n-item-color-hover)"
    })])]), cM("current", [cE("sup", `
            position: absolute;
            top: 2px;
            right: 2px;
            content: "";
            height: 4px;
            width: 4px;
            border-radius: 2px;
            background-color: var(--n-item-color-active);
            transition:
              background-color .2s var(--n-bezier);
          `)]), c$1("&::after", `
          content: "";
          z-index: -1;
          position: absolute;
          left: 0;
          right: 0;
          top: 0;
          bottom: 0;
          border-radius: inherit;
          transition: background-color .3s var(--n-bezier);
        `), cM("covered, start, end", [cNotM("excluded", [c$1("&::before", `
              content: "";
              z-index: -2;
              position: absolute;
              left: calc((var(--n-item-size) - var(--n-item-cell-width)) / 2);
              right: calc((var(--n-item-size) - var(--n-item-cell-width)) / 2);
              top: 0;
              bottom: 0;
              background-color: var(--n-item-color-included);
            `), c$1("&:nth-child(7n + 1)::before", {
      borderTopLeftRadius: "var(--n-item-border-radius)",
      borderBottomLeftRadius: "var(--n-item-border-radius)"
    }), c$1("&:nth-child(7n + 7)::before", {
      borderTopRightRadius: "var(--n-item-border-radius)",
      borderBottomRightRadius: "var(--n-item-border-radius)"
    })])]), cM("selected", {
      color: "var(--n-item-text-color-active)"
    }, [c$1("&::after", {
      backgroundColor: "var(--n-item-color-active)"
    }), cM("start", [c$1("&::before", {
      left: "50%"
    })]), cM("end", [c$1("&::before", {
      right: "50%"
    })]), cE("sup", {
      backgroundColor: "var(--n-panel-color)"
    })]), cM("excluded", {
      color: "var(--n-item-text-color-disabled)"
    }, [cM("selected", [c$1("&::after", {
      backgroundColor: "var(--n-item-color-disabled)"
    })])]), cM("disabled", {
      cursor: "not-allowed",
      color: "var(--n-item-text-color-disabled)"
    }, [cM("covered", [c$1("&::before", {
      backgroundColor: "var(--n-item-color-disabled)"
    })]), cM("selected", [c$1("&::before", {
      backgroundColor: "var(--n-item-color-disabled)"
    }), c$1("&::after", {
      backgroundColor: "var(--n-item-color-disabled)"
    })])])])]), cE("vertical-divider", `
      grid-area: divider;
      height: 100%;
      width: 1px;
      background-color: var(--n-calendar-divider-color);
    `), cB("date-panel-footer", {
      borderTop: "1px solid var(--n-panel-action-divider-color)",
      padding: "var(--n-panel-extra-footer-padding)"
    }), cB("date-panel-actions", `
      flex: 1;
      padding: var(--n-panel-action-padding);
      display: flex;
      align-items: center;
      justify-content: space-between;
      border-top: 1px solid var(--n-panel-action-divider-color);
    `, [cE("prefix, suffix", `
        display: flex;
        margin-bottom: -8px;
      `), cE("suffix", `
        align-self: flex-end;
      `), cE("prefix", `
        flex-wrap: wrap;
      `), cB("button", `
        margin-bottom: 8px;
      `, [c$1("&:not(:last-child)", `
          margin-right: 8px;
        `)])])]), c$1("[data-n-date].transition-disabled", {
      transition: "none !important"
    }, [c$1("&::before, &::after", {
      transition: "none !important"
    })])]);

    const datePickerProps = {
      ...useTheme.props,
      to: useAdjustedTo.propTo,
      bordered: {
        type: Boolean,
        default: void 0
      },
      clearable: Boolean,
      updateValueOnClose: Boolean,
      defaultValue: [Number, Array],
      defaultFormattedValue: [String, Array],
      defaultTime: [Number, String, Array],
      disabled: {
        type: Boolean,
        default: void 0
      },
      placement: {
        type: String,
        default: "bottom-start"
      },
      value: [Number, Array],
      formattedValue: [String, Array],
      size: String,
      type: {
        type: String,
        default: "date"
      },
      valueFormat: String,
      separator: String,
      placeholder: String,
      startPlaceholder: String,
      endPlaceholder: String,
      format: String,
      dateFormat: String,
      timeFormat: String,
      actions: Array,
      shortcuts: Object,
      isDateDisabled: Function,
      isTimeDisabled: Function,
      show: {
        type: Boolean,
        default: void 0
      },
      panel: Boolean,
      ranges: Object,
      firstDayOfWeek: Number,
      inputReadonly: Boolean,
      closeOnSelect: Boolean,
      status: String,
      timePickerProps: [Object, Array],
      onClear: Function,
      onConfirm: Function,
      defaultCalendarStartTime: Number,
      defaultCalendarEndTime: Number,
      bindCalendarMonths: Boolean,
      "onUpdate:show": [Function, Array],
      onUpdateShow: [Function, Array],
      "onUpdate:formattedValue": [Function, Array],
      onUpdateFormattedValue: [Function, Array],
      "onUpdate:value": [Function, Array],
      onUpdateValue: [Function, Array],
      onFocus: [Function, Array],
      onBlur: [Function, Array],
      onChange: [Function, Array]
    };
    var DatePicker = vue.defineComponent({
      name: "DatePicker",
      props: datePickerProps,
      setup(props, { slots }) {
        {
          vue.watchEffect(() => {
            if (props.onChange !== void 0) {
              warnOnce(
                "data-picker",
                "`on-change` is deprecated, please use `on-update:value` instead."
              );
            }
          });
        }
        const { localeRef, dateLocaleRef } = useLocale("DatePicker");
        const formItem = useFormItem(props);
        const { mergedSizeRef, mergedDisabledRef, mergedStatusRef } = formItem;
        const {
          mergedComponentPropsRef,
          mergedClsPrefixRef,
          mergedBorderedRef,
          namespaceRef,
          inlineThemeDisabled
        } = useConfig(props);
        const panelInstRef = vue.ref(null);
        const triggerElRef = vue.ref(null);
        const inputInstRef = vue.ref(null);
        const uncontrolledShowRef = vue.ref(false);
        const controlledShowRef = vue.toRef(props, "show");
        const mergedShowRef = useMergedState(controlledShowRef, uncontrolledShowRef);
        const dateFnsOptionsRef = vue.computed(() => {
          return {
            locale: dateLocaleRef.value.locale
          };
        });
        const mergedFormatRef = vue.computed(() => {
          const { format: format2 } = props;
          if (format2)
            return format2;
          switch (props.type) {
            case "date":
            case "daterange":
              return localeRef.value.dateFormat;
            case "datetime":
            case "datetimerange":
              return localeRef.value.dateTimeFormat;
            case "year":
            case "yearrange":
              return localeRef.value.yearTypeFormat;
            case "month":
            case "monthrange":
              return localeRef.value.monthTypeFormat;
            case "quarter":
            case "quarterrange":
              return localeRef.value.quarterFormat;
          }
        });
        const mergedValueFormatRef = vue.computed(() => {
          return props.valueFormat ?? mergedFormatRef.value;
        });
        function getTimestampValue(value) {
          if (value === null)
            return null;
          const { value: mergedValueFormat } = mergedValueFormatRef;
          const { value: dateFnsOptions } = dateFnsOptionsRef;
          if (Array.isArray(value)) {
            return [
              strictParse(
                value[0],
                mergedValueFormat,
                new Date(),
                dateFnsOptions
              ).getTime(),
              strictParse(
                value[1],
                mergedValueFormat,
                new Date(),
                dateFnsOptions
              ).getTime()
            ];
          }
          return strictParse(
            value,
            mergedValueFormat,
            new Date(),
            dateFnsOptions
          ).getTime();
        }
        const { defaultFormattedValue, defaultValue } = props;
        const uncontrolledValueRef = vue.ref(
          (defaultFormattedValue !== void 0 ? getTimestampValue(defaultFormattedValue) : defaultValue) ?? null
        );
        const controlledValueRef = vue.computed(() => {
          const { formattedValue } = props;
          if (formattedValue !== void 0) {
            return getTimestampValue(formattedValue);
          }
          return props.value;
        });
        const mergedValueRef = useMergedState(
          controlledValueRef,
          uncontrolledValueRef
        );
        const pendingValueRef = vue.ref(null);
        vue.watchEffect(() => {
          pendingValueRef.value = mergedValueRef.value;
        });
        const singleInputValueRef = vue.ref("");
        const rangeStartInputValueRef = vue.ref("");
        const rangeEndInputValueRef = vue.ref("");
        const themeRef = useTheme(
          "DatePicker",
          "-date-picker",
          style$R,
          datePickerLight$1,
          props,
          mergedClsPrefixRef
        );
        const timePickerSizeRef = vue.computed(() => {
          return mergedComponentPropsRef?.value?.DatePicker?.timePickerSize || "small";
        });
        const isRangeRef = vue.computed(() => {
          return [
            "daterange",
            "datetimerange",
            "monthrange",
            "quarterrange",
            "yearrange"
          ].includes(props.type);
        });
        const localizedPlacehoderRef = vue.computed(() => {
          const { placeholder } = props;
          if (placeholder === void 0) {
            const { type } = props;
            switch (type) {
              case "date":
                return localeRef.value.datePlaceholder;
              case "datetime":
                return localeRef.value.datetimePlaceholder;
              case "month":
                return localeRef.value.monthPlaceholder;
              case "year":
                return localeRef.value.yearPlaceholder;
              case "quarter":
                return localeRef.value.quarterPlaceholder;
              default:
                return "";
            }
          } else {
            return placeholder;
          }
        });
        const localizedStartPlaceholderRef = vue.computed(() => {
          if (props.startPlaceholder === void 0) {
            if (props.type === "daterange") {
              return localeRef.value.startDatePlaceholder;
            } else if (props.type === "datetimerange") {
              return localeRef.value.startDatetimePlaceholder;
            } else if (props.type === "monthrange") {
              return localeRef.value.startMonthPlaceholder;
            }
            return "";
          } else {
            return props.startPlaceholder;
          }
        });
        const localizedEndPlaceholderRef = vue.computed(() => {
          if (props.endPlaceholder === void 0) {
            if (props.type === "daterange") {
              return localeRef.value.endDatePlaceholder;
            } else if (props.type === "datetimerange") {
              return localeRef.value.endDatetimePlaceholder;
            } else if (props.type === "monthrange") {
              return localeRef.value.endMonthPlaceholder;
            }
            return "";
          } else {
            return props.endPlaceholder;
          }
        });
        const mergedActionsRef = vue.computed(() => {
          const { actions, type, clearable } = props;
          if (actions === null)
            return [];
          if (actions !== void 0)
            return actions;
          const result = clearable ? ["clear"] : [];
          switch (type) {
            case "date": {
              result.push("now");
              return result;
            }
            case "datetime": {
              result.push("now", "confirm");
              return result;
            }
            case "daterange": {
              result.push("confirm");
              return result;
            }
            case "datetimerange": {
              result.push("confirm");
              return result;
            }
            case "month": {
              result.push("now", "confirm");
              return result;
            }
            case "year": {
              result.push("now");
              return result;
            }
            case "quarter": {
              result.push("now", "confirm");
              return result;
            }
            case "monthrange":
            case "yearrange":
            case "quarterrange": {
              result.push("confirm");
              return result;
            }
            default: {
              warn$2(
                "data-picker",
                "The type is wrong, n-date-picker's type only supports `date`, `datetime`, `daterange` and `datetimerange`."
              );
              break;
            }
          }
        });
        function getFormattedValue(value) {
          if (value === null)
            return null;
          if (Array.isArray(value)) {
            const { value: mergedValueFormat } = mergedValueFormatRef;
            const { value: dateFnsOptions } = dateFnsOptionsRef;
            return [
              format$4(value[0], mergedValueFormat, dateFnsOptions),
              format$4(value[1], mergedValueFormat, dateFnsOptionsRef.value)
            ];
          } else {
            return format$4(
              value,
              mergedValueFormatRef.value,
              dateFnsOptionsRef.value
            );
          }
        }
        function doUpdatePendingValue(value) {
          pendingValueRef.value = value;
        }
        function doUpdateFormattedValue(value, timestampValue) {
          const {
            "onUpdate:formattedValue": _onUpdateFormattedValue,
            onUpdateFormattedValue
          } = props;
          if (_onUpdateFormattedValue) {
            call(
              _onUpdateFormattedValue,
              value,
              timestampValue
            );
          }
          if (onUpdateFormattedValue) {
            call(
              onUpdateFormattedValue,
              value,
              timestampValue
            );
          }
        }
        function doUpdateValue(value, options) {
          const {
            "onUpdate:value": _onUpdateValue,
            onUpdateValue,
            onChange
          } = props;
          const { nTriggerFormChange, nTriggerFormInput } = formItem;
          const formattedValue = getFormattedValue(value);
          if (options.doConfirm) {
            doConfirm(value, formattedValue);
          }
          if (onUpdateValue) {
            call(onUpdateValue, value, formattedValue);
          }
          if (_onUpdateValue) {
            call(_onUpdateValue, value, formattedValue);
          }
          if (onChange)
            call(onChange, value, formattedValue);
          uncontrolledValueRef.value = value;
          doUpdateFormattedValue(formattedValue, value);
          nTriggerFormChange();
          nTriggerFormInput();
        }
        function doClear() {
          const { onClear } = props;
          onClear?.();
        }
        function doConfirm(value, formattedValue) {
          const { onConfirm } = props;
          if (onConfirm)
            onConfirm(value, formattedValue);
        }
        function doFocus(e) {
          const { onFocus } = props;
          const { nTriggerFormFocus } = formItem;
          if (onFocus)
            call(onFocus, e);
          nTriggerFormFocus();
        }
        function doBlur(e) {
          const { onBlur } = props;
          const { nTriggerFormBlur } = formItem;
          if (onBlur)
            call(onBlur, e);
          nTriggerFormBlur();
        }
        function doUpdateShow(show) {
          const { "onUpdate:show": _onUpdateShow, onUpdateShow } = props;
          if (_onUpdateShow)
            call(_onUpdateShow, show);
          if (onUpdateShow)
            call(onUpdateShow, show);
          uncontrolledShowRef.value = show;
        }
        function handleKeydown(e) {
          if (e.key === "Escape") {
            if (mergedShowRef.value) {
              markEventEffectPerformed(e);
              closeCalendar({
                returnFocus: true
              });
            }
          }
        }
        function handleInputKeydown(e) {
          if (e.key === "Escape" && mergedShowRef.value) {
            markEventEffectPerformed(e);
          }
        }
        function handleClear() {
          doUpdateShow(false);
          inputInstRef.value?.deactivate();
          doClear();
        }
        function handlePanelClear() {
          inputInstRef.value?.deactivate();
          doClear();
        }
        function handlePanelTabOut() {
          closeCalendar({
            returnFocus: true
          });
        }
        function handleClickOutside(e) {
          if (mergedShowRef.value && !triggerElRef.value?.contains(getPreciseEventTarget(e))) {
            closeCalendar({
              returnFocus: false
            });
          }
        }
        function handlePanelClose(disableUpdateOnClose) {
          closeCalendar({
            returnFocus: true,
            disableUpdateOnClose
          });
        }
        function handlePanelUpdateValue(value, doUpdate) {
          if (doUpdate) {
            doUpdateValue(value, { doConfirm: false });
          } else {
            doUpdatePendingValue(value);
          }
        }
        function handlePanelConfirm() {
          const pendingValue = pendingValueRef.value;
          doUpdateValue(
            Array.isArray(pendingValue) ? [pendingValue[0], pendingValue[1]] : pendingValue,
            { doConfirm: true }
          );
        }
        function deriveInputState() {
          const { value } = pendingValueRef;
          if (isRangeRef.value) {
            if (Array.isArray(value) || value === null) {
              deriveRangeInputState(value);
            }
          } else {
            if (!Array.isArray(value)) {
              deriveSingleInputState(value);
            }
          }
        }
        function deriveSingleInputState(value) {
          if (value === null) {
            singleInputValueRef.value = "";
          } else {
            singleInputValueRef.value = format$4(
              value,
              mergedFormatRef.value,
              dateFnsOptionsRef.value
            );
          }
        }
        function deriveRangeInputState(values) {
          if (values === null) {
            rangeStartInputValueRef.value = "";
            rangeEndInputValueRef.value = "";
          } else {
            const dateFnsOptions = dateFnsOptionsRef.value;
            rangeStartInputValueRef.value = format$4(
              values[0],
              mergedFormatRef.value,
              dateFnsOptions
            );
            rangeEndInputValueRef.value = format$4(
              values[1],
              mergedFormatRef.value,
              dateFnsOptions
            );
          }
        }
        function handleInputActivate() {
          if (!mergedShowRef.value) {
            openCalendar();
          }
        }
        function handleInputBlur(e) {
          if (!panelInstRef.value?.$el.contains(e.relatedTarget)) {
            doBlur(e);
            deriveInputState();
            closeCalendar({
              returnFocus: false
            });
          }
        }
        function handleInputDeactivate() {
          if (mergedDisabledRef.value)
            return;
          deriveInputState();
          closeCalendar({
            returnFocus: false
          });
        }
        function handleSingleUpdateValue(v) {
          if (v === "") {
            doUpdateValue(null, { doConfirm: false });
            return;
          }
          const newSelectedDateTime = strictParse(
            v,
            mergedFormatRef.value,
            new Date(),
            dateFnsOptionsRef.value
          );
          if (isValid$1(newSelectedDateTime)) {
            doUpdateValue(getTime(newSelectedDateTime), { doConfirm: false });
            deriveInputState();
          } else {
            singleInputValueRef.value = v;
          }
        }
        function handleRangeUpdateValue(v) {
          if (v[0] === "" && v[1] === "") {
            doUpdateValue(null, { doConfirm: false });
            return;
          }
          const [startTime, endTime] = v;
          const newStartTime = strictParse(
            startTime,
            mergedFormatRef.value,
            new Date(),
            dateFnsOptionsRef.value
          );
          const newEndTime = strictParse(
            endTime,
            mergedFormatRef.value,
            new Date(),
            dateFnsOptionsRef.value
          );
          if (isValid$1(newStartTime) && isValid$1(newEndTime)) {
            doUpdateValue([getTime(newStartTime), getTime(newEndTime)], {
              doConfirm: false
            });
            deriveInputState();
          } else {
            [rangeStartInputValueRef.value, rangeEndInputValueRef.value] = v;
          }
        }
        function handleTriggerClick(e) {
          if (mergedDisabledRef.value)
            return;
          if (happensIn(e, "clear"))
            return;
          if (!mergedShowRef.value) {
            openCalendar();
          }
        }
        function handleInputFocus(e) {
          if (mergedDisabledRef.value)
            return;
          doFocus(e);
        }
        function openCalendar() {
          if (mergedDisabledRef.value || mergedShowRef.value)
            return;
          doUpdateShow(true);
        }
        function closeCalendar({
          returnFocus,
          disableUpdateOnClose
        }) {
          if (mergedShowRef.value) {
            doUpdateShow(false);
            if (props.type !== "date" && props.updateValueOnClose && !disableUpdateOnClose) {
              handlePanelConfirm();
            }
            if (returnFocus) {
              inputInstRef.value?.focus();
            }
          }
        }
        vue.watch(pendingValueRef, () => {
          deriveInputState();
        });
        deriveInputState();
        vue.watch(mergedShowRef, (value) => {
          if (!value) {
            pendingValueRef.value = mergedValueRef.value;
          }
        });
        const uniVaidation = uniCalendarValidation(props, pendingValueRef);
        const dualValidation = dualCalendarValidation(props, pendingValueRef);
        vue.provide(datePickerInjectionKey, {
          mergedClsPrefixRef,
          mergedThemeRef: themeRef,
          timePickerSizeRef,
          localeRef,
          dateLocaleRef,
          firstDayOfWeekRef: vue.toRef(props, "firstDayOfWeek"),
          isDateDisabledRef: vue.toRef(props, "isDateDisabled"),
          rangesRef: vue.toRef(props, "ranges"),
          timePickerPropsRef: vue.toRef(props, "timePickerProps"),
          closeOnSelectRef: vue.toRef(props, "closeOnSelect"),
          updateValueOnCloseRef: vue.toRef(props, "updateValueOnClose"),
          ...uniVaidation,
          ...dualValidation,
          datePickerSlots: slots
        });
        const exposedMethods = {
          focus: () => {
            inputInstRef.value?.focus();
          },
          blur: () => {
            inputInstRef.value?.blur();
          }
        };
        const triggerCssVarsRef = vue.computed(() => {
          const {
            common: { cubicBezierEaseInOut },
            self: { iconColor, iconColorDisabled }
          } = themeRef.value;
          return {
            "--n-bezier": cubicBezierEaseInOut,
            "--n-icon-color-override": iconColor,
            "--n-icon-color-disabled-override": iconColorDisabled
          };
        });
        const triggerThemeClassHandle = inlineThemeDisabled ? useThemeClass(
          "date-picker-trigger",
          void 0,
          triggerCssVarsRef,
          props
        ) : void 0;
        const cssVarsRef = vue.computed(() => {
          const { type } = props;
          const {
            common: { cubicBezierEaseInOut },
            self: {
              calendarTitleFontSize,
              calendarDaysFontSize,
              itemFontSize,
              itemTextColor,
              itemColorDisabled,
              itemColorIncluded,
              itemColorHover,
              itemColorActive,
              itemBorderRadius,
              itemTextColorDisabled,
              itemTextColorActive,
              panelColor,
              panelTextColor,
              arrowColor,
              calendarTitleTextColor,
              panelActionDividerColor,
              panelHeaderDividerColor,
              calendarDaysDividerColor,
              panelBoxShadow,
              panelBorderRadius,
              calendarTitleFontWeight,
              panelExtraFooterPadding,
              panelActionPadding,
              itemSize,
              itemCellWidth,
              itemCellHeight,
              scrollItemWidth,
              scrollItemHeight,
              calendarTitlePadding,
              calendarTitleHeight,
              calendarDaysHeight,
              calendarDaysTextColor,
              arrowSize,
              panelHeaderPadding,
              calendarDividerColor,
              calendarTitleGridTempateColumns,
              iconColor,
              iconColorDisabled,
              scrollItemBorderRadius,
              calendarTitleColorHover,
              [createKey("calendarLeftPadding", type)]: calendarLeftPadding,
              [createKey("calendarRightPadding", type)]: calendarRightPadding
            }
          } = themeRef.value;
          return {
            "--n-bezier": cubicBezierEaseInOut,
            "--n-panel-border-radius": panelBorderRadius,
            "--n-panel-color": panelColor,
            "--n-panel-box-shadow": panelBoxShadow,
            "--n-panel-text-color": panelTextColor,
            "--n-panel-header-padding": panelHeaderPadding,
            "--n-panel-header-divider-color": panelHeaderDividerColor,
            "--n-calendar-left-padding": calendarLeftPadding,
            "--n-calendar-right-padding": calendarRightPadding,
            "--n-calendar-title-color-hover": calendarTitleColorHover,
            "--n-calendar-title-height": calendarTitleHeight,
            "--n-calendar-title-padding": calendarTitlePadding,
            "--n-calendar-title-font-size": calendarTitleFontSize,
            "--n-calendar-title-font-weight": calendarTitleFontWeight,
            "--n-calendar-title-text-color": calendarTitleTextColor,
            "--n-calendar-title-grid-template-columns": calendarTitleGridTempateColumns,
            "--n-calendar-days-height": calendarDaysHeight,
            "--n-calendar-days-divider-color": calendarDaysDividerColor,
            "--n-calendar-days-font-size": calendarDaysFontSize,
            "--n-calendar-days-text-color": calendarDaysTextColor,
            "--n-calendar-divider-color": calendarDividerColor,
            "--n-panel-action-padding": panelActionPadding,
            "--n-panel-extra-footer-padding": panelExtraFooterPadding,
            "--n-panel-action-divider-color": panelActionDividerColor,
            "--n-item-font-size": itemFontSize,
            "--n-item-border-radius": itemBorderRadius,
            "--n-item-size": itemSize,
            "--n-item-cell-width": itemCellWidth,
            "--n-item-cell-height": itemCellHeight,
            "--n-item-text-color": itemTextColor,
            "--n-item-color-included": itemColorIncluded,
            "--n-item-color-disabled": itemColorDisabled,
            "--n-item-color-hover": itemColorHover,
            "--n-item-color-active": itemColorActive,
            "--n-item-text-color-disabled": itemTextColorDisabled,
            "--n-item-text-color-active": itemTextColorActive,
            "--n-scroll-item-width": scrollItemWidth,
            "--n-scroll-item-height": scrollItemHeight,
            "--n-scroll-item-border-radius": scrollItemBorderRadius,
            "--n-arrow-size": arrowSize,
            "--n-arrow-color": arrowColor,
            "--n-icon-color": iconColor,
            "--n-icon-color-disabled": iconColorDisabled
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("date-picker", void 0, cssVarsRef, props) : void 0;
        return {
          ...exposedMethods,
          mergedStatus: mergedStatusRef,
          mergedClsPrefix: mergedClsPrefixRef,
          mergedBordered: mergedBorderedRef,
          namespace: namespaceRef,
          uncontrolledValue: uncontrolledValueRef,
          pendingValue: pendingValueRef,
          panelInstRef,
          triggerElRef,
          inputInstRef,
          isMounted: isMounted(),
          displayTime: singleInputValueRef,
          displayStartTime: rangeStartInputValueRef,
          displayEndTime: rangeEndInputValueRef,
          mergedShow: mergedShowRef,
          adjustedTo: useAdjustedTo(props),
          isRange: isRangeRef,
          localizedStartPlaceholder: localizedStartPlaceholderRef,
          localizedEndPlaceholder: localizedEndPlaceholderRef,
          mergedSize: mergedSizeRef,
          mergedDisabled: mergedDisabledRef,
          localizedPlacehoder: localizedPlacehoderRef,
          isValueInvalid: uniVaidation.isValueInvalidRef,
          isStartValueInvalid: dualValidation.isStartValueInvalidRef,
          isEndValueInvalid: dualValidation.isEndValueInvalidRef,
          handleInputKeydown,
          handleClickOutside,
          handleKeydown,
          handleClear,
          handlePanelClear,
          handleTriggerClick,
          handleInputActivate,
          handleInputDeactivate,
          handleInputFocus,
          handleInputBlur,
          handlePanelTabOut,
          handlePanelClose,
          handleRangeUpdateValue,
          handleSingleUpdateValue,
          handlePanelUpdateValue,
          handlePanelConfirm,
          mergedTheme: themeRef,
          actions: mergedActionsRef,
          triggerCssVars: inlineThemeDisabled ? void 0 : triggerCssVarsRef,
          triggerThemeClass: triggerThemeClassHandle?.themeClass,
          triggerOnRender: triggerThemeClassHandle?.onRender,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender
        };
      },
      render() {
        const { clearable, triggerOnRender, mergedClsPrefix, $slots } = this;
        const commonPanelProps = {
          onUpdateValue: this.handlePanelUpdateValue,
          onTabOut: this.handlePanelTabOut,
          onClose: this.handlePanelClose,
          onClear: this.handlePanelClear,
          onKeydown: this.handleKeydown,
          onConfirm: this.handlePanelConfirm,
          ref: "panelInstRef",
          value: this.pendingValue,
          active: this.mergedShow,
          actions: this.actions,
          shortcuts: this.shortcuts,
          style: this.cssVars,
          defaultTime: this.defaultTime,
          themeClass: this.themeClass,
          panel: this.panel,
          onRender: this.onRender
        };
        const renderPanel = () => {
          const { type } = this;
          return type === "datetime" ? /* @__PURE__ */ vue.h(DatetimePanel, {
            ...commonPanelProps
          }) : type === "daterange" ? /* @__PURE__ */ vue.h(DaterangePanel, {
            ...commonPanelProps,
            defaultCalendarStartTime: this.defaultCalendarStartTime,
            defaultCalendarEndTime: this.defaultCalendarEndTime,
            bindCalendarMonths: this.bindCalendarMonths
          }) : type === "datetimerange" ? /* @__PURE__ */ vue.h(DatetimerangePanel, {
            ...commonPanelProps,
            defaultCalendarStartTime: this.defaultCalendarStartTime,
            defaultCalendarEndTime: this.defaultCalendarEndTime,
            bindCalendarMonths: this.bindCalendarMonths
          }) : type === "month" || type === "year" || type === "quarter" ? /* @__PURE__ */ vue.h(MonthPanel, {
            ...commonPanelProps,
            type,
            key: type
          }) : type === "monthrange" || type === "yearrange" || type === "quarterrange" ? /* @__PURE__ */ vue.h(MonthRangePanel, {
            ...commonPanelProps,
            type
          }) : /* @__PURE__ */ vue.h(DatePanel, {
            ...commonPanelProps
          });
        };
        if (this.panel) {
          return renderPanel();
        }
        triggerOnRender?.();
        const commonInputProps = {
          bordered: this.mergedBordered,
          size: this.mergedSize,
          passivelyActivated: true,
          disabled: this.mergedDisabled,
          readonly: this.inputReadonly || this.mergedDisabled,
          clearable,
          onClear: this.handleClear,
          onClick: this.handleTriggerClick,
          onKeydown: this.handleInputKeydown,
          onActivate: this.handleInputActivate,
          onDeactivate: this.handleInputDeactivate,
          onFocus: this.handleInputFocus,
          onBlur: this.handleInputBlur
        };
        return /* @__PURE__ */ vue.h("div", {
          ref: "triggerElRef",
          class: [
            `${mergedClsPrefix}-date-picker`,
            this.mergedDisabled && `${mergedClsPrefix}-date-picker--disabled`,
            this.isRange && `${mergedClsPrefix}-date-picker--range`,
            this.triggerThemeClass
          ],
          style: this.triggerCssVars,
          onKeydown: this.handleKeydown
        }, /* @__PURE__ */ vue.h(VBinder, null, {
          default: () => [
            /* @__PURE__ */ vue.h(VTarget, null, {
              default: () => this.isRange ? /* @__PURE__ */ vue.h(NInput, {
                ref: "inputInstRef",
                status: this.mergedStatus,
                value: [this.displayStartTime, this.displayEndTime],
                placeholder: [
                  this.localizedStartPlaceholder,
                  this.localizedEndPlaceholder
                ],
                textDecoration: [
                  this.isStartValueInvalid ? "line-through" : "",
                  this.isEndValueInvalid ? "line-through" : ""
                ],
                pair: true,
                onUpdateValue: this.handleRangeUpdateValue,
                theme: this.mergedTheme.peers.Input,
                themeOverrides: this.mergedTheme.peerOverrides.Input,
                internalForceFocus: this.mergedShow,
                internalDeactivateOnEnter: true,
                ...commonInputProps
              }, {
                separator: () => this.separator === void 0 ? resolveSlot($slots.separator, () => [
                  /* @__PURE__ */ vue.h(NBaseIcon, {
                    clsPrefix: mergedClsPrefix,
                    class: `${mergedClsPrefix}-date-picker-icon`
                  }, {
                    default: () => /* @__PURE__ */ vue.h(ToIcon, null)
                  })
                ]) : this.separator,
                [clearable ? "clear-icon-placeholder" : "suffix"]: () => resolveSlot($slots["date-icon"], () => [
                  /* @__PURE__ */ vue.h(NBaseIcon, {
                    clsPrefix: mergedClsPrefix,
                    class: `${mergedClsPrefix}-date-picker-icon`
                  }, {
                    default: () => /* @__PURE__ */ vue.h(DateIcon, null)
                  })
                ])
              }) : /* @__PURE__ */ vue.h(NInput, {
                ref: "inputInstRef",
                status: this.mergedStatus,
                value: this.displayTime,
                placeholder: this.localizedPlacehoder,
                textDecoration: this.isValueInvalid && !this.isRange ? "line-through" : "",
                onUpdateValue: this.handleSingleUpdateValue,
                theme: this.mergedTheme.peers.Input,
                themeOverrides: this.mergedTheme.peerOverrides.Input,
                internalForceFocus: this.mergedShow,
                internalDeactivateOnEnter: true,
                ...commonInputProps
              }, {
                [clearable ? "clear-icon-placeholder" : "suffix"]: () => /* @__PURE__ */ vue.h(NBaseIcon, {
                  clsPrefix: mergedClsPrefix,
                  class: `${mergedClsPrefix}-date-picker-icon`
                }, {
                  default: () => resolveSlot($slots["date-icon"], () => [
                    /* @__PURE__ */ vue.h(DateIcon, null)
                  ])
                })
              })
            }),
            /* @__PURE__ */ vue.h(VFollower, {
              show: this.mergedShow,
              containerClass: this.namespace,
              to: this.adjustedTo,
              teleportDisabled: this.adjustedTo === useAdjustedTo.tdkey,
              placement: this.placement
            }, {
              default: () => /* @__PURE__ */ vue.h(vue.Transition, {
                name: "fade-in-scale-up-transition",
                appear: this.isMounted
              }, {
                default: () => {
                  if (!this.mergedShow)
                    return null;
                  return vue.withDirectives(renderPanel(), [
                    [
                      clickoutside$1,
                      this.handleClickOutside,
                      void 0,
                      { capture: true }
                    ]
                  ]);
                }
              })
            })
          ]
        }));
      }
    });

    var commonVariables$7 = {
      thPaddingBorderedSmall: "8px 12px",
      thPaddingBorderedMedium: "12px 16px",
      thPaddingBorderedLarge: "16px 24px",
      thPaddingSmall: "0",
      thPaddingMedium: "0",
      thPaddingLarge: "0",
      tdPaddingBorderedSmall: "8px 12px",
      tdPaddingBorderedMedium: "12px 16px",
      tdPaddingBorderedLarge: "16px 24px",
      tdPaddingSmall: "0 0 8px 0",
      tdPaddingMedium: "0 0 12px 0",
      tdPaddingLarge: "0 0 16px 0"
    };

    const self$F = vars => {
      const {
        tableHeaderColor,
        textColor2,
        textColor1,
        cardColor,
        modalColor,
        popoverColor,
        dividerColor,
        borderRadius,
        fontWeightStrong,
        lineHeight,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge
      } = vars;
      return { ...commonVariables$7,
        lineHeight,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        titleTextColor: textColor1,
        thColor: composite(cardColor, tableHeaderColor),
        thColorModal: composite(modalColor, tableHeaderColor),
        thColorPopover: composite(popoverColor, tableHeaderColor),
        thTextColor: textColor1,
        thFontWeight: fontWeightStrong,
        tdTextColor: textColor2,
        tdColor: cardColor,
        tdColorModal: modalColor,
        tdColorPopover: popoverColor,
        borderColor: composite(cardColor, dividerColor),
        borderColorModal: composite(modalColor, dividerColor),
        borderColorPopover: composite(popoverColor, dividerColor),
        borderRadius
      };
    };
    const descriptionsLight = {
      name: "Descriptions",
      common: commonLight,
      self: self$F
    };
    var descriptionsLight$1 = descriptionsLight;

    const descriptionsDark = {
      name: "Descriptions",
      common: commonDark,
      self: self$F
    };
    var descriptionsDark$1 = descriptionsDark;

    const DESCRIPTION_ITEM_FLAG = Symbol("DESCRIPTION_ITEM_FLAG");
    function isDescriptionsItem(vNode) {
      if (typeof vNode === "object" && vNode && !Array.isArray(vNode)) {
        return vNode.type && vNode.type[DESCRIPTION_ITEM_FLAG];
      }

      return false;
    }

    var style$Q = c$1([cB("descriptions", {
      fontSize: "var(--n-font-size)"
    }, [cB("descriptions-separator", `
      display: inline-block;
      margin: 0 8px 0 2px;
    `), cB("descriptions-table-wrapper", [cB("descriptions-table", [cB("descriptions-table-row", [cB("descriptions-table-header", {
      padding: "var(--n-th-padding)"
    }), cB("descriptions-table-content", {
      padding: "var(--n-td-padding)"
    })])])]), cNotM("bordered", [cB("descriptions-table-wrapper", [cB("descriptions-table", [cB("descriptions-table-row", [c$1("&:last-child", [cB("descriptions-table-content", {
      paddingBottom: 0
    })])])])])]), cM("left-label-placement", [cB("descriptions-table-content", [c$1("> *", {
      verticalAlign: "top"
    })])]), cM("left-label-align", [c$1("th", {
      textAlign: "left"
    })]), cM("center-label-align", [c$1("th", {
      textAlign: "center"
    })]), cM("right-label-align", [c$1("th", {
      textAlign: "right"
    })]), cM("bordered", [cB("descriptions-table-wrapper", `
        border-radius: var(--n-border-radius);
        overflow: hidden;
        background: var(--n-merged-td-color);
        border: 1px solid var(--n-merged-border-color);
      `, [cB("descriptions-table", [cB("descriptions-table-row", [c$1("&:not(:last-child)", [cB("descriptions-table-content", {
      borderBottom: "1px solid var(--n-merged-border-color)"
    }), cB("descriptions-table-header", {
      borderBottom: "1px solid var(--n-merged-border-color)"
    })]), cB("descriptions-table-header", `
              font-weight: 400;
              background-clip: padding-box;
              background-color: var(--n-merged-th-color);
            `, [c$1("&:not(:last-child)", {
      borderRight: "1px solid var(--n-merged-border-color)"
    })]), cB("descriptions-table-content", [c$1("&:not(:last-child)", {
      borderRight: "1px solid var(--n-merged-border-color)"
    })])])])])]), cB("descriptions-header", `
      font-weight: var(--n-th-font-weight);
      font-size: 18px;
      transition: color .3s var(--n-bezier);
      line-height: var(--n-line-height);
      margin-bottom: 16px;
      color: var(--n-title-text-color);
    `), cB("descriptions-table-wrapper", `
      transition:
        background-color .3s var(--n-bezier),
        border-color .3s var(--n-bezier);
    `, [cB("descriptions-table", `
        width: 100%;
        border-collapse: separate;
        border-spacing: 0;
        box-sizing: border-box;
      `, [cB("descriptions-table-row", `
          box-sizing: border-box;
          transition: border-color .3s var(--n-bezier);
        `, [cB("descriptions-table-header", `
            font-weight: var(--n-th-font-weight);
            line-height: var(--n-line-height);
            display: table-cell;
            box-sizing: border-box;
            color: var(--n-th-text-color);
            transition:
              color .3s var(--n-bezier),
              background-color .3s var(--n-bezier),
              border-color .3s var(--n-bezier);
          `), cB("descriptions-table-content", `
            vertical-align: top;
            line-height: var(--n-line-height);
            display: table-cell;
            box-sizing: border-box;
            color: var(--n-td-text-color);
            transition:
              color .3s var(--n-bezier),
              background-color .3s var(--n-bezier),
              border-color .3s var(--n-bezier);
          `, [cE("content", `
              transition: color .3s var(--n-bezier);
              display: inline-block;
              color: var(--n-td-text-color);
            `)]), cE("label", `
            font-weight: var(--n-th-font-weight);
            transition: color .3s var(--n-bezier);
            display: inline-block;
            margin-right: 14px;
            color: var(--n-th-text-color);
          `)])])])]), cB("descriptions-table-wrapper", `
    --n-merged-th-color: var(--n-th-color);
    --n-merged-td-color: var(--n-td-color);
    --n-merged-border-color: var(--n-border-color);
  `), insideModal(cB("descriptions-table-wrapper", `
      --n-merged-th-color: var(--n-th-color-modal);
      --n-merged-td-color: var(--n-td-color-modal);
      --n-merged-border-color: var(--n-border-color-modal);
    `)), insidePopover(cB("descriptions-table-wrapper", `
      --n-merged-th-color: var(--n-th-color-popover);
      --n-merged-td-color: var(--n-td-color-popover);
      --n-merged-border-color: var(--n-border-color-popover);
    `))]);

    const descriptionsProps = {
      ...useTheme.props,
      title: String,
      column: {
        type: Number,
        default: 3
      },
      columns: Number,
      labelPlacement: {
        type: String,
        default: "top"
      },
      labelAlign: {
        type: String,
        default: "left"
      },
      separator: {
        type: String,
        default: ":"
      },
      size: {
        type: String,
        default: "medium"
      },
      bordered: Boolean,
      labelStyle: [Object, String],
      contentStyle: [Object, String]
    };
    var Descriptions = vue.defineComponent({
      name: "Descriptions",
      props: descriptionsProps,
      setup(props) {
        const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
        const themeRef = useTheme(
          "Descriptions",
          "-descriptions",
          style$Q,
          descriptionsLight$1,
          props,
          mergedClsPrefixRef
        );
        const cssVarsRef = vue.computed(() => {
          const { size, bordered } = props;
          const {
            common: { cubicBezierEaseInOut },
            self: {
              titleTextColor,
              thColor,
              thColorModal,
              thColorPopover,
              thTextColor,
              thFontWeight,
              tdTextColor,
              tdColor,
              tdColorModal,
              tdColorPopover,
              borderColor,
              borderColorModal,
              borderColorPopover,
              borderRadius,
              lineHeight,
              [createKey("fontSize", size)]: fontSize,
              [createKey(bordered ? "thPaddingBordered" : "thPadding", size)]: thPadding,
              [createKey(bordered ? "tdPaddingBordered" : "tdPadding", size)]: tdPadding
            }
          } = themeRef.value;
          return {
            "--n-title-text-color": titleTextColor,
            "--n-th-padding": thPadding,
            "--n-td-padding": tdPadding,
            "--n-font-size": fontSize,
            "--n-bezier": cubicBezierEaseInOut,
            "--n-th-font-weight": thFontWeight,
            "--n-line-height": lineHeight,
            "--n-th-text-color": thTextColor,
            "--n-td-text-color": tdTextColor,
            "--n-th-color": thColor,
            "--n-th-color-modal": thColorModal,
            "--n-th-color-popover": thColorPopover,
            "--n-td-color": tdColor,
            "--n-td-color-modal": tdColorModal,
            "--n-td-color-popover": tdColorPopover,
            "--n-border-radius": borderRadius,
            "--n-border-color": borderColor,
            "--n-border-color-modal": borderColorModal,
            "--n-border-color-popover": borderColorPopover
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass(
          "descriptions",
          vue.computed(() => {
            let hash = "";
            const { size, bordered } = props;
            if (bordered)
              hash += "a";
            hash += size[0];
            return hash;
          }),
          cssVarsRef,
          props
        ) : void 0;
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender,
          compitableColumn: useCompitable(props, ["columns", "column"]),
          inlineThemeDisabled
        };
      },
      render() {
        const defaultSlots = this.$slots.default;
        const children = defaultSlots ? flatten$3(defaultSlots()) : [];
        const memorizedLength = children.length;
        const {
          compitableColumn,
          labelPlacement,
          labelAlign,
          size,
          bordered,
          title,
          cssVars,
          mergedClsPrefix,
          separator,
          onRender
        } = this;
        onRender?.();
        const filteredChildren = children.filter(
          (child) => isDescriptionsItem(child)
        );
        if (memorizedLength !== filteredChildren.length) {
          warn$2(
            "descriptions",
            "`n-descriptions` only takes `n-descriptions-item` as children."
          );
        }
        const defaultState = {
          span: 0,
          row: [],
          secondRow: [],
          rows: []
        };
        const itemState = filteredChildren.reduce((state, vNode, index) => {
          const props = vNode.props || {};
          const isLastIteration = filteredChildren.length - 1 === index;
          const itemLabel = [
            "label" in props ? props.label : getVNodeChildren(vNode, "label")
          ];
          const itemChildren = [getVNodeChildren(vNode)];
          const itemSpan = props.span || 1;
          const memorizedSpan = state.span;
          state.span += itemSpan;
          const labelStyle = props.labelStyle || props["label-style"] || this.labelStyle;
          const contentStyle = props.contentStyle || props["content-style"] || this.contentStyle;
          if (labelPlacement === "left") {
            if (bordered) {
              state.row.push(
                /* @__PURE__ */ vue.h("th", {
                  class: `${mergedClsPrefix}-descriptions-table-header`,
                  colspan: 1,
                  style: labelStyle
                }, itemLabel),
                /* @__PURE__ */ vue.h("td", {
                  class: `${mergedClsPrefix}-descriptions-table-content`,
                  colspan: isLastIteration ? (compitableColumn - memorizedSpan) * 2 + 1 : itemSpan * 2 - 1,
                  style: contentStyle
                }, itemChildren)
              );
            } else {
              state.row.push(
                /* @__PURE__ */ vue.h("td", {
                  class: `${mergedClsPrefix}-descriptions-table-content`,
                  colspan: isLastIteration ? (compitableColumn - memorizedSpan) * 2 : itemSpan * 2
                }, /* @__PURE__ */ vue.h("span", {
                  class: `${mergedClsPrefix}-descriptions-table-content__label`,
                  style: labelStyle
                }, [
                  ...itemLabel,
                  separator && /* @__PURE__ */ vue.h("span", {
                    class: `${mergedClsPrefix}-descriptions-separator`
                  }, separator)
                ]), /* @__PURE__ */ vue.h("span", {
                  class: `${mergedClsPrefix}-descriptions-table-content__content`,
                  style: contentStyle
                }, itemChildren))
              );
            }
          } else {
            const colspan = isLastIteration ? (compitableColumn - memorizedSpan) * 2 : itemSpan * 2;
            state.row.push(
              /* @__PURE__ */ vue.h("th", {
                class: `${mergedClsPrefix}-descriptions-table-header`,
                colspan,
                style: labelStyle
              }, itemLabel)
            );
            state.secondRow.push(
              /* @__PURE__ */ vue.h("td", {
                class: `${mergedClsPrefix}-descriptions-table-content`,
                colspan,
                style: contentStyle
              }, itemChildren)
            );
          }
          if (state.span >= compitableColumn || isLastIteration) {
            state.span = 0;
            if (state.row.length) {
              state.rows.push(state.row);
              state.row = [];
            }
            if (labelPlacement !== "left") {
              if (state.secondRow.length) {
                state.rows.push(state.secondRow);
                state.secondRow = [];
              }
            }
          }
          return state;
        }, defaultState);
        const rows = itemState.rows.map((row) => /* @__PURE__ */ vue.h("tr", {
          class: `${mergedClsPrefix}-descriptions-table-row`
        }, row));
        return /* @__PURE__ */ vue.h("div", {
          style: cssVars,
          class: [
            `${mergedClsPrefix}-descriptions`,
            this.themeClass,
            `${mergedClsPrefix}-descriptions--${labelPlacement}-label-placement`,
            `${mergedClsPrefix}-descriptions--${labelAlign}-label-align`,
            `${mergedClsPrefix}-descriptions--${size}-size`,
            bordered && `${mergedClsPrefix}-descriptions--bordered`
          ]
        }, title || this.$slots.header ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-descriptions-header`
        }, title || getSlot$1(this, "header")) : null, /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-descriptions-table-wrapper`
        }, /* @__PURE__ */ vue.h("table", {
          class: `${mergedClsPrefix}-descriptions-table`
        }, /* @__PURE__ */ vue.h("tbody", null, rows))));
      }
    });

    const descriptionsItemProps = {
      label: String,
      span: {
        type: Number,
        default: 1
      },
      labelStyle: [Object, String],
      contentStyle: [Object, String]
    };
    var DescriptionsItem = vue.defineComponent({
      name: "DescriptionsItem",
      [DESCRIPTION_ITEM_FLAG]: true,
      props: descriptionsItemProps,

      render() {
        return null;
      }

    });

    var commonVars$5 = {
      titleFontSize: "18px",
      padding: "16px 28px 20px 28px",
      iconSize: "28px",
      actionSpace: "12px",
      contentMargin: "8px 0 16px 0",
      iconMargin: "0 4px 0 0",
      iconMarginIconTop: "4px 0 8px 0",
      closeSize: "22px",
      closeIconSize: "18px",
      closeMargin: "20px 26px 0 0",
      closeMarginIconTop: "10px 16px 0 0"
    };

    const self$E = vars => {
      const {
        textColor1,
        textColor2,
        modalColor,
        closeIconColor,
        closeIconColorHover,
        closeIconColorPressed,
        closeColorHover,
        closeColorPressed,
        infoColor,
        successColor,
        warningColor,
        errorColor,
        primaryColor,
        dividerColor,
        borderRadius,
        fontWeightStrong,
        lineHeight,
        fontSize
      } = vars;
      return { ...commonVars$5,
        fontSize,
        lineHeight,
        border: `1px solid ${dividerColor}`,
        titleTextColor: textColor1,
        textColor: textColor2,
        color: modalColor,
        closeColorHover,
        closeColorPressed,
        closeIconColor,
        closeIconColorHover,
        closeIconColorPressed,
        closeBorderRadius: borderRadius,
        iconColor: primaryColor,
        iconColorInfo: infoColor,
        iconColorSuccess: successColor,
        iconColorWarning: warningColor,
        iconColorError: errorColor,
        borderRadius,
        titleFontWeight: fontWeightStrong
      };
    };
    const dialogLight = createTheme$1({
      name: "Dialog",
      common: commonLight,
      peers: {
        Button: buttonLight$1
      },
      self: self$E
    });
    var dialogLight$1 = dialogLight;

    const dialogDark = {
      name: "Dialog",
      common: commonDark,
      peers: {
        Button: buttonDark$1
      },
      self: self$E
    };
    var dialogDark$1 = dialogDark;

    const dialogProps = {
      icon: Function,
      type: {
        type: String,
        default: "default"
      },
      title: [String, Function],
      closable: {
        type: Boolean,
        default: true
      },
      negativeText: String,
      positiveText: String,
      positiveButtonProps: Object,
      negativeButtonProps: Object,
      content: [String, Function],
      action: Function,
      showIcon: {
        type: Boolean,
        default: true
      },
      loading: Boolean,
      bordered: Boolean,
      iconPlacement: String,
      onPositiveClick: Function,
      onNegativeClick: Function,
      onClose: Function
    };
    const dialogPropKeys = keysOf(dialogProps);

    var style$P = c$1([cB("dialog", `
    word-break: break-word;
    line-height: var(--n-line-height);
    position: relative;
    background: var(--n-color);
    color: var(--n-text-color);
    box-sizing: border-box;
    margin: auto;
    border-radius: var(--n-border-radius);
    padding: var(--n-padding);
    transition:
      border-color .3s var(--n-bezier),
      background-color .3s var(--n-bezier),
      color .3s var(--n-bezier);
  `, [cE("icon", {
      color: "var(--n-icon-color)"
    }), cM("bordered", {
      border: "var(--n-border)"
    }), cM("icon-top", [cE("close", {
      margin: "var(--n-close-margin)"
    }), cE("icon", {
      margin: "var(--n-icon-margin)"
    }), cE("content", {
      textAlign: "center"
    }), cE("title", {
      justifyContent: "center"
    }), cE("action", {
      justifyContent: "center"
    })]), cM("icon-left", [cE("icon", {
      margin: "var(--n-icon-margin)"
    }), cM("closable", [cE("title", `
          padding-right: calc(var(--n-close-size) + 6px);
        `)])]), cE("close", `
      position: absolute;
      right: 0;
      top: 0;
      margin: var(--n-close-margin);
      transition:
        background-color .3s var(--n-bezier),
        color .3s var(--n-bezier);
      z-index: 1;
    `), cE("content", `
      font-size: var(--n-font-size);
      margin: var(--n-content-margin);
      position: relative;
      word-break: break-word;
    `, [cM("last", "margin-bottom: 0;")]), cE("action", `
      display: flex;
      justify-content: flex-end;
    `, [c$1("> *:not(:last-child)", {
      marginRight: "var(--n-action-space)"
    })]), cE("icon", {
      fontSize: "var(--n-icon-size)",
      transition: "color .3s var(--n-bezier)"
    }), cE("title", `
      transition: color .3s var(--n-bezier);
      display: flex;
      align-items: center;
      font-size: var(--n-title-font-size);
      font-weight: var(--n-title-font-weight);
      color: var(--n-title-text-color);
    `), cB("dialog-icon-container", {
      display: "flex",
      justifyContent: "center"
    })]), insideModal(cB("dialog", `
      width: 446px;
      max-width: calc(100vw - 32px);
    `)), cB("dialog", [asModal(`
      width: 446px;
      max-width: calc(100vw - 32px);
    `)])]);

    const iconRenderMap$2 = {
      default: () => /* @__PURE__ */ vue.h(InfoIcon, null),
      info: () => /* @__PURE__ */ vue.h(InfoIcon, null),
      success: () => /* @__PURE__ */ vue.h(SuccessIcon, null),
      warning: () => /* @__PURE__ */ vue.h(WarningIcon, null),
      error: () => /* @__PURE__ */ vue.h(ErrorIcon, null)
    };
    const NDialog = vue.defineComponent({
      name: "Dialog",
      alias: [
        "NimbusConfirmCard",
        "Confirm"
      ],
      props: {
        ...useTheme.props,
        ...dialogProps
      },
      setup(props) {
        const { mergedComponentPropsRef, mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
        const mergedIconPlacementRef = vue.computed(() => {
          const { iconPlacement } = props;
          return iconPlacement || mergedComponentPropsRef?.value?.Dialog?.iconPlacement || "left";
        });
        function handlePositiveClick(e) {
          const { onPositiveClick } = props;
          if (onPositiveClick)
            onPositiveClick(e);
        }
        function handleNegativeClick(e) {
          const { onNegativeClick } = props;
          if (onNegativeClick)
            onNegativeClick(e);
        }
        function handleCloseClick() {
          const { onClose } = props;
          if (onClose)
            onClose();
        }
        const themeRef = useTheme(
          "Dialog",
          "-dialog",
          style$P,
          dialogLight$1,
          props,
          mergedClsPrefixRef
        );
        const cssVarsRef = vue.computed(() => {
          const { type } = props;
          const iconPlacement = mergedIconPlacementRef.value;
          const {
            common: { cubicBezierEaseInOut },
            self: {
              fontSize,
              lineHeight,
              border,
              titleTextColor,
              textColor,
              color,
              closeBorderRadius,
              closeColorHover,
              closeColorPressed,
              closeIconColor,
              closeIconColorHover,
              closeIconColorPressed,
              closeIconSize,
              borderRadius,
              titleFontWeight,
              titleFontSize,
              padding,
              iconSize,
              actionSpace,
              contentMargin,
              closeSize,
              [iconPlacement === "top" ? "iconMarginIconTop" : "iconMargin"]: iconMargin,
              [iconPlacement === "top" ? "closeMarginIconTop" : "closeMargin"]: closeMargin,
              [createKey("iconColor", type)]: iconColor
            }
          } = themeRef.value;
          return {
            "--n-font-size": fontSize,
            "--n-icon-color": iconColor,
            "--n-bezier": cubicBezierEaseInOut,
            "--n-close-margin": closeMargin,
            "--n-icon-margin": iconMargin,
            "--n-icon-size": iconSize,
            "--n-close-size": closeSize,
            "--n-close-icon-size": closeIconSize,
            "--n-close-border-radius": closeBorderRadius,
            "--n-close-color-hover": closeColorHover,
            "--n-close-color-pressed": closeColorPressed,
            "--n-close-icon-color": closeIconColor,
            "--n-close-icon-color-hover": closeIconColorHover,
            "--n-close-icon-color-pressed": closeIconColorPressed,
            "--n-color": color,
            "--n-text-color": textColor,
            "--n-border-radius": borderRadius,
            "--n-padding": padding,
            "--n-line-height": lineHeight,
            "--n-border": border,
            "--n-content-margin": contentMargin,
            "--n-title-font-size": titleFontSize,
            "--n-title-font-weight": titleFontWeight,
            "--n-title-text-color": titleTextColor,
            "--n-action-space": actionSpace
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass(
          "dialog",
          vue.computed(() => `${props.type[0]}${mergedIconPlacementRef.value[0]}`),
          cssVarsRef,
          props
        ) : void 0;
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          mergedIconPlacement: mergedIconPlacementRef,
          mergedTheme: themeRef,
          handlePositiveClick,
          handleNegativeClick,
          handleCloseClick,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender
        };
      },
      render() {
        const {
          bordered,
          mergedIconPlacement,
          cssVars,
          closable,
          showIcon,
          title,
          content,
          action,
          negativeText,
          positiveText,
          positiveButtonProps,
          negativeButtonProps,
          handlePositiveClick,
          handleNegativeClick,
          mergedTheme,
          loading,
          type,
          mergedClsPrefix
        } = this;
        this.onRender?.();
        const icon = showIcon ? /* @__PURE__ */ vue.h(NBaseIcon, {
          clsPrefix: mergedClsPrefix,
          class: `${mergedClsPrefix}-dialog__icon`
        }, {
          default: () => resolveWrappedSlot(
            this.$slots.icon,
            (children) => children || (this.icon ? render$1(this.icon) : iconRenderMap$2[this.type]())
          )
        }) : null;
        const actionNode = resolveWrappedSlot(
          this.$slots.action,
          (children) => children || positiveText || negativeText || action ? /* @__PURE__ */ vue.h("div", {
            class: `${mergedClsPrefix}-dialog__action`
          }, children || (action ? [render$1(action)] : [
            this.negativeText && /* @__PURE__ */ vue.h(NButton, {
              theme: mergedTheme.peers.Button,
              themeOverrides: mergedTheme.peerOverrides.Button,
              ghost: true,
              size: "small",
              onClick: handleNegativeClick,
              ...negativeButtonProps
            }, {
              default: () => render$1(this.negativeText)
            }),
            this.positiveText && /* @__PURE__ */ vue.h(NButton, {
              theme: mergedTheme.peers.Button,
              themeOverrides: mergedTheme.peerOverrides.Button,
              size: "small",
              type: type === "default" ? "primary" : type,
              disabled: loading,
              loading,
              onClick: handlePositiveClick,
              ...positiveButtonProps
            }, {
              default: () => render$1(this.positiveText)
            })
          ])) : null
        );
        return /* @__PURE__ */ vue.h("div", {
          class: [
            `${mergedClsPrefix}-dialog`,
            this.themeClass,
            this.closable && `${mergedClsPrefix}-dialog--closable`,
            `${mergedClsPrefix}-dialog--icon-${mergedIconPlacement}`,
            bordered && `${mergedClsPrefix}-dialog--bordered`
          ],
          style: cssVars,
          role: "dialog"
        }, closable ? /* @__PURE__ */ vue.h(NBaseClose, {
          clsPrefix: mergedClsPrefix,
          class: `${mergedClsPrefix}-dialog__close`,
          onClick: this.handleCloseClick
        }) : null, showIcon && mergedIconPlacement === "top" ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-dialog-icon-container`
        }, icon) : null, /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-dialog__title`
        }, showIcon && mergedIconPlacement === "left" ? icon : null, resolveSlot(this.$slots.header, () => [render$1(title)])), /* @__PURE__ */ vue.h("div", {
          class: [
            `${mergedClsPrefix}-dialog__content`,
            actionNode ? "" : `${mergedClsPrefix}-dialog__content--last`
          ]
        }, resolveSlot(this.$slots.default, () => [render$1(content)])), actionNode);
      }
    });

    const dialogProviderInjectionKey = createInjectionKey("n-dialog-provider");
    const dialogApiInjectionKey = createInjectionKey("n-dialog-api");

    const self$D = vars => {
      const {
        modalColor,
        textColor2,
        boxShadow3
      } = vars;
      return {
        color: modalColor,
        textColor: textColor2,
        boxShadow: boxShadow3
      };
    };
    const modalLight = createTheme$1({
      name: "Modal",
      common: commonLight,
      peers: {
        Scrollbar: scrollbarLight$1,
        Dialog: dialogLight$1,
        Card: cardLight$1
      },
      self: self$D
    });
    var modalLight$1 = modalLight;

    const modalDark = {
      name: "Modal",
      common: commonDark,
      peers: {
        Scrollbar: scrollbarDark$1,
        Dialog: dialogDark$1,
        Card: cardDark$1
      },
      self: self$D
    };
    var modalDark$1 = modalDark;

    const presetProps = { ...cardBaseProps,
      ...dialogProps
    };
    const presetPropsKeys = keysOf(presetProps);

    var NModalBodyWrapper = vue.defineComponent({
      name: "ModalBody",
      inheritAttrs: false,
      props: {
        show: {
          type: Boolean,
          required: true
        },
        preset: String,
        displayDirective: {
          type: String,
          required: true
        },
        trapFocus: {
          type: Boolean,
          default: true
        },
        autoFocus: {
          type: Boolean,
          default: true
        },
        blockScroll: Boolean,
        ...presetProps,
        renderMask: Function,
        onClickoutside: Function,
        onBeforeLeave: {
          type: Function,
          required: true
        },
        onAfterLeave: {
          type: Function,
          required: true
        },
        onPositiveClick: {
          type: Function,
          required: true
        },
        onNegativeClick: {
          type: Function,
          required: true
        },
        onClose: {
          type: Function,
          required: true
        },
        onAfterEnter: Function,
        onEsc: Function
      },
      setup(props) {
        const bodyRef = vue.ref(null);
        const scrollbarRef = vue.ref(null);
        const displayedRef = vue.ref(props.show);
        const transformOriginXRef = vue.ref(null);
        const transformOriginYRef = vue.ref(null);
        vue.watch(vue.toRef(props, "show"), (value) => {
          if (value)
            displayedRef.value = true;
        });
        useLockHtmlScroll(vue.computed(() => props.blockScroll && displayedRef.value));
        const NModal = vue.inject(modalInjectionKey);
        function styleTransformOrigin() {
          if (NModal.transformOriginRef.value === "center") {
            return "";
          }
          const { value: transformOriginX } = transformOriginXRef;
          const { value: transformOriginY } = transformOriginYRef;
          if (transformOriginX === null || transformOriginY === null) {
            return "";
          } else if (scrollbarRef.value) {
            const scrollTop = scrollbarRef.value.containerScrollTop;
            return `${transformOriginX}px ${transformOriginY + scrollTop}px`;
          }
          return "";
        }
        function syncTransformOrigin(el) {
          if (NModal.transformOriginRef.value === "center") {
            return;
          }
          const mousePosition = NModal.getMousePosition();
          if (!mousePosition) {
            return;
          }
          if (!scrollbarRef.value)
            return;
          const scrollTop = scrollbarRef.value.containerScrollTop;
          const { offsetLeft, offsetTop } = el;
          if (mousePosition) {
            const top = mousePosition.y;
            const left = mousePosition.x;
            transformOriginXRef.value = -(offsetLeft - left);
            transformOriginYRef.value = -(offsetTop - top - scrollTop);
          }
          el.style.transformOrigin = styleTransformOrigin();
        }
        function handleEnter(el) {
          void vue.nextTick(() => {
            syncTransformOrigin(el);
          });
        }
        function handleBeforeLeave(el) {
          el.style.transformOrigin = styleTransformOrigin();
          props.onBeforeLeave();
        }
        function handleAfterLeave() {
          displayedRef.value = false;
          transformOriginXRef.value = null;
          transformOriginYRef.value = null;
          props.onAfterLeave();
        }
        function handleCloseClick() {
          const { onClose } = props;
          if (onClose) {
            onClose();
          }
        }
        function handleNegativeClick() {
          props.onNegativeClick();
        }
        function handlePositiveClick() {
          props.onPositiveClick();
        }
        const childNodeRef = vue.ref(null);
        vue.watch(childNodeRef, (node) => {
          if (node) {
            void vue.nextTick(() => {
              const el = node.el;
              if (el && bodyRef.value !== el) {
                bodyRef.value = el;
              }
            });
          }
        });
        vue.provide(modalBodyInjectionKey, bodyRef);
        vue.provide(drawerBodyInjectionKey, null);
        vue.provide(popoverBodyInjectionKey, null);
        return {
          mergedTheme: NModal.mergedThemeRef,
          appear: NModal.appearRef,
          isMounted: NModal.isMountedRef,
          mergedClsPrefix: NModal.mergedClsPrefixRef,
          bodyRef,
          scrollbarRef,
          displayed: displayedRef,
          childNodeRef,
          handlePositiveClick,
          handleNegativeClick,
          handleCloseClick,
          handleAfterLeave,
          handleBeforeLeave,
          handleEnter
        };
      },
      render() {
        const {
          $slots,
          $attrs,
          handleEnter,
          handleAfterLeave,
          handleBeforeLeave,
          preset,
          mergedClsPrefix
        } = this;
        let childNode = null;
        if (!preset) {
          childNode = getFirstSlotVNode($slots);
          if (!childNode) {
            warn$2("modal", "default slot is empty");
            return;
          }
          childNode = vue.cloneVNode(childNode);
          childNode.props = vue.mergeProps(
            {
              class: `${mergedClsPrefix}-modal`
            },
            $attrs,
            childNode.props || {}
          );
        }
        return this.displayDirective === "show" || this.displayed || this.show ? vue.withDirectives(
          /* @__PURE__ */ vue.h("div", {
            role: "none",
            class: `${mergedClsPrefix}-modal-body-wrapper`
          }, /* @__PURE__ */ vue.h(NScrollbar, {
            ref: "scrollbarRef",
            theme: this.mergedTheme.peers.Scrollbar,
            themeOverrides: this.mergedTheme.peerOverrides.Scrollbar,
            contentClass: `${mergedClsPrefix}-modal-scroll-content`
          }, {
            default: () => [
              this.renderMask?.(),
              /* @__PURE__ */ vue.h(FocusTrap, {
                disabled: !this.trapFocus,
                active: this.show,
                onEsc: this.onEsc,
                autoFocus: this.autoFocus
              }, {
                default: () => /* @__PURE__ */ vue.h(vue.Transition, {
                  name: "fade-in-scale-up-transition",
                  appear: this.appear ?? this.isMounted,
                  onEnter: handleEnter,
                  onAfterEnter: this.onAfterEnter,
                  onAfterLeave: handleAfterLeave,
                  onBeforeLeave: handleBeforeLeave
                }, {
                  default: () => {
                    const dirs = [
                      [vue.vShow, this.show]
                    ];
                    const { onClickoutside } = this;
                    if (onClickoutside) {
                      dirs.push([
                        clickoutside$1,
                        this.onClickoutside,
                        void 0,
                        { capture: true }
                      ]);
                    }
                    return vue.withDirectives(
                      this.preset === "confirm" || this.preset === "dialog" ? /* @__PURE__ */ vue.h(NDialog, {
                        ...this.$attrs,
                        class: [
                          `${mergedClsPrefix}-modal`,
                          this.$attrs.class
                        ],
                        ref: "bodyRef",
                        theme: this.mergedTheme.peers.Dialog,
                        themeOverrides: this.mergedTheme.peerOverrides.Dialog,
                        ...keep(this.$props, dialogPropKeys),
                        "aria-modal": "true"
                      }, $slots) : this.preset === "card" ? /* @__PURE__ */ vue.h(NCard, {
                        ...this.$attrs,
                        ref: "bodyRef",
                        class: [
                          `${mergedClsPrefix}-modal`,
                          this.$attrs.class
                        ],
                        theme: this.mergedTheme.peers.Card,
                        themeOverrides: this.mergedTheme.peerOverrides.Card,
                        ...keep(this.$props, cardBasePropKeys),
                        "aria-modal": "true",
                        role: "dialog"
                      }, $slots) : this.childNodeRef = childNode,
                      dirs
                    );
                  }
                })
              })
            ]
          })),
          [
            [
              vue.vShow,
              this.displayDirective === "if" || this.displayed || this.show
            ]
          ]
        ) : null;
      }
    });

    var style$O = c$1([cB("modal-container", `
    position: fixed;
    left: 0;
    top: 0;
    height: 0;
    width: 0;
    display: flex;
  `), cB("modal-mask", `
    position: fixed;
    left: 0;
    right: 0;
    top: 0;
    bottom: 0;
    background-color: rgba(0, 0, 0, .4);
  `, [fadeInTransition({
      enterDuration: ".25s",
      leaveDuration: ".25s",
      enterCubicBezier: "var(--n-bezier-ease-out)",
      leaveCubicBezier: "var(--n-bezier-ease-out)"
    })]), cB("modal-body-wrapper", `
    position: fixed;
    left: 0;
    right: 0;
    top: 0;
    bottom: 0;
    overflow: visible;
  `, [cB("modal-scroll-content", `
      min-height: 100%;
      display: flex;
      position: relative;
    `)]), cB("modal", `
    position: relative;
    align-self: center;
    color: var(--n-text-color);
    margin: auto;
    box-shadow: var(--n-box-shadow);
  `, [fadeInScaleUpTransition({
      duration: ".25s",
      enterScale: ".5"
    })])]);

    const modalProps = {
      ...useTheme.props,
      show: Boolean,
      unstableShowMask: {
        type: Boolean,
        default: true
      },
      maskClosable: {
        type: Boolean,
        default: true
      },
      preset: String,
      to: [String, Object],
      displayDirective: {
        type: String,
        default: "if"
      },
      transformOrigin: {
        type: String,
        default: "mouse"
      },
      zIndex: Number,
      autoFocus: {
        type: Boolean,
        default: true
      },
      trapFocus: {
        type: Boolean,
        default: true
      },
      closeOnEsc: {
        type: Boolean,
        default: true
      },
      blockScroll: { type: Boolean, default: true },
      ...presetProps,
      onEsc: Function,
      "onUpdate:show": [Function, Array],
      onUpdateShow: [Function, Array],
      onAfterEnter: Function,
      onBeforeLeave: Function,
      onAfterLeave: Function,
      onClose: Function,
      onPositiveClick: Function,
      onNegativeClick: Function,
      onMaskClick: Function,
      internalDialog: Boolean,
      internalAppear: {
        type: Boolean,
        default: void 0
      },
      overlayStyle: [String, Object],
      onBeforeHide: Function,
      onAfterHide: Function,
      onHide: Function
    };
    var NModal = vue.defineComponent({
      name: "Modal",
      inheritAttrs: false,
      props: modalProps,
      setup(props) {
        {
          if (props.onHide) {
            warnOnce("modal", "`on-hide` is deprecated.");
          }
          if (props.onAfterHide) {
            warnOnce(
              "modal",
              "`on-after-hide` is deprecated, please use `on-after-leave` instead."
            );
          }
          if (props.onBeforeHide) {
            warnOnce(
              "modal",
              "`on-before-hide` is deprecated, please use `on-before-leave` instead."
            );
          }
          if (props.overlayStyle) {
            warnOnce(
              "modal",
              "`overlay-style` is deprecated, please use `style` instead."
            );
          }
        }
        const containerRef = vue.ref(null);
        const { mergedClsPrefixRef, namespaceRef, inlineThemeDisabled } = useConfig(props);
        const themeRef = useTheme(
          "Modal",
          "-modal",
          style$O,
          modalLight$1,
          props,
          mergedClsPrefixRef
        );
        const clickedRef = useClicked(64);
        const clickedPositionRef = useClickPosition();
        const isMountedRef = isMounted();
        const NDialogProvider = props.internalDialog ? vue.inject(dialogProviderInjectionKey, null) : null;
        const isComposingRef = useIsComposing();
        function doUpdateShow(show) {
          const { onUpdateShow, "onUpdate:show": _onUpdateShow, onHide } = props;
          if (onUpdateShow)
            call(onUpdateShow, show);
          if (_onUpdateShow)
            call(_onUpdateShow, show);
          if (onHide && !show)
            onHide(show);
        }
        function handleCloseClick() {
          const { onClose } = props;
          if (onClose) {
            void Promise.resolve(onClose()).then((value) => {
              if (value === false)
                return;
              doUpdateShow(false);
            });
          } else {
            doUpdateShow(false);
          }
        }
        function handlePositiveClick() {
          const { onPositiveClick } = props;
          if (onPositiveClick) {
            void Promise.resolve(onPositiveClick()).then((value) => {
              if (value === false)
                return;
              doUpdateShow(false);
            });
          } else {
            doUpdateShow(false);
          }
        }
        function handleNegativeClick() {
          const { onNegativeClick } = props;
          if (onNegativeClick) {
            void Promise.resolve(onNegativeClick()).then((value) => {
              if (value === false)
                return;
              doUpdateShow(false);
            });
          } else {
            doUpdateShow(false);
          }
        }
        function handleBeforeLeave() {
          const { onBeforeLeave, onBeforeHide } = props;
          if (onBeforeLeave)
            call(onBeforeLeave);
          if (onBeforeHide)
            onBeforeHide();
        }
        function handleAfterLeave() {
          const { onAfterLeave, onAfterHide } = props;
          if (onAfterLeave)
            call(onAfterLeave);
          if (onAfterHide)
            onAfterHide();
        }
        function handleClickoutside(e) {
          const { onMaskClick } = props;
          if (onMaskClick) {
            onMaskClick(e);
          }
          if (props.maskClosable) {
            if (containerRef.value?.contains(getPreciseEventTarget(e))) {
              doUpdateShow(false);
            }
          }
        }
        function handleEsc(e) {
          props.onEsc?.();
          if (props.show && props.closeOnEsc && eventEffectNotPerformed(e)) {
            !isComposingRef.value && doUpdateShow(false);
          }
        }
        vue.provide(modalInjectionKey, {
          getMousePosition: () => {
            if (NDialogProvider) {
              const { clickedRef: clickedRef2, clickPositionRef } = NDialogProvider;
              if (clickedRef2.value && clickPositionRef.value) {
                return clickPositionRef.value;
              }
            }
            if (clickedRef.value) {
              return clickedPositionRef.value;
            }
            return null;
          },
          mergedClsPrefixRef,
          mergedThemeRef: themeRef,
          isMountedRef,
          appearRef: vue.toRef(props, "internalAppear"),
          transformOriginRef: vue.toRef(props, "transformOrigin")
        });
        const cssVarsRef = vue.computed(() => {
          const {
            common: { cubicBezierEaseOut },
            self: { boxShadow, color, textColor }
          } = themeRef.value;
          return {
            "--n-bezier-ease-out": cubicBezierEaseOut,
            "--n-box-shadow": boxShadow,
            "--n-color": color,
            "--n-text-color": textColor
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("theme-class", void 0, cssVarsRef, props) : void 0;
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          namespace: namespaceRef,
          isMounted: isMountedRef,
          containerRef,
          presetProps: vue.computed(() => {
            const pickedProps = keep(props, presetPropsKeys);
            return pickedProps;
          }),
          handleEsc,
          handleAfterLeave,
          handleClickoutside,
          handleBeforeLeave,
          doUpdateShow,
          handleNegativeClick,
          handlePositiveClick,
          handleCloseClick,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender
        };
      },
      render() {
        const { mergedClsPrefix } = this;
        return /* @__PURE__ */ vue.h(LazyTeleport, {
          to: this.to,
          show: this.show
        }, {
          default: () => {
            this.onRender?.();
            const { unstableShowMask } = this;
            return vue.withDirectives(
              /* @__PURE__ */ vue.h("div", {
                role: "none",
                ref: "containerRef",
                class: [
                  `${mergedClsPrefix}-modal-container`,
                  this.themeClass,
                  this.namespace
                ],
                style: this.cssVars
              }, /* @__PURE__ */ vue.h(NModalBodyWrapper, {
                style: this.overlayStyle,
                ...this.$attrs,
                ref: "bodyWrapper",
                displayDirective: this.displayDirective,
                show: this.show,
                preset: this.preset,
                autoFocus: this.autoFocus,
                trapFocus: this.trapFocus,
                blockScroll: this.blockScroll,
                ...this.presetProps,
                onEsc: this.handleEsc,
                onClose: this.handleCloseClick,
                onNegativeClick: this.handleNegativeClick,
                onPositiveClick: this.handlePositiveClick,
                onBeforeLeave: this.handleBeforeLeave,
                onAfterEnter: this.onAfterEnter,
                onAfterLeave: this.handleAfterLeave,
                onClickoutside: unstableShowMask ? void 0 : this.handleClickoutside,
                renderMask: unstableShowMask ? () => /* @__PURE__ */ vue.h(vue.Transition, {
                  name: "fade-in-transition",
                  key: "mask",
                  appear: this.internalAppear ?? this.isMounted
                }, {
                  default: () => {
                    return this.show ? /* @__PURE__ */ vue.h("div", {
                      "aria-hidden": true,
                      ref: "containerRef",
                      class: `${mergedClsPrefix}-modal-mask`,
                      onClick: this.handleClickoutside
                    }) : null;
                  }
                }) : void 0
              }, this.$slots)),
              [
                [
                  zindexable$1,
                  {
                    zIndex: this.zIndex,
                    enabled: this.show
                  }
                ]
              ]
            );
          }
        });
      }
    });

    const exposedDialogEnvProps = {
      ...dialogProps,
      blockScroll: { type: Boolean, default: true },
      closeOnEsc: { type: Boolean, default: true },
      onEsc: Function,
      autoFocus: {
        type: Boolean,
        default: true
      },
      internalStyle: [String, Object],
      maskClosable: {
        type: Boolean,
        default: true
      },
      onPositiveClick: Function,
      onNegativeClick: Function,
      onClose: Function,
      onMaskClick: Function
    };
    const NDialogEnvironment = vue.defineComponent({
      name: "DialogEnvironment",
      props: {
        ...exposedDialogEnvProps,
        internalKey: {
          type: String,
          required: true
        },
        to: [String, Object],
        onInternalAfterLeave: {
          type: Function,
          required: true
        }
      },
      setup(props) {
        const showRef = vue.ref(true);
        function handleAfterLeave() {
          props.onInternalAfterLeave(props.internalKey);
        }
        function handlePositiveClick(e) {
          const { onPositiveClick } = props;
          if (onPositiveClick) {
            void Promise.resolve(onPositiveClick(e)).then((result) => {
              if (result === false)
                return;
              hide();
            });
          } else {
            hide();
          }
        }
        function handleNegativeClick(e) {
          const { onNegativeClick } = props;
          if (onNegativeClick) {
            void Promise.resolve(onNegativeClick(e)).then((result) => {
              if (result === false)
                return;
              hide();
            });
          } else {
            hide();
          }
        }
        function handleCloseClick() {
          const { onClose } = props;
          if (onClose) {
            void Promise.resolve(onClose()).then((result) => {
              if (result === false)
                return;
              hide();
            });
          } else {
            hide();
          }
        }
        function handleMaskClick(e) {
          const { onMaskClick, maskClosable } = props;
          if (onMaskClick) {
            onMaskClick(e);
            maskClosable && hide();
          }
        }
        function handleEsc() {
          const { onEsc } = props;
          if (onEsc) {
            onEsc();
          }
        }
        function hide() {
          showRef.value = false;
        }
        function handleUpdateShow(value) {
          showRef.value = value;
        }
        return {
          show: showRef,
          hide,
          handleUpdateShow,
          handleAfterLeave,
          handleCloseClick,
          handleNegativeClick,
          handlePositiveClick,
          handleMaskClick,
          handleEsc
        };
      },
      render() {
        const {
          handlePositiveClick,
          handleUpdateShow,
          handleNegativeClick,
          handleCloseClick,
          handleAfterLeave,
          handleMaskClick,
          handleEsc,
          to,
          maskClosable,
          show
        } = this;
        return /* @__PURE__ */ vue.h(NModal, {
          show,
          onUpdateShow: handleUpdateShow,
          onMaskClick: handleMaskClick,
          onEsc: handleEsc,
          to,
          maskClosable,
          onAfterLeave: handleAfterLeave,
          closeOnEsc: this.closeOnEsc,
          blockScroll: this.blockScroll,
          autoFocus: this.autoFocus,
          internalAppear: true,
          internalDialog: true
        }, {
          default: () => /* @__PURE__ */ vue.h(NDialog, {
            ...keep(this.$props, dialogPropKeys),
            style: this.internalStyle,
            onClose: handleCloseClick,
            onNegativeClick: handleNegativeClick,
            onPositiveClick: handlePositiveClick
          })
        });
      }
    });

    const dialogProviderProps = {
      injectionKey: String,
      to: [String, Object]
    };
    const NDialogProvider = vue.defineComponent({
      name: "DialogProvider",
      props: dialogProviderProps,

      setup() {
        const dialogListRef = vue.ref([]);
        const dialogInstRefs = {};

        function create() {
          let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          const key = createId();
          const dialogReactive = vue.reactive({ ...options,
            key,
            destroy: () => {
              dialogInstRefs[`n-dialog-${key}`].hide();
            }
          });
          dialogListRef.value.push(dialogReactive);
          return dialogReactive;
        }

        const typedApi = ["info", "success", "warning", "error"].map(type => options => {
          return create({ ...options,
            type
          });
        });

        function handleAfterLeave(key) {
          const {
            value: dialogList
          } = dialogListRef;
          dialogList.splice(dialogList.findIndex(dialog => dialog.key === key), 1);
        }

        function destroyAll() {
          Object.values(dialogInstRefs).forEach(dialogInstRef => dialogInstRef.hide());
        }

        const api = {
          create,
          destroyAll,
          info: typedApi[0],
          success: typedApi[1],
          warning: typedApi[2],
          error: typedApi[3]
        };
        vue.provide(dialogApiInjectionKey, api);
        vue.provide(dialogProviderInjectionKey, {
          clickedRef: useClicked(64),
          clickPositionRef: useClickPosition()
        });
        return { ...api,
          dialogList: dialogListRef,
          dialogInstRefs,
          handleAfterLeave
        };
      },

      render() {
        var _this$$slots$default, _this$$slots;

        return vue.h(vue.Fragment, null, [this.dialogList.map(dialog => vue.h(NDialogEnvironment, omit(dialog, ["destroy", "style"], {
          internalStyle: dialog.style,
          to: this.to,
          ref: inst => {
            if (inst === null) {
              delete this.dialogInstRefs[`n-dialog-${dialog.key}`];
            } else {
              this.dialogInstRefs[`n-dialog-${dialog.key}`] = inst;
            }
          },
          internalKey: dialog.key,
          onInternalAfterLeave: this.handleAfterLeave
        }))), (_this$$slots$default = (_this$$slots = this.$slots).default) === null || _this$$slots$default === void 0 ? void 0 : _this$$slots$default.call(_this$$slots)]);
      }

    });

    function useDialog() {
      const dialog = vue.inject(dialogApiInjectionKey, null);

      if (dialog === null) {
        throwError("use-dialog", "No outer <n-dialog-provider /> founded.");
      }

      return dialog;
    }

    const self$C = vars => {
      const {
        textColor1,
        dividerColor,
        fontWeightStrong
      } = vars;
      return {
        textColor: textColor1,
        color: dividerColor,
        fontWeight: fontWeightStrong
      };
    };
    const dividerLight = {
      name: "Divider",
      common: commonLight,
      self: self$C
    };
    var dividerLight$1 = dividerLight;

    const dividerDark = {
      name: "Divider",
      common: commonDark,
      self: self$C
    };
    var dividerDark$1 = dividerDark;

    var style$N = cB("divider", `
  position: relative;
  display: flex;
  width: 100%;
  box-sizing: border-box;
  font-size: 16px;
  color: var(--n-text-color);
  transition:
    color .3s var(--n-bezier),
    background-color .3s var(--n-bezier);
`, [cNotM("vertical", `
    margin-top: 24px;
    margin-bottom: 24px;
  `, [cNotM("no-title", `
      display: flex;
      align-items: center;
    `)]), cE("title", `
    display: flex;
    align-items: center;
    margin-left: 12px;
    margin-right: 12px;
    white-space: nowrap;
    font-weight: var(--n-font-weight);
  `), cM("title-position-left", [cE("line", [cM("left", {
      width: "28px"
    })])]), cM("title-position-right", [cE("line", [cM("right", {
      width: "28px"
    })])]), cM("dashed", [cE("line", `
      background-color: #0000;
      height: 0px;
      width: 100%;
      border-style: dashed;
      border-width: 1px 0 0;
    `)]), cM("vertical", `
    display: inline-block;
    height: 1em;
    margin: 0 8px;
    vertical-align: middle;
    width: 1px;
  `), cE("line", `
    border: none;
    transition: background-color .3s var(--n-bezier), border-color .3s var(--n-bezier);
    height: 1px;
    width: 100%;
    margin: 0;
  `), cNotM("dashed", [cE("line", {
      backgroundColor: "var(--n-color)"
    })]), cM("dashed", [cE("line", {
      borderColor: "var(--n-color)"
    })]), cM("vertical", {
      backgroundColor: "var(--n-color)"
    })]);

    const dividerProps = {
      ...useTheme.props,
      titlePlacement: {
        type: String,
        default: "center"
      },
      dashed: Boolean,
      vertical: Boolean
    };
    var NDivider = vue.defineComponent({
      name: "Divider",
      props: dividerProps,
      setup(props) {
        const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
        const themeRef = useTheme(
          "Divider",
          "-divider",
          style$N,
          dividerLight$1,
          props,
          mergedClsPrefixRef
        );
        const cssVarsRef = vue.computed(() => {
          const {
            common: { cubicBezierEaseInOut },
            self: { color, textColor, fontWeight }
          } = themeRef.value;
          return {
            "--n-bezier": cubicBezierEaseInOut,
            "--n-color": color,
            "--n-text-color": textColor,
            "--n-font-weight": fontWeight
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("divider", void 0, cssVarsRef, props) : void 0;
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender
        };
      },
      render() {
        const {
          $slots,
          titlePlacement,
          vertical,
          dashed,
          cssVars,
          mergedClsPrefix
        } = this;
        this.onRender?.();
        return /* @__PURE__ */ vue.h("div", {
          role: "separator",
          class: [
            `${mergedClsPrefix}-divider`,
            this.themeClass,
            {
              [`${mergedClsPrefix}-divider--vertical`]: vertical,
              [`${mergedClsPrefix}-divider--no-title`]: !$slots.default,
              [`${mergedClsPrefix}-divider--dashed`]: dashed,
              [`${mergedClsPrefix}-divider--title-position-${titlePlacement}`]: $slots.default && titlePlacement
            }
          ],
          style: cssVars
        }, !vertical ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-divider__line ${mergedClsPrefix}-divider__line--left`
        }) : null, !vertical && $slots.default ? /* @__PURE__ */ vue.h(vue.Fragment, null, /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-divider__title`
        }, this.$slots), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-divider__line ${mergedClsPrefix}-divider__line--right`
        })) : null);
      }
    });

    const self$B = vars => {
      const {
        modalColor,
        textColor1,
        textColor2,
        boxShadow3,
        lineHeight,
        fontWeightStrong,
        dividerColor,
        closeColorHover,
        closeColorPressed,
        closeIconColor,
        closeIconColorHover,
        closeIconColorPressed,
        borderRadius,
        primaryColorHover
      } = vars;
      return {
        bodyPadding: "16px 24px",
        headerPadding: "16px 24px",
        footerPadding: "16px 24px",
        color: modalColor,
        textColor: textColor2,
        titleTextColor: textColor1,
        titleFontSize: "18px",
        titleFontWeight: fontWeightStrong,
        boxShadow: boxShadow3,
        lineHeight,
        headerBorderBottom: `1px solid ${dividerColor}`,
        footerBorderTop: `1px solid ${dividerColor}`,
        closeIconColor,
        closeIconColorHover,
        closeIconColorPressed,
        closeSize: "22px",
        closeIconSize: "18px",
        closeColorHover,
        closeColorPressed,
        closeBorderRadius: borderRadius,
        resizableTriggerColorHover: primaryColorHover
      };
    };
    const drawerLight = createTheme$1({
      name: "Drawer",
      common: commonLight,
      peers: {
        Scrollbar: scrollbarLight$1
      },
      self: self$B
    });
    var drawerLight$1 = drawerLight;

    const drawerDark = {
      name: "Drawer",
      common: commonDark,
      peers: {
        Scrollbar: scrollbarDark$1
      },
      self: self$B
    };
    var drawerDark$1 = drawerDark;

    var rtlStyle$e = cB("drawer", [cM("rtl", `
    direction: rtl;
    text-align: right;
  `, [cB("drawer-content", [cB("drawer-header", [cE("close", `
          margin-left: 0;
          margin-right: 6px;
        `)])])])]);

    const drawerRtl = {
      name: "Drawer",
      style: rtlStyle$e,
      peers: [scrollbarRtl]
    };
    var drawerRtl$1 = drawerRtl;

    var NDrawerBodyWrapper = vue.defineComponent({
      name: "NDrawerContent",
      inheritAttrs: false,
      props: {
        blockScroll: Boolean,
        show: {
          type: Boolean,
          default: void 0
        },
        displayDirective: {
          type: String,
          required: true
        },
        placement: {
          type: String,
          required: true
        },
        contentStyle: [Object, String],
        nativeScrollbar: {
          type: Boolean,
          required: true
        },
        scrollbarProps: Object,
        trapFocus: {
          type: Boolean,
          default: true
        },
        autoFocus: {
          type: Boolean,
          default: true
        },
        showMask: {
          type: [Boolean, String],
          required: true
        },
        resizable: Boolean,
        onClickoutside: Function,
        onAfterLeave: Function,
        onAfterEnter: Function,
        onEsc: Function
      },
      setup(props) {
        const displayedRef = vue.ref(!!props.show);
        const bodyRef = vue.ref(null);
        const NDrawer = vue.inject(drawerInjectionKey);
        let startPosition = 0;
        let memoizedBodyStyleCursor = "";
        let hoverTimerId = null;
        const isHoverOnResizeTriggerRef = vue.ref(false);
        const isDraggingRef = vue.ref(false);
        const isVertical = vue.computed(() => {
          return props.placement === "top" || props.placement === "bottom";
        });
        const { mergedClsPrefixRef, mergedRtlRef } = useConfig(props);
        const rtlEnabledRef = useRtl("Drawer", mergedRtlRef, mergedClsPrefixRef);
        const handleMousedownResizeTrigger = (e) => {
          isDraggingRef.value = true;
          startPosition = isVertical.value ? e.clientY : e.clientX;
          memoizedBodyStyleCursor = document.body.style.cursor;
          document.body.style.cursor = isVertical.value ? "ns-resize" : "ew-resize";
          document.body.addEventListener("mousemove", handleBodyMousemove);
          document.body.addEventListener("mouseleave", handleBodyMouseleave);
          document.body.addEventListener("mouseup", handleBodyMouseup);
        };
        const handleMouseenterResizeTrigger = () => {
          if (hoverTimerId !== null) {
            window.clearTimeout(hoverTimerId);
            hoverTimerId = null;
          }
          if (isDraggingRef.value) {
            isHoverOnResizeTriggerRef.value = true;
          } else {
            hoverTimerId = window.setTimeout(() => {
              isHoverOnResizeTriggerRef.value = true;
            }, 300);
          }
        };
        const handleMouseleaveResizeTrigger = () => {
          if (hoverTimerId !== null) {
            window.clearTimeout(hoverTimerId);
            hoverTimerId = null;
          }
          isHoverOnResizeTriggerRef.value = false;
        };
        const { doUpdateHeight, doUpdateWidth } = NDrawer;
        const handleBodyMousemove = (e) => {
          if (isDraggingRef.value) {
            if (isVertical.value) {
              let height = bodyRef.value?.offsetHeight || 0;
              const increment = startPosition - e.clientY;
              height += props.placement === "bottom" ? increment : -increment;
              doUpdateHeight(height);
              startPosition = e.clientY;
            } else {
              let width = bodyRef.value?.offsetWidth || 0;
              const increment = startPosition - e.clientX;
              width += props.placement === "right" ? increment : -increment;
              doUpdateWidth(width);
              startPosition = e.clientX;
            }
          }
        };
        const handleBodyMouseup = () => {
          if (isDraggingRef.value) {
            startPosition = 0;
            isDraggingRef.value = false;
            document.body.style.cursor = memoizedBodyStyleCursor;
            document.body.removeEventListener("mousemove", handleBodyMousemove);
            document.body.removeEventListener("mouseup", handleBodyMouseup);
            document.body.removeEventListener("mouseleave", handleBodyMouseleave);
          }
        };
        const handleBodyMouseleave = handleBodyMouseup;
        vue.watchEffect(() => {
          if (props.show)
            displayedRef.value = true;
        });
        vue.watch(
          () => props.show,
          (value) => {
            if (!value) {
              handleBodyMouseup();
            }
          }
        );
        vue.onBeforeUnmount(() => {
          handleBodyMouseup();
        });
        const bodyDirectivesRef = vue.computed(() => {
          const { show } = props;
          const directives = [[vue.vShow, show]];
          if (!props.showMask) {
            directives.push([
              clickoutside$1,
              props.onClickoutside,
              void 0,
              { capture: true }
            ]);
          }
          return directives;
        });
        function handleAfterLeave() {
          displayedRef.value = false;
          props.onAfterLeave?.();
        }
        useLockHtmlScroll(vue.computed(() => props.blockScroll && displayedRef.value));
        vue.provide(drawerBodyInjectionKey, bodyRef);
        vue.provide(popoverBodyInjectionKey, null);
        vue.provide(modalBodyInjectionKey, null);
        return {
          bodyRef,
          rtlEnabled: rtlEnabledRef,
          mergedClsPrefix: NDrawer.mergedClsPrefixRef,
          isMounted: NDrawer.isMountedRef,
          mergedTheme: NDrawer.mergedThemeRef,
          displayed: displayedRef,
          transitionName: vue.computed(() => {
            return {
              right: "slide-in-from-right-transition",
              left: "slide-in-from-left-transition",
              top: "slide-in-from-top-transition",
              bottom: "slide-in-from-bottom-transition"
            }[props.placement];
          }),
          handleAfterLeave,
          bodyDirectives: bodyDirectivesRef,
          handleMousedownResizeTrigger,
          handleMouseenterResizeTrigger,
          handleMouseleaveResizeTrigger,
          isDragging: isDraggingRef,
          isHoverOnResizeTrigger: isHoverOnResizeTriggerRef
        };
      },
      render() {
        const { $slots, mergedClsPrefix } = this;
        return this.displayDirective === "show" || this.displayed || this.show ? vue.withDirectives(
          /* @__PURE__ */ vue.h("div", {
            role: "none"
          }, /* @__PURE__ */ vue.h(FocusTrap, {
            disabled: !this.showMask || !this.trapFocus,
            active: this.show,
            autoFocus: this.autoFocus,
            onEsc: this.onEsc
          }, {
            default: () => /* @__PURE__ */ vue.h(vue.Transition, {
              name: this.transitionName,
              appear: this.isMounted,
              onAfterEnter: this.onAfterEnter,
              onAfterLeave: this.handleAfterLeave
            }, {
              default: () => vue.withDirectives(
                vue.h(
                  "div",
                  vue.mergeProps(this.$attrs, {
                    role: "dialog",
                    ref: "bodyRef",
                    "aria-modal": "true",
                    class: [
                      `${mergedClsPrefix}-drawer`,
                      this.rtlEnabled && `${mergedClsPrefix}-drawer--rtl`,
                      `${mergedClsPrefix}-drawer--${this.placement}-placement`,
                      this.isDragging && `${mergedClsPrefix}-drawer--unselectable`,
                      this.nativeScrollbar && `${mergedClsPrefix}-drawer--native-scrollbar`
                    ]
                  }),
                  [
                    this.resizable ? /* @__PURE__ */ vue.h("div", {
                      class: [
                        `${mergedClsPrefix}-drawer__resize-trigger`,
                        (this.isDragging || this.isHoverOnResizeTrigger) && `${mergedClsPrefix}-drawer__resize-trigger--hover`
                      ],
                      onMouseenter: this.handleMouseenterResizeTrigger,
                      onMouseleave: this.handleMouseleaveResizeTrigger,
                      onMousedown: this.handleMousedownResizeTrigger
                    }) : null,
                    this.nativeScrollbar ? /* @__PURE__ */ vue.h("div", {
                      class: `${mergedClsPrefix}-drawer-content-wrapper`,
                      style: this.contentStyle,
                      role: "none"
                    }, $slots) : /* @__PURE__ */ vue.h(NScrollbar, {
                      ...this.scrollbarProps,
                      contentStyle: this.contentStyle,
                      contentClass: `${mergedClsPrefix}-drawer-content-wrapper`,
                      theme: this.mergedTheme.peers.Scrollbar,
                      themeOverrides: this.mergedTheme.peerOverrides.Scrollbar
                    }, $slots)
                  ]
                ),
                this.bodyDirectives
              )
            })
          })),
          [
            [
              vue.vShow,
              this.displayDirective === "if" || this.displayed || this.show
            ]
          ]
        ) : null;
      }
    });

    const {
      cubicBezierEaseIn: cubicBezierEaseIn$3,
      cubicBezierEaseOut: cubicBezierEaseOut$3
    } = commonVariables$m;
    function slideInFromRightTransition() {
      let {
        duration = "0.3s",
        leaveDuration = "0.2s",
        name = "slide-in-from-right"
      } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return [c$1(`&.${name}-transition-leave-active`, {
        transition: `transform ${leaveDuration} ${cubicBezierEaseIn$3}`
      }), c$1(`&.${name}-transition-enter-active`, {
        transition: `transform ${duration} ${cubicBezierEaseOut$3}`
      }), c$1(`&.${name}-transition-enter-to`, {
        transform: "translateX(0)"
      }), c$1(`&.${name}-transition-enter-from`, {
        transform: "translateX(100%)"
      }), c$1(`&.${name}-transition-leave-from`, {
        transform: "translateX(0)"
      }), c$1(`&.${name}-transition-leave-to`, {
        transform: "translateX(100%)"
      })];
    }

    const {
      cubicBezierEaseIn: cubicBezierEaseIn$2,
      cubicBezierEaseOut: cubicBezierEaseOut$2
    } = commonVariables$m;
    function slideInFromLeftTransition() {
      let {
        duration = "0.3s",
        leaveDuration = "0.2s",
        name = "slide-in-from-left"
      } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return [c$1(`&.${name}-transition-leave-active`, {
        transition: `transform ${leaveDuration} ${cubicBezierEaseIn$2}`
      }), c$1(`&.${name}-transition-enter-active`, {
        transition: `transform ${duration} ${cubicBezierEaseOut$2}`
      }), c$1(`&.${name}-transition-enter-to`, {
        transform: "translateX(0)"
      }), c$1(`&.${name}-transition-enter-from`, {
        transform: "translateX(-100%)"
      }), c$1(`&.${name}-transition-leave-from`, {
        transform: "translateX(0)"
      }), c$1(`&.${name}-transition-leave-to`, {
        transform: "translateX(-100%)"
      })];
    }

    const {
      cubicBezierEaseIn: cubicBezierEaseIn$1,
      cubicBezierEaseOut: cubicBezierEaseOut$1
    } = commonVariables$m;
    function slideInFromTopTransition() {
      let {
        duration = "0.3s",
        leaveDuration = "0.2s",
        name = "slide-in-from-top"
      } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return [c$1(`&.${name}-transition-leave-active`, {
        transition: `transform ${leaveDuration} ${cubicBezierEaseIn$1}`
      }), c$1(`&.${name}-transition-enter-active`, {
        transition: `transform ${duration} ${cubicBezierEaseOut$1}`
      }), c$1(`&.${name}-transition-enter-to`, {
        transform: "translateY(0)"
      }), c$1(`&.${name}-transition-enter-from`, {
        transform: "translateY(-100%)"
      }), c$1(`&.${name}-transition-leave-from`, {
        transform: "translateY(0)"
      }), c$1(`&.${name}-transition-leave-to`, {
        transform: "translateY(-100%)"
      })];
    }

    const {
      cubicBezierEaseIn,
      cubicBezierEaseOut
    } = commonVariables$m;
    function slideInFromBottomTransition() {
      let {
        duration = "0.3s",
        leaveDuration = "0.2s",
        name = "slide-in-from-bottom"
      } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return [c$1(`&.${name}-transition-leave-active`, {
        transition: `transform ${leaveDuration} ${cubicBezierEaseIn}`
      }), c$1(`&.${name}-transition-enter-active`, {
        transition: `transform ${duration} ${cubicBezierEaseOut}`
      }), c$1(`&.${name}-transition-enter-to`, {
        transform: "translateY(0)"
      }), c$1(`&.${name}-transition-enter-from`, {
        transform: "translateY(100%)"
      }), c$1(`&.${name}-transition-leave-from`, {
        transform: "translateY(0)"
      }), c$1(`&.${name}-transition-leave-to`, {
        transform: "translateY(100%)"
      })];
    }

    var style$M = c$1([cB("drawer", `
    word-break: break-word;
    line-height: var(--n-line-height);
    position: absolute;
    pointer-events: all;
    box-shadow: var(--n-box-shadow);
    transition:
      background-color .3s var(--n-bezier),
      color .3s var(--n-bezier);
    background-color: var(--n-color);
    color: var(--n-text-color);
    box-sizing: border-box;
  `, [slideInFromRightTransition(), slideInFromLeftTransition(), slideInFromTopTransition(), slideInFromBottomTransition(), cM("unselectable", `
      user-select: none;
      -webkit-user-select: none;
    `), cM("native-scrollbar", [cB("drawer-content-wrapper", `
        overflow: auto;
        height: 100%;
      `)]), cE("resize-trigger", `
      position: absolute;
      background-color: #0000;
      transition: background-color .3s var(--n-bezier);
    `, [cM("hover", `
        background-color: var(--n-resize-trigger-color-hover);
      `)]), cB("drawer-content-wrapper", `
      box-sizing: border-box;
    `), cB("drawer-content", `
      height: 100%;
      display: flex;
      flex-direction: column;
    `, [cM("native-scrollbar", [cB("drawer-body-content-wrapper", `
          height: 100%;
          overflow: auto;
        `)]), cB("drawer-body", `
        flex: 1 0 0;
        overflow: hidden;
      `), cB("drawer-body-content-wrapper", `
        box-sizing: border-box;
        padding: var(--n-body-padding);
      `), cB("drawer-header", `
        font-weight: var(--n-title-font-weight);
        line-height: 1;
        font-size: var(--n-title-font-size);
        color: var(--n-title-text-color);
        padding: var(--n-header-padding);
        transition: border .3s var(--n-bezier);
        border-bottom: 1px solid var(--n-divider-color);
        border-bottom: var(--n-header-border-bottom);
        display: flex;
        justify-content: space-between;
        align-items: center;
      `, [cE("close", `
          margin-left: 6px;
          transition:
            background-color .3s var(--n-bezier),
            color .3s var(--n-bezier);
        `)]), cB("drawer-footer", `
        display: flex;
        justify-content: flex-end;
        border-top: var(--n-footer-border-top);
        transition: border .3s var(--n-bezier);
        padding: var(--n-footer-padding);
      `)]), cM("right-placement", `
      top: 0;
      bottom: 0;
      right: 0;
    `, [cE("resize-trigger", `
        width: 3px;
        height: 100%;
        top: 0;
        left: 0;
        transform: translateX(-1.5px);
        cursor: ew-resize;
      `)]), cM("left-placement", `
      top: 0;
      bottom: 0;
      left: 0;
    `, [cE("resize-trigger", `
        width: 3px;
        height: 100%;
        top: 0;
        right: 0;
        transform: translateX(1.5px);
        cursor: ew-resize;
      `)]), cM("top-placement", `
      top: 0;
      left: 0;
      right: 0;
    `, [cE("resize-trigger", `
        width: 100%;
        height: 3px;
        bottom: 0;
        left: 0;
        transform: translateY(1.5px);
        cursor: ns-resize;
      `)]), cM("bottom-placement", `
      left: 0;
      bottom: 0;
      right: 0;
    `, [cE("resize-trigger", `
        width: 100%;
        height: 3px;
        top: 0;
        left: 0;
        transform: translateY(-1.5px);
        cursor: ns-resize;
      `)])]), c$1("body", [c$1(">", [cB("drawer-container", {
      position: "fixed"
    })])]), cB("drawer-container", `
    position: relative;
    position: absolute;
    left: 0;
    right: 0;
    top: 0;
    bottom: 0;
    pointer-events: none;
  `, [c$1("> *", {
      pointerEvents: "all"
    })]), cB("drawer-mask", `
    background-color: rgba(0, 0, 0, .3);
    position: absolute;
    left: 0;
    right: 0;
    top: 0;
    bottom: 0;
  `, [cM("invisible", `
      background-color: rgba(0, 0, 0, 0)
    `), fadeInTransition({
      enterDuration: "0.2s",
      leaveDuration: "0.2s",
      enterCubicBezier: "var(--n-bezier-in)",
      leaveCubicBezier: "var(--n-bezier-out)"
    })])]);

    const drawerProps = {
      ...useTheme.props,
      show: Boolean,
      width: [Number, String],
      height: [Number, String],
      placement: {
        type: String,
        default: "right"
      },
      maskClosable: {
        type: Boolean,
        default: true
      },
      showMask: {
        type: [Boolean, String],
        default: true
      },
      to: [String, Object],
      displayDirective: {
        type: String,
        default: "if"
      },
      nativeScrollbar: {
        type: Boolean,
        default: true
      },
      zIndex: Number,
      onMaskClick: Function,
      scrollbarProps: Object,
      contentStyle: [Object, String],
      trapFocus: {
        type: Boolean,
        default: true
      },
      onEsc: Function,
      autoFocus: {
        type: Boolean,
        default: true
      },
      closeOnEsc: {
        type: Boolean,
        default: true
      },
      blockScroll: {
        type: Boolean,
        default: true
      },
      resizable: Boolean,
      defaultWidth: {
        type: [Number, String],
        default: 251
      },
      defaultHeight: {
        type: [Number, String],
        default: 251
      },
      onUpdateWidth: [Function, Array],
      onUpdateHeight: [Function, Array],
      "onUpdate:width": [Function, Array],
      "onUpdate:height": [Function, Array],
      "onUpdate:show": [Function, Array],
      onUpdateShow: [Function, Array],
      onAfterEnter: Function,
      onAfterLeave: Function,
      drawerStyle: [String, Object],
      drawerClass: String,
      target: null,
      onShow: Function,
      onHide: Function
    };
    var Drawer = vue.defineComponent({
      name: "Drawer",
      inheritAttrs: false,
      props: drawerProps,
      setup(props) {
        {
          vue.watchEffect(() => {
            if (props.drawerStyle !== void 0) {
              warnOnce(
                "drawer",
                "`drawer-style` is deprecated, please use `style` instead."
              );
            }
            if (props.drawerClass !== void 0) {
              warnOnce(
                "drawer",
                "`drawer-class` is deprecated, please use `class` instead."
              );
            }
            if (props.target !== void 0) {
              warnOnce("drawer", "`target` is deprecated, please use `to` instead.");
            }
            if (props.onShow !== void 0) {
              warnOnce(
                "drawer",
                "`on-show` is deprecated, please use `on-update:show` instead."
              );
            }
            if (props.onHide !== void 0) {
              warnOnce(
                "drawer",
                "`on-hide` is deprecated, please use `on-update:show` instead."
              );
            }
          });
        }
        const { mergedClsPrefixRef, namespaceRef, inlineThemeDisabled } = useConfig(props);
        const isMountedRef = isMounted();
        const themeRef = useTheme(
          "Drawer",
          "-drawer",
          style$M,
          drawerLight$1,
          props,
          mergedClsPrefixRef
        );
        const uncontrolledWidthRef = vue.ref(props.defaultWidth);
        const uncontrolledHeightRef = vue.ref(props.defaultHeight);
        const mergedWidthRef = useMergedState(
          vue.toRef(props, "width"),
          uncontrolledWidthRef
        );
        const mergedHeightRef = useMergedState(
          vue.toRef(props, "height"),
          uncontrolledHeightRef
        );
        const styleWidthRef = vue.computed(() => {
          const { placement } = props;
          if (placement === "top" || placement === "bottom")
            return "";
          return formatLength(mergedWidthRef.value);
        });
        const styleHeightRef = vue.computed(() => {
          const { placement } = props;
          if (placement === "left" || placement === "right")
            return "";
          return formatLength(mergedHeightRef.value);
        });
        const doUpdateWidth = (value) => {
          const { onUpdateWidth, "onUpdate:width": _onUpdateWidth } = props;
          if (onUpdateWidth)
            call(onUpdateWidth, value);
          if (_onUpdateWidth)
            call(_onUpdateWidth, value);
          uncontrolledWidthRef.value = value;
        };
        const doUpdateHeight = (value) => {
          const { onUpdateHeight, "onUpdate:width": _onUpdateHeight } = props;
          if (onUpdateHeight)
            call(onUpdateHeight, value);
          if (_onUpdateHeight)
            call(_onUpdateHeight, value);
          uncontrolledHeightRef.value = value;
        };
        const mergedBodyStyleRef = vue.computed(() => {
          return [
            {
              width: styleWidthRef.value,
              height: styleHeightRef.value
            },
            props.drawerStyle || ""
          ];
        });
        function handleMaskClick(e) {
          const { onMaskClick, maskClosable } = props;
          if (maskClosable) {
            doUpdateShow(false);
          }
          if (onMaskClick)
            onMaskClick(e);
        }
        const isComposingRef = useIsComposing();
        function handleEsc(e) {
          props.onEsc?.();
          if (props.show && props.closeOnEsc && eventEffectNotPerformed(e)) {
            !isComposingRef.value && doUpdateShow(false);
          }
        }
        function doUpdateShow(show) {
          const { onHide, onUpdateShow, "onUpdate:show": _onUpdateShow } = props;
          if (onUpdateShow)
            call(onUpdateShow, show);
          if (_onUpdateShow)
            call(_onUpdateShow, show);
          if (onHide && !show)
            call(onHide, show);
        }
        vue.provide(drawerInjectionKey, {
          isMountedRef,
          mergedThemeRef: themeRef,
          mergedClsPrefixRef,
          doUpdateShow,
          doUpdateHeight,
          doUpdateWidth
        });
        const cssVarsRef = vue.computed(() => {
          const {
            common: { cubicBezierEaseInOut, cubicBezierEaseIn, cubicBezierEaseOut },
            self: {
              color,
              textColor,
              boxShadow,
              lineHeight,
              headerPadding,
              footerPadding,
              bodyPadding,
              titleFontSize,
              titleTextColor,
              titleFontWeight,
              headerBorderBottom,
              footerBorderTop,
              closeIconColor,
              closeIconColorHover,
              closeIconColorPressed,
              closeColorHover,
              closeColorPressed,
              closeIconSize,
              closeSize,
              closeBorderRadius,
              resizableTriggerColorHover
            }
          } = themeRef.value;
          return {
            "--n-line-height": lineHeight,
            "--n-color": color,
            "--n-text-color": textColor,
            "--n-box-shadow": boxShadow,
            "--n-bezier": cubicBezierEaseInOut,
            "--n-bezier-out": cubicBezierEaseOut,
            "--n-bezier-in": cubicBezierEaseIn,
            "--n-header-padding": headerPadding,
            "--n-body-padding": bodyPadding,
            "--n-footer-padding": footerPadding,
            "--n-title-text-color": titleTextColor,
            "--n-title-font-size": titleFontSize,
            "--n-title-font-weight": titleFontWeight,
            "--n-header-border-bottom": headerBorderBottom,
            "--n-footer-border-top": footerBorderTop,
            "--n-close-icon-color": closeIconColor,
            "--n-close-icon-color-hover": closeIconColorHover,
            "--n-close-icon-color-pressed": closeIconColorPressed,
            "--n-close-size": closeSize,
            "--n-close-color-hover": closeColorHover,
            "--n-close-color-pressed": closeColorPressed,
            "--n-close-icon-size": closeIconSize,
            "--n-close-border-radius": closeBorderRadius,
            "--n-resize-trigger-color-hover": resizableTriggerColorHover
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("drawer", void 0, cssVarsRef, props) : void 0;
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          namespace: namespaceRef,
          mergedBodyStyle: mergedBodyStyleRef,
          handleMaskClick,
          handleEsc,
          mergedTheme: themeRef,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender,
          isMounted: isMountedRef
        };
      },
      render() {
        const { mergedClsPrefix } = this;
        return /* @__PURE__ */ vue.h(LazyTeleport, {
          to: this.to,
          show: this.show
        }, {
          default: () => {
            this.onRender?.();
            return vue.withDirectives(
              /* @__PURE__ */ vue.h("div", {
                class: [
                  `${mergedClsPrefix}-drawer-container`,
                  this.namespace,
                  this.themeClass
                ],
                style: this.cssVars,
                role: "none"
              }, this.showMask ? /* @__PURE__ */ vue.h(vue.Transition, {
                name: "fade-in-transition",
                appear: this.isMounted
              }, {
                default: () => this.show ? /* @__PURE__ */ vue.h("div", {
                  "aria-hidden": true,
                  class: [
                    `${mergedClsPrefix}-drawer-mask`,
                    this.showMask === "transparent" && `${mergedClsPrefix}-drawer-mask--invisible`
                  ],
                  onClick: this.handleMaskClick
                }) : null
              }) : null, /* @__PURE__ */ vue.h(NDrawerBodyWrapper, {
                ...this.$attrs,
                class: [this.drawerClass, this.$attrs.class],
                style: [this.mergedBodyStyle, this.$attrs.style],
                blockScroll: this.blockScroll,
                contentStyle: this.contentStyle,
                placement: this.placement,
                scrollbarProps: this.scrollbarProps,
                show: this.show,
                displayDirective: this.displayDirective,
                nativeScrollbar: this.nativeScrollbar,
                onAfterEnter: this.onAfterEnter,
                onAfterLeave: this.onAfterLeave,
                trapFocus: this.trapFocus,
                autoFocus: this.autoFocus,
                resizable: this.resizable,
                showMask: this.showMask,
                onEsc: this.handleEsc,
                onClickoutside: this.handleMaskClick
              }, this.$slots)),
              [[zindexable$1, { zIndex: this.zIndex, enabled: this.show }]]
            );
          }
        });
      }
    });

    const drawerContentProps = {
      title: {
        type: String
      },
      headerStyle: [Object, String],
      footerStyle: [Object, String],
      bodyStyle: [Object, String],
      bodyContentStyle: [Object, String],
      nativeScrollbar: { type: Boolean, default: true },
      scrollbarProps: Object,
      closable: Boolean
    };
    var DrawerContent = vue.defineComponent({
      name: "DrawerContent",
      props: drawerContentProps,
      setup() {
        const NDrawer = vue.inject(drawerInjectionKey, null);
        if (!NDrawer) {
          throwError(
            "drawer-content",
            "`n-drawer-content` must be placed inside `n-drawer`."
          );
        }
        const { doUpdateShow } = NDrawer;
        function handleCloseClick() {
          doUpdateShow(false);
        }
        return {
          handleCloseClick,
          mergedTheme: NDrawer.mergedThemeRef,
          mergedClsPrefix: NDrawer.mergedClsPrefixRef
        };
      },
      render() {
        const {
          title,
          mergedClsPrefix,
          nativeScrollbar,
          mergedTheme,
          bodyStyle,
          bodyContentStyle,
          headerStyle,
          footerStyle,
          scrollbarProps,
          closable,
          $slots
        } = this;
        return /* @__PURE__ */ vue.h("div", {
          role: "none",
          class: [
            `${mergedClsPrefix}-drawer-content`,
            nativeScrollbar && `${mergedClsPrefix}-drawer-content--native-scrollbar`
          ]
        }, $slots.header || title || closable ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-drawer-header`,
          style: headerStyle,
          role: "none"
        }, /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-drawer-header__main`,
          role: "heading",
          "aria-level": "1"
        }, $slots.header !== void 0 ? $slots.header() : title), closable && /* @__PURE__ */ vue.h(NBaseClose, {
          onClick: this.handleCloseClick,
          clsPrefix: mergedClsPrefix,
          class: `${mergedClsPrefix}-drawer-header__close`,
          absolute: true
        })) : null, nativeScrollbar ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-drawer-body`,
          style: bodyStyle,
          role: "none"
        }, /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-drawer-body-content-wrapper`,
          style: bodyContentStyle,
          role: "none"
        }, $slots)) : /* @__PURE__ */ vue.h(NScrollbar, {
          themeOverrides: mergedTheme.peerOverrides.Scrollbar,
          theme: mergedTheme.peers.Scrollbar,
          ...scrollbarProps,
          class: `${mergedClsPrefix}-drawer-body`,
          contentClass: `${mergedClsPrefix}-drawer-body-content-wrapper`,
          contentStyle: bodyContentStyle
        }, $slots), $slots.footer ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-drawer-footer`,
          style: footerStyle,
          role: "none"
        }, $slots.footer()) : null);
      }
    });

    var commonVariables$6 = {
      actionMargin: "0 0 0 20px",
      actionMarginRtl: "0 20px 0 0"
    };

    const dynamicInputDark = {
      name: "DynamicInput",
      common: commonDark,
      peers: {
        Input: inputDark$1,
        Button: buttonDark$1
      },

      self() {
        return commonVariables$6;
      }

    };
    var dynamicInputDark$1 = dynamicInputDark;

    const self$A = () => {
      return commonVariables$6;
    };

    const dynamicInputLight = createTheme$1({
      name: "DynamicInput",
      common: commonLight,
      peers: {
        Input: inputLight$1,
        Button: buttonLight$1
      },
      self: self$A
    });
    var dynamicInputLight$1 = dynamicInputLight;

    var rtlStyle$d = cB("dynamic-input", [cM("rtl", `
    direction: rtl;
  `, [cB("dynamic-input-preset-pair", [cB("dynamic-input-pair-input", [c$1("&:first-child", {
      "margin-left": "12px",
      "margin-right": "0"
    })])]), cB("dynamic-input-item", [cE("action", `
        margin: var(--action-margin-rtl);
      `)])])]);

    function createRightBorderStyle(type) {
      return cM(type + "-type", [c$1("& +", [cB("button", {}, [cM(type + "-type", [cE("border", {
        borderRightWidth: zero
      }), cE("state-border", {
        left: n1
      })])])])]);
    }

    var rtlStyle$c = cB("button-group", [cNotM("vertical", [cM("rtl", `
      direction: rtl;
    `, [cB("button", [c$1("&:last-child:not(:first-child)", `
          margin-right: ${zero};
          border-top-right-radius: ${zero};
          border-bottom-right-radius: ${zero};
        `), c$1("&:first-child:not(:last-child)", `
          margin-left: ${zero};
          border-top-left-radius: ${zero};
          border-bottom-left-radius: ${zero};
        `), c$1("&:not(:last-child):not(:first-child)", `
          margin-left: ${zero};
          margin-right: ${zero};
          border-radius: ${zero};
        `), createRightBorderStyle("default"), cM("ghost", [createRightBorderStyle("primary"), createRightBorderStyle("info"), createRightBorderStyle("success"), createRightBorderStyle("warning"), createRightBorderStyle("error")])])])])]);

    const buttonGroupRtl = {
      name: "ButtonGroup",
      style: rtlStyle$c
    };

    var rtlStyle$b = cB("input-number", [cM("rtl", `
    direction: rtl;
  `)]);

    const inputNumberRtl = {
      name: "InputNumber",
      style: rtlStyle$b,
      peers: [inputRtl, buttonRtl]
    };

    const dynamicInputRtl = {
      name: "DynamicInput",
      style: rtlStyle$d,
      peers: [inputRtl, buttonRtl, buttonGroupRtl, checkboxRtl, inputNumberRtl]
    };

    const dynamicInputInjectionKey = createInjectionKey("n-dynamic-input");

    var NDynamicInputInputPreset = vue.defineComponent({
      name: "DynamicInputInputPreset",
      props: {
        clsPrefix: {
          type: String,
          required: true
        },
        value: {
          type: String,
          default: ""
        },
        parentPath: String,
        path: String,
        onUpdateValue: {
          type: Function,
          required: true
        }
      },
      setup() {
        const {
          mergedThemeRef,
          placeholderRef
        } = vue.inject(dynamicInputInjectionKey);
        return {
          mergedTheme: mergedThemeRef,
          placeholder: placeholderRef
        };
      },
      render() {
        const { mergedTheme, placeholder, value, clsPrefix, onUpdateValue } = this;
        return /* @__PURE__ */ vue.h("div", {
          class: `${clsPrefix}-dynamic-input-preset-input`
        }, /* @__PURE__ */ vue.h(NInput, {
          theme: mergedTheme.peers.Input,
          "theme-overrides": mergedTheme.peerOverrides.Input,
          value,
          placeholder,
          onUpdateValue
        }));
      }
    });

    var NDynamicInputPairPreset = vue.defineComponent({
      name: "DynamicInputPairPreset",
      props: {
        clsPrefix: {
          type: String,
          required: true
        },
        value: {
          type: Object,
          default: () => ({
            key: "",
            value: ""
          })
        },
        parentPath: String,
        path: String,
        onUpdateValue: {
          type: Function,
          required: true
        }
      },
      setup(props) {
        const { mergedThemeRef, keyPlaceholderRef, valuePlaceholderRef } = vue.inject(
          dynamicInputInjectionKey
        );
        return {
          mergedTheme: mergedThemeRef,
          keyPlaceholder: keyPlaceholderRef,
          valuePlaceholder: valuePlaceholderRef,
          handleKeyInput(key) {
            props.onUpdateValue({
              key,
              value: props.value.value
            });
          },
          handleValueInput(value) {
            props.onUpdateValue({
              key: props.value.key,
              value
            });
          }
        };
      },
      render() {
        const {
          mergedTheme,
          keyPlaceholder,
          valuePlaceholder,
          value,
          clsPrefix
        } = this;
        return /* @__PURE__ */ vue.h("div", {
          class: `${clsPrefix}-dynamic-input-preset-pair`
        }, /* @__PURE__ */ vue.h(NInput, {
          theme: mergedTheme.peers.Input,
          "theme-overrides": mergedTheme.peerOverrides.Input,
          value: value.key,
          class: `${clsPrefix}-dynamic-input-pair-input`,
          placeholder: keyPlaceholder,
          onUpdateValue: this.handleKeyInput
        }), /* @__PURE__ */ vue.h(NInput, {
          theme: mergedTheme.peers.Input,
          "theme-overrides": mergedTheme.peerOverrides.Input,
          value: value.value,
          class: `${clsPrefix}-dynamic-input-pair-input`,
          placeholder: valuePlaceholder,
          onUpdateValue: this.handleValueInput
        }));
      }
    });

    var style$L = cB("dynamic-input", {
      width: "100%"
    }, [cB("dynamic-input-item", `
    margin-bottom: 10px;
    display: flex;
    flex-wrap: nowrap;
  `, [cB("dynamic-input-preset-input", {
      flex: 1,
      alignItems: "center"
    }), cB("dynamic-input-preset-pair", `
      flex: 1;
      display: flex;
      align-items: center;
    `, [cB("dynamic-input-pair-input", [c$1("&:first-child", {
      "margin-right": "12px"
    })])]), cE("action", `
      align-self: flex-start;
      display: flex;
      justify-content: flex-end;
      flex-shrink: 0;
      flex-grow: 0;
      margin: var(--action-margin);
    `, [cM("icon", {
      cursor: "pointer"
    })]), c$1("&:last-child", {
      marginBottom: 0
    })]), cB("form-item", `
    padding-top: 0 !important;
    margin-right: 0 !important;
  `, [cB("form-item-blank", {
      paddingTop: "0 !important"
    })])]);

    const globalDataKeyMap = /* @__PURE__ */ new WeakMap();
    const dynamicInputProps = {
      ...useTheme.props,
      max: Number,
      min: {
        type: Number,
        default: 0
      },
      value: Array,
      defaultValue: {
        type: Array,
        default: () => []
      },
      preset: {
        type: String,
        default: "input"
      },
      keyField: String,
      itemStyle: [String, Object],
      keyPlaceholder: {
        type: String,
        default: ""
      },
      valuePlaceholder: {
        type: String,
        default: ""
      },
      placeholder: {
        type: String,
        default: ""
      },
      showSortButton: Boolean,
      createButtonProps: Object,
      onCreate: Function,
      onRemove: Function,
      "onUpdate:value": [Function, Array],
      onUpdateValue: [Function, Array],
      onClear: Function,
      onInput: [Function, Array]
    };
    var DynamicInput = vue.defineComponent({
      name: "DynamicInput",
      props: dynamicInputProps,
      setup(props, { slots }) {
        {
          vue.watchEffect(() => {
            if (props.onClear !== void 0) {
              warnOnce(
                "dynamic-input",
                "`on-clear` is deprecated, it is out of usage anymore."
              );
            }
            if (props.onInput !== void 0) {
              warnOnce(
                "dynamic-input",
                "`on-input` is deprecated, please use `on-update:value` instead."
              );
            }
          });
        }
        const {
          mergedComponentPropsRef,
          mergedClsPrefixRef,
          mergedRtlRef,
          inlineThemeDisabled
        } = useConfig();
        const NFormItem = vue.inject(formItemInjectionKey, null);
        const uncontrolledValueRef = vue.ref(props.defaultValue);
        const controlledValueRef = vue.toRef(props, "value");
        const mergedValueRef = useMergedState(
          controlledValueRef,
          uncontrolledValueRef
        );
        const themeRef = useTheme(
          "DynamicInput",
          "-dynamic-input",
          style$L,
          dynamicInputLight$1,
          props,
          mergedClsPrefixRef
        );
        const insertionDisabledRef = vue.computed(() => {
          const { value: mergedValue } = mergedValueRef;
          if (Array.isArray(mergedValue)) {
            const { max } = props;
            return max !== void 0 && mergedValue.length >= max;
          }
          return false;
        });
        const removeDisabledRef = vue.computed(() => {
          const { value: mergedValue } = mergedValueRef;
          if (Array.isArray(mergedValue))
            return mergedValue.length <= props.min;
          return true;
        });
        const buttonSizeRef = vue.computed(() => {
          return mergedComponentPropsRef?.value?.DynamicInput?.buttonSize;
        });
        function doUpdateValue(value) {
          const { onInput, "onUpdate:value": _onUpdateValue, onUpdateValue } = props;
          if (onInput)
            call(onInput, value);
          if (_onUpdateValue)
            call(_onUpdateValue, value);
          if (onUpdateValue)
            call(onUpdateValue, value);
          uncontrolledValueRef.value = value;
        }
        function ensureKey(value, index) {
          if (value === void 0 || value === null)
            return index;
          if (typeof value !== "object")
            return index;
          const rawValue = vue.isProxy(value) ? vue.toRaw(value) : value;
          let key = globalDataKeyMap.get(rawValue);
          if (key === void 0) {
            globalDataKeyMap.set(rawValue, key = createId());
          }
          return key;
        }
        function handleValueChange(index, value) {
          const { value: mergedValue } = mergedValueRef;
          const newValue = Array.from(mergedValue ?? []);
          const originalItem = newValue[index];
          newValue[index] = value;
          if (originalItem && value && typeof originalItem === "object" && typeof value === "object") {
            const rawOriginal = vue.isProxy(originalItem) ? vue.toRaw(originalItem) : originalItem;
            const rawNew = vue.isProxy(value) ? vue.toRaw(value) : value;
            const originalKey = globalDataKeyMap.get(rawOriginal);
            if (originalKey !== void 0) {
              globalDataKeyMap.set(rawNew, originalKey);
            }
          }
          doUpdateValue(newValue);
        }
        function handleCreateClick() {
          createItem(0);
        }
        function createItem(index) {
          const { value: mergedValue } = mergedValueRef;
          const { onCreate } = props;
          const newValue = Array.from(mergedValue ?? []);
          if (onCreate) {
            newValue.splice(index + 1, 0, onCreate(index + 1));
            doUpdateValue(newValue);
          } else if (slots.default) {
            newValue.splice(index + 1, 0, null);
            doUpdateValue(newValue);
          } else {
            switch (props.preset) {
              case "input":
                newValue.splice(index + 1, 0, "");
                doUpdateValue(newValue);
                break;
              case "pair":
                newValue.splice(index + 1, 0, { key: "", value: "" });
                doUpdateValue(newValue);
                break;
            }
          }
        }
        function remove(index) {
          const { value: mergedValue } = mergedValueRef;
          if (!Array.isArray(mergedValue))
            return;
          const { min } = props;
          if (mergedValue.length <= min)
            return;
          const newValue = Array.from(mergedValue);
          newValue.splice(index, 1);
          doUpdateValue(newValue);
          const { onRemove } = props;
          if (onRemove)
            onRemove(index);
        }
        function swap(array, currentIndex, targetIndex) {
          if (currentIndex < 0 || targetIndex < 0 || currentIndex >= array.length || targetIndex >= array.length) {
            return;
          }
          if (currentIndex === targetIndex)
            return;
          const currentItem = array[currentIndex];
          array[currentIndex] = array[targetIndex];
          array[targetIndex] = currentItem;
        }
        function move(type, index) {
          const { value: mergedValue } = mergedValueRef;
          if (!Array.isArray(mergedValue))
            return;
          const newValue = Array.from(mergedValue);
          if (type === "up") {
            swap(newValue, index, index - 1);
          }
          if (type === "down") {
            swap(newValue, index, index + 1);
          }
          doUpdateValue(newValue);
        }
        vue.provide(dynamicInputInjectionKey, {
          mergedThemeRef: themeRef,
          keyPlaceholderRef: vue.toRef(props, "keyPlaceholder"),
          valuePlaceholderRef: vue.toRef(props, "valuePlaceholder"),
          placeholderRef: vue.toRef(props, "placeholder")
        });
        const rtlEnabledRef = useRtl(
          "DynamicInput",
          mergedRtlRef,
          mergedClsPrefixRef
        );
        const cssVarsRef = vue.computed(() => {
          const {
            self: { actionMargin, actionMarginRtl }
          } = themeRef.value;
          return {
            "--action-margin": actionMargin,
            "--action-margin-rtl": actionMarginRtl
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("dynamic-input", void 0, cssVarsRef, props) : void 0;
        return {
          locale: useLocale("DynamicInput").localeRef,
          rtlEnabled: rtlEnabledRef,
          buttonSize: buttonSizeRef,
          mergedClsPrefix: mergedClsPrefixRef,
          NFormItem,
          uncontrolledValue: uncontrolledValueRef,
          mergedValue: mergedValueRef,
          insertionDisabled: insertionDisabledRef,
          removeDisabled: removeDisabledRef,
          handleCreateClick,
          ensureKey,
          handleValueChange,
          remove,
          move,
          createItem,
          mergedTheme: themeRef,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender
        };
      },
      render() {
        const {
          $slots,
          buttonSize,
          mergedClsPrefix,
          mergedValue,
          locale,
          mergedTheme,
          keyField,
          itemStyle,
          preset,
          showSortButton,
          NFormItem,
          ensureKey,
          handleValueChange,
          remove,
          createItem,
          move,
          onRender
        } = this;
        onRender?.();
        return /* @__PURE__ */ vue.h("div", {
          class: [
            `${mergedClsPrefix}-dynamic-input`,
            this.rtlEnabled && `${mergedClsPrefix}-dynamic-input--rtl`,
            this.themeClass
          ],
          style: this.cssVars
        }, !Array.isArray(mergedValue) || mergedValue.length === 0 ? /* @__PURE__ */ vue.h(NButton, {
          block: true,
          ghost: true,
          dashed: true,
          size: buttonSize,
          ...this.createButtonProps,
          disabled: this.insertionDisabled,
          theme: mergedTheme.peers.Button,
          themeOverrides: mergedTheme.peerOverrides.Button,
          onClick: this.handleCreateClick
        }, {
          default: () => resolveSlot($slots["create-button-default"], () => [
            locale.create
          ]),
          icon: () => resolveSlot($slots["create-button-icon"], () => [
            /* @__PURE__ */ vue.h(NBaseIcon, {
              clsPrefix: mergedClsPrefix
            }, { default: () => /* @__PURE__ */ vue.h(AddIcon, null) })
          ])
        }) : mergedValue.map((_, index) => /* @__PURE__ */ vue.h("div", {
          key: keyField ? _[keyField] : ensureKey(_, index),
          "data-key": keyField ? _[keyField] : ensureKey(_, index),
          class: `${mergedClsPrefix}-dynamic-input-item`,
          style: itemStyle
        }, resolveSlotWithProps(
          $slots.default,
          {
            value: mergedValue[index],
            index
          },
          () => {
            return [
              preset === "input" ? /* @__PURE__ */ vue.h(NDynamicInputInputPreset, {
                clsPrefix: mergedClsPrefix,
                value: mergedValue[index],
                parentPath: NFormItem ? NFormItem.path.value : void 0,
                path: NFormItem?.path.value ? `${NFormItem.path.value}[${index}]` : void 0,
                onUpdateValue: (v) => handleValueChange(index, v)
              }) : preset === "pair" ? /* @__PURE__ */ vue.h(NDynamicInputPairPreset, {
                clsPrefix: mergedClsPrefix,
                value: mergedValue[index],
                parentPath: NFormItem ? NFormItem.path.value : void 0,
                path: NFormItem?.path.value ? `${NFormItem.path.value}[${index}]` : void 0,
                onUpdateValue: (v) => handleValueChange(index, v)
              }) : null
            ];
          }
        ), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-dynamic-input-item__action`
        }, /* @__PURE__ */ vue.h(NButtonGroup, {
          size: buttonSize
        }, {
          default: () => [
            /* @__PURE__ */ vue.h(NButton, {
              disabled: this.removeDisabled,
              theme: mergedTheme.peers.Button,
              themeOverrides: mergedTheme.peerOverrides.Button,
              circle: true,
              onClick: () => remove(index)
            }, {
              icon: () => /* @__PURE__ */ vue.h(NBaseIcon, {
                clsPrefix: mergedClsPrefix
              }, { default: () => /* @__PURE__ */ vue.h(RemoveIcon, null) })
            }),
            /* @__PURE__ */ vue.h(NButton, {
              disabled: this.insertionDisabled,
              circle: true,
              theme: mergedTheme.peers.Button,
              themeOverrides: mergedTheme.peerOverrides.Button,
              onClick: () => createItem(index)
            }, {
              icon: () => /* @__PURE__ */ vue.h(NBaseIcon, {
                clsPrefix: mergedClsPrefix
              }, { default: () => /* @__PURE__ */ vue.h(AddIcon, null) })
            }),
            showSortButton ? /* @__PURE__ */ vue.h(NButton, {
              disabled: index === 0,
              circle: true,
              theme: mergedTheme.peers.Button,
              themeOverrides: mergedTheme.peerOverrides.Button,
              onClick: () => move("up", index)
            }, {
              icon: () => /* @__PURE__ */ vue.h(NBaseIcon, {
                clsPrefix: mergedClsPrefix
              }, {
                default: () => /* @__PURE__ */ vue.h(ArrowUpIcon, null)
              })
            }) : null,
            showSortButton ? /* @__PURE__ */ vue.h(NButton, {
              disabled: index === mergedValue.length - 1,
              circle: true,
              theme: mergedTheme.peers.Button,
              themeOverrides: mergedTheme.peerOverrides.Button,
              onClick: () => move("down", index)
            }, {
              icon: () => /* @__PURE__ */ vue.h(NBaseIcon, {
                clsPrefix: mergedClsPrefix
              }, { default: () => /* @__PURE__ */ vue.h(ArrowDownIcon, null) })
            }) : null
          ]
        })))));
      }
    });

    var commonVars$4 = {
      gapSmall: "4px 8px",
      gapMedium: "8px 12px",
      gapLarge: "12px 16px"
    };

    const spaceDark = {
      name: "Space",

      self() {
        return commonVars$4;
      }

    };
    var spaceDark$1 = spaceDark;

    const self$z = () => {
      return commonVars$4;
    };

    const spaceLight = {
      name: "Space",
      self: self$z
    };
    var spaceLight$1 = spaceLight;

    var rtlStyle$a = cB("space", [cM("rtl", `
    direction: rtl;
  `)]);

    const spaceRtl = {
      name: "Space",
      style: rtlStyle$a
    };

    let supportFlexGap;
    const ensureSupportFlexGap = () => {
      if (!isBrowser$2) return true;

      if (supportFlexGap === void 0) {
        const flex = document.createElement("div");
        flex.style.display = "flex";
        flex.style.flexDirection = "column";
        flex.style.rowGap = "1px";
        flex.appendChild(document.createElement("div"));
        flex.appendChild(document.createElement("div"));
        document.body.appendChild(flex);
        const isSupported = flex.scrollHeight === 1;
        document.body.removeChild(flex);
        return supportFlexGap = isSupported;
      }

      return supportFlexGap;
    };

    const spaceProps = {
      ...useTheme.props,
      align: String,
      justify: {
        type: String,
        default: "start"
      },
      inline: Boolean,
      vertical: Boolean,
      size: {
        type: [String, Number, Array],
        default: "medium"
      },
      wrapItem: {
        type: Boolean,
        default: true
      },
      itemStyle: [String, Object],
      wrap: {
        type: Boolean,
        default: true
      },
      internalUseGap: {
        type: Boolean,
        default: void 0
      }
    };
    var NSpace = vue.defineComponent({
      name: "Space",
      props: spaceProps,
      setup(props) {
        const { mergedClsPrefixRef, mergedRtlRef } = useConfig(props);
        const themeRef = useTheme(
          "Space",
          "-space",
          void 0,
          spaceLight$1,
          props,
          mergedClsPrefixRef
        );
        const rtlEnabledRef = useRtl("Space", mergedRtlRef, mergedClsPrefixRef);
        return {
          useGap: ensureSupportFlexGap(),
          rtlEnabled: rtlEnabledRef,
          mergedClsPrefix: mergedClsPrefixRef,
          margin: vue.computed(() => {
            const { size } = props;
            if (Array.isArray(size)) {
              return {
                horizontal: size[0],
                vertical: size[1]
              };
            }
            if (typeof size === "number") {
              return {
                horizontal: size,
                vertical: size
              };
            }
            const {
              self: { [createKey("gap", size)]: gap }
            } = themeRef.value;
            const { row, col } = getGap(gap);
            return {
              horizontal: depx(col),
              vertical: depx(row)
            };
          })
        };
      },
      render() {
        const {
          vertical,
          align,
          inline,
          justify,
          itemStyle,
          margin,
          wrap,
          mergedClsPrefix,
          rtlEnabled,
          useGap,
          wrapItem,
          internalUseGap
        } = this;
        const children = flatten$3(getSlot$1(this));
        if (!children.length)
          return null;
        const horizontalMargin = `${margin.horizontal}px`;
        const semiHorizontalMargin = `${margin.horizontal / 2}px`;
        const verticalMargin = `${margin.vertical}px`;
        const semiVerticalMargin = `${margin.vertical / 2}px`;
        const lastIndex = children.length - 1;
        const isJustifySpace = justify.startsWith("space-");
        return /* @__PURE__ */ vue.h("div", {
          role: "none",
          class: [
            `${mergedClsPrefix}-space`,
            rtlEnabled && `${mergedClsPrefix}-space--rtl`
          ],
          style: {
            display: inline ? "inline-flex" : "flex",
            flexDirection: vertical ? "column" : "row",
            justifyContent: ["start", "end"].includes(justify) ? "flex-" + justify : justify,
            flexWrap: !wrap || vertical ? "nowrap" : "wrap",
            marginTop: useGap || vertical ? "" : `-${semiVerticalMargin}`,
            marginBottom: useGap || vertical ? "" : `-${semiVerticalMargin}`,
            alignItems: align,
            gap: useGap ? `${margin.vertical}px ${margin.horizontal}px` : ""
          }
        }, !wrapItem && (useGap || internalUseGap) ? children : children.map((child, index) => /* @__PURE__ */ vue.h("div", {
          role: "none",
          style: [
            itemStyle,
            {
              maxWidth: "100%"
            },
            useGap ? "" : vertical ? {
              marginBottom: index !== lastIndex ? verticalMargin : ""
            } : rtlEnabled ? {
              marginLeft: isJustifySpace ? justify === "space-between" && index === lastIndex ? "" : semiHorizontalMargin : index !== lastIndex ? horizontalMargin : "",
              marginRight: isJustifySpace ? justify === "space-between" && index === 0 ? "" : semiHorizontalMargin : "",
              paddingTop: semiVerticalMargin,
              paddingBottom: semiVerticalMargin
            } : {
              marginRight: isJustifySpace ? justify === "space-between" && index === lastIndex ? "" : semiHorizontalMargin : index !== lastIndex ? horizontalMargin : "",
              marginLeft: isJustifySpace ? justify === "space-between" && index === 0 ? "" : semiHorizontalMargin : "",
              paddingTop: semiVerticalMargin,
              paddingBottom: semiVerticalMargin
            }
          ]
        }, child)));
      }
    });

    const dynamicTagsDark = {
      name: "DynamicTags",
      common: commonDark,
      peers: {
        Input: inputDark$1,
        Button: buttonDark$1,
        Tag: tagDark$1,
        Space: spaceDark$1
      },

      self() {
        return {
          inputWidth: "64px"
        };
      }

    };
    var dynamicTagsDark$1 = dynamicTagsDark;

    const dynamicTagsLight = createTheme$1({
      name: "DynamicTags",
      common: commonLight,
      peers: {
        Input: inputLight$1,
        Button: buttonLight$1,
        Tag: tagLight$1,
        Space: spaceLight$1
      },

      self() {
        return {
          inputWidth: "64px"
        };
      }

    });
    var dynamicTagsLight$1 = dynamicTagsLight;

    var style$K = cB("dynamic-tags", [cB("input", {
      minWidth: "var(--n-input-width)"
    })]);

    const dynamicTagsProps = {
      ...useTheme.props,
      ...commonProps,
      size: {
        type: String,
        default: "medium"
      },
      closable: {
        type: Boolean,
        default: true
      },
      defaultValue: {
        type: Array,
        default: () => []
      },
      value: Array,
      inputStyle: [String, Object],
      inputProps: Object,
      max: Number,
      tagStyle: [String, Object],
      renderTag: Function,
      onCreate: {
        type: Function,
        default: (label) => label
      },
      "onUpdate:value": [Function, Array],
      onUpdateValue: [Function, Array],
      onChange: [Function, Array]
    };
    var DynamicTags = vue.defineComponent({
      name: "DynamicTags",
      props: dynamicTagsProps,
      setup(props) {
        {
          vue.watchEffect(() => {
            if (props.onChange !== void 0) {
              warnOnce(
                "dynamic-tags",
                "`on-change` is deprecated, please use `on-update:value` instead."
              );
            }
          });
        }
        const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
        const { localeRef } = useLocale("DynamicTags");
        const formItem = useFormItem(props);
        const { mergedDisabledRef } = formItem;
        const inputValueRef = vue.ref("");
        const showInputRef = vue.ref(false);
        const inputForceFocusedRef = vue.ref(true);
        const inputInstRef = vue.ref(null);
        const themeRef = useTheme(
          "DynamicTags",
          "-dynamic-tags",
          style$K,
          dynamicTagsLight$1,
          props,
          mergedClsPrefixRef
        );
        const uncontrolledValueRef = vue.ref(props.defaultValue);
        const controlledValueRef = vue.toRef(props, "value");
        const mergedValueRef = useMergedState(
          controlledValueRef,
          uncontrolledValueRef
        );
        const localizedAddRef = vue.computed(() => {
          return localeRef.value.add;
        });
        const inputSizeRef = vue.computed(() => {
          return smallerSize(props.size);
        });
        const triggerDisabledRef = vue.computed(() => {
          return mergedDisabledRef.value || !!props.max && mergedValueRef.value.length >= props.max;
        });
        function doChange(value) {
          const {
            onChange,
            "onUpdate:value": _onUpdateValue,
            onUpdateValue
          } = props;
          const { nTriggerFormInput, nTriggerFormChange } = formItem;
          if (onChange)
            call(onChange, value);
          if (onUpdateValue)
            call(onUpdateValue, value);
          if (_onUpdateValue)
            call(_onUpdateValue, value);
          uncontrolledValueRef.value = value;
          nTriggerFormInput();
          nTriggerFormChange();
        }
        function handleCloseClick(index) {
          const tags = mergedValueRef.value.slice(0);
          tags.splice(index, 1);
          doChange(tags);
        }
        function handleInputKeyUp(e) {
          switch (e.key) {
            case "Enter":
              handleInputConfirm();
          }
        }
        function handleInputConfirm(externalValue) {
          const nextValue = externalValue ?? inputValueRef.value;
          if (nextValue) {
            const tags = mergedValueRef.value.slice(0);
            tags.push(props.onCreate(nextValue));
            doChange(tags);
          }
          showInputRef.value = false;
          inputForceFocusedRef.value = true;
          inputValueRef.value = "";
        }
        function handleInputBlur() {
          handleInputConfirm();
        }
        function handleAddClick() {
          showInputRef.value = true;
          void vue.nextTick(() => {
            inputInstRef.value?.focus();
            inputForceFocusedRef.value = false;
          });
        }
        const cssVarsRef = vue.computed(() => {
          const {
            self: { inputWidth }
          } = themeRef.value;
          return {
            "--n-input-width": inputWidth
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("dynamic-tags", void 0, cssVarsRef, props) : void 0;
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          inputInstRef,
          localizedAdd: localizedAddRef,
          inputSize: inputSizeRef,
          inputValue: inputValueRef,
          showInput: showInputRef,
          inputForceFocused: inputForceFocusedRef,
          mergedValue: mergedValueRef,
          mergedDisabled: mergedDisabledRef,
          triggerDisabled: triggerDisabledRef,
          handleInputKeyUp,
          handleAddClick,
          handleInputBlur,
          handleCloseClick,
          handleInputConfirm,
          mergedTheme: themeRef,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender
        };
      },
      render() {
        const { mergedTheme, cssVars, mergedClsPrefix, onRender, renderTag } = this;
        onRender?.();
        return /* @__PURE__ */ vue.h(NSpace, {
          class: [`${mergedClsPrefix}-dynamic-tags`, this.themeClass],
          size: "small",
          style: cssVars,
          theme: mergedTheme.peers.Space,
          themeOverrides: mergedTheme.peerOverrides.Space,
          itemStyle: "display: flex;"
        }, {
          default: () => {
            const {
              mergedTheme: mergedTheme2,
              tagStyle,
              type,
              round,
              size,
              color,
              closable,
              mergedDisabled,
              showInput,
              inputValue,
              inputStyle,
              inputSize,
              inputForceFocused,
              triggerDisabled,
              handleInputKeyUp,
              handleInputBlur,
              handleAddClick,
              handleCloseClick,
              handleInputConfirm,
              $slots
            } = this;
            return this.mergedValue.map(
              (tag, index) => renderTag ? renderTag(tag, index) : /* @__PURE__ */ vue.h(NTag, {
                key: index,
                theme: mergedTheme2.peers.Tag,
                themeOverrides: mergedTheme2.peerOverrides.Tag,
                style: tagStyle,
                type,
                round,
                size,
                color,
                closable,
                disabled: mergedDisabled,
                onClose: () => handleCloseClick(index)
              }, {
                default: () => typeof tag === "string" ? tag : tag.label
              })
            ).concat(
              showInput ? $slots.input ? $slots.input({
                submit: handleInputConfirm,
                deactivate: handleInputBlur
              }) : /* @__PURE__ */ vue.h(NInput, {
                placeholder: "",
                size: inputSize,
                style: inputStyle,
                autosize: true,
                ...this.inputProps,
                ref: "inputInstRef",
                value: inputValue,
                onUpdateValue: (v) => {
                  this.inputValue = v;
                },
                theme: mergedTheme2.peers.Input,
                themeOverrides: mergedTheme2.peerOverrides.Input,
                onKeyup: handleInputKeyUp,
                onBlur: handleInputBlur,
                internalForceFocus: inputForceFocused
              }) : $slots.trigger ? $slots.trigger({
                activate: handleAddClick,
                disabled: triggerDisabled
              }) : /* @__PURE__ */ vue.h(NButton, {
                dashed: true,
                disabled: triggerDisabled,
                theme: mergedTheme2.peers.Button,
                themeOverrides: mergedTheme2.peerOverrides.Button,
                size: inputSize,
                onClick: handleAddClick
              }, {
                icon: () => /* @__PURE__ */ vue.h(NBaseIcon, {
                  clsPrefix: mergedClsPrefix
                }, { default: () => /* @__PURE__ */ vue.h(AddIcon, null) })
              })
            );
          }
        });
      }
    });

    const elementDark = {
      name: "Element",
      common: commonDark
    };
    var elementDark$1 = elementDark;

    const elementLight = {
      name: "Element",
      common: commonLight
    };
    var elementLight$1 = elementLight;

    const elementProps = { ...useTheme.props,
      tag: {
        type: String,
        default: "div"
      }
    };
    var NElement = vue.defineComponent({
      name: "Element",
      alias: ["El"],
      props: elementProps,

      setup(props) {
        const {
          mergedClsPrefixRef,
          inlineThemeDisabled
        } = useConfig(props);
        const themeRef = useTheme("Element", "-element", void 0, elementLight$1, props, mergedClsPrefixRef);
        const cssVarsRef = vue.computed(() => {
          const {
            common
          } = themeRef.value;
          return Object.keys(common).reduce((prevValue, key) => {
            prevValue[`--${lodash.exports.kebabCase(key)}`] = common[key];
            return prevValue;
          }, {});
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("element", void 0, cssVarsRef, props) : void 0;
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
          onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
        };
      },

      render() {
        var _$slots$default;

        const {
          tag,
          mergedClsPrefix,
          cssVars,
          themeClass,
          onRender,
          $slots
        } = this;
        onRender === null || onRender === void 0 ? void 0 : onRender();
        return vue.h(tag, {
          role: "none",
          class: [`${mergedClsPrefix}-element`, themeClass],
          style: cssVars
        }, (_$slots$default = $slots.default) === null || _$slots$default === void 0 ? void 0 : _$slots$default.call($slots));
      }

    });

    var commonVariables$5 = {
      feedbackPadding: "4px 0 0 2px",
      feedbackHeightSmall: "24px",
      feedbackHeightMedium: "24px",
      feedbackHeightLarge: "26px",
      feedbackFontSizeSmall: "13px",
      feedbackFontSizeMedium: "14px",
      feedbackFontSizeLarge: "14px",
      labelFontSizeLeftSmall: "14px",
      labelFontSizeLeftMedium: "14px",
      labelFontSizeLeftLarge: "15px",
      labelFontSizeTopSmall: "13px",
      labelFontSizeTopMedium: "14px",
      labelFontSizeTopLarge: "14px",
      labelHeightSmall: "24px",
      labelHeightMedium: "26px",
      labelHeightLarge: "28px",
      labelPaddingVertical: "0 0 6px 2px",
      labelPaddingHorizontal: "0 12px 0 0",
      labelTextAlignVertical: "left",
      labelTextAlignHorizontal: "right"
    };

    const self$y = vars => {
      const {
        heightSmall,
        heightMedium,
        heightLarge,
        textColor1,
        errorColor,
        warningColor,
        lineHeight,
        textColor3
      } = vars;
      return { ...commonVariables$5,
        blankHeightSmall: heightSmall,
        blankHeightMedium: heightMedium,
        blankHeightLarge: heightLarge,
        lineHeight,
        labelTextColor: textColor1,
        asteriskColor: errorColor,
        feedbackTextColorError: errorColor,
        feedbackTextColorWarning: warningColor,
        feedbackTextColor: textColor3
      };
    };
    const formLight = {
      name: "Form",
      common: commonLight,
      self: self$y
    };
    var formLight$1 = formLight;

    const formItemDark = {
      name: "Form",
      common: commonDark,
      self: self$y
    };
    var formDark = formItemDark;

    var style$J = cB("form", [cM("inline", `
    width: 100%;
    display: inline-flex;
    align-items: flex-start;
    align-content: space-around;
  `, [cB("form-item", {
      width: "auto",
      marginRight: "18px"
    }, [c$1("&:last-child", {
      marginRight: 0
    })])])]);

    const formInjectionKey = createInjectionKey("n-form");
    const formItemInstsInjectionKey = createInjectionKey("n-form-item-insts");

    const formProps = {
      ...useTheme.props,
      inline: Boolean,
      labelWidth: [Number, String],
      labelAlign: String,
      labelPlacement: {
        type: String,
        default: "top"
      },
      model: {
        type: Object,
        default: () => {
        }
      },
      rules: Object,
      disabled: Boolean,
      size: String,
      showRequireMark: {
        type: Boolean,
        default: void 0
      },
      requireMarkPlacement: String,
      showFeedback: {
        type: Boolean,
        default: true
      },
      onSubmit: {
        type: Function,
        default: (e) => e.preventDefault()
      },
      showLabel: {
        type: Boolean,
        default: void 0
      },
      validateMessages: Object
    };
    var Form = vue.defineComponent({
      name: "Form",
      props: formProps,
      setup(props) {
        const { mergedClsPrefixRef } = useConfig(props);
        useTheme("Form", "-form", style$J, formLight$1, props, mergedClsPrefixRef);
        const formItems = {};
        const maxChildLabelWidthRef = vue.ref(void 0);
        const deriveMaxChildLabelWidth = (currentWidth) => {
          const currentMaxChildLabelWidth = maxChildLabelWidthRef.value;
          if (currentMaxChildLabelWidth === void 0 || currentWidth >= currentMaxChildLabelWidth) {
            maxChildLabelWidthRef.value = currentWidth;
          }
        };
        async function validate(validateCallback, shouldRuleBeApplied = () => true) {
          return await new Promise((resolve, reject) => {
            const formItemValidationPromises = [];
            for (const key of keysOf(formItems)) {
              const formItemInstances = formItems[key];
              for (const formItemInstance of formItemInstances) {
                if (formItemInstance.path) {
                  formItemValidationPromises.push(
                    formItemInstance.internalValidate(null, shouldRuleBeApplied)
                  );
                }
              }
            }
            void Promise.all(formItemValidationPromises).then((results) => {
              if (results.some((result) => !result.valid)) {
                const errors = results.filter((result) => result.errors).map((result) => result.errors);
                if (validateCallback) {
                  validateCallback(errors);
                }
                reject(errors);
              } else {
                if (validateCallback)
                  validateCallback();
                resolve();
              }
            });
          });
        }
        function restoreValidation() {
          for (const key of keysOf(formItems)) {
            const formItemInstances = formItems[key];
            for (const formItemInstance of formItemInstances) {
              formItemInstance.restoreValidation();
            }
          }
        }
        vue.provide(formInjectionKey, {
          props,
          maxChildLabelWidthRef,
          deriveMaxChildLabelWidth
        });
        vue.provide(formItemInstsInjectionKey, { formItems });
        const formExposedMethod = {
          validate,
          restoreValidation
        };
        return Object.assign(formExposedMethod, {
          mergedClsPrefix: mergedClsPrefixRef
        });
      },
      render() {
        const { mergedClsPrefix } = this;
        return /* @__PURE__ */ vue.h("form", {
          class: [
            `${mergedClsPrefix}-form`,
            this.inline && `${mergedClsPrefix}-form--inline`
          ],
          onSubmit: this.onSubmit
        }, this.$slots);
      }
    });

    function _extends() {
      _extends = Object.assign ? Object.assign.bind() : function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];

          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }

        return target;
      };
      return _extends.apply(this, arguments);
    }

    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;

      _setPrototypeOf(subClass, superClass);
    }

    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf(o);
    }

    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }

    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;

      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }

    function _construct(Parent, args, Class) {
      if (_isNativeReflectConstruct()) {
        _construct = Reflect.construct.bind();
      } else {
        _construct = function _construct(Parent, args, Class) {
          var a = [null];
          a.push.apply(a, args);
          var Constructor = Function.bind.apply(Parent, a);
          var instance = new Constructor();
          if (Class) _setPrototypeOf(instance, Class.prototype);
          return instance;
        };
      }

      return _construct.apply(null, arguments);
    }

    function _isNativeFunction(fn) {
      return Function.toString.call(fn).indexOf("[native code]") !== -1;
    }

    function _wrapNativeSuper(Class) {
      var _cache = typeof Map === "function" ? new Map() : undefined;

      _wrapNativeSuper = function _wrapNativeSuper(Class) {
        if (Class === null || !_isNativeFunction(Class)) return Class;

        if (typeof Class !== "function") {
          throw new TypeError("Super expression must either be null or a function");
        }

        if (typeof _cache !== "undefined") {
          if (_cache.has(Class)) return _cache.get(Class);

          _cache.set(Class, Wrapper);
        }

        function Wrapper() {
          return _construct(Class, arguments, _getPrototypeOf(this).constructor);
        }

        Wrapper.prototype = Object.create(Class.prototype, {
          constructor: {
            value: Wrapper,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        return _setPrototypeOf(Wrapper, Class);
      };

      return _wrapNativeSuper(Class);
    }
    /* eslint no-console:0 */


    var formatRegExp = /%[sdj%]/g;

    var warning = function warning() {}; // don't print warning message when in production env or node runtime


    if (typeof process !== 'undefined' && process.env && "development" !== 'production' && typeof window !== 'undefined' && typeof document !== 'undefined') {
      warning = function warning(type, errors) {
        if (typeof console !== 'undefined' && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING === 'undefined') {
          if (errors.every(function (e) {
            return typeof e === 'string';
          })) {
            console.warn(type, errors);
          }
        }
      };
    }

    function convertFieldsError(errors) {
      if (!errors || !errors.length) return null;
      var fields = {};
      errors.forEach(function (error) {
        var field = error.field;
        fields[field] = fields[field] || [];
        fields[field].push(error);
      });
      return fields;
    }

    function format$1(template) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      var i = 0;
      var len = args.length;

      if (typeof template === 'function') {
        return template.apply(null, args);
      }

      if (typeof template === 'string') {
        var str = template.replace(formatRegExp, function (x) {
          if (x === '%%') {
            return '%';
          }

          if (i >= len) {
            return x;
          }

          switch (x) {
            case '%s':
              return String(args[i++]);

            case '%d':
              return Number(args[i++]);

            case '%j':
              try {
                return JSON.stringify(args[i++]);
              } catch (_) {
                return '[Circular]';
              }

              break;

            default:
              return x;
          }
        });
        return str;
      }

      return template;
    }

    function isNativeStringType(type) {
      return type === 'string' || type === 'url' || type === 'hex' || type === 'email' || type === 'date' || type === 'pattern';
    }

    function isEmptyValue(value, type) {
      if (value === undefined || value === null) {
        return true;
      }

      if (type === 'array' && Array.isArray(value) && !value.length) {
        return true;
      }

      if (isNativeStringType(type) && typeof value === 'string' && !value) {
        return true;
      }

      return false;
    }

    function asyncParallelArray(arr, func, callback) {
      var results = [];
      var total = 0;
      var arrLength = arr.length;

      function count(errors) {
        results.push.apply(results, errors || []);
        total++;

        if (total === arrLength) {
          callback(results);
        }
      }

      arr.forEach(function (a) {
        func(a, count);
      });
    }

    function asyncSerialArray(arr, func, callback) {
      var index = 0;
      var arrLength = arr.length;

      function next(errors) {
        if (errors && errors.length) {
          callback(errors);
          return;
        }

        var original = index;
        index = index + 1;

        if (original < arrLength) {
          func(arr[original], next);
        } else {
          callback([]);
        }
      }

      next([]);
    }

    function flattenObjArr(objArr) {
      var ret = [];
      Object.keys(objArr).forEach(function (k) {
        ret.push.apply(ret, objArr[k] || []);
      });
      return ret;
    }

    var AsyncValidationError = /*#__PURE__*/function (_Error) {
      _inheritsLoose(AsyncValidationError, _Error);

      function AsyncValidationError(errors, fields) {
        var _this;

        _this = _Error.call(this, 'Async Validation Error') || this;
        _this.errors = errors;
        _this.fields = fields;
        return _this;
      }

      return AsyncValidationError;
    }( /*#__PURE__*/_wrapNativeSuper(Error));

    function asyncMap(objArr, option, func, callback, source) {
      if (option.first) {
        var _pending = new Promise(function (resolve, reject) {
          var next = function next(errors) {
            callback(errors);
            return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve(source);
          };

          var flattenArr = flattenObjArr(objArr);
          asyncSerialArray(flattenArr, func, next);
        });

        _pending["catch"](function (e) {
          return e;
        });

        return _pending;
      }

      var firstFields = option.firstFields === true ? Object.keys(objArr) : option.firstFields || [];
      var objArrKeys = Object.keys(objArr);
      var objArrLength = objArrKeys.length;
      var total = 0;
      var results = [];
      var pending = new Promise(function (resolve, reject) {
        var next = function next(errors) {
          results.push.apply(results, errors);
          total++;

          if (total === objArrLength) {
            callback(results);
            return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve(source);
          }
        };

        if (!objArrKeys.length) {
          callback(results);
          resolve(source);
        }

        objArrKeys.forEach(function (key) {
          var arr = objArr[key];

          if (firstFields.indexOf(key) !== -1) {
            asyncSerialArray(arr, func, next);
          } else {
            asyncParallelArray(arr, func, next);
          }
        });
      });
      pending["catch"](function (e) {
        return e;
      });
      return pending;
    }

    function isErrorObj(obj) {
      return !!(obj && obj.message !== undefined);
    }

    function getValue(value, path) {
      var v = value;

      for (var i = 0; i < path.length; i++) {
        if (v == undefined) {
          return v;
        }

        v = v[path[i]];
      }

      return v;
    }

    function complementError(rule, source) {
      return function (oe) {
        var fieldValue;

        if (rule.fullFields) {
          fieldValue = getValue(source, rule.fullFields);
        } else {
          fieldValue = source[oe.field || rule.fullField];
        }

        if (isErrorObj(oe)) {
          oe.field = oe.field || rule.fullField;
          oe.fieldValue = fieldValue;
          return oe;
        }

        return {
          message: typeof oe === 'function' ? oe() : oe,
          fieldValue: fieldValue,
          field: oe.field || rule.fullField
        };
      };
    }

    function deepMerge(target, source) {
      if (source) {
        for (var s in source) {
          if (source.hasOwnProperty(s)) {
            var value = source[s];

            if (typeof value === 'object' && typeof target[s] === 'object') {
              target[s] = _extends({}, target[s], value);
            } else {
              target[s] = value;
            }
          }
        }
      }

      return target;
    }

    var required$1 = function required(rule, value, source, errors, options, type) {
      if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type || rule.type))) {
        errors.push(format$1(options.messages.required, rule.fullField));
      }
    };
    /**
     *  Rule for validating whitespace.
     *
     *  @param rule The validation rule.
     *  @param value The value of the field on the source object.
     *  @param source The source object being validated.
     *  @param errors An array of errors that this rule may add
     *  validation errors to.
     *  @param options The validation options.
     *  @param options.messages The validation messages.
     */


    var whitespace = function whitespace(rule, value, source, errors, options) {
      if (/^\s+$/.test(value) || value === '') {
        errors.push(format$1(options.messages.whitespace, rule.fullField));
      }
    }; // https://github.com/kevva/url-regex/blob/master/index.js


    var urlReg;

    var getUrlRegex = function () {
      if (urlReg) {
        return urlReg;
      }

      var word = '[a-fA-F\\d:]';

      var b = function b(options) {
        return options && options.includeBoundaries ? "(?:(?<=\\s|^)(?=" + word + ")|(?<=" + word + ")(?=\\s|$))" : '';
      };

      var v4 = '(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}';
      var v6seg = '[a-fA-F\\d]{1,4}';
      var v6 = ("\n(?:\n(?:" + v6seg + ":){7}(?:" + v6seg + "|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8\n(?:" + v6seg + ":){6}(?:" + v4 + "|:" + v6seg + "|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4\n(?:" + v6seg + ":){5}(?::" + v4 + "|(?::" + v6seg + "){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4\n(?:" + v6seg + ":){4}(?:(?::" + v6seg + "){0,1}:" + v4 + "|(?::" + v6seg + "){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4\n(?:" + v6seg + ":){3}(?:(?::" + v6seg + "){0,2}:" + v4 + "|(?::" + v6seg + "){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4\n(?:" + v6seg + ":){2}(?:(?::" + v6seg + "){0,3}:" + v4 + "|(?::" + v6seg + "){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4\n(?:" + v6seg + ":){1}(?:(?::" + v6seg + "){0,4}:" + v4 + "|(?::" + v6seg + "){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4\n(?::(?:(?::" + v6seg + "){0,5}:" + v4 + "|(?::" + v6seg + "){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4\n)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1\n").replace(/\s*\/\/.*$/gm, '').replace(/\n/g, '').trim(); // Pre-compile only the exact regexes because adding a global flag make regexes stateful

      var v46Exact = new RegExp("(?:^" + v4 + "$)|(?:^" + v6 + "$)");
      var v4exact = new RegExp("^" + v4 + "$");
      var v6exact = new RegExp("^" + v6 + "$");

      var ip = function ip(options) {
        return options && options.exact ? v46Exact : new RegExp("(?:" + b(options) + v4 + b(options) + ")|(?:" + b(options) + v6 + b(options) + ")", 'g');
      };

      ip.v4 = function (options) {
        return options && options.exact ? v4exact : new RegExp("" + b(options) + v4 + b(options), 'g');
      };

      ip.v6 = function (options) {
        return options && options.exact ? v6exact : new RegExp("" + b(options) + v6 + b(options), 'g');
      };

      var protocol = "(?:(?:[a-z]+:)?//)";
      var auth = '(?:\\S+(?::\\S*)?@)?';
      var ipv4 = ip.v4().source;
      var ipv6 = ip.v6().source;
      var host = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)";
      var domain = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*";
      var tld = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))";
      var port = '(?::\\d{2,5})?';
      var path = '(?:[/?#][^\\s"]*)?';
      var regex = "(?:" + protocol + "|www\\.)" + auth + "(?:localhost|" + ipv4 + "|" + ipv6 + "|" + host + domain + tld + ")" + port + path;
      urlReg = new RegExp("(?:^" + regex + "$)", 'i');
      return urlReg;
    };
    /* eslint max-len:0 */


    var pattern$2 = {
      // http://emailregex.com/
      email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
      // url: new RegExp(
      //   '^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$',
      //   'i',
      // ),
      hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
    };
    var types = {
      integer: function integer(value) {
        return types.number(value) && parseInt(value, 10) === value;
      },
      "float": function float(value) {
        return types.number(value) && !types.integer(value);
      },
      array: function array(value) {
        return Array.isArray(value);
      },
      regexp: function regexp(value) {
        if (value instanceof RegExp) {
          return true;
        }

        try {
          return !!new RegExp(value);
        } catch (e) {
          return false;
        }
      },
      date: function date(value) {
        return typeof value.getTime === 'function' && typeof value.getMonth === 'function' && typeof value.getYear === 'function' && !isNaN(value.getTime());
      },
      number: function number(value) {
        if (isNaN(value)) {
          return false;
        }

        return typeof value === 'number';
      },
      object: function object(value) {
        return typeof value === 'object' && !types.array(value);
      },
      method: function method(value) {
        return typeof value === 'function';
      },
      email: function email(value) {
        return typeof value === 'string' && value.length <= 320 && !!value.match(pattern$2.email);
      },
      url: function url(value) {
        return typeof value === 'string' && value.length <= 2048 && !!value.match(getUrlRegex());
      },
      hex: function hex(value) {
        return typeof value === 'string' && !!value.match(pattern$2.hex);
      }
    };

    var type$1 = function type(rule, value, source, errors, options) {
      if (rule.required && value === undefined) {
        required$1(rule, value, source, errors, options);
        return;
      }

      var custom = ['integer', 'float', 'array', 'regexp', 'object', 'method', 'email', 'number', 'date', 'url', 'hex'];
      var ruleType = rule.type;

      if (custom.indexOf(ruleType) > -1) {
        if (!types[ruleType](value)) {
          errors.push(format$1(options.messages.types[ruleType], rule.fullField, rule.type));
        } // straight typeof check

      } else if (ruleType && typeof value !== rule.type) {
        errors.push(format$1(options.messages.types[ruleType], rule.fullField, rule.type));
      }
    };

    var range = function range(rule, value, source, errors, options) {
      var len = typeof rule.len === 'number';
      var min = typeof rule.min === 'number';
      var max = typeof rule.max === 'number'; // 正则匹配码点范围从U+010000一直到U+10FFFF的文字（补充平面Supplementary Plane）

      var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
      var val = value;
      var key = null;
      var num = typeof value === 'number';
      var str = typeof value === 'string';
      var arr = Array.isArray(value);

      if (num) {
        key = 'number';
      } else if (str) {
        key = 'string';
      } else if (arr) {
        key = 'array';
      } // if the value is not of a supported type for range validation
      // the validation rule rule should use the
      // type property to also test for a particular type


      if (!key) {
        return false;
      }

      if (arr) {
        val = value.length;
      }

      if (str) {
        // 处理码点大于U+010000的文字length属性不准确的bug，如"𠮷𠮷𠮷".lenght !== 3
        val = value.replace(spRegexp, '_').length;
      }

      if (len) {
        if (val !== rule.len) {
          errors.push(format$1(options.messages[key].len, rule.fullField, rule.len));
        }
      } else if (min && !max && val < rule.min) {
        errors.push(format$1(options.messages[key].min, rule.fullField, rule.min));
      } else if (max && !min && val > rule.max) {
        errors.push(format$1(options.messages[key].max, rule.fullField, rule.max));
      } else if (min && max && (val < rule.min || val > rule.max)) {
        errors.push(format$1(options.messages[key].range, rule.fullField, rule.min, rule.max));
      }
    };

    var ENUM$1 = 'enum';

    var enumerable$1 = function enumerable(rule, value, source, errors, options) {
      rule[ENUM$1] = Array.isArray(rule[ENUM$1]) ? rule[ENUM$1] : [];

      if (rule[ENUM$1].indexOf(value) === -1) {
        errors.push(format$1(options.messages[ENUM$1], rule.fullField, rule[ENUM$1].join(', ')));
      }
    };

    var pattern$1 = function pattern(rule, value, source, errors, options) {
      if (rule.pattern) {
        if (rule.pattern instanceof RegExp) {
          // if a RegExp instance is passed, reset `lastIndex` in case its `global`
          // flag is accidentally set to `true`, which in a validation scenario
          // is not necessary and the result might be misleading
          rule.pattern.lastIndex = 0;

          if (!rule.pattern.test(value)) {
            errors.push(format$1(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
          }
        } else if (typeof rule.pattern === 'string') {
          var _pattern = new RegExp(rule.pattern);

          if (!_pattern.test(value)) {
            errors.push(format$1(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
          }
        }
      }
    };

    var rules = {
      required: required$1,
      whitespace: whitespace,
      type: type$1,
      range: range,
      "enum": enumerable$1,
      pattern: pattern$1
    };

    var string = function string(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

      if (validate) {
        if (isEmptyValue(value, 'string') && !rule.required) {
          return callback();
        }

        rules.required(rule, value, source, errors, options, 'string');

        if (!isEmptyValue(value, 'string')) {
          rules.type(rule, value, source, errors, options);
          rules.range(rule, value, source, errors, options);
          rules.pattern(rule, value, source, errors, options);

          if (rule.whitespace === true) {
            rules.whitespace(rule, value, source, errors, options);
          }
        }
      }

      callback(errors);
    };

    var method = function method(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }

        rules.required(rule, value, source, errors, options);

        if (value !== undefined) {
          rules.type(rule, value, source, errors, options);
        }
      }

      callback(errors);
    };

    var number = function number(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

      if (validate) {
        if (value === '') {
          value = undefined;
        }

        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }

        rules.required(rule, value, source, errors, options);

        if (value !== undefined) {
          rules.type(rule, value, source, errors, options);
          rules.range(rule, value, source, errors, options);
        }
      }

      callback(errors);
    };

    var _boolean = function _boolean(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }

        rules.required(rule, value, source, errors, options);

        if (value !== undefined) {
          rules.type(rule, value, source, errors, options);
        }
      }

      callback(errors);
    };

    var regexp = function regexp(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }

        rules.required(rule, value, source, errors, options);

        if (!isEmptyValue(value)) {
          rules.type(rule, value, source, errors, options);
        }
      }

      callback(errors);
    };

    var integer = function integer(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }

        rules.required(rule, value, source, errors, options);

        if (value !== undefined) {
          rules.type(rule, value, source, errors, options);
          rules.range(rule, value, source, errors, options);
        }
      }

      callback(errors);
    };

    var floatFn = function floatFn(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }

        rules.required(rule, value, source, errors, options);

        if (value !== undefined) {
          rules.type(rule, value, source, errors, options);
          rules.range(rule, value, source, errors, options);
        }
      }

      callback(errors);
    };

    var array = function array(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

      if (validate) {
        if ((value === undefined || value === null) && !rule.required) {
          return callback();
        }

        rules.required(rule, value, source, errors, options, 'array');

        if (value !== undefined && value !== null) {
          rules.type(rule, value, source, errors, options);
          rules.range(rule, value, source, errors, options);
        }
      }

      callback(errors);
    };

    var object = function object(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }

        rules.required(rule, value, source, errors, options);

        if (value !== undefined) {
          rules.type(rule, value, source, errors, options);
        }
      }

      callback(errors);
    };

    var ENUM = 'enum';

    var enumerable = function enumerable(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }

        rules.required(rule, value, source, errors, options);

        if (value !== undefined) {
          rules[ENUM](rule, value, source, errors, options);
        }
      }

      callback(errors);
    };

    var pattern = function pattern(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

      if (validate) {
        if (isEmptyValue(value, 'string') && !rule.required) {
          return callback();
        }

        rules.required(rule, value, source, errors, options);

        if (!isEmptyValue(value, 'string')) {
          rules.pattern(rule, value, source, errors, options);
        }
      }

      callback(errors);
    };

    var date = function date(rule, value, callback, source, options) {
      // console.log('integer rule called %j', rule);
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field); // console.log('validate on %s value', value);

      if (validate) {
        if (isEmptyValue(value, 'date') && !rule.required) {
          return callback();
        }

        rules.required(rule, value, source, errors, options);

        if (!isEmptyValue(value, 'date')) {
          var dateObject;

          if (value instanceof Date) {
            dateObject = value;
          } else {
            dateObject = new Date(value);
          }

          rules.type(rule, dateObject, source, errors, options);

          if (dateObject) {
            rules.range(rule, dateObject.getTime(), source, errors, options);
          }
        }
      }

      callback(errors);
    };

    var required = function required(rule, value, callback, source, options) {
      var errors = [];
      var type = Array.isArray(value) ? 'array' : typeof value;
      rules.required(rule, value, source, errors, options, type);
      callback(errors);
    };

    var type = function type(rule, value, callback, source, options) {
      var ruleType = rule.type;
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

      if (validate) {
        if (isEmptyValue(value, ruleType) && !rule.required) {
          return callback();
        }

        rules.required(rule, value, source, errors, options, ruleType);

        if (!isEmptyValue(value, ruleType)) {
          rules.type(rule, value, source, errors, options);
        }
      }

      callback(errors);
    };

    var any = function any(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }

        rules.required(rule, value, source, errors, options);
      }

      callback(errors);
    };

    var validators = {
      string: string,
      method: method,
      number: number,
      "boolean": _boolean,
      regexp: regexp,
      integer: integer,
      "float": floatFn,
      array: array,
      object: object,
      "enum": enumerable,
      pattern: pattern,
      date: date,
      url: type,
      hex: type,
      email: type,
      required: required,
      any: any
    };

    function newMessages() {
      return {
        "default": 'Validation error on field %s',
        required: '%s is required',
        "enum": '%s must be one of %s',
        whitespace: '%s cannot be empty',
        date: {
          format: '%s date %s is invalid for format %s',
          parse: '%s date could not be parsed, %s is invalid ',
          invalid: '%s date %s is invalid'
        },
        types: {
          string: '%s is not a %s',
          method: '%s is not a %s (function)',
          array: '%s is not an %s',
          object: '%s is not an %s',
          number: '%s is not a %s',
          date: '%s is not a %s',
          "boolean": '%s is not a %s',
          integer: '%s is not an %s',
          "float": '%s is not a %s',
          regexp: '%s is not a valid %s',
          email: '%s is not a valid %s',
          url: '%s is not a valid %s',
          hex: '%s is not a valid %s'
        },
        string: {
          len: '%s must be exactly %s characters',
          min: '%s must be at least %s characters',
          max: '%s cannot be longer than %s characters',
          range: '%s must be between %s and %s characters'
        },
        number: {
          len: '%s must equal %s',
          min: '%s cannot be less than %s',
          max: '%s cannot be greater than %s',
          range: '%s must be between %s and %s'
        },
        array: {
          len: '%s must be exactly %s in length',
          min: '%s cannot be less than %s in length',
          max: '%s cannot be greater than %s in length',
          range: '%s must be between %s and %s in length'
        },
        pattern: {
          mismatch: '%s value %s does not match pattern %s'
        },
        clone: function clone() {
          var cloned = JSON.parse(JSON.stringify(this));
          cloned.clone = this.clone;
          return cloned;
        }
      };
    }

    var messages = newMessages();
    /**
     *  Encapsulates a validation schema.
     *
     *  @param descriptor An object declaring validation rules
     *  for this schema.
     */

    var Schema = /*#__PURE__*/function () {
      // ========================= Static =========================
      // ======================== Instance ========================
      function Schema(descriptor) {
        this.rules = null;
        this._messages = messages;
        this.define(descriptor);
      }

      var _proto = Schema.prototype;

      _proto.define = function define(rules) {
        var _this = this;

        if (!rules) {
          throw new Error('Cannot configure a schema with no rules');
        }

        if (typeof rules !== 'object' || Array.isArray(rules)) {
          throw new Error('Rules must be an object');
        }

        this.rules = {};
        Object.keys(rules).forEach(function (name) {
          var item = rules[name];
          _this.rules[name] = Array.isArray(item) ? item : [item];
        });
      };

      _proto.messages = function messages(_messages) {
        if (_messages) {
          this._messages = deepMerge(newMessages(), _messages);
        }

        return this._messages;
      };

      _proto.validate = function validate(source_, o, oc) {
        var _this2 = this;

        if (o === void 0) {
          o = {};
        }

        if (oc === void 0) {
          oc = function oc() {};
        }

        var source = source_;
        var options = o;
        var callback = oc;

        if (typeof options === 'function') {
          callback = options;
          options = {};
        }

        if (!this.rules || Object.keys(this.rules).length === 0) {
          if (callback) {
            callback(null, source);
          }

          return Promise.resolve(source);
        }

        function complete(results) {
          var errors = [];
          var fields = {};

          function add(e) {
            if (Array.isArray(e)) {
              var _errors;

              errors = (_errors = errors).concat.apply(_errors, e);
            } else {
              errors.push(e);
            }
          }

          for (var i = 0; i < results.length; i++) {
            add(results[i]);
          }

          if (!errors.length) {
            callback(null, source);
          } else {
            fields = convertFieldsError(errors);
            callback(errors, fields);
          }
        }

        if (options.messages) {
          var messages$1 = this.messages();

          if (messages$1 === messages) {
            messages$1 = newMessages();
          }

          deepMerge(messages$1, options.messages);
          options.messages = messages$1;
        } else {
          options.messages = this.messages();
        }

        var series = {};
        var keys = options.keys || Object.keys(this.rules);
        keys.forEach(function (z) {
          var arr = _this2.rules[z];
          var value = source[z];
          arr.forEach(function (r) {
            var rule = r;

            if (typeof rule.transform === 'function') {
              if (source === source_) {
                source = _extends({}, source);
              }

              value = source[z] = rule.transform(value);
            }

            if (typeof rule === 'function') {
              rule = {
                validator: rule
              };
            } else {
              rule = _extends({}, rule);
            } // Fill validator. Skip if nothing need to validate


            rule.validator = _this2.getValidationMethod(rule);

            if (!rule.validator) {
              return;
            }

            rule.field = z;
            rule.fullField = rule.fullField || z;
            rule.type = _this2.getType(rule);
            series[z] = series[z] || [];
            series[z].push({
              rule: rule,
              value: value,
              source: source,
              field: z
            });
          });
        });
        var errorFields = {};
        return asyncMap(series, options, function (data, doIt) {
          var rule = data.rule;
          var deep = (rule.type === 'object' || rule.type === 'array') && (typeof rule.fields === 'object' || typeof rule.defaultField === 'object');
          deep = deep && (rule.required || !rule.required && data.value);
          rule.field = data.field;

          function addFullField(key, schema) {
            return _extends({}, schema, {
              fullField: rule.fullField + "." + key,
              fullFields: rule.fullFields ? [].concat(rule.fullFields, [key]) : [key]
            });
          }

          function cb(e) {
            if (e === void 0) {
              e = [];
            }

            var errorList = Array.isArray(e) ? e : [e];

            if (!options.suppressWarning && errorList.length) {
              Schema.warning('async-validator:', errorList);
            }

            if (errorList.length && rule.message !== undefined) {
              errorList = [].concat(rule.message);
            } // Fill error info


            var filledErrors = errorList.map(complementError(rule, source));

            if (options.first && filledErrors.length) {
              errorFields[rule.field] = 1;
              return doIt(filledErrors);
            }

            if (!deep) {
              doIt(filledErrors);
            } else {
              // if rule is required but the target object
              // does not exist fail at the rule level and don't
              // go deeper
              if (rule.required && !data.value) {
                if (rule.message !== undefined) {
                  filledErrors = [].concat(rule.message).map(complementError(rule, source));
                } else if (options.error) {
                  filledErrors = [options.error(rule, format$1(options.messages.required, rule.field))];
                }

                return doIt(filledErrors);
              }

              var fieldsSchema = {};

              if (rule.defaultField) {
                Object.keys(data.value).map(function (key) {
                  fieldsSchema[key] = rule.defaultField;
                });
              }

              fieldsSchema = _extends({}, fieldsSchema, data.rule.fields);
              var paredFieldsSchema = {};
              Object.keys(fieldsSchema).forEach(function (field) {
                var fieldSchema = fieldsSchema[field];
                var fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [fieldSchema];
                paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));
              });
              var schema = new Schema(paredFieldsSchema);
              schema.messages(options.messages);

              if (data.rule.options) {
                data.rule.options.messages = options.messages;
                data.rule.options.error = options.error;
              }

              schema.validate(data.value, data.rule.options || options, function (errs) {
                var finalErrors = [];

                if (filledErrors && filledErrors.length) {
                  finalErrors.push.apply(finalErrors, filledErrors);
                }

                if (errs && errs.length) {
                  finalErrors.push.apply(finalErrors, errs);
                }

                doIt(finalErrors.length ? finalErrors : null);
              });
            }
          }

          var res;

          if (rule.asyncValidator) {
            res = rule.asyncValidator(rule, data.value, cb, data.source, options);
          } else if (rule.validator) {
            try {
              res = rule.validator(rule, data.value, cb, data.source, options);
            } catch (error) {
              console.error == null ? void 0 : console.error(error); // rethrow to report error

              if (!options.suppressValidatorError) {
                setTimeout(function () {
                  throw error;
                }, 0);
              }

              cb(error.message);
            }

            if (res === true) {
              cb();
            } else if (res === false) {
              cb(typeof rule.message === 'function' ? rule.message(rule.fullField || rule.field) : rule.message || (rule.fullField || rule.field) + " fails");
            } else if (res instanceof Array) {
              cb(res);
            } else if (res instanceof Error) {
              cb(res.message);
            }
          }

          if (res && res.then) {
            res.then(function () {
              return cb();
            }, function (e) {
              return cb(e);
            });
          }
        }, function (results) {
          complete(results);
        }, source);
      };

      _proto.getType = function getType(rule) {
        if (rule.type === undefined && rule.pattern instanceof RegExp) {
          rule.type = 'pattern';
        }

        if (typeof rule.validator !== 'function' && rule.type && !validators.hasOwnProperty(rule.type)) {
          throw new Error(format$1('Unknown rule type %s', rule.type));
        }

        return rule.type || 'string';
      };

      _proto.getValidationMethod = function getValidationMethod(rule) {
        if (typeof rule.validator === 'function') {
          return rule.validator;
        }

        var keys = Object.keys(rule);
        var messageIndex = keys.indexOf('message');

        if (messageIndex !== -1) {
          keys.splice(messageIndex, 1);
        }

        if (keys.length === 1 && keys[0] === 'required') {
          return validators.required;
        }

        return validators[this.getType(rule)] || undefined;
      };

      return Schema;
    }();

    Schema.register = function register(type, validator) {
      if (typeof validator !== 'function') {
        throw new Error('Cannot register a validator by type, validator is not a function');
      }

      validators[type] = validator;
    };

    Schema.warning = warning;
    Schema.messages = messages;
    Schema.validators = validators;

    function formItemSize(props) {
      const NForm = vue.inject(formInjectionKey, null);
      return {
        mergedSize: vue.computed(() => {
          if (props.size !== void 0) return props.size;
          if ((NForm === null || NForm === void 0 ? void 0 : NForm.props.size) !== void 0) return NForm.props.size;
          return "medium";
        })
      };
    }
    function formItemMisc(props) {
      const NForm = vue.inject(formInjectionKey, null);
      const mergedLabelWidthRef = vue.computed(() => {
        if (mergedLabelPlacementRef.value === "top") return;
        const {
          labelWidth
        } = props;

        if (labelWidth !== void 0 && labelWidth !== "auto") {
          return formatLength(labelWidth);
        }

        if (labelWidth === "auto" || (NForm === null || NForm === void 0 ? void 0 : NForm.props.labelWidth) === "auto") {
          const autoComputedWidth = NForm === null || NForm === void 0 ? void 0 : NForm.maxChildLabelWidthRef.value;

          if (autoComputedWidth !== void 0) {
            return formatLength(autoComputedWidth);
          } else {
            return void 0;
          }
        }

        if ((NForm === null || NForm === void 0 ? void 0 : NForm.props.labelWidth) !== void 0) {
          return formatLength(NForm.props.labelWidth);
        }

        return void 0;
      });
      const mergedLabelPlacementRef = vue.computed(() => {
        const {
          labelPlacement
        } = props;
        if (labelPlacement !== void 0) return labelPlacement;
        if (NForm !== null && NForm !== void 0 && NForm.props.labelPlacement) return NForm.props.labelPlacement;
        return "top";
      });
      const mergedLabelAlignRef = vue.computed(() => {
        const {
          labelAlign
        } = props;
        if (labelAlign) return labelAlign;
        if (NForm !== null && NForm !== void 0 && NForm.props.labelAlign) return NForm.props.labelAlign;
        return void 0;
      });
      const mergedLabelStyleRef = vue.computed(() => {
        var _props$labelProps;

        return [(_props$labelProps = props.labelProps) === null || _props$labelProps === void 0 ? void 0 : _props$labelProps.style, props.labelStyle, {
          width: mergedLabelWidthRef.value
        }];
      });
      const mergedShowRequireMarkRef = vue.computed(() => {
        const {
          showRequireMark
        } = props;
        if (showRequireMark !== void 0) return showRequireMark;
        return NForm === null || NForm === void 0 ? void 0 : NForm.props.showRequireMark;
      });
      const mergedRequireMarkPlacementRef = vue.computed(() => {
        const {
          requireMarkPlacement
        } = props;
        if (requireMarkPlacement !== void 0) return requireMarkPlacement;
        return (NForm === null || NForm === void 0 ? void 0 : NForm.props.requireMarkPlacement) || "right";
      });
      const validationErroredRef = vue.ref(false);
      const mergedValidationStatusRef = vue.computed(() => {
        const {
          validationStatus
        } = props;
        if (validationStatus !== void 0) return validationStatus;
        if (validationErroredRef.value) return "error";
        return void 0;
      });
      const mergedShowFeedbackRef = vue.computed(() => {
        const {
          showFeedback
        } = props;
        if (showFeedback !== void 0) return showFeedback;
        if ((NForm === null || NForm === void 0 ? void 0 : NForm.props.showFeedback) !== void 0) return NForm.props.showFeedback;
        return true;
      });
      const mergedShowLabelRef = vue.computed(() => {
        const {
          showLabel
        } = props;
        if (showLabel !== void 0) return showLabel;
        if ((NForm === null || NForm === void 0 ? void 0 : NForm.props.showLabel) !== void 0) return NForm.props.showLabel;
        return true;
      });
      return {
        validationErrored: validationErroredRef,
        mergedLabelStyle: mergedLabelStyleRef,
        mergedLabelPlacement: mergedLabelPlacementRef,
        mergedLabelAlign: mergedLabelAlignRef,
        mergedShowRequireMark: mergedShowRequireMarkRef,
        mergedRequireMarkPlacement: mergedRequireMarkPlacementRef,
        mergedValidationStatus: mergedValidationStatusRef,
        mergedShowFeedback: mergedShowFeedbackRef,
        mergedShowLabel: mergedShowLabelRef
      };
    }
    function formItemRule(props) {
      const NForm = vue.inject(formInjectionKey, null);
      const compatibleRulePathRef = vue.computed(() => {
        const {
          rulePath
        } = props;
        if (rulePath !== void 0) return rulePath;
        const {
          path
        } = props;
        if (path !== void 0) return path;
        return void 0;
      });
      const mergedRulesRef = vue.computed(() => {
        const rules = [];
        const {
          rule
        } = props;

        if (rule !== void 0) {
          if (Array.isArray(rule)) rules.push(...rule);else rules.push(rule);
        }

        if (NForm) {
          const {
            rules: formRules
          } = NForm.props;
          const {
            value: rulePath
          } = compatibleRulePathRef;

          if (formRules !== void 0 && rulePath !== void 0) {
            const formRule = lodash.exports.get(formRules, rulePath);

            if (formRule !== void 0) {
              if (Array.isArray(formRule)) {
                rules.push(...formRule);
              } else {
                rules.push(formRule);
              }
            }
          }
        }

        return rules;
      });
      const hasRequiredRuleRef = vue.computed(() => {
        return mergedRulesRef.value.some(rule => rule.required);
      });
      const mergedRequiredRef = vue.computed(() => {
        return hasRequiredRuleRef.value || props.required;
      });
      return {
        mergedRules: mergedRulesRef,
        mergedRequired: mergedRequiredRef
      };
    }

    const {
      cubicBezierEaseInOut
    } = commonVariables$m;
    function fadeDownTransition() {
      let {
        name = "fade-down",
        fromOffset = "-4px",
        enterDuration = ".3s",
        leaveDuration = ".3s",
        enterCubicBezier = cubicBezierEaseInOut,
        leaveCubicBezier = cubicBezierEaseInOut
      } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return [c$1(`&.${name}-transition-enter-from, &.${name}-transition-leave-to`, {
        opacity: 0,
        transform: `translateY(${fromOffset})`
      }), c$1(`&.${name}-transition-enter-to, &.${name}-transition-leave-from`, {
        opacity: 1,
        transform: "translateY(0)"
      }), c$1(`&.${name}-transition-leave-active`, {
        transition: `opacity ${leaveDuration} ${leaveCubicBezier}, transform ${leaveDuration} ${leaveCubicBezier}`
      }), c$1(`&.${name}-transition-enter-active`, {
        transition: `opacity ${enterDuration} ${enterCubicBezier}, transform ${enterDuration} ${enterCubicBezier}`
      })];
    }

    var style$I = cB("form-item", {
      display: "grid",
      lineHeight: "var(--n-line-height)"
    }, [cB("form-item-label", `
    grid-area: label;
    align-items: center;
    line-height: 1.25;
    text-align: var(--n-label-text-align);
    font-size: var(--n-label-font-size);
    height: var(--n-label-height);
    padding: var(--n-label-padding);
    color: var(--n-label-text-color);
    transition: color .3s var(--n-bezier);
    box-sizing: border-box;
  `, [cE("asterisk", `
      user-select: none;
      -webkit-user-select: none;
      color: var(--n-asterisk-color);
      transition: color .3s var(--n-bezier);
    `), cE("asterisk-placeholder", `
      user-select: none;
      -webkit-user-select: none;
      visibility: hidden;
    `)]), cB("form-item-blank", {
      gridArea: "blank",
      minHeight: "var(--n-blank-height)"
    }), cM("left-labelled", `
    grid-template-areas:
      "label blank"
      "label feedback";
    grid-template-columns: auto minmax(0, 1fr);
  `, [cB("form-item-label", `
      height: var(--n-blank-height);
      line-height: var(--n-blank-height);
      box-sizing: border-box;
      white-space: nowrap;
      flex-shrink: 0;
      flex-grow: 0;
    `)]), cM("top-labelled", `
    grid-template-areas:
      "label"
      "blank"
      "feedback";
    grid-template-rows: var(--n-label-height) 1fr;
    grid-template-columns: minmax(0, 100%);
  `, [cM("no-label", `
      grid-template-areas:
        "blank"
        "feedback";
        grid-template-rows: 1fr;
    `), cB("form-item-label", {
      display: "flex",
      alignItems: "flex-end",
      justifyContent: "var(--n-label-text-align)"
    })]), cB("form-item-blank", `
    box-sizing: border-box;
    display: flex;
    align-items: center;
    position: relative;
  `), cB("form-item-feedback-wrapper", `
    grid-area: feedback;
    box-sizing: border-box;
    min-height: var(--n-feedback-height);
    font-size: var(--n-feedback-font-size);
    line-height: 1.25;
    transform-origin: top left;
  `, [c$1("&:not(:empty)", `
      padding: var(--n-feedback-padding);
    `), cB("form-item-feedback", {
      transition: "color .3s var(--n-bezier)",
      color: "var(--n-feedback-text-color)"
    }, [cM("warning", {
      color: "var(--n-feedback-text-color-warning)"
    }), cM("error", {
      color: "var(--n-feedback-text-color-error)"
    }), fadeDownTransition({
      fromOffset: "-3px",
      enterDuration: ".3s",
      leaveDuration: ".2s"
    })])])]);

    const formItemProps = {
      ...useTheme.props,
      label: String,
      labelWidth: [Number, String],
      labelStyle: [String, Object],
      labelAlign: String,
      labelPlacement: String,
      path: String,
      first: Boolean,
      rulePath: String,
      required: Boolean,
      showRequireMark: {
        type: Boolean,
        default: void 0
      },
      requireMarkPlacement: String,
      showFeedback: {
        type: Boolean,
        default: void 0
      },
      rule: [Object, Array],
      size: String,
      ignorePathChange: Boolean,
      validationStatus: String,
      feedback: String,
      showLabel: {
        type: Boolean,
        default: void 0
      },
      labelProps: Object
    };
    const formItemPropKeys = keysOf(formItemProps);
    function wrapValidator(validator, async) {
      return (...args) => {
        try {
          const validateResult = validator(...args);
          if (!async && (typeof validateResult === "boolean" || validateResult instanceof Error || Array.isArray(validateResult)) || validateResult?.then) {
            return validateResult;
          } else if (validateResult === void 0) {
            return true;
          } else {
            warn$2(
              "form-item/validate",
              `You return a ${typeof validateResult} typed value in the validator method, which is not recommended. Please use ` + (async ? "`Promise`" : "`boolean`, `Error` or `Promise`") + " typed value instead."
            );
            return true;
          }
        } catch (err) {
          warn$2(
            "form-item/validate",
            "An error is catched in the validation, so the validation won't be done. Your callback in `validate` method of `n-form` or `n-form-item` won't be called in this validation."
          );
          console.error(err);
          return void 0;
        }
      };
    }
    var NFormItem = vue.defineComponent({
      name: "FormItem",
      props: formItemProps,
      setup(props) {
        useInjectionInstanceCollection(
          formItemInstsInjectionKey,
          "formItems",
          vue.toRef(props, "path")
        );
        const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
        const NForm = vue.inject(formInjectionKey, null);
        const formItemSizeRefs = formItemSize(props);
        const formItemMiscRefs = formItemMisc(props);
        const { validationErrored: validationErroredRef } = formItemMiscRefs;
        const { mergedRequired: mergedRequiredRef, mergedRules: mergedRulesRef } = formItemRule(props);
        const { mergedSize: mergedSizeRef } = formItemSizeRefs;
        const {
          mergedLabelPlacement: labelPlacementRef,
          mergedLabelAlign: labelTextAlignRef
        } = formItemMiscRefs;
        const renderExplainsRef = vue.ref([]);
        const feedbackIdRef = vue.ref(createId());
        const mergedDisabledRef = NForm ? vue.toRef(NForm.props, "disabled") : vue.ref(false);
        const themeRef = useTheme(
          "Form",
          "-form-item",
          style$I,
          formLight$1,
          props,
          mergedClsPrefixRef
        );
        vue.watch(vue.toRef(props, "path"), () => {
          if (props.ignorePathChange)
            return;
          restoreValidation();
        });
        function restoreValidation() {
          renderExplainsRef.value = [];
          validationErroredRef.value = false;
          if (props.feedback) {
            feedbackIdRef.value = createId();
          }
        }
        function handleContentBlur() {
          void internalValidate("blur");
        }
        function handleContentChange() {
          void internalValidate("change");
        }
        function handleContentFocus() {
          void internalValidate("focus");
        }
        function handleContentInput() {
          void internalValidate("input");
        }
        async function validate(options, callback) {
          let trigger;
          let validateCallback;
          let shouldRuleBeApplied;
          let asyncValidatorOptions;
          if (typeof options === "string") {
            trigger = options;
            validateCallback = callback;
          } else if (options !== null && typeof options === "object") {
            trigger = options.trigger;
            validateCallback = options.callback;
            shouldRuleBeApplied = options.shouldRuleBeApplied;
            asyncValidatorOptions = options.options;
          }
          return await new Promise((resolve, reject) => {
            void internalValidate(
              trigger,
              shouldRuleBeApplied,
              asyncValidatorOptions
            ).then(({ valid, errors }) => {
              if (valid) {
                if (validateCallback) {
                  validateCallback();
                }
                resolve();
              } else {
                if (validateCallback) {
                  validateCallback(errors);
                }
                reject(errors);
              }
            });
          });
        }
        const internalValidate = async (trigger = null, shouldRuleBeApplied = () => true, options = {
          suppressWarning: true
        }) => {
          const { path } = props;
          if (!options) {
            options = {};
          } else {
            if (!options.first)
              options.first = props.first;
          }
          const { value: rules } = mergedRulesRef;
          const value = NForm ? lodash.exports.get(NForm.props.model, path || "") : void 0;
          const messageRenderers = {};
          const originalMessageRendersMessage = {};
          const activeRules = (!trigger ? rules : rules.filter((rule) => {
            if (Array.isArray(rule.trigger)) {
              return rule.trigger.includes(trigger);
            } else {
              return rule.trigger === trigger;
            }
          })).filter(shouldRuleBeApplied).map((rule, i) => {
            const shallowClonedRule = Object.assign({}, rule);
            if (shallowClonedRule.validator) {
              shallowClonedRule.validator = wrapValidator(
                shallowClonedRule.validator,
                false
              );
            }
            if (shallowClonedRule.asyncValidator) {
              shallowClonedRule.asyncValidator = wrapValidator(
                shallowClonedRule.asyncValidator,
                true
              );
            }
            if (shallowClonedRule.renderMessage) {
              const rendererKey = `__renderMessage__${i}`;
              originalMessageRendersMessage[rendererKey] = shallowClonedRule.message;
              shallowClonedRule.message = rendererKey;
              messageRenderers[rendererKey] = shallowClonedRule.renderMessage;
            }
            return shallowClonedRule;
          });
          if (!activeRules.length) {
            return {
              valid: true
            };
          }
          const mergedPath = path ?? "__n_no_path__";
          const validator = new Schema({ [mergedPath]: activeRules });
          const { validateMessages } = NForm?.props || {};
          if (validateMessages) {
            validator.messages(validateMessages);
          }
          return await new Promise((resolve) => {
            void validator.validate({ [mergedPath]: value }, options, (errors) => {
              if (errors?.length) {
                renderExplainsRef.value = errors.map((error) => {
                  const transformedMessage = error?.message || "";
                  return {
                    key: transformedMessage,
                    render: () => {
                      if (transformedMessage.startsWith("__renderMessage__")) {
                        return messageRenderers[transformedMessage]();
                      }
                      return transformedMessage;
                    }
                  };
                });
                errors.forEach((error) => {
                  if (error.message?.startsWith("__renderMessage__")) {
                    error.message = originalMessageRendersMessage[error.message];
                  }
                });
                validationErroredRef.value = true;
                resolve({
                  valid: false,
                  errors
                });
              } else {
                restoreValidation();
                resolve({
                  valid: true
                });
              }
            });
          });
        };
        vue.provide(formItemInjectionKey, {
          path: vue.toRef(props, "path"),
          disabled: mergedDisabledRef,
          mergedSize: formItemSizeRefs.mergedSize,
          mergedValidationStatus: formItemMiscRefs.mergedValidationStatus,
          restoreValidation,
          handleContentBlur,
          handleContentChange,
          handleContentFocus,
          handleContentInput
        });
        const exposedRef = {
          validate,
          restoreValidation,
          internalValidate
        };
        const labelElementRef = vue.ref(null);
        vue.onMounted(() => {
          if (labelElementRef.value !== null) {
            NForm?.deriveMaxChildLabelWidth(
              Number(getComputedStyle(labelElementRef.value).width.slice(0, -2))
            );
          }
        });
        const cssVarsRef = vue.computed(() => {
          const { value: size } = mergedSizeRef;
          const { value: labelPlacement } = labelPlacementRef;
          const direction = labelPlacement === "top" ? "vertical" : "horizontal";
          const {
            common: { cubicBezierEaseInOut },
            self: {
              labelTextColor,
              asteriskColor,
              lineHeight,
              feedbackTextColor,
              feedbackTextColorWarning,
              feedbackTextColorError,
              feedbackPadding,
              [createKey("labelHeight", size)]: labelHeight,
              [createKey("blankHeight", size)]: blankHeight,
              [createKey("feedbackFontSize", size)]: feedbackFontSize,
              [createKey("feedbackHeight", size)]: feedbackHeight,
              [createKey("labelPadding", direction)]: labelPadding,
              [createKey("labelTextAlign", direction)]: labelTextAlign,
              [createKey(createKey("labelFontSize", labelPlacement), size)]: labelFontSize
            }
          } = themeRef.value;
          let mergedLabelTextAlign = labelTextAlignRef.value ?? labelTextAlign;
          if (labelPlacement === "top") {
            mergedLabelTextAlign = mergedLabelTextAlign === "right" ? "flex-end" : "flex-start";
          }
          const cssVars = {
            "--n-bezier": cubicBezierEaseInOut,
            "--n-line-height": lineHeight,
            "--n-blank-height": blankHeight,
            "--n-label-font-size": labelFontSize,
            "--n-label-text-align": mergedLabelTextAlign,
            "--n-label-height": labelHeight,
            "--n-label-padding": labelPadding,
            "--n-asterisk-color": asteriskColor,
            "--n-label-text-color": labelTextColor,
            "--n-feedback-padding": feedbackPadding,
            "--n-feedback-font-size": feedbackFontSize,
            "--n-feedback-height": feedbackHeight,
            "--n-feedback-text-color": feedbackTextColor,
            "--n-feedback-text-color-warning": feedbackTextColorWarning,
            "--n-feedback-text-color-error": feedbackTextColorError
          };
          return cssVars;
        });
        const themeClassHandle = useThemeClass(
          "form-item",
          vue.computed(() => {
            return `${mergedSizeRef.value[0]}${labelPlacementRef.value[0]}${labelTextAlignRef.value?.[0] || ""}`;
          }),
          cssVarsRef,
          props
        );
        return {
          labelElementRef,
          mergedClsPrefix: mergedClsPrefixRef,
          mergedRequired: mergedRequiredRef,
          feedbackId: feedbackIdRef,
          renderExplains: renderExplainsRef,
          ...formItemMiscRefs,
          ...formItemSizeRefs,
          ...exposedRef,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender
        };
      },
      render() {
        const {
          $slots,
          mergedClsPrefix,
          mergedShowLabel,
          mergedShowRequireMark,
          mergedRequireMarkPlacement,
          onRender
        } = this;
        const renderedShowRequireMark = mergedShowRequireMark !== void 0 ? mergedShowRequireMark : this.mergedRequired;
        onRender?.();
        return /* @__PURE__ */ vue.h("div", {
          class: [
            `${mergedClsPrefix}-form-item`,
            this.themeClass,
            `${mergedClsPrefix}-form-item--${this.mergedSize}-size`,
            `${mergedClsPrefix}-form-item--${this.mergedLabelPlacement}-labelled`,
            !mergedShowLabel && `${mergedClsPrefix}-form-item--no-label`
          ],
          style: this.cssVars
        }, mergedShowLabel && (this.label || $slots.label) ? /* @__PURE__ */ vue.h("label", {
          ...this.labelProps,
          class: [
            this.labelProps?.class,
            `${mergedClsPrefix}-form-item-label`
          ],
          style: this.mergedLabelStyle,
          ref: "labelElementRef"
        }, mergedRequireMarkPlacement !== "left" ? $slots.label ? $slots.label() : this.label : null, renderedShowRequireMark ? /* @__PURE__ */ vue.h("span", {
          class: `${mergedClsPrefix}-form-item-label__asterisk`
        }, mergedRequireMarkPlacement !== "left" ? "\xA0*" : "*\xA0") : mergedRequireMarkPlacement === "right-hanging" && /* @__PURE__ */ vue.h("span", {
          class: `${mergedClsPrefix}-form-item-label__asterisk-placeholder`
        }, "\xA0*"), mergedRequireMarkPlacement === "left" ? $slots.label ? $slots.label() : this.label : null) : null, /* @__PURE__ */ vue.h("div", {
          class: [
            `${mergedClsPrefix}-form-item-blank`,
            this.mergedValidationStatus && `${mergedClsPrefix}-form-item-blank--${this.mergedValidationStatus}`
          ]
        }, $slots), this.mergedShowFeedback ? /* @__PURE__ */ vue.h("div", {
          key: this.feedbackId,
          class: `${mergedClsPrefix}-form-item-feedback-wrapper`
        }, /* @__PURE__ */ vue.h(vue.Transition, {
          name: "fade-down-transition",
          mode: "out-in"
        }, {
          default: () => {
            const { mergedValidationStatus } = this;
            return resolveWrappedSlot($slots.feedback, (children) => {
              const { feedback } = this;
              const feedbackNodes = children || feedback ? /* @__PURE__ */ vue.h("div", {
                key: "__feedback__",
                class: `${mergedClsPrefix}-form-item-feedback__line`
              }, children || feedback) : this.renderExplains.length ? this.renderExplains?.map(({ key, render }) => /* @__PURE__ */ vue.h("div", {
                key,
                class: `${mergedClsPrefix}-form-item-feedback__line`
              }, render())) : null;
              return feedbackNodes ? mergedValidationStatus === "warning" ? /* @__PURE__ */ vue.h("div", {
                key: "controlled-warning",
                class: `${mergedClsPrefix}-form-item-feedback ${mergedClsPrefix}-form-item-feedback--warning`
              }, feedbackNodes) : mergedValidationStatus === "error" ? /* @__PURE__ */ vue.h("div", {
                key: "controlled-error",
                class: `${mergedClsPrefix}-form-item-feedback ${mergedClsPrefix}-form-item-feedback--error`
              }, feedbackNodes) : mergedValidationStatus === "success" ? /* @__PURE__ */ vue.h("div", {
                key: "controlled-success",
                class: `${mergedClsPrefix}-form-item-feedback ${mergedClsPrefix}-form-item-feedback--success`
              }, feedbackNodes) : /* @__PURE__ */ vue.h("div", {
                key: "controlled-default",
                class: `${mergedClsPrefix}-form-item-feedback`
              }, feedbackNodes) : null;
            });
          }
        })) : null);
      }
    });

    const defaultSpan$1 = 1;
    const gridInjectionKey = createInjectionKey("n-grid");

    const defaultSpan = 1;
    const gridItemProps = {
      span: {
        type: [Number, String],
        default: defaultSpan
      },
      offset: {
        type: [Number, String],
        default: 0
      },
      suffix: Boolean,
      privateOffset: Number,
      privateSpan: Number,
      privateColStart: Number,
      privateShow: {
        type: Boolean,
        default: true
      }
    };
    const gridItemPropKeys = keysOf(gridItemProps);
    var NGridItem = vue.defineComponent({
      __GRID_ITEM__: true,
      name: "GridItem",
      alias: ["Gi"],
      props: gridItemProps,
      setup() {
        const {
          isSsrRef,
          xGapRef,
          itemStyleRef,
          overflowRef,
          layoutShiftDisabledRef
        } = vue.inject(gridInjectionKey);
        const self = vue.getCurrentInstance();
        return {
          overflow: overflowRef,
          itemStyle: itemStyleRef,
          layoutShiftDisabled: layoutShiftDisabledRef,
          mergedXGap: vue.computed(() => {
            return pxfy(xGapRef.value || 0);
          }),
          deriveStyle: () => {
            void isSsrRef.value;
            const {
              privateSpan = defaultSpan,
              privateShow = true,
              privateColStart = void 0,
              privateOffset = 0
            } = self.vnode.props;
            const { value: xGap } = xGapRef;
            const mergedXGap = pxfy(xGap || 0);
            return {
              display: !privateShow ? "none" : "",
              gridColumn: `${privateColStart ?? `span ${privateSpan}`} / span ${privateSpan}`,
              marginLeft: privateOffset ? `calc((100% - (${privateSpan} - 1) * ${mergedXGap}) / ${privateSpan} * ${privateOffset} + ${mergedXGap} * ${privateOffset})` : ""
            };
          }
        };
      },
      render() {
        if (this.layoutShiftDisabled) {
          const { span, offset, mergedXGap } = this;
          return /* @__PURE__ */ vue.h("div", {
            style: {
              gridColumn: `span ${span} / span ${span}`,
              marginLeft: offset ? `calc((100% - (${span} - 1) * ${mergedXGap}) / ${span} * ${offset} + ${mergedXGap} * ${offset})` : ""
            }
          }, this.$slots);
        }
        return /* @__PURE__ */ vue.h("div", {
          style: [this.itemStyle, this.deriveStyle()]
        }, this.$slots.default?.({ overflow: this.overflow }));
      }
    });

    const formItemGiProps = { ...gridItemProps,
      ...formItemProps
    };
    var FormItemGridItem = vue.defineComponent({
      __GRID_ITEM__: true,
      name: "FormItemGridItem",
      alias: ["FormItemGi"],
      props: formItemGiProps,

      setup() {
        const formItemInstRef = vue.ref(null);

        const validate = function () {
          const {
            value
          } = formItemInstRef;

          if (value) {
            return value.validate(...arguments);
          }
        };

        const restoreValidation = () => {
          const {
            value
          } = formItemInstRef;

          if (value) {
            return value.restoreValidation();
          }
        };

        return {
          formItemInstRef,
          validate,
          restoreValidation
        };
      },

      render() {
        return vue.h(NGridItem, keep(this.$.vnode.props || {}, gridItemPropKeys), {
          default: () => {
            const itemProps = keep(this.$props, formItemPropKeys);
            return vue.h(NFormItem, {
              ref: "formItemInstRef",
              ...itemProps
            }, this.$slots);
          }
        });
      }

    });

    const positionStyles$1 = Array.apply(null, {
      length: 24
    }).map((_, index) => {
      const prefixIndex = index + 1;
      const percent = `calc(100% / 24 * ${prefixIndex})`;
      return [cM(`${prefixIndex}-span`, {
        width: percent
      }), cM(`${prefixIndex}-offset`, {
        marginLeft: percent
      }), cM(`${prefixIndex}-push`, {
        left: percent
      }), cM(`${prefixIndex}-pull`, {
        right: percent
      })];
    });
    var style$H = c$1([cB("row", {
      width: "100%",
      display: "flex",
      flexWrap: "wrap"
    }), cB("col", {
      verticalAlign: "top",
      boxSizing: "border-box",
      display: "inline-block",
      position: "relative",
      zIndex: "auto"
    }, [cE("box", {
      position: "relative",
      zIndex: "auto",
      width: "100%",
      height: "100%"
    }), positionStyles$1])]);

    const rowInjectionKey = createInjectionKey("n-row");
    const rowProps = {
      gutter: {
        type: [Array, Number, String],
        default: 0
      },
      alignItems: String,
      justifyContent: String
    };
    const rowPropKeys = keysOf(rowProps);
    var NRow = vue.defineComponent({
      name: "Row",
      props: rowProps,
      setup(props) {
        const { mergedClsPrefixRef, mergedRtlRef } = useConfig(props);
        useStyle("-legacy-grid", style$H, mergedClsPrefixRef);
        const rtlEnabledRef = useRtl("Row", mergedRtlRef, mergedClsPrefixRef);
        const verticalGutterRef = useMemo(() => {
          const { gutter } = props;
          if (Array.isArray(gutter)) {
            return gutter[1] || 0;
          }
          return 0;
        });
        const horizontalGutterRef = useMemo(() => {
          const { gutter } = props;
          if (Array.isArray(gutter)) {
            return gutter[0];
          }
          return Number(gutter);
        });
        vue.provide(rowInjectionKey, {
          mergedClsPrefixRef,
          gutterRef: vue.toRef(props, "gutter"),
          verticalGutterRef,
          horizontalGutterRef
        });
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          rtlEnabled: rtlEnabledRef,
          styleMargin: useMemo(
            () => `-${formatLength(verticalGutterRef.value, {
          c: 0.5
        })} -${formatLength(horizontalGutterRef.value, { c: 0.5 })}`
          ),
          styleWidth: useMemo(
            () => `calc(100% + ${formatLength(horizontalGutterRef.value)})`
          )
        };
      },
      render() {
        return /* @__PURE__ */ vue.h("div", {
          class: [
            `${this.mergedClsPrefix}-row`,
            this.rtlEnabled && `${this.mergedClsPrefix}-row--rtl`
          ],
          style: {
            margin: this.styleMargin,
            width: this.styleWidth,
            alignItems: this.alignItems,
            justifyContent: this.justifyContent
          }
        }, this.$slots);
      }
    });

    const colProps = {
      span: {
        type: [String, Number],
        default: 1
      },
      push: {
        type: [String, Number],
        default: 0
      },
      pull: {
        type: [String, Number],
        default: 0
      },
      offset: {
        type: [String, Number],
        default: 0
      }
    };
    const colPropKeys = keysOf(colProps);
    var NCol = vue.defineComponent({
      name: "Col",
      props: colProps,
      setup(props) {
        const NRow = vue.inject(rowInjectionKey, null);
        if (!NRow)
          throwError("col", "`n-col` must be placed inside `n-row`.");
        return {
          mergedClsPrefix: NRow.mergedClsPrefixRef,
          gutter: NRow.gutterRef,
          stylePadding: vue.computed(
            () => `${formatLength(NRow.verticalGutterRef.value, {
          c: 0.5
        })} ${formatLength(NRow.horizontalGutterRef.value, { c: 0.5 })}`
          ),
          mergedPush: vue.computed(() => Number(props.push) - Number(props.pull))
        };
      },
      render() {
        const {
          $slots,
          span,
          mergedPush,
          offset,
          stylePadding,
          gutter,
          mergedClsPrefix
        } = this;
        return /* @__PURE__ */ vue.h("div", {
          class: [
            `${mergedClsPrefix}-col`,
            {
              [`${mergedClsPrefix}-col--${span}-span`]: true,
              [`${mergedClsPrefix}-col--${mergedPush}-push`]: mergedPush > 0,
              [`${mergedClsPrefix}-col--${-mergedPush}-pull`]: mergedPush < 0,
              [`${mergedClsPrefix}-col--${offset}-offset`]: offset
            }
          ],
          style: {
            padding: stylePadding
          }
        }, gutter ? /* @__PURE__ */ vue.h("div", null, $slots) : $slots);
      }
    });

    const formItemColProps = { ...colProps,
      ...formItemProps
    };
    const formItemColPropKeys = keysOf(formItemColProps);
    var NFormItemCol = vue.defineComponent({
      name: "FormItemCol",
      props: formItemColProps,

      setup() {
        const formItemInstRef = vue.ref(null);

        const validate = function () {
          const {
            value
          } = formItemInstRef;

          if (value) {
            return value.validate(...arguments);
          }
        };

        const restoreValidation = () => {
          const {
            value
          } = formItemInstRef;

          if (value) {
            return value.restoreValidation();
          }
        };

        return {
          formItemInstRef,
          validate,
          restoreValidation
        };
      },

      render() {
        return vue.h(NCol, keep(this.$props, colPropKeys), {
          default: () => {
            const itemProps = keep(this.$props, formItemPropKeys);
            return vue.h(NFormItem, {
              ref: "formItemInstRef",
              ...itemProps
            }, this.$slots);
          }
        });
      }

    });

    const formItemRowProps = { ...rowProps,
      ...formItemColProps
    };
    var FormItemRow = vue.defineComponent({
      name: "FormItemRow",
      props: formItemRowProps,

      setup() {
        const formItemColInstRef = vue.ref(null);

        const validate = function () {
          const {
            value
          } = formItemColInstRef;

          if (value) {
            return value.validate(...arguments);
          }
        };

        const restoreValidation = () => {
          const {
            value
          } = formItemColInstRef;

          if (value) {
            return value.restoreValidation();
          }
        };

        return {
          formItemColInstRef,
          validate,
          restoreValidation
        };
      },

      render() {
        return vue.h(NRow, keep(this.$props, rowPropKeys), {
          default: () => {
            const colProps = keep(this.$props, formItemColPropKeys);
            return vue.h(NFormItemCol, {
              ref: "formItemColInstRef",
              ...colProps,
              span: 24
            }, this.$slots);
          }
        });
      }

    });

    var GlobalStyle = vue.defineComponent({
      name: "GlobalStyle",

      setup() {
        if (typeof document === "undefined") return;
        const NConfigProvider = vue.inject(configProviderInjectionKey, null);
        const {
          body
        } = document;
        const {
          style
        } = body;
        let styleApplied = false;
        let firstApply = true;
        vue.onBeforeMount(() => {
          vue.watchEffect(() => {
            var _NConfigProvider$merg, _NConfigProvider$merg2;

            const {
              textColor2,
              fontSize,
              fontFamily,
              bodyColor,
              cubicBezierEaseInOut,
              lineHeight
            } = NConfigProvider ? lodash.exports.merge({}, ((_NConfigProvider$merg = NConfigProvider.mergedThemeRef.value) === null || _NConfigProvider$merg === void 0 ? void 0 : _NConfigProvider$merg.common) || commonLight, (_NConfigProvider$merg2 = NConfigProvider.mergedThemeOverridesRef.value) === null || _NConfigProvider$merg2 === void 0 ? void 0 : _NConfigProvider$merg2.common) : commonLight;

            if (styleApplied || !body.hasAttribute("n-styled")) {
              style.setProperty("-webkit-text-size-adjust", "100%");
              style.setProperty("-webkit-tap-highlight-color", "transparent");
              style.padding = "0";
              style.margin = "0";
              style.backgroundColor = bodyColor;
              style.color = textColor2;
              style.fontSize = fontSize;
              style.fontFamily = fontFamily;
              style.lineHeight = lineHeight;
              const transition = `color .3s ${cubicBezierEaseInOut}, background-color .3s ${cubicBezierEaseInOut}`;

              if (firstApply) {
                setTimeout(() => {
                  style.transition = transition;
                }, 0);
              } else {
                style.transition = transition;
              }

              body.setAttribute("n-styled", "");
              styleApplied = true;
              firstApply = false;
            } else {
              warn$2("global-style", "More than one n-global-style exist in the document.body. Only the first mounted one will work.");
            }
          });
        });
        vue.onUnmounted(() => {
          if (styleApplied) {
            body.removeAttribute("n-styled");
          }
        });
      },

      render() {
        return null;
      }

    });

    const gradientTextDark = {
      name: "GradientText",
      common: commonDark,

      self(vars) {
        const {
          primaryColor,
          successColor,
          warningColor,
          errorColor,
          infoColor,
          primaryColorSuppl,
          successColorSuppl,
          warningColorSuppl,
          errorColorSuppl,
          infoColorSuppl,
          fontWeightStrong
        } = vars;
        return {
          fontWeight: fontWeightStrong,
          rotate: "252deg",
          colorStartPrimary: primaryColor,
          colorEndPrimary: primaryColorSuppl,
          colorStartInfo: infoColor,
          colorEndInfo: infoColorSuppl,
          colorStartWarning: warningColor,
          colorEndWarning: warningColorSuppl,
          colorStartError: errorColor,
          colorEndError: errorColorSuppl,
          colorStartSuccess: successColor,
          colorEndSuccess: successColorSuppl
        };
      }

    };
    var gradientTextDark$1 = gradientTextDark;

    const self$x = vars => {
      const {
        primaryColor,
        successColor,
        warningColor,
        errorColor,
        infoColor,
        fontWeightStrong
      } = vars;
      return {
        fontWeight: fontWeightStrong,
        rotate: "252deg",
        colorStartPrimary: changeColor(primaryColor, {
          alpha: 0.6
        }),
        colorEndPrimary: primaryColor,
        colorStartInfo: changeColor(infoColor, {
          alpha: 0.6
        }),
        colorEndInfo: infoColor,
        colorStartWarning: changeColor(warningColor, {
          alpha: 0.6
        }),
        colorEndWarning: warningColor,
        colorStartError: changeColor(errorColor, {
          alpha: 0.6
        }),
        colorEndError: errorColor,
        colorStartSuccess: changeColor(successColor, {
          alpha: 0.6
        }),
        colorEndSuccess: successColor
      };
    };

    const gradientTextLight = {
      name: "GradientText",
      common: commonLight,
      self: self$x
    };
    var gradientTextLight$1 = gradientTextLight;

    var style$G = cB("gradient-text", `
  display: inline-block;
  font-weight: var(--n-font-weight);
  -webkit-background-clip: text;
  background-clip: text;
  color: #0000;
  white-space: nowrap;
  background-image: linear-gradient(var(--n-rotate), var(--n-color-start) 0%, var(--n-color-end) 100%);
  transition:
    --n-color-start .3s var(--n-bezier),
    --n-color-end .3s var(--n-bezier);
`);

    const gradientTextProps = {
      ...useTheme.props,
      size: [String, Number],
      fontSize: [String, Number],
      type: {
        type: String,
        default: "primary"
      },
      color: [Object, String],
      gradient: [Object, String]
    };
    var GradientText = vue.defineComponent({
      name: "GradientText",
      props: gradientTextProps,
      setup(props) {
        useHoudini();
        const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
        const compatibleTypeRef = vue.computed(() => {
          const { type } = props;
          if (type === "danger")
            return "error";
          return type;
        });
        const styleFontSizeRef = vue.computed(() => {
          let fontSize = props.size || props.fontSize;
          if (fontSize)
            fontSize = formatLength(fontSize);
          return fontSize || void 0;
        });
        const styleBgImageRef = vue.computed(() => {
          const gradient = props.color || props.gradient;
          if (typeof gradient === "string") {
            return gradient;
          } else if (gradient) {
            const deg = gradient.deg || 0;
            const from = gradient.from;
            const to = gradient.to;
            return `linear-gradient(${deg}deg, ${from} 0%, ${to} 100%)`;
          }
          return void 0;
        });
        const themeRef = useTheme(
          "GradientText",
          "-gradient-text",
          style$G,
          gradientTextLight$1,
          props,
          mergedClsPrefixRef
        );
        const cssVarsRef = vue.computed(() => {
          const { value: type } = compatibleTypeRef;
          const {
            common: { cubicBezierEaseInOut },
            self: {
              rotate,
              [createKey("colorStart", type)]: colorStart,
              [createKey("colorEnd", type)]: colorEnd,
              fontWeight
            }
          } = themeRef.value;
          return {
            "--n-bezier": cubicBezierEaseInOut,
            "--n-rotate": rotate,
            "--n-color-start": colorStart,
            "--n-color-end": colorEnd,
            "--n-font-weight": fontWeight
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass(
          "gradient-text",
          vue.computed(() => compatibleTypeRef.value[0]),
          cssVarsRef,
          props
        ) : void 0;
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          compatibleType: compatibleTypeRef,
          styleFontSize: styleFontSizeRef,
          styleBgImage: styleBgImageRef,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender
        };
      },
      render() {
        const { mergedClsPrefix, onRender } = this;
        onRender?.();
        return /* @__PURE__ */ vue.h("span", {
          class: [
            `${mergedClsPrefix}-gradient-text`,
            `${mergedClsPrefix}-gradient-text--${this.compatibleType}-type`,
            this.themeClass
          ],
          style: [
            {
              fontSize: this.styleFontSize,
              backgroundImage: this.styleBgImage
            },
            this.cssVars
          ]
        }, this.$slots);
      }
    });

    const defaultBreakpoints = {
      xs: 0,
      s: 640,
      m: 1024,
      l: 1280,
      xl: 1536,
      xxl: 1920
    };

    const defaultCols = 24;
    const SSR_ATTR_NAME = "__ssr__";
    const gridProps = {
      layoutShiftDisabled: Boolean,
      responsive: {
        type: [String, Boolean],
        default: "self"
      },
      cols: {
        type: [Number, String],
        default: defaultCols
      },
      itemResponsive: Boolean,
      collapsed: Boolean,
      collapsedRows: {
        type: Number,
        default: 1
      },
      itemStyle: [Object, String],
      xGap: {
        type: [Number, String],
        default: 0
      },
      yGap: {
        type: [Number, String],
        default: 0
      }
    };
    var Grid = vue.defineComponent({
      name: "Grid",
      inheritAttrs: false,
      props: gridProps,
      setup(props) {
        const { mergedClsPrefixRef, mergedBreakpointsRef } = useConfig(props);
        const numRegex = /^\d+$/;
        const widthRef = vue.ref(void 0);
        const breakpointsRef = useBreakpoints(
          mergedBreakpointsRef?.value || defaultBreakpoints
        );
        const isResponsiveRef = useMemo(() => {
          if (props.itemResponsive)
            return true;
          if (!numRegex.test(props.cols.toString()))
            return true;
          if (!numRegex.test(props.xGap.toString()))
            return true;
          if (!numRegex.test(props.yGap.toString()))
            return true;
          return false;
        });
        const responsiveQueryRef = vue.computed(() => {
          if (!isResponsiveRef.value)
            return void 0;
          return props.responsive === "self" ? widthRef.value : breakpointsRef.value;
        });
        const responsiveColsRef = useMemo(() => {
          return Number(
            parseResponsivePropValue(
              props.cols.toString(),
              responsiveQueryRef.value
            )
          ) ?? defaultCols;
        });
        const responsiveXGapRef = useMemo(
          () => parseResponsivePropValue(props.xGap.toString(), responsiveQueryRef.value)
        );
        const responsiveYGapRef = useMemo(
          () => parseResponsivePropValue(props.yGap.toString(), responsiveQueryRef.value)
        );
        const handleResize = (entry) => {
          widthRef.value = entry.contentRect.width;
        };
        const handleResizeRaf = (entry) => {
          beforeNextFrameOnce(handleResize, entry);
        };
        const overflowRef = vue.ref(false);
        const handleResizeRef = vue.computed(
          () => {
            if (props.responsive === "self") {
              return handleResizeRaf;
            }
            return void 0;
          }
        );
        const isSsrRef = vue.ref(false);
        const contentElRef = vue.ref();
        vue.onMounted(() => {
          const { value: contentEl } = contentElRef;
          if (contentEl) {
            if (contentEl.hasAttribute(SSR_ATTR_NAME)) {
              contentEl.removeAttribute(SSR_ATTR_NAME);
              isSsrRef.value = true;
            }
          }
        });
        vue.provide(gridInjectionKey, {
          layoutShiftDisabledRef: vue.toRef(props, "layoutShiftDisabled"),
          isSsrRef,
          itemStyleRef: vue.toRef(props, "itemStyle"),
          xGapRef: responsiveXGapRef,
          overflowRef
        });
        return {
          isSsr: !isBrowser$2,
          contentEl: contentElRef,
          mergedClsPrefix: mergedClsPrefixRef,
          style: vue.computed(() => {
            if (props.layoutShiftDisabled) {
              return {
                width: "100%",
                display: "grid",
                gridTemplateColumns: `repeat(${props.cols}, minmax(0, 1fr))`,
                columnGap: pxfy(props.xGap),
                rowGap: pxfy(props.yGap)
              };
            }
            return {
              width: "100%",
              display: "grid",
              gridTemplateColumns: `repeat(${responsiveColsRef.value}, minmax(0, 1fr))`,
              columnGap: pxfy(responsiveXGapRef.value),
              rowGap: pxfy(responsiveYGapRef.value)
            };
          }),
          isResponsive: isResponsiveRef,
          responsiveQuery: responsiveQueryRef,
          responsiveCols: responsiveColsRef,
          handleResize: handleResizeRef,
          overflow: overflowRef
        };
      },
      render() {
        if (this.layoutShiftDisabled) {
          return vue.h(
            "div",
            vue.mergeProps(
              {
                ref: "contentEl",
                class: `${this.mergedClsPrefix}-grid`,
                style: this.style
              },
              this.$attrs
            ),
            this.$slots
          );
        }
        const renderContent = () => {
          this.overflow = false;
          const rawChildren = flatten$3(getSlot$1(this));
          const childrenAndRawSpan = [];
          const { collapsed, collapsedRows, responsiveCols, responsiveQuery } = this;
          rawChildren.forEach((child) => {
            if (child?.type?.__GRID_ITEM__ !== true)
              return;
            if (isNodeVShowFalse(child)) {
              const clonedNode = vue.cloneVNode(child);
              if (clonedNode.props) {
                clonedNode.props.privateShow = false;
              } else {
                clonedNode.props = { privateShow: false };
              }
              childrenAndRawSpan.push({
                child: clonedNode,
                rawChildSpan: 0
              });
              return;
            }
            child.dirs = child.dirs?.filter(({ dir }) => dir !== vue.vShow) || null;
            const clonedChild = vue.cloneVNode(child);
            const rawChildSpan = Number(
              parseResponsivePropValue(
                clonedChild.props?.span,
                responsiveQuery
              ) ?? defaultSpan$1
            );
            if (rawChildSpan === 0)
              return;
            childrenAndRawSpan.push({
              child: clonedChild,
              rawChildSpan
            });
          });
          let suffixSpan = 0;
          const maybeSuffixNode = childrenAndRawSpan[childrenAndRawSpan.length - 1]?.child;
          if (maybeSuffixNode?.props) {
            const suffixPropValue = maybeSuffixNode.props?.suffix;
            if (suffixPropValue !== void 0 && suffixPropValue !== false) {
              suffixSpan = maybeSuffixNode.props?.span ?? defaultSpan$1;
              maybeSuffixNode.props.privateSpan = suffixSpan;
              maybeSuffixNode.props.privateColStart = responsiveCols + 1 - suffixSpan;
              maybeSuffixNode.props.privateShow = maybeSuffixNode.props.privateShow ?? true;
            }
          }
          let spanCounter = 0;
          let done = false;
          for (const { child, rawChildSpan } of childrenAndRawSpan) {
            if (done) {
              this.overflow = true;
            }
            if (!done) {
              const childOffset = Number(
                parseResponsivePropValue(
                  child.props?.offset,
                  responsiveQuery
                ) ?? 0
              );
              const childSpan = Math.min(rawChildSpan + childOffset, responsiveCols);
              if (!child.props) {
                child.props = {
                  privateSpan: childSpan,
                  privateOffset: childOffset
                };
              } else {
                child.props.privateSpan = childSpan;
                child.props.privateOffset = childOffset;
              }
              if (collapsed) {
                const remainder = spanCounter % responsiveCols;
                if (childSpan + remainder > responsiveCols) {
                  spanCounter += responsiveCols - remainder;
                }
                if (childSpan + spanCounter + suffixSpan > collapsedRows * responsiveCols) {
                  done = true;
                } else {
                  spanCounter += childSpan;
                }
              }
            }
            if (done) {
              if (child.props) {
                if (child.props.privateShow !== true) {
                  child.props.privateShow = false;
                }
              } else {
                child.props = {
                  privateShow: false
                };
              }
            }
          }
          return vue.h(
            "div",
            vue.mergeProps(
              {
                ref: "contentEl",
                class: `${this.mergedClsPrefix}-grid`,
                style: this.style,
                [SSR_ATTR_NAME]: this.isSsr || void 0
              },
              this.$attrs
            ),
            childrenAndRawSpan.map(({ child }) => child)
          );
        };
        return this.isResponsive && this.responsive === "self" ? /* @__PURE__ */ vue.h(VResizeObserver, {
          onResize: this.handleResize
        }, {
          default: renderContent
        }) : renderContent();
      }
    });

    const self$w = vars => {
      const {
        primaryColor,
        baseColor
      } = vars;
      return {
        color: primaryColor,
        iconColor: baseColor
      };
    };
    const iconWrapperLight = {
      name: "IconWrapper",
      common: commonLight,
      self: self$w
    };
    var iconWrapperLight$1 = iconWrapperLight;

    const iconDark = {
      name: "IconWrapper",
      common: commonDark,
      self: self$w
    };
    var iconWrapperDark = iconDark;

    var style$F = cB("icon-wrapper", `
  transition:
    color .3s var(--n-bezier),
    background-color .3s var(--n-bezier);
  background-color: var(--n-color);
  display: inline-flex;
  align-items: center;
  justify-content: center;
  color: var(--n-icon-color);
`);

    const iconWrapperProps = {
      ...useTheme.props,
      size: {
        type: Number,
        default: 24
      },
      borderRadius: {
        type: Number,
        default: 6
      },
      color: String,
      iconColor: String
    };
    const NIconWrapper = vue.defineComponent({
      name: "IconWrapper",
      props: iconWrapperProps,
      setup(props, { slots }) {
        const themeRef = useTheme(
          "IconWrapper",
          "-icon-wrapper",
          style$F,
          iconWrapperLight$1,
          props
        );
        const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
        const cssVarsRef = vue.computed(() => {
          const {
            common: { cubicBezierEaseInOut },
            self: { color, iconColor }
          } = themeRef.value;
          return {
            "--n-bezier": cubicBezierEaseInOut,
            "--n-color": color,
            "--n-icon-color": iconColor
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("icon-wrapper", void 0, cssVarsRef, props) : void 0;
        return () => {
          const size = formatLength(props.size);
          themeClassHandle?.onRender();
          return /* @__PURE__ */ vue.h("div", {
            class: [
              `${mergedClsPrefixRef.value}-icon-wrapper`,
              themeClassHandle?.themeClass.value
            ],
            style: [
              cssVarsRef?.value,
              {
                height: size,
                width: size,
                borderRadius: formatLength(props.borderRadius),
                backgroundColor: props.color,
                color: props.iconColor
              }
            ]
          }, slots);
        };
      }
    });

    const imagePreviewSharedProps = { ...useTheme.props,
      showToolbar: {
        type: Boolean,
        default: true
      },
      showToolbarTooltip: Boolean
    };

    function self$v() {
      return {
        toolbarIconColor: "rgba(255, 255, 255, .9)",
        toolbarColor: "rgba(0, 0, 0, .35)",
        toolbarBoxShadow: "none",
        toolbarBorderRadius: "24px"
      };
    }

    const imageLight = createTheme$1({
      name: "Image",
      common: commonLight,
      peers: {
        Tooltip: tooltipLight$1
      },
      self: self$v
    });

    var commonVars$3 = {
      closeMargin: "16px 12px",
      closeSize: "20px",
      closeIconSize: "16px",
      width: "365px",
      padding: "16px",
      titleFontSize: "16px",
      metaFontSize: "12px",
      descriptionFontSize: "12px"
    };

    const self$u = vars => {
      const {
        textColor2,
        successColor,
        infoColor,
        warningColor,
        errorColor,
        popoverColor,
        closeIconColor,
        closeIconColorHover,
        closeIconColorPressed,
        closeColorHover,
        closeColorPressed,
        textColor1,
        textColor3,
        borderRadius,
        fontWeightStrong,
        boxShadow2,
        lineHeight,
        fontSize
      } = vars;
      return { ...commonVars$3,
        borderRadius,
        lineHeight,
        fontSize,
        headerFontWeight: fontWeightStrong,
        iconColor: textColor2,
        iconColorSuccess: successColor,
        iconColorInfo: infoColor,
        iconColorWarning: warningColor,
        iconColorError: errorColor,
        color: popoverColor,
        textColor: textColor2,
        closeIconColor,
        closeIconColorHover,
        closeIconColorPressed,
        closeBorderRadius: borderRadius,
        closeColorHover,
        closeColorPressed,
        headerTextColor: textColor1,
        descriptionTextColor: textColor3,
        actionTextColor: textColor2,
        boxShadow: boxShadow2
      };
    };
    const notificationLight = createTheme$1({
      name: "Notification",
      common: commonLight,
      peers: {
        Scrollbar: scrollbarLight$1
      },
      self: self$u
    });
    var notificationLight$1 = notificationLight;

    const notificationDark = {
      name: "Notification",
      common: commonDark,
      peers: {
        Scrollbar: scrollbarDark$1
      },
      self: self$u
    };
    var notificationDark$1 = notificationDark;

    var rtlStyle$9 = cB("notification", [cM("rtl", `
    direction: rtl;
  `, [cB("notification-main", `
      margin-left: unset;
      margin-right: 8px;
    `, [cE("header", `
        margin: var(--n-icon-margin);
        margin-right: 0;
      `)]), cE("avatar", `
      left: unset;
      right: var(--n-padding-left);
    `), cM("show-avatar", [cB("notification-main", `
        margin-right: 40px;
        margin-reft: unset;
      `)]), cM("closable", [cB("notification-main", [c$1("> *:first-child", `
          padding-left: 20px;
          padding-right: unset;
        `)]), cE("close", `
        right: unset;
        left: 0;
      `)])])]);

    const notificationRtl = {
      name: "Notification",
      style: rtlStyle$9
    };

    var commonVariables$4 = {
      margin: "0 0 8px 0",
      padding: "10px 20px",
      maxWidth: "720px",
      minWidth: "420px",
      iconMargin: "0 10px 0 0",
      closeMargin: "0 0 0 10px",
      closeSize: "20px",
      closeIconSize: "16px",
      iconSize: "20px",
      fontSize: "14px"
    };

    const self$t = vars => {
      const {
        textColor2,
        closeIconColor,
        closeIconColorHover,
        closeIconColorPressed,
        infoColor,
        successColor,
        errorColor,
        warningColor,
        popoverColor,
        boxShadow2,
        primaryColor,
        lineHeight,
        borderRadius,
        closeColorHover,
        closeColorPressed
      } = vars;
      return { ...commonVariables$4,
        closeBorderRadius: borderRadius,
        textColor: textColor2,
        textColorInfo: textColor2,
        textColorSuccess: textColor2,
        textColorError: textColor2,
        textColorWarning: textColor2,
        textColorLoading: textColor2,
        color: popoverColor,
        colorInfo: popoverColor,
        colorSuccess: popoverColor,
        colorError: popoverColor,
        colorWarning: popoverColor,
        colorLoading: popoverColor,
        boxShadow: boxShadow2,
        boxShadowInfo: boxShadow2,
        boxShadowSuccess: boxShadow2,
        boxShadowError: boxShadow2,
        boxShadowWarning: boxShadow2,
        boxShadowLoading: boxShadow2,
        iconColor: textColor2,
        iconColorInfo: infoColor,
        iconColorSuccess: successColor,
        iconColorWarning: warningColor,
        iconColorError: errorColor,
        iconColorLoading: primaryColor,
        closeColorHover,
        closeColorPressed,
        closeIconColor,
        closeIconColorHover,
        closeIconColorPressed,
        closeColorHoverInfo: closeColorHover,
        closeColorPressedInfo: closeColorPressed,
        closeIconColorInfo: closeIconColor,
        closeIconColorHoverInfo: closeIconColorHover,
        closeIconColorPressedInfo: closeIconColorPressed,
        closeColorHoverSuccess: closeColorHover,
        closeColorPressedSuccess: closeColorPressed,
        closeIconColorSuccess: closeIconColor,
        closeIconColorHoverSuccess: closeIconColorHover,
        closeIconColorPressedSuccess: closeIconColorPressed,
        closeColorHoverError: closeColorHover,
        closeColorPressedError: closeColorPressed,
        closeIconColorError: closeIconColor,
        closeIconColorHoverError: closeIconColorHover,
        closeIconColorPressedError: closeIconColorPressed,
        closeColorHoverWarning: closeColorHover,
        closeColorPressedWarning: closeColorPressed,
        closeIconColorWarning: closeIconColor,
        closeIconColorHoverWarning: closeIconColorHover,
        closeIconColorPressedWarning: closeIconColorPressed,
        closeColorHoverLoading: closeColorHover,
        closeColorPressedLoading: closeColorPressed,
        closeIconColorLoading: closeIconColor,
        closeIconColorHoverLoading: closeIconColorHover,
        closeIconColorPressedLoading: closeIconColorPressed,
        loadingColor: primaryColor,
        lineHeight,
        borderRadius
      };
    };
    const messageLight = {
      name: "Message",
      common: commonLight,
      self: self$t
    };
    var messageLight$1 = messageLight;

    const messageDark = {
      name: "Message",
      common: commonDark,
      self: self$t
    };
    var messageDark$1 = messageDark;

    var rtlStyle$8 = cB("message", [cM("rtl", `
    direction: rtl;
  `, [cE("close", `
      margin: 0 10px 0 0;
    `), cE("icon", `
      margin: 0 0 0 10px;
    `)])]);

    const messageRtl = {
      name: "Message",
      style: rtlStyle$8
    };

    const buttonGroupDark = {
      name: "ButtonGroup",
      common: commonDark
    };
    var buttonGroupDark$1 = buttonGroupDark;

    const buttonGroupLight = {
      name: "ButtonGroup",
      common: commonLight
    };
    var buttonGroupLight$1 = buttonGroupLight;

    const inputNumberDark = {
      name: "InputNumber",
      common: commonDark,
      peers: {
        Button: buttonDark$1,
        Input: inputDark$1
      },

      self(vars) {
        const {
          textColorDisabled
        } = vars;
        return {
          iconColorDisabled: textColorDisabled
        };
      }

    };
    var inputNumberDark$1 = inputNumberDark;

    const self$s = vars => {
      const {
        textColorDisabled
      } = vars;
      return {
        iconColorDisabled: textColorDisabled
      };
    };

    const inputNumberLight = createTheme$1({
      name: "InputNumber",
      common: commonLight,
      peers: {
        Button: buttonLight$1,
        Input: inputLight$1
      },
      self: self$s
    });
    var inputNumberLight$1 = inputNumberLight;

    const layoutDark = {
      name: "Layout",
      common: commonDark,
      peers: {
        Scrollbar: scrollbarDark$1
      },

      self(vars) {
        const {
          textColor2,
          bodyColor,
          popoverColor,
          cardColor,
          dividerColor,
          scrollbarColor,
          scrollbarColorHover
        } = vars;
        return {
          textColor: textColor2,
          textColorInverted: textColor2,
          color: bodyColor,
          colorEmbedded: bodyColor,
          headerColor: cardColor,
          headerColorInverted: cardColor,
          footerColor: cardColor,
          footerColorInverted: cardColor,
          headerBorderColor: dividerColor,
          headerBorderColorInverted: dividerColor,
          footerBorderColor: dividerColor,
          footerBorderColorInverted: dividerColor,
          siderBorderColor: dividerColor,
          siderBorderColorInverted: dividerColor,
          siderColor: cardColor,
          siderColorInverted: cardColor,
          siderToggleButtonBorder: "1px solid transparent",
          siderToggleButtonColor: popoverColor,
          siderToggleButtonIconColor: textColor2,
          siderToggleButtonIconColorInverted: textColor2,
          siderToggleBarColor: composite(bodyColor, scrollbarColor),
          siderToggleBarColorHover: composite(bodyColor, scrollbarColorHover),
          __invertScrollbar: "false"
        };
      }

    };
    var layoutDark$1 = layoutDark;

    const self$r = vars => {
      const {
        baseColor,
        textColor2,
        bodyColor,
        cardColor,
        dividerColor,
        actionColor,
        scrollbarColor,
        scrollbarColorHover,
        invertedColor
      } = vars;
      return {
        textColor: textColor2,
        textColorInverted: "#FFF",
        color: bodyColor,
        colorEmbedded: actionColor,
        headerColor: cardColor,
        headerColorInverted: invertedColor,
        footerColor: actionColor,
        footerColorInverted: invertedColor,
        headerBorderColor: dividerColor,
        headerBorderColorInverted: invertedColor,
        footerBorderColor: dividerColor,
        footerBorderColorInverted: invertedColor,
        siderBorderColor: dividerColor,
        siderBorderColorInverted: invertedColor,
        siderColor: cardColor,
        siderColorInverted: invertedColor,
        siderToggleButtonBorder: `1px solid ${dividerColor}`,
        siderToggleButtonColor: baseColor,
        siderToggleButtonIconColor: textColor2,
        siderToggleButtonIconColorInverted: textColor2,
        siderToggleBarColor: composite(bodyColor, scrollbarColor),
        siderToggleBarColorHover: composite(bodyColor, scrollbarColorHover),
        __invertScrollbar: "true"
      };
    };
    const layoutLight = createTheme$1({
      name: "Layout",
      common: commonLight,
      peers: {
        Scrollbar: scrollbarLight$1
      },
      self: self$r
    });
    var layoutLight$1 = layoutLight;

    const self$q = vars => {
      const {
        textColor2,
        cardColor,
        modalColor,
        popoverColor,
        dividerColor,
        borderRadius,
        fontSize,
        hoverColor
      } = vars;
      return {
        textColor: textColor2,
        color: cardColor,
        colorHover: hoverColor,
        colorModal: modalColor,
        colorHoverModal: composite(modalColor, hoverColor),
        colorPopover: popoverColor,
        colorHoverPopover: composite(popoverColor, hoverColor),
        borderColor: dividerColor,
        borderColorModal: composite(modalColor, dividerColor),
        borderColorPopover: composite(popoverColor, dividerColor),
        borderRadius,
        fontSize
      };
    };
    const listLight = {
      name: "List",
      common: commonLight,
      self: self$q
    };
    var listLight$1 = listLight;

    const listDark$1 = {
      name: "List",
      common: commonDark,
      self: self$q
    };
    var listDark$2 = listDark$1;

    var rtlStyle$7 = cB("list", [cM("rtl", `
    direction: rtl;
    text-align: right;
  `, [cB("list-item", [cE("prefix", `
        margin-right: 0;
        margin-left: 20px;
      `), cE("suffix", `
        margin-right: 20px;
        margin-left: 0;
      `)])])]);

    const listRtl = {
      name: "List",
      style: rtlStyle$7
    };

    const loadingBarDark = {
      name: "LoadingBar",
      common: commonDark,

      self(vars) {
        const {
          primaryColor
        } = vars;
        return {
          colorError: "red",
          colorLoading: primaryColor,
          height: "2px"
        };
      }

    };
    var loadingBarDark$1 = loadingBarDark;

    const self$p = vars => {
      const {
        primaryColor,
        errorColor
      } = vars;
      return {
        colorError: errorColor,
        colorLoading: primaryColor,
        height: "2px"
      };
    };

    const loadingBarLight = {
      name: "LoadingBar",
      common: commonLight,
      self: self$p
    };
    var loadingBarLight$1 = loadingBarLight;

    const logDark = {
      name: "Log",
      common: commonDark,
      peers: {
        Scrollbar: scrollbarDark$1,
        Code: codeDark$1
      },

      self(vars) {
        const {
          textColor2,
          inputColor,
          fontSize,
          primaryColor
        } = vars;
        return {
          loaderFontSize: fontSize,
          loaderTextColor: textColor2,
          loaderColor: inputColor,
          loaderBorder: "1px solid #0000",
          loadingColor: primaryColor
        };
      }

    };
    var logDark$1 = logDark;

    const self$o = vars => {
      const {
        textColor2,
        modalColor,
        borderColor,
        fontSize,
        primaryColor
      } = vars;
      return {
        loaderFontSize: fontSize,
        loaderTextColor: textColor2,
        loaderColor: modalColor,
        loaderBorder: `1px solid ${borderColor}`,
        loadingColor: primaryColor
      };
    };

    const logLight = createTheme$1({
      name: "Log",
      common: commonLight,
      peers: {
        Scrollbar: scrollbarLight$1,
        Code: codeLight$1
      },
      self: self$o
    });
    var logLight$1 = logLight;

    const listDark = {
      name: "Mention",
      common: commonDark,
      peers: {
        InternalSelectMenu: internalSelectMenuDark$1,
        Input: inputDark$1
      },

      self(vars) {
        const {
          boxShadow2
        } = vars;
        return {
          menuBoxShadow: boxShadow2
        };
      }

    };
    var mentionDark = listDark;

    const self$n = vars => {
      const {
        boxShadow2
      } = vars;
      return {
        menuBoxShadow: boxShadow2
      };
    };

    const mentionLight = createTheme$1({
      name: "Mention",
      common: commonLight,
      peers: {
        InternalSelectMenu: internalSelectMenuLight$1,
        Input: inputLight$1
      },
      self: self$n
    });
    var mentionLight$1 = mentionLight;

    function createPartialInvertedVars(color, activeItemColor, activeTextColor, groupTextColor) {
      return {
        itemColorHoverInverted: "#0000",
        itemColorActiveInverted: activeItemColor,
        itemColorActiveHoverInverted: activeItemColor,
        itemColorActiveCollapsedInverted: activeItemColor,
        itemTextColorInverted: color,
        itemTextColorHoverInverted: activeTextColor,
        itemTextColorChildActiveInverted: activeTextColor,
        itemTextColorChildActiveHoverInverted: activeTextColor,
        itemTextColorActiveInverted: activeTextColor,
        itemTextColorActiveHoverInverted: activeTextColor,
        itemTextColorHorizontalInverted: color,
        itemTextColorHoverHorizontalInverted: activeTextColor,
        itemTextColorChildActiveHorizontalInverted: activeTextColor,
        itemTextColorChildActiveHoverHorizontalInverted: activeTextColor,
        itemTextColorActiveHorizontalInverted: activeTextColor,
        itemTextColorActiveHoverHorizontalInverted: activeTextColor,
        itemIconColorInverted: color,
        itemIconColorHoverInverted: activeTextColor,
        itemIconColorActiveInverted: activeTextColor,
        itemIconColorActiveHoverInverted: activeTextColor,
        itemIconColorChildActiveInverted: activeTextColor,
        itemIconColorChildActiveHoverInverted: activeTextColor,
        itemIconColorCollapsedInverted: color,
        itemIconColorHorizontalInverted: color,
        itemIconColorHoverHorizontalInverted: activeTextColor,
        itemIconColorActiveHorizontalInverted: activeTextColor,
        itemIconColorActiveHoverHorizontalInverted: activeTextColor,
        itemIconColorChildActiveHorizontalInverted: activeTextColor,
        itemIconColorChildActiveHoverHorizontalInverted: activeTextColor,
        arrowColorInverted: color,
        arrowColorHoverInverted: activeTextColor,
        arrowColorActiveInverted: activeTextColor,
        arrowColorActiveHoverInverted: activeTextColor,
        arrowColorChildActiveInverted: activeTextColor,
        arrowColorChildActiveHoverInverted: activeTextColor,
        groupTextColorInverted: groupTextColor
      };
    }
    const self$m = vars => {
      const {
        borderRadius,
        textColor3,
        primaryColor,
        textColor2,
        textColor1,
        fontSize,
        dividerColor,
        hoverColor,
        primaryColorHover
      } = vars;
      return {
        borderRadius,
        color: "#0000",
        groupTextColor: textColor3,
        itemColorHover: hoverColor,
        itemColorActive: changeColor(primaryColor, {
          alpha: 0.1
        }),
        itemColorActiveHover: changeColor(primaryColor, {
          alpha: 0.1
        }),
        itemColorActiveCollapsed: changeColor(primaryColor, {
          alpha: 0.1
        }),
        itemTextColor: textColor2,
        itemTextColorHover: textColor2,
        itemTextColorActive: primaryColor,
        itemTextColorActiveHover: primaryColor,
        itemTextColorChildActive: primaryColor,
        itemTextColorChildActiveHover: primaryColor,
        itemTextColorHorizontal: textColor2,
        itemTextColorHoverHorizontal: primaryColorHover,
        itemTextColorActiveHorizontal: primaryColor,
        itemTextColorActiveHoverHorizontal: primaryColor,
        itemTextColorChildActiveHorizontal: primaryColor,
        itemTextColorChildActiveHoverHorizontal: primaryColor,
        itemIconColor: textColor1,
        itemIconColorHover: textColor1,
        itemIconColorActive: primaryColor,
        itemIconColorActiveHover: primaryColor,
        itemIconColorChildActive: primaryColor,
        itemIconColorChildActiveHover: primaryColor,
        itemIconColorCollapsed: textColor1,
        itemIconColorHorizontal: textColor1,
        itemIconColorHoverHorizontal: primaryColorHover,
        itemIconColorActiveHorizontal: primaryColor,
        itemIconColorActiveHoverHorizontal: primaryColor,
        itemIconColorChildActiveHorizontal: primaryColor,
        itemIconColorChildActiveHoverHorizontal: primaryColor,
        itemHeight: "42px",
        arrowColor: textColor2,
        arrowColorHover: textColor2,
        arrowColorActive: primaryColor,
        arrowColorActiveHover: primaryColor,
        arrowColorChildActive: primaryColor,
        arrowColorChildActiveHover: primaryColor,
        colorInverted: "#0000",
        borderColorHorizontal: "#0000",
        fontSize,
        dividerColor,
        ...createPartialInvertedVars("#BBB", primaryColor, "#FFF", "#AAA")
      };
    };
    const menuLight = createTheme$1({
      name: "Menu",
      common: commonLight,
      peers: {
        Tooltip: tooltipLight$1,
        Dropdown: dropdownLight$1
      },
      self: self$m
    });
    var menuLight$1 = menuLight;

    const menuDark = {
      name: "Menu",
      common: commonDark,
      peers: {
        Tooltip: tooltipDark$1,
        Dropdown: dropdownDark$1
      },

      self(vars) {
        const {
          primaryColor,
          primaryColorSuppl
        } = vars;
        const commonSelf = self$m(vars);
        commonSelf.itemColorActive = changeColor(primaryColor, {
          alpha: 0.15
        });
        commonSelf.itemColorActiveHover = changeColor(primaryColor, {
          alpha: 0.15
        });
        commonSelf.itemColorActiveCollapsed = changeColor(primaryColor, {
          alpha: 0.15
        });
        commonSelf.itemColorActiveInverted = primaryColorSuppl;
        commonSelf.itemColorActiveHoverInverted = primaryColorSuppl;
        commonSelf.itemColorActiveCollapsedInverted = primaryColorSuppl;
        return commonSelf;
      }

    };
    var menuDark$1 = menuDark;

    var common = {
      titleFontSize: "18px",
      backSize: "22px"
    };

    function self$l(vars) {
      const {
        textColor1,
        textColor2,
        textColor3,
        fontSize,
        fontWeightStrong,
        primaryColorHover,
        primaryColorPressed
      } = vars;
      return { ...common,
        titleFontWeight: fontWeightStrong,
        fontSize,
        titleTextColor: textColor1,
        backColor: textColor2,
        backColorHover: primaryColorHover,
        backColorPressed: primaryColorPressed,
        subtitleTextColor: textColor3
      };
    }
    const pageHeaderLight = createTheme$1({
      name: "PageHeader",
      common: commonLight,
      self: self$l
    });

    const pageHeaderDark = {
      name: "PageHeader",
      common: commonDark,
      self: self$l
    };

    var rtlStyle$6 = cB("page-header-wrapper", [cM("rtl", [cB("page-header-header", `
      direction: rtl;
    `), cB("page-header", `
      direction: rtl;
    `, [cE("back", `
        margin-right: 0;
        margin-left: 16px;
      `), cE("avatar", `
        margin-right: 0;
        margin-left: 12px;
      `), cE("title", `
        margin-right: 0;
        margin-left: 16px;
      `)]), cB("page-header-content", `
      direction: rtl;
    `), cB("page-header-footer", `
      direction: rtl;
    `)])]);

    var rtl = {
      name: "PageHeader",
      style: rtlStyle$6
    };

    var commonVars$2 = {
      iconSize: "22px"
    };

    const self$k = vars => {
      const {
        fontSize,
        warningColor
      } = vars;
      return { ...commonVars$2,
        fontSize,
        iconColor: warningColor
      };
    };
    const popconfirmLight = createTheme$1({
      name: "Popconfirm",
      common: commonLight,
      peers: {
        Button: buttonLight$1,
        Popover: popoverLight$1
      },
      self: self$k
    });
    var popconfirmLight$1 = popconfirmLight;

    const popconfirmDark = {
      name: "Popconfirm",
      common: commonDark,
      peers: {
        Button: buttonDark$1,
        Popover: popoverDark$1
      },
      self: self$k
    };
    var popconfirmDark$1 = popconfirmDark;

    const self$j = vars => {
      const {
        infoColor,
        successColor,
        warningColor,
        errorColor,
        textColor2,
        progressRailColor,
        fontSize,
        fontWeight
      } = vars;
      return {
        fontSize,
        fontSizeCircle: "28px",
        fontWeightCircle: fontWeight,
        railColor: progressRailColor,
        railHeight: "8px",
        iconSizeCircle: "36px",
        iconSizeLine: "18px",
        iconColor: infoColor,
        iconColorInfo: infoColor,
        iconColorSuccess: successColor,
        iconColorWarning: warningColor,
        iconColorError: errorColor,
        textColorCircle: textColor2,
        textColorLineInner: "rgb(255, 255, 255)",
        textColorLineOuter: textColor2,
        fillColor: infoColor,
        fillColorInfo: infoColor,
        fillColorSuccess: successColor,
        fillColorWarning: warningColor,
        fillColorError: errorColor,
        lineBgProcessing: "linear-gradient(90deg, rgba(255, 255, 255, .3) 0%, rgba(255, 255, 255, .5) 100%)"
      };
    };
    const progressLight = {
      name: "Progress",
      common: commonLight,
      self: self$j
    };
    var progressLight$1 = progressLight;

    const progressDark = {
      name: "Progress",
      common: commonDark,

      self(vars) {
        const commonSelf = self$j(vars);
        commonSelf.textColorLineInner = "rgb(0, 0, 0)";
        commonSelf.lineBgProcessing = "linear-gradient(90deg, rgba(255, 255, 255, .3) 0%, rgba(255, 255, 255, .5) 100%)";
        return commonSelf;
      }

    };
    var progressDark$1 = progressDark;

    const rateDark = {
      name: "Rate",
      common: commonDark,

      self(vars) {
        const {
          railColor
        } = vars;
        return {
          itemColor: railColor,
          itemColorActive: "#CCAA33",
          itemSize: "20px",
          sizeSmall: "16px",
          sizeMedium: "20px",
          sizeLarge: "24px"
        };
      }

    };
    var rateDark$1 = rateDark;

    const self$i = vars => {
      const {
        railColor
      } = vars;
      return {
        itemColor: railColor,
        itemColorActive: "#FFCC33",
        sizeSmall: "16px",
        sizeMedium: "20px",
        sizeLarge: "24px"
      };
    };

    const themeLight = {
      name: "Rate",
      common: commonLight,
      self: self$i
    };
    var rateLight = themeLight;

    var commonVariables$3 = {
      titleFontSizeSmall: "26px",
      titleFontSizeMedium: "32px",
      titleFontSizeLarge: "40px",
      titleFontSizeHuge: "48px",
      fontSizeSmall: "14px",
      fontSizeMedium: "14px",
      fontSizeLarge: "15px",
      fontSizeHuge: "16px",
      iconSizeSmall: "64px",
      iconSizeMedium: "80px",
      iconSizeLarge: "100px",
      iconSizeHuge: "125px",
      iconColor418: void 0,
      iconColor404: void 0,
      iconColor403: void 0,
      iconColor500: void 0
    };

    const self$h = vars => {
      const {
        textColor2,
        textColor1,
        errorColor,
        successColor,
        infoColor,
        warningColor,
        lineHeight,
        fontWeightStrong
      } = vars;
      return { ...commonVariables$3,
        lineHeight,
        titleFontWeight: fontWeightStrong,
        titleTextColor: textColor1,
        textColor: textColor2,
        iconColorError: errorColor,
        iconColorSuccess: successColor,
        iconColorInfo: infoColor,
        iconColorWarning: warningColor
      };
    };
    const resultLight = {
      name: "Result",
      common: commonLight,
      self: self$h
    };
    var resultLight$1 = resultLight;

    const resultDark = {
      name: "Result",
      common: commonDark,
      self: self$h
    };
    var resultDark$1 = resultDark;

    var sizeVariables$3 = {
      railHeight: "4px",
      railWidthVertical: "4px",
      handleSize: "18px",
      dotHeight: "8px",
      dotWidth: "8px",
      dotBorderRadius: "4px"
    };

    const sliderDark = {
      name: "Slider",
      common: commonDark,

      self(vars) {
        const boxShadow = "0 2px 8px 0 rgba(0, 0, 0, 0.12)";
        const {
          railColor,
          modalColor,
          primaryColorSuppl,
          popoverColor,
          textColor2,
          cardColor,
          borderRadius,
          fontSize,
          opacityDisabled
        } = vars;
        return { ...sizeVariables$3,
          fontSize,
          railColor,
          railColorHover: railColor,
          fillColor: primaryColorSuppl,
          fillColorHover: primaryColorSuppl,
          opacityDisabled,
          handleColor: "#FFF",
          dotColor: cardColor,
          dotColorModal: modalColor,
          dotColorPopover: popoverColor,
          handleBoxShadow: "0px 2px 4px 0 rgba(0, 0, 0, 0.4)",
          handleBoxShadowHover: "0px 2px 4px 0 rgba(0, 0, 0, 0.4)",
          handleBoxShadowActive: "0px 2px 4px 0 rgba(0, 0, 0, 0.4)",
          handleBoxShadowFocus: "0px 2px 4px 0 rgba(0, 0, 0, 0.4)",
          indicatorColor: popoverColor,
          indicatorBoxShadow: boxShadow,
          indicatorTextColor: textColor2,
          indicatorBorderRadius: borderRadius,
          dotBorder: `2px solid ${railColor}`,
          dotBorderActive: `2px solid ${primaryColorSuppl}`,
          dotBoxShadow: ""
        };
      }

    };
    var sliderDark$1 = sliderDark;

    const self$g = vars => {
      const indicatorColor = "rgba(0, 0, 0, .85)";
      const boxShadow = "0 2px 8px 0 rgba(0, 0, 0, 0.12)";
      const {
        railColor,
        primaryColor,
        baseColor,
        cardColor,
        modalColor,
        popoverColor,
        borderRadius,
        fontSize,
        opacityDisabled
      } = vars;
      return { ...sizeVariables$3,
        fontSize,
        railColor,
        railColorHover: railColor,
        fillColor: primaryColor,
        fillColorHover: primaryColor,
        opacityDisabled,
        handleColor: "#FFF",
        dotColor: cardColor,
        dotColorModal: modalColor,
        dotColorPopover: popoverColor,
        handleBoxShadow: "0 1px 4px 0 rgba(0, 0, 0, 0.3), inset 0 0 1px 0 rgba(0, 0, 0, 0.05)",
        handleBoxShadowHover: "0 1px 4px 0 rgba(0, 0, 0, 0.3), inset 0 0 1px 0 rgba(0, 0, 0, 0.05)",
        handleBoxShadowActive: "0 1px 4px 0 rgba(0, 0, 0, 0.3), inset 0 0 1px 0 rgba(0, 0, 0, 0.05)",
        handleBoxShadowFocus: "0 1px 4px 0 rgba(0, 0, 0, 0.3), inset 0 0 1px 0 rgba(0, 0, 0, 0.05)",
        indicatorColor,
        indicatorBoxShadow: boxShadow,
        indicatorTextColor: baseColor,
        indicatorBorderRadius: borderRadius,
        dotBorder: `2px solid ${railColor}`,
        dotBorderActive: `2px solid ${primaryColor}`,
        dotBoxShadow: ""
      };
    };

    const sliderLight = {
      name: "Slider",
      common: commonLight,
      self: self$g
    };
    var sliderLight$1 = sliderLight;

    const self$f = vars => {
      const {
        opacityDisabled,
        heightTiny,
        heightSmall,
        heightMedium,
        heightLarge,
        heightHuge,
        primaryColor,
        fontSize
      } = vars;
      return {
        fontSize,
        textColor: primaryColor,
        sizeTiny: heightTiny,
        sizeSmall: heightSmall,
        sizeMedium: heightMedium,
        sizeLarge: heightLarge,
        sizeHuge: heightHuge,
        color: primaryColor,
        opacitySpinning: opacityDisabled
      };
    };
    const spinLight = {
      name: "Spin",
      common: commonLight,
      self: self$f
    };
    var spinLight$1 = spinLight;

    const spinDark = {
      name: "Spin",
      common: commonDark,
      self: self$f
    };
    var spinDark$1 = spinDark;

    const self$e = vars => {
      const {
        textColor2,
        textColor3,
        fontSize,
        fontWeight
      } = vars;
      return {
        labelFontSize: fontSize,
        labelFontWeight: fontWeight,
        valueFontWeight: fontWeight,
        valueFontSize: "24px",
        labelTextColor: textColor3,
        valuePrefixTextColor: textColor2,
        valueSuffixTextColor: textColor2,
        valueTextColor: textColor2
      };
    };
    const statisticLight = {
      name: "Statistic",
      common: commonLight,
      self: self$e
    };
    var statisticLight$1 = statisticLight;

    const statisticDark = {
      name: "Statistic",
      common: commonDark,
      self: self$e
    };
    var statisticDark$1 = statisticDark;

    var rtlStyle$5 = cB("statistic", [cM("rtl", `
    direction: rtl;
    text-align: right;
  `, [cB("statistic-value", [cE("prefix", `
        margin: 0 0 0 4px;
      `), cE("suffix", `
        margin: 0 4px 0 0;
      `)])])]);

    const statisticRtl = {
      name: "Statistic",
      style: rtlStyle$5
    };

    var commonVariables$2 = {
      stepHeaderFontSizeSmall: "14px",
      stepHeaderFontSizeMedium: "16px",
      indicatorIndexFontSizeSmall: "14px",
      indicatorIndexFontSizeMedium: "16px",
      indicatorSizeSmall: "22px",
      indicatorSizeMedium: "28px",
      indicatorIconSizeSmall: "14px",
      indicatorIconSizeMedium: "18px"
    };

    const self$d = vars => {
      const {
        fontWeightStrong,
        baseColor,
        textColorDisabled,
        primaryColor,
        errorColor,
        textColor1,
        textColor2
      } = vars;
      return { ...commonVariables$2,
        stepHeaderFontWeight: fontWeightStrong,
        indicatorTextColorProcess: baseColor,
        indicatorTextColorWait: textColorDisabled,
        indicatorTextColorFinish: primaryColor,
        indicatorTextColorError: errorColor,
        indicatorBorderColorProcess: primaryColor,
        indicatorBorderColorWait: textColorDisabled,
        indicatorBorderColorFinish: primaryColor,
        indicatorBorderColorError: errorColor,
        indicatorColorProcess: primaryColor,
        indicatorColorWait: "#0000",
        indicatorColorFinish: "#0000",
        indicatorColorError: "#0000",
        splitorColorProcess: textColorDisabled,
        splitorColorWait: textColorDisabled,
        splitorColorFinish: primaryColor,
        splitorColorError: textColorDisabled,
        headerTextColorProcess: textColor1,
        headerTextColorWait: textColorDisabled,
        headerTextColorFinish: textColorDisabled,
        headerTextColorError: errorColor,
        descriptionTextColorProcess: textColor2,
        descriptionTextColorWait: textColorDisabled,
        descriptionTextColorFinish: textColorDisabled,
        descriptionTextColorError: errorColor
      };
    };
    const stepsLight = {
      name: "Steps",
      common: commonLight,
      self: self$d
    };
    var stepsLight$1 = stepsLight;

    const stepsDark = {
      name: "Steps",
      common: commonDark,
      self: self$d
    };
    var stepsDark$1 = stepsDark;

    var rtlStyle$4 = c$1([cB("steps", [cM("rtl", `
      direction: rtl;
      text-align: right;
    `, [cB("step-content", [cB("step-content-header", `
          margin-left: 0;
          margin-right: 9px;
        `), cE("description", `
          margin-left: 0;
          margin-right: 9px;
        `)]), cM("vertical", [c$1(">", [cB("step", [c$1(">", [cB("step-indicator", [c$1(">", [cB("step-splitor", `
                    left: unset;
                    right: calc(var(--n-indicator-size) / 2);
                  `)])])])])])])])])]);

    const stepsRtl = {
      name: "Steps",
      style: rtlStyle$4
    };

    var commonVars$1 = {
      buttonHeightSmall: "14px",
      buttonHeightMedium: "18px",
      buttonHeightLarge: "22px",
      buttonWidthSmall: "14px",
      buttonWidthMedium: "18px",
      buttonWidthLarge: "22px",
      buttonWidthPressedSmall: "20px",
      buttonWidthPressedMedium: "24px",
      buttonWidthPressedLarge: "28px",
      railHeightSmall: "18px",
      railHeightMedium: "22px",
      railHeightLarge: "26px",
      railWidthSmall: "32px",
      railWidthMedium: "40px",
      railWidthLarge: "48px"
    };

    const switchDark = {
      name: "Switch",
      common: commonDark,

      self(vars) {
        const {
          primaryColorSuppl,
          opacityDisabled,
          borderRadius,
          primaryColor,
          textColor2,
          baseColor
        } = vars;
        const railOverlayColor = "rgba(255, 255, 255, .20)";
        return { ...commonVars$1,
          iconColor: baseColor,
          textColor: textColor2,
          loadingColor: primaryColorSuppl,
          opacityDisabled,
          railColor: railOverlayColor,
          railColorActive: primaryColorSuppl,
          buttonBoxShadow: "0px 2px 4px 0 rgba(0, 0, 0, 0.4)",
          buttonColor: "#FFF",
          railBorderRadiusSmall: borderRadius,
          railBorderRadiusMedium: borderRadius,
          railBorderRadiusLarge: borderRadius,
          buttonBorderRadiusSmall: borderRadius,
          buttonBorderRadiusMedium: borderRadius,
          buttonBorderRadiusLarge: borderRadius,
          boxShadowFocus: `0 0 8px 0 ${changeColor(primaryColor, {
        alpha: 0.3
      })}`
        };
      }

    };
    var switchDark$1 = switchDark;

    const self$c = vars => {
      const {
        primaryColor,
        opacityDisabled,
        borderRadius,
        textColor3
      } = vars;
      const railOverlayColor = "rgba(0, 0, 0, .14)";
      return { ...commonVars$1,
        iconColor: textColor3,
        textColor: "white",
        loadingColor: primaryColor,
        opacityDisabled,
        railColor: railOverlayColor,
        railColorActive: primaryColor,
        buttonBoxShadow: "0 1px 4px 0 rgba(0, 0, 0, 0.3), inset 0 0 1px 0 rgba(0, 0, 0, 0.05)",
        buttonColor: "#FFF",
        railBorderRadiusSmall: borderRadius,
        railBorderRadiusMedium: borderRadius,
        railBorderRadiusLarge: borderRadius,
        buttonBorderRadiusSmall: borderRadius,
        buttonBorderRadiusMedium: borderRadius,
        buttonBorderRadiusLarge: borderRadius,
        boxShadowFocus: `0 0 0 2px ${changeColor(primaryColor, {
      alpha: 0.2
    })}`
      };
    };

    const switchLight = {
      name: "Switch",
      common: commonLight,
      self: self$c
    };
    var switchLight$1 = switchLight;

    var sizeVariables$2 = {
      thPaddingSmall: "6px",
      thPaddingMedium: "12px",
      thPaddingLarge: "12px",
      tdPaddingSmall: "6px",
      tdPaddingMedium: "12px",
      tdPaddingLarge: "12px"
    };

    const self$b = vars => {
      const {
        dividerColor,
        cardColor,
        modalColor,
        popoverColor,
        tableHeaderColor,
        tableColorStriped,
        textColor1,
        textColor2,
        borderRadius,
        fontWeightStrong,
        lineHeight,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge
      } = vars;
      return { ...sizeVariables$2,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        lineHeight,
        borderRadius,
        borderColor: composite(cardColor, dividerColor),
        borderColorModal: composite(modalColor, dividerColor),
        borderColorPopover: composite(popoverColor, dividerColor),
        tdColor: cardColor,
        tdColorModal: modalColor,
        tdColorPopover: popoverColor,
        tdColorStriped: composite(cardColor, tableColorStriped),
        tdColorStripedModal: composite(modalColor, tableColorStriped),
        tdColorStripedPopover: composite(popoverColor, tableColorStriped),
        thColor: composite(cardColor, tableHeaderColor),
        thColorModal: composite(modalColor, tableHeaderColor),
        thColorPopover: composite(popoverColor, tableHeaderColor),
        thTextColor: textColor1,
        tdTextColor: textColor2,
        thFontWeight: fontWeightStrong
      };
    };
    const tableLight = {
      name: "Table",
      common: commonLight,
      self: self$b
    };
    var tableLight$1 = tableLight;

    const tableDark = {
      name: "Table",
      common: commonDark,
      self: self$b
    };
    var tableDark$1 = tableDark;

    var rtlStyle$3 = c$1([cB("table", [cM("rtl", `
      direction: rtl;
      text-align: right;
    `, [c$1("th, td", `
        border-right: 0px solid var(--n-merged-border-color);
        border-left: 1px solid var(--n-merged-border-color);
      `, [c$1("&:last-child", `
          border-left: none;
          border-right: inherit;
        `)]), cM("single-line", [c$1("th, td", `
          border-left: 0px solid var(--n-merged-border-color);
        `)])])])]);

    const tableRtl = {
      name: "Table",
      style: rtlStyle$3
    };

    var sizeVariables$1 = {
      tabFontSizeSmall: "14px",
      tabFontSizeMedium: "14px",
      tabFontSizeLarge: "16px",
      tabGapSmallLine: "36px",
      tabGapMediumLine: "36px",
      tabGapLargeLine: "36px",
      tabPaddingSmallLine: "6px 0",
      tabPaddingMediumLine: "10px 0",
      tabPaddingLargeLine: "14px 0",
      tabGapSmallBar: "36px",
      tabGapMediumBar: "36px",
      tabGapLargeBar: "36px",
      tabPaddingSmallBar: "4px 0",
      tabPaddingMediumBar: "6px 0",
      tabPaddingLargeBar: "10px 0",
      tabGapSmallCard: "4px",
      tabGapMediumCard: "4px",
      tabGapLargeCard: "4px",
      tabPaddingSmallCard: "6px 10px",
      tabPaddingMediumCard: "8px 12px",
      tabPaddingLargeCard: "8px 16px",
      tabPaddingSmallSegment: "4px 0",
      tabPaddingMediumSegment: "6px 0",
      tabPaddingLargeSegment: "8px 0",
      tabGapSmallSegment: "0",
      tabGapMediumSegment: "0",
      tabGapLargeSegment: "0",
      panePaddingSmall: "8px 0 0 0",
      panePaddingMedium: "12px 0 0 0",
      panePaddingLarge: "16px 0 0 0",
      closeSize: "18px",
      closeIconSize: "14px"
    };

    const self$a = vars => {
      const {
        textColor2,
        primaryColor,
        textColorDisabled,
        closeIconColor,
        closeIconColorHover,
        closeIconColorPressed,
        closeColorHover,
        closeColorPressed,
        tabColor,
        baseColor,
        dividerColor,
        fontWeight,
        textColor1,
        borderRadius,
        fontSize,
        fontWeightStrong
      } = vars;
      return { ...sizeVariables$1,
        colorSegment: tabColor,
        tabFontSizeCard: fontSize,
        tabTextColorLine: textColor1,
        tabTextColorActiveLine: primaryColor,
        tabTextColorHoverLine: primaryColor,
        tabTextColorDisabledLine: textColorDisabled,
        tabTextColorSegment: textColor1,
        tabTextColorActiveSegment: textColor2,
        tabTextColorHoverSegment: textColor2,
        tabTextColorDisabledSegment: textColorDisabled,
        tabTextColorBar: textColor1,
        tabTextColorActiveBar: primaryColor,
        tabTextColorHoverBar: primaryColor,
        tabTextColorDisabledBar: textColorDisabled,
        tabTextColorCard: textColor1,
        tabTextColorHoverCard: textColor1,
        tabTextColorActiveCard: primaryColor,
        tabTextColorDisabledCard: textColorDisabled,
        barColor: primaryColor,
        closeIconColor,
        closeIconColorHover,
        closeIconColorPressed,
        closeColorHover,
        closeColorPressed,
        closeBorderRadius: borderRadius,
        tabColor,
        tabColorSegment: baseColor,
        tabBorderColor: dividerColor,
        tabFontWeightActive: fontWeight,
        tabFontWeight: fontWeight,
        tabBorderRadius: borderRadius,
        paneTextColor: textColor2,
        fontWeightStrong
      };
    };
    const tabsLight = {
      name: "Tabs",
      common: commonLight,
      self: self$a
    };
    var tabsLight$1 = tabsLight;

    const tabsDark = {
      name: "Tabs",
      common: commonDark,

      self(vars) {
        const commonSelf = self$a(vars);
        const {
          inputColor
        } = vars;
        commonSelf.colorSegment = inputColor;
        commonSelf.tabColorSegment = inputColor;
        return commonSelf;
      }

    };
    var tabsDark$1 = tabsDark;

    const self$9 = vars => {
      const {
        textColor1,
        textColor2,
        fontWeightStrong,
        fontSize
      } = vars;
      return {
        fontSize,
        titleTextColor: textColor1,
        textColor: textColor2,
        titleFontWeight: fontWeightStrong
      };
    };
    const thingLight = {
      name: "Thing",
      common: commonLight,
      self: self$9
    };
    var thingLight$1 = thingLight;

    const thingDark = {
      name: "Thing",
      common: commonDark,
      self: self$9
    };
    var thingDark$1 = thingDark;

    var rtlStyle$2 = cB("thing", [cM("rtl", `
    direction: rtl;
    text-align: right;
  `, [cB("thing-avatar", `
      margin-left: 12px;
      margin-right: 0;
    `)])]);

    const thingRtl = {
      name: "Thing",
      style: rtlStyle$2,
      peers: [buttonRtl, spaceRtl]
    };

    var sizeVariables = {
      titleMarginMedium: "0",
      titleMarginLarge: "-2px 0 0 0",
      titleFontSizeMedium: "14px",
      titleFontSizeLarge: "16px",
      iconSizeMedium: "14px",
      iconSizeLarge: "14px"
    };

    const timelineDark = {
      name: "Timeline",
      common: commonDark,

      self(vars) {
        const {
          textColor3,
          infoColorSuppl,
          errorColorSuppl,
          successColorSuppl,
          warningColorSuppl,
          textColor1,
          textColor2,
          railColor,
          fontWeightStrong,
          fontSize
        } = vars;
        return { ...sizeVariables,
          contentFontSize: fontSize,
          titleFontWeight: fontWeightStrong,
          circleBorder: `2px solid ${textColor3}`,
          circleBorderInfo: `2px solid ${infoColorSuppl}`,
          circleBorderError: `2px solid ${errorColorSuppl}`,
          circleBorderSuccess: `2px solid ${successColorSuppl}`,
          circleBorderWarning: `2px solid ${warningColorSuppl}`,
          iconColor: textColor3,
          iconColorInfo: infoColorSuppl,
          iconColorError: errorColorSuppl,
          iconColorSuccess: successColorSuppl,
          iconColorWarning: warningColorSuppl,
          titleTextColor: textColor1,
          contentTextColor: textColor2,
          metaTextColor: textColor3,
          lineColor: railColor
        };
      }

    };
    var timelineDark$1 = timelineDark;

    const self$8 = vars => {
      const {
        textColor3,
        infoColor,
        errorColor,
        successColor,
        warningColor,
        textColor1,
        textColor2,
        railColor,
        fontWeightStrong,
        fontSize
      } = vars;
      return { ...sizeVariables,
        contentFontSize: fontSize,
        titleFontWeight: fontWeightStrong,
        circleBorder: `2px solid ${textColor3}`,
        circleBorderInfo: `2px solid ${infoColor}`,
        circleBorderError: `2px solid ${errorColor}`,
        circleBorderSuccess: `2px solid ${successColor}`,
        circleBorderWarning: `2px solid ${warningColor}`,
        iconColor: textColor3,
        iconColorInfo: infoColor,
        iconColorError: errorColor,
        iconColorSuccess: successColor,
        iconColorWarning: warningColor,
        titleTextColor: textColor1,
        contentTextColor: textColor2,
        metaTextColor: textColor3,
        lineColor: railColor
      };
    };

    const timelineLight = {
      name: "Timeline",
      common: commonLight,
      self: self$8
    };
    var timelineLight$1 = timelineLight;

    var commonVariables$1 = {
      extraFontSizeSmall: "12px",
      extraFontSizeMedium: "12px",
      extraFontSizeLarge: "14px",
      titleFontSizeSmall: "14px",
      titleFontSizeMedium: "16px",
      titleFontSizeLarge: "16px",
      closeSize: "20px",
      closeIconSize: "16px",
      headerHeightSmall: "44px",
      headerHeightMedium: "44px",
      headerHeightLarge: "50px"
    };

    const transferDark$1 = {
      name: "Transfer",
      common: commonDark,
      peers: {
        Checkbox: checkboxDark$1,
        Scrollbar: scrollbarDark$1,
        Input: inputDark$1,
        Empty: emptyDark$1,
        Button: buttonDark$1
      },

      self(vars) {
        const {
          fontWeight,
          fontSizeLarge,
          fontSizeMedium,
          fontSizeSmall,
          heightLarge,
          heightMedium,
          borderRadius,
          inputColor,
          tableHeaderColor,
          textColor1,
          textColorDisabled,
          textColor2,
          textColor3,
          hoverColor,
          closeColorHover,
          closeColorPressed,
          closeIconColor,
          closeIconColorHover,
          closeIconColorPressed,
          dividerColor
        } = vars;
        return { ...commonVariables$1,
          itemHeightSmall: heightMedium,
          itemHeightMedium: heightMedium,
          itemHeightLarge: heightLarge,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          borderRadius,
          dividerColor,
          borderColor: "#0000",
          listColor: inputColor,
          headerColor: tableHeaderColor,
          titleTextColor: textColor1,
          titleTextColorDisabled: textColorDisabled,
          extraTextColor: textColor3,
          extraTextColorDisabled: textColorDisabled,
          itemTextColor: textColor2,
          itemTextColorDisabled: textColorDisabled,
          itemColorPending: hoverColor,
          titleFontWeight: fontWeight,
          closeColorHover,
          closeColorPressed,
          closeIconColor,
          closeIconColorHover,
          closeIconColorPressed
        };
      }

    };
    var transferDark$2 = transferDark$1;

    const self$7 = vars => {
      const {
        fontWeight,
        fontSizeLarge,
        fontSizeMedium,
        fontSizeSmall,
        heightLarge,
        heightMedium,
        borderRadius,
        cardColor,
        tableHeaderColor,
        textColor1,
        textColorDisabled,
        textColor2,
        textColor3,
        borderColor,
        hoverColor,
        closeColorHover,
        closeColorPressed,
        closeIconColor,
        closeIconColorHover,
        closeIconColorPressed
      } = vars;
      return { ...commonVariables$1,
        itemHeightSmall: heightMedium,
        itemHeightMedium: heightMedium,
        itemHeightLarge: heightLarge,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        borderRadius,
        dividerColor: borderColor,
        borderColor,
        listColor: cardColor,
        headerColor: composite(cardColor, tableHeaderColor),
        titleTextColor: textColor1,
        titleTextColorDisabled: textColorDisabled,
        extraTextColor: textColor3,
        extraTextColorDisabled: textColorDisabled,
        itemTextColor: textColor2,
        itemTextColorDisabled: textColorDisabled,
        itemColorPending: hoverColor,
        titleFontWeight: fontWeight,
        closeColorHover,
        closeColorPressed,
        closeIconColor,
        closeIconColorHover,
        closeIconColorPressed
      };
    };

    const transferLight$1 = createTheme$1({
      name: "Transfer",
      common: commonLight,
      peers: {
        Checkbox: checkboxLight$1,
        Scrollbar: scrollbarLight$1,
        Input: inputLight$1,
        Empty: emptyLight$1,
        Button: buttonLight$1
      },
      self: self$7
    });
    var transferLight$2 = transferLight$1;

    const self$6 = vars => {
      const {
        borderRadiusSmall,
        hoverColor,
        pressedColor,
        primaryColor,
        textColor3,
        textColor2,
        textColorDisabled,
        fontSize
      } = vars;
      return {
        fontSize,
        nodeBorderRadius: borderRadiusSmall,
        nodeColorHover: hoverColor,
        nodeColorPressed: pressedColor,
        nodeColorActive: changeColor(primaryColor, {
          alpha: 0.1
        }),
        arrowColor: textColor3,
        nodeTextColor: textColor2,
        nodeTextColorDisabled: textColorDisabled,
        loadingColor: primaryColor,
        dropMarkColor: primaryColor
      };
    };
    const treeLight = createTheme$1({
      name: "Tree",
      common: commonLight,
      peers: {
        Checkbox: checkboxLight$1,
        Scrollbar: scrollbarLight$1,
        Empty: emptyLight$1
      },
      self: self$6
    });
    var treeLight$1 = treeLight;

    const treeDark = {
      name: "Tree",
      common: commonDark,
      peers: {
        Checkbox: checkboxDark$1,
        Scrollbar: scrollbarDark$1,
        Empty: emptyDark$1
      },

      self(vars) {
        const {
          primaryColor
        } = vars;
        const commonSelf = self$6(vars);
        commonSelf.nodeColorActive = changeColor(primaryColor, {
          alpha: 0.15
        });
        return commonSelf;
      }

    };
    var treeDark$1 = treeDark;

    var rtlStyle$1 = cB("tree", [cM("rtl", `
    direction: rtl;
    text-align: right;
  `, [cB("tree-node-switcher", `
      transform: rotate(180deg);
    `, [cM("expanded", `
        transform: rotate(90deg);
      `)]), cB("tree-node-checkbox", `
      margin-right: 0;
      margin-left: 4px;
    `), cB("tree-node-content", [cE("prefix", `
        margin-right: 0;
        margin-left: 8px;
      `)]), cB("tree-node-checkbox", [cM("right", `
        margin-right: 4px;
      `)])])]);

    const treeRtl = {
      name: "Tree",
      style: rtlStyle$1
    };

    const treeSelectDark = {
      name: "TreeSelect",
      common: commonDark,
      peers: {
        Tree: treeDark$1,
        Empty: emptyDark$1,
        InternalSelection: internalSelectionDark$1
      }
    };
    var treeSelectDark$1 = treeSelectDark;

    const self$5 = vars => {
      const {
        popoverColor,
        boxShadow2,
        borderRadius,
        heightMedium,
        dividerColor,
        textColor2
      } = vars;
      return {
        menuPadding: "4px",
        menuColor: popoverColor,
        menuBoxShadow: boxShadow2,
        menuBorderRadius: borderRadius,
        menuHeight: `calc(${heightMedium} * 7.6)`,
        actionDividerColor: dividerColor,
        actionTextColor: textColor2,
        actionPadding: "8px 12px"
      };
    };
    const treeSelectLight = createTheme$1({
      name: "TreeSelect",
      common: commonLight,
      peers: {
        Tree: treeLight$1,
        Empty: emptyLight$1,
        InternalSelection: internalSelectionLight$1
      },
      self: self$5
    });
    var treeSelectLight$1 = treeSelectLight;

    var commonVars = {
      headerFontSize1: "30px",
      headerFontSize2: "22px",
      headerFontSize3: "18px",
      headerFontSize4: "16px",
      headerFontSize5: "16px",
      headerFontSize6: "16px",
      headerMargin1: "28px 0 20px 0",
      headerMargin2: "28px 0 20px 0",
      headerMargin3: "28px 0 20px 0",
      headerMargin4: "28px 0 18px 0",
      headerMargin5: "28px 0 18px 0",
      headerMargin6: "28px 0 18px 0",
      headerPrefixWidth1: "16px",
      headerPrefixWidth2: "16px",
      headerPrefixWidth3: "12px",
      headerPrefixWidth4: "12px",
      headerPrefixWidth5: "12px",
      headerPrefixWidth6: "12px",
      headerBarWidth1: "4px",
      headerBarWidth2: "4px",
      headerBarWidth3: "3px",
      headerBarWidth4: "3px",
      headerBarWidth5: "3px",
      headerBarWidth6: "3px",
      pMargin: "16px 0 16px 0",
      liMargin: ".25em 0 0 0",
      olPadding: "0 0 0 2em",
      ulPadding: "0 0 0 2em"
    };

    const self$4 = vars => {
      const {
        primaryColor,
        textColor2,
        borderColor,
        lineHeight,
        fontSize,
        borderRadiusSmall,
        dividerColor,
        fontWeightStrong,
        textColor1,
        textColor3,
        infoColor,
        warningColor,
        errorColor,
        successColor,
        codeColor
      } = vars;
      return { ...commonVars,
        aTextColor: primaryColor,
        blockquoteTextColor: textColor2,
        blockquotePrefixColor: borderColor,
        blockquoteLineHeight: lineHeight,
        blockquoteFontSize: fontSize,
        codeBorderRadius: borderRadiusSmall,
        liTextColor: textColor2,
        liLineHeight: lineHeight,
        liFontSize: fontSize,
        hrColor: dividerColor,
        headerFontWeight: fontWeightStrong,
        headerTextColor: textColor1,
        pTextColor: textColor2,
        pTextColor1Depth: textColor1,
        pTextColor2Depth: textColor2,
        pTextColor3Depth: textColor3,
        pLineHeight: lineHeight,
        pFontSize: fontSize,
        headerBarColor: primaryColor,
        headerBarColorPrimary: primaryColor,
        headerBarColorInfo: infoColor,
        headerBarColorError: errorColor,
        headerBarColorWarning: warningColor,
        headerBarColorSuccess: successColor,
        textColor: textColor2,
        textColor1Depth: textColor1,
        textColor2Depth: textColor2,
        textColor3Depth: textColor3,
        textColorPrimary: primaryColor,
        textColorInfo: infoColor,
        textColorSuccess: successColor,
        textColorWarning: warningColor,
        textColorError: errorColor,
        codeTextColor: textColor2,
        codeColor,
        codeBorder: "1px solid #0000"
      };
    };
    const typographyLight = {
      name: "Typography",
      common: commonLight,
      self: self$4
    };
    var typographyLight$1 = typographyLight;

    const typographyDark = {
      name: "Typography",
      common: commonDark,
      self: self$4
    };
    var typographyDark$1 = typographyDark;

    const self$3 = vars => {
      const {
        iconColor,
        primaryColor,
        errorColor,
        textColor2,
        successColor,
        opacityDisabled,
        actionColor,
        borderColor,
        hoverColor,
        lineHeight,
        borderRadius,
        fontSize
      } = vars;
      return {
        fontSize,
        lineHeight,
        borderRadius,
        draggerColor: actionColor,
        draggerBorder: `1px dashed ${borderColor}`,
        draggerBorderHover: `1px dashed ${primaryColor}`,
        itemColorHover: hoverColor,
        itemColorHoverError: changeColor(errorColor, {
          alpha: 0.06
        }),
        itemTextColor: textColor2,
        itemTextColorError: errorColor,
        itemTextColorSuccess: successColor,
        itemIconColor: iconColor,
        itemDisabledOpacity: opacityDisabled,
        itemBorderImageCardError: `1px solid ${errorColor}`,
        itemBorderImageCard: `1px solid ${borderColor}`
      };
    };
    const uploadLight = createTheme$1({
      name: "Upload",
      common: commonLight,
      peers: {
        Button: buttonLight$1,
        Progress: progressLight$1
      },
      self: self$3
    });
    var uploadLight$1 = uploadLight;

    const uploadDark = {
      name: "Upload",
      common: commonDark,
      peers: {
        Button: buttonDark$1,
        Progress: progressDark$1
      },

      self(vars) {
        const {
          errorColor
        } = vars;
        const commonSelf = self$3(vars);
        commonSelf.itemColorHoverError = changeColor(errorColor, {
          alpha: 0.09
        });
        return commonSelf;
      }

    };
    var uploadDark$1 = uploadDark;

    const watermarkDark = {
      name: "Watermark",
      common: commonDark,

      self(vars) {
        const {
          fontFamily
        } = vars;
        return {
          fontFamily
        };
      }

    };
    var watermarkDark$1 = watermarkDark;

    const watermarkLight = createTheme$1({
      name: "Watermark",
      common: commonLight,

      self(vars) {
        const {
          fontFamily
        } = vars;
        return {
          fontFamily
        };
      }

    });
    var watermarkLight$1 = watermarkLight;

    const rowLight = {
      name: "Row",
      common: commonLight
    };
    var rowLight$1 = rowLight;

    const rowDark = {
      name: "Row",
      common: commonDark
    };
    var rowDark$1 = rowDark;

    const positionStyles = Array.apply(null, {
      length: 24
    }).map((_, index) => {
      const prefixIndex = index + 1;
      const percent = `calc(100% / 24 * ${prefixIndex})`;
      return [cM(`${prefixIndex}-span`, {
        width: percent
      }), cM(`${prefixIndex}-offset`, {
        marginLeft: percent
      }), cM(`${prefixIndex}-push`, {
        right: percent,
        left: "unset"
      }), cM(`${prefixIndex}-pull`, {
        left: percent,
        right: "unset"
      })];
    });
    var rtlStyle = cB("row", [cM("rtl", `
    direction: rtl;
  `, [cB("col", positionStyles)])]);

    const rowRtl = {
      name: "Row",
      style: rtlStyle
    };

    const imageDark = {
      name: "Image",
      common: commonDark,
      peers: {
        Tooltip: tooltipDark$1
      },
      self: vars => {
        const {
          textColor2
        } = vars;
        return {
          toolbarIconColor: textColor2,
          toolbarColor: "rgba(0, 0, 0, .35)",
          toolbarBoxShadow: "none",
          toolbarBorderRadius: "24px"
        };
      }
    };

    const prevIcon = /* @__PURE__ */ vue.h("svg", {
      viewBox: "0 0 20 20",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg"
    }, /* @__PURE__ */ vue.h("path", {
      d: "M6 5C5.75454 5 5.55039 5.17688 5.50806 5.41012L5.5 5.5V14.5C5.5 14.7761 5.72386 15 6 15C6.24546 15 6.44961 14.8231 6.49194 14.5899L6.5 14.5V5.5C6.5 5.22386 6.27614 5 6 5ZM13.8536 5.14645C13.68 4.97288 13.4106 4.9536 13.2157 5.08859L13.1464 5.14645L8.64645 9.64645C8.47288 9.82001 8.4536 10.0894 8.58859 10.2843L8.64645 10.3536L13.1464 14.8536C13.3417 15.0488 13.6583 15.0488 13.8536 14.8536C14.0271 14.68 14.0464 14.4106 13.9114 14.2157L13.8536 14.1464L9.70711 10L13.8536 5.85355C14.0488 5.65829 14.0488 5.34171 13.8536 5.14645Z",
      fill: "currentColor"
    }));
    const nextIcon = /* @__PURE__ */ vue.h("svg", {
      viewBox: "0 0 20 20",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg"
    }, /* @__PURE__ */ vue.h("path", {
      d: "M13.5 5C13.7455 5 13.9496 5.17688 13.9919 5.41012L14 5.5V14.5C14 14.7761 13.7761 15 13.5 15C13.2545 15 13.0504 14.8231 13.0081 14.5899L13 14.5V5.5C13 5.22386 13.2239 5 13.5 5ZM5.64645 5.14645C5.82001 4.97288 6.08944 4.9536 6.28431 5.08859L6.35355 5.14645L10.8536 9.64645C11.0271 9.82001 11.0464 10.0894 10.9114 10.2843L10.8536 10.3536L6.35355 14.8536C6.15829 15.0488 5.84171 15.0488 5.64645 14.8536C5.47288 14.68 5.4536 14.4106 5.58859 14.2157L5.64645 14.1464L9.79289 10L5.64645 5.85355C5.45118 5.65829 5.45118 5.34171 5.64645 5.14645Z",
      fill: "currentColor"
    }));
    const closeIcon = /* @__PURE__ */ vue.h("svg", {
      viewBox: "0 0 20 20",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg"
    }, /* @__PURE__ */ vue.h("path", {
      d: "M4.089 4.216l.057-.07a.5.5 0 0 1 .638-.057l.07.057L10 9.293l5.146-5.147a.5.5 0 0 1 .638-.057l.07.057a.5.5 0 0 1 .057.638l-.057.07L10.707 10l5.147 5.146a.5.5 0 0 1 .057.638l-.057.07a.5.5 0 0 1-.638.057l-.07-.057L10 10.707l-5.146 5.147a.5.5 0 0 1-.638.057l-.07-.057a.5.5 0 0 1-.057-.638l.057-.07L9.293 10L4.146 4.854a.5.5 0 0 1-.057-.638l.057-.07l-.057.07z",
      fill: "currentColor"
    }));

    var style$E = c$1([c$1("body >", [cB("image-container", "position: fixed;")]), cB("image-preview-container", `
    position: fixed;
    left: 0;
    right: 0;
    top: 0;
    bottom: 0;
    display: flex;
  `), cB("image-preview-overlay", `
    z-index: -1;
    position: absolute;
    left: 0;
    right: 0;
    top: 0;
    bottom: 0;
    background: rgba(0, 0, 0, .3);
  `, [fadeInTransition()]), cB("image-preview-toolbar", `
    z-index: 1;
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    border-radius: var(--n-toolbar-border-radius);
    height: 48px;
    bottom: 40px;
    padding: 0 12px;
    background: var(--n-toolbar-color);
    box-shadow: var(--n-toolbar-box-shadow);
    color: var(--n-toolbar-icon-color);
    transition: color .3s var(--n-bezier);
    display: flex;
    align-items: center;
  `, [cB("base-icon", `
      padding: 0 8px;
      font-size: 28px;
      cursor: pointer;
    `), fadeInTransition()]), cB("image-preview-wrapper", `
    position: absolute;
    left: 0;
    right: 0;
    top: 0;
    bottom: 0;
    display: flex;
    pointer-events: none;
  `, [fadeInScaleUpTransition()]), cB("image-preview", `
    user-select: none;
    -webkit-user-select: none;
    pointer-events: all;
    margin: auto;
    max-height: calc(100vh - 32px);
    max-width: calc(100vw - 32px);
    transition: transform .3s var(--n-bezier);
  `), cB("image", `
    display: inline-flex;
    max-height: 100%;
    max-width: 100%;
  `, [cNotM("preview-disabled", `
      cursor: pointer;
    `), c$1("img", `
      border-radius: inherit;
    `)])]);

    const BLEEDING = 32;
    var NImagePreview = vue.defineComponent({
      name: "ImagePreview",
      props: {
        ...imagePreviewSharedProps,
        onNext: Function,
        onPrev: Function,
        clsPrefix: {
          type: String,
          required: true
        }
      },
      setup(props) {
        const themeRef = useTheme(
          "Image",
          "-image",
          style$E,
          imageLight,
          props,
          vue.toRef(props, "clsPrefix")
        );
        let thumbnailEl = null;
        const previewRef = vue.ref(null);
        const previewWrapperRef = vue.ref(null);
        const previewSrcRef = vue.ref(void 0);
        const showRef = vue.ref(false);
        const displayedRef = vue.ref(false);
        const { localeRef } = useLocale("Image");
        function syncTransformOrigin() {
          const { value: previewWrapper } = previewWrapperRef;
          if (!thumbnailEl || !previewWrapper)
            return;
          const { style: style2 } = previewWrapper;
          const tbox = thumbnailEl.getBoundingClientRect();
          const tx = tbox.left + tbox.width / 2;
          const ty = tbox.top + tbox.height / 2;
          style2.transformOrigin = `${tx}px ${ty}px`;
        }
        function handleKeydown(e) {
          switch (e.key) {
            case "ArrowLeft":
              props.onPrev?.();
              break;
            case "ArrowRight":
              props.onNext?.();
              break;
            case "Escape":
              toggleShow();
              break;
          }
        }
        vue.watch(showRef, (value) => {
          if (value) {
            on("keydown", document, handleKeydown);
          } else
            off("keydown", document, handleKeydown);
        });
        vue.onBeforeUnmount(() => {
          off("keydown", document, handleKeydown);
        });
        let startX = 0;
        let startY = 0;
        let offsetX = 0;
        let offsetY = 0;
        let startOffsetX = 0;
        let startOffsetY = 0;
        let mouseDownClientX = 0;
        let mouseDownClientY = 0;
        let dragging = false;
        function handleMouseMove(e) {
          const { clientX, clientY } = e;
          offsetX = clientX - startX;
          offsetY = clientY - startY;
          beforeNextFrameOnce(derivePreviewStyle);
        }
        function getMoveStrategy(opts) {
          const {
            mouseUpClientX,
            mouseUpClientY,
            mouseDownClientX: mouseDownClientX2,
            mouseDownClientY: mouseDownClientY2
          } = opts;
          const deltaHorizontal = mouseDownClientX2 - mouseUpClientX;
          const deltaVertical = mouseDownClientY2 - mouseUpClientY;
          const moveVerticalDirection = `vertical${deltaVertical > 0 ? "Top" : "Bottom"}`;
          const moveHorizontalDirection = `horizontal${deltaHorizontal > 0 ? "Left" : "Right"}`;
          return {
            moveVerticalDirection,
            moveHorizontalDirection,
            deltaHorizontal,
            deltaVertical
          };
        }
        function getDerivedOffset(moveStrategy) {
          const { value: preview } = previewRef;
          if (!preview)
            return { offsetX: 0, offsetY: 0 };
          const pbox = preview.getBoundingClientRect();
          const {
            moveVerticalDirection,
            moveHorizontalDirection,
            deltaHorizontal,
            deltaVertical
          } = moveStrategy || {};
          let nextOffsetX = 0;
          let nextOffsetY = 0;
          if (pbox.width <= window.innerWidth) {
            nextOffsetX = 0;
          } else if (pbox.left > 0) {
            nextOffsetX = (pbox.width - window.innerWidth) / 2;
          } else if (pbox.right < window.innerWidth) {
            nextOffsetX = -(pbox.width - window.innerWidth) / 2;
          } else if (moveHorizontalDirection === "horizontalRight") {
            nextOffsetX = Math.min(
              (pbox.width - window.innerWidth) / 2,
              startOffsetX - (deltaHorizontal ?? 0)
            );
          } else {
            nextOffsetX = Math.max(
              -((pbox.width - window.innerWidth) / 2),
              startOffsetX - (deltaHorizontal ?? 0)
            );
          }
          if (pbox.height <= window.innerHeight) {
            nextOffsetY = 0;
          } else if (pbox.top > 0) {
            nextOffsetY = (pbox.height - window.innerHeight) / 2;
          } else if (pbox.bottom < window.innerHeight) {
            nextOffsetY = -(pbox.height - window.innerHeight) / 2;
          } else if (moveVerticalDirection === "verticalBottom") {
            nextOffsetY = Math.min(
              (pbox.height - window.innerHeight) / 2,
              startOffsetY - (deltaVertical ?? 0)
            );
          } else {
            nextOffsetY = Math.max(
              -((pbox.height - window.innerHeight) / 2),
              startOffsetY - (deltaVertical ?? 0)
            );
          }
          return {
            offsetX: nextOffsetX,
            offsetY: nextOffsetY
          };
        }
        function handleMouseUp(e) {
          off("mousemove", document, handleMouseMove);
          off("mouseup", document, handleMouseUp);
          const { clientX: mouseUpClientX, clientY: mouseUpClientY } = e;
          dragging = false;
          const moveStrategy = getMoveStrategy({
            mouseUpClientX,
            mouseUpClientY,
            mouseDownClientX,
            mouseDownClientY
          });
          const offset = getDerivedOffset(moveStrategy);
          offsetX = offset.offsetX;
          offsetY = offset.offsetY;
          derivePreviewStyle();
        }
        function handlePreviewMousedown(e) {
          const { clientX, clientY } = e;
          dragging = true;
          startX = clientX - offsetX;
          startY = clientY - offsetY;
          startOffsetX = offsetX;
          startOffsetY = offsetY;
          mouseDownClientX = clientX;
          mouseDownClientY = clientY;
          derivePreviewStyle();
          on("mousemove", document, handleMouseMove);
          on("mouseup", document, handleMouseUp);
        }
        function handlePreviewDblclick() {
          const originalImageSizeScale = getOrignalImageSizeScale();
          scale = scale === originalImageSizeScale ? 1 : originalImageSizeScale;
          derivePreviewStyle();
        }
        const scaleRadix = 1.5;
        let scaleExp = 0;
        let scale = 1;
        let rotate = 0;
        function resetScale() {
          scale = 1;
          scaleExp = 0;
        }
        function handleSwitchPrev() {
          resetScale();
          rotate = 0;
          props.onPrev?.();
        }
        function handleSwitchNext() {
          resetScale();
          rotate = 0;
          props.onNext?.();
        }
        function rotateCounterclockwise() {
          rotate -= 90;
          derivePreviewStyle();
        }
        function rotateClockwise() {
          rotate += 90;
          derivePreviewStyle();
        }
        function getMaxScale() {
          const { value: preview } = previewRef;
          if (!preview)
            return 1;
          const { innerWidth, innerHeight } = window;
          const heightMaxScale = Math.max(
            1,
            preview.naturalHeight / (innerHeight - BLEEDING)
          );
          const widthMaxScale = Math.max(
            1,
            preview.naturalWidth / (innerWidth - BLEEDING)
          );
          return Math.max(3, heightMaxScale * 2, widthMaxScale * 2);
        }
        function getOrignalImageSizeScale() {
          const { value: preview } = previewRef;
          if (!preview)
            return 1;
          const { innerWidth, innerHeight } = window;
          const heightScale = preview.naturalHeight / (innerHeight - BLEEDING);
          const widthScale = preview.naturalWidth / (innerWidth - BLEEDING);
          if (heightScale < 1 && widthScale < 1) {
            return 1;
          }
          return Math.max(heightScale, widthScale);
        }
        function zoomIn() {
          const maxScale = getMaxScale();
          if (scale < maxScale) {
            scaleExp += 1;
            scale = Math.min(maxScale, Math.pow(scaleRadix, scaleExp));
            derivePreviewStyle();
          }
        }
        function zoomOut() {
          if (scale > 0.5) {
            const originalScale = scale;
            scaleExp -= 1;
            scale = Math.max(0.5, Math.pow(scaleRadix, scaleExp));
            const diff = originalScale - scale;
            derivePreviewStyle(false);
            const offset = getDerivedOffset();
            scale += diff;
            derivePreviewStyle(false);
            scale -= diff;
            offsetX = offset.offsetX;
            offsetY = offset.offsetY;
            derivePreviewStyle();
          }
        }
        function derivePreviewStyle(transition = true) {
          const { value: preview } = previewRef;
          if (!preview)
            return;
          const { style: style2 } = preview;
          const transformStyle = `transform-origin: center; transform: translateX(${offsetX}px) translateY(${offsetY}px) rotate(${rotate}deg) scale(${scale});`;
          if (dragging) {
            style2.cssText = "cursor: grabbing; transition: none;" + transformStyle;
          } else {
            style2.cssText = "cursor: grab;" + transformStyle + (transition ? "" : "transition: none;");
          }
          if (!transition) {
            void preview.offsetHeight;
          }
        }
        function toggleShow() {
          showRef.value = !showRef.value;
          displayedRef.value = true;
        }
        function resizeToOrignalImageSize() {
          scale = getOrignalImageSizeScale();
          scaleExp = Math.ceil(Math.log(scale) / Math.log(scaleRadix));
          offsetX = 0;
          offsetY = 0;
          derivePreviewStyle();
        }
        const exposedMethods = {
          setPreviewSrc: (src) => {
            previewSrcRef.value = src;
          },
          setThumbnailEl: (el) => {
            thumbnailEl = el;
          },
          toggleShow
        };
        function withTooltip(node, tooltipKey) {
          if (props.showToolbarTooltip) {
            const { value: theme } = themeRef;
            return /* @__PURE__ */ vue.h(NTooltip, {
              to: false,
              theme: theme.peers.Tooltip,
              themeOverrides: theme.peerOverrides.Tooltip,
              keepAliveOnHover: false
            }, {
              default: () => {
                return localeRef.value[tooltipKey];
              },
              trigger: () => node
            });
          } else {
            return node;
          }
        }
        const cssVarsRef = vue.computed(() => {
          const {
            common: { cubicBezierEaseInOut },
            self: {
              toolbarIconColor,
              toolbarBorderRadius,
              toolbarBoxShadow,
              toolbarColor
            }
          } = themeRef.value;
          return {
            "--n-bezier": cubicBezierEaseInOut,
            "--n-toolbar-icon-color": toolbarIconColor,
            "--n-toolbar-color": toolbarColor,
            "--n-toolbar-border-radius": toolbarBorderRadius,
            "--n-toolbar-box-shadow": toolbarBoxShadow
          };
        });
        const { inlineThemeDisabled } = useConfig();
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("image-preview", void 0, cssVarsRef, props) : void 0;
        return {
          previewRef,
          previewWrapperRef,
          previewSrc: previewSrcRef,
          show: showRef,
          appear: isMounted(),
          displayed: displayedRef,
          handleWheel(e) {
            e.preventDefault();
          },
          handlePreviewMousedown,
          handlePreviewDblclick,
          syncTransformOrigin,
          handleAfterLeave: () => {
            resetScale();
            rotate = 0;
            displayedRef.value = false;
          },
          handleDragStart: (e) => {
            e.preventDefault();
          },
          zoomIn,
          zoomOut,
          rotateCounterclockwise,
          rotateClockwise,
          handleSwitchPrev,
          handleSwitchNext,
          withTooltip,
          resizeToOrignalImageSize,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender,
          ...exposedMethods
        };
      },
      render() {
        const { clsPrefix } = this;
        return /* @__PURE__ */ vue.h(vue.Fragment, null, this.$slots.default?.(), /* @__PURE__ */ vue.h(LazyTeleport, {
          show: this.show
        }, {
          default: () => {
            if (!(this.show || this.displayed)) {
              return null;
            }
            this.onRender?.();
            return vue.withDirectives(
              /* @__PURE__ */ vue.h("div", {
                class: [
                  `${clsPrefix}-image-preview-container`,
                  this.themeClass
                ],
                style: this.cssVars,
                onWheel: this.handleWheel
              }, /* @__PURE__ */ vue.h(vue.Transition, {
                name: "fade-in-transition",
                appear: this.appear
              }, {
                default: () => this.show ? /* @__PURE__ */ vue.h("div", {
                  class: `${clsPrefix}-image-preview-overlay`,
                  onClick: this.toggleShow
                }) : null
              }), this.showToolbar ? /* @__PURE__ */ vue.h(vue.Transition, {
                name: "fade-in-transition",
                appear: this.appear
              }, {
                default: () => {
                  if (!this.show)
                    return null;
                  const { withTooltip } = this;
                  return /* @__PURE__ */ vue.h("div", {
                    class: `${clsPrefix}-image-preview-toolbar`
                  }, this.onPrev ? /* @__PURE__ */ vue.h(vue.Fragment, null, withTooltip(
                    /* @__PURE__ */ vue.h(NBaseIcon, {
                      clsPrefix,
                      onClick: this.handleSwitchPrev
                    }, { default: () => prevIcon }),
                    "tipPrevious"
                  ), withTooltip(
                    /* @__PURE__ */ vue.h(NBaseIcon, {
                      clsPrefix,
                      onClick: this.handleSwitchNext
                    }, { default: () => nextIcon }),
                    "tipNext"
                  )) : null, withTooltip(
                    /* @__PURE__ */ vue.h(NBaseIcon, {
                      clsPrefix,
                      onClick: this.rotateCounterclockwise
                    }, {
                      default: () => /* @__PURE__ */ vue.h(RotateCounterclockwiseIcon, null)
                    }),
                    "tipCounterclockwise"
                  ), withTooltip(
                    /* @__PURE__ */ vue.h(NBaseIcon, {
                      clsPrefix,
                      onClick: this.rotateClockwise
                    }, {
                      default: () => /* @__PURE__ */ vue.h(RotateClockwiseIcon, null)
                    }),
                    "tipClockwise"
                  ), withTooltip(
                    /* @__PURE__ */ vue.h(NBaseIcon, {
                      clsPrefix,
                      onClick: this.resizeToOrignalImageSize
                    }, {
                      default: () => {
                        return /* @__PURE__ */ vue.h(ResizeSmallIcon, null);
                      }
                    }),
                    "tipOriginalSize"
                  ), withTooltip(
                    /* @__PURE__ */ vue.h(NBaseIcon, {
                      clsPrefix,
                      onClick: this.zoomOut
                    }, { default: () => /* @__PURE__ */ vue.h(ZoomOutIcon, null) }),
                    "tipZoomOut"
                  ), withTooltip(
                    /* @__PURE__ */ vue.h(NBaseIcon, {
                      clsPrefix,
                      onClick: this.zoomIn
                    }, { default: () => /* @__PURE__ */ vue.h(ZoomInIcon, null) }),
                    "tipZoomIn"
                  ), withTooltip(
                    /* @__PURE__ */ vue.h(NBaseIcon, {
                      clsPrefix,
                      onClick: this.toggleShow
                    }, { default: () => closeIcon }),
                    "tipClose"
                  ));
                }
              }) : null, /* @__PURE__ */ vue.h(vue.Transition, {
                name: "fade-in-scale-up-transition",
                onAfterLeave: this.handleAfterLeave,
                appear: this.appear,
                onEnter: this.syncTransformOrigin,
                onBeforeLeave: this.syncTransformOrigin
              }, {
                default: () => vue.withDirectives(
                  /* @__PURE__ */ vue.h("div", {
                    class: `${clsPrefix}-image-preview-wrapper`,
                    ref: "previewWrapperRef"
                  }, /* @__PURE__ */ vue.h("img", {
                    draggable: false,
                    onMousedown: this.handlePreviewMousedown,
                    onDblclick: this.handlePreviewDblclick,
                    class: `${clsPrefix}-image-preview`,
                    key: this.previewSrc,
                    src: this.previewSrc,
                    ref: "previewRef",
                    onDragstart: this.handleDragStart
                  })),
                  [[vue.vShow, this.show]]
                )
              })),
              [[zindexable$1, { enabled: this.show }]]
            );
          }
        }));
      }
    });

    const imageGroupInjectionKey = createInjectionKey("n-image-group");
    const imageGroupProps = imagePreviewSharedProps;
    var NImageGroup = vue.defineComponent({
      name: "ImageGroup",
      props: imageGroupProps,
      setup(props) {
        let currentSrc;
        const { mergedClsPrefixRef } = useConfig(props);
        const groupId = `c${createId()}`;
        const vm = vue.getCurrentInstance();
        const setPreviewSrc = (src) => {
          currentSrc = src;
          previewInstRef.value?.setPreviewSrc(src);
        };
        function go(step) {
          if (!vm?.proxy)
            return;
          const container = vm.proxy.$el.parentElement;
          const imgs = container.querySelectorAll(
            `[data-group-id=${groupId}]:not([data-error=true])`
          );
          if (!imgs.length)
            return;
          const index = Array.from(imgs).findIndex(
            (img) => img.dataset.previewSrc === currentSrc
          );
          if (~index) {
            setPreviewSrc(
              imgs[(index + step + imgs.length) % imgs.length].dataset.previewSrc
            );
          } else {
            setPreviewSrc(imgs[0].dataset.previewSrc);
          }
        }
        vue.provide(imageGroupInjectionKey, {
          mergedClsPrefixRef,
          setPreviewSrc,
          setThumbnailEl: (el) => {
            previewInstRef.value?.setThumbnailEl(el);
          },
          toggleShow: () => {
            previewInstRef.value?.toggleShow();
          },
          groupId
        });
        const previewInstRef = vue.ref(null);
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          previewInstRef,
          next: () => go(1),
          prev: () => go(-1)
        };
      },
      render() {
        return /* @__PURE__ */ vue.h(NImagePreview, {
          theme: this.theme,
          themeOverrides: this.themeOverrides,
          clsPrefix: this.mergedClsPrefix,
          ref: "previewInstRef",
          onPrev: this.prev,
          onNext: this.next,
          showToolbar: this.showToolbar,
          showToolbarTooltip: this.showToolbarTooltip
        }, this.$slots);
      }
    });

    const imageProps = {
      alt: String,
      height: [String, Number],
      imgProps: Object,
      lazy: Boolean,
      intersectionObserverOptions: Object,
      objectFit: {
        type: String,
        default: "fill"
      },
      previewSrc: String,
      fallbackSrc: String,
      width: [String, Number],
      src: String,
      previewDisabled: Boolean,
      loadDescription: String,
      onError: Function,
      onLoad: Function,
      ...imagePreviewSharedProps
    };
    var NImage = vue.defineComponent({
      name: "Image",
      props: imageProps,
      inheritAttrs: false,
      setup(props) {
        const imageRef = vue.ref(null);
        const showErrorRef = vue.ref(false);
        const imgPropsRef = vue.toRef(props, "imgProps");
        const previewInstRef = vue.ref(null);
        const imageGroupHandle = vue.inject(imageGroupInjectionKey, null);
        const { mergedClsPrefixRef } = imageGroupHandle || useConfig(props);
        const exposedMethods = {
          click: () => {
            if (props.previewDisabled || showErrorRef.value)
              return;
            const mergedPreviewSrc = props.previewSrc || props.src;
            if (imageGroupHandle) {
              imageGroupHandle.setPreviewSrc(mergedPreviewSrc);
              imageGroupHandle.setThumbnailEl(imageRef.value);
              imageGroupHandle.toggleShow();
              return;
            }
            const { value: previewInst } = previewInstRef;
            if (!previewInst)
              return;
            previewInst.setPreviewSrc(mergedPreviewSrc);
            previewInst.setThumbnailEl(imageRef.value);
            previewInst.toggleShow();
          }
        };
        const shouldStartLoadingRef = vue.ref(!props.lazy);
        vue.onMounted(() => {
          imageRef.value?.setAttribute(
            "data-group-id",
            imageGroupHandle?.groupId || ""
          );
        });
        vue.onMounted(() => {
          if (isImageSupportNativeLazy) {
            return;
          }
          let unobserve;
          const stopWatchHandle = vue.watchEffect(() => {
            unobserve?.();
            unobserve = void 0;
            if (props.lazy) {
              unobserve = observeIntersection(
                imageRef.value,
                props.intersectionObserverOptions,
                shouldStartLoadingRef
              );
            }
          });
          vue.onBeforeUnmount(() => {
            stopWatchHandle();
            unobserve?.();
          });
        });
        vue.watchEffect(() => {
          void props.src;
          void props.imgProps?.src;
          showErrorRef.value = false;
        });
        const loadedRef = vue.ref(false);
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          groupId: imageGroupHandle?.groupId,
          previewInstRef,
          imageRef,
          imgProps: imgPropsRef,
          showError: showErrorRef,
          shouldStartLoading: shouldStartLoadingRef,
          loaded: loadedRef,
          mergedOnError: (e) => {
            if (!shouldStartLoadingRef.value)
              return;
            showErrorRef.value = true;
            const { onError, imgProps: { onError: imgPropsOnError } = {} } = props;
            onError?.(e);
            imgPropsOnError?.(e);
          },
          mergedOnLoad: (e) => {
            const { onLoad, imgProps: { onLoad: imgPropsOnLoad } = {} } = props;
            onLoad?.(e);
            imgPropsOnLoad?.(e);
            loadedRef.value = true;
          },
          ...exposedMethods
        };
      },
      render() {
        const { mergedClsPrefix, imgProps = {}, loaded, $attrs, lazy } = this;
        const placeholderNode = this.$slots.placeholder?.();
        const loadSrc = this.src || imgProps.src || "";
        const imgNode = vue.h("img", {
          ...imgProps,
          class: imgProps.class,
          ref: "imageRef",
          width: this.width || imgProps.width,
          height: this.height || imgProps.height,
          src: isImageSupportNativeLazy ? loadSrc : this.showError ? this.fallbackSrc : this.shouldStartLoading ? loadSrc : void 0,
          alt: this.alt || imgProps.alt,
          "aria-label": this.alt || imgProps.alt,
          onClick: this.click,
          onError: this.mergedOnError,
          onLoad: this.mergedOnLoad,
          loading: lazy ? "lazy" : "eager",
          style: [
            imgProps.style || "",
            placeholderNode && !loaded ? { height: "0", width: "0", visibility: "hidden" } : "",
            { objectFit: this.objectFit }
          ],
          "data-error": this.showError,
          "data-preview-src": this.previewSrc || this.src
        });
        return /* @__PURE__ */ vue.h("div", {
          ...$attrs,
          role: "none",
          class: [
            $attrs.class,
            `${mergedClsPrefix}-image`,
            (this.previewDisabled || this.showError) && `${mergedClsPrefix}-image--preview-disabled`
          ]
        }, this.groupId ? imgNode : /* @__PURE__ */ vue.h(NImagePreview, {
          theme: this.theme,
          themeOverrides: this.themeOverrides,
          clsPrefix: mergedClsPrefix,
          ref: "previewInstRef",
          showToolbar: this.showToolbar,
          showToolbarTooltip: this.showToolbarTooltip
        }, {
          default: () => imgNode
        }), !loaded && placeholderNode);
      }
    });

    function parse(value) {
      if (value === void 0 || value === null || typeof value === "string" && value.trim() === "") {
        return null;
      }

      return Number(value);
    }
    function isWipValue(value) {
      return value.includes(".") && (/^(-)?\d+.*(\.|0)$/.test(value) || /^\.\d+$/.test(value));
    }
    function validator(value) {
      if (value === void 0 || value === null) return true;
      if (Number.isNaN(value)) return false;
      return true;
    }
    function format(value, precision) {
      if (value === void 0 || value === null) return "";
      return precision === void 0 ? String(value) : value.toFixed(precision);
    }
    function parseNumber(number) {
      if (number === null) return null;

      if (typeof number === "number") {
        return number;
      } else {
        const parsedNumber = Number(number);
        if (Number.isNaN(parsedNumber)) return null;else {
          return parsedNumber;
        }
      }
    }

    var style$D = c$1([cB("input-number-suffix", `
    display: inline-block;
    margin-right: 10px;
  `), cB("input-number-prefix", `
    display: inline-block;
    margin-left: 10px;
  `)]);

    const HOLDING_CHANGE_THRESHOLD = 800;
    const HOLDING_CHANGE_INTERVAL = 100;
    const inputNumberProps = {
      ...useTheme.props,
      autofocus: Boolean,
      loading: {
        type: Boolean,
        default: void 0
      },
      placeholder: String,
      defaultValue: {
        type: Number,
        default: null
      },
      value: Number,
      step: {
        type: [Number, String],
        default: 1
      },
      min: [Number, String],
      max: [Number, String],
      size: String,
      disabled: {
        type: Boolean,
        default: void 0
      },
      validator: Function,
      bordered: {
        type: Boolean,
        default: void 0
      },
      showButton: {
        type: Boolean,
        default: true
      },
      buttonPlacement: {
        type: String,
        default: "right"
      },
      readonly: Boolean,
      clearable: Boolean,
      keyboard: {
        type: Object,
        default: {}
      },
      updateValueOnInput: {
        type: Boolean,
        default: true
      },
      parse: Function,
      format: Function,
      precision: Number,
      status: String,
      "onUpdate:value": [Function, Array],
      onUpdateValue: [Function, Array],
      onFocus: [Function, Array],
      onBlur: [Function, Array],
      onClear: [Function, Array],
      onChange: [Function, Array]
    };
    var InputNumber = vue.defineComponent({
      name: "InputNumber",
      props: inputNumberProps,
      setup(props) {
        {
          vue.watchEffect(() => {
            if (props.onChange !== void 0) {
              warnOnce(
                "input-number",
                "`on-change` is deprecated, please use `on-update:value` instead"
              );
            }
          });
        }
        const { mergedBorderedRef, mergedClsPrefixRef, mergedRtlRef } = useConfig(props);
        const themeRef = useTheme(
          "InputNumber",
          "-input-number",
          style$D,
          inputNumberLight$1,
          props,
          mergedClsPrefixRef
        );
        const { localeRef } = useLocale("InputNumber");
        const formItem = useFormItem(props);
        const { mergedSizeRef, mergedDisabledRef, mergedStatusRef } = formItem;
        const inputInstRef = vue.ref(null);
        const minusButtonInstRef = vue.ref(null);
        const addButtonInstRef = vue.ref(null);
        const uncontrolledValueRef = vue.ref(props.defaultValue);
        const controlledValueRef = vue.toRef(props, "value");
        const mergedValueRef = useMergedState(
          controlledValueRef,
          uncontrolledValueRef
        );
        const displayedValueRef = vue.ref("");
        const getPrecision = (value) => {
          const fraction = String(value).split(".")[1];
          return fraction ? fraction.length : 0;
        };
        const getMaxPrecision = (currentValue) => {
          const precisions = [props.min, props.max, props.step, currentValue].map(
            (value) => {
              if (value === void 0)
                return 0;
              return getPrecision(value);
            }
          );
          return Math.max(...precisions);
        };
        const mergedPlaceholderRef = useMemo(() => {
          const { placeholder } = props;
          if (placeholder !== void 0)
            return placeholder;
          return localeRef.value.placeholder;
        });
        const mergedStepRef = useMemo(() => {
          const parsedNumber = parseNumber(props.step);
          if (parsedNumber !== null) {
            return parsedNumber === 0 ? 1 : Math.abs(parsedNumber);
          }
          return 1;
        });
        const mergedMinRef = useMemo(() => {
          const parsedNumber = parseNumber(props.min);
          if (parsedNumber !== null)
            return parsedNumber;
          else
            return null;
        });
        const mergedMaxRef = useMemo(() => {
          const parsedNumber = parseNumber(props.max);
          if (parsedNumber !== null)
            return parsedNumber;
          else
            return null;
        });
        const doUpdateValue = (value) => {
          const { value: mergedValue } = mergedValueRef;
          if (value === mergedValue) {
            deriveDisplayedValueFromValue();
            return;
          }
          const {
            "onUpdate:value": _onUpdateValue,
            onUpdateValue,
            onChange
          } = props;
          const { nTriggerFormInput, nTriggerFormChange } = formItem;
          if (onChange)
            call(onChange, value);
          if (onUpdateValue)
            call(onUpdateValue, value);
          if (_onUpdateValue)
            call(_onUpdateValue, value);
          uncontrolledValueRef.value = value;
          nTriggerFormInput();
          nTriggerFormChange();
        };
        const deriveValueFromDisplayedValue = ({
          offset,
          doUpdateIfValid,
          fixPrecision,
          isInputing
        }) => {
          const { value: displayedValue } = displayedValueRef;
          if (isInputing && isWipValue(displayedValue)) {
            return false;
          }
          const parsedValue = (props.parse || parse)(displayedValue);
          if (parsedValue === null) {
            if (doUpdateIfValid)
              doUpdateValue(null);
            return null;
          }
          if (validator(parsedValue)) {
            const currentPrecision = getPrecision(parsedValue);
            const { precision } = props;
            if (precision !== void 0 && precision < currentPrecision && !fixPrecision) {
              return false;
            }
            let nextValue = parseFloat(
              (parsedValue + offset).toFixed(
                precision ?? getMaxPrecision(parsedValue)
              )
            );
            if (validator(nextValue)) {
              const { value: mergedMax } = mergedMaxRef;
              const { value: mergedMin } = mergedMinRef;
              if (mergedMax !== null && nextValue > mergedMax) {
                if (!doUpdateIfValid || isInputing)
                  return false;
                nextValue = mergedMax;
              }
              if (mergedMin !== null && nextValue < mergedMin) {
                if (!doUpdateIfValid || isInputing)
                  return false;
                nextValue = mergedMin;
              }
              if (props.validator && !props.validator(nextValue))
                return false;
              if (doUpdateIfValid)
                doUpdateValue(nextValue);
              return nextValue;
            }
          }
          return false;
        };
        const deriveDisplayedValueFromValue = () => {
          const { value: mergedValue } = mergedValueRef;
          if (validator(mergedValue)) {
            const { format: formatProp, precision } = props;
            if (formatProp) {
              displayedValueRef.value = formatProp(mergedValue);
            } else {
              if (mergedValue === null || precision === void 0 || getPrecision(mergedValue) > precision) {
                displayedValueRef.value = format(mergedValue, void 0);
              } else {
                displayedValueRef.value = format(mergedValue, precision);
              }
            }
          } else {
            displayedValueRef.value = String(mergedValue);
          }
        };
        deriveDisplayedValueFromValue();
        const displayedValueInvalidRef = useMemo(() => {
          const derivedValue = deriveValueFromDisplayedValue({
            offset: 0,
            doUpdateIfValid: false,
            isInputing: false,
            fixPrecision: false
          });
          return derivedValue === false;
        });
        const minusableRef = useMemo(() => {
          const { value: mergedValue } = mergedValueRef;
          if (props.validator && mergedValue === null) {
            return false;
          }
          const { value: mergedStep } = mergedStepRef;
          const derivedNextValue = deriveValueFromDisplayedValue({
            offset: -mergedStep,
            doUpdateIfValid: false,
            isInputing: false,
            fixPrecision: false
          });
          return derivedNextValue !== false;
        });
        const addableRef = useMemo(() => {
          const { value: mergedValue } = mergedValueRef;
          if (props.validator && mergedValue === null) {
            return false;
          }
          const { value: mergedStep } = mergedStepRef;
          const derivedNextValue = deriveValueFromDisplayedValue({
            offset: +mergedStep,
            doUpdateIfValid: false,
            isInputing: false,
            fixPrecision: false
          });
          return derivedNextValue !== false;
        });
        function doFocus(e) {
          const { onFocus } = props;
          const { nTriggerFormFocus } = formItem;
          if (onFocus)
            call(onFocus, e);
          nTriggerFormFocus();
        }
        function doBlur(e) {
          if (e.target === inputInstRef.value?.wrapperElRef) {
            return;
          }
          const value = deriveValueFromDisplayedValue({
            offset: 0,
            doUpdateIfValid: true,
            isInputing: false,
            fixPrecision: true
          });
          if (value !== false) {
            const inputElRef = inputInstRef.value?.inputElRef;
            if (inputElRef) {
              inputElRef.value = String(value || "");
            }
            if (mergedValueRef.value === value) {
              deriveDisplayedValueFromValue();
            }
          } else {
            deriveDisplayedValueFromValue();
          }
          const { onBlur } = props;
          const { nTriggerFormBlur } = formItem;
          if (onBlur)
            call(onBlur, e);
          nTriggerFormBlur();
        }
        function doClear(e) {
          const { onClear } = props;
          if (onClear)
            call(onClear, e);
        }
        function doAdd() {
          const { value: addable } = addableRef;
          if (!addable) {
            clearAddHoldTimeout();
            return;
          }
          const { value: mergedValue } = mergedValueRef;
          if (mergedValue === null) {
            if (!props.validator) {
              doUpdateValue(createValidValue());
            }
          } else {
            const { value: mergedStep } = mergedStepRef;
            deriveValueFromDisplayedValue({
              offset: mergedStep,
              doUpdateIfValid: true,
              isInputing: false,
              fixPrecision: true
            });
          }
        }
        function doMinus() {
          const { value: minusable } = minusableRef;
          if (!minusable) {
            clearMinusHoldTimeout();
            return;
          }
          const { value: mergedValue } = mergedValueRef;
          if (mergedValue === null) {
            if (!props.validator) {
              doUpdateValue(createValidValue());
            }
          } else {
            const { value: mergedStep } = mergedStepRef;
            deriveValueFromDisplayedValue({
              offset: -mergedStep,
              doUpdateIfValid: true,
              isInputing: false,
              fixPrecision: true
            });
          }
        }
        const handleFocus = doFocus;
        const handleBlur = doBlur;
        function createValidValue() {
          if (props.validator)
            return null;
          const { value: mergedMin } = mergedMinRef;
          const { value: mergedMax } = mergedMaxRef;
          if (mergedMin !== null) {
            return Math.max(0, mergedMin);
          } else if (mergedMax !== null) {
            return Math.min(0, mergedMax);
          } else {
            return 0;
          }
        }
        function handleClear(e) {
          doClear(e);
          doUpdateValue(null);
        }
        function handleMouseDown(e) {
          if (addButtonInstRef.value?.$el.contains(e.target)) {
            e.preventDefault();
          }
          if (minusButtonInstRef.value?.$el.contains(e.target)) {
            e.preventDefault();
          }
          inputInstRef.value?.activate();
        }
        let minusHoldStateIntervalId = null;
        let addHoldStateIntervalId = null;
        let firstMinusMousedownId = null;
        function clearMinusHoldTimeout() {
          if (firstMinusMousedownId) {
            window.clearTimeout(firstMinusMousedownId);
            firstMinusMousedownId = null;
          }
          if (minusHoldStateIntervalId) {
            window.clearInterval(minusHoldStateIntervalId);
            minusHoldStateIntervalId = null;
          }
        }
        function clearAddHoldTimeout() {
          if (firstAddMousedownId) {
            window.clearTimeout(firstAddMousedownId);
            firstAddMousedownId = null;
          }
          if (addHoldStateIntervalId) {
            window.clearInterval(addHoldStateIntervalId);
            addHoldStateIntervalId = null;
          }
        }
        function handleMinusMousedown() {
          clearMinusHoldTimeout();
          firstMinusMousedownId = window.setTimeout(() => {
            minusHoldStateIntervalId = window.setInterval(() => {
              doMinus();
            }, HOLDING_CHANGE_INTERVAL);
          }, HOLDING_CHANGE_THRESHOLD);
          on("mouseup", document, clearMinusHoldTimeout, {
            once: true
          });
        }
        let firstAddMousedownId = null;
        function handleAddMousedown() {
          clearAddHoldTimeout();
          firstAddMousedownId = window.setTimeout(() => {
            addHoldStateIntervalId = window.setInterval(() => {
              doAdd();
            }, HOLDING_CHANGE_INTERVAL);
          }, HOLDING_CHANGE_THRESHOLD);
          on("mouseup", document, clearAddHoldTimeout, {
            once: true
          });
        }
        const handleAddClick = () => {
          if (addHoldStateIntervalId)
            return;
          doAdd();
        };
        const handleMinusClick = () => {
          if (minusHoldStateIntervalId)
            return;
          doMinus();
        };
        function handleKeyDown(e) {
          if (e.key === "Enter") {
            if (e.target === inputInstRef.value?.wrapperElRef) {
              return;
            }
            const value = deriveValueFromDisplayedValue({
              offset: 0,
              doUpdateIfValid: true,
              isInputing: false,
              fixPrecision: true
            });
            if (value !== false) {
              inputInstRef.value?.deactivate();
            }
          } else if (e.key === "ArrowUp") {
            if (!addableRef.value)
              return;
            if (props.keyboard.ArrowUp === false)
              return;
            e.preventDefault();
            const value = deriveValueFromDisplayedValue({
              offset: 0,
              doUpdateIfValid: true,
              isInputing: false,
              fixPrecision: true
            });
            if (value !== false) {
              doAdd();
            }
          } else if (e.key === "ArrowDown") {
            if (!minusableRef.value)
              return;
            if (props.keyboard.ArrowDown === false)
              return;
            e.preventDefault();
            const value = deriveValueFromDisplayedValue({
              offset: 0,
              doUpdateIfValid: true,
              isInputing: false,
              fixPrecision: true
            });
            if (value !== false) {
              doMinus();
            }
          }
        }
        function handleUpdateDisplayedValue(value) {
          displayedValueRef.value = value;
          if (props.updateValueOnInput && !props.format && !props.parse && props.precision === void 0) {
            deriveValueFromDisplayedValue({
              offset: 0,
              doUpdateIfValid: true,
              isInputing: true,
              fixPrecision: false
            });
          }
        }
        vue.watch(mergedValueRef, () => {
          deriveDisplayedValueFromValue();
        });
        const exposedMethods = {
          focus: () => inputInstRef.value?.focus(),
          blur: () => inputInstRef.value?.blur()
        };
        const rtlEnabledRef = useRtl(
          "InputNumber",
          mergedRtlRef,
          mergedClsPrefixRef
        );
        return {
          ...exposedMethods,
          rtlEnabled: rtlEnabledRef,
          inputInstRef,
          minusButtonInstRef,
          addButtonInstRef,
          mergedClsPrefix: mergedClsPrefixRef,
          mergedBordered: mergedBorderedRef,
          uncontrolledValue: uncontrolledValueRef,
          mergedValue: mergedValueRef,
          mergedPlaceholder: mergedPlaceholderRef,
          displayedValueInvalid: displayedValueInvalidRef,
          mergedSize: mergedSizeRef,
          mergedDisabled: mergedDisabledRef,
          displayedValue: displayedValueRef,
          addable: addableRef,
          minusable: minusableRef,
          mergedStatus: mergedStatusRef,
          handleFocus,
          handleBlur,
          handleClear,
          handleMouseDown,
          handleAddClick,
          handleMinusClick,
          handleAddMousedown,
          handleMinusMousedown,
          handleKeyDown,
          handleUpdateDisplayedValue,
          mergedTheme: themeRef,
          inputThemeOverrides: {
            paddingSmall: "0 8px 0 10px",
            paddingMedium: "0 8px 0 12px",
            paddingLarge: "0 8px 0 14px"
          },
          buttonThemeOverrides: vue.computed(() => {
            const {
              self: { iconColorDisabled }
            } = themeRef.value;
            const [r, g, b, a] = rgba(iconColorDisabled);
            return {
              textColorTextDisabled: `rgb(${r}, ${g}, ${b})`,
              opacityDisabled: `${a}`
            };
          })
        };
      },
      render() {
        const { mergedClsPrefix, $slots } = this;
        const renderMinusButton = () => {
          return /* @__PURE__ */ vue.h(XButton, {
            text: true,
            disabled: !this.minusable || this.mergedDisabled || this.readonly,
            focusable: false,
            theme: this.mergedTheme.peers.Button,
            themeOverrides: this.mergedTheme.peerOverrides.Button,
            builtinThemeOverrides: this.buttonThemeOverrides,
            onClick: this.handleMinusClick,
            onMousedown: this.handleMinusMousedown,
            ref: "minusButtonInstRef"
          }, {
            icon: () => resolveSlot($slots["minus-icon"], () => [
              /* @__PURE__ */ vue.h(NBaseIcon, {
                clsPrefix: mergedClsPrefix
              }, {
                default: () => /* @__PURE__ */ vue.h(RemoveIcon, null)
              })
            ])
          });
        };
        const renderAddButton = () => {
          return /* @__PURE__ */ vue.h(XButton, {
            text: true,
            disabled: !this.addable || this.mergedDisabled || this.readonly,
            focusable: false,
            theme: this.mergedTheme.peers.Button,
            themeOverrides: this.mergedTheme.peerOverrides.Button,
            builtinThemeOverrides: this.buttonThemeOverrides,
            onClick: this.handleAddClick,
            onMousedown: this.handleAddMousedown,
            ref: "addButtonInstRef"
          }, {
            icon: () => resolveSlot($slots["add-icon"], () => [
              /* @__PURE__ */ vue.h(NBaseIcon, {
                clsPrefix: mergedClsPrefix
              }, {
                default: () => /* @__PURE__ */ vue.h(AddIcon, null)
              })
            ])
          });
        };
        return /* @__PURE__ */ vue.h("div", {
          class: [
            `${mergedClsPrefix}-input-number`,
            this.rtlEnabled && `${mergedClsPrefix}-input-number--rtl`
          ]
        }, /* @__PURE__ */ vue.h(NInput, {
          ref: "inputInstRef",
          autofocus: this.autofocus,
          status: this.mergedStatus,
          bordered: this.mergedBordered,
          loading: this.loading,
          value: this.displayedValue,
          onUpdateValue: this.handleUpdateDisplayedValue,
          theme: this.mergedTheme.peers.Input,
          themeOverrides: this.mergedTheme.peerOverrides.Input,
          builtinThemeOverrides: this.inputThemeOverrides,
          size: this.mergedSize,
          placeholder: this.mergedPlaceholder,
          disabled: this.mergedDisabled,
          readonly: this.readonly,
          textDecoration: this.displayedValueInvalid ? "line-through" : void 0,
          onFocus: this.handleFocus,
          onBlur: this.handleBlur,
          onKeydown: this.handleKeyDown,
          onMousedown: this.handleMouseDown,
          onClear: this.handleClear,
          clearable: this.clearable,
          internalLoadingBeforeSuffix: true
        }, {
          prefix: () => this.showButton && this.buttonPlacement === "both" ? [
            renderMinusButton(),
            resolveWrappedSlot($slots.prefix, (children) => {
              if (children) {
                return /* @__PURE__ */ vue.h("span", {
                  class: `${mergedClsPrefix}-input-number-prefix`
                }, children);
              }
              return null;
            })
          ] : $slots.prefix?.(),
          suffix: () => this.showButton ? [
            resolveWrappedSlot($slots.suffix, (children) => {
              if (children) {
                return /* @__PURE__ */ vue.h("span", {
                  class: `${mergedClsPrefix}-input-number-suffix`
                }, children);
              }
              return null;
            }),
            this.buttonPlacement === "right" ? renderMinusButton() : null,
            renderAddButton()
          ] : $slots.suffix?.()
        }));
      }
    });

    const layoutSiderInjectionKey = createInjectionKey("n-layout-sider");
    const positionProp = {
      type: String,
      default: "static"
    };

    var style$C = cB("layout", `
  color: var(--n-text-color);
  background-color: var(--n-color);
  box-sizing: border-box;
  position: relative;
  z-index: auto;
  flex: auto;
  overflow: hidden;
  transition:
    box-shadow .3s var(--n-bezier),
    background-color .3s var(--n-bezier),
    color .3s var(--n-bezier);
`, [cB("layout-scroll-container", `
    overflow-x: hidden;
    box-sizing: border-box;
    height: 100%;
  `), cM("absolute-positioned", `
    position: absolute;
    left: 0;
    right: 0;
    top: 0;
    bottom: 0;
  `)]);

    const layoutProps = {
      embedded: Boolean,
      position: positionProp,
      nativeScrollbar: {
        type: Boolean,
        default: true
      },
      scrollbarProps: Object,
      onScroll: Function,
      contentStyle: {
        type: [String, Object],
        default: ""
      },
      hasSider: Boolean,
      siderPlacement: {
        type: String,
        default: "left"
      }
    };
    const layoutInjectionKey = createInjectionKey("n-layout");
    function createLayoutComponent(isContent) {
      return vue.defineComponent({
        name: isContent ? "LayoutContent" : "Layout",
        props: {
          ...useTheme.props,
          ...layoutProps
        },
        setup(props) {
          const scrollableElRef = vue.ref(null);
          const scrollbarInstRef = vue.ref(null);
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme(
            "Layout",
            "-layout",
            style$C,
            layoutLight$1,
            props,
            mergedClsPrefixRef
          );
          function scrollTo(options, y) {
            if (props.nativeScrollbar) {
              const { value: scrollableEl } = scrollableElRef;
              if (scrollableEl) {
                if (y === void 0) {
                  scrollableEl.scrollTo(options);
                } else {
                  scrollableEl.scrollTo(options, y);
                }
              }
            } else {
              const { value: scrollbarInst } = scrollbarInstRef;
              if (scrollbarInst) {
                scrollbarInst.scrollTo(options, y);
              }
            }
          }
          vue.provide(layoutInjectionKey, props);
          let scrollX = 0;
          let scrollY = 0;
          const handleNativeElScroll = (e) => {
            const target = e.target;
            scrollX = target.scrollLeft;
            scrollY = target.scrollTop;
            props.onScroll?.(e);
          };
          useReactivated(() => {
            if (props.nativeScrollbar) {
              const el = scrollableElRef.value;
              if (el) {
                el.scrollTop = scrollY;
                el.scrollLeft = scrollX;
              }
            }
          });
          const hasSiderStyle = {
            display: "flex",
            flexWrap: "nowrap",
            width: "100%",
            flexDirection: "row"
          };
          const exposedMethods = {
            scrollTo
          };
          const cssVarsRef = vue.computed(() => {
            const {
              common: { cubicBezierEaseInOut },
              self
            } = themeRef.value;
            return {
              "--n-bezier": cubicBezierEaseInOut,
              "--n-color": props.embedded ? self.colorEmbedded : self.color,
              "--n-text-color": self.textColor
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass(
            "layout",
            vue.computed(() => {
              return props.embedded ? "e" : "";
            }),
            cssVarsRef,
            props
          ) : void 0;
          return {
            mergedClsPrefix: mergedClsPrefixRef,
            scrollableElRef,
            scrollbarInstRef,
            hasSiderStyle,
            mergedTheme: themeRef,
            handleNativeElScroll,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle?.themeClass,
            onRender: themeClassHandle?.onRender,
            ...exposedMethods
          };
        },
        render() {
          const { mergedClsPrefix, hasSider } = this;
          this.onRender?.();
          const hasSiderStyle = hasSider ? this.hasSiderStyle : void 0;
          const layoutClass = [
            this.themeClass,
            isContent && `${mergedClsPrefix}-layout-content`,
            `${mergedClsPrefix}-layout`,
            `${mergedClsPrefix}-layout--${this.position}-positioned`
          ];
          return /* @__PURE__ */ vue.h("div", {
            class: layoutClass,
            style: this.cssVars
          }, this.nativeScrollbar ? /* @__PURE__ */ vue.h("div", {
            ref: "scrollableElRef",
            class: `${mergedClsPrefix}-layout-scroll-container`,
            style: [this.contentStyle, hasSiderStyle],
            onScroll: this.handleNativeElScroll
          }, this.$slots) : /* @__PURE__ */ vue.h(NScrollbar, {
            ...this.scrollbarProps,
            onScroll: this.onScroll,
            ref: "scrollbarInstRef",
            theme: this.mergedTheme.peers.Scrollbar,
            themeOverrides: this.mergedTheme.peerOverrides.Scrollbar,
            contentStyle: [this.contentStyle, hasSiderStyle]
          }, this.$slots));
        }
      });
    }
    var Layout = createLayoutComponent(false);

    var LayoutContent = createLayoutComponent(true);

    var style$B = cB("layout-header", `
  transition:
    color .3s var(--n-bezier),
    background-color .3s var(--n-bezier),
    box-shadow .3s var(--n-bezier),
    border-color .3s var(--n-bezier);
  box-sizing: border-box;
  width: 100%;
  background-color: var(--n-color);
  color: var(--n-text-color);
`, [cM("absolute-positioned", `
    position: absolute;
    left: 0;
    right: 0;
    top: 0;
  `), cM("bordered", `
    border-bottom: solid 1px var(--n-border-color);
  `)]);

    const headerProps$1 = {
      position: positionProp,
      inverted: Boolean,
      bordered: {
        type: Boolean,
        default: false
      }
    };
    var LayoutHeader = vue.defineComponent({
      name: "LayoutHeader",
      props: {
        ...useTheme.props,
        ...headerProps$1
      },
      setup(props) {
        const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
        const themeRef = useTheme(
          "Layout",
          "-layout-header",
          style$B,
          layoutLight$1,
          props,
          mergedClsPrefixRef
        );
        const cssVarsRef = vue.computed(() => {
          const {
            common: { cubicBezierEaseInOut },
            self
          } = themeRef.value;
          const vars = {
            "--n-bezier": cubicBezierEaseInOut
          };
          if (props.inverted) {
            vars["--n-color"] = self.headerColorInverted;
            vars["--n-text-color"] = self.textColorInverted;
            vars["--n-border-color"] = self.headerBorderColorInverted;
          } else {
            vars["--n-color"] = self.headerColor;
            vars["--n-text-color"] = self.textColor;
            vars["--n-border-color"] = self.headerBorderColor;
          }
          return vars;
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass(
          "layout-header",
          vue.computed(() => props.inverted ? "a" : "b"),
          cssVarsRef,
          props
        ) : void 0;
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender
        };
      },
      render() {
        const { mergedClsPrefix } = this;
        this.onRender?.();
        return /* @__PURE__ */ vue.h("div", {
          class: [
            `${mergedClsPrefix}-layout-header`,
            this.themeClass,
            this.position && `${mergedClsPrefix}-layout-header--${this.position}-positioned`,
            this.bordered && `${mergedClsPrefix}-layout-header--bordered`
          ],
          style: this.cssVars
        }, this.$slots);
      }
    });

    var style$A = cB("layout-footer", `
  transition:
    box-shadow .3s var(--n-bezier),
    color .3s var(--n-bezier),
    background-color .3s var(--n-bezier),
    border-color .3s var(--n-bezier);
  color: var(--n-text-color);
  background-color: var(--n-color);
  box-sizing: border-box;
`, [cM("absolute-positioned", `
    position: absolute;
    left: 0;
    right: 0;
    bottom: 0;
  `), cM("bordered", `
    border-top: solid 1px var(--n-border-color);
  `)]);

    const layoutFooterProps = {
      ...useTheme.props,
      inverted: Boolean,
      position: positionProp,
      bordered: Boolean
    };
    var LayoutFooter = vue.defineComponent({
      name: "LayoutFooter",
      props: layoutFooterProps,
      setup(props) {
        const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
        const themeRef = useTheme(
          "Layout",
          "-layout-footer",
          style$A,
          layoutLight$1,
          props,
          mergedClsPrefixRef
        );
        const cssVarsRef = vue.computed(() => {
          const {
            common: { cubicBezierEaseInOut },
            self
          } = themeRef.value;
          const vars = {
            "--n-bezier": cubicBezierEaseInOut
          };
          if (props.inverted) {
            vars["--n-color"] = self.footerColorInverted;
            vars["--n-text-color"] = self.textColorInverted;
            vars["--n-border-color"] = self.footerBorderColorInverted;
          } else {
            vars["--n-color"] = self.footerColor;
            vars["--n-text-color"] = self.textColor;
            vars["--n-border-color"] = self.footerBorderColor;
          }
          return vars;
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass(
          "layout-footer",
          vue.computed(() => props.inverted ? "a" : "b"),
          cssVarsRef,
          props
        ) : void 0;
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender
        };
      },
      render() {
        const { mergedClsPrefix } = this;
        this.onRender?.();
        return /* @__PURE__ */ vue.h("div", {
          class: [
            `${mergedClsPrefix}-layout-footer`,
            this.themeClass,
            this.position && `${mergedClsPrefix}-layout-footer--${this.position}-positioned`,
            this.bordered && `${mergedClsPrefix}-layout-footer--bordered`
          ],
          style: this.cssVars
        }, this.$slots);
      }
    });

    var style$z = cB("layout-sider", `
  flex-shrink: 0;
  box-sizing: border-box;
  position: relative;
  z-index: 1;
  color: var(--n-text-color);
  transition:
    color .3s var(--n-bezier),
    border-color .3s var(--n-bezier),
    min-width .3s var(--n-bezier),
    max-width .3s var(--n-bezier),
    transform .3s var(--n-bezier),
    background-color .3s var(--n-bezier);
  background-color: var(--n-color);
  display: flex;
  justify-content: flex-end;
`, [cM("bordered", [cE("border", `
      content: "";
      position: absolute;
      top: 0;
      bottom: 0;
      width: 1px;
      background-color: var(--n-border-color);
      transition: background-color .3s var(--n-bezier);
    `)]), cE("left-placement", [cM("bordered", [cE("border", `
        right: 0;
      `)])]), cM("right-placement", `
    justify-content: flex-start;
  `, [cM("bordered", [cE("border", `
        left: 0;
      `)]), cM("collapsed", [cB("layout-toggle-button", [cB("base-icon", `
          transform: rotate(180deg);
        `)]), cB("layout-toggle-bar", [c$1("&:hover", [cE("top", {
      transform: "rotate(-12deg) scale(1.15) translateY(-2px)"
    }), cE("bottom", {
      transform: "rotate(12deg) scale(1.15) translateY(2px)"
    })])])]), cB("layout-toggle-button", `
      left: 0;
      transform: translateX(-50%) translateY(-50%);
    `, [cB("base-icon", `
        transform: rotate(0);
      `)]), cB("layout-toggle-bar", `
      left: -28px;
      transform: rotate(180deg);
    `, [c$1("&:hover", [cE("top", {
      transform: "rotate(12deg) scale(1.15) translateY(-2px)"
    }), cE("bottom", {
      transform: "rotate(-12deg) scale(1.15) translateY(2px)"
    })])])]), cM("collapsed", [cB("layout-toggle-bar", [c$1("&:hover", [cE("top", {
      transform: "rotate(-12deg) scale(1.15) translateY(-2px)"
    }), cE("bottom", {
      transform: "rotate(12deg) scale(1.15) translateY(2px)"
    })])]), cB("layout-toggle-button", [cB("base-icon", `
        transform: rotate(0);
      `)])]), cB("layout-toggle-button", `
    transition:
      color .3s var(--n-bezier),
      right .3s var(--n-bezier),
      left .3s var(--n-bezier),
      border-color .3s var(--n-bezier),
      background-color .3s var(--n-bezier);
    cursor: pointer;
    width: 24px;
    height: 24px;
    position: absolute;
    top: 50%;
    right: 0;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 18px;
    color: var(--n-toggle-button-icon-color);
    border: var(--n-toggle-button-border);
    background-color: var(--n-toggle-button-color);
    box-shadow: 0 2px 4px 0px rgba(0, 0, 0, .06);
    transform: translateX(50%) translateY(-50%);
    z-index: 1;
  `, [cB("base-icon", `
      transition: transform .3s var(--n-bezier);
      transform: rotate(180deg);
    `)]), cB("layout-toggle-bar", `
    cursor: pointer;
    height: 72px;
    width: 32px;
    position: absolute;
    top: calc(50% - 36px);
    right: -28px;
  `, [cE("top, bottom", `
      position: absolute;
      width: 4px;
      border-radius: 2px;
      height: 38px;
      left: 14px;
      transition:
        background-color .3s var(--n-bezier),
        transform .3s var(--n-bezier);
    `), cE("bottom", `
      position: absolute;
      top: 34px;
    `), c$1("&:hover", [cE("top", {
      transform: "rotate(12deg) scale(1.15) translateY(-2px)"
    }), cE("bottom", {
      transform: "rotate(-12deg) scale(1.15) translateY(2px)"
    })]), cE("top, bottom", {
      backgroundColor: "var(--n-toggle-bar-color)"
    }), c$1("&:hover", [cE("top, bottom", {
      backgroundColor: "var(--n-toggle-bar-color-hover)"
    })])]), cE("border", `
    position: absolute;
    top: 0;
    right: 0;
    bottom: 0;
    width: 1px;
    transition: background-color .3s var(--n-bezier);
  `), cB("layout-sider-scroll-container", `
    flex-grow: 1;
    flex-shrink: 0;
    box-sizing: border-box;
    height: 100%;
    opacity: 0;
    transition: opacity .3s var(--n-bezier);
    max-width: 100%;
  `), cM("show-content", [cB("layout-sider-scroll-container", {
      opacity: 1
    })]), cM("absolute-positioned", `
    position: absolute;
    left: 0;
    top: 0;
    bottom: 0;
  `)]);

    var ToggleButton = vue.defineComponent({
      name: "LayoutToggleButton",
      props: {
        clsPrefix: {
          type: String,
          required: true
        },
        onClick: Function
      },
      render() {
        const { clsPrefix } = this;
        return /* @__PURE__ */ vue.h("div", {
          class: `${clsPrefix}-layout-toggle-button`,
          onClick: this.onClick
        }, /* @__PURE__ */ vue.h(NBaseIcon, {
          clsPrefix
        }, {
          default: () => /* @__PURE__ */ vue.h(ChevronRightIcon, null)
        }));
      }
    });

    var ToggleBar = vue.defineComponent({
      props: {
        clsPrefix: {
          type: String,
          required: true
        },
        onClick: Function
      },
      render() {
        const { clsPrefix } = this;
        return /* @__PURE__ */ vue.h("div", {
          onClick: this.onClick,
          class: `${clsPrefix}-layout-toggle-bar`
        }, /* @__PURE__ */ vue.h("div", {
          class: `${clsPrefix}-layout-toggle-bar__top`
        }), /* @__PURE__ */ vue.h("div", {
          class: `${clsPrefix}-layout-toggle-bar__bottom`
        }));
      }
    });

    const layoutSiderProps = {
      position: positionProp,
      bordered: Boolean,
      collapsedWidth: {
        type: Number,
        default: 48
      },
      width: {
        type: [Number, String],
        default: 272
      },
      contentStyle: {
        type: [String, Object],
        default: ""
      },
      collapseMode: {
        type: String,
        default: "transform"
      },
      collapsed: {
        type: Boolean,
        default: void 0
      },
      defaultCollapsed: Boolean,
      showCollapsedContent: {
        type: Boolean,
        default: true
      },
      showTrigger: {
        type: [Boolean, String],
        default: false
      },
      nativeScrollbar: {
        type: Boolean,
        default: true
      },
      inverted: Boolean,
      scrollbarProps: Object,
      triggerStyle: [String, Object],
      collapsedTriggerStyle: [String, Object],
      "onUpdate:collapsed": [Function, Array],
      onUpdateCollapsed: [Function, Array],
      onAfterEnter: Function,
      onAfterLeave: Function,
      onExpand: [Function, Array],
      onCollapse: [Function, Array],
      onScroll: Function
    };
    var LayoutSider = vue.defineComponent({
      name: "LayoutSider",
      props: {
        ...useTheme.props,
        ...layoutSiderProps
      },
      setup(props) {
        const layoutProps = vue.inject(layoutInjectionKey);
        {
          if (!layoutProps) {
            warn$2(
              "layout-sider",
              "Layout sider is not allowed to be put outside layout."
            );
          } else {
            if (!layoutProps.hasSider) {
              warn$2(
                "layout-sider",
                "You are putting `n-layout-sider` in a `n-layout` but haven't set `has-sider` on the `n-layout`."
              );
            }
          }
        }
        const scrollableElRef = vue.ref(null);
        const scrollbarInstRef = vue.ref(null);
        const styleMaxWidthRef = vue.computed(() => {
          return formatLength(
            mergedCollapsedRef.value ? props.collapsedWidth : props.width
          );
        });
        const scrollContainerStyleRef = vue.computed(() => {
          if (props.collapseMode !== "transform")
            return {};
          return {
            minWidth: formatLength(props.width)
          };
        });
        const siderPlacementRef = vue.computed(() => {
          return layoutProps ? layoutProps.siderPlacement : "left";
        });
        const uncontrolledCollapsedRef = vue.ref(props.defaultCollapsed);
        const mergedCollapsedRef = useMergedState(
          vue.toRef(props, "collapsed"),
          uncontrolledCollapsedRef
        );
        function scrollTo(options, y) {
          if (props.nativeScrollbar) {
            const { value: scrollableEl } = scrollableElRef;
            if (scrollableEl) {
              if (y === void 0) {
                scrollableEl.scrollTo(options);
              } else {
                scrollableEl.scrollTo(options, y);
              }
            }
          } else {
            const { value: scrollbarInst } = scrollbarInstRef;
            if (scrollbarInst) {
              scrollbarInst.scrollTo(options, y);
            }
          }
        }
        function handleTriggerClick() {
          const {
            "onUpdate:collapsed": _onUpdateCollapsed,
            onUpdateCollapsed,
            onExpand,
            onCollapse
          } = props;
          const { value: collapsed } = mergedCollapsedRef;
          if (onUpdateCollapsed) {
            call(onUpdateCollapsed, !collapsed);
          }
          if (_onUpdateCollapsed) {
            call(_onUpdateCollapsed, !collapsed);
          }
          uncontrolledCollapsedRef.value = !collapsed;
          if (collapsed) {
            if (onExpand)
              call(onExpand);
          } else {
            if (onCollapse)
              call(onCollapse);
          }
        }
        let scrollX = 0;
        let scrollY = 0;
        const handleNativeElScroll = (e) => {
          const target = e.target;
          scrollX = target.scrollLeft;
          scrollY = target.scrollTop;
          props.onScroll?.(e);
        };
        useReactivated(() => {
          if (props.nativeScrollbar) {
            const el = scrollableElRef.value;
            if (el) {
              el.scrollTop = scrollY;
              el.scrollLeft = scrollX;
            }
          }
        });
        vue.provide(layoutSiderInjectionKey, {
          collapsedRef: mergedCollapsedRef,
          collapseModeRef: vue.toRef(props, "collapseMode")
        });
        const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
        const themeRef = useTheme(
          "Layout",
          "-layout-sider",
          style$z,
          layoutLight$1,
          props,
          mergedClsPrefixRef
        );
        function handleTransitionend(e) {
          if (e.propertyName === "max-width") {
            if (mergedCollapsedRef.value) {
              props.onAfterLeave?.();
            } else {
              props.onAfterEnter?.();
            }
          }
        }
        const exposedMethods = {
          scrollTo
        };
        const cssVarsRef = vue.computed(() => {
          const {
            common: { cubicBezierEaseInOut },
            self
          } = themeRef.value;
          const {
            siderToggleButtonColor,
            siderToggleButtonBorder,
            siderToggleBarColor,
            siderToggleBarColorHover
          } = self;
          const vars = {
            "--n-bezier": cubicBezierEaseInOut,
            "--n-toggle-button-color": siderToggleButtonColor,
            "--n-toggle-button-border": siderToggleButtonBorder,
            "--n-toggle-bar-color": siderToggleBarColor,
            "--n-toggle-bar-color-hover": siderToggleBarColorHover
          };
          if (props.inverted) {
            vars["--n-color"] = self.siderColorInverted;
            vars["--n-text-color"] = self.textColorInverted;
            vars["--n-border-color"] = self.siderBorderColorInverted;
            vars["--n-toggle-button-icon-color"] = self.siderToggleButtonIconColorInverted;
            vars.__invertScrollbar = self.__invertScrollbar;
          } else {
            vars["--n-color"] = self.siderColor;
            vars["--n-text-color"] = self.textColor;
            vars["--n-border-color"] = self.siderBorderColor;
            vars["--n-toggle-button-icon-color"] = self.siderToggleButtonIconColor;
          }
          return vars;
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass(
          "layout-sider",
          vue.computed(() => props.inverted ? "a" : "b"),
          cssVarsRef,
          props
        ) : void 0;
        return {
          scrollableElRef,
          scrollbarInstRef,
          mergedClsPrefix: mergedClsPrefixRef,
          mergedTheme: themeRef,
          styleMaxWidth: styleMaxWidthRef,
          mergedCollapsed: mergedCollapsedRef,
          scrollContainerStyle: scrollContainerStyleRef,
          siderPlacement: siderPlacementRef,
          handleNativeElScroll,
          handleTransitionend,
          handleTriggerClick,
          inlineThemeDisabled,
          cssVars: cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender,
          ...exposedMethods
        };
      },
      render() {
        const { mergedClsPrefix, mergedCollapsed, showTrigger } = this;
        this.onRender?.();
        return /* @__PURE__ */ vue.h("aside", {
          class: [
            `${mergedClsPrefix}-layout-sider`,
            this.themeClass,
            `${mergedClsPrefix}-layout-sider--${this.position}-positioned`,
            `${mergedClsPrefix}-layout-sider--${this.siderPlacement}-placement`,
            this.bordered && `${mergedClsPrefix}-layout-sider--bordered`,
            mergedCollapsed && `${mergedClsPrefix}-layout-sider--collapsed`,
            (!mergedCollapsed || this.showCollapsedContent) && `${mergedClsPrefix}-layout-sider--show-content`
          ],
          onTransitionend: this.handleTransitionend,
          style: [
            this.inlineThemeDisabled ? void 0 : this.cssVars,
            {
              maxWidth: this.styleMaxWidth,
              width: formatLength(this.width)
            }
          ]
        }, !this.nativeScrollbar ? /* @__PURE__ */ vue.h(NScrollbar, {
          ...this.scrollbarProps,
          onScroll: this.onScroll,
          ref: "scrollbarInstRef",
          style: this.scrollContainerStyle,
          contentStyle: this.contentStyle,
          theme: this.mergedTheme.peers.Scrollbar,
          themeOverrides: this.mergedTheme.peerOverrides.Scrollbar,
          builtinThemeOverrides: this.inverted && this.cssVars.__invertScrollbar === "true" ? {
            colorHover: "rgba(255, 255, 255, .4)",
            color: "rgba(255, 255, 255, .3)"
          } : void 0
        }, this.$slots) : /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-layout-sider-scroll-container`,
          onScroll: this.handleNativeElScroll,
          style: [
            this.scrollContainerStyle,
            {
              overflow: "auto"
            },
            this.contentStyle
          ],
          ref: "scrollableElRef"
        }, this.$slots), showTrigger ? showTrigger === "bar" ? /* @__PURE__ */ vue.h(ToggleBar, {
          clsPrefix: mergedClsPrefix,
          style: mergedCollapsed ? this.collapsedTriggerStyle : this.triggerStyle,
          onClick: this.handleTriggerClick
        }) : /* @__PURE__ */ vue.h(ToggleButton, {
          clsPrefix: mergedClsPrefix,
          style: mergedCollapsed ? this.collapsedTriggerStyle : this.triggerStyle,
          onClick: this.handleTriggerClick
        }) : null, this.bordered ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-layout-sider__border`
        }) : null);
      }
    });

    var commonVariables = {
      extraFontSize: "12px",
      width: "440px"
    };

    const transferDark = {
      name: "Transfer",
      common: commonDark,
      peers: {
        Checkbox: checkboxDark$1,
        Scrollbar: scrollbarDark$1,
        Input: inputDark$1,
        Empty: emptyDark$1,
        Button: buttonDark$1
      },

      self(vars) {
        const {
          iconColorDisabled,
          iconColor,
          fontWeight,
          fontSizeLarge,
          fontSizeMedium,
          fontSizeSmall,
          heightLarge,
          heightMedium,
          heightSmall,
          borderRadius,
          inputColor,
          tableHeaderColor,
          textColor1,
          textColorDisabled,
          textColor2,
          hoverColor
        } = vars;
        return { ...commonVariables,
          itemHeightSmall: heightSmall,
          itemHeightMedium: heightMedium,
          itemHeightLarge: heightLarge,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          borderRadius,
          borderColor: "#0000",
          listColor: inputColor,
          headerColor: tableHeaderColor,
          titleTextColor: textColor1,
          titleTextColorDisabled: textColorDisabled,
          extraTextColor: textColor2,
          filterDividerColor: "#0000",
          itemTextColor: textColor2,
          itemTextColorDisabled: textColorDisabled,
          itemColorPending: hoverColor,
          titleFontWeight: fontWeight,
          iconColor,
          iconColorDisabled
        };
      }

    };
    var legacyTransferDark = transferDark;

    const self$2 = vars => {
      const {
        fontWeight,
        iconColorDisabled,
        iconColor,
        fontSizeLarge,
        fontSizeMedium,
        fontSizeSmall,
        heightLarge,
        heightMedium,
        heightSmall,
        borderRadius,
        cardColor,
        tableHeaderColor,
        textColor1,
        textColorDisabled,
        textColor2,
        borderColor,
        hoverColor
      } = vars;
      return { ...commonVariables,
        itemHeightSmall: heightSmall,
        itemHeightMedium: heightMedium,
        itemHeightLarge: heightLarge,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        borderRadius,
        borderColor,
        listColor: cardColor,
        headerColor: composite(cardColor, tableHeaderColor),
        titleTextColor: textColor1,
        titleTextColorDisabled: textColorDisabled,
        extraTextColor: textColor2,
        filterDividerColor: borderColor,
        itemTextColor: textColor2,
        itemTextColorDisabled: textColorDisabled,
        itemColorPending: hoverColor,
        titleFontWeight: fontWeight,
        iconColor,
        iconColorDisabled
      };
    };

    const transferLight = createTheme$1({
      name: "Transfer",
      common: commonLight,
      peers: {
        Checkbox: checkboxLight$1,
        Scrollbar: scrollbarLight$1,
        Input: inputLight$1,
        Empty: emptyLight$1,
        Button: buttonLight$1
      },
      self: self$2
    });
    var legacyTransferLight = transferLight;

    const transferInjectionKey$1 = createInjectionKey("n-transfer");

    var NTransferHeader$1 = vue.defineComponent({
      name: "TransferHeader",
      props: {
        source: {
          type: Boolean,
          default: false
        },
        onChange: {
          type: Function,
          required: true
        },
        title: String
      },
      setup(props) {
        const {
          srcOptsRef,
          tgtOptsRef,
          srcCheckedStatusRef,
          tgtCheckedStatusRef,
          srcCheckedValuesRef,
          tgtCheckedValuesRef,
          mergedThemeRef,
          disabledRef,
          mergedClsPrefixRef
        } = vue.inject(transferInjectionKey$1);
        const checkboxPropsRef = vue.computed(() => {
          const { source } = props;
          if (source) {
            return srcCheckedStatusRef.value;
          } else {
            return tgtCheckedStatusRef.value;
          }
        });
        return () => {
          const { source } = props;
          const { value: checkboxProps } = checkboxPropsRef;
          const { value: mergedTheme } = mergedThemeRef;
          const { value: mergedClsPrefix } = mergedClsPrefixRef;
          return /* @__PURE__ */ vue.h("div", {
            class: `${mergedClsPrefix}-legacy-transfer-list-header`
          }, /* @__PURE__ */ vue.h("div", {
            class: `${mergedClsPrefix}-legacy-transfer-list-header__checkbox`
          }, /* @__PURE__ */ vue.h(NCheckbox, {
            theme: mergedTheme.peers.Checkbox,
            themeOverrides: mergedTheme.peerOverrides.Checkbox,
            checked: checkboxProps.checked,
            indeterminate: checkboxProps.indeterminate,
            disabled: checkboxProps.disabled || disabledRef.value,
            onUpdateChecked: props.onChange
          })), /* @__PURE__ */ vue.h("div", {
            class: `${mergedClsPrefix}-legacy-transfer-list-header__header`
          }, props.title), /* @__PURE__ */ vue.h("div", {
            class: `${mergedClsPrefix}-legacy-transfer-list-header__extra`
          }, source ? srcCheckedValuesRef.value.length : tgtCheckedValuesRef.value.length, "/", source ? srcOptsRef.value.length : tgtOptsRef.value.length));
        };
      }
    });

    var NTransferListItem$1 = vue.defineComponent({
      name: "NTransferListItem",
      props: {
        source: {
          type: Boolean,
          default: false
        },
        label: {
          type: String,
          required: true
        },
        value: {
          type: [String, Number],
          required: true
        },
        disabled: {
          type: Boolean,
          default: false
        }
      },
      setup(props) {
        const { source } = props;
        const {
          mergedClsPrefixRef,
          mergedThemeRef,
          srcCheckedValuesRef,
          tgtCheckedValuesRef,
          handleSrcCheckboxClick,
          handleTgtCheckboxClick
        } = vue.inject(transferInjectionKey$1);
        const checkedRef = source ? useMemo(() => srcCheckedValuesRef.value.includes(props.value)) : useMemo(() => tgtCheckedValuesRef.value.includes(props.value));
        const handleClick = source ? () => {
          if (!props.disabled) {
            handleSrcCheckboxClick(!checkedRef.value, props.value);
          }
        } : () => {
          if (!props.disabled) {
            handleTgtCheckboxClick(!checkedRef.value, props.value);
          }
        };
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          mergedTheme: mergedThemeRef,
          checked: checkedRef,
          handleClick
        };
      },
      render() {
        const { disabled, mergedTheme, mergedClsPrefix, label, checked, source } = this;
        return /* @__PURE__ */ vue.h("div", {
          class: [
            `${mergedClsPrefix}-legacy-transfer-list-item`,
            disabled && `${mergedClsPrefix}-legacy-transfer-list-item--disabled`,
            source ? `${mergedClsPrefix}-legacy-transfer-list-item--source` : `${mergedClsPrefix}-legacy-transfer-list-item--target`
          ],
          onClick: this.handleClick
        }, /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-legacy-transfer-list-item__checkbox`
        }, /* @__PURE__ */ vue.h(NCheckbox, {
          theme: mergedTheme.peers.Checkbox,
          themeOverrides: mergedTheme.peerOverrides.Checkbox,
          disabled,
          checked
        })), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-legacy-transfer-list-item__label`,
          title: getTitleAttribute(label)
        }, label));
      }
    });

    var NTransferList$1 = vue.defineComponent({
      name: "TransferList",
      props: {
        virtualScroll: {
          type: Boolean,
          required: true
        },
        itemSize: {
          type: Number,
          required: true
        },
        options: {
          type: Array,
          required: true
        },
        disabled: {
          type: Boolean,
          required: true
        },
        isMounted: {
          type: Boolean,
          required: true
        },
        isInputing: {
          type: Boolean,
          required: true
        },
        source: {
          type: Boolean,
          default: false
        }
      },
      setup() {
        const { mergedThemeRef, mergedClsPrefixRef } = vue.inject(transferInjectionKey$1);
        const scrollerInstRef = vue.ref(null);
        const vlInstRef = vue.ref(null);
        function syncVLScroller() {
          scrollerInstRef.value?.sync();
        }
        function scrollContainer() {
          const { value } = vlInstRef;
          if (!value)
            return null;
          const { listElRef } = value;
          return listElRef;
        }
        function scrollContent() {
          const { value } = vlInstRef;
          if (!value)
            return null;
          const { itemsElRef } = value;
          return itemsElRef;
        }
        return {
          mergedTheme: mergedThemeRef,
          mergedClsPrefix: mergedClsPrefixRef,
          scrollerInstRef,
          vlInstRef,
          syncVLScroller,
          scrollContainer,
          scrollContent
        };
      },
      render() {
        const { mergedTheme, mergedClsPrefix, virtualScroll, syncVLScroller } = this;
        return /* @__PURE__ */ vue.h(vue.Fragment, null, /* @__PURE__ */ vue.h(NScrollbar, {
          ref: "scrollerInstRef",
          theme: mergedTheme.peers.Scrollbar,
          themeOverrides: mergedTheme.peerOverrides.Scrollbar,
          container: virtualScroll ? this.scrollContainer : void 0,
          content: virtualScroll ? this.scrollContent : void 0
        }, {
          default: () => virtualScroll ? /* @__PURE__ */ vue.h(VVirtualList, {
            ref: "vlInstRef",
            style: { height: "100%" },
            class: `${mergedClsPrefix}-legacy-transfer-list-content`,
            items: this.options,
            itemSize: this.itemSize,
            showScrollbar: false,
            onResize: syncVLScroller,
            onScroll: syncVLScroller,
            keyField: "value"
          }, {
            default: ({ item }) => {
              const { source, disabled } = this;
              return /* @__PURE__ */ vue.h(NTransferListItem$1, {
                source,
                key: item.value,
                value: item.value,
                disabled: item.disabled || disabled,
                label: item.label
              });
            }
          }) : /* @__PURE__ */ vue.h("div", {
            class: `${mergedClsPrefix}-legacy-transfer-list-content`
          }, /* @__PURE__ */ vue.h(vue.TransitionGroup, {
            name: "item",
            appear: this.isMounted,
            css: !this.isInputing
          }, {
            default: () => {
              const { source, disabled } = this;
              return this.options.map((option) => /* @__PURE__ */ vue.h(NTransferListItem$1, {
                source,
                key: option.value,
                value: option.value,
                disabled: option.disabled || disabled,
                label: option.label
              }));
            }
          }))
        }), /* @__PURE__ */ vue.h(vue.Transition, {
          name: "fade-in-transition",
          appear: this.isMounted,
          css: !this.isInputing
        }, {
          default: () => this.options.length ? null : /* @__PURE__ */ vue.h(NEmpty, {
            theme: mergedTheme.peers.Empty,
            themeOverrides: mergedTheme.peerOverrides.Empty
          })
        }));
      }
    });

    var NTransferFilter$1 = vue.defineComponent({
      name: "TransferFilter",
      props: {
        value: String,
        placeholder: String,
        disabled: Boolean,
        onFocus: {
          type: Function,
          required: true
        },
        onBlur: {
          type: Function,
          required: true
        },
        onUpdateValue: {
          type: Function,
          required: true
        }
      },
      setup() {
        const { mergedThemeRef, mergedClsPrefixRef } = vue.inject(transferInjectionKey$1);
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          mergedTheme: mergedThemeRef
        };
      },
      render() {
        const { mergedTheme, mergedClsPrefix } = this;
        return /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-legacy-transfer-filter`
        }, /* @__PURE__ */ vue.h(NInput, {
          value: this.value,
          onUpdateValue: this.onUpdateValue,
          disabled: this.disabled,
          theme: mergedTheme.peers.Input,
          themeOverrides: mergedTheme.peerOverrides.Input,
          clearable: true,
          size: "small",
          placeholder: this.placeholder,
          onFocus: this.onFocus,
          onBlur: this.onBlur
        }, {
          "clear-icon-placeholder": () => /* @__PURE__ */ vue.h(NBaseIcon, {
            clsPrefix: mergedClsPrefix,
            class: `${mergedClsPrefix}-legacy-transfer-icon`
          }, { default: () => /* @__PURE__ */ vue.h(SearchIcon, null) })
        }));
      }
    });

    function useTransferData$1(props, mergedDisabledRef) {
      const uncontrolledValueRef = vue.ref(props.defaultValue);
      const controlledValueRef = vue.toRef(props, "value");
      const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
      const optMapRef = vue.computed(() => {
        const map = /* @__PURE__ */new Map();
        (props.options || []).forEach(opt => map.set(opt.value, opt));
        return map;
      });
      const tgtValueSetRef = vue.computed(() => new Set(mergedValueRef.value || []));
      const srcOptsRef = vue.computed(() => props.options.filter(option => !tgtValueSetRef.value.has(option.value)));
      const tgtOptsRef = vue.computed(() => {
        const optMap = optMapRef.value;
        return (mergedValueRef.value || []).map(v => optMap.get(v));
      });
      const srcPatternRef = vue.ref("");
      const tgtPatternRef = vue.ref("");
      const filteredSrcOptsRef = vue.computed(() => {
        if (!props.filterable) return srcOptsRef.value;
        const {
          filter
        } = props;
        return srcOptsRef.value.filter(opt => filter(srcPatternRef.value, opt, "source"));
      });
      const filteredTgtOptsRef = vue.computed(() => {
        if (!props.filterable) return tgtOptsRef.value;
        const {
          filter
        } = props;
        return tgtOptsRef.value.filter(opt => filter(tgtPatternRef.value, opt, "target"));
      });
      const avlSrcValueSetRef = vue.computed(() => new Set(filteredSrcOptsRef.value.filter(opt => !opt.disabled).map(opt => opt.value)));
      const avlTgtValueSetRef = vue.computed(() => new Set(filteredTgtOptsRef.value.filter(opt => !opt.disabled).map(opt => opt.value)));
      const srcCheckedValuesRef = vue.ref([]);
      const tgtCheckedValuesRef = vue.ref([]);
      const srcCheckedStatusRef = vue.computed(() => {
        const srcCheckedLength = srcCheckedValuesRef.value.filter(v => avlSrcValueSetRef.value.has(v)).length;
        const avlValueCount = avlSrcValueSetRef.value.size;

        if (avlValueCount === 0) {
          return {
            checked: false,
            indeterminate: false,
            disabled: true
          };
        } else if (srcCheckedLength === 0) {
          return {
            checked: false,
            indeterminate: false
          };
        } else if (srcCheckedLength === avlValueCount) {
          return {
            checked: true,
            indeterminate: false
          };
        } else {
          return {
            checked: false,
            indeterminate: true
          };
        }
      });
      const tgtCheckedStatusRef = vue.computed(() => {
        const tgtCheckedLength = tgtCheckedValuesRef.value.filter(v => avlTgtValueSetRef.value.has(v)).length;
        const avlValueCount = avlTgtValueSetRef.value.size;

        if (avlValueCount === 0) {
          return {
            checked: false,
            indeterminate: false,
            disabled: true
          };
        } else if (tgtCheckedLength === 0) {
          return {
            checked: false,
            indeterminate: false
          };
        } else if (tgtCheckedLength === avlValueCount) {
          return {
            checked: true,
            indeterminate: false
          };
        } else {
          return {
            checked: false,
            indeterminate: true
          };
        }
      });
      const fromButtonDisabledRef = useMemo(() => {
        if (mergedDisabledRef.value) return true;
        return tgtCheckedValuesRef.value.length === 0;
      });
      const toButtonDisabledRef = useMemo(() => {
        if (mergedDisabledRef.value) return true;
        return srcCheckedValuesRef.value.length === 0;
      });
      const isInputingRef = vue.ref(false);

      function handleInputFocus() {
        isInputingRef.value = true;
      }

      function handleInputBlur() {
        isInputingRef.value = false;
      }

      function handleSrcFilterUpdateValue(value) {
        srcPatternRef.value = value ?? "";
      }

      function handleTgtFilterUpdateValue(value) {
        tgtPatternRef.value = value ?? "";
      }

      return {
        uncontrolledValue: uncontrolledValueRef,
        mergedValue: mergedValueRef,
        avlSrcValueSet: avlSrcValueSetRef,
        avlTgtValueSet: avlTgtValueSetRef,
        tgtOpts: tgtOptsRef,
        srcOpts: srcOptsRef,
        filteredSrcOpts: filteredSrcOptsRef,
        filteredTgtOpts: filteredTgtOptsRef,
        srcCheckedValues: srcCheckedValuesRef,
        tgtCheckedValues: tgtCheckedValuesRef,
        srcCheckedStatus: srcCheckedStatusRef,
        tgtCheckedStatus: tgtCheckedStatusRef,
        srcPattern: srcPatternRef,
        tgtPattern: tgtPatternRef,
        isInputing: isInputingRef,
        fromButtonDisabled: fromButtonDisabledRef,
        toButtonDisabled: toButtonDisabledRef,
        handleInputFocus,
        handleInputBlur,
        handleTgtFilterUpdateValue,
        handleSrcFilterUpdateValue
      };
    }

    const animation = c$1([c$1("@keyframes legacy-transfer-slide-in-from-left", `
    0% {
      transform: translateX(-150%);
    }
    100% {
      transform: translateX(0);
    }
  `), c$1("@keyframes legacy-transfer-slide-out-to-right", `
    0% {
      transform: translateX(0);
    }
    100% {
      transform: translateX(150%);
    }
  `), c$1("@keyframes legacy-transfer-slide-in-from-right", `
    0% {
      transform: translateX(150%);
    }
    100% {
      transform: translateX(0);
    }
  `), c$1("@keyframes legacy-transfer-slide-out-to-left", `
    0% {
      transform: translateX(0);
    }
    100% {
      transform: translateX(-150%);
    }
  `), c$1("@keyframes legacy-transfer-height-collapse", `
    0% {
      max-height: var(--n-item-height);
    }
    100% {
      max-height: 0;
    }
  `), c$1("@keyframes legacy-transfer-height-expand", `
    0% {
      max-height: 0;
    }
    100% {
      max-height: var(--n-item-height);
    }
  `)]);
    var style$y = c$1([cB("legacy-transfer", `
    display: flex;
    width: var(--n-width);
    font-size: var(--n-font-size);
    height: 240px;
    display: flex;
    flex-wrap: nowrap;
  `, [cB("legacy-transfer-icon", `
      color: var(--n-icon-color);
      transition: color .3s var(--n-bezier);
    `), cM("disabled", [cB("legacy-transfer-icon", {
      color: "var(--n-icon-color-disabled)"
    })]), cB("legacy-transfer-list", `
      height: inherit;
      display: flex;
      flex-direction: column;
      background-clip: padding-box;
      width: calc(50% - 36px);
      position: relative;
      transition: background-color .3s var(--n-bezier);
      border-radius: var(--n-border-radius);
      background-color: var(--n-list-color);
    `, [cE("border", `
        border: 1px solid var(--n-border-color);
        transition: border-color .3s var(--n-bezier);
        pointer-events: none;
        border-radius: inherit;
        position: absolute;
        left: 0;
        right: 0;
        top: 0;
        bottom: 0;
      `), cB("legacy-transfer-list-header", `
        height: calc(var(--n-item-height) + 4px);
        box-sizing: border-box;
        display: flex;
        align-items: center;
        background-clip: padding-box;
        border-radius: inherit;
        border-bottom-left-radius: 0;
        border-bottom-right-radius: 0;
        background-color: var(--n-header-color);
        transition:
          border-color .3s var(--n-bezier),
          background-color .3s var(--n-bezier);
      `, [cE("checkbox", `
          display: flex;
          align-items: center;
          position: relative;
          padding: 0 9px 0 14px;
        `), cE("header", `
          flex: 1;
          line-height: 1;
          font-weight: var(--n-header-font-weight);
          transition: color .3s var(--n-bezier);
          color: var(--n-header-text-color);
        `, [cM("disabled", {
      color: "var(--n-header-text-color-disabled)"
    })]), cE("extra", `
          transition: color .3s var(--n-bezier);
          font-size: var(--n-extra-font-size);
          justify-self: flex-end;
          margin-right: 14px;
          white-space: nowrap;
          color: var(--n-header-extra-text-color);
        `)]), cB("legacy-transfer-list-body", `
        flex-basis: 0;
        flex-grow: 1;
        box-sizing: border-box;
        position: relative;
        display: flex;
        flex-direction: column;
        border-radius: inherit;
        border-top-left-radius: 0;
        border-top-right-radius: 0;
      `, [cB("legacy-transfer-filter", `
          padding: 0 8px 8px 8px;
          box-sizing: border-box;
          background-color: var(--n-header-color);
          transition:
            border-color .3s var(--n-bezier),
            background-color .3s var(--n-bezier);
          border-bottom: 1px solid var(--n-filter-divider-color);
        `), cB("legacy-transfer-list-flex-container", `
          flex: 1;
          position: relative;
        `, [cB("scrollbar", `
            position: absolute;
            left: 0;
            right: 0;
            top: 0;
            bottom: 0;
            height: unset;
          `, [cB("scrollbar-content", {
      width: "100%"
    })]), cB("empty", `
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translateY(-50%) translateX(-50%);
          `, [fadeInTransition()]), cB("legacy-transfer-list-content", `
            padding: 0;
            margin: 0;
            position: relative;
          `, [cM("transition-disabled", [cB("legacy-transfer-list-item", {
      animation: "none !important"
    })]), cB("legacy-transfer-list-item", `
              height: var(--n-item-height);
              max-height: var(--n-item-height);
                transition:
                  background-color .3s var(--n-bezier),
                  color .3s var(--n-bezier);
              position: relative;
              cursor: pointer;
              display: flex;
              align-items: center;
              color: var(--n-item-text-color);
            `, [cNotM("disabled", [c$1("&:hover", {
      backgroundColor: "var(--n-item-color-pending)"
    })]), cE("extra", `
                text-overflow: ellipsis;
                overflow: hidden;
                white-space: nowrap;
                padding-right: 4px;
              `), cE("checkbox", `
                display: flex;
                align-items: center;
                position: relative;
                padding: 0 9px 0 14px;
              `), cM("disabled", `
                cursor: not-allowed
                background-color: #0000;
                color: var(--n-item-text-color-disabled);
              `), cM("source", {
      animationFillMode: "forwards"
    }, [c$1("&.item-enter-active", `
                  transform: translateX(150%);
                  animation-duration: .25s, .25s;
                  animation-timing-function: var(--n-bezier), var(--n-bezier-ease-out);
                  animation-delay: 0s, .25s;
                  animation-name: legacy-transfer-height-expand, legacy-transfer-slide-in-from-right;
                `), c$1("&.item-leave-active", `
                  transform: translateX(-150%);
                  animation-duration: .25s, .25s;
                  animation-timing-function: var(--n-bezier), var(--n-bezier-ease-in);
                  animation-delay: .25s, 0s;
                  animation-name: legacy-transfer-height-collapse, legacy-transfer-slide-out-to-right;
                `)]), cM("target", {
      animationFillMode: "forwards"
    }, [c$1("&.item-enter-active", `
                  transform: translateX(-150%);
                  animation-duration: .25s, .25s;
                  animation-timing-function: var(--n-bezier), var(--n-bezier-ease-out);
                  animation-delay: 0s, .25s;
                  animation-name: legacy-transfer-height-expand, legacy-transfer-slide-in-from-left;
                `), c$1("&.item-leave-active", `
                  transform: translateX(150%);
                  animation-duration: .25s, .25s;
                  animation-timing-function: var(--n-bezier), var(--n-bezier-ease-in);
                  animation-delay: .25s, 0s;
                  animation-name: legacy-transfer-height-collapse, legacy-transfer-slide-out-to-left;
                `)])])])])])]), cB("legacy-transfer-gap", {
      width: "72px",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      flexDirection: "column"
    }), cB("button", [c$1("&:first-child", {
      marginBottom: "12px"
    })])]), animation]);

    const transferProps$1 = {
      ...useTheme.props,
      value: Array,
      defaultValue: {
        type: Array,
        default: null
      },
      options: {
        type: Array,
        default: () => []
      },
      disabled: {
        type: Boolean,
        default: void 0
      },
      virtualScroll: Boolean,
      sourceTitle: String,
      targetTitle: String,
      filterable: Boolean,
      sourceFilterPlaceholder: String,
      targetFilterPlaceholder: String,
      filter: {
        type: Function,
        default: (pattern, option) => {
          if (!pattern)
            return true;
          return ~("" + option.label).toLowerCase().indexOf(("" + pattern).toLowerCase());
        }
      },
      size: String,
      "onUpdate:value": [Function, Array],
      onUpdateValue: [Function, Array],
      onChange: [Function, Array]
    };
    var Transfer$1 = vue.defineComponent({
      name: "LegacyTransfer",
      props: transferProps$1,
      setup(props) {
        {
          vue.watchEffect(() => {
            if (props.onChange !== void 0) {
              warnOnce(
                "legacy-transfer",
                "`on-change` is deprecated, please use `on-update:value` instead."
              );
            }
          });
        }
        const { mergedClsPrefixRef } = useConfig(props);
        const themeRef = useTheme(
          "LegacyTransfer",
          "-legacy-transfer",
          style$y,
          legacyTransferLight,
          props,
          mergedClsPrefixRef
        );
        const formItem = useFormItem(props);
        const { mergedSizeRef, mergedDisabledRef } = formItem;
        const itemSizeRef = vue.computed(() => {
          const { value: size } = mergedSizeRef;
          const {
            self: { [createKey("itemHeight", size)]: itemSize }
          } = themeRef.value;
          return depx(itemSize);
        });
        const {
          uncontrolledValue: uncontrolledValueRef,
          mergedValue: mergedValueRef,
          avlSrcValueSet: avlSrcValueSetRef,
          avlTgtValueSet: avlTgtValueSetRef,
          tgtOpts: tgtOptsRef,
          srcOpts: srcOptsRef,
          filteredSrcOpts: filteredSrcOptsRef,
          filteredTgtOpts: filteredTgtOptsRef,
          srcCheckedValues: srcCheckedValuesRef,
          tgtCheckedValues: tgtCheckedValuesRef,
          srcCheckedStatus: srcCheckedStatusRef,
          tgtCheckedStatus: tgtCheckedStatusRef,
          srcPattern: srcPatternRef,
          tgtPattern: tgtPatternRef,
          isInputing: isInputingRef,
          fromButtonDisabled: fromButtonDisabledRef,
          toButtonDisabled: toButtonDisabledRef,
          handleInputFocus,
          handleInputBlur,
          handleTgtFilterUpdateValue,
          handleSrcFilterUpdateValue
        } = useTransferData$1(props, mergedDisabledRef);
        function doUpdateValue(value) {
          const {
            onUpdateValue,
            "onUpdate:value": _onUpdateValue,
            onChange
          } = props;
          const { nTriggerFormInput, nTriggerFormChange } = formItem;
          if (onUpdateValue)
            call(onUpdateValue, value);
          if (_onUpdateValue)
            call(_onUpdateValue, value);
          if (onChange)
            call(onChange, value);
          uncontrolledValueRef.value = value;
          nTriggerFormInput();
          nTriggerFormChange();
        }
        function handleSrcHeaderCheck(value) {
          const {
            value: { checked, indeterminate }
          } = srcCheckedStatusRef;
          if (indeterminate || checked) {
            srcCheckedValuesRef.value = [];
          } else {
            srcCheckedValuesRef.value = Array.from(avlSrcValueSetRef.value);
          }
        }
        function handleTgtHeaderCheck() {
          const {
            value: { checked, indeterminate }
          } = tgtCheckedStatusRef;
          if (indeterminate || checked) {
            tgtCheckedValuesRef.value = [];
          } else {
            tgtCheckedValuesRef.value = Array.from(avlTgtValueSetRef.value);
          }
        }
        function handleTgtCheckboxClick(checked, optionValue) {
          if (checked) {
            tgtCheckedValuesRef.value.push(optionValue);
          } else {
            const index = tgtCheckedValuesRef.value.findIndex(
              (v) => v === optionValue
            );
            if (~index) {
              tgtCheckedValuesRef.value.splice(index, 1);
            }
          }
        }
        function handleSrcCheckboxClick(checked, optionValue) {
          if (checked) {
            srcCheckedValuesRef.value.push(optionValue);
          } else {
            const index = srcCheckedValuesRef.value.findIndex(
              (v) => v === optionValue
            );
            if (~index) {
              srcCheckedValuesRef.value.splice(index, 1);
            }
          }
        }
        function handleToTgtClick() {
          doUpdateValue(
            srcCheckedValuesRef.value.concat(mergedValueRef.value || [])
          );
          srcCheckedValuesRef.value = [];
        }
        function handleToSrcClick() {
          const tgtCheckedValueSet = new Set(tgtCheckedValuesRef.value);
          doUpdateValue(
            (mergedValueRef.value || []).filter((v) => !tgtCheckedValueSet.has(v))
          );
          tgtCheckedValuesRef.value = [];
        }
        vue.provide(transferInjectionKey$1, {
          mergedClsPrefixRef,
          mergedSizeRef,
          disabledRef: mergedDisabledRef,
          mergedThemeRef: themeRef,
          srcCheckedValuesRef,
          tgtCheckedValuesRef,
          srcOptsRef,
          tgtOptsRef,
          srcCheckedStatusRef,
          tgtCheckedStatusRef,
          handleSrcCheckboxClick,
          handleTgtCheckboxClick
        });
        const { localeRef } = useLocale("LegacyTransfer");
        return {
          locale: localeRef,
          mergedClsPrefix: mergedClsPrefixRef,
          mergedDisabled: mergedDisabledRef,
          itemSize: itemSizeRef,
          isMounted: isMounted(),
          isInputing: isInputingRef,
          mergedTheme: themeRef,
          filteredSrcOpts: filteredSrcOptsRef,
          filteredTgtOpts: filteredTgtOptsRef,
          srcPattern: srcPatternRef,
          tgtPattern: tgtPatternRef,
          toButtonDisabled: toButtonDisabledRef,
          fromButtonDisabled: fromButtonDisabledRef,
          handleSrcHeaderCheck,
          handleTgtHeaderCheck,
          handleToSrcClick,
          handleToTgtClick,
          handleInputFocus,
          handleInputBlur,
          handleTgtFilterUpdateValue,
          handleSrcFilterUpdateValue,
          cssVars: vue.computed(() => {
            const { value: size } = mergedSizeRef;
            const {
              common: {
                cubicBezierEaseInOut,
                cubicBezierEaseIn,
                cubicBezierEaseOut
              },
              self: {
                width,
                borderRadius,
                borderColor,
                listColor,
                headerColor,
                titleTextColor,
                titleTextColorDisabled,
                extraTextColor,
                filterDividerColor,
                itemTextColor,
                itemColorPending,
                itemTextColorDisabled,
                extraFontSize,
                titleFontWeight,
                iconColor,
                iconColorDisabled,
                [createKey("fontSize", size)]: fontSize,
                [createKey("itemHeight", size)]: itemHeight
              }
            } = themeRef.value;
            return {
              "--n-bezier": cubicBezierEaseInOut,
              "--n-bezier-ease-in": cubicBezierEaseIn,
              "--n-bezier-ease-out": cubicBezierEaseOut,
              "--n-border-color": borderColor,
              "--n-border-radius": borderRadius,
              "--n-extra-font-size": extraFontSize,
              "--n-filter-divider-color": filterDividerColor,
              "--n-font-size": fontSize,
              "--n-header-color": headerColor,
              "--n-header-extra-text-color": extraTextColor,
              "--n-header-font-weight": titleFontWeight,
              "--n-header-text-color": titleTextColor,
              "--n-header-text-color-disabled": titleTextColorDisabled,
              "--n-item-color-pending": itemColorPending,
              "--n-item-height": itemHeight,
              "--n-item-text-color": itemTextColor,
              "--n-item-text-color-disabled": itemTextColorDisabled,
              "--n-list-color": listColor,
              "--n-width": width,
              "--n-icon-color": iconColor,
              "--n-icon-color-disabled": iconColorDisabled
            };
          })
        };
      },
      render() {
        const { mergedClsPrefix } = this;
        return /* @__PURE__ */ vue.h("div", {
          class: [
            `${mergedClsPrefix}-legacy-transfer`,
            this.mergedDisabled && `${mergedClsPrefix}-legacy-transfer--disabled`,
            this.filterable && `${mergedClsPrefix}-legacy-transfer--filterable`
          ],
          style: this.cssVars
        }, /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-legacy-transfer-list`
        }, /* @__PURE__ */ vue.h(NTransferHeader$1, {
          source: true,
          onChange: this.handleSrcHeaderCheck,
          title: this.sourceTitle || this.locale.sourceTitle
        }), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-legacy-transfer-list-body`
        }, this.filterable ? /* @__PURE__ */ vue.h(NTransferFilter$1, {
          onUpdateValue: this.handleSrcFilterUpdateValue,
          value: this.srcPattern,
          disabled: this.mergedDisabled,
          placeholder: this.sourceFilterPlaceholder,
          onFocus: this.handleInputFocus,
          onBlur: this.handleInputBlur
        }) : null, /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-legacy-transfer-list-flex-container`
        }, /* @__PURE__ */ vue.h(NTransferList$1, {
          source: true,
          options: this.filteredSrcOpts,
          disabled: this.mergedDisabled,
          virtualScroll: this.virtualScroll,
          isMounted: this.isMounted,
          isInputing: this.isInputing,
          itemSize: this.itemSize
        }))), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-legacy-transfer-list__border`
        })), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-legacy-transfer-gap`
        }, /* @__PURE__ */ vue.h(NButton, {
          disabled: this.toButtonDisabled || this.mergedDisabled,
          theme: this.mergedTheme.peers.Button,
          themeOverrides: this.mergedTheme.peerOverrides.Button,
          onClick: this.handleToTgtClick
        }, {
          icon: () => /* @__PURE__ */ vue.h(NBaseIcon, {
            clsPrefix: mergedClsPrefix
          }, { default: () => /* @__PURE__ */ vue.h(ChevronRightIcon, null) })
        }), /* @__PURE__ */ vue.h(NButton, {
          disabled: this.fromButtonDisabled || this.mergedDisabled,
          theme: this.mergedTheme.peers.Button,
          themeOverrides: this.mergedTheme.peerOverrides.Button,
          onClick: this.handleToSrcClick
        }, {
          icon: () => /* @__PURE__ */ vue.h(NBaseIcon, {
            clsPrefix: mergedClsPrefix
          }, { default: () => /* @__PURE__ */ vue.h(ChevronLeftIcon, null) })
        })), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-legacy-transfer-list`
        }, /* @__PURE__ */ vue.h(NTransferHeader$1, {
          onChange: this.handleTgtHeaderCheck,
          title: this.targetTitle || this.locale.targetTitle
        }), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-legacy-transfer-list-body`
        }, this.filterable ? /* @__PURE__ */ vue.h(NTransferFilter$1, {
          onUpdateValue: this.handleTgtFilterUpdateValue,
          value: this.tgtPattern,
          disabled: this.mergedDisabled,
          placeholder: this.targetFilterPlaceholder,
          onFocus: this.handleInputFocus,
          onBlur: this.handleInputBlur
        }) : null, /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-legacy-transfer-list-flex-container`
        }, /* @__PURE__ */ vue.h(NTransferList$1, {
          options: this.filteredTgtOpts,
          disabled: this.mergedDisabled,
          virtualScroll: this.virtualScroll,
          isMounted: this.isMounted,
          isInputing: this.isInputing,
          itemSize: this.itemSize
        }))), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-legacy-transfer-list__border`
        })));
      }
    });

    var style$x = c$1([cB("list", `
    --n-merged-border-color: var(--n-border-color);
    --n-merged-color: var(--n-color);
    --n-merged-color-hover: var(--n-color-hover);
    margin: 0;
    font-size: var(--n-font-size);
    transition:
      background-color .3s var(--n-bezier),
      color .3s var(--n-bezier),
      border-color .3s var(--n-bezier);
    padding: 0;
    list-style-type: none;
    color: var(--n-text-color);
    background-color: var(--n-merged-color);
  `, [cM("show-divider", [cB("list-item", [c$1("&:not(:last-child)", [cE("divider", `
            background-color: var(--n-merged-border-color);
          `)])])]), cM("clickable", [cB("list-item", `
        cursor: pointer;
      `)]), cM("bordered", `
      border: 1px solid var(--n-merged-border-color);
      border-radius: var(--n-border-radius);
    `), cM("hoverable", [cB("list-item", `
        border-radius: var(--n-border-radius);
      `, [c$1("&:hover", `
          background-color: var(--n-merged-color-hover);
        `, [cE("divider", `
            background-color: transparent;
          `)])])]), cM("bordered, hoverable", [cB("list-item", `
        padding: 12px 20px;
      `), cE("header, footer", `
        padding: 12px 20px;
      `)]), cE("header, footer", `
      padding: 12px 0;
      box-sizing: border-box;
      transition: border-color .3s var(--n-bezier);
    `, [c$1("&:not(:last-child)", `
        border-bottom: 1px solid var(--n-merged-border-color);
      `)]), cB("list-item", `
      position: relative;
      padding: 12px 0;
      box-sizing: border-box;
      display: flex;
      flex-wrap: nowrap;
      align-items: center;
      transition:
        background-color .3s var(--n-bezier),
        border-color .3s var(--n-bezier);
    `, [cE("prefix", `
        margin-right: 20px;
        flex: 0;
      `), cE("suffix", `
        margin-left: 20px;
        flex: 0;
      `), cE("main", `
        flex: 1;
      `), cE("divider", `
        height: 1px;
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        background-color: transparent;
        transition: background-color .3s var(--n-bezier);
        pointer-events: none;
      `)])]), insideModal(cB("list", `
      --n-merged-color-hover: var(--n-color-hover-modal);
      --n-merged-color: var(--n-color-modal);
      --n-merged-border-color: var(--n-border-color-modal);
    `)), insidePopover(cB("list", `
      --n-merged-color-hover: var(--n-color-hover-popover);
      --n-merged-color: var(--n-color-popover);
      --n-merged-border-color: var(--n-border-color-popover);
    `))]);

    const listProps = {
      ...useTheme.props,
      size: {
        type: String,
        default: "medium"
      },
      bordered: Boolean,
      clickable: Boolean,
      hoverable: Boolean,
      showDivider: {
        type: Boolean,
        default: true
      }
    };
    const listInjectionKey = createInjectionKey("n-list");
    var List = vue.defineComponent({
      name: "List",
      props: listProps,
      setup(props) {
        const { mergedClsPrefixRef, inlineThemeDisabled, mergedRtlRef } = useConfig(props);
        const rtlEnabledRef = useRtl("List", mergedRtlRef, mergedClsPrefixRef);
        const themeRef = useTheme(
          "List",
          "-list",
          style$x,
          listLight$1,
          props,
          mergedClsPrefixRef
        );
        vue.provide(listInjectionKey, {
          showDividerRef: vue.toRef(props, "showDivider"),
          mergedClsPrefixRef
        });
        const cssVarsRef = vue.computed(() => {
          const {
            common: { cubicBezierEaseInOut },
            self: {
              fontSize,
              textColor,
              color,
              colorModal,
              colorPopover,
              borderColor,
              borderColorModal,
              borderColorPopover,
              borderRadius,
              colorHover,
              colorHoverModal,
              colorHoverPopover
            }
          } = themeRef.value;
          return {
            "--n-font-size": fontSize,
            "--n-bezier": cubicBezierEaseInOut,
            "--n-text-color": textColor,
            "--n-color": color,
            "--n-border-radius": borderRadius,
            "--n-border-color": borderColor,
            "--n-border-color-modal": borderColorModal,
            "--n-border-color-popover": borderColorPopover,
            "--n-color-modal": colorModal,
            "--n-color-popover": colorPopover,
            "--n-color-hover": colorHover,
            "--n-color-hover-modal": colorHoverModal,
            "--n-color-hover-popover": colorHoverPopover
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("list", void 0, cssVarsRef, props) : void 0;
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          rtlEnabled: rtlEnabledRef,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender
        };
      },
      render() {
        const { $slots, mergedClsPrefix, onRender } = this;
        onRender?.();
        return /* @__PURE__ */ vue.h("ul", {
          class: [
            `${mergedClsPrefix}-list`,
            this.rtlEnabled && `${mergedClsPrefix}-list--rtl`,
            this.bordered && `${mergedClsPrefix}-list--bordered`,
            this.showDivider && `${mergedClsPrefix}-list--show-divider`,
            this.hoverable && `${mergedClsPrefix}-list--hoverable`,
            this.clickable && `${mergedClsPrefix}-list--clickable`,
            this.themeClass
          ],
          style: this.cssVars
        }, $slots.header ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-list__header`
        }, $slots.header()) : null, $slots.default?.(), $slots.footer ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-list__footer`
        }, $slots.footer()) : null);
      }
    });

    var ListItem = vue.defineComponent({
      name: "ListItem",
      setup() {
        const listInjection = vue.inject(listInjectionKey, null);
        if (!listInjection) {
          throwError("list-item", "`n-list-item` must be placed in `n-list`.");
        }
        return {
          showDivider: listInjection.showDividerRef,
          mergedClsPrefix: listInjection.mergedClsPrefixRef
        };
      },
      render() {
        const { $slots, mergedClsPrefix } = this;
        return /* @__PURE__ */ vue.h("li", {
          class: `${mergedClsPrefix}-list-item`
        }, $slots.prefix ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-list-item__prefix`
        }, $slots.prefix()) : null, $slots.default ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-list-item__main`
        }, $slots) : null, $slots.suffix ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-list-item__suffix`
        }, $slots.suffix()) : null, this.showDivider && /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-list-item__divider`
        }));
      }
    });

    const loadingBarProviderInjectionKey = createInjectionKey("n-loading-bar");
    const loadingBarApiInjectionKey = createInjectionKey("n-loading-bar-api");

    var style$w = cB("loading-bar-container", `
  z-index: 5999;
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  height: 2px;
`, [fadeInTransition({
      enterDuration: "0.3s",
      leaveDuration: "0.8s"
    }), cB("loading-bar", `
    width: 100%;
    transition:
      max-width 4s linear,
      background .2s linear;
    height: var(--n-height);
  `, [cM("starting", `
      background: var(--n-color-loading);
    `), cM("finishing", `
      background: var(--n-color-loading);
      transition:
        max-width .2s linear,
        background .2s linear;
    `), cM("error", `
      background: var(--n-color-error);
      transition:
        max-width .2s linear,
        background .2s linear;
    `)])]);

    function createClassName(status, clsPrefix) {
      return `${clsPrefix}-loading-bar ${clsPrefix}-loading-bar--${status}`;
    }
    var NLoadingBar = vue.defineComponent({
      name: "LoadingBar",
      setup(props) {
        const { inlineThemeDisabled } = useConfig();
        const {
          props: providerProps,
          mergedClsPrefixRef
        } = vue.inject(loadingBarProviderInjectionKey);
        const loadingBarRef = vue.ref(null);
        const enteringRef = vue.ref(false);
        const startedRef = vue.ref(false);
        const loadingRef = vue.ref(false);
        const transitionDisabledRef = vue.ref(false);
        let finishing = false;
        const erroringRef = vue.ref(false);
        const mergedLoadingBarStyle = vue.computed(() => {
          const { loadingBarStyle } = providerProps;
          if (!loadingBarStyle)
            return "";
          return loadingBarStyle[erroringRef.value ? "error" : "loading"];
        });
        async function init() {
          enteringRef.value = false;
          loadingRef.value = false;
          finishing = false;
          erroringRef.value = false;
          transitionDisabledRef.value = true;
          await vue.nextTick();
          transitionDisabledRef.value = false;
        }
        async function start(fromProgress = 0, toProgress = 80, status = "starting") {
          await init();
          loadingRef.value = true;
          startedRef.value = true;
          await vue.nextTick();
          const el = loadingBarRef.value;
          if (!el)
            return;
          el.style.maxWidth = `${fromProgress}%`;
          el.style.transition = "none";
          void el.offsetWidth;
          el.className = createClassName(status, mergedClsPrefixRef.value);
          el.style.transition = "";
          el.style.maxWidth = `${toProgress}%`;
        }
        function finish() {
          if (finishing || erroringRef.value || !loadingRef.value)
            return;
          finishing = true;
          const el = loadingBarRef.value;
          if (!el)
            return;
          el.className = createClassName("finishing", mergedClsPrefixRef.value);
          el.style.maxWidth = "100%";
          void el.offsetWidth;
          loadingRef.value = false;
        }
        function error() {
          if (finishing || erroringRef.value)
            return;
          if (!loadingRef.value) {
            void start(100, 100, "error").then(() => {
              erroringRef.value = true;
              const el = loadingBarRef.value;
              if (!el)
                return;
              el.className = createClassName("error", mergedClsPrefixRef.value);
              void el.offsetWidth;
              loadingRef.value = false;
            });
          } else {
            erroringRef.value = true;
            const el = loadingBarRef.value;
            if (!el)
              return;
            el.className = createClassName("error", mergedClsPrefixRef.value);
            el.style.maxWidth = "100%";
            void el.offsetWidth;
            loadingRef.value = false;
          }
        }
        function handleEnter() {
          enteringRef.value = true;
        }
        function handleAfterEnter() {
          enteringRef.value = false;
        }
        async function handleAfterLeave() {
          await init();
        }
        const themeRef = useTheme(
          "LoadingBar",
          "-loading-bar",
          style$w,
          loadingBarLight$1,
          providerProps,
          mergedClsPrefixRef
        );
        const cssVarsRef = vue.computed(() => {
          const {
            self: { height, colorError, colorLoading }
          } = themeRef.value;
          return {
            "--n-height": height,
            "--n-color-loading": colorLoading,
            "--n-color-error": colorError
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("loading-bar", void 0, cssVarsRef, providerProps) : void 0;
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          loadingBarRef,
          started: startedRef,
          loading: loadingRef,
          entering: enteringRef,
          transitionDisabled: transitionDisabledRef,
          start,
          error,
          finish,
          handleEnter,
          handleAfterEnter,
          handleAfterLeave,
          mergedLoadingBarStyle,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender
        };
      },
      render() {
        if (!this.started)
          return null;
        const { mergedClsPrefix } = this;
        return /* @__PURE__ */ vue.h(vue.Transition, {
          name: "fade-in-transition",
          appear: true,
          onEnter: this.handleEnter,
          onAfterEnter: this.handleAfterEnter,
          onAfterLeave: this.handleAfterLeave,
          css: !this.transitionDisabled
        }, {
          default: () => {
            this.onRender?.();
            return vue.withDirectives(
              /* @__PURE__ */ vue.h("div", {
                class: [
                  `${mergedClsPrefix}-loading-bar-container`,
                  this.themeClass
                ]
              }, /* @__PURE__ */ vue.h("div", {
                ref: "loadingBarRef",
                class: [`${mergedClsPrefix}-loading-bar`],
                style: [
                  this.cssVars,
                  this.mergedLoadingBarStyle
                ]
              })),
              [[vue.vShow, this.loading || !this.loading && this.entering]]
            );
          }
        });
      }
    });

    const loadingBarProviderProps = {
      ...useTheme.props,
      to: {
        type: [String, Object],
        default: void 0
      },
      loadingBarStyle: {
        type: Object
      }
    };
    var NLoadingBarProvider = vue.defineComponent({
      name: "LoadingBarProvider",
      props: loadingBarProviderProps,
      setup(props) {
        const isMountedRef = isMounted();
        const loadingBarRef = vue.ref(null);
        const methods = {
          start() {
            if (isMountedRef.value) {
              loadingBarRef.value?.start();
            } else {
              void vue.nextTick(() => {
                loadingBarRef.value?.start();
              });
            }
          },
          error() {
            if (isMountedRef.value) {
              loadingBarRef.value?.error();
            } else {
              void vue.nextTick(() => {
                loadingBarRef.value?.error();
              });
            }
          },
          finish() {
            if (isMountedRef.value) {
              loadingBarRef.value?.finish();
            } else {
              void vue.nextTick(() => {
                loadingBarRef.value?.finish();
              });
            }
          }
        };
        const { mergedClsPrefixRef } = useConfig(props);
        vue.provide(loadingBarApiInjectionKey, methods);
        vue.provide(loadingBarProviderInjectionKey, {
          props,
          mergedClsPrefixRef
        });
        return Object.assign(methods, {
          loadingBarRef
        });
      },
      render() {
        return /* @__PURE__ */ vue.h(vue.Fragment, null, /* @__PURE__ */ vue.h(vue.Teleport, {
          to: this.to ?? "body"
        }, /* @__PURE__ */ vue.h(NLoadingBar, {
          ref: "loadingBarRef"
        })), this.$slots.default?.());
      }
    });

    function useLoadingBar() {
      const loadingBar = vue.inject(loadingBarApiInjectionKey, null);

      if (loadingBar === null) {
        throwError("use-loading-bar", "No outer <n-loading-bar-provider /> founded.");
      }

      return loadingBar;
    }

    var NLogLoader = vue.defineComponent({
      name: "LogLoader",
      props: {
        clsPrefix: {
          type: String,
          required: true
        }
      },
      setup() {
        return {
          locale: useLocale("Log").localeRef
        };
      },
      render() {
        const { clsPrefix } = this;
        return /* @__PURE__ */ vue.h("div", {
          class: `${clsPrefix}-log-loader`
        }, /* @__PURE__ */ vue.h(NBaseLoading, {
          clsPrefix,
          strokeWidth: 24,
          scale: 0.85
        }), /* @__PURE__ */ vue.h("span", {
          class: `${clsPrefix}-log-loader__content`
        }, this.locale.loading));
      }
    });

    const logInjectionKey = createInjectionKey("n-log");

    var NLogLine = vue.defineComponent({
      props: {
        line: {
          type: String,
          default: ""
        }
      },
      setup(props) {
        const { trimRef, highlightRef, languageRef, mergedHljsRef } = vue.inject(logInjectionKey);
        const selfRef = vue.ref(null);
        const maybeTrimmedLinesRef = vue.computed(() => {
          return trimRef.value ? props.line.trim() : props.line;
        });
        function setInnerHTML() {
          if (selfRef.value) {
            selfRef.value.innerHTML = generateCodeHTML(
              languageRef.value,
              maybeTrimmedLinesRef.value
            );
          }
        }
        function generateCodeHTML(language, code) {
          const { value: hljs } = mergedHljsRef;
          if (hljs) {
            if (language && hljs.getLanguage(language)) {
              return hljs.highlight(code, { language }).value;
            }
          }
          return code;
        }
        vue.onMounted(() => {
          if (highlightRef.value) {
            setInnerHTML();
          }
        });
        vue.watch(vue.toRef(props, "line"), () => {
          if (highlightRef.value) {
            setInnerHTML();
          }
        });
        return {
          highlight: highlightRef,
          selfRef,
          maybeTrimmedLines: maybeTrimmedLinesRef
        };
      },
      render() {
        const { highlight, maybeTrimmedLines } = this;
        return /* @__PURE__ */ vue.h("pre", {
          ref: "selfRef"
        }, highlight ? null : maybeTrimmedLines);
      }
    });

    var style$v = cB("log", `
  position: relative;
  box-sizing: border-box;
  transition: border-color .3s var(--n-bezier);
`, [c$1("pre", `
    white-space: pre-wrap;
    word-break: break-word;
    margin: 0;
  `), cB("log-loader", `
    transition:
      color .3s var(--n-bezier),
      background-color .3s var(--n-bezier),
      border-color .3s var(--n-bezier);
    box-sizing: border-box;
    position: absolute;
    right: 16px;
    top: 8px;
    height: 34px;
    border-radius: 17px;
    line-height: 34px;
    white-space: nowrap;
    overflow: hidden;
    border: var(--n-loader-border);
    color: var(--n-loader-text-color);
    background-color: var(--n-loader-color);
    font-size: var(--n-loader-font-size);
  `, [fadeInScaleUpTransition(), cE("content", `
      display: inline-block;
      vertical-align: bottom;
      line-height: 34px;
      padding-left: 40px;
      padding-right: 20px;
      white-space: nowrap;
    `), cB("base-loading", `
      color: var(--n-loading-color);
      position: absolute;
      left: 12px;
      top: calc(50% - 10px);
      font-size: 20px;
      width: 20px;
      height: 20px;
      display: inline-block;
    `)])]);

    const logProps = {
      ...useTheme.props,
      loading: Boolean,
      trim: Boolean,
      log: String,
      fontSize: {
        type: Number,
        default: 14
      },
      lines: {
        type: Array,
        default: () => []
      },
      lineHeight: {
        type: Number,
        default: 1.25
      },
      language: String,
      rows: {
        type: Number,
        default: 15
      },
      offsetTop: {
        type: Number,
        default: 0
      },
      offsetBottom: {
        type: Number,
        default: 0
      },
      hljs: Object,
      onReachTop: Function,
      onReachBottom: Function,
      onRequireMore: Function
    };
    var Log = vue.defineComponent({
      name: "Log",
      props: logProps,
      setup(props) {
        const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
        const slientRef = vue.ref(false);
        const highlightRef = vue.computed(() => {
          return props.language !== void 0;
        });
        const styleHeightRef = vue.computed(() => {
          return `calc(${Math.round(
        props.rows * props.lineHeight * props.fontSize
      )}px)`;
        });
        const mergedLinesRef = vue.computed(() => {
          const { log } = props;
          if (log) {
            return log.split("\n");
          }
          return props.lines;
        });
        const scrollbarRef = vue.ref(null);
        const themeRef = useTheme(
          "Log",
          "-log",
          style$v,
          logLight$1,
          props,
          mergedClsPrefixRef
        );
        function handleScroll(e) {
          const container = e.target;
          const content = container.firstElementChild;
          if (slientRef.value) {
            void vue.nextTick(() => {
              slientRef.value = false;
            });
            return;
          }
          const containerHeight = container.offsetHeight;
          const containerScrollTop = container.scrollTop;
          const contentHeight = content.offsetHeight;
          const scrollTop = containerScrollTop;
          const scrollBottom = contentHeight - containerScrollTop - containerHeight;
          if (scrollTop <= props.offsetTop) {
            const { onReachTop, onRequireMore } = props;
            if (onRequireMore)
              onRequireMore("top");
            if (onReachTop)
              onReachTop();
          }
          if (scrollBottom <= props.offsetBottom) {
            const { onReachBottom, onRequireMore } = props;
            if (onRequireMore)
              onRequireMore("bottom");
            if (onReachBottom)
              onReachBottom();
          }
        }
        const handleWheel = lodash.exports.throttle(_handleWheel, 300);
        function _handleWheel(e) {
          if (slientRef.value) {
            void vue.nextTick(() => {
              slientRef.value = false;
            });
            return;
          }
          if (scrollbarRef.value) {
            const { containerRef, contentRef } = scrollbarRef.value;
            if (containerRef && contentRef) {
              const containerHeight = containerRef.offsetHeight;
              const containerScrollTop = containerRef.scrollTop;
              const contentHeight = contentRef.offsetHeight;
              const scrollTop = containerScrollTop;
              const scrollBottom = contentHeight - containerScrollTop - containerHeight;
              const deltaY = e.deltaY;
              if (scrollTop === 0 && deltaY < 0) {
                const { onRequireMore } = props;
                if (onRequireMore)
                  onRequireMore("top");
              }
              if (scrollBottom <= 0 && deltaY > 0) {
                const { onRequireMore } = props;
                if (onRequireMore)
                  onRequireMore("bottom");
              }
            }
          }
        }
        function scrollTo(options) {
          const { value: scrollbarInst } = scrollbarRef;
          if (!scrollbarInst)
            return;
          const { slient, top, position } = options;
          if (slient) {
            slientRef.value = true;
          }
          if (top !== void 0) {
            scrollbarInst.scrollTo({ left: 0, top });
          } else if (position === "bottom" || position === "top") {
            scrollbarInst.scrollTo({ position });
          }
        }
        function scrollToTop(slient = false) {
          warn$2(
            "log",
            "`scrollToTop` is deprecated, please use `scrollTo({ position: 'top'})` instead."
          );
          scrollTo({
            position: "top",
            slient
          });
        }
        function scrollToBottom(slient = false) {
          warn$2(
            "log",
            "`scrollToTop` is deprecated, please use `scrollTo({ position: 'bottom'})` instead."
          );
          scrollTo({
            position: "bottom",
            slient
          });
        }
        vue.provide(logInjectionKey, {
          languageRef: vue.toRef(props, "language"),
          mergedHljsRef: useHljs(props, highlightRef),
          trimRef: vue.toRef(props, "trim"),
          highlightRef
        });
        const exportedMethods = {
          scrollTo
        };
        const cssVarsRef = vue.computed(() => {
          const {
            self: {
              loaderFontSize,
              loaderTextColor,
              loaderColor,
              loaderBorder,
              loadingColor
            },
            common: { cubicBezierEaseInOut }
          } = themeRef.value;
          return {
            "--n-bezier": cubicBezierEaseInOut,
            "--n-loader-font-size": loaderFontSize,
            "--n-loader-border": loaderBorder,
            "--n-loader-color": loaderColor,
            "--n-loader-text-color": loaderTextColor,
            "--n-loading-color": loadingColor
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("log", void 0, cssVarsRef, props) : void 0;
        return {
          ...exportedMethods,
          mergedClsPrefix: mergedClsPrefixRef,
          scrollbarRef,
          mergedTheme: themeRef,
          styleHeight: styleHeightRef,
          mergedLines: mergedLinesRef,
          scrollToTop,
          scrollToBottom,
          handleWheel,
          handleScroll,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender
        };
      },
      render() {
        const { mergedClsPrefix, mergedTheme, onRender } = this;
        onRender?.();
        return vue.h(
          "div",
          {
            class: [`${mergedClsPrefix}-log`, this.themeClass],
            style: [
              {
                lineHeight: this.lineHeight,
                height: this.styleHeight
              },
              this.cssVars
            ],
            onWheelPassive: this.handleWheel
          },
          [
            /* @__PURE__ */ vue.h(NScrollbar, {
              ref: "scrollbarRef",
              theme: mergedTheme.peers.Scrollbar,
              themeOverrides: mergedTheme.peerOverrides.Scrollbar,
              onScroll: this.handleScroll
            }, {
              default: () => /* @__PURE__ */ vue.h(NCode, {
                internalNoHighlight: true,
                internalFontSize: this.fontSize,
                theme: mergedTheme.peers.Code,
                themeOverrides: mergedTheme.peerOverrides.Code
              }, {
                default: () => this.mergedLines.map((line, index) => {
                  return /* @__PURE__ */ vue.h(NLogLine, {
                    key: index,
                    line
                  });
                })
              })
            }),
            /* @__PURE__ */ vue.h(vue.Transition, {
              name: "fade-in-scale-up-transition"
            }, {
              default: () => this.loading ? /* @__PURE__ */ vue.h(NLogLoader, {
                clsPrefix: mergedClsPrefix
              }) : null
            })
          ]
        );
      }
    });

    const menuInjectionKey = createInjectionKey("n-menu");
    const submenuInjectionKey = createInjectionKey("n-submenu");
    const menuItemGroupInjectionKey = createInjectionKey("n-menu-item-group");

    const ICON_MARGIN_RIGHT = 8;
    function useMenuChild(props) {
      const NMenu = vue.inject(menuInjectionKey);
      const {
        props: menuProps,
        mergedCollapsedRef
      } = NMenu;
      const NSubmenu = vue.inject(submenuInjectionKey, null);
      const NMenuOptionGroup = vue.inject(menuItemGroupInjectionKey, null);
      const horizontalRef = vue.computed(() => {
        return menuProps.mode === "horizontal";
      });
      const dropdownPlacementRef = vue.computed(() => {
        if (horizontalRef.value) {
          return menuProps.dropdownPlacement;
        }

        if ("tmNodes" in props) return "right-start";
        return "right";
      });
      const maxIconSizeRef = vue.computed(() => {
        return Math.max(menuProps.collapsedIconSize ?? menuProps.iconSize, menuProps.iconSize);
      });
      const activeIconSizeRef = vue.computed(() => {
        if (!horizontalRef.value && props.root && mergedCollapsedRef.value) {
          return menuProps.collapsedIconSize ?? menuProps.iconSize;
        } else {
          return menuProps.iconSize;
        }
      });
      const paddingLeftRef = vue.computed(() => {
        if (horizontalRef.value) return void 0;
        const {
          collapsedWidth,
          indent,
          rootIndent
        } = menuProps;
        const {
          root,
          isGroup
        } = props;
        const mergedRootIndent = rootIndent === void 0 ? indent : rootIndent;

        if (root) {
          if (mergedCollapsedRef.value) {
            return collapsedWidth / 2 - maxIconSizeRef.value / 2;
          }

          return mergedRootIndent;
        }

        if (NMenuOptionGroup) {
          return indent / 2 + NMenuOptionGroup.paddingLeftRef.value;
        }

        if (NSubmenu) {
          return (isGroup ? indent / 2 : indent) + NSubmenu.paddingLeftRef.value;
        }

        return void 0;
      });
      const iconMarginRightRef = vue.computed(() => {
        const {
          collapsedWidth,
          indent,
          rootIndent
        } = menuProps;
        const {
          value: maxIconSize
        } = maxIconSizeRef;
        const {
          root
        } = props;
        if (horizontalRef.value) return ICON_MARGIN_RIGHT;
        if (!root) return ICON_MARGIN_RIGHT;
        if (!mergedCollapsedRef.value) return ICON_MARGIN_RIGHT;
        const mergedRootIndent = rootIndent === void 0 ? indent : rootIndent;
        return mergedRootIndent + maxIconSize + ICON_MARGIN_RIGHT - (collapsedWidth + maxIconSize) / 2;
      });
      return {
        dropdownPlacement: dropdownPlacementRef,
        activeIconSize: activeIconSizeRef,
        maxIconSize: maxIconSizeRef,
        paddingLeft: paddingLeftRef,
        iconMarginRight: iconMarginRightRef,
        NMenu,
        NSubmenu
      };
    }

    const useMenuChildProps = {
      internalKey: {
        type: [String, Number],
        required: true
      },
      root: Boolean,
      isGroup: Boolean,
      level: {
        type: Number,
        required: true
      },
      title: [String, Function],
      extra: [String, Function]
    };

    const menuItemGroupProps = {
      ...useMenuChildProps,
      tmNode: {
        type: Object,
        required: true
      },
      tmNodes: {
        type: Array,
        required: true
      }
    };
    const NMenuOptionGroup = vue.defineComponent({
      name: "MenuOptionGroup",
      props: menuItemGroupProps,
      setup(props) {
        vue.provide(submenuInjectionKey, null);
        const MenuChild = useMenuChild(props);
        vue.provide(menuItemGroupInjectionKey, {
          paddingLeftRef: MenuChild.paddingLeft
        });
        const { mergedClsPrefixRef, props: menuProps } = vue.inject(menuInjectionKey);
        return function() {
          const { value: mergedClsPrefix } = mergedClsPrefixRef;
          const paddingLeft = MenuChild.paddingLeft.value;
          const { nodeProps } = menuProps;
          const attrs = nodeProps?.(props.tmNode.rawNode);
          return /* @__PURE__ */ vue.h("div", {
            class: `${mergedClsPrefix}-menu-item-group`,
            role: "group"
          }, /* @__PURE__ */ vue.h("div", {
            ...attrs,
            class: [`${mergedClsPrefix}-menu-item-group-title`, attrs?.class],
            style: [
              attrs?.style || "",
              paddingLeft !== void 0 ? `padding-left: ${paddingLeft}px;` : ""
            ]
          }, render$1(props.title), props.extra ? /* @__PURE__ */ vue.h(vue.Fragment, null, " ", render$1(props.extra)) : null), /* @__PURE__ */ vue.h("div", null, props.tmNodes.map((tmNode) => itemRenderer(tmNode, menuProps))));
        };
      }
    });

    var NMenuOptionContent = vue.defineComponent({
      name: "MenuOptionContent",
      props: {
        collapsed: Boolean,
        disabled: Boolean,
        title: [String, Function],
        icon: Function,
        extra: [String, Function],
        showArrow: Boolean,
        childActive: Boolean,
        hover: Boolean,
        paddingLeft: Number,
        selected: Boolean,
        maxIconSize: {
          type: Number,
          required: true
        },
        activeIconSize: {
          type: Number,
          required: true
        },
        iconMarginRight: {
          type: Number,
          required: true
        },
        clsPrefix: {
          type: String,
          required: true
        },
        onClick: Function,
        tmNode: {
          type: Object,
          required: true
        }
      },
      setup(props) {
        const { props: menuProps } = vue.inject(menuInjectionKey);
        return {
          menuProps,
          style: vue.computed(() => {
            const { paddingLeft } = props;
            return { paddingLeft: paddingLeft && `${paddingLeft}px` };
          }),
          iconStyle: vue.computed(() => {
            const { maxIconSize, activeIconSize, iconMarginRight } = props;
            return {
              width: `${maxIconSize}px`,
              height: `${maxIconSize}px`,
              fontSize: `${activeIconSize}px`,
              marginRight: `${iconMarginRight}px`
            };
          })
        };
      },
      render() {
        const {
          clsPrefix,
          tmNode,
          menuProps: { renderIcon, renderLabel, renderExtra, expandIcon }
        } = this;
        const icon = renderIcon ? renderIcon(tmNode.rawNode) : render$1(this.icon);
        return /* @__PURE__ */ vue.h("div", {
          onClick: (e) => {
            this.onClick?.(e);
          },
          role: "none",
          class: [
            `${clsPrefix}-menu-item-content`,
            {
              [`${clsPrefix}-menu-item-content--selected`]: this.selected,
              [`${clsPrefix}-menu-item-content--collapsed`]: this.collapsed,
              [`${clsPrefix}-menu-item-content--child-active`]: this.childActive,
              [`${clsPrefix}-menu-item-content--disabled`]: this.disabled,
              [`${clsPrefix}-menu-item-content--hover`]: this.hover
            }
          ],
          style: this.style
        }, icon && /* @__PURE__ */ vue.h("div", {
          class: `${clsPrefix}-menu-item-content__icon`,
          style: this.iconStyle,
          role: "none"
        }, [icon]), /* @__PURE__ */ vue.h("div", {
          class: `${clsPrefix}-menu-item-content-header`,
          role: "none"
        }, renderLabel ? renderLabel(tmNode.rawNode) : render$1(this.title), this.extra || renderExtra ? /* @__PURE__ */ vue.h("span", {
          class: `${clsPrefix}-menu-item-content-header__extra`
        }, " ", renderExtra ? renderExtra(tmNode.rawNode) : render$1(this.extra)) : null), this.showArrow ? /* @__PURE__ */ vue.h(NBaseIcon, {
          ariaHidden: true,
          class: `${clsPrefix}-menu-item-content__arrow`,
          clsPrefix
        }, {
          default: () => expandIcon ? expandIcon(tmNode.rawNode) : /* @__PURE__ */ vue.h(ChevronDownFilledIcon, null)
        }) : null);
      }
    });

    const submenuProps = {
      ...useMenuChildProps,
      rawNodes: {
        type: Array,
        default: () => []
      },
      tmNodes: {
        type: Array,
        default: () => []
      },
      tmNode: {
        type: Object,
        required: true
      },
      disabled: {
        type: Boolean,
        default: false
      },
      icon: Function,
      onClick: Function
    };
    const NSubmenu = vue.defineComponent({
      name: "Submenu",
      props: submenuProps,
      setup(props) {
        const MenuChild = useMenuChild(props);
        const { NMenu, NSubmenu: NSubmenu2 } = MenuChild;
        const { props: menuProps, mergedCollapsedRef, mergedThemeRef } = NMenu;
        const mergedDisabledRef = vue.computed(() => {
          const { disabled } = props;
          if (NSubmenu2?.mergedDisabledRef.value)
            return true;
          if (menuProps.disabled)
            return true;
          return disabled;
        });
        const dropdownShowRef = vue.ref(false);
        vue.provide(submenuInjectionKey, {
          paddingLeftRef: MenuChild.paddingLeft,
          mergedDisabledRef
        });
        vue.provide(menuItemGroupInjectionKey, null);
        function doClick() {
          const { onClick } = props;
          if (onClick)
            onClick();
        }
        function handleClick() {
          if (!mergedDisabledRef.value) {
            if (!mergedCollapsedRef.value) {
              NMenu.toggleExpand(props.internalKey);
            }
            doClick();
          }
        }
        function handlePopoverShowChange(value) {
          dropdownShowRef.value = value;
        }
        return {
          menuProps,
          mergedTheme: mergedThemeRef,
          doSelect: NMenu.doSelect,
          inverted: NMenu.invertedRef,
          isHorizontal: NMenu.isHorizontalRef,
          mergedClsPrefix: NMenu.mergedClsPrefixRef,
          maxIconSize: MenuChild.maxIconSize,
          activeIconSize: MenuChild.activeIconSize,
          iconMarginRight: MenuChild.iconMarginRight,
          dropdownPlacement: MenuChild.dropdownPlacement,
          dropdownShow: dropdownShowRef,
          paddingLeft: MenuChild.paddingLeft,
          mergedDisabled: mergedDisabledRef,
          mergedValue: NMenu.mergedValueRef,
          childActive: useMemo(() => {
            return NMenu.activePathRef.value.includes(props.internalKey);
          }),
          collapsed: vue.computed(() => {
            if (menuProps.mode === "horizontal")
              return false;
            if (mergedCollapsedRef.value) {
              return true;
            }
            return !NMenu.mergedExpandedKeysRef.value.includes(props.internalKey);
          }),
          dropdownEnabled: vue.computed(() => {
            return !mergedDisabledRef.value && (menuProps.mode === "horizontal" || mergedCollapsedRef.value);
          }),
          handlePopoverShowChange,
          handleClick
        };
      },
      render() {
        const {
          mergedClsPrefix,
          menuProps: { renderIcon, renderLabel }
        } = this;
        const createSubmenuItem = () => {
          const {
            isHorizontal,
            paddingLeft,
            collapsed,
            mergedDisabled,
            maxIconSize,
            activeIconSize,
            title,
            childActive,
            icon,
            handleClick,
            menuProps: { nodeProps },
            dropdownShow,
            iconMarginRight,
            tmNode,
            mergedClsPrefix: mergedClsPrefix2
          } = this;
          const attrs = nodeProps?.(tmNode.rawNode);
          return /* @__PURE__ */ vue.h("div", {
            ...attrs,
            class: [`${mergedClsPrefix2}-menu-item`, attrs?.class],
            role: "menuitem"
          }, /* @__PURE__ */ vue.h(NMenuOptionContent, {
            tmNode,
            paddingLeft,
            collapsed,
            disabled: mergedDisabled,
            iconMarginRight,
            maxIconSize,
            activeIconSize,
            title,
            extra: this.extra,
            showArrow: !isHorizontal,
            childActive,
            clsPrefix: mergedClsPrefix2,
            icon,
            hover: dropdownShow,
            onClick: handleClick
          }));
        };
        const createSubmenuChildren = () => {
          return /* @__PURE__ */ vue.h(NFadeInExpandTransition, null, {
            default: () => {
              const { tmNodes, collapsed } = this;
              return !collapsed ? /* @__PURE__ */ vue.h("div", {
                class: `${mergedClsPrefix}-submenu-children`,
                role: "menu"
              }, tmNodes.map((item) => itemRenderer(item, this.menuProps))) : null;
            }
          });
        };
        return this.root ? /* @__PURE__ */ vue.h(NDropdown, {
          size: "large",
          ...this.menuProps?.dropdownProps,
          themeOverrides: this.mergedTheme.peerOverrides.Dropdown,
          theme: this.mergedTheme.peers.Dropdown,
          builtinThemeOverrides: {
            fontSizeLarge: "14px",
            optionIconSizeLarge: "18px"
          },
          value: this.mergedValue,
          trigger: "hover",
          disabled: !this.dropdownEnabled,
          placement: this.dropdownPlacement,
          keyField: this.menuProps.keyField,
          labelField: this.menuProps.labelField,
          childrenField: this.menuProps.childrenField,
          onUpdateShow: this.handlePopoverShowChange,
          options: this.rawNodes,
          onSelect: this.doSelect,
          inverted: this.inverted,
          renderIcon,
          renderLabel
        }, {
          default: () => /* @__PURE__ */ vue.h("div", {
            class: `${mergedClsPrefix}-submenu`,
            role: "menuitem",
            "aria-expanded": !this.collapsed
          }, createSubmenuItem(), this.isHorizontal ? null : createSubmenuChildren())
        }) : /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-submenu`,
          role: "menuitem",
          "aria-expanded": !this.collapsed
        }, createSubmenuItem(), createSubmenuChildren());
      }
    });

    const menuItemProps = {
      ...useMenuChildProps,
      tmNode: {
        type: Object,
        required: true
      },
      disabled: Boolean,
      icon: Function,
      onClick: Function
    };
    const NMenuOption = vue.defineComponent({
      name: "MenuOption",
      props: menuItemProps,
      setup(props) {
        const MenuChild = useMenuChild(props);
        const { NSubmenu, NMenu } = MenuChild;
        const { props: menuProps, mergedClsPrefixRef, mergedCollapsedRef } = NMenu;
        const submenuDisabledRef = NSubmenu ? NSubmenu.mergedDisabledRef : { value: false };
        const mergedDisabledRef = vue.computed(() => {
          return submenuDisabledRef.value || props.disabled;
        });
        function doClick(e) {
          const { onClick } = props;
          if (onClick)
            onClick(e);
        }
        function handleClick(e) {
          if (!mergedDisabledRef.value) {
            NMenu.doSelect(props.internalKey, props.tmNode.rawNode);
            doClick(e);
          }
        }
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          dropdownPlacement: MenuChild.dropdownPlacement,
          paddingLeft: MenuChild.paddingLeft,
          iconMarginRight: MenuChild.iconMarginRight,
          maxIconSize: MenuChild.maxIconSize,
          activeIconSize: MenuChild.activeIconSize,
          mergedTheme: NMenu.mergedThemeRef,
          menuProps,
          dropdownEnabled: useMemo(() => {
            return props.root && mergedCollapsedRef.value && menuProps.mode !== "horizontal" && !mergedDisabledRef.value;
          }),
          selected: vue.computed(() => {
            if (NMenu.mergedValueRef.value === props.internalKey)
              return true;
            return false;
          }),
          mergedDisabled: mergedDisabledRef,
          handleClick
        };
      },
      render() {
        const {
          mergedClsPrefix,
          mergedTheme,
          tmNode,
          menuProps: { renderLabel, nodeProps }
        } = this;
        const attrs = nodeProps?.(tmNode.rawNode);
        return /* @__PURE__ */ vue.h("div", {
          ...attrs,
          role: "menuitem",
          class: [`${mergedClsPrefix}-menu-item`, attrs?.class]
        }, /* @__PURE__ */ vue.h(NTooltip, {
          theme: mergedTheme.peers.Tooltip,
          themeOverrides: mergedTheme.peerOverrides.Tooltip,
          trigger: "hover",
          placement: this.dropdownPlacement,
          disabled: !this.dropdownEnabled || this.title === void 0,
          internalExtraClass: ["menu-tooltip"]
        }, {
          default: () => renderLabel ? renderLabel(tmNode.rawNode) : render$1(this.title),
          trigger: () => /* @__PURE__ */ vue.h(NMenuOptionContent, {
            tmNode,
            clsPrefix: mergedClsPrefix,
            paddingLeft: this.paddingLeft,
            iconMarginRight: this.iconMarginRight,
            maxIconSize: this.maxIconSize,
            activeIconSize: this.activeIconSize,
            selected: this.selected,
            title: this.title,
            extra: this.extra,
            disabled: this.mergedDisabled,
            icon: this.icon,
            onClick: this.handleClick
          })
        }));
      }
    });

    var NMenuDivider = vue.defineComponent({
      name: "MenuDivider",
      setup() {
        const NMenu = vue.inject(menuInjectionKey);
        const { mergedClsPrefixRef, isHorizontalRef } = NMenu;
        return () => isHorizontalRef.value ? null : /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefixRef.value}-menu-divider`
        });
      }
    });

    const groupPropKeys = keysOf(menuItemGroupProps);
    const itemPropKeys = keysOf(menuItemProps);
    const submenuPropKeys = keysOf(submenuProps);
    function isIgnoredNode(rawNode) {
      return rawNode.type === "divider" || rawNode.type === "render";
    }
    function isDividerNode(rawNode) {
      return rawNode.type === "divider";
    }
    function itemRenderer(tmNode, menuProps) {
      const { rawNode } = tmNode;
      const { show } = rawNode;
      if (typeof show === "boolean" && !show) {
        return null;
      }
      if (isIgnoredNode(rawNode)) {
        if (isDividerNode(rawNode)) {
          return /* @__PURE__ */ vue.h(NMenuDivider, {
            key: tmNode.key,
            ...rawNode.props
          });
        }
        return null;
      }
      const { labelField } = menuProps;
      const { key, level, isGroup } = tmNode;
      const props = {
        ...rawNode,
        title: rawNode.title || rawNode[labelField],
        extra: rawNode.titleExtra || rawNode.extra,
        key,
        internalKey: key,
        level,
        root: level === 0,
        isGroup
      };
      if (tmNode.children) {
        if (tmNode.isGroup) {
          return vue.h(
            NMenuOptionGroup,
            keep(props, groupPropKeys, { tmNode, tmNodes: tmNode.children, key })
          );
        }
        return vue.h(
          NSubmenu,
          keep(props, submenuPropKeys, {
            key,
            rawNodes: rawNode[menuProps.childrenField],
            tmNodes: tmNode.children,
            tmNode
          })
        );
      } else {
        return vue.h(
          NMenuOption,
          keep(props, itemPropKeys, {
            key,
            tmNode
          })
        );
      }
    }

    const hoverStyleChildren = [c$1("&::before", "background-color: var(--n-item-color-hover);"), cE("arrow", `
    color: var(--n-arrow-color-hover);
  `), cE("icon", `
    color: var(--n-item-icon-color-hover);
  `), cB("menu-item-content-header", `
    color: var(--n-item-text-color-hover);
  `, [c$1("a", `
      color: var(--n-item-text-color-hover);
    `), cE("extra", `
      color: var(--n-item-text-color-hover);
    `)])];
    const horizontalHoverStyleChildren = [cE("icon", `
    color: var(--n-item-icon-color-hover-horizontal);
  `), cB("menu-item-content-header", `
    color: var(--n-item-text-color-hover-horizontal);
  `, [c$1("a", `
      color: var(--n-item-text-color-hover-horizontal);
    `), cE("extra", `
      color: var(--n-item-text-color-hover-horizontal);
    `)])];
    var style$u = c$1([cB("menu", `
    background-color: var(--n-color);
    color: var(--n-item-text-color);
    overflow: hidden;
    transition: background-color .3s var(--n-bezier);
    box-sizing: border-box;
    font-size: var(--n-font-size);
    padding-bottom: 6px;
  `, [cM("horizontal", `
      display: inline-flex;
      padding-bottom: 0;
    `, [cB("submenu", "margin: 0;"), cB("menu-item", "margin: 0;"), cB("menu-item-content", `
        padding: 0 20px;
        border-bottom: 2px solid #0000;
      `, [c$1("&::before", "display: none;"), cM("selected", "border-bottom: 2px solid var(--n-border-color-horizontal)")]), cB("menu-item-content", [cM("selected", [cE("icon", "color: var(--n-item-icon-color-active-horizontal);"), cB("menu-item-content-header", `
            color: var(--n-item-text-color-active-horizontal);
          `, [c$1("a", "color: var(--n-item-text-color-active-horizontal);"), cE("extra", "color: var(--n-item-text-color-active-horizontal);")])]), cM("child-active", `
          border-bottom: 2px solid var(--n-border-color-horizontal);
        `, [cB("menu-item-content-header", `
            color: var(--n-item-text-color-child-active-horizontal);
          `, [c$1("a", `
              color: var(--n-item-text-color-child-active-horizontal);
            `), cE("extra", `
              color: var(--n-item-text-color-child-active-horizontal);
            `)]), cE("icon", `
            color: var(--n-item-icon-color-child-active-horizontal);
          `)]), cNotM("disabled", [cNotM("selected, child-active", [c$1("&:focus-within", horizontalHoverStyleChildren)]), cM("selected", [hoverStyle(null, [cE("icon", "color: var(--n-item-icon-color-active-hover-horizontal);"), cB("menu-item-content-header", `
                color: var(--n-item-text-color-active-hover-horizontal);
              `, [c$1("a", "color: var(--n-item-text-color-active-hover-horizontal);"), cE("extra", "color: var(--n-item-text-color-active-hover-horizontal);")])])]), cM("child-active", [hoverStyle(null, [cE("icon", "color: var(--n-item-icon-color-child-active-hover-horizontal);"), cB("menu-item-content-header", `
                color: var(--n-item-text-color-child-active-hover-horizontal);
              `, [c$1("a", "color: var(--n-item-text-color-child-active-hover-horizontal);"), cE("extra", "color: var(--n-item-text-color-child-active-hover-horizontal);")])])]), hoverStyle("border-bottom: 2px solid var(--n-border-color-horizontal);", horizontalHoverStyleChildren)]), cB("menu-item-content-header", [c$1("a", "color: var(--n-item-text-color-horizontal);")])])]), cM("collapsed", [cB("menu-item-content", [cM("selected", [c$1("&::before", `
            background-color: var(--n-item-color-active-collapsed) !important;
          `)]), cB("menu-item-content-header", "opacity: 0;"), cE("arrow", "opacity: 0;"), cE("icon", "color: var(--n-item-icon-color-collapsed);")])]), cB("menu-item", `
      height: var(--n-item-height);
      margin-top: 6px;
      position: relative;
    `), cB("menu-item-content", `
      box-sizing: border-box;
      line-height: 1.75;
      height: 100%;
      display: grid;
      grid-template-areas: "icon content arrow";
      grid-template-columns: auto 1fr auto;
      align-items: center;
      cursor: pointer;
      position: relative;
      padding-right: 18px;
      transition:
        background-color .3s var(--n-bezier),
        padding-left .3s var(--n-bezier),
        border-color .3s var(--n-bezier);
    `, [c$1("> *", "z-index: 1;"), c$1("&::before", `
        z-index: auto;
        content: "";
        background-color: #0000;
        position: absolute;
        left: 8px;
        right: 8px;
        top: 0;
        bottom: 0;
        pointer-events: none;
        border-radius: var(--n-border-radius);
        transition: background-color .3s var(--n-bezier);
      `), cM("disabled", `
        opacity: .45;
        cursor: not-allowed;
      `), cM("collapsed", [cE("arrow", "transform: rotate(0);")]), cM("selected", [c$1("&::before", "background-color: var(--n-item-color-active);"), cE("arrow", "color: var(--n-arrow-color-active);"), cE("icon", "color: var(--n-item-icon-color-active);"), cB("menu-item-content-header", `
          color: var(--n-item-text-color-active);
        `, [c$1("a", "color: var(--n-item-text-color-active);"), cE("extra", "color: var(--n-item-text-color-active);")])]), cM("child-active", [cB("menu-item-content-header", `
          color: var(--n-item-text-color-child-active);
        `, [c$1("a", `
            color: var(--n-item-text-color-child-active);
          `), cE("extra", `
            color: var(--n-item-text-color-child-active);
          `)]), cE("arrow", `
          color: var(--n-arrow-color-child-active);
        `), cE("icon", `
          color: var(--n-item-icon-color-child-active);
        `)]), cNotM("disabled", [cNotM("selected, child-active", [c$1("&:focus-within", hoverStyleChildren)]), cM("selected", [hoverStyle(null, [cE("arrow", "color: var(--n-arrow-color-active-hover);"), cE("icon", "color: var(--n-item-icon-color-active-hover);"), cB("menu-item-content-header", `
              color: var(--n-item-text-color-active-hover);
            `, [c$1("a", "color: var(--n-item-text-color-active-hover);"), cE("extra", "color: var(--n-item-text-color-active-hover);")])])]), cM("child-active", [hoverStyle(null, [cE("arrow", "color: var(--n-arrow-color-child-active-hover);"), cE("icon", "color: var(--n-item-icon-color-child-active-hover);"), cB("menu-item-content-header", `
              color: var(--n-item-text-color-child-active-hover);
            `, [c$1("a", "color: var(--n-item-text-color-child-active-hover);"), cE("extra", "color: var(--n-item-text-color-child-active-hover);")])])]), cM("selected", [hoverStyle(null, [c$1("&::before", "background-color: var(--n-item-color-active-hover);")])]), hoverStyle(null, hoverStyleChildren)]), cE("icon", `
        grid-area: icon;
        color: var(--n-item-icon-color);
        transition:
          color .3s var(--n-bezier),
          font-size .3s var(--n-bezier),
          margin-right .3s var(--n-bezier);
        box-sizing: content-box;
        display: inline-flex;
        align-items: center;
        justify-content: center;
      `), cE("arrow", `
        grid-area: arrow;
        font-size: 16px;
        color: var(--n-arrow-color);
        transform: rotate(180deg);
        opacity: 1;
        transition:
          color .3s var(--n-bezier),
          transform 0.2s var(--n-bezier),
          opacity 0.2s var(--n-bezier);
      `), cB("menu-item-content-header", `
        grid-area: content;
        transition:
          color .3s var(--n-bezier),
          opacity .3s var(--n-bezier);
        opacity: 1;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        color: var(--n-item-text-color);
      `, [c$1("a", `
          outline: none;
          text-decoration: none;
          transition: color .3s var(--n-bezier);
          color: var(--n-item-text-color);
        `, [c$1("&::before", `
            content: "";
            position: absolute;
            left: 0;
            right: 0;
            top: 0;
            bottom: 0;
          `)]), cE("extra", `
          font-size: .93em;
          color: var(--n-group-text-color);
          transition: color .3s var(--n-bezier);
        `)])]), cB("submenu", `
      cursor: pointer;
      position: relative;
      margin-top: 6px;
    `, [cB("menu-item-content", `
        height: var(--n-item-height);
      `), cB("submenu-children", `
        overflow: hidden;
        padding: 0;
      `, [fadeInHeightExpandTransition({
      duration: ".2s"
    })])]), cB("menu-item-group", [cB("menu-item-group-title", `
        margin-top: 6px;
        color: var(--n-group-text-color);
        cursor: default;
        font-size: .93em;
        height: 36px;
        display: flex;
        align-items: center;
        transition:
          padding-left .3s var(--n-bezier),
          color .3s var(--n-bezier);
      `)])]), cB("menu-tooltip", [c$1("a", `
      color: inherit;
      text-decoration: none;
    `)]), cB("menu-divider", `
    transition: background-color .3s var(--n-bezier);
    background-color: var(--n-divider-color);
    height: 1px;
    margin: 6px 18px;
  `)]);

    function hoverStyle(props, children) {
      return [cM("hover", props, children), c$1("&:hover", props, children)];
    }

    function useCheckDeprecated(props) {
      vue.watchEffect(() => {
        if (props.items) {
          warnOnce("menu", "`items` is deprecated, please use `options` instead.");
        }

        if (props.onOpenNamesChange) {
          warnOnce("menu", "`on-open-names-change` is deprecated, please use `on-update:expanded-keys` instead.");
        }

        if (props.onSelect) {
          warnOnce("menu", "`on-select` is deprecated, please use `on-update:value` instead.");
        }

        if (props.onExpandedNamesChange) {
          warnOnce("menu", "`on-expanded-names-change` is deprecated, please use `on-update:expanded-keys` instead.");
        }

        if (props.expandedNames) {
          warnOnce("menu", "`expanded-names` is deprecated, please use `expanded-keys` instead.");
        }

        if (props.defaultExpandedNames) {
          warnOnce("menu", "`default-expanded-names` is deprecated, please use `default-expanded-keys` instead.");
        }
      });
    }

    const menuProps = {
      ...useTheme.props,
      options: {
        type: Array,
        default: () => []
      },
      collapsed: {
        type: Boolean,
        default: void 0
      },
      collapsedWidth: {
        type: Number,
        default: 48
      },
      iconSize: {
        type: Number,
        default: 20
      },
      collapsedIconSize: {
        type: Number,
        default: 24
      },
      rootIndent: Number,
      indent: {
        type: Number,
        default: 32
      },
      labelField: {
        type: String,
        default: "label"
      },
      keyField: {
        type: String,
        default: "key"
      },
      childrenField: {
        type: String,
        default: "children"
      },
      defaultExpandAll: Boolean,
      defaultExpandedKeys: Array,
      expandedKeys: Array,
      value: [String, Number],
      defaultValue: {
        type: [String, Number],
        default: null
      },
      mode: {
        type: String,
        default: "vertical"
      },
      watchProps: {
        type: Array,
        default: void 0
      },
      disabled: Boolean,
      show: {
        type: Boolean,
        defalut: true
      },
      inverted: Boolean,
      "onUpdate:expandedKeys": [Function, Array],
      onUpdateExpandedKeys: [Function, Array],
      onUpdateValue: [Function, Array],
      "onUpdate:value": [Function, Array],
      expandIcon: Function,
      renderIcon: Function,
      renderLabel: Function,
      renderExtra: Function,
      dropdownProps: Object,
      accordion: Boolean,
      nodeProps: Function,
      items: Array,
      onOpenNamesChange: [Function, Array],
      onSelect: [Function, Array],
      onExpandedNamesChange: [Function, Array],
      expandedNames: Array,
      defaultExpandedNames: Array,
      dropdownPlacement: {
        type: String,
        default: "bottom"
      }
    };
    var Menu = vue.defineComponent({
      name: "Menu",
      props: menuProps,
      setup(props) {
        {
          useCheckDeprecated(props);
        }
        const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
        const themeRef = useTheme(
          "Menu",
          "-menu",
          style$u,
          menuLight$1,
          props,
          mergedClsPrefixRef
        );
        const layoutSider = vue.inject(layoutSiderInjectionKey, null);
        const mergedCollapsedRef = vue.computed(() => {
          const { collapsed } = props;
          if (collapsed !== void 0)
            return collapsed;
          if (layoutSider) {
            const { collapseModeRef, collapsedRef } = layoutSider;
            if (collapseModeRef.value === "width") {
              return collapsedRef.value ?? false;
            }
          }
          return false;
        });
        const treeMateRef = vue.computed(() => {
          const { keyField, childrenField } = props;
          return createTreeMate(
            props.items || props.options,
            {
              getChildren(node) {
                return node[childrenField];
              },
              getKey(node) {
                return node[keyField] ?? node.name;
              }
            }
          );
        });
        const treeKeysLevelOneRef = vue.computed(
          () => new Set(treeMateRef.value.treeNodes.map((e) => e.key))
        );
        const { watchProps } = props;
        const uncontrolledValueRef = vue.ref(null);
        if (watchProps?.includes("defaultValue")) {
          vue.watchEffect(() => {
            uncontrolledValueRef.value = props.defaultValue;
          });
        } else {
          uncontrolledValueRef.value = props.defaultValue;
        }
        const controlledValueRef = vue.toRef(props, "value");
        const mergedValueRef = useMergedState(
          controlledValueRef,
          uncontrolledValueRef
        );
        const uncontrolledExpandedKeysRef = vue.ref([]);
        const initUncontrolledExpandedKeys = () => {
          uncontrolledExpandedKeysRef.value = props.defaultExpandAll ? treeMateRef.value.getNonLeafKeys() : props.defaultExpandedNames || props.defaultExpandedKeys || treeMateRef.value.getPath(mergedValueRef.value, {
            includeSelf: false
          }).keyPath;
        };
        if (watchProps?.includes("defaultExpandedKeys")) {
          vue.watchEffect(initUncontrolledExpandedKeys);
        } else {
          initUncontrolledExpandedKeys();
        }
        const controlledExpandedKeysRef = useCompitable(props, [
          "expandedNames",
          "expandedKeys"
        ]);
        const mergedExpandedKeysRef = useMergedState(
          controlledExpandedKeysRef,
          uncontrolledExpandedKeysRef
        );
        const tmNodesRef = vue.computed(() => treeMateRef.value.treeNodes);
        const activePathRef = vue.computed(() => {
          return treeMateRef.value.getPath(mergedValueRef.value).keyPath;
        });
        vue.provide(menuInjectionKey, {
          props,
          mergedCollapsedRef,
          mergedThemeRef: themeRef,
          mergedValueRef,
          mergedExpandedKeysRef,
          activePathRef,
          mergedClsPrefixRef,
          isHorizontalRef: vue.computed(() => props.mode === "horizontal"),
          invertedRef: vue.toRef(props, "inverted"),
          doSelect,
          toggleExpand
        });
        function doSelect(value, item) {
          const {
            "onUpdate:value": _onUpdateValue,
            onUpdateValue,
            onSelect
          } = props;
          if (onUpdateValue) {
            call(onUpdateValue, value, item);
          }
          if (_onUpdateValue) {
            call(_onUpdateValue, value, item);
          }
          if (onSelect) {
            call(onSelect, value, item);
          }
          uncontrolledValueRef.value = value;
        }
        function doUpdateExpandedKeys(value) {
          const {
            "onUpdate:expandedKeys": _onUpdateExpandedKeys,
            onUpdateExpandedKeys,
            onExpandedNamesChange,
            onOpenNamesChange
          } = props;
          if (_onUpdateExpandedKeys) {
            call(_onUpdateExpandedKeys, value);
          }
          if (onUpdateExpandedKeys) {
            call(onUpdateExpandedKeys, value);
          }
          if (onExpandedNamesChange) {
            call(onExpandedNamesChange, value);
          }
          if (onOpenNamesChange) {
            call(onOpenNamesChange, value);
          }
          uncontrolledExpandedKeysRef.value = value;
        }
        function toggleExpand(key) {
          const currentExpandedKeys = Array.from(mergedExpandedKeysRef.value);
          const index = currentExpandedKeys.findIndex(
            (expanededKey) => expanededKey === key
          );
          if (~index) {
            currentExpandedKeys.splice(index, 1);
          } else {
            if (props.accordion) {
              if (treeKeysLevelOneRef.value.has(key)) {
                const closeKeyIndex = currentExpandedKeys.findIndex(
                  (e) => treeKeysLevelOneRef.value.has(e)
                );
                if (closeKeyIndex > -1) {
                  currentExpandedKeys.splice(closeKeyIndex, 1);
                }
              }
            }
            currentExpandedKeys.push(key);
          }
          doUpdateExpandedKeys(currentExpandedKeys);
        }
        const showOption = (key) => {
          const selectedKeyPath = treeMateRef.value.getPath(
            key ?? mergedValueRef.value,
            {
              includeSelf: false
            }
          ).keyPath;
          if (!selectedKeyPath.length)
            return;
          const currentExpandedKeys = Array.from(mergedExpandedKeysRef.value);
          const nextExpandedKeys = /* @__PURE__ */ new Set([
            ...currentExpandedKeys,
            ...selectedKeyPath
          ]);
          if (props.accordion) {
            treeKeysLevelOneRef.value.forEach((firstLevelKey) => {
              if (nextExpandedKeys.has(firstLevelKey) && !selectedKeyPath.includes(firstLevelKey)) {
                nextExpandedKeys.delete(firstLevelKey);
              }
            });
          }
          doUpdateExpandedKeys(Array.from(nextExpandedKeys));
        };
        const cssVarsRef = vue.computed(() => {
          const { inverted } = props;
          const {
            common: { cubicBezierEaseInOut },
            self
          } = themeRef.value;
          const {
            borderRadius,
            borderColorHorizontal,
            fontSize,
            itemHeight,
            dividerColor
          } = self;
          const vars = {
            "--n-divider-color": dividerColor,
            "--n-bezier": cubicBezierEaseInOut,
            "--n-font-size": fontSize,
            "--n-border-color-horizontal": borderColorHorizontal,
            "--n-border-radius": borderRadius,
            "--n-item-height": itemHeight
          };
          if (inverted) {
            vars["--n-group-text-color"] = self.groupTextColorInverted;
            vars["--n-color"] = self.colorInverted;
            vars["--n-item-text-color"] = self.itemTextColorInverted;
            vars["--n-item-text-color-hover"] = self.itemTextColorHoverInverted;
            vars["--n-item-text-color-active"] = self.itemTextColorActiveInverted;
            vars["--n-item-text-color-child-active"] = self.itemTextColorChildActiveInverted;
            vars["--n-item-text-color-child-active-hover"] = self.itemTextColorChildActiveInverted;
            vars["--n-item-text-color-active-hover"] = self.itemTextColorActiveHoverInverted;
            vars["--n-item-icon-color"] = self.itemIconColorInverted;
            vars["--n-item-icon-color-hover"] = self.itemIconColorHoverInverted;
            vars["--n-item-icon-color-active"] = self.itemIconColorActiveInverted;
            vars["--n-item-icon-color-active-hover"] = self.itemIconColorActiveHoverInverted;
            vars["--n-item-icon-color-child-active"] = self.itemIconColorChildActiveInverted;
            vars["--n-item-icon-color-child-active-hover"] = self.itemIconColorChildActiveHoverInverted;
            vars["--n-item-icon-color-collapsed"] = self.itemIconColorCollapsedInverted;
            vars["--n-item-text-color-horizontal"] = self.itemTextColorHorizontalInverted;
            vars["--n-item-text-color-hover-horizontal"] = self.itemTextColorHoverHorizontalInverted;
            vars["--n-item-text-color-active-horizontal"] = self.itemTextColorActiveHorizontalInverted;
            vars["--n-item-text-color-child-active-horizontal"] = self.itemTextColorChildActiveHorizontalInverted;
            vars["--n-item-text-color-child-active-hover-horizontal"] = self.itemTextColorChildActiveHoverHorizontalInverted;
            vars["--n-item-text-color-active-hover-horizontal"] = self.itemTextColorActiveHoverHorizontalInverted;
            vars["--n-item-icon-color-horizontal"] = self.itemIconColorHorizontalInverted;
            vars["--n-item-icon-color-hover-horizontal"] = self.itemIconColorHoverHorizontalInverted;
            vars["--n-item-icon-color-active-horizontal"] = self.itemIconColorActiveHorizontalInverted;
            vars["--n-item-icon-color-active-hover-horizontal"] = self.itemIconColorActiveHoverHorizontalInverted;
            vars["--n-item-icon-color-child-active-horizontal"] = self.itemIconColorChildActiveHorizontalInverted;
            vars["--n-item-icon-color-child-active-hover-horizontal"] = self.itemIconColorChildActiveHoverHorizontalInverted;
            vars["--n-arrow-color"] = self.arrowColorInverted;
            vars["--n-arrow-color-hover"] = self.arrowColorHoverInverted;
            vars["--n-arrow-color-active"] = self.arrowColorActiveInverted;
            vars["--n-arrow-color-active-hover"] = self.arrowColorActiveHoverInverted;
            vars["--n-arrow-color-child-active"] = self.arrowColorChildActiveInverted;
            vars["--n-arrow-color-child-active-hover"] = self.arrowColorChildActiveHoverInverted;
            vars["--n-item-color-hover"] = self.itemColorHoverInverted;
            vars["--n-item-color-active"] = self.itemColorActiveInverted;
            vars["--n-item-color-active-hover"] = self.itemColorActiveHoverInverted;
            vars["--n-item-color-active-collapsed"] = self.itemColorActiveCollapsedInverted;
          } else {
            vars["--n-group-text-color"] = self.groupTextColor;
            vars["--n-color"] = self.color;
            vars["--n-item-text-color"] = self.itemTextColor;
            vars["--n-item-text-color-hover"] = self.itemTextColorHover;
            vars["--n-item-text-color-active"] = self.itemTextColorActive;
            vars["--n-item-text-color-child-active"] = self.itemTextColorChildActive;
            vars["--n-item-text-color-child-active-hover"] = self.itemTextColorChildActiveHover;
            vars["--n-item-text-color-active-hover"] = self.itemTextColorActiveHover;
            vars["--n-item-icon-color"] = self.itemIconColor;
            vars["--n-item-icon-color-hover"] = self.itemIconColorHover;
            vars["--n-item-icon-color-active"] = self.itemIconColorActive;
            vars["--n-item-icon-color-active-hover"] = self.itemIconColorActiveHover;
            vars["--n-item-icon-color-child-active"] = self.itemIconColorChildActive;
            vars["--n-item-icon-color-child-active-hover"] = self.itemIconColorChildActiveHover;
            vars["--n-item-icon-color-collapsed"] = self.itemIconColorCollapsed;
            vars["--n-item-text-color-horizontal"] = self.itemTextColorHorizontal;
            vars["--n-item-text-color-hover-horizontal"] = self.itemTextColorHoverHorizontal;
            vars["--n-item-text-color-active-horizontal"] = self.itemTextColorActiveHorizontal;
            vars["--n-item-text-color-child-active-horizontal"] = self.itemTextColorChildActiveHorizontal;
            vars["--n-item-text-color-child-active-hover-horizontal"] = self.itemTextColorChildActiveHoverHorizontal;
            vars["--n-item-text-color-active-hover-horizontal"] = self.itemTextColorActiveHoverHorizontal;
            vars["--n-item-icon-color-horizontal"] = self.itemIconColorHorizontal;
            vars["--n-item-icon-color-hover-horizontal"] = self.itemIconColorHoverHorizontal;
            vars["--n-item-icon-color-active-horizontal"] = self.itemIconColorActiveHorizontal;
            vars["--n-item-icon-color-active-hover-horizontal"] = self.itemIconColorActiveHoverHorizontal;
            vars["--n-item-icon-color-child-active-horizontal"] = self.itemIconColorChildActiveHorizontal;
            vars["--n-item-icon-color-child-active-hover-horizontal"] = self.itemIconColorChildActiveHoverHorizontal;
            vars["--n-arrow-color"] = self.arrowColor;
            vars["--n-arrow-color-hover"] = self.arrowColorHover;
            vars["--n-arrow-color-active"] = self.arrowColorActive;
            vars["--n-arrow-color-active-hover"] = self.arrowColorActiveHover;
            vars["--n-arrow-color-child-active"] = self.arrowColorChildActive;
            vars["--n-arrow-color-child-active-hover"] = self.arrowColorChildActiveHover;
            vars["--n-item-color-hover"] = self.itemColorHover;
            vars["--n-item-color-active"] = self.itemColorActive;
            vars["--n-item-color-active-hover"] = self.itemColorActiveHover;
            vars["--n-item-color-active-collapsed"] = self.itemColorActiveCollapsed;
          }
          return vars;
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass(
          "menu",
          vue.computed(() => props.inverted ? "a" : "b"),
          cssVarsRef,
          props
        ) : void 0;
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          controlledExpandedKeys: controlledExpandedKeysRef,
          uncontrolledExpanededKeys: uncontrolledExpandedKeysRef,
          mergedExpandedKeys: mergedExpandedKeysRef,
          uncontrolledValue: uncontrolledValueRef,
          mergedValue: mergedValueRef,
          activePath: activePathRef,
          tmNodes: tmNodesRef,
          mergedTheme: themeRef,
          mergedCollapsed: mergedCollapsedRef,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender,
          showOption
        };
      },
      render() {
        const { mergedClsPrefix, mode, themeClass, onRender } = this;
        onRender?.();
        return /* @__PURE__ */ vue.h("div", {
          role: mode === "horizontal" ? "menubar" : "menu",
          class: [
            `${mergedClsPrefix}-menu`,
            themeClass,
            `${mergedClsPrefix}-menu--${mode}`,
            this.mergedCollapsed && `${mergedClsPrefix}-menu--collapsed`
          ],
          style: this.cssVars
        }, this.tmNodes.map((tmNode) => itemRenderer(tmNode, this.$props)));
      }
    });

    function getRelativePosition(element) {
      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        debug: false,
        useSelectionEnd: false,
        checkWidthOverflow: true
      };
      const selectionStart = element.selectionStart !== null ? element.selectionStart : 0;
      const selectionEnd = element.selectionEnd !== null ? element.selectionEnd : 0;
      const position = options.useSelectionEnd ? selectionEnd : selectionStart;
      const properties = ["direction", "boxSizing", "width", "height", "overflowX", "overflowY", "borderTopWidth", "borderRightWidth", "borderBottomWidth", "borderLeftWidth", "borderStyle", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "fontStyle", "fontVariant", "fontWeight", "fontStretch", "fontSize", "fontSizeAdjust", "lineHeight", "fontFamily", "textAlign", "textTransform", "textIndent", "textDecoration", "letterSpacing", "wordSpacing", "tabSize", "MozTabSize"];
      const isFirefox = navigator.userAgent.toLowerCase().includes("firefox");

      if (!isBrowser$2) {
        throw new Error("textarea-caret-position#getCaretPosition should only be called in a browser");
      }

      const debug = options === null || options === void 0 ? void 0 : options.debug;

      if (debug) {
        const el = document.querySelector("#input-textarea-caret-position-mirror-div");
        if (el !== null && el !== void 0 && el.parentNode) el.parentNode.removeChild(el);
      }

      const div = document.createElement("div");
      div.id = "input-textarea-caret-position-mirror-div";
      document.body.appendChild(div);
      const style = div.style;
      const computed = window.getComputedStyle ? window.getComputedStyle(element) : element.currentStyle;
      const isInput = element.nodeName === "INPUT";
      style.whiteSpace = isInput ? "nowrap" : "pre-wrap";
      if (!isInput) style.wordWrap = "break-word";
      style.position = "absolute";
      if (!debug) style.visibility = "hidden";
      properties.forEach(prop => {
        if (isInput && prop === "lineHeight") {
          if (computed.boxSizing === "border-box") {
            const height = parseInt(computed.height);
            const outerHeight = parseInt(computed.paddingTop) + parseInt(computed.paddingBottom) + parseInt(computed.borderTopWidth) + parseInt(computed.borderBottomWidth);
            const targetHeight = outerHeight + parseInt(computed.lineHeight);

            if (height > targetHeight) {
              style.lineHeight = `${height - outerHeight}px`;
            } else if (height === targetHeight) {
              style.lineHeight = computed.lineHeight;
            } else {
              style.lineHeight = "0";
            }
          } else {
            style.lineHeight = computed.height;
          }
        } else {
          style[prop] = computed[prop];
        }
      });

      if (isFirefox) {
        if (element.scrollHeight > parseInt(computed.height)) {
          style.overflowY = "scroll";
        }
      } else {
        style.overflow = "hidden";
      }

      div.textContent = element.value.substring(0, position);

      if (isInput && div.textContent) {
        div.textContent = div.textContent.replace(/\s/g, "\xA0");
      }

      const span = document.createElement("span");
      span.textContent = element.value.substring(position) || ".";
      span.style.position = "relative";
      span.style.left = `${-element.scrollLeft}px`;
      span.style.top = `${-element.scrollTop}px`;
      div.appendChild(span);
      const relativePosition = {
        top: span.offsetTop + parseInt(computed.borderTopWidth),
        left: span.offsetLeft + parseInt(computed.borderLeftWidth),
        absolute: false,
        height: parseInt(computed.fontSize) * 1.5
      };

      if (debug) {
        span.style.backgroundColor = "#aaa";
      } else {
        document.body.removeChild(div);
      }

      if (relativePosition.left >= element.clientWidth && options.checkWidthOverflow) {
        relativePosition.left = element.clientWidth;
      }

      return relativePosition;
    }

    var style$t = c$1([cB("mention", "width: 100%; z-index: auto; position: relative;"), cB("mention-menu", `
    box-shadow: var(--n-menu-box-shadow);
  `, [fadeInScaleUpTransition({
      originalTransition: "background-color .3s var(--n-bezier), box-shadow .3s var(--n-bezier)"
    })])]);

    const mentionProps = {
      ...useTheme.props,
      to: useAdjustedTo.propTo,
      autosize: [Boolean, Object],
      options: {
        type: Array,
        default: []
      },
      type: {
        type: String,
        default: "text"
      },
      separator: {
        type: String,
        validator: (separator) => {
          if (separator.length !== 1) {
            warn$2("mention", "`separator`'s length must be 1.");
            return false;
          }
          return true;
        },
        default: " "
      },
      bordered: {
        type: Boolean,
        default: void 0
      },
      disabled: Boolean,
      value: String,
      defaultValue: {
        type: String,
        default: ""
      },
      loading: Boolean,
      prefix: {
        type: [String, Array],
        default: "@"
      },
      placeholder: {
        type: String,
        default: ""
      },
      placement: {
        type: String,
        default: "bottom-start"
      },
      size: String,
      renderLabel: Function,
      status: String,
      "onUpdate:value": [Array, Function],
      onUpdateValue: [Array, Function],
      onSearch: Function,
      onSelect: Function,
      onFocus: Function,
      onBlur: Function,
      internalDebug: Boolean
    };
    var Mention = vue.defineComponent({
      name: "Mention",
      props: mentionProps,
      setup(props) {
        const {
          namespaceRef,
          mergedClsPrefixRef,
          mergedBorderedRef,
          inlineThemeDisabled
        } = useConfig(props);
        const themeRef = useTheme(
          "Mention",
          "-mention",
          style$t,
          mentionLight$1,
          props,
          mergedClsPrefixRef
        );
        const formItem = useFormItem(props);
        const inputInstRef = vue.ref(null);
        const cursorRef = vue.ref(null);
        const followerRef = vue.ref(null);
        const partialPatternRef = vue.ref("");
        let cachedPrefix = null;
        let cachedPartialPatternStart = null;
        let cachedPartialPatternEnd = null;
        const filteredOptionsRef = vue.computed(() => {
          const { value: pattern } = partialPatternRef;
          return props.options.filter((option) => {
            if (!pattern)
              return true;
            if (typeof option.label === "string") {
              return option.label.startsWith(pattern);
            }
            if (typeof option.value === "string") {
              return option.value.startsWith(pattern);
            }
            return false;
          });
        });
        const treeMateRef = vue.computed(() => {
          return createTreeMate(filteredOptionsRef.value, {
            getKey: (v) => {
              return v.value;
            }
          });
        });
        const selectMenuInstRef = vue.ref(null);
        const showMenuRef = vue.ref(false);
        const uncontrolledValueRef = vue.ref(props.defaultValue);
        const controlledValueRef = vue.toRef(props, "value");
        const mergedValueRef = useMergedState(
          controlledValueRef,
          uncontrolledValueRef
        );
        const cssVarsRef = vue.computed(() => {
          const {
            self: { menuBoxShadow }
          } = themeRef.value;
          return {
            "--n-menu-box-shadow": menuBoxShadow
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("mention", void 0, cssVarsRef, props) : void 0;
        function doUpdateShowMenu(show) {
          if (props.disabled)
            return;
          if (!show) {
            cachedPrefix = null;
            cachedPartialPatternStart = null;
            cachedPartialPatternEnd = null;
          }
          showMenuRef.value = show;
        }
        function doUpdateValue(value) {
          const { onUpdateValue, "onUpdate:value": _onUpdateValue } = props;
          const { nTriggerFormChange, nTriggerFormInput } = formItem;
          if (_onUpdateValue) {
            call(_onUpdateValue, value);
          }
          if (onUpdateValue) {
            call(onUpdateValue, value);
          }
          nTriggerFormInput();
          nTriggerFormChange();
          uncontrolledValueRef.value = value;
        }
        function getInputEl() {
          return props.type === "text" ? inputInstRef.value.inputElRef : inputInstRef.value.textareaElRef;
        }
        function deriveShowMenu() {
          const inputEl = getInputEl();
          if (document.activeElement !== inputEl) {
            doUpdateShowMenu(false);
            return;
          }
          const { selectionEnd } = inputEl;
          if (selectionEnd === null) {
            doUpdateShowMenu(false);
            return;
          }
          const inputValue = inputEl.value;
          const { separator } = props;
          const { prefix } = props;
          const prefixArray = typeof prefix === "string" ? [prefix] : prefix;
          for (let i = selectionEnd - 1; i >= 0; --i) {
            const char = inputValue[i];
            if (char === separator || char === "\n" || char === "\r") {
              doUpdateShowMenu(false);
              return;
            }
            if (prefixArray.includes(char)) {
              const partialPattern = inputValue.slice(i + 1, selectionEnd);
              doUpdateShowMenu(true);
              props.onSearch?.(partialPattern, char);
              partialPatternRef.value = partialPattern;
              cachedPrefix = char;
              cachedPartialPatternStart = i + 1;
              cachedPartialPatternEnd = selectionEnd;
              return;
            }
          }
          doUpdateShowMenu(false);
        }
        function syncCursor() {
          const { value: cursorAnchor } = cursorRef;
          if (!cursorAnchor)
            return;
          const inputEl = getInputEl();
          const cursorPos = getRelativePosition(inputEl);
          cursorPos.left += inputEl.parentElement.offsetLeft;
          cursorAnchor.style.left = `${cursorPos.left}px`;
          cursorAnchor.style.top = `${cursorPos.top + cursorPos.height}px`;
        }
        function syncPosition() {
          if (!showMenuRef.value)
            return;
          followerRef.value?.syncPosition();
        }
        function handleInputUpdateValue(value) {
          doUpdateValue(value);
          syncAfterCursorMove();
        }
        function syncAfterCursorMove() {
          setTimeout(() => {
            syncCursor();
            deriveShowMenu();
            void vue.nextTick().then(syncPosition);
          }, 0);
        }
        function handleInputKeyDown(e) {
          if (e.key === "ArrowLeft" || e.key === "ArrowRight") {
            if (inputInstRef.value?.isCompositing)
              return;
            syncAfterCursorMove();
          } else if (e.key === "ArrowUp" || e.key === "ArrowDown" || e.key === "Enter") {
            if (inputInstRef.value?.isCompositing)
              return;
            const { value: selectMenuInst } = selectMenuInstRef;
            if (showMenuRef.value) {
              if (selectMenuInst) {
                e.preventDefault();
                if (e.key === "ArrowUp") {
                  selectMenuInst.prev();
                } else if (e.key === "ArrowDown") {
                  selectMenuInst.next();
                } else {
                  const pendingOptionTmNode = selectMenuInst.getPendingTmNode();
                  if (pendingOptionTmNode) {
                    handleSelect(pendingOptionTmNode);
                  } else {
                    doUpdateShowMenu(false);
                  }
                }
              }
            } else {
              syncAfterCursorMove();
            }
          }
        }
        function handleInputFocus(e) {
          const { onFocus } = props;
          onFocus?.(e);
          const { nTriggerFormFocus } = formItem;
          nTriggerFormFocus();
          syncAfterCursorMove();
        }
        function focus() {
          inputInstRef.value?.focus();
        }
        function blur() {
          inputInstRef.value?.blur();
        }
        function handleInputBlur(e) {
          const { onBlur } = props;
          onBlur?.(e);
          const { nTriggerFormBlur } = formItem;
          nTriggerFormBlur();
          doUpdateShowMenu(false);
        }
        function handleSelect(tmNode) {
          if (cachedPrefix === null || cachedPartialPatternStart === null || cachedPartialPatternEnd === null) {
            {
              warn$2(
                "mention",
                "Cache works unexpectly, this is probably a bug. Please create an issue."
              );
            }
            return;
          }
          const {
            rawNode: { value = "" }
          } = tmNode;
          const inputEl = getInputEl();
          const inputValue = inputEl.value;
          const { separator } = props;
          const nextEndPart = inputValue.slice(cachedPartialPatternEnd);
          const alreadySeparated = nextEndPart.startsWith(separator);
          const nextMiddlePart = `${value}${alreadySeparated ? "" : separator}`;
          doUpdateValue(
            inputValue.slice(0, cachedPartialPatternStart) + nextMiddlePart + nextEndPart
          );
          props.onSelect?.(tmNode.rawNode, cachedPrefix);
          const nextSelectionEnd = cachedPartialPatternStart + nextMiddlePart.length + (alreadySeparated ? 1 : 0);
          void vue.nextTick().then(() => {
            inputEl.selectionStart = nextSelectionEnd;
            inputEl.selectionEnd = nextSelectionEnd;
            deriveShowMenu();
          });
        }
        function handleInputMouseDown() {
          if (!props.disabled) {
            syncAfterCursorMove();
          }
        }
        return {
          namespace: namespaceRef,
          mergedClsPrefix: mergedClsPrefixRef,
          mergedBordered: mergedBorderedRef,
          mergedSize: formItem.mergedSizeRef,
          mergedStatus: formItem.mergedStatusRef,
          mergedTheme: themeRef,
          treeMate: treeMateRef,
          selectMenuInstRef,
          inputInstRef,
          cursorRef,
          followerRef,
          showMenu: showMenuRef,
          adjustedTo: useAdjustedTo(props),
          isMounted: isMounted(),
          mergedValue: mergedValueRef,
          handleInputFocus,
          handleInputBlur,
          handleInputUpdateValue,
          handleInputKeyDown,
          handleSelect,
          handleInputMouseDown,
          focus,
          blur,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender
        };
      },
      render() {
        const { mergedTheme, mergedClsPrefix, $slots } = this;
        return /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-mention`
        }, /* @__PURE__ */ vue.h(NInput, {
          status: this.mergedStatus,
          themeOverrides: mergedTheme.peerOverrides.Input,
          theme: mergedTheme.peers.Input,
          size: this.mergedSize,
          autosize: this.autosize,
          type: this.type,
          ref: "inputInstRef",
          placeholder: this.placeholder,
          onMousedown: this.handleInputMouseDown,
          onUpdateValue: this.handleInputUpdateValue,
          onKeydown: this.handleInputKeyDown,
          onFocus: this.handleInputFocus,
          onBlur: this.handleInputBlur,
          bordered: this.mergedBordered,
          disabled: this.disabled,
          value: this.mergedValue
        }), /* @__PURE__ */ vue.h(VBinder, null, {
          default: () => [
            /* @__PURE__ */ vue.h(VTarget, null, {
              default: () => {
                const style2 = {
                  position: "absolute",
                  width: 0,
                  height: 0
                };
                if (this.internalDebug) {
                  style2.width = "1px";
                  style2.height = "1px";
                  style2.background = "red";
                }
                return /* @__PURE__ */ vue.h("div", {
                  style: style2,
                  ref: "cursorRef"
                });
              }
            }),
            /* @__PURE__ */ vue.h(VFollower, {
              ref: "followerRef",
              placement: this.placement,
              show: this.showMenu,
              containerClass: this.namespace,
              to: this.adjustedTo,
              teleportDisabled: this.adjustedTo === useAdjustedTo.tdkey
            }, {
              default: () => /* @__PURE__ */ vue.h(vue.Transition, {
                name: "fade-in-scale-up-transition",
                appear: this.isMounted
              }, {
                default: () => {
                  const { mergedTheme: mergedTheme2, onRender } = this;
                  onRender?.();
                  return this.showMenu ? /* @__PURE__ */ vue.h(NInternalSelectMenu, {
                    clsPrefix: mergedClsPrefix,
                    theme: mergedTheme2.peers.InternalSelectMenu,
                    themeOverrides: mergedTheme2.peerOverrides.InternalSelectMenu,
                    autoPending: true,
                    ref: "selectMenuInstRef",
                    class: [
                      `${mergedClsPrefix}-mention-menu`,
                      this.themeClass
                    ],
                    loading: this.loading,
                    treeMate: this.treeMate,
                    virtualScroll: false,
                    style: this.cssVars,
                    onToggle: this.handleSelect,
                    renderLabel: this.renderLabel
                  }, $slots) : null;
                }
              })
            })
          ]
        }));
      }
    });

    const messageProps = {
      icon: Function,
      type: {
        type: String,
        default: "info"
      },
      content: [String, Number, Function],
      showIcon: {
        type: Boolean,
        default: true
      },
      closable: Boolean,
      keepAliveOnHover: Boolean,
      onClose: Function,
      onMouseenter: Function,
      onMouseleave: Function
    };

    const messageApiInjectionKey = createInjectionKey("n-message-api");
    const messageProviderInjectionKey = createInjectionKey("n-message-provider");

    var style$s = c$1([cB("message-wrapper", `
    margin: var(--n-margin);
    z-index: 0;
    transform-origin: top center;
    display: flex;
  `, [fadeInHeightExpandTransition({
      overflow: "visible",
      originalTransition: "transform .3s var(--n-bezier)",
      enterToProps: {
        transform: "scale(1)"
      },
      leaveToProps: {
        transform: "scale(0.85)"
      }
    })]), cB("message", `
    box-sizing: border-box;
    display: flex;
    align-items: center;
    transition:
      color .3s var(--n-bezier),
      box-shadow .3s var(--n-bezier),
      background-color .3s var(--n-bezier),
      opacity .3s var(--n-bezier),
      transform .3s var(--n-bezier),
      margin-bottom .3s var(--n-bezier);
    padding: var(--n-padding);
    border-radius: var(--n-border-radius);
    flex-wrap: nowrap;
    overflow: hidden;
    max-width: var(--n-max-width);
    color: var(--n-text-color);
    background-color: var(--n-color);
    box-shadow: var(--n-box-shadow);
  `, [cE("content", `
      display: inline-block;
      line-height: var(--n-line-height);
      font-size: var(--n-font-size);
    `), cE("icon", `
      position: relative;
      margin: var(--n-icon-margin);
      height: var(--n-icon-size);
      width: var(--n-icon-size);
      font-size: var(--n-icon-size);
      flex-shrink: 0;
    `, [["default", "info", "success", "warning", "error", "loading"].map(type => cM(`${type}-type`, [c$1("> *", `
            color: var(--n-icon-color-${type});
            transition: color .3s var(--n-bezier);
          `)])), c$1("> *", `
        position: absolute;
        left: 0;
        top: 0;
        right: 0;
        bottom: 0;
      `, [iconSwitchTransition()])]), cE("close", `
      margin: var(--n-close-margin);
      transition:
        background-color .3s var(--n-bezier),
        color .3s var(--n-bezier);
      flex-shrink: 0;
    `, [c$1("&:hover", `
        color: var(--n-close-icon-color-hover);
      `), c$1("&:active", `
        color: var(--n-close-icon-color-pressed);
      `)])]), cB("message-container", `
    z-index: 6000;
    position: fixed;
    height: 0;
    overflow: visible;
    display: flex;
    flex-direction: column;
    align-items: center;
  `, [cM("top", `
      top: 12px;
      left: 0;
      right: 0;
    `), cM("top-left", `
      top: 12px;
      left: 12px;
      right: 0;
      align-items: flex-start;
    `), cM("top-right", `
      top: 12px;
      left: 0;
      right: 12px;
      align-items: flex-end;
    `), cM("bottom", `
      bottom: 4px;
      left: 0;
      right: 0;
      justify-content: flex-end;
    `), cM("bottom-left", `
      bottom: 4px;
      left: 12px;
      right: 0;
      justify-content: flex-end;
      align-items: flex-start;
    `), cM("bottom-right", `
      bottom: 4px;
      left: 0;
      right: 12px;
      justify-content: flex-end;
      align-items: flex-end;
    `)])]);

    const iconRenderMap$1 = {
      info: () => /* @__PURE__ */ vue.h(InfoIcon, null),
      success: () => /* @__PURE__ */ vue.h(SuccessIcon, null),
      warning: () => /* @__PURE__ */ vue.h(WarningIcon, null),
      error: () => /* @__PURE__ */ vue.h(ErrorIcon, null),
      default: () => null
    };
    var NMessage = vue.defineComponent({
      name: "Message",
      props: {
        ...messageProps,
        render: Function
      },
      setup(props) {
        const { inlineThemeDisabled, mergedRtlRef } = useConfig(props);
        const {
          props: messageProviderProps,
          mergedClsPrefixRef
        } = vue.inject(messageProviderInjectionKey);
        const rtlEnabledRef = useRtl("Message", mergedRtlRef, mergedClsPrefixRef);
        const themeRef = useTheme(
          "Message",
          "-message",
          style$s,
          messageLight$1,
          messageProviderProps,
          mergedClsPrefixRef
        );
        const cssVarsRef = vue.computed(() => {
          const { type } = props;
          const {
            common: { cubicBezierEaseInOut },
            self: {
              padding,
              margin,
              maxWidth,
              iconMargin,
              closeMargin,
              closeSize,
              iconSize,
              fontSize,
              lineHeight,
              borderRadius,
              iconColorInfo,
              iconColorSuccess,
              iconColorWarning,
              iconColorError,
              iconColorLoading,
              closeIconSize,
              closeBorderRadius,
              [createKey("textColor", type)]: textColor,
              [createKey("boxShadow", type)]: boxShadow,
              [createKey("color", type)]: color,
              [createKey("closeColorHover", type)]: closeColorHover,
              [createKey("closeColorPressed", type)]: closeColorPressed,
              [createKey("closeIconColor", type)]: closeIconColor,
              [createKey("closeIconColorPressed", type)]: closeIconColorPressed,
              [createKey("closeIconColorHover", type)]: closeIconColorHover
            }
          } = themeRef.value;
          return {
            "--n-bezier": cubicBezierEaseInOut,
            "--n-margin": margin,
            "--n-padding": padding,
            "--n-max-width": maxWidth,
            "--n-font-size": fontSize,
            "--n-icon-margin": iconMargin,
            "--n-icon-size": iconSize,
            "--n-close-icon-size": closeIconSize,
            "--n-close-border-radius": closeBorderRadius,
            "--n-close-size": closeSize,
            "--n-close-margin": closeMargin,
            "--n-text-color": textColor,
            "--n-color": color,
            "--n-box-shadow": boxShadow,
            "--n-icon-color-info": iconColorInfo,
            "--n-icon-color-success": iconColorSuccess,
            "--n-icon-color-warning": iconColorWarning,
            "--n-icon-color-error": iconColorError,
            "--n-icon-color-loading": iconColorLoading,
            "--n-close-color-hover": closeColorHover,
            "--n-close-color-pressed": closeColorPressed,
            "--n-close-icon-color": closeIconColor,
            "--n-close-icon-color-pressed": closeIconColorPressed,
            "--n-close-icon-color-hover": closeIconColorHover,
            "--n-line-height": lineHeight,
            "--n-border-radius": borderRadius
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass(
          "message",
          vue.computed(() => props.type[0]),
          cssVarsRef,
          {}
        ) : void 0;
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          rtlEnabled: rtlEnabledRef,
          messageProviderProps,
          handleClose() {
            props.onClose?.();
          },
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender,
          placement: messageProviderProps.placement
        };
      },
      render() {
        const {
          render: renderMessage,
          type,
          closable,
          content,
          mergedClsPrefix,
          cssVars,
          themeClass,
          onRender,
          icon,
          handleClose,
          showIcon
        } = this;
        onRender?.();
        let iconNode;
        return /* @__PURE__ */ vue.h("div", {
          class: [`${mergedClsPrefix}-message-wrapper`, themeClass],
          onMouseenter: this.onMouseenter,
          onMouseleave: this.onMouseleave,
          style: [
            {
              alignItems: this.placement.startsWith("top") ? "flex-start" : "flex-end"
            },
            cssVars
          ]
        }, renderMessage ? renderMessage(this.$props) : /* @__PURE__ */ vue.h("div", {
          class: [
            `${mergedClsPrefix}-message ${mergedClsPrefix}-message--${type}-type`,
            this.rtlEnabled && `${mergedClsPrefix}-message--rtl`
          ]
        }, (iconNode = createIconVNode(icon, type, mergedClsPrefix)) && showIcon ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-message__icon ${mergedClsPrefix}-message__icon--${type}-type`
        }, /* @__PURE__ */ vue.h(NIconSwitchTransition, null, {
          default: () => iconNode
        })) : null, /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-message__content`
        }, render$1(content)), closable ? /* @__PURE__ */ vue.h(NBaseClose, {
          clsPrefix: mergedClsPrefix,
          class: `${mergedClsPrefix}-message__close`,
          onClick: handleClose,
          absolute: true
        }) : null));
      }
    });
    function createIconVNode(icon, type, clsPrefix) {
      if (typeof icon === "function") {
        return icon();
      } else {
        const innerIcon = type === "loading" ? /* @__PURE__ */ vue.h(NBaseLoading, {
          clsPrefix,
          strokeWidth: 24,
          scale: 0.85
        }) : iconRenderMap$1[type]();
        if (!innerIcon)
          return null;
        return /* @__PURE__ */ vue.h(NBaseIcon, {
          clsPrefix,
          key: type
        }, {
          default: () => innerIcon
        });
      }
    }

    var MessageEnvironment = vue.defineComponent({
      name: "MessageEnvironment",
      props: {
        ...messageProps,
        duration: {
          type: Number,
          default: 3e3
        },
        onAfterLeave: Function,
        onLeave: Function,
        internalKey: {
          type: String,
          required: true
        },
        onInternalAfterLeave: Function,
        onHide: Function,
        onAfterHide: Function
      },
      setup(props) {
        let timerId = null;
        const showRef = vue.ref(true);
        vue.onMounted(() => {
          setHideTimeout();
        });
        function setHideTimeout() {
          const { duration } = props;
          if (duration) {
            timerId = window.setTimeout(hide, duration);
          }
        }
        function handleMouseenter(e) {
          if (e.currentTarget !== e.target)
            return;
          if (timerId !== null) {
            window.clearTimeout(timerId);
            timerId = null;
          }
        }
        function handleMouseleave(e) {
          if (e.currentTarget !== e.target)
            return;
          setHideTimeout();
        }
        function hide() {
          const { onHide } = props;
          showRef.value = false;
          if (timerId) {
            window.clearTimeout(timerId);
            timerId = null;
          }
          if (onHide)
            onHide();
        }
        function handleClose() {
          const { onClose } = props;
          if (onClose)
            onClose();
          hide();
        }
        function handleAfterLeave() {
          const { onAfterLeave, onInternalAfterLeave, onAfterHide, internalKey } = props;
          if (onAfterLeave)
            onAfterLeave();
          if (onInternalAfterLeave)
            onInternalAfterLeave(internalKey);
          if (onAfterHide)
            onAfterHide();
        }
        function deactivate() {
          hide();
        }
        return {
          show: showRef,
          hide,
          handleClose,
          handleAfterLeave,
          handleMouseleave,
          handleMouseenter,
          deactivate
        };
      },
      render() {
        return /* @__PURE__ */ vue.h(NFadeInExpandTransition, {
          appear: true,
          onAfterLeave: this.handleAfterLeave,
          onLeave: this.onLeave
        }, {
          default: () => [
            this.show ? /* @__PURE__ */ vue.h(NMessage, {
              content: this.content,
              type: this.type,
              icon: this.icon,
              showIcon: this.showIcon,
              closable: this.closable,
              onClose: this.handleClose,
              onMouseenter: this.keepAliveOnHover ? this.handleMouseenter : void 0,
              onMouseleave: this.keepAliveOnHover ? this.handleMouseleave : void 0
            }) : null
          ]
        });
      }
    });

    const messageProviderProps = {
      ...useTheme.props,
      to: [String, Object],
      duration: {
        type: Number,
        default: 3e3
      },
      keepAliveOnHover: Boolean,
      max: Number,
      placement: {
        type: String,
        default: "top"
      },
      closable: Boolean,
      containerStyle: [String, Object]
    };
    var NMessageProvider = vue.defineComponent({
      name: "MessageProvider",
      props: messageProviderProps,
      setup(props) {
        const { mergedClsPrefixRef } = useConfig(props);
        const messageListRef = vue.ref([]);
        const messageRefs = vue.ref({});
        const api = {
          create(content, options) {
            return create(content, { type: "default", ...options });
          },
          info(content, options) {
            return create(content, { ...options, type: "info" });
          },
          success(content, options) {
            return create(content, { ...options, type: "success" });
          },
          warning(content, options) {
            return create(content, { ...options, type: "warning" });
          },
          error(content, options) {
            return create(content, { ...options, type: "error" });
          },
          loading(content, options) {
            return create(content, { ...options, type: "loading" });
          },
          destroyAll
        };
        vue.provide(messageProviderInjectionKey, {
          props,
          mergedClsPrefixRef
        });
        vue.provide(messageApiInjectionKey, api);
        function create(content, options) {
          const key = createId();
          const messageReactive = vue.reactive({
            ...options,
            content,
            key,
            destroy: () => {
              messageRefs.value[key]?.hide();
            }
          });
          const { max } = props;
          if (max && messageListRef.value.length >= max) {
            messageListRef.value.shift();
          }
          messageListRef.value.push(messageReactive);
          return messageReactive;
        }
        function handleAfterLeave(key) {
          messageListRef.value.splice(
            messageListRef.value.findIndex((message) => message.key === key),
            1
          );
          delete messageRefs.value[key];
        }
        function destroyAll() {
          Object.values(messageRefs.value).forEach((messageInstRef) => {
            messageInstRef.hide();
          });
        }
        return Object.assign(
          {
            mergedClsPrefix: mergedClsPrefixRef,
            messageRefs,
            messageList: messageListRef,
            handleAfterLeave
          },
          api
        );
      },
      render() {
        return /* @__PURE__ */ vue.h(vue.Fragment, null, this.$slots.default?.(), this.messageList.length ? /* @__PURE__ */ vue.h(vue.Teleport, {
          to: this.to ?? "body"
        }, /* @__PURE__ */ vue.h("div", {
          class: [
            `${this.mergedClsPrefix}-message-container`,
            `${this.mergedClsPrefix}-message-container--${this.placement}`
          ],
          key: "message-container",
          style: this.containerStyle
        }, this.messageList.map((message) => {
          return /* @__PURE__ */ vue.h(MessageEnvironment, {
            ref: (inst) => {
              if (inst) {
                this.messageRefs[message.key] = inst;
              }
            },
            internalKey: message.key,
            onInternalAfterLeave: this.handleAfterLeave,
            ...omit(message, ["destroy"], void 0),
            duration: message.duration === void 0 ? this.duration : message.duration,
            keepAliveOnHover: message.keepAliveOnHover === void 0 ? this.keepAliveOnHover : message.keepAliveOnHover,
            closable: message.closable === void 0 ? this.closable : message.closable
          });
        }))) : null);
      }
    });

    function useMessage() {
      const api = vue.inject(messageApiInjectionKey, null);

      if (api === null) {
        throwError("use-message", "No outer <n-message-provider /> founded. See prerequisite in https://www.naiveui.com/en-US/os-theme/components/message for more details. If you want to use `useMessage` outside setup, please check https://www.naiveui.com/zh-CN/os-theme/components/message#Q-&-A.");
      }

      return api;
    }

    const notificationProviderInjectionKey = createInjectionKey("n-notification-provider");

    const NotificationContainer = vue.defineComponent({
      name: "NotificationContainer",
      props: {
        scrollable: {
          type: Boolean,
          required: true
        },
        placement: {
          type: String,
          required: true
        }
      },
      setup() {
        const { mergedThemeRef, mergedClsPrefixRef, wipTransitionCountRef } = vue.inject(notificationProviderInjectionKey);
        const selfRef = vue.ref(null);
        vue.watchEffect(() => {
          if (wipTransitionCountRef.value > 0) {
            selfRef?.value?.classList.add("transitioning");
          } else {
            selfRef?.value?.classList.remove("transitioning");
          }
        });
        return {
          selfRef,
          mergedTheme: mergedThemeRef,
          mergedClsPrefix: mergedClsPrefixRef,
          transitioning: wipTransitionCountRef
        };
      },
      render() {
        const { $slots, scrollable, mergedClsPrefix, mergedTheme, placement } = this;
        return /* @__PURE__ */ vue.h("div", {
          ref: "selfRef",
          class: [
            `${mergedClsPrefix}-notification-container`,
            scrollable && `${mergedClsPrefix}-notification-container--scrollable`,
            `${mergedClsPrefix}-notification-container--${placement}`
          ]
        }, scrollable ? /* @__PURE__ */ vue.h(NScrollbar, {
          theme: mergedTheme.peers.Scrollbar,
          themeOverrides: mergedTheme.peerOverrides.Scrollbar,
          contentStyle: { overflow: "hidden" }
        }, $slots) : $slots);
      }
    });

    const iconRenderMap = {
      info: () => /* @__PURE__ */ vue.h(InfoIcon, null),
      success: () => /* @__PURE__ */ vue.h(SuccessIcon, null),
      warning: () => /* @__PURE__ */ vue.h(WarningIcon, null),
      error: () => /* @__PURE__ */ vue.h(ErrorIcon, null),
      default: () => null
    };
    const notificationProps = {
      closable: {
        type: Boolean,
        default: true
      },
      type: {
        type: String,
        default: "default"
      },
      avatar: Function,
      title: [String, Function],
      description: [String, Function],
      content: [String, Function],
      meta: [String, Function],
      action: [String, Function],
      onClose: {
        type: Function,
        required: true
      },
      keepAliveOnHover: Boolean,
      onMouseenter: Function,
      onMouseleave: Function
    };
    const notificationPropKeys = keysOf(notificationProps);
    const Notification = vue.defineComponent({
      name: "Notification",
      props: notificationProps,
      setup(props) {
        const {
          mergedClsPrefixRef,
          mergedThemeRef,
          props: providerProps
        } = vue.inject(notificationProviderInjectionKey);
        const { inlineThemeDisabled, mergedRtlRef } = useConfig();
        const rtlEnabledRef = useRtl(
          "Notification",
          mergedRtlRef,
          mergedClsPrefixRef
        );
        const cssVarsRef = vue.computed(() => {
          const { type } = props;
          const {
            self: {
              color,
              textColor,
              closeIconColor,
              closeIconColorHover,
              closeIconColorPressed,
              headerTextColor,
              descriptionTextColor,
              actionTextColor,
              borderRadius,
              headerFontWeight,
              boxShadow,
              lineHeight,
              fontSize,
              closeMargin,
              closeSize,
              width,
              padding,
              closeIconSize,
              closeBorderRadius,
              closeColorHover,
              closeColorPressed,
              titleFontSize,
              metaFontSize,
              descriptionFontSize,
              [createKey("iconColor", type)]: iconColor
            },
            common: { cubicBezierEaseOut, cubicBezierEaseIn, cubicBezierEaseInOut }
          } = mergedThemeRef.value;
          const { left, right, top, bottom } = getMargin(padding);
          return {
            "--n-color": color,
            "--n-font-size": fontSize,
            "--n-text-color": textColor,
            "--n-description-text-color": descriptionTextColor,
            "--n-action-text-color": actionTextColor,
            "--n-title-text-color": headerTextColor,
            "--n-title-font-weight": headerFontWeight,
            "--n-bezier": cubicBezierEaseInOut,
            "--n-bezier-ease-out": cubicBezierEaseOut,
            "--n-bezier-ease-in": cubicBezierEaseIn,
            "--n-border-radius": borderRadius,
            "--n-box-shadow": boxShadow,
            "--n-close-border-radius": closeBorderRadius,
            "--n-close-color-hover": closeColorHover,
            "--n-close-color-pressed": closeColorPressed,
            "--n-close-icon-color": closeIconColor,
            "--n-close-icon-color-hover": closeIconColorHover,
            "--n-close-icon-color-pressed": closeIconColorPressed,
            "--n-line-height": lineHeight,
            "--n-icon-color": iconColor,
            "--n-close-margin": closeMargin,
            "--n-close-size": closeSize,
            "--n-close-icon-size": closeIconSize,
            "--n-width": width,
            "--n-padding-left": left,
            "--n-padding-right": right,
            "--n-padding-top": top,
            "--n-padding-bottom": bottom,
            "--n-title-font-size": titleFontSize,
            "--n-meta-font-size": metaFontSize,
            "--n-description-font-size": descriptionFontSize
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass(
          "notification",
          vue.computed(() => props.type[0]),
          cssVarsRef,
          providerProps
        ) : void 0;
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          showAvatar: vue.computed(() => {
            return props.avatar || props.type !== "default";
          }),
          handleCloseClick() {
            props.onClose();
          },
          rtlEnabled: rtlEnabledRef,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender
        };
      },
      render() {
        const { mergedClsPrefix } = this;
        this.onRender?.();
        return /* @__PURE__ */ vue.h("div", {
          class: [`${mergedClsPrefix}-notification-wrapper`, this.themeClass],
          onMouseenter: this.onMouseenter,
          onMouseleave: this.onMouseleave,
          style: this.cssVars
        }, /* @__PURE__ */ vue.h("div", {
          class: [
            `${mergedClsPrefix}-notification`,
            this.rtlEnabled && `${mergedClsPrefix}-notification--rtl`,
            this.themeClass,
            {
              [`${mergedClsPrefix}-notification--closable`]: this.closable,
              [`${mergedClsPrefix}-notification--show-avatar`]: this.showAvatar
            }
          ],
          style: this.cssVars
        }, this.showAvatar ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-notification__avatar`
        }, this.avatar ? render$1(this.avatar) : this.type !== "default" ? /* @__PURE__ */ vue.h(NBaseIcon, {
          clsPrefix: mergedClsPrefix
        }, { default: () => iconRenderMap[this.type]() }) : null) : null, this.closable ? /* @__PURE__ */ vue.h(NBaseClose, {
          clsPrefix: mergedClsPrefix,
          class: `${mergedClsPrefix}-notification__close`,
          onClick: this.handleCloseClick
        }) : null, /* @__PURE__ */ vue.h("div", {
          ref: "bodyRef",
          class: `${mergedClsPrefix}-notification-main`
        }, this.title ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-notification-main__header`
        }, render$1(this.title)) : null, this.description ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-notification-main__description`
        }, render$1(this.description)) : null, this.content ? /* @__PURE__ */ vue.h("pre", {
          class: `${mergedClsPrefix}-notification-main__content`
        }, render$1(this.content)) : null, this.meta || this.action ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-notification-main-footer`
        }, this.meta ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-notification-main-footer__meta`
        }, render$1(this.meta)) : null, this.action ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-notification-main-footer__action`
        }, render$1(this.action)) : null) : null)));
      }
    });

    const notificationEnvOptions = {
      ...notificationProps,
      duration: Number,
      onClose: Function,
      onLeave: Function,
      onAfterEnter: Function,
      onAfterLeave: Function,
      onHide: Function,
      onAfterShow: Function,
      onAfterHide: Function
    };
    const NotificationEnvironment = vue.defineComponent({
      name: "NotificationEnvironment",
      props: {
        ...notificationEnvOptions,
        internalKey: {
          type: String,
          required: true
        },
        onInternalAfterLeave: {
          type: Function,
          required: true
        }
      },
      setup(props) {
        const {
          wipTransitionCountRef
        } = vue.inject(notificationProviderInjectionKey);
        const showRef = vue.ref(true);
        let timerId = null;
        function hide() {
          showRef.value = false;
          if (timerId) {
            window.clearTimeout(timerId);
          }
        }
        function handleBeforeEnter(el) {
          wipTransitionCountRef.value++;
          void vue.nextTick(() => {
            el.style.height = `${el.offsetHeight}px`;
            el.style.maxHeight = "0";
            el.style.transition = "none";
            void el.offsetHeight;
            el.style.transition = "";
            el.style.maxHeight = el.style.height;
          });
        }
        function handleAfterEnter(el) {
          wipTransitionCountRef.value--;
          el.style.height = "";
          el.style.maxHeight = "";
          const { onAfterEnter, onAfterShow } = props;
          if (onAfterEnter)
            onAfterEnter();
          if (onAfterShow)
            onAfterShow();
        }
        function handleBeforeLeave(el) {
          wipTransitionCountRef.value++;
          el.style.maxHeight = `${el.offsetHeight}px`;
          el.style.height = `${el.offsetHeight}px`;
          void el.offsetHeight;
        }
        function handleLeave(el) {
          const { onHide } = props;
          if (onHide)
            onHide();
          el.style.maxHeight = "0";
          void el.offsetHeight;
        }
        function handleAfterLeave() {
          wipTransitionCountRef.value--;
          const { onAfterLeave, onInternalAfterLeave, onAfterHide, internalKey } = props;
          if (onAfterLeave)
            onAfterLeave();
          onInternalAfterLeave(internalKey);
          if (onAfterHide)
            onAfterHide();
        }
        function setHideTimeout() {
          const { duration } = props;
          if (duration) {
            timerId = window.setTimeout(hide, duration);
          }
        }
        function handleMouseenter(e) {
          if (e.currentTarget !== e.target)
            return;
          if (timerId !== null) {
            window.clearTimeout(timerId);
            timerId = null;
          }
        }
        function handleMouseleave(e) {
          if (e.currentTarget !== e.target)
            return;
          setHideTimeout();
        }
        function handleClose() {
          const { onClose } = props;
          if (onClose) {
            void Promise.resolve(onClose()).then((feedback) => {
              if (feedback === false)
                return;
              hide();
            });
          } else {
            hide();
          }
        }
        vue.onMounted(() => {
          if (props.duration) {
            timerId = window.setTimeout(hide, props.duration);
          }
        });
        return {
          show: showRef,
          hide,
          handleClose,
          handleAfterLeave,
          handleLeave,
          handleBeforeLeave,
          handleAfterEnter,
          handleBeforeEnter,
          handleMouseenter,
          handleMouseleave
        };
      },
      render() {
        return /* @__PURE__ */ vue.h(vue.Transition, {
          name: "notification-transition",
          appear: true,
          onBeforeEnter: this.handleBeforeEnter,
          onAfterEnter: this.handleAfterEnter,
          onBeforeLeave: this.handleBeforeLeave,
          onLeave: this.handleLeave,
          onAfterLeave: this.handleAfterLeave
        }, {
          default: () => {
            return this.show ? /* @__PURE__ */ vue.h(Notification, {
              ...keep(this.$props, notificationPropKeys),
              onClose: this.handleClose,
              onMouseenter: this.duration && this.keepAliveOnHover ? this.handleMouseenter : void 0,
              onMouseleave: this.duration && this.keepAliveOnHover ? this.handleMouseleave : void 0
            }) : null;
          }
        });
      }
    });

    var style$r = c$1([cB("notification-container", `
    z-index: 4000;
    position: fixed;
    overflow: visible;
    display: flex;
    flex-direction: column;
    align-items: flex-end;
  `, [c$1(">", [cB("scrollbar", `
        width: initial;
        overflow: visible;
        height: -moz-fit-content !important;
        height: fit-content !important;
        max-height: 100vh !important;
      `, [c$1(">", [cB("scrollbar-container", `
            height: -moz-fit-content !important;
            height: fit-content !important;
            max-height: 100vh !important;
          `, [cB("scrollbar-content", `
              padding-top: 12px;
              padding-bottom: 33px;
            `)])])])]), cM("top, top-right, top-left", `
      top: 12px;
    `, [c$1("&.transitioning >", [cB("scrollbar", [c$1(">", [cB("scrollbar-container", `
              min-height: 100vh !important;
            `)])])])]), cM("bottom, bottom-right, bottom-left", `
      bottom: 12px;
    `, [c$1(">", [cB("scrollbar", [c$1(">", [cB("scrollbar-container", [cB("scrollbar-content", `
                padding-bottom: 12px;
              `)])])])]), cB("notification-wrapper", `
        display: flex;
        align-items: flex-end;
        margin-bottom: 0;
        margin-top: 12px;
      `)]), cM("top, bottom", `
      left: 50%;
      transform: translateX(-50%);
    `, [cB("notification-wrapper", [c$1("&.notification-transition-enter-from, &.notification-transition-leave-to", `
          transform: scale(0.85);
        `), c$1("&.notification-transition-leave-from, &.notification-transition-enter-to", `
          transform: scale(1);
        `)])]), cM("top", [cB("notification-wrapper", `
        transform-origin: top center;
      `)]), cM("bottom", [cB("notification-wrapper", `
        transform-origin: bottom center;
      `)]), cM("top-right, bottom-right", [cB("notification", `
        margin-left: 28px;
        margin-right: 16px;
      `)]), cM("top-left, bottom-left", [cB("notification", `
        margin-left: 16px;
        margin-right: 28px;
      `)]), cM("top-right", `
      right: 0;
    `, [placementTransformStyle("top-right")]), cM("top-left", `
      left: 0;
    `, [placementTransformStyle("top-left")]), cM("bottom-right", `
      right: 0;
    `, [placementTransformStyle("bottom-right")]), cM("bottom-left", `
      left: 0;
    `, [placementTransformStyle("bottom-left")]), cM("scrollable", [cM("top-right", `
        top: 0;
      `), cM("top-left", `
        top: 0;
      `), cM("bottom-right", `
        bottom: 0;
      `), cM("bottom-left", `
        bottom: 0;
      `)]), cB("notification-wrapper", `
      margin-bottom: 12px;
    `, [c$1("&.notification-transition-enter-from, &.notification-transition-leave-to", `
        opacity: 0;
        margin-top: 0 !important;
        margin-bottom: 0 !important;
      `), c$1("&.notification-transition-leave-from, &.notification-transition-enter-to", `
        opacity: 1;
      `), c$1("&.notification-transition-leave-active", `
        transition:
          background-color .3s var(--n-bezier),
          color .3s var(--n-bezier),
          opacity .3s var(--n-bezier),
          transform .3s var(--n-bezier-ease-in),
          max-height .3s var(--n-bezier),
          margin-top .3s linear,
          margin-bottom .3s linear,
          box-shadow .3s var(--n-bezier);
      `), c$1("&.notification-transition-enter-active", `
        transition:
          background-color .3s var(--n-bezier),
          color .3s var(--n-bezier),
          opacity .3s var(--n-bezier),
          transform .3s var(--n-bezier-ease-out),
          max-height .3s var(--n-bezier),
          margin-top .3s linear,
          margin-bottom .3s linear,
          box-shadow .3s var(--n-bezier);
      `)]), cB("notification", `
      background-color: var(--n-color);
      color: var(--n-text-color);
      transition:
        background-color .3s var(--n-bezier),
        color .3s var(--n-bezier),
        opacity .3s var(--n-bezier),
        box-shadow .3s var(--n-bezier);
      font-family: inherit;
      font-size: var(--n-font-size);
      font-weight: 400;
      position: relative;
      display: flex;
      overflow: hidden;
      flex-shrink: 0;
      padding-left: var(--n-padding-left);
      padding-right: var(--n-padding-right);
      width: var(--n-width);
      border-radius: var(--n-border-radius);
      box-shadow: var(--n-box-shadow);
      box-sizing: border-box;
      opacity: 1;
    `, [cE("avatar", [cB("icon", {
      color: "var(--n-icon-color)"
    }), cB("base-icon", {
      color: "var(--n-icon-color)"
    })]), cM("show-avatar", [cB("notification-main", `
          margin-left: 40px;
          width: calc(100% - 40px);
        `)]), cM("closable", [cB("notification-main", [c$1("> *:first-child", {
      paddingRight: "20px"
    })]), cE("close", `
          position: absolute;
          top: 0;
          right: 0;
          margin: var(--n-close-margin);
          transition:
            background-color .3s var(--n-bezier),
            color .3s var(--n-bezier);
        `)]), cE("avatar", `
        position: absolute;
        top: var(--n-padding-top);
        left: var(--n-padding-left);
        width: 28px;
        height: 28px;
        font-size: 28px;
        display: flex;
        align-items: center;
        justify-content: center;
      `, [cB("icon", "transition: color .3s var(--n-bezier);")]), cB("notification-main", `
        padding-top: var(--n-padding-top);
        padding-bottom: var(--n-padding-bottom);
        box-sizing: border-box;
        display: flex;
        flex-direction: column;
        margin-left: 8px;
        width: calc(100% - 8px);
      `, [cB("notification-main-footer", `
          display: flex;
          align-items: center;
          justify-content: space-between;
          margin-top: 12px;
        `, [cE("meta", `
            font-size: var(--n-meta-font-size);
            transition: color .3s var(--n-bezier-ease-out);
            color: var(--n-description-text-color);
          `), cE("action", `
            cursor: pointer;
            transition: color .3s var(--n-bezier-ease-out);
            color: var(--n-action-text-color);
          `)]), cE("header", `
          font-weight: var(--n-title-font-weight);
          font-size: var(--n-title-font-size);
          transition: color .3s var(--n-bezier-ease-out);
          color: var(--n-title-text-color);
        `), cE("description", `
          margin-top: 8px;
          font-size: var(--n-description-font-size);
          transition: color .3s var(--n-bezier-ease-out);
          color: var(--n-description-text-color);
        `), cE("content", `
          line-height: var(--n-line-height);
          margin: 12px 0 0 0;
          font-family: inherit;
          white-space: pre-wrap;
          word-wrap: break-word;
          transition: color .3s var(--n-bezier-ease-out);
          color: var(--n-text-color);
        `, [c$1("&:first-child", {
      margin: 0
    })])])])])]);

    function placementTransformStyle(placement) {
      const direction = placement.split("-")[1];
      const transformXEnter = direction === "left" ? "calc(-100%)" : "calc(100%)";
      const transformXLeave = "0";
      return cB("notification-wrapper", [c$1("&.notification-transition-enter-from, &.notification-transition-leave-to", `
      transform: translate(${transformXEnter}, 0);
    `), c$1("&.notification-transition-leave-from, &.notification-transition-enter-to", `
      transform: translate(${transformXLeave}, 0);
    `)]);
    }

    const notificationApiInjectionKey = createInjectionKey("n-notification-api");
    const notificationProviderProps = {
      ...useTheme.props,
      containerStyle: [String, Object],
      to: [String, Object],
      scrollable: {
        type: Boolean,
        default: true
      },
      max: Number,
      placement: {
        type: String,
        default: "top-right"
      },
      keepAliveOnHover: Boolean
    };
    var NNotificationProvider = vue.defineComponent({
      name: "NotificationProvider",
      props: notificationProviderProps,
      setup(props) {
        const { mergedClsPrefixRef } = useConfig(props);
        const notificationListRef = vue.ref([]);
        const notificationRefs = {};
        const leavingKeySet = /* @__PURE__ */ new Set();
        function create(options) {
          const key = createId();
          const destroy = () => {
            leavingKeySet.add(key);
            if (notificationRefs[key]) {
              notificationRefs[key].hide();
            }
          };
          const notificationReactive = vue.reactive({
            ...options,
            key,
            destroy,
            hide: destroy,
            deactivate: destroy
          });
          const { max } = props;
          if (max && notificationListRef.value.length - leavingKeySet.size >= max) {
            let someoneMountedRemoved = false;
            let index = 0;
            for (const notification of notificationListRef.value) {
              if (!leavingKeySet.has(notification.key)) {
                if (notificationRefs[notification.key]) {
                  notification.destroy();
                  someoneMountedRemoved = true;
                }
                break;
              }
              index++;
            }
            if (!someoneMountedRemoved) {
              notificationListRef.value.splice(index, 1);
            }
          }
          notificationListRef.value.push(notificationReactive);
          return notificationReactive;
        }
        const apis = ["info", "success", "warning", "error"].map(
          (type) => {
            return (options) => create({ ...options, type });
          }
        );
        function handleAfterLeave(key) {
          leavingKeySet.delete(key);
          notificationListRef.value.splice(
            notificationListRef.value.findIndex(
              (notification) => notification.key === key
            ),
            1
          );
        }
        const themeRef = useTheme(
          "Notification",
          "-notification",
          style$r,
          notificationLight$1,
          props,
          mergedClsPrefixRef
        );
        const api = {
          create,
          info: apis[0],
          success: apis[1],
          warning: apis[2],
          error: apis[3],
          open,
          destroyAll
        };
        const wipTransitionCountRef = vue.ref(0);
        vue.provide(notificationApiInjectionKey, api);
        vue.provide(notificationProviderInjectionKey, {
          props,
          mergedClsPrefixRef,
          mergedThemeRef: themeRef,
          wipTransitionCountRef
        });
        function open(options) {
          return create(options);
        }
        function destroyAll() {
          Object.values(notificationListRef.value).forEach((notification) => {
            notification.hide();
          });
        }
        return Object.assign(
          {
            mergedClsPrefix: mergedClsPrefixRef,
            notificationList: notificationListRef,
            notificationRefs,
            handleAfterLeave
          },
          api
        );
      },
      render() {
        const { placement } = this;
        return /* @__PURE__ */ vue.h(vue.Fragment, null, this.$slots.default?.(), this.notificationList.length ? /* @__PURE__ */ vue.h(vue.Teleport, {
          to: this.to ?? "body"
        }, /* @__PURE__ */ vue.h(NotificationContainer, {
          style: this.containerStyle,
          scrollable: this.scrollable && placement !== "top" && placement !== "bottom",
          placement
        }, {
          default: () => {
            return this.notificationList.map((notification) => {
              return /* @__PURE__ */ vue.h(NotificationEnvironment, {
                ref: (inst) => {
                  const refKey = notification.key;
                  if (inst === null) {
                    delete this.notificationRefs[refKey];
                  } else
                    this.notificationRefs[refKey] = inst;
                },
                ...omit(notification, [
                  "destroy",
                  "hide",
                  "deactivate"
                ]),
                internalKey: notification.key,
                onInternalAfterLeave: this.handleAfterLeave,
                keepAliveOnHover: notification.keepAliveOnHover === void 0 ? this.keepAliveOnHover : notification.keepAliveOnHover
              });
            });
          }
        })) : null);
      }
    });

    function useNotification() {
      const api = vue.inject(notificationApiInjectionKey, null);

      if (api === null) {
        throwError("use-notification", "No outer `n-notification-provider` found.");
      }

      return api;
    }

    var style$q = c$1([cB("page-header-header", `
    margin-bottom: 20px;
  `), cB("page-header", `
    display: flex;
    align-items: center;
    justify-content: space-between;
    line-height: 1.5;
    font-size: var(--n-font-size);
  `, [cE("main", `
      display: flex;
      flex-wrap: nowrap;
      align-items: center;
    `), cE("back", `
      display: flex;
      margin-right: 16px;
      font-size: var(--n-back-size);
      cursor: pointer;
      color: var(--n-back-color);
      transition: color .3s var(--n-bezier);
    `, [c$1("&:hover", "color: var(--n-back-color-hover);"), c$1("&:active", "color: var(--n-back-color-pressed);")]), cE("avatar", `
      display: flex;
      margin-right: 12px
    `), cE("title", `
      margin-right: 16px;
      transition: color .3s var(--n-bezier);
      font-size: var(--n-title-font-size);
      font-weight: var(--n-title-font-weight);
      color: var(--n-title-text-color);
    `), cE("subtitle", `
      font-size: 14px;
      transition: color .3s var(--n-bezier);
      color: var(--n-subtitle-text-color);
    `)]), cB("page-header-content", `
    font-size: var(--n-font-size);
  `, [c$1("&:not(:first-child)", "margin-top: 20px;")]), cB("page-header-footer", `
    font-size: var(--n-font-size);
  `, [c$1("&:not(:first-child)", "margin-top: 20px;")])]);

    const pageHeaderProps = {
      ...useTheme.props,
      title: String,
      subtitle: String,
      extra: String,
      onBack: Function
    };
    var PageHeader = vue.defineComponent({
      name: "PageHeader",
      props: pageHeaderProps,
      setup(props) {
        const { mergedClsPrefixRef, mergedRtlRef, inlineThemeDisabled } = useConfig(props);
        const themeRef = useTheme(
          "PageHeader",
          "-page-header",
          style$q,
          pageHeaderLight,
          props,
          mergedClsPrefixRef
        );
        const rtlEnabledRef = useRtl("PageHeader", mergedRtlRef, mergedClsPrefixRef);
        const cssVarsRef = vue.computed(() => {
          const {
            self: {
              titleTextColor,
              subtitleTextColor,
              backColor,
              fontSize,
              titleFontSize,
              backSize,
              titleFontWeight,
              backColorHover,
              backColorPressed
            },
            common: { cubicBezierEaseInOut }
          } = themeRef.value;
          return {
            "--n-title-text-color": titleTextColor,
            "--n-title-font-size": titleFontSize,
            "--n-title-font-weight": titleFontWeight,
            "--n-font-size": fontSize,
            "--n-back-size": backSize,
            "--n-subtitle-text-color": subtitleTextColor,
            "--n-back-color": backColor,
            "--n-back-color-hover": backColorHover,
            "--n-back-color-pressed": backColorPressed,
            "--n-bezier": cubicBezierEaseInOut
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("page-header", void 0, cssVarsRef, props) : void 0;
        return {
          rtlEnabled: rtlEnabledRef,
          mergedClsPrefix: mergedClsPrefixRef,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender
        };
      },
      render() {
        const { onBack, title, subtitle, extra, mergedClsPrefix, cssVars, $slots } = this;
        this.onRender?.();
        const {
          title: titleSlot,
          subtitle: subtitleSlot,
          extra: extraSlot,
          default: defaultSlot,
          header: headerSlot,
          avatar: avatarSlot,
          footer: footerSlot,
          back: backSlot
        } = $slots;
        const showBack = onBack;
        const showTitle = title || titleSlot;
        const showSubtitle = subtitle || subtitleSlot;
        const showExtra = extra || extraSlot;
        return /* @__PURE__ */ vue.h("div", {
          style: cssVars,
          class: [
            `${mergedClsPrefix}-page-header-wrapper`,
            this.themeClass,
            this.rtlEnabled && `${mergedClsPrefix}-page-header-wrapper--rtl`
          ]
        }, headerSlot ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-page-header-header`,
          key: "breadcrumb"
        }, headerSlot()) : null, (showBack || avatarSlot || showTitle || showSubtitle || showExtra) && /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-page-header`,
          key: "header"
        }, /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-page-header__main`,
          key: "back"
        }, showBack ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-page-header__back`,
          onClick: onBack
        }, backSlot ? backSlot() : /* @__PURE__ */ vue.h(NBaseIcon, {
          clsPrefix: mergedClsPrefix
        }, {
          default: () => /* @__PURE__ */ vue.h(ArrowBackIcon, null)
        })) : null, avatarSlot ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-page-header__avatar`
        }, avatarSlot()) : null, showTitle ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-page-header__title`,
          key: "title"
        }, title || titleSlot()) : null, showSubtitle ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-page-header__subtitle`,
          key: "subtitle"
        }, subtitle || subtitleSlot()) : null), showExtra ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-page-header__extra`
        }, extra || extraSlot()) : null), defaultSlot ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-page-header-content`,
          key: "content"
        }, defaultSlot()) : null, footerSlot ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-page-header-footer`,
          key: "footer"
        }, footerSlot()) : null);
      }
    });

    const popconfirmInjectionKey = createInjectionKey("n-popconfirm");

    const panelProps = {
      positiveText: String,
      negativeText: String,
      showIcon: {
        type: Boolean,
        default: true
      },
      onPositiveClick: {
        type: Function,
        required: true
      },
      onNegativeClick: {
        type: Function,
        required: true
      }
    };
    const panelPropKeys = keysOf(panelProps);
    var PopconfirmPanel = vue.defineComponent({
      name: "NPopconfirmPanel",
      props: panelProps,
      setup(props) {
        const { localeRef } = useLocale("Popconfirm");
        const { inlineThemeDisabled } = useConfig();
        const {
          mergedClsPrefixRef,
          mergedThemeRef,
          props: popconfirmProps
        } = vue.inject(popconfirmInjectionKey);
        const cssVarsRef = vue.computed(() => {
          const {
            common: { cubicBezierEaseInOut },
            self: { fontSize, iconSize, iconColor }
          } = mergedThemeRef.value;
          return {
            "--n-bezier": cubicBezierEaseInOut,
            "--n-font-size": fontSize,
            "--n-icon-size": iconSize,
            "--n-icon-color": iconColor
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass(
          "popconfirm-panel",
          void 0,
          cssVarsRef,
          popconfirmProps
        ) : void 0;
        return {
          ...useLocale("Popconfirm"),
          mergedClsPrefix: mergedClsPrefixRef,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          localizedPositiveText: vue.computed(() => {
            return props.positiveText || localeRef.value.positiveText;
          }),
          localizedNegativeText: vue.computed(() => {
            return props.negativeText || localeRef.value.negativeText;
          }),
          positiveButtonProps: vue.toRef(popconfirmProps, "positiveButtonProps"),
          negativeButtonProps: vue.toRef(popconfirmProps, "negativeButtonProps"),
          handlePositiveClick(e) {
            props.onPositiveClick(e);
          },
          handleNegativeClick(e) {
            props.onNegativeClick(e);
          },
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender
        };
      },
      render() {
        const { mergedClsPrefix, showIcon, $slots } = this;
        const actionContentNode = resolveSlot(
          $slots.action,
          () => this.negativeText === null && this.positiveText === null ? [] : [
            this.negativeText !== null && /* @__PURE__ */ vue.h(NButton, {
              size: "small",
              onClick: this.handleNegativeClick,
              ...this.negativeButtonProps
            }, { default: () => this.localizedNegativeText }),
            this.positiveText !== null && /* @__PURE__ */ vue.h(NButton, {
              size: "small",
              type: "primary",
              onClick: this.handlePositiveClick,
              ...this.positiveButtonProps
            }, { default: () => this.localizedPositiveText })
          ]
        );
        this.onRender?.();
        return /* @__PURE__ */ vue.h("div", {
          class: [`${mergedClsPrefix}-popconfirm__panel`, this.themeClass],
          style: this.cssVars
        }, resolveWrappedSlot(
          $slots.default,
          (children) => showIcon || children ? /* @__PURE__ */ vue.h("div", {
            class: `${mergedClsPrefix}-popconfirm__body`
          }, showIcon ? /* @__PURE__ */ vue.h("div", {
            class: `${mergedClsPrefix}-popconfirm__icon`
          }, resolveSlot($slots.icon, () => [
            /* @__PURE__ */ vue.h(NBaseIcon, {
              clsPrefix: mergedClsPrefix
            }, { default: () => /* @__PURE__ */ vue.h(WarningIcon, null) })
          ])) : null, children) : null
        ), actionContentNode ? /* @__PURE__ */ vue.h("div", {
          class: [`${mergedClsPrefix}-popconfirm__action`]
        }, actionContentNode) : null);
      }
    });

    var style$p = cB("popconfirm", [cE("body", `
    font-size: var(--n-font-size);
    display: flex;
    align-items: center;
    flex-wrap: nowrap;
    position: relative;
  `, [cE("icon", `
      display: flex;
      font-size: var(--n-icon-size);
      color: var(--n-icon-color);
      transition: color .3s var(--n-bezier);
      margin: 0 8px 0 0;
    `)]), cE("action", `
    display: flex;
    justify-content: flex-end;
  `, [c$1("&:not(:first-child)", "margin-top: 8px"), cB("button", [c$1("&:not(:last-child)", "margin-right: 8px;")])])]);

    const popconfirmProps = { ...useTheme.props,
      ...popoverBaseProps,
      positiveText: String,
      negativeText: String,
      showIcon: {
        type: Boolean,
        default: true
      },
      trigger: {
        type: String,
        default: "click"
      },
      positiveButtonProps: Object,
      negativeButtonProps: Object,
      onPositiveClick: Function,
      onNegativeClick: Function
    };
    var Popconfirm = vue.defineComponent({
      name: "Popconfirm",
      props: popconfirmProps,
      __popover__: true,

      setup(props) {
        const {
          mergedClsPrefixRef
        } = useConfig();
        const themeRef = useTheme("Popconfirm", "-popconfirm", style$p, popconfirmLight$1, props, mergedClsPrefixRef);
        const popoverInstRef = vue.ref(null);

        function handlePositiveClick(e) {
          const {
            onPositiveClick,
            "onUpdate:show": onUpdateShow
          } = props;
          void Promise.resolve(onPositiveClick ? onPositiveClick(e) : true).then(value => {
            var _popoverInstRef$value;

            if (value === false) return;
            (_popoverInstRef$value = popoverInstRef.value) === null || _popoverInstRef$value === void 0 ? void 0 : _popoverInstRef$value.setShow(false);
            if (onUpdateShow) call(onUpdateShow, false);
          });
        }

        function handleNegativeClick(e) {
          const {
            onNegativeClick,
            "onUpdate:show": onUpdateShow
          } = props;
          void Promise.resolve(onNegativeClick ? onNegativeClick(e) : true).then(value => {
            var _popoverInstRef$value2;

            if (value === false) return;
            (_popoverInstRef$value2 = popoverInstRef.value) === null || _popoverInstRef$value2 === void 0 ? void 0 : _popoverInstRef$value2.setShow(false);
            if (onUpdateShow) call(onUpdateShow, false);
          });
        }

        vue.provide(popconfirmInjectionKey, {
          mergedThemeRef: themeRef,
          mergedClsPrefixRef,
          props
        });
        const exposedMethods = {
          setShow(value) {
            var _popoverInstRef$value3;

            (_popoverInstRef$value3 = popoverInstRef.value) === null || _popoverInstRef$value3 === void 0 ? void 0 : _popoverInstRef$value3.setShow(value);
          },

          syncPosition() {
            var _popoverInstRef$value4;

            (_popoverInstRef$value4 = popoverInstRef.value) === null || _popoverInstRef$value4 === void 0 ? void 0 : _popoverInstRef$value4.syncPosition();
          }

        };
        return { ...exposedMethods,
          mergedTheme: themeRef,
          popoverInstRef,
          handlePositiveClick,
          handleNegativeClick
        };
      },

      render() {
        const {
          $slots: slots,
          $props: props,
          mergedTheme
        } = this;
        return vue.h(NPopover, omit(props, panelPropKeys, {
          theme: mergedTheme.peers.Popover,
          themeOverrides: mergedTheme.peerOverrides.Popover,
          internalExtraClass: ["popconfirm"],
          ref: "popoverInstRef"
        }), {
          trigger: slots.activator || slots.trigger,
          default: () => {
            const panelProps = keep(props, panelPropKeys);
            return vue.h(PopconfirmPanel, { ...panelProps,
              onPositiveClick: this.handlePositiveClick,
              onNegativeClick: this.handleNegativeClick
            }, slots);
          }
        });
      }

    });

    var style$o = c$1([cB("progress", {
      display: "inline-block"
    }, [cB("progress-icon", `
      color: var(--n-icon-color);
      transition: color .3s var(--n-bezier);
    `), cM("line", `
      width: 100%;
      display: block;
    `, [cB("progress-content", `
        display: flex;
        align-items: center;
      `, [cB("progress-graph", {
      flex: 1
    })]), cB("progress-custom-content", {
      marginLeft: "14px"
    }), cB("progress-icon", `
        width: 30px;
        padding-left: 14px;
        height: var(--n-icon-size-line);
        line-height: var(--n-icon-size-line);
        font-size: var(--n-icon-size-line);
      `, [cM("as-text", `
          color: var(--n-text-color-line-outer);
          text-align: center;
          width: 40px;
          font-size: var(--n-font-size);
          padding-left: 4px;
          transition: color .3s var(--n-bezier);
        `)])]), cM("circle, dashboard", {
      width: "120px"
    }, [cB("progress-custom-content", `
        position: absolute;
        left: 50%;
        top: 50%;
        transform: translateX(-50%) translateY(-50%);
        display: flex;
        align-items: center;
        justify-content: center;
      `), cB("progress-text", `
        position: absolute;
        left: 50%;
        top: 50%;
        transform: translateX(-50%) translateY(-50%);
        display: flex;
        align-items: center;
        color: inherit;
        font-size: var(--n-font-size-circle);
        color: var(--n-text-color-circle);
        font-weight: var(--n-font-weight-circle);
        transition: color .3s var(--n-bezier);
        white-space: nowrap;
      `), cB("progress-icon", `
        position: absolute;
        left: 50%;
        top: 50%;
        transform: translateX(-50%) translateY(-50%);
        display: flex;
        align-items: center;
        color: var(--n-icon-color);
        font-size: var(--n-icon-size-circle);
      `)]), cM("multiple-circle", `
      width: 200px;
      color: inherit;
    `, [cB("progress-text", `
        font-weight: var(--n-font-weight-circle);
        color: var(--n-text-color-circle);
        position: absolute;
        left: 50%;
        top: 50%;
        transform: translateX(-50%) translateY(-50%);
        display: flex;
        align-items: center;
        justify-content: center;
        transition: color .3s var(--n-bezier);
      `)]), cB("progress-content", {
      position: "relative"
    }), cB("progress-graph", {
      position: "relative"
    }, [cB("progress-graph-circle", [c$1("svg", {
      verticalAlign: "bottom"
    }), cB("progress-graph-circle-fill", `
          stroke: var(--n-fill-color);
          transition:
            opacity .3s var(--n-bezier),
            stroke .3s var(--n-bezier),
            stroke-dasharray .3s var(--n-bezier);
        `, [cM("empty", {
      opacity: 0
    })]), cB("progress-graph-circle-rail", `
          transition: stroke .3s var(--n-bezier);
          overflow: hidden;
          stroke: var(--n-rail-color);
        `)]), cB("progress-graph-line", [cM("indicator-inside", [cB("progress-graph-line-rail", `
            height: 16px;
            line-height: 16px;
            border-radius: 10px;
          `, [cB("progress-graph-line-fill", `
              height: inherit;
              border-radius: 10px;
            `), cB("progress-graph-line-indicator", `
              background: #0000;
              white-space: nowrap;
              text-align: right;
              margin-left: 14px;
              margin-right: 14px;
              height: inherit;
              font-size: 12px;
              color: var(--n-text-color-line-inner);
              transition: color .3s var(--n-bezier);
            `)])]), cM("indicator-inside-label", `
          height: 16px;
          display: flex;
          align-items: center;
        `, [cB("progress-graph-line-rail", `
            flex: 1;
            transition: background-color .3s var(--n-bezier);
          `), cB("progress-graph-line-indicator", `
            background: var(--n-fill-color);
            font-size: 12px;
            transform: translateZ(0);
            display: flex;
            vertical-align: middle;
            height: 16px;
            line-height: 16px;
            padding: 0 10px;
            border-radius: 10px;
            position: absolute;
            white-space: nowrap;
            color: var(--n-text-color-line-inner);
            transition:
              right .2s var(--n-bezier),
              color .3s var(--n-bezier),
              background-color .3s var(--n-bezier);
          `)]), cB("progress-graph-line-rail", `
          position: relative;
          overflow: hidden;
          height: var(--n-rail-height);
          border-radius: 5px;
          background-color: var(--n-rail-color);
          transition: background-color .3s var(--n-bezier);
        `, [cB("progress-graph-line-fill", `
            background: var(--n-fill-color);
            position: relative;
            border-radius: 5px;
            height: inherit;
            width: 100%;
            max-width: 0%;
            transition:
              background-color .3s var(--n-bezier),
              max-width .2s var(--n-bezier);
          `, [cM("processing", [c$1("&::after", `
                content: "";
                background-image: var(--n-line-bg-processing);
                animation: progress-processing-animation 2s var(--n-bezier) infinite;
              `)])])])])])]), c$1("@keyframes progress-processing-animation", `
    0% {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      right: 100%;
      opacity: 1;
    }
    66% {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      right: 0;
      opacity: 0;
    }
    100% {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      right: 0;
      opacity: 0;
    }
  `)]);

    const iconMap$2 = {
      success: /* @__PURE__ */ vue.h(SuccessIcon, null),
      error: /* @__PURE__ */ vue.h(ErrorIcon, null),
      warning: /* @__PURE__ */ vue.h(WarningIcon, null),
      info: /* @__PURE__ */ vue.h(InfoIcon, null)
    };
    var Line = vue.defineComponent({
      name: "ProgressLine",
      props: {
        clsPrefix: {
          type: String,
          required: true
        },
        percentage: {
          type: Number,
          default: 0
        },
        railColor: String,
        railStyle: [String, Object],
        fillColor: String,
        status: {
          type: String,
          required: true
        },
        indicatorPlacement: {
          type: String,
          required: true
        },
        indicatorTextColor: String,
        unit: {
          type: String,
          default: "%"
        },
        processing: {
          type: Boolean,
          required: true
        },
        showIndicator: {
          type: Boolean,
          required: true
        },
        height: [String, Number],
        railBorderRadius: [String, Number],
        fillBorderRadius: [String, Number]
      },
      setup(props, { slots }) {
        const styleHeightRef = vue.computed(() => {
          return formatLength(props.height);
        });
        const styleRailBorderRadiusRef = vue.computed(() => {
          if (props.railBorderRadius !== void 0) {
            return formatLength(props.railBorderRadius);
          }
          if (props.height !== void 0) {
            return formatLength(props.height, { c: 0.5 });
          }
          return "";
        });
        const styleFillBorderRadiusRef = vue.computed(() => {
          if (props.fillBorderRadius !== void 0) {
            return formatLength(props.fillBorderRadius);
          }
          if (props.railBorderRadius !== void 0) {
            return formatLength(props.railBorderRadius);
          }
          if (props.height !== void 0) {
            return formatLength(props.height, { c: 0.5 });
          }
          return "";
        });
        return () => {
          const {
            indicatorPlacement,
            railColor,
            railStyle,
            percentage,
            unit,
            indicatorTextColor,
            status,
            showIndicator,
            fillColor,
            processing,
            clsPrefix
          } = props;
          return /* @__PURE__ */ vue.h("div", {
            class: `${clsPrefix}-progress-content`,
            role: "none"
          }, /* @__PURE__ */ vue.h("div", {
            class: `${clsPrefix}-progress-graph`,
            "aria-hidden": true
          }, /* @__PURE__ */ vue.h("div", {
            class: [
              `${clsPrefix}-progress-graph-line`,
              {
                [`${clsPrefix}-progress-graph-line--indicator-${indicatorPlacement}`]: true
              }
            ]
          }, /* @__PURE__ */ vue.h("div", {
            class: `${clsPrefix}-progress-graph-line-rail`,
            style: [
              {
                backgroundColor: railColor,
                height: styleHeightRef.value,
                borderRadius: styleRailBorderRadiusRef.value
              },
              railStyle
            ]
          }, /* @__PURE__ */ vue.h("div", {
            class: [
              `${clsPrefix}-progress-graph-line-fill`,
              processing && `${clsPrefix}-progress-graph-line-fill--processing`
            ],
            style: {
              maxWidth: `${props.percentage}%`,
              backgroundColor: fillColor,
              height: styleHeightRef.value,
              lineHeight: styleHeightRef.value,
              borderRadius: styleFillBorderRadiusRef.value
            }
          }, indicatorPlacement === "inside" ? /* @__PURE__ */ vue.h("div", {
            class: `${clsPrefix}-progress-graph-line-indicator`
          }, percentage, unit) : null)))), showIndicator && indicatorPlacement === "outside" ? /* @__PURE__ */ vue.h("div", null, slots.default ? /* @__PURE__ */ vue.h("div", {
            class: `${clsPrefix}-progress-custom-content`,
            style: {
              color: indicatorTextColor
            },
            role: "none"
          }, slots.default()) : status === "default" ? /* @__PURE__ */ vue.h("div", {
            role: "none",
            class: `${clsPrefix}-progress-icon ${clsPrefix}-progress-icon--as-text`,
            style: {
              color: indicatorTextColor
            }
          }, percentage, unit) : /* @__PURE__ */ vue.h("div", {
            class: `${clsPrefix}-progress-icon`,
            "aria-hidden": true
          }, /* @__PURE__ */ vue.h(NBaseIcon, {
            clsPrefix
          }, { default: () => iconMap$2[status] }))) : null);
        };
      }
    });

    const iconMap$1 = {
      success: /* @__PURE__ */ vue.h(SuccessIcon, null),
      error: /* @__PURE__ */ vue.h(ErrorIcon, null),
      warning: /* @__PURE__ */ vue.h(WarningIcon, null),
      info: /* @__PURE__ */ vue.h(InfoIcon, null)
    };
    var Circle = vue.defineComponent({
      name: "ProgressCircle",
      props: {
        clsPrefix: {
          type: String,
          required: true
        },
        status: {
          type: String,
          required: true
        },
        strokeWidth: {
          type: Number,
          required: true
        },
        fillColor: String,
        railColor: String,
        railStyle: [String, Object],
        percentage: {
          type: Number,
          default: 0
        },
        offsetDegree: {
          type: Number,
          default: 0
        },
        showIndicator: {
          type: Boolean,
          required: true
        },
        indicatorTextColor: String,
        unit: String,
        viewBoxWidth: {
          type: Number,
          required: true
        },
        gapDegree: {
          type: Number,
          required: true
        },
        gapOffsetDegree: {
          type: Number,
          default: 0
        }
      },
      setup(props, { slots }) {
        function getPathStyles(percent, offsetDegree, strokeColor) {
          const { gapDegree, viewBoxWidth } = props;
          const radius = 50;
          const beginPositionX = 0;
          const beginPositionY = radius;
          const endPositionX = 0;
          const endPositionY = 2 * radius;
          const pathString = `M 55,55 m ${beginPositionX},${beginPositionY}
      a ${radius},${radius} 0 1 1 ${endPositionX},${-endPositionY}
      a ${radius},${radius} 0 1 1 ${-endPositionX},${endPositionY}`;
          const len = Math.PI * 2 * radius;
          const pathStyle = {
            stroke: strokeColor,
            strokeDasharray: `${percent / 100 * (len - gapDegree)}px ${viewBoxWidth * 8}px`,
            strokeDashoffset: `-${gapDegree / 2}px`,
            transformOrigin: offsetDegree ? "center" : void 0,
            transform: offsetDegree ? `rotate(${offsetDegree}deg)` : void 0
          };
          return {
            pathString,
            pathStyle
          };
        }
        return () => {
          const {
            fillColor,
            railColor,
            strokeWidth,
            offsetDegree,
            status,
            percentage,
            showIndicator,
            indicatorTextColor,
            unit,
            gapOffsetDegree,
            clsPrefix
          } = props;
          const { pathString: railPathString, pathStyle: railPathStyle } = getPathStyles(100, 0, railColor);
          const { pathString: fillPathString, pathStyle: fillPathStyle } = getPathStyles(percentage, offsetDegree, fillColor);
          return /* @__PURE__ */ vue.h("div", {
            class: `${clsPrefix}-progress-content`,
            role: "none"
          }, /* @__PURE__ */ vue.h("div", {
            class: `${clsPrefix}-progress-graph`,
            "aria-hidden": true
          }, /* @__PURE__ */ vue.h("div", {
            class: `${clsPrefix}-progress-graph-circle`,
            style: {
              transform: gapOffsetDegree ? `rotate(${gapOffsetDegree}deg)` : void 0
            }
          }, /* @__PURE__ */ vue.h("svg", {
            viewBox: "0 0 110 110"
          }, /* @__PURE__ */ vue.h("g", null, /* @__PURE__ */ vue.h("path", {
            class: `${clsPrefix}-progress-graph-circle-rail`,
            d: railPathString,
            "stroke-width": strokeWidth,
            "stroke-linecap": "round",
            fill: "none",
            style: railPathStyle
          })), /* @__PURE__ */ vue.h("g", null, /* @__PURE__ */ vue.h("path", {
            class: [
              `${clsPrefix}-progress-graph-circle-fill`,
              percentage === 0 && `${clsPrefix}-progress-graph-circle-fill--empty`
            ],
            d: fillPathString,
            "stroke-width": strokeWidth,
            "stroke-linecap": "round",
            fill: "none",
            style: fillPathStyle
          }))))), showIndicator ? /* @__PURE__ */ vue.h("div", null, slots.default ? /* @__PURE__ */ vue.h("div", {
            class: `${clsPrefix}-progress-custom-content`,
            role: "none"
          }, slots.default()) : status !== "default" ? /* @__PURE__ */ vue.h("div", {
            class: `${clsPrefix}-progress-icon`,
            "aria-hidden": true
          }, /* @__PURE__ */ vue.h(NBaseIcon, {
            clsPrefix
          }, {
            default: () => iconMap$1[status]
          })) : /* @__PURE__ */ vue.h("div", {
            class: `${clsPrefix}-progress-text`,
            style: {
              color: indicatorTextColor
            },
            role: "none"
          }, /* @__PURE__ */ vue.h("span", {
            class: `${clsPrefix}-progress-text__percentage`
          }, percentage), /* @__PURE__ */ vue.h("span", {
            class: `${clsPrefix}-progress-text__unit`
          }, unit))) : null);
        };
      }
    });

    function circlePath(r, sw, vw = 100) {
      return `m ${vw / 2} ${vw / 2 - r} a ${r} ${r} 0 1 1 0 ${2 * r} a ${r} ${r} 0 1 1 0 -${2 * r}`;
    }
    var MultipleCircle = vue.defineComponent({
      name: "ProgressMultipleCircle",
      props: {
        clsPrefix: {
          type: String,
          required: true
        },
        viewBoxWidth: {
          type: Number,
          required: true
        },
        percentage: {
          type: Array,
          default: [0]
        },
        strokeWidth: {
          type: Number,
          required: true
        },
        circleGap: {
          type: Number,
          required: true
        },
        showIndicator: {
          type: Boolean,
          required: true
        },
        fillColor: {
          type: Array,
          default: () => []
        },
        railColor: {
          type: Array,
          default: () => []
        },
        railStyle: {
          type: Array,
          default: () => []
        }
      },
      setup(props, { slots }) {
        const strokeDasharrayRef = vue.computed(() => {
          const strokeDasharrays = props.percentage.map(
            (v, i) => `${Math.PI * v / 100 * (props.viewBoxWidth / 2 - props.strokeWidth / 2 * (1 + 2 * i) - props.circleGap * i) * 2}, ${props.viewBoxWidth * 8}`
          );
          return strokeDasharrays;
        });
        return () => {
          const {
            viewBoxWidth,
            strokeWidth,
            circleGap,
            showIndicator,
            fillColor,
            railColor,
            railStyle,
            percentage,
            clsPrefix
          } = props;
          return /* @__PURE__ */ vue.h("div", {
            class: `${clsPrefix}-progress-content`,
            role: "none"
          }, /* @__PURE__ */ vue.h("div", {
            class: `${clsPrefix}-progress-graph`,
            "aria-hidden": true
          }, /* @__PURE__ */ vue.h("div", {
            class: `${clsPrefix}-progress-graph-circle`
          }, /* @__PURE__ */ vue.h("svg", {
            viewBox: `0 0 ${viewBoxWidth} ${viewBoxWidth}`
          }, percentage.map((p, index) => {
            return /* @__PURE__ */ vue.h("g", {
              key: index
            }, /* @__PURE__ */ vue.h("path", {
              class: `${clsPrefix}-progress-graph-circle-rail`,
              d: circlePath(
                viewBoxWidth / 2 - strokeWidth / 2 * (1 + 2 * index) - circleGap * index,
                strokeWidth,
                viewBoxWidth
              ),
              "stroke-width": strokeWidth,
              "stroke-linecap": "round",
              fill: "none",
              style: [
                {
                  strokeDashoffset: 0,
                  stroke: railColor[index]
                },
                railStyle[index]
              ]
            }), /* @__PURE__ */ vue.h("path", {
              class: [
                `${clsPrefix}-progress-graph-circle-fill`,
                p === 0 && `${clsPrefix}-progress-graph-circle-fill--empty`
              ],
              d: circlePath(
                viewBoxWidth / 2 - strokeWidth / 2 * (1 + 2 * index) - circleGap * index,
                strokeWidth,
                viewBoxWidth
              ),
              "stroke-width": strokeWidth,
              "stroke-linecap": "round",
              fill: "none",
              style: {
                strokeDasharray: strokeDasharrayRef.value[index],
                strokeDashoffset: 0,
                stroke: fillColor[index]
              }
            }));
          })))), showIndicator && slots.default ? /* @__PURE__ */ vue.h("div", null, /* @__PURE__ */ vue.h("div", {
            class: `${clsPrefix}-progress-text`
          }, slots.default())) : null);
        };
      }
    });

    const progressProps = {
      ...useTheme.props,
      processing: Boolean,
      type: {
        type: String,
        default: "line"
      },
      gapDegree: Number,
      gapOffsetDegree: Number,
      status: {
        type: String,
        default: "default"
      },
      railColor: [String, Array],
      railStyle: [String, Array],
      color: [String, Array],
      viewBoxWidth: {
        type: Number,
        default: 100
      },
      strokeWidth: {
        type: Number,
        default: 7
      },
      percentage: [Number, Array],
      unit: {
        type: String,
        default: "%"
      },
      showIndicator: {
        type: Boolean,
        default: true
      },
      indicatorPosition: {
        type: String,
        default: "outside"
      },
      indicatorPlacement: {
        type: String,
        default: "outside"
      },
      indicatorTextColor: String,
      circleGap: {
        type: Number,
        default: 1
      },
      height: Number,
      borderRadius: [String, Number],
      fillBorderRadius: [String, Number],
      offsetDegree: Number
    };
    var NProgress = vue.defineComponent({
      name: "Progress",
      props: progressProps,
      setup(props) {
        const mergedIndicatorPlacementRef = vue.computed(() => {
          return props.indicatorPlacement || props.indicatorPosition;
        });
        const gapDeg = vue.computed(() => {
          if (props.gapDegree || props.gapDegree === 0) {
            return props.gapDegree;
          }
          if (props.type === "dashboard") {
            return 75;
          }
          return void 0;
        });
        const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
        const themeRef = useTheme(
          "Progress",
          "-progress",
          style$o,
          progressLight$1,
          props,
          mergedClsPrefixRef
        );
        const cssVarsRef = vue.computed(() => {
          const { status } = props;
          const {
            common: { cubicBezierEaseInOut },
            self: {
              fontSize,
              fontSizeCircle,
              railColor,
              railHeight,
              iconSizeCircle,
              iconSizeLine,
              textColorCircle,
              textColorLineInner,
              textColorLineOuter,
              lineBgProcessing,
              fontWeightCircle,
              [createKey("iconColor", status)]: iconColor,
              [createKey("fillColor", status)]: fillColor
            }
          } = themeRef.value;
          return {
            "--n-bezier": cubicBezierEaseInOut,
            "--n-fill-color": fillColor,
            "--n-font-size": fontSize,
            "--n-font-size-circle": fontSizeCircle,
            "--n-font-weight-circle": fontWeightCircle,
            "--n-icon-color": iconColor,
            "--n-icon-size-circle": iconSizeCircle,
            "--n-icon-size-line": iconSizeLine,
            "--n-line-bg-processing": lineBgProcessing,
            "--n-rail-color": railColor,
            "--n-rail-height": railHeight,
            "--n-text-color-circle": textColorCircle,
            "--n-text-color-line-inner": textColorLineInner,
            "--n-text-color-line-outer": textColorLineOuter
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass(
          "progress",
          vue.computed(() => props.status[0]),
          cssVarsRef,
          props
        ) : void 0;
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          mergedIndicatorPlacement: mergedIndicatorPlacementRef,
          gapDeg,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender
        };
      },
      render() {
        const {
          type,
          cssVars,
          indicatorTextColor,
          showIndicator,
          status,
          railColor,
          railStyle,
          color,
          percentage,
          viewBoxWidth,
          strokeWidth,
          mergedIndicatorPlacement,
          unit,
          borderRadius,
          fillBorderRadius,
          height,
          processing,
          circleGap,
          mergedClsPrefix,
          gapDeg,
          gapOffsetDegree,
          themeClass,
          $slots,
          onRender
        } = this;
        onRender?.();
        return /* @__PURE__ */ vue.h("div", {
          class: [
            themeClass,
            `${mergedClsPrefix}-progress`,
            `${mergedClsPrefix}-progress--${type}`,
            `${mergedClsPrefix}-progress--${status}`
          ],
          style: cssVars,
          "aria-valuemax": 100,
          "aria-valuemin": 0,
          "aria-valuenow": percentage,
          role: type === "circle" || type === "line" || type === "dashboard" ? "progressbar" : "none"
        }, type === "circle" || type === "dashboard" ? /* @__PURE__ */ vue.h(Circle, {
          clsPrefix: mergedClsPrefix,
          status,
          showIndicator,
          indicatorTextColor,
          railColor,
          fillColor: color,
          railStyle,
          offsetDegree: this.offsetDegree,
          percentage,
          viewBoxWidth,
          strokeWidth,
          gapDegree: gapDeg === void 0 ? type === "dashboard" ? 75 : 0 : gapDeg,
          gapOffsetDegree,
          unit
        }, $slots) : type === "line" ? /* @__PURE__ */ vue.h(Line, {
          clsPrefix: mergedClsPrefix,
          status,
          showIndicator,
          indicatorTextColor,
          railColor,
          fillColor: color,
          railStyle,
          percentage,
          processing,
          indicatorPlacement: mergedIndicatorPlacement,
          unit,
          fillBorderRadius,
          railBorderRadius: borderRadius,
          height
        }, $slots) : type === "multiple-circle" ? /* @__PURE__ */ vue.h(MultipleCircle, {
          clsPrefix: mergedClsPrefix,
          strokeWidth,
          railColor,
          fillColor: color,
          railStyle,
          viewBoxWidth,
          percentage,
          showIndicator,
          circleGap
        }, $slots) : null);
      }
    });

    var style$n = cB("rate", {
      display: "inline-flex",
      flexWrap: "nowrap"
    }, [c$1("&:hover", [cE("item", `
      transition:
        transform .1s var(--n-bezier),
        color .3s var(--n-bezier);
    `)]), cE("item", `
    position: relative;
    display: flex;
    transition:
      transform .1s var(--n-bezier),
      color .3s var(--n-bezier);
    transform: scale(1);
    font-size: var(--n-item-size);
    color: var(--n-item-color);
  `, [c$1("&:not(:first-child)", {
      marginLeft: "6px"
    }), cM("active", {
      color: "var(--n-item-color-active)"
    })]), cNotM("readonly", `
    cursor: pointer;
  `, [cE("item", [c$1("&:hover", {
      transform: "scale(1.05)"
    }), c$1("&:active", {
      transform: "scale(0.96)"
    })])]), cE("half", `
    display: flex;
    transition: inherit;
    position: absolute;
    top: 0;
    left: 0;
    bottom: 0;
    width: 50%;
    overflow: hidden;
    color: rgba(255, 255, 255, 0);
  `, [cM("active", {
      color: "var(--n-item-color-active)"
    })])]);

    var StarIcon = /* @__PURE__ */ vue.h("svg", {
      viewBox: "0 0 512 512"
    }, /* @__PURE__ */ vue.h("path", {
      d: "M394 480a16 16 0 01-9.39-3L256 383.76 127.39 477a16 16 0 01-24.55-18.08L153 310.35 23 221.2a16 16 0 019-29.2h160.38l48.4-148.95a16 16 0 0130.44 0l48.4 149H480a16 16 0 019.05 29.2L359 310.35l50.13 148.53A16 16 0 01394 480z"
    }));

    const rateProps = {
      ...useTheme.props,
      allowHalf: Boolean,
      count: {
        type: Number,
        default: 5
      },
      value: Number,
      defaultValue: {
        type: Number,
        default: 0
      },
      readonly: Boolean,
      size: {
        type: [String, Number],
        default: "medium"
      },
      color: String,
      "onUpdate:value": [Function, Array],
      onUpdateValue: [Function, Array]
    };
    var Rate = vue.defineComponent({
      name: "Rate",
      props: rateProps,
      setup(props) {
        const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
        const themeRef = useTheme(
          "Rate",
          "-rate",
          style$n,
          rateLight,
          props,
          mergedClsPrefixRef
        );
        const controlledValueRef = vue.toRef(props, "value");
        const uncontrolledValueRef = vue.ref(props.defaultValue);
        const hoverIndexRef = vue.ref(null);
        const formItem = useFormItem(props);
        function doUpdateValue(value) {
          const { "onUpdate:value": _onUpdateValue, onUpdateValue } = props;
          const { nTriggerFormChange, nTriggerFormInput } = formItem;
          if (_onUpdateValue) {
            call(_onUpdateValue, value);
          }
          if (onUpdateValue) {
            call(onUpdateValue, value);
          }
          uncontrolledValueRef.value = value;
          nTriggerFormChange();
          nTriggerFormInput();
        }
        function getDerivedValue(index, e) {
          if (props.allowHalf) {
            if (e.offsetX >= Math.floor(e.currentTarget.offsetWidth / 2)) {
              return index + 1;
            } else {
              return index + 0.5;
            }
          } else {
            return index + 1;
          }
        }
        function handleMouseMove(index, e) {
          hoverIndexRef.value = getDerivedValue(index, e);
        }
        function handleMouseLeave() {
          hoverIndexRef.value = null;
        }
        function handleClick(index, e) {
          doUpdateValue(getDerivedValue(index, e));
        }
        const mergedSizeRef = vue.computed(() => {
          const { size } = props;
          const { self } = themeRef.value;
          if (typeof size === "number") {
            return `${size}px`;
          } else {
            return self[createKey("size", size)];
          }
        });
        const cssVarsRef = vue.computed(() => {
          const {
            common: { cubicBezierEaseInOut },
            self
          } = themeRef.value;
          const { itemColor, itemColorActive } = self;
          return {
            "--n-bezier": cubicBezierEaseInOut,
            "--n-item-color": itemColor,
            "--n-item-color-active": props.color || itemColorActive,
            "--n-item-size": mergedSizeRef.value
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass(
          "rate",
          vue.computed(() => {
            const size = mergedSizeRef.value;
            const { color } = props;
            let hash = "";
            if (size) {
              hash += size[0];
            }
            if (color) {
              hash += color2Class(color);
            }
            return hash;
          }),
          cssVarsRef,
          props
        ) : void 0;
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          mergedValue: useMergedState(controlledValueRef, uncontrolledValueRef),
          hoverIndex: hoverIndexRef,
          handleMouseMove,
          handleClick,
          handleMouseLeave,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender
        };
      },
      render() {
        const {
          readonly,
          hoverIndex,
          mergedValue,
          mergedClsPrefix,
          onRender,
          $slots: { default: defaultSlot }
        } = this;
        onRender?.();
        return /* @__PURE__ */ vue.h("div", {
          class: [
            `${mergedClsPrefix}-rate`,
            {
              [`${mergedClsPrefix}-rate--readonly`]: readonly
            },
            this.themeClass
          ],
          style: this.cssVars,
          onMouseleave: this.handleMouseLeave
        }, vue.renderList(this.count, (_, index) => {
          const icon = defaultSlot ? defaultSlot() : /* @__PURE__ */ vue.h(NBaseIcon, {
            clsPrefix: mergedClsPrefix
          }, { default: () => StarIcon });
          const fullStarActive = hoverIndex !== null ? index + 1 <= hoverIndex : index + 1 <= mergedValue;
          return /* @__PURE__ */ vue.h("div", {
            key: index,
            class: [
              `${mergedClsPrefix}-rate__item`,
              fullStarActive && `${mergedClsPrefix}-rate__item--active`
            ],
            onClick: readonly ? void 0 : (e) => {
              this.handleClick(index, e);
            },
            onMousemove: readonly ? void 0 : (e) => {
              this.handleMouseMove(index, e);
            }
          }, icon, this.allowHalf ? /* @__PURE__ */ vue.h("div", {
            class: [
              `${mergedClsPrefix}-rate__half`,
              {
                [`${mergedClsPrefix}-rate__half--active`]: !fullStarActive && hoverIndex !== null ? index + 0.5 <= hoverIndex : index + 0.5 <= mergedValue
              }
            ]
          }, icon) : null);
        }));
      }
    });

    var image404 = /* @__PURE__ */ vue.h("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 36 36"
    }, /* @__PURE__ */ vue.h("circle", {
      fill: "#FFCB4C",
      cx: "18",
      cy: "17.018",
      r: "17"
    }), /* @__PURE__ */ vue.h("path", {
      fill: "#65471B",
      d: "M14.524 21.036c-.145-.116-.258-.274-.312-.464-.134-.46.13-.918.59-1.021 4.528-1.021 7.577 1.363 7.706 1.465.384.306.459.845.173 1.205-.286.358-.828.401-1.211.097-.11-.084-2.523-1.923-6.182-1.098-.274.061-.554-.016-.764-.184z"
    }), /* @__PURE__ */ vue.h("ellipse", {
      fill: "#65471B",
      cx: "13.119",
      cy: "11.174",
      rx: "2.125",
      ry: "2.656"
    }), /* @__PURE__ */ vue.h("ellipse", {
      fill: "#65471B",
      cx: "24.375",
      cy: "12.236",
      rx: "2.125",
      ry: "2.656"
    }), /* @__PURE__ */ vue.h("path", {
      fill: "#F19020",
      d: "M17.276 35.149s1.265-.411 1.429-1.352c.173-.972-.624-1.167-.624-1.167s1.041-.208 1.172-1.376c.123-1.101-.861-1.363-.861-1.363s.97-.4 1.016-1.539c.038-.959-.995-1.428-.995-1.428s5.038-1.221 5.556-1.341c.516-.12 1.32-.615 1.069-1.694-.249-1.08-1.204-1.118-1.697-1.003-.494.115-6.744 1.566-8.9 2.068l-1.439.334c-.54.127-.785-.11-.404-.512.508-.536.833-1.129.946-2.113.119-1.035-.232-2.313-.433-2.809-.374-.921-1.005-1.649-1.734-1.899-1.137-.39-1.945.321-1.542 1.561.604 1.854.208 3.375-.833 4.293-2.449 2.157-3.588 3.695-2.83 6.973.828 3.575 4.377 5.876 7.952 5.048l3.152-.681z"
    }), /* @__PURE__ */ vue.h("path", {
      fill: "#65471B",
      d: "M9.296 6.351c-.164-.088-.303-.224-.391-.399-.216-.428-.04-.927.393-1.112 4.266-1.831 7.699-.043 7.843.034.433.231.608.747.391 1.154-.216.405-.74.546-1.173.318-.123-.063-2.832-1.432-6.278.047-.257.109-.547.085-.785-.042zm12.135 3.75c-.156-.098-.286-.243-.362-.424-.187-.442.023-.927.468-1.084 4.381-1.536 7.685.48 7.823.567.415.26.555.787.312 1.178-.242.39-.776.495-1.191.238-.12-.072-2.727-1.621-6.267-.379-.266.091-.553.046-.783-.096z"
    }));

    var image500 = /* @__PURE__ */ vue.h("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 36 36"
    }, /* @__PURE__ */ vue.h("path", {
      fill: "#FFCC4D",
      d: "M36 18c0 9.941-8.059 18-18 18-9.94 0-18-8.059-18-18C0 8.06 8.06 0 18 0c9.941 0 18 8.06 18 18"
    }), /* @__PURE__ */ vue.h("ellipse", {
      fill: "#664500",
      cx: "18",
      cy: "27",
      rx: "5",
      ry: "6"
    }), /* @__PURE__ */ vue.h("path", {
      fill: "#664500",
      d: "M5.999 11c-.208 0-.419-.065-.599-.2-.442-.331-.531-.958-.2-1.4C8.462 5.05 12.816 5 13 5c.552 0 1 .448 1 1 0 .551-.445.998-.996 1-.155.002-3.568.086-6.204 3.6-.196.262-.497.4-.801.4zm24.002 0c-.305 0-.604-.138-.801-.4-2.64-3.521-6.061-3.598-6.206-3.6-.55-.006-.994-.456-.991-1.005C22.006 5.444 22.45 5 23 5c.184 0 4.537.05 7.8 4.4.332.442.242 1.069-.2 1.4-.18.135-.39.2-.599.2zm-16.087 4.5l1.793-1.793c.391-.391.391-1.023 0-1.414s-1.023-.391-1.414 0L12.5 14.086l-1.793-1.793c-.391-.391-1.023-.391-1.414 0s-.391 1.023 0 1.414l1.793 1.793-1.793 1.793c-.391.391-.391 1.023 0 1.414.195.195.451.293.707.293s.512-.098.707-.293l1.793-1.793 1.793 1.793c.195.195.451.293.707.293s.512-.098.707-.293c.391-.391.391-1.023 0-1.414L13.914 15.5zm11 0l1.793-1.793c.391-.391.391-1.023 0-1.414s-1.023-.391-1.414 0L23.5 14.086l-1.793-1.793c-.391-.391-1.023-.391-1.414 0s-.391 1.023 0 1.414l1.793 1.793-1.793 1.793c-.391.391-.391 1.023 0 1.414.195.195.451.293.707.293s.512-.098.707-.293l1.793-1.793 1.793 1.793c.195.195.451.293.707.293s.512-.098.707-.293c.391-.391.391-1.023 0-1.414L24.914 15.5z"
    }));

    var image418 = /* @__PURE__ */ vue.h("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 36 36"
    }, /* @__PURE__ */ vue.h("ellipse", {
      fill: "#292F33",
      cx: "18",
      cy: "26",
      rx: "18",
      ry: "10"
    }), /* @__PURE__ */ vue.h("ellipse", {
      fill: "#66757F",
      cx: "18",
      cy: "24",
      rx: "18",
      ry: "10"
    }), /* @__PURE__ */ vue.h("path", {
      fill: "#E1E8ED",
      d: "M18 31C3.042 31 1 16 1 12h34c0 2-1.958 19-17 19z"
    }), /* @__PURE__ */ vue.h("path", {
      fill: "#77B255",
      d: "M35 12.056c0 5.216-7.611 9.444-17 9.444S1 17.271 1 12.056C1 6.84 8.611 3.611 18 3.611s17 3.229 17 8.445z"
    }), /* @__PURE__ */ vue.h("ellipse", {
      fill: "#A6D388",
      cx: "18",
      cy: "13",
      rx: "15",
      ry: "7"
    }), /* @__PURE__ */ vue.h("path", {
      d: "M21 17c-.256 0-.512-.098-.707-.293-2.337-2.337-2.376-4.885-.125-8.262.739-1.109.9-2.246.478-3.377-.461-1.236-1.438-1.996-1.731-2.077-.553 0-.958-.443-.958-.996 0-.552.491-.995 1.043-.995.997 0 2.395 1.153 3.183 2.625 1.034 1.933.91 4.039-.351 5.929-1.961 2.942-1.531 4.332-.125 5.738.391.391.391 1.023 0 1.414-.195.196-.451.294-.707.294zm-6-2c-.256 0-.512-.098-.707-.293-2.337-2.337-2.376-4.885-.125-8.262.727-1.091.893-2.083.494-2.947-.444-.961-1.431-1.469-1.684-1.499-.552 0-.989-.447-.989-1 0-.552.458-1 1.011-1 .997 0 2.585.974 3.36 2.423.481.899 1.052 2.761-.528 5.131-1.961 2.942-1.531 4.332-.125 5.738.391.391.391 1.023 0 1.414-.195.197-.451.295-.707.295z",
      fill: "#5C913B"
    }));

    var image403 = /* @__PURE__ */ vue.h("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 36 36"
    }, /* @__PURE__ */ vue.h("path", {
      fill: "#EF9645",
      d: "M15.5 2.965c1.381 0 2.5 1.119 2.5 2.5v.005L20.5.465c1.381 0 2.5 1.119 2.5 2.5V4.25l2.5-1.535c1.381 0 2.5 1.119 2.5 2.5V8.75L29 18H15.458L15.5 2.965z"
    }), /* @__PURE__ */ vue.h("path", {
      fill: "#FFDC5D",
      d: "M4.625 16.219c1.381-.611 3.354.208 4.75 2.188.917 1.3 1.187 3.151 2.391 3.344.46.073 1.234-.313 1.234-1.397V4.5s0-2 2-2 2 2 2 2v11.633c0-.029 1-.064 1-.082V2s0-2 2-2 2 2 2 2v14.053c0 .017 1 .041 1 .069V4.25s0-2 2-2 2 2 2 2v12.638c0 .118 1 .251 1 .398V8.75s0-2 2-2 2 2 2 2V24c0 6.627-5.373 12-12 12-4.775 0-8.06-2.598-9.896-5.292C8.547 28.423 8.096 26.051 8 25.334c0 0-.123-1.479-1.156-2.865-1.469-1.969-2.5-3.156-3.125-3.866-.317-.359-.625-1.707.906-2.384z"
    }));

    var style$m = cB("result", `
  color: var(--n-text-color);
  line-height: var(--n-line-height);
  font-size: var(--n-font-size);
  transition:
    color .3s var(--n-bezier);
`, [cB("result-icon", `
    display: flex;
    justify-content: center;
    transition: color .3s var(--n-bezier);
  `, [cE("status-image", `
      font-size: var(--n-icon-size);
      width: 1em;
      height: 1em;
    `), cB("base-icon", `
      color: var(--n-icon-color);
      font-size: var(--n-icon-size);
    `)]), cB("result-content", {
      marginTop: "24px"
    }), cB("result-footer", `
    margin-top: 24px;
    text-align: center;
  `), cB("result-header", [cE("title", `
      margin-top: 16px;
      font-weight: var(--n-title-font-weight);
      transition: color .3s var(--n-bezier);
      text-align: center;
      color: var(--n-title-text-color);
      font-size: var(--n-title-font-size);
    `), cE("description", `
      margin-top: 4px;
      text-align: center;
      font-size: var(--n-font-size);
    `)])]);

    const iconMap = {
      403: image403,
      404: image404,
      418: image418,
      500: image500,
      info: /* @__PURE__ */ vue.h(InfoIcon, null),
      success: /* @__PURE__ */ vue.h(SuccessIcon, null),
      warning: /* @__PURE__ */ vue.h(WarningIcon, null),
      error: /* @__PURE__ */ vue.h(ErrorIcon, null)
    };
    const resultProps = {
      ...useTheme.props,
      size: {
        type: String,
        default: "medium"
      },
      status: {
        type: String,
        default: "info"
      },
      title: String,
      description: String
    };
    var Result = vue.defineComponent({
      name: "Result",
      props: resultProps,
      setup(props) {
        const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
        const themeRef = useTheme(
          "Result",
          "-result",
          style$m,
          resultLight$1,
          props,
          mergedClsPrefixRef
        );
        const cssVarsRef = vue.computed(() => {
          const { size, status } = props;
          const {
            common: { cubicBezierEaseInOut },
            self: {
              textColor,
              lineHeight,
              titleTextColor,
              titleFontWeight,
              [createKey("iconColor", status)]: iconColor,
              [createKey("fontSize", size)]: fontSize,
              [createKey("titleFontSize", size)]: titleFontSize,
              [createKey("iconSize", size)]: iconSize
            }
          } = themeRef.value;
          return {
            "--n-bezier": cubicBezierEaseInOut,
            "--n-font-size": fontSize,
            "--n-icon-size": iconSize,
            "--n-line-height": lineHeight,
            "--n-text-color": textColor,
            "--n-title-font-size": titleFontSize,
            "--n-title-font-weight": titleFontWeight,
            "--n-title-text-color": titleTextColor,
            "--n-icon-color": iconColor || ""
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass(
          "result",
          vue.computed(() => {
            const { size, status } = props;
            let hash = "";
            if (size) {
              hash += size[0];
            }
            if (status) {
              hash += status[0];
            }
            return hash;
          }),
          cssVarsRef,
          props
        ) : void 0;
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender
        };
      },
      render() {
        const { status, $slots, mergedClsPrefix, onRender } = this;
        onRender?.();
        return /* @__PURE__ */ vue.h("div", {
          class: [`${mergedClsPrefix}-result`, this.themeClass],
          style: this.cssVars
        }, /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-result-icon`
        }, $slots.icon?.() || /* @__PURE__ */ vue.h(NBaseIcon, {
          clsPrefix: mergedClsPrefix
        }, { default: () => iconMap[status] })), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-result-header`
        }, this.title ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-result-header__title`
        }, this.title) : null, this.description ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-result-header__description`
        }, this.description) : null), $slots.default && /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-result-content`
        }, $slots), $slots.footer && /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-result-footer`
        }, $slots.footer()));
      }
    });

    const scrollbarProps = {
      ...useTheme.props,
      trigger: String,
      xScrollable: Boolean,
      onScroll: Function
    };
    const Scrollbar = vue.defineComponent({
      name: "Scrollbar",
      props: scrollbarProps,
      setup() {
        const scrollbarInstRef = vue.ref(null);
        const exposedMethods = {
          scrollTo: (...args) => {
            scrollbarInstRef.value?.scrollTo(args[0], args[1]);
          },
          scrollBy: (...args) => {
            scrollbarInstRef.value?.scrollBy(args[0], args[1]);
          }
        };
        return {
          ...exposedMethods,
          scrollbarInstRef
        };
      },
      render() {
        return /* @__PURE__ */ vue.h(NScrollbar, {
          ref: "scrollbarInstRef",
          ...this.$props
        }, this.$slots);
      }
    });
    var Scrollbar$1 = Scrollbar;

    const skeletonDark = {
      name: "Skeleton",
      common: commonDark,

      self(vars) {
        const {
          heightSmall,
          heightMedium,
          heightLarge,
          borderRadius
        } = vars;
        return {
          color: "rgba(255, 255, 255, 0.12)",
          colorEnd: "rgba(255, 255, 255, 0.18)",
          borderRadius,
          heightSmall,
          heightMedium,
          heightLarge
        };
      }

    };

    const self$1 = vars => {
      const {
        heightSmall,
        heightMedium,
        heightLarge,
        borderRadius
      } = vars;
      return {
        color: "#eee",
        colorEnd: "#ddd",
        borderRadius,
        heightSmall,
        heightMedium,
        heightLarge
      };
    };

    const skeletonLight = {
      name: "Skeleton",
      common: commonLight,
      self: self$1
    };

    var style$l = c$1([cB("skeleton", `
    height: 1em;
    width: 100%;
    transition: background-color .3s var(--n-bezier);
    transition:
      --n-color-start .3s var(--n-bezier),
      --n-color-end .3s var(--n-bezier),
      background-color .3s var(--n-bezier);
    animation: 2s skeleton-loading infinite cubic-bezier(0.36, 0, 0.64, 1);
    background-color: var(--n-color-start);
  `), c$1("@keyframes skeleton-loading", `
    0% {
      background: var(--n-color-start);
    }
    40% {
      background: var(--n-color-end);
    }
    80% {
      background: var(--n-color-start);
    }
    100% {
      background: var(--n-color-start);
    }
  `)]);

    const skeletonProps = {
      ...useTheme.props,
      text: Boolean,
      round: Boolean,
      circle: Boolean,
      height: [String, Number],
      width: [String, Number],
      size: String,
      repeat: {
        type: Number,
        default: 1
      },
      animated: {
        type: Boolean,
        default: true
      },
      sharp: {
        type: Boolean,
        default: true
      }
    };
    var Skeleton = vue.defineComponent({
      name: "Skeleton",
      inheritAttrs: false,
      props: skeletonProps,
      setup(props) {
        useHoudini();
        const { mergedClsPrefixRef } = useConfig(props);
        const themeRef = useTheme(
          "Skeleton",
          "-skeleton",
          style$l,
          skeletonLight,
          props,
          mergedClsPrefixRef
        );
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          style: vue.computed(() => {
            const theme = themeRef.value;
            const {
              common: { cubicBezierEaseInOut }
            } = theme;
            const selfThemeVars = theme.self;
            const { color, colorEnd, borderRadius } = selfThemeVars;
            let sizeHeight;
            const { circle, sharp, round, width, height, size, text, animated } = props;
            if (size !== void 0) {
              sizeHeight = selfThemeVars[createKey("height", size)];
            }
            const mergedWidth = circle ? width ?? height ?? sizeHeight : width;
            const mergedHeight = (circle ? width ?? height : height) ?? sizeHeight;
            return {
              display: text ? "inline-block" : "",
              verticalAlign: text ? "-0.125em" : "",
              borderRadius: circle ? "50%" : round ? "4096px" : sharp ? "" : borderRadius,
              width: typeof mergedWidth === "number" ? pxfy(mergedWidth) : mergedWidth,
              height: typeof mergedHeight === "number" ? pxfy(mergedHeight) : mergedHeight,
              animation: !animated ? "none" : "",
              "--n-bezier": cubicBezierEaseInOut,
              "--n-color-start": color,
              "--n-color-end": colorEnd
            };
          })
        };
      },
      render() {
        const { repeat, style: style2, mergedClsPrefix, $attrs } = this;
        const child = vue.h(
          "div",
          vue.mergeProps(
            {
              class: `${mergedClsPrefix}-skeleton`,
              style: style2
            },
            $attrs
          )
        );
        if (repeat > 1) {
          return /* @__PURE__ */ vue.h(vue.Fragment, null, Array.apply(null, { length: repeat }).map((_) => [
            child,
            "\n"
          ]));
        }
        return child;
      }
    });

    function isTouchEvent(e) {
      return window.TouchEvent && e instanceof window.TouchEvent;
    }
    function useRefs() {
      const refs = vue.ref( /* @__PURE__ */new Map());

      const setRefs = index => el => {
        refs.value.set(index, el);
      };

      vue.onBeforeUpdate(() => refs.value.clear());
      return [refs, setRefs];
    }

    var style$k = c$1([cB("slider", `
    display: block;
    padding: calc((var(--n-handle-size) - var(--n-rail-height)) / 2) 0;
    position: relative;
    z-index: 0;
    width: 100%;
    cursor: pointer;
    user-select: none;
    -webkit-user-select: none;
  `, [cM("reverse", [cB("slider-handles", [cB("slider-handle-wrapper", `
          transform: translate(50%, -50%);
        `)]), cB("slider-dots", [cB("slider-dot", `
          transform: translateX(50%, -50%);
        `)]), cM("vertical", [cB("slider-handles", [cB("slider-handle-wrapper", `
            transform: translate(-50%, -50%);
          `)]), cB("slider-marks", [cB("slider-mark", `
            transform: translateY(calc(-50% + var(--n-dot-height) / 2));
          `)]), cB("slider-dots", [cB("slider-dot", `
            transform: translateX(-50%) translateY(0);
          `)])])]), cM("vertical", `
      padding: 0 calc((var(--n-handle-size) - var(--n-rail-height)) / 2);
      width: var(--n-rail-width-vertical);
      height: 100%;
    `, [cB("slider-handles", `
        top: calc(var(--n-handle-size) / 2);
        right: 0;
        bottom: calc(var(--n-handle-size) / 2);
        left: 0;
      `, [cB("slider-handle-wrapper", `
          top: unset;
          left: 50%;
          transform: translate(-50%, 50%);
        `)]), cB("slider-rail", `
        height: 100%;
      `, [cE("fill", `
          top: unset;
          right: 0;
          bottom: unset;
          left: 0;
        `)]), cM("with-mark", `
        width: var(--n-rail-width-vertical);
        margin: 0 32px 0 8px;
      `), cB("slider-marks", `
        top: calc(var(--n-handle-size) / 2);
        right: unset;
        bottom: calc(var(--n-handle-size) / 2);
        left: 22px;
      `, [cB("slider-mark", `
          transform: translateY(50%);
          white-space: nowrap;
        `)]), cB("slider-dots", `
        top: calc(var(--n-handle-size) / 2);
        right: unset;
        bottom: calc(var(--n-handle-size) / 2);
        left: 50%;
      `, [cB("slider-dot", `
          transform: translateX(-50%) translateY(50%);
        `)])]), cM("disabled", `
      cursor: not-allowed;
      opacity: var(--n-opacity-disabled);
    `, [cB("slider-handle", `
        cursor: not-allowed;
      `)]), cM("with-mark", `
      width: 100%;
      margin: 8px 0 32px 0;
    `), c$1("&:hover", [cB("slider-rail", {
      backgroundColor: "var(--n-rail-color-hover)"
    }, [cE("fill", {
      backgroundColor: "var(--n-fill-color-hover)"
    })]), cB("slider-handle", {
      boxShadow: "var(--n-handle-box-shadow-hover)"
    })]), cM("active", [cB("slider-rail", {
      backgroundColor: "var(--n-rail-color-hover)"
    }, [cE("fill", {
      backgroundColor: "var(--n-fill-color-hover)"
    })]), cB("slider-handle", {
      boxShadow: "var(--n-handle-box-shadow-hover)"
    })]), cB("slider-marks", `
      position: absolute;
      top: 18px;
      left: calc(var(--n-handle-size) / 2);
      right: calc(var(--n-handle-size) / 2);
    `, [cB("slider-mark", `
        position: absolute;
        transform: translateX(-50%);
        white-space: nowrap;
      `)]), cB("slider-rail", `
      width: 100%;
      position: relative;
      height: var(--n-rail-height);
      background-color: var(--n-rail-color);
      transition: background-color .3s var(--n-bezier);
      border-radius: calc(var(--n-rail-height) / 2);
    `, [cE("fill", `
        position: absolute;
        top: 0;
        bottom: 0;
        border-radius: calc(var(--n-rail-height) / 2);
        transition: background-color .3s var(--n-bezier);
        background-color: var(--n-fill-color);
      `)]), cB("slider-handles", `
      position: absolute;
      top: 0;
      right: calc(var(--n-handle-size) / 2);
      bottom: 0;
      left: calc(var(--n-handle-size) / 2);
    `, [cB("slider-handle-wrapper", `
        outline: none;
        position: absolute;
        top: 50%;
        transform: translate(-50%, -50%);
        cursor: pointer;
        display: flex;
      `, [cB("slider-handle", `
          height: var(--n-handle-size);
          width: var(--n-handle-size);
          border-radius: 50%;
          overflow: hidden;
          transition: box-shadow .2s var(--n-bezier), background-color .3s var(--n-bezier);
          background-color: var(--n-handle-color);
          box-shadow: var(--n-handle-box-shadow);
        `, [c$1("&:hover", `
            box-shadow: var(--n-handle-box-shadow-hover);
          `)]), c$1("&:focus", [cB("slider-handle", `
            box-shadow: var(--n-handle-box-shadow-focus);
          `, [c$1("&:hover", `
              box-shadow: var(--n-handle-box-shadow-active);
            `)])])])]), cB("slider-dots", `
      position: absolute;
      top: 50%;
      left: calc(var(--n-handle-size) / 2);
      right: calc(var(--n-handle-size) / 2);
    `, [cM("transition-disabled", [cB("slider-dot", "transition: none;")]), cB("slider-dot", `
        transition:
          border-color .3s var(--n-bezier),
          box-shadow .3s var(--n-bezier),
          background-color .3s var(--n-bezier);
        position: absolute;
        transform: translate(-50%, -50%);
        height: var(--n-dot-height);
        width:  var(--n-dot-width);
        border-radius: var(--n-dot-border-radius);
        overflow: hidden;
        box-sizing: border-box;
        border: var(--n-dot-border);
        background-color: var(--n-dot-color);
      `, [cM("active", "border: var(--n-dot-border-active);")])])]), cB("slider-handle-indicator", `
    font-size: var(--n-font-size);
    padding: 6px 10px;
    border-radius: var(--n-indicator-border-radius);
    color: var(--n-indicator-text-color);
    background-color: var(--n-indicator-color);
    box-shadow: var(--n-indicator-box-shadow);
  `, [fadeInScaleUpTransition()]), cB("slider-handle-indicator", `
    font-size: var(--n-font-size);
    padding: 6px 10px;
    border-radius: var(--n-indicator-border-radius);
    color: var(--n-indicator-text-color);
    background-color: var(--n-indicator-color);
    box-shadow: var(--n-indicator-box-shadow);
  `, [cM("top", `
      margin-bottom: 12px;
    `), cM("right", `
      margin-left: 12px;
    `), cM("bottom", `
      margin-top: 12px;
    `), cM("left", `
      margin-right: 12px;
    `), fadeInScaleUpTransition()]), insideModal(cB("slider", [cB("slider-dot", "background-color: var(--n-dot-color-modal);")])), insidePopover(cB("slider", [cB("slider-dot", "background-color: var(--n-dot-color-popover);")]))]);

    const eventButtonLeft = 0;
    const sliderProps = {
      ...useTheme.props,
      to: useAdjustedTo.propTo,
      defaultValue: {
        type: [Number, Array],
        default: 0
      },
      marks: Object,
      disabled: {
        type: Boolean,
        default: void 0
      },
      formatTooltip: Function,
      min: {
        type: Number,
        default: 0
      },
      max: {
        type: Number,
        default: 100
      },
      step: {
        type: [Number, String],
        default: 1
      },
      range: Boolean,
      value: [Number, Array],
      placement: String,
      showTooltip: {
        type: Boolean,
        default: void 0
      },
      tooltip: {
        type: Boolean,
        default: true
      },
      vertical: Boolean,
      reverse: Boolean,
      "onUpdate:value": [Function, Array],
      onUpdateValue: [Function, Array]
    };
    var Slider = vue.defineComponent({
      name: "Slider",
      props: sliderProps,
      setup(props) {
        const { mergedClsPrefixRef, namespaceRef, inlineThemeDisabled } = useConfig(props);
        const themeRef = useTheme(
          "Slider",
          "-slider",
          style$k,
          sliderLight$1,
          props,
          mergedClsPrefixRef
        );
        const handleRailRef = vue.ref(null);
        const [handleRefs, setHandleRefs] = useRefs();
        const [followerRefs, setFollowerRefs] = useRefs();
        const followerEnabledIndexSetRef = vue.ref(/* @__PURE__ */ new Set());
        const formItem = useFormItem(props);
        const { mergedDisabledRef } = formItem;
        const precisionRef = vue.computed(() => {
          const { step } = props;
          if (step <= 0 || step === "mark")
            return 0;
          const stepString = step.toString();
          let precision = 0;
          if (stepString.includes(".")) {
            precision = stepString.length - stepString.indexOf(".") - 1;
          }
          return precision;
        });
        const uncontrolledValueRef = vue.ref(props.defaultValue);
        const controlledValueRef = vue.toRef(props, "value");
        const mergedValueRef = useMergedState(
          controlledValueRef,
          uncontrolledValueRef
        );
        const arrifiedValueRef = vue.computed(() => {
          const { value: mergedValue } = mergedValueRef;
          return (props.range ? mergedValue : [mergedValue]).map(
            clampValue
          );
        });
        const handleCountExceeds2Ref = vue.computed(
          () => arrifiedValueRef.value.length > 2
        );
        const mergedPlacementRef = vue.computed(() => {
          return props.placement === void 0 ? props.vertical ? "right" : "top" : props.placement;
        });
        const markValuesRef = vue.computed(() => {
          const { marks } = props;
          return marks ? Object.keys(marks).map(parseFloat) : null;
        });
        const activeIndexRef = vue.ref(-1);
        const previousIndexRef = vue.ref(-1);
        const hoverIndexRef = vue.ref(-1);
        const draggingRef = vue.ref(false);
        const dotTransitionDisabledRef = vue.ref(false);
        const styleDirectionRef = vue.computed(() => {
          const { vertical, reverse } = props;
          const left = reverse ? "right" : "left";
          const bottom = reverse ? "top" : "bottom";
          return vertical ? bottom : left;
        });
        const fillStyleRef = vue.computed(() => {
          if (handleCountExceeds2Ref.value)
            return;
          const values = arrifiedValueRef.value;
          const start = valueToPercentage(
            props.range ? Math.min(...values) : props.min
          );
          const end = valueToPercentage(
            props.range ? Math.max(...values) : values[0]
          );
          const { value: styleDirection } = styleDirectionRef;
          return props.vertical ? {
            [styleDirection]: `${start}%`,
            height: `${end - start}%`
          } : {
            [styleDirection]: `${start}%`,
            width: `${end - start}%`
          };
        });
        const markInfosRef = vue.computed(() => {
          const mergedMarks = [];
          const { marks } = props;
          if (marks) {
            const orderValues = arrifiedValueRef.value.slice();
            orderValues.sort((a, b) => a - b);
            const { value: styleDirection } = styleDirectionRef;
            const { value: handleCountExceeds2 } = handleCountExceeds2Ref;
            const { range } = props;
            const isActive = handleCountExceeds2 ? () => false : (num) => range ? num >= orderValues[0] && num <= orderValues[orderValues.length - 1] : num <= orderValues[0];
            for (const key of Object.keys(marks)) {
              const num = Number(key);
              mergedMarks.push({
                active: isActive(num),
                label: marks[key],
                style: {
                  [styleDirection]: `${valueToPercentage(num)}%`
                }
              });
            }
          }
          return mergedMarks;
        });
        function getHandleStyle(value, index) {
          const percentage = valueToPercentage(value);
          const { value: styleDirection } = styleDirectionRef;
          return {
            [styleDirection]: `${percentage}%`,
            zIndex: index === activeIndexRef.value ? 1 : 0
          };
        }
        function isShowTooltip(index) {
          return props.showTooltip || hoverIndexRef.value === index || activeIndexRef.value === index && draggingRef.value;
        }
        function shouldKeepTooltipTransition(index) {
          if (!draggingRef.value)
            return true;
          return !(activeIndexRef.value === index && previousIndexRef.value === index);
        }
        function focusActiveHandle(index) {
          if (~index) {
            activeIndexRef.value = index;
            handleRefs.value.get(index)?.focus();
          }
        }
        function syncPosition() {
          followerRefs.value.forEach((inst, index) => {
            if (isShowTooltip(index))
              inst.syncPosition();
          });
        }
        function doUpdateValue(value) {
          const { "onUpdate:value": _onUpdateValue, onUpdateValue } = props;
          const { nTriggerFormInput, nTriggerFormChange } = formItem;
          if (onUpdateValue)
            call(onUpdateValue, value);
          if (_onUpdateValue)
            call(_onUpdateValue, value);
          uncontrolledValueRef.value = value;
          nTriggerFormInput();
          nTriggerFormChange();
        }
        function dispatchValueUpdate(value) {
          const { range } = props;
          if (range) {
            if (Array.isArray(value)) {
              const { value: oldValues } = arrifiedValueRef;
              if (value.join() !== oldValues.join()) {
                doUpdateValue(value);
              }
            }
          } else if (!Array.isArray(value)) {
            const oldValue = arrifiedValueRef.value[0];
            if (oldValue !== value) {
              doUpdateValue(value);
            }
          }
        }
        function doDispatchValue(value, index) {
          if (props.range) {
            const values = arrifiedValueRef.value.slice();
            values.splice(index, 1, value);
            dispatchValueUpdate(values);
          } else {
            dispatchValueUpdate(value);
          }
        }
        function sanitizeValue(value, currentValue, stepBuffer) {
          const stepping = stepBuffer !== void 0;
          if (!stepBuffer) {
            stepBuffer = value - currentValue > 0 ? 1 : -1;
          }
          const markValues = markValuesRef.value || [];
          const { step } = props;
          if (step === "mark") {
            const closestMark2 = getClosestMark(
              value,
              markValues.concat(currentValue),
              stepping ? stepBuffer : void 0
            );
            return closestMark2 ? closestMark2.value : currentValue;
          }
          if (step <= 0)
            return currentValue;
          const { value: precision } = precisionRef;
          let closestMark;
          if (stepping) {
            const currentStep = Number((currentValue / step).toFixed(precision));
            const actualStep = Math.floor(currentStep);
            const leftStep = currentStep > actualStep ? actualStep : actualStep - 1;
            const rightStep = currentStep < actualStep ? actualStep : actualStep + 1;
            closestMark = getClosestMark(
              currentValue,
              [
                Number((leftStep * step).toFixed(precision)),
                Number((rightStep * step).toFixed(precision)),
                ...markValues
              ],
              stepBuffer
            );
          } else {
            const roundValue = getRoundValue(value);
            closestMark = getClosestMark(value, [...markValues, roundValue]);
          }
          return closestMark ? clampValue(closestMark.value) : currentValue;
        }
        function clampValue(value) {
          return Math.min(props.max, Math.max(props.min, value));
        }
        function valueToPercentage(value) {
          const { max, min } = props;
          return (value - min) / (max - min) * 100;
        }
        function percentageToValue(percentage) {
          const { max, min } = props;
          return min + (max - min) * percentage;
        }
        function getRoundValue(value) {
          const { step, min } = props;
          if (step <= 0 || step === "mark")
            return value;
          const newValue = Math.round((value - min) / step) * step + min;
          return Number(newValue.toFixed(precisionRef.value));
        }
        function getClosestMark(currentValue, markValues = markValuesRef.value, buffer) {
          if (!markValues || !markValues.length)
            return null;
          let closestMark = null;
          let index = -1;
          while (++index < markValues.length) {
            const diff = markValues[index] - currentValue;
            const distance = Math.abs(diff);
            if ((buffer === void 0 || diff * buffer > 0) && (closestMark === null || distance < closestMark.distance)) {
              closestMark = {
                index,
                distance,
                value: markValues[index]
              };
            }
          }
          return closestMark;
        }
        function getPointValue(event) {
          const railEl = handleRailRef.value;
          if (!railEl)
            return;
          const touchEvent = isTouchEvent(event) ? event.touches[0] : event;
          const railRect = railEl.getBoundingClientRect();
          let percentage;
          if (props.vertical) {
            percentage = (railRect.bottom - touchEvent.clientY) / railRect.height;
          } else {
            percentage = (touchEvent.clientX - railRect.left) / railRect.width;
          }
          if (props.reverse) {
            percentage = 1 - percentage;
          }
          return percentageToValue(percentage);
        }
        function handleRailKeyDown(e) {
          if (mergedDisabledRef.value)
            return;
          const { vertical, reverse } = props;
          switch (e.key) {
            case "ArrowUp":
              e.preventDefault();
              handleStepValue(vertical && reverse ? -1 : 1);
              break;
            case "ArrowRight":
              e.preventDefault();
              handleStepValue(!vertical && reverse ? -1 : 1);
              break;
            case "ArrowDown":
              e.preventDefault();
              handleStepValue(vertical && reverse ? 1 : -1);
              break;
            case "ArrowLeft":
              e.preventDefault();
              handleStepValue(!vertical && reverse ? 1 : -1);
              break;
          }
        }
        function handleStepValue(ratio) {
          const activeIndex = activeIndexRef.value;
          if (activeIndex === -1)
            return;
          const { step } = props;
          const currentValue = arrifiedValueRef.value[activeIndex];
          const nextValue = step <= 0 || step === "mark" ? currentValue : currentValue + step * ratio;
          doDispatchValue(
            sanitizeValue(nextValue, currentValue, ratio > 0 ? 1 : -1),
            activeIndex
          );
        }
        function handleRailMouseDown(event) {
          if (mergedDisabledRef.value)
            return;
          if (!isTouchEvent(event) && event.button !== eventButtonLeft) {
            return;
          }
          const pointValue = getPointValue(event);
          if (pointValue === void 0)
            return;
          const values = arrifiedValueRef.value.slice();
          const activeIndex = props.range ? getClosestMark(pointValue, values)?.index ?? -1 : 0;
          if (activeIndex !== -1) {
            event.preventDefault();
            focusActiveHandle(activeIndex);
            startDragging();
            doDispatchValue(
              sanitizeValue(pointValue, arrifiedValueRef.value[activeIndex]),
              activeIndex
            );
          }
        }
        function startDragging() {
          if (!draggingRef.value) {
            draggingRef.value = true;
            on("touchend", document, handleMouseUp);
            on("mouseup", document, handleMouseUp);
            on("touchmove", document, handleMouseMove);
            on("mousemove", document, handleMouseMove);
          }
        }
        function stopDragging() {
          if (draggingRef.value) {
            draggingRef.value = false;
            off("touchend", document, handleMouseUp);
            off("mouseup", document, handleMouseUp);
            off("touchmove", document, handleMouseMove);
            off("mousemove", document, handleMouseMove);
          }
        }
        function handleMouseMove(event) {
          const { value: activeIndex } = activeIndexRef;
          if (!draggingRef.value || activeIndex === -1) {
            stopDragging();
            return;
          }
          const pointValue = getPointValue(event);
          doDispatchValue(
            sanitizeValue(pointValue, arrifiedValueRef.value[activeIndex]),
            activeIndex
          );
        }
        function handleMouseUp() {
          stopDragging();
        }
        function handleHandleFocus(index) {
          activeIndexRef.value = index;
          if (!mergedDisabledRef.value) {
            hoverIndexRef.value = index;
          }
        }
        function handleHandleBlur(index) {
          if (activeIndexRef.value === index) {
            activeIndexRef.value = -1;
            stopDragging();
          }
          if (hoverIndexRef.value === index) {
            hoverIndexRef.value = -1;
          }
        }
        function handleHandleMouseEnter(index) {
          hoverIndexRef.value = index;
        }
        function handleHandleMouseLeave(index) {
          if (hoverIndexRef.value === index) {
            hoverIndexRef.value = -1;
          }
        }
        vue.watch(
          activeIndexRef,
          (_, previous) => void vue.nextTick(() => previousIndexRef.value = previous)
        );
        vue.watch(mergedValueRef, () => {
          if (props.marks) {
            if (dotTransitionDisabledRef.value)
              return;
            dotTransitionDisabledRef.value = true;
            void vue.nextTick(() => {
              dotTransitionDisabledRef.value = false;
            });
          }
          void vue.nextTick(syncPosition);
        });
        vue.onBeforeUnmount(() => {
          stopDragging();
        });
        const cssVarsRef = vue.computed(() => {
          const {
            self: {
              railColor,
              railColorHover,
              fillColor,
              fillColorHover,
              handleColor,
              opacityDisabled,
              dotColor,
              dotColorModal,
              handleBoxShadow,
              handleBoxShadowHover,
              handleBoxShadowActive,
              handleBoxShadowFocus,
              dotBorder,
              dotBoxShadow,
              railHeight,
              railWidthVertical,
              handleSize,
              dotHeight,
              dotWidth,
              dotBorderRadius,
              fontSize,
              dotBorderActive,
              dotColorPopover
            },
            common: { cubicBezierEaseInOut }
          } = themeRef.value;
          return {
            "--n-bezier": cubicBezierEaseInOut,
            "--n-dot-border": dotBorder,
            "--n-dot-border-active": dotBorderActive,
            "--n-dot-border-radius": dotBorderRadius,
            "--n-dot-box-shadow": dotBoxShadow,
            "--n-dot-color": dotColor,
            "--n-dot-color-modal": dotColorModal,
            "--n-dot-color-popover": dotColorPopover,
            "--n-dot-height": dotHeight,
            "--n-dot-width": dotWidth,
            "--n-fill-color": fillColor,
            "--n-fill-color-hover": fillColorHover,
            "--n-font-size": fontSize,
            "--n-handle-box-shadow": handleBoxShadow,
            "--n-handle-box-shadow-active": handleBoxShadowActive,
            "--n-handle-box-shadow-focus": handleBoxShadowFocus,
            "--n-handle-box-shadow-hover": handleBoxShadowHover,
            "--n-handle-color": handleColor,
            "--n-handle-size": handleSize,
            "--n-opacity-disabled": opacityDisabled,
            "--n-rail-color": railColor,
            "--n-rail-color-hover": railColorHover,
            "--n-rail-height": railHeight,
            "--n-rail-width-vertical": railWidthVertical
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("slider", void 0, cssVarsRef, props) : void 0;
        const indicatorCssVarsRef = vue.computed(() => {
          const {
            self: {
              fontSize,
              indicatorColor,
              indicatorBoxShadow,
              indicatorTextColor,
              indicatorBorderRadius
            }
          } = themeRef.value;
          return {
            "--n-font-size": fontSize,
            "--n-indicator-border-radius": indicatorBorderRadius,
            "--n-indicator-box-shadow": indicatorBoxShadow,
            "--n-indicator-color": indicatorColor,
            "--n-indicator-text-color": indicatorTextColor
          };
        });
        const indicatorThemeClassHandle = inlineThemeDisabled ? useThemeClass("slider-indicator", void 0, indicatorCssVarsRef, props) : void 0;
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          namespace: namespaceRef,
          uncontrolledValue: uncontrolledValueRef,
          mergedValue: mergedValueRef,
          mergedDisabled: mergedDisabledRef,
          mergedPlacement: mergedPlacementRef,
          isMounted: isMounted(),
          adjustedTo: useAdjustedTo(props),
          dotTransitionDisabled: dotTransitionDisabledRef,
          markInfos: markInfosRef,
          isShowTooltip,
          shouldKeepTooltipTransition,
          handleRailRef,
          setHandleRefs,
          setFollowerRefs,
          fillStyle: fillStyleRef,
          getHandleStyle,
          activeIndex: activeIndexRef,
          arrifiedValues: arrifiedValueRef,
          followerEnabledIndexSet: followerEnabledIndexSetRef,
          handleRailMouseDown,
          handleHandleFocus,
          handleHandleBlur,
          handleHandleMouseEnter,
          handleHandleMouseLeave,
          handleRailKeyDown,
          indicatorCssVars: inlineThemeDisabled ? void 0 : indicatorCssVarsRef,
          indicatorThemeClass: indicatorThemeClassHandle?.themeClass,
          indicatorOnRender: indicatorThemeClassHandle?.onRender,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender
        };
      },
      render() {
        const { mergedClsPrefix, themeClass, formatTooltip } = this;
        this.onRender?.();
        return /* @__PURE__ */ vue.h("div", {
          class: [
            `${mergedClsPrefix}-slider`,
            themeClass,
            {
              [`${mergedClsPrefix}-slider--disabled`]: this.mergedDisabled,
              [`${mergedClsPrefix}-slider--active`]: this.activeIndex !== -1,
              [`${mergedClsPrefix}-slider--with-mark`]: this.marks,
              [`${mergedClsPrefix}-slider--vertical`]: this.vertical,
              [`${mergedClsPrefix}-slider--reverse`]: this.reverse
            }
          ],
          style: this.cssVars,
          onKeydown: this.handleRailKeyDown,
          onMousedown: this.handleRailMouseDown,
          onTouchstart: this.handleRailMouseDown
        }, /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-slider-rail`
        }, /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-slider-rail__fill`,
          style: this.fillStyle
        }), this.marks ? /* @__PURE__ */ vue.h("div", {
          class: [
            `${mergedClsPrefix}-slider-dots`,
            this.dotTransitionDisabled && `${mergedClsPrefix}-slider-dots--transition-disabled`
          ]
        }, this.markInfos.map((mark) => /* @__PURE__ */ vue.h("div", {
          key: mark.label,
          class: [
            `${mergedClsPrefix}-slider-dot`,
            {
              [`${mergedClsPrefix}-slider-dot--active`]: mark.active
            }
          ],
          style: mark.style
        }))) : null, /* @__PURE__ */ vue.h("div", {
          ref: "handleRailRef",
          class: `${mergedClsPrefix}-slider-handles`
        }, this.arrifiedValues.map((value, index) => {
          const showTooltip = this.isShowTooltip(index);
          return /* @__PURE__ */ vue.h(VBinder, null, {
            default: () => [
              /* @__PURE__ */ vue.h(VTarget, null, {
                default: () => /* @__PURE__ */ vue.h("div", {
                  ref: this.setHandleRefs(index),
                  class: `${mergedClsPrefix}-slider-handle-wrapper`,
                  tabindex: this.mergedDisabled ? -1 : 0,
                  style: this.getHandleStyle(value, index),
                  onFocus: () => this.handleHandleFocus(index),
                  onBlur: () => this.handleHandleBlur(index),
                  onMouseenter: () => this.handleHandleMouseEnter(index),
                  onMouseleave: () => this.handleHandleMouseLeave(index)
                }, resolveSlot(this.$slots.thumb, () => [
                  /* @__PURE__ */ vue.h("div", {
                    class: `${mergedClsPrefix}-slider-handle`
                  })
                ]))
              }),
              this.tooltip && /* @__PURE__ */ vue.h(VFollower, {
                ref: this.setFollowerRefs(index),
                show: showTooltip,
                to: this.adjustedTo,
                enabled: this.showTooltip && !this.range || this.followerEnabledIndexSet.has(index),
                teleportDisabled: this.adjustedTo === useAdjustedTo.tdkey,
                placement: this.mergedPlacement,
                containerClass: this.namespace
              }, {
                default: () => /* @__PURE__ */ vue.h(vue.Transition, {
                  name: "fade-in-scale-up-transition",
                  appear: this.isMounted,
                  css: this.shouldKeepTooltipTransition(index),
                  onEnter: () => {
                    this.followerEnabledIndexSet.add(index);
                  },
                  onAfterLeave: () => {
                    this.followerEnabledIndexSet.delete(index);
                  }
                }, {
                  default: () => {
                    if (showTooltip) {
                      this.indicatorOnRender?.();
                      return /* @__PURE__ */ vue.h("div", {
                        class: [
                          `${mergedClsPrefix}-slider-handle-indicator`,
                          this.indicatorThemeClass,
                          `${mergedClsPrefix}-slider-handle-indicator--${this.mergedPlacement}`
                        ],
                        style: this.indicatorCssVars
                      }, typeof formatTooltip === "function" ? formatTooltip(value) : value);
                    }
                    return null;
                  }
                })
              })
            ]
          });
        })), this.marks ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-slider-marks`
        }, this.markInfos.map((mark) => /* @__PURE__ */ vue.h("div", {
          key: mark.label,
          class: `${mergedClsPrefix}-slider-mark`,
          style: mark.style
        }, mark.label))) : null));
      }
    });

    var style$j = c$1([c$1("@keyframes spin-rotate", `
    from {
      transform: rotate(0);
    }
    to {
      transform: rotate(360deg);
    }
  `), cB("spin-container", {
      position: "relative"
    }, [cB("spin-body", `
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translateX(-50%) translateY(-50%);
    `, [fadeInTransition()])]), cB("spin-body", `
    display: inline-flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;
  `), cB("spin", `
    display: inline-flex;
    height: var(--n-size);
    width: var(--n-size);
    font-size: var(--n-size);
    color: var(--n-color);
  `, [cM("rotate", `
      animation: spin-rotate 2s linear infinite;
    `)]), cB("spin-description", `
    display: inline-block;
    font-size: var(--n-font-size);
    color: var(--n-text-color);
    transition: color .3s var(--n-bezier);
    margin-top: 8px;
  `), cB("spin-content", `
    opacity: 1;
    transition: opacity .3s var(--n-bezier);
    pointer-events: all;
  `, [cM("spinning", `
      user-select: none;
      -webkit-user-select: none;
      pointer-events: none;
      opacity: var(--n-opacity-spinning);
    `)])]);

    const STROKE_WIDTH = {
      small: 20,
      medium: 18,
      large: 16
    };
    const spinProps = {
      ...useTheme.props,
      description: String,
      stroke: String,
      size: {
        type: [String, Number],
        default: "medium"
      },
      show: {
        type: Boolean,
        default: true
      },
      strokeWidth: Number,
      rotate: {
        type: Boolean,
        default: true
      },
      spinning: {
        type: Boolean,
        validator: () => {
          return true;
        },
        default: void 0
      }
    };
    var Spin = vue.defineComponent({
      name: "Spin",
      props: spinProps,
      setup(props) {
        {
          vue.watchEffect(() => {
            if (props.spinning !== void 0) {
              warnOnce(
                "spin",
                "`spinning` is deprecated, please use `show` instead."
              );
            }
          });
        }
        const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
        const themeRef = useTheme(
          "Spin",
          "-spin",
          style$j,
          spinLight$1,
          props,
          mergedClsPrefixRef
        );
        const cssVarsRef = vue.computed(() => {
          const { size: spinSize } = props;
          const {
            common: { cubicBezierEaseInOut },
            self
          } = themeRef.value;
          const { opacitySpinning, color, textColor } = self;
          const size = typeof spinSize === "number" ? pxfy(spinSize) : self[createKey("size", spinSize)];
          return {
            "--n-bezier": cubicBezierEaseInOut,
            "--n-opacity-spinning": opacitySpinning,
            "--n-size": size,
            "--n-color": color,
            "--n-text-color": textColor
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass(
          "spin",
          vue.computed(() => {
            const { size } = props;
            return typeof size === "number" ? String(size) : size[0];
          }),
          cssVarsRef,
          props
        ) : void 0;
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          compitableShow: useCompitable(props, ["spinning", "show"]),
          mergedStrokeWidth: vue.computed(() => {
            const { strokeWidth } = props;
            if (strokeWidth !== void 0)
              return strokeWidth;
            const { size } = props;
            return STROKE_WIDTH[typeof size === "number" ? "medium" : size];
          }),
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender
        };
      },
      render() {
        const { $slots, mergedClsPrefix, description } = this;
        const rotate = $slots.icon && this.rotate;
        const descriptionNode = (description || $slots.description) && /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-spin-description`
        }, description || $slots.description?.());
        const icon = $slots.icon ? /* @__PURE__ */ vue.h("div", {
          class: [`${mergedClsPrefix}-spin-body`, this.themeClass]
        }, /* @__PURE__ */ vue.h("div", {
          class: [
            `${mergedClsPrefix}-spin`,
            rotate && `${mergedClsPrefix}-spin--rotate`
          ],
          style: $slots.default ? "" : this.cssVars
        }, $slots.icon()), descriptionNode) : /* @__PURE__ */ vue.h("div", {
          class: [`${mergedClsPrefix}-spin-body`, this.themeClass]
        }, /* @__PURE__ */ vue.h(NBaseLoading, {
          clsPrefix: mergedClsPrefix,
          style: $slots.default ? "" : this.cssVars,
          stroke: this.stroke,
          "stroke-width": this.mergedStrokeWidth,
          class: `${mergedClsPrefix}-spin`
        }), descriptionNode);
        this.onRender?.();
        return $slots.default ? /* @__PURE__ */ vue.h("div", {
          class: [`${mergedClsPrefix}-spin-container`, this.themeClass],
          style: this.cssVars
        }, /* @__PURE__ */ vue.h("div", {
          class: [
            `${mergedClsPrefix}-spin-content`,
            this.compitableShow && `${mergedClsPrefix}-spin-content--spinning`
          ]
        }, $slots), /* @__PURE__ */ vue.h(vue.Transition, {
          name: "fade-in-transition"
        }, {
          default: () => this.compitableShow ? icon : null
        })) : icon;
      }
    });

    var style$i = cB("statistic", [cE("label", `
    font-weight: var(--n-label-font-weight);
    transition: .3s color var(--n-bezier);
    font-size: var(--n-label-font-size);
    color: var(--n-label-text-color);
  `), cB("statistic-value", `
    margin-top: 4px;
    font-weight: var(--n-value-font-weight);
  `, [cE("prefix", `
      margin: 0 4px 0 0;
      font-size: var(--n-value-font-size);
      transition: .3s color var(--n-bezier);
      color: var(--n-value-prefix-text-color);
    `, [cB("icon", {
      verticalAlign: "-0.125em"
    })]), cE("content", `
      font-size: var(--n-value-font-size);
      transition: .3s color var(--n-bezier);
      color: var(--n-value-text-color);
    `), cE("suffix", `
      margin: 0 0 0 4px;
      font-size: var(--n-value-font-size);
      transition: .3s color var(--n-bezier);
      color: var(--n-value-suffix-text-color);
    `, [cB("icon", {
      verticalAlign: "-0.125em"
    })])])]);

    const statisticProps = {
      ...useTheme.props,
      tabularNums: Boolean,
      label: String,
      value: [String, Number]
    };
    var Statistic = vue.defineComponent({
      name: "Statistic",
      props: statisticProps,
      setup(props) {
        const { mergedClsPrefixRef, inlineThemeDisabled, mergedRtlRef } = useConfig(props);
        const themeRef = useTheme(
          "Statistic",
          "-statistic",
          style$i,
          statisticLight$1,
          props,
          mergedClsPrefixRef
        );
        const rtlEnabledRef = useRtl("Statistic", mergedRtlRef, mergedClsPrefixRef);
        const cssVarsRef = vue.computed(() => {
          const {
            self: {
              labelFontWeight,
              valueFontSize,
              valueFontWeight,
              valuePrefixTextColor,
              labelTextColor,
              valueSuffixTextColor,
              valueTextColor,
              labelFontSize
            },
            common: { cubicBezierEaseInOut }
          } = themeRef.value;
          return {
            "--n-bezier": cubicBezierEaseInOut,
            "--n-label-font-size": labelFontSize,
            "--n-label-font-weight": labelFontWeight,
            "--n-label-text-color": labelTextColor,
            "--n-value-font-weight": valueFontWeight,
            "--n-value-font-size": valueFontSize,
            "--n-value-prefix-text-color": valuePrefixTextColor,
            "--n-value-suffix-text-color": valueSuffixTextColor,
            "--n-value-text-color": valueTextColor
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("statistic", void 0, cssVarsRef, props) : void 0;
        return {
          rtlEnabled: rtlEnabledRef,
          mergedClsPrefix: mergedClsPrefixRef,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender
        };
      },
      render() {
        const {
          mergedClsPrefix,
          $slots: {
            default: defaultSlot,
            label: labelSlot,
            prefix: prefixSlot,
            suffix: suffixSlot
          }
        } = this;
        this.onRender?.();
        return /* @__PURE__ */ vue.h("div", {
          class: [
            `${mergedClsPrefix}-statistic`,
            this.themeClass,
            this.rtlEnabled && `${mergedClsPrefix}-statistic--rtl`
          ],
          style: this.cssVars
        }, resolveWrappedSlot(labelSlot, (children) => /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-statistic__label`
        }, this.label || children)), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-statistic-value`,
          style: {
            fontVariantNumeric: this.tabularNums ? "tabular-nums" : ""
          }
        }, resolveWrappedSlot(
          prefixSlot,
          (children) => children && /* @__PURE__ */ vue.h("span", {
            class: `${mergedClsPrefix}-statistic-value__prefix`
          }, children)
        ), this.value !== void 0 ? /* @__PURE__ */ vue.h("span", {
          class: `${mergedClsPrefix}-statistic-value__content`
        }, this.value) : resolveWrappedSlot(
          defaultSlot,
          (children) => children && /* @__PURE__ */ vue.h("span", {
            class: `${mergedClsPrefix}-statistic-value__content`
          }, children)
        ), resolveWrappedSlot(
          suffixSlot,
          (children) => children && /* @__PURE__ */ vue.h("span", {
            class: `${mergedClsPrefix}-statistic-value__suffix`
          }, children)
        )));
      }
    });

    var style$h = cB("steps", `
  width: 100%;
  display: flex;
`, [cB("step", `
    position: relative;
    display: flex;
    flex: 1;
  `, [cM("disabled", "cursor: not-allowed"), cM("clickable", `
      cursor: pointer;
    `), c$1("&:last-child", [cB("step-splitor", "display: none;")])]), cB("step-splitor", `
    background-color: var(--n-splitor-color);
    margin-top: calc(var(--n-step-header-font-size) / 2);
    height: 1px;
    flex: 1;
    align-self: flex-start;
    margin-left: 12px;
    margin-right: 12px;
    transition:
      color .3s var(--n-bezier),
      background-color .3s var(--n-bezier);
  `), cB("step-content", "flex: 1;", [cB("step-content-header", `
      color: var(--n-header-text-color);
      margin-top: calc(var(--n-indicator-size) / 2 - var(--n-step-header-font-size) / 2);
      line-height: var(--n-step-header-font-size);
      font-size: var(--n-step-header-font-size);
      position: relative;
      display: flex;
      font-weight: var(--n-step-header-font-weight);
      margin-left: 9px;
      transition:
        color .3s var(--n-bezier),
        background-color .3s var(--n-bezier);
    `, [cE("title", `
        white-space: nowrap;
        flex: 0;
      `)]), cE("description", `
      color: var(--n-description-text-color);
      margin-top: 12px;
      margin-left: 9px;
      transition:
        color .3s var(--n-bezier),
        background-color .3s var(--n-bezier);
    `)]), cB("step-indicator", `
    background-color: var(--n-indicator-color);
    box-shadow: 0 0 0 1px var(--n-indicator-border-color);
    height: var(--n-indicator-size);
    width: var(--n-indicator-size);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    transition:
      background-color .3s var(--n-bezier),
      box-shadow .3s var(--n-bezier);
  `, [cB("step-indicator-slot", `
      position: relative;
      width: var(--n-indicator-icon-size);
      height: var(--n-indicator-icon-size);
      font-size: var(--n-indicator-icon-size);
      line-height: var(--n-indicator-icon-size);
    `, [cE("index", `
        display: inline-block;
        text-align: center;
        position: absolute;
        left: 0;
        top: 0;
        font-size: var(--n-indicator-index-font-size);
        width: var(--n-indicator-icon-size);
        height: var(--n-indicator-icon-size);
        line-height: var(--n-indicator-icon-size);
        color: var(--n-indicator-text-color);
        transition: color .3s var(--n-bezier);
      `, [iconSwitchTransition()]), cB("icon", `
        color: var(--n-indicator-text-color);
        transition: color .3s var(--n-bezier);
      `, [iconSwitchTransition()]), cB("base-icon", `
        color: var(--n-indicator-text-color);
        transition: color .3s var(--n-bezier);
      `, [iconSwitchTransition()])])]), cM("vertical", "flex-direction: column;", [cNotM("show-description", [c$1(">", [cB("step", "padding-bottom: 8px;")])]), c$1(">", [cB("step", "margin-bottom: 16px;", [c$1("&:last-child", "margin-bottom: 0;"), c$1(">", [cB("step-indicator", [c$1(">", [cB("step-splitor", `
                position: absolute;
                bottom: -8px;
                width: 1px;
                margin: 0 !important;
                left: calc(var(--n-indicator-size) / 2);
                height: calc(100% - var(--n-indicator-size));
              `)])]), cB("step-content", [cE("description", "margin-top: 8px;")])])])])])]);

    function stepWithIndex(step, i) {
      if (typeof step !== "object" || step === null || Array.isArray(step)) {
        return null;
      }
      if (!step.props)
        step.props = {};
      step.props.internalIndex = i + 1;
      return step;
    }
    function stepsWithIndex(steps) {
      return steps.map((step, i) => stepWithIndex(step, i));
    }
    const stepsProps = {
      ...useTheme.props,
      current: Number,
      status: {
        type: String,
        default: "process"
      },
      size: {
        type: String,
        default: "medium"
      },
      vertical: Boolean,
      "onUpdate:current": [Function, Array],
      onUpdateCurrent: [Function, Array]
    };
    const stepsInjectionKey = createInjectionKey("n-steps");
    var Steps = vue.defineComponent({
      name: "Steps",
      props: stepsProps,
      setup(props, { slots }) {
        const { mergedClsPrefixRef, mergedRtlRef } = useConfig(props);
        const rtlEnabledRef = useRtl("Steps", mergedRtlRef, mergedClsPrefixRef);
        const themeRef = useTheme(
          "Steps",
          "-steps",
          style$h,
          stepsLight$1,
          props,
          mergedClsPrefixRef
        );
        vue.provide(stepsInjectionKey, {
          props,
          mergedThemeRef: themeRef,
          mergedClsPrefixRef,
          stepsSlots: slots
        });
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          rtlEnabled: rtlEnabledRef
        };
      },
      render() {
        const { mergedClsPrefix } = this;
        return /* @__PURE__ */ vue.h("div", {
          class: [
            `${mergedClsPrefix}-steps`,
            this.rtlEnabled && `${mergedClsPrefix}-steps--rtl`,
            this.vertical && `${mergedClsPrefix}-steps--vertical`
          ]
        }, stepsWithIndex(flatten$3(getSlot$1(this))));
      }
    });

    const stepProps = {
      status: String,
      title: String,
      description: String,
      disabled: Boolean,
      internalIndex: {
        type: Number,
        default: 0
      }
    };
    var Step = vue.defineComponent({
      name: "Step",
      props: stepProps,
      setup(props) {
        const NSteps = vue.inject(stepsInjectionKey, null);
        if (!NSteps)
          throwError("step", "`n-step` must be placed inside `n-steps`.");
        const { inlineThemeDisabled } = useConfig();
        const {
          props: stepsProps,
          mergedThemeRef,
          mergedClsPrefixRef,
          stepsSlots
        } = NSteps;
        const verticalRef = vue.computed(() => {
          return stepsProps.vertical;
        });
        const mergedStatusRef = vue.computed(
          () => {
            const { status } = props;
            if (status) {
              return status;
            } else {
              const { internalIndex } = props;
              const { current } = stepsProps;
              if (current === void 0)
                return "process";
              if (internalIndex < current) {
                return "finish";
              } else if (internalIndex === current) {
                return stepsProps.status || "process";
              } else if (internalIndex > current) {
                return "wait";
              }
            }
            return "process";
          }
        );
        const cssVarsRef = vue.computed(() => {
          const { value: status } = mergedStatusRef;
          const { size } = stepsProps;
          const {
            common: { cubicBezierEaseInOut },
            self: {
              stepHeaderFontWeight,
              [createKey("stepHeaderFontSize", size)]: stepHeaderFontSize,
              [createKey("indicatorIndexFontSize", size)]: indicatorIndexFontSize,
              [createKey("indicatorSize", size)]: indicatorSize,
              [createKey("indicatorIconSize", size)]: indicatorIconSize,
              [createKey("indicatorTextColor", status)]: indicatorTextColor,
              [createKey("indicatorBorderColor", status)]: indicatorBorderColor,
              [createKey("headerTextColor", status)]: headerTextColor,
              [createKey("splitorColor", status)]: splitorColor,
              [createKey("indicatorColor", status)]: indicatorColor,
              [createKey("descriptionTextColor", status)]: descriptionTextColor
            }
          } = mergedThemeRef.value;
          return {
            "--n-bezier": cubicBezierEaseInOut,
            "--n-description-text-color": descriptionTextColor,
            "--n-header-text-color": headerTextColor,
            "--n-indicator-border-color": indicatorBorderColor,
            "--n-indicator-color": indicatorColor,
            "--n-indicator-icon-size": indicatorIconSize,
            "--n-indicator-index-font-size": indicatorIndexFontSize,
            "--n-indicator-size": indicatorSize,
            "--n-indicator-text-color": indicatorTextColor,
            "--n-splitor-color": splitorColor,
            "--n-step-header-font-size": stepHeaderFontSize,
            "--n-step-header-font-weight": stepHeaderFontWeight
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass(
          "step",
          vue.computed(() => {
            const { value: status } = mergedStatusRef;
            const { size } = stepsProps;
            return `${status[0]}${size[0]}`;
          }),
          cssVarsRef,
          stepsProps
        ) : void 0;
        const handleStepClick = vue.computed(() => {
          if (props.disabled)
            return void 0;
          const { onUpdateCurrent, "onUpdate:current": _onUpdateCurrent } = stepsProps;
          return onUpdateCurrent || _onUpdateCurrent ? () => {
            if (onUpdateCurrent) {
              call(onUpdateCurrent, props.internalIndex);
            }
            if (_onUpdateCurrent) {
              call(_onUpdateCurrent, props.internalIndex);
            }
          } : void 0;
        });
        return {
          stepsSlots,
          mergedClsPrefix: mergedClsPrefixRef,
          vertical: verticalRef,
          mergedStatus: mergedStatusRef,
          handleStepClick,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender
        };
      },
      render() {
        const { mergedClsPrefix, onRender, handleStepClick, disabled } = this;
        const descriptionNode = resolveWrappedSlot(
          this.$slots.default,
          (children) => {
            const mergedDescription = children || this.description;
            if (mergedDescription) {
              return /* @__PURE__ */ vue.h("div", {
                class: `${mergedClsPrefix}-step-content__description`
              }, mergedDescription);
            }
            return null;
          }
        );
        onRender?.();
        return /* @__PURE__ */ vue.h("div", {
          class: [
            `${mergedClsPrefix}-step`,
            disabled && `${mergedClsPrefix}-step--disabled`,
            !disabled && handleStepClick && `${mergedClsPrefix}-step--clickable`,
            this.themeClass,
            descriptionNode && `${mergedClsPrefix}-step--show-description`,
            `${mergedClsPrefix}-step--${this.mergedStatus}-status`
          ],
          style: this.cssVars,
          onClick: handleStepClick
        }, /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-step-indicator`
        }, /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-step-indicator-slot`
        }, /* @__PURE__ */ vue.h(NIconSwitchTransition, null, {
          default: () => {
            return resolveWrappedSlot(this.$slots.icon, (icon) => {
              const { mergedStatus, stepsSlots } = this;
              return !(mergedStatus === "finish" || mergedStatus === "error") ? icon || /* @__PURE__ */ vue.h("div", {
                key: this.internalIndex,
                class: `${mergedClsPrefix}-step-indicator-slot__index`
              }, this.internalIndex) : mergedStatus === "finish" ? /* @__PURE__ */ vue.h(NBaseIcon, {
                clsPrefix: mergedClsPrefix,
                key: "finish"
              }, {
                default: () => resolveSlot(stepsSlots["finish-icon"], () => [
                  /* @__PURE__ */ vue.h(FinishedIcon, null)
                ])
              }) : mergedStatus === "error" ? /* @__PURE__ */ vue.h(NBaseIcon, {
                clsPrefix: mergedClsPrefix,
                key: "error"
              }, {
                default: () => resolveSlot(stepsSlots["error-icon"], () => [
                  /* @__PURE__ */ vue.h(ErrorIcon$1, null)
                ])
              }) : null;
            });
          }
        })), this.vertical ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-step-splitor`
        }) : null), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-step-content`
        }, /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-step-content-header`
        }, /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-step-content-header__title`
        }, resolveSlot(this.$slots.title, () => [this.title])), !this.vertical ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-step-splitor`
        }) : null), descriptionNode));
      }
    });

    var style$g = cB("switch", `
  height: var(--n-height);
  min-width: var(--n-width);
  vertical-align: middle;
  user-select: none;
  -webkit-user-select: none;
  display: inline-flex;
  outline: none;
  justify-content: center;
  align-items: center;
`, [cE("children-placeholder", `
    height: var(--n-rail-height);
    display: flex;
    flex-direction: column;
    overflow: hidden;
    pointer-events: none;
    visibility: hidden;
  `), cE("rail-placeholder", `
    display: flex;
    flex-wrap: none;
  `), cE("button-placeholder", `
    width: calc(1.75 * var(--n-rail-height));
    height: var(--n-rail-height);
  `), cB("base-loading", `
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translateX(-50%) translateY(-50%);
    font-size: calc(var(--n-button-width) - 4px);
    color: var(--n-loading-color);
    transition: color .3s var(--n-bezier);
  `, [iconSwitchTransition({
      left: "50%",
      top: "50%",
      originalTransform: "translateX(-50%) translateY(-50%)"
    })]), cE("checked, unchecked", `
    transition: color .3s var(--n-bezier);
    color: var(--n-text-color);
    box-sizing: border-box;
    position: absolute;
    white-space: nowrap;
    top: 0;
    bottom: 0;
    display: flex;
    align-items: center;
    line-height: 1;
  `), cE("checked", `
    right: 0;
    padding-right: calc(1.25 * var(--n-rail-height) - var(--n-offset));
  `), cE("unchecked", `
    left: 0;
    justify-content: flex-end;
    padding-left: calc(1.25 * var(--n-rail-height) - var(--n-offset));
  `), c$1("&:focus", [cE("rail", `
      box-shadow: var(--n-box-shadow-focus);
    `)]), cM("round", [cE("rail", "border-radius: calc(var(--n-rail-height) / 2);", [cE("button", "border-radius: calc(var(--n-button-height) / 2);")])]), cNotM("disabled", [cNotM("icon", [cM("rubber-band", [cM("pressed", [cE("rail", [cE("button", "max-width: var(--n-button-width-pressed);")])]), cE("rail", [c$1("&:active", [cE("button", "max-width: var(--n-button-width-pressed);")])]), cM("active", [cM("pressed", [cE("rail", [cE("button", "left: calc(100% - var(--n-offset) - var(--n-button-width-pressed));")])]), cE("rail", [c$1("&:active", [cE("button", "left: calc(100% - var(--n-offset) - var(--n-button-width-pressed));")])])])])])]), cM("active", [cE("rail", [cE("button", "left: calc(100% - var(--n-button-width) - var(--n-offset))")])]), cE("rail", `
    overflow: hidden;
    height: var(--n-rail-height);
    min-width: var(--n-rail-width);
    border-radius: var(--n-rail-border-radius);
    cursor: pointer;
    position: relative;
    transition:
      opacity .3s var(--n-bezier),
      background .3s var(--n-bezier),
      box-shadow .3s var(--n-bezier);
    background-color: var(--n-rail-color);
  `, [cE("button-icon", `
      color: var(--n-icon-color);
      transition: color .3s var(--n-bezier);
      font-size: calc(var(--n-button-height) - 4px);
      position: absolute;
      left: 0;
      right: 0;
      top: 0;
      bottom: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      line-height: 1;
    `, [iconSwitchTransition()]), cE("button", `
      align-items: center;
      top: var(--n-offset);
      left: var(--n-offset);
      height: var(--n-button-height);
      width: var(--n-button-width-pressed);
      max-width: var(--n-button-width);
      border-radius: var(--n-button-border-radius);
      background-color: var(--n-button-color);
      box-shadow: var(--n-button-box-shadow);
      box-sizing: border-box;
      cursor: inherit;
      content: "";
      position: absolute;
      transition:
        background-color .3s var(--n-bezier),
        left .3s var(--n-bezier),
        opacity .3s var(--n-bezier),
        max-width .3s var(--n-bezier),
        box-shadow .3s var(--n-bezier);
    `)]), cM("active", [cE("rail", "background-color: var(--n-rail-color-active);")]), cM("loading", [cE("rail", `
      cursor: wait;
    `)]), cM("disabled", [cE("rail", `
      cursor: not-allowed;
      opacity: .5;
    `)])]);

    const switchProps = {
      ...useTheme.props,
      size: {
        type: String,
        default: "medium"
      },
      value: {
        type: [String, Number, Boolean],
        default: void 0
      },
      loading: Boolean,
      defaultValue: {
        type: [String, Number, Boolean],
        default: false
      },
      disabled: {
        type: Boolean,
        default: void 0
      },
      round: {
        type: Boolean,
        default: true
      },
      "onUpdate:value": [Function, Array],
      onUpdateValue: [Function, Array],
      checkedValue: {
        type: [String, Number, Boolean],
        default: true
      },
      uncheckedValue: {
        type: [String, Number, Boolean],
        default: false
      },
      railStyle: Function,
      rubberBand: {
        type: Boolean,
        default: true
      },
      onChange: [Function, Array]
    };
    let supportCssMax;
    var Switch = vue.defineComponent({
      name: "Switch",
      props: switchProps,
      setup(props) {
        {
          vue.watchEffect(() => {
            if (props.onChange) {
              warnOnce(
                "switch",
                "`on-change` is deprecated, please use `on-update:value` instead."
              );
            }
          });
        }
        if (supportCssMax === void 0) {
          if (typeof CSS !== "undefined") {
            if (typeof CSS.supports !== "undefined") {
              supportCssMax = CSS.supports("width", "max(1px)");
            } else {
              supportCssMax = false;
            }
          } else {
            supportCssMax = true;
          }
        }
        const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
        const themeRef = useTheme(
          "Switch",
          "-switch",
          style$g,
          switchLight$1,
          props,
          mergedClsPrefixRef
        );
        const formItem = useFormItem(props);
        const { mergedSizeRef, mergedDisabledRef } = formItem;
        const uncontrolledValueRef = vue.ref(props.defaultValue);
        const controlledValueRef = vue.toRef(props, "value");
        const mergedValueRef = useMergedState(
          controlledValueRef,
          uncontrolledValueRef
        );
        const checkedRef = vue.computed(() => {
          return mergedValueRef.value === props.checkedValue;
        });
        const pressedRef = vue.ref(false);
        const focusedRef = vue.ref(false);
        const mergedRailStyleRef = vue.computed(() => {
          const { railStyle } = props;
          if (!railStyle)
            return void 0;
          return railStyle({ focused: focusedRef.value, checked: checkedRef.value });
        });
        function doUpdateValue(value) {
          const {
            "onUpdate:value": _onUpdateValue,
            onChange,
            onUpdateValue
          } = props;
          const { nTriggerFormInput, nTriggerFormChange } = formItem;
          if (_onUpdateValue)
            call(_onUpdateValue, value);
          if (onUpdateValue)
            call(onUpdateValue, value);
          if (onChange)
            call(onChange, value);
          uncontrolledValueRef.value = value;
          nTriggerFormInput();
          nTriggerFormChange();
        }
        function doFocus() {
          const { nTriggerFormFocus } = formItem;
          nTriggerFormFocus();
        }
        function doBlur() {
          const { nTriggerFormBlur } = formItem;
          nTriggerFormBlur();
        }
        function handleClick() {
          if (props.loading || mergedDisabledRef.value)
            return;
          if (mergedValueRef.value !== props.checkedValue) {
            doUpdateValue(props.checkedValue);
          } else {
            doUpdateValue(props.uncheckedValue);
          }
        }
        function handleFocus() {
          focusedRef.value = true;
          doFocus();
        }
        function handleBlur() {
          focusedRef.value = false;
          doBlur();
          pressedRef.value = false;
        }
        function handleKeyup(e) {
          if (props.loading || mergedDisabledRef.value)
            return;
          if (e.key === " ") {
            if (mergedValueRef.value !== props.checkedValue) {
              doUpdateValue(props.checkedValue);
            } else {
              doUpdateValue(props.uncheckedValue);
            }
            pressedRef.value = false;
          }
        }
        function handleKeydown(e) {
          if (props.loading || mergedDisabledRef.value)
            return;
          if (e.key === " ") {
            e.preventDefault();
            pressedRef.value = true;
          }
        }
        const cssVarsRef = vue.computed(() => {
          const { value: size } = mergedSizeRef;
          const {
            self: {
              opacityDisabled,
              railColor,
              railColorActive,
              buttonBoxShadow,
              buttonColor,
              boxShadowFocus,
              loadingColor,
              textColor,
              iconColor,
              [createKey("buttonHeight", size)]: buttonHeight,
              [createKey("buttonWidth", size)]: buttonWidth,
              [createKey("buttonWidthPressed", size)]: buttonWidthPressed,
              [createKey("railHeight", size)]: railHeight,
              [createKey("railWidth", size)]: railWidth,
              [createKey("railBorderRadius", size)]: railBorderRadius,
              [createKey("buttonBorderRadius", size)]: buttonBorderRadius
            },
            common: { cubicBezierEaseInOut }
          } = themeRef.value;
          let offset;
          let height;
          let width;
          if (supportCssMax) {
            offset = `calc((${railHeight} - ${buttonHeight}) / 2)`;
            height = `max(${railHeight}, ${buttonHeight})`;
            width = `max(${railWidth}, calc(${railWidth} + ${buttonHeight} - ${railHeight}))`;
          } else {
            offset = pxfy((depx(railHeight) - depx(buttonHeight)) / 2);
            height = pxfy(Math.max(depx(railHeight), depx(buttonHeight)));
            width = depx(railHeight) > depx(buttonHeight) ? railWidth : pxfy(depx(railWidth) + depx(buttonHeight) - depx(railHeight));
          }
          return {
            "--n-bezier": cubicBezierEaseInOut,
            "--n-button-border-radius": buttonBorderRadius,
            "--n-button-box-shadow": buttonBoxShadow,
            "--n-button-color": buttonColor,
            "--n-button-width": buttonWidth,
            "--n-button-width-pressed": buttonWidthPressed,
            "--n-button-height": buttonHeight,
            "--n-height": height,
            "--n-offset": offset,
            "--n-opacity-disabled": opacityDisabled,
            "--n-rail-border-radius": railBorderRadius,
            "--n-rail-color": railColor,
            "--n-rail-color-active": railColorActive,
            "--n-rail-height": railHeight,
            "--n-rail-width": railWidth,
            "--n-width": width,
            "--n-box-shadow-focus": boxShadowFocus,
            "--n-loading-color": loadingColor,
            "--n-text-color": textColor,
            "--n-icon-color": iconColor
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass(
          "switch",
          vue.computed(() => {
            return mergedSizeRef.value[0];
          }),
          cssVarsRef,
          props
        ) : void 0;
        return {
          handleClick,
          handleBlur,
          handleFocus,
          handleKeyup,
          handleKeydown,
          mergedRailStyle: mergedRailStyleRef,
          pressed: pressedRef,
          mergedClsPrefix: mergedClsPrefixRef,
          mergedValue: mergedValueRef,
          checked: checkedRef,
          mergedDisabled: mergedDisabledRef,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender
        };
      },
      render() {
        const {
          mergedClsPrefix,
          mergedDisabled,
          checked,
          mergedRailStyle,
          onRender,
          $slots
        } = this;
        onRender?.();
        const {
          checked: checkedSlot,
          unchecked: uncheckedSlot,
          icon: iconSlot,
          "checked-icon": checkedIconSlot,
          "unchecked-icon": uncheckedIconSlot
        } = $slots;
        const hasIcon = !(isSlotEmpty(iconSlot) && isSlotEmpty(checkedIconSlot) && isSlotEmpty(uncheckedIconSlot));
        return /* @__PURE__ */ vue.h("div", {
          role: "switch",
          "aria-checked": checked,
          class: [
            `${mergedClsPrefix}-switch`,
            this.themeClass,
            hasIcon && `${mergedClsPrefix}-switch--icon`,
            checked && `${mergedClsPrefix}-switch--active`,
            mergedDisabled && `${mergedClsPrefix}-switch--disabled`,
            this.round && `${mergedClsPrefix}-switch--round`,
            this.loading && `${mergedClsPrefix}-switch--loading`,
            this.pressed && `${mergedClsPrefix}-switch--pressed`,
            this.rubberBand && `${mergedClsPrefix}-switch--rubber-band`
          ],
          tabindex: !this.mergedDisabled ? 0 : void 0,
          style: this.cssVars,
          onClick: this.handleClick,
          onFocus: this.handleFocus,
          onBlur: this.handleBlur,
          onKeyup: this.handleKeyup,
          onKeydown: this.handleKeydown
        }, /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-switch__rail`,
          "aria-hidden": "true",
          style: mergedRailStyle
        }, resolveWrappedSlot(
          checkedSlot,
          (checkedSlotChildren) => resolveWrappedSlot(uncheckedSlot, (uncheckedSlotChildren) => {
            if (checkedSlotChildren || uncheckedSlotChildren) {
              return /* @__PURE__ */ vue.h("div", {
                "aria-hidden": true,
                class: `${mergedClsPrefix}-switch__children-placeholder`
              }, /* @__PURE__ */ vue.h("div", {
                class: `${mergedClsPrefix}-switch__rail-placeholder`
              }, /* @__PURE__ */ vue.h("div", {
                class: `${mergedClsPrefix}-switch__button-placeholder`
              }), checkedSlotChildren), /* @__PURE__ */ vue.h("div", {
                class: `${mergedClsPrefix}-switch__rail-placeholder`
              }, /* @__PURE__ */ vue.h("div", {
                class: `${mergedClsPrefix}-switch__button-placeholder`
              }), uncheckedSlotChildren));
            }
            return null;
          })
        ), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-switch__button`
        }, resolveWrappedSlot(
          iconSlot,
          (icon) => resolveWrappedSlot(
            checkedIconSlot,
            (checkedIcon) => resolveWrappedSlot(uncheckedIconSlot, (uncheckedIcon) => {
              return /* @__PURE__ */ vue.h(NIconSwitchTransition, null, {
                default: () => this.loading ? /* @__PURE__ */ vue.h(NBaseLoading, {
                  key: "loading",
                  clsPrefix: mergedClsPrefix,
                  strokeWidth: 20
                }) : this.checked && (checkedIcon || icon) ? /* @__PURE__ */ vue.h("div", {
                  class: `${mergedClsPrefix}-switch__button-icon`,
                  key: checkedIcon ? "checked-icon" : "icon"
                }, checkedIcon || icon) : !this.checked && (uncheckedIcon || icon) ? /* @__PURE__ */ vue.h("div", {
                  class: `${mergedClsPrefix}-switch__button-icon`,
                  key: uncheckedIcon ? "unchecked-icon" : "icon"
                }, uncheckedIcon || icon) : null
              });
            })
          )
        ), resolveWrappedSlot(
          checkedSlot,
          (children) => children && /* @__PURE__ */ vue.h("div", {
            key: "checked",
            class: `${mergedClsPrefix}-switch__checked`
          }, children)
        ), resolveWrappedSlot(
          uncheckedSlot,
          (children) => children && /* @__PURE__ */ vue.h("div", {
            key: "unchecked",
            class: `${mergedClsPrefix}-switch__unchecked`
          }, children)
        ))));
      }
    });

    var style$f = c$1([cB("table", `
    font-size: var(--n-font-size);
    font-variant-numeric: tabular-nums;
    line-height: var(--n-line-height);
    width: 100%;
    border-radius: var(--n-border-radius) var(--n-border-radius) 0 0;
    text-align: left;
    border-collapse: separate;
    border-spacing: 0;
    overflow: hidden;
    background-color: var(--n-td-color);
    border-color: var(--n-merged-border-color);
    transition:
      background-color .3s var(--n-bezier),
      border-color .3s var(--n-bezier),
      color .3s var(--n-bezier);
    --n-merged-border-color: var(--n-border-color);
  `, [c$1("th", `
      white-space: nowrap;
      transition:
        background-color .3s var(--n-bezier),
        border-color .3s var(--n-bezier),
        color .3s var(--n-bezier);
      text-align: inherit;
      padding: var(--n-th-padding);
      vertical-align: inherit;
      text-transform: none;
      border: 0px solid var(--n-merged-border-color);
      font-weight: var(--n-th-font-weight);
      color: var(--n-th-text-color);
      background-color: var(--n-th-color);
      border-bottom: 1px solid var(--n-merged-border-color);
      border-right: 1px solid var(--n-merged-border-color);
    `, [c$1("&:last-child", `
        border-right: 0px solid var(--n-merged-border-color);
      `)]), c$1("td", `
      transition:
        background-color .3s var(--n-bezier),
        border-color .3s var(--n-bezier),
        color .3s var(--n-bezier);
      padding: var(--n-td-padding);
      color: var(--n-td-text-color);
      background-color: var(--n-td-color);
      border: 0px solid var(--n-merged-border-color);
      border-right: 1px solid var(--n-merged-border-color);
      border-bottom: 1px solid var(--n-merged-border-color);
    `, [c$1("&:last-child", `
        border-right: 0px solid var(--n-merged-border-color);
      `)]), cM("bordered", `
      border: 1px solid var(--n-merged-border-color);
      border-radius: var(--n-border-radius);
    `, [c$1("tr", [c$1("&:last-child", [c$1("td", `
            border-bottom: 0 solid var(--n-merged-border-color);
          `)])])]), cM("single-line", [c$1("th", `
        border-right: 0px solid var(--n-merged-border-color);
      `), c$1("td", `
        border-right: 0px solid var(--n-merged-border-color);
      `)]), cM("single-column", [c$1("tr", [c$1("&:not(:last-child)", [c$1("td", `
            border-bottom: 0px solid var(--n-merged-border-color);
          `)])])]), cM("striped", [c$1("tr:nth-of-type(even)", [c$1("td", "background-color: var(--n-td-color-striped)")])]), cNotM("bottom-bordered", [c$1("tr", [c$1("&:last-child", [c$1("td", `
            border-bottom: 0px solid var(--n-merged-border-color);
          `)])])])]), insideModal(cB("table", `
      background-color: var(--n-td-color-modal);
      --n-merged-border-color: var(--n-border-color-modal);
    `, [c$1("th", `
        background-color: var(--n-th-color-modal);
      `), c$1("td", `
        background-color: var(--n-td-color-modal);
      `)])), insidePopover(cB("table", `
      background-color: var(--n-td-color-popover);
      --n-merged-border-color: var(--n-border-color-popover);
    `, [c$1("th", `
        background-color: var(--n-th-color-popover);
      `), c$1("td", `
        background-color: var(--n-td-color-popover);
      `)]))]);

    const tableProps = {
      ...useTheme.props,
      bordered: {
        type: Boolean,
        default: true
      },
      bottomBordered: {
        type: Boolean,
        default: true
      },
      singleLine: {
        type: Boolean,
        default: true
      },
      striped: Boolean,
      singleColumn: Boolean,
      size: {
        type: String,
        default: "medium"
      }
    };
    var Table = vue.defineComponent({
      name: "Table",
      props: tableProps,
      setup(props) {
        const { mergedClsPrefixRef, inlineThemeDisabled, mergedRtlRef } = useConfig(props);
        const themeRef = useTheme(
          "Table",
          "-table",
          style$f,
          tableLight$1,
          props,
          mergedClsPrefixRef
        );
        const rtlEnabledRef = useRtl("Table", mergedRtlRef, mergedClsPrefixRef);
        const cssVarsRef = vue.computed(() => {
          const { size } = props;
          const {
            self: {
              borderColor,
              tdColor,
              tdColorModal,
              tdColorPopover,
              thColor,
              thColorModal,
              thColorPopover,
              thTextColor,
              tdTextColor,
              borderRadius,
              thFontWeight,
              lineHeight,
              borderColorModal,
              borderColorPopover,
              tdColorStriped,
              tdColorStripedModal,
              tdColorStripedPopover,
              [createKey("fontSize", size)]: fontSize,
              [createKey("tdPadding", size)]: tdPadding,
              [createKey("thPadding", size)]: thPadding
            },
            common: { cubicBezierEaseInOut }
          } = themeRef.value;
          return {
            "--n-bezier": cubicBezierEaseInOut,
            "--n-td-color": tdColor,
            "--n-td-color-modal": tdColorModal,
            "--n-td-color-popover": tdColorPopover,
            "--n-td-text-color": tdTextColor,
            "--n-border-color": borderColor,
            "--n-border-color-modal": borderColorModal,
            "--n-border-color-popover": borderColorPopover,
            "--n-border-radius": borderRadius,
            "--n-font-size": fontSize,
            "--n-th-color": thColor,
            "--n-th-color-modal": thColorModal,
            "--n-th-color-popover": thColorPopover,
            "--n-th-font-weight": thFontWeight,
            "--n-th-text-color": thTextColor,
            "--n-line-height": lineHeight,
            "--n-td-padding": tdPadding,
            "--n-th-padding": thPadding,
            "--n-td-color-striped": tdColorStriped,
            "--n-td-color-striped-modal": tdColorStripedModal,
            "--n-td-color-striped-popover": tdColorStripedPopover
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass(
          "table",
          vue.computed(() => {
            return props.size[0];
          }),
          cssVarsRef,
          props
        ) : void 0;
        return {
          rtlEnabled: rtlEnabledRef,
          mergedClsPrefix: mergedClsPrefixRef,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender
        };
      },
      render() {
        const { mergedClsPrefix } = this;
        this.onRender?.();
        return /* @__PURE__ */ vue.h("table", {
          class: [
            `${mergedClsPrefix}-table`,
            this.themeClass,
            {
              [`${mergedClsPrefix}-table--rtl`]: this.rtlEnabled,
              [`${mergedClsPrefix}-table--bottom-bordered`]: this.bottomBordered,
              [`${mergedClsPrefix}-table--bordered`]: this.bordered,
              [`${mergedClsPrefix}-table--single-line`]: this.singleLine,
              [`${mergedClsPrefix}-table--single-column`]: this.singleColumn,
              [`${mergedClsPrefix}-table--striped`]: this.striped
            }
          ],
          style: this.cssVars
        }, this.$slots);
      }
    });

    var Th = vue.defineComponent({
      name: "Th",
      render() {
        return /* @__PURE__ */ vue.h("th", null, this.$slots);
      }
    });

    var Tr = vue.defineComponent({
      name: "Tr",
      render() {
        return /* @__PURE__ */ vue.h("tr", null, this.$slots);
      }
    });

    var Td = vue.defineComponent({
      name: "Td",
      render() {
        return /* @__PURE__ */ vue.h("td", null, this.$slots);
      }
    });

    var Thead = vue.defineComponent({
      name: "Thead",
      render() {
        return /* @__PURE__ */ vue.h("thead", null, this.$slots);
      }
    });

    var Tbody = vue.defineComponent({
      name: "Tbody",
      render() {
        return /* @__PURE__ */ vue.h("tbody", null, this.$slots);
      }
    });

    const tabsInjectionKey = createInjectionKey("n-tabs");

    const tabPaneProps = {
      tab: [String, Number, Object, Function],
      name: {
        type: [String, Number],
        required: true
      },
      disabled: Boolean,
      displayDirective: {
        type: String,
        default: "if"
      },
      closable: {
        type: Boolean,
        default: void 0
      },
      tabProps: Object,
      label: [String, Number, Object, Function]
    };
    var TabPane = vue.defineComponent({
      __TAB_PANE__: true,
      name: "TabPane",
      alias: ["TabPanel"],
      props: tabPaneProps,
      setup(props) {
        {
          vue.watchEffect(() => {
            if (props.label !== void 0) {
              warnOnce(
                "tab-pane",
                "`label` is deprecated, please use `tab` instead."
              );
            }
          });
        }
        const NTab = vue.inject(tabsInjectionKey, null);
        if (!NTab) {
          throwError("tab-pane", "`n-tab-pane` must be placed inside `n-tabs`.");
        }
        return {
          style: NTab.paneStyleRef,
          class: NTab.paneClassRef,
          mergedClsPrefix: NTab.mergedClsPrefixRef
        };
      },
      render() {
        return /* @__PURE__ */ vue.h("div", {
          class: [`${this.mergedClsPrefix}-tab-pane`, this.class],
          style: this.style
        }, this.$slots);
      }
    });

    const tabProps = {
      internalLeftPadded: Boolean,
      internalAddable: Boolean,
      internalCreatedByPane: Boolean,
      ...omit(tabPaneProps, ["displayDirective"])
    };
    var Tab = vue.defineComponent({
      __TAB__: true,
      inheritAttrs: false,
      name: "Tab",
      props: tabProps,
      setup(props) {
        const {
          mergedClsPrefixRef,
          valueRef,
          typeRef,
          closableRef,
          tabStyleRef,
          tabChangeIdRef,
          onBeforeLeaveRef,
          triggerRef,
          handleAdd,
          activateTab,
          handleClose
        } = vue.inject(tabsInjectionKey);
        return {
          trigger: triggerRef,
          mergedClosable: vue.computed(() => {
            if (props.internalAddable)
              return false;
            const { closable } = props;
            if (closable === void 0)
              return closableRef.value;
            return closable;
          }),
          style: tabStyleRef,
          clsPrefix: mergedClsPrefixRef,
          value: valueRef,
          type: typeRef,
          handleClose(e) {
            e.stopPropagation();
            if (props.disabled)
              return;
            handleClose(props.name);
          },
          activateTab() {
            if (props.disabled)
              return;
            if (props.internalAddable) {
              handleAdd();
              return;
            }
            const { name: nameProp } = props;
            const id = ++tabChangeIdRef.id;
            if (nameProp !== valueRef.value) {
              const { value: onBeforeLeave } = onBeforeLeaveRef;
              if (!onBeforeLeave) {
                activateTab(nameProp);
              } else {
                void Promise.resolve(
                  onBeforeLeave(props.name, valueRef.value)
                ).then((allowLeave) => {
                  if (allowLeave && tabChangeIdRef.id === id) {
                    activateTab(nameProp);
                  }
                });
              }
            }
          }
        };
      },
      render() {
        const {
          internalAddable,
          clsPrefix,
          name,
          disabled,
          label,
          tab,
          value,
          mergedClosable,
          style,
          trigger,
          $slots: { default: defaultSlot }
        } = this;
        const mergedTab = label ?? tab;
        return /* @__PURE__ */ vue.h("div", {
          class: `${clsPrefix}-tabs-tab-wrapper`
        }, this.internalLeftPadded ? /* @__PURE__ */ vue.h("div", {
          class: `${clsPrefix}-tabs-tab-pad`
        }) : null, /* @__PURE__ */ vue.h("div", {
          key: name,
          "data-name": name,
          "data-disabled": disabled ? true : void 0,
          ...vue.mergeProps(
            {
              class: [
                `${clsPrefix}-tabs-tab`,
                value === name && `${clsPrefix}-tabs-tab--active`,
                disabled && `${clsPrefix}-tabs-tab--disabled`,
                mergedClosable && `${clsPrefix}-tabs-tab--closable`,
                internalAddable && `${clsPrefix}-tabs-tab--addable`
              ],
              onClick: trigger === "click" ? this.activateTab : void 0,
              onMouseenter: trigger === "hover" ? this.activateTab : void 0,
              style: internalAddable ? void 0 : style
            },
            this.internalCreatedByPane ? this.tabProps || {} : this.$attrs
          )
        }, /* @__PURE__ */ vue.h("span", {
          class: `${clsPrefix}-tabs-tab__label`
        }, internalAddable ? /* @__PURE__ */ vue.h(vue.Fragment, null, /* @__PURE__ */ vue.h("div", {
          class: `${clsPrefix}-tabs-tab__height-placeholder`
        }, "\xA0"), /* @__PURE__ */ vue.h(NBaseIcon, {
          clsPrefix
        }, {
          default: () => /* @__PURE__ */ vue.h(AddIcon, null)
        })) : defaultSlot ? defaultSlot() : typeof mergedTab === "object" ? mergedTab : render$1(mergedTab ?? name)), mergedClosable && this.type === "card" ? /* @__PURE__ */ vue.h(NBaseClose, {
          clsPrefix,
          class: `${clsPrefix}-tabs-tab__close`,
          onClick: this.handleClose,
          disabled
        }) : null));
      }
    });

    var style$e = cB("tabs", `
  box-sizing: border-box;
  width: 100%;
  transition:
    background-color .3s var(--n-bezier),
    border-color .3s var(--n-bezier);
`, [cM("segment-type", [cB("tabs-rail", [c$1("&.transition-disabled", "color: red;", [cB("tabs-tab", `
          transition: none;
        `)])])]), cB("tabs-rail", `
    padding: 3px;
    border-radius: var(--n-tab-border-radius);
    width: 100%;
    background-color: var(--n-color-segment);
    transition: background-color .3s var(--n-bezier);
    display: flex;
    align-items: center;
  `, [cB("tabs-tab-wrapper", `
      flex-basis: 0;
      flex-grow: 1;
      display: flex;
      align-items: center;
      justify-content: center;
    `, [cB("tabs-tab", `
        overflow: hidden;
        border-radius: var(--n-tab-border-radius);
        width: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
      `, [cM("active", `
          font-weight: var(--n-font-weight-strong);
          color: var(--n-tab-text-color-active);
          background-color: var(--n-tab-color-segment);
          box-shadow: 0 1px 3px 0 rgba(0, 0, 0, .08);
        `), c$1("&:hover", `
          color: var(--n-tab-text-color-hover);
        `)])])]), cM("flex", [cB("tabs-nav", {
      width: "100%"
    }, [cB("tabs-wrapper", {
      width: "100%"
    }, [cB("tabs-tab", {
      marginRight: 0
    })])])]), cB("tabs-nav", `
    box-sizing: border-box;
    line-height: 1.5;
    display: flex;
    transition: border-color .3s var(--n-bezier);
  `, [cE("prefix, suffix", `
      display: flex;
      align-items: center;
    `), cE("prefix", "padding-right: 16px;"), cE("suffix", "padding-left: 16px;")]), cB("tabs-nav-scroll-wrapper", `
    flex: 1;
    position: relative;
    overflow: hidden;
  `, [cM("shadow-before", [c$1("&::before", `
        box-shadow: inset 10px 0 8px -8px rgba(0, 0, 0, .12);
      `)]), cM("shadow-after", [c$1("&::after", `
        box-shadow: inset -10px 0 8px -8px rgba(0, 0, 0, .12);
      `)]), c$1("&::before, &::after", `
      transition: box-shadow .3s var(--n-bezier);
      pointer-events: none;
      content: "";
      position: absolute;
      top: 0;
      bottom: 0;
      width: 20px;
      z-index: 1;
    `), c$1("&::before", `
      left: 0;
    `), c$1("&::after", `
      right: 0;
    `)]), cB("tabs-nav-scroll-content", `
    display: flex;
    position: relative;
    min-width: 100%;
    width: fit-content;
  `), cB("tabs-wrapper", `
    display: inline-flex;
    flex-wrap: nowrap;
    position: relative;
  `), cB("tabs-tab-wrapper", `
    display: flex;
    flex-wrap: nowrap;
    flex-shrink: 0;
    flex-grow: 0;
  `), cB("tabs-tab", `
    cursor: pointer;
    white-space: nowrap;
    flex-wrap: nowrap;
    display: inline-flex;
    align-items: center;
    color: var(--n-tab-text-color);
    font-size: var(--n-tab-font-size);
    background-clip: padding-box;
    padding: var(--n-tab-padding);
    transition:
      box-shadow .3s var(--n-bezier),
      color .3s var(--n-bezier),
      background-color .3s var(--n-bezier),
      border-color .3s var(--n-bezier);
  `, [cM("disabled", {
      cursor: "not-allowed"
    }), cE("close", `
      margin-left: 6px;
      transition:
        background-color .3s var(--n-bezier),
        color .3s var(--n-bezier);
    `), cE("label", `
      display: flex;
      align-items: center;
    `)]), cB("tabs-bar", `
    position: absolute;
    bottom: 0;
    height: 2px;
    border-radius: 1px;
    background-color: var(--n-bar-color);
    transition:
      left .2s var(--n-bezier),
      max-width .2s var(--n-bezier),
      background-color .3s var(--n-bezier);
  `, [c$1("&.transition-disabled", `
      transition: none;
    `), cM("disabled", `
      background-color: var(--n-tab-text-color-disabled)
    `)]), cB("tabs-pane-wrapper", `
    position: relative;
    overflow: hidden;
    transition: max-height .2s var(--n-bezier);
  `), cB("tab-pane", `
    color: var(--n-pane-text-color);
    width: 100%;
    padding: var(--n-pane-padding);
    transition:
      color .3s var(--n-bezier),
      background-color .3s var(--n-bezier),
      opacity .2s var(--n-bezier);
    left: 0;
    right: 0;
    top: 0;
  `, [c$1("&.next-transition-leave-active, &.prev-transition-leave-active, &.next-transition-enter-active, &.prev-transition-enter-active", `
      transition:
      color .3s var(--n-bezier),
      background-color .3s var(--n-bezier),
      transform .2s var(--n-bezier),
      opacity .2s var(--n-bezier);
    `), c$1("&.next-transition-leave-active, &.prev-transition-leave-active", `
      position: absolute;
    `), c$1("&.next-transition-enter-from, &.prev-transition-leave-to", `
      transform: translateX(32px);
      opacity: 0;
    `), c$1("&.next-transition-leave-to, &.prev-transition-enter-from", `
      transform: translateX(-32px);
      opacity: 0;
    `), c$1("&.next-transition-leave-from, &.next-transition-enter-to, &.prev-transition-leave-from, &.prev-transition-enter-to", `
      transform: translateX(0);
      opacity: 1;
    `)]), cB("tabs-tab-pad", `
    width: var(--n-tab-gap);
    flex-grow: 0;
    flex-shrink: 0;
  `), cM("line-type, bar-type", [cB("tabs-tab", `
      font-weight: var(--n-tab-font-weight);
      box-sizing: border-box;
      vertical-align: bottom;
    `, [c$1("&:hover", {
      color: "var(--n-tab-text-color-hover)"
    }), cM("active", `
        color: var(--n-tab-text-color-active);
        font-weight: var(--n-tab-font-weight-active);
      `), cM("disabled", {
      color: "var(--n-tab-text-color-disabled)"
    })])]), cB("tabs-nav", [cM("line-type", [cE("prefix, suffix", `
        transition: border-color .3s var(--n-bezier);
        border-bottom: 1px solid var(--n-tab-border-color);
      `), cB("tabs-nav-scroll-content", `
        transition: border-color .3s var(--n-bezier);
        border-bottom: 1px solid var(--n-tab-border-color);
      `), cB("tabs-bar", `
        border-radius: 0;
        bottom: -1px;
      `)]), cM("card-type", [cE("prefix, suffix", `
        transition: border-color .3s var(--n-bezier);
        border-bottom: 1px solid var(--n-tab-border-color);
      `), cB("tabs-pad", `
        flex-grow: 1;
        transition: border-color .3s var(--n-bezier);
        border-bottom: 1px solid var(--n-tab-border-color);
      `), cB("tabs-tab-pad", `
        transition: border-color .3s var(--n-bezier);
        border-bottom: 1px solid var(--n-tab-border-color);
      `), cB("tabs-tab", `
        font-weight: var(--n-tab-font-weight);
        border: 1px solid var(--n-tab-border-color);
        border-top-left-radius: var(--n-tab-border-radius);
        border-top-right-radius: var(--n-tab-border-radius);
        background-color: var(--n-tab-color);
        box-sizing: border-box;
        position: relative;
        vertical-align: bottom;
        display: flex;
        justify-content: space-between;
        font-size: var(--n-tab-font-size);
        color: var(--n-tab-text-color);
      `, [cM("addable", `
          padding-left: 8px;
          padding-right: 8px;
          font-size: 16px;
        `, [cE("height-placeholder", `
            width: 0;
            font-size: var(--n-tab-font-size);
          `), cNotM("disabled", [c$1("&:hover", `
              color: var(--n-tab-text-color-hover);
            `)])]), cM("closable", "padding-right: 6px;"), cM("active", `
          border-bottom: 1px solid #0000;
          background-color: #0000;
          font-weight: var(--n-tab-font-weight-active);
          color: var(--n-tab-text-color-active);
        `), cM("disabled", "color: var(--n-tab-text-color-disabled);")]), cB("tabs-scroll-padding", "border-bottom: 1px solid var(--n-tab-border-color);")])])]);

    const tabsProps = {
      ...useTheme.props,
      value: [String, Number],
      defaultValue: [String, Number],
      trigger: {
        type: String,
        default: "click"
      },
      type: {
        type: String,
        default: "bar"
      },
      closable: Boolean,
      justifyContent: String,
      size: {
        type: String,
        default: "medium"
      },
      tabStyle: [String, Object],
      barWidth: Number,
      paneClass: String,
      paneStyle: [String, Object],
      addable: [Boolean, Object],
      tabsPadding: {
        type: Number,
        default: 0
      },
      animated: Boolean,
      onBeforeLeave: Function,
      onAdd: Function,
      "onUpdate:value": [Function, Array],
      onUpdateValue: [Function, Array],
      onClose: [Function, Array],
      labelSize: String,
      activeName: [String, Number],
      onActiveNameChange: [Function, Array]
    };
    var Tabs = vue.defineComponent({
      name: "Tabs",
      props: tabsProps,
      setup(props, { slots }) {
        {
          vue.watchEffect(() => {
            if (props.labelSize !== void 0) {
              warnOnce(
                "tabs",
                "`label-size` is deprecated, please use `size` instead."
              );
            }
            if (props.activeName !== void 0) {
              warnOnce(
                "tabs",
                "`active-name` is deprecated, please use `value` instead."
              );
            }
            if (props.onActiveNameChange !== void 0) {
              warnOnce(
                "tabs",
                "`on-active-name-change` is deprecated, please use `on-update:value` instead."
              );
            }
          });
        }
        const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
        const themeRef = useTheme(
          "Tabs",
          "-tabs",
          style$e,
          tabsLight$1,
          props,
          mergedClsPrefixRef
        );
        const tabsElRef = vue.ref(null);
        const barElRef = vue.ref(null);
        const scrollWrapperElRef = vue.ref(null);
        const addTabInstRef = vue.ref(null);
        const xScrollInstRef = vue.ref(
          null
        );
        const leftReachedRef = vue.ref(true);
        const rightReachedRef = vue.ref(true);
        const compitableSizeRef = useCompitable(props, ["labelSize", "size"]);
        const compitableValueRef = useCompitable(props, ["activeName", "value"]);
        const uncontrolledValueRef = vue.ref(
          compitableValueRef.value ?? props.defaultValue ?? (slots.default ? flatten$3(slots.default())[0]?.props?.name : null)
        );
        const mergedValueRef = useMergedState(
          compitableValueRef,
          uncontrolledValueRef
        );
        const tabChangeIdRef = { id: 0 };
        const tabWrapperStyleRef = vue.computed(() => {
          if (!props.justifyContent || props.type === "card")
            return void 0;
          return {
            display: "flex",
            justifyContent: props.justifyContent
          };
        });
        vue.watch(mergedValueRef, () => {
          tabChangeIdRef.id = 0;
          updateCurrentBarStyle();
        });
        function getCurrentEl() {
          const { value } = mergedValueRef;
          if (value === null)
            return null;
          const tabEl = tabsElRef.value?.querySelector(`[data-name="${value}"]`);
          return tabEl;
        }
        function updateBarStyle(tabEl) {
          if (props.type === "card")
            return;
          const { value: barEl } = barElRef;
          if (!barEl)
            return;
          if (tabEl) {
            const disabledClassName = `${mergedClsPrefixRef.value}-tabs-bar--disabled`;
            const { barWidth } = props;
            if (tabEl.dataset.disabled === "true") {
              barEl.classList.add(disabledClassName);
            } else {
              barEl.classList.remove(disabledClassName);
            }
            if (typeof barWidth === "number" && tabEl.offsetWidth >= barWidth) {
              const offsetDiffLeft = Math.floor((tabEl.offsetWidth - barWidth) / 2) + tabEl.offsetLeft;
              barEl.style.left = `${offsetDiffLeft}px`;
              barEl.style.maxWidth = `${barWidth}px`;
            } else {
              barEl.style.left = `${tabEl.offsetLeft}px`;
              barEl.style.maxWidth = `${tabEl.offsetWidth}px`;
            }
            barEl.style.width = "8192px";
            void barEl.offsetWidth;
          }
        }
        function updateCurrentBarStyle() {
          if (props.type === "card")
            return;
          const tabEl = getCurrentEl();
          if (tabEl) {
            updateBarStyle(tabEl);
          }
        }
        const tabsPaneWrapperRef = vue.ref(null);
        let fromHeight = 0;
        let hangingTransition = null;
        function onAnimationBeforeLeave(el) {
          const tabsPaneWrapperEl = tabsPaneWrapperRef.value;
          if (tabsPaneWrapperEl) {
            fromHeight = el.getBoundingClientRect().height;
            const fromHeightPx = `${fromHeight}px`;
            const applyFromStyle = () => {
              tabsPaneWrapperEl.style.height = fromHeightPx;
              tabsPaneWrapperEl.style.maxHeight = fromHeightPx;
            };
            if (!hangingTransition) {
              hangingTransition = applyFromStyle;
            } else {
              applyFromStyle();
              hangingTransition();
              hangingTransition = null;
            }
          }
        }
        function onAnimationEnter(el) {
          const tabsPaneWrapperEl = tabsPaneWrapperRef.value;
          if (tabsPaneWrapperEl) {
            const targetHeight = el.getBoundingClientRect().height;
            const applyTargetStyle = () => {
              void document.body.offsetHeight;
              tabsPaneWrapperEl.style.maxHeight = `${targetHeight}px`;
              tabsPaneWrapperEl.style.height = `${Math.max(
            fromHeight,
            targetHeight
          )}px`;
            };
            if (!hangingTransition) {
              hangingTransition = applyTargetStyle;
            } else {
              hangingTransition();
              hangingTransition = null;
              applyTargetStyle();
            }
          }
        }
        function onAnimationAfterEnter() {
          const tabsPaneWrapperEl = tabsPaneWrapperRef.value;
          if (tabsPaneWrapperEl) {
            tabsPaneWrapperEl.style.maxHeight = "";
            tabsPaneWrapperEl.style.height = "";
          }
        }
        const renderNameListRef = { value: [] };
        const animationDirectionRef = vue.ref("next");
        function activateTab(panelName) {
          const currentValue = mergedValueRef.value;
          let dir = "next";
          for (const name of renderNameListRef.value) {
            if (name === currentValue) {
              break;
            }
            if (name === panelName) {
              dir = "prev";
              break;
            }
          }
          animationDirectionRef.value = dir;
          doUpdateValue(panelName);
        }
        function doUpdateValue(panelName) {
          const {
            onActiveNameChange,
            onUpdateValue,
            "onUpdate:value": _onUpdateValue
          } = props;
          if (onActiveNameChange) {
            call(onActiveNameChange, panelName);
          }
          if (onUpdateValue)
            call(onUpdateValue, panelName);
          if (_onUpdateValue)
            call(_onUpdateValue, panelName);
          uncontrolledValueRef.value = panelName;
        }
        function handleClose(panelName) {
          const { onClose } = props;
          if (onClose)
            call(onClose, panelName);
        }
        function updateBarPositionInstantly() {
          const { value: barEl } = barElRef;
          if (!barEl)
            return;
          const disableTransitionClassName = "transition-disabled";
          barEl.classList.add(disableTransitionClassName);
          updateCurrentBarStyle();
          barEl.classList.remove(disableTransitionClassName);
        }
        let memorizedWidth = 0;
        function _handleNavResize(entry) {
          if (entry.contentRect.width === 0 && entry.contentRect.height === 0) {
            return;
          }
          if (memorizedWidth === entry.contentRect.width) {
            return;
          }
          memorizedWidth = entry.contentRect.width;
          const { type } = props;
          if (type === "line" || type === "bar") {
            {
              updateBarPositionInstantly();
            }
          }
          if (type !== "segment") {
            deriveScrollShadow(xScrollInstRef.value?.$el);
          }
        }
        const handleNavResize = lodash.exports.throttle(_handleNavResize, 64);
        vue.watch([() => props.justifyContent, () => props.size], () => {
          void vue.nextTick(() => {
            const { type } = props;
            if (type === "line" || type === "bar") {
              updateBarPositionInstantly();
            }
          });
        });
        const addTabFixedRef = vue.ref(false);
        function _handleTabsResize(entry) {
          const {
            target,
            contentRect: { width }
          } = entry;
          const containerWidth = target.parentElement.offsetWidth;
          if (!addTabFixedRef.value) {
            if (containerWidth < width) {
              addTabFixedRef.value = true;
            }
          } else {
            const { value: addTabInst } = addTabInstRef;
            if (!addTabInst)
              return;
            if (containerWidth - width > addTabInst.$el.offsetWidth) {
              addTabFixedRef.value = false;
            }
          }
          deriveScrollShadow(xScrollInstRef.value?.$el);
        }
        const handleTabsResize = lodash.exports.throttle(_handleTabsResize, 64);
        function handleAdd() {
          const { onAdd } = props;
          if (onAdd)
            onAdd();
          void vue.nextTick(() => {
            const currentEl = getCurrentEl();
            const { value: xScrollInst } = xScrollInstRef;
            if (!currentEl || !xScrollInst)
              return;
            xScrollInst.scrollTo({
              left: currentEl.offsetLeft,
              top: 0,
              behavior: "smooth"
            });
          });
        }
        function deriveScrollShadow(el) {
          if (!el)
            return;
          const { scrollLeft, scrollWidth, offsetWidth } = el;
          leftReachedRef.value = scrollLeft <= 0;
          rightReachedRef.value = scrollLeft + offsetWidth >= scrollWidth;
        }
        const handleScroll = lodash.exports.throttle((e) => {
          deriveScrollShadow(e.target);
        }, 64);
        vue.provide(tabsInjectionKey, {
          triggerRef: vue.toRef(props, "trigger"),
          tabStyleRef: vue.toRef(props, "tabStyle"),
          paneClassRef: vue.toRef(props, "paneClass"),
          paneStyleRef: vue.toRef(props, "paneStyle"),
          mergedClsPrefixRef,
          typeRef: vue.toRef(props, "type"),
          closableRef: vue.toRef(props, "closable"),
          valueRef: mergedValueRef,
          tabChangeIdRef,
          onBeforeLeaveRef: vue.toRef(props, "onBeforeLeave"),
          activateTab,
          handleClose,
          handleAdd
        });
        onFontsReady(() => {
          updateCurrentBarStyle();
        });
        vue.watchEffect(() => {
          const { value: el } = scrollWrapperElRef;
          if (!el)
            return;
          const { value: clsPrefix } = mergedClsPrefixRef;
          const shadowBeforeClass = `${clsPrefix}-tabs-nav-scroll-wrapper--shadow-before`;
          const shadowAfterClass = `${clsPrefix}-tabs-nav-scroll-wrapper--shadow-after`;
          if (leftReachedRef.value) {
            el.classList.remove(shadowBeforeClass);
          } else {
            el.classList.add(shadowBeforeClass);
          }
          if (rightReachedRef.value) {
            el.classList.remove(shadowAfterClass);
          } else {
            el.classList.add(shadowAfterClass);
          }
        });
        const tabsRailElRef = vue.ref(null);
        vue.watch(mergedValueRef, () => {
          if (props.type === "segment") {
            const tabsRailEl = tabsRailElRef.value;
            if (tabsRailEl) {
              void vue.nextTick(() => {
                tabsRailEl.classList.add("transition-disabled");
                void tabsRailEl.offsetWidth;
                tabsRailEl.classList.remove("transition-disabled");
              });
            }
          }
        });
        const exposedMethods = {
          syncBarPosition: () => {
            updateCurrentBarStyle();
          }
        };
        const cssVarsRef = vue.computed(() => {
          const { value: size } = compitableSizeRef;
          const { type } = props;
          const typeSuffix = {
            card: "Card",
            bar: "Bar",
            line: "Line",
            segment: "Segment"
          }[type];
          const sizeType = `${size}${typeSuffix}`;
          const {
            self: {
              barColor,
              closeIconColor,
              closeIconColorHover,
              closeIconColorPressed,
              tabColor,
              tabBorderColor,
              paneTextColor,
              tabFontWeight,
              tabBorderRadius,
              tabFontWeightActive,
              colorSegment,
              fontWeightStrong,
              tabColorSegment,
              closeSize,
              closeIconSize,
              closeColorHover,
              closeColorPressed,
              closeBorderRadius,
              [createKey("panePadding", size)]: panePadding,
              [createKey("tabPadding", sizeType)]: tabPadding,
              [createKey("tabGap", sizeType)]: tabGap,
              [createKey("tabTextColor", type)]: tabTextColor,
              [createKey("tabTextColorActive", type)]: tabTextColorActive,
              [createKey("tabTextColorHover", type)]: tabTextColorHover,
              [createKey("tabTextColorDisabled", type)]: tabTextColorDisabled,
              [createKey("tabFontSize", size)]: tabFontSize
            },
            common: { cubicBezierEaseInOut }
          } = themeRef.value;
          return {
            "--n-bezier": cubicBezierEaseInOut,
            "--n-color-segment": colorSegment,
            "--n-bar-color": barColor,
            "--n-tab-font-size": tabFontSize,
            "--n-tab-text-color": tabTextColor,
            "--n-tab-text-color-active": tabTextColorActive,
            "--n-tab-text-color-disabled": tabTextColorDisabled,
            "--n-tab-text-color-hover": tabTextColorHover,
            "--n-pane-text-color": paneTextColor,
            "--n-tab-border-color": tabBorderColor,
            "--n-tab-border-radius": tabBorderRadius,
            "--n-close-size": closeSize,
            "--n-close-icon-size": closeIconSize,
            "--n-close-color-hover": closeColorHover,
            "--n-close-color-pressed": closeColorPressed,
            "--n-close-border-radius": closeBorderRadius,
            "--n-close-icon-color": closeIconColor,
            "--n-close-icon-color-hover": closeIconColorHover,
            "--n-close-icon-color-pressed": closeIconColorPressed,
            "--n-tab-color": tabColor,
            "--n-tab-font-weight": tabFontWeight,
            "--n-tab-font-weight-active": tabFontWeightActive,
            "--n-tab-padding": tabPadding,
            "--n-tab-gap": tabGap,
            "--n-pane-padding": panePadding,
            "--n-font-weight-strong": fontWeightStrong,
            "--n-tab-color-segment": tabColorSegment
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass(
          "tabs",
          vue.computed(() => {
            return `${compitableSizeRef.value[0]}${props.type[0]}`;
          }),
          cssVarsRef,
          props
        ) : void 0;
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          mergedValue: mergedValueRef,
          renderedNames: /* @__PURE__ */ new Set(),
          tabsRailElRef,
          tabsPaneWrapperRef,
          tabsElRef,
          barElRef,
          addTabInstRef,
          xScrollInstRef,
          scrollWrapperElRef,
          addTabFixed: addTabFixedRef,
          tabWrapperStyle: tabWrapperStyleRef,
          handleNavResize,
          mergedSize: compitableSizeRef,
          handleScroll,
          handleTabsResize,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          animationDirection: animationDirectionRef,
          renderNameListRef,
          onAnimationBeforeLeave,
          onAnimationEnter,
          onAnimationAfterEnter,
          onRender: themeClassHandle?.onRender,
          ...exposedMethods
        };
      },
      render() {
        const {
          mergedClsPrefix,
          type,
          addTabFixed,
          addable,
          mergedSize,
          renderNameListRef,
          onRender,
          $slots: { default: defaultSlot, prefix: prefixSlot, suffix: suffixSlot }
        } = this;
        onRender?.();
        const tabPaneChildren = defaultSlot ? flatten$3(defaultSlot()).filter((v) => {
          return v.type.__TAB_PANE__ === true;
        }) : [];
        const tabChildren = defaultSlot ? flatten$3(defaultSlot()).filter((v) => {
          return v.type.__TAB__ === true;
        }) : [];
        const showPane = !tabChildren.length;
        const isCard = type === "card";
        const isSegment = type === "segment";
        const mergedJustifyContent = !isCard && !isSegment && this.justifyContent;
        renderNameListRef.value = [];
        return /* @__PURE__ */ vue.h("div", {
          class: [
            `${mergedClsPrefix}-tabs`,
            this.themeClass,
            `${mergedClsPrefix}-tabs--${type}-type`,
            `${mergedClsPrefix}-tabs--${mergedSize}-size`,
            mergedJustifyContent && `${mergedClsPrefix}-tabs--flex`
          ],
          style: this.cssVars
        }, /* @__PURE__ */ vue.h("div", {
          class: [
            `${mergedClsPrefix}-tabs-nav--${type}-type`,
            `${mergedClsPrefix}-tabs-nav`
          ]
        }, resolveWrappedSlot(
          prefixSlot,
          (children) => children && /* @__PURE__ */ vue.h("div", {
            class: `${mergedClsPrefix}-tabs-nav__prefix`
          }, children)
        ), isSegment ? /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-tabs-rail`,
          ref: "tabsRailElRef"
        }, showPane ? tabPaneChildren.map((tabPaneVNode, index) => {
          renderNameListRef.value.push(tabPaneVNode.props.name);
          return /* @__PURE__ */ vue.h(Tab, {
            ...tabPaneVNode.props,
            internalCreatedByPane: true,
            internalLeftPadded: index !== 0
          }, tabPaneVNode.children ? {
            default: tabPaneVNode.children.tab
          } : void 0);
        }) : tabChildren.map((tabVNode, index) => {
          renderNameListRef.value.push(tabVNode.props.name);
          if (index === 0) {
            return tabVNode;
          } else {
            return createLeftPaddedTabVNode(tabVNode);
          }
        })) : /* @__PURE__ */ vue.h(VResizeObserver, {
          onResize: this.handleNavResize
        }, {
          default: () => /* @__PURE__ */ vue.h("div", {
            class: `${mergedClsPrefix}-tabs-nav-scroll-wrapper`,
            ref: "scrollWrapperElRef"
          }, /* @__PURE__ */ vue.h(VXScroll, {
            ref: "xScrollInstRef",
            onScroll: this.handleScroll
          }, {
            default: () => {
              const rawWrappedTabs = /* @__PURE__ */ vue.h("div", {
                style: this.tabWrapperStyle,
                class: `${mergedClsPrefix}-tabs-wrapper`
              }, mergedJustifyContent ? null : /* @__PURE__ */ vue.h("div", {
                class: `${mergedClsPrefix}-tabs-scroll-padding`,
                style: { width: `${this.tabsPadding}px` }
              }), showPane ? tabPaneChildren.map(
                (tabPaneVNode, index) => {
                  renderNameListRef.value.push(
                    tabPaneVNode.props.name
                  );
                  return justifyTabDynamicProps(
                    /* @__PURE__ */ vue.h(Tab, {
                      ...tabPaneVNode.props,
                      internalCreatedByPane: true,
                      internalLeftPadded: index !== 0 && (!mergedJustifyContent || mergedJustifyContent === "center" || mergedJustifyContent === "start" || mergedJustifyContent === "end")
                    }, tabPaneVNode.children ? {
                      default: tabPaneVNode.children.tab
                    } : void 0)
                  );
                }
              ) : tabChildren.map(
                (tabVNode, index) => {
                  renderNameListRef.value.push(
                    tabVNode.props.name
                  );
                  if (index !== 0 && !mergedJustifyContent) {
                    return justifyTabDynamicProps(
                      createLeftPaddedTabVNode(tabVNode)
                    );
                  } else {
                    return justifyTabDynamicProps(tabVNode);
                  }
                }
              ), !addTabFixed && addable && isCard ? createAddTag(
                addable,
                (showPane ? tabPaneChildren.length : tabChildren.length) !== 0
              ) : null, mergedJustifyContent ? null : /* @__PURE__ */ vue.h("div", {
                class: `${mergedClsPrefix}-tabs-scroll-padding`,
                style: { width: `${this.tabsPadding}px` }
              }));
              let wrappedTabs = rawWrappedTabs;
              if (isCard && addable) {
                wrappedTabs = /* @__PURE__ */ vue.h(VResizeObserver, {
                  onResize: this.handleTabsResize
                }, {
                  default: () => rawWrappedTabs
                });
              }
              return /* @__PURE__ */ vue.h("div", {
                ref: "tabsElRef",
                class: `${mergedClsPrefix}-tabs-nav-scroll-content`
              }, wrappedTabs, isCard ? /* @__PURE__ */ vue.h("div", {
                class: `${mergedClsPrefix}-tabs-pad`
              }) : null, isCard ? null : /* @__PURE__ */ vue.h("div", {
                ref: "barElRef",
                class: `${mergedClsPrefix}-tabs-bar`
              }));
            }
          }))
        }), addTabFixed && addable && isCard ? createAddTag(addable, true) : null, resolveWrappedSlot(
          suffixSlot,
          (children) => children && /* @__PURE__ */ vue.h("div", {
            class: `${mergedClsPrefix}-tabs-nav__suffix`
          }, children)
        )), showPane && (this.animated ? /* @__PURE__ */ vue.h("div", {
          ref: "tabsPaneWrapperRef",
          class: `${mergedClsPrefix}-tabs-pane-wrapper`
        }, filterMapTabPanes(
          tabPaneChildren,
          this.mergedValue,
          this.renderedNames,
          this.onAnimationBeforeLeave,
          this.onAnimationEnter,
          this.onAnimationAfterEnter,
          this.animationDirection
        )) : filterMapTabPanes(
          tabPaneChildren,
          this.mergedValue,
          this.renderedNames
        )));
      }
    });
    function filterMapTabPanes(tabPaneVNodes, value, renderedNames, onBeforeLeave, onEnter, onAfterEnter, animationDirection) {
      const children = [];
      tabPaneVNodes.forEach((vNode) => {
        const {
          name,
          displayDirective,
          "display-directive": _displayDirective
        } = vNode.props;
        const matchDisplayDirective = (directive) => displayDirective === directive || _displayDirective === directive;
        const show = value === name;
        if (vNode.key !== void 0) {
          vNode.key = name;
        }
        if (show || matchDisplayDirective("show") || matchDisplayDirective("show:lazy") && renderedNames.has(name)) {
          if (!renderedNames.has(name)) {
            renderedNames.add(name);
          }
          const useVShow = !matchDisplayDirective("if");
          children.push(useVShow ? vue.withDirectives(vNode, [[vue.vShow, show]]) : vNode);
        }
      });
      if (!animationDirection) {
        return children;
      }
      return /* @__PURE__ */ vue.h(vue.TransitionGroup, {
        name: `${animationDirection}-transition`,
        onBeforeLeave,
        onEnter,
        onAfterEnter
      }, { default: () => children });
    }
    function createAddTag(addable, internalLeftPadded) {
      return /* @__PURE__ */ vue.h(Tab, {
        ref: "addTabInstRef",
        key: "__addable",
        name: "__addable",
        internalCreatedByPane: true,
        internalAddable: true,
        internalLeftPadded,
        disabled: typeof addable === "object" && addable.disabled
      });
    }
    function createLeftPaddedTabVNode(tabVNode) {
      const modifiedVNode = vue.cloneVNode(tabVNode);
      if (modifiedVNode.props) {
        modifiedVNode.props.internalLeftPadded = true;
      } else {
        modifiedVNode.props = {
          internalLeftPadded: true
        };
      }
      return modifiedVNode;
    }
    function justifyTabDynamicProps(tabVNode) {
      if (Array.isArray(tabVNode.dynamicProps)) {
        if (!tabVNode.dynamicProps.includes("internalLeftPadded")) {
          tabVNode.dynamicProps.push("internalLeftPadded");
        }
      } else {
        tabVNode.dynamicProps = ["internalLeftPadded"];
      }
      return tabVNode;
    }

    var style$d = cB("thing", `
  display: flex;
  transition: color .3s var(--n-bezier);
  font-size: var(--n-font-size);
  color: var(--n-text-color);
`, [cB("thing-avatar", `
    margin-right: 12px;
    margin-top: 2px;
  `), cB("thing-avatar-header-wrapper", `
    display: flex;
    flex-wrap: nowrap;
  `, [cB("thing-header-wrapper", `
      flex: 1;
    `)]), cB("thing-main", `
    flex-grow: 1;
  `, [cB("thing-header", `
      display: flex;
      margin-bottom: 4px;
      justify-content: space-between;
      align-items: center;
    `, [cE("title", `
        font-size: 16px;
        font-weight: var(--n-title-font-weight);
        transition: color .3s var(--n-bezier);
        color: var(--n-title-text-color);
      `)]), cE("description", [c$1("&:not(:last-child)", `
        margin-bottom: 4px;
      `)]), cE("content", [c$1("&:not(:first-child)", `
        margin-top: 12px;
      `)]), cE("footer", [c$1("&:not(:first-child)", `
        margin-top: 12px;
      `)]), cE("action", [c$1("&:not(:first-child)", `
        margin-top: 12px;
      `)])])]);

    const thingProps = {
      ...useTheme.props,
      title: String,
      titleExtra: String,
      description: String,
      descriptionStyle: [String, Object],
      content: String,
      contentStyle: [String, Object],
      contentIndented: Boolean
    };
    var Thing = vue.defineComponent({
      name: "Thing",
      props: thingProps,
      setup(props, { slots }) {
        const { mergedClsPrefixRef, inlineThemeDisabled, mergedRtlRef } = useConfig(props);
        const themeRef = useTheme(
          "Thing",
          "-thing",
          style$d,
          thingLight$1,
          props,
          mergedClsPrefixRef
        );
        const rtlEnabledRef = useRtl("Thing", mergedRtlRef, mergedClsPrefixRef);
        const cssVarsRef = vue.computed(() => {
          const {
            self: { titleTextColor, textColor, titleFontWeight, fontSize },
            common: { cubicBezierEaseInOut }
          } = themeRef.value;
          return {
            "--n-bezier": cubicBezierEaseInOut,
            "--n-font-size": fontSize,
            "--n-text-color": textColor,
            "--n-title-font-weight": titleFontWeight,
            "--n-title-text-color": titleTextColor
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("thing", void 0, cssVarsRef, props) : void 0;
        return () => {
          const { value: mergedClsPrefix } = mergedClsPrefixRef;
          const rtlEnabled = rtlEnabledRef ? rtlEnabledRef.value : false;
          themeClassHandle?.onRender?.();
          return /* @__PURE__ */ vue.h("div", {
            class: [
              `${mergedClsPrefix}-thing`,
              themeClassHandle?.themeClass,
              rtlEnabled && `${mergedClsPrefix}-thing--rtl`
            ],
            style: inlineThemeDisabled ? void 0 : cssVarsRef.value
          }, slots.avatar && props.contentIndented ? /* @__PURE__ */ vue.h("div", {
            class: `${mergedClsPrefix}-thing-avatar`
          }, slots.avatar()) : null, /* @__PURE__ */ vue.h("div", {
            class: `${mergedClsPrefix}-thing-main`
          }, !props.contentIndented && (slots.header || props.title || slots["header-extra"] || props.titleExtra || slots.avatar) ? /* @__PURE__ */ vue.h("div", {
            class: `${mergedClsPrefix}-thing-avatar-header-wrapper`
          }, slots.avatar ? /* @__PURE__ */ vue.h("div", {
            class: `${mergedClsPrefix}-thing-avatar`
          }, slots.avatar()) : null, slots.header || props.title || slots["header-extra"] || props.titleExtra ? /* @__PURE__ */ vue.h("div", {
            class: `${mergedClsPrefix}-thing-header-wrapper`
          }, /* @__PURE__ */ vue.h("div", {
            class: `${mergedClsPrefix}-thing-header`
          }, slots.header || props.title ? /* @__PURE__ */ vue.h("div", {
            class: `${mergedClsPrefix}-thing-header__title`
          }, slots.header ? slots.header() : props.title) : null, slots["header-extra"] || props.titleExtra ? /* @__PURE__ */ vue.h("div", {
            class: `${mergedClsPrefix}-thing-header__extra`
          }, slots["header-extra"] ? slots["header-extra"]() : props.titleExtra) : null), slots.description || props.description ? /* @__PURE__ */ vue.h("div", {
            class: `${mergedClsPrefix}-thing-main__description`,
            style: props.descriptionStyle
          }, slots.description ? slots.description() : props.description) : null) : null) : /* @__PURE__ */ vue.h(vue.Fragment, null, slots.header || props.title || slots["header-extra"] || props.titleExtra ? /* @__PURE__ */ vue.h("div", {
            class: `${mergedClsPrefix}-thing-header`
          }, slots.header || props.title ? /* @__PURE__ */ vue.h("div", {
            class: `${mergedClsPrefix}-thing-header__title`
          }, slots.header ? slots.header() : props.title) : null, slots["header-extra"] || props.titleExtra ? /* @__PURE__ */ vue.h("div", {
            class: `${mergedClsPrefix}-thing-header__extra`
          }, slots["header-extra"] ? slots["header-extra"]() : props.titleExtra) : null) : null, slots.description || props.description ? /* @__PURE__ */ vue.h("div", {
            class: `${mergedClsPrefix}-thing-main__description`,
            style: props.descriptionStyle
          }, slots.description ? slots.description() : props.description) : null), slots.default || props.content ? /* @__PURE__ */ vue.h("div", {
            class: `${mergedClsPrefix}-thing-main__content`,
            style: props.contentStyle
          }, slots.default ? slots.default() : props.content) : null, slots.footer ? /* @__PURE__ */ vue.h("div", {
            class: `${mergedClsPrefix}-thing-main__footer`
          }, slots.footer()) : null, slots.action ? /* @__PURE__ */ vue.h("div", {
            class: `${mergedClsPrefix}-thing-main__action`
          }, slots.action()) : null));
        };
      }
    });

    const timeProps = {
      time: {
        type: [Number, Date],
        default: void 0
      },
      type: {
        type: String,
        default: "datetime"
      },
      to: {
        type: [Number, Date],
        default: void 0
      },
      unix: Boolean,
      format: String,
      text: Boolean,
      timeZone: String
    };
    var Time = vue.defineComponent({
      name: "Time",
      props: timeProps,

      setup(props) {
        const now = Date.now();
        const {
          localeRef,
          dateLocaleRef
        } = useLocale("Time");
        const mergedFormatRef = vue.computed(() => {
          const {
            timeZone
          } = props;

          if (timeZone) {
            return (time, _format, options) => {
              return formatInTimeZone(time, timeZone, _format, options);
            };
          }

          return format$4;
        });
        const dateFnsOptionsRef = vue.computed(() => {
          return {
            locale: dateLocaleRef.value.locale
          };
        });
        const mergedTimeRef = vue.computed(() => {
          const {
            time
          } = props;

          if (props.unix) {
            if (time === void 0) return now;
            return fromUnixTime(typeof time === "number" ? time : time.valueOf());
          }

          return time ?? now;
        });
        const mergedToRef = vue.computed(() => {
          const {
            to
          } = props;

          if (props.unix) {
            if (to === void 0) return now;
            return fromUnixTime(typeof to === "number" ? to : to.valueOf());
          }

          return to ?? now;
        });
        const renderedTimeRef = vue.computed(() => {
          if (props.format) {
            return mergedFormatRef.value(mergedTimeRef.value, props.format, dateFnsOptionsRef.value);
          } else if (props.type === "date") {
            return mergedFormatRef.value(mergedTimeRef.value, localeRef.value.dateFormat, dateFnsOptionsRef.value);
          } else if (props.type === "datetime") {
            return mergedFormatRef.value(mergedTimeRef.value, localeRef.value.dateTimeFormat, dateFnsOptionsRef.value);
          } else {
            return formatDistanceStrict(mergedTimeRef.value, mergedToRef.value, {
              addSuffix: true,
              locale: dateLocaleRef.value.locale
            });
          }
        });
        return {
          renderedTime: renderedTimeRef
        };
      },

      render() {
        return this.text ? vue.createTextVNode(this.renderedTime) : vue.h("time", [this.renderedTime]);
      }

    });

    const lineHeight = 1.25;
    var style$c = cB("timeline", `
  position: relative;
  width: 100%;
  display: flex;
  flex-direction: column;
  line-height: ${lineHeight};
`, [cM("horizontal", `
    flex-direction: row;
  `, [c$1(">", [cB("timeline-item", `
        flex-shrink: 0;
        padding-right: 40px;
      `, [c$1(">", [cB("timeline-item-content", `
          margin-top: calc(var(--n-icon-size) + 12px);
          `, [cE("meta", `
              margin-top: 6px;
              margin-bottom: unset;
            `)]), cB("timeline-item-timeline", `
            width: 100%;
            height: calc(var(--n-icon-size) + 12px);
          `, [cE("line", `
              left: var(--n-icon-size);
              top: calc(var(--n-icon-size) / 2 - 1px);
              right: 0px;
              width: unset;
              height: 2px;
            `)])])])])]), cM("right-placement", [cB("timeline-item", [cB("timeline-item-content", `
        text-align: right;
        margin-right: calc(var(--n-icon-size) + 12px);
      `), cB("timeline-item-timeline", `
        width: var(--n-icon-size);
        right: 0;
      `)])]), cM("left-placement", [cB("timeline-item", [cB("timeline-item-content", `
        margin-left: calc(var(--n-icon-size) + 12px);
      `), cB("timeline-item-timeline", `
        left: 0;
      `)])]), cB("timeline-item", `
    position: relative;
  `, [c$1("&:last-child", [cB("timeline-item-timeline", [cE("line", `
          display: none;
        `)]), cB("timeline-item-content", [cE("meta", `
          margin-bottom: 0;
        `)])]), cB("timeline-item-content", [cE("title", `
        margin: var(--n-title-margin);
        font-size: var(--n-title-font-size);
        transition: color .3s var(--n-bezier);
        font-weight: var(--n-title-font-weight);
        margin-bottom: 6px;
        color: var(--n-title-text-color);
      `), cE("content", `
        transition: color .3s var(--n-bezier);
        font-size: var(--n-content-font-size);
        color: var(--n-content-text-color);
      `), cE("meta", `
        transition: color .3s var(--n-bezier);
        font-size: 12px;
        margin-top: 6px;
        margin-bottom: 20px;
        color: var(--n-meta-text-color);
      `)]), cM("dashed-line-type", [cB("timeline-item-timeline", [cE("line", `
          --n-color-start: var(--n-line-color);
          transition: --n-color-start .3s var(--n-bezier);
          background-color: transparent;
          background-image: linear-gradient(180deg, var(--n-color-start), var(--n-color-start) 50%, transparent 50%, transparent 100%);
          background-size: 1px 10px;
        `)])]), cB("timeline-item-timeline", `
      width: calc(var(--n-icon-size) + 12px);
      position: absolute;
      top: calc(var(--n-title-font-size) * ${lineHeight} / 2 - var(--n-icon-size) / 2);
      height: 100%;
    `, [cE("circle", `
        border: var(--n-circle-border);
        transition:
          background-color .3s var(--n-bezier),
          border-color .3s var(--n-bezier);
        width: var(--n-icon-size);
        height: var(--n-icon-size);
        border-radius: var(--n-icon-size);
        box-sizing: border-box;
      `), cE("icon", `
        color: var(--n-icon-color);
        font-size: var(--n-icon-size);
        height: var(--n-icon-size);
        width: var(--n-icon-size);
        display: flex;
        align-items: center;
        justify-content: center;
      `), cE("line", `
        transition: background-color .3s var(--n-bezier);
        position: absolute;
        top: var(--n-icon-size);
        left: calc(var(--n-icon-size) / 2 - 1px);
        bottom: 0px;
        width: 2px;
        background-color: var(--n-line-color);
      `)])])]);

    const timelineProps = {
      ...useTheme.props,
      horizontal: Boolean,
      itemPlacement: {
        type: String,
        default: "left"
      },
      size: {
        type: String,
        default: "medium"
      },
      iconSize: Number
    };
    const timelineInjectionKey = createInjectionKey("n-timeline");
    var Timeline = vue.defineComponent({
      name: "Timeline",
      props: timelineProps,
      setup(props, { slots }) {
        const { mergedClsPrefixRef } = useConfig(props);
        const themeRef = useTheme(
          "Timeline",
          "-timeline",
          style$c,
          timelineLight$1,
          props,
          mergedClsPrefixRef
        );
        vue.provide(timelineInjectionKey, {
          props,
          mergedThemeRef: themeRef,
          mergedClsPrefixRef
        });
        return () => {
          const { value: mergedClsPrefix } = mergedClsPrefixRef;
          return /* @__PURE__ */ vue.h("div", {
            class: [
              `${mergedClsPrefix}-timeline`,
              props.horizontal && `${mergedClsPrefix}-timeline--horizontal`,
              `${mergedClsPrefix}-timeline--${props.size}-size`,
              !props.horizontal && `${mergedClsPrefix}-timeline--${props.itemPlacement}-placement`
            ]
          }, slots);
        };
      }
    });

    const timelineItemProps = {
      time: [String, Number],
      title: String,
      content: String,
      color: String,
      lineType: {
        type: String,
        default: "default"
      },
      type: {
        type: String,
        default: "default"
      }
    };
    var TimelineItem = vue.defineComponent({
      name: "TimelineItem",
      props: timelineItemProps,
      setup(props) {
        const NTimeline = vue.inject(timelineInjectionKey);
        if (!NTimeline) {
          throwError(
            "timeline-item",
            "`n-timeline-item` must be placed inside `n-timeline`."
          );
        }
        useHoudini();
        const { inlineThemeDisabled } = useConfig();
        const cssVarsRef = vue.computed(() => {
          const {
            props: { size, iconSize: iconSizeProp },
            mergedThemeRef
          } = NTimeline;
          const { type } = props;
          const {
            self: {
              titleTextColor,
              contentTextColor,
              metaTextColor,
              lineColor,
              titleFontWeight,
              contentFontSize,
              [createKey("iconSize", size)]: iconSize,
              [createKey("titleMargin", size)]: titleMargin,
              [createKey("titleFontSize", size)]: titleFontSize,
              [createKey("circleBorder", type)]: circleBorder,
              [createKey("iconColor", type)]: iconColor
            },
            common: { cubicBezierEaseInOut }
          } = mergedThemeRef.value;
          return {
            "--n-bezier": cubicBezierEaseInOut,
            "--n-circle-border": circleBorder,
            "--n-icon-color": iconColor,
            "--n-content-font-size": contentFontSize,
            "--n-content-text-color": contentTextColor,
            "--n-line-color": lineColor,
            "--n-meta-text-color": metaTextColor,
            "--n-title-font-size": titleFontSize,
            "--n-title-font-weight": titleFontWeight,
            "--n-title-margin": titleMargin,
            "--n-title-text-color": titleTextColor,
            "--n-icon-size": formatLength(iconSizeProp) || iconSize
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass(
          "timeline-item",
          vue.computed(() => {
            const {
              props: { size, iconSize: iconSizeProp }
            } = NTimeline;
            const { type } = props;
            return `${size[0]}${iconSizeProp || "a"}${type[0]}`;
          }),
          cssVarsRef,
          NTimeline.props
        ) : void 0;
        return {
          mergedClsPrefix: NTimeline.mergedClsPrefixRef,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender
        };
      },
      render() {
        const { mergedClsPrefix, color, onRender, $slots } = this;
        onRender?.();
        return /* @__PURE__ */ vue.h("div", {
          class: [
            `${mergedClsPrefix}-timeline-item`,
            this.themeClass,
            `${mergedClsPrefix}-timeline-item--${this.type}-type`,
            `${mergedClsPrefix}-timeline-item--${this.lineType}-line-type`
          ],
          style: this.cssVars
        }, /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-timeline-item-timeline`
        }, /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-timeline-item-timeline__line`
        }), resolveWrappedSlot($slots.icon, (children) => {
          return children ? /* @__PURE__ */ vue.h("div", {
            class: `${mergedClsPrefix}-timeline-item-timeline__icon`,
            style: { color }
          }, children) : /* @__PURE__ */ vue.h("div", {
            class: `${mergedClsPrefix}-timeline-item-timeline__circle`,
            style: { borderColor: color }
          });
        })), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-timeline-item-content`
        }, resolveWrappedSlot($slots.header, (children) => {
          const mergedChildren = children || this.title;
          if (mergedChildren) {
            return /* @__PURE__ */ vue.h("div", {
              class: `${mergedClsPrefix}-timeline-item-content__title`
            }, children || this.title);
          }
          return null;
        }), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-timeline-item-content__content`
        }, resolveSlot($slots.default, () => [this.content])), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-timeline-item-content__meta`
        }, resolveSlot($slots.footer, () => [this.time]))));
      }
    });

    const transferInjectionKey = createInjectionKey("n-transfer");

    var NTransferHeader = vue.defineComponent({
      name: "TransferHeader",
      props: {
        size: {
          type: String,
          required: true
        },
        source: Boolean,
        onCheckedAll: Function,
        onClearAll: Function,
        title: String
      },
      setup(props) {
        const {
          targetOptionsRef,
          canNotSelectAnythingRef,
          canBeClearedRef,
          allCheckedRef,
          mergedThemeRef,
          disabledRef,
          mergedClsPrefixRef,
          srcOptionsLengthRef
        } = vue.inject(transferInjectionKey);
        const { localeRef } = useLocale("Transfer");
        return () => {
          const { source, onClearAll, onCheckedAll } = props;
          const { value: mergedTheme } = mergedThemeRef;
          const { value: mergedClsPrefix } = mergedClsPrefixRef;
          const { value: locale } = localeRef;
          const buttonSize = props.size === "large" ? "small" : "tiny";
          const { title } = props;
          return /* @__PURE__ */ vue.h("div", {
            class: `${mergedClsPrefix}-transfer-list-header`
          }, title && /* @__PURE__ */ vue.h("div", {
            class: `${mergedClsPrefix}-transfer-list-header__title`
          }, title), source && /* @__PURE__ */ vue.h(NButton, {
            class: `${mergedClsPrefix}-transfer-list-header__button`,
            theme: mergedTheme.peers.Button,
            themeOverrides: mergedTheme.peerOverrides.Button,
            size: buttonSize,
            tertiary: true,
            onClick: allCheckedRef.value ? onClearAll : onCheckedAll,
            disabled: canNotSelectAnythingRef.value || disabledRef.value
          }, {
            default: () => allCheckedRef.value ? locale.unselectAll : locale.selectAll
          }), !source && canBeClearedRef.value && /* @__PURE__ */ vue.h(NButton, {
            class: `${mergedClsPrefix}-transfer-list-header__button`,
            theme: mergedTheme.peers.Button,
            themeOverrides: mergedTheme.peerOverrides.Button,
            size: buttonSize,
            tertiary: true,
            onClick: onClearAll,
            disabled: disabledRef.value
          }, {
            default: () => locale.clearAll
          }), /* @__PURE__ */ vue.h("div", {
            class: `${mergedClsPrefix}-transfer-list-header__extra`
          }, source ? locale.total(srcOptionsLengthRef.value) : locale.selected(targetOptionsRef.value.length)));
        };
      }
    });

    var NTransferListItem = vue.defineComponent({
      name: "NTransferListItem",
      props: {
        source: Boolean,
        label: {
          type: String,
          required: true
        },
        value: {
          type: [String, Number],
          required: true
        },
        disabled: Boolean,
        option: {
          type: Object,
          required: true
        }
      },
      setup(props) {
        const {
          targetValueSetRef,
          mergedClsPrefixRef,
          mergedThemeRef,
          handleItemCheck,
          renderSourceLabelRef,
          renderTargetLabelRef
        } = vue.inject(transferInjectionKey);
        const checkedRef = useMemo(() => targetValueSetRef.value.has(props.value));
        function handleClick() {
          if (!props.disabled) {
            handleItemCheck(!checkedRef.value, props.value);
          }
        }
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          mergedTheme: mergedThemeRef,
          checked: checkedRef,
          handleClick,
          renderSourceLabel: renderSourceLabelRef,
          renderTargetLabel: renderTargetLabelRef
        };
      },
      render() {
        const {
          disabled,
          mergedTheme,
          mergedClsPrefix,
          label,
          checked,
          source,
          renderSourceLabel,
          renderTargetLabel
        } = this;
        return /* @__PURE__ */ vue.h("div", {
          class: [
            `${mergedClsPrefix}-transfer-list-item`,
            disabled && `${mergedClsPrefix}-transfer-list-item--disabled`,
            source ? `${mergedClsPrefix}-transfer-list-item--source` : `${mergedClsPrefix}-transfer-list-item--target`
          ],
          onClick: source ? this.handleClick : void 0
        }, /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-transfer-list-item__background`
        }), source && /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-transfer-list-item__checkbox`
        }, /* @__PURE__ */ vue.h(NCheckbox, {
          theme: mergedTheme.peers.Checkbox,
          themeOverrides: mergedTheme.peerOverrides.Checkbox,
          disabled,
          checked
        })), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-transfer-list-item__label`,
          title: getTitleAttribute(label)
        }, source ? renderSourceLabel ? renderSourceLabel({
          option: this.option
        }) : label : renderTargetLabel ? renderTargetLabel({
          option: this.option
        }) : label), !source && !disabled && /* @__PURE__ */ vue.h(NBaseClose, {
          focusable: false,
          class: `${mergedClsPrefix}-transfer-list-item__close`,
          clsPrefix: mergedClsPrefix,
          onClick: this.handleClick
        }));
      }
    });

    var NTransferList = vue.defineComponent({
      name: "TransferList",
      props: {
        virtualScroll: {
          type: Boolean,
          required: true
        },
        itemSize: {
          type: Number,
          required: true
        },
        options: {
          type: Array,
          required: true
        },
        disabled: {
          type: Boolean,
          required: true
        },
        source: Boolean
      },
      setup() {
        const { mergedThemeRef, mergedClsPrefixRef } = vue.inject(transferInjectionKey);
        const scrollerInstRef = vue.ref(null);
        const vlInstRef = vue.ref(null);
        function syncVLScroller() {
          scrollerInstRef.value?.sync();
        }
        function scrollContainer() {
          const { value } = vlInstRef;
          if (!value)
            return null;
          const { listElRef } = value;
          return listElRef;
        }
        function scrollContent() {
          const { value } = vlInstRef;
          if (!value)
            return null;
          const { itemsElRef } = value;
          return itemsElRef;
        }
        return {
          mergedTheme: mergedThemeRef,
          mergedClsPrefix: mergedClsPrefixRef,
          scrollerInstRef,
          vlInstRef,
          syncVLScroller,
          scrollContainer,
          scrollContent
        };
      },
      render() {
        const { mergedTheme, options } = this;
        if (options.length === 0) {
          return /* @__PURE__ */ vue.h(NEmpty, {
            theme: mergedTheme.peers.Empty,
            themeOverrides: mergedTheme.peerOverrides.Empty
          });
        }
        const { mergedClsPrefix, virtualScroll, source, disabled, syncVLScroller } = this;
        return /* @__PURE__ */ vue.h(NScrollbar, {
          ref: "scrollerInstRef",
          theme: mergedTheme.peers.Scrollbar,
          themeOverrides: mergedTheme.peerOverrides.Scrollbar,
          container: virtualScroll ? this.scrollContainer : void 0,
          content: virtualScroll ? this.scrollContent : void 0
        }, {
          default: () => virtualScroll ? /* @__PURE__ */ vue.h(VVirtualList, {
            ref: "vlInstRef",
            style: { height: "100%" },
            class: `${mergedClsPrefix}-transfer-list-content`,
            items: this.options,
            itemSize: this.itemSize,
            showScrollbar: false,
            onResize: syncVLScroller,
            onScroll: syncVLScroller,
            keyField: "value"
          }, {
            default: ({ item }) => {
              const { source: source2, disabled: disabled2 } = this;
              return /* @__PURE__ */ vue.h(NTransferListItem, {
                source: source2,
                key: item.value,
                value: item.value,
                disabled: item.disabled || disabled2,
                label: item.label,
                option: item
              });
            }
          }) : /* @__PURE__ */ vue.h("div", {
            class: `${mergedClsPrefix}-transfer-list-content`
          }, options.map((option) => /* @__PURE__ */ vue.h(NTransferListItem, {
            source,
            key: option.value,
            value: option.value,
            disabled: option.disabled || disabled,
            label: option.label,
            option
          })))
        });
      }
    });

    var NTransferFilter = vue.defineComponent({
      name: "TransferFilter",
      props: {
        value: String,
        placeholder: String,
        disabled: Boolean,
        onUpdateValue: {
          type: Function,
          required: true
        }
      },
      setup() {
        const { mergedThemeRef, mergedClsPrefixRef } = vue.inject(transferInjectionKey);
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          mergedTheme: mergedThemeRef
        };
      },
      render() {
        const { mergedTheme, mergedClsPrefix } = this;
        return /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-transfer-filter`
        }, /* @__PURE__ */ vue.h(NInput, {
          value: this.value,
          onUpdateValue: this.onUpdateValue,
          disabled: this.disabled,
          placeholder: this.placeholder,
          theme: mergedTheme.peers.Input,
          themeOverrides: mergedTheme.peerOverrides.Input,
          clearable: true,
          size: "small"
        }, {
          "clear-icon-placeholder": () => /* @__PURE__ */ vue.h(NBaseIcon, {
            clsPrefix: mergedClsPrefix
          }, { default: () => /* @__PURE__ */ vue.h(SearchIcon, null) })
        }));
      }
    });

    function useTransferData(props) {
      const uncontrolledValueRef = vue.ref(props.defaultValue);
      const mergedValueRef = useMergedState(vue.toRef(props, "value"), uncontrolledValueRef);
      const optionsMapRef = vue.computed(() => {
        const map = /* @__PURE__ */new Map();
        (props.options || []).forEach(opt => map.set(opt.value, opt));
        return map;
      });
      const targetValueSetRef = vue.computed(() => new Set(mergedValueRef.value || []));
      const targetOptionsRef = vue.computed(() => {
        const optionMap = optionsMapRef.value;
        const targetOptions = [];
        (mergedValueRef.value || []).forEach(v => {
          const option = optionMap.get(v);

          if (option) {
            targetOptions.push(option);
          }
        });
        return targetOptions;
      });
      const srcPatternRef = vue.ref("");
      const tgtPatternRef = vue.ref("");
      const mergedSrcFilterableRef = vue.computed(() => {
        return props.sourceFilterable || !!props.filterable;
      });
      const filteredSrcOptionsRef = vue.computed(() => {
        if (!mergedSrcFilterableRef.value) return props.options;
        const {
          filter
        } = props;
        return props.options.filter(opt => filter(srcPatternRef.value, opt, "source"));
      });
      const filteredTgtOptionsRef = vue.computed(() => {
        if (!props.targetFilterable) return targetOptionsRef.value;
        const {
          filter
        } = props;
        return targetOptionsRef.value.filter(opt => filter(tgtPatternRef.value, opt, "target"));
      });
      const mergedValueSetRef = vue.computed(() => {
        const {
          value
        } = mergedValueRef;
        if (value === null) return /* @__PURE__ */new Set();
        return new Set(value);
      });
      const valueSetForCheckAllRef = vue.computed(() => {
        const values = new Set(mergedValueSetRef.value);
        filteredSrcOptionsRef.value.forEach(option => {
          if (!option.disabled && !values.has(option.value)) {
            values.add(option.value);
          }
        });
        return values;
      });
      const valueSetForUncheckAllRef = vue.computed(() => {
        const values = new Set(mergedValueSetRef.value);
        filteredSrcOptionsRef.value.forEach(option => {
          if (!option.disabled && values.has(option.value)) {
            values.delete(option.value);
          }
        });
        return values;
      });
      const valueSetForClearRef = vue.computed(() => {
        const values = new Set(mergedValueSetRef.value);
        filteredTgtOptionsRef.value.forEach(option => {
          if (!option.disabled) {
            values.delete(option.value);
          }
        });
        return values;
      });
      const canNotSelectAnythingRef = vue.computed(() => {
        return filteredSrcOptionsRef.value.every(option => option.disabled);
      });
      const allCheckedRef = vue.computed(() => {
        if (!filteredSrcOptionsRef.value.length) {
          return false;
        }

        const mergedValueSet = mergedValueSetRef.value;
        return filteredSrcOptionsRef.value.every(option => option.disabled || mergedValueSet.has(option.value));
      });
      const canBeClearedRef = vue.computed(() => {
        return filteredTgtOptionsRef.value.some(option => !option.disabled);
      });

      function handleSrcFilterUpdateValue(value) {
        srcPatternRef.value = value ?? "";
      }

      function handleTgtFilterUpdateValue(value) {
        tgtPatternRef.value = value ?? "";
      }

      return {
        uncontrolledValueRef,
        mergedValueRef,
        targetValueSetRef,
        valueSetForCheckAllRef,
        valueSetForUncheckAllRef,
        valueSetForClearRef,
        filteredTgtOptionsRef,
        filteredSrcOptionsRef,
        targetOptionsRef,
        canNotSelectAnythingRef,
        canBeClearedRef,
        allCheckedRef,
        srcPatternRef,
        tgtPatternRef,
        mergedSrcFilterableRef,
        handleSrcFilterUpdateValue,
        handleTgtFilterUpdateValue
      };
    }

    var style$b = cB("transfer", `
  width: 100%;
  font-size: var(--n-font-size);
  height: 300px;
  display: flex;
  flex-wrap: nowrap;
  word-break: break-word;
`, [cM("disabled", [cB("transfer-list", [cB("transfer-list-header", [cE("title", `
          color: var(--n-header-text-color-disabled);
        `), cE("extra", `
          color: var(--n-header-extra-text-color-disabled);
        `)])])]), cB("transfer-list", `
    flex: 1;
    min-width: 0;
    height: inherit;
    display: flex;
    flex-direction: column;
    background-clip: padding-box;
    position: relative;
    transition: background-color .3s var(--n-bezier);
    background-color: var(--n-list-color);
  `, [cM("source", `
      border-top-left-radius: var(--n-border-radius);
      border-bottom-left-radius: var(--n-border-radius);
    `, [cE("border", "border-right: 1px solid var(--n-divider-color);")]), cM("target", `
      border-top-right-radius: var(--n-border-radius);
      border-bottom-right-radius: var(--n-border-radius);
    `, [cE("border", "border-left: none;")]), cE("border", `
      padding: 0 12px;
      border: 1px solid var(--n-border-color);
      transition: border-color .3s var(--n-bezier);
      pointer-events: none;
      border-radius: inherit;
      position: absolute;
      left: 0;
      right: 0;
      top: 0;
      bottom: 0;
    `), cB("transfer-list-header", `
      min-height: var(--n-header-height);
      box-sizing: border-box;
      display: flex;
      padding: 12px 12px 10px 12px;
      align-items: center;
      background-clip: padding-box;
      border-radius: inherit;
      border-bottom-left-radius: 0;
      border-bottom-right-radius: 0;
      line-height: 1.5;
      transition:
        border-color .3s var(--n-bezier),
        background-color .3s var(--n-bezier);
    `, [c$1("> *:not(:first-child)", `
        margin-left: 8px;
      `), cE("title", `
        flex: 1;
        min-width: 0;
        line-height: 1.5;
        font-size: var(--n-header-font-size);
        font-weight: var(--n-header-font-weight);
        transition: color .3s var(--n-bezier);
        color: var(--n-header-text-color);
      `), cE("button", `
        position: relative;
      `), cE("extra", `
        transition: color .3s var(--n-bezier);
        font-size: var(--n-extra-font-size);
        margin-right: 0;
        white-space: nowrap;
        color: var(--n-header-extra-text-color);
      `)]), cB("transfer-list-body", `
      flex-basis: 0;
      flex-grow: 1;
      box-sizing: border-box;
      position: relative;
      display: flex;
      flex-direction: column;
      border-radius: inherit;
      border-top-left-radius: 0;
      border-top-right-radius: 0;
    `, [cB("transfer-filter", `
        padding: 4px 12px 8px 12px;
        box-sizing: border-box;
        transition:
          border-color .3s var(--n-bezier),
          background-color .3s var(--n-bezier);
      `), cB("transfer-list-flex-container", `
        flex: 1;
        position: relative;
      `, [cB("scrollbar", `
          position: absolute;
          left: 0;
          right: 0;
          top: 0;
          bottom: 0;
          height: unset;
        `), cB("empty", `
          position: absolute;
          left: 50%;
          top: 50%;
          transform: translateY(-50%) translateX(-50%);
        `), cB("transfer-list-content", `
          padding: 0;
          margin: 0;
          position: relative;
        `, [cB("transfer-list-item", `
            padding: 0 12px;
            min-height: var(--n-item-height);
            display: flex;
            align-items: center;
            color: var(--n-item-text-color);
            position: relative;
            transition: color .3s var(--n-bezier);
          `, [cE("background", `
              position: absolute;
              left: 4px;
              right: 4px;
              top: 0;
              bottom: 0;
              border-radius: var(--n-border-radius);
              transition: background-color .3s var(--n-bezier);
            `), cE("checkbox", `
              position: relative;
              margin-right: 8px;
            `), cE("close", `
              opacity: 0;
              pointer-events: none;
              position: relative;
              transition:
                opacity .3s var(--n-bezier),
                background-color .3s var(--n-bezier),
                color .3s var(--n-bezier);
            `), cE("label", `
              position: relative;
              min-width: 0;
              flex-grow: 1;
            `), cM("source", "cursor: pointer;"), cM("disabled", `
              cursor: not-allowed;
              color: var(--n-item-text-color-disabled);
            `), cNotM("disabled", [c$1("&:hover", [cE("background", "background-color: var(--n-item-color-pending);"), cE("close", `
                  opacity: 1;
                  pointer-events: all;
                `)])])])])])])])]);

    const transferProps = {
      ...useTheme.props,
      value: Array,
      defaultValue: {
        type: Array,
        default: null
      },
      options: {
        type: Array,
        default: () => []
      },
      disabled: {
        type: Boolean,
        default: void 0
      },
      virtualScroll: Boolean,
      sourceTitle: String,
      targetTitle: String,
      filterable: {
        type: Boolean,
        default: void 0
      },
      sourceFilterable: Boolean,
      targetFilterable: Boolean,
      sourceFilterPlaceholder: String,
      targetFilterPlaceholder: String,
      filter: {
        type: Function,
        default: (pattern, option) => {
          if (!pattern)
            return true;
          return ~("" + option.label).toLowerCase().indexOf(("" + pattern).toLowerCase());
        }
      },
      size: String,
      renderSourceLabel: Function,
      renderTargetLabel: Function,
      renderSourceList: Function,
      "onUpdate:value": [Function, Array],
      onUpdateValue: [Function, Array],
      onChange: [Function, Array]
    };
    var Transfer = vue.defineComponent({
      name: "Transfer",
      props: transferProps,
      setup(props) {
        {
          vue.watchEffect(() => {
            if (props.onChange !== void 0) {
              warnOnce(
                "transfer",
                "`on-change` is deprecated, please use `on-update:value` instead."
              );
            }
            if (props.filterable !== void 0) {
              warnOnce(
                "transfer",
                "`filterable` is deprecated, please use `source-filterable` or `target-filterable` instead."
              );
            }
          });
        }
        const { mergedClsPrefixRef } = useConfig(props);
        const themeRef = useTheme(
          "Transfer",
          "-transfer",
          style$b,
          transferLight$2,
          props,
          mergedClsPrefixRef
        );
        const formItem = useFormItem(props);
        const { mergedSizeRef, mergedDisabledRef } = formItem;
        const itemSizeRef = vue.computed(() => {
          const { value: size } = mergedSizeRef;
          const {
            self: { [createKey("itemHeight", size)]: itemSize }
          } = themeRef.value;
          return depx(itemSize);
        });
        const {
          uncontrolledValueRef,
          mergedValueRef,
          targetValueSetRef,
          valueSetForCheckAllRef,
          valueSetForUncheckAllRef,
          valueSetForClearRef,
          filteredTgtOptionsRef,
          filteredSrcOptionsRef,
          targetOptionsRef,
          canNotSelectAnythingRef,
          canBeClearedRef,
          allCheckedRef,
          srcPatternRef,
          tgtPatternRef,
          mergedSrcFilterableRef,
          handleSrcFilterUpdateValue,
          handleTgtFilterUpdateValue
        } = useTransferData(props);
        function doUpdateValue(value) {
          const {
            onUpdateValue,
            "onUpdate:value": _onUpdateValue,
            onChange
          } = props;
          const { nTriggerFormInput, nTriggerFormChange } = formItem;
          if (onUpdateValue)
            call(onUpdateValue, value);
          if (_onUpdateValue)
            call(_onUpdateValue, value);
          if (onChange)
            call(onChange, value);
          uncontrolledValueRef.value = value;
          nTriggerFormInput();
          nTriggerFormChange();
        }
        function handleSourceCheckAll() {
          doUpdateValue([...valueSetForCheckAllRef.value]);
        }
        function handleSourceUncheckAll() {
          doUpdateValue([...valueSetForUncheckAllRef.value]);
        }
        function handleTargetClearAll() {
          doUpdateValue([...valueSetForClearRef.value]);
        }
        function handleItemCheck(checked, optionValue) {
          if (checked) {
            doUpdateValue((mergedValueRef.value || []).concat(optionValue));
          } else {
            doUpdateValue(
              (mergedValueRef.value || []).filter((v) => v !== optionValue)
            );
          }
        }
        function handleChecked(optionValueList) {
          doUpdateValue(optionValueList);
        }
        vue.provide(transferInjectionKey, {
          targetValueSetRef,
          mergedClsPrefixRef,
          disabledRef: mergedDisabledRef,
          mergedThemeRef: themeRef,
          targetOptionsRef,
          canNotSelectAnythingRef,
          canBeClearedRef,
          allCheckedRef,
          srcOptionsLengthRef: vue.computed(() => props.options.length),
          handleItemCheck,
          renderSourceLabelRef: vue.toRef(props, "renderSourceLabel"),
          renderTargetLabelRef: vue.toRef(props, "renderTargetLabel")
        });
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          mergedDisabled: mergedDisabledRef,
          itemSize: itemSizeRef,
          isMounted: isMounted(),
          mergedTheme: themeRef,
          filteredSrcOpts: filteredSrcOptionsRef,
          filteredTgtOpts: filteredTgtOptionsRef,
          srcPattern: srcPatternRef,
          tgtPattern: tgtPatternRef,
          mergedSize: mergedSizeRef,
          mergedSrcFilterable: mergedSrcFilterableRef,
          handleSrcFilterUpdateValue,
          handleTgtFilterUpdateValue,
          handleSourceCheckAll,
          handleSourceUncheckAll,
          handleTargetClearAll,
          handleItemCheck,
          handleChecked,
          cssVars: vue.computed(() => {
            const { value: size } = mergedSizeRef;
            const {
              common: { cubicBezierEaseInOut },
              self: {
                borderRadius,
                borderColor,
                listColor,
                titleTextColor,
                titleTextColorDisabled,
                extraTextColor,
                itemTextColor,
                itemColorPending,
                itemTextColorDisabled,
                titleFontWeight,
                closeColorHover,
                closeColorPressed,
                closeIconColor,
                closeIconColorHover,
                closeIconColorPressed,
                closeIconSize,
                closeSize,
                dividerColor,
                extraTextColorDisabled,
                [createKey("extraFontSize", size)]: extraFontSize,
                [createKey("fontSize", size)]: fontSize,
                [createKey("titleFontSize", size)]: titleFontSize,
                [createKey("itemHeight", size)]: itemHeight,
                [createKey("headerHeight", size)]: headerHeight
              }
            } = themeRef.value;
            return {
              "--n-bezier": cubicBezierEaseInOut,
              "--n-border-color": borderColor,
              "--n-border-radius": borderRadius,
              "--n-extra-font-size": extraFontSize,
              "--n-font-size": fontSize,
              "--n-header-font-size": titleFontSize,
              "--n-header-extra-text-color": extraTextColor,
              "--n-header-extra-text-color-disabled": extraTextColorDisabled,
              "--n-header-font-weight": titleFontWeight,
              "--n-header-text-color": titleTextColor,
              "--n-header-text-color-disabled": titleTextColorDisabled,
              "--n-item-color-pending": itemColorPending,
              "--n-item-height": itemHeight,
              "--n-item-text-color": itemTextColor,
              "--n-item-text-color-disabled": itemTextColorDisabled,
              "--n-list-color": listColor,
              "--n-header-height": headerHeight,
              "--n-close-size": closeSize,
              "--n-close-icon-size": closeIconSize,
              "--n-close-color-hover": closeColorHover,
              "--n-close-color-pressed": closeColorPressed,
              "--n-close-icon-color": closeIconColor,
              "--n-close-icon-color-hover": closeIconColorHover,
              "--n-close-icon-color-pressed": closeIconColorPressed,
              "--n-divider-color": dividerColor
            };
          })
        };
      },
      render() {
        const {
          mergedClsPrefix,
          renderSourceList,
          mergedTheme,
          mergedSrcFilterable,
          targetFilterable
        } = this;
        return /* @__PURE__ */ vue.h("div", {
          class: [
            `${mergedClsPrefix}-transfer`,
            this.mergedDisabled && `${mergedClsPrefix}-transfer--disabled`
          ],
          style: this.cssVars
        }, /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-transfer-list ${mergedClsPrefix}-transfer-list--source`
        }, /* @__PURE__ */ vue.h(NTransferHeader, {
          source: true,
          title: this.sourceTitle,
          onCheckedAll: this.handleSourceCheckAll,
          onClearAll: this.handleSourceUncheckAll,
          size: this.mergedSize
        }), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-transfer-list-body`
        }, mergedSrcFilterable ? /* @__PURE__ */ vue.h(NTransferFilter, {
          onUpdateValue: this.handleSrcFilterUpdateValue,
          value: this.srcPattern,
          disabled: this.mergedDisabled,
          placeholder: this.sourceFilterPlaceholder
        }) : null, /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-transfer-list-flex-container`
        }, renderSourceList ? /* @__PURE__ */ vue.h(NScrollbar, {
          theme: mergedTheme.peers.Scrollbar,
          themeOverrides: mergedTheme.peerOverrides.Scrollbar
        }, {
          default: () => renderSourceList({
            onCheck: this.handleChecked,
            checkedOptions: this.filteredTgtOpts,
            pattern: this.srcPattern
          })
        }) : /* @__PURE__ */ vue.h(NTransferList, {
          source: true,
          options: this.filteredSrcOpts,
          disabled: this.mergedDisabled,
          virtualScroll: this.virtualScroll,
          itemSize: this.itemSize
        }))), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-transfer-list__border`
        })), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-transfer-list ${mergedClsPrefix}-transfer-list--target`
        }, /* @__PURE__ */ vue.h(NTransferHeader, {
          onClearAll: this.handleTargetClearAll,
          size: this.mergedSize,
          title: this.targetTitle
        }), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-transfer-list-body`
        }, targetFilterable ? /* @__PURE__ */ vue.h(NTransferFilter, {
          onUpdateValue: this.handleTgtFilterUpdateValue,
          value: this.tgtPattern,
          disabled: this.mergedDisabled,
          placeholder: this.sourceFilterPlaceholder
        }) : null, /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-transfer-list-flex-container`
        }, /* @__PURE__ */ vue.h(NTransferList, {
          options: this.filteredTgtOpts,
          disabled: this.mergedDisabled,
          virtualScroll: this.virtualScroll,
          itemSize: this.itemSize
        }))), /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-transfer-list__border`
        })));
      }
    });

    const treeSelectInjectionKey = createInjectionKey("n-tree-select");

    const treeInjectionKey = createInjectionKey("n-tree");

    var NTreeNodeSwitcher = vue.defineComponent({
      name: "NTreeSwitcher",
      props: {
        clsPrefix: {
          type: String,
          required: true
        },
        expanded: Boolean,
        hide: Boolean,
        loading: Boolean,
        onClick: Function
      },
      setup(props) {
        const { renderSwitcherIconRef } = vue.inject(treeInjectionKey, null);
        return () => {
          const { clsPrefix } = props;
          return /* @__PURE__ */ vue.h("span", {
            "data-switcher": true,
            class: [
              `${clsPrefix}-tree-node-switcher`,
              {
                [`${clsPrefix}-tree-node-switcher--expanded`]: props.expanded,
                [`${clsPrefix}-tree-node-switcher--hide`]: props.hide
              }
            ],
            onClick: props.onClick
          }, /* @__PURE__ */ vue.h("div", {
            class: `${clsPrefix}-tree-node-switcher__icon`
          }, /* @__PURE__ */ vue.h(NIconSwitchTransition, null, {
            default: () => {
              if (props.loading) {
                return /* @__PURE__ */ vue.h(NBaseLoading, {
                  clsPrefix,
                  key: "loading",
                  radius: 85,
                  strokeWidth: 20
                });
              }
              const { value: renderSwitcherIcon } = renderSwitcherIconRef;
              return renderSwitcherIcon ? renderSwitcherIcon() : /* @__PURE__ */ vue.h(NBaseIcon, {
                clsPrefix,
                key: "switcher"
              }, { default: () => /* @__PURE__ */ vue.h(SwitcherIcon, null) });
            }
          })));
        };
      }
    });

    var NTreeNodeCheckbox = vue.defineComponent({
      name: "NTreeNodeCheckbox",
      props: {
        clsPrefix: {
          type: String,
          required: true
        },
        right: Boolean,
        focusable: Boolean,
        disabled: Boolean,
        checked: Boolean,
        indeterminate: Boolean,
        onCheck: Function
      },
      setup(props) {
        const NTree = vue.inject(treeInjectionKey);
        function doCheck(value) {
          const { onCheck } = props;
          if (onCheck)
            return onCheck(value);
        }
        function handleUpdateValue(value) {
          if (props.indeterminate) {
            doCheck(false);
          } else {
            doCheck(value);
          }
        }
        return {
          handleUpdateValue,
          mergedTheme: NTree.mergedThemeRef
        };
      },
      render() {
        const {
          clsPrefix,
          mergedTheme,
          checked,
          indeterminate,
          disabled,
          focusable,
          handleUpdateValue
        } = this;
        return /* @__PURE__ */ vue.h("span", {
          class: [
            `${clsPrefix}-tree-node-checkbox`,
            this.right && `${clsPrefix}-tree-node-checkbox--right`
          ],
          "data-checkbox": true
        }, /* @__PURE__ */ vue.h(NCheckbox, {
          focusable,
          disabled,
          theme: mergedTheme.peers.Checkbox,
          themeOverrides: mergedTheme.peerOverrides.Checkbox,
          checked,
          indeterminate,
          onUpdateChecked: handleUpdateValue
        }));
      }
    });

    var NTreeNodeContent = vue.defineComponent({
      name: "TreeNodeContent",
      props: {
        clsPrefix: {
          type: String,
          required: true
        },
        disabled: Boolean,
        checked: Boolean,
        selected: Boolean,
        onClick: Function,
        onDragstart: Function,
        tmNode: {
          type: Object,
          required: true
        },
        nodeProps: Object
      },
      setup(props) {
        const { renderLabelRef, renderPrefixRef, renderSuffixRef, labelFieldRef } = vue.inject(treeInjectionKey);
        const selfRef = vue.ref(null);
        function doClick(e) {
          const { onClick } = props;
          if (onClick)
            onClick(e);
        }
        function handleClick(e) {
          doClick(e);
        }
        return {
          selfRef,
          renderLabel: renderLabelRef,
          renderPrefix: renderPrefixRef,
          renderSuffix: renderSuffixRef,
          labelField: labelFieldRef,
          handleClick
        };
      },
      render() {
        const {
          clsPrefix,
          labelField,
          nodeProps,
          checked = false,
          selected = false,
          renderLabel,
          renderPrefix,
          renderSuffix,
          handleClick,
          onDragstart,
          tmNode: {
            rawNode,
            rawNode: { prefix, suffix, [labelField]: label }
          }
        } = this;
        return /* @__PURE__ */ vue.h("span", {
          ...nodeProps,
          ref: "selfRef",
          class: [`${clsPrefix}-tree-node-content`, nodeProps?.class],
          onClick: handleClick,
          draggable: onDragstart === void 0 ? void 0 : true,
          onDragstart
        }, renderPrefix || prefix ? /* @__PURE__ */ vue.h("div", {
          class: `${clsPrefix}-tree-node-content__prefix`
        }, renderPrefix ? renderPrefix({
          option: rawNode,
          selected,
          checked
        }) : render$1(prefix)) : null, /* @__PURE__ */ vue.h("div", {
          class: `${clsPrefix}-tree-node-content__text`
        }, renderLabel ? renderLabel({
          option: rawNode,
          selected,
          checked
        }) : render$1(label)), renderSuffix || suffix ? /* @__PURE__ */ vue.h("div", {
          class: `${clsPrefix}-tree-node-content__suffix`
        }, renderSuffix ? renderSuffix({
          option: rawNode,
          selected,
          checked
        }) : render$1(suffix)) : null);
      }
    });

    function renderDropMark({
      position,
      offsetLevel,
      indent,
      el
    }) {
      const style = {
        position: "absolute",
        boxSizing: "border-box",
        right: 0
      };
      if (position === "inside") {
        style.left = 0;
        style.top = 0;
        style.bottom = 0;
        style.borderRadius = "inherit";
        style.boxShadow = "inset 0 0 0 2px var(--n-drop-mark-color)";
      } else {
        const cssPosition = position === "before" ? "top" : "bottom";
        style[cssPosition] = 0;
        style.left = `${el.offsetLeft + 6 - offsetLevel * indent}px`;
        style.height = "2px";
        style.backgroundColor = "var(--n-drop-mark-color)";
        style.transformOrigin = cssPosition;
        style.borderRadius = "1px";
        style.transform = position === "before" ? "translateY(-4px)" : "translateY(4px)";
      }
      return /* @__PURE__ */ vue.h("div", {
        style
      });
    }
    function defaultAllowDrop({
      dropPosition,
      node
    }) {
      if (node.isLeaf === false)
        return true;
      if (node.children) {
        return true;
      }
      return dropPosition !== "inside";
    }

    const TreeNode = vue.defineComponent({
      name: "TreeNode",
      props: {
        clsPrefix: {
          type: String,
          required: true
        },
        tmNode: {
          type: Object,
          required: true
        }
      },
      setup(props) {
        const NTree = vue.inject(treeInjectionKey);
        const {
          droppingNodeParentRef,
          droppingMouseNodeRef,
          draggingNodeRef,
          droppingPositionRef,
          droppingOffsetLevelRef,
          nodePropsRef,
          indentRef,
          blockLineRef,
          checkboxPlacementRef,
          checkOnClickRef
        } = NTree;
        const disabledRef = vue.computed(
          () => NTree.disabledRef.value || props.tmNode.disabled
        );
        const resolvedNodePropsRef = vue.computed(() => {
          const { value: nodeProps } = nodePropsRef;
          if (!nodeProps)
            return void 0;
          return nodeProps({ option: props.tmNode.rawNode });
        });
        const contentInstRef = vue.ref(null);
        const contentElRef = { value: null };
        vue.onMounted(() => {
          contentElRef.value = contentInstRef.value.$el;
        });
        function handleSwitcherClick() {
          const { tmNode } = props;
          if (!tmNode.isLeaf && !tmNode.shallowLoaded) {
            if (!NTree.loadingKeysRef.value.has(tmNode.key)) {
              NTree.loadingKeysRef.value.add(tmNode.key);
            } else {
              return;
            }
            const {
              onLoadRef: { value: onLoad }
            } = NTree;
            if (onLoad) {
              void onLoad(tmNode.rawNode).then(() => {
                NTree.handleSwitcherClick(tmNode);
              }).finally(() => {
                NTree.loadingKeysRef.value.delete(tmNode.key);
              });
            }
          } else {
            NTree.handleSwitcherClick(tmNode);
          }
        }
        const selectableRef = useMemo(
          () => !props.tmNode.disabled && NTree.selectableRef.value && (NTree.internalTreeSelect ? NTree.mergedCheckStrategyRef.value !== "child" || NTree.multipleRef.value && NTree.cascadeRef.value || props.tmNode.isLeaf : true)
        );
        const checkableRef = useMemo(
          () => NTree.checkableRef.value && (NTree.cascadeRef.value || NTree.mergedCheckStrategyRef.value !== "child" || props.tmNode.isLeaf)
        );
        const checkedRef = useMemo(
          () => NTree.displayedCheckedKeysRef.value.includes(props.tmNode.key)
        );
        const mergedCheckOnClickRef = useMemo(() => {
          const { value: checkable } = checkableRef;
          if (!checkable)
            return false;
          const { value: checkOnClick } = checkOnClickRef;
          if (typeof checkOnClick === "boolean") {
            return checkOnClick;
          }
          return checkOnClick(props.tmNode.rawNode);
        });
        function _handleClick(e) {
          const { value: expandOnClick } = NTree.expandOnClickRef;
          const { value: selectable } = selectableRef;
          const { value: mergedCheckOnClick } = mergedCheckOnClickRef;
          if (!selectable && !expandOnClick && !mergedCheckOnClick)
            return;
          if (happensIn(e, "checkbox") || happensIn(e, "switcher"))
            return;
          const { tmNode } = props;
          if (selectable) {
            NTree.handleSelect(tmNode);
          }
          if (expandOnClick && !tmNode.isLeaf) {
            handleSwitcherClick();
          }
          if (mergedCheckOnClick) {
            handleCheck(!checkedRef.value);
          }
        }
        function handleContentClick(e) {
          if (blockLineRef.value)
            return;
          if (!disabledRef.value)
            _handleClick(e);
          resolvedNodePropsRef.value?.onClick?.(e);
        }
        function handleLineClick(e) {
          if (!blockLineRef.value)
            return;
          if (!disabledRef.value) {
            _handleClick(e);
          }
          resolvedNodePropsRef.value?.onClick?.(e);
        }
        function handleCheck(checked) {
          NTree.handleCheck(props.tmNode, checked);
        }
        function handleDragStart(e) {
          NTree.handleDragStart({
            event: e,
            node: props.tmNode
          });
        }
        function handleDragEnter(e) {
          if (e.currentTarget !== e.target) {
            return;
          }
          NTree.handleDragEnter({
            event: e,
            node: props.tmNode
          });
        }
        function handleDragOver(e) {
          e.preventDefault();
          NTree.handleDragOver({
            event: e,
            node: props.tmNode
          });
        }
        function handleDragEnd(e) {
          NTree.handleDragEnd({
            event: e,
            node: props.tmNode
          });
        }
        function handleDragLeave(e) {
          if (e.currentTarget !== e.target) {
            return;
          }
          NTree.handleDragLeave({
            event: e,
            node: props.tmNode
          });
        }
        function handleDrop(e) {
          e.preventDefault();
          if (droppingPositionRef.value !== null) {
            NTree.handleDrop({
              event: e,
              node: props.tmNode,
              dropPosition: droppingPositionRef.value
            });
          }
        }
        return {
          showDropMark: useMemo(() => {
            const { value: draggingNode } = draggingNodeRef;
            if (!draggingNode)
              return;
            const { value: droppingPosition } = droppingPositionRef;
            if (!droppingPosition)
              return;
            const { value: droppingMouseNode } = droppingMouseNodeRef;
            if (!droppingMouseNode) {
              return;
            }
            const { tmNode } = props;
            if (tmNode.key === droppingMouseNode.key)
              return true;
            return false;
          }),
          showDropMarkAsParent: useMemo(() => {
            const { value: droppingNodeParent } = droppingNodeParentRef;
            if (!droppingNodeParent)
              return false;
            const { tmNode } = props;
            const { value: droppingPosition } = droppingPositionRef;
            if (droppingPosition === "before" || droppingPosition === "after") {
              return droppingNodeParent.key === tmNode.key;
            }
            return false;
          }),
          pending: useMemo(
            () => NTree.pendingNodeKeyRef.value === props.tmNode.key
          ),
          loading: useMemo(() => NTree.loadingKeysRef.value.has(props.tmNode.key)),
          highlight: useMemo(() => {
            return NTree.highlightKeySetRef.value?.has(props.tmNode.key);
          }),
          checked: checkedRef,
          indeterminate: useMemo(
            () => NTree.displayedIndeterminateKeysRef.value.includes(props.tmNode.key)
          ),
          selected: useMemo(
            () => NTree.mergedSelectedKeysRef.value.includes(props.tmNode.key)
          ),
          expanded: useMemo(
            () => NTree.mergedExpandedKeysRef.value.includes(props.tmNode.key)
          ),
          disabled: disabledRef,
          checkable: checkableRef,
          mergedCheckOnClick: mergedCheckOnClickRef,
          checkboxDisabled: vue.computed(() => !!props.tmNode.rawNode.checkboxDisabled),
          selectable: selectableRef,
          expandOnClick: NTree.expandOnClickRef,
          internalScrollable: NTree.internalScrollableRef,
          draggable: NTree.draggableRef,
          blockLine: blockLineRef,
          nodeProps: resolvedNodePropsRef,
          checkboxFocusable: NTree.internalCheckboxFocusableRef,
          droppingPosition: droppingPositionRef,
          droppingOffsetLevel: droppingOffsetLevelRef,
          indent: indentRef,
          checkboxPlacement: checkboxPlacementRef,
          contentInstRef,
          contentElRef,
          handleCheck,
          handleDrop,
          handleDragStart,
          handleDragEnter,
          handleDragOver,
          handleDragEnd,
          handleDragLeave,
          handleLineClick,
          handleContentClick,
          handleSwitcherClick
        };
      },
      render() {
        const {
          tmNode,
          clsPrefix,
          checkable,
          expandOnClick,
          selectable,
          selected,
          checked,
          highlight,
          draggable,
          blockLine,
          indent,
          disabled,
          pending,
          internalScrollable,
          nodeProps,
          checkboxPlacement
        } = this;
        const dragEventHandlers = draggable && !disabled ? {
          onDragenter: this.handleDragEnter,
          onDragleave: this.handleDragLeave,
          onDragend: this.handleDragEnd,
          onDrop: this.handleDrop,
          onDragover: this.handleDragOver
        } : void 0;
        const dataKey = internalScrollable ? createDataKey(tmNode.key) : void 0;
        const checkboxOnRight = checkboxPlacement === "right";
        const checkboxNode = checkable ? /* @__PURE__ */ vue.h(NTreeNodeCheckbox, {
          right: checkboxOnRight,
          focusable: this.checkboxFocusable,
          disabled: disabled || this.checkboxDisabled,
          clsPrefix,
          checked: this.checked,
          indeterminate: this.indeterminate,
          onCheck: this.handleCheck
        }) : null;
        return /* @__PURE__ */ vue.h("div", {
          class: `${clsPrefix}-tree-node-wrapper`,
          ...dragEventHandlers
        }, /* @__PURE__ */ vue.h("div", {
          ...blockLine ? nodeProps : void 0,
          class: [
            `${clsPrefix}-tree-node`,
            {
              [`${clsPrefix}-tree-node--selected`]: selected,
              [`${clsPrefix}-tree-node--checkable`]: checkable,
              [`${clsPrefix}-tree-node--highlight`]: highlight,
              [`${clsPrefix}-tree-node--pending`]: pending,
              [`${clsPrefix}-tree-node--disabled`]: disabled,
              [`${clsPrefix}-tree-node--selectable`]: selectable,
              [`${clsPrefix}-tree-node--clickable`]: selectable || expandOnClick || this.mergedCheckOnClick
            },
            nodeProps?.class
          ],
          "data-key": dataKey,
          draggable: draggable && blockLine,
          onClick: this.handleLineClick,
          onDragstart: draggable && blockLine && !disabled ? this.handleDragStart : void 0
        }, repeat(
          tmNode.level,
          /* @__PURE__ */ vue.h("div", {
            class: `${clsPrefix}-tree-node-indent`
          }, /* @__PURE__ */ vue.h("div", {
            style: { width: `${indent}px` }
          }))
        ), /* @__PURE__ */ vue.h(NTreeNodeSwitcher, {
          clsPrefix,
          expanded: this.expanded,
          loading: this.loading,
          hide: tmNode.isLeaf,
          onClick: this.handleSwitcherClick
        }), !checkboxOnRight ? checkboxNode : null, /* @__PURE__ */ vue.h(NTreeNodeContent, {
          ref: "contentInstRef",
          clsPrefix,
          checked,
          selected,
          onClick: this.handleContentClick,
          nodeProps: blockLine ? void 0 : nodeProps,
          onDragstart: draggable && !blockLine && !disabled ? this.handleDragStart : void 0,
          tmNode
        }), draggable ? this.showDropMark ? renderDropMark({
          el: this.contentElRef.value,
          position: this.droppingPosition,
          offsetLevel: this.droppingOffsetLevel,
          indent
        }) : this.showDropMarkAsParent ? renderDropMark({
          el: this.contentElRef.value,
          position: "inside",
          offsetLevel: this.droppingOffsetLevel,
          indent
        }) : null : null, checkboxOnRight ? checkboxNode : null));
      }
    });

    function traverse(nodes, childrenField, callback, callbackAfter) {
      nodes === null || nodes === void 0 ? void 0 : nodes.forEach(node => {
        callback(node);
        traverse(node[childrenField], childrenField, callback, callbackAfter);
        callbackAfter(node);
      });
    }

    function keysWithFilter(nodes, pattern, keyField, childrenField, filter) {
      const keys = /* @__PURE__ */new Set();
      const highlightKeySet = /* @__PURE__ */new Set();
      const path = [];
      traverse(nodes, childrenField, node => {
        path.push(node);

        if (filter(pattern, node)) {
          highlightKeySet.add(node[keyField]);

          for (let i = path.length - 2; i >= 0; --i) {
            if (!keys.has(path[i][keyField])) {
              keys.add(path[i][keyField]);
            } else {
              return;
            }
          }
        }
      }, () => {
        path.pop();
      });
      return {
        expandedKeys: Array.from(keys),
        highlightKeySet
      };
    }

    if (isBrowser$2 && Image) {
      const emptyImage2 = new Image();
      emptyImage2.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
    }
    function filterTree(tree, filter, pattern, keyField, childrenField) {
      const visitedTailKeys = /* @__PURE__ */new Set();
      const visitedNonTailKeys = /* @__PURE__ */new Set();
      const highlightKeySet = /* @__PURE__ */new Set();
      const expandedKeys = [];
      const filteredTree = [];
      const path = [];

      function visit(t) {
        t.forEach(n => {
          path.push(n);

          if (filter(pattern, n)) {
            visitedTailKeys.add(n[keyField]);
            highlightKeySet.add(n[keyField]);

            for (let i = path.length - 2; i >= 0; --i) {
              const key = path[i][keyField];

              if (!visitedNonTailKeys.has(key)) {
                visitedNonTailKeys.add(key);

                if (visitedTailKeys.has(key)) {
                  visitedTailKeys.delete(key);
                }
              } else {
                break;
              }
            }
          }

          const children = n[childrenField];

          if (children) {
            visit(children);
          }

          path.pop();
        });
      }

      visit(tree);

      function build(t, sibs) {
        t.forEach(n => {
          const key = n[keyField];
          const isVisitedTail = visitedTailKeys.has(key);
          const isVisitedNonTail = visitedNonTailKeys.has(key);
          if (!isVisitedTail && !isVisitedNonTail) return;
          const children = n[childrenField];

          if (children) {
            if (isVisitedTail) {
              sibs.push(n);
            } else {
              expandedKeys.push(key);
              const clonedNode = { ...n,
                [childrenField]: []
              };
              sibs.push(clonedNode);
              build(children, clonedNode[childrenField]);
            }
          } else {
            sibs.push(n);
          }
        });
      }

      build(tree, filteredTree);
      return {
        filteredTree,
        highlightKeySet,
        expandedKeys
      };
    }

    function useKeyboard({
      props,
      fNodesRef,
      mergedExpandedKeysRef,
      mergedSelectedKeysRef,
      handleSelect,
      handleSwitcherClick
    }) {
      const { value: mergedSelectedKeys } = mergedSelectedKeysRef;
      const treeSelectInjection = vue.inject(treeSelectInjectionKey, null);
      const pendingNodeKeyRef = treeSelectInjection ? treeSelectInjection.pendingNodeKeyRef : vue.ref(
        mergedSelectedKeys.length ? mergedSelectedKeys[mergedSelectedKeys.length - 1] : null
      );
      function handleKeydown(e) {
        if (!props.keyboard)
          return;
        const { value: pendingNodeKey } = pendingNodeKeyRef;
        if (pendingNodeKey === null) {
          if (e.key === "ArrowDown" || e.key === "ArrowUp") {
            e.preventDefault();
          }
          if (["ArrowDown", "ArrowUp", "ArrowLeft", "ArrowRight"].includes(e.key)) {
            if (pendingNodeKey === null) {
              const { value: fNodes } = fNodesRef;
              let fIndex = 0;
              while (fIndex < fNodes.length) {
                if (!fNodes[fIndex].disabled) {
                  pendingNodeKeyRef.value = fNodes[fIndex].key;
                  break;
                }
                fIndex += 1;
              }
            }
          }
        } else {
          const { value: fNodes } = fNodesRef;
          let fIndex = fNodes.findIndex((tmNode) => tmNode.key === pendingNodeKey);
          if (!~fIndex)
            return;
          if (e.key === "Enter") {
            handleSelect(fNodes[fIndex]);
          } else if (e.key === "ArrowDown") {
            e.preventDefault();
            fIndex += 1;
            while (fIndex < fNodes.length) {
              if (!fNodes[fIndex].disabled) {
                pendingNodeKeyRef.value = fNodes[fIndex].key;
                break;
              }
              fIndex += 1;
            }
          } else if (e.key === "ArrowUp") {
            e.preventDefault();
            fIndex -= 1;
            while (fIndex >= 0) {
              if (!fNodes[fIndex].disabled) {
                pendingNodeKeyRef.value = fNodes[fIndex].key;
                break;
              }
              fIndex -= 1;
            }
          } else if (e.key === "ArrowLeft") {
            const pendingNode = fNodes[fIndex];
            if (pendingNode.isLeaf || !mergedExpandedKeysRef.value.includes(pendingNodeKey)) {
              const parentTmNode = pendingNode.getParent();
              if (parentTmNode) {
                pendingNodeKeyRef.value = parentTmNode.key;
              }
            } else {
              handleSwitcherClick(pendingNode);
            }
          } else if (e.key === "ArrowRight") {
            const pendingNode = fNodes[fIndex];
            if (pendingNode.isLeaf)
              return;
            if (!mergedExpandedKeysRef.value.includes(pendingNodeKey)) {
              handleSwitcherClick(pendingNode);
            } else {
              fIndex += 1;
              while (fIndex < fNodes.length) {
                if (!fNodes[fIndex].disabled) {
                  pendingNodeKeyRef.value = fNodes[fIndex].key;
                  break;
                }
                fIndex += 1;
              }
            }
          }
        }
      }
      return {
        pendingNodeKeyRef,
        handleKeydown
      };
    }

    var MotionWrapper = vue.defineComponent({
      name: "TreeMotionWrapper",
      props: {
        clsPrefix: {
          type: String,
          required: true
        },
        height: Number,
        nodes: {
          type: Array,
          required: true
        },
        mode: {
          type: String,
          required: true
        },
        onAfterEnter: {
          type: Function,
          required: true
        }
      },
      render() {
        const { clsPrefix } = this;
        return /* @__PURE__ */ vue.h(NFadeInExpandTransition, {
          onAfterEnter: this.onAfterEnter,
          appear: true,
          reverse: this.mode === "collapse"
        }, {
          default: () => /* @__PURE__ */ vue.h("div", {
            class: [
              `${clsPrefix}-tree-motion-wrapper`,
              `${clsPrefix}-tree-motion-wrapper--${this.mode}`
            ],
            style: {
              height: pxfy(this.height)
            }
          }, this.nodes.map((node) => /* @__PURE__ */ vue.h(TreeNode, {
            clsPrefix,
            tmNode: node
          })))
        });
      }
    });

    var style$a = cB("tree", `
  font-size: var(--n-font-size);
  outline: none;
`, [c$1("ul, li", `
    margin: 0;
    padding: 0;
    list-style: none;
  `), c$1(">", [cB("tree-node", [c$1("&:first-child", {
      marginTop: 0
    })])]), cB("tree-node-indent", `
    flex-grow: 0;
    flex-shrink: 0;
    height: 0;
  `), cB("tree-motion-wrapper", [cM("expand", [fadeInHeightExpandTransition({
      duration: "0.2s"
    })]), cM("collapse", [fadeInHeightExpandTransition({
      duration: "0.2s",
      reverse: true
    })])]), cB("tree-node-wrapper", `
    box-sizing: border-box;
    padding: 3px 0;
  `), cB("tree-node", `
    position: relative;
    display: flex;
    border-radius: var(--n-node-border-radius);
    transition: background-color .3s var(--n-bezier);
  `, [cM("highlight", [cB("tree-node-content", [cE("text", {
      borderBottomColor: "var(--n-node-text-color-disabled)"
    })])]), cM("disabled", [cB("tree-node-content", `
        color: var(--n-node-text-color-disabled);
        cursor: not-allowed;
      `)]), cNotM("disabled", [cM("clickable", [cB("tree-node-content", `
          cursor: pointer;
        `)])])]), cM("block-node", [cB("tree-node-content", `
      flex-grow: 1;
      flex-shrink: 0;
    `)]), cNotM("block-line", [cB("tree-node", [cNotM("disabled", [cB("tree-node-content", [c$1("&:hover", {
      backgroundColor: "var(--n-node-color-hover)"
    })]), cM("selectable", [cB("tree-node-content", [c$1("&:active", {
      backgroundColor: "var(--n-node-color-pressed)"
    })])]), cM("pending", [cB("tree-node-content", `
            background-color: var(--n-node-color-hover);
          `)]), cM("selected", [cB("tree-node-content", {
      backgroundColor: "var(--n-node-color-active)"
    })])])])]), cM("block-line", [cB("tree-node", [cNotM("disabled", [c$1("&:hover", {
      backgroundColor: "var(--n-node-color-hover)"
    }), cM("pending", `
          background-color: var(--n-node-color-hover);
        `), cM("selectable", [cNotM("selected", [c$1("&:active", {
      backgroundColor: "var(--n-node-color-pressed)"
    })])]), cM("selected", {
      backgroundColor: "var(--n-node-color-active)"
    })]), cM("disabled", `
        cursor: not-allowed;
      `)])]), cB("tree-node-switcher", `
    cursor: pointer;
    display: inline-flex;
    flex-shrink: 0;
    height: 24px;
    width: 24px;
    align-items: center;
    justify-content: center;
    transition: transform .15s var(--n-bezier);
    vertical-align: bottom;
  `, [cE("icon", `
      position: relative;
      height: 14px;
      width: 14px;
      display: flex;
      color: var(--n-arrow-color);
      transition: color .3s var(--n-bezier);
      font-size: 14px;
    `, [cB("icon", [iconSwitchTransition()]), cB("base-loading", `
        color: var(--n-loading-color);
        position: absolute;
        left: 0;
        top: 0;
        right: 0;
        bottom: 0;
      `, [iconSwitchTransition()]), cB("base-icon", [iconSwitchTransition()])]), cM("hide", {
      visibility: "hidden"
    }), cM("expanded", {
      transform: "rotate(90deg)"
    })]), cB("tree-node-checkbox", `
    display: inline-flex;
    height: 24px;
    width: 16px;
    vertical-align: bottom;
    align-items: center;
    justify-content: center;
    margin-right: 4px;
  `, [cM("right", "margin-left: 4px;")]), cM("checkable", [cB("tree-node-content", `
      padding: 0 6px;
    `)]), cB("tree-node-content", `
    position: relative;
    display: inline-flex;
    align-items: center;
    min-height: 24px;
    box-sizing: border-box;
    line-height: 1.5;
    vertical-align: bottom;
    padding: 0 6px 0 4px;
    cursor: default;
    border-radius: var(--n-node-border-radius);
    text-decoration-color: #0000;
    text-decoration-line: underline;
    color: var(--n-node-text-color);
    transition:
      color .3s var(--n-bezier),
      text-decoration-color .3s var(--n-bezier),
      background-color .3s var(--n-bezier),
      border-color .3s var(--n-bezier);
  `, [c$1("&:last-child", {
      marginBottom: 0
    }), cE("prefix", `
      display: inline-flex;
      margin-right: 8px;
    `), cE("text", `
      border-bottom: 1px solid #0000;
      transition: border-color .3s var(--n-bezier);
      flex-grow:1;
    `), cE("suffix", `
      display: inline-flex;
    `)]), cE("empty", "margin: auto;")]);

    const ITEM_SIZE = 30;
    function createTreeMateOptions(keyField, childrenField, disabledField) {
      return {
        getIsGroup() {
          return false;
        },
        getKey(node) {
          return node[keyField];
        },
        getChildren(node) {
          return node[childrenField];
        },
        getDisabled(node) {
          return !!(node[disabledField] || node.checkboxDisabled);
        }
      };
    }
    const treeSharedProps = {
      allowCheckingNotLoaded: Boolean,
      filter: Function,
      defaultExpandAll: Boolean,
      expandedKeys: Array,
      keyField: {
        type: String,
        default: "key"
      },
      labelField: {
        type: String,
        default: "label"
      },
      childrenField: {
        type: String,
        default: "children"
      },
      disabledField: {
        type: String,
        default: "disabled"
      },
      defaultExpandedKeys: {
        type: Array,
        default: () => []
      },
      indeterminateKeys: Array,
      renderSwitcherIcon: Function,
      onUpdateIndeterminateKeys: [Function, Array],
      "onUpdate:indeterminateKeys": [Function, Array],
      onUpdateExpandedKeys: [Function, Array],
      "onUpdate:expandedKeys": [Function, Array]
    };
    const treeProps = {
      ...useTheme.props,
      accordion: Boolean,
      showIrrelevantNodes: { type: Boolean, default: true },
      data: {
        type: Array,
        default: () => []
      },
      expandOnDragenter: {
        type: Boolean,
        default: true
      },
      expandOnClick: Boolean,
      checkOnClick: {
        type: [Boolean, Function],
        default: false
      },
      cancelable: {
        type: Boolean,
        default: true
      },
      checkable: Boolean,
      draggable: Boolean,
      blockNode: Boolean,
      blockLine: Boolean,
      disabled: Boolean,
      checkedKeys: Array,
      defaultCheckedKeys: {
        type: Array,
        default: () => []
      },
      selectedKeys: Array,
      defaultSelectedKeys: {
        type: Array,
        default: () => []
      },
      multiple: Boolean,
      pattern: {
        type: String,
        default: ""
      },
      onLoad: Function,
      cascade: Boolean,
      selectable: {
        type: Boolean,
        default: true
      },
      indent: {
        type: Number,
        default: 16
      },
      allowDrop: {
        type: Function,
        default: defaultAllowDrop
      },
      animated: {
        type: Boolean,
        default: true
      },
      checkboxPlacement: {
        type: String,
        default: "left"
      },
      virtualScroll: Boolean,
      watchProps: Array,
      renderLabel: Function,
      renderPrefix: Function,
      renderSuffix: Function,
      nodeProps: Function,
      keyboard: {
        type: Boolean,
        default: true
      },
      onDragenter: [Function, Array],
      onDragleave: [Function, Array],
      onDragend: [Function, Array],
      onDragstart: [Function, Array],
      onDragover: [Function, Array],
      onDrop: [Function, Array],
      onUpdateCheckedKeys: [Function, Array],
      "onUpdate:checkedKeys": [Function, Array],
      onUpdateSelectedKeys: [Function, Array],
      "onUpdate:selectedKeys": [Function, Array],
      ...treeSharedProps,
      internalTreeSelect: Boolean,
      internalScrollable: Boolean,
      internalScrollablePadding: String,
      internalRenderEmpty: Function,
      internalHighlightKeySet: Object,
      internalUnifySelectCheck: Boolean,
      internalCheckboxFocusable: {
        type: Boolean,
        default: true
      },
      internalFocusable: {
        type: Boolean,
        default: true
      },
      checkStrategy: {
        type: String,
        default: "all"
      },
      leafOnly: Boolean
    };
    var NTree = vue.defineComponent({
      name: "Tree",
      props: treeProps,
      setup(props) {
        {
          vue.watchEffect(() => {
            if (props.leafOnly) {
              warnOnce(
                "tree",
                '`leaf-only` is deprecated, please use `check-strategy="child"` instead'
              );
            }
          });
        }
        const { mergedClsPrefixRef, inlineThemeDisabled, mergedRtlRef } = useConfig(props);
        const rtlEnabledRef = useRtl("Tree", mergedRtlRef, mergedClsPrefixRef);
        const themeRef = useTheme(
          "Tree",
          "-tree",
          style$a,
          treeLight$1,
          props,
          mergedClsPrefixRef
        );
        const selfElRef = vue.ref(null);
        const scrollbarInstRef = vue.ref(null);
        const virtualListInstRef = vue.ref(null);
        function getScrollContainer() {
          return virtualListInstRef.value?.listElRef;
        }
        function getScrollContent() {
          return virtualListInstRef.value?.itemsElRef;
        }
        const filteredTreeInfoRef = vue.computed(() => {
          const { pattern } = props;
          if (!pattern) {
            return {
              filteredTree: props.data,
              highlightKeySet: null,
              expandedKeys: void 0
            };
          }
          if (!pattern.length || !mergedFilterRef.value) {
            return {
              filteredTree: props.data,
              highlightKeySet: null,
              expandedKeys: void 0
            };
          }
          return filterTree(
            props.data,
            mergedFilterRef.value,
            pattern,
            props.keyField,
            props.childrenField
          );
        });
        const displayTreeMateRef = vue.computed(
          () => createTreeMate(
            props.showIrrelevantNodes ? props.data : filteredTreeInfoRef.value.filteredTree,
            createTreeMateOptions(
              props.keyField,
              props.childrenField,
              props.disabledField
            )
          )
        );
        const treeSelectInjection = vue.inject(treeSelectInjectionKey, null);
        const dataTreeMateRef = props.internalTreeSelect ? treeSelectInjection.dataTreeMate : displayTreeMateRef;
        const { watchProps } = props;
        const uncontrolledCheckedKeysRef = vue.ref([]);
        if (watchProps?.includes("defaultCheckedKeys")) {
          vue.watchEffect(() => {
            uncontrolledCheckedKeysRef.value = props.defaultCheckedKeys;
          });
        } else {
          uncontrolledCheckedKeysRef.value = props.defaultCheckedKeys;
        }
        const controlledCheckedKeysRef = vue.toRef(props, "checkedKeys");
        const mergedCheckedKeysRef = useMergedState(
          controlledCheckedKeysRef,
          uncontrolledCheckedKeysRef
        );
        const checkedStatusRef = vue.computed(() => {
          const value = dataTreeMateRef.value.getCheckedKeys(
            mergedCheckedKeysRef.value,
            {
              cascade: props.cascade,
              allowNotLoaded: props.allowCheckingNotLoaded
            }
          );
          return value;
        });
        const mergedCheckStrategyRef = vue.computed(
          () => props.leafOnly ? "child" : props.checkStrategy
        );
        const displayedCheckedKeysRef = vue.computed(() => {
          return checkedStatusRef.value.checkedKeys;
        });
        const displayedIndeterminateKeysRef = vue.computed(() => {
          const { indeterminateKeys } = props;
          if (indeterminateKeys !== void 0)
            return indeterminateKeys;
          return checkedStatusRef.value.indeterminateKeys;
        });
        const uncontrolledSelectedKeysRef = vue.ref([]);
        if (watchProps?.includes("defaultSelectedKeys")) {
          vue.watchEffect(() => {
            uncontrolledSelectedKeysRef.value = props.defaultSelectedKeys;
          });
        } else {
          uncontrolledSelectedKeysRef.value = props.defaultSelectedKeys;
        }
        const controlledSelectedKeysRef = vue.toRef(props, "selectedKeys");
        const mergedSelectedKeysRef = useMergedState(
          controlledSelectedKeysRef,
          uncontrolledSelectedKeysRef
        );
        const uncontrolledExpandedKeysRef = vue.ref([]);
        const initUncontrolledExpandedKeys = (keys) => {
          uncontrolledExpandedKeysRef.value = props.defaultExpandAll ? dataTreeMateRef.value.getNonLeafKeys() : keys === void 0 ? props.defaultExpandedKeys : keys;
        };
        if (watchProps?.includes("defaultExpandedKeys")) {
          vue.watchEffect(() => initUncontrolledExpandedKeys(void 0));
        } else {
          vue.watchEffect(() => initUncontrolledExpandedKeys(props.defaultExpandedKeys));
        }
        const controlledExpandedKeysRef = vue.toRef(props, "expandedKeys");
        const mergedExpandedKeysRef = useMergedState(
          controlledExpandedKeysRef,
          uncontrolledExpandedKeysRef
        );
        const fNodesRef = vue.computed(
          () => displayTreeMateRef.value.getFlattenedNodes(mergedExpandedKeysRef.value)
        );
        const { pendingNodeKeyRef, handleKeydown } = useKeyboard({
          props,
          mergedSelectedKeysRef,
          fNodesRef,
          mergedExpandedKeysRef,
          handleSelect,
          handleSwitcherClick
        });
        let expandTimerId = null;
        let nodeKeyToBeExpanded = null;
        const uncontrolledHighlightKeySetRef = vue.ref(/* @__PURE__ */ new Set());
        const controlledHighlightKeySetRef = vue.computed(() => {
          return props.internalHighlightKeySet || filteredTreeInfoRef.value.highlightKeySet;
        });
        const mergedHighlightKeySetRef = useMergedState(
          controlledHighlightKeySetRef,
          uncontrolledHighlightKeySetRef
        );
        const loadingKeysRef = vue.ref(/* @__PURE__ */ new Set());
        const expandedNonLoadingKeysRef = vue.computed(() => {
          return mergedExpandedKeysRef.value.filter(
            (key) => !loadingKeysRef.value.has(key)
          );
        });
        let dragStartX = 0;
        const draggingNodeRef = vue.ref(null);
        const droppingNodeRef = vue.ref(null);
        const droppingMouseNodeRef = vue.ref(null);
        const droppingPositionRef = vue.ref(null);
        const droppingOffsetLevelRef = vue.ref(0);
        const droppingNodeParentRef = vue.computed(() => {
          const { value: droppingNode } = droppingNodeRef;
          if (!droppingNode)
            return null;
          return droppingNode.parent;
        });
        const mergedFilterRef = vue.computed(() => {
          const { filter } = props;
          if (filter)
            return filter;
          const { labelField } = props;
          return (pattern, node) => {
            if (!pattern.length)
              return true;
            const label = node[labelField];
            if (typeof label === "string") {
              return label.toLowerCase().includes(pattern.toLowerCase());
            }
            return false;
          };
        });
        vue.watch(
          vue.toRef(props, "data"),
          () => {
            loadingKeysRef.value.clear();
            pendingNodeKeyRef.value = null;
            resetDndState();
          },
          {
            deep: false
          }
        );
        let memorizedExpandedKeys;
        vue.watch(vue.toRef(props, "pattern"), (value, oldValue) => {
          if (props.showIrrelevantNodes) {
            memorizedExpandedKeys = void 0;
            if (value) {
              const { expandedKeys: expandedKeysAfterChange, highlightKeySet } = keysWithFilter(
                props.data,
                props.pattern,
                props.keyField,
                props.childrenField,
                mergedFilterRef.value
              );
              uncontrolledHighlightKeySetRef.value = highlightKeySet;
              doUpdateExpandedKeys(
                expandedKeysAfterChange,
                getOptionsByKeys(expandedKeysAfterChange)
              );
            } else {
              uncontrolledHighlightKeySetRef.value = /* @__PURE__ */ new Set();
            }
          } else {
            if (!value.length) {
              if (memorizedExpandedKeys !== void 0) {
                doUpdateExpandedKeys(
                  memorizedExpandedKeys,
                  getOptionsByKeys(memorizedExpandedKeys)
                );
              }
            } else {
              if (!oldValue.length) {
                memorizedExpandedKeys = mergedExpandedKeysRef.value;
              }
              const { expandedKeys } = filteredTreeInfoRef.value;
              if (expandedKeys !== void 0) {
                doUpdateExpandedKeys(expandedKeys, getOptionsByKeys(expandedKeys));
              }
            }
          }
        });
        async function triggerLoading(node) {
          const { onLoad } = props;
          if (!onLoad) {
            {
              warn$2(
                "tree",
                "There is unloaded node in data but props.onLoad is not specified."
              );
            }
            return await Promise.resolve();
          }
          const { value: loadingKeys } = loadingKeysRef;
          return await new Promise((resolve) => {
            if (!loadingKeys.has(node.key)) {
              loadingKeys.add(node.key);
              onLoad(node.rawNode).then(() => {
                loadingKeys.delete(node.key);
                resolve();
              }).catch((loadError) => {
                console.error(loadError);
                resetDragExpandState();
              });
            }
          });
        }
        vue.watchEffect(() => {
          const { value: displayTreeMate } = displayTreeMateRef;
          if (!displayTreeMate)
            return;
          const { getNode } = displayTreeMate;
          mergedExpandedKeysRef.value?.forEach((key) => {
            const node = getNode(key);
            if (node && !node.shallowLoaded) {
              void triggerLoading(node);
            }
          });
        });
        const aipRef = vue.ref(false);
        const afNodesRef = vue.ref([]);
        vue.watch(expandedNonLoadingKeysRef, (value, prevValue) => {
          if (!props.animated) {
            void vue.nextTick(syncScrollbar);
            return;
          }
          const prevVSet = new Set(prevValue);
          let addedKey = null;
          let removedKey = null;
          for (const expandedKey of value) {
            if (!prevVSet.has(expandedKey)) {
              if (addedKey !== null)
                return;
              addedKey = expandedKey;
            }
          }
          const currentVSet = new Set(value);
          for (const expandedKey of prevValue) {
            if (!currentVSet.has(expandedKey)) {
              if (removedKey !== null)
                return;
              removedKey = expandedKey;
            }
          }
          if (addedKey === null && removedKey === null) {
            return;
          }
          const { virtualScroll } = props;
          const viewportHeight = (virtualScroll ? virtualListInstRef.value.listElRef : selfElRef.value).offsetHeight;
          const viewportItemCount = Math.ceil(viewportHeight / ITEM_SIZE) + 1;
          let baseExpandedKeys;
          if (addedKey !== null) {
            baseExpandedKeys = prevValue;
          }
          if (removedKey !== null) {
            if (baseExpandedKeys === void 0) {
              baseExpandedKeys = value;
            } else {
              baseExpandedKeys = baseExpandedKeys.filter(
                (key) => key !== removedKey
              );
            }
          }
          aipRef.value = true;
          afNodesRef.value = displayTreeMateRef.value.getFlattenedNodes(baseExpandedKeys);
          if (addedKey !== null) {
            const expandedNodeIndex = afNodesRef.value.findIndex(
              (node) => node.key === addedKey
            );
            if (~expandedNodeIndex) {
              const children = afNodesRef.value[expandedNodeIndex].children;
              if (children) {
                const expandedChildren = flatten$1(children, value);
                afNodesRef.value.splice(expandedNodeIndex + 1, 0, {
                  __motion: true,
                  mode: "expand",
                  height: virtualScroll ? expandedChildren.length * ITEM_SIZE : void 0,
                  nodes: virtualScroll ? expandedChildren.slice(0, viewportItemCount) : expandedChildren
                });
              }
            }
          }
          if (removedKey !== null) {
            const collapsedNodeIndex = afNodesRef.value.findIndex(
              (node) => node.key === removedKey
            );
            if (~collapsedNodeIndex) {
              const collapsedNodeChildren = afNodesRef.value[collapsedNodeIndex].children;
              if (!collapsedNodeChildren)
                return;
              aipRef.value = true;
              const collapsedChildren = flatten$1(collapsedNodeChildren, value);
              afNodesRef.value.splice(collapsedNodeIndex + 1, 0, {
                __motion: true,
                mode: "collapse",
                height: virtualScroll ? collapsedChildren.length * ITEM_SIZE : void 0,
                nodes: virtualScroll ? collapsedChildren.slice(0, viewportItemCount) : collapsedChildren
              });
            }
          }
        });
        const getFIndexRef = vue.computed(() => {
          return createIndexGetter(fNodesRef.value);
        });
        const mergedFNodesRef = vue.computed(() => {
          if (aipRef.value)
            return afNodesRef.value;
          else
            return fNodesRef.value;
        });
        function syncScrollbar() {
          const { value: scrollbarInst } = scrollbarInstRef;
          if (scrollbarInst)
            scrollbarInst.sync();
        }
        function handleAfterEnter() {
          aipRef.value = false;
          if (props.virtualScroll) {
            void vue.nextTick(syncScrollbar);
          }
        }
        function getOptionsByKeys(keys) {
          const { getNode } = dataTreeMateRef.value;
          return keys.map((key) => getNode(key)?.rawNode || null);
        }
        function doUpdateExpandedKeys(value, option) {
          const {
            "onUpdate:expandedKeys": _onUpdateExpandedKeys,
            onUpdateExpandedKeys
          } = props;
          uncontrolledExpandedKeysRef.value = value;
          if (_onUpdateExpandedKeys) {
            call(_onUpdateExpandedKeys, value, option);
          }
          if (onUpdateExpandedKeys) {
            call(onUpdateExpandedKeys, value, option);
          }
        }
        function doUpdateCheckedKeys(value, option) {
          const {
            "onUpdate:checkedKeys": _onUpdateCheckedKeys,
            onUpdateCheckedKeys
          } = props;
          uncontrolledCheckedKeysRef.value = value;
          if (onUpdateCheckedKeys) {
            call(onUpdateCheckedKeys, value, option);
          }
          if (_onUpdateCheckedKeys) {
            call(_onUpdateCheckedKeys, value, option);
          }
        }
        function doUpdateIndeterminateKeys(value, option) {
          const {
            "onUpdate:indeterminateKeys": _onUpdateIndeterminateKeys,
            onUpdateIndeterminateKeys
          } = props;
          if (_onUpdateIndeterminateKeys) {
            call(_onUpdateIndeterminateKeys, value, option);
          }
          if (onUpdateIndeterminateKeys) {
            call(onUpdateIndeterminateKeys, value, option);
          }
        }
        function doUpdateSelectedKeys(value, option) {
          const {
            "onUpdate:selectedKeys": _onUpdateSelectedKeys,
            onUpdateSelectedKeys
          } = props;
          uncontrolledSelectedKeysRef.value = value;
          if (onUpdateSelectedKeys) {
            call(onUpdateSelectedKeys, value, option);
          }
          if (_onUpdateSelectedKeys) {
            call(_onUpdateSelectedKeys, value, option);
          }
        }
        function doDragEnter(info) {
          const { onDragenter } = props;
          if (onDragenter)
            call(onDragenter, info);
        }
        function doDragLeave(info) {
          const { onDragleave } = props;
          if (onDragleave)
            call(onDragleave, info);
        }
        function doDragEnd(info) {
          const { onDragend } = props;
          if (onDragend)
            call(onDragend, info);
        }
        function doDragStart(info) {
          const { onDragstart } = props;
          if (onDragstart)
            call(onDragstart, info);
        }
        function doDragOver(info) {
          const { onDragover } = props;
          if (onDragover)
            call(onDragover, info);
        }
        function doDrop(info) {
          const { onDrop } = props;
          if (onDrop)
            call(onDrop, info);
        }
        function resetDndState() {
          resetDragState();
          resetDropState();
        }
        function resetDragState() {
          draggingNodeRef.value = null;
        }
        function resetDropState() {
          droppingOffsetLevelRef.value = 0;
          droppingNodeRef.value = null;
          droppingMouseNodeRef.value = null;
          droppingPositionRef.value = null;
          resetDragExpandState();
        }
        function resetDragExpandState() {
          if (expandTimerId) {
            window.clearTimeout(expandTimerId);
            expandTimerId = null;
          }
          nodeKeyToBeExpanded = null;
        }
        function handleCheck(node, checked) {
          if (props.disabled || node.disabled) {
            return;
          }
          if (props.internalUnifySelectCheck && !props.multiple) {
            handleSelect(node);
            return;
          }
          const { checkedKeys, indeterminateKeys } = dataTreeMateRef.value[checked ? "check" : "uncheck"](node.key, displayedCheckedKeysRef.value, {
            cascade: props.cascade,
            checkStrategy: mergedCheckStrategyRef.value,
            allowNotLoaded: props.allowCheckingNotLoaded
          });
          doUpdateCheckedKeys(checkedKeys, getOptionsByKeys(checkedKeys));
          doUpdateIndeterminateKeys(
            indeterminateKeys,
            getOptionsByKeys(indeterminateKeys)
          );
        }
        function toggleExpand(node) {
          if (props.disabled)
            return;
          const { key } = node;
          const { value: mergedExpandedKeys } = mergedExpandedKeysRef;
          const index = mergedExpandedKeys.findIndex(
            (expandNodeId) => expandNodeId === key
          );
          if (~index) {
            const expandedKeysAfterChange = Array.from(mergedExpandedKeys);
            expandedKeysAfterChange.splice(index, 1);
            doUpdateExpandedKeys(
              expandedKeysAfterChange,
              getOptionsByKeys(expandedKeysAfterChange)
            );
          } else {
            const nodeToBeExpanded = displayTreeMateRef.value.getNode(key);
            if (!nodeToBeExpanded || nodeToBeExpanded.isLeaf) {
              return;
            }
            let nextKeys;
            if (props.accordion) {
              const siblingKeySet = new Set(
                node.siblings.map(({ key: key2 }) => key2)
              );
              nextKeys = mergedExpandedKeys.filter((expandedKey) => {
                return !siblingKeySet.has(expandedKey);
              });
              nextKeys.push(key);
            } else {
              nextKeys = mergedExpandedKeys.concat(key);
            }
            doUpdateExpandedKeys(nextKeys, getOptionsByKeys(nextKeys));
          }
        }
        function handleSwitcherClick(node) {
          if (props.disabled || aipRef.value)
            return;
          toggleExpand(node);
        }
        function handleSelect(node) {
          if (props.disabled || !props.selectable) {
            return;
          }
          pendingNodeKeyRef.value = node.key;
          if (props.internalUnifySelectCheck) {
            const {
              value: { checkedKeys, indeterminateKeys }
            } = checkedStatusRef;
            if (props.multiple) {
              handleCheck(
                node,
                !(checkedKeys.includes(node.key) || indeterminateKeys.includes(node.key))
              );
            } else {
              doUpdateCheckedKeys([node.key], getOptionsByKeys([node.key]));
            }
          }
          if (props.multiple) {
            const selectedKeys = Array.from(mergedSelectedKeysRef.value);
            const index = selectedKeys.findIndex((key) => key === node.key);
            if (~index) {
              if (props.cancelable) {
                selectedKeys.splice(index, 1);
              }
            } else if (!~index) {
              selectedKeys.push(node.key);
            }
            doUpdateSelectedKeys(selectedKeys, getOptionsByKeys(selectedKeys));
          } else {
            const selectedKeys = mergedSelectedKeysRef.value;
            if (selectedKeys.includes(node.key)) {
              if (props.cancelable) {
                doUpdateSelectedKeys([], []);
              }
            } else {
              doUpdateSelectedKeys([node.key], getOptionsByKeys([node.key]));
            }
          }
        }
        function expandDragEnterNode(node) {
          if (expandTimerId) {
            window.clearTimeout(expandTimerId);
            expandTimerId = null;
          }
          if (node.isLeaf)
            return;
          nodeKeyToBeExpanded = node.key;
          const expand = () => {
            if (nodeKeyToBeExpanded !== node.key)
              return;
            const { value: droppingMouseNode } = droppingMouseNodeRef;
            if (droppingMouseNode && droppingMouseNode.key === node.key && !mergedExpandedKeysRef.value.includes(node.key)) {
              const nextKeys = mergedExpandedKeysRef.value.concat(node.key);
              doUpdateExpandedKeys(nextKeys, getOptionsByKeys(nextKeys));
            }
            expandTimerId = null;
            nodeKeyToBeExpanded = null;
          };
          if (!node.shallowLoaded) {
            expandTimerId = window.setTimeout(() => {
              void triggerLoading(node).then(() => {
                expand();
              });
            }, 1e3);
          } else {
            expandTimerId = window.setTimeout(() => {
              expand();
            }, 1e3);
          }
        }
        function handleDragEnter({ event, node }) {
          if (!props.draggable || props.disabled || node.disabled)
            return;
          handleDragOver({ event, node }, false);
          doDragEnter({ event, node: node.rawNode });
        }
        function handleDragLeave({ event, node }) {
          if (!props.draggable || props.disabled || node.disabled)
            return;
          doDragLeave({ event, node: node.rawNode });
        }
        function handleDragLeaveTree(e) {
          if (e.target !== e.currentTarget)
            return;
          resetDropState();
        }
        function handleDragEnd({ event, node }) {
          resetDndState();
          if (!props.draggable || props.disabled || node.disabled)
            return;
          doDragEnd({ event, node: node.rawNode });
        }
        function handleDragStart({ event, node }) {
          if (!props.draggable || props.disabled || node.disabled)
            return;
          dragStartX = event.clientX;
          draggingNodeRef.value = node;
          doDragStart({ event, node: node.rawNode });
        }
        function handleDragOver({ event, node }, emit = true) {
          if (!props.draggable || props.disabled || node.disabled)
            return;
          const { value: draggingNode } = draggingNodeRef;
          if (!draggingNode)
            return;
          const { allowDrop, indent } = props;
          if (emit)
            doDragOver({ event, node: node.rawNode });
          const el = event.currentTarget;
          const { height: elOffsetHeight, top: elClientTop } = el.getBoundingClientRect();
          const eventOffsetY = event.clientY - elClientTop;
          let mousePosition;
          const allowDropInside = allowDrop({
            node: node.rawNode,
            dropPosition: "inside",
            phase: "drag"
          });
          if (allowDropInside) {
            if (eventOffsetY <= 8) {
              mousePosition = "before";
            } else if (eventOffsetY >= elOffsetHeight - 8) {
              mousePosition = "after";
            } else {
              mousePosition = "inside";
            }
          } else {
            if (eventOffsetY <= elOffsetHeight / 2) {
              mousePosition = "before";
            } else {
              mousePosition = "after";
            }
          }
          const { value: getFindex } = getFIndexRef;
          let finalDropNode;
          let finalDropPosition;
          const hoverNodeFIndex = getFindex(node.key);
          if (hoverNodeFIndex === null) {
            resetDropState();
            return;
          }
          let mouseAtExpandedNonLeafNode = false;
          if (mousePosition === "inside") {
            finalDropNode = node;
            finalDropPosition = "inside";
          } else {
            if (mousePosition === "before") {
              if (node.isFirstChild) {
                finalDropNode = node;
                finalDropPosition = "before";
              } else {
                finalDropNode = fNodesRef.value[hoverNodeFIndex - 1];
                finalDropPosition = "after";
              }
            } else {
              finalDropNode = node;
              finalDropPosition = "after";
            }
          }
          if (!finalDropNode.isLeaf && mergedExpandedKeysRef.value.includes(finalDropNode.key)) {
            mouseAtExpandedNonLeafNode = true;
            if (finalDropPosition === "after") {
              finalDropNode = fNodesRef.value[hoverNodeFIndex + 1];
              if (!finalDropNode) {
                finalDropNode = node;
                finalDropPosition = "inside";
              } else {
                finalDropPosition = "before";
              }
            }
          }
          const droppingMouseNode = finalDropNode;
          droppingMouseNodeRef.value = droppingMouseNode;
          if (!mouseAtExpandedNonLeafNode && draggingNode.isLastChild && draggingNode.key === finalDropNode.key) {
            finalDropPosition = "after";
          }
          if (finalDropPosition === "after") {
            let offset = dragStartX - event.clientX;
            let offsetLevel = 0;
            while (offset >= indent / 2 && finalDropNode.parent !== null && finalDropNode.isLastChild && offsetLevel < 1) {
              offset -= indent;
              offsetLevel += 1;
              finalDropNode = finalDropNode.parent;
            }
            droppingOffsetLevelRef.value = offsetLevel;
          } else {
            droppingOffsetLevelRef.value = 0;
          }
          if (draggingNode.contains(finalDropNode) || finalDropPosition === "inside" && draggingNode.parent?.key === finalDropNode.key) {
            if (draggingNode.key === droppingMouseNode.key && draggingNode.key === finalDropNode.key) ; else {
              resetDropState();
              return;
            }
          }
          if (!allowDrop({
            node: finalDropNode.rawNode,
            dropPosition: finalDropPosition,
            phase: "drag"
          })) {
            resetDropState();
            return;
          }
          if (draggingNode.key === finalDropNode.key) {
            resetDragExpandState();
          } else {
            if (nodeKeyToBeExpanded !== finalDropNode.key) {
              if (finalDropPosition === "inside") {
                if (props.expandOnDragenter) {
                  expandDragEnterNode(finalDropNode);
                  if (!finalDropNode.shallowLoaded && nodeKeyToBeExpanded !== finalDropNode.key) {
                    resetDndState();
                    return;
                  }
                } else {
                  if (!finalDropNode.shallowLoaded) {
                    resetDndState();
                    return;
                  }
                }
              } else {
                resetDragExpandState();
              }
            } else {
              if (finalDropPosition !== "inside") {
                resetDragExpandState();
              }
            }
          }
          droppingPositionRef.value = finalDropPosition;
          droppingNodeRef.value = finalDropNode;
        }
        function handleDrop({ event, node, dropPosition }) {
          if (!props.draggable || props.disabled || node.disabled) {
            return;
          }
          const { value: draggingNode } = draggingNodeRef;
          const { value: droppingNode } = droppingNodeRef;
          const { value: droppingPosition } = droppingPositionRef;
          if (!draggingNode || !droppingNode || !droppingPosition) {
            return;
          }
          if (!props.allowDrop({
            node: droppingNode.rawNode,
            dropPosition: droppingPosition,
            phase: "drag"
          })) {
            return;
          }
          if (draggingNode.key === droppingNode.key) {
            return;
          }
          if (droppingPosition === "before") {
            const nextNode = draggingNode.getNext({ includeDisabled: true });
            if (nextNode) {
              if (nextNode.key === droppingNode.key) {
                resetDropState();
                return;
              }
            }
          }
          if (droppingPosition === "after") {
            const prevNode = draggingNode.getPrev({ includeDisabled: true });
            if (prevNode) {
              if (prevNode.key === droppingNode.key) {
                resetDropState();
                return;
              }
            }
          }
          doDrop({
            event,
            node: droppingNode.rawNode,
            dragNode: draggingNode.rawNode,
            dropPosition
          });
          resetDndState();
        }
        function handleScroll() {
          syncScrollbar();
        }
        function handleResize() {
          syncScrollbar();
        }
        function handleFocusout(e) {
          if (props.virtualScroll || props.internalScrollable) {
            const { value: scrollbarInst } = scrollbarInstRef;
            if (scrollbarInst?.containerRef?.contains(e.relatedTarget)) {
              return;
            }
            pendingNodeKeyRef.value = null;
          } else {
            const { value: selfEl } = selfElRef;
            if (selfEl?.contains(e.relatedTarget))
              return;
            pendingNodeKeyRef.value = null;
          }
        }
        vue.watch(pendingNodeKeyRef, (value) => {
          if (value === null)
            return;
          if (props.virtualScroll) {
            virtualListInstRef.value?.scrollTo({ key: value });
          } else if (props.internalScrollable) {
            const { value: scrollbarInst } = scrollbarInstRef;
            if (scrollbarInst === null)
              return;
            const targetEl = scrollbarInst.contentRef?.querySelector(
              `[data-key="${createDataKey(value)}"]`
            );
            if (!targetEl)
              return;
            scrollbarInst.scrollTo({
              el: targetEl
            });
          }
        });
        vue.provide(treeInjectionKey, {
          loadingKeysRef,
          highlightKeySetRef: mergedHighlightKeySetRef,
          displayedCheckedKeysRef,
          displayedIndeterminateKeysRef,
          mergedSelectedKeysRef,
          mergedExpandedKeysRef,
          mergedThemeRef: themeRef,
          mergedCheckStrategyRef,
          nodePropsRef: vue.toRef(props, "nodeProps"),
          disabledRef: vue.toRef(props, "disabled"),
          checkableRef: vue.toRef(props, "checkable"),
          selectableRef: vue.toRef(props, "selectable"),
          expandOnClickRef: vue.toRef(props, "expandOnClick"),
          onLoadRef: vue.toRef(props, "onLoad"),
          draggableRef: vue.toRef(props, "draggable"),
          blockLineRef: vue.toRef(props, "blockLine"),
          indentRef: vue.toRef(props, "indent"),
          cascadeRef: vue.toRef(props, "cascade"),
          checkOnClickRef: vue.toRef(props, "checkOnClick"),
          checkboxPlacementRef: props.checkboxPlacement,
          droppingMouseNodeRef,
          droppingNodeParentRef,
          draggingNodeRef,
          droppingPositionRef,
          droppingOffsetLevelRef,
          fNodesRef,
          pendingNodeKeyRef,
          internalScrollableRef: vue.toRef(props, "internalScrollable"),
          internalCheckboxFocusableRef: vue.toRef(props, "internalCheckboxFocusable"),
          internalTreeSelect: props.internalTreeSelect,
          renderLabelRef: vue.toRef(props, "renderLabel"),
          renderPrefixRef: vue.toRef(props, "renderPrefix"),
          renderSuffixRef: vue.toRef(props, "renderSuffix"),
          renderSwitcherIconRef: vue.toRef(props, "renderSwitcherIcon"),
          labelFieldRef: vue.toRef(props, "labelField"),
          multipleRef: vue.toRef(props, "multiple"),
          handleSwitcherClick,
          handleDragEnd,
          handleDragEnter,
          handleDragLeave,
          handleDragStart,
          handleDrop,
          handleDragOver,
          handleSelect,
          handleCheck
        });
        function scrollTo(options) {
          virtualListInstRef.value?.scrollTo(options);
        }
        const exposedMethods = {
          handleKeydown,
          scrollTo
        };
        const cssVarsRef = vue.computed(() => {
          const {
            common: { cubicBezierEaseInOut },
            self: {
              fontSize,
              nodeBorderRadius,
              nodeColorHover,
              nodeColorPressed,
              nodeColorActive,
              arrowColor,
              loadingColor,
              nodeTextColor,
              nodeTextColorDisabled,
              dropMarkColor
            }
          } = themeRef.value;
          return {
            "--n-arrow-color": arrowColor,
            "--n-loading-color": loadingColor,
            "--n-bezier": cubicBezierEaseInOut,
            "--n-font-size": fontSize,
            "--n-node-border-radius": nodeBorderRadius,
            "--n-node-color-active": nodeColorActive,
            "--n-node-color-hover": nodeColorHover,
            "--n-node-color-pressed": nodeColorPressed,
            "--n-node-text-color": nodeTextColor,
            "--n-node-text-color-disabled": nodeTextColorDisabled,
            "--n-drop-mark-color": dropMarkColor
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("tree", void 0, cssVarsRef, props) : void 0;
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          mergedTheme: themeRef,
          rtlEnabled: rtlEnabledRef,
          fNodes: mergedFNodesRef,
          aip: aipRef,
          selfElRef,
          virtualListInstRef,
          scrollbarInstRef,
          handleFocusout,
          handleDragLeaveTree,
          handleScroll,
          getScrollContainer,
          getScrollContent,
          handleAfterEnter,
          handleResize,
          handleKeydown: exposedMethods.handleKeydown,
          scrollTo: exposedMethods.scrollTo,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender
        };
      },
      render() {
        const { fNodes, internalRenderEmpty } = this;
        if (!fNodes.length && internalRenderEmpty) {
          return internalRenderEmpty();
        }
        const {
          mergedClsPrefix,
          blockNode,
          blockLine,
          draggable,
          disabled,
          internalFocusable,
          checkable,
          handleKeydown,
          rtlEnabled,
          handleFocusout
        } = this;
        const mergedFocusable = internalFocusable && !disabled;
        const tabindex = mergedFocusable ? "0" : void 0;
        const treeClass = [
          `${mergedClsPrefix}-tree`,
          rtlEnabled && `${mergedClsPrefix}-tree--rtl`,
          checkable && `${mergedClsPrefix}-tree--checkable`,
          (blockLine || blockNode) && `${mergedClsPrefix}-tree--block-node`,
          blockLine && `${mergedClsPrefix}-tree--block-line`
        ];
        const createNode = (tmNode) => {
          return "__motion" in tmNode ? /* @__PURE__ */ vue.h(MotionWrapper, {
            height: tmNode.height,
            nodes: tmNode.nodes,
            clsPrefix: mergedClsPrefix,
            mode: tmNode.mode,
            onAfterEnter: this.handleAfterEnter
          }) : /* @__PURE__ */ vue.h(TreeNode, {
            key: tmNode.key,
            tmNode,
            clsPrefix: mergedClsPrefix
          });
        };
        if (this.virtualScroll) {
          const { mergedTheme, internalScrollablePadding } = this;
          const padding = getMargin(internalScrollablePadding || "0");
          return /* @__PURE__ */ vue.h(XScrollbar, {
            ref: "scrollbarInstRef",
            onDragleave: draggable ? this.handleDragLeaveTree : void 0,
            container: this.getScrollContainer,
            content: this.getScrollContent,
            class: treeClass,
            theme: mergedTheme.peers.Scrollbar,
            themeOverrides: mergedTheme.peerOverrides.Scrollbar,
            tabindex,
            onKeydown: mergedFocusable ? handleKeydown : void 0,
            onFocusout: mergedFocusable ? handleFocusout : void 0
          }, {
            default: () => {
              this.onRender?.();
              return /* @__PURE__ */ vue.h(VVirtualList, {
                ref: "virtualListInstRef",
                items: this.fNodes,
                itemSize: ITEM_SIZE,
                ignoreItemResize: this.aip,
                paddingTop: padding.top,
                paddingBottom: padding.bottom,
                class: this.themeClass,
                style: [
                  this.cssVars,
                  {
                    paddingLeft: padding.left,
                    paddingRight: padding.right
                  }
                ],
                onScroll: this.handleScroll,
                onResize: this.handleResize,
                showScrollbar: false,
                itemResizable: true
              }, {
                default: ({ item }) => createNode(item)
              });
            }
          });
        }
        const { internalScrollable } = this;
        treeClass.push(this.themeClass);
        this.onRender?.();
        if (internalScrollable) {
          return /* @__PURE__ */ vue.h(XScrollbar, {
            class: treeClass,
            tabindex,
            onKeydown: mergedFocusable ? handleKeydown : void 0,
            onFocusout: mergedFocusable ? handleFocusout : void 0,
            style: this.cssVars,
            contentStyle: { padding: this.internalScrollablePadding }
          }, {
            default: () => /* @__PURE__ */ vue.h("div", {
              onDragleave: draggable ? this.handleDragLeaveTree : void 0,
              ref: "selfElRef"
            }, this.fNodes.map(createNode))
          });
        } else {
          return /* @__PURE__ */ vue.h("div", {
            class: treeClass,
            tabindex,
            ref: "selfElRef",
            style: this.cssVars,
            onKeydown: mergedFocusable ? handleKeydown : void 0,
            onFocusout: mergedFocusable ? handleFocusout : void 0,
            onDragleave: draggable ? this.handleDragLeaveTree : void 0
          }, !fNodes.length ? resolveSlot(this.$slots.empty, () => [
            /* @__PURE__ */ vue.h(NEmpty, {
              class: `${mergedClsPrefix}-tree__empty`,
              theme: this.mergedTheme.peers.Empty,
              themeOverrides: this.mergedTheme.peerOverrides.Empty
            })
          ]) : fNodes.map(createNode));
        }
      }
    });

    function treeOption2SelectOption(tmNode, labelField) {
      const {
        rawNode
      } = tmNode;
      return { ...rawNode,
        label: rawNode[labelField],
        value: tmNode.key
      };
    }
    function treeOption2SelectOptionWithPath(tmNode, path, separator, labelField) {
      const {
        rawNode
      } = tmNode;
      return { ...rawNode,
        value: tmNode.key,
        label: path.map(v => v.rawNode[labelField]).join(separator)
      };
    }

    var style$9 = c$1([cB("tree-select", `
    z-index: auto;
    outline: none;
    width: 100%;
    position: relative;
  `), cB("tree-select-menu", `
    position: relative;
    overflow: hidden;
    margin: 4px 0;
    transition: box-shadow .3s var(--n-bezier), background-color .3s var(--n-bezier);
    border-radius: var(--n-menu-border-radius);
    box-shadow: var(--n-menu-box-shadow);
    background-color: var(--n-menu-color);
    outline: none;
  `, [cB("tree", "max-height: var(--n-menu-height);"), cE("empty", `
      display: flex;
      padding: 12px 32px;
      flex: 1;
      justify-content: center;
    `), cE("action", `
      padding: var(--n-action-padding);
      transition:
        color .3s var(--n-bezier);
        border-color .3s var(--n-bezier);
      border-top: 1px solid var(--n-action-divider-color);
      color: var(--n-action-text-color);
    `), fadeInScaleUpTransition()])]);

    const treeSelectProps = {
      ...useTheme.props,
      bordered: {
        type: Boolean,
        default: true
      },
      cascade: Boolean,
      checkable: Boolean,
      clearable: Boolean,
      clearFilterAfterSelect: {
        type: Boolean,
        default: true
      },
      consistentMenuWidth: {
        type: Boolean,
        default: true
      },
      defaultShow: Boolean,
      defaultValue: {
        type: [String, Number, Array],
        default: null
      },
      disabled: {
        type: Boolean,
        default: void 0
      },
      filterable: Boolean,
      checkStrategy: {
        type: String,
        default: "all"
      },
      loading: Boolean,
      maxTagCount: [String, Number],
      multiple: Boolean,
      showPath: Boolean,
      separator: {
        type: String,
        default: " / "
      },
      options: {
        type: Array,
        default: () => []
      },
      placeholder: String,
      placement: {
        type: String,
        default: "bottom-start"
      },
      show: {
        type: Boolean,
        default: void 0
      },
      size: String,
      value: [String, Number, Array],
      to: useAdjustedTo.propTo,
      menuProps: Object,
      virtualScroll: {
        type: Boolean,
        default: true
      },
      status: String,
      renderTag: Function,
      ...treeSharedProps,
      renderLabel: Function,
      renderPrefix: Function,
      renderSuffix: Function,
      nodeProps: Function,
      onBlur: Function,
      onFocus: Function,
      onLoad: Function,
      onUpdateShow: [Function, Array],
      onUpdateValue: [Function, Array],
      "onUpdate:value": [Function, Array],
      "onUpdate:show": [Function, Array],
      leafOnly: Boolean
    };
    var TreeSelect = vue.defineComponent({
      name: "TreeSelect",
      props: treeSelectProps,
      setup(props) {
        {
          vue.watchEffect(() => {
            if (props.leafOnly) {
              warnOnce(
                "tree-select",
                '`leaf-only` is deprecated, please use `check-strategy="child"` instead.'
              );
            }
          });
        }
        const followerInstRef = vue.ref(null);
        const triggerInstRef = vue.ref(null);
        const treeInstRef = vue.ref(null);
        const menuElRef = vue.ref(null);
        const { mergedClsPrefixRef, namespaceRef, inlineThemeDisabled } = useConfig(props);
        const { localeRef } = useLocale("Select");
        const {
          mergedSizeRef,
          mergedDisabledRef,
          mergedStatusRef,
          nTriggerFormBlur,
          nTriggerFormChange,
          nTriggerFormFocus,
          nTriggerFormInput
        } = useFormItem(props);
        const uncontrolledValueRef = vue.ref(props.defaultValue);
        const controlledValueRef = vue.toRef(props, "value");
        const mergedValueRef = useMergedState(
          controlledValueRef,
          uncontrolledValueRef
        );
        const uncontrolledShowRef = vue.ref(props.defaultShow);
        const controlledShowRef = vue.toRef(props, "show");
        const mergedShowRef = useMergedState(controlledShowRef, uncontrolledShowRef);
        const patternRef = vue.ref("");
        const mergedFilterRef = vue.computed(() => {
          const { filter } = props;
          if (filter)
            return filter;
          const { labelField } = props;
          return (pattern, node) => {
            if (!pattern.length)
              return true;
            return node[labelField].toLowerCase().includes(pattern.toLowerCase());
          };
        });
        const dataTreeMateRef = vue.computed(
          () => createTreeMate(
            props.options,
            createTreeMateOptions(
              props.keyField,
              props.childrenField,
              props.disabledField
            )
          )
        );
        const { value: initMergedValue } = mergedValueRef;
        const pendingNodeKeyRef = vue.ref(
          props.checkable ? null : Array.isArray(initMergedValue) && initMergedValue.length ? initMergedValue[initMergedValue.length - 1] : null
        );
        const mergedCascadeRef = vue.computed(() => {
          return props.multiple && props.cascade && props.checkable;
        });
        const uncontrolledExpandedKeysRef = vue.ref(
          props.defaultExpandAll ? void 0 : props.defaultExpandedKeys || props.expandedKeys
        );
        const controlledExpandedKeysRef = vue.toRef(props, "expandedKeys");
        const mergedExpandedKeysRef = useMergedState(
          controlledExpandedKeysRef,
          uncontrolledExpandedKeysRef
        );
        const focusedRef = vue.ref(false);
        const mergedPlaceholderRef = vue.computed(() => {
          const { placeholder } = props;
          if (placeholder !== void 0)
            return placeholder;
          return localeRef.value.placeholder;
        });
        const treeSelectedKeysRef = vue.computed(() => {
          if (props.checkable)
            return [];
          return treeCheckedKeysRef.value;
        });
        const treeCheckedKeysRef = vue.computed(() => {
          const { value: mergedValue } = mergedValueRef;
          if (props.multiple) {
            if (Array.isArray(mergedValue))
              return mergedValue;
            else
              return [];
          } else {
            if (mergedValue === null || Array.isArray(mergedValue))
              return [];
            else
              return [mergedValue];
          }
        });
        const selectedOptionRef = vue.computed(() => {
          const { multiple, showPath, separator, labelField } = props;
          if (multiple)
            return null;
          const { value: mergedValue } = mergedValueRef;
          if (!Array.isArray(mergedValue) && mergedValue !== null) {
            const { value: treeMate } = dataTreeMateRef;
            const tmNode = treeMate.getNode(mergedValue);
            if (tmNode !== null) {
              return showPath ? treeOption2SelectOptionWithPath(
                tmNode,
                treeMate.getPath(mergedValue).treeNodePath,
                separator,
                labelField
              ) : treeOption2SelectOption(tmNode, labelField);
            }
          }
          return null;
        });
        const selectedOptionsRef = vue.computed(() => {
          const { multiple, showPath, separator } = props;
          if (!multiple)
            return null;
          const { value: mergedValue } = mergedValueRef;
          if (Array.isArray(mergedValue)) {
            const res = [];
            const { value: treeMate } = dataTreeMateRef;
            const { checkedKeys } = treeMate.getCheckedKeys(mergedValue, {
              checkStrategy: props.checkStrategy,
              cascade: mergedCascadeRef.value,
              allowNotLoaded: props.allowCheckingNotLoaded
            });
            const { labelField } = props;
            checkedKeys.forEach((value) => {
              const tmNode = treeMate.getNode(value);
              if (tmNode !== null) {
                res.push(
                  showPath ? treeOption2SelectOptionWithPath(
                    tmNode,
                    treeMate.getPath(value).treeNodePath,
                    separator,
                    labelField
                  ) : treeOption2SelectOption(tmNode, labelField)
                );
              }
            });
            return res;
          }
          return [];
        });
        const menuPaddingRef = vue.computed(() => {
          const {
            self: { menuPadding }
          } = themeRef.value;
          return menuPadding;
        });
        function focusSelection() {
          triggerInstRef.value?.focus();
        }
        function focusSelectionInput() {
          triggerInstRef.value?.focusInput();
        }
        function doUpdateShow(value) {
          const { onUpdateShow, "onUpdate:show": _onUpdateShow } = props;
          if (onUpdateShow)
            call(onUpdateShow, value);
          if (_onUpdateShow)
            call(_onUpdateShow, value);
          uncontrolledShowRef.value = value;
        }
        function doUpdateValue(value, option) {
          const { onUpdateValue, "onUpdate:value": _onUpdateValue } = props;
          if (onUpdateValue)
            call(onUpdateValue, value, option);
          if (_onUpdateValue) {
            call(_onUpdateValue, value, option);
          }
          uncontrolledValueRef.value = value;
          nTriggerFormInput();
          nTriggerFormChange();
        }
        function doUpdateIndeterminateKeys(value, option) {
          const {
            onUpdateIndeterminateKeys,
            "onUpdate:indeterminateKeys": _onUpdateIndeterminateKeys
          } = props;
          if (onUpdateIndeterminateKeys) {
            call(onUpdateIndeterminateKeys, value, option);
          }
          if (_onUpdateIndeterminateKeys) {
            call(_onUpdateIndeterminateKeys, value, option);
          }
        }
        function doUpdateExpandedKeys(keys, option) {
          const {
            onUpdateExpandedKeys,
            "onUpdate:expandedKeys": _onUpdateExpandedKeys
          } = props;
          if (onUpdateExpandedKeys) {
            call(onUpdateExpandedKeys, keys, option);
          }
          if (_onUpdateExpandedKeys) {
            call(_onUpdateExpandedKeys, keys, option);
          }
          uncontrolledExpandedKeysRef.value = keys;
        }
        function doFocus(e) {
          const { onFocus } = props;
          if (onFocus)
            onFocus(e);
          nTriggerFormFocus();
        }
        function doBlur(e) {
          closeMenu();
          const { onBlur } = props;
          if (onBlur)
            onBlur(e);
          nTriggerFormBlur();
        }
        function closeMenu() {
          doUpdateShow(false);
        }
        function openMenu() {
          if (!mergedDisabledRef.value) {
            patternRef.value = "";
            doUpdateShow(true);
            if (props.filterable) {
              focusSelectionInput();
            }
          }
        }
        function handleMenuLeave() {
          patternRef.value = "";
        }
        function handleMenuClickoutside(e) {
          if (mergedShowRef.value) {
            if (!triggerInstRef.value?.$el.contains(
              getPreciseEventTarget(e)
            )) {
              closeMenu();
            }
          }
        }
        function handleTriggerClick() {
          if (mergedDisabledRef.value)
            return;
          if (!mergedShowRef.value) {
            openMenu();
          } else {
            if (!props.filterable) {
              closeMenu();
            }
          }
        }
        function getOptionsByKeys(keys) {
          const {
            value: { getNode }
          } = dataTreeMateRef;
          return keys.map((key) => getNode(key)?.rawNode || null);
        }
        function handleUpdateCheckedKeys(keys) {
          const options = getOptionsByKeys(keys);
          if (props.multiple) {
            doUpdateValue(keys, options);
          } else {
            keys.length ? doUpdateValue(keys[0], options[0] || null) : doUpdateValue(null, null);
            closeMenu();
            if (!props.filterable) {
              focusSelection();
            }
          }
          if (props.filterable) {
            focusSelectionInput();
            if (props.clearFilterAfterSelect)
              patternRef.value = "";
          }
        }
        function handleUpdateIndeterminateKeys(keys) {
          if (props.checkable) {
            doUpdateIndeterminateKeys(keys, getOptionsByKeys(keys));
          }
        }
        function handleTriggerFocus(e) {
          if (menuElRef.value?.contains(e.relatedTarget))
            return;
          focusedRef.value = true;
          doFocus(e);
        }
        function handleTriggerBlur(e) {
          if (menuElRef.value?.contains(e.relatedTarget))
            return;
          focusedRef.value = false;
          doBlur(e);
        }
        function handleMenuFocusin(e) {
          if (menuElRef.value?.contains(e.relatedTarget) || triggerInstRef.value?.$el?.contains(e.relatedTarget)) {
            return;
          }
          focusedRef.value = true;
          doFocus(e);
        }
        function handleMenuFocusout(e) {
          if (menuElRef.value?.contains(e.relatedTarget) || triggerInstRef.value?.$el?.contains(e.relatedTarget)) {
            return;
          }
          focusedRef.value = false;
          doBlur(e);
        }
        function handleClear(e) {
          e.stopPropagation();
          const { multiple } = props;
          if (!multiple && props.filterable) {
            closeMenu();
          }
          if (multiple) {
            doUpdateValue([], []);
          } else {
            doUpdateValue(null, null);
          }
        }
        function handleDeleteOption(option) {
          const { value: mergedValue } = mergedValueRef;
          if (Array.isArray(mergedValue)) {
            const { value: treeMate } = dataTreeMateRef;
            const { checkedKeys: checkedKeysValue } = treeMate.getCheckedKeys(
              mergedValue,
              {
                cascade: mergedCascadeRef.value,
                allowNotLoaded: props.allowCheckingNotLoaded
              }
            );
            const index = checkedKeysValue.findIndex((key) => key === option.value);
            if (~index) {
              if (props.checkable) {
                const { checkedKeys } = treeMate.uncheck(
                  option.value,
                  checkedKeysValue,
                  {
                    checkStrategy: props.checkStrategy,
                    cascade: mergedCascadeRef.value,
                    allowNotLoaded: props.allowCheckingNotLoaded
                  }
                );
                doUpdateValue(checkedKeys, getOptionsByKeys(checkedKeys));
              } else {
                const nextValue = Array.from(checkedKeysValue);
                nextValue.splice(index, 1);
                doUpdateValue(nextValue, getOptionsByKeys(nextValue));
              }
            }
          }
        }
        function handlePatternInput(e) {
          const { value } = e.target;
          patternRef.value = value;
        }
        function treeHandleKeydown(e) {
          const { value: treeInst } = treeInstRef;
          if (treeInst) {
            treeInst.handleKeydown(e);
          }
        }
        function handleKeydown(e) {
          if (e.key === "Enter") {
            if (mergedShowRef.value) {
              treeHandleKeydown(e);
              if (!props.multiple) {
                closeMenu();
                focusSelection();
              }
            } else {
              openMenu();
            }
            e.preventDefault();
          } else if (e.key === "Escape") {
            if (mergedShowRef.value) {
              markEventEffectPerformed(e);
              closeMenu();
              focusSelection();
            }
          } else {
            if (mergedShowRef.value) {
              treeHandleKeydown(e);
            } else if (e.key === "ArrowDown") {
              openMenu();
            }
          }
        }
        function handleTabOut() {
          closeMenu();
          focusSelection();
        }
        function handleMenuMousedown(e) {
          if (!happensIn(e, "action"))
            e.preventDefault();
        }
        const selectionRenderTagRef = vue.computed(() => {
          const { renderTag } = props;
          if (!renderTag)
            return void 0;
          return function selectionRenderTag({
            option,
            handleClose
          }) {
            const { value } = option;
            if (value !== void 0) {
              const treeOption = dataTreeMateRef.value.getNode(value);
              if (treeOption) {
                return renderTag({ option: treeOption.rawNode, handleClose });
              }
            }
            return value;
          };
        });
        vue.provide(treeSelectInjectionKey, {
          pendingNodeKeyRef,
          dataTreeMate: dataTreeMateRef
        });
        function handleTriggerOrMenuResize() {
          if (!mergedShowRef.value)
            return;
          followerInstRef.value?.syncPosition();
        }
        useOnResize(menuElRef, handleTriggerOrMenuResize);
        const themeRef = useTheme(
          "TreeSelect",
          "-tree-select",
          style$9,
          treeSelectLight$1,
          props,
          mergedClsPrefixRef
        );
        const cssVarsRef = vue.computed(() => {
          const {
            common: { cubicBezierEaseInOut },
            self: {
              menuBoxShadow,
              menuBorderRadius,
              menuColor,
              menuHeight,
              actionPadding,
              actionDividerColor,
              actionTextColor
            }
          } = themeRef.value;
          return {
            "--n-menu-box-shadow": menuBoxShadow,
            "--n-menu-border-radius": menuBorderRadius,
            "--n-menu-color": menuColor,
            "--n-menu-height": menuHeight,
            "--n-bezier": cubicBezierEaseInOut,
            "--n-action-padding": actionPadding,
            "--n-action-text-color": actionTextColor,
            "--n-action-divider-color": actionDividerColor
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("tree-select", void 0, cssVarsRef, props) : void 0;
        return {
          menuElRef,
          mergedStatus: mergedStatusRef,
          triggerInstRef,
          followerInstRef,
          treeInstRef,
          mergedClsPrefix: mergedClsPrefixRef,
          mergedValue: mergedValueRef,
          mergedShow: mergedShowRef,
          namespace: namespaceRef,
          adjustedTo: useAdjustedTo(props),
          isMounted: isMounted(),
          focused: focusedRef,
          menuPadding: menuPaddingRef,
          mergedPlaceholder: mergedPlaceholderRef,
          mergedExpandedKeys: mergedExpandedKeysRef,
          treeSelectedKeys: treeSelectedKeysRef,
          treeCheckedKeys: treeCheckedKeysRef,
          mergedSize: mergedSizeRef,
          mergedDisabled: mergedDisabledRef,
          selectedOption: selectedOptionRef,
          selectedOptions: selectedOptionsRef,
          pattern: patternRef,
          pendingNodeKey: pendingNodeKeyRef,
          mergedCascade: mergedCascadeRef,
          mergedFilter: mergedFilterRef,
          selectionRenderTag: selectionRenderTagRef,
          handleTriggerOrMenuResize,
          doUpdateExpandedKeys,
          handleMenuLeave,
          handleTriggerClick,
          handleMenuClickoutside,
          handleUpdateCheckedKeys,
          handleUpdateIndeterminateKeys,
          handleTriggerFocus,
          handleTriggerBlur,
          handleMenuFocusin,
          handleMenuFocusout,
          handleClear,
          handleDeleteOption,
          handlePatternInput,
          handleKeydown,
          handleTabOut,
          handleMenuMousedown,
          mergedTheme: themeRef,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender
        };
      },
      render() {
        const { mergedTheme, mergedClsPrefix, $slots } = this;
        return /* @__PURE__ */ vue.h("div", {
          class: `${mergedClsPrefix}-tree-select`
        }, /* @__PURE__ */ vue.h(VBinder, null, {
          default: () => [
            /* @__PURE__ */ vue.h(VTarget, null, {
              default: () => /* @__PURE__ */ vue.h(NInternalSelection, {
                ref: "triggerInstRef",
                onResize: this.handleTriggerOrMenuResize,
                status: this.mergedStatus,
                focused: this.focused,
                clsPrefix: mergedClsPrefix,
                theme: mergedTheme.peers.InternalSelection,
                themeOverrides: mergedTheme.peerOverrides.InternalSelection,
                renderTag: this.selectionRenderTag,
                selectedOption: this.selectedOption,
                selectedOptions: this.selectedOptions,
                size: this.mergedSize,
                bordered: this.bordered,
                placeholder: this.mergedPlaceholder,
                disabled: this.mergedDisabled,
                active: this.mergedShow,
                loading: this.loading,
                multiple: this.multiple,
                maxTagCount: this.maxTagCount,
                showArrow: true,
                filterable: this.filterable,
                clearable: this.clearable,
                pattern: this.pattern,
                onPatternInput: this.handlePatternInput,
                onClear: this.handleClear,
                onClick: this.handleTriggerClick,
                onFocus: this.handleTriggerFocus,
                onBlur: this.handleTriggerBlur,
                onDeleteOption: this.handleDeleteOption,
                onKeydown: this.handleKeydown
              }, {
                arrow: () => [this.$slots.arrow?.()]
              })
            }),
            /* @__PURE__ */ vue.h(VFollower, {
              ref: "followerInstRef",
              show: this.mergedShow,
              placement: this.placement,
              to: this.adjustedTo,
              teleportDisabled: this.adjustedTo === useAdjustedTo.tdkey,
              containerClass: this.namespace,
              width: this.consistentMenuWidth ? "target" : void 0,
              minWidth: "target"
            }, {
              default: () => /* @__PURE__ */ vue.h(vue.Transition, {
                name: "fade-in-scale-up-transition",
                appear: this.isMounted,
                onLeave: this.handleMenuLeave
              }, {
                default: () => {
                  if (!this.mergedShow)
                    return null;
                  const {
                    mergedClsPrefix: mergedClsPrefix2,
                    checkable,
                    multiple,
                    menuProps,
                    options
                  } = this;
                  this.onRender?.();
                  return vue.withDirectives(
                    /* @__PURE__ */ vue.h("div", {
                      ...menuProps,
                      class: [
                        `${mergedClsPrefix2}-tree-select-menu`,
                        menuProps?.class,
                        this.themeClass
                      ],
                      ref: "menuElRef",
                      style: [
                        menuProps?.style || "",
                        this.cssVars
                      ],
                      tabindex: 0,
                      onMousedown: this.handleMenuMousedown,
                      onKeydown: this.handleKeydown,
                      onFocusin: this.handleMenuFocusin,
                      onFocusout: this.handleMenuFocusout
                    }, /* @__PURE__ */ vue.h(NTree, {
                      ref: "treeInstRef",
                      blockLine: true,
                      allowCheckingNotLoaded: this.allowCheckingNotLoaded,
                      showIrrelevantNodes: false,
                      animated: false,
                      pattern: this.pattern,
                      filter: this.mergedFilter,
                      data: options,
                      cancelable: multiple,
                      labelField: this.labelField,
                      keyField: this.keyField,
                      disabledField: this.disabledField,
                      childrenField: this.childrenField,
                      theme: mergedTheme.peers.Tree,
                      themeOverrides: mergedTheme.peerOverrides.Tree,
                      defaultExpandAll: this.defaultExpandAll,
                      defaultExpandedKeys: this.defaultExpandedKeys,
                      expandedKeys: this.mergedExpandedKeys,
                      checkedKeys: this.treeCheckedKeys,
                      selectedKeys: this.treeSelectedKeys,
                      checkable,
                      checkStrategy: this.checkStrategy,
                      cascade: this.mergedCascade,
                      leafOnly: this.leafOnly,
                      multiple: this.multiple,
                      renderLabel: this.renderLabel,
                      renderPrefix: this.renderPrefix,
                      renderSuffix: this.renderSuffix,
                      renderSwitcherIcon: this.renderSwitcherIcon,
                      nodeProps: this.nodeProps,
                      virtualScroll: this.consistentMenuWidth && this.virtualScroll,
                      internalTreeSelect: true,
                      internalUnifySelectCheck: true,
                      internalScrollable: true,
                      internalScrollablePadding: this.menuPadding,
                      internalFocusable: false,
                      internalCheckboxFocusable: false,
                      internalRenderEmpty: () => /* @__PURE__ */ vue.h("div", {
                        class: `${mergedClsPrefix2}-tree-select-menu__empty`
                      }, resolveSlot($slots.empty, () => [
                        /* @__PURE__ */ vue.h(NEmpty, {
                          theme: mergedTheme.peers.Empty,
                          themeOverrides: mergedTheme.peerOverrides.Empty
                        })
                      ])),
                      onLoad: this.onLoad,
                      onUpdateCheckedKeys: this.handleUpdateCheckedKeys,
                      onUpdateIndeterminateKeys: this.handleUpdateIndeterminateKeys,
                      onUpdateExpandedKeys: this.doUpdateExpandedKeys
                    }), resolveWrappedSlot($slots.action, (children) => {
                      return children ? /* @__PURE__ */ vue.h("div", {
                        class: `${mergedClsPrefix2}-tree-select-menu__action`,
                        "data-action": true
                      }, children) : null;
                    }), /* @__PURE__ */ vue.h(FocusDetector, {
                      onFocus: this.handleTabOut
                    })),
                    [
                      [
                        clickoutside$1,
                        this.handleMenuClickoutside,
                        void 0,
                        { capture: true }
                      ]
                    ]
                  );
                }
              })
            })
          ]
        }));
      }
    });

    var style$8 = cB("h", `
  font-size: var(--n-font-size);
  font-weight: var(--n-font-weight);
  margin: var(--n-margin);
  transition: color .3s var(--n-bezier);
  color: var(--n-text-color);
`, [c$1("&:first-child", {
      marginTop: 0
    }), cM("prefix-bar", {
      position: "relative",
      paddingLeft: "var(--n-prefix-width)"
    }, [cM("align-text", {
      paddingLeft: 0
    }, [c$1("&::before", {
      left: "calc(-1 * var(--n-prefix-width))"
    })]), c$1("&::before", `
      content: "";
      width: var(--n-bar-width);
      border-radius: calc(var(--n-bar-width) / 2);
      transition: background-color .3s var(--n-bezier);
      left: 0;
      top: 0;
      bottom: 0;
      position: absolute;
    `), c$1("&::before", {
      backgroundColor: "var(--n-bar-color)"
    })])]);

    const headerProps = { ...useTheme.props,
      type: {
        type: String,
        default: "default"
      },
      prefix: String,
      alignText: Boolean
    };
    var createHeader = (level => vue.defineComponent({
      name: `H${level}`,
      props: headerProps,

      setup(props) {
        const {
          mergedClsPrefixRef,
          inlineThemeDisabled
        } = useConfig(props);
        const themeRef = useTheme("Typography", "-h", style$8, typographyLight$1, props, mergedClsPrefixRef);
        const cssVarsRef = vue.computed(() => {
          const {
            type
          } = props;
          const {
            common: {
              cubicBezierEaseInOut
            },
            self: {
              headerFontWeight,
              headerTextColor,
              [createKey("headerPrefixWidth", level)]: prefixWidth,
              [createKey("headerFontSize", level)]: fontSize,
              [createKey("headerMargin", level)]: margin,
              [createKey("headerBarWidth", level)]: barWidth,
              [createKey("headerBarColor", type)]: barColor
            }
          } = themeRef.value;
          return {
            "--n-bezier": cubicBezierEaseInOut,
            "--n-font-size": fontSize,
            "--n-margin": margin,
            "--n-bar-color": barColor,
            "--n-bar-width": barWidth,
            "--n-font-weight": headerFontWeight,
            "--n-text-color": headerTextColor,
            "--n-prefix-width": prefixWidth
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass(`h${level}`, vue.computed(() => props.type[0]), cssVarsRef, props) : void 0;
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
          onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
        };
      },

      render() {
        var _this$onRender;

        const {
          prefix,
          alignText,
          mergedClsPrefix,
          cssVars,
          $slots
        } = this;
        (_this$onRender = this.onRender) === null || _this$onRender === void 0 ? void 0 : _this$onRender.call(this);
        return vue.h(`h${level}`, {
          class: [`${mergedClsPrefix}-h`, `${mergedClsPrefix}-h${level}`, this.themeClass, {
            [`${mergedClsPrefix}-h--prefix-bar`]: prefix,
            [`${mergedClsPrefix}-h--align-text`]: alignText
          }],
          style: cssVars
        }, $slots);
      }

    }));

    const NH1 = createHeader("1");
    const NH2 = createHeader("2");
    const NH3 = createHeader("3");
    const NH4 = createHeader("4");
    const NH5 = createHeader("5");
    const NH6 = createHeader("6");

    var style$7 = cB("a", `
  cursor: pointer;
  transition:
    color .3s var(--n-bezier),
    text-decoration-color .3s var(--n-bezier);
  text-decoration-color: var(--n-text-color);
  color: var(--n-text-color);
`);

    const aProps = {
      ...useTheme.props
    };
    var a = vue.defineComponent({
      name: "A",
      props: aProps,
      setup(props) {
        const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
        const themeRef = useTheme(
          "Typography",
          "-a",
          style$7,
          typographyLight$1,
          props,
          mergedClsPrefixRef
        );
        const cssVarsRef = vue.computed(() => {
          const {
            common: { cubicBezierEaseInOut },
            self: { aTextColor }
          } = themeRef.value;
          return {
            "--n-text-color": aTextColor,
            "--n-bezier": cubicBezierEaseInOut
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("a", void 0, cssVarsRef, props) : void 0;
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender
        };
      },
      render() {
        this.onRender?.();
        return /* @__PURE__ */ vue.h("a", {
          class: [`${this.mergedClsPrefix}-a`, this.themeClass],
          style: this.cssVars
        }, this.$slots);
      }
    });

    var style$6 = cB("p", `
  box-sizing: border-box;
  transition: color .3s var(--n-bezier);
  margin: var(--n-margin);
  font-size:  var(--n-font-size);
  line-height: var(--n-line-height);
  color: var(--n-text-color);
`, [c$1("&:first-child", "margin-top: 0;"), c$1("&:last-child", "margin-bottom: 0;")]);

    const pProps = {
      ...useTheme.props,
      depth: [String, Number]
    };
    var p = vue.defineComponent({
      name: "P",
      props: pProps,
      setup(props) {
        const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
        const themeRef = useTheme(
          "Typography",
          "-p",
          style$6,
          typographyLight$1,
          props,
          mergedClsPrefixRef
        );
        const cssVarsRef = vue.computed(() => {
          const { depth } = props;
          const typeSafeDepth = depth || "1";
          const {
            common: { cubicBezierEaseInOut },
            self: {
              pFontSize,
              pLineHeight,
              pMargin,
              pTextColor,
              [`pTextColor${typeSafeDepth}Depth`]: depthTextColor
            }
          } = themeRef.value;
          return {
            "--n-bezier": cubicBezierEaseInOut,
            "--n-font-size": pFontSize,
            "--n-line-height": pLineHeight,
            "--n-margin": pMargin,
            "--n-text-color": depth === void 0 ? pTextColor : depthTextColor
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass(
          "p",
          vue.computed(() => `${props.depth || ""}`),
          cssVarsRef,
          props
        ) : void 0;
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender
        };
      },
      render() {
        this.onRender?.();
        return /* @__PURE__ */ vue.h("p", {
          class: [`${this.mergedClsPrefix}-p`, this.themeClass],
          style: this.cssVars
        }, this.$slots);
      }
    });

    var style$5 = cB("blockquote", `
  font-size: var(--n-font-size);
  line-height: var(--n-line-height);
  margin: 0;
  margin-top: 12px;
  margin-bottom: 12px;
  box-sizing: border-box;
  padding-left: 12px;
  border-left: 4px solid var(--n-prefix-color);
  color: var(--n-text-color);
  transition:
    color .3s var(--n-bezier),
    border-color .3s var(--n-bezier);
`, [c$1("&:first-child", {
      marginTop: 0
    }), c$1("&:last-child", {
      marginBottom: 0
    }), cM("align-text", {
      marginLeft: "-16px"
    })]);

    const blockquoteProps = {
      ...useTheme.props,
      alignText: Boolean
    };
    var blockquote = vue.defineComponent({
      name: "Blockquote",
      props: blockquoteProps,
      setup(props) {
        const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
        const themeRef = useTheme(
          "Typography",
          "-blockquote",
          style$5,
          typographyLight$1,
          props,
          mergedClsPrefixRef
        );
        const cssVarsRef = vue.computed(() => {
          const {
            common: { cubicBezierEaseInOut },
            self: {
              blockquoteTextColor,
              blockquotePrefixColor,
              blockquoteLineHeight,
              blockquoteFontSize
            }
          } = themeRef.value;
          return {
            "--n-bezier": cubicBezierEaseInOut,
            "--n-font-size": blockquoteFontSize,
            "--n-line-height": blockquoteLineHeight,
            "--n-prefix-color": blockquotePrefixColor,
            "--n-text-color": blockquoteTextColor
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("blockquote", void 0, cssVarsRef, props) : void 0;
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender
        };
      },
      render() {
        const { mergedClsPrefix } = this;
        this.onRender?.();
        return /* @__PURE__ */ vue.h("blockquote", {
          class: [
            `${mergedClsPrefix}-blockquote`,
            this.themeClass,
            this.alignText && `${mergedClsPrefix}-blockquote--align-text`
          ],
          style: this.cssVars
        }, this.$slots);
      }
    });

    var style$4 = cB("hr", `
  margin: 12px 0;
  transition: border-color .3s var(--n-bezier);
  border-left: none;
  border-right: none;
  border-bottom: none;
  border-top: 1px solid var(--n-color);
`);

    var hr = vue.defineComponent({
      name: "Hr",
      props: {
        ...useTheme.props
      },
      setup(props) {
        const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
        const themeRef = useTheme(
          "Typography",
          "-hr",
          style$4,
          typographyLight$1,
          props,
          mergedClsPrefixRef
        );
        const cssVarsRef = vue.computed(() => {
          const {
            common: { cubicBezierEaseInOut },
            self: { hrColor }
          } = themeRef.value;
          return {
            "--n-bezier": cubicBezierEaseInOut,
            "--n-color": hrColor
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("hr", void 0, cssVarsRef, props) : void 0;
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender
        };
      },
      render() {
        this.onRender?.();
        return /* @__PURE__ */ vue.h("hr", {
          class: [`${this.mergedClsPrefix}-hr`, this.themeClass],
          style: this.cssVars
        });
      }
    });

    const liStyle = c$1("li", {
      transition: "color .3s var(--n-bezier)",
      lineHeight: "var(--n-line-height)",
      margin: "var(--n-li-margin)",
      marginBottom: 0,
      color: "var(--n-text-color)"
    });
    const childStyle = [c$1("&:first-child", `
    margin-top: 0;
  `), c$1("&:last-child", `
    margin-bottom: 0;
  `)];
    var style$3 = c$1([cB("ol", {
      fontSize: "var(--n-font-size)",
      padding: "var(--n-ol-padding)"
    }, [cM("align-text", {
      paddingLeft: 0
    }), liStyle, childStyle]), cB("ul", {
      fontSize: "var(--n-font-size)",
      padding: "var(--n-ul-padding)"
    }, [cM("align-text", {
      paddingLeft: 0
    }), liStyle, childStyle])]);

    const ulProps = {
      ...useTheme.props,
      alignText: Boolean
    };
    var ul = vue.defineComponent({
      name: "Ul",
      props: ulProps,
      setup(props) {
        const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
        const themeRef = useTheme(
          "Typography",
          "-xl",
          style$3,
          typographyLight$1,
          props,
          mergedClsPrefixRef
        );
        const cssVarsRef = vue.computed(() => {
          const {
            common: { cubicBezierEaseInOut },
            self: {
              olPadding,
              ulPadding,
              liMargin,
              liTextColor,
              liLineHeight,
              liFontSize
            }
          } = themeRef.value;
          return {
            "--n-bezier": cubicBezierEaseInOut,
            "--n-font-size": liFontSize,
            "--n-line-height": liLineHeight,
            "--n-text-color": liTextColor,
            "--n-li-margin": liMargin,
            "--n-ol-padding": olPadding,
            "--n-ul-padding": ulPadding
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("ul", void 0, cssVarsRef, props) : void 0;
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender
        };
      },
      render() {
        const { mergedClsPrefix } = this;
        this.onRender?.();
        return /* @__PURE__ */ vue.h("ul", {
          class: [
            `${mergedClsPrefix}-ul`,
            this.themeClass,
            this.alignText && `${mergedClsPrefix}-ul--align-text`
          ],
          style: this.cssVars
        }, this.$slots);
      }
    });

    const olProps = {
      ...useTheme.props,
      alignText: Boolean
    };
    var ol = vue.defineComponent({
      name: "Ol",
      props: olProps,
      setup(props) {
        const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
        const themeRef = useTheme(
          "Typography",
          "-xl",
          style$3,
          typographyLight$1,
          props,
          mergedClsPrefixRef
        );
        const cssVarsRef = vue.computed(() => {
          const {
            common: { cubicBezierEaseInOut },
            self: {
              olPadding,
              ulPadding,
              liMargin,
              liTextColor,
              liLineHeight,
              liFontSize
            }
          } = themeRef.value;
          return {
            "--n-bezier": cubicBezierEaseInOut,
            "--n-font-size": liFontSize,
            "--n-line-height": liLineHeight,
            "--n-text-color": liTextColor,
            "--n-li-margin": liMargin,
            "--n-ol-padding": olPadding,
            "--n-ul-padding": ulPadding
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("ol", void 0, cssVarsRef, props) : void 0;
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender
        };
      },
      render() {
        const { mergedClsPrefix } = this;
        this.onRender?.();
        return /* @__PURE__ */ vue.h("ol", {
          class: [
            `${mergedClsPrefix}-ol`,
            this.themeClass,
            this.alignText && `${mergedClsPrefix}-ol--align-text`
          ],
          style: this.cssVars
        }, this.$slots);
      }
    });

    var li = vue.defineComponent({
      name: "Li",
      render() {
        return /* @__PURE__ */ vue.h("li", null, this.$slots);
      }
    });

    var style$2 = cB("text", `
  transition: color .3s var(--n-bezier);
  color: var(--n-text-color);
`, [cM("strong", `
    font-weight: var(--n-font-weight-strong);
  `), cM("italic", {
      fontStyle: "italic"
    }), cM("underline", {
      textDecoration: "underline"
    }), cM("code", `
    line-height: 1.4;
    display: inline-block;
    font-family: var(--n-font-famliy-mono);
    transition:
      color .3s var(--n-bezier),
      border-color .3s var(--n-bezier),
      background-color .3s var(--n-bezier);
    box-sizing: border-box;
    padding: .05em .35em 0 .35em;
    border-radius: var(--n-code-border-radius);
    font-size: .9em;
    color: var(--n-code-text-color);
    background-color: var(--n-code-color);
    border: var(--n-code-border);
  `)]);

    const textProps = {
      ...useTheme.props,
      code: Boolean,
      type: {
        type: String,
        default: "default"
      },
      delete: Boolean,
      strong: Boolean,
      italic: Boolean,
      underline: Boolean,
      depth: [String, Number],
      tag: String,
      as: {
        type: String,
        validator: () => {
          {
            warn$2("text", "`as` is deprecated, please use `tag` instead.");
          }
          return true;
        },
        default: void 0
      }
    };
    var text = vue.defineComponent({
      name: "Text",
      props: textProps,
      setup(props) {
        const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
        const themeRef = useTheme(
          "Typography",
          "-text",
          style$2,
          typographyLight$1,
          props,
          mergedClsPrefixRef
        );
        const cssVarsRef = vue.computed(() => {
          const { depth, type } = props;
          const textColorKey = type === "default" ? depth === void 0 ? "textColor" : `textColor${depth}Depth` : createKey("textColor", type);
          const {
            common: { fontWeightStrong, fontFamilyMono, cubicBezierEaseInOut },
            self: {
              codeTextColor,
              codeBorderRadius,
              codeColor,
              codeBorder,
              [textColorKey]: textColor
            }
          } = themeRef.value;
          return {
            "--n-bezier": cubicBezierEaseInOut,
            "--n-text-color": textColor,
            "--n-font-weight-strong": fontWeightStrong,
            "--n-font-famliy-mono": fontFamilyMono,
            "--n-code-border-radius": codeBorderRadius,
            "--n-code-text-color": codeTextColor,
            "--n-code-color": codeColor,
            "--n-code-border": codeBorder
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass(
          "text",
          vue.computed(() => `${props.type[0]}${props.depth || ""}`),
          cssVarsRef,
          props
        ) : void 0;
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          compitableTag: useCompitable(props, ["as", "tag"]),
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender
        };
      },
      render() {
        const { mergedClsPrefix } = this;
        this.onRender?.();
        const textClass = [
          `${mergedClsPrefix}-text`,
          this.themeClass,
          {
            [`${mergedClsPrefix}-text--code`]: this.code,
            [`${mergedClsPrefix}-text--delete`]: this.delete,
            [`${mergedClsPrefix}-text--strong`]: this.strong,
            [`${mergedClsPrefix}-text--italic`]: this.italic,
            [`${mergedClsPrefix}-text--underline`]: this.underline
          }
        ];
        const children = this.$slots.default?.();
        return this.code ? /* @__PURE__ */ vue.h("code", {
          class: textClass,
          style: this.cssVars
        }, this.delete ? /* @__PURE__ */ vue.h("del", null, children) : children) : this.delete ? /* @__PURE__ */ vue.h("del", {
          class: textClass,
          style: this.cssVars
        }, children) : vue.h(
          this.compitableTag || "span",
          { class: textClass, style: this.cssVars },
          children
        );
      }
    });

    const uploadInjectionKey = createInjectionKey("n-upload");

    const uploadDraggerKey = "__UPLOAD_DRAGGER__";
    var NUploadDragger = vue.defineComponent({
      name: "UploadDragger",
      [uploadDraggerKey]: true,
      setup(_, { slots }) {
        const NUpload = vue.inject(uploadInjectionKey, null);
        if (!NUpload) {
          throwError(
            "upload-dragger",
            "`n-upload-dragger` must be placed inside `n-upload`."
          );
        }
        return () => {
          const {
            mergedClsPrefixRef: { value: mergedClsPrefix },
            mergedDisabledRef: { value: mergedDisabled },
            maxReachedRef: { value: maxReached }
          } = NUpload;
          return /* @__PURE__ */ vue.h("div", {
            class: [
              `${mergedClsPrefix}-upload-dragger`,
              (mergedDisabled || maxReached) && `${mergedClsPrefix}-upload-dragger--disabled`
            ]
          }, slots);
        };
      }
    });

    const isImageFileType = type => type.includes("image/");

    const getExtname = function () {
      let url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
      const temp = url.split("/");
      const filename = temp[temp.length - 1];
      const filenameWithoutSuffix = filename.split(/#|\?/)[0];
      return (/\.[^./\\]*$/.exec(filenameWithoutSuffix) || [""])[0];
    };

    const isImageFile = file => {
      if (file.type) {
        return isImageFileType(file.type);
      }

      const url = file.thumbnailUrl || file.url || "";
      const extension = getExtname(url);

      if (/^data:image\//.test(url) || /(webp|svg|png|gif|jpg|jpeg|jfif|bmp|dpg|ico)$/i.test(extension)) {
        return true;
      }

      if (/^data:/.test(url)) {
        return false;
      }

      if (extension) {
        return false;
      }

      return true;
    };
    async function createImageDataUrl(file) {
      return await new Promise(resolve => {
        if (!file.type || !isImageFileType(file.type)) {
          resolve("");
          return;
        }

        resolve(window.URL.createObjectURL(file));
      });
    }
    const environmentSupportFile = isBrowser$2 && window.FileReader && window.File;
    function isFileSystemDirectoryEntry(item) {
      return item.isDirectory;
    }
    function isFileSystemFileEntry(item) {
      return item.isFile;
    }
    async function getFilesFromEntries(entries, directory) {
      const fileAndEntries = [];

      let _resolve;

      let requestCallbackCount = 0;

      function lock() {
        requestCallbackCount++;
      }

      function unlock() {
        requestCallbackCount--;

        if (!requestCallbackCount) {
          _resolve(fileAndEntries);
        }
      }

      function _getFilesFromEntries(entries2) {
        entries2.forEach(entry => {
          if (!entry) return;
          lock();

          if (directory && isFileSystemDirectoryEntry(entry)) {
            const directoryReader = entry.createReader();
            lock();
            directoryReader.readEntries(entries3 => {
              _getFilesFromEntries(entries3);

              unlock();
            }, () => {
              unlock();
            });
          } else if (isFileSystemFileEntry(entry)) {
            lock();
            entry.file(file => {
              fileAndEntries.push({
                file,
                entry,
                source: "dnd"
              });
              unlock();
            }, () => {
              unlock();
            });
          }

          unlock();
        });
      }

      await new Promise(resolve => {
        _resolve = resolve;

        _getFilesFromEntries(entries);
      });
      return fileAndEntries;
    }
    function createSettledFileInfo(fileInfo) {
      const {
        id,
        name,
        percentage,
        status,
        url,
        file,
        thumbnailUrl,
        type,
        fullPath,
        batchId
      } = fileInfo;
      return {
        id,
        name,
        percentage: percentage ?? null,
        status,
        url: url ?? null,
        file: file ?? null,
        thumbnailUrl: thumbnailUrl ?? null,
        type: type ?? null,
        fullPath: fullPath ?? null,
        batchId: batchId ?? null
      };
    }
    function matchType(name, mimeType, accept) {
      name = name.toLowerCase();
      mimeType = mimeType.toLocaleLowerCase();
      accept = accept.toLocaleLowerCase();
      const acceptAtoms = accept.split(",").map(acceptAtom => acceptAtom.trim()).filter(Boolean);
      return acceptAtoms.some(acceptAtom => {
        if (acceptAtom.startsWith(".")) {
          if (name.endsWith(acceptAtom)) return true;
        } else if (acceptAtom.includes("/")) {
          const [type, subtype] = mimeType.split("/");
          const [acceptType, acceptSubtype] = acceptAtom.split("/");

          if (acceptType === "*" || type && acceptType && acceptType === type) {
            if (acceptSubtype === "*" || subtype && acceptSubtype && acceptSubtype === subtype) {
              return true;
            }
          }
        } else {
          return true;
        }

        return false;
      });
    }
    const download = (url, name) => {
      if (!url) return;
      const a = document.createElement("a");
      a.href = url;

      if (name !== void 0) {
        a.download = name;
      }

      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
    };

    var NUploadTrigger = vue.defineComponent({
      name: "UploadTrigger",
      props: {
        abstract: Boolean
      },
      setup(props, { slots }) {
        const NUpload = vue.inject(uploadInjectionKey, null);
        if (!NUpload) {
          throwError(
            "upload-trigger",
            "`n-upload-trigger` must be placed inside `n-upload`."
          );
        }
        const {
          mergedClsPrefixRef,
          mergedDisabledRef,
          maxReachedRef,
          listTypeRef,
          dragOverRef,
          openOpenFileDialog,
          draggerInsideRef,
          handleFileAddition,
          mergedDirectoryDndRef,
          triggerStyleRef
        } = NUpload;
        const isImageCardTypeRef = vue.computed(
          () => listTypeRef.value === "image-card"
        );
        function handleTriggerClick() {
          if (mergedDisabledRef.value || maxReachedRef.value)
            return;
          openOpenFileDialog();
        }
        function handleTriggerDragOver(e) {
          e.preventDefault();
          dragOverRef.value = true;
        }
        function handleTriggerDragEnter(e) {
          e.preventDefault();
          dragOverRef.value = true;
        }
        function handleTriggerDragLeave(e) {
          e.preventDefault();
          dragOverRef.value = false;
        }
        function handleTriggerDrop(e) {
          e.preventDefault();
          if (!draggerInsideRef.value || mergedDisabledRef.value || maxReachedRef.value) {
            dragOverRef.value = false;
            return;
          }
          const dataTransferItems = e.dataTransfer?.items;
          if (dataTransferItems?.length) {
            void getFilesFromEntries(
              Array.from(dataTransferItems).map((item) => item.webkitGetAsEntry()),
              mergedDirectoryDndRef.value
            ).then((files) => {
              handleFileAddition(files);
            }).finally(() => {
              dragOverRef.value = false;
            });
          } else {
            dragOverRef.value = false;
          }
        }
        return () => {
          const { value: mergedClsPrefix } = mergedClsPrefixRef;
          return props.abstract ? slots.default?.({
            handleClick: handleTriggerClick,
            handleDrop: handleTriggerDrop,
            handleDragOver: handleTriggerDragOver,
            handleDragEnter: handleTriggerDragEnter,
            handleDragLeave: handleTriggerDragLeave
          }) : /* @__PURE__ */ vue.h("div", {
            class: [
              `${mergedClsPrefix}-upload-trigger`,
              (mergedDisabledRef.value || maxReachedRef.value) && `${mergedClsPrefix}-upload-trigger--disabled`,
              isImageCardTypeRef.value && `${mergedClsPrefix}-upload-trigger--image-card`
            ],
            style: triggerStyleRef.value,
            onClick: handleTriggerClick,
            onDrop: handleTriggerDrop,
            onDragover: handleTriggerDragOver,
            onDragenter: handleTriggerDragEnter,
            onDragleave: handleTriggerDragLeave
          }, isImageCardTypeRef.value ? /* @__PURE__ */ vue.h(NUploadDragger, null, {
            default: () => resolveSlot(slots.default, () => [
              /* @__PURE__ */ vue.h(NBaseIcon, {
                clsPrefix: mergedClsPrefix
              }, { default: () => /* @__PURE__ */ vue.h(AddIcon, null) })
            ])
          }) : slots);
        };
      }
    });

    var NUploadProgress = vue.defineComponent({
      name: "UploadProgress",
      props: {
        show: Boolean,
        percentage: {
          type: Number,
          required: true
        },
        status: {
          type: String,
          required: true
        }
      },
      setup() {
        const NUpload = vue.inject(uploadInjectionKey);
        return {
          mergedTheme: NUpload.mergedThemeRef
        };
      },
      render() {
        return /* @__PURE__ */ vue.h(NFadeInExpandTransition, null, {
          default: () => this.show ? /* @__PURE__ */ vue.h(NProgress, {
            type: "line",
            showIndicator: false,
            percentage: this.percentage,
            status: this.status,
            height: 2,
            theme: this.mergedTheme.peers.Progress,
            themeOverrides: this.mergedTheme.peerOverrides.Progress
          }) : null
        });
      }
    });

    const imageIcon = /* @__PURE__ */ vue.h("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 28 28"
    }, /* @__PURE__ */ vue.h("g", {
      fill: "none"
    }, /* @__PURE__ */ vue.h("path", {
      d: "M21.75 3A3.25 3.25 0 0 1 25 6.25v15.5A3.25 3.25 0 0 1 21.75 25H6.25A3.25 3.25 0 0 1 3 21.75V6.25A3.25 3.25 0 0 1 6.25 3h15.5zm.583 20.4l-7.807-7.68a.75.75 0 0 0-.968-.07l-.084.07l-7.808 7.68c.183.065.38.1.584.1h15.5c.204 0 .4-.035.583-.1l-7.807-7.68l7.807 7.68zM21.75 4.5H6.25A1.75 1.75 0 0 0 4.5 6.25v15.5c0 .208.036.408.103.593l7.82-7.692a2.25 2.25 0 0 1 3.026-.117l.129.117l7.82 7.692c.066-.185.102-.385.102-.593V6.25a1.75 1.75 0 0 0-1.75-1.75zm-3.25 3a2.5 2.5 0 1 1 0 5a2.5 2.5 0 0 1 0-5zm0 1.5a1 1 0 1 0 0 2a1 1 0 0 0 0-2z",
      fill: "currentColor"
    })));
    const documentIcon = /* @__PURE__ */ vue.h("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 28 28"
    }, /* @__PURE__ */ vue.h("g", {
      fill: "none"
    }, /* @__PURE__ */ vue.h("path", {
      d: "M6.4 2A2.4 2.4 0 0 0 4 4.4v19.2A2.4 2.4 0 0 0 6.4 26h15.2a2.4 2.4 0 0 0 2.4-2.4V11.578c0-.729-.29-1.428-.805-1.944l-6.931-6.931A2.4 2.4 0 0 0 14.567 2H6.4zm-.9 2.4a.9.9 0 0 1 .9-.9H14V10a2 2 0 0 0 2 2h6.5v11.6a.9.9 0 0 1-.9.9H6.4a.9.9 0 0 1-.9-.9V4.4zm16.44 6.1H16a.5.5 0 0 1-.5-.5V4.06l6.44 6.44z",
      fill: "currentColor"
    })));

    const buttonThemeOverrides = {
      paddingMedium: "0 3px",
      heightMedium: "24px",
      iconSizeMedium: "18px"
    };
    var NUploadFile = vue.defineComponent({
      name: "UploadFile",
      props: {
        clsPrefix: {
          type: String,
          required: true
        },
        file: {
          type: Object,
          required: true
        },
        listType: {
          type: String,
          required: true
        }
      },
      setup(props) {
        const NUpload = vue.inject(uploadInjectionKey);
        const imageRef = vue.ref(null);
        const thumbnailUrlRef = vue.ref("");
        const progressStatusRef = vue.computed(() => {
          const { file } = props;
          if (file.status === "finished")
            return "success";
          if (file.status === "error")
            return "error";
          return "info";
        });
        const buttonTypeRef = vue.computed(() => {
          const { file } = props;
          if (file.status === "error")
            return "error";
          return void 0;
        });
        const showProgressRef = vue.computed(() => {
          const { file } = props;
          return file.status === "uploading";
        });
        const showCancelButtonRef = vue.computed(() => {
          if (!NUpload.showCancelButtonRef.value)
            return false;
          const { file } = props;
          return ["uploading", "pending", "error"].includes(file.status);
        });
        const showRemoveButtonRef = vue.computed(() => {
          if (!NUpload.showRemoveButtonRef.value)
            return false;
          const { file } = props;
          return ["finished"].includes(file.status);
        });
        const showDownloadButtonRef = vue.computed(() => {
          if (!NUpload.showDownloadButtonRef.value)
            return false;
          const { file } = props;
          return ["finished"].includes(file.status);
        });
        const showRetryButtonRef = vue.computed(() => {
          if (!NUpload.showRetryButtonRef.value)
            return false;
          const { file } = props;
          return ["error"].includes(file.status);
        });
        const mergedThumbnailUrlRef = useMemo(() => {
          return thumbnailUrlRef.value || props.file.thumbnailUrl || props.file.url;
        });
        const showPreviewButtonRef = vue.computed(() => {
          if (!NUpload.showPreviewButtonRef.value)
            return false;
          const {
            file: { status },
            listType
          } = props;
          return ["finished"].includes(status) && mergedThumbnailUrlRef.value && listType === "image-card";
        });
        function handleRetryClick() {
          NUpload.submit(props.file.id);
        }
        function handleRemoveOrCancelClick(e) {
          e.preventDefault();
          const { file } = props;
          if (["finished", "pending", "error"].includes(file.status)) {
            handleRemove(file);
          } else if (["uploading"].includes(file.status)) {
            handleAbort(file);
          } else {
            warn$2("upload", "The button clicked type is unknown.");
          }
        }
        function handleDownloadClick(e) {
          e.preventDefault();
          handleDownload(props.file);
        }
        function handleRemove(file) {
          const {
            xhrMap,
            doChange,
            onRemoveRef: { value: onRemove },
            mergedFileListRef: { value: mergedFileList }
          } = NUpload;
          void Promise.resolve(
            onRemove ? onRemove({
              file: Object.assign({}, file),
              fileList: mergedFileList
            }) : true
          ).then((result) => {
            if (result === false)
              return;
            const fileAfterChange = Object.assign({}, file, {
              status: "removed"
            });
            xhrMap.delete(file.id);
            doChange(fileAfterChange, void 0, {
              remove: true
            });
          });
        }
        function handleDownload(file) {
          const {
            onDownloadRef: { value: onDownload }
          } = NUpload;
          void Promise.resolve(
            onDownload ? onDownload(Object.assign({}, file)) : true
          ).then((res) => {
            if (res !== false) {
              download(file.url, file.name);
            }
          });
        }
        function handleAbort(file) {
          const { xhrMap } = NUpload;
          const xhr = xhrMap.get(file.id);
          xhr?.abort();
          handleRemove(Object.assign({}, file));
        }
        function handlePreviewClick() {
          const {
            onPreviewRef: { value: onPreview }
          } = NUpload;
          if (onPreview) {
            onPreview(props.file);
          } else if (props.listType === "image-card") {
            const { value } = imageRef;
            if (!value)
              return;
            value.click();
          }
        }
        const deriveFileThumbnailUrl = async () => {
          const { listType } = props;
          if (listType !== "image" && listType !== "image-card") {
            return;
          }
          if (!environmentSupportFile || !(props.file.file instanceof File)) {
            return;
          }
          thumbnailUrlRef.value = await NUpload.getFileThumbnailUrl(props.file);
        };
        vue.watchEffect(() => {
          void deriveFileThumbnailUrl();
        });
        return {
          mergedTheme: NUpload.mergedThemeRef,
          progressStatus: progressStatusRef,
          buttonType: buttonTypeRef,
          showProgress: showProgressRef,
          disabled: NUpload.mergedDisabledRef,
          showCancelButton: showCancelButtonRef,
          showRemoveButton: showRemoveButtonRef,
          showDownloadButton: showDownloadButtonRef,
          showRetryButton: showRetryButtonRef,
          showPreviewButton: showPreviewButtonRef,
          mergedThumbnailUrl: mergedThumbnailUrlRef,
          imageRef,
          handleRemoveOrCancelClick,
          handleDownloadClick,
          handleRetryClick,
          handlePreviewClick
        };
      },
      render() {
        const { clsPrefix, mergedTheme, listType, file } = this;
        let icon;
        const isImageType = listType === "image";
        const isImageCardType = listType === "image-card";
        if (isImageType || isImageCardType) {
          icon = !isImageFile(file) ? /* @__PURE__ */ vue.h("span", {
            class: `${clsPrefix}-upload-file-info__thumbnail`
          }, /* @__PURE__ */ vue.h(NBaseIcon, {
            clsPrefix
          }, { default: () => documentIcon })) : this.mergedThumbnailUrl && file.status !== "error" ? /* @__PURE__ */ vue.h("a", {
            rel: "noopener noreferer",
            target: "_blank",
            href: file.url || void 0,
            class: `${clsPrefix}-upload-file-info__thumbnail`,
            onClick: this.handlePreviewClick
          }, listType === "image-card" ? /* @__PURE__ */ vue.h(NImage, {
            src: this.mergedThumbnailUrl || void 0,
            previewSrc: file.url || void 0,
            alt: file.name,
            ref: "imageRef"
          }) : /* @__PURE__ */ vue.h("img", {
            src: this.mergedThumbnailUrl || void 0,
            alt: file.name
          })) : /* @__PURE__ */ vue.h("span", {
            class: `${clsPrefix}-upload-file-info__thumbnail`
          }, /* @__PURE__ */ vue.h(NBaseIcon, {
            clsPrefix
          }, { default: () => imageIcon }));
        } else {
          icon = /* @__PURE__ */ vue.h("span", {
            class: `${clsPrefix}-upload-file-info__thumbnail`
          }, /* @__PURE__ */ vue.h(NBaseIcon, {
            clsPrefix
          }, { default: () => /* @__PURE__ */ vue.h(AttachIcon, null) }));
        }
        const progress = /* @__PURE__ */ vue.h(NUploadProgress, {
          show: this.showProgress,
          percentage: file.percentage || 0,
          status: this.progressStatus
        });
        const showName = listType === "text" || listType === "image";
        return /* @__PURE__ */ vue.h("div", {
          class: [
            `${clsPrefix}-upload-file`,
            `${clsPrefix}-upload-file--${this.progressStatus}-status`,
            file.url && file.status !== "error" && listType !== "image-card" && `${clsPrefix}-upload-file--with-url`,
            `${clsPrefix}-upload-file--${listType}-type`
          ]
        }, /* @__PURE__ */ vue.h("div", {
          class: `${clsPrefix}-upload-file-info`
        }, icon, /* @__PURE__ */ vue.h("div", {
          class: `${clsPrefix}-upload-file-info__name`
        }, showName && (file.url && file.status !== "error" ? /* @__PURE__ */ vue.h("a", {
          rel: "noopener noreferer",
          target: "_blank",
          href: file.url || void 0,
          onClick: this.handlePreviewClick
        }, file.name) : /* @__PURE__ */ vue.h("span", {
          onClick: this.handlePreviewClick
        }, file.name)), isImageType && progress), /* @__PURE__ */ vue.h("div", {
          class: [
            `${clsPrefix}-upload-file-info__action`,
            `${clsPrefix}-upload-file-info__action--${listType}-type`
          ]
        }, this.showPreviewButton ? /* @__PURE__ */ vue.h(NButton, {
          key: "preview",
          quaternary: true,
          type: this.buttonType,
          onClick: this.handlePreviewClick,
          theme: mergedTheme.peers.Button,
          themeOverrides: mergedTheme.peerOverrides.Button,
          builtinThemeOverrides: buttonThemeOverrides
        }, {
          icon: () => /* @__PURE__ */ vue.h(NBaseIcon, {
            clsPrefix
          }, { default: () => /* @__PURE__ */ vue.h(EyeIcon, null) })
        }) : null, (this.showRemoveButton || this.showCancelButton) && !this.disabled && /* @__PURE__ */ vue.h(NButton, {
          key: "cancelOrTrash",
          theme: mergedTheme.peers.Button,
          themeOverrides: mergedTheme.peerOverrides.Button,
          quaternary: true,
          builtinThemeOverrides: buttonThemeOverrides,
          type: this.buttonType,
          onClick: this.handleRemoveOrCancelClick
        }, {
          icon: () => /* @__PURE__ */ vue.h(NIconSwitchTransition, null, {
            default: () => this.showRemoveButton ? /* @__PURE__ */ vue.h(NBaseIcon, {
              clsPrefix,
              key: "trash"
            }, { default: () => /* @__PURE__ */ vue.h(TrashIcon, null) }) : /* @__PURE__ */ vue.h(NBaseIcon, {
              clsPrefix,
              key: "cancel"
            }, { default: () => /* @__PURE__ */ vue.h(CancelIcon, null) })
          })
        }), this.showRetryButton && !this.disabled && /* @__PURE__ */ vue.h(NButton, {
          key: "retry",
          quaternary: true,
          type: this.buttonType,
          onClick: this.handleRetryClick,
          theme: mergedTheme.peers.Button,
          themeOverrides: mergedTheme.peerOverrides.Button,
          builtinThemeOverrides: buttonThemeOverrides
        }, {
          icon: () => /* @__PURE__ */ vue.h(NBaseIcon, {
            clsPrefix
          }, { default: () => /* @__PURE__ */ vue.h(RetryIcon, null) })
        }), this.showDownloadButton ? /* @__PURE__ */ vue.h(NButton, {
          key: "download",
          quaternary: true,
          type: this.buttonType,
          onClick: this.handleDownloadClick,
          theme: mergedTheme.peers.Button,
          themeOverrides: mergedTheme.peerOverrides.Button,
          builtinThemeOverrides: buttonThemeOverrides
        }, {
          icon: () => /* @__PURE__ */ vue.h(NBaseIcon, {
            clsPrefix
          }, { default: () => /* @__PURE__ */ vue.h(DownloadIcon, null) })
        }) : null)), !isImageType && progress);
      }
    });

    var NUploadFileList = vue.defineComponent({
      name: "UploadFileList",
      setup(_, { slots }) {
        const NUpload = vue.inject(uploadInjectionKey, null);
        if (!NUpload) {
          throwError(
            "upload-file-list",
            "`n-upload-file-list` must be placed inside `n-upload`."
          );
        }
        const {
          abstractRef,
          mergedClsPrefixRef,
          listTypeRef,
          mergedFileListRef,
          fileListStyleRef,
          cssVarsRef,
          themeClassRef,
          maxReachedRef,
          showTriggerRef,
          imageGroupPropsRef
        } = NUpload;
        const isImageCardTypeRef = vue.computed(
          () => listTypeRef.value === "image-card"
        );
        const renderFileList = () => mergedFileListRef.value.map((file) => /* @__PURE__ */ vue.h(NUploadFile, {
          clsPrefix: mergedClsPrefixRef.value,
          key: file.id,
          file,
          listType: listTypeRef.value
        }));
        const renderUploadFileList = () => isImageCardTypeRef.value ? /* @__PURE__ */ vue.h(NImageGroup, {
          ...imageGroupPropsRef.value
        }, { default: renderFileList }) : /* @__PURE__ */ vue.h(NFadeInExpandTransition, {
          group: true
        }, {
          default: renderFileList
        });
        return () => {
          const { value: mergedClsPrefix } = mergedClsPrefixRef;
          const { value: abstract } = abstractRef;
          return /* @__PURE__ */ vue.h("div", {
            class: [
              `${mergedClsPrefix}-upload-file-list`,
              isImageCardTypeRef.value && `${mergedClsPrefix}-upload-file-list--grid`,
              abstract ? themeClassRef?.value : void 0
            ],
            style: [
              abstract && cssVarsRef ? cssVarsRef.value : "",
              fileListStyleRef.value
            ]
          }, renderUploadFileList(), showTriggerRef.value && !maxReachedRef.value && isImageCardTypeRef.value && /* @__PURE__ */ vue.h(NUploadTrigger, null, slots));
        };
      }
    });

    var style$1 = c$1([cB("upload", "width: 100%;", [cM("dragger-inside", [cB("upload-trigger", `
        display: block;
      `)]), cM("drag-over", [cB("upload-dragger", `
        border: var(--n-dragger-border-hover);
      `)])]), cB("upload-dragger", `
    cursor: pointer;
    box-sizing: border-box;
    width: 100%;
    text-align: center;
    border-radius: var(--n-border-radius);
    padding: 24px;
    opacity: 1;
    transition:
      opacity .3s var(--n-bezier),
      border-color .3s var(--n-bezier),
      background-color .3s var(--n-bezier);
    background-color: var(--n-dragger-color);
    border: var(--n-dragger-border);
  `, [c$1("&:hover", `
      border: var(--n-dragger-border-hover);
    `), cM("disabled", `
      cursor: not-allowed;
    `)]), cB("upload-trigger", `
    display: inline-block;
    box-sizing: border-box;
    opacity: 1;
    transition: opacity .3s var(--n-bezier);
  `, [c$1("+", [cB("upload-file-list", "margin-top: 8px;")]), cM("disabled", `
      opacity: var(--n-item-disabled-opacity);
      cursor: not-allowed;
    `), cM("image-card", `
      width: 96px;
      height: 96px;
    `, [cB("base-icon", `
        font-size: 24px;
      `), cB("upload-dragger", `
        padding: 0;
        height: 100%;
        width: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
      `)])]), cB("upload-file-list", `
    line-height: var(--n-line-height);
    opacity: 1;
    transition: opacity .3s var(--n-bezier);
  `, [c$1("a, img", "outline: none;"), cM("disabled", `
      opacity: var(--n-item-disabled-opacity);
      cursor: not-allowed;
    `, [cB("upload-file", "cursor: not-allowed;")]), cM("grid", `
      display: grid;
      grid-template-columns: repeat(auto-fill, 96px);
      grid-gap: 8px;
      margin-top: 0;
    `), cB("upload-file", `
      display: block;
      box-sizing: border-box;
      cursor: default;
      padding: 0px 12px 0 6px;
      transition: background-color .3s  var(--n-bezier);
      border-radius: var(--n-border-radius);
    `, [fadeInHeightExpandTransition(), cB("progress", [fadeInHeightExpandTransition({
      foldPadding: true
    })]), c$1("&:hover", `
        background-color: var(--n-item-color-hover);
      `, [cB("upload-file-info", [cE("action", `
            opacity: 1;
          `)])]), cM("image-type", `
        border-radius: var(--n-border-radius);
        text-decoration: underline;
        text-decoration-color: #0000;
      `, [cB("upload-file-info", `
          padding-top: 0px;
          padding-bottom: 0px;
          width: 100%;
          height: 100%;
          display: flex;
          justify-content: space-between;
          align-items: center;
          padding: 6px 0;
        `, [cB("progress", `
            padding: 2px 0;
            margin-bottom: 0;
          `), cE("name", `
            padding: 0 8px;
          `), cE("thumbnail", `
            width: 32px;
            height: 32px;
            font-size: 28px;
            display: flex;
            justify-content: center;
            align-items: center;
          `, [c$1("img", `
              width: 100%;
            `)])])]), cM("text-type", [cB("progress", `
          box-sizing: border-box;
          padding-bottom: 6px;
          margin-bottom: 6px;
        `)]), cM("image-card-type", `
        position: relative;
        width: 96px;
        height: 96px;
        border: var(--n-item-border-image-card);
        border-radius: var(--n-border-radius);
        padding: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: border-color .3s var(--n-bezier), background-color .3s var(--n-bezier);
        border-radius: var(--n-border-radius);
        overflow: hidden;
      `, [cB("progress", `
          position: absolute;
          left: 8px;
          bottom: 8px;
          right: 8px;
          width: unset;
        `), cB("upload-file-info", `
          padding: 0;
          width: 100%;
          height: 100%;
        `, [cE("thumbnail", `
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 36px;
          `, [c$1("img", `
              width: 100%;
            `)])]), c$1("&::before", `
          position: absolute;
          z-index: 1;
          left: 0;
          right: 0;
          top: 0;
          bottom: 0;
          border-radius: inherit;
          opacity: 0;
          transition: opacity .2s var(--n-bezier);
          content: "";
        `), c$1("&:hover", [c$1("&::before", "opacity: 1;"), cB("upload-file-info", [cE("thumbnail", "opacity: .12;")])])]), cM("error-status", [c$1("&:hover", `
          background-color: var(--n-item-color-hover-error);
        `), cB("upload-file-info", [cE("name", "color: var(--n-item-text-color-error);"), cE("thumbnail", "color: var(--n-item-text-color-error);")]), cM("image-card-type", `
          border: var(--n-item-border-image-card-error);
        `)]), cM("with-url", `
        cursor: pointer;
      `, [cB("upload-file-info", [cE("name", `
            color: var(--n-item-text-color-success);
            text-decoration-color: var(--n-item-text-color-success);
          `, [c$1("a", `
              text-decoration: underline;
            `)])])]), cB("upload-file-info", `
        position: relative;
        padding-top: 6px;
        padding-bottom: 6px;
        display: flex;
        flex-wrap: nowrap;
      `, [cE("thumbnail", `
          font-size: 18px;
          opacity: 1;
          transition: opacity .2s var(--n-bezier);
          color: var(--n-item-icon-color);
        `, [cB("base-icon", `
            margin-right: 2px;
            vertical-align: middle;
            transition: color .3s var(--n-bezier);
          `)]), cE("action", `
          padding-top: inherit;
          padding-bottom: inherit;
          position: absolute;
          right: 0;
          top: 0;
          bottom: 0;
          width: 80px;
          display: flex;
          align-items: center;
          transition: opacity .2s var(--n-bezier);
          justify-content: flex-end;
          opacity: 0;
        `, [cB("button", [c$1("&:not(:last-child)", {
      marginRight: "4px"
    }), cB("base-icon", [c$1("svg", [iconSwitchTransition()])])]), cM("image-type", `
            position: relative;
            max-width: 80px;
            width: auto;
          `), cM("image-card-type", `
            z-index: 2;
            position: absolute;
            width: 100%;
            height: 100%;
            left: 0;
            right: 0;
            bottom: 0;
            top: 0;
            display: flex;
            justify-content: center;
            align-items: center;
          `)]), cE("name", `
          color: var(--n-item-text-color);
          flex: 1;
          display: flex;
          justify-content: center;
          text-overflow: ellipsis;
          overflow: hidden;
          flex-direction: column;
          text-decoration-color: #0000;
          font-size: var(--n-font-size);
          transition:
            color .3s var(--n-bezier),
            text-decoration-color .3s var(--n-bezier);
        `, [c$1("a", `
            color: inherit;
            text-decoration: underline;
          `)])])])]), cB("upload-file-input", `
    display: block;
    width: 0;
    height: 0;
    opacity: 0;
  `)]);

    function createXhrHandlers(inst, file, xhr) {
      const { doChange, xhrMap } = inst;
      let percentage = 0;
      function handleXHRError(e) {
        let fileAfterChange = Object.assign({}, file, {
          status: "error",
          percentage
        });
        xhrMap.delete(file.id);
        fileAfterChange = createSettledFileInfo(
          inst.onError?.({ file: fileAfterChange, event: e }) || fileAfterChange
        );
        doChange(fileAfterChange, e);
      }
      function handleXHRLoad(e) {
        if (inst.isErrorState) {
          if (inst.isErrorState(xhr)) {
            handleXHRError(e);
            return;
          }
        } else {
          if (xhr.status < 200 || xhr.status >= 300) {
            handleXHRError(e);
            return;
          }
        }
        let fileAfterChange = Object.assign({}, file, {
          status: "finished",
          percentage,
          file: null
        });
        xhrMap.delete(file.id);
        fileAfterChange = createSettledFileInfo(
          inst.onFinish?.({ file: fileAfterChange, event: e }) || fileAfterChange
        );
        doChange(fileAfterChange, e);
      }
      return {
        handleXHRLoad,
        handleXHRError,
        handleXHRAbort(e) {
          const fileAfterChange = Object.assign({}, file, {
            status: "removed",
            file: null,
            percentage
          });
          xhrMap.delete(file.id);
          doChange(fileAfterChange, e);
        },
        handleXHRProgress(e) {
          const fileAfterChange = Object.assign({}, file, {
            status: "uploading"
          });
          if (e.lengthComputable) {
            const progress = Math.ceil(e.loaded / e.total * 100);
            fileAfterChange.percentage = progress;
            percentage = progress;
          }
          doChange(fileAfterChange, e);
        }
      };
    }
    function customSubmitImpl(options) {
      const { inst, file, data, headers, withCredentials, action, customRequest } = options;
      const { doChange } = options.inst;
      let percentage = 0;
      customRequest({
        file,
        data,
        headers,
        withCredentials,
        action,
        onProgress(event) {
          const fileAfterChange = Object.assign({}, file, {
            status: "uploading"
          });
          const progress = event.percent;
          fileAfterChange.percentage = progress;
          percentage = progress;
          doChange(fileAfterChange);
        },
        onFinish() {
          let fileAfterChange = Object.assign({}, file, {
            status: "finished",
            percentage,
            file: null
          });
          fileAfterChange = createSettledFileInfo(
            inst.onFinish?.({ file: fileAfterChange }) || fileAfterChange
          );
          doChange(fileAfterChange);
        },
        onError() {
          let fileAfterChange = Object.assign({}, file, {
            status: "error",
            percentage
          });
          fileAfterChange = createSettledFileInfo(
            inst.onError?.({ file: fileAfterChange }) || fileAfterChange
          );
          doChange(fileAfterChange);
        }
      });
    }
    function registerHandler(inst, file, request) {
      const handlers = createXhrHandlers(inst, file, request);
      request.onabort = handlers.handleXHRAbort;
      request.onerror = handlers.handleXHRError;
      request.onload = handlers.handleXHRLoad;
      if (request.upload) {
        request.upload.onprogress = handlers.handleXHRProgress;
      }
    }
    function unwrapFunctionValue(data, file) {
      if (typeof data === "function") {
        return data({ file });
      }
      if (data)
        return data;
      return {};
    }
    function setHeaders(request, headers, file) {
      const headersObject = unwrapFunctionValue(headers, file);
      if (!headersObject)
        return;
      Object.keys(headersObject).forEach((key) => {
        request.setRequestHeader(key, headersObject[key]);
      });
    }
    function appendData(formData, data, file) {
      const dataObject = unwrapFunctionValue(data, file);
      if (!dataObject)
        return;
      Object.keys(dataObject).forEach((key) => {
        formData.append(key, dataObject[key]);
      });
    }
    function submitImpl(inst, fieldName, file, {
      method,
      action,
      withCredentials,
      headers,
      data
    }) {
      const request = new XMLHttpRequest();
      inst.xhrMap.set(file.id, request);
      request.withCredentials = withCredentials;
      const formData = new FormData();
      appendData(formData, data, file);
      formData.append(fieldName, file.file);
      registerHandler(inst, file, request);
      if (action !== void 0) {
        request.open(method.toUpperCase(), action);
        setHeaders(request, headers, file);
        request.send(formData);
        const fileAfterChange = Object.assign({}, file, {
          status: "uploading"
        });
        inst.doChange(fileAfterChange);
      }
    }
    const uploadProps = {
      ...useTheme.props,
      name: {
        type: String,
        default: "file"
      },
      accept: String,
      action: String,
      customRequest: Function,
      directory: Boolean,
      directoryDnd: { type: Boolean, default: void 0 },
      method: {
        type: String,
        default: "POST"
      },
      multiple: Boolean,
      showFileList: {
        type: Boolean,
        default: true
      },
      data: [Object, Function],
      headers: [Object, Function],
      withCredentials: Boolean,
      disabled: {
        type: Boolean,
        default: void 0
      },
      onChange: Function,
      onRemove: Function,
      onFinish: Function,
      onError: Function,
      onBeforeUpload: Function,
      isErrorState: Function,
      onDownload: Function,
      defaultUpload: {
        type: Boolean,
        default: true
      },
      fileList: Array,
      "onUpdate:fileList": [Function, Array],
      onUpdateFileList: [Function, Array],
      fileListStyle: [String, Object],
      defaultFileList: {
        type: Array,
        default: () => []
      },
      showCancelButton: {
        type: Boolean,
        default: true
      },
      showRemoveButton: {
        type: Boolean,
        default: true
      },
      showDownloadButton: Boolean,
      showRetryButton: {
        type: Boolean,
        default: true
      },
      showPreviewButton: {
        type: Boolean,
        default: true
      },
      listType: {
        type: String,
        default: "text"
      },
      onPreview: Function,
      createThumbnailUrl: Function,
      abstract: Boolean,
      max: Number,
      showTrigger: {
        type: Boolean,
        default: true
      },
      imageGroupProps: Object,
      inputProps: Object,
      triggerStyle: [String, Object]
    };
    var Upload = vue.defineComponent({
      name: "Upload",
      props: uploadProps,
      setup(props) {
        if (props.abstract && props.listType === "image-card") {
          throwError(
            "upload",
            "when the list-type is image-card, abstract is not supported."
          );
        }
        const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
        const themeRef = useTheme(
          "Upload",
          "-upload",
          style$1,
          uploadLight$1,
          props,
          mergedClsPrefixRef
        );
        const formItem = useFormItem(props);
        const maxReachedRef = vue.computed(() => {
          const { max } = props;
          if (max !== void 0) {
            return mergedFileListRef.value.length >= max;
          }
          return false;
        });
        const uncontrolledFileListRef = vue.ref(props.defaultFileList);
        const controlledFileListRef = vue.toRef(props, "fileList");
        const inputElRef = vue.ref(null);
        const draggerInsideRef = {
          value: false
        };
        const dragOverRef = vue.ref(false);
        const xhrMap = /* @__PURE__ */ new Map();
        const _mergedFileListRef = useMergedState(
          controlledFileListRef,
          uncontrolledFileListRef
        );
        const mergedFileListRef = vue.computed(
          () => _mergedFileListRef.value.map(createSettledFileInfo)
        );
        function openOpenFileDialog() {
          inputElRef.value?.click();
        }
        function handleFileInputChange(e) {
          const target = e.target;
          handleFileAddition(
            target.files ? Array.from(target.files).map((file) => ({
              file,
              entry: null,
              source: "input"
            })) : null,
            e
          );
          target.value = "";
        }
        function doUpdateFileList(files) {
          const { "onUpdate:fileList": _onUpdateFileList, onUpdateFileList } = props;
          if (_onUpdateFileList)
            call(_onUpdateFileList, files);
          if (onUpdateFileList)
            call(onUpdateFileList, files);
          uncontrolledFileListRef.value = files;
        }
        const mergedMultipleRef = vue.computed(() => props.multiple || props.directory);
        function handleFileAddition(fileAndEntries, e) {
          if (!fileAndEntries || fileAndEntries.length === 0)
            return;
          const { onBeforeUpload } = props;
          fileAndEntries = mergedMultipleRef.value ? fileAndEntries : [fileAndEntries[0]];
          const { max, accept } = props;
          fileAndEntries = fileAndEntries.filter(({ file, source }) => {
            if (source === "dnd" && accept?.trim()) {
              return matchType(file.name, file.type, accept);
            } else {
              return true;
            }
          });
          if (max) {
            fileAndEntries = fileAndEntries.slice(
              0,
              max - mergedFileListRef.value.length
            );
          }
          const batchId = createId();
          void Promise.all(
            fileAndEntries.map(async ({ file, entry }) => {
              const fileInfo = {
                id: createId(),
                batchId,
                name: file.name,
                status: "pending",
                percentage: 0,
                file,
                url: null,
                type: file.type,
                thumbnailUrl: null,
                fullPath: entry?.fullPath ?? `/${file.webkitRelativePath || file.name}`
              };
              if (!onBeforeUpload || await onBeforeUpload({
                file: fileInfo,
                fileList: mergedFileListRef.value
              }) !== false) {
                return fileInfo;
              }
              return null;
            })
          ).then(async (fileInfos) => {
            let nextTickChain = Promise.resolve();
            fileInfos.forEach((fileInfo) => {
              nextTickChain = nextTickChain.then(vue.nextTick).then(() => {
                fileInfo && doChange(fileInfo, e, {
                  append: true
                });
              });
            });
            return await nextTickChain;
          }).then(() => {
            if (props.defaultUpload) {
              submit();
            }
          });
        }
        function submit(fileId) {
          const {
            method,
            action,
            withCredentials,
            headers,
            data,
            name: fieldName
          } = props;
          const filesToUpload = fileId !== void 0 ? mergedFileListRef.value.filter((file) => file.id === fileId) : mergedFileListRef.value;
          const shouldReupload = fileId !== void 0;
          filesToUpload.forEach((file) => {
            const { status } = file;
            if (status === "pending" || status === "error" && shouldReupload) {
              if (props.customRequest) {
                customSubmitImpl({
                  inst: {
                    doChange,
                    xhrMap,
                    onFinish: props.onFinish,
                    onError: props.onError
                  },
                  file,
                  action,
                  withCredentials,
                  headers,
                  data,
                  customRequest: props.customRequest
                });
              } else {
                submitImpl(
                  {
                    doChange,
                    xhrMap,
                    onFinish: props.onFinish,
                    onError: props.onError,
                    isErrorState: props.isErrorState
                  },
                  fieldName,
                  file,
                  {
                    method,
                    action,
                    withCredentials,
                    headers,
                    data
                  }
                );
              }
            }
          });
        }
        const doChange = (fileAfterChange, event, options = {
          append: false,
          remove: false
        }) => {
          const { append, remove } = options;
          const fileListAfterChange = Array.from(mergedFileListRef.value);
          const fileIndex = fileListAfterChange.findIndex(
            (file) => file.id === fileAfterChange.id
          );
          if (append || remove || ~fileIndex) {
            if (append) {
              fileListAfterChange.push(fileAfterChange);
            } else if (remove) {
              fileListAfterChange.splice(fileIndex, 1);
            } else {
              fileListAfterChange.splice(fileIndex, 1, fileAfterChange);
            }
            const { onChange } = props;
            if (onChange) {
              onChange({
                file: fileAfterChange,
                fileList: fileListAfterChange,
                event
              });
            }
            doUpdateFileList(fileListAfterChange);
          } else {
            warn$2("upload", "File has no corresponding id in current file list.");
          }
        };
        async function getFileThumbnailUrl(file) {
          const { createThumbnailUrl } = props;
          return createThumbnailUrl ? await createThumbnailUrl(file.file) : await createImageDataUrl(file.file);
        }
        const cssVarsRef = vue.computed(() => {
          const {
            common: { cubicBezierEaseInOut },
            self: {
              draggerColor,
              draggerBorder,
              draggerBorderHover,
              itemColorHover,
              itemColorHoverError,
              itemTextColorError,
              itemTextColorSuccess,
              itemTextColor,
              itemIconColor,
              itemDisabledOpacity,
              lineHeight,
              borderRadius,
              fontSize,
              itemBorderImageCardError,
              itemBorderImageCard
            }
          } = themeRef.value;
          return {
            "--n-bezier": cubicBezierEaseInOut,
            "--n-border-radius": borderRadius,
            "--n-dragger-border": draggerBorder,
            "--n-dragger-border-hover": draggerBorderHover,
            "--n-dragger-color": draggerColor,
            "--n-font-size": fontSize,
            "--n-item-color-hover": itemColorHover,
            "--n-item-color-hover-error": itemColorHoverError,
            "--n-item-disabled-opacity": itemDisabledOpacity,
            "--n-item-icon-color": itemIconColor,
            "--n-item-text-color": itemTextColor,
            "--n-item-text-color-error": itemTextColorError,
            "--n-item-text-color-success": itemTextColorSuccess,
            "--n-line-height": lineHeight,
            "--n-item-border-image-card-error": itemBorderImageCardError,
            "--n-item-border-image-card": itemBorderImageCard
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("upload", void 0, cssVarsRef, props) : void 0;
        vue.provide(uploadInjectionKey, {
          mergedClsPrefixRef,
          mergedThemeRef: themeRef,
          showCancelButtonRef: vue.toRef(props, "showCancelButton"),
          showDownloadButtonRef: vue.toRef(props, "showDownloadButton"),
          showRemoveButtonRef: vue.toRef(props, "showRemoveButton"),
          showRetryButtonRef: vue.toRef(props, "showRetryButton"),
          onRemoveRef: vue.toRef(props, "onRemove"),
          onDownloadRef: vue.toRef(props, "onDownload"),
          mergedFileListRef,
          triggerStyleRef: vue.toRef(props, "triggerStyle"),
          xhrMap,
          submit,
          doChange,
          showPreviewButtonRef: vue.toRef(props, "showPreviewButton"),
          onPreviewRef: vue.toRef(props, "onPreview"),
          getFileThumbnailUrl,
          listTypeRef: vue.toRef(props, "listType"),
          dragOverRef,
          openOpenFileDialog,
          draggerInsideRef,
          handleFileAddition,
          mergedDisabledRef: formItem.mergedDisabledRef,
          maxReachedRef,
          fileListStyleRef: vue.toRef(props, "fileListStyle"),
          abstractRef: vue.toRef(props, "abstract"),
          acceptRef: vue.toRef(props, "accept"),
          cssVarsRef: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClassRef: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender,
          showTriggerRef: vue.toRef(props, "showTrigger"),
          imageGroupPropsRef: vue.toRef(props, "imageGroupProps"),
          mergedDirectoryDndRef: vue.computed(() => {
            return props.directoryDnd ?? props.directory;
          })
        });
        const exposedMethods = {
          clear: () => {
            uncontrolledFileListRef.value = [];
          },
          submit,
          openOpenFileDialog
        };
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          draggerInsideRef,
          inputElRef,
          mergedTheme: themeRef,
          dragOver: dragOverRef,
          mergedMultiple: mergedMultipleRef,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle?.themeClass,
          onRender: themeClassHandle?.onRender,
          handleFileInputChange,
          ...exposedMethods
        };
      },
      render() {
        const { draggerInsideRef, mergedClsPrefix, $slots, directory, onRender } = this;
        if ($slots.default && !this.abstract) {
          const firstChild = $slots.default()[0];
          if (firstChild?.type?.[uploadDraggerKey]) {
            draggerInsideRef.value = true;
          }
        }
        const inputNode = /* @__PURE__ */ vue.h("input", {
          ...this.inputProps,
          ref: "inputElRef",
          type: "file",
          class: `${mergedClsPrefix}-upload-file-input`,
          accept: this.accept,
          multiple: this.mergedMultiple,
          onChange: this.handleFileInputChange,
          webkitdirectory: directory,
          directory
        });
        if (this.abstract) {
          return /* @__PURE__ */ vue.h(vue.Fragment, null, $slots.default?.(), /* @__PURE__ */ vue.h(vue.Teleport, {
            to: "body"
          }, inputNode));
        }
        onRender?.();
        return /* @__PURE__ */ vue.h("div", {
          class: [
            `${mergedClsPrefix}-upload`,
            draggerInsideRef.value && `${mergedClsPrefix}-upload--dragger-inside`,
            this.dragOver && `${mergedClsPrefix}-upload--drag-over`,
            this.themeClass
          ],
          style: this.cssVars
        }, inputNode, this.showTrigger && this.listType !== "image-card" && /* @__PURE__ */ vue.h(NUploadTrigger, null, $slots), this.showFileList && /* @__PURE__ */ vue.h(NUploadFileList, null, $slots));
      }
    });

    var style = c$1([cB("watermark-container", `
    position: relative;
  `, [cNotM("selectable", `
      user-select: none;
      -webkit-user-select: none;
    `), cM("global-rotate", `
      overflow: hidden;
    `), cM("fullscreen", `
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      position: fixed;
    `)]), cB("watermark", `
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    background-repeat: repeat;
  `, [cM("fullscreen", `
      position: fixed;
    `), cM("global-rotate", `
      position: absolute;
      height: max(284vh, 284vw);
      width: max(284vh, 284vw);
    `)])]);

    function getRatio(context) {
      if (!context) {
        return 1;
      }
      const backingStore = context.backingStorePixelRatio || context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;
      return (window.devicePixelRatio || 1) / backingStore;
    }
    const watermarkProps = {
      ...useTheme.props,
      debug: Boolean,
      cross: Boolean,
      fullscreen: Boolean,
      width: {
        type: Number,
        default: 32
      },
      height: {
        type: Number,
        default: 32
      },
      zIndex: {
        type: Number,
        default: 10
      },
      xGap: {
        type: Number,
        default: 0
      },
      yGap: {
        type: Number,
        default: 0
      },
      yOffset: {
        type: Number,
        default: 0
      },
      xOffset: {
        type: Number,
        default: 0
      },
      rotate: {
        type: Number,
        default: 0
      },
      image: String,
      imageOpacity: { type: Number, default: 1 },
      imageHeight: Number,
      imageWidth: Number,
      content: String,
      selectable: {
        type: Boolean,
        default: true
      },
      fontSize: {
        type: Number,
        default: 14
      },
      fontFamily: String,
      fontStyle: {
        type: String,
        default: "normal"
      },
      fontVariant: {
        type: String,
        default: ""
      },
      fontWeight: {
        type: Number,
        default: 400
      },
      fontColor: {
        type: String,
        default: "rgba(128, 128, 128, .3)"
      },
      fontStretch: {
        type: String,
        default: ""
      },
      lineHeight: {
        type: Number,
        default: 14
      },
      globalRotate: {
        type: Number,
        default: 0
      }
    };
    var Watermark = vue.defineComponent({
      name: "Watermark",
      props: watermarkProps,
      setup(props, { slots }) {
        const { mergedClsPrefixRef } = useConfig(props);
        const themeRef = useTheme(
          "Watermark",
          "-watermark",
          style,
          watermarkLight$1,
          props,
          mergedClsPrefixRef
        );
        const base64UrlRef = vue.ref("");
        const canvas = isBrowser$2 ? document.createElement("canvas") : null;
        const ctx = canvas ? canvas.getContext("2d") : null;
        const fontsReadyRef = vue.ref(false);
        onFontsReady(() => fontsReadyRef.value = true);
        vue.watchEffect(() => {
          if (!canvas)
            return;
          void fontsReadyRef.value;
          const ratio = getRatio(ctx);
          const {
            xGap,
            yGap,
            width,
            height,
            yOffset,
            xOffset,
            rotate,
            image,
            content,
            fontColor,
            fontStyle,
            fontVariant,
            fontStretch,
            fontWeight,
            fontFamily,
            fontSize,
            lineHeight,
            debug
          } = props;
          const canvasWidth = (xGap + width) * ratio;
          const canvasHeight = (yGap + height) * ratio;
          const canvasOffsetLeft = xOffset * ratio;
          const canvasOffsetTop = yOffset * ratio;
          canvas.width = canvasWidth;
          canvas.height = canvasHeight;
          if (ctx) {
            ctx.translate(0, 0);
            const markWidth = width * ratio;
            const markHeight = height * ratio;
            if (debug) {
              ctx.strokeStyle = "grey";
              ctx.strokeRect(0, 0, markWidth, markHeight);
            }
            ctx.rotate(rotate * (Math.PI / 180));
            if (image) {
              const img = new Image();
              img.crossOrigin = "anonymous";
              img.referrerPolicy = "no-referrer";
              img.src = image;
              img.onload = () => {
                ctx.globalAlpha = props.imageOpacity;
                const { imageWidth, imageHeight } = props;
                ctx.drawImage(
                  img,
                  canvasOffsetLeft,
                  canvasOffsetTop,
                  (props.imageWidth || (imageHeight ? img.width * imageHeight / img.height : img.width)) * ratio,
                  (props.imageHeight || (imageWidth ? img.height * imageWidth / img.width : img.height)) * ratio
                );
                base64UrlRef.value = canvas.toDataURL();
              };
            } else if (content) {
              if (debug) {
                ctx.strokeStyle = "green";
                ctx.strokeRect(0, 0, markWidth, markHeight);
              }
              ctx.font = `${fontStyle} ${fontVariant} ${fontWeight} ${fontStretch} ${fontSize * ratio}px/${lineHeight * ratio}px ${fontFamily || themeRef.value.self.fontFamily}`;
              ctx.fillStyle = fontColor;
              ctx.fillText(
                content,
                canvasOffsetLeft,
                canvasOffsetTop + lineHeight * ratio
              );
              base64UrlRef.value = canvas.toDataURL();
            }
          } else {
            warnOnce("watermark", "Canvas is not supported in the browser.");
          }
        });
        return () => {
          const { globalRotate, fullscreen, zIndex } = props;
          const mergedClsPrefix = mergedClsPrefixRef.value;
          const isFullScreenGlobalRotate = globalRotate !== 0 && fullscreen;
          const rotatedImageOffset = "max(142vh, 142vw)";
          const watermarkNode = /* @__PURE__ */ vue.h("div", {
            class: [
              `${mergedClsPrefix}-watermark`,
              globalRotate !== 0 && `${mergedClsPrefix}-watermark--global-rotate`,
              fullscreen && `${mergedClsPrefix}-watermark--fullscreen`
            ],
            style: {
              transform: globalRotate ? `translateX(-50%) translateY(-50%) rotate(${globalRotate}deg)` : void 0,
              zIndex: isFullScreenGlobalRotate ? void 0 : zIndex,
              backgroundSize: `${props.xGap + props.width}px`,
              backgroundPosition: globalRotate === 0 ? props.cross ? `${props.width / 2}px ${props.height / 2}px, 0 0` : "" : props.cross ? `calc(${rotatedImageOffset} + ${props.width / 2}px) calc(${rotatedImageOffset} + ${props.height / 2}px), ${rotatedImageOffset} ${rotatedImageOffset}` : rotatedImageOffset,
              backgroundImage: props.cross ? `url(${base64UrlRef.value}), url(${base64UrlRef.value})` : `url(${base64UrlRef.value})`
            }
          });
          if (props.fullscreen && !globalRotate)
            return watermarkNode;
          return /* @__PURE__ */ vue.h("div", {
            class: [
              `${mergedClsPrefix}-watermark-container`,
              globalRotate !== 0 && `${mergedClsPrefix}-watermark-container--global-rotate`,
              fullscreen && `${mergedClsPrefix}-watermark-container--fullscreen`,
              props.selectable && `${mergedClsPrefix}-watermark-container--selectable`
            ],
            style: {
              zIndex: isFullScreenGlobalRotate ? zIndex : void 0
            }
          }, slots.default?.(), watermarkNode);
        };
      }
    });

    const NInjectionExtractor = vue.defineComponent({
      name: "InjectionExtractor",
      props: {
        onSetup: Function
      },
      setup(props, { slots }) {
        props.onSetup?.();
        return () => slots.default?.();
      }
    });

    const injectionFactoryMap = {
      message: useMessage,
      notification: useNotification,
      loadingBar: useLoadingBar,
      dialog: useDialog
    };
    function createDiscreteApp(_ref) {
      let {
        providersAndProps,
        configProviderProps
      } = _ref;
      const extractedApi = {};

      const App2 = () => {
        return vue.h(NConfigProvider, vue.unref(configProviderProps), {
          default: () => providersAndProps.map(_ref2 => {
            let {
              type,
              Provider,
              props
            } = _ref2;
            return vue.h(Provider, vue.unref(props), {
              default: () => vue.h(NInjectionExtractor, {
                onSetup: () => extractedApi[type] = injectionFactoryMap[type]()
              })
            });
          })
        });
      };

      let app = vue.createApp(App2);
      let hostEl = document.createElement("div");
      document.body.appendChild(hostEl);
      app.mount(hostEl);

      const unmount = () => {
        var _hostEl$parentNode;

        if (app === null || hostEl === null) {
          warn$2("discrete", "unmount call no need because discrete app has been unmounted");
          return;
        }

        app.unmount();
        (_hostEl$parentNode = hostEl.parentNode) === null || _hostEl$parentNode === void 0 ? void 0 : _hostEl$parentNode.removeChild(hostEl);
        hostEl = null;
        app = null;
      };

      return {
        unmount,
        ...extractedApi
      };
    }

    function createDiscreteApi(includes) {
      let {
        configProviderProps,
        messageProviderProps,
        dialogProviderProps,
        notificationProviderProps,
        loadingBarProviderProps
      } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      const providersAndProps = [];
      includes.forEach(type => {
        switch (type) {
          case "message":
            providersAndProps.push({
              type,
              Provider: NMessageProvider,
              props: messageProviderProps
            });
            break;

          case "notification":
            providersAndProps.push({
              type,
              Provider: NNotificationProvider,
              props: notificationProviderProps
            });
            break;

          case "dialog":
            providersAndProps.push({
              type,
              Provider: NDialogProvider,
              props: dialogProviderProps
            });
            break;

          case "loadingBar":
            providersAndProps.push({
              type,
              Provider: NLoadingBarProvider,
              props: loadingBarProviderProps
            });
            break;
        }
      });
      const discreteApp = createDiscreteApp({
        providersAndProps,
        configProviderProps
      });
      return discreteApp;
    }

    var components = /*#__PURE__*/Object.freeze({
        __proto__: null,
        NAffix: NAffix,
        affixProps: affixProps,
        NAlert: Alert,
        alertProps: alertProps,
        NAnchor: AnchorAdapter,
        anchorProps: anchorProps,
        NAnchorLink: Link,
        anchorLinkProps: anchorLinkProps,
        NAutoComplete: AutoComplete,
        autoCompleteProps: autoCompleteProps,
        NAvatar: NAvatar,
        avatarProps: avatarProps,
        NAvatarGroup: AvatarGroup,
        avatarGroupProps: avatarGroupProps,
        NBackTop: BackTop,
        backTopProps: backTopProps,
        NBadge: Badge,
        badgeProps: badgeProps,
        NBreadcrumb: Breadcrumb,
        breadcrumbProps: breadcrumbProps,
        NBreadcrumbItem: BreadcrumbItem,
        breadcrumbItemProps: breadcrumbItemProps,
        NButton: NButton,
        NxButton: XButton,
        buttonProps: buttonProps,
        NButtonGroup: NButtonGroup,
        buttonGroupProps: buttonGroupProps,
        NCalendar: Calendar,
        calendarProps: calendarProps,
        NColorPicker: NColorPicker,
        colorPickerProps: colorPickerProps,
        NCard: NCard,
        cardProps: cardProps,
        NCarousel: Carousel,
        carouselProps: carouselProps,
        NCarouselItem: NCarouselItem,
        NCascader: Cascader,
        cascaderProps: cascaderProps,
        NCheckbox: NCheckbox,
        checkboxProps: checkboxProps,
        NCheckboxGroup: NCheckboxGroup,
        checkboxGroupProps: checkboxGroupProps,
        NCode: NCode,
        codeProps: codeProps,
        NCollapse: NCollapse,
        collapseProps: collapseProps,
        NCollapseItem: NCollapseItem,
        collapseItemProps: collapseItemProps,
        NCollapseTransition: CollapseTransition,
        collapseTransitionProps: collapseTransitionProps,
        NConfigProvider: NConfigProvider,
        configProviderProps: configProviderProps,
        NCountdown: Countdown,
        countdownProps: countdownProps,
        NNumberAnimation: NumberAnimation,
        numberAnimationProps: numberAnimationProps,
        NDataTable: DataTable,
        dataTableProps: dataTableProps,
        NDatePicker: DatePicker,
        datePickerProps: datePickerProps,
        NDescriptions: Descriptions,
        descriptionsProps: descriptionsProps,
        NDescriptionsItem: DescriptionsItem,
        descriptionsItemProps: descriptionsItemProps,
        NDialog: NDialog,
        dialogProps: dialogProps,
        NDialogProvider: NDialogProvider,
        dialogProviderProps: dialogProviderProps,
        useDialog: useDialog,
        NDivider: NDivider,
        dividerProps: dividerProps,
        NDrawer: Drawer,
        drawerProps: drawerProps,
        NDrawerContent: DrawerContent,
        drawerContentProps: drawerContentProps,
        NDropdown: NDropdown,
        dropdownProps: dropdownProps,
        NDynamicInput: DynamicInput,
        dynamicInputProps: dynamicInputProps,
        NDynamicTags: DynamicTags,
        dynamicTagsProps: dynamicTagsProps,
        NElement: NElement,
        elementProps: elementProps,
        NEl: NElement,
        NEllipsis: NEllipsis,
        ellipsisProps: ellipsisProps,
        NEmpty: NEmpty,
        emptyProps: emptyProps,
        NForm: Form,
        formProps: formProps,
        NFormItem: NFormItem,
        formItemProps: formItemProps,
        NFormItemGridItem: FormItemGridItem,
        NFormItemGi: FormItemGridItem,
        formItemGiProps: formItemGiProps,
        formItemGridItemProps: formItemGiProps,
        NFormItemCol: NFormItemCol,
        NFormItemRow: FormItemRow,
        NGlobalStyle: GlobalStyle,
        NGradientText: GradientText,
        gradientTextProps: gradientTextProps,
        NGrid: Grid,
        gridProps: gridProps,
        NGridItem: NGridItem,
        gridItemProps: gridItemProps,
        NGi: NGridItem,
        giProps: gridItemProps,
        NIcon: NIcon,
        iconProps: iconProps,
        NIconWrapper: NIconWrapper,
        iconWrapperProps: iconWrapperProps,
        NImage: NImage,
        imageProps: imageProps,
        NImageGroup: NImageGroup,
        imageGroupProps: imageGroupProps,
        NInput: NInput,
        inputProps: inputProps,
        NInputGroup: NInputGroup,
        inputGroupProps: inputGroupProps,
        NInputGroupLabel: InputGroupLabel,
        inputGroupLabelProps: inputGroupLabelProps,
        NInputNumber: InputNumber,
        inputNumberProps: inputNumberProps,
        NLayout: Layout,
        layoutProps: layoutProps,
        layoutContentProps: layoutProps,
        NLayoutContent: LayoutContent,
        NLayoutHeader: LayoutHeader,
        layoutHeaderProps: headerProps$1,
        NLayoutFooter: LayoutFooter,
        layoutFooterProps: layoutFooterProps,
        NLayoutSider: LayoutSider,
        layoutSiderProps: layoutSiderProps,
        NRow: NRow,
        rowProps: rowProps,
        NCol: NCol,
        colProps: colProps,
        NLegacyTransfer: Transfer$1,
        legacyTransferProps: transferProps$1,
        NList: List,
        listProps: listProps,
        NListItem: ListItem,
        NLoadingBarProvider: NLoadingBarProvider,
        loadingBarProviderProps: loadingBarProviderProps,
        useLoadingBar: useLoadingBar,
        NLog: Log,
        logProps: logProps,
        NMenu: Menu,
        menuProps: menuProps,
        NMention: Mention,
        mentionProps: mentionProps,
        NMessageProvider: NMessageProvider,
        messageProviderProps: messageProviderProps,
        useMessage: useMessage,
        NModal: NModal,
        modalProps: modalProps,
        NNotificationProvider: NNotificationProvider,
        notificationProviderProps: notificationProviderProps,
        useNotification: useNotification,
        NPageHeader: PageHeader,
        pageHeaderProps: pageHeaderProps,
        NPagination: NPagination,
        paginationProps: paginationProps,
        NPopconfirm: Popconfirm,
        popconfirmProps: popconfirmProps,
        NPopover: NPopover,
        popoverProps: popoverProps,
        NPopselect: NPopselect,
        popselectProps: popselectProps,
        NProgress: NProgress,
        progressProps: progressProps,
        NRadio: NRadio,
        radioProps: radioProps,
        NRadioGroup: NRadioGroup,
        radioGroupProps: radioGroupProps,
        NRadioButton: RadioButton,
        radioButtonProps: radioButtonProps,
        NRate: Rate,
        rateProps: rateProps,
        NResult: Result,
        resultProps: resultProps,
        NScrollbar: Scrollbar$1,
        scrollbarProps: scrollbarProps,
        NSelect: NSelect,
        selectProps: selectProps,
        NSkeleton: Skeleton,
        skeletonProps: skeletonProps,
        NSlider: Slider,
        sliderProps: sliderProps,
        NSpace: NSpace,
        spaceProps: spaceProps,
        NSpin: Spin,
        spinProps: spinProps,
        NStatistic: Statistic,
        statisticProps: statisticProps,
        NSteps: Steps,
        stepsProps: stepsProps,
        NStep: Step,
        stepProps: stepProps,
        NSwitch: Switch,
        switchProps: switchProps,
        NTable: Table,
        tableProps: tableProps,
        NTh: Th,
        NTr: Tr,
        NTd: Td,
        NThead: Thead,
        NTbody: Tbody,
        NTabs: Tabs,
        tabsProps: tabsProps,
        NTabPane: TabPane,
        tabPaneProps: tabPaneProps,
        NTab: Tab,
        tabProps: tabProps,
        NTag: NTag,
        tagProps: tagProps,
        NThing: Thing,
        thingProps: thingProps,
        NTime: Time,
        timeProps: timeProps,
        NTimePicker: NTimePicker,
        timePickerProps: timePickerProps,
        NTimeline: Timeline,
        timelineProps: timelineProps,
        NTimelineItem: TimelineItem,
        timelineItemProps: timelineItemProps,
        NTooltip: NTooltip,
        tooltipProps: tooltipProps,
        NTransfer: Transfer,
        transferProps: transferProps,
        NTree: NTree,
        treeProps: treeProps,
        NTreeSelect: TreeSelect,
        treeSelectProps: treeSelectProps,
        NH1: NH1,
        NH2: NH2,
        NH3: NH3,
        NH4: NH4,
        NH5: NH5,
        NH6: NH6,
        h1Props: headerProps,
        h2Props: headerProps,
        h3Props: headerProps,
        h4Props: headerProps,
        h5Props: headerProps,
        h6Props: headerProps,
        NA: a,
        aProps: aProps,
        NP: p,
        pProps: pProps,
        NBlockquote: blockquote,
        blockquoteProps: blockquoteProps,
        NHr: hr,
        NUl: ul,
        ulProps: ulProps,
        NOl: ol,
        olProps: olProps,
        NLi: li,
        NText: text,
        textProps: textProps,
        NUpload: Upload,
        uploadProps: uploadProps,
        NUploadDragger: NUploadDragger,
        NUploadTrigger: NUploadTrigger,
        NUploadFileList: NUploadFileList,
        NWatermark: Watermark,
        watermarkProps: watermarkProps,
        createDiscreteApi: createDiscreteApi
    });

    var version = "2.32.2";

    function create() {
      let {
        componentPrefix = "N",
        components = []
      } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      const installTargets = [];

      function registerComponent(app, name, component) {
        const registered = app.component(componentPrefix + name);

        if (!registered) {
          app.component(componentPrefix + name, component);
        }
      }

      function install(app) {
        if (installTargets.includes(app)) return;
        installTargets.push(app);
        components.forEach(component => {
          const {
            name,
            alias
          } = component;
          registerComponent(app, name, component);

          if (alias) {
            alias.forEach(aliasName => {
              registerComponent(app, aliasName, component);
            });
          }
        });
      }

      return {
        version,
        componentPrefix,
        install
      };
    }

    const naive = create({
      components: Object.keys(components).map(key => components[key])
    });
    var naive$1 = naive;
    const install = naive.install;

    function useThemeVars() {
      const configProviderInjection = vue.inject(configProviderInjectionKey, null);
      return vue.computed(() => {
        if (configProviderInjection === null) return commonLight;
        const {
          mergedThemeRef: {
            value: mergedTheme
          },
          mergedThemeOverridesRef: {
            value: mergedThemeOverrides
          }
        } = configProviderInjection;
        const currentThemeVars = (mergedTheme === null || mergedTheme === void 0 ? void 0 : mergedTheme.common) || commonLight;

        if (mergedThemeOverrides !== null && mergedThemeOverrides !== void 0 && mergedThemeOverrides.common) {
          return Object.assign({}, currentThemeVars, mergedThemeOverrides.common);
        } else {
          return currentThemeVars;
        }
      });
    }

    const darkTheme = {
      name: "dark",
      common: commonDark,
      Alert: alertDark$1,
      Anchor: anchorDark$1,
      AutoComplete: autoCompleteDark$1,
      Avatar: avatarDark$1,
      AvatarGroup: avatarGroupDark$1,
      BackTop: backTopDark$1,
      Badge: badgeDark$1,
      Breadcrumb: breadcrumbDark$1,
      Button: buttonDark$1,
      ButtonGroup: buttonGroupDark$1,
      Calendar: calendarDark$1,
      Card: cardDark$1,
      Carousel: carouselDark$1,
      Cascader: cascaderDark$1,
      Checkbox: checkboxDark$1,
      Code: codeDark$1,
      Collapse: collapseDark$1,
      CollapseTransition: collapseTransitionDark$1,
      ColorPicker: colorPickerDark$1,
      DataTable: dataTableDark$1,
      DatePicker: datePickerDark$1,
      Descriptions: descriptionsDark$1,
      Dialog: dialogDark$1,
      Divider: dividerDark$1,
      Drawer: drawerDark$1,
      Dropdown: dropdownDark$1,
      DynamicInput: dynamicInputDark$1,
      DynamicTags: dynamicTagsDark$1,
      Element: elementDark$1,
      Empty: emptyDark$1,
      Ellipsis: ellipsisDark$1,
      Form: formDark,
      GradientText: gradientTextDark$1,
      Icon: iconDark$2,
      IconWrapper: iconWrapperDark,
      Image: imageDark,
      Input: inputDark$1,
      InputNumber: inputNumberDark$1,
      LegacyTransfer: legacyTransferDark,
      Layout: layoutDark$1,
      List: listDark$2,
      LoadingBar: loadingBarDark$1,
      Log: logDark$1,
      Menu: menuDark$1,
      Mention: mentionDark,
      Message: messageDark$1,
      Modal: modalDark$1,
      Notification: notificationDark$1,
      PageHeader: pageHeaderDark,
      Pagination: paginationDark$1,
      Popconfirm: popconfirmDark$1,
      Popover: popoverDark$1,
      Popselect: popselectDark,
      Progress: progressDark$1,
      Radio: radioDark$1,
      Rate: rateDark$1,
      Result: resultDark$1,
      Row: rowDark$1,
      Scrollbar: scrollbarDark$1,
      Select: selectDark$1,
      Skeleton: skeletonDark,
      Slider: sliderDark$1,
      Space: spaceDark$1,
      Spin: spinDark$1,
      Statistic: statisticDark$1,
      Steps: stepsDark$1,
      Switch: switchDark$1,
      Table: tableDark$1,
      Tabs: tabsDark$1,
      Tag: tagDark$1,
      Thing: thingDark$1,
      TimePicker: timePickerDark$1,
      Timeline: timelineDark$1,
      Tooltip: tooltipDark$1,
      Transfer: transferDark$2,
      Tree: treeDark$1,
      TreeSelect: treeSelectDark$1,
      Typography: typographyDark$1,
      Upload: uploadDark$1,
      Watermark: watermarkDark$1
    };

    const lightTheme = {
      name: "light",
      common: commonLight,
      Alert: alertLight$1,
      Anchor: anchorLight$1,
      AutoComplete: autoCompleteLight$1,
      Avatar: avatarLight$1,
      AvatarGroup: avatarGroupLight$1,
      BackTop: backTopLight$1,
      Badge: badgeLight$1,
      Breadcrumb: breadcrumbLight$1,
      Button: buttonLight$1,
      ButtonGroup: buttonGroupLight$1,
      Calendar: calendarLight$1,
      Card: cardLight$1,
      Carousel: carouselLight$1,
      Cascader: cascaderLight$1,
      Checkbox: checkboxLight$1,
      Code: codeLight$1,
      Collapse: collapseLight$1,
      CollapseTransition: collapseTransitionLight$1,
      ColorPicker: colorPickerLight$1,
      DataTable: dataTableLight$1,
      DatePicker: datePickerLight$1,
      Descriptions: descriptionsLight$1,
      Dialog: dialogLight$1,
      Divider: dividerLight$1,
      Drawer: drawerLight$1,
      Dropdown: dropdownLight$1,
      DynamicInput: dynamicInputLight$1,
      DynamicTags: dynamicTagsLight$1,
      Element: elementLight$1,
      Empty: emptyLight$1,
      Ellipsis: ellipsisLight$1,
      Form: formLight$1,
      GradientText: gradientTextLight$1,
      Icon: iconLight$1,
      IconWrapper: iconWrapperLight$1,
      Image: imageLight,
      Input: inputLight$1,
      InputNumber: inputNumberLight$1,
      Layout: layoutLight$1,
      LegacyTransfer: legacyTransferLight,
      List: listLight$1,
      LoadingBar: loadingBarLight$1,
      Log: logLight$1,
      Menu: menuLight$1,
      Mention: mentionLight$1,
      Message: messageLight$1,
      Modal: modalLight$1,
      Notification: notificationLight$1,
      PageHeader: pageHeaderLight,
      Pagination: paginationLight$1,
      Popconfirm: popconfirmLight$1,
      Popover: popoverLight$1,
      Popselect: popselectLight$1,
      Progress: progressLight$1,
      Radio: radioLight$1,
      Rate: rateLight,
      Row: rowLight$1,
      Result: resultLight$1,
      Scrollbar: scrollbarLight$1,
      Skeleton: skeletonLight,
      Select: selectLight$1,
      Slider: sliderLight$1,
      Space: spaceLight$1,
      Spin: spinLight$1,
      Statistic: statisticLight$1,
      Steps: stepsLight$1,
      Switch: switchLight$1,
      Table: tableLight$1,
      Tabs: tabsLight$1,
      Tag: tagLight$1,
      Thing: thingLight$1,
      TimePicker: timePickerLight$1,
      Timeline: timelineLight$1,
      Tooltip: tooltipLight$1,
      Transfer: transferLight$2,
      Tree: treeLight$1,
      TreeSelect: treeSelectLight$1,
      Typography: typographyLight$1,
      Upload: uploadLight$1,
      Watermark: watermarkLight$1
    };

    function createTheme(name, componentThemes) {
      const nameIsString = typeof name === "string";
      const theme = {
        name: nameIsString ? name : "customized-theme"
      };

      if (nameIsString) {
        if (componentThemes) {
          for (const cTheme of componentThemes) {
            theme[cTheme.name] = cTheme;
          }
        }
      } else {
        for (const cTheme of name) {
          theme[cTheme.name] = cTheme;
        }
      }

      return theme;
    }

    const ColorWandIcon = /* @__PURE__ */ vue.h("svg", {
      viewBox: "0 0 16 16",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      style: { width: "1em", height: "1em", color: "currentColor" }
    }, /* @__PURE__ */ vue.h("path", {
      d: "M13.5 1C13.7761 1 14 1.22386 14 1.5V2H14.5C14.7761 2 15 2.22386 15 2.5C15 2.77614 14.7761 3 14.5 3H14V3.5C14 3.77614 13.7761 4 13.5 4C13.2239 4 13 3.77614 13 3.5V3H12.5C12.2239 3 12 2.77614 12 2.5C12 2.22386 12.2239 2 12.5 2H13V1.5C13 1.22386 13.2239 1 13.5 1Z",
      fill: "currentColor"
    }), /* @__PURE__ */ vue.h("path", {
      d: "M3.5 3C3.77615 3 4 3.22386 4 3.5V4H4.5C4.77615 4 5 4.22386 5 4.5C5 4.77614 4.77615 5 4.5 5H4V5.5C4 5.77614 3.77615 6 3.5 6C3.22386 6 3 5.77614 3 5.5V5H2.5C2.22386 5 2 4.77614 2 4.5C2 4.22386 2.22386 4 2.5 4H3V3.5C3 3.22386 3.22386 3 3.5 3Z",
      fill: "currentColor"
    }), /* @__PURE__ */ vue.h("path", {
      d: "M12.5 12C12.7761 12 13 11.7761 13 11.5C13 11.2239 12.7761 11 12.5 11H12V10.5C12 10.2239 11.7761 10 11.5 10C11.2239 10 11 10.2239 11 10.5V11H10.5C10.2239 11 10 11.2239 10 11.5C10 11.7761 10.2239 12 10.5 12H11V12.5C11 12.7761 11.2239 13 11.5 13C11.7761 13 12 12.7761 12 12.5V12H12.5Z",
      fill: "currentColor"
    }), /* @__PURE__ */ vue.h("path", {
      d: "M8.72956 4.56346C9.4771 3.81592 10.6891 3.81592 11.4367 4.56347C12.1842 5.31102 12.1842 6.52303 11.4367 7.27058L4.26679 14.4404C3.51924 15.1879 2.30723 15.1879 1.55968 14.4404C0.812134 13.6928 0.812138 12.4808 1.55969 11.7333L8.72956 4.56346ZM8.25002 6.4572L2.26679 12.4404C1.90977 12.7974 1.90977 13.3763 2.26679 13.7333C2.62381 14.0903 3.20266 14.0903 3.55968 13.7333L9.54292 7.75009L8.25002 6.4572ZM10.25 7.04299L10.7295 6.56347C11.0866 6.20645 11.0866 5.6276 10.7296 5.27057C10.3725 4.91355 9.79368 4.91355 9.43666 5.27057L8.95713 5.7501L10.25 7.04299Z",
      fill: "currentColor"
    }));
    const showColorPicker = (key) => {
      if (key.includes("pacity"))
        return false;
      if (key.includes("color") || key.includes("Color"))
        return true;
      return false;
    };
    var ThemeEditor = vue.defineComponent({
      name: "ThemeEditor",
      inheritAttrs: false,
      setup() {
        const fileInputRef = vue.ref(null);
        const NConfigProvider2 = vue.inject(configProviderInjectionKey, null);
        const theme = vue.computed(() => {
          const mergedTheme = NConfigProvider2?.mergedThemeRef.value || lightTheme;
          const mergedThemeOverrides = NConfigProvider2?.mergedThemeOverridesRef.value;
          const common = lodash.exports.merge(
            {},
            mergedTheme.common || lightTheme.common,
            mergedThemeOverrides?.common,
            overridesRef.value.common || {}
          );
          const overrides = {
            common
          };
          for (const key of Object.keys(lightTheme)) {
            if (key === "common")
              continue;
            overrides[key] = mergedTheme[key]?.self?.(common) || lightTheme[key].self?.(common);
            if (mergedThemeOverrides && overrides[key]) {
              lodash.exports.merge(overrides[key], mergedThemeOverrides[key]);
            }
          }
          return overrides;
        });
        const themeCommonDefaultRef = vue.computed(() => {
          return NConfigProvider2?.mergedThemeRef.value?.common || lightTheme.common;
        });
        const showPanelRef = vue.ref(false);
        const overridesRef = vue.ref(
          JSON.parse(localStorage["naive-ui-theme-overrides"] || "{}")
        );
        const tempOverridesRef = vue.ref(
          JSON.parse(localStorage["naive-ui-theme-overrides"] || "{}")
        );
        const varNamePatternRef = vue.ref("");
        const compNamePatternRef = vue.ref("");
        const tempVarNamePatternRef = vue.ref("");
        const tempCompNamePatternRef = vue.ref("");
        function applyTempOverrides() {
          overridesRef.value = lodash.exports.cloneDeep(vue.toRaw(tempOverridesRef.value));
        }
        function setTempOverrides(compName, varName, value) {
          const { value: tempOverrides } = tempOverridesRef;
          if (!(compName in tempOverrides))
            tempOverrides[compName] = {};
          const compOverrides = tempOverrides[compName];
          if (value) {
            compOverrides[varName] = value;
          } else {
            delete compOverrides[varName];
          }
        }
        function handleClearAllClick() {
          tempOverridesRef.value = {};
          overridesRef.value = {};
        }
        function handleImportClick() {
          const { value: fileInput } = fileInputRef;
          if (!fileInput)
            return;
          fileInput.click();
        }
        function handleInputFileChange() {
          const { value: fileInput } = fileInputRef;
          if (!fileInput)
            return;
          const fileList = fileInput.files;
          const file = fileList?.[0];
          if (!file)
            return;
          file.text().then((value) => {
            overridesRef.value = JSON.parse(value);
            tempOverridesRef.value = JSON.parse(value);
          }).catch((e) => {
            alert("Imported File is Invalid");
            console.error(e);
          }).finally(() => {
            fileInput.value = "";
          });
        }
        function handleExportClick() {
          const url = URL.createObjectURL(
            new Blob([JSON.stringify(overridesRef.value, void 0, 2)])
          );
          const a = document.createElement("a");
          a.href = url;
          a.download = "naive-ui-theme-overrides.json";
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        }
        vue.watch(overridesRef, (value) => {
          localStorage["naive-ui-theme-overrides"] = JSON.stringify(value);
        });
        return {
          locale: useLocale("ThemeEditor").localeRef,
          themeCommonDefault: themeCommonDefaultRef,
          theme,
          showPanel: showPanelRef,
          tempOverrides: tempOverridesRef,
          overrides: overridesRef,
          compNamePattern: compNamePatternRef,
          tempCompNamePattern: tempCompNamePatternRef,
          varNamePattern: varNamePatternRef,
          tempVarNamePattern: tempVarNamePatternRef,
          fileInputRef,
          applyTempOverrides,
          setTempOverrides,
          handleClearAllClick,
          handleExportClick,
          handleImportClick,
          handleInputFileChange
        };
      },
      render() {
        return /* @__PURE__ */ vue.h(NConfigProvider, {
          themeOverrides: this.overrides
        }, {
          default: () => [
            /* @__PURE__ */ vue.h(NPopover, {
              scrollable: true,
              arrowPointToCenter: true,
              trigger: "manual",
              show: this.showPanel,
              displayDirective: "show",
              placement: "top-end",
              style: {
                width: "288px",
                height: "calc(100vh - 200px)",
                padding: 0
              }
            }, {
              trigger: () => /* @__PURE__ */ vue.h(NElement, {
                style: [
                  {
                    position: "fixed",
                    zIndex: 10,
                    bottom: "40px",
                    right: `calc(40px + ${lockHtmlScrollRightCompensationRef.value})`,
                    width: "44px",
                    height: "44px",
                    fontSize: "26px",
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "center",
                    borderRadius: "50%",
                    backgroundColor: "var(--popover-color)",
                    color: "var(--text-color-2)",
                    transition: "color .3s var(--cubic-bezier-ease-in-out), background-color .3s var(--cubic-bezier-ease-in-out), box-shadow .3s var(--cubic-bezier-ease-in-out)",
                    boxShadow: "0 2px 8px 0px rgba(0, 0, 0, .12)",
                    cursor: "pointer"
                  },
                  this.$attrs.style
                ],
                onClick: () => {
                  this.showPanel = !this.showPanel;
                }
              }, { default: () => ColorWandIcon }),
              default: () => /* @__PURE__ */ vue.h(vue.Fragment, null, /* @__PURE__ */ vue.h("input", {
                type: "file",
                ref: "fileInputRef",
                style: {
                  display: "block",
                  width: 0,
                  height: 0,
                  visibility: "hidden"
                },
                onChange: this.handleInputFileChange
              }), /* @__PURE__ */ vue.h(NSpace, {
                vertical: true
              }, {
                default: () => /* @__PURE__ */ vue.h(vue.Fragment, null, /* @__PURE__ */ vue.h("div", {
                  style: {
                    marginBottom: "8px",
                    fontSize: "18px",
                    fontWeight: 500
                  }
                }, this.locale.title), this.locale.filterCompName, /* @__PURE__ */ vue.h(NInput, {
                  onChange: () => {
                    this.compNamePattern = this.tempCompNamePattern;
                  },
                  onInput: (value) => {
                    this.tempCompNamePattern = value;
                  },
                  value: this.tempCompNamePattern,
                  placeholder: this.locale.filterCompName
                }), this.locale.filterVarName, /* @__PURE__ */ vue.h(NInput, {
                  onChange: (value) => {
                    this.varNamePattern = value;
                  },
                  onInput: (value) => {
                    this.tempVarNamePattern = value;
                  },
                  value: this.tempVarNamePattern,
                  placeholder: this.locale.filterVarName
                }), /* @__PURE__ */ vue.h(NButton, {
                  size: "small",
                  onClick: () => {
                    this.compNamePattern = "";
                    this.varNamePattern = "";
                    this.tempCompNamePattern = "";
                    this.tempVarNamePattern = "";
                  },
                  block: true
                }, { default: () => this.locale.clearSearch }), /* @__PURE__ */ vue.h(NButton, {
                  size: "small",
                  onClick: this.handleClearAllClick,
                  block: true
                }, {
                  default: () => this.locale.clearAllVars
                }), /* @__PURE__ */ vue.h(NSpace, {
                  itemStyle: { flex: 1 }
                }, {
                  default: () => /* @__PURE__ */ vue.h(vue.Fragment, null, /* @__PURE__ */ vue.h(NButton, {
                    block: true,
                    size: "small",
                    onClick: this.handleImportClick
                  }, {
                    default: () => this.locale.import
                  }), /* @__PURE__ */ vue.h(NButton, {
                    block: true,
                    size: "small",
                    onClick: this.handleExportClick
                  }, {
                    default: () => this.locale.export
                  }))
                }))
              }), /* @__PURE__ */ vue.h(NDivider, null), /* @__PURE__ */ vue.h(NCollapse, null, {
                default: () => {
                  const { theme, compNamePattern, varNamePattern } = this;
                  const themeKeys = Object.keys(theme);
                  const compNamePatternLower = compNamePattern.toLowerCase();
                  const varNamePatternLower = varNamePattern.toLowerCase();
                  let filteredItemsCount = 0;
                  const collapsedItems = themeKeys.filter((themeKey) => {
                    return themeKey.toLowerCase().includes(compNamePatternLower);
                  }).map((themeKey) => {
                    const componentTheme = themeKey === "common" ? this.themeCommonDefault : theme[themeKey];
                    if (componentTheme === void 0) {
                      return null;
                    }
                    const varKeys = Object.keys(
                      componentTheme
                    ).filter((key) => {
                      return key !== "name" && key.toLowerCase().includes(varNamePatternLower);
                    });
                    if (!varKeys.length) {
                      return null;
                    }
                    filteredItemsCount += 1;
                    return /* @__PURE__ */ vue.h(NCollapseItem, {
                      title: themeKey,
                      name: themeKey
                    }, {
                      default: () => {
                        return /* @__PURE__ */ vue.h(NSpace, {
                          vertical: true
                        }, {
                          default: () => varKeys.map((varKey) => {
                            return [
                              /* @__PURE__ */ vue.h("div", {
                                key: `${varKey}Label`,
                                style: {
                                  wordBreak: "break-word"
                                }
                              }, varKey),
                              showColorPicker(varKey) ? /* @__PURE__ */ vue.h(NColorPicker, {
                                key: varKey,
                                modes: ["rgb", "hex"],
                                value: this.tempOverrides?.[themeKey]?.[varKey] || componentTheme[varKey],
                                onComplete: this.applyTempOverrides,
                                onUpdateValue: (value) => {
                                  this.setTempOverrides(
                                    themeKey,
                                    varKey,
                                    value
                                  );
                                }
                              }, {
                                action: () => /* @__PURE__ */ vue.h(NButton, {
                                  size: "small",
                                  disabled: componentTheme[varKey] === this.tempOverrides?.[themeKey]?.[varKey],
                                  onClick: () => {
                                    this.setTempOverrides(
                                      themeKey,
                                      varKey,
                                      componentTheme[varKey]
                                    );
                                    this.applyTempOverrides();
                                  }
                                }, {
                                  default: () => this.locale.restore
                                })
                              }) : /* @__PURE__ */ vue.h(NInput, {
                                key: varKey,
                                onChange: this.applyTempOverrides,
                                onUpdateValue: (value) => {
                                  this.setTempOverrides(
                                    themeKey,
                                    varKey,
                                    value
                                  );
                                },
                                value: this.tempOverrides?.[themeKey]?.[varKey] || "",
                                placeholder: componentTheme[varKey]
                              })
                            ];
                          })
                        });
                      }
                    });
                  });
                  if (!filteredItemsCount)
                    return /* @__PURE__ */ vue.h(NEmpty, null);
                  return collapsedItems;
                }
              }))
            }),
            this.$slots.default?.()
          ]
        });
      }
    });

    exports.NA = a;
    exports.NAffix = NAffix;
    exports.NAlert = Alert;
    exports.NAnchor = AnchorAdapter;
    exports.NAnchorLink = Link;
    exports.NAutoComplete = AutoComplete;
    exports.NAvatar = NAvatar;
    exports.NAvatarGroup = AvatarGroup;
    exports.NBackTop = BackTop;
    exports.NBadge = Badge;
    exports.NBlockquote = blockquote;
    exports.NBreadcrumb = Breadcrumb;
    exports.NBreadcrumbItem = BreadcrumbItem;
    exports.NButton = NButton;
    exports.NButtonGroup = NButtonGroup;
    exports.NCalendar = Calendar;
    exports.NCard = NCard;
    exports.NCarousel = Carousel;
    exports.NCarouselItem = NCarouselItem;
    exports.NCascader = Cascader;
    exports.NCheckbox = NCheckbox;
    exports.NCheckboxGroup = NCheckboxGroup;
    exports.NCode = NCode;
    exports.NCol = NCol;
    exports.NCollapse = NCollapse;
    exports.NCollapseItem = NCollapseItem;
    exports.NCollapseTransition = CollapseTransition;
    exports.NColorPicker = NColorPicker;
    exports.NConfigProvider = NConfigProvider;
    exports.NCountdown = Countdown;
    exports.NDataTable = DataTable;
    exports.NDatePicker = DatePicker;
    exports.NDescriptions = Descriptions;
    exports.NDescriptionsItem = DescriptionsItem;
    exports.NDialog = NDialog;
    exports.NDialogProvider = NDialogProvider;
    exports.NDivider = NDivider;
    exports.NDrawer = Drawer;
    exports.NDrawerContent = DrawerContent;
    exports.NDropdown = NDropdown;
    exports.NDynamicInput = DynamicInput;
    exports.NDynamicTags = DynamicTags;
    exports.NEl = NElement;
    exports.NElement = NElement;
    exports.NEllipsis = NEllipsis;
    exports.NEmpty = NEmpty;
    exports.NForm = Form;
    exports.NFormItem = NFormItem;
    exports.NFormItemCol = NFormItemCol;
    exports.NFormItemGi = FormItemGridItem;
    exports.NFormItemGridItem = FormItemGridItem;
    exports.NFormItemRow = FormItemRow;
    exports.NGi = NGridItem;
    exports.NGlobalStyle = GlobalStyle;
    exports.NGradientText = GradientText;
    exports.NGrid = Grid;
    exports.NGridItem = NGridItem;
    exports.NH1 = NH1;
    exports.NH2 = NH2;
    exports.NH3 = NH3;
    exports.NH4 = NH4;
    exports.NH5 = NH5;
    exports.NH6 = NH6;
    exports.NHr = hr;
    exports.NIcon = NIcon;
    exports.NIconWrapper = NIconWrapper;
    exports.NImage = NImage;
    exports.NImageGroup = NImageGroup;
    exports.NInput = NInput;
    exports.NInputGroup = NInputGroup;
    exports.NInputGroupLabel = InputGroupLabel;
    exports.NInputNumber = InputNumber;
    exports.NLayout = Layout;
    exports.NLayoutContent = LayoutContent;
    exports.NLayoutFooter = LayoutFooter;
    exports.NLayoutHeader = LayoutHeader;
    exports.NLayoutSider = LayoutSider;
    exports.NLegacyTransfer = Transfer$1;
    exports.NLi = li;
    exports.NList = List;
    exports.NListItem = ListItem;
    exports.NLoadingBarProvider = NLoadingBarProvider;
    exports.NLog = Log;
    exports.NMention = Mention;
    exports.NMenu = Menu;
    exports.NMessageProvider = NMessageProvider;
    exports.NModal = NModal;
    exports.NNotificationProvider = NNotificationProvider;
    exports.NNumberAnimation = NumberAnimation;
    exports.NOl = ol;
    exports.NP = p;
    exports.NPageHeader = PageHeader;
    exports.NPagination = NPagination;
    exports.NPopconfirm = Popconfirm;
    exports.NPopover = NPopover;
    exports.NPopselect = NPopselect;
    exports.NProgress = NProgress;
    exports.NRadio = NRadio;
    exports.NRadioButton = RadioButton;
    exports.NRadioGroup = NRadioGroup;
    exports.NRate = Rate;
    exports.NResult = Result;
    exports.NRow = NRow;
    exports.NScrollbar = Scrollbar$1;
    exports.NSelect = NSelect;
    exports.NSkeleton = Skeleton;
    exports.NSlider = Slider;
    exports.NSpace = NSpace;
    exports.NSpin = Spin;
    exports.NStatistic = Statistic;
    exports.NStep = Step;
    exports.NSteps = Steps;
    exports.NSwitch = Switch;
    exports.NTab = Tab;
    exports.NTabPane = TabPane;
    exports.NTable = Table;
    exports.NTabs = Tabs;
    exports.NTag = NTag;
    exports.NTbody = Tbody;
    exports.NTd = Td;
    exports.NText = text;
    exports.NTh = Th;
    exports.NThead = Thead;
    exports.NThemeEditor = ThemeEditor;
    exports.NThing = Thing;
    exports.NTime = Time;
    exports.NTimePicker = NTimePicker;
    exports.NTimeline = Timeline;
    exports.NTimelineItem = TimelineItem;
    exports.NTooltip = NTooltip;
    exports.NTr = Tr;
    exports.NTransfer = Transfer;
    exports.NTree = NTree;
    exports.NTreeSelect = TreeSelect;
    exports.NUl = ul;
    exports.NUpload = Upload;
    exports.NUploadDragger = NUploadDragger;
    exports.NUploadFileList = NUploadFileList;
    exports.NUploadTrigger = NUploadTrigger;
    exports.NWatermark = Watermark;
    exports.NxButton = XButton;
    exports.aProps = aProps;
    exports.affixProps = affixProps;
    exports.alertDark = alertDark$1;
    exports.alertProps = alertProps;
    exports.anchorDark = anchorDark$1;
    exports.anchorLinkProps = anchorLinkProps;
    exports.anchorProps = anchorProps;
    exports.autoCompleteDark = autoCompleteDark$1;
    exports.autoCompleteProps = autoCompleteProps;
    exports.avatarDark = avatarDark$1;
    exports.avatarGroupProps = avatarGroupProps;
    exports.avatarProps = avatarProps;
    exports.backTopDark = backTopDark$1;
    exports.backTopProps = backTopProps;
    exports.badgeDark = badgeDark$1;
    exports.badgeProps = badgeProps;
    exports.blockquoteProps = blockquoteProps;
    exports.breadcrumbDark = breadcrumbDark$1;
    exports.breadcrumbItemProps = breadcrumbItemProps;
    exports.breadcrumbProps = breadcrumbProps;
    exports.buttonDark = buttonDark$1;
    exports.buttonGroupDark = buttonGroupDark$1;
    exports.buttonGroupProps = buttonGroupProps;
    exports.buttonProps = buttonProps;
    exports.c = c$1;
    exports.cB = cB;
    exports.cE = cE;
    exports.cM = cM;
    exports.cNotM = cNotM;
    exports.calendarProps = calendarProps;
    exports.cardDark = cardDark$1;
    exports.cardProps = cardProps;
    exports.carouselProps = carouselProps;
    exports.cascaderDark = cascaderDark$1;
    exports.cascaderProps = cascaderProps;
    exports.checkboxDark = checkboxDark$1;
    exports.checkboxGroupProps = checkboxGroupProps;
    exports.checkboxProps = checkboxProps;
    exports.codeDark = codeDark$1;
    exports.codeProps = codeProps;
    exports.colProps = colProps;
    exports.collapseDark = collapseDark$1;
    exports.collapseItemProps = collapseItemProps;
    exports.collapseProps = collapseProps;
    exports.collapseTransitionProps = collapseTransitionProps;
    exports.colorPickerProps = colorPickerProps;
    exports.commonDark = commonDark;
    exports.commonLight = commonLight;
    exports.configProviderProps = configProviderProps;
    exports.countdownProps = countdownProps;
    exports.create = create;
    exports.createDiscreteApi = createDiscreteApi;
    exports.createLocale = createLocale;
    exports.createTheme = createTheme;
    exports.darkTheme = darkTheme;
    exports.dataTableDark = dataTableDark$1;
    exports.dataTableProps = dataTableProps;
    exports.dateDeDE = dateDeDE$1;
    exports.dateEnGB = dateEnGB$1;
    exports.dateEnUS = dateEnUS;
    exports.dateEo = dateEo$1;
    exports.dateEsAR = dateEsAR$1;
    exports.dateFrFR = dateFrFR$1;
    exports.dateIdID = dateIdID$1;
    exports.dateItIT = dateItIT$1;
    exports.dateJaJP = dateJaJP$1;
    exports.dateKoKR = dateKoKR$1;
    exports.dateNbNO = dateNbNO$1;
    exports.dateNlNL = dateNlNL$1;
    exports.datePickerDark = datePickerDark$1;
    exports.datePickerProps = datePickerProps;
    exports.datePlPL = datePlPL$1;
    exports.datePtBR = datePtBr$1;
    exports.dateRuRU = dateRuRU$1;
    exports.dateSkSK = dateSkSK$1;
    exports.dateThTH = dateThTH$1;
    exports.dateUkUA = dateUkUA$1;
    exports.dateViVN = dateVi$1;
    exports.dateZhCN = dateZhCN$1;
    exports.dateZhTW = datezhTW$1;
    exports.deDE = deDE$1;
    exports["default"] = naive$1;
    exports.descriptionsDark = descriptionsDark$1;
    exports.descriptionsItemProps = descriptionsItemProps;
    exports.descriptionsProps = descriptionsProps;
    exports.dialogDark = dialogDark$1;
    exports.dialogProps = dialogProps;
    exports.dialogProviderProps = dialogProviderProps;
    exports.dividerDark = dividerDark$1;
    exports.dividerProps = dividerProps;
    exports.drawerContentProps = drawerContentProps;
    exports.drawerDark = drawerDark$1;
    exports.drawerProps = drawerProps;
    exports.dropdownDark = dropdownDark$1;
    exports.dropdownProps = dropdownProps;
    exports.dynamicInputDark = dynamicInputDark$1;
    exports.dynamicInputProps = dynamicInputProps;
    exports.dynamicTagsDark = dynamicTagsDark$1;
    exports.dynamicTagsProps = dynamicTagsProps;
    exports.elementDark = elementDark$1;
    exports.elementProps = elementProps;
    exports.ellipsisProps = ellipsisProps;
    exports.emptyDark = emptyDark$1;
    exports.emptyProps = emptyProps;
    exports.enGB = enGB$1;
    exports.enUS = enUS$2;
    exports.eo = eo$1;
    exports.esAR = esAR$1;
    exports.formDark = formDark;
    exports.formItemGiProps = formItemGiProps;
    exports.formItemGridItemProps = formItemGiProps;
    exports.formItemProps = formItemProps;
    exports.formProps = formProps;
    exports.frFR = frFR$1;
    exports.giProps = gridItemProps;
    exports.gradientTextDark = gradientTextDark$1;
    exports.gradientTextProps = gradientTextProps;
    exports.gridItemProps = gridItemProps;
    exports.gridProps = gridProps;
    exports.h1Props = headerProps;
    exports.h2Props = headerProps;
    exports.h3Props = headerProps;
    exports.h4Props = headerProps;
    exports.h5Props = headerProps;
    exports.h6Props = headerProps;
    exports.iconDark = iconDark$2;
    exports.iconProps = iconProps;
    exports.iconWrapperProps = iconWrapperProps;
    exports.idID = idID$1;
    exports.imageGroupProps = imageGroupProps;
    exports.imageProps = imageProps;
    exports.inputDark = inputDark$1;
    exports.inputGroupLabelProps = inputGroupLabelProps;
    exports.inputGroupProps = inputGroupProps;
    exports.inputNumberDark = inputNumberDark$1;
    exports.inputNumberProps = inputNumberProps;
    exports.inputProps = inputProps;
    exports.install = install;
    exports.internalSelectMenuDark = internalSelectMenuDark$1;
    exports.internalSelectionDark = internalSelectionDark$1;
    exports.itIT = itIT$1;
    exports.jaJP = jaJP$1;
    exports.koKR = koKR$1;
    exports.layoutContentProps = layoutProps;
    exports.layoutDark = layoutDark$1;
    exports.layoutFooterProps = layoutFooterProps;
    exports.layoutHeaderProps = headerProps$1;
    exports.layoutProps = layoutProps;
    exports.layoutSiderProps = layoutSiderProps;
    exports.legacyTransferProps = transferProps$1;
    exports.lightTheme = lightTheme;
    exports.listDark = listDark$2;
    exports.listProps = listProps;
    exports.loadingBarDark = loadingBarDark$1;
    exports.loadingBarProviderProps = loadingBarProviderProps;
    exports.logDark = logDark$1;
    exports.logProps = logProps;
    exports.mentionDark = mentionDark;
    exports.mentionProps = mentionProps;
    exports.menuDark = menuDark$1;
    exports.menuProps = menuProps;
    exports.messageDark = messageDark$1;
    exports.messageProviderProps = messageProviderProps;
    exports.modalDark = modalDark$1;
    exports.modalProps = modalProps;
    exports.nbNO = nbNO$1;
    exports.nlNL = nlNL$1;
    exports.notificationDark = notificationDark$1;
    exports.notificationProviderProps = notificationProviderProps;
    exports.numberAnimationProps = numberAnimationProps;
    exports.olProps = olProps;
    exports.pProps = pProps;
    exports.pageHeaderProps = pageHeaderProps;
    exports.paginationDark = paginationDark$1;
    exports.paginationProps = paginationProps;
    exports.plPL = plPL$1;
    exports.popconfirmDark = popconfirmDark$1;
    exports.popconfirmProps = popconfirmProps;
    exports.popoverDark = popoverDark$1;
    exports.popoverProps = popoverProps;
    exports.popselectDark = popselectDark;
    exports.popselectProps = popselectProps;
    exports.progressDark = progressDark$1;
    exports.progressProps = progressProps;
    exports.ptBR = ptBR$1;
    exports.radioButtonProps = radioButtonProps;
    exports.radioDark = radioDark$1;
    exports.radioGroupProps = radioGroupProps;
    exports.radioProps = radioProps;
    exports.rateDark = rateDark$1;
    exports.rateProps = rateProps;
    exports.resultDark = resultDark$1;
    exports.resultProps = resultProps;
    exports.rowProps = rowProps;
    exports.ruRU = ruRu$1;
    exports.scrollbarDark = scrollbarDark$1;
    exports.scrollbarProps = scrollbarProps;
    exports.selectDark = selectDark$1;
    exports.selectProps = selectProps;
    exports.skSK = skSK$1;
    exports.skeletonProps = skeletonProps;
    exports.sliderDark = sliderDark$1;
    exports.sliderProps = sliderProps;
    exports.spaceDark = spaceDark$1;
    exports.spaceProps = spaceProps;
    exports.spinDark = spinDark$1;
    exports.spinProps = spinProps;
    exports.statisticDark = statisticDark$1;
    exports.statisticProps = statisticProps;
    exports.stepProps = stepProps;
    exports.stepsDark = stepsDark$1;
    exports.stepsProps = stepsProps;
    exports.switchDark = switchDark$1;
    exports.switchProps = switchProps;
    exports.tabPaneProps = tabPaneProps;
    exports.tabProps = tabProps;
    exports.tableDark = tableDark$1;
    exports.tableProps = tableProps;
    exports.tabsDark = tabsDark$1;
    exports.tabsProps = tabsProps;
    exports.tagDark = tagDark$1;
    exports.tagProps = tagProps;
    exports.textProps = textProps;
    exports.thTH = thTH$1;
    exports.thingDark = thingDark$1;
    exports.thingProps = thingProps;
    exports.timePickerDark = timePickerDark$1;
    exports.timePickerProps = timePickerProps;
    exports.timeProps = timeProps;
    exports.timelineDark = timelineDark$1;
    exports.timelineItemProps = timelineItemProps;
    exports.timelineProps = timelineProps;
    exports.tooltipDark = tooltipDark$1;
    exports.tooltipProps = tooltipProps;
    exports.transferDark = transferDark$2;
    exports.transferProps = transferProps;
    exports.treeDark = treeDark$1;
    exports.treeProps = treeProps;
    exports.treeSelectDark = treeSelectDark$1;
    exports.treeSelectProps = treeSelectProps;
    exports.typographyDark = typographyDark$1;
    exports.ukUA = ukUA$1;
    exports.ulProps = ulProps;
    exports.unstableAlertRtl = alertRtl;
    exports.unstableAvatarGroupRtl = avatarGroupRtl;
    exports.unstableBadgeRtl = badgeRtl;
    exports.unstableButtonGroupRtl = buttonGroupRtl;
    exports.unstableButtonRtl = buttonRtl;
    exports.unstableCardRtl = cardRtl;
    exports.unstableCheckboxRtl = checkboxRtl;
    exports.unstableCollapseRtl = collapseRtl;
    exports.unstableCollapseTransitionRtl = collapseTransitionRtl;
    exports.unstableDrawerRtl = drawerRtl$1;
    exports.unstableDynamicInputRtl = dynamicInputRtl;
    exports.unstableInputNumberRtl = inputNumberRtl;
    exports.unstableInputRtl = inputRtl;
    exports.unstableListRtl = listRtl;
    exports.unstableMessageRtl = messageRtl;
    exports.unstableNotificationRtl = notificationRtl;
    exports.unstablePageHeaderRtl = rtl;
    exports.unstablePaginationRtl = paginationRtl;
    exports.unstableRadioRtl = radioRtl;
    exports.unstableRowRtl = rowRtl;
    exports.unstableScrollbarRtl = scrollbarRtl$1;
    exports.unstableSpaceRtl = spaceRtl;
    exports.unstableStatisticRtl = statisticRtl;
    exports.unstableStepsRtl = stepsRtl;
    exports.unstableTableRtl = tableRtl;
    exports.unstableTagRtl = tagRtl;
    exports.unstableThingRtl = thingRtl;
    exports.unstableTreeRtl = treeRtl;
    exports.uploadDark = uploadDark$1;
    exports.uploadProps = uploadProps;
    exports.useDialog = useDialog;
    exports.useLoadingBar = useLoadingBar;
    exports.useMessage = useMessage;
    exports.useNotification = useNotification;
    exports.useOsTheme = useOsTheme;
    exports.useThemeVars = useThemeVars;
    exports.version = version;
    exports.viVN = viVN$1;
    exports.watermarkDark = watermarkDark$1;
    exports.watermarkProps = watermarkProps;
    exports.zhCN = zhCN$1;
    exports.zhTW = zhTW$1;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
