{"/soft/Lichee/zh/index.html":{"title":"Lichee Pi","content":" title: Lichee Pi keywords: Sipeed, Hardware, 矽速, 软件资料, 文档, 资料下载 desc: 矽速科技的硬件资料站 Lichee 是 [Sipeed](https://www.sipeed.com/) 推出的开源产品，是为了能让用户获得优廉的linux设备，实战linux底层相关的内容的产品。 <h2> Lichee (Linux) </h2> [Lichee Zero](./Zero Doc/Start/intro_cn.html) [Lichee Nano](./Nano Doc Backup/index.html) [Lichee RV](./Lichee RV/intro_cn.html) 更多产品在计划中"},"/soft/Lichee/zh/Zero-Doc/application/QT_doc4.html":{"title":"QtCreator使用","content":" title: QtCreator使用 完成了tslib和QT的编译后，就成功搭建了Qt环境，接下来就可以使用QtCreator来开发图形界面了\\~ ## QtCreator安装 ``` wget http://download.qt.io/official_releases/qtcreator/4.4/4.4.1/qt creator opensource linux x86_64 4.4.1.run ``` 下载好后，在图形界面里双击运行即可。 注意，由于docker开图形界面比较麻烦，所以qtcreator不包含在docker镜像中，大家可以自行下载到本机安装。 ## QtCreator配置 打开qtcreator，打开 Tools > option > Build&Run 首先配置Qt版本，这里需要用到前面编译好的qmake，点击add，把前面编译好的qmake指给它 ![](./../static/Drive/QT_1.jpg) 然后配置工具链，把我们使用的linaro工具链指给它 ![](./../static/Drive/QT_2.jpg) 最后配置 构建套件（Kit），就是组合Qt版本和工具链版本，我们这里新建 arm v7套件。 ![](./../static/Drive/QT_3.jpg) 保存应用退出即可。 ## QtCreator的简单使用 新建工程，一路默认下去（选择arm v7套件），完成。 ![](./../static/Drive/QT_4.jpg) 随便拉些控件： ![](./../static/Drive/QT_5.jpg) 然后点左下角运行按键就会自动构建，在工程目录下生成对应二进制文件。 把生成的程序拷贝到目标板上，运行： ``` root@LicheePi:~# ./test ./test: /usr/lib/arm linux gnueabihf/libstdc++.so.6: version `CXXABI_1.3.9' not found (required by ./test) ./test: /usr/lib/arm linux gnueabihf/libstdc++.so.6: version `CXXABI_1.3.9' not found (required by /opt/qt5.9.1 arm/lib/libQt5Widgets.so.5) ./test: /usr/lib/arm linux gnueabihf/libstdc++.so.6: version `CXXABI_1.3.9' not found (required by /opt/qt5.9.1 arm/lib/libQt5Gui.so.5) ./test: /usr/lib/arm linux gnueabihf/libstdc++.so.6: version `CXXABI_1.3.9' not found (required by /opt/qt5.9.1 arm/lib/libQt5Core.so.5) ``` 检查现有的libstdc++: ``` root@LicheePi:~# strings /usr/lib/arm linux gnueabihf/libstdc++.so.6 grep CXXA CXXABI_1.3 CXXABI_1.3.1 CXXABI_1.3.2 CXXABI_1.3.3 CXXABI_1.3.4 CXXABI_1.3.5 CXXABI_1.3.6 CXXABI_1.3.7 CXXABI_1.3.8 CXXABI_TM_1 CXXABI_ARM_1.3.3 ``` 说明系统里的libstdc++6使用了较老的编译器，导致test程序里链接后，无法正常使用库中的函数。 于是从linaro的 **arm linux gnueabihf/lib** 下拷出新的 **libstdc++.so.6.0.22** 覆盖即可。 再次运行，会发现界面上没有文字，终端提示没有字体。 于是下载任意字体，如simsun.ttf,放到 **/opt/qt5.9.1 arm/lib/fonts** 下，再重新运行，就有字体显示了。 ![](./../static/Drive/QT_6.jpg) 此时会发现无法触摸，于是运行下触摸校准程序： ts_calibrate ts_test 校准，测试通过后，再次运行，即可触摸控制了。 但此时会看到终端光标在左下角闪烁，而且有时候内核信息会覆盖图像，所以： 禁止printk，隐藏光标。 ``` echo 0 > /proc/sys/kernel/printk echo e \"\\033[?25l\" > /dev/tty0 ```"},"/soft/Lichee/zh/Zero-Doc/application/QT_doc6.html":{"title":"Qt字体相关","content":" title: Qt字体相关 ## 支持的字体 嵌入式Qt支持4中格式的字体，分别是： 1. TrueType(TTF) 可缩放字体格式，桌面系统中主要使用的字体 2. PostscripType(PFA/PFB)可缩放字体格式，打印主要使用的字体，可TTF类似 3. **Bitmap Distribution Format fonts (BDF)**不可缩放字体的标准格式，在X11平台系统中可以找到 4. Qt Prerendered Font (QPF) Qt预渲染字体，专用于嵌入式Qt的一种字体格式 QPF字体格式是嵌入式Qt内置支持的字体，可以使用QTSDK中提供的makeqpf工具利用前三种字体文件来生成。 而其它的字体格式是否支持则是可以进行裁剪定制的，可以去掉对TTF、BDF字体的支持以降低Qt库的空间占用，通过定义下面的Qt特性宏： ``` /* TrueType (TTF and TTC) font file format, only used by Qt/Embedded. */ #define QT_NO_TRUETYPE /* Bitmap Distribution Format (BDF) font file format, only used by Qt/Embedded. */ #define QT_NO_BDF ``` 当然，不定义这两个宏则表示支持TTF、BDF字体。 因为QPF是预渲染的，嵌入式Qt使用它时不需要读取和解析它，只需要进行简单快速的映射，因此它对内存的消耗是最小的。 因此一种方法是利用TTF和BDF字体文件制作好需要的QPF字体文件，然后移除对两者的支持。 TTF、PFA和QPF字体都支持字体的反锯齿，即使字体尽量显示的圆滑而不会有锯齿感，从而提供更好的可读性和观感，特别是在低分辨率设备上，但是这是以消耗更多的内存和空间为代价的，大概是不反锯齿的八倍。 对于所有的字体文件，嵌入式Qt都是使用Unicode编码的格式。 ## 使用字体文件 当Qt应用运行时，它会到以下两个目标之一去寻找规定的字体定义文件fontdir： ``` $QTDIR/lib/fonts/fontdir QTDIR是一般使用Qte都会定义的环境变量 /usr/local/qt embedded/lib/fonts/fontdir 可能是默认的qt安装路径 ``` fontdir文件定义了Qt应用可以使用的字体格式、大小和文件等内容。fontdir文件的内容和字体条目定义的格式可以参考如下的示例文件，文件中有相应的说明： 一个典型的FONTDIR文件的内容如下所示： fixed fixed_120_50.qpf QPF n 50 120 helvetica helvetica_80_50.qpf QPF n 50 80 helvetica helvetica_120_50.qpf QPF n 50 120 u helvetica helvetica_120_75.qpf QPF n 75 120 u helvetica helvetica_140_75.qpf QPF n 75 140 helvetica helvetica_180_75.qpf QPF n 75 180 文件中每行都标识一个特定的字库，每个段的含义是： 第一列为name， 第二列为file， 第三列为renderer，相当于字型格式，所以有BDF，TTT，QPF等选择。 第四列n表示iitalic，表示是否为斜体字。 第五列表示weight，其中50表示Normal，75表示Bold。 第六列表示size，例如：120表示12pt。 第七列为flags，有下面三个选择： s smooth(anti aliased) u unicode range when saving (default is Latin 1 a ASCII range when saving(default is Latin 1)) 你可以在文件中添加其它的字体格式条目，前提是你有相应的字体文件，不然加了也没用。 ## 关于文件中的渲染引擎renderer 上面也提到了，renderer只能是BDF或者FT，BDF对应BDF字体文件，而FT是FreeType的缩写，FreeType是一个强大的库用来实现渲染TTF/TTC和PFA字体，在嵌入式QT库的编译配置时可以选择是否支持。注意到没有QPF渲染引擎的说法，这是因为QPF字体文件的使用是不需要在fontdir文件中定义的，只需要将QPF字体文件放到和fontdir文件同一级目录下就可以，但是QPF字体文件的命名必须符合Qte的规范： name_size_weightitalicflag.qpf e.g: wenquanyi_160_75.qpf 16pt文泉驿粗体，不支持斜体 wenquanyi_160_50i.qpf 16pt文泉驿正常，支持斜体 ## 关于文件中的字体大小size size的大小是字体大小\\*10，也就是12pt字体的size是120，但是我对pt这个单位没有什么概念，所以我特意查找对比了一下字体大小的单位表示，整理如下： 小五号:9pt, 五号:10.5pt, 小四号:12pt 四号:13.75pt(磅), 三号:15.75pt(磅), 二号:21pt 中文最小字号:八号;2.83pt 1mm, 28.3pt 1cm 一号字体(27.5pt) 字体大小对应的点阵: 9pt:1212(96dpi),1515(120dpi); 12pt: 1515(96dpi),1919(120dpi) 不过在实际的嵌入式设备上显示时好像和这种字体大小在word上的显示不太一致，如前面的16pt文泉驿字体在设备上显示的大小感觉和word中的小四号字体差不多大。 ## 关于中文字体支持 步入重点，如果需要支持中文字体，显然就需要有对应的中文字体文件。 前面提到的unifont.bdf文件和文泉驿字体文件都是可以支持中文的，也可以从对应的网站上下载到官方的字体文件。 而文泉驿字体在Linux系统X11平台上也是使用的比较多的，所以可以直接取用。 ## 关于QPF字体文件生成的捷径 前面提到可以使用makeqpf工具通过TTF、BDF字体文件来生成QPF字体文件，这就需要编译makeqpf工具，然后自己一个个去进行相应的转换，你还可能不确定会使用到哪些字体。 另一种更方便快捷的方法是让Qt应用自动完成需要使用字体的QPF生成，方法就是在运行Qt应用时，加上 savefonts 选项。此时应用会将所有使用到的非QPF字体自动转换生成QPF字体文件并保存下来。 然后你就可以去掉TTF、BDF支持，支持使用QPF字体文件进行部署了。 ## 参考资料 <http://doc.qt.io/qt 5/qt embedded fonts.html>"},"/soft/Lichee/zh/Zero-Doc/application/otg2PC.html":{"title":"Zero通过otg与PC共享网络","content":" title: Zero通过otg与PC共享网络 ## 修改内核 在内核选项中勾选上`Ethernet Gadget`, 就可以让Zero与PC通过usb共享网络。 ``` Location: > Device Drivers \t > USB support (USB_SUPPORT [ y]) \t\t > USB Gadget Support (USB_GADGET [ y]) \t\t\t<*> USB Gadget precomposed configurations (Ethernet Gadget (with CDC Ethernet support)) ``` ## 配置zero网卡 ### on zero #### 打开usb0网卡 `ifconfig usb0 up` #### 设置usb0 ip `usb0 192.168.2.100 netmask 255.255.255.0` 由于usb网卡默认关闭，所以建议将该文件写入开机脚本，上电即可使用ssh连接。 修改/etc/init.d/S40network ``` start) printf \"Starting network: \" /sbin/ifup a /sbin/ifconfig usb0 up /sbin/ifconfig usb0 192.168.2.100 netmask 255.255.255.0 [ $? 0 ] && echo \"OK\" echo \"FAIL\" ;; stop) printf \"Stopping network: \" /sbin/ifdown a /sbin/ifconfig usb0 down [ $? 0 ] && echo \"OK\" echo \"FAIL\" ;; ``` ### on pc(linux) `ifconfig a` `usb0: flags 4163<UP,BROADCAST,RUNNING,MULTICAST> mtu 1500` 如果出现： `enx1288194be3c3: flags 4163<UP,BROADCAST,RUNNING,MULTICAST> mtu 1500` 可以尝试重启ubuntu，然后就可以正确识别。如果还不行，也可以以`enx1288194be3c3`代替`usb0`继续执行后面操作。 #### 为usb网卡分配ip `ifconfig usb0 192.168.2.1 netmask 255.255.255.0` 然后就可以ping通了 ``` lithromantic@ubuntu ~ ☺ ping 192.168.2.100 PING 192.168.2.100 (192.168.2.100) 56(84) bytes of data. 64 bytes from 192.168.2.100: icmp_seq 1 ttl 64 time 1.45 ms 64 bytes from 192.168.2.100: icmp_seq 2 ttl 64 time 1.08 ms 64 bytes from 192.168.2.100: icmp_seq 3 ttl 64 time 0.920 ms 64 bytes from 192.168.2.100: icmp_seq 4 ttl 64 time 0.721 ms 64 bytes from 192.168.2.100: icmp_seq 5 ttl 64 time 0.713 ms ^C 192.168.2.100 ping statistics 5 packets transmitted, 5 received, 0% packet loss, time 4026ms rtt min/avg/max/mdev 0.713/0.976/1.454/0.274 ms ``` ``` # ping 192.168.2.1 PING 192.168.2.1 (192.168.2.1): 56 data bytes 64 bytes from 192.168.2.1: seq 0 ttl 64 time 1.227 ms 64 bytes from 192.168.2.1: seq 1 ttl 64 time 0.941 ms 64 bytes from 192.168.2.1: seq 2 ttl 64 time 0.880 ms 64 bytes from 192.168.2.1: seq 3 ttl 64 time 0.953 ms 64 bytes from 192.168.2.1: seq 4 ttl 64 time 1.165 ms ^C 192.168.2.1 ping statistics 5 packets transmitted, 5 packets received, 0% packet loss round trip min/avg/max 0.880/1.033/1.227 ms ``` 需要注意的是，此时Licheepi Zero只能访问主机ip地址，所以是无法正常上网的。 on pc (Windows) Windows不能很好的识别Licheepi Zero的usb网络，需要手动安装驱动，详情参考[测试测试 g_serial / g_ether USB Gadget (RNDIS) / 全志 V3S/F1C100s/X3/D1/R329/AIC800 / WhyCan Forum(哇酷开发者社区)](https://whycan.com/t_2401.html) ### SSH连接 在linux中，可以直接在终端中ssh连接 ``` lithromantic@ubuntu: ~ $ ssh root@192.168.2.100 [20:41:18] root@192.168.2.100's password: # ls badapple.mp4 demo ``` 如果需要移动文件等操作，可以使用scp，或者在文件管理器中添加`sftp://192.168.2.100` 以文件夹形式打开Licheepi Zero的磁盘。 ![image 20210901115013624](./../static/Drive/image 20210901115013624.png) ![image 20210901115115780](./../static/Drive/image 20210901115115780.png) 对于windows，如果驱动安装失败，可以通过ssh桥接的方式连接LicheepiZero（需要linux虚拟机）。 参考连接：[烂泥：学习ssh之ssh隧道应用 烂泥行天下 (ilanni.com)](https://www.ilanni.com/?p 10425) 操作如下 ![202109011224](./../static/Drive/202109011224.gif)"},"/soft/Lichee/zh/Zero-Doc/application/QT_index.html":{"title":"基于QT的GUI开发","content":" title: 基于QT的GUI开发 本节介绍各类QT操作"},"/soft/Lichee/zh/Zero-Doc/application/QT_doc2.html":{"title":"移植QT5.9.1","content":" title: 移植QT5.9.1 移植完成tslib之后，就可以进行QT本体的移植了，目前最新版本为5.9.1。 注意QT本体编译时间较长，笔记本上会耗时2\\~3小时，我使用的32线程服务器的编译时间为9分钟左右。 ## 下载QT5.9.1 ``` wget http://download.qt.io/official_releases/qt/5.9/5.9.1/single/qt everywhere opensource src 5.9.1.tar.xz tar xf qt everywhere opensource src 5.9.1.tar.xz #这里解压也需要30s左右，别以为死机了。。 cd qt everywhere opensource src 5.9.1 ./configure help >help.txt #QT的配置较为复杂，进来先看看帮助文档，在本节最后附录里有翻译 ``` 一般来说，我们需要编译主机和目标板两个版本的qt： > 主机版可以用于前期的gui的设计调试；目标板用于实际产品的验证。 ## 编译X11版本 主机版一般是X11，配置如下： ``` #!/bin/bash ./configure prefix /opt/qt 5.9.1 x11 opensource make tools #安装位置，开源版本，编译qt工具（makeqpf,qtconfig） make j32 sudo make install ``` 运行该脚本，首次配置用时1分钟左右。编译一次参考时间： real 9m17.309s user 206m59.052s sys 17m30.300s 所以单核虚拟机编译需要三小时左右。 编译完成后install也需要1分钟左右。 安装完成后在/opt/qt 5.9.1 x11下可见安装的文件。 ## 交叉编译arm版本 注意，在第二次编译前，先 `make clean` 下。如果编译时候仍有错误，可以重新解压编译。 交叉编译，需要配置 xplatform选项，比如要在arm linux平台上移植Qt的话，就在配置项中加上 ` xplatform linux arm gnueabi g++` ，这个是平台名字，Qt5支持的交叉平台都可在源码顶层目录中的 **/qtbase/mkspecs/** 下找到。 首先我们需要编辑 **qtbase/mkspecs/linux arm gnueabi g++/qmake.conf**： 加上：（注意，和tslib类似，这里要加上其它什么支持的话，也是交叉编译的库的路径） ``` QT_QPA_DEFAULT_PLATFORM linuxfb QMAKE_CFLAGS_RELEASE + O2 march armv7 a lts QMAKE_CXXFLAGS_RELEASE + O2 march armv7 a lts QMAKE_INCDIR + /opt/tslib/include /opt/sqlite3/include QMAKE_LIBDIR + /opt/tslib/lib /opt/sqlite3/lib ``` 把 **arm linux gnueabihf gcc** 改成 **arm linux gnueabi gcc** 等。 然后再编辑配置脚本cfg_arm.sh ``` #!/bin/sh ./configure verbose \\ prefix /opt/qt5.9.1 arm \\ confirm license \\ opensource \\ release \\ make libs \\ xplatform linux arm gnueabi g++ \\ optimized qmake \\ pch \\ sql sqlite sqlite \\ qt libjpeg \\ qt libpng \\ qt zlib \\ tslib \\ no opengl \\ no sse2 \\ no openssl \\ no cups \\ no glib \\ no dbus \\ no xcb \\ no separate debug info \\ I/opt/tslib/include L/opt/tslib/lib \\ make examples make tools nomake tests no iconv ``` ``` make j32 sudo make install ``` 完成后，相关文件在 **/opt/qt5.9.1 arm** 下。 ## 向开发板添加Qt库 首先将 **/opt/qt5.9.1 arm** 和 **/opt/tslib** 复制到开发板的对应目录下 然后设置开发板 Qt 环境变量， `vi /etc/bash.bashrc` 添加下面内容： ``` export TSLIB_CONSOLEDEVICE none export TSLIB_FBDEVICE /dev/fb0 export TSLIB_TSDEVICE /dev/input/event1 export TSLIB_CONFFILE /opt/tslib/etc/ts.conf export TSLIB_PLUGINDIR /opt/tslib/lib/ts export TSLIB_CALIBFILE /etc/pointercal export LD_LIBRARY_PATH /lib:/usr/lib:/opt/tslib/lib:/opt/qt5.9.1 arm/lib export PATH /bin:/sbin:/usr/bin/:/usr/sbin:/opt/tslib/bin export QT_QPA_PLATFORM_PLUGIN_PATH /opt/qt5.9.1 arm/plugins export QT_QPA_PLATFORM linuxfb:tty /dev/fb0 export QT_QPA_FONTDIR /opt/qt5.9.1 arm/lib/fonts export QT_QPA_GENERIC_PLUGINS tslib:$TSLIB_TSDEVICE ``` 保存后生效上述内容： `source /etc/bash.bashrc` ## 参考资料 <http://blog.csdn.net/newthinker_wei/article/details/39560109> <http://www.linuxidc.com/Linux/2014 03/98079.htm> ## 附录：QT配置帮助文件 翻译 Usage: configure [options] [assignments] 在命令行使用VAR value来配置变量。 每个大写的库名（用 list libraries可以查看），支持这些后缀： _INCDIR, _LIBDIR, _PREFIX (INCDIR PREFIX/include, LIBDIR PREFIX/lib), _LIBS, and on Windows and Darwin _LIBS_DEBUG and _LIBS_RELEASE. E.g., ICU_PREFIX /opt/icu42 ICU_LIBS \" licui18n licuuc licudata\". 同时支持操作 QMAKE_* 变量，来修改mkspec里指定的值，比如QMAKE_CXXFLAGS+ g3. **顶层安装路径：** prefix 目标路径（在开发板上的绝对路径） [如果使能了developer build，就是/usr/local/Qt $QT_VERSION, $PWD] extprefix 安装路径（在主机上的路径，比prefix更多一个前置路径），可不写 [SYSROOT/PREFIX] hostprefix [dir] .. The installation directory for build tools running on the host machine. If [dir] is not given, the current build directory will be used. [EXTPREFIX] external hostbindir Path to Qt tools built for this machine. Use this when platform does not match the current system, i.e., to make a Canadian Cross Build. **微调安装路径的分布** ，注意除了 sysconfdir外的所有目录需要在 ** prefix/ hostprefix** 下。 （这里基本可以不配置） bindir Executables [PREFIX/bin] headerdir Header files [PREFIX/include] libdir Libraries [PREFIX/lib] archdatadir . Arch dependent data [PREFIX] plugindir Plugins [ARCHDATADIR/plugins] libexecdir .. Helper programs [ARCHDATADIR/bin on Windows, ARCHDATADIR/libexec otherwise] importdir QML1 imports [ARCHDATADIR/imports] qmldir QML2 imports [ARCHDATADIR/qml] datadir .. Arch independent data [PREFIX] docdir Documentation [DATADIR/doc] translationdir . Translations [DATADIR/translations] sysconfdir .. Settings used by Qt programs [PREFIX/etc/xdg] examplesdir . Examples [PREFIX/examples] testsdir . Tests [PREFIX/tests] hostbindir .. Host executables [HOSTPREFIX/bin] hostlibdir .. Host libraries [HOSTPREFIX/lib] hostdatadir . Data used by qmake [HOSTPREFIX] **对剩余的选项的约定：** 当一个选项描述符在一系列方括号内的变量之后，这个选项的解释是： 空选项表示yes； 所有其他值是可能的前缀，比如 no gui. Values are listed in the order they are tried if not specified; 'auto' 是 'yes/no'的简写. 单个 'yes' 和 'no' 表示没有自动检测的二进制选项。 **可配置的meta：** help, h Display this help screen verbose, v Print verbose messages during configuration continue Continue configure despite errors redo . Re configure with previously used options. Additional options may be passed, but will not be saved for later use by redo. recheck . Discard cached negative configure test results. Use this after installing missing dependencies. recheck all Discard all cached configure test results. feature Enable no feature Disable [none] list features . List available features. Note that some features have dedicated command line options as well. list libraries List possible external dependencies. **构建选项：** opensource . Build the Open Source Edition of Qt commercial . Build the Commercial Edition of Qt confirm license .. Automatically acknowledge the license release . Build Qt with debugging turned off [yes] debug Build Qt with debugging turned on [no] debug and release Build two versions of Qt, with and without debugging turned on [yes] (Apple and Windows only) optimize debug Enable debug friendly optimizations in debug builds [auto] (Not supported with MSVC) optimize size . Optimize release builds for size instead of speed [no] optimized tools .. Build optimized host tools even in debug build [no] force debug info . Create symbol files for release builds [no] separate debug info . Split off debug information to separate files [no] strip Strip release binaries of unneeded symbols [yes] force asserts . Enable Q_ASSERT even in release builds [no] developer build .. Compile and link Qt for developing Qt itself (exports for auto tests, extra checks, etc.) [no] shared .. Build shared Qt libraries [yes] (no for UIKit) static .. Build static Qt libraries [no] (yes for UIKit) framework .. Build Qt framework bundles [yes] (Apple only) platform Select host mkspec [detected] xplatform .. Select target mkspec when cross compiling [PLATFORM] device . Cross compile for device device option <key value> Add option for the device mkspec appstore compliant .. Disable code that is not allowed in platform app stores. This is on by default for platforms which require distribution through an app store by default, in particular Android, iOS, tvOS, watchOS, and Universal Windows Platform. [auto] qtnamespace .. Wrap all Qt library code in 'namespace { }'. qtlibinfix .. Rename all libQt5*.so to libQt5*.so. testcocoon . Instrument with the TestCocoon code coverage tool [no] gcov . Instrument with the GCov code coverage tool [no] sanitize {addressthreadmemoryundefined} Instrument with the specified compiler sanitizer. c++std . Select C++ standard [c++1z/c++14/c++11] (Not supported with MSVC) sse2 . Use SSE2 instructions [auto] sse3/ ssse3/ sse4.1/ sse4.2/ avx/ avx2/ avx512 Enable use of particular x86 instructions [auto] Enabled ones are still subject to runtime detection. mips_dsp/ mips_dspr2 Use MIPS DSP/rev2 instructions [auto] qreal .. typedef qreal to the specified type. [double] Note: this affects binary compatibility. R . Add an explicit runtime library path to the Qt libraries. Supports paths relative to LIBDIR. rpath Link Qt libraries and executables using the library install path as a runtime library path. Similar to R LIBDIR. On Apple platforms, disabling this implies using absolute install names (based in LIBDIR) for dynamic libraries and frameworks. [auto] reduce exports Reduce amount of exported symbols [auto] reduce relocations .. Reduce amount of relocations [auto] (Unix only) plugin manifests . Embed manifests into plugins [no] (Windows only) static runtime With static, use static runtime [no] (Windows only) pch .. Use precompiled headers [auto] ltcg . Use Link Time Code Generation [no] use gold linker .. Use the GNU gold linker [auto] incredibuild xge . Use the IncrediBuild XGE [no] (Windows only) make tool . Use to build qmake [nmake] (Windows only) mp Use multiple processors for compilation (MSVC only) warnings are errors . Treat warnings as errors [no; yes if developer build] silent .. Reduce the build output so that warnings and errors can be seen more easily **构建环境：** sysroot . Set as the target sysroot gcc sysroot With sysroot, pass sysroot to the compiler [yes] pkg config . Use pkg config [auto] (Unix only) D . Pass additional preprocessor define I . Pass additional include path L . Pass additional library path F . Pass additional framework path (Apple only) sdk .. Build Qt using Apple provided SDK . The argument should be one of the available SDKs as listed by 'xcodebuild showsdks'. Note that the argument applies only to Qt libraries and applications built using the target mkspec not host tools such as qmake, moc, rcc, etc. android sdk path . Set Android SDK root path [$ANDROID_SDK_ROOT] android ndk path . Set Android NDK root path [$ANDROID_NDK_ROOT] android ndk platform Set Android platform android ndk host . Set Android NDK host (linux x86, linux x86_64, etc.) [$ANDROID_NDK_HOST] android arch .. Set Android architecture (armeabi, armeabi v7a, arm64 v8a, x86, x86_64, mips, mips64) android toolchain version Set Android toolchain version android style assets Automatically extract style assets from the device at run time. This option makes the Android style behave correctly, but also makes the Android platform plugin incompatible with the LGPL2.1. [yes] **组件选择** skip Exclude an entire repository from the build. make Add to the list of parts to be built. Specifying this option clears the default list first. [libs and examples, also tools if not cross building, also tests if developer build] nomake . Exclude from the list of parts to be built. compile examples . When unset, install only the sources of examples [yes] gui .. Build the Qt GUI module and dependencies [yes] widgets . Build the Qt Widgets module and dependencies [yes] no dbus . Do not build the Qt D Bus module [default on Android and Windows] dbus linked Build Qt D Bus and link to libdbus 1 [auto] dbus runtime .. Build Qt D Bus and dynamically load libdbus 1 [no] accessibility . Enable accessibility support [yes] Note: Disabling accessibility is not recommended. qml debug .. Enable QML debugging support [yes] Qt comes with bundled copies of some 3rd party libraries. These are used by default if auto detection of the respective system library fails. **核心选项** doubleconversion . Select used double conversion library [system/qt/no] No implies use of sscanf_l and snprintf_l (imprecise). glib . Enable Glib support [no; auto on Unix] eventfd . Enable eventfd support inotify . Enable inotify support iconv Enable iconv(3) support [posix/sun/gnu/no] (Unix only) icu .. Enable ICU support [auto] pcre . Select used libpcre2 [system/qt] pps .. Enable PPS support [auto] (QNX only) zlib . Select used zlib [system/qt] **日志后端** journald . Enable journald support [no] (Unix only) syslog Enable syslog support [no] (Unix only) slog2 . Enable slog2 support [auto] (QNX only) **网络选择** ssl .. Enable either SSL support method [auto] no openssl . Do not use OpenSSL [default on Apple and WinRT] openssl linked Use OpenSSL and link to libssl [no] openssl runtime .. Use OpenSSL and dynamically load libssl [auto] securetransport .. Use SecureTransport [auto] (Apple only) sctp . Enable SCTP support [no] libproxy Enable use of libproxy [no] system proxies Use system network proxies by default [yes] **Gui, 打印, 挂件选择** cups . Enable CUPS support [auto] (Unix only) fontconfig . Enable Fontconfig support [auto] (Unix only) freetype Select used FreeType [system/qt/no] harfbuzz Select used HarfBuzz NG [system/qt/no] (Not auto detected on Apple and Windows) gtk .. Enable GTK platform theme support [auto] lgmon Enable lgmon support [auto] (QNX only) no opengl .. Disable OpenGL support opengl .. Enable OpenGL support. Supported APIs: es2 (default on Windows), desktop (default on Unix), dynamic (Windows only) opengles3 .. Enable OpenGL ES 3.x support instead of ES 2.x [auto] angle Use bundled ANGLE to support OpenGL ES 2.0 [auto] (Windows only) combined angle lib .. Merge LibEGL and LibGLESv2 into LibANGLE (Windows only) qpa . Select default QPA backend (e.g., xcb, cocoa, windows) xcb xlib . Enable Xcb Xlib support [auto] **平台后端：** direct2d . Enable Direct2D support [auto] (Windows only) directfb . Enable DirectFB support [no] (Unix only) eglfs . Enable EGLFS support [auto; no on Android and Windows] gbm Enable backends for GBM [auto] (Linux only) kms Enable backends for KMS [auto] (Linux only) linuxfb .. Enable Linux Framebuffer support [auto] (Linux only) mirclient Enable Mir client support [no] (Linux only) xcb Select used xcb * libraries [system/qt/no] ( qt xcb still uses system version of libxcb itself) **输入后端** evdev . Enable evdev support [auto] imf Enable IMF support [auto] (QNX only) libinput . Enable libinput support [auto] mtdev . Enable mtdev support [auto] tslib . Enable tslib support [auto] xinput2 .. Enable XInput2 support [auto] xkbcommon x11 .. Select xkbcommon used in combination with xcb [system/qt/no] xkb config root With qt xkbcommon x11, set default XKB config root [detect] xkbcommon evdev Enable X less xkbcommon in combination with libinput [auto] **图像格式** gif Enable reading support for GIF [auto] ico Enable support for ICO [yes] libpng Select used libpng [system/qt/no] libjpeg .. Select used libjpeg [system/qt/no] **数据库选项** sql .. Enable SQL plugin. Supported drivers: db2 ibase mysql oci odbc psql sqlite2 sqlite tds [all auto] sqlite .. Select used sqlite3 [system/qt] **Qt3D 选项** assimp .. Select used assimp library [system/qt/no] qt3d profile jobs Enable jobs profiling [no] qt3d profile gl .. Enable OpenGL profiling [no] **多媒体选项** pulseaudio . Enable PulseAudio support [auto] (Unix only) alsa . Enable ALSA support [auto] (Unix only) no gstreamer .. Disable support for GStreamer gstreamer [version] . Enable GStreamer support [auto] With no parameter, 1.0 is tried first, then 0.10. mediaplayer backend Select media player backend (Windows only) Supported backends: directshow (default), wmf"},"/soft/Lichee/zh/Zero-Doc/application/debug.html":{"title":"Segment Fault调试","content":" title: Segment Fault调试 在调试linux程序时经常会出现段错误，这里介绍常规的段错误定位方法，即使用core dump文件。 ## 配置core dump 先设置允许的core dump文件大小。 ``` echo \"ulimit c 102400\" >> /etc/profile #ulimit c unlimited 可以设置为无限 source /etc/profile #生效 ``` 使用 `ulimit c` 来查看当前的core文件大小。 ## 配置core 文件名 **/proc/sys/kernel/core\\_uses\\_pid** 可以控制产生的 core 文件的文件名中是否添加 pid 作为扩展 ，如果添加则文件内容为 1 ，否则为 0 ## 配置core保存位置 core保存位置默认为当前目录下core名字 *proc/sys/kernel/core\\_pattern* 可以设置格式化的 core 文件保存位置或文件名 ，比如原来文件内容是 core %e 可以这样修改 : `echo \"/corefile/core %e %p %t\" > core_pattern` 将会控制所产生的 core 文件会存放到 /corefile 目录下，产生的文件名为 core 命令名 pid 时间戳 以下是参数列表 : %p insert pid into filename 添加 pid %u insert current uid into filename 添加当前 uid %g insert current gid into filename 添加当前 gid %s insert signal that caused the coredump into the filename 添加导致产生 core 的信号 %t insert UNIX time that the coredump occurred into filename 添加 core 文件生成时的 unix 时间 %h insert hostname where the coredump happened into filename 添加主机名 %e insert coredumping executable name into filename 添加命令名"},"/soft/Lichee/zh/Zero-Doc/application/QT_doc3.html":{"title":"移植QT4.8.7","content":" title: 移植QT4.8.7 之前移植了QT5.9.1，这里移植QT4.8.7就简单介绍下 ## 下载QT4.8.7 ``` wget http://download.qt.io/official_releases/qt/4.8/4.8.7/qt everywhere opensource src 4.8.7.tar.gz tar xf qt everywhere opensource src 4.8.7.tar.gz cd qt everywhere opensource src 4.8.7 ./configure help >help.txt #QT的配置较为复杂，进来先看看帮助文档，在本节最后附录里有翻译 ``` 一般来说，我们需要编译主机和目标板两个版本的qt： 主机版可以用于前期的gui的设计调试；目标板用于实际产品的验证。 ## 编译X11版本 主机版一般是X11，配置如下： ``` #!/bin/bash ./configure prefix /opt/qt 4.8.7 x11 opensource make tools #安装位置，开源版本，编译qt工具（makeqpf,qtconfig） make j32 #约10分钟 sudo make install ``` 安装完成后在 */opt/qt 4.8.7 x11* 下可见安装的文件。 ## 交叉编译arm版本 注意，在第二次编译前，先 `make clean` 下。如果编译时候仍有错误，可以重新解压编译。 交叉编译，需要配置 xplatform选项，比如要在arm linux平台上移植Qt的话，就在配置项中加上 ** xplatform linux arm gnueabi g++** ，这个是平台名字，Qt5支持的交叉平台都可在源码顶层目录中的 mkspecs/ 下找到。 首先我们需要编辑 **mkspecs/qws/linux arm gnueabi g++/qmake.conf** ： 加上：（注意，和tslib类似，这里要加上其它什么支持的话，也是交叉编译的库的路径） ``` QT_QPA_DEFAULT_PLATFORM linuxfb QMAKE_CFLAGS_RELEASE + O2 march armv7 a lts QMAKE_CXXFLAGS_RELEASE + O2 march armv7 a lts QMAKE_INCDIR + /opt/tslib/include /opt/sqlite3/include QMAKE_LIBDIR + /opt/tslib/lib /opt/sqlite3/lib ``` 把 *arm linux gnueabihf gcc* 改成 *arm linux gnueabi gcc* 等。 然后再编辑配置脚本cfg\\_arm.sh ``` #/bin/sh ./configure verbose \\ opensource \\ confirm license \\ release shared \\ embedded arm \\ xplatform qws/linux arm gnueabi g++ \\ depths 4,8,16,32 \\ fast \\ optimized qmake \\ pch \\ qt sql sqlite \\ qt libjpeg \\ qt zlib \\ qt libpng \\ qt freetype \\ little endian host little endian \\ no qt3support \\ no libtiff no libmng \\ no opengl \\ no mmx no sse no sse2 \\ no 3dnow \\ no openssl \\ no webkit \\ no qvfb \\ no phonon \\ no nis \\ no opengl \\ no cups \\ no glib \\ qt gfx transformed \\ no xcursor no xfixes no xrandr no xrender \\ no separate debug info \\ nomake examples make tools make docs \\ qt mouse tslib I/opt/tslib/include L/opt/tslib/lib make j32 sudo make install ``` 完成后，相关文件在 **/opt/qt4.8.7 arm** 下。 ## 常见编译错误 配置QT的时候，如果指定了 webkit，编译的时候会报错： > ../3rdpartyjavascriptcoreJavaScriptCore/wtf/TypeTraits.h:173:69:error: 'std::tr1' has not been declared 解决方法： 修改QT源码目录下mkspecs/qws/linux arm gnueabi g++/qmake.conf文件，加上一行：QMAKE_CXXFLAGS \\$\\$QMAKE_CFLAGS std gnu++98 \\>\\>\\> /opt/gcc linaro 6.3.1 2017.05 x86_64_arm linux gnueabihf/bin/../lib/gcc/arm linux gnueabihf/6.3.1/../../../../arm linux gnueabihf/bin/ld: warning: libts.so.0, needed by /home/wcz/qt everywhere opensource src 4.8.7_arm/lib/libQtGui.so, not found (try using rpath or rpath link) 提示没有tslib的库，当然了，提示中也清楚的说了(try using rpath or rpath link)。 我们可以： > 1. 进入到编译报错的目录，在这里是“examples/network/broadcastreceiver“ > 2. 修改这个目录中的Makefile文件，找到LFLAGS一行，在最后面加上” Wl, rpath,/opt/tslib/lib“，也就是手动指定tslib的目录。（这里还没清楚为何configure时的参数没起作用） > 3. 就地make > 4. 退回到主目录 > 5. 继续make 上面的操作，如果每个Makefile都要编辑一遍的话，那就太麻烦了，我们偷偷懒。 针对Makefile的LFLAGS一行的特点，我们使用 *find、grep、awk、sed、xargs* 来完成这个操作，如下： 进入到出错目录的顶层，如上示例，我们进入到examples。 cd examples find . name Makefile xargs grep rpath link grep v tslib awk F: '{fname[NR] $1} END {for (i 1;i< NR;i++){print fname[i]}}' xargs sed i 's/LFLAGS.*/& Wl, rpath,\\/opt\\/tslib\\/lib/' <注意，这个命令会直接修改目录中最底层的每一个Makefile，请试验成功后再使用.> ## 向开发板添加Qt库 首先将 **/opt/qt5.9.1 arm和/opt/tslib** 复制到开发板的对应目录下 然后设置开发板 Qt 环境变量， `vi /etc/bash.bashrc` 添加下面内容： ``` export TSLIB_CONSOLEDEVICE none export TSLIB_FBDEVICE /dev/fb0 export TSLIB_TSDEVICE /dev/input/event1 export TSLIB_CONFFILE /opt/tslib/etc/ts.conf export TSLIB_PLUGINDIR /opt/tslib/lib/ts export TSLIB_CALIBFILE /etc/pointercal export LD_LIBRARY_PATH /lib:/usr/lib:/opt/tslib/lib:/opt/qt5.9.1 arm/lib export PATH /bin:/sbin:/usr/bin/:/usr/sbin:/opt/tslib/bin export QT_QPA_PLATFORM_PLUGIN_PATH /opt/qt5.9.1 arm/plugins export QT_QPA_PLATFORM linuxfb:tty /dev/fb0 export QT_QPA_FONTDIR /opt/qt5.9.1 arm/lib/fonts export QT_QPA_GENERIC_PLUGINS tslib:$TSLIB_TSDEVICE export QWS_MOUSE_PROTO Tslib:/dev/input/event0 export LD_LIBRARY_PATH $LD_LIBRARY_PATH:/optslib/lib:/opt/qt5.9.1 arm/lib:/usr/lib/arm linux gnueabihf/lib ``` 保存后生效上述内容： `source /etc/bash.bashrc` br生成的文件系统则为： ``` export TSLIB_CONSOLEDEVICE none export TSLIB_FBDEVICE /dev/fb0 export TSLIB_TSDEVICE /dev/input/event1 export TSLIB_CONFFILE /etc/ts.conf export TSLIB_PLUGINDIR /usr/lib/ts export TSLIB_CALIBFILE /etc/pointercal export LD_LIBRARY_PATH /lib:/usr/lib export PATH /bin:/sbin:/usr/bin/:/usr/sbin export QT_QPA_PLATFORM_PLUGIN_PATH /usr/lib/qt/plugins export QT_QPA_PLATFORM linuxfb:tty /dev/fb0 export QT_QPA_FONTDIR /usr/lib/qt/lib/fonts export QT_QPA_GENERIC_PLUGINS tslib:$TSLIB_TSDEVICE export QWS_MOUSE_PROTO Tslib:/dev/input/event1 ``` ## 参考资料 <http://blog.csdn.net/armfpga123/article/details/52921558> <http://blog.chinaunix.net/uid 29962009 id 5012060.html>"},"/soft/Lichee/zh/Zero-Doc/application/QT_doc9.html":{"title":"Qt去除鼠标指针显示","content":" title: Qt去除鼠标指针显示 ## qt全屏显示 主要是设置setWindowFlags 可以这样使用全屏幕 ``` yourwidget >setWindowFlags(Qt::window Qt::FramelessWindowHint); //第一个Qt::window表示此widget是窗口类型，第二个参数使用无框架就是没有标题，状态栏等。具体参考 $QTPATH/examples/widgets/windowflags/ ``` ## Qt Embedded Linux下隐藏鼠标箭头 1. 编译Qt库的时候添加编译选项QT\\_NO\\_CURSOR，这样cursor相关的代码统统不会被编译进去，自然鼠标光标也不会出现在程序中。 no mouse tslib 2. 只希望在某个QWidget下不出现鼠标光标，则只要对这个widget调用 `QWidget::setCursor(QCursor(Qt::BlankCursor))`，其它的窗口仍将出现鼠标。 3. 在main函数中，实例化了APPLICATION后，调用 `QApplication::setOverrideCursor(Qt::BlankCursor);` 4. 任一控件下显示与关闭鼠标 ``` this >setCursor(Qt::BlankCursor); //隐藏鼠标 this >setCursor(Qt::ArrowCursor); //显示正常鼠标 ``` this改为需要隐藏鼠标的部件，就可以令当鼠标移动到该部件时候，效果生效。 以上的都需要动一下鼠标才会消失，不知道不是我没有搞好，下面一启动就可以隐藏起来 5. 调用下面函数 `QWSServer::setCursorVisible(false);` 这是一个静态函数，可以在main()函数中，实例化QApplication以后调用，这样整个程序将不会出现鼠标的光标。注意必须包含头文件。//但是在程序启动时会闪现一下光标 ## 源代码 > src/corelib/global/qfeatures.h"},"/soft/Lichee/zh/Zero-Doc/application/autorun.html":{"title":"开机自启动","content":" title: 开机自启动 ## buildroot 根文件系统 修改/etc/inittab: > `ttyS0::respawn:/root/logintest L ttyS0 115200 vt100` 新建logintest： ``` #!/bin/sh /bin/login f root ``` 自启动任务在 */etc/init.d/rcS* 中加入即可 export 相关环境变量在 */etc/profile* 中加入。 ## 开机免登陆 ### 修改mingetty： <http://www.filewatcher.com/m/mingetty 1.07.tar.gz.13435 0.html> ``` 第352行的char *logname, *s; 更改为char *logname \"root\", *s; 把第409 415行注释 /* if (autologin) { do_prompt (0); printf (\"login: %s (automatic login)\\n\", autologin); logname autologin; } else while ((logname get_logname ()) 0) /* do nothing */ /*; */ ``` 修改makefile CC arm none linux gnueabi gcc //本机编译则不用 编译生成mingetty将生成的mingetty程序拷贝到根文件系统的/sbin目录下 ### 修改login <http://www.filewatcher.com/_/?q util linux 2.13 pre7.tar.bz2> 修改login.c中的代码 把344行的passwd_req 1; 更改为passwd_req 0; 在文件中添加locale.h头文件 #include <locale.h> 编译生成login `gcc o login login.c ../lib/setproctitle.c checktty.c Wall lcrypt I ../include/` 更新login 将生成的login 程序拷贝到根文件系统的/bin目录下，结束。 ### 修改inittab文件 将跟文件系统/etc/inittab文件中的最后的登录语句 `S2:2345:respawn:/sbin/mingetty ttyS0` 将修改后的根文件系统重新下载到系统中，系统启动时就会直接登录。不需要输入用户名及密码了。 ### 开机屏幕不显示log 在 **boot.scr** 中去掉tty0即可"},"/soft/Lichee/zh/Zero-Doc/application/USB_cam.html":{"title":"USB摄像头使用","content":" title: USB摄像头使用 ## 内核选项 插入USB摄像头，lsusb 可见：（摄像头PID:VID视你插入的USB摄像头型号而定） `Bus 001 Device 003: ID 1908:2311 GEMBIRD` 在dev下可见 **video0** 设备。 ## fswebcam fswebcam可以用来抓取摄像头图片。可以通过apt get直接安装。 `fswebcam d /dev/video0 no banner r 320x240 capture.jpg` 抓取一帧图片。 root@LicheePi:~# fswebcam help Usage: fswebcam [<options>] <filename> [[<options>] <filename> ] Options: ?, help Display this help page and exit. c, config <filename> Load configuration from file. q, quiet Hides all messages except for errors. v, verbose Displays extra messages while capturing version Displays the version and exits. l, loop <seconds> Run in loop mode. b, background Run in the background. o, output <filename> Output the log to a file. d, device <name> Sets the source to use. i, input <number/name> Selects the input to use. t, tuner <number> Selects the tuner to use. f, frequency <number> Selects the frequency use. p, palette <name> Selects the palette format to use. D, delay <number> Sets the pre capture delay time. (seconds) r, resolution <size> Sets the capture resolution. fps <framerate> Sets the capture frame rate. F, frames <number> Sets the number of frames to capture. S, skip <number> Sets the number of frames to skip. dumpframe <filename> Dump a raw frame to file. s, set <name> <value> Sets a control value. revert Restores original captured image. flip <direction> Flips the image. (h, v) crop <size>[,<offset>] Crop a part of the image. scale <size> Scales the image. rotate <angle> Rotates the image in right angles. deinterlace Reduces interlace artifacts. invert Inverts the images colours. greyscale Removes colour from the image. swapchannels <c1c2> Swap channels c1 and c2. no banner Hides the banner. top banner Puts the banner at the top. bottom banner Puts the banner at the bottom. (Default) banner colour <colour> Sets the banner colour. (#AARRGGBB) line colour <colour> Sets the banner line colour. text colour <colour> Sets the text colour. font <[name][:size]> Sets the font and/or size. no shadow Disables the text shadow. shadow Enables the text shadow. title <text> Sets the main title. (top left) no title Clears the main title. subtitle <text> Sets the sub title. (bottom left) no subtitle Clears the sub title. timestamp <format> Sets the timestamp format. (top right) no timestamp Clears the timestamp. gmt Use GMT instead of local timezone. info <text> Sets the info text. (bottom right) no info Clears the info text. underlay <PNG image> Sets the underlay image. no underlay Clears the underlay. overlay <PNG image> Sets the overlay image. no overlay Clears the overlay. jpeg <factor> Outputs a JPEG image. ( 1, 0 95) png <factor> Outputs a PNG image. ( 1, 0 10) save <filename> Save image to file. exec <command> Execute a command and wait for it to complete. ## mjpeg streamer 前置软件： ``` sudo apt get update sudo apt get install g++ libjpeg62 turbo dev imagemagick libv4l dev cmake git sudo git clone https://github.com/jacksonliam/mjpg streamer.git cd mjpg streamer/mjpg streamer experimental make all sudo make install ``` 设置环境变量 `export LD_LIBRARY_PATH $LD_LIBRARY_PATH:/usr/local/lib/mjpg streamer` 开启web服务器 `mjpg_streamer i \"input_uvc.so d /dev/video0 r 640x480\" o \"output_http.so p 8080 w /usr/local/share/mjpg streamer/www\"` 然后在同个局域网内的电脑的浏览器上访问 zero ip:8080即可看到图像。 ``` mjpg_streamer i \"input_uvc.so f 10 r 320*240 y\" o \"output_http.so c \"ruoyun:liufeng\" w www p 8888\" o \"output_file.so d 1000 f /mnt \" i 输入 \"input_uvc.so f 10 r 320*240 y\" input_uvc.so：UVC输入组件 f 10 ：表示10帧 r 320*240 ：分辨率 y ：YUV格式输入（有卡顿），不加表示MJPG输入（需要摄像头支持） o输出 \"output_http.so c \"ruoyun:liufeng\" w www p 8888\" output_http.so ：网页输出组件 c \"ruoyun:liufeng\" ：用户名：ruoyun 密码：liufeng w www : 网页输出 p 8888 ：端口 8888 \"output_file.so d 1000 f /mnt \" output_file.so ：图片输出组件 d 1000 ： 时间1S f /mnt ：输出图片放在哪，我是开机直接把/mnu挂载到本地文件夹了 ``` 总体帮助 ``` root@LicheePi:~# mjpg_streamer help Usage: mjpg_streamer i input \"<input plugin.so> [parameters]\" o output \"<output plugin.so> [parameters]\" [ h help ] ..: display this help [ v version ] ..: display version information [ b background] : fork to the background, daemon mode Example #1: To open an UVC webcam \"/dev/video1\" and stream it via HTTP: mjpg_streamer i \"input_uvc.so d /dev/video1\" o \"output_http.so\" Example #2: To open an UVC webcam and stream via HTTP port 8090: mjpg_streamer i \"input_uvc.so\" o \"output_http.so p 8090\" Example #3: To get help for a certain input plugin: mjpg_streamer i \"input_uvc.so help\" In case the modules ( plugins) can not be found: * Set the default search path for the modules with: export LD_LIBRARY_PATH /path/to/plugins, * or put the plugins into the \"/lib/\" or \"/usr/lib\" folder, * or instead of just providing the plugin file name, use a complete path and filename: mjpg_streamer i \"/path/to/modules/input_uvc.so\" ``` 输入插件帮助 ``` root@LicheePi:~# mjpg_streamer i \"input_uvc.so help\" MJPG Streamer Version.: 2.0 Help for input plugin..: UVC webcam grabber The following parameters can be passed to this plugin: [ d device ] .: video device to open (your camera) [ r resolution ] : the resolution of the video device, can be one of the following strings: QQVGA QCIF CGA QVGA CIF PAL VGA SVGA XGA HD SXGA UXGA FHD or a custom value like the following example: 640x480 [ f fps ] .: frames per second (activates YUYV format, disables MJPEG) [ q quality ] ..: set quality of JPEG encoding [ m minimum_size ].: drop frames smaller then this limit, useful if the webcam produces small sized garbage frames may happen under low light conditions [ e every_frame ]..: drop all frames except numbered [ n no_dynctrl ] : do not initalize dynctrls of Linux UVC driver [ l led ] .: switch the LED \"on\", \"off\", let it \"blink\" or leave it up to the driver using the value \"auto\" [ t tvnorm ] : set TV Norm pal, ntsc or secam [ u uyvy ] ..: Use UYVY format, default: MJPEG (uses more cpu power) [ y yuv ] ..: Use YUV format, default: MJPEG (uses more cpu power) [ fourcc ] : Use FOURCC codec 'argopt', currently supported codecs are: RGBP Optional parameters (may not be supported by all cameras): [ br ] ..: Set image brightness (auto or integer) [ co ] ..: Set image contrast (integer) [ sh ] ..: Set image sharpness (integer) [ sa ] ..: Set image saturation (integer) [ cb ] ..: Set color balance (auto or integer) [ wb ] ..: Set white balance (auto or integer) [ ex ] ..: Set exposure (auto, shutter priority, aperature priority, or integer) [ bk ] ..: Set backlight compensation (integer) [ rot ] .: Set image rotation (0 359) [ hf ] ..: Set horizontal flip (true/false) [ vf ] ..: Set vertical flip (true/false) [ pl ] ..: Set power line filter (disabled, 50hz, 60hz, auto) [ gain ] : Set gain (auto or integer) [ cagc ] : Set chroma gain control (auto or integer) input_init() return value signals to exit ``` 输出插件帮助 ``` root@LicheePi:~# mjpg_streamer o \"output_http.so help\" MJPG Streamer Version.: 2.0 Help for output plugin..: HTTP output plugin The following parameters can be passed to this plugin: [ w www ] ..: folder that contains webpages in flat hierarchy (no subfolders) [ p port ] .: TCP port for this HTTP server [ l ] listen ] ..: Listen on Hostname / IP [ c credentials ] : ask for \"username:password\" on connect [ n nocommands ] .: disable execution of commands output_init() return value signals to exit ```"},"/soft/Lichee/zh/Zero-Doc/application/QT_doc1.html":{"title":"移植tslib","content":" title: 移植tslib tslib是电阻式触摸屏用于校准的一个软件库，是一个开源的程序，能够为触摸屏驱动获得的采样提供诸如滤波、去抖、校准等功能，通常作为触摸屏驱动的适配层，为上层的应用提供了一个统一的接口。 所以这里先编译安装tslib，这样在后面编译Qt的时候才能打包编译进去。 ## 下载编译tslib sudo apt get install libtool automake autogen autoconf libsysfs dev git clone https://github.com/kergoth/tslib.git cd tslib echo \"ac_cv_func_malloc_0_nonnull yes\" > tmp.cache ./autogen.sh ./configure host arm linux gnueabihf cache file tmp.cache prefix /opt/tslib CC /opt/gcc linaro 6.3.1 2017.05 x86_64_arm linux gnueabihf/bin/arm linux gnueabihf gcc make sudo make install 完成后tslib就被安装到了/opt/tslib目录下 ## 参考资料 <http://blog.csdn.net/hpu11/article/details/53105947>"},"/soft/Lichee/zh/Zero-Doc/application/QT_doc5.html":{"title":"Qt5.x移植到Qt4.8","content":" title: Qt5.x移植到Qt4.8 在使用Qt5.x之后，发现Qt5.x还是比Qt4.8臃肿很多，所以在空间受限的设备上，还是建议使用Qt4.8. 这里记录Qt5.x的程序移植到Qt4.8上会遇到的一些问题。 ## QtSerialPort 移植 QtSerialPort是Qt5.3之后自带的，所以在Qt4.8上我们需要手工安装。 Qt串口模块5.5开始不再支持Qt4，所以建议用最后一个版本，\\*qtserialport opensource src 5.4.2\\* pro里加上CONFIG + serialport 在这里下载： <https://pan.baidu.com/s/1o6UVlk2> 解压，打开其中的工程 <http://pkgs.fedoraproject.org/repo/pkgs/udev/udev 182.tar.xz/d0a1ac9501d7c4ae68839d1b601592b8/udev 182.tar.xz> ``` sudo apt get install libblkid dev libkmod dev libgirepository1.0 dev ./configure prefix /opt/qt4.8.7 arm/ target arm linux gnueabihf host arm linux gnueabihf LD arm linux gnueabihf ld with pci ids path /var/share/pci.ids ``` ## 线程延时 QThread::msleep(100); 线程延时100ms改成： ``` QEventLoop eventloop; QTimer::singleShot(100, &eventloop, SLOT(quit())); eventloop.exec(); ``` ## 中文乱码 在最前面加上： ``` QTextCodec *codec QTextCodec::codecForName(\"UTF 8\"); QTextCodec::setCodecForTr(codec); QTextCodec::setCodecForLocale(codec); QTextCodec::setCodecForCStrings(codec); ``` ## C++11 /home/zepan/develop/Second/wifiscanthread.h:16: warning: non static data member initializers only available with std c++11 or std gnu++11 bool stopped false; ^~~~~ ## 无法打开显示设备 ``` root@LicheePi:~# ./Second4.8 QWSSocket::connectToLocalFile could not connect:: Connection refused QWSSocket::connectToLocalFile could not connect:: Connection refused ^C root@LicheePi:~#./Second4.8 qws QLock::QLock: Cannot create semaphore /tmp/qtembedded 0/QtEmbedded 0 'd' (38, Function not implemented) Cannot get display lock Aborted ``` 最近查看Qt源码才发现，Qt需要用到System V IPC进行进程间通信，而Android的进程间通信用的是谷歌自己的方式，所以Qt根本无法实现进程间的通信，自然无法正常启动。 重新配置内核，打开 System V IPC选项，问题解决。 ## 参考文章 <http://blog.csdn.net/yuyu414/article/details/42400721>"},"/soft/Lichee/zh/Zero-Doc/application/QT_doc7.html":{"title":"Qt移植总结","content":" title: Qt移植总结 ## PC端步骤 交叉编译好qt everywhere,内含关键的qmake qmake用于配置qtcreator ## 目标板步骤 1. 拷贝qt5.9.1 arm， sqlite3，tslib（内含ts_calibrate） 到/opt下 2. 拷贝字体到/opt/qt5.9.1 arm/lib/fonts下 3. 之前交叉编译qt的工具链里的/usr/lib/arm linux gnueabihf/lib/libstdc++.so.6.0.22 覆盖当前的so 4. 编辑/etc/bash.bashrc， 加入环境变量： ``` export TSLIB_CONSOLEDEVICE none export TSLIB_FBDEVICE /dev/fb0 export TSLIB_TSDEVICE /dev/input/event1 export TSLIB_CONFFILE /opt/tslib/etc/ts.conf export TSLIB_PLUGINDIR /opt/tslib/lib/ts export TSLIB_CALIBFILE /etc/pointercal export LD_LIBRARY_PATH /lib:/usr/lib:/opt/tslib/lib:/opt/qt5.9.1 arm/lib export PATH /bin:/sbin:/usr/bin/:/usr/sbin:/opt/tslib/bin export QT_QPA_PLATFORM_PLUGIN_PATH /opt/qt5.9.1 arm/plugins export QT_QPA_PLATFORM linuxfb:tty /dev/fb0 export QT_QPA_FONTDIR /opt/qt5.9.1 arm/lib/fonts export QT_QPA_GENERIC_PLUGINS tslib:$TSLIB_TSDEVICE ``` 5. 拷贝编译好的基于qt的应用程序到自定义目录下"},"/soft/Lichee/zh/Zero-Doc/application/QT_doc8.html":{"title":"Qt裁剪","content":" title: Qt裁剪 默认编译出来的Qt库是很大的，有几十M，甚至上百M。 为了将Qt库放入小容量的SPI flash中，我们需要去除不必要的库，裁剪必要的库。 ## 去除不必要的库 ### 裁剪feature ./src/corelib/global/qfeatures.h ./configure qconfig myfile ### 针对嵌入式版本的配置 Qt的嵌入式版本本身就支持feature裁剪，我们可以充分利用这一特性让Qt库尽量变小。具体的做法是要做一个自己的 **qconfig [myconfig].h** 特性文件，该文件中定义你要去掉Qt中的哪些feature。在configure的时候加“ ** qconfig myconfig** ” 选项， Qt就会根据你给出的配置文件来编译，以达到裁剪的目的。这里要强调一下，这种裁剪方式只适用于嵌入式版本。这里的myconfig可以用任何你喜欢的名字来代替。 在qt的代码中已经给出了一些qconfig头文件的例子，默认编译采用full config也就是 不裁剪任何feature。所有Qt预定义好的qconfig文件，可以在 **src/corelib/global/** 下找到，包括 *qconfig minimal.h, qconfig small.h, qconfig.medium.h,qconfig large.h和qconfig dist.h*，也就是从裁剪量由多到少都有据可依。如果要添加你自己的配置文件，要在 **src/corelib/global** 下建立一个形如qconfig xxx.h的文件，这个xxx也就是你要在configure的时候传入的qconfig参数。 笔者测试使用的Qt版本是4.4.1，这个版本的build system有个小毛病，就是如果你指定的qconfig参数实际上没有 **qconfig xxx.h** 文件对应， build不会停止，它只会给出一个不起眼的提示，编译过程会继续， 这一点挺让人费解的。而且这种情况下Qt编译使用的配置基本上和fullconfig相同，鉴于它的让人迷惑的举动，个人觉得有必要提醒大家一下，使用自定义qconfig的时候一定要确定配置文件放对了位置，而且qconfig参数给的正确。 一般我们的建议是在桌面上测试阶段编译一个full的版本，再根据你的项目使用Qt feature的情况总结哪些可去掉的feature。 feature之间有千丝万缕的依赖关系，这个问题也是困扰很多人的难点所在。具体的依赖可以查阅 **src/corelib/global/qfeatures.h** 和 **src/corelib/global/qfeatures.txt** （描述依赖关系的文档）。另外，Qt里还提供了一个可视化的配置依赖的工具，叫做qconfig，在 **QTDIR/tools/qconfig** 目录。该工具需要基于Qt桌面版本编译。 如在我的linux系统下可以用下面的命令来编译： ``` cd qt embedded linux commercial 4.4.1/tools/qconfig /usr/local/Trolltech/Qt 4.4.3/bin/qmake make ``` 编译成功后运行 `./qconfig`，初始要打开qfeatures.txt. Qconfig读取该文件生成一个树状图，该图很清楚的显示出feature之间的依赖关系。如下图所示，如果你去掉了LINEEDIT这个feature，用到该控件的combobox也就不能继续使用了。有了这个工具裁剪Qt变得简洁直观，方便了很多。 选定了你要去掉的feature后点击菜单 File > Save As.. 会弹出保存文件的页面，文件名字应该定义成 **qconfig xxx.h** 的形式，这样你在configure的时候就可以传入相应的qconfig参数了。 你还可以通过选择 File > Open 打开现有的 **qconfig xxx.h** 文件，通过修改已经有的文件更快的编辑配置。 根据笔者测试，未经裁剪的qte4.4.1编译出来为： libQtCore.so是2.6M libQtGui.so是9.5M 如果用small来编译，就能缩小为： libQtCore.so是2.0M libQtGui.so是5.7M 差异还是比较明显的。 ## 使用静态编译 在编译Qt库时使用 ** static** 选项 重新编译qtserial等库，并install 在pro里加上 `QT + core gui sql serialport` 程序改为release 实测减少有限"},"/soft/Lichee/zh/Zero-Doc/Contribution/article_3.html":{"title":"Lichee Pi zero SPI LCD使用指南","content":" title: Lichee Pi zero SPI LCD使用指南 在阅读本文之前，首先要保证你能够成功的编译linux内核，并构建一个完整的根文件系统。关于这部分的知识，之后还会单独写一个文档讨论。 其实lichee pizero使用的4.10内核已经包含了市面上常见的SPI液晶屏的驱动（fbtft），我们所要做的仅仅是在设备树中添加节点。说起fbtft，它之前独立于内核存在过一段时间，作为单独的代码文件发布，如果你需要它，可以手动把这部分文件复制到内核源码中\\<参考 [fbtft的 github仓库](https://github.com/notro/fbtft)\\>。后来被并入内核，具体是在哪一个版本的被并入内核的，这个也不必深究了。不过目前为止fbtft并未转正，依然存放在drivers/staging目录中。 ## 配置内核添加fbtft驱动 使用make menuconfig配置内核，加入ili9341驱动。fbtft还支持更多型号的SPI总线的液晶屏。关于支持列表这里就不一一列出，可以进入menuconfig中查看。 ``` Device Drivers > [*] Staging drivers > <*> Support for small TFT LCD display modules > <*> FB driver for the ILI9341 LCD Controller <*> Generic FB driver for TFT LCD displays ``` 编译内核： > `make j4` ## 修改设备树注册ili9341 lichee pi zero默认注册40Pin RGB液晶屏，并且在启动参数中设置console为tty0。为了尽可能减少改动，我们在设备树中删除了默认的40Pin液晶屏，这样新添加的ili9341也就顺利成章的成了唯一的太子，启动时的信息会通过他显示。 下面是使用git对比改动前后的细节： ``` diff git a/arch/arm/boot/dts/sun8i v3s licheepi zero.dts b/arch/arm/boot/dts/sun8i v3s licheepi zero.dts index 929a79e..9c91f75 100644 a/arch/arm/boot/dts/sun8i v3s licheepi zero.dts +++ b/arch/arm/boot/dts/sun8i v3s licheepi zero.dts @@ 90,3 +90,21 @@ usb0_id_det gpio <&pio 5 6 GPIO_ACTIVE_HIGH>; status \"okay\"; }; + +&spi0 { + status \"okay\"; + + ili9341@0 { + compatible \"ilitek,ili9341\"; + reg <0>; + + spi max frequency <15000000>; + rotate <270>; + bgr; + fps <10>; + buswidth <8>; + reset gpios <&pio 1 7 GPIO_ACTIVE_LOW>; + dc gpios <&pio 1 5 GPIO_ACTIVE_LOW>; + debug <0>; + }; +}; diff git a/arch/arm/boot/dts/sun8i v3s.dtsi b/arch/arm/boot/dts/sun8i v3s.dtsi index 50b8788..b0eb22e 100644 a/arch/arm/boot/dts/sun8i v3s.dtsi +++ b/arch/arm/boot/dts/sun8i v3s.dtsi @@ 54,15 +54,6 @@ #address cells <1>; #size cells <1>; ranges; simplefb_lcd: framebuffer@0 { compatible \"allwinner,simple framebuffer\", \"simple framebuffer\"; allwinner,pipeline \"de0 lcd0\"; clocks <&ccu CLK_BUS_TCON0>, <&ccu CLK_BUS_DE>, <&ccu CLK_DE>, <&ccu CLK_TCON0>; status \"disabled\"; }; ``` dc gpios \\<&pio 1 5 GPIO\\_ACTIVE\\_LOW\\>; 在设备树中，PA对应&pio 0, PB对应&pio 1， 以此类推。因此dc gpios实际表示的是PB5，也就是zero丝印上的PWM1。 reset gpios \\<&pio 1 7 GPIO\\_ACTIVE\\_LOW\\>; 如果我的屏幕的RESET引脚连接了高电平，或者接了一个RC回路作为上电复位的信号，那么这里的复位引脚是不是可以不指定呢？ 这样也是不可以的。因为在程序中，首先读取reset gpios，若reset gpios在设备树中不存在，那么直接忽略其余的信号。这样导致无法控制最关键的dc gpios引脚。因此至少在不更改程序的前提下，这条信号是一定要写上的。 ``` static int fbtft_request_gpios_dt(struct fbtft_par *par) { int i; int ret; if (!par >info >device >of_node) return EINVAL; ret fbtft_request_one_gpio(par, \"reset gpios\", 0, &par >gpio.reset); if (ret) return ret; ret fbtft_request_one_gpio(par, \"dc gpios\", 0, &par >gpio.dc); if (ret) return ret; ``` ## 更新SD卡中的程序 假设你之前已经创建好了一张可以正确启动的SD卡，那么你要做的很简单： > 将 **arch/arm/boot/zImage** 和 > **arch/arm/boot/dts/sun8i v3s licheepi zero.dtb** > 拷贝到SD卡中的vfat分区，覆盖之前的程序即可。 ## 硬件连接 ## 上电启动 linux内核启动时会加载fbtft驱动，注册framebuffer设备，打印如下信息： ``` [ 0.860671] fbtft_of_value: buswidth 8 [ 0.864653] fbtft_of_value: debug 0 [ 0.868325] fbtft_of_value: rotate 270 [ 0.872252] fbtft_of_value: fps 10 [ 1.244063] graphics fb0: fb_ili9341 frame buffer, 320x240, 150 KiB video memory, 16 KiB DMA buffer memory, fps 10, spi32766.0 at 15 MHz ``` 显示效果如下图： ![](./../static/Contribution/article_29.jpg)"},"/soft/Lichee/zh/Zero-Doc/Contribution/article_8.html":{"title":"Zero Spi Nor Flash启动系统制作指南","content":" title: Zero Spi Nor Flash启动系统制作指南 ## Uboot编译配置 首先规划flash分区，我测试用的flash大小为16M，型号为MX25L12873F，规划如下： ``` [第一分区1MB存放spl和uboot] 0x000000000000 0x000000100000 : \"uboot\" [第二分区64KB存放dtb文件] 0x000000100000 0x000000110000 : \"dtb\" [第三分区4MB存放内核] 0x000000110000 0x000000510000 : \"kernel\" [剩余空间存放根文件系统] 0x000000510000 0x000001000000 : \"rootfs\" ``` 由于目前Uboot环境变量固定存放在1MB位置之内，所有留给uboot的空间固定到flash前1MB的位置不变。每个分区的大小必须是擦除块大小的整数倍，MX25L12873F的擦除块大小是64KB。 ### 准备uboot 下载包含spi驱动的体验版本uboot，该驱动目前尚未合并到主线 `git clone b v3s spi experimental https://github.com/Lichee Pi/u boot.git` 执行 `make ARCH arm menuconfig` 打开uboot菜单配置，进入到 Device Drivers \\> SPI Flash Support 注意看一下自己flash的厂家名称，例如选上Macronix SPI flash support用来支持我测试用的 flash：MX25L12873F。 配置uboot默认环境变量，在文件 `include/configs/sun8i.h` 中添加默认bootcmd和bootargs的环境变量设置，注意添加的位置在 **“\\#include &#60;configs/sunxi common.h&#62;”** 的前边。 ![](./../static/Contribution/article_50.jpg) ``` #define CONFIG_BOOTCOMMAND \"sf probe 0; \" \\ \"sf read 0x41800000 0x100000 0x10000; \" \\ \"sf read 0x41000000 0x110000 0x400000; \" \\ \"bootz 0x41000000 0x41800000\" #define CONFIG_BOOTARGS \"console ttyS0,115200 earlyprintk panic 5 rootwait \" \\ \"mtdparts spi32766.0:1M(uboot)ro,64k(dtb)ro,4M(kernel)ro, (rootfs) root 31:03 rw rootfstype jffs2\" ``` 该环境变量通过在bootargs中增加mtdparts内核参数来告诉内核flash的分区设置信息，并通过 `root 31:03` 来告诉内核rootfs的位置。 ``` sf read 0x41800000 0x100000 0x10000; //从flash0x100000（1MB）位置读取dtb放到内存0x41800000偏移处。 sf read 0x41000000 0x110000 0x400000; //从flash0x110000（1MB+64KB）位置读取dtb放到内存0x41000000偏移处。 bootz 0x41000000 （内核地址） 0x41800000（dtb地址） 启动内核 ``` ### 编译uboot `make ARCH arm CROSS_COMPILE arm linux gnueabihf j4` ## linux内核编译配置 linux内核基于github上的版本 <https://github.com/Lichee Pi/linux.git> 执行 `make ARCH arm menuconfig` 打开内核菜单配置，进入到 Device Drivers \\> Memory Technology Device (MTD) support，确保选择上mtd的 \\<\\*\\> Command line partition table parsing 支持，该项目用来解析uboot传递过来的flash分区信息。 ![](./../static/Contribution/article_51.jpg) 修改dts配置添加spi flash节点 > `vi arch/arm/boot/dts/sun8i v3s licheepi zero.dts` 添加spi节点配置: ``` &spi0 { status \"okay\"; mx25l12805d:mx25l12805d@0 { compatible \"jedec,spi nor\"; reg <0x0>; spi max frequency <50000000>; #address cells <1>; #size cells <1>; }; }; ``` ![](./../static/Contribution/article_52.jpg) 添加对jffs2文件系统的支持，路径在 File systems \\> Miscellaneous filesystems \\> Journalling Flash File System v2 (JFFS2) support ![](./../static/Contribution/article_53.png) 退出菜单配置并编译内核和dts ``` make ARCH arm CROSS_COMPILE arm linux gnueabihf j4 make ARCH arm CROSS_COMPILE arm linux gnueabihf dtbs ``` ## 准备镜像文件 首先选择rootfs文件系统，我是用的是群朋提供的最小根文件系统rootfs brmin.tar.gz，大小只有3M左右，下载地址在 [https://pan.baidu.com/share/link?shareid 1432204556&uk 3658413294\\#list/path %2F](https://pan.baidu.com/share/link?shareid 1432204556&uk 3658413294#list/path %2F) > Lichee Zero\\>zero_imager.zip Flash支持jffs2文件系统格式，所以需要使用此该rootfs制作jffs2文件系统镜像; 下载jffs2文件系统制作工具 `apt get install mtd utils` 解压 rootfs brmin.tar.gz `tar xzvf rootfs brmin.tar.gz` 总空间是 **16M 1M 64K 4M 0xAF0000** `mkfs.jffs2 s 0x100 e 0x10000 p 0xAF0000 d rootfs/ o jffs2.img` 页大小 **0x100 256** 字节,块大小 **0x10000 64k** jffs2分区总空间 0xAF0000 jffs2.img是生成的文件系统镜像。 最后将uboot，dtb，kernel，rootfs打包成一个系统镜像，命令如下: ``` dd if /dev/zero of flashimg.bin bs 16M count 1 dd if ../ubootmainline/u boot/u boot sunxi with spl.bin of flashimg.bin bs 1K conv notrunc dd if ../zero41y/linux zero 4.10.y/arch/arm/boot/dts/sun8i v3s licheepi zero dock.dtb of flashimg.bin bs 1K seek 1024 conv notrunc dd if ../zero41y/linux zero 4.10.y/arch/arm/boot/zImage of flashimg.bin bs 1K seek 1088 conv notrunc dd if ../zero_imager/jffs2/jffs2.img of flashimg.bin bs 1K seek 5184 conv notrunc ``` 1. 生成一个空文件，大小是16MB 2. 将uboot添加到文件开头 3. 将dtb放到1M偏移处 4. 将kernel放到1M+64K偏移处 5. 将rootfs放到1M+64K+4M偏移处 > 偏移大小是seek，单位是KB。 执行完毕后生成镜像文件flashimg.bin ## 烧写镜像 下载sunxiflash烧写工具， `git clone b spi rebase https://github.com/Icenowy/sunxi tools.git` > 请选择spi rebase分支 进入工具目录执行　\\**make*\\* Zero有一个usb下载模式称为fel模式。zero的启动顺序是先sd卡然后spi flash。如果sd卡启动检测失败（没有sd卡或者sd卡中没有启动ubootspl），然后spiflash也启动检测失败（没有spiflash或者spiflash中没有启动ubootspl），那么会自动进入fel模式。 所以当你的spiflash还没有启动镜像的时候你拔掉sd上电会自动进入fel模式。 如果你的spiflash已经有了启动镜像，那么需要在sd卡中烧入一个sunxi提供的启动工具（ `dd if fel sdboot.sunxi of /dev/mmcblk0 bs 1024 seek 8` ），那么插入该sd卡启动会进入fel模式；还有另一种方法，擦除spiflash内容上点也会进入fel模式。 进入fel模式后使用usb数据线连接pc和zero,进入sunxi tool目录 > 执行 `sudo ./sunxi fel version` 会显示硬件版本信息。 > 执行 `sudo ./sunxi fel spiflash info` 会显示spi flash信息。 执行如下命令烧入我们前边制作好的镜像文件 `sudo ./sunxi fel p spiflash write 0 ../bootimg/flashimg.bin` ![](./../static/Contribution/article_54.jpg) 等待大概5分钟，烧写完成，如果没有意外重新上电zero那么就会进入linux系统了，账号是root没有密码。 ![](./../static/Contribution/article_55.jpg)"},"/soft/Lichee/zh/Zero-Doc/Contribution/article_7.html":{"title":"Qt5 移植到 licheepi zero","content":" title: Qt5 移植到 licheepi zero **环境** host:Ubuntu14.04 64 位 target:licheepi（全志 v3s） 文件系统： mindb 交叉编译链： gcc linaro 6.3.1 2017.02 x86\\_64\\_arm linux gnueabihf.tar.xz tslib 源代码： tslib 1.4.tar.gz tslib 安装目标路径： /usr/local/tslib1.4 QT 源代码： qt everywhere opensource src 5.4.1.tar.gz QT 安装目标路径： /usr/local/qt5.4.1 安装步骤： > 本文主要讲述 QT 的移植过程， tslib 的移植过程可以搜索《 tslib1.4 移植全过程》参考，如果不需要触摸屏，可以不用移植 tslib。 ## 准备工作 确保以下软件已安装， ``` sudo apt get install xorg dev libfontconfig1 dev \\ libfreetype6 dev libx11 dev libxcursor dev libxext dev \\ libxfixes dev libxft dev libxi dev libxrandr dev libxrender dev ``` ## 配置 1) 解压源代码 qt everywhere opensource src 5.4.1.tar.gz，并进入源代码文件夹 ``` tar xzf qt everywhere opensource src 5.4.1.tar.gz cd qt everywhere opensource src 5.4.1/ ``` 2) 指定所用平台的 arm 架构以及交叉编译器： `vi qtbase/mkspecs/linux arm gnueabi g++/qmake.conf` 改成以下内容，实际应需要根据自己的开发环境作出相应改变： ``` # # qmake configuration for building with arm linux gnueabi g++ # MAKEFILE_GENERATOR UNIX CONFIG + incremental QMAKE_INCREMENTAL_STYLE sublib QT_QPA_DEFAULT_PLATFORM linuxfb QMAKE_CFLAGS_RELEASE + O2 march armv7 a QMAKE_CXXFLAGS_RELEASE + O2 march armv7 a include(../common/linux.conf) include(../common/gcc base unix.conf) include(../common/g++ unix.conf) QMAKE_INCDIR + /usr/local/tslib/include QMAKE_LIBDIR + /usr/local/tslib/lib 执行modifications to g++.conf QMAKE_CC arm linux gnueabihf gcc lts QMAKE_CXX arm linux gnueabihf g++ lts QMAKE_LINK arm linux gnueabihf g++ lts QMAKE_LINK_SHLIB arm linux gnueabihf g++ lts 执行modifications to linux.conf QMAKE_AR arm linux gnueabihf ar cqs QMAKE_OBJCOPY arm linux gnueabihf objcopy QMAKE_NM arm linux gnueabihf nm P QMAKE_STRIP arm linux gnueabihf strip load(qt_config) ``` 3) 根据自己的实际需求配置 Qt（此处是使用 tslib 的编译）： ``` ./configure \\ prefix /usr/local/qt5.4.1 \\ confirm license \\ opensource \\ release \\ make libs \\ xplatform linux arm gnueabi g++ \\ optimized qmake \\ pch \\ qt sql sqlite \\ qt libjpeg \\ qt libpng \\ qt zlib \\ tslib \\ no opengl \\ no sse2 \\ no openssl \\ no nis \\ no cups \\ no glib \\ no dbus \\ no xcb \\ no xcursor no xfixes no xrandr no xrender \\ no separate debug info \\ make examples nomake tools nomake tests no iconv ``` ## 编译安装 `sudo make && make install` ## 移植 Qt 到 licheepi 开发板 完成上述步骤后， qt5.4.1 将被安装到 **/usr/local/qt5.4.1** 中。然后将/usr/local/中的 qt5.4.1 复制到开发板的 /opt/目录中，将/usr/local/中的 tslib 复制到开发板的/usr/local/中。 ## 设置开发板 Qt 环境变量： `vi /etc/bash.bashrc` 添加下面内容： ``` export TSLIB_CONSOLEDEVICE none export TSLIB_FBDEVICE /dev/fb0 export TSLIB_TSDEVICE /dev/input/event1 export TSLIB_CONFFILE /usr/local/tslib/etc/ts.conf export TSLIB_PLUGINDIR /usr/local/tslib/lib/ts export TSLIB_CALIBFILE /etc/pointercal export LD_LIBRARY_PATH /lib:/usr/lib:/usr/local/tslib/lib:/opt/qt5.4.1/lib export PATH /bin:/sbin:/usr/bin/:/usr/sbin:/usr/local/tslib/bin export QT_QPA_PLATFORM_PLUGIN_PATH /opt/qt5.4.1/plugins export QT_QPA_PLATFORM linuxfb:tty /dev/fb0 export QT_QPA_FONTDIR /opt/qt5.4.1/lib/fonts export QT_QPA_GENERIC_PLUGINS tslib:$TSLIB_TSDEVICE ``` 保存退出后使上面的环境变量生效： `source /etc/bash.bashrc` ## 运行一些 example： ``` /opt/qt5.4.1/examples/touch/pinchzoom/pinchzoom /opt/qt5.4.1/examples/svg/embedded/fluidlauncher/fluidlauncher ``` 我们可以看到用 linuxfb 方式的运行的 QT 是没有窗体边框的，这是 qt5 的一个特点，似乎是其为了更好的转移到手机等移动终端。 测试程序时候可能会提示某些库文件不存在，可以拷贝 ubuntu主机中的交叉编译器下相应的库文件到 licheepi 开发板，然后添加环境变量是之生效。 不知道的话就都拷过去吧。"},"/soft/Lichee/zh/Zero-Doc/Contribution/article_12.html":{"title":"TF WIFI 小白编","content":" title: TF WIFI 小白编 > 荔枝派Zero开发板TF WiFi模块 ## 旧版的首先要把这电阻去了 ![](./../static/Contribution/article_56.png) ## 焊接 1. 要把wifi模块与zero正确连接(我用的是焊接于底部) 2. 堆叠焊接于底部 3. 堆叠焊于底部，可使散热情况优于前者，但需要注意两点: 4. 下图红圈处需要剪断，否则无法插屏幕 5. 天线要弯过来，或者重新焊接到背面。 ![](./../static/Contribution/article_57.png) ## 下载驱动 从网盘里下载r8723bs.ko驱动 网盘资料：链接: <https://pan.baidu.com/s/1nv7Fq2X> \\>\\>\\> （建议在下载完后改名字，因为，这个名字里面有空格,因为空格有转义符,很容易搞错，打TAB比较方便，但是在写自启脚本时TAB却是空格，所以，，，你懂的(・∀・)）注:名字一定要以.ko结尾 ## WiFi使用方法 ### 加载驱动并启用WiFi 在命令行里执行 ``` insmod r8723bs.ko sudo ifconfig wlan0 up ``` ### 启动好之后把联网脚本设为可执行文件 `chmod 777 connect_wx.sh` ### 输入下面命令编辑无线配置文件 `vi /etc/wpa_supplicant.conf` 然后将里面的下面部分删除 ``` network { } ``` 然后保存修改，接着输入如下命令生成新的无线网络配置文件 `wpa_passphrase 无线网络名称 无线密码 >> /etc/wpa_supplicant.conf` 然后就成了，接着输入 `./connect_wx.sh` 看看是否成功连网，和ip地址 ## 成功加载驱动却没有wlan0 在命令行里执行 ``` mount /dev/mmcblk0p1 /mnt/ cat /mnt/boot.scr ``` 然后就会看到这个 ``` 'V·z?Xցܣ]Mڳetenv bootargs console ttyS0,115200 panic 5 console tty0 rootwait root /dev/mmcblk0p2 earlyprintk rw load mmc 0:1 0x41000000 zImage load mmc 0:1 0x41800000 sun8i v3s licheepi zero ctc.dtb < 这里使用了错误的dtb bootz 0x41000000 0x4180000 ``` 从网盘中获取正确的dtb来覆盖，具有wifi功能的dtb是 `sun8i v3s licheepi zero dock.dtb` （在网盘的zero\\_imager里面） 或者不用改。。把系统卡在电脑上读，在电脑里面改也行 zero\\_imager 里面有正确的boot.scr直接在电脑里面换上去就行了再把 `sun8i v3s licheepi zero dock.dtb` 复制到root目录 ![](./../static/Contribution/article_58.png) ## 开机自动连网 首先写一个shell脚本来加载驱动,启动wlan0，运行连网脚本，放在任意目录都可以，输入命令： `vi wifi.sh` 然后按a进入插入模式,输入: ``` #!/bin/sh insmod /root(你放WiFi驱动的路径)/wifi.ko(WiFi驱动的名字) ifconfig wlan0 up /root/connect_wx.sh ``` 写好后按下esc，再输入： `wq` 保存数据后输入: `chmod 777 wifi.sh` 然后添加开机启动脚本 `vi /etc/rc.local` 会显示这个 ![](./../static/Contribution/article_59.png) 然后把你的wifi自启脚本以绝对路径形式输入 `exit 0` 上面的一行中，如果路径太长,一行写不完，就在这一行的最后面输入然后按下enter键"},"/soft/Lichee/zh/Zero-Doc/Contribution/article_1.html":{"title":"荔枝派zero开箱指南","content":" title: 荔枝派zero开箱指南 ## Zero各部分简介 ### 正面： ![](./../static/Contribution/article_1.jpg) 1. 主控v3s芯片，Allwinner V3s (ARM Cortex A7 CPU, 1.2GHz, 512Mbit DDR2 integrated) 2. tf卡插槽，tf卡金手指朝下插入。 3. micro usb口,可以用来给板子供电，也可以通过micro usb otg转接线转成标准usb大口然后连接各种usb外设，比如usb无线网卡。也可以接一个usb hub方便插多个usb设备。 4. 一个RGB灯。 5. 板子3.3V输出，注意方形焊盘是正。 6. 板子5V供电输入，也可以接3.7v锂电池给板子供电，注意方形焊盘是正。 7. UART0扩展接口，主要用来通过串口工具连接PC调试使用。 8. 上边两排分别有两排2.54排针焊接孔和两排1.27排针焊接孔（是邮票半孔），方便扩展，一般扩展只需焊接上下两排2.54排针即可。 ### 反面： ![](./../static/Contribution/article_2.jpg) 1. 40P 通用RGB屏幕接口 2. spi flash焊盘，默认没有焊接。 ### 焊接好排针： ![](./../static/Contribution/article_3.jpg) ## 启动方式介绍 最常用的启动方式是sd卡启动，网盘有可以直接使用的linux系统镜像，直接烧入sd卡后便可以启动并使用linux系统。也支持其他启动方式spi flash、网络启动、usb下载启动等。 ## 系统镜像组成部分介绍 SD卡中的系统镜像一般分为三个区，第一个区称为boot区或者引导区，该部分没有文件系统而是直接将二进制的bootloader(uboot)文件直接写入。第二个区可以被称为linux内核区，fat文件系统，存放linux内核、内核参数文件还有设备数dtb文件。第三个区是root分区，用来存放根文件系统和用户数据等，一般是ext4文件分区格式。 <! 系统镜像下载地址链接: <https://pan.baidu.com/s/1nv7Fq2X> 密码: 5gec > ## 镜像烧录及简单演示 ### 在tf卡上创建分区文件系统 首先需要一台linux操作系统的电脑或者在vmware虚拟机上安装linux系统，推荐ubuntu14 64位版本，ubuntu系统默认安装即可。 我使用的是vmware虚拟机的形式，在vmware上安装完毕ubuntu后推荐安装vmware tools工具，安装这个工具后可以在windows和ubuntu桌面之间直接无缝复制粘贴文件。 下面制作tf卡启动系统，需要一张大于8g的tf卡和一个读卡器，将tf卡插入读卡器并插入电脑。如果是虚拟机请检查下虚拟机右下角这个图标的状态，如下图 ![](./../static/Contribution/article_4.jpg) 如果是这种灰色的表示读卡器的操作权在windows系统，需要点击一个这个图标，选择链接（断开与主机连接），这样读卡器的控制器才能到虚拟机linux系统中。 ![](./../static/Contribution/article_5.jpg) 在桌面环境搜索gparted分区编辑器并打开。 ![](./../static/Contribution/article_6.jpg) 输入超级用户密码 ![](./../static/Contribution/article_7.jpg) 在右上角中选择tf卡对应的设备 ![](./../static/Contribution/article_8.jpg) 依次选中tf卡上已经存在的分区，右键【删除】来删除分区 ![](./../static/Contribution/article_56.jpg) 如果只有【卸载】选择，那么需要先点击卸载，然后再删除分区。 ![](./../static/Contribution/article_57.jpg) 所有分区删除完毕后，点击右上角对勾，将操作应用到磁盘。 ![](./../static/Contribution/article_58.jpg) 点击左上角加号创建新分区，之前剩余空间输入2MB(主要用来存放uboot)，新大小输入20，文件系选择fat16，点击添加。 ![](./../static/Contribution/article_59.jpg) 再次点击左上角加号创建新分区，这次使用所有的默认参数如下图所示，分区大小将使用tf卡剩余的所有空间，文件系统是ext4. ![](./../static/Contribution/article_9.jpg) 点击对勾，应用创建分区到tf卡。 ![](./../static/Contribution/article_10.jpg) 打开linux终端，输入命令sudo fdisk –l 可以看到刚才我们创建的两个分区。 ![](./../static/Contribution/article_11.jpg) /dev/sdb即代表tf卡，/dev/sdb1代表的是tf的第一个分区，/dev/sdb2代表的是tf的第二个分区 ### 烧写镜像： 从百度网盘镜像及SDK：链接: <https://pan.baidu.com/s/1nv7Fq2X> 密码: 5gec 下载镜像文件，zero_imager.zip包含内核启动文件、内核镜像和烧写脚本。rootfs xxxx.tar.gz是根文件系统，根据不同的需求打包制作出了多个根文件系统 rootfs brmin.tar.gz是最精简的根文件系统只有1.5M\\ rootfs brpy.tar.gz 在brmin基础上包含python环境\\ rootfs minmin.tar.gz debian(包含 apt, network)\\ rootfs mindb.tar.gz debian(包含apt, network, gcc, python )\\ rootfs minX.tar.gz debian(包含桌面系统) 将zero_imager.zip解压到某个目录下，并将需要的根文件系统放到这个目录下，本例以rootfs minX.tar.gz为例子。打开终端，执行如下命令 ``` unzip zero_imager.zip（解压） cp rootfs minX.tar.gz zero_imager/（将rootfs minX.tar.gz复制到zero_imager目录） cd zero_imager/（切换当前路径到zero_imager） ``` 第一步，将uboot写入到sd卡8k偏移处。 ``` sudo dd if u boot sunxi with spl_480800.bin of /dev/sdb bs 1024 seek 8 ``` ![](./../static/Contribution/article_12.jpg) 第二步，将内核文件，启动参数文件，dtb写入到tf卡的第一分区。 ``` sudo mount /dev/sdb1 mnt/ sudo cp zImage mnt/ sudo cp sun8i v3s licheepi zero*.dtb mnt/ sudo cp boot.scr mnt/ sync sudo umount /dev/sdb1 ``` ![](./../static/Contribution/article_13.jpg) 第三步，将根文件系统内容写入到tf卡的第二分区。 ``` sudo mount /dev/sdb2 mnt/ sudo rm rf mnt/* sudo tar xzvf rootfs minX.tar.gz C mnt/ sudo cp r overlay_rootfs base/* mnt/ sudo cp r overlay_rootfs minX/* mnt/ sudo dd if /dev/zero of mnt/swap bs 1M count 128 sudo mkswap mnt/swap sudo echo \"/swap swap swap defaults 0 0\" >> mnt/etc/fstab sync sudo umount /dev/sdb2 ``` ### 启动系统： 使用串口工具连接LicheePiZero,注意rx接tx，tx接rx，插入电脑，打开串口工具，我使用的是PuTTY\\_0.67.0.0.exe。有屏幕的插入屏幕。 ![](./../static/Contribution/article_14.jpg) ![](./../static/Contribution/article_15.jpg) ![](./../static/Contribution/article_16.jpg) 输入账号root密码licheepi，登陆到系统。"},"/soft/Lichee/zh/Zero-Doc/Contribution/article_9.html":{"title":"Visio-uboot-sunxi流程","content":" title: 'Visio uboot sunxi流程' > **attention** > > 暂待修复"},"/soft/Lichee/zh/Zero-Doc/Contribution/todolist.html":{"title":"荔枝派TODO任务领取","content":" title: 荔枝派TODO任务领取 前言 本文档详细介绍荔枝派Zero的使用，将由群主设计目录框架，群友众包完成。 完成每篇文档的群友均可获得Zero一片，有难度的文档会酌情提高回报。 需要什么教程的朋友可以在这里留言，我将添加到TODO List里。 本文不定期更新开发者任务，有荔枝派相关的，也有其他小项目的，有兴趣的朋友可以在其下留言或者直接小窗联系群主QQ：\\*715805855\\*, 或者邮箱 <*zepanwucai@gmail.com>\\* 领取任务。 tips 普通简单任务请在一周内完成，困难任务酌情放宽时间。 tips 每个任务同时可由多人认领，由最先完成者获取回报。也可组队认领，回报由队内协商分配 LicheePi Zero TODO List 其它项目 快餐式外包 "},"/soft/Lichee/zh/Zero-Doc/Contribution/contents.html":{"title":"投稿文章精选","content":" title: 投稿文章精选 感谢各位的辛勤付出与技术分享，现将各篇优秀技术文章集合如下："},"/soft/Lichee/zh/Zero-Doc/Contribution/build_doc.html":{"title":"文档构建","content":" title: 文档构建 前言 本文档选择使用Sphinx来进行构建，支持以 reStructuredText 和 Markdown 格式编写 本地构建 1. 拉取文档 打开终端，运行以下命令: > `git clone https://github.com/Lichee Pi/lichee pi zero.git` 2. 安装依赖 首先我们需要通过pip安装Sphinx > `pip install Sphinx` > > 若您没有安装pip，请参照 [pip > 安装](http://pip.readthedocs.io/en/stable/installing/) 接着安装本文档的模块依赖 > `pip install sphinx_rtd_theme` 用于支持文档主题 > > `pip install recommonmark` 用于支持Markdown文本格式 3. 构建 ~~~~ {.sourceCode .bash} cd Lichee Zero Doc zh CN # windows .\\make.bat html # linux make html ~~~~ 构建完成，进入 build \\> html \\> index.html 打开以浏览器浏览即可。 技术文档贡献 若您有意向贡献您的实践经验，请参照 [todolist](todolist.html) 以reStructuredText编写文档 .rst 文件是轻量级标记语言的一种，被设计为容易阅读和编写的纯文本，并且可以借助Docutils这样的程序进行文档处理，也可以转换为HTML或PDF等多种格式，或由Sphinx Doc这样的程序转换为LaTex、man等更多格式。 在本文档中， *.rst* 文件配合sphinx工具以及readthedoc主题，具有较为丰富的文本表现。 此外，与Markdown对比来看： > 1. RST更适合于构建完整较大的文档，Markdown更适用于构建单页应用 > 2. RST格式更为丰富，Markdown更为简洁 > 3. RST格式要求稍高于Markdown reStructuredText语法请参考 [quick reStructuredText](http://docutils.sourceforge.net/docs/user/rst/quickref.html#doctest blocks) 个人建议您也可以通过查看 [Read the Docs主题示例](https://sphinx rtd theme.readthedocs.io/en/latest/demo/demo.html#id27) ，配合其 [github](https://github.com/rtfd/sphinx_rtd_theme/edit/master/docs/demo/demo.rst) 的编辑源码模式，可更直观地进行对照、借鉴。 另： RST的表格对于中文支持不好，个人推荐借助 [pytablewriter](http://pytablewriter.rtfd.io) 来生成中文表格 ~~~~ {.sourceCode .python} # coding: utf 8 import pytablewriter writer pytablewriter.RstGridTableWriter() writer.table_name \"example_table\" writer.header_list ['水果', '价格', '数量'] writer.value_matrix [ ['香蕉', '1', '5'], ['苹果', '1', '6'], ['草莓', '1', '7'], ] writer.write_table() ~~~~ > **渲染为：** ~~~~ {.sourceCode .rst :caption: 转换结果： :linenos:} .. table:: + + + + 水果价格数量 + + + + 香蕉 1 5 + + + + 苹果 1 6 + + + + 草莓 1 7 + + + + ~~~~ 以Markdown编写文档 Markdown语句较为简明，互联网上也有大量的辅助工具与教程； 个人推荐您使用 vscode配合插件Markdown All in One，或使用 [typora](https://www.typora.io/) ，笔者使用体验较为舒适 > **一点小提醒** > > 若您单纯使用Markdown书写，无需注意以下所有内容； > > 若您 **想用Markdown而不涉及rst及其语法** 构建您的 **个人文档** > 时，建议您使用 [Mkdocs](http://www.mkdocs.org/) 替代sphinx，参阅 > [readthedocs build > process](http://docs.readthedocs.io/en/latest/builds.html#mkdocs) ； > > 若您将Markdown文件加入sphinx的构建行列，请注意以下两条： > > 要使用sphinx所提供的特性时，如： > > > > **tip** > > > > > > 15% if the service is good. > > > > > **error** > > > > > > Does not compute. > > > > 请将其标为代码片段，代码类型为： > > **eval\\_rst**，sphinx将会将此片段作为rst文本进行解析： > > > > ~~~~ {.sourceCode .markdown} > > ```eval_rst > > > > .. Tip:: 15% if the service is good. > > > > .. Error:: Does not compute. > > > > ``` > > ~~~~ > > sphinx对Markdown的表格支持不够完全，请使用上一条所用方法，以rst语法来绘制表格"},"/soft/Lichee/zh/Zero-Doc/Contribution/article_10.html":{"title":"lichee 编译踩坑记录(ilichee ZERO)","content":" title: 'lichee 编译踩坑记录(ilichee ZERO)' ## 编译环境 编译的时候原来是正常编译过linux内核的，不过buildroot和里面带的程序还需要其他的一些软件包 需要安装的包 `bison flex texinfo zlib1g dev gawk` 填坑方案 `sudo apt get install [包名称]` ## buildroot源码 由于各种各样的原因buildroot里到处是坑 有的源码可能对新编译器不适应，需要修改 修改时有两个位置，如果还没有进行编译可以在 `/buildroot/pakage/[包名称]/` 里找到对应文件/文件夹 编译时使用的是将上面的源码复制到 `/out/linux/common/buildroot/build/[包名称]` 或 `/out/linux/common/buildroot/build/host [包名称]` 下，所以如果编译的过程中出错除了改buildroot里的源码也需要改后面那两个(如果有)文件夹下的源码 ### host m4 1.4.15 buildroot过程中 ``` ./stdio.h:456:1:error: 'gets' undeclared here (not in a function) _GL_WARN_ON_USE(gets, \"gets is a security hole use fgets instead\"); ``` 填坑方法：参考链接：<http://www.civilnet.cn/talk/browse.php?topicno 78555> 找到： `host m4 1.4.15/lib/stdio.h` ，然后对stdio.h文件做出如下改动，必要时连同 `stdio.in.h` 一起修改： ``` modified file 'host m4 1.4.15/lib/stdio.h' @@ 140,8 +140,10 @@ +#if defined gets #undef gets _GL_WARN_ON_USE (gets, \"gets is a security hole use fgets instead\"); +#endif ``` 修改后测试通过 ### host autoconf 2.65 buildroot过程中 `conftest.c:14625:must be after @defmac' to use@defmacx'` 填坑方法：参考链接：<http://gnu autoconf.7623.n7.nabble.com/compile error conftest c 14625 must be after defmac to use defmacx td18843.html> 找到 `autoconf 2.65/doc/autoconf.texi` ,进行修改 ``` @@ 15,7 +15,7 @@ @c The ARG is an optional argument. To be used for macro arguments in @c their documentation (@defmac). @macro ovar{varname} @r{[}@var{\\varname}@r{]}@c +@r{[}@var{\\varname}@r{]} @end macro @c @dvar(ARG, DEFAULT) @@ 23,7 +23,7 @@ @c The ARG is an optional argument, defaulting to DEFAULT. To be used @c for macro arguments in their documentation (@defmac). @macro dvar{varname, default} @r{[}@var{\\varname} @samp{\\default}@r{]}@c +@r{[}@var{\\varname} @samp{\\default}@r{]} @end macro @c Handling the indexes with Texinfo yields several different problems. ``` 修改后测试通过 ### host makedevs buildroot过程中 ``` /lichee/out/linux/common/buildroot/build/host makedevs/makedevs.c:374:6: error: variable ‘ret’ set but not used [ Werror unused but set variable] int ret EXIT_SUCCESS; ^ cc1: all warnings being treated as errors ``` 找到 `/makedevs/makedevs.c` 或 `/host makedevs/makedevs.c` 进行修改 最后一行， `return 0`; 修改为： `return ret`; 这也算(╯‵□′)╯︵┻━┻) ## lichee缺rootfs.cpio.gz buildroot后 无法定位 **\"rootfs.cpio.gz\"** 泽畔大大说可以自己包一个 我从H3的SDK里扒了一个出来 目前为止没有出错放到linux内核目录下 ## awk: line 2: function strtonum never defined awk版本问题，需要安装gawk `sudo apt get install gawk` ## pack finish但无镜像输出 出现 `Dragon execute image.cfg failed` lichee默认的对象是编译到nor flash上，但是没找到nor flash的配置文件o(╯□╰)o 修改\\**/lichee/tools/pack/pack*\\* ``` 354： update_mbr sys_partition_nor.bin 1 > /dev/null 355： dragon image.cfg sys_partition_nor.fex 354： +update_mbr sys_partition.bin 1 > /dev/null 355： +dragon image.cfg sys_partition.fex ``` 用默认的配置文件 似乎是针对nand的 ``` sudo ./build.sh sudo ./build.sh pack ``` 终于成功〒▽〒"},"/soft/Lichee/zh/Zero-Doc/Contribution/article_11.html":{"title":"lichee\\_zero\\_外设GPIO接口","content":" title: 'lichee\\_zero\\_外设GPIO接口' > **attention** > > 暂待修复"},"/soft/Lichee/zh/Zero-Doc/Contribution/article_6.html":{"title":"Licheepi Zero Ethernet适配指南","content":" title: Licheepi Zero Ethernet适配指南 ## U Boot适配Ethernet U Boot 2017已经支持了sun8i emac的驱动，只需要在编译时选上并且修改dts就行。 进入u boot源码目录： ``` $ make LicheePi_Zero_defconfig $ make menuconfig ``` ![](./../static/Contribution/article_39.png) 选择 **Device Drivers \\>** ![](./../static/Contribution/article_40.png) 选择 **Network device support \\>** 并选中 **Allwinner Sun8i Ethernet MAC support** ![](./../static/Contribution/article_41.png) 修改dts ``` diff git a/arch/arm/dts/sun8i v3s licheepi zero.dts b/arch/arm/dts/sun8i v3s licheepi zero.dts index 3d9168c..b8b9fc3 100644 a/arch/arm/dts/sun8i v3s licheepi zero.dts +++ b/arch/arm/dts/sun8i v3s licheepi zero.dts @@ 49,6 +49,7 @@ compatible \"licheepi,licheepi zero\", \"allwinner,sun8i v3s\"; aliases { + ethernet0 &emac; serial0 &uart0; }; @@ 81,3 +82,14 @@ usb0_id_det gpio <&pio 5 6 GPIO_ACTIVE_HIGH>; status \"okay\"; }; + +&emac { + phy <&phy0>; + phy mode \"mii\"; + allwinner,use internal phy; + allwinner,leds active low; + status \"okay\"; + phy0: ethernet phy@0 { + reg <1>; + }; +}; ``` ``` diff git a/arch/arm/dts/sun8i v3s.dtsi b/arch/arm/dts/sun8i v3s.dtsi index ebefc0f..cb81dd5 100644 a/arch/arm/dts/sun8i v3s.dtsi +++ b/arch/arm/dts/sun8i v3s.dtsi @@ 96,6 +96,11 @@ #size cells <1>; ranges; + syscon: syscon@01c00000 { + compatible \"allwinner,sun8i h3 syscon\",\"syscon\"; + reg <0x01c00000 0x34>; + }; + mmc0: mmc@01c0f000 { compatible \"allwinner,sun7i a20 mmc\"; reg <0x01c0f000 0x1000>; @@ 208,6 +213,17 @@ interrupt controller; #interrupt cells <3>; + emac_rgmii_pins: emac0@0 { + allwinner,pins \"PD0\", \"PD1\", \"PD2\", \"PD3\", + \"PD4\", \"PD5\", \"PD7\", + \"PD8\", \"PD9\", \"PD10\", + \"PD12\", \"PD13\", \"PD15\", + \"PD16\", \"PD17\"; + allwinner,function \"emac\"; + allwinner,drive <SUN4I_PINCTRL_40_MA>; + allwinner,pull <SUN4I_PINCTRL_NO_PULL>; + }; + uart0_pins_a: uart0@0 { pins \"PB8\", \"PB9\"; function \"uart0\"; @@ 270,6 +286,20 @@ status \"disabled\"; }; + emac: ethernet@1c30000 { + compatible \"allwinner,sun8i h3 emac\"; + reg <0x01c30000 0x104>, <0x01c00030 0x4>; + reg names \"emac\", \"syscon\"; + interrupts <GIC_SPI 82 IRQ_TYPE_LEVEL_HIGH>; + resets <&ccu RST_BUS_EMAC>, <&ccu RST_BUS_EPHY>; + reset names \"ahb\", \"ephy\"; + clocks <&ccu CLK_BUS_EMAC>, <&ccu CLK_BUS_EPHY>; + clock names \"ahb\", \"ephy\"; + #address cells <1>; + #size cells <0>; + status \"disabled\"; + }; + gic: interrupt controller@01c81000 { compatible \"arm,cortex a7 gic\", \"arm,cortex a15 gic\"; reg <0x01c81000 0x1000>, ``` 编译： > `$ make ARCH arm CROSS_COMPILE arm linux gnueabihf ` 烧写： > `$ dd if u boot sunxi with spl.bin of ${card} bs 1024 seek 8` 使用Ethernet： ![](./../static/Contribution/article_42.png) ## Kernel适配Ethernet 目前Linux 4.12还没又对sun8i emac进行支持，所以Kernel要使用V3s的以太网要打sun8i emac的补丁还有修改dts文件。 打上sun8i emac补丁： 拉下我已经适配好的内核源码：https://github.com/techping/linux/tree/licheepi zero 修改dts(上面git仓库是已经修改完的)： ``` index 387fc2a..904e60e 100644 a/arch/arm/boot/dts/sun8i v3s licheepi zero.dts +++ b/arch/arm/boot/dts/sun8i v3s licheepi zero.dts @@ 50,6 +50,7 @@ aliases { serial0 &uart0; + ethernet0 &emac; }; chosen { @@ 101,3 +102,10 @@ usb0_id_det gpio <&pio 5 6 GPIO_ACTIVE_HIGH>; status \"okay\"; }; + +&emac { + phy handle <&int_mii_phy>; + phy mode \"mii\"; + allwinner,leds active low; + status \"okay\"; +}; ``` ``` diff git a/arch/arm/boot/dts/sun8i v3s.dtsi b/arch/arm/boot/dts/sun8i v3s.dtsi index 7107596..65be2ab 100644 a/arch/arm/boot/dts/sun8i v3s.dtsi +++ b/arch/arm/boot/dts/sun8i v3s.dtsi @@ 40,7 +40,10 @@ * OTHER DEALINGS IN THE SOFTWARE. */ +#include <dt bindings/clock/sun8i v3s ccu.h> +#include <dt bindings/reset/sun8i v3s ccu.h> #include <dt bindings/interrupt controller/arm gic.h> +#include <dt bindings/pinctrl/sun4i a10.h> / { #address cells <1>; @@ 93,6 +96,12 @@ #size cells <1>; ranges; + syscon: syscon@1c00000 { + compatible \"allwinner,sun8i h3 system controller\", + \"syscon\"; + reg <0x01c00000 0x1000>; + }; + mmc0: mmc@01c0f000 { compatible \"allwinner,sun7i a20 mmc\"; reg <0x01c0f000 0x1000>; @@ 205,6 +214,17 @@ interrupt controller; #interrupt cells <3>; + emac_rgmii_pins: emac0@0 { + allwinner,pins \"PD0\", \"PD1\", \"PD2\", \"PD3\", + \"PD4\", \"PD5\", \"PD7\", + \"PD8\", \"PD9\", \"PD10\", + \"PD12\", \"PD13\", \"PD15\", + \"PD16\", \"PD17\"; + allwinner,function \"emac\"; + allwinner,drive <SUN4I_PINCTRL_40_MA>; + allwinner,pull <SUN4I_PINCTRL_NO_PULL>; + }; + i2c0_pins: i2c0 { pins \"PB6\", \"PB7\"; function \"i2c0\"; @@ 295,6 +315,31 @@ #size cells <0>; }; + emac: ethernet@1c30000 { + compatible \"allwinner,sun8i h3 emac\"; + syscon <&syscon>; + reg <0x01c30000 0x104>; + interrupts <GIC_SPI 82 IRQ_TYPE_LEVEL_HIGH>; + interrupt names \"macirq\"; + resets <&ccu RST_BUS_EMAC>; + reset names \"stmmaceth\"; + clocks <&ccu CLK_BUS_EMAC>; + clock names \"stmmaceth\"; + #address cells <1>; + #size cells <0>; + status \"disabled\"; + + mdio: mdio { + #address cells <1>; + #size cells <0>; + int_mii_phy: ethernet phy@0 { + compatible \"ethernet phy ieee802.3 c22\"; + reg <1>; + clocks <&ccu CLK_BUS_EPHY>; + resets <&ccu RST_BUS_EPHY>; + }; + }; + }; gic: interrupt controller@01c81000 { compatible \"arm,cortex a7 gic\", \"arm,cortex a15 gic\"; reg <0x01c81000 0x1000>, ``` 进入内核目录： ``` $ make sunxi_defconfig ARCH arm $ make menuconfig ARCH arm ``` ![](./../static/Contribution/article_43.png) 选择 **Device Drivers \\>** ![](./../static/Contribution/article_44.png) 选择 **Network device support \\>** ![](./../static/Contribution/article_45.png) 选择 **Ethernet driver support \\>** ![](./../static/Contribution/article_46.png) 选中 **Allwinner sun8i EMAC support** 和 **Use dwmac sun8i bindings** ![](./../static/Contribution/article_47.png) 编译 `$ make ARCH arm CROSS_COMPILE arm linux gnueabihf ` 得到 zImage 和 sun8i v3s licheepi zero.dtb 烧写 将内核、dtb、rootfs刷入sd卡中，启动： `$ ifup eth0` ![](./../static/Contribution/article_48.png) eth0启动成功！ ![](./../static/Contribution/article_49.png) **Ethernet驱动适配成功！**"},"/soft/Lichee/zh/Zero-Doc/Contribution/article_4.html":{"title":"Zero u-boot编译和使用指南","content":" title: Zero u boot编译和使用指南 ## Uboot的基本结构 下面来看看该uboot中的目录结构 ``` ├── api 存放uboot提供的API接口函数 ├── arch 平台相关的部分我们只需要关心这个目录下的ARM文件夹 │ ├──arm │ │ └──cpu │ │ │ └──armv7 │ │ └──dts │ │ │ └──*.dts 存放设备的dts,也就是设备配置相关的引脚信息 ├── board 对于不同的平台的开发板对应的代码 ├── cmd 顾名思义，大部分的命令的实现都在这个文件夹下面。 ├── common 公共的代码 ├── configs 各个板子的对应的配置文件都在里面，我们的Lichee配置也在里面 ├── disk 对磁盘的一些操作都在这个文件夹里面，例如分区等。 ├── doc 参考文档，这里面有很多跟平台等相关的使用文档。 ├── drivers 各式各样的驱动文件都在这里面 ├── dts 一种树形结构（device tree）这个应该是uboot新的语法 ├── examples 官方给出的一些样例程序 ├── fs 文件系统，uboot会用到的一些文件系统 ├── include 头文件，所有的头文件都在这个文件夹下面 ├── lib 一些常用的库文件在这个文件夹下面 ├── Licenses 这个其实跟编译无关了，就是一些license的声明 ├── net 网络相关的，需要用的小型网络协议栈 ├── post 上电自检程序 ├── scripts 编译脚本和Makefile文件 ├── spl second program loader，即相当于二级uboot启动。 ├── test 小型的单元测试程序。 └── tools 里面有很多uboot常用的工具。 ``` 了解了uboot的基本结构，我们可以知道一些相关的配置在什么地方了。 lichee的uboot配置文件放在confgs文件目录下面，名称为 LicheePi_Zero_480x272LCD_defconfig LicheePi_Zero_800x480LCD_defconfig LicheePi_Zero_defconfig 这3个配置是根据不同的Zero显示设备进行的配置，使用其中之一即可，可以在uboot目录下执行命令 `make LicheePi_Zero_defconfig` 这样配置就生效了。 关于设备的配置引脚信息可以在arch/arm/dts的设备树下面进行查找。 通过查看arch/arm/dts/Makefile我们看到下面这段关于v3s的代码： ``` dtb $(CONFIG_MACH_SUN8I_V3S) + \\ sun8i v3s licheepi zero.dtb ``` 我们基本可以找到对应的dtb文件就是sun8i v3s licheepi zero.dtb 打开 **sun8i v3s licheepi zero.dts** （dtb是object文件，相当于\\*.o, dts相当于\\*.c）文件 ``` #include \"sun8i v3s.dtsi\" //这个文件包含了sun8i v3s系列的配置 #include \"sunxi common regulators.dtsi\" / { model \"Lichee Pi Zero\"; compatible \"licheepi,licheepi zero\", \"allwinner,sun8i v3s\"; aliases { serial0 &uart0; }; chosen { stdout path \"serial0:115200n8\"; }; }; &mmc0 { pinctrl 0 <&mmc0_pins_a>; pinctrl names \"default\"; broken cd; bus width <4>; vmmc supply <&reg_vcc3v3>; status \"okay\"; }; &uart0 { pinctrl 0 <&uart0_pins_a>; pinctrl names \"default\"; status \"okay\"; }; &usb_otg { dr_mode \"otg\"; status \"okay\"; }; &usbphy { usb0_id_det gpio <&pio 5 6 GPIO_ACTIVE_HIGH>; status \"okay\"; }; ``` 从这个配置文件中可以看出，我们所用的stdout输出是用的uart0 波特率115200，mmc的配置， uart0的引脚采用的是uart0\\_pins\\_a 等。 如若需要修改对应的输出，可以在这个文件中修改。 ## menuconfig里的常见配置选项 编译uboot的需要生成.config文件来将该配置生效。配置的生效有两步： **第一步，先将Zero默认的配置加载进来：** Zero已经将配置定制好了，执行相应的命令就可以生成了。下面是生成配置的命令 `make ARCH arm CROSS_COMPILE arm linux gnueabihf LicheePi_Zero_800x480LCD_defconfig` 这个命令可以分为3个部分 设置变量ARCH值为arm\\ 设置变量CROSS_COMPILE值为arm linux gnueabihf \\ make LicheePi_Zero_800x480LCD_defconfig 最后一个 **make LicheePi_Zero_800x480LCD_defconfig** 才是重点，执行这条命令就可以对应生成一个编译所需要的配置文件.config **第二步，对于配置文件可以通过是图形界面的方式修改某一个特定配置选项** 有了配置文件，需要的时候我们可以对其进行修改，linux提供了一种图形界面的方式，这种方式一般在后期需要改某些编译选项的时候，用户交互比较方便，现在我们可以来看看有哪些配置。 `make ARCH arm menuconfig` 执行这个命令就可以出现一个UI交互比较好的配置文件选项，可以看下面的截图： ![](./../static/Contribution/article_30.png) 按回车，即选择当前菜单\\ 按Y 代表该config选项选中\\ 按N 代表不选中该选项\\ 按M 代表该驱动编译成\\*.ko的方式，在系统起来之后，当驱动需要的时候加载\\ \\</\\> 按/ 可以查找某个选项\\ 退出 <*> 按Y选中后的状态 **这里面有几个常见的配置选项我们可以看下：** 1. 第一个Architecture select架构选择，不用质疑这个是ARM架构 2. 第二个ARM architecture 这个选项比较重要，主要配置ARM框架下的常用的配置函数以及LCD等参数 ![](./../static/Contribution/article_31.png) ``` Target select (Support sunxi (Allwinner) SoCs) 进去之后可以选择sunxi Soc系列芯片 [*] Sunxi SoC Variant 这个就是对芯片Soc 的选择，我们可以看到配置选择了`sun8i (Allwinner V3s) (360) sunxi dram clock speed 配置dram的时钟速率 (14779) sunxi dram zq value 配置dram的ZQ值，是用来动态加强DDR3的 * Board uses DDR2 DRAM 使用DDR2 DRAM ``` ![](./../static/Contribution/article_32.png) ``` [*] Enable graphical uboot console on HDMI, LCD or VGA 这个就是在显示设备上使能串口控制 [ ] VGA via LCD controller support 使能支持VGA通过LCD的控制器，就是LCD和VAG转换需要的控制器 (x:800,y:480,depth:18,pclk_khz:33000,le:87,ri:40,up:31,lo:13,hs:1,vs:1,sync:3,vmode:0) LCD pane > 该选项就是配置LCD的分辨率的配置选项可以看到x是800 y是480 等等一些关于LCD的配置内容，点击回车进去可以对其进行修改。 (1) LCD panel display clock phase 这个是LCD的显示时钟相位 () LCD panel power enable pin LCD的电源使能引脚 () LCD panel reset pin LCD的复位引脚 (PB4) LCD panel backlight pwm pin 背光PWN引脚 这个应该是调节亮度的引脚PB4 [*] LCD panel backlight pwm is inverted 反转PWN背光引脚 [ ] LCD panel needs to be configured via i2c LCD panel support (Generic parallel interface LCD panel) > 这个选择支持的LCDpanel (X) Generic parallel interface LCD panel 这里选择支持通用的并行的LCD接口 ( ) Generic lvds interface LCD panel 这个是LVDS接口 ( ) MIPI 4 lane, 513Mbps LCD panel via SSD2828 bridge chip ( ) eDP 4 lane, 1.62G LCD panel via ANX9804 bridge chip ( ) Hitachi tx18d42vm LCD panel ( ) tl059wv5c0 LCD panel (0) GMAC Transmit Clock Delay Chain ``` 3. General setup \\>(0x400) Size of malloc() pool before relocation 这个我们就看下malloc的栈池分配了0x400大小 4. Boot images \\>(1008000000) CPU clock frequency 这里设置了CPU的时钟频率 5. delay in seconds before automatically booting这个是uboot开机的时候的一个等待时间的秒数，可以改大一点，默认是2s 6. Console \\> 这个就是串口打印的一些配置 7. Display information about the CPU during start up 开机的时候显示CPU信息。 8. Display information about the board during start up 开机的时候显示BOARD的信息 9. SPL / TPL \\> 这个就是SPL相关的配置了 ``` [*] MMC raw mode: by sector 按扇区 (0x50) Address on the MMC to load U Boot from mmc加载uboot的地址 [*] Support GPIO 支持GPIO [*] Support I2C 支持I2C [*] Support common libraries 支持通用lib [*] Support disk paritions 支持分区 [*] Support generic libraries 支持一般lib库 [*] Support MMC 支持MMC [*] Support power drivers 支持电源驱动 [*] Support serial 支持串口 ``` 10. Command line interface \\>这里存放的是u boot启动的时候支持的cmd 基本常用的就是上述配置，其他配置都可以采用官方配置就可以了。 ## 编译步骤 上面已经讲述了如何把配置文件进行生成.config文件。做好这两件事情之后就可以编译了。 官方git上给的命令是： `time make ARCH arm CROSS_COMPILE arm linux gnueabihf 2>&1 tee build.log` 第一个time命令完全可以去掉，time主要为了计算该编译需要花费的时间 `make ARCH arm CROSS_COMPILE arm linux gnueabihf ` 这个之前的config也说了，其实就是给变量ARCH赋值arm 给CROSS\\_COMPILE赋值arm linux gnueabihf 也可以先省去，剩下的： `make 2>&1 tee build.log` tee 这个命令是把make生成的log写入到build.log文件中，这样编译之后的log文件可以保留存有备份，也可以省去。 `make 2>&1` 查了下资料 数字2对应stderr 数字1对应stdout 这里即将标准err输出&作为连接符表示‘与’的意思，即标准输出和标准error输出都进行输出。 其实真正执行编译的是下面的命令： `make ARCH arm CROSS_COMPILE arm linux gnueabihf ` 小伙伴可以试下，该命令是否可以编译出 **u boot sunxi with spl.bin**文件，其他的命令都是辅助编译的命令，用于调试的时候开启。亲测直接`make CROSS_COMPILE arm linux gnueabihf ` 也是可以的。 **FAQ：下面的内容可能其他章节会讲到，所以下面就大致讲下编译环境的搭建** 本文所描述的uboot是基于Lichee\\_Pi/uboot.git的版本 先下载代码，执行下面的命令。 git clone <https://github.com/Lichee Pi/u boot.git> git checkout b v3s current origin/v3s current export ARCH arm CROSS\\_COMPILE arm linux gnueabihf make LicheePi\\_Zero\\_defconfig 先要配置好编译环境可以参照[开发环境搭建](https://github.com/Zepan/ilichee/blob/master/%E8%BF%9E%E8%BD%BD%E5%B8%96/2.1.1%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.md) 操作系统官方默认是在Ubuntu 14.04 64bit的环境下编译的。 我试了下在Ubuntu16.04.1的ubuntu的版本下进行编译。 装好虚拟机操作系统之后，我们先安装一些依赖包 ``` sudo apt get install git core gnupg flex bison gperf build essential zip curl zlib1g dev libc6 dev lib32ncurses5 dev gcc multilib x11proto core dev libx11 dev lib32z1 dev libgl1 mesa dev g++ multilib mingw32 tofrodos python markdown libxml2 utils sudo apt get install gcc arm linux gnueabihf ``` 执行完这两条命令之后，如果安装成功，应该是可以编译的，当然我在尝试的时候最后mingw32会出现一些问题。 可能对于ubuntu16.04版本还要根据 git上[编译坑\\_Ubuntu16.04编译过程踩坑记录](https://github.com/Zepan/ilichee/blob/master/%E9%82%A3%E4%BA%9B%E5%B9%B4%E6%88%91%E4%BB%AC%E8%B8%A9%E7%9A%84%E5%9D%91/%E7%BC%96%E8%AF%91%E5%9D%91_Ubuntu%2016.04%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95.md) 来修改gcc的版本.然后呢根据[编译坑\\_Ubuntu16.04编译过程踩坑记录二](https://github.com/Zepan/ilichee/blob/master/%E9%82%A3%E4%BA%9B%E5%B9%B4%E6%88%91%E4%BB%AC%E8%B8%A9%E7%9A%84%E5%9D%91/%E7%BC%96%E8%AF%91%E5%9D%91_Ubuntu16.04%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95%E4%BA%8C.md) 来修改部分的mingw32相关的编译选项，对了后面编译uboot的时候还会遇到dtc编译版本低的问题，所以在此还要执行`sudo apt get install device tree compiler`的命令升级dtc。至此编译环境基本搭建好了。 这些都是楼主踩过的坑，感谢楼主，我们应该不需要踩了。还是挺有用的。 接着就可以下载uboot的源代码： <https://github.com/Lichee Pi/u boot.git> 执行这段命令uboot的源代码就下下来了。"},"/soft/Lichee/zh/Zero-Doc/Contribution/article_5.html":{"title":"TF WiFi使用方法","content":" title: TF WiFi使用方法 ## TF WiFi的硬件安装 TF WiFi可以使用插卡形式或者堆叠形式。 ### 插卡形式安装 直接在Zero上插卡形式安装，会占用SDC0接口，所以只能从SPI Flash启动。 此时，仅能使用WiFi功能，BT由于未接线而无法使用。 ![](./../static/Contribution/article_33.png) ### 堆叠形式安装 对于小体积应用，推荐使用堆叠形式安装，有多种安装方式： ### 前置步骤 注意，初版Zero有一个阻值错误，导致WiFi无法启用，为下图红圈处电阻。 修复方法为： **去除该电阻（推荐）** ，或者更换成510欧电阻。 ![](./../static/Contribution/article_34.png) ### 堆叠焊接于顶部 此为默认的安装形式如图所示，焊接上方SDIO WiFi的8个引脚，下方BT的4个引脚。 ![](./../static/Contribution/article_35.jpg) TF WiFi 2.54间距的焊盘，可以直接插入插针焊接。 BT有2个1.27偏移的焊盘，建议焊接方法如下所示： 取2Pin 排针，插入焊盘，接于半孔上，焊接上下两侧，最后用剪刀或者钳子去除多余部分。 ![](./../static/Contribution/article_36.jpg) 此焊接方式，可使得板子最为紧凑，但缺点是发热大户CPU和WiFi直接贴合在一起，可导致温度达到60度以上。 ### 堆叠焊接于底部 堆叠焊于底部，可使散热情况优于前者，但需要注意两点: 1. 下图红圈处需要剪断，否则无法插屏幕 2. 天线要弯过来，或者重新焊接到背面。 ![](./../static/Contribution/article_37.png) ### 堆叠插拔形式 如果不想把TF WiFi焊死上去，可以使用排座焊接到TF WiFi上，插拔使用： ![](./../static/Contribution/article_38.png) ## WiFi使用方法 网盘中提供的镜像的root目录下提供了r8723bs.ko, 开机后，执行 insmod r8723bs.ko ifconfig wlan0 up 来启动无线接口 编辑好 `/etc/wpa_supplicant.conf` 后，执行 *connect\\_wx.sh* 来连接网络。 ## 蓝牙使用方法 下载或clone下面的源码，编译 <https://github.com/NextThingCo/rtl8723bs_bt> 首先在dts里使能UART： ``` uart0_pins_a: uart0@0 { pins \"PB8\", \"PB9\";function \"uart0\";bias pull up; }; uart1_pins_a: uart1@0 { pins \"PE21\", \"PE22\";function \"uart1\";bias pull up; }; uart2_pins_a: uart2@0 { pins \"PB0\", \"PB1\";function \"uart2\";bias pull up; }; sun8i v3s licheepi zero.dts: &uart0 { pinctrl 0 <&uart0_pins_a>;pinctrl names \"default\";status \"okay\"; }; &uart1 { pinctrl 0 <&uart1_pins_a>;pinctrl names \"default\";status \"okay\"; }; &uart2 { pinctrl 0 <&uart2_pins_a>;pinctrl names \"default\";status \"okay\"; }; ``` 再在内核里使能蓝牙功能： []Networking support >Bluetooth subsystem support []Networking support >Bluetooth subsystem support >Bluetooth device > HC UART driver >Three wire UART (H5) protocol support 最后就可以在终端里开启蓝牙，扫描使用设备了： ``` ./start_bt.sh ttyS2 hciconfig a hciconfig hci0 up hcitool scan ``` ## 常见WiFi错误排查 ### wifi驱动加载成功，但是ifconfig a没有wlan0 ``` root@LicheePi:~# insmod r8723bs.ko [ 37.054004] r8723bs: loading out of tree module taints kernel. [ 37.090084] RTL8723BS: module init start [ 37.094173] RTL8723BS: rtl8723bs v4.3.5.5_12290.20140916_BTCOEX20140507 4E40 [ 37.101496] RTL8723BS: rtl8723bs BT Coex version BTCOEX20140507 4E40 [ 37.108377] RTL8723BS: module init ret 0 root@LicheePi:~# ifconfig a lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 UP LOOPBACK RUNNING MTU:65536 Metric:1 RX packets:0 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:0 (0.0 B) TX bytes:0 (0.0 B) usb0 Link encap:Ethernet HWaddr 96:c0:f5:f1:ab:22 BROADCAST MULTICAST MTU:1500 Metric:1 RX packets:0 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:0 (0.0 B) TX bytes:0 (0.0 B) ``` 检查第一分区中的boot.scr是否正确： ``` root@LicheePi:~# mount /dev/mmcblk0p1 /mnt/ root@LicheePi:~# ls /mnt/ boot.scr sun8i v3s licheepi zero dock.dtb zImage sun8i v3s licheepi zero ctc.dtb sun8i v3s licheepi zero.dtb root@LicheePi:~# cat /mnt/boot.scr 'V·z?Xցܣ]Mڳetenv bootargs console ttyS0,115200 panic 5 console tty0 rootwait root /dev/mmcblk0p2 earlyprintk rw load mmc 0:1 0x41000000 zImage load mmc 0:1 0x41800000 sun8i v3s licheepi zero ctc.dtb < 这里使用了错误的dtb bootz 0x41000000 0x41800000 ``` 从网盘中获取正确的dtb来覆盖，具有wifi功能的dtb是sun8i v3s licheepi zero dock.dtb ## wifi驱动加载失败 ``` root@LicheePi:~# insmod r8723bs.ko insmod: ERROR: could not insert module r8723bs.ko: Invalid module format ``` 使用了错误内核的wifi模块，请到网盘或者qq群文件里重新下载最新的ko文件加载。 ### 间隔1s左右打印sdio RTO 0x52之类的信息 wifi模块焊接不良，或者没有去除之前提到的电阻。"},"/soft/Lichee/zh/Zero-Doc/Contribution/article_2.html":{"title":"Zero i2c oled使用指南","content":" title: Zero i2c oled使用指南 ## 硬件连接 一般市面上买到的单色oled屏幕模块一般都是同时支持spi和i2c接口的，而默认一般都是spi接口模式，需要根据说明书调整模模块上电阻的位置来转换到i2c模式。我手中这个模块一般比较常见，分辨率是128\\*64，需要焊接R1和R4，注意下方那个电阻位置要短接。 ![](./../static/Contribution/article_17.jpg) ![](./../static/Contribution/article_18.jpg) 然后连接到zero的i2c0的位置，reset引脚我连接到了uart2的tx脚位置。我手中暂时没有dock，如果是使用dock，请根据实际情况插到对应位置。 ## ssd1307fb驱动配置 Oled使用的控制芯片是 ssd1306，最新版本的linux中包含Ssd1306的i2c驱动，驱动加载后会注册成功linux framebuffer，驱动文件路径是： `/drivers/video/fbdev/ssd1307fb.c` ，该驱动可以通过配置支持ssd130x系列芯片。 所以要使用oled只需要在dts配置好就可以了 进入linux目录调出配置菜单 ``` /linux zero 4.10.y$ make ARCH arm menuconfig ``` 选中 \\<*> Solomon SSD1307 framebuffer support ![](./../static/Contribution/article_19.jpg) ![](./../static/Contribution/article_20.jpg) 修改dts资源文件 ``` vi arch/arm/boot/dts/sun8i v3s licheepi zero.dts ``` 添加 `ssd1306fb i2c` 节点，`0x3c` 是i2c设备的地址，reset getio是复位脚我选择的是\\**PB0*\\* ![](./../static/Contribution/article_21.jpg) 接下来编译内核和编译dtb ``` make ARCH arm CROSS_COMPILE arm linux gnueabihf j24 uImage make ARCH arm CROSS_COMPILE arm linux gnueabihf dtbs ``` 然后将内核和dtbs更新到zero上，插入串口上电。 我是将驱动直接编译到内核里，可以在内核日志中看到驱动加载成功。 ![](./../static/Contribution/article_22.jpg) 并且屏幕被点亮，该驱动默认不清空屏幕ram中内容，屏幕初始化后默认是花屏内容是正常的。如下状态。 ![](./../static/Contribution/article_23.jpg) 驱动注册后一般会挂载为/dev/fb0或者/dev/fb1设备文件。 写一个简单的oled模块测试程序，读取屏幕信息，并刷将荔枝派logo显示上去效果如下： ![](./../static/Contribution/article_24.jpg) 首先用photoshop做出目标图片，然后保存成bmp格式，然后使用windows自带的画图工具打开bmp，然后点击另存为保存为1位位图格式。使用字模软件将bmp转换成程序用的字节序列，我用的是zimo221这款字模工具软件 ![](./../static/Contribution/article_25.jpg) 注意在参数设置中要勾选字节倒叙选项。 下面写一个测试程序，加载驱动并把图像显示到屏幕上 ``` #include <unistd.h> #include <stdio.h> #include <fcntl.h> #include <linux/fb.h> #include <sys/mman.h> #include <stdlib.h> #include <string.h> /*seconds: the seconds; mseconds: the micro seconds*/ void setTimer(int seconds, int mseconds) { struct timeval temp; temp.tv_sec seconds; temp.tv_usec mseconds; printf(\"timer1\\n\"); select(0, NULL, NULL, NULL, &temp); printf(\"timer2\\n\"); return ; } int main () { char lichee[] { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0xE0,0x00,0x04,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0x60,0x00,0x06,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0x40,0x00,0x04,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0x40,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0x00,0x00,0x00, 0x40,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0x00,0x00,0x00, 0x40,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xC0,0x0F,0x00,0x00,0x00,0x00,0x00,0x00, 0x40,0x00,0x07,0x3C,0x74,0xE0,0x81,0x03,0xE0,0x0F,0x00,0x00,0x00,0x00,0x00,0x00, 0x40,0x00,0x04,0x22,0x8C,0x10,0x43,0x04,0xF0,0x1F,0x00,0x00,0x00,0x00,0x00,0x00, 0x40,0x00,0x04,0x42,0x84,0x10,0x22,0x0C,0xF8,0x1F,0x00,0x00,0x00,0x00,0x00,0x00, 0x40,0x00,0x04,0x03,0x84,0x08,0x22,0x08,0xFC,0x3F,0x00,0x00,0x00,0x00,0x00,0x00, 0x40,0x00,0x04,0x01,0x84,0x18,0x22,0x08,0xFE,0x3F,0x00,0x00,0x00,0x00,0x00,0x00, 0x40,0x00,0x04,0x01,0x84,0x18,0x20,0x00,0xFE,0x7F,0x00,0x00,0x00,0x00,0x00,0x00, 0x40,0x00,0x04,0x01,0x84,0x08,0x20,0x00,0xFE,0x7F,0x00,0x00,0x00,0x00,0x00,0x00, 0x40,0x10,0x04,0x03,0x84,0x18,0x20,0x00,0xFE,0xFF,0x00,0x00,0x00,0x00,0x00,0x08, 0x40,0x10,0x04,0x02,0x84,0x10,0x22,0x00,0xFF,0xFF,0x01,0x00,0x00,0x00,0x00,0x0C, 0x40,0x18,0x04,0x06,0x84,0x30,0x40,0x04,0xFF,0xFF,0x03,0x00,0x00,0x00,0x00,0x06, 0xE0,0x0F,0x1F,0x1C,0xCE,0xC1,0x80,0x03,0xFF,0xFF,0x07,0x00,0x00,0x00,0x00,0x07, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xFF,0xFF,0x0F,0x00,0x00,0x00,0x80,0x07, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xBF,0xFF,0x1F,0x00,0x00,0x00,0xC0,0x07, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xDF,0xFF,0x7F,0x00,0x00,0x00,0xE0,0x07, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xC7,0xFF,0xFF,0x00,0x00,0x00,0xF0,0x03, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0xC9,0xFF,0xFF,0x01,0x00,0x00,0xF0,0x03, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0xC0,0xFF,0xFF,0x03,0x00,0x00,0xF8,0x03, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0xC0,0xFF,0xFF,0x07,0x00,0x00,0xF0,0x03, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0xC0,0xF7,0xFF,0x0F,0x00,0x00,0xF8,0x03, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0xE3,0xFF,0xFF,0x1F,0x00,0x00,0xF8,0x01, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xEF,0xFF,0xFF,0x7F,0x00,0x00,0xF8,0x01, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xFB,0xFF,0xFF,0xFF,0x00,0x00,0xFC,0x01, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xFF,0xFF,0xFF,0xFF,0x03,0x00,0xFC,0x00, 0x40,0x30,0x00,0x06,0x04,0x00,0x00,0x80,0xFF,0xFF,0xFF,0xFF,0x07,0x00,0xFE,0x00, 0x40,0x10,0x02,0x06,0x04,0xC0,0x00,0x9C,0xFF,0xFF,0xFF,0xFF,0x0F,0x00,0xFF,0x00, 0xFE,0xFF,0x07,0x06,0x04,0x80,0xC8,0x81,0xFF,0xFF,0xFF,0xFF,0x3F,0x00,0x7F,0x00, 0x40,0x10,0x00,0x06,0x04,0x80,0x08,0x00,0xFF,0xFF,0xFF,0xFF,0x7F,0x80,0x7F,0x00, 0x40,0x13,0x00,0x16,0xCC,0x00,0x08,0x10,0xFF,0xFF,0xFF,0xFF,0xFF,0xC0,0x7F,0x00, 0x00,0xC3,0xC0,0x3F,0x04,0x00,0x08,0x0E,0xFE,0xFF,0xFF,0xFF,0xFF,0xE3,0x3F,0x00, 0x00,0xC1,0x00,0x06,0x04,0x10,0x48,0x00,0xFE,0xFF,0xFF,0xFF,0xFF,0xF7,0x3F,0x00, 0x80,0x41,0x00,0x06,0x04,0x20,0x49,0x00,0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,0x3F,0x00, 0x80,0x40,0x00,0x0E,0x44,0x20,0x48,0x30,0xFC,0xFF,0xFF,0xFF,0xFF,0xFF,0x3F,0x00, 0x60,0x78,0x00,0x9F,0x61,0x80,0x48,0x08,0xF8,0xFF,0xFF,0xFF,0xFF,0xFF,0x3F,0x00, 0x38,0x30,0x00,0x17,0x60,0x80,0x48,0x02,0xF8,0xFF,0xFF,0xFF,0xFF,0xFF,0x3F,0x00, 0x20,0x60,0x00,0x17,0x21,0x80,0x48,0x02,0xF0,0xFF,0xFF,0xFF,0xFF,0xFF,0x1F,0x00, 0xFE,0xFB,0x83,0x06,0x30,0x40,0x48,0x02,0xE0,0xFF,0xFF,0xFF,0xFF,0xFF,0x1F,0x00, 0x30,0x23,0x02,0x06,0x12,0x70,0x44,0x04,0xC0,0xFF,0xFF,0xFF,0xFF,0xFF,0x0F,0x00, 0x30,0x23,0x42,0x06,0x1A,0x60,0x44,0x04,0x80,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00, 0x10,0x31,0x02,0x06,0x0C,0x40,0x44,0x08,0x80,0xFF,0xFF,0xFF,0xFF,0xFF,0x03,0x00, 0x18,0x11,0x03,0x06,0x0E,0x60,0x42,0x18,0xC0,0xFF,0xFF,0xFF,0xFF,0xFF,0x01,0x00, 0x88,0x19,0x03,0x06,0x31,0x60,0xC2,0x30,0xE0,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00, 0xC4,0xCD,0x01,0x86,0xE0,0x61,0x41,0x20,0xE0,0xFF,0xFF,0xFF,0xFF,0x7F,0x00,0x00, 0x00,0x82,0x01,0x36,0x80,0x00,0x00,0x00,0xF0,0xFF,0xFF,0xFF,0xFF,0x1F,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0x9F,0xFF,0xFF,0xFF,0x07,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x0F,0xFF,0xFF,0xFF,0x01,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xFC,0xFF,0x7F,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF0,0xFF,0x0F,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF8,0x7F,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0x01,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 }; int fp 0; long screensize 0; char *fbp 0; struct fb_var_screeninfo vinfo; struct fb_fix_screeninfo finfo; fp open (\"/dev/fb1\",O_RDWR); if (fp < 0){ printf(\"Error : Can not open framebuffer device/n\"); exit(1); } if (ioctl(fp,FBIOGET_FSCREENINFO,&finfo)){ printf(\"Error reading fixed information/n\"); exit(2); } if (ioctl(fp,FBIOGET_VSCREENINFO,&vinfo)){ printf(\"Error reading variable information/n\"); exit(3); } printf(\"The mem is :%d\\n\",finfo.smem_len); printf(\"The line_length is :%d\\n\",finfo.line_length); printf(\"The xres is :%d\\n\",vinfo.xres); printf(\"The yres is :%d\\n\",vinfo.yres); printf(\"bits_per_pixel is :%d\\n\",vinfo.bits_per_pixel); screensize vinfo.xres * vinfo.yres * vinfo.bits_per_pixel / 8; printf(\"screensize: %d\\n\",screensize); fbp (char *) mmap (0, screensize, PROT_READ PROT_WRITE, MAP_SHARED, fp,0); if ((int) fbp 1) { printf (\"Error: failed to map framebuffer device to memory./n\"); exit (4); } int i 0; memset(fbp, 0x00, 1024); setTimer(3,0); while(1){ for(i 0;i<1024;i++){ fbp[i] lichee[i]; } setTimer(3,0); memset(fbp, 0x00, 1024); setTimer(3,0); } munmap (fbp, screensize); close (fp); } ``` 将字节序在程序中定义为数组在荔枝板中，编译程序并执行。 ![](./../static/Contribution/article_26.jpg) ## 单片机驱动一直为i2c驱动 一般情况下使用ssb1307fb这个驱动就很完美了了，我在发现ssd1307fb这个驱动程序之前，我将显示屏厂家提供的stm8 i2c测试代码移植到了linux上实现了一个驱动，加载驱动后效果如下 ![](./../static/Contribution/article_27.jpg) 我将此驱动也发出来供参考，该驱动程序直接在linux i2c设备注册中实现了oled的测试显示，该驱动包含一个基本ascii的字库和字符串显示逻辑。 ``` #include <linux/kernel.h> #include <linux/init.h> #include <linux/module.h> #include <linux/slab.h> #include <linux/jiffies.h> #include <linux/i2c.h> #include <linux/mutex.h> #include <linux/fs.h> #include <asm/uaccess.h> #define SSD1306_CMD 0 #define SSD1306_DAT 1 #define SSD1306_WIDTH 128 #define SSD1306_HEIGHT 64 #define SSD1306_TS_NAME \"ssd1306_ts\" static uint8_t s_chDispalyBuffer[128][8]; const uint8_t c_chFont1608[95][16] { {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*\" \",0*/ {0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0xCC,0x00,0x0C,0x00,0x00,0x00,0x00,0x00,0x00},/*\"!\",1*/ {0x00,0x00,0x08,0x00,0x30,0x00,0x60,0x00,0x08,0x00,0x30,0x00,0x60,0x00,0x00,0x00},/*\"\"\",2*/ {0x02,0x20,0x03,0xFC,0x1E,0x20,0x02,0x20,0x03,0xFC,0x1E,0x20,0x02,0x20,0x00,0x00},/*\"#\",3*/ {0x00,0x00,0x0E,0x18,0x11,0x04,0x3F,0xFF,0x10,0x84,0x0C,0x78,0x00,0x00,0x00,0x00},/*\"$\",4*/ {0x0F,0x00,0x10,0x84,0x0F,0x38,0x00,0xC0,0x07,0x78,0x18,0x84,0x00,0x78,0x00,0x00},/*\"%\",5*/ {0x00,0x78,0x0F,0x84,0x10,0xC4,0x11,0x24,0x0E,0x98,0x00,0xE4,0x00,0x84,0x00,0x08},/*\"&\",6*/ {0x08,0x00,0x68,0x00,0x70,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*\"'\",7*/ {0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xE0,0x18,0x18,0x20,0x04,0x40,0x02,0x00,0x00},/*\"(\",8*/ {0x00,0x00,0x40,0x02,0x20,0x04,0x18,0x18,0x07,0xE0,0x00,0x00,0x00,0x00,0x00,0x00},/*\")\",9*/ {0x02,0x40,0x02,0x40,0x01,0x80,0x0F,0xF0,0x01,0x80,0x02,0x40,0x02,0x40,0x00,0x00},/*\"*\",10*/ {0x00,0x80,0x00,0x80,0x00,0x80,0x0F,0xF8,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x00},/*\"+\",11*/ {0x00,0x01,0x00,0x0D,0x00,0x0E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*\",\",12*/ {0x00,0x00,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80},/*\" \",13*/ {0x00,0x00,0x00,0x0C,0x00,0x0C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*\".\",14*/ {0x00,0x00,0x00,0x06,0x00,0x18,0x00,0x60,0x01,0x80,0x06,0x00,0x18,0x00,0x20,0x00},/*\"/\",15*/ {0x00,0x00,0x07,0xF0,0x08,0x08,0x10,0x04,0x10,0x04,0x08,0x08,0x07,0xF0,0x00,0x00},/*\"0\",16*/ {0x00,0x00,0x08,0x04,0x08,0x04,0x1F,0xFC,0x00,0x04,0x00,0x04,0x00,0x00,0x00,0x00},/*\"1\",17*/ {0x00,0x00,0x0E,0x0C,0x10,0x14,0x10,0x24,0x10,0x44,0x11,0x84,0x0E,0x0C,0x00,0x00},/*\"2\",18*/ {0x00,0x00,0x0C,0x18,0x10,0x04,0x11,0x04,0x11,0x04,0x12,0x88,0x0C,0x70,0x00,0x00},/*\"3\",19*/ {0x00,0x00,0x00,0xE0,0x03,0x20,0x04,0x24,0x08,0x24,0x1F,0xFC,0x00,0x24,0x00,0x00},/*\"4\",20*/ {0x00,0x00,0x1F,0x98,0x10,0x84,0x11,0x04,0x11,0x04,0x10,0x88,0x10,0x70,0x00,0x00},/*\"5\",21*/ {0x00,0x00,0x07,0xF0,0x08,0x88,0x11,0x04,0x11,0x04,0x18,0x88,0x00,0x70,0x00,0x00},/*\"6\",22*/ {0x00,0x00,0x1C,0x00,0x10,0x00,0x10,0xFC,0x13,0x00,0x1C,0x00,0x10,0x00,0x00,0x00},/*\"7\",23*/ {0x00,0x00,0x0E,0x38,0x11,0x44,0x10,0x84,0x10,0x84,0x11,0x44,0x0E,0x38,0x00,0x00},/*\"8\",24*/ {0x00,0x00,0x07,0x00,0x08,0x8C,0x10,0x44,0x10,0x44,0x08,0x88,0x07,0xF0,0x00,0x00},/*\"9\",25*/ {0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x0C,0x03,0x0C,0x00,0x00,0x00,0x00,0x00,0x00},/*\":\",26*/ {0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*\";\",27*/ {0x00,0x00,0x00,0x80,0x01,0x40,0x02,0x20,0x04,0x10,0x08,0x08,0x10,0x04,0x00,0x00},/*\"<\",28*/ {0x02,0x20,0x02,0x20,0x02,0x20,0x02,0x20,0x02,0x20,0x02,0x20,0x02,0x20,0x00,0x00},/*\" \",29*/ {0x00,0x00,0x10,0x04,0x08,0x08,0x04,0x10,0x02,0x20,0x01,0x40,0x00,0x80,0x00,0x00},/*\">\",30*/ {0x00,0x00,0x0E,0x00,0x12,0x00,0x10,0x0C,0x10,0x6C,0x10,0x80,0x0F,0x00,0x00,0x00},/*\"?\",31*/ {0x03,0xE0,0x0C,0x18,0x13,0xE4,0x14,0x24,0x17,0xC4,0x08,0x28,0x07,0xD0,0x00,0x00},/*\"@\",32*/ {0x00,0x04,0x00,0x3C,0x03,0xC4,0x1C,0x40,0x07,0x40,0x00,0xE4,0x00,0x1C,0x00,0x04},/*\"A\",33*/ {0x10,0x04,0x1F,0xFC,0x11,0x04,0x11,0x04,0x11,0x04,0x0E,0x88,0x00,0x70,0x00,0x00},/*\"B\",34*/ {0x03,0xE0,0x0C,0x18,0x10,0x04,0x10,0x04,0x10,0x04,0x10,0x08,0x1C,0x10,0x00,0x00},/*\"C\",35*/ {0x10,0x04,0x1F,0xFC,0x10,0x04,0x10,0x04,0x10,0x04,0x08,0x08,0x07,0xF0,0x00,0x00},/*\"D\",36*/ {0x10,0x04,0x1F,0xFC,0x11,0x04,0x11,0x04,0x17,0xC4,0x10,0x04,0x08,0x18,0x00,0x00},/*\"E\",37*/ {0x10,0x04,0x1F,0xFC,0x11,0x04,0x11,0x00,0x17,0xC0,0x10,0x00,0x08,0x00,0x00,0x00},/*\"F\",38*/ {0x03,0xE0,0x0C,0x18,0x10,0x04,0x10,0x04,0x10,0x44,0x1C,0x78,0x00,0x40,0x00,0x00},/*\"G\",39*/ {0x10,0x04,0x1F,0xFC,0x10,0x84,0x00,0x80,0x00,0x80,0x10,0x84,0x1F,0xFC,0x10,0x04},/*\"H\",40*/ {0x00,0x00,0x10,0x04,0x10,0x04,0x1F,0xFC,0x10,0x04,0x10,0x04,0x00,0x00,0x00,0x00},/*\"I\",41*/ {0x00,0x03,0x00,0x01,0x10,0x01,0x10,0x01,0x1F,0xFE,0x10,0x00,0x10,0x00,0x00,0x00},/*\"J\",42*/ {0x10,0x04,0x1F,0xFC,0x11,0x04,0x03,0x80,0x14,0x64,0x18,0x1C,0x10,0x04,0x00,0x00},/*\"K\",43*/ {0x10,0x04,0x1F,0xFC,0x10,0x04,0x00,0x04,0x00,0x04,0x00,0x04,0x00,0x0C,0x00,0x00},/*\"L\",44*/ {0x10,0x04,0x1F,0xFC,0x1F,0x00,0x00,0xFC,0x1F,0x00,0x1F,0xFC,0x10,0x04,0x00,0x00},/*\"M\",45*/ {0x10,0x04,0x1F,0xFC,0x0C,0x04,0x03,0x00,0x00,0xE0,0x10,0x18,0x1F,0xFC,0x10,0x00},/*\"N\",46*/ {0x07,0xF0,0x08,0x08,0x10,0x04,0x10,0x04,0x10,0x04,0x08,0x08,0x07,0xF0,0x00,0x00},/*\"O\",47*/ {0x10,0x04,0x1F,0xFC,0x10,0x84,0x10,0x80,0x10,0x80,0x10,0x80,0x0F,0x00,0x00,0x00},/*\"P\",48*/ {0x07,0xF0,0x08,0x18,0x10,0x24,0x10,0x24,0x10,0x1C,0x08,0x0A,0x07,0xF2,0x00,0x00},/*\"Q\",49*/ {0x10,0x04,0x1F,0xFC,0x11,0x04,0x11,0x00,0x11,0xC0,0x11,0x30,0x0E,0x0C,0x00,0x04},/*\"R\",50*/ {0x00,0x00,0x0E,0x1C,0x11,0x04,0x10,0x84,0x10,0x84,0x10,0x44,0x1C,0x38,0x00,0x00},/*\"S\",51*/ {0x18,0x00,0x10,0x00,0x10,0x04,0x1F,0xFC,0x10,0x04,0x10,0x00,0x18,0x00,0x00,0x00},/*\"T\",52*/ {0x10,0x00,0x1F,0xF8,0x10,0x04,0x00,0x04,0x00,0x04,0x10,0x04,0x1F,0xF8,0x10,0x00},/*\"U\",53*/ {0x10,0x00,0x1E,0x00,0x11,0xE0,0x00,0x1C,0x00,0x70,0x13,0x80,0x1C,0x00,0x10,0x00},/*\"V\",54*/ {0x1F,0xC0,0x10,0x3C,0x00,0xE0,0x1F,0x00,0x00,0xE0,0x10,0x3C,0x1F,0xC0,0x00,0x00},/*\"W\",55*/ {0x10,0x04,0x18,0x0C,0x16,0x34,0x01,0xC0,0x01,0xC0,0x16,0x34,0x18,0x0C,0x10,0x04},/*\"X\",56*/ {0x10,0x00,0x1C,0x00,0x13,0x04,0x00,0xFC,0x13,0x04,0x1C,0x00,0x10,0x00,0x00,0x00},/*\"Y\",57*/ {0x08,0x04,0x10,0x1C,0x10,0x64,0x10,0x84,0x13,0x04,0x1C,0x04,0x10,0x18,0x00,0x00},/*\"Z\",58*/ {0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0xFE,0x40,0x02,0x40,0x02,0x40,0x02,0x00,0x00},/*\"[\",59*/ {0x00,0x00,0x30,0x00,0x0C,0x00,0x03,0x80,0x00,0x60,0x00,0x1C,0x00,0x03,0x00,0x00},/*\"\\\",60*/ {0x00,0x00,0x40,0x02,0x40,0x02,0x40,0x02,0x7F,0xFE,0x00,0x00,0x00,0x00,0x00,0x00},/*\"]\",61*/ {0x00,0x00,0x00,0x00,0x20,0x00,0x40,0x00,0x40,0x00,0x40,0x00,0x20,0x00,0x00,0x00},/*\"^\",62*/ {0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01},/*\"_\",63*/ {0x00,0x00,0x40,0x00,0x40,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*\"`\",64*/ {0x00,0x00,0x00,0x98,0x01,0x24,0x01,0x44,0x01,0x44,0x01,0x44,0x00,0xFC,0x00,0x04},/*\"a\",65*/ {0x10,0x00,0x1F,0xFC,0x00,0x88,0x01,0x04,0x01,0x04,0x00,0x88,0x00,0x70,0x00,0x00},/*\"b\",66*/ {0x00,0x00,0x00,0x70,0x00,0x88,0x01,0x04,0x01,0x04,0x01,0x04,0x00,0x88,0x00,0x00},/*\"c\",67*/ {0x00,0x00,0x00,0x70,0x00,0x88,0x01,0x04,0x01,0x04,0x11,0x08,0x1F,0xFC,0x00,0x04},/*\"d\",68*/ {0x00,0x00,0x00,0xF8,0x01,0x44,0x01,0x44,0x01,0x44,0x01,0x44,0x00,0xC8,0x00,0x00},/*\"e\",69*/ {0x00,0x00,0x01,0x04,0x01,0x04,0x0F,0xFC,0x11,0x04,0x11,0x04,0x11,0x00,0x18,0x00},/*\"f\",70*/ {0x00,0x00,0x00,0xD6,0x01,0x29,0x01,0x29,0x01,0x29,0x01,0xC9,0x01,0x06,0x00,0x00},/*\"g\",71*/ {0x10,0x04,0x1F,0xFC,0x00,0x84,0x01,0x00,0x01,0x00,0x01,0x04,0x00,0xFC,0x00,0x04},/*\"h\",72*/ {0x00,0x00,0x01,0x04,0x19,0x04,0x19,0xFC,0x00,0x04,0x00,0x04,0x00,0x00,0x00,0x00},/*\"i\",73*/ {0x00,0x00,0x00,0x03,0x00,0x01,0x01,0x01,0x19,0x01,0x19,0xFE,0x00,0x00,0x00,0x00},/*\"j\",74*/ {0x10,0x04,0x1F,0xFC,0x00,0x24,0x00,0x40,0x01,0xB4,0x01,0x0C,0x01,0x04,0x00,0x00},/*\"k\",75*/ {0x00,0x00,0x10,0x04,0x10,0x04,0x1F,0xFC,0x00,0x04,0x00,0x04,0x00,0x00,0x00,0x00},/*\"l\",76*/ {0x01,0x04,0x01,0xFC,0x01,0x04,0x01,0x00,0x01,0xFC,0x01,0x04,0x01,0x00,0x00,0xFC},/*\"m\",77*/ {0x01,0x04,0x01,0xFC,0x00,0x84,0x01,0x00,0x01,0x00,0x01,0x04,0x00,0xFC,0x00,0x04},/*\"n\",78*/ {0x00,0x00,0x00,0xF8,0x01,0x04,0x01,0x04,0x01,0x04,0x01,0x04,0x00,0xF8,0x00,0x00},/*\"o\",79*/ {0x01,0x01,0x01,0xFF,0x00,0x85,0x01,0x04,0x01,0x04,0x00,0x88,0x00,0x70,0x00,0x00},/*\"p\",80*/ {0x00,0x00,0x00,0x70,0x00,0x88,0x01,0x04,0x01,0x04,0x01,0x05,0x01,0xFF,0x00,0x01},/*\"q\",81*/ {0x01,0x04,0x01,0x04,0x01,0xFC,0x00,0x84,0x01,0x04,0x01,0x00,0x01,0x80,0x00,0x00},/*\"r\",82*/ {0x00,0x00,0x00,0xCC,0x01,0x24,0x01,0x24,0x01,0x24,0x01,0x24,0x01,0x98,0x00,0x00},/*\"s\",83*/ {0x00,0x00,0x01,0x00,0x01,0x00,0x07,0xF8,0x01,0x04,0x01,0x04,0x00,0x00,0x00,0x00},/*\"t\",84*/ {0x01,0x00,0x01,0xF8,0x00,0x04,0x00,0x04,0x00,0x04,0x01,0x08,0x01,0xFC,0x00,0x04},/*\"u\",85*/ {0x01,0x00,0x01,0x80,0x01,0x70,0x00,0x0C,0x00,0x10,0x01,0x60,0x01,0x80,0x01,0x00},/*\"v\",86*/ {0x01,0xF0,0x01,0x0C,0x00,0x30,0x01,0xC0,0x00,0x30,0x01,0x0C,0x01,0xF0,0x01,0x00},/*\"w\",87*/ {0x00,0x00,0x01,0x04,0x01,0x8C,0x00,0x74,0x01,0x70,0x01,0x8C,0x01,0x04,0x00,0x00},/*\"x\",88*/ {0x01,0x01,0x01,0x81,0x01,0x71,0x00,0x0E,0x00,0x18,0x01,0x60,0x01,0x80,0x01,0x00},/*\"y\",89*/ {0x00,0x00,0x01,0x84,0x01,0x0C,0x01,0x34,0x01,0x44,0x01,0x84,0x01,0x0C,0x00,0x00},/*\"z\",90*/ {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x3E,0xFC,0x40,0x02,0x40,0x02},/*\"{\",91*/ {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00},/*\"\",92*/ {0x00,0x00,0x40,0x02,0x40,0x02,0x3E,0xFC,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*\"}\",93*/ {0x00,0x00,0x60,0x00,0x80,0x00,0x80,0x00,0x40,0x00,0x40,0x00,0x20,0x00,0x20,0x00},/*\"~\",94*/ }; struct i2c_client *ssd1306_client; static void ssd1306_write_byte(uint8_t chData, uint8_t chCmd) { uint8_t cmd 0x00; if (chCmd) { cmd 0x40; } else { cmd 0x00; } i2c_smbus_write_byte_data(ssd1306_client, cmd, chData); } void ssd1306_display_on(void) { ssd1306_write_byte(0x8D, SSD1306_CMD); ssd1306_write_byte(0x14, SSD1306_CMD); ssd1306_write_byte(0xAF, SSD1306_CMD); } /** * @brief OLED turns off * * @param None * * @retval None **/ void ssd1306_display_off(void) { ssd1306_write_byte(0x8D, SSD1306_CMD); ssd1306_write_byte(0x10, SSD1306_CMD); ssd1306_write_byte(0xAE, SSD1306_CMD); } void ssd1306_refresh_gram(void) { uint8_t i, j; for (i 0; i < 8; i ++) { ssd1306_write_byte(0xB0 + i, SSD1306_CMD); ssd1306_write_byte(0x02, SSD1306_CMD); ssd1306_write_byte(0x10, SSD1306_CMD); for (j 0; j < 128; j ++) { ssd1306_write_byte(s_chDispalyBuffer[j][i], SSD1306_DAT); } } } void ssd1306_clear_screen(uint8_t chFill) { memset(s_chDispalyBuffer,chFill, sizeof(s_chDispalyBuffer)); ssd1306_refresh_gram(); } /** * @brief Draws a piont on the screen * * @param chXpos: Specifies the X position * @param chYpos: Specifies the Y position * @param chPoint: 0: the point turns off 1: the piont turns on * * @retval None **/ void ssd1306_draw_point(uint8_t chXpos, uint8_t chYpos, uint8_t chPoint) { uint8_t chPos, chBx, chTemp 0; if (chXpos > 127 chYpos > 63) { return; } chPos 7 chYpos / 8; // chBx chYpos % 8; chTemp 1 << (7 chBx); if (chPoint) { s_chDispalyBuffer[chXpos][chPos] chTemp; } else { s_chDispalyBuffer[chXpos][chPos] & ~chTemp; } } /** * @brief Fills a rectangle * * @param chXpos1: Specifies the X position 1 (X top left position) * @param chYpos1: Specifies the Y position 1 (Y top left position) * @param chXpos2: Specifies the X position 2 (X bottom right position) * @param chYpos3: Specifies the Y position 2 (Y bottom right position) * * @retval **/ void ssd1306_fill_screen(uint8_t chXpos1, uint8_t chYpos1, uint8_t chXpos2, uint8_t chYpos2, uint8_t chDot) { uint8_t chXpos, chYpos; for (chXpos chXpos1; chXpos < chXpos2; chXpos ++) { for (chYpos chYpos1; chYpos < chYpos2; chYpos ++) { ssd1306_draw_point(chXpos, chYpos, chDot); } } ssd1306_refresh_gram(); } /** * @brief Displays one character at the specified position * * @param chXpos: Specifies the X position * @param chYpos: Specifies the Y position * @param chSize: * @param chMode * @retval **/ void ssd1306_display_char(uint8_t chXpos, uint8_t chYpos, uint8_t chChr, uint8_t chSize, uint8_t chMode) { uint8_t i, j; uint8_t chTemp, chYpos0 chYpos; chChr chChr ' '; for (i 0; i < chSize; i ++) { if (chMode) { chTemp c_chFont1608[chChr][i]; } else { chTemp ~c_chFont1608[chChr][i]; } for (j 0; j < 8; j ++) { if (chTemp & 0x80) { ssd1306_draw_point(chXpos, chYpos, 1); } else { ssd1306_draw_point(chXpos, chYpos, 0); } chTemp << 1; chYpos ++; if ((chYpos chYpos0) chSize) { chYpos chYpos0; chXpos ++; break; } } } } /** * @brief Displays a string on the screen * * @param chXpos: Specifies the X position * @param chYpos: Specifies the Y position * @param pchString: Pointer to a string to display on the screen * * @retval None **/ void ssd1306_display_string(uint8_t chXpos, uint8_t chYpos, const uint8_t *pchString, uint8_t chSize, uint8_t chMode) { printk(\"%s, ssd1306 str %s\\n\", __func__, pchString); while (*pchString ! '\\0') { if (chXpos > (SSD1306_WIDTH chSize / 2)) { chXpos 0; chYpos + chSize; if (chYpos > (SSD1306_HEIGHT chSize)) { chYpos chXpos 0; ssd1306_clear_screen(0x00); } } ssd1306_display_char(chXpos, chYpos, *pchString, chSize, chMode); chXpos + chSize / 2; pchString ++; } } void ssd1306_init(void) { ssd1306_write_byte(0xAE, SSD1306_CMD);// turn off oled panel ssd1306_write_byte(0x00, SSD1306_CMD);// set low column address ssd1306_write_byte(0x10, SSD1306_CMD);// set high column address ssd1306_write_byte(0x40, SSD1306_CMD);// set start line address Set Mapping RAM Display Start Line (0x00~0x3F) ssd1306_write_byte(0x81, SSD1306_CMD);// set contrast control register ssd1306_write_byte(0xCF, SSD1306_CMD);// Set SEG Output Current Brightness ssd1306_write_byte(0xA1, SSD1306_CMD);// Set SEG/Column Mapping ssd1306_write_byte(0xC0, SSD1306_CMD);//Set COM/Row Scan Direction ssd1306_write_byte(0xA6, SSD1306_CMD);// set normal display ssd1306_write_byte(0xA8, SSD1306_CMD);// set multiplex ratio(1 to 64) ssd1306_write_byte(0x3f, SSD1306_CMD);// 1/64 duty ssd1306_write_byte(0xD3, SSD1306_CMD);// set display offset Shift Mapping RAM Counter (0x00~0x3F) ssd1306_write_byte(0x00, SSD1306_CMD);// not offset ssd1306_write_byte(0xd5, SSD1306_CMD);// set display clock divide ratio/oscillator frequency ssd1306_write_byte(0x80, SSD1306_CMD);// set divide ratio, Set Clock as 100 Frames/Sec ssd1306_write_byte(0xD9, SSD1306_CMD);// set pre charge period ssd1306_write_byte(0xF1, SSD1306_CMD);//Set Pre Charge as 15 Clocks & Discharge as 1 Clock ssd1306_write_byte(0xDA, SSD1306_CMD);// set com pins hardware configuration ssd1306_write_byte(0x12, SSD1306_CMD); ssd1306_write_byte(0xDB, SSD1306_CMD);// set vcomh ssd1306_write_byte(0x40, SSD1306_CMD);//Set VCOM Deselect Level ssd1306_write_byte(0x20, SSD1306_CMD);// Set Page Addressing Mode (0x00/0x01/0x02) ssd1306_write_byte(0x02, SSD1306_CMD);// ssd1306_write_byte(0x8D, SSD1306_CMD);// set Charge Pump enable/disable ssd1306_write_byte(0x14, SSD1306_CMD);// set(0x10) disable ssd1306_write_byte(0xA4, SSD1306_CMD);// Disable Entire Display On (0xa4/0xa5) ssd1306_write_byte(0xA6, SSD1306_CMD);// Disable Inverse Display On (0xa6/a7) ssd1306_write_byte(0xAF, SSD1306_CMD);// turn on oled panel ssd1306_display_on(); ssd1306_clear_screen(0xff); } static int ssd1306_ts_probe(struct i2c_client *client, const struct i2c_device_id *id) { printk(\"ssd1306_ts_probe\\n\"); printk(\"probe %s\\n\",__func__); printk(\"%s, addr %x, line %d\\n\", __func__, client >addr, client >adapter >nr); printk(\"%s, name %s, adapter nr %d\\n\", __func__, client >adapter >name, client >adapter >nr); ssd1306_client client; ssd1306_init(); ssd1306_clear_screen(0x00); //ssd1306_display_off(); ssd1306_display_on(); ssd1306_display_string(18, 0, \"Welcome!\", 16, 1); ssd1306_display_string(0, 16, \"zero i2c driver\", 16, 1); ssd1306_refresh_gram(); // ssd1306_display_on(); return 0; }; static const struct i2c_device_id ssd1306_ts_id[] { { \"ssd1306\", 0 }, { } }; MODULE_DEVICE_TABLE(i2c, ssd1306_ts_id); static struct i2c_driver ssd1306_ts_driver { .probe ssd1306_ts_probe, .id_table ssd1306_ts_id, .driver { .name SSD1306_TS_NAME, }, }; module_i2c_driver(ssd1306_ts_driver); MODULE_LICENSE(\"GPL\"); ``` 相应dts配置如下： ![](./../static/Contribution/article_28.jpg)"},"/soft/Lichee/zh/Zero-Doc/Start/docker_ubuntu.html":{"title":"基础ubuntu系统配置","content":" title: 基础ubuntu系统配置 运行以下命令： ``` sudo apt get update sudo apt get install iputils ping vim git wget xz utils bzip2 gcc device tree compiler python time make gcc arm linux gnueabihf g++ arm linux gnueabihf ```"},"/soft/Lichee/zh/Zero-Doc/Start/docker_command.html":{"title":"Docker命令速查","content":" title: Docker命令速查 ## Docker 概念 `镜像` ：只读的模板 `容器` ：负责应用程序的运行。是从镜像创建的运行实例，互相隔离，安全的平台。 `镜像只读` :容器在启动时创建一层可写层作为最上层。（类似overlayfs） `仓库` ：集中存放镜像的地方，和github类似。[https://hub.docker.com/](https://hub.docker.com/) ## Docker 安装 ```bash sudo apt get install docker.io sudo gpasswd a your_user_name docker #加入用户组 sudo service docker restart newgrp docker #使用新用户组，或者也可以断开终端重连生效 docker version #查看docker版本信息 ``` docker下各文件默认存放在/var/lib/docker下 `du h max depth 1 /var/lib/docker #查看docker目录大小` ## Docker镜像操作 ```bash docker search licheepi #搜索镜像 docker pull zepan/licheepi #下载镜像 docker run zepan/licheepi apt get install y xxx #在镜像中执行命令，安装某软件 docker commit m \"install something\" a \"zepan\" container_id zepan/licheepi docker login docker push zepan/licheepi ``` ## Docker容器操作 ### 运行交互式的容器 ``` docker run i t learn/tutorial /bin/bash //开启一个交互式虚拟终端 i 交互式 t 虚拟终端 d 后台 P 端口映射 docker port id //查看端口映射情况 docker inspect id //查看容器详细状态 ``` ### 启动容器（后台模式） ``` docker run d learn/tutorial /bin/sh c \"while true; do echo hello world; sleep 1; done\" 返回容器id：350807154a3dd17309b23bb9a9a9897dd3fc91667a7d176aca42f390808e3019 ``` ### 通过ps查看正在运行的容器实例 ``` zepan@ubuntu:~$ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 350807154a3d learn/tutorial \"/bin/sh c 'while \" 31 seconds ago Up 30 seconds blissful_lamport docker ps l //查看最后运行的容器 docker ps a //查看所有容器 ``` ### 查看对应容器的输出： ``` docker logs 3508 或 blissful_lamport docker logs f xxxx //类似tail f ``` ### 停止/开始/重启容器： ``` docker stop 3508 //通过发送信号方式停止 docker kill 3508 //kill方式停止 docker start 3508 //start i 交互式执行 docker restart 3508 ``` ### 删除容器 ``` docker remove 3508 docker rm `docker ps a q` //删除所有容器 ``` ### 主机容器互拷数据 ``` docker cp id:/xxx/xx /yyy/yy/ docker cp /yyy/yy/ id:/xxx/xx ``` ### 开启容器的ssh ``` docker run d p 6666:22 zepan/licheepi /usr/sbin/sshd D ```"},"/soft/Lichee/zh/Zero-Doc/Start/tips.html":{"title":"Linux使用小贴士","content":"# Linux使用小贴士 ## Ubuntu如何开启ssh？ 桌面版ubutnu默认没有安装ssh服务器，无法通过ssh远程连接；需要安装服务器来启用ssh。 ```bash sudo apt get install openssh server ``` ## 如何在ubuntu与windows间传递文件？ 最简单的方式：下载WinSCP，即可互传文件。 或者也可以搭建Samba服务器，那样在windows上可以直接访问共享文件夹。 ## 如何在ubuntu上搭建samba服务器并设置共享文件夹？ 此处仅作最简单的匿名登陆方式介绍（以ubuntu为例）： 首先安装samba ```bash sudo apt get install samba ``` 打开samba配置文件 ```bash sudo vim /etc/samba/smb.conf ``` 编辑内容 ``` ## Debugging/Accounting #### # share the dir without passwd security user map to guest Bad User # 在文件结尾添加如下行： [share] # 更改path为指定目录 path /your/path public yes writable yes ``` 启动Samba服务： ```bash /etc/init.d/samba start ``` 将共享目录赋予权限 `sudo chmod 777 your_path` 注：最好将共享目录的上级目录也赋予权限"},"/soft/Lichee/zh/Zero-Doc/Start/docker_env.html":{"title":"docker安装","content":"# docker安装 ## 什么是docker？ Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从Apache2.0协议开源。 Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。 容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。 本节只简单介绍docker开发环境的搭建，想要详细了解docker，可以查看本节的附录“Docker 命令速查”。简而言之，我帮你搞好了docker镜像，你就不用自己再费力搭建啦。 ## docker下载安装 ```bash sudo apt get install docker.io docker version ``` 安装成功后可见版本信息 ```bash Client version: 1.6.2 Client API version: 1.18 Go version (client): go1.2.1 Git commit (client): 7c8fca2 OS/Arch (client): linux/amd64 FATA[0000] Get http:///var/run/docker.sock/v1.18/version: dial unix /var/run/docker.sock: permission denied. Are you trying to connect to a TLS enabled daemon without TLS? ``` 默认情况下会报后面的错误，如果使用sudo就不会报错。不想每次都sudo的话，可以把用户加入到docker组。 ```bash //如果还没有 docker group 就添加一个(默认安装后已经有了) //sudo groupadd docker //将用户加入该 group 内。然后退出并重新登录就生效啦。 sudo gpasswd a ${your_user_name} docker //重启 docker 服务 sudo service docker restart //切换当前会话到新 group, 或者关掉终端重新连接也会生效 //newgrp docker ``` ## 安装荔枝派开发镜像 ```bash docker pull zepan/licheepi docker run d p 6666:22 zepan/licheepi /usr/sbin/sshd D ``` 这样就安装并开启的容器ssh服务，只需连接主机的6666端口，以root用户，licheepi密码登录即可进行开发操作。"},"/soft/Lichee/zh/Zero-Doc/Start/docker_index.html":{"title":"Docker环境简明教程","content":" title: Docker环境简明教程 这里给大家准备了搭建ok的环境，可以直接下载使用。 当然这里使用的不是大家熟悉的虚拟机镜像，而是docker镜像，所以也写个简单的使用教程。 **传统的开发环境搭建** ，将在下章系统开发篇进行详细介绍"},"/soft/Lichee/zh/Zero-Doc/Start/board_intro.html":{"title":"LicheePI Zero","content":" title: LicheePI Zero ## 简介 **荔枝派Zero**（下面简称 **Zero**）是一款精致迷你的 **Cortex A7** 核心板/开发板，可用于初学者学习linux或者商用于产品开发。 Zero 在稍长于SD卡的尺寸上（**45x26mm**）提供了丰富的外设（LCD,ETH,UART,SPI,I2C,PWM,SDIO ）和强劲的性能（**24MHZ~1.2GHZ, 64MB DDR** ）。 得益于精巧的的PCB设计，Zero 相关的开发和使用非常方便： 直插面包板 直插40P RGB LCD 使用OTG口进行供电和数据传输(虚拟串口，虚拟以太网等) 使用堆叠式的WiFi 模块联网 直接贴片 Zero 提供了 **Linux主线** 支持和 全志官方原生 Camdriod（适用于行车记录仪应用）SDK，可以选择你熟悉的系统来进行开发。 ## Zero上手提示 对于刚入坑的小白，请先看以下几点基础说明： 1. Zero 需要插卡启动（或者自行焊接spi flash）；请不要问为什么通电后没反应 2. TF卡槽是下图中荔枝派logo上方的长方形插槽 3. 收到Zero后看到主芯片上有连锡请不要慌张，这是设计如此（相同的电源管脚），请参阅原理图，[点我下载](https://dl.sipeed.com/fileList/LICHEE/Zero/HDK/lichee_zero_Schematic.pdf) 4. Zero的系统调试串口是UART0，即下图右下方的“U0T R”标识的两个引脚 5. Zero正面的led不是上电就闪烁的，请不要认为上电后led不亮就是坏的 6. Zero的USB是OTG USB，既可以供电，又能通信（比如作为usb虚拟网口与电脑共享网络) 7. Zero usb口下方的“GND 5V”可以作为电源输入，使用串口小板的5V或者锂电池均可供电。 8. 推荐的两边排针焊接方式是向下焊接。“G 5V”插针推荐向上焊接。 9. 推荐的底层调试接法是：usb转串口小板接“U0T R”和“G 5V”。 10. 推荐的联网方式是：USB虚拟网口 或者 [tf wifi](./../Contribution/article_12.html)。 11. Zero毕竟是上千M主频的Cortex A7处理器，运行时温度在40\\~60℃，请不要认为芯片在此范围内的发热是短路。 12. Zero运行Linux空载电流约100mA，满载电流约150\\~180mA，插上LCD电流约200\\~300mA。不插卡上电电流约50\\~60mA。 如果收到板子后还有其他疑问，请加 **官方交流QQ群：712961164** 。 ## 功能框图 ![](./../static/start/board_intro_1.png) ## Zero实物图 <img src \"./../static/start/lichee zero cut.jpg\" > ## 硬件参数 项目 参数 **CPU** 全志V3S， ARM Cortex A7, 最高1.2GHz 存储 预留SOP8 SPI Flash焊盘（可定制贴片8\\~32MB SPI NorFlash,128MB Nand Flash）<br> 板载 半槽TF卡座，可TF启动。 **内存** 集成64MB DDR2 显示 通用 40P RGB LCD FPC座 <br> 可直插常见的40P 4.3/5/7寸屏幕（板载背光驱动），通过转接板可插50P 7/9寸屏 <br> 支持常见的272x480, 480x800,1024x600等分辨率 <br> 板载电阻式触摸屏芯片，支持电阻屏 <br> 板载RGB LED 通信接口 SDIO x2，可搭配配套SDIO WiFi+BT 模块 <br> SPI x1 <br> I2C x2 <br> UART x3 <br> 100M Ether x1（含EPHY）<br> OTG USB x1 <br> MIPI CSI x1 其它接口 PWM x2 <br> LRADC x1 <br> Speakerx2 + Mic x1 电气特性 Micro USB 5V供电； 2.54mm 插针 3.3V\\~5V供电； 1.27mm邮票孔供电 <br> 输出 3.3V 和 3.0V（AVCC），可选择输入RTC电压 <br> 1GHz linux空载运行电流 90\\~100mA， 满载运行电流 \\~180mA <br> 存储温度 40\\~125℃，运行温度 20\\~70℃ ## 其他资料 国内下载链接： 百度网盘: [https://pan.baidu.com/s/138PYwV2gjnO74qTLX0TVtA](https://pan.baidu.com/s/138PYwV2gjnO74qTLX0TVtA) 下载站：[dl.sipeed.com/shareURL/LICHEE/Zero/HDK](https://dl.sipeed.com/shareURL/LICHEE/Zero/HDK)"},"/soft/Lichee/zh/Zero-Doc/Start/intro_cn.html":{"title":"荔枝派Zero","content":"# 荔枝派Zero ## 缘起 那年仲夏之夜，我吃着荔枝DIY了荔枝派One。 One的众筹和生产过程可谓万分曲折，不过整个流程经历下来也让我更清楚怎样的Pi才是一块好Pi。 > 笔者是业余时间将项目中使用过的主控芯片部分电路抽出，重新设计布局而成荔枝派系列板卡，时间并不充分，但是提供qq群与论坛供大家交流整理资料； > 希望初次学习linux使用的朋友能够钻研在使用中遇到的问题并与大家交流分享，而不要当伸手党，真正的linux大神不是伸手伸出来的，也不是培训班里培训出来的，**而是自己踩坑踩出来的**。 荔枝派Zero从去年年末开始构思，设计目标就是一块满足创客和嵌入式工程师一切美好设想的Pi： > **低成本，小体积，高性能，易使用，多扩展。** 45x26mm，略长于SD卡；24MHz~1.2GHz；多种开发语言，`直插面包板`，同时 `全引脚邮票孔引出` ；支持多种外设模块 **目标应用场景是：** 使用较复杂的通信接口和协议的物联网应用 需要较美观，复杂逻辑的人机交互界面的应用 需要较多运算(相对于常用MCU)的应用场景 需要使用linux下的开源软件进行快速开发的场景 高端极客玩家，在体积、性能、易用性 上取得平衡。 入门级玩家，软件工程师，使用熟悉的语言进行硬件diy。 ## 初识 荔枝派Zero基于Allwinner V3s (**ARM Cortex A7 CPU, 1.2GHz, 512Mbit DDR2 integrated**), 可从板载SPI Nor Flash(SOP8 16MB / WSON8 32MB) 或者 TF卡启动。 Zero采用了巧妙的引脚引出设计： 兼容常用的2.54mm插针，甚至可以 **直插面包板** 使用； 使用1.27mm邮票孔引出，可以 **直接贴片** 使用； 1.27mm邮票孔也可以使用 **2.54插针偏移半针位焊接** ，适合diy 板载 **FPC40接口** ，可以转接多种实用外设 专为Zero设计的 **TF wifi** 模块，可插卡槽，也可直插2.54焊针。 荔枝派Zero 麻雀虽小五脏俱全，具备了常用的多种低速外设（UART，SPI，I2C，PWM，ADC），单片机上少有的高速接口它也有不少（OTG USB，MIPI CSI，EPHY，RGB LCD），还内置了CODEC（直接耳机麦克）~ Zero的引脚布局示意图如下： “2.54mm Pinout”标识是可直接插入面包板或者使用标准杜邦线连接的。 “1.27mm”标识的是较为不常用或者不方便手工接线的引脚，一般在贴片时使用，或者也可以用2.54插针偏移半个针位使用。 ![](./../static/start/board_intro_1.png) 话不多说，下面开始曝照！ > 由于以下样板由我手工焊接，难免有些焊接痕迹，焊得丑请轻喷，成品会用机贴的。 正面：从左往右为：RGB LED；主芯片；tf卡槽；LCD背光电路；micro usb otg。 ![](./../static/start/zero_2.jpg) 背面：从左往右为：电阻屏控制器；DCDC芯片；预留的SPI flash接口，兼容SOP8和WSON8封装的SPI flash（16/32MB）；FPC40接口。 ![](./../static/start/zero_1.jpg) 正反面一起看： ![](./../static/start/lichee zero.jpg) 插针引出演示： 直插面包板：双列插针间距900mil，可直插面包板！ 应该是首款可直插面包板的Cortex A7水果派~ 手残党的福音~ ![](./../static/start/intro_5.jpg) Zero的常用引脚使用2.54mm插针引出，如果想用到全部引脚，也不必像其它板子那样飞线，仍然可以用2.54插针和杜邦线搞定！ 如下图所示，邮票孔是1.27mm间距，所以刚好可以间隔半个脚位焊上2.54mm插针，轻松使用杜邦线连接！ ![](./../static/start/intro_6.jpg) 上面的高清大图看上去是不是觉得Zero比较大呢？没有比较就没有伤害，其实Zero只比SD卡长一点！ 与SD卡一起比个子： ![](./../static/start/intro_7.jpg) Zero默认运行主频高达1G（最高1.2G），你是否认为它功耗感人？ NONONO，其实它以1G主频跑起linux后的运行电流 和 STM32F4 以168MHz主频全速运行的电流（93mA）差不多！ 比STMF7全速运行于216MHz的电流（193mA）要低一半以上！ 有图有真相： ![](./../static/start/intro_8.jpg) 再来看看Zero全速运行时的发热情况： ![](./../static/start/intro_9.jpg) 是的，仅有40度左右，略高于体温，比H3之流 动辄80℃+的CPU温度要让人安心多了，再也不用画蛇添足地给水果派加装散热片了~ 这还是1GHz主频下的电流和发热情况，Zero可以在24MHz~1.2GHz之间以24MHz步进设置主频，如果你用24MHz或者48MHz当单片机用的话，那耗电还会低上不少！ ## 细探 Zero除了核心板本身，还设计了一系列常用的外设以及配套底板用于功能验证，在此为您细细道来。 ### TF Wifi卡 IoT大行其道的今天，联网功能也必不可少。 Zero可使用Wifi，Ethernet连入网络，还在配套演示底板上集成了Lora模块，可用作Lora网关。 出于体积考虑，Zero核心板上并未加入wifi功能，但是我专为Zero设计了小巧的tf wifi 模块，可用多种方式与Zero叠加。 下图就是TF WiFi模块： ![](./../static/start/intro_10.jpg) 模块本身使用0.8mm厚度 PCB制成，与TF卡厚度（0.75mm）极为接近，可以直接插入TF卡槽！ 注意到上图有一长一短模块，长模块是为常用的全槽TF卡槽兼容使用，短模块是为Zero上的半槽TF卡槽使用。 由于PCB仅有0.8mm厚，所以收到PCB后，只要使用剪刀沿白色丝印剪下，即可获得半槽使用的TF WiFi模块！ TF Wifi卡的多种使用方法： ![](./../static/start/intro_11.gif) #### 直插板载卡槽 > **注意Zero默认使用TF卡启动，若要使用TF插槽接TF WiFi模块，则需要从SPI Flash启动。** #### 2.54插针叠加 当使用TF卡作为启动介质而占用了板载TF卡槽时，仍可使用2.54插针轻松叠加使用！ Zero精心排布了2.54插针的引脚顺序，并在TF Wifi 模块上预留了相同顺序的2.54mm间距焊盘，因此可以直接使用2.54mm插针叠加！ > *注意右侧刚好没有和FPC40的翻盖干涉，仍可使用座子外接屏幕等外设~ * #### 直插底板的TF卡槽 底板上也预留了TF卡槽，因此选购了底板的话可以直插底板上的卡槽。 ### 通用40P RGB液晶屏 Zero采用了和One兼容的通用40P RGB液晶屏（含触摸屏），并且板载了电阻屏控制器，支持触控操作。之前买了One的液晶屏套餐的可复用之前的液晶屏。 下图是5寸 480x800高清液晶屏，另有480x272的4.3寸普清液晶屏。 ![](./../static/start/zero_7.jpg) ### RGB转VGA模块 去年年中以来，液晶屏价格暴涨，如果无法接受目前液晶屏价格的话，可以选择RGB转VGA模块，可接普通显示器使用。 ![](./../static/start/intro_13.jpg) ### RGB转HDMI模块 如果你的显示器没有VGA接口（土豪高端显示器），可选用RGB转HDMI模块，该模块可直插HDMI显示器。 > **注意：截止发稿时，笔者还没时间搞这模块的驱动，该驱动列入开发者奖励计划（详见后文）。** ![](./../static/start/intro_14.jpg) ### RGB转LVDS模块 如果你手中有闲置的笔记本显示屏（非高清，1280x800, 1366x768或更低分辨率），则可选购该模块。注意笔记本屏幕一般需要额外的LED背光电源供电。 > *该模块支持单八，单六 LVDS屏；正面FPC座为单八接口，背面为单六接口。* ![](./../static/start/intro_15.jpg) 如果你手头没有闲置笔记本液晶屏，又想尝试大屏，众筹套餐中提供了10.1寸LVDS平板屏幕，1280x800分辨率，内置led恒流升压驱动电路。 ### RGB转DVP CSI模块 Zero的DVP CSI接口引脚和RGB引脚复用，所以之前购买了One的摄像头的用户，可以使用此转接板转接原DVP接口的24Pin摄像头（OV7670，OV2640等）。 > *注意：截止发稿时，笔者还没时间搞改摄像头驱动，该驱动列入开发者奖励计划（详见后文）。* ![](./../static/start/intro_16.jpg) ### RGB转GPIO模块 如果你没用到LCD屏，又需要很多IO，则可以使用该RGB转GPIO模块，它将转出22个GPIO，以及两路ADC（使用电阻屏驱动器），和若干电源引脚。 ![](./../static/start/intro_17.jpg) ## 添翼 前面介绍的模块主要是FPC40的转接板，对于Zero上1.27邮票孔引出的其它引脚，除了可以用2.54插针偏移半位焊接引出外，也可使用配套底板（Docker）直接贴片上去，更加紧凑，也方便验证、使用各个高速接口。 Docker布局概览： ![](./../static/start/intro_18.png) 实物图镇楼： ![](./../static/start/intro_19.jpg) 底板左下方有两三排插针，分别是I2C，SPI，UART，PWM的引出插针。 右下方有四个功能按键，是使用Zero的ADC功能实现的。 右侧为usb供电口，电池接口，USB OTG口；底板的电源电路支持单节锂电池的充放电管理，以及5V升压。 右上方为内置网络变压器的RJ45接口。 > *注意到RJ45接口较高，体积较大，所以默认不焊接上去，只附上该座子，有需要验证以太网口的朋友可自行焊接；需要DIY掌上设备的朋友可留空该座来减小底板体积。* 底板上方为美标四线耳机座和高灵敏度麦克风。 底板下方配有一个24pin MIPI的摄像头座，座子为b2b连接器（axe624124）。 配套的是500W像素自动对焦的OV5648摄像头。 > *注意：截止发稿时，笔者还没时间搞这模块的驱动，该驱动列入开发者奖励计划（详见后文）。该摄像头在官方SDK里有驱动，但尚未在主线内核中适配。* ### 底板的功放模块 Zero自带CODEC，但自带的CODEC只能推动耳机，所以底板上贴的是耳机座。 考虑到用Zero做WiFi音箱或者其它自带扬声器发声的设备（如掌机？），底板上预留了功放模块的接口，即TF卡槽后面的5pin 排母。 在该接口上可堆叠PA模块，如下图所示 ![](./../static/start/intro_20.jpg) PA模块可带动3W*2个扬声器，并自带音量旋钮，适合做一些手持设备。 以下是可选配的扬声器： ![](./../static/start/intro_21.jpg) ![](./../static/start/intro_22.jpg) > *也可搭配骨传导扬声器！可做骨传导耳机或者振动音箱~* ### 底板的显示模块 底板下方有一排2.54排座，可用于插接I2C接口的OLED或者SPI接口的TFT。 0.96寸128x64 OLED: ![](./../static/start/intro_23.jpg) 1.3寸128x64 OLED: ![](./../static/start/intro_24.jpg) 2.4寸 240x320 TFT: ![](./../static/start/intro_25.jpg) ### 底板的输入设备 底板的输入除了四个ADC做的功能按键外，还可选配下小手柄/键盘。 手柄与2.4寸屏幕搭配食用风味更佳 /斜眼笑 ![](./../static/start/intro_26.gif) ### 底板的通信接口 底板上有三个通信接口，分别是TF Wifi卡接口，RJ45 以太网接口，和Lora模块接口。 前面介绍的TF Wifi卡插底板的示意图： ![](./../static/start/intro_27.jpg) 底板背面的Lora模块示意图： ![](./../static/start/intro_28.jpg) Lora模块本身可以全双工，但是Zero作为网关使用时，底部Lora模块配置为一发一收，可以显著降低丢包率。 Lora网关的相关参数为： 1. 星形拓扑，空旷通信距离15km 2. xxx ### 底板的语音助手外设 底板的耳机口可外接麦克风阵列模块，实现远场语音识别（声源单位，波束成型），阵列模块自带关键词唤醒功能。 麦克风阵列模块默认搭配高灵敏度驻极体麦克风，可选配硅麦克（一致性好） ![](./../static/start/intro_29.png) 麦克风阵列的主要参数为： 1. 板载6颗驻极体/硅麦克，24颗LED，可选配OLED 2. 声源定位精度优于15°，板上LED或者OLED指示方位 3. 消除混响，500ms以内室内混响 4. 波束成形，可指定6方位波束成形，具有噪声抑制和语音增强功能，室内环境下语音识别距离约5m。 5. 关键词唤醒，可设定自定义关键词唤醒（使用拼音配置，方便快捷，无需上传服务器计算特征码），引脚输出唤醒边沿。 6. 一路模拟音频输出，一路I2S数字音频输出。 7. 可使用I2C/UART配置模块参数，读取信息（声源角度等） ## 惊艳 Zero核心板或者配套底板还可选配无线键鼠与锂电池，搭配定制的LCD转轴支架，简单组装即成一台迷你笔记本！ > *注：Zero底板具有锂电池充放电管理功能；Zero核心板不可直接给锂电池充电。* 使用Zero核心板制作的简易“笔记本电脑”，只需一块电池，一个屏幕，一个无线键鼠。 ![](./../static/start/intro_29.jpg) Zero开启debian桌面系统 ![](./../static/start/intro_30.jpg) ![](./../static/start/intro_31.jpg) 回顾GBA经典游戏 ![](./../static/start/intro_32.jpg) Zero畅玩经典游戏DOOM！ ![](./../static/start/intro_33.jpg) 荔枝派Zero还可以运行树莓派系统！原来你是披着树莓皮的的荔枝派！ > 注：Zero由于内存限制，运行树莓派系统会较为卡顿。 ![](./../static/start/intro_34.jpg) 开启键盘夜光的靓图！是不是有大牌范呢？ ![](./../static/start/intro_35.jpg) ![](./../static/start/intro_36.jpg) 详情还可戳 [视频演示](http://v.youku.com/v_show/id_XMjYwNzkyOTM1Ng .html?spm a2hzp.8244740.userfeed.5!2~5~5~5!3~5~A) 欣赏喔~ ## 未完待续 配件全家福（貌似还漏了个别配件） ![](./../static/start/zero_8.jpg)"},"/soft/Lichee/zh/Zero-Doc/Start/use_board.html":{"title":"开箱使用","content":"# 开箱使用 > 编辑于2022.06.15 ## 准备系统存储介质 前面有一个章节已经介绍烧录镜像了，这里就不重复了。 ## 焊接排针 使用的话就要焊接排针与电脑通信，然后进行相关操作会方便得多。 默认使用串口0来进行通信的，对应在板子上的 U0T R 引脚。 ## 启动系统 把 TF 卡插进板子，然后连接好串口（gnd也连一下），打开串口工具。给板子上电。 我们就可以在串口终端里看到板子的打印信息了。 ```bash U Boot SPL 2017.01 rc2 00073 gdd6e874 dirty (Nov 09 2021 06:26:31) DRAM: 64 MiB Trying to boot from MMC1 U Boot 2017.01 rc2 00073 gdd6e874 dirty (Nov 09 2021 06:26:31 +0000) Allwinner Technology CPU: Allwinner V3s (SUN8I 1681) Model: Lichee Pi Zero DRAM: 64 MiB ``` 接着就会到登陆选项 ```bash Welcome to licheepi licheepi login: Password: ``` 对于在前面使用的名为 Zero_pub_V0.3.gz 的镜像，用户名和密码分别是 `root` 和 `licheepi` 。 对于使用 debian 镜像的，用户名为 `root`，密码为 `toortoor` 。 要知道输密码的时候是没有输入回显的，所以不要问为什么输密码没有反应了 ### 使用 对于 Zero_pub_V0.3.gz 镜像登陆进去后有如下文件: ```bash licheepi# ls l total 18356 rw r r 1 root root 13727311 Nov 9 2021 badapple.mp4 rwxr r 1 root root 2837888 Nov 9 2021 demo rwxr r 1 root root 25318 Nov 9 2021 gpiod 1.5.0.tar.gz rwxr xr x 1 root root 2187328 Nov 9 2021 maix_asr rw r r 1 root root 60 Nov 9 2021 readme drwxr xr x 5 root root 4096 Nov 9 2021 test_files ``` 我们可以直接运行 demo 程序，然后在配套的 rgb 屏幕上看到图案。 ```bash licheepi# ./demo The framebuffer device was opened successfully. 800x480, 32bpp The framebuffer device was mapped to memory successfully. ``` 从上面的信息可以看到之分辨率为 480\\*800 的图形。因此要是在480\\*272的屏幕中会显示不全 ![](./../static/start/800_400_zero_lvgl_demo.png) 关于其他的使用会在后序章节中提到。"},"/soft/Lichee/zh/Zero-Doc/System_Development/SPI_flash_build.html":{"title":"SPI Flash 系统编译","content":" title: SPI Flash 系统编译 在一些低成本应用场景，需要在SPI flash上启动系统，这需要对Uboot和系统镜像做些适配。 本文介绍SPI Flash镜像的制作过程。 ## Flash分区规划 这里 使用 MX25L25645G, **32M SPI flash** 作为启动介质，规划分区如下： ## Uboot编译配置 由于目前Uboot环境变量固定存放在1MB位置之内，所有留给uboot的空间固定到flash前1MB的位置不变。 每个分区的大小必须是擦除块大小的整数倍，MX25L25645G的擦除块大小是64KB。 ### 准备uboot 下载包含spi驱动的体验版本uboot，该驱动目前尚未合并到主线 > `git clone b v3s spi experimental https://github.com/Lichee Pi/u boot.git` ### 配置Flash支持型号 执行 `make ARCH arm menuconfig` 打开uboot菜单配置，进入到 Device Drivers \\> SPI Flash Support 注意看一下自己flash的厂家名称，例如选上Macronix SPI flash support用来支持测试用的flash：MX25L25645G。 如果使用的是16MB以上的flash，需要勾选flash bank支持选项，否则最多只能读到16MB： **CONFIG\\_SPI\\_FLASH\\_BAR** ### 配置uboot默认环境变量 在文件 **include/configs/sun8i.h** 中添加默认bootcmd和bootargs的环境变量设置，注意添加的位置在“#include &#60;configs/sunxi common.h&#62; ”的前边。 ![](./../static/System_Development/uboot_conf_4.jpg) ``` #define CONFIG_BOOTCOMMAND \"sf probe 0; \" \\ \"sf read 0x41800000 0x100000 0x10000; \" \\ \"sf read 0x41000000 0x110000 0x400000; \" \\ \"bootz 0x41000000 0x41800000\" #define CONFIG_BOOTARGS \"console ttyS0,115200 earlyprintk panic 5 rootwait \" \\ \"mtdparts spi32766.0:1M(uboot)ro,64k(dtb)ro,4M(kernel)ro, (rootfs) root 31:03 rw rootfstype jffs2\" ``` 环境命令解析： sf probe 0; //初始化Flash设备（CS拉低） sf read 0x41800000 0x100000 0x10000;//从flash0x100000（1MB）位置读取dtb放到内存0x41800000偏移处。//如果是bsp的bin，则是0x41d00000 sf read 0x41000000 0x110000 0x400000;//从flash0x110000（1MB+64KB）位置读取dtb放到内存0x41000000偏移处。 bootz 0x41000000 （内核地址） 0x41800000（dtb地址） 启动内核 启动参数解析: console ttyS0,115200 earlyprintk panic 5 rootwait//在串口0上输出信息 mtdparts spi32766.0:1M(uboot)ro,64k(dtb)ro,4M(kernel)ro, (rootfs) root 31:03 rw rootfstype jffs2 //spi32766.0是设备名，后面是分区大小，名字，读写属性。 root 31:03表示根文件系统是mtd3；jffs2格式 ### 编译uboot ``` time make ARCH arm CROSS_COMPILE arm linux gnueabihf 2>&1 tee build.log ``` 会在目录下生成 *u boot sunxi with spl.bin* ## linux内核编译配置 linux内核基于github上的版<a href \"https://github.com/Lichee Pi/linux.git\" target \"_blank\">https://github.com/Lichee Pi/linux.git</a>，分支为最新的zero 4.13.y ### 内核选项配置 执行 `make ARCH arm menuconfig` 打开内核菜单配置， 进入到 Device Drivers > Memory Technology Device (MTD) support ， 确保选择上mtd的 **<*> Command line partition table parsing** 支持，该项目用来解析uboot传递过来的flash分区信息。 以及SPI NOR 设备的支持。 ![](./../static/System_Development/uboot_conf_5.jpg) 添加对jffs2文件系统的支持，路径在 File systems \\> Miscellaneous filesystems \\> Journalling Flash File System v2 (JFFS2) support ![](./../static/System_Development/uboot_conf_6.png) ### 设备树配置 修改dts配置添加spi flash节点 > `vi arch/arm/boot/dts/sun8i v3s licheepi zero.dts` 添加spi节点配置: ``` &spi0 { status \"okay\"; mx25l25635e:mx25l25635e@0 { compatible \"jedec,spi nor\"; reg <0x0>; spi max frequency <50000000>; #address cells <1>; #size cells <1>; }; }; ``` ![](./../static/System_Development/uboot_conf_7.jpg) 这里的flash型号需要在下表之中，否则将无法识别：（注意容量也一定要对应） ``` static const struct spi_device_id m25p_ids[] { /* * Allow non DT platform devices to bind to the \"spi nor\" modalias, and * hack around the fact that the SPI core does not provide uevent * matching for .of_match_table */ {\"spi nor\"}, /* * Entries not used in DTs that should be safe to drop after replacing * them with \"spi nor\" in platform data. */ {\"s25sl064a\"}, {\"w25x16\"}, {\"m25p10\"}, {\"m25px64\"}, /* * Entries that were used in DTs without \"jedec,spi nor\" fallback and * should be kept for backward compatibility. */ {\"at25df321a\"}, {\"at25df641\"}, {\"at26df081a\"}, {\"mx25l4005a\"}, {\"mx25l1606e\"}, {\"mx25l6405d\"}, {\"mx25l12805d\"}, {\"mx25l25635e\"},{\"mx66l51235l\"}, {\"n25q064\"}, {\"n25q128a11\"}, {\"n25q128a13\"}, {\"n25q512a\"}, {\"s25fl256s1\"}, {\"s25fl512s\"}, {\"s25sl12801\"}, {\"s25fl008k\"}, {\"s25fl064k\"}, {\"sst25vf040b\"},{\"sst25vf016b\"},{\"sst25vf032b\"},{\"sst25wf040\"}, {\"m25p40\"}, {\"m25p80\"}, {\"m25p16\"}, {\"m25p32\"}, {\"m25p64\"}, {\"m25p128\"}, {\"w25x80\"}, {\"w25x32\"}, {\"w25q32\"}, {\"w25q32dw\"}, {\"w25q80bl\"}, {\"w25q128\"}, {\"w25q256\"}, /* Flashes that can't be detected using JEDEC */ {\"m25p05 nonjedec\"}, {\"m25p10 nonjedec\"}, {\"m25p20 nonjedec\"}, {\"m25p40 nonjedec\"}, {\"m25p80 nonjedec\"}, {\"m25p16 nonjedec\"}, {\"m25p32 nonjedec\"}, {\"m25p64 nonjedec\"}, {\"m25p128 nonjedec\"}, /* Everspin MRAMs (non JEDEC) */ { \"mr25h256\" }, /* 256 Kib, 40 MHz */ { \"mr25h10\" }, /* 1 Mib, 40 MHz */ { \"mr25h40\" }, /* 4 Mib, 40 MHz */ { }, }; ``` ``` make ARCH arm CROSS_COMPILE arm linux gnueabihf j32 make ARCH arm CROSS_COMPILE arm linux gnueabihf dtbs ``` ## 准备镜像文件 ### 下载根文件系统 首先选择rootfs文件系统，我是用的是群朋提供的最小根文件系统 *rootfs brmin.tar.gz*，大小只有3M左右，下载地址在 https://pan.baidu.com/share/link? shareid 1432204556&uk 3658413294#list/path %2F Lichee Zero>zero_imager.zip ### 制作jffs2文件系统 Flash支持jffs2文件系统格式，所以需要使用此该rootfs制作jffs2文件系统镜像、 下载jffs2文件系统制作工具 > `apt get install mtd utils` 解压 rootfs brmin.tar.gz > `tar xzvf rootfs brmin.tar.gz` 计算好jffs的大小，可以使用zero\\_imager里的 **make\\_jffs2.sh 32** 生成 总空间是32M 1M 64K 4M 0x1AF0000 > `mkfs.jffs2 s 0x100 e 0x10000 p 0x1AF0000 d rootfs/ o jffs2.img` 页大小0x100 256字节 块大小0x10000 64k jffs2分区总空间0x1AF0000 jffs2.img是生成的文件系统镜像。 最后将uboot，dtb，kernel，rootfs打包成一个系统镜像，命令如下;（即zero_imager里的 *make_spiflash.sh 32 dock*） ``` #!/bin/sh dd if /dev/zero of flashimg.bin bs 1M count $1 dd if u boot sunxi with spl $2.bin of flashimg.bin bs 1K conv notrunc dd if sun8i v3s licheepi zero $2.dtb of flashimg.bin bs 1K seek 1024 conv notrunc dd if zImage of flashimg.bin bs 1K seek 1088 conv notrunc dd if jffs2.img of flashimg.bin bs 1K seek 5184 conv notrunc ``` 第一步： 生成一个空文件，大小是32MB\\ 第二步： 将uboot添加到文件开头\\ 第三步： 将dtb放到1M偏移处\\ 第四步： 将kernel放到1M+64K偏移处 第五步： 将rootfs放到1M+64K+4M偏移处 偏移大小是seek，单位是KB。 执行完毕后生成镜像文件 **flashimg.bin** ## 烧写镜像 ### 下载sunxiflash烧写工具 git clone b spi rebase https://github.com/Icenowy/sunxi tools.git > 注意是spi rebase分支。 进入工具目录执行 `make && sudo make install` 如果出现：\\*fel\\_lib.c:26:20: fatal error: libusb.h: No such file or directory\\*，那需要安装libusb： `sudo apt get install libusb 1.0 0 dev` ### 进入fel模式 Zero有一个usb下载模式称为fel模式，进入fel模式有下面几种方式： 1. TF卡和spi flash 同时没有可启动镜像 也就是说你不插卡，且焊接的是新的或者没有有效镜像的spi flash，那就上电自动进入fel下载模式 2. TF卡中有进入fel模式的特殊固件 **fel sdboot.sunxi** 如果你的spiflash已经有了启动镜像，那么需要在TF卡中烧入一个sunxi提供的启动工具 （`dd if fel sdboot.sunxi of /dev/mmcblk0 bs 1024 seek 8` ），那么插入该TF卡启动会进入fel模式； 3. 上电时SPI_MISO拉低到地 该引脚为boot引脚，上电时出于低电平即会进入fel下载模式。 ### sunxi fel的操作 进入fel模式后使用usb数据线连接pc和zero,即可进行操作。 ``` sudo sunxi fel version #查看连接的cpu信息 AWUSBFEX soc 00001681(V3s) 00000001 ver 0001 44 08 scratchpad 00007e00 00000000 00000000 sudo sunxi fel spiflash info #显示flash信息 Manufacturer: Unknown (C2h), model: 20h, size: 33554432 bytes. ``` 执行如下命令烧入我们前边制作好的镜像文件 ``` sudo sunxi fel p spiflash write 0 flashimg.bin # p 显示进度条 # spiflash info Retrieves basic information # spiflash hex[dump] addr length Dumps SPI flash region in hex # spiflash read addr length file Write SPI flash contents into file # spiflash write addr file Store file contents into SPI flash ``` ![](./../static/System_Development/uboot_conf_8.jpg) SPI flash下载速度约50KB/s，等待5分钟（16MB）或者10分钟（32MB），烧写完成，如果一切顺利，重新上电zero那么就会进入linux系统了，账号是root没有密码。 ![](./../static/System_Development/uboot_conf_9.jpg) ## 附录： 启动日志 U Boot SPL 2017.01 rc2 00073 gdd6e874 dirty (Oct 14 2017 16:33:01) DRAM: 64 MiB Trying to boot from sunxi SPI U Boot 2017.01 rc2 00073 gdd6e874 dirty (Oct 14 2017 16:33:01 +0000) Allwinner Technology CPU: Allwinner V3s (SUN8I 1681) Model: Lichee Pi Zero DRAM: 64 MiB MMC: SUNXI SD/MMC: 0 SF: Detected mx25l25635f with page size 256 Bytes, erase size 64 KiB, total 32 MiB *** Warning bad CRC, using default environment Setting up a 800x480 lcd console (overscan 0x0) dotclock: 33000kHz 33000kHz: (1 * 3MHz * 66) / 6 In: serial@01c28000 Out: serial@01c28000 Err: serial@01c28000 U Boot 2017.01 rc2 00073 gdd6e874 dirty (Oct 14 2017 16:33:01 +0000) Allwinner Technology CPU: Allwinner V3s (SUN8I 1681) Model: Lichee Pi Zero DRAM: 64 MiB MMC: SUNXI SD/MMC: 0 SF: Detected mx25l25635f with page size 256 Bytes, erase size 64 KiB, total 32 MiB *** Warning bad CRC, using default environment Setting up a 800x480 lcd console (overscan 0x0) dotclock: 33000kHz 33000kHz: (1 * 3MHz * 66) / 6 In: serial@01c28000 Out: serial@01c28000 Err: serial@01c28000 Net: No ethernet found. starting USB No controllers found Hit any key to stop autoboot: 0 SF: Detected mx25l25635f with page size 256 Bytes, erase size 64 KiB, total 32 MiB device 0 offset 0x100000, size 0x10000 SF: 65536 bytes @ 0x100000 Read: OK device 0 offset 0x110000, size 0x400000 SF: 4194304 bytes @ 0x110000 Read: OK ## Flattened Device Tree blob at 41800000 Booting using the fdt blob at 0x41800000 Loading Device Tree to 42dfa000, end 42dffc48 OK Starting kernel [ 0.000000] Booting Linux on physical CPU 0x0 [ 0.000000] Linux version 4.13.0 licheepi zero+ (root@bf756b445919) (gcc version 6.3.1 20170404 (Linaro GCC 6.3 2017.05)) #10 SMP Sat Oct 14 16:59:37 UTC 2017 [ 0.000000] CPU: ARMv7 Processor [410fc075] revision 5 (ARMv7), cr 10c5387d [ 0.000000] CPU: div instructions available: patching division code [ 0.000000] CPU: PIPT / VIPT nonaliasing data cache, VIPT aliasing instruction cache [ 0.000000] OF: fdt: Machine model: Lichee Pi Zero XFJ [ 0.000000] Memory policy: Data cache writealloc [ 0.000000] percpu: Embedded 16 pages/cpu @c3de6000 s33868 r8192 d23476 u65536 [ 0.000000] Built 1 zonelists in Zone order, mobility grouping on. Total pages: 15883 [ 0.000000] Kernel command line: console ttyS0,115200 earlyprintk panic 5 rootwait mtdparts spi32766.0:1M(uboot)ro,64k(dtb)ro,4M(kernel)ro, (rootfs) root 31:03 rw rootfstype jffs2 [ 0.000000] PID hash table entries: 256 (order: 2, 1024 bytes) [ 0.000000] Dentry cache hash table entries: 8192 (order: 3, 32768 bytes) [ 0.000000] Inode cache hash table entries: 4096 (order: 2, 16384 bytes) [ 0.000000] Memory: 53576K/64036K available (6144K kernel code, 229K rwdata, 1512K rodata, 1024K init, 265K bss, 10460K reserved, 0K cma reserved, 0K highmem) [ 0.000000] Virtual kernel memory layout: [ 0.000000] vector : 0xffff0000 0xffff1000 ( 4 kB) [ 0.000000] fixmap : 0xffc00000 0xfff00000 (3072 kB) [ 0.000000] vmalloc : 0xc4000000 0xff800000 ( 952 MB) [ 0.000000] lowmem : 0xc0000000 0xc3e89000 ( 62 MB) [ 0.000000] pkmap : 0xbfe00000 0xc0000000 ( 2 MB) [ 0.000000] modules : 0xbf000000 0xbfe00000 ( 14 MB) [ 0.000000] .text : 0xc0008000 0xc0700000 (7136 kB) [ 0.000000] .init : 0xc0900000 0xc0a00000 (1024 kB) [ 0.000000] .data : 0xc0a00000 0xc0a39580 ( 230 kB) [ 0.000000] .bss : 0xc0a3f65c 0xc0a81b54 ( 266 kB) [ 0.000000] SLUB: HWalign 64, Order 0 3, MinObjects 0, CPUs 1, Nodes 1 [ 0.000000] Hierarchical RCU implementation. [ 0.000000] RCU event tracing is enabled. [ 0.000000] RCU restricting CPUs from NR_CPUS 8 to nr_cpu_ids 1. [ 0.000000] RCU: Adjusting geometry for rcu_fanout_leaf 16, nr_cpu_ids 1 [ 0.000000] NR_IRQS: 16, nr_irqs: 16, preallocated irqs: 16 [ 0.000000] arch_timer: cp15 timer(s) running at 24.00MHz (virt). [ 0.000000] clocksource: arch_sys_counter: mask: 0xffffffffffffff max_cycles: 0x588fe9dc0, max_idle_ns: 440795202592 ns [ 0.000008] sched_clock: 56 bits at 24MHz, resolution 41ns, wraps every 4398046511097ns [ 0.000019] Switching to timer based delay loop, resolution 41ns [ 0.000187] clocksource: timer: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 79635851949 ns [ 0.000420] Console: colour dummy device 80x30 [ 0.000457] Calibrating delay loop (skipped), value calculated using timer frequency.. 48.00 BogoMIPS (lpj 240000) [ 0.000475] pid_max: default: 32768 minimum: 301 [ 0.000604] Mount cache hash table entries: 1024 (order: 0, 4096 bytes) [ 0.000619] Mountpoint cache hash table entries: 1024 (order: 0, 4096 bytes) [ 0.001213] CPU: Testing write buffer coherency: ok [ 0.001589] /cpus/cpu@0 missing clock frequency property [ 0.001612] CPU0: thread 1, cpu 0, socket 0, mpidr 80000000 [ 0.002074] Setting up static identity map for 0x40100000 0x40100060 [ 0.002259] Hierarchical SRCU implementation. [ 0.002765] smp: Bringing up secondary CPUs [ 0.002781] smp: Brought up 1 node, 1 CPU [ 0.002790] SMP: Total of 1 processors activated (48.00 BogoMIPS). [ 0.002797] CPU: All CPU(s) started in SVC mode. [ 0.003559] devtmpfs: initialized [ 0.006668] VFP support v0.3: implementor 41 architecture 2 part 30 variant 7 rev 5 [ 0.006932] clocksource: jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 19112604462750000 ns [ 0.006967] futex hash table entries: 256 (order: 2, 16384 bytes) [ 0.007136] pinctrl core: initialized pinctrl subsystem [ 0.008026] random: get_random_u32 called from bucket_table_alloc+0xf4/0x244 with crng_init 0 [ 0.008162] NET: Registered protocol family 16 [ 0.008655] DMA: preallocated 256 KiB pool for atomic coherent allocations [ 0.009800] hw breakpoint: found 5 (+1 reserved) breakpoint and 4 watchpoint registers. [ 0.009817] hw breakpoint: maximum watchpoint size is 8 bytes. [ 0.023260] SCSI subsystem initialized [ 0.023562] usbcore: registered new interface driver usbfs [ 0.023652] usbcore: registered new interface driver hub [ 0.023747] usbcore: registered new device driver usb [ 0.023983] Linux video capture interface: v2.00 [ 0.024036] pps_core: LinuxPPS API ver. 1 registered [ 0.024044] pps_core: Software ver. 5.3.6 Copyright 2005 2007 Rodolfo Giometti <giometti@linux.it> [ 0.024064] PTP clock support registered [ 0.024282] Advanced Linux Sound Architecture Driver Initialized. [ 0.024955] Bluetooth: Core ver 2.22 [ 0.025029] NET: Registered protocol family 31 [ 0.025037] Bluetooth: HCI device and connection manager initialized [ 0.025056] Bluetooth: HCI socket layer initialized [ 0.025066] Bluetooth: L2CAP socket layer initialized [ 0.025097] Bluetooth: SCO socket layer initialized [ 0.026313] clocksource: Switched to clocksource arch_sys_counter [ 0.037157] NET: Registered protocol family 2 [ 0.037746] TCP established hash table entries: 1024 (order: 0, 4096 bytes) [ 0.037780] TCP bind hash table entries: 1024 (order: 1, 8192 bytes) [ 0.037803] TCP: Hash tables configured (established 1024 bind 1024) [ 0.037937] UDP hash table entries: 256 (order: 1, 8192 bytes) [ 0.037985] UDP Lite hash table entries: 256 (order: 1, 8192 bytes) [ 0.038205] NET: Registered protocol family 1 [ 0.038812] RPC: Registered named UNIX socket transport module. [ 0.038833] RPC: Registered udp transport module. [ 0.038840] RPC: Registered tcp transport module. [ 0.038846] RPC: Registered tcp NFSv4.1 backchannel transport module. [ 0.040940] workingset: timestamp_bits 30 max_order 14 bucket_order 0 [ 0.048568] NFS: Registering the id_resolver key type [ 0.048618] Key type id_resolver registered [ 0.048627] Key type id_legacy registered [ 0.048672] jffs2: version 2.2. (NAND) © 2001 2006 Red Hat, Inc. [ 0.050140] random: fast init done [ 0.053091] Block layer SCSI generic (bsg) driver version 0.4 loaded (major 249) [ 0.053111] io scheduler noop registered [ 0.053118] io scheduler deadline registered [ 0.053358] io scheduler cfq registered (default) [ 0.053368] io scheduler mq deadline registered [ 0.053376] io scheduler kyber registered [ 0.057981] sun8i v3s pinctrl 1c20800.pinctrl: initialized sunXi PIO driver [ 0.058417] name allwinner,sun7i a20 pwm [ 0.058432] npwm 2 [ 0.127969] Serial: 8250/16550 driver, 8 ports, IRQ sharing disabled [ 0.131445] console [ttyS0] disabled [ 0.151721] 1c28000.serial: ttyS0 at MMIO 0x1c28000 (irq 33, base_baud 1500000) is a U6_16550A [ 0.780269] console [ttyS0] enabled [ 0.805297] 1c28400.serial: ttyS1 at MMIO 0x1c28400 (irq 34, base_baud 1500000) is a U6_16550A [ 0.835807] 1c28800.serial: ttyS2 at MMIO 0x1c28800 (irq 35, base_baud 1500000) is a U6_16550A [ 0.848508] libphy: Fixed MDIO Bus: probed [ 0.853001] usbcore: registered new interface driver r8152 [ 0.858614] ehci_hcd: USB 2.0 'Enhanced' Host Controller (EHCI) Driver [ 0.865135] ehci platform: EHCI generic platform driver [ 0.870676] ehci platform 1c1a000.usb: EHCI Host Controller [ 0.876350] ehci platform 1c1a000.usb: new USB bus registered, assigned bus number 1 [ 0.884288] ehci platform 1c1a000.usb: irq 25, io mem 0x01c1a000 [ 0.916344] ehci platform 1c1a000.usb: USB 2.0 started, EHCI 1.00 [ 0.923490] hub 1 0:1.0: USB hub found [ 0.927421] hub 1 0:1.0: 1 port detected [ 0.931878] ohci_hcd: USB 1.1 'Open' Host Controller (OHCI) Driver [ 0.938171] ohci platform: OHCI generic platform driver [ 0.943713] ohci platform 1c1a400.usb: Generic Platform OHCI controller [ 0.950433] ohci platform 1c1a400.usb: new USB bus registered, assigned bus number 2 [ 0.958360] ohci platform 1c1a400.usb: irq 26, io mem 0x01c1a400 [ 1.031375] hub 2 0:1.0: USB hub found [ 1.035198] hub 2 0:1.0: 1 port detected [ 1.042745] udc core: couldn't find an available UDC added [g_ether] to list of pending drivers [ 1.052618] sun6i rtc 1c20400.rtc: rtc core: registered rtc sun6i as rtc0 [ 1.059513] sun6i rtc 1c20400.rtc: RTC enabled [ 1.064048] i2c /dev entries driver [ 1.069222] usbcore: registered new interface driver uvcvideo [ 1.074974] USB Video Class driver (1.1.1) [ 1.079833] sunxi wdt 1c20ca0.watchdog: Watchdog enabled (timeout 16 sec, nowayout 0) [ 1.087825] Bluetooth: HCI UART driver ver 2.3 [ 1.092273] Bluetooth: HCI UART protocol Three wire (H5) registered [ 1.156357] sunxi mmc 1c0f000.mmc: base:0xc407b000 irq:23 [ 1.162805] usbcore: registered new interface driver usbhid [ 1.168456] usbhid: USB HID core driver [ 1.174122] NET: Registered protocol family 17 [ 1.178794] Key type dns_resolver registered [ 1.183228] Registering SWP/SWPB emulation handler [ 1.193806] simple framebuffer 43e89000.framebuffer: framebuffer at 0x43e89000, 0x177000 bytes, mapped to 0xc4400000 [ 1.204454] simple framebuffer 43e89000.framebuffer: format x8r8g8b8, mode 800x480x32, linelength 3200 [ 1.222854] Console: switching to colour frame buffer device 100x30 [ 1.235317] simple framebuffer 43e89000.framebuffer: fb0: simplefb registered! [ 1.243916] usb_phy_generic usb_phy_generic.0.auto: usb_phy_generic.0.auto supply vcc not found, using dummy regulator [ 1.255346] musb hdrc musb hdrc.1.auto: MUSB HDRC host driver [ 1.261186] musb hdrc musb hdrc.1.auto: new USB bus registered, assigned bus number 3 [ 1.270315] hub 3 0:1.0: USB hub found [ 1.274184] hub 3 0:1.0: 1 port detected [ 1.279498] using random self ethernet address [ 1.283985] using random host ethernet address [ 1.289160] usb0: HOST MAC 8e:ca:5f:61:47:a8 [ 1.293475] usb0: MAC f2:57:f4:ad:74:af [ 1.297416] using random self ethernet address [ 1.301858] using random host ethernet address [ 1.306400] g_ether gadget: Ethernet Gadget, version: Memorial Day 2008 [ 1.313010] g_ether gadget: g_ether ready [ 1.317402] sun6i rtc 1c20400.rtc: setting system clock to 1970 01 01 00:56:52 UTC (3412) [ 1.325834] vcc3v0: disabling [ 1.328911] vcc5v0: disabling [ 1.331879] ALSA device list: [ 1.334841] No soundcards found. [ 1.339241] VFS: Cannot open root device \"31:03\" or unknown block(31,3): error 19 [ 1.346938] Please append a correct \"root \" boot option; here are the available partitions: [ 1.355286] Kernel panic not syncing: VFS: Unable to mount root fs on unknown block(31,3) [ 1.363630] CPU: 0 PID: 1 Comm: swapper/0 Not tainted 4.13.0 licheepi zero+ #10 [ 1.370926] Hardware name: Allwinner sun8i Family [ 1.375664] [<c010e58c>] (unwind_backtrace) from [<c010b2b0>] (show_stack+0x10/0x14) [ 1.383408] [<c010b2b0>] (show_stack) from [<c06923dc>] (dump_stack+0x84/0x98) [ 1.390632] [<c06923dc>] (dump_stack) from [<c011b728>] (panic+0xdc/0x248) [ 1.397507] [<c011b728>] (panic) from [<c09011d0>] (mount_block_root+0x188/0x25c) [ 1.404985] [<c09011d0>] (mount_block_root) from [<c09013c4>] (mount_root+0x120/0x128) [ 1.412894] [<c09013c4>] (mount_root) from [<c090151c>] (prepare_namespace+0x150/0x194) [ 1.420891] [<c090151c>] (prepare_namespace) from [<c0900e20>] (kernel_init_freeable+0x1bc/0x1cc) [ 1.429755] [<c0900e20>] (kernel_init_freeable) from [<c06a514c>] (kernel_init+0x8/0x108) [ 1.437927] [<c06a514c>] (kernel_init) from [<c0107638>] (ret_from_fork+0x14/0x3c) [ 1.445499] Rebooting in 5 seconds.. U Boot SPL 2017.01 rc2 00073 gdd6e874 dirty (Nov 26 2017 15:10:41) DRAM: 64 MiB Trying to boot from sunxi SPICPU: Allwinner V3s (SUN8I 1681) Model: Lichee Pi Zero DRAM: 64 MiB MMC: SUNXI SD/MMC: 0 SF: Detected w25q128bv with page size 256 Bytes, erase size 64 KiB, total 16 MiB *** Warning bad CRC, using default environment Setting up a 800x480 lcd console (overscan 0x0) dotclock: 27000kHz 27000kHz: (1 * 3MHz * 54) / 6 beep 0 beep 1 beep 0 beep 1 beep 0 beep 1 In: serial@01c28000 Out: serial@01c28000 Err: serial@01c28000 CPU: Allwinner V3s (SUN8I 1681) Model: Lichee Pi Zero DRAM: 64 MiB MMC: SUNXI SD/MMC: 0 SF: Detected w25q128bv with page size 256 Bytes, erase size 64 KiB, total 16 MiB *** Warning bad CRC, using default environment Setting up a 800x480 lcd console (overscan 0x0) dotclock: 27000kHz 27000kHz: (1 * 3MHz * 54) / 6 beep 0 beep 1 beep 0 beep 1 beep 0 beep 1 In: serial@01c28000 Out: serial@01c28000 Err: serial@01c28000 Net: No ethernet found. starting USB No controllers found Hit any key to stop autoboot: 0 SF: Detected w25q128bv with page size 256 Bytes, erase size 64 KiB, total 16 MiB device 0 offset 0x100000, size 0x10000 SF: 65536 bytes @ 0x100000 Read: OK device 0 offset 0x110000, size 0x400000 SF: 4194304 bytes @ 0x110000 Read: OK ## Flattened Device Tree blob at 41800000 Booting using the fdt blob at 0x41800000 Loading Device Tree to 42dfa000, end 42dffbfa OK Starting kernel [ 0.000000] Booting Linux on physical CPU 0x0 [ 0.000000] Linux version 4.13.0 licheepi zero+ (root@bf756b445919) (gcc version 6.3.1 20170404 (Linaro GCC 6.3 2017.05)) #95 SMP Mon Nov 27 01:20:31 UTC 2017 [ 0.000000] CPU: ARMv7 Processor [410fc075] revision 5 (ARMv7), cr 10c5387d [ 0.000000] CPU: div instructions available: patching division code [ 0.000000] CPU: PIPT / VIPT nonaliasing data cache, VIPT aliasing instruction cache [ 0.000000] OF: fdt: Machine model: Lichee Pi Zero XFJ [ 0.000000] Memory policy: Data cache writealloc [ 0.000000] percpu: Embedded 15 pages/cpu @c3de7000 s32588 r8192 d20660 u61440 [ 0.000000] Built 1 zonelists in Zone order, mobility grouping on. Total pages: 15883 [ 0.000000] Kernel command line: console ttyS0,115200 earlyprintk panic 5 rootwait mtdparts spi32766.0:1M(uboot)ro,64k(dtb)ro,4M(kernel)ro, (rootfs) root 31:03 rw rootfstype jffs2 [ 0.000000] PID hash table entries: 256 (order: 2, 1024 bytes) [ 0.000000] Dentry cache hash table entries: 8192 (order: 3, 32768 bytes) [ 0.000000] Inode cache hash table entries: 4096 (order: 2, 16384 bytes) [ 0.000000] Memory: 55708K/64036K available (4096K kernel code, 187K rwdata, 1144K rodata, 1024K init, 232K bss, 8328K reserved, 0K cma reserved, 0K highmem) [ 0.000000] Virtual kernel memory layout: [ 0.000000] vector : 0xffff0000 0xffff1000 ( 4 kB) [ 0.000000] fixmap : 0xffc00000 0xfff00000 (3072 kB) [ 0.000000] vmalloc : 0xc4000000 0xff800000 ( 952 MB) [ 0.000000] lowmem : 0xc0000000 0xc3e89000 ( 62 MB) [ 0.000000] pkmap : 0xbfe00000 0xc0000000 ( 2 MB) [ 0.000000] modules : 0xbf000000 0xbfe00000 ( 14 MB) [ 0.000000] .text : 0xc0008000 0xc0500000 (5088 kB) [ 0.000000] .init : 0xc0700000 0xc0800000 (1024 kB) [ 0.000000] .data : 0xc0800000 0xc082ee00 ( 188 kB) [ 0.000000] .bss : 0xc08332d0 0xc086d584 ( 233 kB) [ 0.000000] SLUB: HWalign 64, Order 0 3, MinObjects 0, CPUs 1, Nodes 1 [ 0.000000] Hierarchical RCU implementation. [ 0.000000] RCU event tracing is enabled. [ 0.000000] RCU restricting CPUs from NR_CPUS 8 to nr_cpu_ids 1. [ 0.000000] RCU: Adjusting geometry for rcu_fanout_leaf 16, nr_cpu_ids 1 [ 0.000000] NR_IRQS: 16, nr_irqs: 16, preallocated irqs: 16 [ 0.000000] arch_timer: cp15 timer(s) running at 24.00MHz (virt). [ 0.000000] clocksource: arch_sys_counter: mask: 0xffffffffffffff max_cycles: 0x588fe9dc0, max_idle_ns: 440795202592 ns [ 0.000009] sched_clock: 56 bits at 24MHz, resolution 41ns, wraps every 4398046511097ns [ 0.000024] Switching to timer based delay loop, resolution 41ns [ 0.000214] clocksource: timer: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 79635851949 ns [ 0.000465] Console: colour dummy device 80x30 [ 0.000506] Calibrating delay loop (skipped), value calculated using timer frequency.. 48.00 BogoMIPS (lpj 240000) [ 0.000525] pid_max: default: 32768 minimum: 301 [ 0.000672] Mount cache hash table entries: 1024 (order: 0, 4096 bytes) [ 0.000692] Mountpoint cache hash table entries: 1024 (order: 0, 4096 bytes) [ 0.001393] CPU: Testing write buffer coherency: ok [ 0.001817] /cpus/cpu@0 missing clock frequency property [ 0.001842] CPU0: thread 1, cpu 0, socket 0, mpidr 80000000 [ 0.002345] Setting up static identity map for 0x40100000 0x40100060 [ 0.002541] Hierarchical SRCU implementation. [ 0.003148] smp: Bringing up secondary CPUs [ 0.003163] smp: Brought up 1 node, 1 CPU [ 0.003175] SMP: Total of 1 processors activated (48.00 BogoMIPS). [ 0.003184] CPU: All CPU(s) started in SVC mode. [ 0.004066] devtmpfs: initialized [ 0.007259] VFP support v0.3: implementor 41 architecture 2 part 30 variant 7 rev 5 [ 0.007578] clocksource: jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 19112604462750000 ns [ 0.007614] futex hash table entries: 256 (order: 2, 16384 bytes) [ 0.007813] pinctrl core: initialized pinctrl subsystem [ 0.008896] DMA: preallocated 256 KiB pool for atomic coherent allocations [ 0.010158] hw breakpoint: found 5 (+1 reserved) breakpoint and 4 watchpoint registers. [ 0.010179] hw breakpoint: maximum watchpoint size is 8 bytes. [ 0.022957] SCSI subsystem initialized [ 0.023159] usbcore: registered new interface driver usbfs [ 0.023235] usbcore: registered new interface driver hub [ 0.023362] usbcore: registered new device driver usb [ 0.023474] Linux video capture interface: v2.00 [ 0.023517] pps_core: LinuxPPS API ver. 1 registered [ 0.023526] pps_core: Software ver. 5.3.6 Copyright 2005 2007 Rodolfo Giometti <giometti@linux.it> [ 0.023695] Advanced Linux Sound Architecture Driver Initialized. [ 0.024215] clocksource: Switched to clocksource arch_sys_counter [ 0.039085] workingset: timestamp_bits 30 max_order 14 bucket_order 0 [ 0.046435] squashfs: version 4.0 (2009/01/31) Phillip Lougher [ 0.046808] jffs2: version 2.2. (NAND) ? 2001 2006 Red Hat, Inc. [ 0.048756] random: fast init done [ 0.052407] Block layer SCSI generic (bsg) driver version 0.4 loaded (major 250) [ 0.052432] io scheduler noop registered [ 0.052442] io scheduler deadline registered [ 0.052669] io scheduler cfq registered (default) [ 0.052681] io scheduler mq deadline registered [ 0.052690] io scheduler kyber registered [ 0.057653] sun8i v3s pinctrl 1c20800.pinctrl: initialized sunXi PIO driver [ 0.058150] name allwinner,sun7i a20 pwm [ 0.058168] npwm 2 [ 0.139525] Serial: 8250/16550 driver, 8 ports, IRQ sharing disabled [ 0.143224] console [ttyS0] disabled [ 0.163532] 1c28000.serial: ttyS0 at MMIO 0x1c28000 (irq 33, base_baud 1500000) is a U6_16550A [ 0.676919] console [ttyS0] enabled [ 0.702093] 1c28400.serial: ttyS1 at MMIO 0x1c28400 (irq 34, base_baud 1500000) is a U6_16550A [ 0.732771] 1c28800.serial: ttyS2 at MMIO 0x1c28800 (irq 35, base_baud 1500000) is a U6_16550A [ 0.747219] m25p80 spi32766.0: w25q128 (16384 Kbytes) [ 0.752288] in cmdline partion [ 0.755486] p4 : size 100000 [ 0.758369] p4 : size 10000 [ 0.761160] p4 : size 400000 [ 0.764037] p4 : size ffffffff [ 0.767126] spi32766.0: parser cmdlinepart: 4 [ 0.771481] 4 cmdlinepart partitions found on MTD device spi32766.0 [ 0.777758] Creating 4 MTD partitions on \"spi32766.0\": [ 0.782904] 0x000000000000 0x000000100000 : \"uboot\" [ 0.789535] 0x000000100000 0x000000110000 : \"dtb\" [ 0.795874] 0x000000110000 0x000000510000 : \"kernel\" [ 0.802292] 0x000000510000 0x000001000000 : \"rootfs\" [ 0.809706] sun6i rtc 1c20400.rtc: rtc core: registered rtc sun6i as rtc0 [ 0.816602] sun6i rtc 1c20400.rtc: RTC enabled [ 0.821153] i2c /dev entries driver [ 0.826715] sunxi wdt 1c20ca0.watchdog: Watchdog enabled (timeout 16 sec, nowayout 0) [ 0.835775] usbcore: registered new interface driver usbhid [ 0.841355] usbhid: USB HID core driver [ 0.846926] Registering SWP/SWPB emulation handler [ 0.856875] simple framebuffer 43e89000.framebuffer: framebuffer at 0x43e89000, 0x177000 bytes, mapped to 0xc4400000 [ 0.867547] simple framebuffer 43e89000.framebuffer: format x8r8g8b8, mode 800x480x32, linelength 3200 [ 0.885830] Console: switching to colour frame buffer device 100x30 [ 0.900736] simple framebuffer 43e89000.framebuffer: fb0: simplefb registered! [ 0.908121] sun6i rtc 1c20400.rtc: setting system clock to 1970 01 01 02:33:59 UTC (9239) [ 0.916575] vcc3v0: disabling [ 0.919554] vcc3v3: disabling [ 0.922519] vcc5v0: disabling [ 0.925539] ALSA device list: [ 0.928507] No soundcards found. [ 0.994326] random: crng init done [ 1.519199] VFS: Mounted root (jffs2 filesystem) on device 31:3. [ 1.526365] devtmpfs: mounted [ 1.530825] Freeing unused kernel memory: 1024K Starting logging: OK Starting mdev modprobe: can't change directory to '/lib/modules': No such file or directory Initializing random number generator done. Starting network: ip: socket: Function not implemented ip: socket: Function not implemented FAIL Welcome to Lichee Pi Lichee login: ## 附录：sunxi fel帮助说明 ``` sunxi fel v1.4.1 87 g78a7566 Usage: sunxi fel [options] command arguments [command ] h, help Print this usage summary and exit v, verbose Verbose logging p, progress \"write\" transfers show a progress bar l, list Enumerate all (USB) FEL devices and exit d, dev bus:devnum Use specific USB bus and device number sid SID Select device by SID key (exact match) spl file Load and execute U Boot SPL If file additionally contains a main U Boot binary (u boot sunxi with spl.bin), this command also transfers that to memory (default address from image), but won't execute it. uboot file with spl like \"spl\", but actually starts U Boot U Boot execution will take place when the fel utility exits. This allows combining \"uboot\" with further \"write\" commands (to transfer other files needed for the boot). hex[dump] address length Dumps memory region in hex dump address length Binary memory dump exe[cute] address Call function address reset64 address RMR request for AArch64 warm boot memmove dest source size Copy <size> bytes within device memory readl address Read 32 bit value from device memory writel address value Write 32 bit value to device memory read address length file Write memory contents into file write address file Store file contents into memory write with progress addr file \"write\" with progress bar write with gauge addr file Output progress for \"dialog gauge\" write with xgauge addr file Extended gauge output (updates prompt) multi[write] # addr file \"write with progress\" multiple files, sharing a common progress status multi[write] with gauge like their \"write with *\" counterpart, multi[write] with xgauge but following the 'multi' syntax: <#> addr file [addr file [ ]] echo gauge \"some text\" Update prompt/caption for gauge output ver[sion] Show BROM version sid Retrieve and output 128 bit SID key clear address length Clear memory fill address length value Fill memory spiflash info Retrieves basic information spiflash hex[dump] addr length Dumps SPI flash region in hex spiflash read addr length file Write SPI flash contents into file spiflash write addr file Store file contents into SPI flash ``` ## 参考资料 <a href \"http://blog.sina.com.cn/s/blog_5ed5a1f40100f3qq.html\" target \"_black\">http://blog.sina.com.cn/s/blog_5ed5a1f40100f3qq.html</a>"},"/soft/Lichee/zh/Zero-Doc/System_Development/SPI_falsh_doc1.html":{"title":"sunxi-fel增加对16M以上Flash的支持","content":" title: sunxi fel增加对16M以上Flash的支持 由于SPI flash 的地址是24bit，也就是最大16M 地址空间，所以对于32M flash，需要增加bank切换支持。 uboot中有 **CONFIG\\_SPI\\_FLASH\\_BAR** 选项可以使能bank切换。 但是sunxi fel中尚未支持，所以下载的时候超出16M会循环覆盖掉。 这里介绍对sunxi fel增加16M以上flash支持的方法。 ## u boot的支持 ``` static int write_bar(struct spi_flash *flash, u32 offset) { u8 cmd, bank_sel; int ret; bank_sel offset / (SPI_FLASH_16MB_BOUN << flash >shift); if (bank_sel flash >bank_curr) goto bar_end; cmd flash >bank_write_cmd; ret spi_flash_write_common(flash, &cmd, 1, &bank_sel, 1); if (ret < 0) { debug(\"SF: fail to write bank register\\n\"); return ret; } bar_end: flash >bank_curr bank_sel; return flash >bank_curr; } ``` ## sunxi fel的支持 ``` #define CMD_WRITE_ENABLE 0x06 #define SPI_FLASH_16MB_BOUN 0x1000000 # define CMD_BANKADDR_BRWR 0x17 //only SPANSION flash use it # define CMD_BANKADDR_BRRD 0x16 # define CMD_EXTNADDR_WREAR 0xC5 # define CMD_EXTNADDR_RDEAR 0xC8 size_t bank_curr 0; void aw_fel_spiflash_write_helper(feldev_handle *dev, uint32_t offset, void *buf, size_t len, size_t erase_size, uint8_t erase_cmd, size_t program_size, uint8_t program_cmd) { uint8_t *buf8 (uint8_t *)buf; size_t max_chunk_size dev >soc_info >scratch_addr dev >soc_info >spl_addr; size_t cmd_idx, bank_sel; if (max_chunk_size > 0x1000) max_chunk_size 0x1000; uint8_t *cmdbuf malloc(max_chunk_size); cmd_idx 0; prepare_spi_batch_data_transfer(dev, dev >soc_info >spl_addr); //add bank support { cmd_idx 0; bank_sel offset /SPI_FLASH_16MB_BOUN; if (bank_sel bank_curr) goto bar_end; /* Emit write enable command */ cmdbuf[cmd_idx++] 0; cmdbuf[cmd_idx++] 1; cmdbuf[cmd_idx++] CMD_WRITE_ENABLE; /* Emit write bank */ cmdbuf[cmd_idx++] 0; cmdbuf[cmd_idx++] 2; cmdbuf[cmd_idx++] CMD_EXTNADDR_WREAR; cmdbuf[cmd_idx++] offset >> 24; /* Emit wait for completion */ cmdbuf[cmd_idx++] 0xFF; cmdbuf[cmd_idx++] 0xFF; /* Emit the end marker */ cmdbuf[cmd_idx++] 0; cmdbuf[cmd_idx++] 0; aw_fel_write(dev, cmdbuf, dev >soc_info >spl_addr, cmd_idx); aw_fel_remotefunc_execute(dev, NULL); bar_end: bank_curr bank_sel; } cmd_idx 0; ``` 重新编译sunxi fel后就可以烧录32M flash了\\~"},"/soft/Lichee/zh/Zero-Doc/System_Development/bsp_build.html":{"title":"BSP源码下载与编译","content":" title: BSP源码下载与编译 ## BSP内核剥离 BSP内核对摄像头驱动支持较好，所以在摄像头应用中有必要使用BSP内核。 官方SDK中camdriod与lichee linux内核绑定，而camdriod比较庞大，所以我们只需抽取lichee linux内核，而抛弃camdriod代码。 单独使用lichee linux的方法是：（构建走读见后一节） 解压 *buildroot/dl/gcc linarno.tar.gz* 到 *lichee/out/sun8iw8p1/linux/common/buildroot/external toolchain*，并加入环境变量（这步其实在下一步里包含了） 对于Ubuntu20.04，还需要安装32位支持库 ``` sudo apt get install lib32ncurses5 dev lib32z1 ``` 不然会报`make: arm linux gnueabi gcc: No such file or directory`这样的错误。 在lichee/linux 3.4目录下执行`bash ./scripts/build_tiger cdr.sh` 执行过程中会生成内核文件： Image Name: Linux 3.4.39 Created: Tue Sep 5 06:55:03 2017 Image Type: ARM Linux Kernel Image (uncompressed) Data Size: 2275400 Bytes 2222.07 kB 2.17 MB Load Address: 40008000 Entry Point: 40008000 Image arch/arm/boot/uImage is ready 'arch/arm/boot/Image' > 'output/bImage' 'arch/arm/boot/uImage' > 'output/uImage' 'arch/arm/boot/zImage' > 'output/zImage' Building modules compile Kernel successful 从主线uboot启动内核，一般使用uImage。 ## BSP内核配置 BSP内核源码在lichee/linux 3.4下。 通过 `make ARCH arm menuconfig` 来配置内核。 我们可以使能摄像头需要修改的一些内核配置： ``` > Device Drivers x > Multimedia support (MEDIA_SUPPORT [ y]) x > Video capture adapters (VIDEO_CAPTURE_DRIVERS [ y]) x > V4L USB devices (V4L_USB_DRIVERS [ y]) x ><M> USB Video Class (UVC) CONFIG_USB_VIDEO_CLASS ``` ``` > Device Drivers x > Multimedia support (MEDIA_SUPPORT [ y]) x > Video capture adapters (VIDEO_CAPTURE_DRIVERS [ y]) x > V4L platform devices (V4L_PLATFORM_DRIVERS [ y]) x > SoC camera support (SOC_CAMERA [ y]) x x <M> ov2640 camera support x x <M> ov5647 camera support x x <M> sunxi video front end (camera and etc)driver x x <M> v4l2 driver for SUNXI <*> sunxi video encoder and decoder support ``` 由于camdriod原始的内核配置是为了在spi nor flash上运行而配置的，没有ext4支持，所以需要额外添加ext4支持： ``` File systems > <*> The Extended 4 (ext4) filesystem filesystem x x [*] Use ext4 for ext2/ext3 file systems (NEW) x x [*] Ext4 extended attributes (NEW) x x [ ] Ext4 POSIX Access Control Lists (NEW) x x [ ] Ext4 Security Labels (NEW) x x [ ] EXT4 debugging support (NEW) x x [ ] JBD2 (ext4) debugging support (NEW) ``` 另外还要加上CONFIG_LBDAF（大文件支持，否则无法挂载文件系统） ``` > Enable the block layer (BLOCK [ y]) [*] Support for large (2TB+) block devices and files ``` 再加上CGROUPS支持： ``` > General setup [*] Control Group support > ``` 如果在文件系统（如debian）中使用了SWAP等特性，则还需要在内核中开启SWAP。 ```none > General setup [*] Support for paging of anonymous memory (swap) ``` debian下还需要开启 FHANDLE 特性，否则会出现以下错误 ``` > General setup [*] open by fhandle syscalls ``` 如果需要使用wifi功能，则还需要勾选RTL8723BS的支持（注意需要选择模块方式），和AW_RF_PM选项。 ``` > Device Drivers x\t > Network device support (NETDEVICES [ n]) x \t > Wireless LAN (WLAN [ n]) x x \t\t<M> Realtek 8723B SDIO WiFi ``` ``` > Networking support * Wireless > <*> cfg80211 wireless configuration API <*> Generic IEEE 802.11 Networking Stack (mac80211) ``` ``` > Device Drivers x \t > Misc devicess x x \t\t [*] Allwinner rf module pm drivers ``` 以及下节所说的fex修改。 ## uboot启动BSP内核 使用主线uboot启动BSP内核，需要修改下启动脚本，放入BSP内核需要的 *script.bin* 配置文件（相当于主线linux的dtb） 修改boot.cmd: ``` vim /root/u boot/boot.cmd ``` 重新生成boot.scr: ``` cd /root/u boot/ mkimage C none A arm T script d boot.cmd boot.scr ``` 复制一份 *lichee/tools/pack/chips/sun8iw8p1/configs/tiger cdr/sys_config.fex* ``` cp /root/lichee/tools/pack/chips/sun8iw8p1/configs/tiger cdr/sys_config.fex /root/u boot vim /root/u boot/sys_config.fex ``` 首先修改SD卡检测策略，设置为不检测，默认插入 `[776]:sdc_detmode 3` 使能RTL8723bs无线网卡的话，需要使能mmc1，也设置为不检测sd卡。 ``` [790]:[mmc1_para] [791]:sdc_used 1 [792]:sdc_detmode 3 ``` 默认mipi摄像头：h22_mipi和dw9714_act，dvp摄像头：ov5640和gc2035 ~~[98]:CIS[0]~~ ... ~~[157]:vip_dev1_af_pwdn ~~(内容重复) ``` ; ;vip (video input port) configuration ;vip_used: 0:disable 1:enable ;vip_mode: 0:sample one interface to one buffer 1:sample two interface to one buffer ;vip_dev_qty: The quantity of devices linked to capture bus ; ;vip_define_sensor_list: If you want use sensor detect function, please set vip_define_sensor_list 1, and ; verify that file /system/etc/hawkview/sensor_list_cfg.ini is properly configured! ; ;vip_dev(x)_pos: sensor position, \"rear\" or \"front\", if vip_define_sensor_list 1,vip_dev(x)_pos must be configured! ; ;vip_dev(x)_isp_used 0:not use isp 1:use isp ;vip_dev(x)_fmt: 0:yuv 1:bayer raw rgb ;vip_dev(x)_stby_mode: 0:not shut down power at standby 1:shut down power at standby ;vip_dev(x)_vflip: flip in vertical direction 0:disable 1:enable ;vip_dev(x)_hflip: flip in horizontal direction 0:disable 1:enable ;vip_dev(x)_iovdd: camera module io power handle string, pmu power supply ;vip_dev(x)_iovdd_vol: camera module io power voltage, pmu power supply ;vip_dev(x)_avdd: camera module analog power handle string, pmu power supply ;vip_dev(x)_avdd_vol: camera module analog power voltage, pmu power supply ;vip_dev(x)_dvdd: camera module core power handle string, pmu power supply ;vip_dev(x)_dvdd_vol: camera module core power voltage, pmu power supply ;vip_dev(x)_afvdd: camera module vcm power handle string, pmu power supply ;vip_dev(x)_afvdd_vol: camera module vcm power voltage, pmu power supply ;x indicates the index of the devices which are linked to the same capture bus ;fill voltage in uV, e.g. iovdd 2.8V, vip_devx_iovdd_vol 2800000 ;fill handle string as below: ;axp22_eldo3 ;axp22_dldo4 ;axp22_eldo2 ;fill handle string \"\" when not using any pmu power supply ; [csi0] vip_used 1 vip_mode 0 vip_dev_qty 1 vip_define_sensor_list 0 vip_csi_mck port:PE20<3><default><default><default> vip_csi_sck port:PE21<2><default><default><default> vip_csi_sda port:PE22<2><default><default><default> vip_dev0_mname \"h22_mipi\" vip_dev0_pos \"rear\" vip_dev0_lane 1 vip_dev0_twi_id 0 vip_dev0_twi_addr 0x60 vip_dev0_isp_used 1 vip_dev0_fmt 1 vip_dev0_stby_mode 0 vip_dev0_vflip 0 vip_dev0_hflip 0 vip_dev0_iovdd \"\" vip_dev0_iovdd_vol 3000000 vip_dev0_avdd \"csi avdd\" vip_dev0_avdd_vol 3000000 vip_dev0_dvdd \"csi dvdd\" vip_dev0_dvdd_vol 3000000 vip_dev0_afvdd \"\" vip_dev0_afvdd_vol 2800000 vip_dev0_power_en vip_dev0_reset port:PG00<1><default><default><default> vip_dev0_pwdn port:PG01<1><default><default><default> vip_dev0_flash_en vip_dev0_flash_mode vip_dev0_af_pwdn vip_dev0_act_used 0 vip_dev0_act_name \"dw9714_act\" vip_dev0_act_slave 0x18 vip_dev1_mname \"\" vip_dev1_pos \"front\" vip_dev1_lane 1 vip_dev1_twi_id 0 vip_dev1_twi_addr vip_dev1_isp_used 0 vip_dev1_fmt 1 vip_dev1_stby_mode 0 vip_dev1_vflip 0 vip_dev1_hflip 0 vip_dev1_iovdd \"\" vip_dev1_iovdd_vol 2800000 vip_dev1_avdd \"\" vip_dev1_avdd_vol 2800000 vip_dev1_dvdd \"\" vip_dev1_dvdd_vol 1500000 vip_dev1_afvdd \"\" vip_dev1_afvdd_vol 2800000 vip_dev1_power_en vip_dev1_reset vip_dev1_pwdn vip_dev1_flash_en ;fill handle string as below: ;axp22_eldo3 ;axp22_dldo4 ;axp22_eldo2 ;fill handle string \"\" when not using any pmu power supply ; [csi0] vip_used 1 vip_mode 0 vip_dev_qty 1 vip_define_sensor_list 0 vip_csi_mck port:PE20<3><default><default><default> vip_csi_sck port:PE21<2><default><default><default> vip_csi_sda port:PE22<2><default><default><default> vip_dev0_mname \"h22_mipi\" vip_dev0_pos \"rear\" vip_dev0_lane 1 vip_dev0_twi_id 0 vip_dev0_twi_addr 0x60 vip_dev0_isp_used 1 vip_dev0_fmt 1 vip_dev0_stby_mode 0 vip_dev0_vflip 0 vip_dev0_hflip 0 vip_dev0_iovdd \"\" vip_dev0_iovdd_vol 3000000 vip_dev0_avdd \"csi avdd\" vip_dev0_avdd_vol 3000000 vip_dev0_dvdd \"csi dvdd\" vip_dev0_dvdd_vol 3000000 vip_dev0_afvdd \"\" vip_dev0_afvdd_vol 2800000 vip_dev0_power_en vip_dev0_reset port:PG00<1><default><default><default> vip_dev0_pwdn port:PG01<1><default><default><default> vip_dev0_flash_en vip_dev0_flash_mode vip_dev0_af_pwdn vip_dev0_act_used 0 vip_dev0_act_name \"dw9714_act\" vip_dev0_act_slave 0x18 vip_dev1_mname \"\" vip_dev1_pos \"front\" vip_dev1_lane 1 vip_dev1_twi_id 0 vip_dev1_twi_addr vip_dev1_isp_used 0 vip_dev1_fmt 1 vip_dev1_stby_mode 0 vip_dev1_vflip 0 vip_dev1_hflip 0 vip_dev1_iovdd \"\" vip_dev1_iovdd_vol 2800000 vip_dev1_avdd \"\" vip_dev1_avdd_vol 2800000 vip_dev1_dvdd \"\" vip_dev1_dvdd_vol 1500000 vip_dev1_afvdd \"\" vip_dev1_afvdd_vol 2800000 vip_dev1_power_en vip_dev1_reset vip_dev1_pwdn vip_dev1_flash_en vip_dev1_flash_mode vip_dev1_af_pwdn [csi1] vip_used 0 vip_mode 0 vip_dev_qty 1 vip_define_sensor_list 0 vip_csi_pck port:PE00<2><default><default><default> vip_csi_mck port:PE01<2><default><default><default> vip_csi_hsync port:PE02<2><default><default><default> vip_csi_vsync port:PE03<2><default><default><default> vip_csi_d0 port:PE04<2><default><default><default> vip_csi_d1 port:PE05<2><default><default><default> vip_csi_d2 port:PE06<2><default><default><default> vip_csi_d3 port:PE07<2><default><default><default> vip_csi_d4 port:PE08<2><default><default><default> vip_csi_d5 port:PE09<2><default><default><default> vip_csi_d6 port:PE10<2><default><default><default> vip_csi_d7 port:PE11<2><default><default><default> vip_csi_d8 port:PE12<2><default><default><default> ;vip_csi_d9 port:PE13<2><default><default><default> vip_csi_d10 port:PE14<2><default><default><default> vip_csi_d11 port:PE15<2><default><default><default> vip_csi_sck port:PE21<2><default><default><default> vip_csi_sda port:PE22<2><default><default><default> vip_dev0_mname \"ov5640\" vip_dev0_pos \"front\" vip_dev0_twi_id 4 vip_dev0_twi_addr 0x78 vip_dev0_isp_used 0 vip_dev0_fmt 0 vip_dev0_stby_mode 0 vip_dev0_vflip 0 vip_dev0_hflip 0 vip_dev0_iovdd \"\" vip_dev0_iovdd_vol 2800000 vip_dev0_avdd \"\" vip_dev0_avdd_vol 2800000 vip_dev0_dvdd \"\" vip_dev0_dvdd_vol 1500000 vip_dev0_afvdd \"\" vip_dev0_afvdd_vol 2800000 vip_dev0_power_en vip_dev0_reset port:PE23<1><default><default><default> vip_dev0_pwdn port:PE24<1><default><default><default> vip_dev0_flash_en vip_dev0_flash_mode vip_dev0_af_pwdn vip_dev0_act_used 0 vip_dev0_act_name \"ad5820_act\" vip_dev0_act_slave 0x18 vip_dev1_mname \"gc2035\" vip_dev1_pos \"front\" vip_dev1_lane 1 vip_dev1_twi_id 4 vip_dev1_twi_addr 0x78 vip_dev1_isp_used 0 vip_dev1_fmt 1 vip_dev1_stby_mode 0 vip_dev1_vflip 0 vip_dev1_hflip 0 vip_dev1_iovdd \"\" vip_dev1_iovdd_vol 2800000 vip_dev1_avdd \"\" vip_dev1_avdd_vol 2800000 vip_dev1_dvdd \"\" vip_dev1_dvdd_vol 1500000 vip_dev1_afvdd \"\" vip_dev1_afvdd_vol 2800000 vip_dev1_power_en vip_dev1_reset vip_dev1_pwdn vip_dev1_flash_en vip_dev1_flash_mode vip_dev1_af_pwdn ``` 将其中的摄像头信息改成自己使用的摄像头信息。 保存，并使用 `fex2bin sys_config.fex script.bin` 生成script.bin文件。 如果提示`E: sys_config.fex:165: invalid character at 4.` 就注释掉165 166两行。 > 将script.bin也放入第一分区。 再将前面编译的uImage放入第一分区。 > 此时就可以使用主线Uboot启动bsp内核了。"},"/soft/Lichee/zh/Zero-Doc/System_Development/kernel_index.html":{"title":"主线Kernel","content":" title: 主线Kernel 本节主要介绍linux内核的基础编译与相关细节。"},"/soft/Lichee/zh/Zero-Doc/System_Development/download_dd.html":{"title":"linux烧录镜像","content":" title: linux烧录镜像 ## 准备 先去[下载站 Sipeed](https://dl.sipeed.com/shareURL/LICHEE/Zero/) 或者 [百度网盘](https://eyun.baidu.com/s/3htTXfaG#sharelink/parent_path %2F%E6%B7%B1%E5%9C%B3%E7%9F%BD%E9%80%9F%E7%A7%91%E6%8A%80%E6%9C%89%E9%99%90%E5%85%AC%E5%8F%B8&path %2F%E4%B8%8B%E8%BD%BD%E7%AB%99%E6%96%87%E4%BB%B6%2FLICHEE%2FZero) 获取镜像。 余下内容以 Zero_pub_V0.3.gz [点我跳转](https://dl.sipeed.com/shareURL/LICHEE/Zero/SDK) 压缩包里面的镜像为例 TF卡 X86 Linux 系统 ## 烧录步骤 ### 获得SD卡路径 打开 Linux 的终端界面（也就是命令行） 插入内存卡 使用 `sudo fdisk l` 命令查看内存卡 ```shell (base) [Desktop] sudo fdisk l Disk /dev/sdb: 1.84 GiB, 1977614336 bytes, 3862528 sectors Disk model: SD Card Reader Units: sectors of 1 * 512 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disklabel type: dos Disk identifier: 0xfb8e04f1 Device Boot Start End Sectors Size Id Type /dev/sdb1 2048 67583 65536 32M 6 FAT16 /dev/sdb2 67584 980991 913408 446M 83 Linux ``` 可以看出SD卡的盘符是/dev/sdb ### 取消系统对于该盘符的挂载 使用`umount`命令取消挂载 ```shell (base) [Desktop] umount /dev/sdb1 (base) [Desktop] umount /dev/sdb2 ``` ### 写入镜像 写入前自行先解压出 .`img` 文件 这里使用 `dd` 来烧录镜像，一般 dd 指令的基本用法如下： `sudo dd if 镜像 of /dev/卷标 ` 例如我们使用下面的命令来烧录： ```bash sudo dd if test.img of /dev/sdb bs 1M status progress oflag direct ``` if 后面接的是想要烧录的镜像，of 指向烧录位置，可以是设备或者文件，bs指块大小，status 为显示烧录状态，oflag表示dd方式，这里选择直连（即不复制到内存中） 等到终端自行退出到可输入模式后就已经完成烧录了"},"/soft/Lichee/zh/Zero-Doc/System_Development/uboot_build.html":{"title":"Uboot 编译","content":" title: Uboot 编译 ## 基础编译 ### 安装交叉编译器 网盘地址：[https://pan.baidu.com/s/1hsf22fq](https://pan.baidu.com/s/1hsf22fq) 国外用户：[https://releases.linaro.org/components/toolchain/binaries/6.3 2017.05/arm linux gnueabihf/](hhttps://releases.linaro.org/components/toolchain/binaries/6.3 2017.05/arm linux gnueabihf/) ``` wget https://releases.linaro.org/components/toolchain/binaries/latest/arm linux gnueabihf/gcc linaro 6.3.1 2017.05 x86_64_arm linux gnueabihf.tar.xz tar xvf gcc linaro 6.3.1 2017.05 x86_64_arm linux gnueabihf.tar.xz mv gcc linaro 6.3.1 2017.05 x86_64_arm linux gnueabihf /opt/ vim /etc/bash.bashrc # add: PATH \"$PATH:/opt/gcc linaro 6.3.1 2017.05 x86_64_arm linux gnueabihf/bin\" source /etc/bash.bashrc arm linux gnueabihf gcc v sudo apt get install device tree compiler ``` ### 下载编译Uboot ``` git clone https://github.com/Lichee Pi/u boot.git b v3s current #or git clone https://github.com/Lichee Pi/u boot.git b v3s spi experimental cd u boot make ARCH arm CROSS_COMPILE arm linux gnueabihf LicheePi_Zero_800x480LCD_defconfig #or make ARCH arm CROSS_COMPILE arm linux gnueabihf LicheePi_Zero480x272LCD_defconfig #or make ARCH arm CROSS_COMPILE arm linux gnueabihf LicheePi_Zero_defconfig make ARCH arm menuconfig time make ARCH arm CROSS_COMPILE arm linux gnueabihf 2>&1 tee build.log ``` 编译完成后，在当前目录下生成了u boot sunxi with spl.bin，可以烧录到8K偏移处启动。 ## Uboot结构简介 下面来看看该uboot中的目录结构 ├── api 存放uboot提供的API接口函数 ├── arch 平台相关的部分我们只需要关心这个目录下的ARM文件夹 │ ├──arm │ │ └──cpu │ │ │ └──armv7 │ │ └──dts │ │ │ └──*.dts 存放设备的dts,也就是设备配置相关的引脚信息 ├── board 对于不同的平台的开发板对应的代码 ├── cmd 顾名思义，大部分的命令的实现都在这个文件夹下面。 ├── common 公共的代码 ├── configs 各个板子的对应的配置文件都在里面，我们的Lichee配置也在里面 ├── disk 对磁盘的一些操作都在这个文件夹里面，例如分区等。 ├── doc 参考文档，这里面有很多跟平台等相关的使用文档。 ├── drivers 各式各样的驱动文件都在这里面 ├── dts 一种树形结构（device tree）这个应该是uboot新的语法 ├── examples 官方给出的一些样例程序 ├── fs 文件系统，uboot会用到的一些文件系统 ├── include 头文件，所有的头文件都在这个文件夹下面 ├── lib 一些常用的库文件在这个文件夹下面 ├── Licenses 这个其实跟编译无关了，就是一些license的声明 ├── net 网络相关的，需要用的小型网络协议栈 ├── post 上电自检程序 ├── scripts 编译脚本和Makefile文件 ├── spl second program loader，即相当于二级uboot启动。 ├── test 小型的单元测试程序。 └── tools 里面有很多uboot常用的工具。 了解了uboot的基本结构，我们可以知道一些相关的配置在什么地方了。 lichee的uboot配置文件放在confgs文件目录下面，名称为 LicheePi_Zero_480x272LCD_defconfig LicheePi_Zero_800x480LCD_defconfig LicheePi_Zero_defconfig 这3个配置是根据不同的Zero显示设备进行的配置，使用其中之一即可，可在uboot目录下执行命令 make LicheePi_Zero_defconfig 这样配置就生效了。"},"/soft/Lichee/zh/Zero-Doc/System_Development/kernel_build.html":{"title":"主线Kernel基础编译","content":" title: 主线Kernel基础编译 ## 安装依赖 `sudo apt install git wget make gcc flex bison libssl dev bc kmod ` ## 安装交叉编译器 下载地址：<https://releases.linaro.org/components/toolchain/binaries/6.3 2017.05/arm linux gnueabihf/> ``` wget https://releases.linaro.org/components/toolchain/binaries/6.3 2017.05/arm linux gnueabihf/gcc linaro 6.3.1 2017.05 x86_64_arm linux gnueabihf.tar.xz tar xvf gcc linaro 6.3.1 2017.05 x86_64_arm linux gnueabihf.tar.xz mv gcc linaro 6.3.1 2017.05 x86_64_arm linux gnueabihf /opt/ vim /etc/bash.bashrc export PATH \"$PATH:/opt/gcc linaro 6.3.1 2017.05 x86_64_arm linux gnueabihf/bin\" source /etc/bash.bashrc arm linux gnueabihf gcc v ``` ## 下载编译linux源码 (默认是zero 5.2.y分支)： depth 1 指拉取最近一次更改，不然会拉取所有更改（警告，数据量爆炸！） ``` git clone b zero 5.2.y depth 1 https://github.com/Lichee Pi/linux.git ``` 修改makefile文件 ``` cd linux vim Makefile [364]ARCH arm [365]CROSS_COMPILE arm linux gnueabihf [366]INSTALL_MOD_PATH out ``` 分别是指定架构，交叉编译器，MOD安装位置。 如果涉及到多个编译链版本，可以不用写入环境变量，在这里直接绝对路径指定。 ``` [365]CROSS_COMPILE /opt/gcc linaro 6.3.1 2017.05 x86_64_arm linux gnueabihf/bin/arm linux gnueabihf ``` 然后开始编译 ``` cd linux make licheepi_zero_defconfig make menuconfig #一般不用修改，需要时单独改 make j16 make j16 modules #编译模块 make j16 modules_install #安装模块 make dtbs #编译设备树 ``` 编译完成后，zImage在arch/arm/boot/下，驱动模块在out/lib下，设备树在arch/arm/boot/dts下。 然后把zImage，sun8i v3s licheepi zero dock.dtb放到第一分区 modules文件夹放入文件系统的lib下s 使用`modprobe xxx`加载模块。 编译过程中可能遇到以下问题： > /usr/bin/ld: scripts/dtc/dtc parser.tab.o:(.bss+0x20): multiple definition of `yylloc'; scripts/dtc/dtc lexer.lex.o:(.bss+0x0): first defined here > collect2: error: ld returned 1 exit status > make[1]: *** [scripts/Makefile.host:99: scripts/dtc/dtc] Error 1 解决办法： ``` vim scripts/dtc/dtc parser.tab.h 修改extern XXX yylloc 为yyloc vim scripts/dtc/dtc lexer.l 修改XXX yylloc 为 extern XXX yylloc ```"},"/soft/Lichee/zh/Zero-Doc/System_Development/bsp_index.html":{"title":"BSP内核编译","content":" title: BSP内核编译 由于主线内核暂不支持摄像头控制器，所以需要使用BSP内核来使能摄像头驱动。 本篇主要讲解编译启动BSP内核的方法。"},"/soft/Lichee/zh/Zero-Doc/System_Development/emdebian.html":{"title":"emdebian根文件系统","content":" title: emdebian根文件系统 如果想要更接近桌面系统的根文件系统，emdebian是不二之选。emdebian也是深度可定制，大小从不到100M到上G均可配置。但这个大小基本上无法使用spi flash了，只能使用tf卡或者emmc。优点是有包管理系统，可以直接apt get install来安装新软件包。 ## 环境搭建 ### 安装依赖包 sudo apt get install multistrap qemu qemu user static binfmt support dpkg cross ### 建立工作目录： ``` mkdir emdebian cd emdebian mkdir mindb cd mindb ``` ### 编辑multistrap_mindb.conf配置文件 示例如下： 具体语法请参考：https://wiki.debian.org/Multistrap 这里使用了较快的清华大学的镜像站，身在国外的朋友可以视情况更改。 ``` [General] directory target rootfs cleanup true noauth true unpack true debootstrap Debian Net Utils aptsources Debian [Debian] packages apt kmod lsof source http://ftp2.cn.debian.org/debian/ keyring debian archive keyring suite stretch components main contrib non free [Net] #Basic packages to enable the networking packages netbase net tools ethtool udev iproute iputils ping ifupdown isc dhcp client ssh source http://ftp2.cn.debian.org/debian/ [Utils] #General purpose utilities packages locales adduser vim less wget dialog usbutils source http://ftp2.cn.debian.org/debian/ ``` 如果出现 ``` W: GPG error: http://mirrors.huaweicloud.com/repository/debian stretch Release: The following signatures couldn't be verified because the public key is not available: NO_PUBKEY XXXX E: The repository 'http://mirrors.huaweicloud.com/repository/debian stretch Release' is not signed. ``` 将：$config_str . \" o Acquire::AllowInsecureRepositories true\"; 写入到320行 ``` vim /usr/sbin/multistrap $config_str ''; $config_str . \" o Apt::Architecture \" . shellescape($arch); $config_str . \" o Dir::Etc::TrustedParts \" . shellescape(\"${dir}${etcdir}trusted.gpg.d\"); $config_str . \" o Dir::Etc::Trusted \" . shellescape(\"${dir}${etcdir}trusted.gpg\"); $config_str . \" o Acquire::AllowInsecureRepositories true\"; $config_str . \" o Apt::Get::AllowUnauthenticated true\" if (defined $noauth); ``` ### 创建根文件系统 `sudo multistrap a armhf f multistrap_mindb.conf` 执行完成后，target rootfs即是所需的根文件系统。 ### 配置软件包 使用QEMU来配置软件包，将target rootfs作为root挂载来操作。 ``` sudo cp /usr/bin/qemu arm static target rootfs/usr/bin sudo mount o bind /dev/ target rootfs/dev/ sudo LC_ALL C LANGUAGE C LANG C chroot target rootfs dpkg configure a #这里就可以模拟板子情况执行相关命令，比如安装额外的软件包 sudo umount target rootfs/dev/ #最后记得卸载 ``` 其中出现选择系统shell的提示框，选否，即不使用dash。 ### 做最后的一些配置 ``` #!/bin/sh #Directory contains the target rootfs TARGET_ROOTFS_DIR \"target rootfs\" #Board hostname filename $TARGET_ROOTFS_DIR/etc/hostname echo acqua > $filename #Default name servers filename $TARGET_ROOTFS_DIR/etc/resolv.conf echo nameserver 8.8.8.8 > $filename echo nameserver 8.8.4.4 >> $filename #Default network interfaces filename $TARGET_ROOTFS_DIR/etc/network/interfaces echo auto eth0 >> $filename echo allow hotplug eth0 >> $filename echo iface eth0 inet dhcp >> $filename #eth0 MAC address echo hwaddress ether 00:04:25:12:34:56 >> $filename #Set the the debug port filename $TARGET_ROOTFS_DIR/etc/inittab echo T0:2345:respawn:/sbin/getty L ttyS0 115200 vt100 >> $filename #Set rules to change wlan dongles filename $TARGET_ROOTFS_DIR/etc/udev/rules.d/70 persistent net.rules echo SUBSYSTEM '\"net\", ACTION \"add\", DRIVERS \"?\", ATTR{address} \"\", ATTR{dev_id} \"0x0\", ATTR{type} \"1\", KERNEL \"wlan*\", NAME \"wlan0\"' > $filename #microSD partitions mounting filename $TARGET_ROOTFS_DIR/etc/fstab echo /dev/mmcblk0p1 /boot vfat noatime 0 1 > $filename echo /dev/mmcblk0p2 / ext4 noatime 0 1 >> $filename echo proc /proc proc defaults 0 0 >> $filename #Add the standard Debian non free repositories useful to load #closed source firmware (i.e. WiFi dongle firmware) filename $TARGET_ROOTFS_DIR/etc/apt/sources.list echo deb http://http.debian.net/debian/ stretch main contrib non free > $filename ``` ### 设置密码和其它操作 ``` sudo chroot target rootfs passwd sudo LC_ALL C LANGUAGE C LANG C chroot target rootfs apt get install packagename ``` 修改 target rootfs/etc/ssh/sshd_config来使能root登录 **PermitRootLogin yes**"},"/soft/Lichee/zh/Zero-Doc/System_Development/kernel_printk.html":{"title":"内核printk等级设置","content":" title: 内核printk等级设置 1、查看当前控制台的打印级别 `cat /proc/sys/kernel/printk` 4 4 1 7 其中第一个“4”表示内核打印函数printk的打印级别，只有级别比他高的信息才能在控制台上打印出来，既 0－3级别的信息 2、修改打印 echo \"新的打印级别 4 1 7\" \\>/proc/sys/kernel/printk ​3、不够打印级别的信息会被写到日志中可通过dmesg 命令来查看 4、printk的打印级别 ``` #define KERN_EMERG \"<0>\" /* system is unusable */ #define KERN_ALERT \"<1>\" /* action must be taken immediately */ #define KERN_CRIT \"<2>\" /* critical conditions */ #define KERN_ERR \"<3>\" /* error conditions */ #define KERN_WARNING \"<4>\" /* warning conditions */ #define KERN_NOTICE \"<5>\" /* normal but significantcondition */ #define KERN_INFO \"<6>\" /* informational */ #define KERN_DEBUG \"<7>\" /* debug level messages */ ``` 5、printk函数的使用 printk(打印级别 “要打印的信息”) 打印级别 既上面定义的几个宏"},"/soft/Lichee/zh/Zero-Doc/System_Development/SPI_index.html":{"title":"SPI Flash 杂谈","content":" title: SPI Flash 杂谈 在一些低成本应用场景，需要在SPI flash上启动系统，这需要对Uboot和系统镜像做些适配。 本节将对SPI flash的编译及相关应用作详细描述。"},"/soft/Lichee/zh/Zero-Doc/System_Development/uboot_logo.html":{"title":"开机logo替换","content":" title: 开机logo替换 ## uboot启动界面的版本信息隐藏 **drivers/video/cfb_console.c** 中加上 `CONFIG_HIDE_LOGO_VERSION` ，可以隐藏uboot的版本信息。 ## uboot开机画面更换 Uboot的开机logo默认情况（只定义了 `CONFIG_VIDEO_LOGO`）是企鹅logo，这个是存在于uboot代码中的一个头文件（ **include/video_logo.h** 或 **bmp_logo.h**），这个是一个巨大的结构体，其中保存着图片每个像素点的色彩数据。 ### 准备一张jpeg图片，通过命令行处理为8bit BMP图片 ``` #!/bin/sh #install Netpbm first jpegtopnm $1 ppmquant 31 ppmtobmp bpp 8 > $2 ``` 使用方法： （脚本名） （ 待处理的JPG图片名） （输出文件名） //这种方式出来的图不如用专业图片处理软件的好 ### 将bmp文件放入/tools/logos中，并修改/tools/下的Makefile ``` # Generated LCD/video logo LOGO_H $(OBJTREE)/include/bmp_logo.h LOGO $(CONFIG_LCD_LOGO) + $(LOGO_H) LOGO $(CONFIG_VIDEO_LOGO) + $(LOGO_H) ifeq ($(LOGO_BMP),) LOGO_BMP logos/mylogo.bmp endif ifeq ($(VENDOR),atmel) LOGO_BMP logos/atmel.bmp endif ifeq ($(VENDOR),esd) LOGO_BMP logos/esd.bmp endif ifeq ($(VENDOR),freescale) LOGO_BMP logos/freescale.bmp endif ifeq ($(VENDOR),ronetix) LOGO_BMP logos/ronetix.bmp endif ifeq ($(VENDOR),syteco) LOGO_BMP logos/syteco.bmp endif ``` 将 **mylogo.bmp** 替换成你生成的logo ### 确认配置文件 在 **include/configs/sun8i.h​** 中加入两个宏定义： ``` #define CONFIG_VIDEO_LOGO #define CONFIG_VIDEO_BMP_LOGO ``` 编译的时候，你的bmp文件会被 **tools/bmp_logo.c** 编译出的工具bmp_logo制作成 **include/bmp_logo.h**，并编译进uboot中。 ### 重新编译u boot即可得到显示新logo的u boot。 > 相关代码在drivers/video/cfb_console.c下 ``` #ifdef CONFIG_VIDEO_LOGO /* Plot the logo and get start point of console */ debug(\"Video: Drawing the logo \\n\"); video_console_address video_logo(); ``` drv_video_init > cfg_video_init ## linux开机画面更换 ### 方法一 **drivers/video/logo/logo_linux_clut224.ppm** 是默认的启动Logo图片，把自己的Logo图片（png格式）转换成ppm格式，替换这个文件，同时删除 **logo_linux_clut224.c logo_linux_clut224.o** 文件，重新编译 具体方法： ``` #sudo apt get install netpbm #pngtopnm your_boot.png > logo_linux_clut2240.pnm #pnmquant 224 logo_linux_clut2240.pnm > logo_linux_clut2241.pnm #pnmtoplainpnm logo_linux_clut2241.pnm > logo_linux_clut224.ppm #cp drivers/video/logo/logo_linux_clut224.ppm drivers/video/logo/logo_linux_clut224.ppm.bak #cp pic/logo_linux_clut224.ppm drivers/video/logo/logo_linux_clut224.ppm ``` 注：先把png转换成pnm格式，但内核的Logo最高只支持224色，需要把颜色转换成224色，最后把pnm转成ppm，文件名必须是 **logo_linux_clut224.ppm** 。 注意在kernel的menuconfig里需要使能LOGO。 ### 方法二 用RedHat9.0自带的图片编辑工具GIMP(其他发行版自己安装就行了)。 1. 将颜色数改为224（在GIMP中一次选择 图像 \\>模式 \\>索引。如下图所示）。 2. 调整大小：宽高都小两像素，否则不显示。 3. 另存为，保存为ppm格式，在弹出的对话框中选择Ascii，然后复制到Logo文件夹替换原来的文件，同时删除 **logo_linux_clut224.c logo_linux_clut224.o** 文件。 ## 隐藏启动光标 在内核的当前目录进入到 **drivers/video/console/fbcon.c** 文件 将 `static void fb_flashcursor(void *private)，static void fbcon_cursor(struct vc_data *vc, int mode)` 用空函数替换。 另一种禁止光标的方法： ``` #obj $(CONFIG_FRAMEBUFFER_CONSOLE) + fbcon.o bitblit.o font.o softcursor.o obj $(CONFIG_FRAMEBUFFER_CONSOLE) + fbcon.o bitblit.o font.o ``` 编译遇到一个 **soft_cursor** 没有定义的问题问题，注释代码： ``` //ABING // if (err) // soft_cursor(info, &cursor); ```"},"/soft/Lichee/zh/Zero-Doc/System_Development/SPI_falsh_doc5.html":{"title":"uboot 对SPI flash 的识别","content":" title: uboot 对SPI flash 的识别 flash信息在 ``` const struct spi_flash_info spi_flash_ids[] { {\"w25p80\", INFO(0xef2014, 0x0, 64 * 1024, 16, 0) }, {\"w25p16\", INFO(0xef2015, 0x0, 64 * 1024, 32, 0) }, {\"w25p32\", INFO(0xef2016, 0x0, 64 * 1024, 64, 0) }, {\"w25x40\", INFO(0xef3013, 0x0, 64 * 1024, 8, SECT_4K) }, {\"w25x16\", INFO(0xef3015, 0x0, 64 * 1024, 32, SECT_4K) }, {\"w25x32\", INFO(0xef3016, 0x0, 64 * 1024, 64, SECT_4K) }, {\"w25x64\", INFO(0xef3017, 0x0, 64 * 1024, 128, SECT_4K) }, {\"w25q80bl\", INFO(0xef4014, 0x0, 64 * 1024, 16, RD_FULL WR_QPP SECT_4K) }, {\"w25q16cl\", INFO(0xef4015, 0x0, 64 * 1024, 32, RD_FULL WR_QPP SECT_4K) }, {\"w25q32bv\", INFO(0xef4016, 0x0, 64 * 1024, 64, RD_FULL WR_QPP SECT_4K) }, {\"w25q64cv\", INFO(0xef4017, 0x0, 64 * 1024, 128, RD_FULL WR_QPP SECT_4K) }, {\"w25q128bv\", INFO(0xef4018, 0x0, 64 * 1024, 256, RD_FULL WR_QPP SECT_4K) }, {\"w25q256\", INFO(0xef4019, 0x0, 64 * 1024, 512, RD_FULL WR_QPP SECT_4K) }, {\"w25q80bw\", INFO(0xef5014, 0x0, 64 * 1024, 16, RD_FULL WR_QPP SECT_4K) }, {\"w25q16dw\", INFO(0xef6015, 0x0, 64 * 1024, 32, RD_FULL WR_QPP SECT_4K) }, {\"w25q32dw\", INFO(0xef6016, 0x0, 64 * 1024, 64, RD_FULL WR_QPP SECT_4K) }, {\"w25q64dw\", INFO(0xef6017, 0x0, 64 * 1024, 128, RD_FULL WR_QPP SECT_4K) }, {\"w25q128fw\", INFO(0xef6018, 0x0, 64 * 1024, 256, RD_FULL WR_QPP SECT_4K) }, #define INFO(_jedec_id, _ext_id, _sector_size, _n_sectors, _flags) \\ .id { \\ ((_jedec_id) >> 16) & 0xff, \\ ((_jedec_id) >> 8) & 0xff, \\ (_jedec_id) & 0xff, \\ ((_ext_id) >> 8) & 0xff, \\ (_ext_id) & 0xff, \\ }, \\ .id_len (!(_jedec_id) ? 0 : (3 + ((_ext_id) ? 2 : 0))), \\ .sector_size (_sector_size), \\ .n_sectors (_n_sectors), \\ .page_size 256, \\ .flags (_flags), struct spi_flash_info { /* Device name ([MANUFLETTER][DEVTYPE][DENSITY][EXTRAINFO]) */ const char *name; /* * This array stores the ID bytes. * The first three bytes are the JEDIC ID. * JEDEC ID zero means \"no ID\" (mostly older chips). */ u8 id[SPI_FLASH_MAX_ID_LEN]; u8 id_len; /* * The size listed here is what works with SPINOR_OP_SE, which isn't * necessarily called a \"sector\" by the vendor. */ u32 sector_size; u32 n_sectors; u16 page_size; u16 flags; #define SECT_4K BIT(0) /* CMD_ERASE_4K works uniformly */ #define E_FSR BIT(1) /* use flag status register for */ #define SST_WR BIT(2) /* use SST byte/word programming */ #define WR_QPP BIT(3) /* use Quad Page Program */ #define RD_QUAD BIT(4) /* use Quad Read */ #define RD_DUAL BIT(5) /* use Dual Read */ #define RD_QUADIO BIT(6) /* use Quad IO Read */ #define RD_DUALIO BIT(7) /* use Dual IO Read */ #define RD_FULL (RD_QUAD RD_DUAL RD_QUADIO RD_DUALIO) }; ```"},"/soft/Lichee/zh/Zero-Doc/System_Development/download_index.html":{"title":"Zero系统烧录","content":" title: Zero系统烧录 荔枝派Zero的系统烧录主要分以下几种： 1. dd镜像烧录 2. 分区镜像烧录 3. SPI Flash系统烧录 4. 另为方便广大用户使用，有Win32DiskImage一键烧录方式 Zero能够烧录的系统目前有Linux，Camdroid，Openwrt等，甚至能够运行去掉图形界面的低版本安卓，今后随着广大荔枝派爱好者开发，将会有更多可供烧录的系统面世。 如果您对开发或移植荔枝派Zero系统感兴趣，欢迎加入荔枝派DIY交流群：712961164"},"/soft/Lichee/zh/Zero-Doc/System_Development/download_onekey.html":{"title":"Windows 下烧录指南","content":" title: Windows 下烧录指南 > 最方便的镜像烧录方法，类似于ghost一键装机 ## 准备： 先去下载站获取镜像 dl.sipeed.com [点我跳转](https://dl.sipeed.com/shareURL/LICHEE/Zero/Images)。 余下内容以 Zero_pub_V0.3.gz [点我跳转](https://dl.sipeed.com/shareURL/LICHEE/Zero/SDK) 压缩包里面的镜像为例 下载[Etcher](https://www.balena.io/etcher/ \"Etcher\") 下载[SD Card Formatter](https://www.sdcard.org/downloads/formatter/eula_windows/SDCardFormatterv5_WinEN.zip \"SDCardFormatter\") ## 烧录步骤： > 格式化内存卡是为了能够成功烧录~ 打开SD卡格式化工具 点击`Refresh`来刷新盘符 在 `Select card` 选中目标盘符 点击右下角 `Format` 等待弹框提示 `successful` <img src \"./../static/System_Development/format.gif\" > 打开Etcher 解压镜像，得到 .img镜像文件 点击`Flash from file`,选中想要烧录的镜像包 点击`Select target`选中sd卡 点击`Flash`烧录 等待烧录完成 <img src \"./../static/System_Development/flash.gif\" > 到此就已经结束烧录了。"},"/soft/Lichee/zh/Zero-Doc/System_Development/Imager.html":{"title":"Zero Imager的使用","content":" title: Zero Imager的使用 Zero imager是zero固件打包，烧录 工具集，使用zero imager可以方便地进行各种配置（主线，bsp；tf，spi）的镜像打包，烧录，修改等。 ## zero imager 目录 zepan@ubuntu:~/develop/zero_imager$ ls build dtb fex img kernel modules overlay README rootfs uboot build： 内有各种脚本，打包烧录等操作均需要进入该目录操作 uboot：sdk生成的uboot镜像 dtb：主线内核使用的dtb，会从sdk中拷贝到这里 fex：bsp内核使用的fex，会从sdk里拷贝到这里 img：打包完成的镜像 kernel：sdk生成的zImage，按内核版本分类摆放 modules：sdk生成的内核模块 rootfs：各种预制的根文件系统，如rootfs brmin.tar.gz overlay：在预制根文件系统上添加的内容 ## zero imager 板级配置 在打包系统前，需要填写板级配置并生效。 ### 全局环境变量 首先进入 build目录，编辑env.sh文件，填写正确的路径信息，这里需要编辑的是： ``` # need edit as your env export _TOP_DIR /home/zepan/develop/zero_imager export _KERNEL_MAINDIR \"goofy_elion:/root/linux/\" export _KERNEL_BSPDIR \"goofy_elion:/root/lichee/linux 3.4/\" export _UBOOT_DEVDIR \"goofy_elion:/root/u boot\" export _BR_DEVDIR \"goofy_elion:/root/buildroot 2017.08\" export _CP_CMD \"docker cp\" ￥_LINUX_MAINDIR是你的主线linux sdk目录 ￥_LINUX_BSPDIR是你的bsp inux sdk目录 ￥_UBOOT_DEVDIR是你的uboot sdk目录 ￥_CP_CMD是你的cp命令，如果sdk在本机上，就直接是cp，如果是在远程请自行填写cp命令 ``` ### 板级环境变量 然后进入configs目录，编辑或者新建你的板级配置文件，这里以 **env dock tfmain.sh** 为例介绍下。 板级环境变量配置文件名，命名为 \" **env 板子名 启动介质名 内核种类.sh** \" 其中的内容，其余部分可以拷贝，仅修改下面部分： ``` #change here to your config export _CASE_NAME dock export _BOOT_DEV tf export _KERNEL_TYPE main export _KERNEL_VER 4.14.14 export _DT_NAME sun8i v3s licheepi zero dock #export _DT_NAME sun8i v3s licheepi zero with 800x480 lcd export _ROOTFS_TYPE brmin export _IMG_SIZE 128 export _UBOOT_SIZE 1 export _CFG_SIZEKB 0 export _P1_SIZE 4 ``` 这里主要就是填写你的板子使用的镜像的配置信息： > 启动介质是tf或者spi， 内核种类是main或者bsp， 内核版本按实际填写， > DT即设备树配置名， 根文件系统类型即rootfs目录下的名字后缀。 > 设定的镜像大小，以MB为单位，下同。 UBOOT分区大小。 SPI > 启动时使用的FEX/DTB分区大小（单位KB）。 > 第一分区大小（tf启动时放置内核和dtb等，spi启动时放置内核）。 注意这里会自动生成板子配置后缀名： ``` export _SUFFIX $_CASE_NAME $_BOOT_DEV$_KERNEL_TYPE ``` 如 dock tfmain ### 生效板级配置 在build目录下执行 `source configs/env dock tfmain.sh` 即可生效对应配置。 执行后会在build目录下生成 **boot.scr** 启动脚本。 每次打开新终端 请先执行一遍该命令来导入配置。 ## 镜像更新，打包命令 pull_uboot.sh：从sdk里更新uboot pull_kernel.sh: 从sdk里更新zImage和dts和modules pull_br.sh: 从sdk更新buildroot生成的根文件系统 pack_img.sh: 打包img到dd文件，生成文件在img目录下 局部更新镜像内容，可以在overlay下对应目录拷贝需要的文件，打包镜像时会将文件写入根文件系统的对应目录。 ## TF镜像烧录命令 write_dd.sh /dev/sdX: 一键烧录dd镜像，小白专用 //以下为调试时逐个分区调试使用的烧录脚本 write_all.sh /dev/sdX: 一键烧录 write_partion.sh /dev/sdX: 对tf卡分区 write_mkfs.sh /dev/sdX: tf卡格式化 write_boot.sh /dev/sdX: 烧录uboot write_p1.sh /dev/sdX: 烧录第一分区 write_p2.sh /dev/sdX: 烧录第二分区 write_overlay.sh /dev/sdX: 烧录overlay write_swap.sh /dev/sdX: 启用swap"},"/soft/Lichee/zh/Zero-Doc/System_Development/type.html":{"title":"Zero的开发环境分类","content":" title: Zero的开发环境分类 ## Camdriod 官方SDK Camdriod是V3S的官方开发环境，又被称为“坑卓”。 此坑卓非彼安卓，不能运行原生安卓apk，请不要妄想在64MB内存上跑安卓。。 坑卓 linux内核版本为3.4，系统配置方法是使用fex文件，对摄像头支持较好。 需要开发行车记录仪方案的，可以尝试使用坑卓。 荔枝派目前不提供对坑卓的技术支持。（有偿的也不提供）。 坑卓SDK下载： camdriod 本体： [http://pan.baidu.com/s/1miQN1Ra](http://pan.baidu.com/s/1miQN1Ra) Lichee Linux：[http://pan.baidu.com/s/1eRJrViy](http://pan.baidu.com/s/1eRJrViy) > 芯片资料和坑卓开发说明：[http://pan.baidu.com/s/1pLQbwuB](http://pan.baidu.com/s/1pLQbwuB) 下载后解压，把两个文件夹放在同一目录下，按照坑卓开发说明开发即可。 ## 主线Uboot + Bsp 内核 如果不想被坑卓坑，又想比较好地使用摄像头，可以使用主线Uboot加Bsp内核方案，系统配置为fex文件配置。 主线uboot： <https://github.com/Lichee Pi/u boot> > bsp内核即前面的lichee linux： <http://pan.baidu.com/s/1eRJrViy> ## 主线Uboot + 主线linux 如果想使用主线的特性，可以使用 主线Uboot + 主线linux 开发环境。系统配置为dts设备树配置。 主线uboot： <https://github.com/Lichee Pi/u boot> > 主线linux： <https://github.com/Lichee Pi/linux> ## Docker开发环境 如果不想自己配置繁琐的开发环境，请使用docker开发环境，免去所有配置烦恼。 ## Zero的文件系统 主要分为buildroot/LEDE，emdebian两类，前者较小，可以在spi flash(16/32MB)或者小容量TF卡（64/128MB）上运行。"},"/soft/Lichee/zh/Zero-Doc/System_Development/buildroot.html":{"title":"licheepi buildroot根文件系统","content":"# licheepi buildroot根文件系统 buildroot可用于构建小型的linux根文件系统。 大小最小可低至2M，与内核一起可以放入最小8M的spi flash中。 buildroot中可以方便地加入第三方软件包（其实已经内置了很多），省去了手工交叉编译的烦恼。 美中不足的是不支持包管理系统，没有gcc等。 ## 下载安装 首先安装一些依赖，比如linux头文件： ``` apt get install linux headers $(uname r) apt get install libncurses5 dev apt get install wget apt get install gcc automake autoconf libtool make ``` 然后下载安装： ```none wget https://buildroot.org/downloads/buildroot 2017.08.tar.gz tar xvf buildroot 2017.08.tar.gz cd buildroot 2017.08/ make menuconfig ``` ## 配置 看下ubootroot的目录结构 ``` . ├── arch: #存放CPU架构相关的配置脚本，如arm/mips/x86,这些CPU相关的配置，在制作工具链时，编译uboot和kernel时很关键. ├── board ├── boot ├── CHANGES ├── Config.in ├── Config.in.legacy ├── configs: #放置开发板的一些配置参数.  ├── COPYING ├── DEVELOPERS ├── dl: #存放下载的源代码及应用软件的压缩包.  ├── docs: #存放相关的参考文档.  ├── fs: #放各种文件系统的源代码.  ├── linux: #存放着Linux kernel的自动构建脚本.  ├── Makefile ├── Makefile.legacy ├── output: #是编译出来的输出文件夹.  │   ├── build: #存放解压后的各种软件包编译完成后的现场. │   ├── host: #存放着制作好的编译工具链，如gcc、arm linux gcc等工具. │   ├── images: #存放着编译好的uboot.bin, zImage, rootfs等镜像文件，可烧写到板子里, 让linux系统跑起来. │   ├── staging │   └── target: #用来制作rootfs文件系统，里面放着Linux系统基本的目录结构，以及编译好的应用库和bin可执行文件. (buildroot根据用户配置把.ko .so .bin文件安装到对应的目录下去，根据用户的配置安装指定位置) ├── package：#下面放着应用软件的配置文件，每个应用软件的配置文件有Config.in和soft_name.mk。 ├── README ├── support ├── system ├── toolchain └── utils # 实用工具 ``` 一般通过make xxx_defconfig来选择一个defconfig，这个文件在configs目录下。 当configs中不存在对应的开发板时，我们就要手动从头配置一遍。 使用`make config`进入配置界面。 ``` Target options >选择目标板架构特性。 Build options >配置编译选项。 Toolchain > 配置交叉工具链，使用buildroot工具链还是外部提供。 System configuration > Kernel > Target packages > Filesystem images > Bootloaders > Host utilities > Legacy config options > ``` ### 选中Target options以选择licheepi对应的架构 licheepi用的v3s cpu 参数如下 ``` CPU ARM Cortex A7 @ 1.2GHz Support NEON Advanced SIMD instruction VFPv4 Floating Point Unit ``` 选择相应的参数 ``` Target Architecture (ARM (little endian)) > Target Binary Format (ELF) > Target Architecture Variant (cortex A7) > Target ABI (EABIhf) > Floating point strategy (VFPv4 D16) > ARM instruction set (ARM) > ``` ### Build options主要配置以下一些内容 配置文件保存位置，将配置文件保存的好处是，在重新构建时，只需要调用make <xxx_defconfig>然后make,而不必重新全部配置。 示例：`$(CONFIG_DIR)/configs/LicheePi_Zero_defconfig `,。然后`make savedefconfig`保存配置文件。 配置下载位置，因为系统构建的时候需要从网络上抓起很多软件报的代码进行编译构建。这个一般不需要修改。 strip target binaries建议使能，这样会使文件尺寸变小。 对于其他的选项基本可以不做修改。 ### Toolchain 配置交叉工具链 因为之前开发uboot和内核都用到了自己下载的工具链，所以这里也配置成外部工具链。没有的话先配置工具链 ``` wget https://releases.linaro.org/components/toolchain/binaries/6.3 2017.05/arm linux gnueabihf/gcc linaro 6.3.1 2017.05 x86_64_arm linux gnueabihf.tar.xz tar xvf gcc linaro 6.3.1 2017.05 x86_64_arm linux gnueabihf.tar.xz mv gcc linaro 6.3.1 2017.05 x86_64_arm linux gnueabihf /opt/ vim /etc/bash.bashrc # add: PATH \"$PATH:/opt/gcc linaro 6.3.1 2017.05 x86_64_arm linux gnueabihf/bin\" source /etc/bash.bashrc arm linux gnueabihf gcc v ``` 出现以下信息则配置成功。 ``` Thread model: posix gcc version 6.3.1 20170404 (Linaro GCC 6.3 2017.05) ``` 配置成外部工具链 ``` Toolchain type (External toolchain) > x ( ) Buildroot toolchain x (X) External toolchain ``` 在本机上外部工具链配置为： **/opt/gcc linaro 6.3.1 2017.05 x86_64_arm linux gnueabihf/** 选中`() Toolchain path (NEW)`，填入path ``` (/opt/gcc linaro 6.3.1 2017.05 x86_64_arm linux gnueabihf/) Toolchain path ``` Toolchain prefix前缀是： **arm linux gnueabihf** External toolchain gcc version：我们使用的是6.3版本,选中6.x External toolchain kernel headers series：是在 **arm linux gnueabihf/libc/usr/include/linux/version.h** 里读取内核版本信息。本机的版本是4.6(263680 0x040600, 即4.6.0) ``` cat /opt/gcc linaro 6.3.1 2017.05 x86_64_arm linux gnueabihf/arm linux gnueabihf/libc/usr/include/linux/version.h #define LINUX_VERSION_CODE 263680 ``` External toolchain C library还是选择传统的glibc。需要小体积可以选uclibc（需要自行编译安装）。然后勾选上 `[] Toolchain has C++ support?` ### System configuration 配置系统参数 System hostname：根据需要定义一个字符串，是控制台前面的提示符xxx@vsi，这里改为 `(licheepi) System hostname` Init system：这里选择busybox，轻量级使用非常广泛。可选的有systemV,systemd. Root password配置登录密码。 ### Target package 用于配置一些软件包，例如QT5 ``` Target packages > x Graphic libraries and applications (graphic/text) > xx [*] Qt5 > ``` 有时候下载速度慢，可以复制make时打印的下载链接，使用迅雷等下载好后，拷贝到dl目录下，会自动识别。 ## Ⅲ、编译 make.注意还要安装一下依赖， ``` apt get install g++ patch cpio python unzip rsync bc ``` 不然会报： ``` You may have to install 'g++' on your build machine You must install 'patch' on your build machine You must install 'cpio' on your build machine You must install 'python' on your build machine You must install 'unzip' on your build machine You must install 'rsync' on your build machine You must install 'bc' on your build machine ``` 如果编译busybox时出现 ``` arm linux gnueabihf gcc: error: unrecognized argument in option ' march i586' ``` 并且make clean后仍然报错的，可以试试make clean all（不知道啥原理但是好使了） 编译完成后会在output/images下生成rootfs.tar, 解压到第二分区后就能使用了。 默认失能串口登录，需要修改 **/etc/inittab** : ``` #console::respawn:/sbin/getty L console 0 vt100 # GENERIC_SERIAL ttyS0::respawn:/sbin/getty L ttyS0 115200 vt100 # GE ``` 如果需要免密码登录，直接 ``` #console::respawn:/sbin/getty L console 0 vt100 # GENERIC_SERIAL ttyS0::respawn:/bin/sh ```"},"/soft/Lichee/zh/Zero-Doc/System_Development/SPI_falsh_doc3.html":{"title":"jffs2文件系统挂载不上的常见原因","content":" title: jffs2文件系统挂载不上的常见原因 ## 内核命令行不正确 [ 0.000000] Kernel command line: console ttyS0,115200 earlyprintk panic 5 rootwait mtdparts spi32766.0:1M(uboot)ro,64k(dtb)ro,4M(kernel)ro,3008k(rootfs) root 31:03 rw rootfstype jffs2 内核命令行应正确显示分区信息，如果分区信息不正确则无法正确挂载。 分区信息在 **include/configs/sun8i.h** 里修改 ``` #define CONFIG_BOOTCOMMAND \"sf probe 0; \" \\ \"sf read 0x41800000 0x100000 0x10000; \" \\ \"sf read 0x41000000 0x110000 0x400000; \" \\ \"bootz 0x41000000 0x41800000\" #define CONFIG_BOOTARGS \"console ttyS0,115200 earlyprintk panic 5 rootwait \" \\ \"mtdparts spi32766.0:1M(uboot)ro,64k(dtb)ro,4M(kernel)ro, (rootfs) root 31:03 rw rootfstype jffs2\" ``` ## 识别不到分区 正常识别到分区，应该报以下信息： [ 0.862858] m25p80 spi32766.0: w25q128 (16384 Kbytes) [ 0.867927] in cmdline partion [ 0.871123] p4 : size 100000 [ 0.874005] p4 : size 10000 [ 0.876796] p4 : size 400000 [ 0.879714] p4 : size 2f0000 [ 0.882596] spi32766.0: parser cmdlinepart: 4 [ 0.886949] 4 cmdlinepart partitions found on MTD device spi32766.0 [ 0.893230] Creating 4 MTD partitions on \"spi32766.0\": [ 0.898374] 0x000000000000 0x000000100000 : \"uboot\" [ 0.904828] 0x000000100000 0x000000110000 : \"dtb\" [ 0.910973] 0x000000110000 0x000000510000 : \"kernel\" [ 0.917258] 0x000000510000 0x000000800000 : \"rootfs\" 如果没有显示以上信息，则需要确认有无勾选相关驱动 进入到 Device Drivers > Memory Technology Device (MTD) support ，确保选择上mtd的 **< * > Command line partition table parsing** 支持，该项目用来解析uboot传递过来的flash分区信息。 以及SPI NOR 设备的支持。 添加对jffs2文件系统的支持，路径在File systems > Miscellaneous filesystems > Journalling Flash File System v2 (JFFS2) support ## jffs2 Magic bitmask 错误 jffs2: Node at 0x00000f6c with length 0x00000144 would run over the end of the erase block [ 1.133830] jffs2: Perhaps the file system was created with the wrong erase size? [ 1.141435] jffs2: jffs2_scan_eraseblock(): Magic bitmask 0x1985 not found at 0x00000f70: 0x0144 instead [ 1.150994] jffs2: jffs2_scan_eraseblock(): Magic bitmask 0x1985 not found at 0x00000f74: 0x912a instead [ 1.160547] jffs2: jffs2_scan_eraseblock(): Magic bitmask 0x1985 not found at 0x00000f78: 0x0002 instead [ 1.170127] jffs2: jffs2_scan_eraseblock(): Magic bitmask 0x1985 not found at 0x00000f7c: 0x000d instead [ 1.180689] jffs2: jffs2_scan_eraseblock(): Magic bitmask 0x1985 not found at 0x00000f80: 0x81a4 instead [ 1.190183] jffs2: jffs2_scan_eraseblock(): Magic bitmask 0x1985 not found at 0x00000f84: 0x03e8 instead [ 1.199668] jffs2: jffs2_scan_eraseblock(): Magic bitmask 0x1985 not found at 0x00000f88: 0x11d8 instead [ 1.209151] jffs2: jffs2_scan_eraseblock(): Magic bitmask 0x1985 not found at 0x00000f8c: 0xdec2 instead [ 1.218634] jffs2: jffs2_scan_eraseblock(): Magic bitmask 0x1985 not found at 0x00000f90: 0xdec2 instead [ 1.228102] jffs2: jffs2_scan_eraseblock(): Magic bitmask 0x1985 not found at 0x00000f94: 0xdec2 instead [ 1.237581] jffs2: Further such events for this erase block will not be printed [ 1.245110] jffs2: jffs2_scan_eraseblock(): Magic bitmask 0x1985 not found at 0x00001000: 0x3fb1 instead [ 1.254615] jffs2: jffs2_scan_eraseblock(): Magic bitmask 0x1985 not found at 0x00001004: 0x1a28 instead [ 1.264102] jffs2: jffs2_scan_eraseblock(): Magic bitmask 0x1985 not found at 0x00001008: 0x7f01 instead [ 1.273586] jffs2: jffs2_scan_eraseblock(): Magic bitmask 0x1985 not found at 0x0000100c: 0x505d instead [ 1.283098] jffs2: jffs2_scan_eraseblock(): Magic bitmask 0x1985 not found at 0x00001010: 0x84c8 instead [ 1.292588] jffs2: jffs2_scan_eraseblock(): Magic bitmask 0x1985 not found at 0x00001014: 0xd8d1 instead [ 1.302072] jffs2: jffs2_scan_eraseblock(): Magic bitmask 0x1985 not found at 0x00001018: 0x4001 instead [ 1.311555] jffs2: jffs2_scan_eraseblock(): Magic bitmask 0x1985 not found at 0x0000101c: 0x8485 instead [ 1.321033] jffs2: jffs2_scan_eraseblock(): Magic bitmask 0x1985 not found at 0x00001020: 0x65b1 instead [ 1.330514] jffs2: jffs2_scan_eraseblock(): Magic bitmask 0x1985 not found at 0x00001024: 0x5d81 instead 该错误有若干种可能： 1. jffs2镜像生成错误 `mkfs.jffs2 s 0x100 e 0x10000 p 0xAF0000 d rootfs brmin o jffs2 brmin.img` 这里 s代表页大小，普通spi nor flash的页大小是256字节，即0x100 e表示擦除的块大小，普通spi nor flash的块大小是64K字节，即0x10000 p表示分区大小，在生成时会擦除分区大小的flash初始化。 这里必须和uboot里指定的分区大小一致，否则会出现脏页。 2.内核使用了扇区擦除 mkfs.jffs2 使用的最小擦除尺寸是8KB，而spi flash的扇区大小是4KB，所以按照扇区擦除的话，会无法使用，所以必须使用块擦除。 编译内核前先确认下drivers/mtd/spi nor/spi nor.c里，自己使用的flash的相关信息 `#define SECT_4K BIT(0) /* SPINOR_OP_BE_4K works uniformly */` 如果发现信息里有SECT\\_4K，则会导致jffs2不能正常擦除（64KB），需要去掉该flag。 ## 其它摘录 Question1：JFFS2 error: (1) jffs2_build_inode_pass1: child dir \"alsa\" (ino #1159) of dir ino #1074 appears to be a hard link JFFS2 error: (1) jffs2_build_inode_pass1: child dir \"l\" (ino #1170) of dir ino #1075 appears to be a hard link 原由 : flash没有erase彻底. VFS: Mounted root (jffs2 filesystem) on device 31:1. Freeing init memory: 136K JFFS2 notice: (1) check_node_data: wrong data CRC in data node at 0x0f0a7f78: read 0x4462b066, calculated 0x48ea177f. JFFS2 error: (488) jffs2_do_read_inode_internal: Argh. Special inode #139 with mode 0x61b0 had more than one node iget() failed for ino #139 mknod: /dev/null: File exists Populating /dev using udev: udevd (499): /proc/499/oom_adj is deprecated, please use /proc/499/oom_score_adj instead. JFFS2 error: (500) jffs2_do_read_inode_internal: Argh. Special inode #1123 with mode 0x21b0 had more than one node iget() failed for ino #1123 Question2：jffs2_scan_eraseblock(): Magic bitmask 0x1985 not found at 0x00000024: 0x2b10 instead mkfs.jffs2 s 的参数问题 对照FLASH的大小再重新生成镜像文件过即可 The answer this means that the data on your flash device is not a valid JFFS2 file system. There is no single solution for this problem, but we will try to provide you some ideas how to fix this. The first question you should try to answer is \"why the data on my flash device is incorrect so that JFFS2 rejects to deal with it?\". There are may be a plenty of reasons, e.g.: you flash driver is severely buggy so it reads trash instead of valid data; you flashed some trash instead of a valid JFFS2 image; you did not manage to flash JFFS2 image correctly so that you ended up with garbage on your flash, although the original image was perfectly fine; you forgot to erase your flash before flashing it, etc. Anyways, JFFS2 wouldn't complain if it was able to find correct data. As it does complain, there is something wrong with the data it reads. One common mistake is to use /dev/mtdX or /dev/mtdblockX devices to flash JFFS2 images on NAND flashes. E.g. cp jffs2_fs.img /dev/mtd2 This is incorrect because when dealing with NAND flashes one has to skip bad eraseblocks and write only in NAND page size chunks. Please, use the nandwrite utility instead. Also please, do not forget to erase your flash before flashing the image. You may use the flash_eraseall utility for this. And it makes sense to make sure the erase functionality actually works by reading the erased MTD device back and checking that only 0xFF bytes were read. You may try to check if your flash driver works correctly and if you flashed the file system image correctly by means of reading the flash back after you have flashed your image, and compare the read image with the original one. Please, use the nandread utility to read from NAND flashes. You can also do the following experiment to make sure JFFS2 works well. Erase your MTD device and mount it to JFFS2. You will end up with an empty file system. Copy some files to the JFFS2 file system and unmount it. Then mount it again and see if it mounts without problems. If it does, this is most probably not a JFFS2 bug. Question3：Empty flash at 0xXXXXXXXX ends at 0xXXXXXXXX This message is generated if a block of data is partially written. It is generally not a sign of any problem. Question4：Name CRC failed on node at 0x00b620c8: Read 0x640c8ca3, calculated 0x795111fe 重启，则不会有如上CRC错误信息。 问题原因： 我在烧写jffs2 img之前，使用fis init f 来擦除flash。fis init f 命令执行完以后，flash空间就都是0xFF了！即使在mkfs.jffs2的时候使用' p'参数指定最终输出img的大小，但是超出文件系统的部分也会被填充为0xFF!但这可不是jffs2的格式！ 我用fis create分了5M多（0x590000）的分区，但是jffs2fs.img只有不到3M（0x250000），那么把它烧写到flash以后，分区中除了jffs2 img之外剩余的flash空间（大概2M）全是0xFF，这不是jffs2要求的格式，所以，会发出CRC错误的信息。假如有一种工具，他可以将flash format为jffs2的格式，那么就不会出现这个问题了。目前我还没有找到这种工具，但是，可以确信的是：上面的CRC错误是不影响jffs2文件系统的使用 http://blog.chinaunix.net/space.php?uid 20727076&do blog&id 1885384 Question5: VFS: Mounted root (jffs2 filesystem) readonly. Freeing unused kernel memory: 304k freed Error 3 while decompressing! 804878c4(1884) >81200000(16384) Failed to execute /linuxrc. Attempting defaults Kernel panic not syncing: No init found. Try passing init option to kernel. 原由 : 没有仔细看 mkfs.jffs2 的手册, 须要指定 b参数, 大小与PAGE_SIZE一样 (查看.config文件 CONFIG_PAGE_SIZE_16KB y). Question6: 共提示以下几种错误： Empty flash at 0x00258c88 ends at 0x00258c8c jffs2_scan_inode_node(): CRC failed on node at 0x002873f0: Read 0x50dc72ec, calculated 0xafbffd1d jffs2_scan_eraseblock(): Magic bitmask 0x1985 not found at 0x002d24ac: 0x000d instead JFFS2 notice: (1) jffs2_build_xattr_subsystem: complete building xattr subsystem, 0 of xdatum (0 unchecked, 0 orphan) and 0 of xref (0 dead, 0 orphan) found. VFS: Mounted root (jffs2 filesystem). Freeing init memory: 124K JFFS2 notice: (1) check_node_data: wrong data CRC in data node at 0x00012000: read 0x1a9bfab2, calculated 0xdc27bef6. JFFS2 notice: (728) read_dnode: wrong data CRC in data node at 0x0000e438: read 0x3dcf6001, calculated 0xcb81f1ee. JFFS2 warning: (1) jffs2_do_read_inode_internal: no data nodes found for ino #14 JFFS2 notice: (1) jffs2_do_read_inode_internal: but it has children so we fake some modes for it Failed to execute /linuxrc. Attempting defaults Kernel panic not syncing: No init found. Try passing init option to kernel. 分析： 记得JFFS2是采用自己的ECC算法，但是在内核中又打开了S3C2410_HARDWARE_ECC 解决方案： 去掉硬件ECC"},"/soft/Lichee/zh/Zero-Doc/System_Development/download_LL.html":{"title":"分区镜像烧录","content":" title: 分区镜像烧录 简介： 一步步来的镜像烧录，适合调节各个部位的代码，方便一些特别的底层运作方式 推荐镜像下载位址：hack to 环荣内网 then //192.168.1.89/musume/Lichee/all 2017/all.rar 此镜像中的文件介绍： （当时在外出差刚好缺个路由器，于是就做了个路由器镜像） Lichee\\_main\\_gpt.bin 主GPT头和分区表 Lichee\\_Zero\\_ac.bin 仿基带，就是区分设备用的 eazyboot.mbn 类似BIOS的界面，其实就是个设置菜单，有个看看用的磁盘检测功能，可以观看进度条在跑，并不检测磁盘，不会衰减磁盘使用寿命 bootlist.mbn 真正的系统启动选单 Misc.img 驱动跟一堆底层的东西 splash.img 里面就一张开机图片，直接将原版的 **drivers/video/logo/logo_linux_clut224.ppm** 移植过来的，可以任意修改 system.img 路由器系统，需配合Zero底板与TF Wifi Card，LCD小屏使用 recovery.img 仅恢复cache与Set，无其他功能，跟戳路由器复位效果差不多 userdata.img 初账号：Lichee Zero 密码：88888888 Web.img 就一个荔枝派Zero的欢迎页面，单独放着方便大家修改成自己喜欢的页面 步骤： 见云汉荔枝派板块系统名称帖子"},"/soft/Lichee/zh/Zero-Doc/System_Development/uboot_index.html":{"title":"主线Uboot","content":" title: 主线Uboot 本节讲解主线Uboot的编译、配置及相关内容"},"/soft/Lichee/zh/Zero-Doc/System_Development/download_SPI.html":{"title":"SPI Flash系统烧录","content":" title: SPI Flash系统烧录 步骤概要： 1. 打开SPI烧录软件 2. 读取现有目录 3. 擦除区域内容 4. 下载固件 5. 选择对应的固件与烧写位址 6. 等待烧好后上机使用 注意事项：如果您是将芯片吹出来装到编程器里烧写的，请注意芯片左上角圆点方向"},"/soft/Lichee/zh/Zero-Doc/System_Development/SPI_falsh_doc2.html":{"title":"overlayfs的使用","content":" title: overlayfs的使用 前面简单做的jffs2文件系统，没有经过压缩，体积比较大，在spi flash中放不了多少东西。 这里介绍使用overlayfs有效利用flash空间。（著名的openwrt上用的就是这一套） ## squashfs 使用 squashfs是只读压缩文件系统，我们把相对固定的根文件系统部分使用squash压缩存储。 把目录文件放在rootfs下，然后执行 > mksquashfs rootfs rootfs sq.img 即可获得squashfs的根文件系统。 启动squashfs需要改动uboot的环境变量： ``` #define CONFIG_BOOTARGS \"console ttyS0,115200 earlyprintk panic 5 rootwait \" \\ \"mtdparts spi32766.0:1M(uboot)ro,64k(dtb)ro,4M(kernel)ro, (rootfs) root 31:03 rw rootfstype squashfs ``` 以及在内核编译时选上相应选项。 在启动系统后可以在/proc/filesystems 查看系统支持的文件系统： ``` # cat /proc/filesystems nodev sysfs nodev rootfs nodev ramfs nodev bdev nodev proc nodev cgroup nodev cgroup2 nodev tmpfs nodev devtmpfs nodev configfs nodev debugfs nodev sockfs nodev pipefs nodev rpc_pipefs nodev devpts squashfs vfat nodev nfs nodev nfs4 nodev jffs2 nodev overlay ``` ## overlayfs使用 overlayfs 顾名思义，就是一种覆盖式的文件系统。 常见用法是，底层文件系统只读，上层文件系统可读写；著名的docker就是使用的overlayfs。 在嵌入式应用中，底层只读系统一般使用squashfs，上层使用jffs2. 首先我们重新分区： ``` #define CONFIG_BOOTARGS \"console ttyS0,115200 earlyprintk panic 5 rootwait \" \\ \"mtdparts spi32766.0:1M(uboot)ro,64k(dtb)ro,4M(kernel)ro,16M(rootfs) (data) root 31:03 rw rootfstype squashfs ``` 这样就是给固定只读的rootfs划分了16M空间，剩余空间约10.9M划分给可读写的数据分区。 同时在只读根文件系统下新建overlay目录。 开机启动后，执行以下命令来挂载overlayfs： 注意需要使用正规mount命令，而不是busybox的mount命令才能挂载 ``` mount n t jffs2 /dev/mtdblock4 /overlay mount n t overlay overlayfs:/overlay o lowerdir /,upperdir /overlay,workdir /workdir /mnt ```"},"/soft/Lichee/zh/Zero-Doc/System_Development/bsp_review.html":{"title":"BSP内核构建走读","content":" title: BSP内核构建走读 ## camdriod中对lichee的构建过程 使用BSP内核的话，需要使用官方sdk编译camdriod并从中取出uImage。 鉴于camdriod较大，所以我们先简单走读下camdriod中对lichee的构建过程，扣出这部分内容。 camdriod的构建脚本： ``` #!/bin/bash source build/envsetup.sh && lunch && mklichee && extract bsp && make j8 && pack ``` **source build/envsetup.sh** 这里是include各种环境变量，比如就添加了 **tiger_cdr eng** 选项，这里先不管它。 lunch就是选择目标板配置了，是在 **build/envsetup.sh** 中的函数。 接着就是关键的mklichee了，在 **device/softwinner/common/vendorsetup.sh** 里，深入看下： ``` function set_environment() { LICHEE_CHIP \"sun8iw8p1\" export CAMLINUX_BUILD_TOP `pwd` export DEVICE_DIR $CAMLINUX_BUILD_TOP/device/softwinner export TARGET_OUT $CAMLINUX_BUILD_TOP/output export OUT_DIR $CAMLINUX_BUILD_TOP/out export LICHEE_DIR $CAMLINUX_BUILD_TOP/../lichee export LICHEE_OUT_DIR $LICHEE_DIR/out/sun8iw8p1/linux export BR_ROOTFS_DIR $TARGET_OUT/target export LICHEE_BR_DIR ${LICHEE_DIR}/buildroot export LICHEE_KERN_DIR ${LICHEE_DIR}/linux 3.4 export LINUXOUT_MODULE_DIR $LICHEE_KERN_DIR/output/lib/modules/*/* export LICHEE_KERN_OUTDIR $LICHEE_KERN_DIR/output export LICHEE_TOOLS_DIR ${LICHEE_DIR}/tools export LICHEE_UBOOT_DIR ${LICHEE_DIR}/brandy/u boot 2011.09 } ``` ``` function mklichee() { mksetting #显示目前的配置信息 mk_info \"build lichee \" mkbr && mkkernel # mkbr && mkkernel && mkuboot [ $? ne 0 ] && return 1 return 0 } ``` mkbr是运行了 `buildroot/scripts/build.sh buildroot linux sun8iw8p1` ``` function mkbr() { mk_info \"build buildroot \" local build_script build_script \"scripts/build.sh\" LICHEE_PLATFORM \"linux\" (cd ${LICHEE_BR_DIR} && [ x ${build_script} ] && ./${build_script} \"buildroot\" ${LICHEE_PLATFORM} ${LICHEE_CHIP}) [ $? ne 0 ] && mk_error \"build buildroot Failed\" && return 1 mk_info \"build buildroot OK.\" } ``` ``` if [ \"x${LICHEE_PLATFORM}\" \"xlinux\" ] ; then build_buildroot export PATH ${LICHEE_BR_OUT}/external toolchain/bin:$PATH build_external else build_toolchain ``` LICHEE\\_PLATFORM并没有被传入，实际执行的是下面这个build\\_toolchain： ``` build_toolchain() { local tooldir \"${LICHEE_BR_OUT}/external toolchain\" mkdir p ${tooldir} if [ f ${tooldir}/.installed ] ; then printf \"external toolchain has been installed\\n\" else printf \"installing external toolchain\\n\" printf \"please wait for a few minutes \\n\" tar strip components 1 \\ jxf ${LICHEE_BR_DIR}/dl/gcc linaro.tar.bz2 \\ C ${tooldir} [ $? eq 0 ] && touch ${tooldir}/.installed fi export PATH ${tooldir}/bin:${PATH} } ``` 这里LICHEE_BR_OUT是 **lichee/out/sun8iw8p1/linux/common/buildroot** LICHEE_BR_DIR是lichee/buildroot, 需要先导入。 这里使用的linaro版本比较老。注意如果使用较新的gcc反而会出错。 这里就是解压了linaro gcc，并加入到环境变量。 mkbr看完了，接下来看mkkernel。 ``` function mkkernel() { local platformdef $tdevice if [ ! n $tdevice ]; then echo \"Please lunch device\" return 1 fi echo \"Make the kernel\" echo \"platformdef \"${platformdef} (cd ${LICHEE_KERN_DIR}/; ./build.sh p ${platformdef}) [ $? ne 0 ] && mk_error \"build mkkernel fail\" && return 1 echo \"Make the kernel finish\" return 0 } ``` 执行的是lichee/linux 3.4/build.sh, 跟下去是执行了： > `./scripts/build_${PLATFORM}.sh all` 看script目录下，有： build_crane cdr.sh build_crane ipc.sh build_crane sdv.sh build_crane standard.sh build_rootfs.sh build.sh build_sun6i.sh build_sun8iw8p1.sh build_tiger cdr.sh build_tiger ipc.sh build_tiger standard.sh 就是代表的可以构建的板子型号。我们实际编译的时候只需要执行 **build_tiger cdr.sh** 即可。 综上所述，需要剥离camdriod所用的lichee内核，只需要： > 1. 解压buildroot/dl/gcc linarno.tar.gz > 到lichee/out/sun8iw8p1/linux/common/buildroot/external toolchain，并加入环境变量（这步其实在下一步里包含了） > 2. 执行build_tiger cdr.sh ## 启动信息 ``` Starting kernel [sun8i_fixup]: From boot, get meminfo: Start: 0x40000000 Size: 64MB ion_carveout reserve: 28m@0 28m@0 ion_reserve_common: ion reserve: [0x42400000, 0x44000000]! [ 0.000000] Booting Linux on physical CPU 0 [ 0.000000] Linux version 3.4.39 (root@bf756b445919) (gcc version 4.6.3 20120201 (prerelease) (crosstool NG linaro 1.13.1 2012.02 20120222 Linaro GCC 2012.02) ) #29 Wed Nov 29 10:53:16 UTC 2017 [ 0.000000] bootconsole [earlycon0] enabled [ 0.000000] Initialized persistent memory from 41d20800 41d307ff [ 0.000000] Kernel command line: console ttyS0,115200 panic 5 rootwait root /dev/mmcblk0p2 earlyprintk rw [ 0.000000] PID hash table entries: 256 (order: 2, 1024 bytes) [ 0.000000] Dentry cache hash table entries: 8192 (order: 3, 32768 bytes) [ 0.000000] Inode cache hash table entries: 4096 (order: 2, 16384 bytes) [ 0.000000] Memory: 64MB 64MB total [ 0.000000] Memory: 29312k/29312k available, 36224k reserved, 0K highmem [ 0.000000] Virtual kernel memory layout: [ 0.000000] vector : 0xffff0000 0xffff1000 ( 4 kB) [ 0.000000] fixmap : 0xfff00000 0xfffe0000 ( 896 kB) [ 0.000000] vmalloc : 0xc4800000 0xff000000 ( 936 MB) [ 0.000000] lowmem : 0xc0000000 0xc4000000 ( 64 MB) [ 0.000000] modules : 0xbf000000 0xc0000000 ( 16 MB) [ 0.000000] .text : 0xc0008000 0xc050d000 (5140 kB) [ 0.000000] .init : 0xc050d000 0xc0530000 ( 140 kB) [ 0.000000] .data : 0xc0530000 0xc05ab500 ( 494 kB) [ 0.000000] .bss : 0xc05ab524 0xc068c28c ( 900 kB) [ 0.000000] NR_IRQS:544 [ 0.000000] Architected local timer running at 24.00MHz. [ 0.000000] Switching to timer based delay loop [ 0.000000] sched_clock: 32 bits at 24MHz, resolution 41ns, wraps every 178956ms [ 0.000000] Console: colour dummy device 80x30 [ 0.014545] Calibrating delay loop (skipped), value calculated using timer frequency.. 4800.00 BogoMIPS (lpj 24000000) [ 0.022936] pid_max: default: 32768 minimum: 301 [ 0.027778] Mount cache hash table entries: 512 [ 0.030637] CPU: Testing write buffer coherency: ok [ 0.035150] Setting up static identity map for 0x40396048 0x403960a0 [ 0.040773] devtmpfs: initialized [ 0.045346] pinctrl core: initialized pinctrl subsystem [ 0.049168] NET: Registered protocol family 16 [ 0.050362] DMA: preallocated 128 KiB pool for atomic coherent allocations [ 0.056956] script_sysfs_init success [ 0.060951] gpiochip_add: registered GPIOs 0 to 223 on device: sunxi pinctrl [ 0.068164] sunxi pinctrl sunxi pinctrl: initialized sunXi PIO driver [ 0.070438] gpiochip_add: registered GPIOs 1024 to 1031 on device: axp pinctrl [ 0.078235] persistent_ram: uncorrectable error in header [ 0.080020] persistent_ram: no valid data in buffer (sig 0x75371537) [ 0.091722] console [ram 1] enabled [ 0.092266] Not Found clk pll_isp in script [ 0.094113] Not Found clk pll_video in script [ 0.098719] Not Found clk pll_ve in script [ 0.100012] Not Found clk pll_periph0 in script [ 0.104666] Not Found clk pll_de in script [ 0.113517] bio: create slab <bio 0> at 0 [ 0.113966] pwm module init! [ 0.118375] SCSI subsystem initialized [ 0.120028] usbcore: registered new interface driver usbfs [ 0.125313] usbcore: registered new interface driver hub [ 0.130165] usbcore: registered new device driver usb [ 0.135149] twi_chan_cfg()340 [twi0] has no twi_regulator. [ 0.140018] twi_chan_cfg()340 [twi1] has no twi_regulator. [ 0.146123] Linux video capture interface: v2.00 [ 0.150126] gpiochip_add: gpios 1024..1028 (axp_pin) failed to register [ 0.156916] Advanced Linux Sound Architecture Driver Version 1.0.25. [ 0.160794] Switching to clocksource arch_sys_counter [ 0.171015] NET: Registered protocol family 2 [ 0.171466] IP route cache hash table entries: 1024 (order: 0, 4096 bytes) [ 0.177306] TCP established hash table entries: 2048 (order: 2, 16384 bytes) [ 0.184207] TCP bind hash table entries: 2048 (order: 1, 8192 bytes) [ 0.190440] TCP: Hash tables configured (established 2048 bind 2048) [ 0.196921] TCP: reno registered [ 0.200126] UDP hash table entries: 256 (order: 0, 4096 bytes) [ 0.206122] UDP Lite hash table entries: 256 (order: 0, 4096 bytes) [ 0.212647] NET: Registered protocol family 1 [ 0.217253] standby_mode 1. [ 0.219870] wakeup src cnt is : 3. [ 0.223491] pmu1_enable 0x0. [ 0.226639] config_pmux_para: script_parser_fetch err. [ 0.232034] pmu2_enable 0x0. [ 0.235126] add_sys_pwr_dm: get ldo name failed [ 0.239818] add_sys_pwr_dm: get ldo name failed [ 0.244317] add_sys_pwr_dm: get ldo name failed [ 0.248900] add_sys_pwr_dm: get ldo name failed [ 0.253610] add_sys_pwr_dm: get ldo name failed [ 0.258090] add_sys_pwr_dm: get ldo name failed [ 0.262796] add_sys_pwr_dm: get ldo name failed [ 0.267274] add_sys_pwr_dm: get ldo name failed [ 0.271877] add_sys_pwr_dm: get ldo name failed [ 0.276566] add_sys_pwr_dm: get ldo name failed [ 0.281061] after inited: sys_mask config 0x0. [ 0.285927] dynamic_standby enalbe 0x0. [ 0.290049] sunxi_reg_init enter [ 0.295521] squashfs: version 4.0 (2009/01/31) Phillip Lougher [ 0.299326] jffs2: version 2.2. (NAND) (SUMMARY) © 2001 2006 Red Hat, Inc. [ 0.306584] msgmni has been set to 57 [ 0.311246] io scheduler noop registered [ 0.313995] io scheduler deadline registered [ 0.318410] io scheduler cfq registered (default) [ 0.323712] [DISP]disp_module_init [ 0.326990] cmdline,disp [ 0.329889] [DISP] disp_get_rotation_sw,line:68:disp 0 out of range? g_rot_sw 0 [ 0.336609] [DISP] disp_init_connections,line:289:NULL pointer: 0, 0 [ 0.344754] [DISP] Fb_map_kernel_logo,line:924:Fb_map_kernel_logo failed! [ 0.352381] [DISP] disp_sys_power_enable,line:387:some error happen, fail to get regulator [ 0.358275] [DISP] disp_sys_gpio_set_value,line:374:OSAL_GPIO_DevWRITE_ONEPIN_DATA, hdl is NULL [ 0.367297] [DISP]disp_module_init finish [ 0.371458] sw_uart_get_devinfo()1503 uart0 has no uart_regulator. [ 0.378007] uart0: ttyS0 at MMIO 0x1c28000 (irq 32) is a SUNXI [ 0.383640] sw_uart_pm()890 uart0 clk is already enable [ 0.389159] sw_console_se󙞠 0.397781] console [ttyS0] enabled, bootconsole disabled [ 0.397781] console [ttyS0] enabled, bootconsole disabled [ 0.405808] sunxi_spi_chan_cfg()1376 [spi 0] has no spi_regulator. [ 0.417215] spi spi0: master is unqueued, this is deprecated [ 0.423980] m25p_probe()988 Use the Dual Mode Read. [ 0.429818] m25p80 spi0.0: found W25q128, expected at25df641 [ 0.436364] m25p80 spi0.0: W25q128 (16384 Kbytes) [ 0.442069] Creating 4 MTD partitions on \"spi0.0\": [ 0.447623] 0x000000000000 0x000000100000 : \"uboot\" [ 0.454335] 0x000000100000 0x000000110000 : \"script\" [ 0.461007] 0x000000110000 0x000000510000 : \"kernel\" [ 0.467737] 0x000000510000 0x000001000000 : \"rootfs\" [ 0.474560] ehci_hcd: USB 2.0 'Enhanced' Host Controller (EHCI) Driver [ 0.502308] sunxi ehci sunxi ehci.1: SW USB2.0 'Enhanced' Host Controller (EHCI) Driver [ 0.511538] sunxi ehci sunxi ehci.1: new USB bus registered, assigned bus number 1 [ 0.520232] sunxi ehci sunxi ehci.1: irq 104, io mem 0xf1c1a000 [ 0.540038] sunxi ehci sunxi ehci.1: USB 0.0 started, EHCI 1.00 [ 0.547565] hub 1 0:1.0: USB hub found [ 0.552045] hub 1 0:1.0: 1 port detected [ 0.557035] sunxi ehci sunxi ehci.1: remove, state 1 [ 0.562716] usb usb1: USB disconnect, device number 1 [ 0.570093] [DISP] disp_lcd_pwm_enable,line:1021:pwm device hdl is NULL [ 0.577820] sunxi ehci sunxi ehci.1: USB bus 1 deregistered [ 0.594381] ohci_hcd: USB 1.1 'Open' Host Controller (OHCI) Driver [ 0.621611] sunxi ohci sunxi ohci.1: SW USB2.0 'Open' Host Controller (OHCI) Driver [ 0.630292] sunxi ohci sunxi ohci.1: new USB bus registered, assigned bus number 1 [ 0.638963] sunxi ohci sunxi ohci.1: irq 105, io mem 0xf1c1a400 [ 0.704775] hub 1 0:1.0: USB hub found [ 0.709188] hub 1 0:1.0: 1 port detected [ 0.714159] sunxi ohci sunxi ohci.1: remove, state 1 [ 0.719942] usb usb1: USB disconnect, device number 1 [ 0.726383] sunxi ohci sunxi ohci.1: USB bus 1 deregistered [ 0.742856] Initializing USB Mass Storage driver [ 0.748591] usbcore: registered new interface driver usb storage [ 0.755417] USB Mass Storage support registered. [ 0.761162] file system registered [ 0.766892] android_usb gadget: Mass Storage Function, version: 2009/09/11 [ 0.774821] android_usb gadget: Number of LUNs 1 [ 0.780100] lun0: LUN: removable file: (no medium) [ 0.786312] android_usb gadget: android_usb ready [ 0.791843] sunxikbd_script_init: key para not found, used default para. [ 0.800884] sunxi rtc sunxi rtc: rtc core: registered sunxi rtc as rtc0 [ 0.808628] [VFE]cci probe start cci_sel 0! [ 0.813793] [VFE]cci probe end cci_sel 0! [ 0.818593] [VFE]cci_init end [ 0.822038] [VFE]Welcome to Video Front End driver [ 0.827986] [VFE]pdev >id 0 [ 0.831435] [VFE]dev >mipi_sel 0 [ 0.835324] [VFE]dev >vip_sel 0 [ 0.839114] [VFE]dev >isp_sel 0 [ 0.849164] [VFE_WARN]vfe vpu clock is null [ 0.860599] [VFE]pdev >id 1 [ 0.864021] [VFE]dev >mipi_sel 1 [ 0.868014] [VFE]dev >vip_sel 1 [ 0.871864] [VFE]dev >isp_sel 0 [ 0.875672] [VFE]probe_work_handle start! [ 0.880358] [VFE] ..vfe clk open! .. [ 0.889010] [VFE]v4l2 subdev register input_num 0 [ 0.894683] [VFE_WARN]vfe vpu clock is null [ 0.899688] [VFE_ERR]vip1 request pinctrl handle for device [csi1] failed! [ 0.907603] [VFE_ERR]get regulator csi_avdd error! [ 0.913056] [VFE_ERR]vfe_device_regulator_get error at input_num 0 [ 0.920482] [VFE]vfe_init end [ 0.924426] platform reg 20 cs dcdc2: Driver reg 20 cs dcdc2 requests probe deferral [ 0.933586] [VFE]V4L2 device registered as video0 [ 0.938969] [VFE] ..vfe clk close! .. [ 0.947676] platform reg 20 cs dcdc3: Driver reg 20 cs dcdc3 requests probe deferral [ 0.956440] [VFE]probe_work_handle end! [ 0.960938] [VFE]probe_work_handle start! [ 0.965515] [VFE] ..vfe clk open! .. [ 0.974033] platform reg 20 cs ldo1: Driver reg 20 cs ldo1 requests probe deferral [ 0.982739] platform reg 20 cs ldo2: Driver reg 20 cs ldo2 requests probe deferral [ 0.991682] [VFE]v4l2 subdev register input_num 0 [ 0.997227] [VFE]vfe sensor detect start! input_num 0 [ 1.003274] [VFE]Find sensor name is \"ov2640\", i2c address is 60, type is \"YUV\" ! [ 1.011824] [VFE]Sub device register \"ov2640\" i2c_addr 0x60 start! [ 1.018998] [VFE_ERR]Error registering v4l2 subdevice No such device! [ 1.026388] [VFE_ERR]vfe sensor register check error at input_num 0 [ 1.033813] platform reg 20 cs ldo3: Driver reg 20 cs ldo3 requests probe deferral [ 1.042602] platform reg 20 cs ldo4: Driver reg 20 cs ldo4 requests probe deferral [ 1.051390] platform reg 20 cs ldoio0: Driver reg 20 cs ldoio0 requests probe deferral [ 1.060339] sunxi_wdt_init_module: sunxi WatchDog Timer Driver v1.0 [ 1.067734] sunxi_wdt_probe: devm_ioremap return wdt_reg 0xf1c20ca0, res >start 0x01c20ca0, res >end 0x01c20cbf [ 1.079242] [VFE]V4L2 device registered as video1 [ 1.084960] [VFE] ..vfe clk close! .. [ 1.093623] sunxi_wdt_probe: initialized (g_timeout 16s, g_nowayout 0) [ 1.101032] wdt_enable, write reg 0xf1c20cb8 val 0x00000000 [ 1.107445] wdt_set_tmout, write 0x000000b0 to mode reg 0xf1c20cb8, actual timeout 16 sec [ 1.116779] [VFE]probe_work_handle end! [ 1.127839] sunxi_leds_fetch_sysconfig_para leds is not used in config [ 1.135343] script_get_err [ 1.140895] usbcore: registered new interface driver usbhid [ 1.147192] usbhid: USB HID core driver [ 1.152295] ashmem: initialized [ 1.156010] logger: created 256K log 'log_main' [ 1.161344] logger: created 32K log 'log_events' [ 1.166840] logger: created 32K log 'log_radio' [ 1.173330] logger: created 32K log 'log_system' [ 1.181135] *******************Try sdio******************* [ 1.188578] script_get_item return type err, consider it no ldo [ 1.196448] asoc: sndcodec < > sunxi codec mapping ok [ 1.203087] *******************Try sd ******************* [ 1.210630] TCP: cubic registered [ 1.214424] NET: Registered protocol family 17 [ 1.219580] VFP support v0.3: implementor 41 architecture 2 part 30 variant 7 rev 5 [ 1.228464] ThumbEE CPU extension supported. [ 1.233373] Registering SWP/SWPB emulation handler [ 1.243467] platform reg 20 cs ldoio0: Driver reg 20 cs ldoio0 requests probe deferral [ 1.252523] platform reg 20 cs ldo4: Driver reg 20 cs ldo4 requests probe deferral [ 1.261210] platform reg 20 cs ldo3: Driver reg 20 cs ldo3 requests probe deferral [ 1.269839] platform reg 20 cs ldo2: Driver reg 20 cs ldo2 requests probe deferral [ 1.278387] platform reg 20 cs ldo1: Driver reg 20 cs ldo1 requests probe deferral [ 1.287040] platform reg 20 cs dcdc3: Driver reg 20 cs dcdc3 requests probe deferral [ 1.295877] platform reg 20 cs dcdc2: Driver reg 20 cs dcdc2 requests probe deferral [ 1.304676] sunxi rtc sunxi rtc: setting system clock to 1970 01 01 00:52:23 UTC (3143) [ 1.315547] ALSA device list: [ 1.318966] #0: audiocodec [ 1.322763] Waiting for root device /dev/mmcblk0p2 [ 1.330265] mmc0: new high speed SDHC card at address 0007 [ 1.336986] mmcblk0: mmc0:0007 SD16G 14.4 GiB [ 1.344244] mmcblk0: p1 p2 [ 1.348240] mmcblk mmc0:0007: Card claimed for testing. [ 1.354284] mmc0:0007: SD16G 14.4 GiB [ 1.358650] platform reg 20 cs dcdc2: Driver reg 20 cs dcdc2 requests probe deferral [ 1.367505] *******************sd init ok******************* [ 1.373971] platform reg 20 cs dcdc3: Driver reg 20 cs dcdc3 requests probe deferral [ 1.382857] platform reg 20 cs ldo1: Driver reg 20 cs ldo1 requests probe deferral [ 1.392791] platform reg 20 cs ldo2: Driver reg 20 cs ldo2 requests probe deferral [ 1.401342] platform reg 20 cs ldo3: Driver reg 20 cs ldo3 requests probe deferral [ 1.409966] platform reg 20 cs ldo4: Driver reg 20 cs ldo4 requests probe deferral [ 1.418782] platform reg 20 cs ldoio0: Driver reg 20 cs ldoio0 requests probe deferral [ 1.430110] fs_names /dev/root [ 1.433712] fs_name ext3 [ 1.439951] EXT4 fs (mmcblk0p2): couldn't mount as ext3 due to feature incompatibilities [ 1.451442] err 22 [ 1.453911] fs_name ext2 [ 1.456821] *******************Try sdio******************* [ 1.465105] EXT4 fs (mmcblk0p2): couldn't mount as ext2 due to feature incompatibilities [ 1.474453] err 22 [ 1.476890] fs_name ext4 [ 1.489053] mmc1: new high speed SDIO card at address 0001 [ 1.495719] *******************sdio init ok******************* [ 2.726144] EXT4 fs (mmcblk0p2): mounted filesystem with ordered data mode. Opts: (null) [ 2.735371] VFS: Mounted root (ext4 filesystem) on device 179:2. [ 2.742251] err 0 [ 2.747567] devtmpfs: mounted [ 2.751204] Freeing init memory: 140K [ 2.930884] systemd[1]: systemd 215 running in system mode. (+PAM +AUDIT +SELINUX +IMA +SYSVINIT +LIBCRYPTSETUP +GCRYPT +ACL +XZ SECCOMP APPARMOR) [ 2.946338] systemd[1]: Detected architecture 'arm'. Welcome to Debian GNU/Linux 8 (jessie)! [ 3.001376] systemd[1]: Failed to insert module 'autofs4' [ 3.007740] systemd[1]: Failed to insert module 'ipv6' [ 3.016049] systemd[1]: Set hostname to <LicheePi>. [ 3.386763] systemd[1]: Cannot add dependency job for unit dbus.socket, ignoring: Unit dbus.socket failed to load: No such file or directory. [ 3.401457] systemd[1]: Cannot add dependency job for unit display manager.service, ignoring: Unit display manager.service failed to load: No such file or directory. [ 3.420884] systemd[1]: Expecting device dev ttyS0.device Expecting device dev ttyS0.device [ 3.450242] systemd[1]: Starting Forward Password Requests to Wall Directory Watch. [ 3.459321] systemd[1]: Started Forward Password Requests to Wall Directory Watch. [ 3.468062] systemd[1]: Starting Remote File Systems (Pre). [ OK ] Reached target Remote File Systems (Pre). [ 3.490182] systemd[1]: Reached target Remote File Systems (Pre). [ 3.497335] systemd[1]: Starting Dispatch Password Requests to Console Directory Watch. [ 3.506789] systemd[1]: Started Dispatch Password Requests to Console Directory Watch. [ 3.515820] systemd[1]: Starting Paths. [ OK ] Reached target Paths. [ 3.540183] systemd[1]: Reached target Paths. [ 3.545244] systemd[1]: Starting Encrypted Volumes. [ OK ] Reached target Encrypted Volumes. [ 3.570180] systemd[1]: Reached target Encrypted Volumes. [ 3.576595] systemd[1]: Set up automount Arbitrary Executable File Formats File System Automount Point. [ 3.587363] systemd[1]: Starting Swap. [ OK ] Reached target Swap. [ 3.610166] systemd[1]: Reached target Swap. [ 3.615133] systemd[1]: Expecting device dev mmcblk0p1.device Expecting device dev mmcblk0p1.device [ 3.640202] systemd[1]: Starting Root Slice. [ OK ] Created slice Root Slice. [ 3.660178] systemd[1]: Created slice Root Slice. [ 3.665716] systemd[1]: Starting /dev/initctl Compatibility Named Pipe. [ OK ] Listening on /dev/initctl Compatibility Named Pipe. [ 3.690188] systemd[1]: Listening on /dev/initctl Compatibility Named Pipe. [ 3.698235] systemd[1]: Starting Delayed Shutdown Socket. [ OK ] Listening on Delayed Shutdown Socket. [ 3.720181] systemd[1]: Listening on Delayed Shutdown Socket. [ 3.726873] systemd[1]: Starting Journal Socket (/dev/log). [ OK ] Listening on Journal Socket (/dev/log). [ 3.750183] systemd[1]: Listening on Journal Socket (/dev/log). [ 3.757124] systemd[1]: Starting udev Control Socket. [ OK ] Listening on udev Control Socket. [ 3.780183] systemd[1]: Listening on udev Control Socket. [ 3.786538] systemd[1]: Starting udev Kernel Socket. [ OK ] Listening on udev Kernel Socket. [ 3.810188] systemd[1]: Listening on udev Kernel Socket. [ 3.816409] systemd[1]: Starting User and Session Slice. [ OK ] Created slice User and Session Slice. [ 3.840194] systemd[1]: Created slice User and Session Slice. [ 3.846923] systemd[1]: Starting Journal Socket. [ OK ] Listening on Journal Socket. [ 3.870194] systemd[1]: Listening on Journal Socket. [ 3.876115] systemd[1]: Starting Sockets. [ OK ] Reached target Sockets. [ 3.900178] systemd[1]: Reached target Sockets. [ 3.905463] systemd[1]: Starting System Slice. [ OK ] Created slice System Slice. [ 3.930189] systemd[1]: Created slice System Slice. [ 3.935980] systemd[1]: Started Create list of required static device nodes for the current kernel. [ 3.946850] systemd[1]: Mounting Debug File System Mounting Debug File System [ 3.972002] systemd[1]: Mounted POSIX Message Queue File System. [ 3.985664] systemd[1]: Starting Load Kernel Modules Starting Load Kernel Modules [ 4.016065] systemd[1]: Started Set Up Additional Binary Formats. [ 4.024319] systemd[1]: Mounted Huge Pages File System. [ 4.036274] systemd[1]: Starting udev Coldplug all Devices Starting udev Coldplug all Devices [ 4.062631] systemd[1]: Starting Create Static Device Nodes in /dev Starting Create Static Device Nodes in /dev [ 4.092537] systemd[1]: Starting system getty.slice. [ OK ] Created slice system getty.slice. [ 4.112748] systemd[1]: Created slice system getty.slice. [ 4.122317] systemd[1]: Starting system serial\\x2dgetty.slice. [ OK ] Created slice system serial\\x2dgetty.slice. [ 4.150268] systemd[1]: Created slice system serial\\x2dgetty.slice. [ 4.157615] systemd[1]: Started File System Check on Root Device. [ 4.164807] systemd[1]: Starting Journal Service Starting Journal Service [ OK ] Started Journal Service. [ 4.210299] systemd[1]: Started Journal Service. [ OK ] Reached target Slices. [ OK ] Mounted Debug File System. [ OK ] Started Load Kernel Modules. [ OK ] Started Create Static Device Nodes in /dev. Starting udev Kernel Device Manager Starting Apply Kernel Variables [ OK ] Started udev Kernel Device Man[ 4.372555] systemd udevd[69]: starting version 215 ager. [ OK ] Started udev Coldplug all Devices. [ OK ] Started Apply Kernel Variables. Starting Copy rules generated while the root was ro Starting LSB: Set preliminary keymap [ OK ] Started Copy rules generated while the root was ro. [ OK ] Started LSB: Set preliminary keymap. Starting Remount Root and Kernel File Systems [ 4.640531] EXT4 fs (mmcblk0p2): re mounted. Opts: (null) [ OK ] Started Remount Root and Kernel File Systems. [ OK ] Reached target Local File Systems (Pre). Starting Load/Save Random Seed [ OK ] Reached target Sound Card. [ OK ] Started Load/Save Random Seed. [ 5.012110] [VFE]vfe_open [ OK [ 5.043465] [VFE]vfe_open ] Found device /dev/mmcblk0p1. [ 5.058511] [VFE] ..vfe clk open! .. [ 5.082179] [VFE] ..vfe clk open! .. [ OK ] Found device /dev/ttyS0. [ 5.112320] [VFE]vfe_open ok [ 5.115853] [VFE]vfe_close [ 5.118958] [VFE]vfe select input flag 0, s_input have not be used . [ 5.126480] [VFE] ..vfe clk close! .. [ 5.144821] [VFE]vfe_open ok [ 5.148348] [VFE]vfe_close [ 5.151598] [VFE]vfe select input flag 0, s_input have not be used . [ 5.158972] [VFE] ..vfe clk close! .. Mounting /boot [ 5.224773] [VFE]vfe_close end [ 5.282919] [VFE]vfe_close end [ OK ] Mounted /boot. [ OK ] Reached target Local File Systems. Starting Create Volatile Files and Directories [ OK ] Reached target Remote File Systems. Starting Trigger Flushing of Journal to Persistent Storage Starting LSB: Set console font and keymap Starting LSB: Raise network interfaces . [ OK ] Started LSB: Set console font and keymap. [ 5.519209] systemd journald[65]: Received request to flush runtime journal from PID 1 [ OK ] Started Trigger Flushing of Journal to Persistent Storage. [ OK ] Started Create Volatile Files and Directories. Starting Update UTMP about System Boot/Shutdown [ OK ] Started Update UTMP about System Boot/Shutdown. [ OK ] Started LSB: Raise network interfaces.. [ OK ] Reached target Network. [ OK ] Reached target System Initialization. [ OK ] Reached target Timers. Starting Restore Sound Card State [ OK ] Reached target Basic System. Starting Regular background program processing daemon [ OK ] Started Regular background program processing daemon. Starting OpenBSD Secure Shell server [ OK ] Started OpenBSD Secure Shell server. Starting /etc/rc.local Compatibility Starting Permit User Sessions Starting getty on tty2 tty6 if dbus and logind are not available [ OK ] Started Restore Sound Card State. [ OK ] Started /etc/rc.local Compatibility. [ OK ] Started Permit User Sessions. Starting Getty on tty2 [ OK ] Started Getty on tty2. Starting Getty on tty1 [ OK ] Started Getty on tty1. Starting Serial Getty on ttyS0 [ OK ] Started Serial Getty on ttyS0. [ OK ] Started getty on tty2 tty6 if dbus and logind are not available. Starting Getty on tty6 [ OK ] Started Getty on tty6. Starting Getty on tty5 [ OK ] Started Getty on tty5. Starting Getty on tty4 [ OK ] Started Getty on tty4. Starting Getty on tty3 [ OK ] Started Getty on tty3. [ OK ] Reached target Login Prompts. [ OK ] Reached target Multi User System. [ OK ] Reached target Graphical Interface. Starting Update UTMP about System Runlevel Changes [ OK ] Started Update UTMP about System Runlevel Changes. Debian GNU/Linux 8 LicheePi ttyS0 LicheePi login: root ```"},"/soft/Lichee/zh/Zero-Doc/System_Development/start_basic_use.html":{"title":"基础使用","content":"# 基础使用 进行完前面的烧录步骤后我们可以启动 Zero 了。 下面的都是用前面提到过的 Zero_pub_V0.3.gz 里面的镜像来说明基础使用 ## 连接串口 对于zero的串口根据板子上的丝印应该是使用 U0T R 这两个 uart0 引脚作为通信引脚。对应的位置可以参考下面图片： 其中的 UART0 的两个引脚就是我们要用的。 ![](./../static/start/board_intro_1.png) ## 相关使用 ### 登录 对于使用 Zero_pub_V0.3.gz 压缩包里面的镜像所烧录的系统。 用户名 ： `root` 密码 ： `licheepi` ### 使用显示屏 运行在 /root/ 目录下的 demo 程序可以看到接在RGB接口的屏幕显示出了画面 ```bash /root/demo ``` 要注意的是默认的 demo 显示分辨虑为 480\\*800，因此在 480\\*272 的屏幕上会显示的不完整 （未完待续）"},"/soft/Lichee/zh/Zero-Doc/System_Development/uboot_conf.html":{"title":"Uboot 配置","content":" title: Uboot 配置 > 内容整理自： 贡献投稿篇 > 投稿文章精选 > Zero u boot编译和使用指南 ## Uboot配置命令 `make ARCH arm menuconfig` ![](./../static/System_Development/uboot_conf_1.png) 按回车，即选择当前菜单 按Y 代表该config选项选中 按N 代表不选中该选项 按M 代表该驱动编译成*.ko的方式，在系统起来之后，当驱动需要的时候加载 </> 按/ 可以查找某个选项 退出 < * > 按Y选中后的状态 **这里面有几个常见的配置选项我们可以看下：** 1. 第一个Architecture select架构选择，不用质疑这个是ARM架构 2. 第二个ARM architecture 这个选项比较重要，主要配置ARM框架下的常用的配置函数以及LCD等参数 ![](./../static/System_Development/uboot_conf_2.png) ## DDR配置 ``` ··· Target select (Support sunxi (Allwinner) SoCs) #进去之后可以选择sunxi Soc系列芯片 ··· [*] Sunxi SoC Variant # 这个就是对芯片Soc 的选择，我们可以看到配置选择了`sun8i (Allwinner V3s) (360) sunxi dram clock speed # 配置dram的时钟速率 (14779) sunxi dram zq value # 配置dram的ZQ值，是用来动态加强DDR3的 * Board uses DDR2 DRAM # 使用DDR2 DRAM ``` ## LCD配置 ![](./../static/System_Development/uboot_conf_3.png) ``` [*] Enable graphical uboot console on HDMI, LCD or VGA 这个就是在显示设备上使能串口控制 [ ] VGA via LCD controller support 使能支持VGA通过LCD的控制器，就是LCD和VAG转换需要的控制器 (x:800,y:480,depth:18,pclk_khz:33000,le:87,ri:40,up:31,lo:13,hs:1,vs:1,sync:3,vmode:0) LCD pane > 该选项就是配置LCD的分辨率的配置选项可以看到x是800 y是480 等等一些关于LCD的配置内容，点击回车进去可以对其进行修改。 (1) LCD panel display clock phase 这个是LCD的显示时钟相位 () LCD panel power enable pin LCD的电源使能引脚 () LCD panel reset pin LCD的复位引脚 (PB4) LCD panel backlight pwm pin 背光PWN引脚 这个应该是调节亮度的引脚PB4 [*] LCD panel backlight pwm is inverted 反转PWN背光引脚 [ ] LCD panel needs to be configured via i2c LCD panel support (Generic parallel interface LCD panel) > 这个选择支持的LCDpanel (X) Generic parallel interface LCD panel 这里选择支持通用的并行的LCD接口 ( ) Generic lvds interface LCD panel 这个是LVDS接口 ( ) MIPI 4 lane, 513Mbps LCD panel via SSD2828 bridge chip ( ) eDP 4 lane, 1.62G LCD panel via ANX9804 bridge chip ( ) Hitachi tx18d42vm LCD panel ( ) tl059wv5c0 LCD panel (0) GMAC Transmit Clock Delay Chain ``` ## 时钟频率配置 `Boot images >(1008000000) CPU clock frequency` 这里设置了CPU的时钟频率 ## 开机延时设置 `delay in seconds before automatically booting` 这个是uboot开机的时候的一个等待时间的秒数，可以改大一点，默认是2s ## SPL配置 ``` SPL / TPL > 这个就是SPL相关的配置了 [*] MMC raw mode: by sector 按扇区 (0x50) Address on the MMC to load U Boot from mmc加载uboot的地址 [*] Support GPIO 支持GPIO [*] Support I2C 支持I2C [*] Support common libraries 支持通用lib [*] Support disk paritions 支持分区 [*] Support generic libraries 支持一般lib库 [*] Support MMC 支持MMC [*] Support power drivers 支持电源驱动 [*] Support serial 支持串口 ```"},"/soft/Lichee/zh/Zero-Doc/System_Development/filesys_index.html":{"title":"根文件系统编译","content":" title: 根文件系统编译 本节将讲解buildroot及emdebian两种根文件系统的编译过程"},"/soft/Lichee/zh/Zero-Doc/System_Development/SPI_falsh_doc6.html":{"title":"关于系统reboot","content":" title: 关于系统reboot 在使用spi flash时，执行reboot命令，有时会无法重启，这里追查下原因。 ## 正常重启信息 # reboot # Stopping network: OK Saving random seed done. Stopping logging: OK umount: devtmpfs busy remounted read only [ 16.812893] EXT4 fs (mmcblk0p2): re mounted. Opts: (null) Sent SIGTERM to all processes Sent SIGKILL to all processes Requesting system reboot [ 18.830716] reboot: Restarting system ``` void kernel_restart(char *cmd) { kernel_restart_prepare(cmd); migrate_to_reboot_cpu(); syscore_shutdown(); if (!cmd) pr_emerg(\"Restarting system\\n\"); else pr_emerg(\"Restarting system with command '%s'\\n\", cmd); kmsg_dump(KMSG_DUMP_RESTART); machine_restart(cmd); } ``` arch/arm/kernel/setup.c: `arm_pm_restart mdesc >restart;` ## 重启失败 ``` void machine_restart(char *cmd) { local_irq_disable(); smp_send_stop(); if (arm_pm_restart) arm_pm_restart(reboot_mode, cmd); else do_kernel_restart(cmd); //正常来说不会走到这里 /* Give a grace period for failure to restart of 1s */ mdelay(1000); /* Whoops the platform was unable to reboot. Tell the user! */ printk(\"Reboot failed System halted\\n\"); while (1); } ``` ``` void do_kernel_restart(char *cmd) { atomic_notifier_call_chain(&restart_handler_list, reboot_mode, cmd); } register_restart_handler ``` ``` int atomic_notifier_call_chain(struct atomic_notifier_head *nh, unsigned long val, void *v) { return __atomic_notifier_call_chain(nh, val, v, 1, NULL); } ``` spi flash问题 [ 312.719945] INFO: trying to register non static key. [ 312.724967] the code is fine but needs lockdep annotation. [ 312.730448] turning off the locking correctness validator. [ 312.735943] CPU: 0 PID: 162 Comm: sync Not tainted 4.13.0 licheepi zero+ #55 [ 312.742981] Hardware name: Allwinner sun8i Family [ 312.747734] [<c010e8a8>] (unwind_backtrace) from [<c010b594>] (show_stack+0x10/0x14) [ 312.755483] [<c010b594>] (show_stack) from [<c048ec4c>] (dump_stack+0x84/0x98) [ 312.762711] [<c048ec4c>] (dump_stack) from [<c015e698>] (register_lock_class+0x3f8/0x624) [ 312.770886] [<c015e698>] (register_lock_class) from [<c015fb0c>] (__lock_acquire.constprop.7+0x60/0x954) [ 312.780358] [<c015fb0c>] (__lock_acquire.constprop.7) from [<c0160468>] (lock_acquire+0x68/0x84) [ 312.789143] [<c0160468>] (lock_acquire) from [<c0132498>] (flush_work+0x50/0x290) [ 312.796624] [<c0132498>] (flush_work) from [<c0133f00>] (__cancel_work_timer+0xec/0x1c4) [ 312.804722] [<c0133f00>] (__cancel_work_timer) from [<c028d1b4>] (jffs2_sync_fs+0x14/0x38) [ 312.812995] [<c028d1b4>] (jffs2_sync_fs) from [<c0207e30>] (iterate_supers+0xc0/0x120) [ 312.820912] [<c0207e30>] (iterate_supers) from [<c0233708>] (sys_sync+0x44/0xa4) [ 312.828310] [<c0233708>] (sys_sync) from [<c0107620>] (ret_fast_syscall+0x0/0x3c) ``` static int jffs2_sync_fs(struct super_block *sb, int wait) { struct jffs2_sb_info *c JFFS2_SB_INFO(sb); #ifdef CONFIG_JFFS2_FS_WRITEBUFFER cancel_delayed_work_sync(&c >wbuf_dwork); #endif mutex_lock(&c >alloc_sem); jffs2_flush_wbuf_pad(c); mutex_unlock(&c >alloc_sem); return 0; } bool cancel_delayed_work_sync(struct delayed_work *dwork) { return __cancel_work_timer(&dwork >work, true); } EXPORT_SYMBOL(cancel_delayed_work_sync); ``` **CONFIG_JFFS2_FS_WRITEBUFFER** 去掉，可以不出现oops信息 ## 原因 是使用了32Mflash，在重启的时候，没有退出4 byte地址模式导致。（因为板子上没有PMU，没有对flash进行复位） ``` static void spi_nor_set_4byte_opcodes(struct spi_nor *nor, const struct flash_info *info) { /* Do some manufacturer fixups first */ switch (JEDEC_MFR(info)) { case SNOR_MFR_SPANSION: /* No small sector erase for 4 byte command set */ nor >erase_opcode SPINOR_OP_SE; nor >mtd.erasesize info >sector_size; break; default: break; } nor >read_opcode spi_nor_convert_3to4_read(nor >read_opcode); nor >program_opcode spi_nor_convert_3to4_program(nor >program_opcode); nor >erase_opcode spi_nor_convert_3to4_erase(nor >erase_opcode); } /* Enable/disable 4 byte addressing mode. */ static inline int set_4byte(struct spi_nor *nor, const struct flash_info *info, int enable) { int status; bool need_wren false; u8 cmd; switch (JEDEC_MFR(info)) { case SNOR_MFR_MICRON: /* Some Micron need WREN command; all will accept it */ need_wren true; case SNOR_MFR_MACRONIX: case SNOR_MFR_WINBOND: if (need_wren) write_enable(nor); //nor >write_reg(nor, SPINOR_OP_WREN, NULL, 0); cmd enable ? SPINOR_OP_EN4B : SPINOR_OP_EX4B; status nor >write_reg(nor, cmd, NULL, 0); if (need_wren) write_disable(nor); return status; default: /* Spansion style */ nor >cmd_buf[0] enable << 7; return nor >write_reg(nor, SPINOR_OP_BRWR, nor >cmd_buf, 1); } } ``` ``` struct m25p { struct spi_device *spi; struct spi_nor spi_nor; u8 command[MAX_CMD_SIZE]; }; ``` ``` static int m25p_remove(struct spi_device *spi) { struct m25p *flash spi_get_drvdata(spi); //add to exit 4 byte address mode /* Clean up MTD stuff. */ return mtd_device_unregister(&flash >spi_nor.mtd); } ``` ## 新增关机接口 ``` static void m25p_shutdown(struct spi_device *spi) { struct m25p *flash spi_get_drvdata(spi); struct spi_nor nor flash >spi_nor; int status; //add to exit 4 byte address mode nor.write_reg(&nor, SPINOR_OP_WREN, NULL, 0); status nor.write_reg(&nor, SPINOR_OP_EX4B, NULL, 0); printk(\"remove spi flash!\\n\"); /* Clean up MTD stuff. */ mtd_device_unregister(&flash >spi_nor.mtd); return; } ``` ``` static struct spi_driver m25p80_driver { .driver { .name \"m25p80\", .of_match_table m25p_of_table, }, .id_table m25p_ids, .probe m25p_probe, .remove m25p_remove, .shutdown m25p_shutdown, /* REVISIT: many of these chips have deep power down modes, which * should clearly be entered on suspend() to minimize power use. * And also when they're otherwise idle */ }; ``` **CONFIG\\_SPI\\_FLASH\\_BAR** ## 参考资料 <a href \"http://www.wowotech.net/linux_kenrel/reboot.html\" target \"_black\">http://www.wowotech.net/linux_kenrel/reboot.html</a> <a href \"http://blog.csdn.net/manfeel/article/details/43530817\" target \"_black\">http://blog.csdn.net/manfeel/article/details/43530817</a>"},"/soft/Lichee/zh/Zero-Doc/System_Development/bsp_mem.html":{"title":"bsp内核中的保留内存","content":" title: bsp内核中的保留内存 > **问？** > > bsp内核启动时，打印的内存信息发现有35M内存是保留的，这些内存是被谁使用了呢？ > **答！** > > 原来，其中的大头，28MB是被 ion 使用了，在menuconfig里的 > **CONFIG\\_ION\\_SUNXI** 中，有 > **CONFIG\\_ION\\_SUNXI\\_RESERVE\\_LIST**，默认保留了28M 内存给 *vfe, ve* > 等。"},"/soft/Lichee/zh/Zero-Doc/System_Development/bsp_cam.html":{"title":"BSP内核的摄像头使用","content":" title: BSP内核的摄像头使用 ``` Device Drivers > <*> Multimedia support > <*> sunxi video encoder and decoder support //视频编码器，包括h264/mpeg4/mpeg2/vc1/rmvb. 以模块形式编译，cedar_ve.ko ``` ``` [*] Video capture adapters > [*] V4L platform devices > ``` ``` V4L platform devices < > Support for timberdale Video In/LogiWIN <*> SoC camera support < > imx074 support < > mt9m001 support < > mt9m111, mt9m112 and mt9m131 support < > mt9t031 support < > mt9t112 support < > mt9v022 support < > rj54n1cb0c support < > tw9910 support < > platform camera support <M> ov2640 camera support <M> ov5642 camera support < > ov6650 sensor support < > ov772x camera support < > ov9640 camera support < > ov9740 camera support < > SuperH Mobile MIPI CSI 2 Interface driver < > SuperH Mobile CEU Interface driver <*> sunxi video front end (camera and etc)driver <*> v4l2 driver for SUNXI Sensor CSI > ``` ``` < > ov2710_mipi < > ov4689 < > ov4689 60fps < > ar0330 mipi < > ov4689 sdv < > gc1004_mipi <M> h22_mipi < > nt99231_mipi ``` 查看编译后的ko： ``` //触摸屏 aw5306_ts.ko gt818_ts.ko gt82x.ko gt911_ts.ko ft5x_ts.ko gslX680.ko gslX680new.ko icn83xx_ts.ko gt9xx_ts.ko gt9xxf_ts.ko tu_ts.ko //杂项 da380.ko //加速度传感器 fatfs.ko //文件系统 scsi_wait_scan.ko sw device.ko //Linux kernel modules for Detection i2c device. uvcvideo.ko //UVC摄像头 //普通摄像头驱动 media/video/ ov2640.ko ov5642.ko //V4L2 videobuf core.ko videobuf dma contig.ko videobuf2 core.ko videobuf2 memops.ko videobuf2 vmalloc.ko //VFE vfe_v4l2.ko //media/video/sunxi vfe vfe_os.ko vfe_subdev.ko cci.ko //摄像头控制接口，sunxi vfe/csi_cci h22_mipi.ko //media/video/sunxi vfe/device/h22_mipi.ko //cedar 视频编码 cedar_ve.ko //media/cedar ve/cedar_ve.ko ``` 实际可以使用的是 *media/video/sunxi vfe/* 下的摄像头驱动 platform_cfg.h bsp_common.c config.c config.h vfe.c vfe.h vfe_os.c vfe_os.h vfe_os.ko vfe_subdev.c vfe_subdev.h vfe_subdev.ko vfe_v4l2.ko //调焦器 actuator //摄像头控制器接口驱动 csi csi_cci mipi_csi //闪光灯 flash_light //ISP相关 isp_cfg lib //isp库 platform //不同主控芯片的配置 //测试，功能 test utility //支持的传感器 device 支持的传感器 Makefile gc0312.c gc5004.c hi257.c nt99252.c ov5640.c s5k3h7.c sp2518.c ar0330.c gc0328.c gc5004_mipi.c hm5040.c ov12830.c ov5640_mipi.c s5k4e1.c sp2519.c ar0330_mipi.c gc0328c.c gs5604.c hm5065.c ov13850.c ov5647.c s5k4e1_mipi.c sp5408.c bf3a03.c gc0329.c gt2005.c hm8030.c ov16825.c ov5647_mipi.c s5k4ec.c sp5409.c built in.o gc1004_mipi.c h22_mipi.c hm8131.c ov2640.c ov5648.c s5k4ec_mipi.c t4k05.c camera.h gc2035.c h22_mipi.ko imx179.c ov2686.c ov5650.c s5k5e2ya.c t8et5.c camera_cfg.h gc2145.c h22_mipi.mod.c imx214.c ov2710.c ov7736.c s5k5e2yx.c tc358743.c gc0307.c gc2155.c h22_mipi.mod.o imx219.c ov2710_mipi.c ov8825.c siv121d.c gc0308.c gc2235.c h22_mipi.o modules.builtin ov4689.c ov8850.c sp0718.c gc0309.c gc2355.c h42_mipi.c modules.order ov4689_60fps.c ov8858.c sp0838.c gc0311.c gc2355_mipi.c hi253.c nt99231_mipi.c ov4689_sdv.c ov8858_4lane.c sp2508.c 可见zero配套的ov2640和ov5647都在其中。 但是他们不在menuconfig中，所以在上层的Kconfig中加入： ``` config OV2640 tristate \"ov2640\" default n config OV5647_MIPI tristate \"ov5647_mipi\" default n ``` 在本层的Makefile中加入： ``` obj $(CONFIG_OV2640) + ov2640.o obj $(CONFIG_OV5647_MIPI) + ov5647_mipi.o ``` 重新在menuconfig中勾选，编译，即可得到： LD [M] drivers/media/video/sunxi vfe/device/ov2640.ko LD [M] drivers/media/video/sunxi vfe/device/ov5647_mipi.ko 将ko文件放入系统中，手动加载，然后使用fswebcam尝试拍照： ``` root@LicheePi:~# fswebcam d /dev/video0 no banner r 320x240 capture.jpg [ 255.199106] [VFE]vfe_open Opening /dev/video0 [ 255.202406] [VFE] ..vfe clk open! .. Trying source module v4l2 [ 255.213786] [VFE]vfe_open ok [ 255.219628] [VFE_ERR]input index(0) > dev >dev_qty(1) 1 invalid!, device_valid_flag[0] 0 /dev/video0 opened. 255.229491] [VFE]vfe_close mNo input was specified, using t[ 255.235232] [VFE]vfe select input flag 0, s_input have not be used . he first. Unable to qu[ 255.245365] [VFE] ..vfe clk close! .. ery input 0. VIDIOC_EN[ 255.256556] [VFE]vfe_close end UMINPUT: Invalid argument ``` 跟踪相关信息，是在vfe.c, 函数 **static int vidioc_enum_input(struct file\\*file, void \\*priv,struct v4l2_input \\*inp)** 中： ``` 2807 if (0 dev >device_valid_flag[inp >index]) { 2808 vfe_err(\"input index(%d) > dev >dev_qty(%d) 1 invalid!, device_valid_flag[%d] %d\\n\", inp >index, dev >dev_ qty,inp >index, dev >device_valid_flag[inp >index]); 2809 return EINVAL; 2810 } ``` 即枚举摄像头时，发现device_valid_flag标志位不对，该标志位是在： ``` static void probe_work_handle(struct work_struct *work) if(vfe_sensor_register_check(dev,&dev >v4l2_dev,dev >ccm_cfg[input_num],&dev >dev_sensor[input_num],input_nu m) NULL) 5126 { 5127 vfe_err(\"vfe sensor register check error at input_num %d\\n\",input_num); 5128 dev >device_valid_flag[input_num] 0; 5129 //goto snesor_register_end; 5130 } 5131 else{ 5132 dev >device_valid_flag[input_num] 1; 5133 } ``` 这个函数是在vfe_probe中调用，也即初始化时检测的。 vfe驱动加载过程： csi_cci/cci_platform_drv.c 加载cci.ko vfe.c vfe_os.ko加载 vfe_subdev.ko vfe_v4l2.ko //media/video/sunxi vfe 查看开机启动信息： //cci.ko加载，即摄像头控制器初始化 [ 0.808628] [VFE]cci probe start cci_sel 0! [ 0.813793] [VFE]cci probe end cci_sel 0! [ 0.818593] [VFE]cci_init end //VFE驱加载 [ 0.822038] [VFE]Welcome to Video Front End driver [ 0.827986] [VFE]pdev >id 0 [ 0.831435] [VFE]dev >mipi_sel 0 [ 0.835324] [VFE]dev >vip_sel 0 [ 0.839114] [VFE]dev >isp_sel 0 [ 0.849164] [VFE_WARN]vfe vpu clock is null [ 0.849164] [VFE_WARN]vfe vpu clock is null [ 0.860599] [VFE]pdev >id 1 [ 0.864021] [VFE]dev >mipi_sel 1 [ 0.868014] [VFE]dev >vip_sel 1 [ 0.871864] [VFE]dev >isp_sel 0 [ 0.875672] [VFE]probe_work_handle start! [ 0.880358] [VFE] ..vfe clk open! .. [ 0.880358] [VFE] ..vfe clk open! .. [ 0.889010] [VFE]v4l2 subdev register input_num 0 [ 0.894683] [VFE_WARN]vfe vpu clock is null [ 0.894683] [VFE_WARN]vfe vpu clock is null [ 0.899688] [VFE_ERR]vip1 request pinctrl handle for device [csi1] failed! [ 0.907603] [VFE_ERR]get regulator csi_avdd error! [ 0.913056] [VFE_ERR]vfe_device_regulator_get error at input_num 0 [ 0.913056] [VFE_ERR]vfe_device_regulator_get error at input_num 0 [ 0.920482] [VFE]vfe_init end [ 0.920482] [VFE]vfe_init end //V4L2设备注册，生成video0 [ 0.933586] [VFE]V4L2 device registered as video0 [ 0.938969] [VFE] ..vfe clk close! .. [ 0.938969] [VFE] ..vfe clk close! .. [ 0.956440] [VFE]probe_work_handle end! [ 0.960938] [VFE]probe_work_handle start! [ 0.965515] [VFE] ..vfe clk open! .. [ 0.965515] [VFE] ..vfe clk open! .. [ 0.991682] [VFE]v4l2 subdev register input_num 0 [ 0.997227] [VFE]vfe sensor detect start! input_num 0 [ 0.997227] [VFE]vfe sensor detect start! input_num 0 [ 1.003274] [VFE]Find sensor name is \"ov2640\", i2c address is 60, type is \"YUV\" ! [ 1.011824] [VFE]Sub device register \"ov2640\" i2c_addr 0x60 start! [ 1.018998] [VFE_ERR]Error registering v4l2 subdevice No such device! [ 1.026388] [VFE_ERR]vfe sensor register check error at input_num 0 [ 1.026388] [VFE_ERR]vfe sensor register check error at input_num 0 [ 1.079242] [VFE]V4L2 device registered as video1 [ 1.084960] [VFE] ..vfe clk close! .. [ 1.084960] [VFE] ..vfe clk close! .. [ 1.116779] [VFE]probe_work_handle end! [ 5.012110] [VFE]vfe_open [ 5.012110] [VFE]vfe_open [ 5.043465] [VFE]vfe_open [ 5.043465] [VFE]vfe_open [ 5.058511] [VFE] ..vfe clk open! .. [ 5.058511] [VFE] ..vfe clk open! .. [ 5.082179] [VFE] ..vfe clk open! .. [ 5.082179] [VFE] ..vfe clk open! .. [ 5.112320] [VFE]vfe_open ok [ 5.112320] [VFE]vfe_open ok [ 5.115853] [VFE]vfe_close [ 5.115853] [VFE]vfe_close [ 5.118958] [VFE]vfe select input flag 0, s_input have not be used . [ 5.118958] [VFE]vfe select input flag 0, s_input have not be used . [ 5.126480] [VFE] ..vfe clk close! .. [ 5.126480] [VFE] ..vfe clk close! .. [ 5.144821] [VFE]vfe_open ok [ 5.144821] [VFE]vfe_open ok [ 5.148348] [VFE]vfe_close [ 5.148348] [VFE]vfe_close [ 5.151598] [VFE]vfe select input flag 0, s_input have not be used . [ 5.151598] [VFE]vfe select input flag 0, s_input have not be used . [ 5.158972] [VFE] ..vfe clk close! .. [ 5.158972] [VFE] ..vfe clk close! .. [ 5.224773] [VFE]vfe_close end [ 5.224773] [VFE]vfe_close end [ 5.282919] [VFE]vfe_close end [ 5.282919] [VFE]vfe_close end ``` static struct v4l2_subdev *vfe_sensor_register_check(struct vfe_dev *dev,struct v4l2_device *v4l2_dev,struct ccm_config *ccm_cfg, struct i2c_board_info *sensor_i2c_board,int input_num ) { int sensor_cnt,ret, sensor_num; struct sensor_item sensor_info; if(dev >vip_define_sensor_list 1) { sensor_num ccm_cfg >sensor_cfg_ini >detect_sensor_num; if(ccm_cfg >sensor_cfg_ini >detect_sensor_num 0) { sensor_num 1; } } else { sensor_num 1; } for(sensor_cnt 0; sensor_cnt<sensor_num; sensor_cnt++) { if(dev >vip_define_sensor_list 1) { if(ccm_cfg >sensor_cfg_ini >detect_sensor_num > 0) cpy_ccm_sub_device_cfg(ccm_cfg, sensor_cnt); } if(get_sensor_info(ccm_cfg >ccm, &sensor_info) 0) { if(ccm_cfg >i2c_addr ! sensor_info.i2c_addr) { vfe_warn(\"Sensor info \\\"%s\\\" i2c_addr is different from sys_config!\\n\", sensor_info.sensor_name ); //vfe_warn(\"Sensor info i2c_addr %d, sys_config i2c_addr %d!\\n\", sensor_info.i2c_addr, ccm_cfg >i2c_addr); //ccm_cfg >i2c_addr sensor_info.i2c_addr; } if(ccm_cfg >is_bayer_raw ! sensor_info.sensor_type) { vfe_warn(\"Camer detect \\\"%s\\\" fmt is different from sys_config!\\n\", sensor_info_type[sensor_info.sensor_type]); vfe_warn(\"Apply detect fmt %d replace sys_config fmt %d!\\n\", sensor_info.sensor_type, ccm_cfg >is_bayer_raw); ccm_cfg >is_bayer_raw sensor_info.sensor_type; } if(sensor_info.sensor_type SENSOR_RAW) { ccm_cfg >is_isp_used 1; } else { ccm_cfg >act_used 0; } vfe_print(\"Find sensor name is \\\"%s\\\", i2c address is %x, type is \\\"%s\\\" !\\n\",sensor_info.sensor_name,sensor_info.i2c_addr, sensor_info_type[sensor_info.sensor_type]); } sensor_i2c_board >addr (unsigned short)(ccm_cfg >i2c_addr>>1); strcpy(sensor_i2c_board >type,ccm_cfg >ccm); vfe_print(\"Sub device register \\\"%s\\\" i2c_addr 0x%x start!\\n\",sensor_i2c_board >type, ccm_cfg >i2c_addr); ret vfe_sensor_subdev_register_check(dev,v4l2_dev,ccm_cfg,sensor_i2c_board); if( ret 1) { vfe_sensor_subdev_unregister(v4l2_dev,ccm_cfg,sensor_i2c_board); vfe_print(\"Sub device register \\\"%s\\\" failed!\\n\",sensor_i2c_board >type); ccm_cfg >sd NULL; continue; } else if(ret ENODEV ret EFAULT) { continue; } else if(ret 0) { vfe_print(\"Sub device register \\\"%s\\\" is OK!\\n\",sensor_i2c_board >type); break; } } return ccm_cfg >sd; } ```"},"/soft/Lichee/zh/Zero-Doc/System_Development/SPI_falsh_doc4.html":{"title":"JFFS2文件系统简介","content":" title: JFFS2文件系统简介 JFFS2 是一个日志结构(log structured)的文件系统，包含数据 和 原数据(meta data)的节点在闪存上顺序的存储。 JFFS2 之所以选择日志结构的存储方式，是因为对闪存的更新应该是 out of place 的更新方式，而不是对磁盘的 in place 的更新方式。在闪存上 in place 更新方式的问题我们已经在闪存转换层一节描述过了。 ## JFFS2介绍 ### 节点头部定义和兼容性 JFFS2 将文件系统的数据和原数据以节点的形式存储在闪存上，具体来说节点头部的定义如下： ![这个图不见了！！！！](./../static/System_Development/uboot_conf_9.gif) 幻数屏蔽位：0x1985 用来标识 JFFS2 文件系统。 节点类型：JFFS2 自身定义了三种节点类型，但是考虑到文件系统可扩展性和兼容性，JFFS2 从 ext2 借鉴了经验，节点类型的最高两位被用来定义节点的兼容属性，具体来说有下面几种兼容属性： JFFS2\\_FEATURE\\_INCOMPAT：当 JFFS2 发现了一个不能识别的节点类型，并且它的兼容属性是 JFFS2\\_FEATURE\\_INCOMPAT，那么 JFFS2 必须拒绝挂载(mount)文件系统。 JFFS2\\_FEATURE\\_ROCOMPAT：当 JFFS2 发现了一个不能识别的节点类型，并且它的兼容属性是 JFFS2\\_FEATURE\\_ROCOMPAT，那么 JFFS2 必须以只读的方式挂载文件系统。 JFFS2\\_FEATURE\\_RWCOMPAT\\_DELETE：当 JFFS2发现了一个不能识别的节点类型，并且它的兼容属性是 JFFS2\\_FEATURE\\_RWCOMPAT\\_DELETE，那么在垃圾回收的时候，这个节点可以被删除。 JFFS2\\_FEATURE\\_RWCOMPAT\\_COPY：当 JFFS2 发现了一个不能识别的节点类型，并且它的兼容属性是 JFFS2\\_FEATURE\\_RWCOMPAT\\_COPY，那么在垃圾回收的时候，这个节点要被拷贝到新的位置。 节点总长度：包括节点头和数据的长度。 节点头部 CRC 校验：包含节点头部的校验码，为文件系统的可靠性提供了支持。 ### 节点类型 JFFS2 定义了三种节点类型： JFFS2\\_NODETYPE\\_INODE： INODE 节点包含了i 节点的原数据(i节点号，文件的组 ID, 属主 id, 访问时间，偏移，长度等)，文件数据被附在 INODE 节点之后。除此之外，每个 INODE 节点还有一个版本号，它被用来维护属于一个i 节点的所有 INODE 节点的全序关系。下面举例来说明这个全序关系在 JFFS2 的使用： ![这个图不见了！！！！](http://www.ibm.com/developerworks/cn/linux/l jffs2/images/image003.gif) 因此，当文件系统从闪存上读节点信息后，会生成下面的映射信息： ![](http://www.ibm.com/developerworks/cn/linux/l jffs2/images/image004.gif) 根据这个映射信息表，文件系统就知道到相应的 INODE 节点去读取相应的文件内容。最后要说明的是，JFFS2 支持文件数据的压缩存储，因此在 INODE 节点中还包含了所使用的压缩算法，在读取数据的时候选择相应的压缩算法来解压缩。 JFFS2_NODETYPE_DIRENT：DIRENT 节点就是把文件名与 i 节点对应起来。在 DIRENT节点中也有一个版本号，这个版本号的作用主要是用来删除一个 dentry。具体来说，当我们要从一个目录中删除一个 dentry 时，我们要写一个 DIRENT 节点，节点中的文件名与被删除的 dentry 中的文件名相同，i 节点号置为 0，同时设置一个更高的版本号。 JFFS2_NODETYPE_CLEANMARKER：当一个擦写块被擦写完毕后，CLEANMARKER 节点会被写在 NOR flash 的开头，或 NAND flash 的 OOB(Out Of Band) 区域来表明这是一个干净，可写的擦写块。在 JFFS v1 中，如果扫描到开头的 1K 都是 0xFF 就认为这个擦写块是干净的。但是在实际的测试中发现，如果在擦写的过程中突然掉电，擦写块上也可能会有大块连续 0xFF，但是这并不表明这个擦写块是干净的。于是我们需要 CLEANMARKER 节点来确切的标识一个干净的擦写块。 ### JFFS2节点，擦写块在内存中的表示和操作 JFFS2 维护了几个链表来管理擦写块，根据擦写块上的内容，一个擦写块会在不同的链表上。具体来说，当一个擦写块上都是合法(valid)的节点时，它会在clean\\_list 上；当一个擦写块包含至少一个过时(obsolete)的节点时，它会在dirty\\_list 上；当一个擦写块被擦写完毕，并被写入 CLEANMARKER节点后，它会在 free\\_list 上。 通常情况下，JFFS2 顺序的在擦写块上写入不同的节点，直到一个擦写块被写满。此时 JFFS2 从 free_list 上取下一个擦写块，继续从擦写块的开头开始写入节点。当 free_list 上擦写块的数量逐渐减少到一个预先设定的阀值的时候，垃圾回收就被触发了，为文件系统清理出更多的可用擦写块。为了减少对内存的占用，JFFS2 并没有把 i 节点所有的信息都保留在内存中，而只是把那些在请求到来时不能很快获得的信息保留在内存中。具体来说，对于在闪存上的每个 i 节点，在内存里都有一个 struct jffs2_inode_cache 与之对应，这个结构里保存了 i 节点号，指向 i 节点的连接数，以及一个指向属于这个 i 节点的物理节点链表的指针。所有的 struct jffs2_inode_cache 存储在一个哈希表中。闪存上的每个节点在内存中由一个 struct jffs2_raw_node_ref 表示，这个结构里保存了此节点的物理偏移，总长度，以及两个指向 struct jffs2_raw_node_ref 的指针。一个指针指向此节点在物理擦写块上的下一个节点，另一个指针指向属于同一个 i 节点的物理节点链表的下一个节点。 ![这个图不见了！！！！](http://www.ibm.com/developerworks/cn/linux/l jffs2/images/image006.gif) 在闪存上的节点的起始偏移都是 4 字节对齐的，所以 struct jffs2_inode_cache 中flash_offset 的最低两位没有被用到。JFFS2 正好利用最低位作为此节点是否过时的标记。 下面举一例来说明 JFFS2 是如何使用这些数据结构的。VFS 调用 iget() 来得到一个 i 节点的信息，当这个 i 节点不在缓存中的时候，VFS 就会调用 JFFS2 的 read_inode() 回调函数来得到 i 节点信息。传给 read_inode() 的参数是 i 节点号，JFFS2 用这个 i 节点号从哈希表中查找相应的 struct jffs2_inode_cache，然后利用属于这个 i 节点的节点链表从闪存上读入节点信息，建立类似于表三的映射信息。 ### JFFS2 挂载过程 JFFS2 的挂载过程分为四个阶段： 1. JFFS2 扫描闪存介质，检查每个节点 CRC 校验码的合法性，同时分配了 struct jffs2\\_inode\\_cache 和 struct jffs2\\_raw\\_node\\_ref 2. 扫描每个 i 节点的物理节点链表，标识出过时的物理节点；对每一个合法的 dentry 节点，将相应的 jffs2\\_inode\\_cache 中的 nlink 加一。 3. 找出 nlink 为 0 的 jffs2\\_inode\\_cache，释放相应的节点。 4. 释放在扫描过程中使用的临时信息。 ### JFFS2 垃圾回收机制 当 free_list 上的擦写块数太少了，垃圾回收就会被触发。垃圾回收主要的任务就是回收那些已经过时的节点，但是除此之外它还要考虑磨损平衡的问题。因为如果一味的从 dirty_list上选取擦写块进行垃圾回收，那么 dirty_list 上的擦写块将先于 clean_list 上的擦写块被磨损坏。JFFS2 的处理方式是以 99% 的概率从 dirty_list，1% 的概率从 clean_list 上取一个擦写块下来。由此可以看出 JFFS2 的设计思想是偏向于性能，同时兼顾磨损平衡。对这个块上每一个没有过时的节点执行相同的操作： 1. 找出这个节点所属的 i 节点号(见图五)。 2. 调用 iget()，建立这个 i 节点的文件映射表。 3. 找出这个节点上没有过时的数据内容，并且如果合法的数据太少，JFFS2 还会合并相邻的节点。 4. 将数据读入倒缓存里，然后将它拷贝到新的擦写块上。 5. 将回收的节点置为过时。 当擦写块上所有的节点都被置为过时，就可以擦写这个擦写块，回收使用它。 ## JFFS2 的不足之处 ### 挂载时间过长 JFFS2 的挂载过程需要对闪存从头到尾的扫描，这个过程是很慢的，我们在测试中发现，挂载一个 16M 的闪存有时需要半分钟以上的时间。 ### 磨损平衡的随意性(random nature) JFFS2 对磨损平衡是用概率的方法来解决的，这很难保证磨损平衡的确定性。在某些情况下，可能造成对擦写块不必要的擦写操作；在某些情况下，又会引起对磨损平衡调整的不及时。 ### 很差的扩展性 JFFS2 中有两个地方的处理是 O(N) 的，这使得它的扩展性很差。 首先，挂载时间同闪存的大小，闪存上节点数目成正比。 其次，虽然 JFFS2 尽可能的减少内存的占用，但通过上面对 JFFS2 的介绍我们可以知道实际上它对内存的占用量是同 i 节点数和闪存上的节点数成正比的。 因此在实际应用中，JFFS2 最大能用在 128M 的闪存上。 ## JFFS2 的新特性 最近加入到 JFFS2 中的两个补丁程序分别解决了上面提到的挂载时间过长和磨损平衡随意性的问题。 ### 磨损块小结补丁程序(erase block summary patch) 这个补丁程序最基本的思想就是用空间来换时间。具体来说，就是将每个擦写块每个节点的原数据信息写在这个擦写块的最后，当 JFFS2 挂载的时候，对每个擦写块只需要读一次来读取这个小结节点，因此大大减少了挂载时间。使用了磨损块小结补丁程序，一个擦写块的结构就像下面这样： ![这个图不见了！！！！](http://www.ibm.com/developerworks/cn/linux/l jffs2/images/image007.gif) 根据我们的测试，使用磨损块小结补丁程序，挂载一个 12M 的闪存需要 2\\~3秒，挂载一个 16M 的闪存需要 3\\~4 秒。 ### 改进的磨损平衡补丁程序 这个补丁程序的基本思想是，记录每个擦写块的擦写次数，当闪存上各个擦写块的擦写次数的差距超过某个预定的阀值，开始进行磨损平衡的调整。调整的策略是，在垃圾回收时将擦写次数小的擦写块上的数据迁移到擦写次数大的擦写块上。这样一来我们提高了磨损平衡的确定性，我们可以知道什么时候开始磨损平衡的调整，也可以知道选取哪些擦写块进行磨损平衡的调整。 ### 擦写块头部补丁程序 在写改进的磨损平衡补丁程序的过程之中，我们需要记录每个擦写块的擦写次数，这个信息需要记录在各自的擦写块上。可是我们发现 JFFS2 中缺少一种灵活的对每个擦写块的信息进行扩展的机制。于是我们为每个擦写块引入了擦写块头部(header)，这个头部负责纪录每个擦写块的信息(比如说擦写次数)，并且它提供了灵活的扩展机制，将来如果有新的信息需要记录，可以很容易的加入到头部之中。 ## JFFS3 简介 虽然不断有新的补丁程序来提高 JFFS2 的性能，但是不可扩展性是它最大的问题，但是这是它自身设计的先天缺陷，是没有办法靠后天来弥补的。因此我们需要一个全新的文件系统，而 JFFS3 就是这样的一个文件系统，JFFS3 的设计目标是支持大容量闪存(>1TB)的文件系统。JFFS3 与 JFFS2 在设计上根本的区别在于，JFFS3 将索引信息存放在闪存上，而 JFFS2将索引信息保存在内存中。比如说，由给定的文件内的偏移定位到存储介质上的物理偏移地址所需的信息，查找某个目录下所有的目录项所需的信息都是索引信息的一种。 JFFS3 现在还处于设计阶段，文件系统的基本结构借鉴了 Reiser4 的设计思想，整个文件系统就是一个 B+ 树。JFFS3 的发起者正工作于垃圾回收机制的设计，这是 JFFS3 中最复杂，也是最富有挑战性的部分。JFFS3 的设计文档可以在http://www.linux mtd.infradead.org/doc/jffs3.html 得到，有兴趣的读者可以积极参与到 JFFS3 的设计中，发表自己的见解，参与讨论。 > 节选自：<http://blog.csdn.net/harhy/article/details/50637488>"},"/soft/Lichee/zh/Zero-Doc/Drive/peripheral_index.html":{"title":"Zero外设把玩","content":" title: Zero外设把玩 本节介绍zero各种外设资源的适配。"},"/soft/Lichee/zh/Zero-Doc/Drive/GPIO_mmap.html":{"title":"C语言方式(mmap)","content":" title: C语言方式(mmap) 这里提供接近单片机寄存器操作的一种应用层GPIO操作方式，也封装成库给大家使用。 ## GPIO 寄存器介绍 在 [V3S datasheet](http://lichee.jicm.cn/doc/V3S/Allwinner_V3s_Datasheet_V1.0.pdf) 第224页是GPIO控制器的相关介绍。 V3S从有PB/C/E/F/G五个GPIO端口，每个都是32位端口（实际引脚没有引出那么多）,也是32位寄存器。 每个端口由以下几个寄存器组成： > (n 1,2,4,5,6；寄存器基址为0x01C20800) Register Name Offset Description 详细描述 Pn_CFG0 n*0x24+0x00 Port n Configure Register 0 (n 1,2,4,5,6) 每个脚4bit，最高位保留。000 输入;001 输出;010 外设功能1;011 外设功能2;100 外设功能3;101 外设功能4;110 EINT中断;111 IO失能 Pn_CFG1 n*0x24+0x04 Port n Configure Register 1 同上 Pn_CFG2 n*0x24+0x08 Port n Configure Register 2 同上 Pn_CFG3 n*0x24+0x0C Port n Configure Register 3 同上 Pn_DAT n*0x24+0x10 Port n Data Register 每位代表输入输出值 Pn_DRV0 n*0x24+0x14 Port n Multi Driving Register 0 0~3逐级递增 Pn_DRV1 n*0x24+0x18 Port n Multi Driving Register 1 同上 Pn_PUL0 n*0x24+0x1C Port n PullRegister 0 0浮空，1上拉，2下拉，3保留 Pn_PUL1 n*0x24+0x20 Port n PullRegister 1 同上 Pn_INT_CFG0 0x200+n*0x20+0x00 PIO Interrrupt Configure Register 0 0上升，1下降，2高电平，3低电平，4双边沿 Pn_INT_CFG1 0x200+n*0x20+0x04 PIO Interrrupt Configure Register 1 同上 Pn_INT_CFG2 0x200+n*0x20+0x08 PIO Interrrupt Configure Register 2 同上 Pn_INT_CFG3 0x200+n*0x20+0x0C PIO Interrrupt Configure Register 3 同上 Pn_INT_CTL 0x200+n*0x20+0x10PIO Interrupt Control Register 0失能，1使能 Pn_INT_STA 0x200+n*0x20+0x14PIO Interrupt Status Register 0未发生中断，1发生中断。写1清除 Pn_INT_DEB 0x200+n*0x20+0x18PIO Interrupt Debounce Register bit0，选择中断时钟，0,32Khz，低速时钟；1，24MHz主时钟。bit6:4，去抖时钟分频，选择的时钟源2^n分频，即最大256分频。 寄存器 地址 PB配置1C20824 PC配置1C20848 PE配置1C20890 PF配置1C208B4 PG配置1C208D8 ## mmap简介 mmap简单来说就是把一片物理内存空间（或者文件）映射到应用的虚拟内存空间，这样，直接在应用层就能操作CPU的寄存器，类似于单片机的寄存器操作。我们只要封装好寄存器操作的库函数，就能在以后的程序里简单调用了\\~ 详细的mmap介绍可以参考附录的链接。 为了操作寄存器，我们需要用到 */dev/mem* 设备，这个设备是是物理内存的全映像，可以用来访问物理内存，一般用法是 `open(\"/dev/mem\",O_RDWRO_SYNC)`，然后mmap，接着就可以用mmap的地址来访问物理内存，这实际上就是实现用户空间驱动的一种方法。 ``` #include <sys/mmap.h> void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset); //start: 映射区的起始地址，0的话由接口自动返回 //length: 映射区的长度 //prot: 内存保护标志，不能与文件的打开模式冲突。以下值可以 或 组合。 //PROT_EXEC 页内容可以被执行 //PROT_READ 页内容可以被读取 //PROT_WRITE 页可以被写入 //PROT_NONE 页不可访问 //flag: 指定映射对象的类型，是否可以共享等。 //fd: 文件描述符 //oft: 被映射对象内容的起点偏移。映射物理内存的话，就是物理内存地址。**必须页对齐。** int munmap(void *start, size_t length); //start: 前面获得的地址 //length: 映射区的大小。 int msync ( void * addr , size_t len, int flags) //一般说来，进程在映射空间的对共享内容的改变并不直接写回到磁盘文件中，往往在调用munmap（）后才执行该操作。可以通过调用msync()实现磁盘上文件内容与共享内存区的内容一致。 //但是对于映射物理内存来说是直接作用的。 ``` 代码片段： ``` #include <sys/mmap.h> char dev_name[] \"/dev/mem\"; GPIO_REGISTER *gpio_base; fd open(dev_name,O_RDWR); if(fd<0){ printf(\"open %s is error\\n\",dev_name); return 1 ; } gpio_base (GPIO_REGISTER *)mmap( 0, 0x32, PROT_READ PROT_WRITE, MAP_SHARED,fd, 0x40060000 ); if(gpio_base NULL){ printf(\"gpio base mmap is error\\n\"); close(fd); return 1; } //后面就是对寄存器操作了 //结束后解除映射 munmap(gpio_base, 0x32); ``` 我基于mmap写了个应用层调试寄存器的小程序，reg dbger,在github上可以下载使用。 使用方法为： reg dbger r reg_addr //读寄存器 reg dbger rb reg_addr bit_oft bit_cnt //读寄存器的bit_oft开始的bit_cnt位 reg dbger w reg_addr value //写寄存器 reg dbger wb reg_addr bit_oft bit_cnt value //写寄存器的bit_oft开始的bit_cnt位 reg dbger dump reg_addr cnt //批量dump出cnt个寄存器值 比如操作gpio寄存器，点亮熄灭Zero上的绿色LED： # PG0 # 配置寄存器 0x01C20800+6*0x24+0 1C208D8 # 数据寄存器 0x01C20800+6*0x24+0x10 1C208E8 reg dbger r 1C208D8 reg dbger r 1C208E8 reg dbger wb 1C208D8 0 3 1 #输出状态 reg dbger wb 1C208E8 0 1 0 #输出0，点亮 同样基于mmap写了个应用层操作GPIO的小程序，lpi gpio,在github上可以下载使用。 使用方法为： lpi gpio set PG0 out/in 0/1/2 //设置为输出的话,0低电平，1,2高电平；设置为输入，0下拉，1上拉，2浮空。 lpi gpio r PG0 lpi gpio w PG0 0/1 lpi gpio pwm PG0 100 200 //PG0 pwm输出，两个参数分别表示高低电平的微秒数（>60us） lpi gpio test PG0 //测试PG0用函数翻转IO的最大速率，结果为1.85MHz lpi gpio tfast PG0 //测试PG0用软件翻转IO的最大速率，结果为10MHz 为方便在C语言里调用，我生成了gpio操作的动态库 [libgpio.so](https://libgpio.so/)，大家可以在c程序中调用。 这里是一个简单的使用例程： ``` #include \"lpi_gpio.h\" #define USLEEP_T 61 int main() { lpi_gpio_initlib(); lpi_gpio_init(6, 0, 1, 0); while(1) { //generate 1KHz PWM lpi_gpio_w(6, 0, 1); usleep(500 USLEEP_T); lpi_gpio_w(6, 0, 0); usleep(500 USLEEP_T); } lpi_gpio_deinitlib(); return; } ``` //gcc fPIC shared o libgpio.so lib_gpio.c //编译生成动态库 gcc test_gpio.c L. lgpio o test_gpio //编译生成应用程序 LD_LIBRARY_PATH . ./test_gpio //运行应用程序，手工指定动态库位置 //or add libgpio.so to /etc/ld.so.conf, ldconfig ## 附录 mmap参考资料：<http://blog.chinaunix.net/uid 26669729 id 3077015.html> linux动态库：<http://www.cnblogs.com/jiqingwu/p/linux_dynamic_lib_create.html> linux静态库：<http://www.cnblogs.com/jiqingwu/p/4325382.html>"},"/soft/Lichee/zh/Zero-Doc/Drive/GPIO_index.html":{"title":"GPIO","content":" title: GPIO 本节介绍zero 各种GPIO操作的适配。 在这里先给出几种操作方法的IO翻转速率比较："},"/soft/Lichee/zh/Zero-Doc/Drive/Device_Tree_Intro.html":{"title":"设备树简介","content":" title: 设备树简介 Device Tree是一种描述硬件的数据结构， DTS(Device Tree Source)就是用来描述目标板硬件信息的源文件。 ## 设备树基本数据格式 device tree是一个简单的节点和属性树，属性是键值对，节点可以包含属性和子节点。下面是一个.dts格式的简单设备树。 ``` { node1 { a string property \"A string\"; a string list property \"first string\", \"second string\"; a byte data property [0x01 0x23 0x34 0x56]; child node1 { first child property; second child property <1>; a string property \"Hello, world\"; }; child node2 { }; }; node2 { an empty property; a cell property <1 2 3 4>; /* each number (cell) is a uint32 */ child node1 { }; }; }; ``` 编译设备树后，可以使用 `dtc I dtb O dts xxx.dtb o xxx.dts` 来查看实际生成的设备树文件 在运行系统时，\\*/sys/firmware/devicetree\\* 可以查看实际使用的是设备树 ## 设备树常用操作 ``` / { demo1: demo1 { compatible \"demo1\"; property1 <1>; property2; property3 <2>; property4; }; }; &demo1 { /delete property/property2; /delete property/property3; }; ``` ``` memory_DDR1@c0000000 { device_type \"memory\"; reg <0 0xc0000000 0 0x40000000>; }; / { /delete node/ memory_DDR1@c0000000; }; ``` ## 设备树实例解析 下面解析sun8i v3s.dtsi设备树实例 ``` #include <dt bindings/interrupt controller/arm gic.h> #include <dt bindings/clock/sun8i v3s ccu.h> #include <dt bindings/reset/sun8i v3s ccu.h> / { #address cells <1>; //表示子节点默认用一个uint32表示地址（32位系统），如果是64位系统将是2 #size cells <1>; //表示子节点默认用一个uint32表示大小 interrupt parent <&gic>; //interrupt parent是独立字段，表示整个设备的中断父节点是gic //<&gic>表示取gic地址。gic配置详见文件末尾 chosen { #address cells <1>; #size cells <1>; ranges; simplefb_lcd: framebuffer@0 { compatible \"allwinner,simple framebuffer\", \"simple framebuffer\"; allwinner,pipeline \"de0 lcd0\"; clocks <&ccu CLK_BUS_TCON0>, <&display_clocks 0>, <&display_clocks 6>, <&ccu CLK_TCON0>; status \"disabled\"; }; }; cpus { #address cells <1>; #size cells <0>; cpu@0 { compatible \"arm,cortex a7\"; device_type \"cpu\"; reg <0>; clocks <&ccu CLK_CPU>; }; }; de: display engine { compatible \"allwinner,sun8i v3s display engine\"; allwinner,pipelines <&mixer0>; status \"disabled\"; }; timer { compatible \"arm,armv7 timer\"; interrupts <GIC_PPI 13 (GIC_CPU_MASK_SIMPLE(4) IRQ_TYPE_LEVEL_LOW)>, <GIC_PPI 14 (GIC_CPU_MASK_SIMPLE(4) IRQ_TYPE_LEVEL_LOW)>, <GIC_PPI 11 (GIC_CPU_MASK_SIMPLE(4) IRQ_TYPE_LEVEL_LOW)>, <GIC_PPI 10 (GIC_CPU_MASK_SIMPLE(4) IRQ_TYPE_LEVEL_LOW)>; }; clocks { #address cells <1>; #size cells <1>; ranges; osc24M: osc24M_clk { #clock cells <0>; compatible \"fixed clock\"; clock frequency <24000000>; clock output names \"osc24M\"; }; osc32k: osc32k_clk { #clock cells <0>; compatible \"fixed clock\"; clock frequency <32768>; clock output names \"osc32k\"; }; }; soc { compatible \"simple bus\"; #address cells <1>; #size cells <1>; ranges; display_clocks: clock@1000000 { compatible \"allwinner,sun8i v3s de2 clk\"; reg <0x01000000 0x100000>; clocks <&ccu CLK_DE>, <&ccu CLK_BUS_DE>; clock names \"mod\", \"bus\"; resets <&ccu RST_BUS_DE>; #clock cells <1>; #reset cells <1>; }; mixer0: mixer@1100000 { compatible \"allwinner,sun8i v3s de2 mixer\"; reg <0x01100000 0x100000>; clocks <&display_clocks 0>, <&display_clocks 6>; clock names \"bus\", \"mod\"; resets <&display_clocks 0>; assigned clocks <&display_clocks 6>; assigned clock rates <150000000>; ports { #address cells <1>; #size cells <0>; mixer0_out: port@1 { #address cells <1>; #size cells <0>; reg <1>; mixer0_out_tcon0: endpoint@0 { reg <0>; remote endpoint <&tcon0_in_mixer0>; }; }; }; }; tcon0: lcd controller@1c0c000 { compatible \"allwinner,sun8i v3s tcon\"; reg <0x01c0c000 0x1000>; interrupts <GIC_SPI 86 IRQ_TYPE_LEVEL_HIGH>; clocks <&ccu CLK_BUS_TCON0>, <&ccu CLK_TCON0>; clock names \"ahb\", \"tcon ch0\"; clock output names \"tcon pixel clock\"; resets <&ccu RST_BUS_TCON0>; reset names \"lcd\"; status \"disabled\"; ports { #address cells <1>; #size cells <0>; tcon0_in: port@0 { #address cells <1>; #size cells <0>; reg <0>; tcon0_in_mixer0: endpoint@0 { reg <0>; remote endpoint <&mixer0_out_tcon0>; }; }; tcon0_out: port@1 { #address cells <1>; #size cells <0>; reg <1>; }; }; }; mmc0: mmc@01c0f000 { compatible \"allwinner,sun7i a20 mmc\"; reg <0x01c0f000 0x1000>; clocks <&ccu CLK_BUS_MMC0>, <&ccu CLK_MMC0>, <&ccu CLK_MMC0_OUTPUT>, <&ccu CLK_MMC0_SAMPLE>; clock names \"ahb\", \"mmc\", \"output\", \"sample\"; resets <&ccu RST_BUS_MMC0>; reset names \"ahb\"; interrupts <GIC_SPI 60 IRQ_TYPE_LEVEL_HIGH>; status \"disabled\"; #address cells <1>; #size cells <0>; }; mmc1: mmc@01c10000 { compatible \"allwinner,sun7i a20 mmc\"; reg <0x01c10000 0x1000>; clocks <&ccu CLK_BUS_MMC1>, <&ccu CLK_MMC1>, <&ccu CLK_MMC1_OUTPUT>, <&ccu CLK_MMC1_SAMPLE>; clock names \"ahb\", \"mmc\", \"output\", \"sample\"; resets <&ccu RST_BUS_MMC1>; reset names \"ahb\"; interrupts <GIC_SPI 61 IRQ_TYPE_LEVEL_HIGH>; pinctrl names \"default\"; pinctrl 0 <&mmc1_pins>; status \"disabled\"; #address cells <1>; #size cells <0>; }; mmc2: mmc@01c11000 { compatible \"allwinner,sun7i a20 mmc\"; reg <0x01c11000 0x1000>; clocks <&ccu CLK_BUS_MMC2>, <&ccu CLK_MMC2>, <&ccu CLK_MMC2_OUTPUT>, <&ccu CLK_MMC2_SAMPLE>; clock names \"ahb\", \"mmc\", \"output\", \"sample\"; resets <&ccu RST_BUS_MMC2>; reset names \"ahb\"; interrupts <GIC_SPI 62 IRQ_TYPE_LEVEL_HIGH>; status \"disabled\"; #address cells <1>; #size cells <0>; }; usb_otg: usb@01c19000 { compatible \"allwinner,sun8i h3 musb\"; reg <0x01c19000 0x0400>; clocks <&ccu CLK_BUS_OTG>; resets <&ccu RST_BUS_OTG>; interrupts <GIC_SPI 71 IRQ_TYPE_LEVEL_HIGH>; interrupt names \"mc\"; phys <&usbphy 0>; phy names \"usb\"; extcon <&usbphy 0>; status \"disabled\"; }; usbphy: phy@01c19400 { compatible \"allwinner,sun8i v3s usb phy\"; reg <0x01c19400 0x2c>, <0x01c1a800 0x4>; reg names \"phy_ctrl\", \"pmu0\"; clocks <&ccu CLK_USB_PHY0>; clock names \"usb0_phy\"; resets <&ccu RST_USB_PHY0>; reset names \"usb0_reset\"; status \"disabled\"; #phy cells <1>; }; ehci0: usb@01c1a000 { compatible \"allwinner,sun8i v3s ehci\", \"generic ehci\"; reg <0x01c1a000 0x100>; interrupts <GIC_SPI 72 IRQ_TYPE_LEVEL_HIGH>; clocks <&ccu CLK_BUS_EHCI0>, <&ccu CLK_BUS_OHCI0>; resets <&ccu RST_BUS_EHCI0>, <&ccu RST_BUS_OHCI0>; status \"disabled\"; }; ohci0: usb@01c1a400 { compatible \"allwinner,sun8i v3s ohci\", \"generic ohci\"; reg <0x01c1a400 0x100>; interrupts <GIC_SPI 73 IRQ_TYPE_LEVEL_HIGH>; clocks <&ccu CLK_BUS_EHCI0>, <&ccu CLK_BUS_OHCI0>, <&ccu CLK_USB_OHCI0>; resets <&ccu RST_BUS_EHCI0>, <&ccu RST_BUS_OHCI0>; status \"disabled\"; }; ccu: clock@01c20000 { compatible \"allwinner,sun8i v3s ccu\"; reg <0x01c20000 0x400>; clocks <&osc24M>, <&osc32k>; clock names \"hosc\", \"losc\"; #clock cells <1>; #reset cells <1>; }; rtc: rtc@01c20400 { compatible \"allwinner,sun6i a31 rtc\"; reg <0x01c20400 0x54>; interrupts <GIC_SPI 40 IRQ_TYPE_LEVEL_HIGH>, <GIC_SPI 41 IRQ_TYPE_LEVEL_HIGH>; }; pio: pinctrl@01c20800 { compatible \"allwinner,sun8i v3s pinctrl\"; reg <0x01c20800 0x400>; interrupts <GIC_SPI 15 IRQ_TYPE_LEVEL_HIGH>, <GIC_SPI 17 IRQ_TYPE_LEVEL_HIGH>; clocks <&ccu CLK_BUS_PIO>, <&osc24M>, <&osc32k>; clock names \"apb\", \"hosc\", \"losc\"; gpio controller; #gpio cells <3>; interrupt controller; #interrupt cells <3>; i2c0_pins: i2c0 { pins \"PB6\", \"PB7\"; function \"i2c0\"; }; uart0_pins_a: uart0@0 { pins \"PB8\", \"PB9\"; function \"uart0\"; }; mmc0_pins_a: mmc0@0 { pins \"PF0\", \"PF1\", \"PF2\", \"PF3\", \"PF4\", \"PF5\"; function \"mmc0\"; drive strength <30>; bias pull up; }; mmc1_pins: mmc1 { pins \"PG0\", \"PG1\", \"PG2\", \"PG3\", \"PG4\", \"PG5\"; function \"mmc1\"; drive strength <30>; bias pull up; }; spi0_pins: spi0 { pins \"PC0\", \"PC1\", \"PC2\", \"PC3\"; function \"spi0\"; }; }; timer@01c20c00 { compatible \"allwinner,sun4i a10 timer\"; reg <0x01c20c00 0xa0>; interrupts <GIC_SPI 18 IRQ_TYPE_LEVEL_HIGH>, <GIC_SPI 19 IRQ_TYPE_LEVEL_HIGH>; clocks <&osc24M>; }; wdt0: watchdog@01c20ca0 { compatible \"allwinner,sun6i a31 wdt\"; reg <0x01c20ca0 0x20>; interrupts <GIC_SPI 25 IRQ_TYPE_LEVEL_HIGH>; }; lradc: lradc@1c22800 { compatible \"allwinner,sun4i a10 lradc keys\"; reg <0x01c22800 0x400>; interrupts <GIC_SPI 30 IRQ_TYPE_LEVEL_HIGH>; status \"disabled\"; }; uart0: serial@01c28000 { compatible \"snps,dw apb uart\"; reg <0x01c28000 0x400>; interrupts <GIC_SPI 0 IRQ_TYPE_LEVEL_HIGH>; reg shift <2>; reg io width <4>; clocks <&ccu CLK_BUS_UART0>; resets <&ccu RST_BUS_UART0>; status \"disabled\"; }; uart1: serial@01c28400 { compatible \"snps,dw apb uart\"; reg <0x01c28400 0x400>; interrupts <GIC_SPI 1 IRQ_TYPE_LEVEL_HIGH>; reg shift <2>; reg io width <4>; clocks <&ccu CLK_BUS_UART1>; resets <&ccu RST_BUS_UART1>; status \"disabled\"; }; uart2: serial@01c28800 { compatible \"snps,dw apb uart\"; reg <0x01c28800 0x400>; interrupts <GIC_SPI 2 IRQ_TYPE_LEVEL_HIGH>; reg shift <2>; reg io width <4>; clocks <&ccu CLK_BUS_UART2>; resets <&ccu RST_BUS_UART2>; status \"disabled\"; }; i2c0: i2c@01c2ac00 { compatible \"allwinner,sun6i a31 i2c\"; reg <0x01c2ac00 0x400>; interrupts <GIC_SPI 6 IRQ_TYPE_LEVEL_HIGH>; clocks <&ccu CLK_BUS_I2C0>; resets <&ccu RST_BUS_I2C0>; pinctrl names \"default\"; pinctrl 0 <&i2c0_pins>; status \"disabled\"; #address cells <1>; #size cells <0>; }; i2c1: i2c@01c2b000 { compatible \"allwinner,sun6i a31 i2c\"; reg <0x01c2b000 0x400>; interrupts <GIC_SPI 7 IRQ_TYPE_LEVEL_HIGH>; clocks <&ccu CLK_BUS_I2C1>; resets <&ccu RST_BUS_I2C1>; status \"disabled\"; #address cells <1>; #size cells <0>; }; spi0: spi@1c68000 { compatible \"allwinner,sun8i h3 spi\"; reg <0x01c68000 0x1000>; interrupts <GIC_SPI 65 IRQ_TYPE_LEVEL_HIGH>; clocks <&ccu CLK_BUS_SPI0>, <&ccu CLK_SPI0>; clock names \"ahb\", \"mod\"; pinctrl names \"default\"; pinctrl 0 <&spi0_pins>; resets <&ccu RST_BUS_SPI0>; status \"disabled\"; #address cells <1>; #size cells <0>; }; gic: interrupt controller@01c81000 { // interrupt controller是独立字段，表示中断控制器。gic是其一个实例，地址在01c81000 compatible \"arm,cortex a7 gic\", \"arm,cortex a15 gic\"; //驱动匹配 reg <0x01c81000 0x1000>, //中断控制器的寄存器地址，和大小 <0x01c82000 0x1000>, <0x01c84000 0x2000>, <0x01c86000 0x2000>; interrupt controller; #interrupt cells <3>; //调用该实例需要三个参数 interrupts <GIC_PPI 9 (GIC_CPU_MASK_SIMPLE(4) IRQ_TYPE_LEVEL_HIGH)>; }; }; }; ``` 系统中的每个设备由device tree的一个节点来表示； ``` static struct of_device_id beep_table[] { {.compatible \"fs4412,beep\"}, }; static struct platform_driver beep_driver { .probe beep_probe, .remove beep_remove, .driver { .name \"bigbang\", .of_match_table beep_table, }, }; ``` ``` fs4412 beep{ compatible \"fs4412,beep\"; reg <0x114000a0 0x4 0x139D0000 0x14>; }; ``` **compatible**，关键属性，驱动中使用of_match_table，即of_device_id列表，其中就使用compatible字段来匹配设备。 简单地说就是，内核启动后会把设备树加载到树状结构体中，当insmod的时候，就会在树中查找匹配的设备节点来加载。 **reg**，描述寄存器基址和长度，可以有多个。 ``` pwm: pwm@01c21400 { compatible \"allwinner,sun8i h3 pwm\"; reg <0x01c21400 0x8>; clocks <&osc24M>; #pwm cells <3>; status \"okay\"; }; ``` 实例 : 类 @ 地址 { compatible： “供应商, 设备id” reg clocks } ## 基于设备树的driver的结构体的填充 ``` static struct of_device_id beep_table[] { {.compatible \"fs4412,beep\"}, }; static struct platform_driver beep_driver { .probe beep_probe, .remove beep_remove, .driver { .name \"bigbang\", .of_match_table beep_table, }, }; ``` make dtbs 在内核根目录 ## sys下设备树查看 **/sys/firmware/devicetree** 可以查看实际使用的是设备树 ## 参考资料 <http://e76103db.wiz03.com/share/s/3Dogfr2DXA6Q27Og6x2QoKY92Bk9at14FABh21OAAE28lAme>"},"/soft/Lichee/zh/Zero-Doc/Drive/PWM.html":{"title":"PWM输出","content":" title: PWM输出 ## PWM驱动 dtsi: 增加PWM0，1的引脚 pwm0_pins: pwm0 { pins \"PB4\"; function \"pwm0\"; }; pwm1_pins: pwm1 { pins \"PB5\"; function \"pwm1\"; }; pwm: pwm@01c21400 { compatible \"allwinner,sun7i a20 pwm\"; //这里选a20是因为v3s和a20一样有两路pwm reg <0x01c21400 0xC>; clocks <&osc24M>; #pwm cells <3>; status \"okay\"; }; dts中使能PWM： &pwm { pinctrl names \"default\"; pinctrl 0 <&pwm0_pins>, <&pwm1_pins>; status \"okay\"; }; sysfs里使能： echo 0 > /sys/class/pwm/pwmchip0/export echo 1000000 > /sys/class/pwm/pwmchip0/pwm0/period echo 500000 > /sys/class/pwm/pwmchip0/pwm0/duty_cycle echo 1 > /sys/class/pwm/pwmchip0/pwm0/enable echo 1 > /sys/class/pwm/pwmchip0/export echo 1000000 > /sys/class/pwm/pwmchip0/pwm1/period echo 200000 > /sys/class/pwm/pwmchip0/pwm1/duty_cycle echo 1 > /sys/class/pwm/pwmchip0/pwm1/enable //注意一定要配置好参数后再使能，否则会报参数错误 polarity：接受normal或inversed两个参数. period：表示pwm波的周期(单位：纳秒)； duty\\_cycle：在normal模式下，表示一个周期内高电平持续的时间（单位：纳秒），所以duty\\_cycle \\< period；在reversed模式下，表示一个周期中低电平持续的时间（单位：纳秒）； enable：向其中写入1表示启动pwm，写入0，表示关闭pwm； 注意V3S的PWM由24M分频而来，无法生成太高频的pwm。 ## PWM驱动分析 PWM驱动在 *drivers/pwm/pwm sun4i.c* 中。 插入驱动： ``` static int sun4i_pwm_probe(struct platform_device *pdev) { struct sun4i_pwm_chip *pwm; struct resource *res; int ret; const struct of_device_id *match; match of_match_device(sun4i_pwm_dt_ids, &pdev >dev); //在设备树中查找节点 pwm devm_kzalloc(&pdev >dev, sizeof(*pwm), GFP_KERNEL); if (!pwm) return ENOMEM; res platform_get_resource(pdev, IORESOURCE_MEM, 0); pwm >base devm_ioremap_resource(&pdev >dev, res); //申请寄存器的内存空间 if (IS_ERR(pwm >base)) return PTR_ERR(pwm >base); pwm >clk devm_clk_get(&pdev >dev, NULL); if (IS_ERR(pwm >clk)) return PTR_ERR(pwm >clk); pwm >data match >data; pwm >chip.dev &pdev >dev; pwm >chip.ops &sun4i_pwm_ops; pwm >chip.base 1; pwm >chip.npwm pwm >data >npwm; pwm >chip.of_xlate of_pwm_xlate_with_flags; pwm >chip.of_pwm_n_cells 3; spin_lock_init(&pwm >ctrl_lock); ret pwmchip_add(&pwm >chip); //在/sys/class/pwm/下创建pwmchip0X if (ret < 0) { dev_err(&pdev >dev, \"failed to add PWM chip: %d\\n\", ret); return ret; } platform_set_drvdata(pdev, pwm); return 0; } ```"},"/soft/Lichee/zh/Zero-Doc/Drive/GPUandDRM.html":{"title":"GPU/DRM驱动","content":" title: 'GPU/DRM驱动' 代码在driver/gpu/drm下 The Direct Rendering Manager (DRM) is a subsystem of the Linux kernel responsible for interfacing with GPUs of modern video cards. DRM exposes an API that user space programs can use to send commands and data to the GPU, and perform operations such as configuring the mode setting of the display. DRM was first developed as the kernel space component of the X Server's Direct Rendering Infrastructure,[1] but since then it has been used by other graphic stack alternatives such as Wayland. DRM（图形渲染架构）是linux的一个内核子系统，负责GPU的交互接口。 DRM暴露API，用户空间的程序可以发送命令和数据给GPU。 如果没有DRM： ![找不到了](http://odfef978i.bkt.clouddn.com/Free Converter.com access_to_video_card_without_drm 85644921.png) 使用DRM： ![](./../static/Drive/GPUandDRM.png) 查看DRM驱动代码： root@bf756b445919:~/linux/drivers/gpu/drm/sun4i# ls *.c sun4i_backend.c sun4i_dotclock.c sun4i_framebuffer.c sun4i_hdmi_enc.c sun4i_layer.c sun4i_tcon.c sun6i_drc.c sun8i_mixer.c sun4i_crtc.c sun4i_drv.c sun4i_hdmi_ddc_clk.c sun4i_hdmi_tmds_clk.c sun4i_rgb.c sun4i_tv.c sun8i_layer.c 参考现成的dts： sun5i a13 q8 tablet.dts #include \"sun5i a13.dtsi\" #include \"sun5i reference design tablet.dtsi\" / { model \"Q8 A13 Tablet\"; compatible \"allwinner,q8 a13\", \"allwinner,sun5i a13\"; panel: panel { compatible \"urt,umsh 8596md t\", \"simple panel\"; #address cells <1>; #size cells <0>; port@0 { reg <0>; /* TODO: lcd panel uses axp gpio0 as enable pin */ backlight <&backlight>; #address cells <1>; #size cells <0>; panel_input: endpoint@0 { reg <0>; remote endpoint <&tcon0_out_lcd>; }; }; }; }; &be0 { status \"okay\"; }; &tcon0 { pinctrl names \"default\"; pinctrl 0 <&lcd_rgb666_pins>; status \"okay\"; }; &tcon0_out { tcon0_out_lcd: endpoint@0 { reg <0>; remote endpoint <&panel_input>; }; }; 这里引用了 **compatible \"urt,umsh 8596md t\", \"simple panel\"**; 在 **drivers/gpu/drm/panel/panel simple.c** 里有很多屏幕型号，选取合适的屏幕型号即可 开启DRM还需要使能以下内核 1. support for simple panels 2. CMA 3. DMA_CMA 然后需要失能（注释）掉原来的simplefb在dts中的节点"},"/soft/Lichee/zh/Zero-Doc/Drive/UART.html":{"title":"UART操作","content":" subtitle: 基础操作 title: UART操作 首先在dts里使能UART： sun8i v3s.dtsi: uart0_pins_a: uart0@0 { pins \"PB8\", \"PB9\";function \"uart0\";bias pull up; }; uart1_pins_a: uart1@0 { pins \"PE21\", \"PE22\";function \"uart1\";bias pull up; }; uart2_pins_a: uart2@0 { pins \"PB0\", \"PB1\";function \"uart2\";bias pull up; }; sun8i v3s licheepi zero.dts: &uart0 { pinctrl 0 <&uart0_pins_a>;pinctrl names \"default\";status \"okay\"; }; &uart1 { pinctrl 0 <&uart1_pins_a>;pinctrl names \"default\";status \"okay\"; }; &uart2 { pinctrl 0 <&uart2_pins_a>;pinctrl names \"default\";status \"okay\"; }; 然后启动后就能看到ttyS0\\~ttyS2了 再使用常见串口软件就能使用 ## 波特率分频问题 为了串口通信稳定，一般要求波特率误差在2.5%以内。 V3S的uart是挂在APB2下，而APB2时钟是24M，所以对一些高速率的波特率，难以分频到合适的频率。 以921600为例，下面进行修改： 进入 **uboot的arch/arm/mach sunxi/clock_sun6i.c**，修改uart时钟： ``` void clock_init_uart(void) { #if CONFIG_CONS_INDEX < 5 struct sunxi_ccm_reg *const ccm (struct sunxi_ccm_reg *)SUNXI_CCM_BASE; /* uart clock source is apb2 */ writel(APB2_CLK_SRC_OSC24M //这里改为APB2_CLK_SRC_PLL6，从内部pll6时钟分频 APB2_CLK_RATE_N_1 //这里预分频不变 APB2_CLK_RATE_M(1), &ccm >apb2_div); ``` pll6时钟默认为600MHz，可以分出比较高的串口波特率。 600/0.9216/16 40.69， 舍入为41，相对误差为0.75% ``` /* ns16550 reg in the low bits of cpu reg */ #define CONFIG_SYS_NS16550_CLK 24000000 //这里改为600000000 #ifndef CONFIG_DM_SERIAL ``` 剩余的就是按照原有方法修改波特率了。"},"/soft/Lichee/zh/Zero-Doc/Drive/CODEC.html":{"title":"CODEC的使用","content":" title: CODEC的使用 默认dts中使能了codec 需要使用的话，在buildroot中勾选 alsa utils相关命令 ## CODEC 设备 ``` # ls /dev/snd controlC0 pcmC0D0c pcmC0D0p timer ``` controlC0表示控制器 pcmC0D0c 表示capture pcmC0D0p 表示play timer 表示定时器 使用该设备编程可以参考：<http://blog.csdn.net/zhenwenxian/article/details/5901239> 出现了该设备说明codec驱动被正确加载。 ## alsa utils 使用 ### 查看设备 # arecord l **** List of CAPTURE Hardware Devices **** card 0: Codec [V3s Audio Codec], device 0: CDC PCM Codec 0 [] Subdevices: 1/1 Subdevice #0: subdevice #0 ### 调节音量 alsamixer是图形化的amixer工具,如下图所示 ![](./../static/Drive/CODEC_1.jpg) ![](./../static/Drive/CODEC_2.jpg) 从左到右是：耳机音量，耳机输出源，Mic增益，mic1 boost, DAC增益。 可以很方便地调整音频输出设置 00表示当前音量正常，MM表示此声道是静音.可以通过键盘上的M键来切换静音和正常状态. 开机后默认状态是静音状态，需要取消掉静音状态 > `amixer c 0 sset 'Headphone',0 100% unmute` ### 查看控制器 amixer contents numid 13,iface MIXER,name 'Headphone Source Playback Route' ; type ENUMERATED,access rw ,values 2,items 2 ; Item #0 'DAC' ; Item #1 'Mixer' : values 0,0 numid 3,iface MIXER,name 'Headphone Playback Switch' ; type BOOLEAN,access rw ,values 2 : values off,off numid 2,iface MIXER,name 'Headphone Playback Volume' ; type INTEGER,access rw R ,values 1,min 0,max 63,step 0 : values 7 dBscale min 63.00dB,step 1.00dB,mute 1 numid 5,iface MIXER,name 'Mic1 Boost Volume' ; type INTEGER,access rw R ,values 1,min 0,max 7,step 0 : values 4 dBrange rangemin 0,,rangemax 0 dBscale min 0.00dB,step 0.00dB,mute 0 rangemin 1,,rangemax 7 dBscale min 24.00dB,step 3.00dB,mute 0 numid 12,iface MIXER,name 'Mic1 Capture Switch' ; type BOOLEAN,access rw ,values 2 : values on,on numid 9,iface MIXER,name 'Mic1 Playback Switch' ; type BOOLEAN,access rw ,values 2 : values off,off numid 4,iface MIXER,name 'Mic1 Playback Volume' ; type INTEGER,access rw R ,values 1,min 0,max 7,step 0 : values 3 dBscale min 4.50dB,step 1.50dB,mute 0 numid 6,iface MIXER,name 'ADC Gain Capture Volume' ; type INTEGER,access rw R ,values 1,min 0,max 7,step 0 : values 3 dBscale min 4.50dB,step 1.50dB,mute 0 numid 7,iface MIXER,name 'DAC Playback Switch' ; type BOOLEAN,access rw ,values 2 : values off,off numid 1,iface MIXER,name 'DAC Playback Volume' ; type INTEGER,access rw R ,values 1,min 0,max 63,step 0 : values 63 dBscale min 73.08dB,step 1.16dB,mute 0 numid 8,iface MIXER,name 'DAC Reversed Playback Switch' ; type BOOLEAN,access rw ,values 2 : values off,off numid 10,iface MIXER,name 'Mixer Capture Switch' ; type BOOLEAN,access rw ,values 2 : values off,off numid 11,iface MIXER,name 'Mixer Reversed Capture Switch' ; type BOOLEAN,access rw ,values 2 : values off,off ### 录音测试 耳机输入内置了放大器。 耳机，linein，同时只能使用1种。 使用输入端口前需要设置mixer控制器，ADC input Mux ADC Input Mux 和对应的输入端口 0 linein 1 fmin 2 mic1 3 mic2 4 mic1,mic2 5 mic1+mic2 6 output mixer 7 linein,mic1 使用amixer来设置通道 amixer c <\"card\"> cset numid <\"control#\"> <\"input_port\"> where: <\"card\"> is the card, 0 for the sunxi codec and 1 for the hdmi audio output <\"input_port\"> is the input port from the table <\"control#\"> is the control # showed using: aximer contents 使用下面命令使能耳机并录音 amixer c 0 cset numid 12 2 使能mic1 arecord D hw:0,0 d 3 f S16_LE r 16000 tmp.wav 录音测试 ### 播放 amixer c 0 sset 'Headphone',0 100% unmute speaker test twav c2 atest aplay tmp.wav 配置文件 /etc/asound.conf(简易配置) : {{{ pcm.!default{ type hw card 0 devive 0 } ctl.!default{ type hw card 0 device 0 } }}} 其中card代表声卡号, device代表设备号,asound.conf的配置极其强大和复杂,详情可查阅<http://www.alsa project.org/main/index.php/Main_Page> ### card, device的确定方法 card, device必须对应hdmi的声卡号和设备号,可以使用aplay l查看对应的hdmi设备,可能会有出现多个hdmi设备,确定当前可以使用的hdmi设备的方法如下: #. cat /proc/asound/cards 查看nvidia设备对应的ID号(假设 1) #. alsamixer c 1 打开声音设置,其中<S/PDIF>即为HDMI输出,“MM”代表静音,alsa在每次重启声音设备时都会默认为静音,所以必须首先打开音量再进行后续的操作。 #. alsactl store 保存上述配置 #. aplay D hw:1,7 /usr/share/sounds/alsa/test.wav \"hw后的1代表声卡号,7代表设备号,需要根据aplay l的输出来确定这两个数字\"找到对应的hdmi输出口。 参考 <http://linux sunxi.org/Audio_Codec>"},"/soft/Lichee/zh/Zero-Doc/Drive/GPIO_pinctrl_intro.html":{"title":"pinctrl-sunxi介绍","content":" title: pinctrl sunxi介绍 drivers/pinctrl/sunxi/pinctrl sunxi.c drivers/pinctrl/sunxi/pinctrl sun8i v3s.c //具体的引脚功能复用情况 gpio\\_in gpio\\_out"},"/soft/Lichee/zh/Zero-Doc/Drive/uboot_GPIO.html":{"title":"uboot下gpio操作","content":" title: uboot下gpio操作 ``` #define endtick(seconds) (get_ticks() + (uint64_t)(seconds) * get_tbclk()) ``` arch/arm/mach sunxi/cpu_info.c arch/arm/lib/bootm.c ``` #include <asm/arch/cpu.h> #include <asm/arch/clock.h> #include <cli.h> unsigned int * cfg_reg (unsigned int *)(0x01C20800+1*0x24+0); unsigned int * data_reg (unsigned int *)(0x01C20800+1*0x24+0x10); unsigned int tmp,tmp0,tmp1; uint64_t t1; int i; tmp *cfg_reg; tmp & ~0x0f00; tmp 0x0100; *cfg_reg tmp; tmp *data_reg; tmp0 tmp&(~0x04); tmp1 tmp0x04; t1 get_ticks()+get_tbclk()/12; for(i 0;i<3;i++) { *data_reg tmp0; puts(\"beep 0\\n\"); while(get_ticks()<t1); t1 get_ticks()+get_tbclk()/10; *data_reg tmp1; puts(\"beep 1\\n\"); while(get_ticks()<t1); t1 get_ticks()+get_tbclk()/10; } *data_reg tmp0; ```"},"/soft/Lichee/zh/Zero-Doc/Drive/watchdog.html":{"title":"看门狗的使用","content":" title: 看门狗的使用 ``` echo 0 >/dev/watchdog0 echo V >/dev/watchdog0 ``` 设置和获得超时值： 对于某些驱动来说，在上层使用SETTIMEOUT ioctl命令改变watchdog的超时值是可能的，那些驱动在他们的选项与中有WDIOF\\_SETTIMEOUT标志。参数是一个代表以秒为单位的超时值，驱动将在同一个变量中返回实际使用的超时值，这个超时值可能由于硬件的限制，而不同于所请求的超时值 ``` int timeout 45; ioctl(fd, WDIOC_SETTIMEOUT, &timeout); printf(\"The timeout was set to %d seconds\\n\", timeout); ``` 如果设备的超时值的粒度只能到分钟，则这个例子可能实际打印\"The timeout was set to 60 seconds\"。 自从Linux 2.4.18内核，通过GETTIMEOUT ioctl命令查询当前超时值也是可能的： ``` ioctl(fd, WDIOC_GETTIMEOUT, &timeout); printf(\"The timeout was is %d seconds\\n\", timeout); ```"},"/soft/Lichee/zh/Zero-Doc/Drive/GPIO_py.html":{"title":"Python 操作GPIO","content":" title: Python 操作GPIO 需要python3.8及以上版本 首先需要安装gpiod 下载gpiod的源码，解压到zero中。 ` wget https://files.pythonhosted.org/packages/09/4f/9c246b2133414f2566d848e89b20dbd8f22dd323f05954ecbb105191ab2a/gpiod 1.5.0.tar.gz` 解压后，使用 ```bash python setup.py build python setup.py install ``` 安装 如果出现 ` ValueError: ZIP does not support timestamps before 1980` ,则需要修改下系统时间。 ` date s 2022 2 22` gpiod依赖于libgpiod，还需要在buildroot中开启。需要注意的是，编译器内核要大于4.8，因此6.x的交叉编译工具不能使用（内核4.6） 升级编译链版本后，需要make clean后重新编译。 如果使用的设备树是with dock的话，还需要注释掉mmc1，不然无法控制PG0 PG5。 然后运行led.py即可。 如果出现** ` module 'gpiod' has no attribute 'chip` , 则需要打开 `/usr/bin/python` , 删除掉gpiod.so led.py ```python import time import gpiod as gpio PG_BASE (7 1)*32 # \"PG\" gpiochip0 gpio.chip(\"gpiochip0\") led gpiochip0.get_line((PG_BASE + 1)) # \"PG1\" config gpio.line_request() config.request_type gpio.line_request.DIRECTION_OUTPUT led.request(config)   while led:    led.set_value(0)    time.sleep(1)    print(hello sipeed!)    led.set_value(1)    time.sleep(1)    print(hello sipeed!) ``` 运行结果 ```bash licheepi# python led.py [ 3634.510245] sun8i v3s pinctrl 1c20800.pinctrl: 1c20800.pinctrl supply vcc pg not found, using dummy regulator hello sipeed! hello sipeed! ```"},"/soft/Lichee/zh/Zero-Doc/Drive/SPI_LCD.html":{"title":"点屏之SPI屏","content":" title: 点屏之SPI屏 荔枝派配套的5寸LCD尺寸比较大，如果需要较小的屏幕，可以选择SPI屏。 目前最新的4.1x内核均包含了市面上常见的SPI液晶屏的驱动（fbtft），我们所要做的仅仅是在设备树中添加节点。 不过目前为止fbtft并未转正，依然存放在 *drivers/staging* 目录中。 ## 配置内核添加fbtft驱动 使用make menuconfig配置内核，加入ili9341驱动。fbtft还支持更多型号的SPI总线的液晶屏。关于支持列表这里就不一一列出，可以进入menuconfig中查看。 Device Drivers > [] Staging drivers > <> Support for small TFT LCD display modules > <> FB driver for the ILI9341 LCD Controller <> Generic FB driver for TFT LCD displays ## 修改设备树注册ili9341 设备树有包含和覆盖特性，所以我们可以在不修改默认配置文件的情况下，新增我们的板子的修改。 新建 **arch/arm/boot/dts/sun8i v3s licheepi zero spitft.dts** 里面加入如下内容，一个就是 **删除** 原来的simplefb节点（uboot里有使能fb的操作，必须删除而不是disable才行） 二就是增加ili9341 挂载在spi0上。这样fbtft驱动在加载的时候就会自动找到这个节点，挂载驱动，显示。 //这里spi速率使用了50M，超出9341的手册范围，但实际测试可以使用。 注意这里删除后，uboot仍然会初始化RGB的驱动，只是内核会使用spi显示。 如果需要完全去除RGB上的显示，需要在uboot里关闭显示。 /dts v1/; #include \"sun8i v3s licheepi zero.dts\" /{ chosen { /delete node/ framebuffer@0; }; }; &spi0 { status \"okay\"; ili9341@0 { compatible \"ilitek,ili9341\"; reg <0>; spi max frequency <50000000>; rotate <270>; bgr; fps <30>; buswidth <8>; reset gpios <&pio 1 7 GPIO_ACTIVE_LOW>; dc gpios <&pio 1 5 GPIO_ACTIVE_LOW>; debug <0>; }; }; 修改好保存后，在dtsMakefile里加入编译对象：\\*sun8i v3s licheepi zero spitft.dtb\\* 注： dc gpios \\<&pio 1 5 GPIO\\_ACTIVE\\_LOW\\>; 在设备树中，PA对应&pio 0, PB对应&pio 1，以此类推。因此dc gpios实际表示的是PB5，也就是zero丝印上的PWM1。 reset gpios \\<&pio 1 7 GPIO\\_ACTIVE\\_LOW\\>; 如果我的屏幕的RESET引脚连接了高电平，或者接了一个RC回路作为上电复位的信号，那么这里的复位引脚是不是可以不指定呢？ 这样也是不可以的。因为在程序中，首先读取reset gpios，若reset gpios在设备树中不存在，那么直接忽略其余的信号。这样导致无法控制最关键的dc gpios引脚。因此至少在不更改程序的前提下，这条信号是一定要写上的。 ``` static int fbtft_request_gpios_dt(struct fbtft_par *par) { int i; int ret; if (!par >info >device >of_node) return EINVAL; ret fbtft_request_one_gpio(par, \"reset gpios\", 0, &par >gpio.reset); if (ret) return ret; ret fbtft_request_one_gpio(par, \"dc gpios\", 0, &par >gpio.dc); if (ret) return ret; ``` 烧写运行后，可以在 **/sys/firmware/devicetree** 下查看实际的设备树 ## 硬件连接 SPI屏zero 3v3 3v3 GND GND DC PWM1 RST 3v3 CS CS CLK CLK MISO MISO MOSI MOSI ## 上电启动 linux内核启动时会加载fbtft驱动，注册framebuffer设备，打印如下信息： [ 1.131698] fbtft_of_value: buswidth 8 [ 1.135680] fbtft_of_value: debug 0 [ 1.139345] fbtft_of_value: rotate 270 [ 1.143268] fbtft_of_value: fps 30 [ 1.192746] mmc0: host does not support reading read only switch, assuming write enable [ 1.202997] mmc0: new high speed SD card at address b368 [ 1.208984] mmcblk0: mmc0:b368 UD 968 MiB [ 1.214696] mmcblk0: p1 p2 [ 1.439491] Console: switching to colour frame buffer device 40x30 [ 1.447560] graphics fb0: fb_ili9341 frame buffer, 320x240, 150 KiB video memory, 16 KiB buffer memory, fps 33, spi0.0 at 50 MHz 说明帧率在33帧左右，适合常见场合。 显示效果如下图： ![](./../static/Drive/SPI_LCD.jpg) 使用mplayer播放视频效果如下, 还是很流畅的。 <http://v.youku.com/v_show/id_XMzM3NjY0NTU3Ng .html> 系统占用如下： PID PPID USER STAT VSZ %VSZ %CPU COMMAND 105 98 root T 19692 35% 0% mplayer dcp1.mp4"},"/soft/Lichee/zh/Zero-Doc/Drive/RGB_LCD.html":{"title":"点屏之RGB屏","content":" title: 点屏之RGB屏 Zero默认支持800x480和480x272这两种常见分辨率的的RGB屏幕。 这两种分辨率的屏幕，直接在编译时候选择对应的分辨率即可。 Zero还可以接RGB2VGA小板或者RGB2LVDS小板来驱动VGA液晶屏或者LVDS屏幕，这时候就需要自己改动屏幕参数了。 ## Uboot屏幕参数 修改FB大小 FB大小为 分辨率x4： > 800x480x4 1.5M 800x600x4 1.8M 1024x600x4 2.4M 1024x768x4 3M 1024x1024x4 4M 默认uboot里预留了2M的FB，对于1024x600以上的屏幕无法显示。 需要修改 **u boot/include/configs/sunxi common.h** 文件 `296 #define CONFIG_SUNXI_MAX_FB_SIZE (2 << 20)` 改为 `296 #define CONFIG_SUNXI_MAX_FB_SIZE (3 << 20)` 增加时序文件 默认配置文件在u boot/configs/LicheePi\\_Zero\\_800x480LCD\\_defconfig等，可以根据自己的需要来新增文件，比如： `u boot/configs/LicheePi_Zero_1024x768LCD_defconfig` `7CONFIG_VIDEO_LCD_MODE \"x:800,y:480,depth:18,pclk_khz:33000,le:87,ri:40,up:31,lo:13,hs:1,vs:1,sync:3,vmode:0\"` 改为 `CONFIG_VIDEO_LCD_MODE \"x:1024,y:768,depth:24,pclk_khz:32000,le:198,ri:120,up:21,lo:821,hs:2,vs:2,sync:3,vmode:0\"` （时钟太高\\>60M貌似会hang？） 这里有个小脚本可以把fex文件的时序转换成uboot的时序： ``` #!/usr/bin/env ruby if !ARGV[0] !File.exists?(ARGV[0]) then abort \"Usage: ruby #{__FILE__} [fex_file_name]\\n\" end def parse_fex_section(filename, section) results {} current_section \"\" File.open(filename).each_line {l current_section $1 if l ~ /^\\[(.*?)\\]/ next if current_section ! section results[$1] $2.strip if l ~ /^(\\S+)\\s*\\ \\s*(.*)/ results[$1] $2.to_i if l ~ /^(\\S+)\\s*\\ \\s*(\\d+)\\s*$/ } return results end def print_video_lcd_mode(lcd0_para, vt_div) x lcd0_para[\"lcd_x\"] y lcd0_para[\"lcd_y\"] depth { 0 > 24, 1 > 18 }[lcd0_para[\"lcd_frm\"]] pclk_khz lcd0_para[\"lcd_dclk_freq\"] * 1000 hs [1, (lcd0_para[\"lcd_hv_hspw\"] lcd0_para[\"lcd_hspw\"])].max vs [1, (lcd0_para[\"lcd_hv_vspw\"] lcd0_para[\"lcd_vspw\"])].max le lcd0_para[\"lcd_hbp\"] hs ri lcd0_para[\"lcd_ht\"] x lcd0_para[\"lcd_hbp\"] up lcd0_para[\"lcd_vbp\"] vs lo lcd0_para[\"lcd_vt\"] / vt_div y lcd0_para[\"lcd_vbp\"] abort \"Unsupported 'lcd_frm' parameter\" if !depth printf(\"CONFIG_VIDEO_LCD_MODE \\\"\" + \"x:#{x},y:#{y},depth:#{depth},pclk_khz:#{pclk_khz},\" + \"le:#{le},ri:#{ri},up:#{up},lo:#{lo},hs:#{hs},vs:#{vs},\" + \"sync:3,vmode:0\\\"\\n\") end lcd0_para parse_fex_section(ARGV[0], \"lcd0_para\") abort \"Not a valid 'lcd0_para' section\" if lcd0_para[\"lcd_used\"] ! 1 printf(\" for sun[457]i \\n\") print_video_lcd_mode(lcd0_para, 2) printf(\"\\n for sun[68]i \\n\") print_video_lcd_mode(lcd0_para, 1) ```"},"/soft/Lichee/zh/Zero-Doc/Drive/Ethernet.html":{"title":"以太网使用指南","content":" title: 以太网使用指南 ## U Boot适配Ethernet U Boot 2017已经支持了sun8i emac的驱动，只需要在编译时选上并且修改dts就行。 进入u boot源码目录： ``` make LicheePi_Zero_defconfig make menuconfig ``` ![](./../static/Drive/Ethernet_1.png) 选择 **Device Drivers \\>** ![](./../static/Drive/Ethernet_2.png) 选择 **Network device support \\>** 并选中 **Allwinner Sun8i Ethernet MAC support** ![](./../static/Drive/Ethernet_3.png) 修改dts sun8i v3s licheepi zero.dts： diff git a/arch/arm/dts/sun8i v3s licheepi zero.dts b/arch/arm/dts/sun8i v3s licheepi zero.dts index 3d9168c..b8b9fc3 100644 a/arch/arm/dts/sun8i v3s licheepi zero.dts +++ b/arch/arm/dts/sun8i v3s licheepi zero.dts @@ 49,6 +49,7 @@ compatible \"licheepi,licheepi zero\", \"allwinner,sun8i v3s\"; aliases { + ethernet0 &emac; serial0 &uart0; }; @@ 81,3 +82,14 @@ usb0_id_det gpio <&pio 5 6 GPIO_ACTIVE_HIGH>; status \"okay\"; }; + +&emac { + phy <&phy0>; + phy mode \"mii\"; + allwinner,use internal phy; + allwinner,leds active low; + status \"okay\"; + phy0: ethernet phy@0 { + reg <1>; + }; +}; sun8i v3s.dtsi： diff git a/arch/arm/dts/sun8i v3s.dtsi b/arch/arm/dts/sun8i v3s.dtsi index ebefc0f..cb81dd5 100644 a/arch/arm/dts/sun8i v3s.dtsi +++ b/arch/arm/dts/sun8i v3s.dtsi @@ 96,6 +96,11 @@ #size cells <1>; ranges; + syscon: syscon@01c00000 { + compatible \"allwinner,sun8i h3 syscon\",\"syscon\"; + reg <0x01c00000 0x34>; + }; + mmc0: mmc@01c0f000 { compatible \"allwinner,sun7i a20 mmc\"; reg <0x01c0f000 0x1000>; @@ 208,6 +213,17 @@ interrupt controller; #interrupt cells <3>; + emac_rgmii_pins: emac0@0 { + allwinner,pins \"PD0\", \"PD1\", \"PD2\", \"PD3\", + \"PD4\", \"PD5\", \"PD7\", + \"PD8\", \"PD9\", \"PD10\", + \"PD12\", \"PD13\", \"PD15\", + \"PD16\", \"PD17\"; + allwinner,function \"emac\"; + allwinner,drive <SUN4I_PINCTRL_40_MA>; + allwinner,pull <SUN4I_PINCTRL_NO_PULL>; + }; + uart0_pins_a: uart0@0 { pins \"PB8\", \"PB9\"; function \"uart0\"; @@ 270,6 +286,20 @@ status \"disabled\"; }; + emac: ethernet@1c30000 { + compatible \"allwinner,sun8i h3 emac\"; + reg <0x01c30000 0x104>, <0x01c00030 0x4>; + reg names \"emac\", \"syscon\"; + interrupts <GIC_SPI 82 IRQ_TYPE_LEVEL_HIGH>; + resets <&ccu RST_BUS_EMAC>, <&ccu RST_BUS_EPHY>; + reset names \"ahb\", \"ephy\"; + clocks <&ccu CLK_BUS_EMAC>, <&ccu CLK_BUS_EPHY>; + clock names \"ahb\", \"ephy\"; + #address cells <1>; + #size cells <0>; + status \"disabled\"; + }; + gic: interrupt controller@01c81000 { compatible \"arm,cortex a7 gic\", \"arm,cortex a15 gic\"; reg <0x01c81000 0x1000>, 编译： ``` make ARCH arm CROSS_COMPILE arm linux gnueabihf ``` 烧写： ``` dd if u boot sunxi with spl.bin of ${card} bs 1024 seek 8 ``` 使用Ethernet： ![](./../static/Drive/Ethernet_4.png) 如果出现： `*** ERROR:ipaddr' not set` ，就需要设置下自己的ip： `setenv ipaddr 192.168.1.111` ## Kernel适配Ethernet 在最新的linux 4.14内核中，已经增加了对以太网的支持。 目前Linux 4.12还没又对sun8i emac进行支持，所以Kernel要使用V3s的以太网要打sun8i emac的补丁还有修改dts文件。 打上sun8i emac补丁： 拉下我已经适配好的内核源码：<https://github.com/techping/linux/tree/licheepi zero> 修改dts(上面git仓库是已经修改完的)： sun8i v3s licheepi zero.dts： index 387fc2a..904e60e 100644 a/arch/arm/boot/dts/sun8i v3s licheepi zero.dts +++ b/arch/arm/boot/dts/sun8i v3s licheepi zero.dts @@ 50,6 +50,7 @@ aliases { serial0 &uart0; + ethernet0 &emac; }; chosen { @@ 101,3 +102,10 @@ usb0_id_det gpio <&pio 5 6 GPIO_ACTIVE_HIGH>; status \"okay\"; }; + +&emac { + phy handle <&int_mii_phy>; + phy mode \"mii\"; + allwinner,leds active low; + status \"okay\"; +}; sun8i v3s.dtsi： diff git a/arch/arm/boot/dts/sun8i v3s.dtsi b/arch/arm/boot/dts/sun8i v3s.dtsi index 7107596..65be2ab 100644 a/arch/arm/boot/dts/sun8i v3s.dtsi +++ b/arch/arm/boot/dts/sun8i v3s.dtsi @@ 40,7 +40,10 @@ * OTHER DEALINGS IN THE SOFTWARE. */ +#include <dt bindings/clock/sun8i v3s ccu.h> +#include <dt bindings/reset/sun8i v3s ccu.h> #include <dt bindings/interrupt controller/arm gic.h> +#include <dt bindings/pinctrl/sun4i a10.h> / { #address cells <1>; @@ 93,6 +96,12 @@ #size cells <1>; ranges; + syscon: syscon@1c00000 { + compatible \"allwinner,sun8i h3 system controller\", + \"syscon\"; + reg <0x01c00000 0x1000>; + }; + mmc0: mmc@01c0f000 { compatible \"allwinner,sun7i a20 mmc\"; reg <0x01c0f000 0x1000>; @@ 205,6 +214,17 @@ interrupt controller; #interrupt cells <3>; + emac_rgmii_pins: emac0@0 { + allwinner,pins \"PD0\", \"PD1\", \"PD2\", \"PD3\", + \"PD4\", \"PD5\", \"PD7\", + \"PD8\", \"PD9\", \"PD10\", + \"PD12\", \"PD13\", \"PD15\", + \"PD16\", \"PD17\"; + allwinner,function \"emac\"; + allwinner,drive <SUN4I_PINCTRL_40_MA>; + allwinner,pull <SUN4I_PINCTRL_NO_PULL>; + }; + i2c0_pins: i2c0 { pins \"PB6\", \"PB7\"; function \"i2c0\"; @@ 295,6 +315,31 @@ #size cells <0>; }; + emac: ethernet@1c30000 { + compatible \"allwinner,sun8i h3 emac\"; + syscon <&syscon>; + reg <0x01c30000 0x104>; + interrupts <GIC_SPI 82 IRQ_TYPE_LEVEL_HIGH>; + interrupt names \"macirq\"; + resets <&ccu RST_BUS_EMAC>; + reset names \"stmmaceth\"; + clocks <&ccu CLK_BUS_EMAC>; + clock names \"stmmaceth\"; + #address cells <1>; + #size cells <0>; + status \"disabled\"; + + mdio: mdio { + #address cells <1>; + #size cells <0>; + int_mii_phy: ethernet phy@0 { + compatible \"ethernet phy ieee802.3 c22\"; + reg <1>; + clocks <&ccu CLK_BUS_EPHY>; + resets <&ccu RST_BUS_EPHY>; + }; + }; + }; gic: interrupt controller@01c81000 { compatible \"arm,cortex a7 gic\", \"arm,cortex a15 gic\"; reg <0x01c81000 0x1000>, 进入内核目录： ``` make sunxi_defconfig ARCH arm make menuconfig ARCH arm ``` 选择 Device Drivers \\> 选择 Network device support \\> 选择 Ethernet driver support \\> 选择 [*] STMicroelectronics devices x x <*> STMicroelectronics 10/100/1000/EQOS Ethernet driver <*> STMMAC Platform bus support x x < > Support for snps,dwc qos ethernet.txt DT binding. <*> Generic driver for DWMAC x x <*> Allwinner GMAC support x x <*> Allwinner sun8i GMAC support 编译 `make ARCH arm CROSS_COMPILE arm linux gnueabihf ` 得到zImage和sun8i v3s licheepi zero.dtb 烧写 将内核、dtb、rootfs刷入sd卡中，启动： `ifup eth0` ![](./../static/Drive/Ethernet_5.png) eth0启动成功！ ![](./../static/Drive/Ethernet_6.png) **Ethernet驱动适配成功！**"},"/soft/Lichee/zh/Zero-Doc/Drive/GPIO_libgpiod.html":{"title":"C语言方式(libgpiod)","content":" title: C语言方式(libgpiod) 在linux4.8以后，可以通过libgpiod库控制gpio 首先在buildroot中生成libgpiod库，然后就可以编写c代码了。 ``` #include <stdio.h> #include <unistd.h> #include <gpiod.h> #define msleep(t) usleep((t)*1000) int main(int argc, char const *argv[]) { struct gpiod_chip *chip; struct gpiod_line *line; struct gpiod_line_request_config config; int req; /* PH0 (H 1)*32+0 (7 1)*32+0 192 */ int PH0 192; /* 打开 GPIO 控制器 */ gpiochip0 gpiod_chip_open(\"/dev/gpiochip0\"); if (!gpiochip0) return 1; /* 获取PH5引脚 */ led gpiod_chip_get_line(gpiochip0, PH5); if (!led) { gpiod_chip_close(gpiochip0); return 1; } config.consumer \"blink\"; config.request_type GPIOD_LINE_REQUEST_DIRECTION_OUTPUT; // 输出模式 /* 配置引脚 */ reg gpiod_line_request(led, &config, 0); if (reg) { fprintf(stderr, \"led request error.\\n\"); return 1; } while (1) { /* 设置引脚电平 */ gpiod_line_set_value(led, 1); printf(\"set led to 0\\n\"); msleep(500); gpiod_line_set_value(led, 0); printf(\"set led to 1\\n\"); msleep(500); } return 0; } ``` 或者 ``` #include <stdio.h> #include <unistd.h> #include <gpiod.h> #define msleep(t) usleep((t)*1000) int main(int argc, char const *argv[]) { struct gpiod_chip *gpiochip0; struct gpiod_line *led; struct gpiod_line_request_config config; int req; /* PH0 (H 1)*32+0 (7 1)*32+0 192 */ int PH0 192; /* 打开 GPIO 控制器 */ gpiochip0 gpiod_chip_open(\"/dev/gpiochip0\"); if (!gpiochip0) return 1; /* 获取PH5引脚 */ led gpiod_chip_get_line(gpiochip0, PH5); if (!led) { gpiod_chip_close(gpiochip0); return 1; } /* 配置引脚 输出模式 name为“bilik” 初始电平为low*/ req gpiod_line_request_output(led, \"blink\", 0); if (req) { fprintf(stderr, \"led request error.\\n\"); return 1; } while (1) { /* 设置引脚电平 */ gpiod_line_set_value(led, 1); printf(\"set led to 0\\n\"); msleep(500); gpiod_line_set_value(led, 0); printf(\"set led to 1\\n\"); msleep(500); } return 0; } ``` 对比python ``` import time import gpiod as gpio PG_BASE (7 1)*32 # \"PG\" gpiochip0 gpio.chip(\"gpiochip0\") led gpiochip0.get_line((PG_BASE + 1)) # \"PG1\" config gpio.line_request() config.request_type gpio.line_request.DIRECTION_OUTPUT led.request(config) while led: led.set_value(0) time.sleep(1) led.set_value(1) time.sleep(1) ``` 可以看出api基本是一致的。 使用交叉编译生成led.o文件，丢到板子里。 需要注意的是，编译libgpiod需要的编译器内核版本需要大于4.8，不然会报configure: error: \"libgpiod needs linux headers version > v4.8.0\"，也即是意味着 `arm linux gnueabihf`的版本要大于7 ### 交叉编译配置 首先下载libgpiod源码 ``` wget https://git.kernel.org/pub/scm/libs/libgpiod/libgpiod.git/snapshot/libgpiod 1.6.3.tar.gz ``` 安装依赖 ``` apt get isntall autoconf ``` 配置安装选项 ``` ./autogen.sh enable tools no host arm linux gnueabihf prefix /home/lithromantic/Desktop/led/source ``` host指定交叉编译链，注意不带后缀 prefix指定安装路径，必须是绝对路径。一般安装到工程目录下，也可以安装到一个固定的位置用于共享。 还需要注释一个define，不然会报`undefined reference to rpl_malloc` `vim config.h` 划到最后尾，删除 ``` /* Define to rpl_malloc if the replacement function should be used. */ #define malloc rpl_malloc ``` 然后 ``` make make install ``` ### 交叉编译 ``` cd led vim led.c arm linux gnueabihf gcc o led led.c I ./source/include L ./source/lib lgpiod ``` `arm linux gnueabihf gcc o led` 使用arm编译器， o 指定输出名为led ` I ./source/include` I 指定头文件位置 ` L ./source/lib` L 指定动态链接库位置 ` lgpiod` 指定使用的链接库 因为我们在荔枝派上已经安装了libgpiod，所以可以动态引用，如果需要静态编译，则需要在最后面添加 ` static`"},"/soft/Lichee/zh/Zero-Doc/Drive/atmel_touch.html":{"title":"atmel触摸屏驱动分析","content":" title: atmel触摸屏驱动分析 最新代码在：<https://github.com/atmel maxtouch/linux> 3847行 从下往上走读： 版权信息 ``` /* Module information */ MODULE_AUTHOR(\"Joonyoung Shim <jy0922.shim@samsung.com>\"); MODULE_DESCRIPTION(\"Atmel maXTouch Touchscreen driver\"); MODULE_LICENSE(\"GPL\"); ``` 设备树匹配的名称： ``` static const struct i2c_device_id mxt_id[] { { \"qt602240_ts\", 0 }, { \"atmel_mxt_ts\", 0 }, { \"atmel_mxt_tp\", 0 }, { \"maxtouch\", 0 }, { \"mXT224\", 0 }, { } }; ``` 待机模式操作 ``` static SIMPLE_DEV_PM_OPS(mxt_pm_ops, mxt_suspend, mxt_resume); #define SIMPLE_DEV_PM_OPS(name, suspend_fn, resume_fn) \\ const struct dev_pm_ops name { \\ SET_SYSTEM_SLEEP_PM_OPS(suspend_fn, resume_fn) \\ } ``` 移除操作 ``` static int mxt_remove(struct i2c_client *client) { struct mxt_data *data i2c_get_clientdata(client); sysfs_remove_group(&client >dev.kobj, &mxt_fw_attr_group); mxt_debug_msg_remove(data); mxt_sysfs_remove(data); #ifndef __POLL if (data >irq) free_irq(data >irq, data); #endif regulator_put(data >reg_avdd); regulator_put(data >reg_vdd); mxt_free_input_device(data); mxt_free_object_table(data); kfree(data); return 0; } ``` 插入操作 ``` static int mxt_probe(struct i2c_client *client, const struct i2c_device_id *id) { struct mxt_data *data; const struct mxt_platform_data *pdata; int error; pdata mxt_get_platform_data(client); //获取平台数据 if (IS_ERR(pdata)) return PTR_ERR(pdata); data kzalloc(sizeof(struct mxt_data), GFP_KERNEL); if (!data) return ENOMEM; snprintf(data >phys, sizeof(data >phys), \"i2c %u %04x/input0\", client >adapter >nr, client >addr); data >client client; data >pdata pdata; i2c_set_clientdata(client, data); //保存数据 if (data >pdata >cfg_name) //配置文件名 mxt_update_file_name(&data >client >dev, &data >cfg_name, data >pdata >cfg_name, strlen(data >pdata >cfg_name)); init_completion(&data >chg_completion); init_completion(&data >reset_completion); init_completion(&data >crc_completion); mutex_init(&data >debug_msg_lock); if (pdata >suspend_mode MXT_SUSPEND_REGULATOR) { __D; error mxt_acquire_irq(data); if (error) goto err_free_mem; error mxt_probe_regulators(data); if (error) goto err_free_irq; disable_irq(data >irq); } error sysfs_create_group(&client >dev.kobj, &mxt_fw_attr_group); if (error) { dev_err(&client >dev, \"Failure %d creating fw sysfs group\\n\", error); return error; } error mxt_initialize(data); if (error) goto err_free_irq; return 0; err_free_irq: if (data >irq) free_irq(data >irq, data); err_free_mem: kfree(data); return error; } ``` 获取平台数据 ``` static const struct mxt_platform_data * mxt_get_platform_data(struct i2c_client *client) { const struct mxt_platform_data *pdata; pdata dev_get_platdata(&client >dev); //已经获取过就直接返回 if (pdata) return pdata; pdata mxt_parse_dt(client); //解析dts//初始化gpio_reset，cfg_name，input_name，gpio keymap，suspend_mode if (!IS_ERR(pdata) PTR_ERR(pdata) ! ENOENT) return pdata; pdata mxt_parse_acpi(client); if (!IS_ERR(pdata) PTR_ERR(pdata) ! ENOENT) return pdata; pdata mxt_default_pdata(client); if (!IS_ERR(pdata)) return pdata; dev_err(&client >dev, \"No platform data specified\\n\"); return ERR_PTR( EINVAL); } ``` 获取中断 ``` static int mxt_acquire_irq(struct mxt_data *data) { int error; #ifndef __POLL if (!data >irq) { //没有中断的话申请中断线程 error request_threaded_irq(data >client >irq, NULL, mxt_interrupt, data >pdata >irqflags IRQF_ONESHOT, data >client >name, data); if (error) { dev_err(&data >client >dev, \"Error requesting irq\\n\"); return error; } /* Presence of data >irq means IRQ initialised */ data >irq data >client >irq; } else { //存在中断，则使能 enable_irq(data >irq); } #endif if (data >object_table && data >use_retrigen_workaround) { error mxt_process_messages_until_invalid(data); if (error) return error; } return 0; } ``` 中断服务例程 ``` static irqreturn_t mxt_interrupt(int irq, void *dev_id) { struct mxt_data *data dev_id; complete(&data >chg_completion); if (data >in_bootloader) { if (data >flash && &data >flash >work) cancel_delayed_work_sync(&data >flash >work); return IRQ_RETVAL(mxt_check_bootloader(data)); } if (!data >object_table) return IRQ_HANDLED; if (data >T44_address) { //有T44地址 return mxt_process_messages_t44(data); } else { return mxt_process_messages(data); } } ``` 处理消息 ``` static irqreturn_t mxt_process_messages(struct mxt_data *data) { int total_handled, num_handled; u8 count data >last_message_count; if (count < 1 count > data >max_reportid) count 1; /* include final invalid message */ total_handled mxt_read_and_process_messages(data, count + 1); if (total_handled < 0) return IRQ_NONE; /* if there were invalid messages, then we are done */ else if (total_handled < count) goto update_count; /* keep reading two msgs until one is invalid or reportid limit */ do { num_handled mxt_read_and_process_messages(data, 2); if (num_handled < 0) return IRQ_NONE; total_handled + num_handled; if (num_handled < 2) break; } while (total_handled < data >num_touchids); update_count: data >last_message_count total_handled; if (data >update_input) { mxt_input_sync(data); data >update_input false; } return IRQ_HANDLED; } ```"},"/soft/Lichee/zh/Zero-Doc/Drive/I2C.html":{"title":"I2C操作","content":" title: I2C操作 ## 使能设备树节点 ``` &i2c0 { status \"okay\"; ns2009: ns2009@48 { compatible \"nsiway,ns2009\"; reg <0x48>; }; sht21: sht21@40 { compatible \"sht21\"; reg <0x40>; }； atmel_mxt_ts@4a { compatible \"atmel,atmel_mxt_ts\"; reg <0x4a>; /*interrupt parent <&pio>; interrupts <6 5 IRQ_TYPE_LEVEL_LOW>;*/ //省引脚，使用轮训方式 }; }; ``` ## 使用i2c tools root@LicheePi:~# i2cdetect l #查看系统使能的i2c总线，这里只有i2c0一个 i2c 0 i2c mv64xxx_i2c adapter I2C adapter root@LicheePi:~# i2cdetect r y 0 //检测总线上的设备。 y表示省去交互式 0 1 2 3 4 5 6 7 8 9 a b c d e f 00: 10: 20: 30: 40: 40 UU 4a 50: 60: 70: 这里的40,48,4a 分别是sht21温湿度传感器，ns2009电阻式触摸传感器，mxt336T电容式触摸传感器。 i2c上读写数据： ``` i2cset y 1 0x40 0x00 0x13 i2cget y 1 0x40 0x00 ``` ## sht21 传感器使用 ``` insmod sht21.ko echo sht21 0x40 > /sys/bus/i2c/devices/i2c 0/new_device ls /sys/class/hwmon/hwmon0 device name subsystem uevent humidity1_input power temp1_input cat /sys/class/hwmon/hwmon0/temp1_input 25201 #毫摄氏度，即25.201摄氏度 cat /sys/class/hwmon/hwmon0/humidity1_input 58872 #毫百分之1，即58.872%RH ``` ## 参考文档 <https://blog.dbrgn.ch/2017/2/6/read sht21 sensor from linux raspberry pi/> <http://www.360doc.com/content/14/1008/11/7775902_415207889.shtml> <http://blog.csdn.net/AJ_chenrui/article/details/51202689>"},"/soft/Lichee/zh/Zero-Doc/Drive/GPIO_file.html":{"title":"文件IO方式操作","content":" title: 文件IO方式操作 ## GPIO编号及复用功能 在Linux中，GPIO 使用0～MAX_INT之间的整数标识。 对于32位CPU，每组GPIO 32个，引脚号就是按顺序排列。 LicheePi Zero的所有IO的复用功能及GPIO标识号为： \\>\\> 总共52个IO，所有IO上电默认状态为高阻态, 驱动电流强度20mA \\>\\> PB和PG具有中断功能 Pin Name Pin Number Func2 Func3 Func4 Func5 Func6 PB0 32 UART2_TX \\ \\ \\ PB_EINT0 PB1 33 UART2_RX \\ \\ \\ PB_EINT1 PB2 34 UART2_RTS \\ \\ \\ PB_EINT2 PB3 35 UART2_CTS \\ \\ \\ PB_EINT3 PB4 36 PWM0 \\ \\ \\ PB_EINT4 PB5 37 PWM1 \\ \\ \\ PB_EINT5 PB6 38 TWI0_SCK \\ \\ \\ PB_EINT6 PB7 39 TWI0_SDA \\ \\ \\ PB_EINT7 PB8 40 TWI1_SCK UART0_TX \\ \\ PB_EINT8 PB9 41 TWI1_SDA UART0_RX \\ \\ PB_EINT9 PC0 64 SDC2_CLK SPI0_MISO \\ \\ \\ PC1 65 SDC2_CMD SPI0_CLK \\ \\ \\ PC2 66 SDC2_RST SPI0_CS \\ \\ \\ PC3 67 SDC2_D0 SPI0_MOSI \\ PE0 128 CSI_PCLK LCD_CLK \\ \\ \\ PE1 129 CSI_MCLK LCD_DE \\ \\ \\ PE2 130 CSI_HSYNC LCD_HSYNC \\ \\ \\ PE3 131 CSI_VSYNC LCD_VSYNC \\ \\ \\ PE4 132 CSI_D0 LCD_D2 \\ \\ \\ PE5 133 CSI_D1 LCD_D3 \\ \\ \\ PE6 134 CSI_D2 LCD_D4 \\ \\ \\ PE7 135 CSI_D3 LCD_D5 \\ \\ \\ PE8 136 CSI_D4 LCD_D6 \\ \\ \\ PE9 137 CSI_D5 LCD_D7 \\ \\ \\ PE10 138 CSI_D6 LCD_D10 \\ \\ \\ PE11 139 CSI_D7 LCD_D11 \\ \\ \\ PE12 140 CSI_D8 LCD_D12 \\ \\ \\ PE13 141 CSI_D9 LCD_D13 \\ \\ \\ PE14 142 CSI_D10 LCD_D14 \\ \\ \\ PE15 143 CSI_D11 LCD_D15 \\ \\ \\ PE16 144 CSI_D12 LCD_D18 \\ \\ \\ PE17 145 CSI_D13 LCD_D19 \\ \\ \\ PE18 146 CSI_D14 LCD_D20 \\ \\ \\ PE19 147 CSI_D15 LCD_D21 \\ \\ \\ PE20 148 CSI_FIELD CSI_MIPI_MCLK \\ \\ \\ PE21 149 CSI_SCK TWI1_SCK UART1_TX \\ \\ PE22 150 CSI_SDA TWI1_SDA UART1_RX \\ \\ PE23 151 \\ LCD_D22 UART1_RTS \\ \\ PE24 152 \\ LCD_D23 UART1_CTS \\ \\ PF0 160 SDC0_D1 JTAG_MS \\ \\ \\ PF1 161 SDC0_D0 JTAG_DI \\ \\ \\ PF2 162 SDC0_CLK UART0_TX \\ \\ \\ PF3 163 SDC0_CMD JTAG_DO \\ \\ \\ PF4 164 SDC0_D3 UART0_RX \\ \\ \\ PF5 165 SDC0_D2 JTAG_CK \\ \\ \\ PF6 166 \\ \\ \\ \\ \\ PG0 192 SDC1_CLK \\ \\ \\ PG_EINT0 PG1 193 SDC1_CMD \\ \\ \\ PG_EINT1 PG2 194 SDC1_D0 \\ \\ \\ PG_EINT2 PG3 195 SDC1_D1 \\ \\ \\ PG_EINT3 PG4 196 SDC1_D2 \\ \\ \\ PG_EINT4 PG5 197 SDC1_D3 \\ \\ \\ PG_EINT5 ## sysfs操作GPIO （在linux4.8以后不再支持） /sys/class/gpio目录下的三种文件： export/unexport文件 gpioN指代具体的gpio引脚 gpio_chipN指代gpio控制器 **export/unexport：** /sys/class/gpio/export，只写，写入GPIO编号来向内核申请GPIO控制权（前提是没有内核代码申请这个gpio端口）, 成功后会在目录下生成gpioN目录。 /sys/class/gpio/unexport和导出的效果相反。 **gpioN:** 指代某个具体的gpio端口, 内有以下属性文件： Attribution Read/Write Value Function direction RW in,out;low,high 设置输入输出 value RW 0,非零 读取或者写入IO电平 edge RW none , rising , falling , both 配置中断触发方式 active_low RW 0,非零 设置低电平有效 **gpiochipN** gpiochipN表示的就是一个gpio_chip,用来管理和控制一组gpio端口的控制器，该目录下存在以下属性文件： Attribution Function base 和N相同，表示控制器管理的最小的端口编号。 lable 诊断使用的标志，寄存器地址，1c20800.pinctrl ngpio 表示控制器管理的gpio端口数量，A~G，224 使用sysfs操作GPIO的例子： #echo 192 > /sys/class/gpio/export #导出 PG0, GREEN #ls /sys/class/gpio/ export gpio192 gpiochip0 unexport #ls /sys/class/gpio/gpio192/ active_low direction subsystem/ value device/ power/ uevent #echo \"out\" > /sys/class/gpio/gpio192/direction #设置为输出 #echo 0 > /sys/class/gpio/gpio192/value #亮灯 #echo 1 > /sys/class/gpio/gpio192/value #灭灯 #echo \"in\" > /sys/class/gpio/gpio192/direction #设置为输入 #cat /sys/class/gpio/gpio192/value #读取电平 0 用户可以参考以上操作进行GPIO控制。 注意对重要引脚的导出操作可能会使系统崩溃。 ## chardev操作gpio （linux4.8版本以上支持，参考文章:[在Linux中控制GPIO St.Lee的个人站 (stlee.tech)](https://www.stlee.tech/2021/01/25/在Linux中控制GPIO/)） 每个 **GPIO 控制器（gpiochip）**会在 `/dev` 中有一个字符设备，并且我们可以使用文件操作（open(), read(), write(), ioctl(), poll(), close()）去访问 GPIO 引脚。 ``` # ls /dev/gpiochip* /dev/gpiochip0 ``` 新的字符设备接口不再使用`cat`，`echo`等方法操作gpio，但是可以使用`libgpiod`提供的 libgpiod tools操作： ``` licheepi# gpioset gpiochip0 192 0 #设置PG0为输出模式，电平为low licheepi# gpioget gpiochip0 192 #设置电平为输入模式，读取电平 0 licheepi# gpioset gpiochip0 192 1 licheepi# gpioget gpiochip0 192 1 licheepi# gpioset gpiochip0 192 0 licheepi# gpioget gpiochip0 192 0 licheepi# gpio\t#查看libgpiod工具 gpiodetect gpiofind gpioget gpioinfo gpiomon gpioset ``` ## 相关库 在使用 `Buildroot` 构建根文件系统时，执行 `make menuconfig`，可以在如下位置找到 `libgpiod` 这个库： ``` Target packages > Libraries > Hardware handling [*] libgpiod [*] install tools ```"},"/soft/Lichee/zh/Zero-Doc/Drive/atmel_inter.html":{"title":"atmel触摸屏中断改轮询","content":" title: atmel触摸屏中断改轮询 普通电容式触摸屏是中断方式的，由于v3s引脚较少，所以尝试改为轮询方式驱动，节省一个IO。 ``` static int __devexit mxt_remove(struct i2c_client *client) #ifndef _TS_POLL free_irq(data >irq, data); #endif ``` ``` static int __devinit mxt_probe(struct i2c_client *client, const struct i2c_device_id *id) err_free_irq: #ifndef _TS_POLL free_irq(client >irq, data); #endif #ifndef _TS_POLL error request_threaded_irq(client >irq, NULL, mxt_interrupt, pdata >irqflags, client >dev.driver >name, data); if (error) { dev_err(&client >dev, \"Failed to register interrupt\\n\"); goto err_free_object; } error input_register_device(input_dev); if (error) goto err_free_irq; #else { struct input_polled_dev *polled_dev; polled_dev devm_input_allocate_polled_device(dev); if (!polled_dev) { dev_err(dev, \"Failed to allocate polled input device\\n\"); return ENOMEM; } polled_dev >private data; polled_dev >poll mxt_poll; polled_dev >poll_interval POLL_INTERVAL; polled_dev >input input_dev; error input_register_polled_device(polled_dev); } #endif #ifdef _TS_POLL #define POLL_INTERVAL 5 static void mxt_poll(struct input_polled_dev *dev) { struct mxt_data *data dev >private; struct mxt_message message; struct mxt_object *object; struct device *dev &data >client >dev; int id; u8 reportid; u8 max_reportid; u8 min_reportid; do { if (mxt_read_message(data, &message)) { dev_err(dev, \"Failed to read message\\n\"); goto end; } reportid message.reportid; /* whether reportid is thing of MXT_TOUCH_MULTI_T9 */ object mxt_get_object(data, MXT_TOUCH_MULTI_T9); if (!object) goto end; max_reportid object >max_reportid; min_reportid max_reportid object >num_report_ids + 1; id reportid min_reportid; if (reportid > min_reportid && reportid < max_reportid) mxt_input_touchevent(data, &message, id); else mxt_dump_message(dev, &message); } while (reportid ! 0xff); end: return; } #endif ``` ``` #ifndef _FLIP_X input_report_abs(input_dev, ABS_MT_POSITION_X, finger[id].x); #else input_report_abs(input_dev, ABS_MT_POSITION_X, 800 finger[id].x); #end #ifndef _FLIP_Y input_report_abs(input_dev, ABS_MT_POSITION_Y, finger[id].y); #else input_report_abs(input_dev, ABS_MT_POSITION_Y, 480 finger[id].y); #endif ```"},"/soft/Lichee/zh/Zero-Doc/Drive/device_index.html":{"title":"设备驱动","content":" title: 设备驱动 本节介绍zero与各种模块的适配。"},"/soft/Lichee/zh/Zero-Doc/index.html":{"title":"荔枝派Zero 用户指南","content":" title: 荔枝派Zero 用户指南 荔枝派Zero是一款精致迷你的Cortex A7核心板/开发板，适用于初学者学习linux或商用产品开发。 **联系我们：** [Q群](https://jq.qq.com/?_wv 1027&k 52cCEVU) [github](https://github.com/Lichee Pi) [论坛](http://bbs.lichee.pro) [淘宝](https://shop152705481.taobao.com/category 1266972912.htm) [邮箱](mailto:zepanwucai@gmail.com) \\_\\_\\_\\_\\_ **文档来源：** [看云](https://www.kancloud.cn/lichee/lpi0) ![设计框图](https://box.kancloud.cn/fb63cd12ae1def9dd50710d2a32dc5c1_1095x740.png)"},"/soft/Lichee/zh/MaixSense/contribution/sdk_struct.html":{"title":"Tina sdk 目录结构","content":" title: Tina sdk 目录结构 Tina Linux SDK 主要由构建系统、配置工具、工具链、host 工具包、目标设备应用程序、文档、脚本、linux 内核、bootloader 部分组成，下面是Tina主目录包含的文件和目录。 ``` Tina SDK/ ├── build ├── config ├── Config.in ├── device ├── dl ├── lichee ├── Makefile ├── out ├── package ├── prebuilt ├── rules.mk ├── scripts ├── target ├── tmp ├── toolchain └── tools ``` 以下将对主要目录中包含的内容进行简单介绍。 ## build build 目录存放 Tina Linux 的构建系统文件，此目录结构下主要是一系列基于 Makefile 规格编写的 .mk 文件，主要的功能有： 1. 检测当前的编译环境是否满足 Tina Linux 的构建需求； 2. 生成 host 包编译规则； 3. 生成工具链的编译规则； 4. 生成 target 包的编译规则； 5. 生成 linux kernel 的编译规则； 6. 生成系统固件的生成规则。 ## config config 目录主要存放 Tina Linux 中配置菜单的界面以及一些固定的配置项，该配置菜单基于内核的 mconf 规格编写。 ## device devices 目录用于存放方案的配置文件，包括内核配置、env 配置、分区表配置、sys_config.fex（全志定制板级配置文件）、board.dts（linux标准设备树文件） 等。 > 这些配置在旧版本Tina（Tina3.0以前）上是保存于 target 目录下，现新版本均移到了 device 目录下，但 defconfig 仍保存在 target 目录下 ## lichee lichee 目录主要存放 bootloader、linux内核、DSP等代码，其中DSP代码及编译环境因涉及DSP供应商科声讯版权，需单独申请。lichee目录下结构如下： ``` Tina SDK ├── brandy 2.0 │ ├── build.sh │ ├── tools │ └── u boot 2018 └── linux 4.9 ``` ## package package 目录存放Tina系统支持的软件包源码和编译规则，目录按照目标软件包的功能进行分类，该目录包含了Tina系统全平台（包括全志R/H/F/V/T系列）的软件包，但是并不是所有软件包都适配了R329方案，部分软件包需要开发者自行适配。 ## prebuild prebuild 目录存放预编译用的交叉编译器，主要包括aarch64的glibc和musl以及arm的glibc和musl。prebuild目录下结构如下： ``` Tina SDK └── linux x86 ├── aarch64 │ ├── aarch64 toolchain.txt │ ├── toolchain sunxi glibc │ └── toolchain sunxi musl ├── arm │ ├── arm toolchain.txt │ ├── toolchain sunxi glibc │ └── toolchain sunxi musl └── host └── host toolchain.txt ``` ## scripts scripts 目录用于存放设备开发中用到的一些脚本。 ## target target目录用于存放开发板相关的配置以及 sdk 和 toolchain 生产的规格。 ## toolchain toolchain 目录用于存放交叉工具链构建配置、规则。 ## tools tools 目录用于存放 host 端工具的编译规则。 ## out out 目录用于保存编译相关的临时文件和最终镜像文件，编译后自动生成此目录，并生成对应的方案out目录，如开发板对应的R329 evb5方案目录结构如下： ``` Tina SDK/out ├── host └── r329 evb5 ├── boot.img ├── compile_dir ├── image ├── md5sums ├── packages ├── r329 evb5 boot.img ├── r329 evb5 Image.gz ├── r329 evb5 uImage ├── rootfs.img ├── sha256sums ├── staging_dir └── tina_r329 evb5_uart0.img ``` 其中 ： tina_r329 evb5_uart0.img 就是编译打包后生成的最终烧写到开发板上的固件； boot.img 为最终烧写到系统 boot 分区的数据； rootfs.img 为最终烧写到系统 rootfs 分区的数据； r329 evb5 uImage为内核的 uImage 格式镜像，若配置为 uImage 格式，则会拷贝成 boot.img； r329 evb5 boot.img为内核的 boot.img 格式镜像，若配置为 boot.img 格式，则会拷贝成 boot.img compile_dir 为 sdk 编译 host、target 和 toolchain 的临时文件目录，存有各个软件包的源码； packages 目录保存的是最终生成的 ipk 软件包。 另外 out 下的 host 目录用于存放 host 端的工具以及一些开发相关的文件。"},"/soft/Lichee/zh/MaixSense/contribution/Build_R329.html":{"title":"R329主线armbian内核，系统，驱动开发方法","content":" title: R329主线armbian内核，系统，驱动开发方法 keywords: R329, maixsnse, MaixSense, Maixsense, armbian, build, kernel 本文需要一些[前置基础](./R329_SDK_编译与烧录.html) 准备环境: * Ubuntu20.04 * [MaixSense](https://wiki.sipeed.com/hardware/zh/maixII/M2A/maixsense.html) * 一张已经烧录`r329 armbian maixpy3 0.4.0.img`的TF卡 * [Armbian_21.08.0 trunk_Maixsense_bullseye_edge_5.14.1.img.xz](https://pan.baidu.com/s/1D8pr2y0 3jNwI5wzdgqb9Q)镜像 ##修改 boot.cmd 的方法 想要改变 uboot 的一些启动配置，就可以通过这个方式进行修改，修改 boot.cmd 后直接在系统里运行完成更新。 > mkimage C none A arm T script d /boot/boot.cmd /boot/boot.scr 主线 linux 都会有类似的配置供你使用，可能是文件可能是分区。 ##Linux 内核、驱动、设备树的相关用法方法 可以参考[Lichee Pi](https://wiki.sipeed.com/soft/Lichee/zh/index.html)(特别详细)，armbian编译没有那么繁琐因此不再赘述。 准备环境`sudo apt install y git wget make gcc flex bison libssl dev bc kmod` 其他相关教程 * [licheepi zero主线Kernel基础编译](https://wiki.sipeed.com/soft/Lichee/zh/Zero Doc/System_Development/kernel_build.html) * [licheepi nano主线Linux编译](https://wiki.sipeed.com/soft/Lichee/zh/Nano Doc Backup/build_sys/kernel.html) ##修改设备树配置的方法 使用`git clone b r329 wip https://github.com/sipeed/linux.git` #完成后切到 `r329 wip` 分支 编译链工具可以用系统自带的`通用编译链`或`gcc linaro`，本文使用的是`gcc arm 8.3 2019.03 x86_64 aarch64 linux gnu.tar.xz` [点我下载](https://armkeil.blob.core.windows.net/developer/Files/downloads/gnu a/8.3 2019.03/binrel/gcc arm 8.3 2019.03 x86_64 aarch64 linux gnu.tar.xz)。 [设备树简介：](https://wiki.sipeed.com/soft/Lichee/zh/Zero Doc/Drive/Device_Tree_Intro.html)用户在设备树里定义并启用的树结点，就可以使用相应驱动。 MaixSense的设备树在`linux/arch/arm64/boot/dts/allwinner/`路径下，和r329相关的设备树有 * sun50i r329 maix iia.dtsi * sun50i r329 maixsense.dts * sun50i r329.dtsi 目前的主线配置`linux/arch/arm64/configs/defconfig`导入它。 输入`make ARCH arm64 defconfig`开始完整编译 ``` make ARCH arm64 CROSS_COMPILE aarch64 linux gnu j4 make ARCH arm64 CROSS_COMPILE aarch64 linux gnu j4 INSTALL_MOD_PATH out modules make ARCH arm64 CROSS_COMPILE aarch64 linux gnu j4 INSTALL_MOD_PATH out modules_install ``` 啥都不清楚的情况下，一路确认键按下去，直到开始编译，导出 modules 是非必要操作，但对应一些外置 ko 模块需要导出拷到 /lib/modules/ 目录中，在 menuconfig 中设置为 M 就可以编译出 ko 模块从外部插入系统。 编译成功后，生成文件所在位置： 内核`Image`文件: ./arch/arm64/boot/Image 对应 armbian 目录下的 boot/Image 设备树`dtb`文件: ./arch/arm64/boot/dts/allwinner/sun50i r329 maixsense.dtb 到 boot/dtb/allwinner/ `modules`文件夹: ./out/lib/modules 将`Image`与`dtb`文件放入`boot`目录下重启后即可自动完成内核的更新（armbian 特有）。 上述内容测试过后，你就可以开始自定义自己的主线内核了，但这个并不是主要目的，只是说一些基础用法。 单独编译`dtb`文件加入设备。 通常来说，在不了解如何编译整体的情况下，只需要通过简单的设备树替换就可以完成驱动适配。 `make ARCH arm64 CROSS_COMPILE aarch64 linux gnu dtbs j4` 参考文章：[为R329添加i2c设备](https://www.cnblogs.com/USTHzhanglu/p/15500269.html) 参考文章：[总结一次为R329开启uart的经历](https://www.cnblogs.com/USTHzhanglu/p/15191052.html) 将编译得到的`dtb`文件复制到`/boot/dtb/`。 这里仅供学习参考，Sipeed 内部已经包含了`/usr/lib/modules/5.14.0 rc4 sun50iw11/kernel/drivers/net/wireless/rtl8723ds/8723ds.ko`模块。 上述方法出来的内核不是我们提供的，因为配置项的不同所以会缺少一些驱动，需要你自行加入；如`8723ds`非主线所使用的 wifi 模块。 `git clone https://github.com/Icenowy/rtl8723ds` #切换到newest kernel 移动到`linux/drivers/net/wireless/realtek/`下 编辑`drivers/net/wireless/Kconfig`添加 `source \"drivers/net/wireless/realtek/rtl8723ds/Kconfig\"`，清除错误的语法，只留最简单的部分即可。 ``` config RTL8723DS \ttristate \"Realtek 8723D SDIO or SPI WiFi\" ``` 编辑`linux/drivers/net/wireless/realtek/Makefile`添加`obj $(CONFIG_RTL8723DS) + rtl8723ds/`使得模块参与编译。 通过`make ARCH arm64 CROSS_COMPILE aarch64 linux gnu j8 menuconfig` 按 `/` 搜索 `8723ds` 把它配上编译即可。 配好直接 `make` 编译就行，在 `sipeed` 的 `armbian` 这里不需要，仅告知如何加入非主线模块，如特殊的 `TP` 触摸屏、`ADC` 按键驱动、`I2C` 传感器驱动等。 ##编译 `armbian` 系统 * 自行准备良好的网络环境，相关问题不做解答，默认懂得都懂，编不出来也很正常，不用太在意。 上述开发的内核模块在 `sipeed` 提供的 `armbian` 镜像中都是无用的，仅用于测试和确认开发环境，所以要进一步把 `armbian` 编译出来才是最终用户所用的环境。 有需要的可以看文档 https://docs.armbian.com/Developer Guide_Build Preparation 说明。 安装 `apt install y dialog psmisc acl uuid runtime curl gnupg gawk` 准备环境 获取 `https://github.com/sipeed/armbian build.git` 切到 r329 wip 分支，然后通过 `compile.sh` 完成编译。 将根据以下配置在 armbian build 中进行编译。 config/boards/maixsense.wip config/bootscripts/boot sun50iw11.cmd config/kernel/linux sun50iw11 edge.config config/sources/families/sun50iw11.conf 运行 `./compile.sh` 选择会自动拉取所有相关的东西，即可编译出来，接下来就是漫长的等待。 注意 `maixsense` 并非为最终 `conf` 版本，你需要在 底下的 `show WIP` 中选择 `agree` 后就可以看到 `maixsense` 了,配置可以是 `bullseye` 和 `minimal` 就好。 编译期间会在 `armbian build/cache/sources` 下 `git clone` 在 `config/sources/families/sun50iw11.conf` 指定的仓库和分支。 把 `https://github.com/Icenowy/rtl8723ds` 改为 `https://github.com/lwfinger/rtl8723ds` 。 把 `armbian build/config/sources/families/sun50iw11.conf` 文件中 `KERNELBRANCH` （linux）的 `r329 wip integrated` 改到 `r329 wip` 分支。 完成后输出如下： ```bash [ o.k. ] Building kernel splash logo [ bullseye ] [ .... ] Installing extras buildpkgs [ hostapd htop mmc utils sunxi tools ] [ o.k. ] Calling image customization script [ customize image.sh ] [ o.k. ] No longer needed packages [ purge ] [ o.k. ] Unmounting [ /home/juwan/R329/armbian build/.tmp/rootfs c735dfca 9977 402a a68b b4529b5aac8f ] [ o.k. ] Preparing image file for rootfs [ maixsense bullseye ] [ o.k. ] Current rootfs size [ 780 MiB ] [ o.k. ] Creating blank image for rootfs [ 984 MiB ] [ .... ] dd: 984MiB [ 136MiB/s] [ >] 100% [ o.k. ] Creating partitions [ root: ext4 ] [ .... ] Creating rootfs [ ext4 on /dev/loop40p1 ] [ .... ] Copying files to [ / ] [ .... ] Copying files to [ /boot ] [ .... ] Updating initramfs... [ update initramfs uv k 5.14.0 rc7 sun50iw11 ] [ o.k. ] Updated initramfs. [ for details see: /home/juwan/R329/armbian build/output/debug/install.log ] [ .... ] Re enabling [ initramfs tools hook for kernel ] [ o.k. ] Unmounting [ /home/juwan/R329/armbian build/.tmp/mount c735dfca 9977 402a a68b b4529b5aac8f/ ] [ o.k. ] Free SD cache [ 8% ] [ o.k. ] Mount point [ 91% ] [ o.k. ] Writing U boot bootloader [ /dev/loop40 ] [ o.k. ] SHA256 calculating [ Armbian_21.08.0 trunk_Maixsense_bullseye_edge_5.14.0_minimal.img ] [ warn ] GPG signing skipped no GPG_PASS [ Armbian_21.08.0 trunk_Maixsense_bullseye_edge_5.14.0_minimal.img ] [ o.k. ] Done building [ /home/juwan/R329/armbian build/output/images/Armbian_21.08.0 trunk_Maixsense_bullseye_edge_5.14.0_minimal.img ] [ o.k. ] Runtime [ 350 min ] [ o.k. ] Repeat Build Options [ ./compile.sh BOARD maixsense BRANCH edge RELEASE bullseye BUILD_MINIMAL yes BUILD_DESKTOP no KERNEL_ONLY no KERNEL_CONFIGURE no COMPRESS_OUTPUTIMAGE sha,gpg,img ] ``` 把 Armbian_21.08.0 trunk_Maixsense_bullseye_edge_5.14.0_minimal.img 拿来烧录就行。 以下是本次的配置：（如果你连这个都没编译出来就不要操作了） ```bash # Allwinner R329 dual core 256M RAM WiFi USB C BOARD_NAME \"MaixSense\" BOARDFAMILY \"sun50iw11\" BOOTCONFIG \"sipeed_maixsense_defconfig\" MODULES_BLACKLIST \"lima\" DEFAULT_CONSOLE \"serial\" BUILD_DESKTOP \"no\" BOOT_LOGO \"yes\" SERIALCON \"ttyS0\" KERNEL_TARGET \"edge\" OFFLINE_WORK \"yes\" CLEAN_LEVEL \"\" # ./compile.sh EXPERT yes BUILD_STABILITY stable BOARD maixsense BRANCH edge RELEASE bullseye BUILD_MINIMAL yes BUILD_IMAGE yes BUILD_DESKTOP no KERNEL_ONLY no KERNEL_CONFIGURE yes COMPRESS_OUTPUTIMAGE sha,gpg,img CLEAN_LEVEL \"\" # ./compile.sh OFFLINE_WORK \"no\" EXPERT yes BUILD_STABILITY stable BOARD maixsense BRANCH edge RELEASE bullseye BUILD_MINIMAL yes BUILD_IMAGE no BUILD_DESKTOP no KERNEL_ONLY yes KERNEL_CONFIGURE yes COMPRESS_OUTPUTIMAGE sha,gpg,img CLEAN_LEVEL \"\" ``` >必须经过第一次完整编译才能用 OFFLINE_WORK 加快仓库的拉取检查。 ###如何修改开机logo > 看 BOOT_LOGO \"yes\" 和替换图片文件自动打包编译到二进制文件。 ###配置开机启动服务脚本 因为系统默认不启动`/etc/rc.local`了，所以需要启动一下再往里面编辑脚本，一定要 & 挂在后台，不然就看不到交互终端了。 执行 `sudo nano /etc/systemd/system/rc local.service` 后输入如下内容： ``` [Unit] Description /etc/rc.local Compatibility ConditionPathExists /etc/rc.local [Service] Type forking ExecStart /etc/rc.local start TimeoutSec 0 StandardOutput tty RemainAfterExit yes SysVStartPriority 99 [Install] WantedBy multi user.target ``` 上述内容保存后执行以下命令 ``` sudo systemctl enable rc local #使能服务 chmod x /etc/rc.local #更改文件权限 sudo systemctl start rc local.service #启动服务 sudo systemctl status rc local.service #查看服务运行状态 ``` 删除用户密码并关闭控制台输出到屏幕上和闪烁光标 查询服务 `systemctl status` 禁用服务 `systemctl disable getty@tty1.service` 即可关闭开机终端。 删除密码 `sudo passwd d root` 之后输入 root 自动进入系统。 使用 `echo 0 > /sys/class/graphics/fbcon/cursor_blink` 关闭终端的光标闪烁`cursor_blink`，对应实现 `drivers/video/console/fbcon.c` 。 ### 编译 aipu.ko 主线模块并加入 armbian 系统 需要结合上下两节食用。没有 linux 外部编译模块基础的，要先简单看过这篇 https://www.kernel.org/doc/Documentation/kbuild/modules.txt 来知道怎么添加外部模块参与编译（*.ko）。 这里提供了一份包含编译 aipu 的分支，你也可以在 linux 目录下外部编译 aipu.ko 模块出来。 将 `armbian build/config/sources/families/sun50iw11.conf` 里的 KERNELSOURCE \"`https://github.com/sipeed/linux`\" 链接替换为`https://github.com/junhuanchen/linux/commits/r329 wip` 。即可采用新源进行 armbian 的编译。 偷懒就用临时配置好的 https://github.com/junhuanchen/armbian build 仓库。 ### 给镜像中添加自定义模块（deb） kernel 的模块（.ko）由 kernel 添加，如果没有改变则删除 `armbian build/output/debs/linux image edge sun50iw11_21.08.0 trunk_arm64.deb` ，可手工可命令。 这里说一下 armbian 的 deb 手工打进去，因为有时候可能不是所有东西都需要，而云端下载太久，就需要提前下好包进去。 在 `armbian build/config/cli/bullseye/main/config_cli_standard/packages.additional` 的末尾添加一下包就可以编译进去，其他的类似有 desktop 目录之类的。 打包某些 deb 包的时候经常会出现 `apt Hash Sum mismatch` 问题，设置成 `apt get o Acquire by hash yes fix missing` 可以解决大部分问题。 ### 常见问题后记 boot 就不提了，看 https://github.com/sipeed/u boot 就行，实际上全部交给 armbian build 仓库就行，这样就具备了基础环境，要编辑的部分自然就很少了。 如果你发现模块加载不成功，可能是 `version magic '5.14.0 rc4 sun50iw11 SMP mod_unload aarch64' should be '5.14.0 rc7 01557 gd78f1b75fd69 dirty SMP preempt mod_unload aarch64'` 错误。这是模块加载不成功的常见 version magic 错误，简单的处理方法是修改 linux/include/linux/vermagic.h 直接怼到 `#define VERMAGIC_STRING \"5.14.0 rc7 01557 gd78f1b75fd69 dirty\"` 。 想要彻底解决上述这个问题，只能重新编译 armbian build 导出镜像改变 kernel version 。"},"/soft/Lichee/zh/MaixSense/contribution/R329_SDK_编译与烧录.html":{"title":"R329 Tina SDK 编译与烧录","content":" title: R329 Tina SDK 编译与烧录 keywords: R329, maixsnse, MaixSense, Maixsense, armbian, build, kernel 原参考文章写于2021年4月 ## 获取仓库 ``` https://github.com/sipeed/R329 Tina jishu git clone https://github.com/sipeed/R329 Tina jishu cd R329 Tina jishu git submodule update init recursive ``` 整个仓库不重要的部分经过 coding 仓库加速，所以只需要关注以下这几个仓库即可。（该版本为开源 SDK 版本，加上了一些驱动配置以支持 Sipeed 的 R329 板） https://github.com/sipeed/r329 package https://github.com/sipeed/r329 linux 4.9 https://github.com/sipeed/r329 target 开源的只是裁剪了一些不必要的版型和暂不公开 DSP 和 NPU 的代码，其他的没有区别，正常使用就好。 package 实际上就对应系统里的软件功能包，如一些 shell 命令或程序。 linux 4.9 对应的 linux 内核，主要影响底层的驱动，需要移植到其他硬件时会来这里更改设备树和相关的裸机驱动即可。 target 对应的是版型的一些配置文件和预置脚本等。 其他的很少改动，可以不用太关心，如 `boot` `、prebuild` 等，在等项目的主仓库拉取的过程中，来认识一下 SDK 的构成吧，等看完了就差不多可以开始进行编译了。 ### SDK 结构 由于SDK目录结构有点长所以仅给传送门 [点我](./sdk_struct.html) 看完后你已经有一些sdk相关概念了，那就开始编译吧。 可以先看这两篇完成基本的安装，我直接列一下必要的库，编译与测试环境在 ubuntu20 （wsl2）建议大于 8G 内存。 连接开发板 https://r329.docs.allwinnertech.com/devboardstudy/r329evb5studyadbuart/ 编译环境配置 https://r329.docs.allwinnertech.com/devboardstudy/r329evb5ubuntu/ 上面两篇参考资料废话很多，如果你已经有经验了，就直接看脚本开始吧。 基础环境的安装： > sudo apt get y install build essential asciidoc binutils bzip2 gawk gettext git libncurses5 dev libz dev patch python3 python2.7 unzip zlib1g dev lib32gcc1 libc6 dev i386 subversion flex uglifyjs git core gcc multilib p7zip p7zip full msmtp libssl dev texinfo libglib2.0 dev xmlto qemu utils upx libelf dev autoconf automake libtool autopoint device tree compiler g++ multilib antlr3 gperf wget curl swig rsync intltool busybox cmake Ubuntu20 要增强一下，补一下下面两个包 libffi6 （python3 需要）。 ``` wget http://mirrors.kernel.org/ubuntu/pool/main/libf/libffi/libffi6_3.2.1 8_amd64.deb sudo apt install ./libffi6_3.2.1 8_amd64.deb sudo apt get install uuid dev ``` 其他的，自己丟了就找一下。 ## 在 R329 Tina jishu 下执行编译命令 编译前建议设置一下 `export FORCE_UNSAFE_CONFIGURE 1` ，第一次编译 host 的软件，会出现 set FORCE_UNSAFE_CONFIGURE 1 这个变量的提示。 ``` cd R329 Tina jishu source build/envsetup.sh lunch r329_evb5 tina make j32 pack ``` 对应的意思是：source 加载编译环境，你可以得到 croot / cout 等跳转目录的功能，lunch 选择版型，确定要编译的版型。 ```bash dls@DESKTOP XPS13:~/R329 Tina jishu$ source build/envsetup.sh Setup env done! Please run lunch next. dls@DESKTOP XPS13:~/R329 Tina jishu$ lunch You're building on Linux Lunch menu... pick a combo: 1. r329_evb5 tina 2. r329_evb5_min tina Which would you like? [Default r329_evb5]: 1 TINA_BUILD_TOP /home/dls/R329 Tina jishu TINA_TARGET_ARCH aarch64 TARGET_PRODUCT r329_evb5 TARGET_PLATFORM r329 TARGET_BOARD r329 evb5 TARGET_PLAN evb5 TARGET_BUILD_VARIANT tina TARGET_BUILD_TYPE release TARGET_KERNEL_VERSION 4.9 TARGET_UBOOT u boot 2018 TARGET_CHIP sun50iw11p1 dls@DESKTOP XPS13:~/R329 Tina jishu$ ``` make 有以下常用命令: make menuconfig 配置软件包 make kernel_menuconfig 配置内核包 make clean 清理项目 make defconfig 保存当前软件配置，主要影响 defconfig。 mkernel 是编译内核的简写命令。 boot 要到目录下进行配置，具体怎么使用，就自己参考荔枝派 linux 的配置加入 arch 即可。 make 单独编译模块的时候 make package/xxx/xxxx/compile 或 clean 即可。 make j32 的意思是 使用 32 核并行编译，建议第一次用 j1， V s 意思是单核并开启日志输出。 如果想要有颜色的输出可以按照 colormake 方便看异常和过滤输出。 pack 会进行打包变成 img ，供 PhoenixSuit 等全志提供的软件进行烧录，可能需要注意的是分区大小之类的调整，当然你可以烧录一次后通过 dd 命令导出镜像，方便其他人烧写。 ## 如何烧写？ 可以参考 [V831 Sipeed](https://wiki.sipeed.com/hardware/zh/maixII/M2/flash.html) 的烧录。 ![板子图片](./../assets/R329_outlook.png \"Board Photo\") 按上图的核心板上的小按钮后通电，就会进入 fel 模式，或不插 SD 卡上电就会自动进入烧写模式（这要基于硬件设计），软件就会检测到了。 这种官方的烧录方法，在开发系统结束后就不会需要了，所以看过一次官方教程就行了 https://r329.docs.allwinnertech.com/devboardstudy/r329evb5compile 。"},"/soft/Lichee/zh/MaixSense/contribution/Tina_R329_swupdate_OTA.html":{"title":"Tina R329 swupdate OTA 步骤","content":" title: Tina R329 swupdate OTA 步骤 keyword: R329, Lichee, Lichee RV, RiscV, linux 本文需要有一定的基础，关于镜像源码和镜像烧录方法可以参考以下链接： > [镜像源码地址](https://github.com/sipeed/R329 Tina jishu) > [R329镜像烧录方法](https://wiki.sipeed.com/hardware/zh/maixII/M2A/flash_system.html) ## 进行相关设置 编译路径执行make menuconfig和make ota_menuconfig中分别选中： Allwinner > swupdate Allwinner > swupdate > Swupdate Settings > General Configuration > MTD support Allwinner > swupdate > Image Handlers > ubivol ## 更改相关参数 sys_config.fex中的storage_type 参数改成5（spi nand） diff git a/configs/evb5/sys_config.fex b/configs/evb5/sys_config.fex index e168eb2..076e56d 100755 a/configs/evb5/sys_config.fex +++ b/configs/evb5/sys_config.fex 23,7 +23,7 eraseflag 0 ; \\[target] boot_clock 1008 storage_type 1 +storage_type 5 ## 编译镜像 编译路径执行 `make j & pack` 编译主系统并打包，此时会生成文件out/r329 evb5/tina_r329 evb5_uart0.img ## 编译OTA系统 编译路径执行`swupdate_make_recovery_img` 编译OTA系统 此时会生成文件out/r329 evb5/boot_initramfs_recovery.img ## 生成OTA文件 编译路径执行 `swupdate_pack_swu` ，此时会生成文件out/r329 evb5/swupdate/tina r329 evb5.swu ## 将OTA文件传送至设备 烧写主系统img，再用adb把OTA文件推到设备下：`adb push tina r329 evb5.swu /mnt/UDISK/` 实际使用的时候就从网络拿到OTA文件即可 ## 执行OTA升级 OTA升级，设备端执行： `swupdate_cmd.sh i /mnt/UDISK/tina r329 evb5.swu e stable,upgrade_recovery` 执行后设备会重启并在重启过程中OTA，因为原log太长，因此仅附部分log: ```shell{.line numbers} root@TinaLinux:/rom/sbin# swupdate_cmd.sh i /mnt/UDISK/tina r329 evb5.swu e st able,upgrade_recovery config new swupdate swu_input: ## i /mnt/UDISK/tina r329 evb5.swu e stable,upgrade_recovery## ## set swupdate_param done ## swu_param: ## i /mnt/UDISK/tina r329 evb5.swu## swu_software: ##stable## swu_mode: ##upgrade_recovery## ###now do swupdate### ###log in /mnt/UDISK/swupdate.log### ## swupdate v i /mnt/UDISK/tina r329 evb5.swu e stable,upgrade_recovery ## Connected to SWUpdate via /tmp/swupdateprog Update started ! ### 此处省略大约一千三百行log BusyBox v1.27.2 () built in shell (ash) _____ _ __ _ _ __ ___ _ _ _ ___ _ _ _ _ _ __ _'_ _ ____________,_ _ _____ Tina is Based on OpenWrt! Tina Linux (Neptune, 5C1C9C53) root@TinaLinux:/# ```"},"/soft/Lichee/zh/MaixSense/get_started/flash_system.html":{"title":"系统烧录","content":"# 系统烧录 ## 系统简介 Lichee MaixSense（以下简称R329）提供了以下两种系统镜像 名称 armbian Tina : : : : : : 简介 专门用于`ARM`开发板的轻量级`Debian` 全志魔改OpenWRT1404的系统 特点 主线化Linux，功能丰富 厂商魔改，比较精简 适用人群 极客，嵌入式入门玩家等 深度开发，需要自行定制等开发人员 > ！！！一定要严格按照步骤操作！！！armbian系统请使用大于 4G 的 TF/SD 卡进行烧录，Tina系统请使用大于 1G 的 TF/SD 卡进行烧录, 质量较差的启动卡会有糟糕的实际使用体验 对于 R329 芯片， 在 Windows 使用 Etcher ，Linux 上使用 Livesuit 烧录镜像文件。 ### armbian 系统镜像 armbian 镜像获取： > 链接：[https://pan.baidu.com/s/12YTwDm4PEhYKYZuH lrBYA](https://pan.baidu.com/s/12YTwDm4PEhYKYZuH lrBYA) 提取码：2333 armbian 使用的烧录方式为 dd，windows下推荐使用 Etcher，linux 下推荐使用 Terminal。 ### Tina 系统镜像 Tina 系统需要自己进行编译，具体编译方式参考<https://github.com/sipeed/R329 Tina jishu> Tina 系统的烧录方式和 MaixII dock通用，可参考[MaixII M2dock 烧录系统 Sipeed Wiki](./../../../../../hardware/zh/maixII/M2/flash.html)，这里不多做介绍 ## 烧录镜像 ### windows 下系统烧录 资源获取： 下载[Etcher](https://www.balena.io/etcher/ \"Etcher\") 下载[SD Card Formatter](https://www.sdcard.org/downloads/formatter/eula_windows/SDCardFormatterv5_WinEN.zip \"SDCardFormatter\") 首先解压镜像，得到 .img 镜像文件，然后使用 SD Card Formatter 格式化sd卡后，打开Etcher，点击 `Flash from file` ,选中解压出来的 .img 文件镜像包，然后点击 `Select target` 选中sd卡，最后点击 `Flash` 进行烧录，等待完成即可。 ![95133](./../assets/95133.gif) ### linux下系统烧录 首先解压镜像，得到 .img 镜像文件，然后格式化 sd 卡，打开 Terminal ，输入 `sudo dd if xxx.img of /dev/sdx bs 1M status progress oflag direct`烧录。注意xxx.img为文件名， `/dev/sdx`为sd卡实挂载位置。 ![2021 08 05 11 44 49](./../assets/2021 08 05 11 44 49.gif) 同时也可以直接使用 Disks 进行更便捷的烧录（需要Ubuntu桌面版)： ![2021080511 46 53](./../assets/2021080511 46 53.gif) 烧录完毕后，即可放入Lichee MaixSense中运行。 ## 访问串口 > 请将 USB口插入到 USB UART 口(下面的口）从而获得串口。 ### Linux & macOS Linux 不需要装驱动，系统自带了，使用 `ls /dev/ttyUSB*` 即可看到设备号 ### Windows `Lichee MaixSense` 使用了 `CH340` 作为驱动芯片。`Windows` 用户需要安装 `CH340` 的驱动。 Windows 下载 [ch340 ch341 driver](https://api.dl.sipeed.com/shareURL/MAIX/tools/ch340_ch341_driver) 安装即可，然后可以在 `设备管理器` 中看到串口设备和端口号"},"/soft/Lichee/zh/MaixSense/application/Hardware_test.html":{"title":"硬件测试","content":"# 硬件测试 ## 测试屏幕 硬件正常的话，开机屏幕会自动输出内核信息，也可以使用`echo \"hello sipeed\">/dev/tty0`重定向信息到屏幕上。 <img src \"./../assets/image 20210805150728052.png\" alt \"image 20210805150728052\" style \"zoom:50%;\" /> ## 测试摄像头 armbian 内置了 ffmpeg ，可以快速捕捉 sensor 数据并输出到屏幕上 使用如下命令快速捕捉 sensor 并输出到屏幕上 ffmpeg i /dev/video0 vframes 1 s 240*240 pix_fmt rgb565le vf transpose 2,transpose 2 f fbdev /dev/fb0 ![image 20210805165654537](./../assets/image 20210805165654537.png) ## 测试网络 使用 nmtui 指令可以进入可视化的配网界面， 选择 Activate a connection ， 选择对应的 SSID ，输入连接密码，确认即可。 ![202108051626](./../assets/202108051626.gif) 设置完毕后使用 ifconfig 查看本机操作，然后就可以使用 ssh 等操作了。 ![image 20210805162936212](./../assets/image 20210805162936212.png) 也可以使用apt下载各种应用 ```bash sudo apt install neofetch ``` ![image 20210805165620823](./../assets/image 20210805165620823.png) 如果遇到终端显示错位，还需要`sudo apt get install xterm`安装下xterm，然后`resize`即可。 ![202108061015](./../assets/202108061015.gif) ## 测试AIPU 获取1000类物体分类模型 下载站链接[zhouyi_test.tar.xz](https://dl.sipeed.com/shareURL/MaixII/MaixII A/example),使用任意方式上传到板子中 ```bash ##解压压缩包 tar xvf zhouyi_test.tar.xz ##授予执行权限 cd zhouyi_test chmod 777 run.sh ##执行1000类物体分类 ./run.sh ##后台执行1000类物体分类 ./run.sh < /dev/null > /dev/null 2> 1 ```"},"/soft/Lichee/zh/MaixSense/application/Speech_usage_zh.html":{"title":"Maix-Speech 详细使用文档","content":" title: Maix Speech 详细使用文档 > 使用默认不带 MaixPy3 的镜像可进行下文操作 Maix ASR 目前完成的功能模块包括：连续数字识别(DIG), 关键词识别(KWS), 大词汇量连续语音识别(LVCSR) 该库基于 AM+LM 两段式识别，用户可灵活配置 声学模型和语言模型 来适应不同的嵌入式场景，也可加入热词等。 ## Maix ASR 运行流程简述 1. asr_device 采集指定长度的原始音频，输出到int16_t数组里 2. asr_preprocess 对原始音频进行 agc/anc/aec 等操作，并进行stft计算，生成80维MEL Fbank数据 3. asr_am 对 fbank 进行声学模型计算，输出每个时刻(默认64ms一格)的拼音预测结果（前BEAM_CNT个） 4. asr_decoder 对am的输出结果进行相关解码处理，实现对应功能，如 DIG/KWS/LVCSR 5. decoder 运行用户注册的回调函数，执行用户逻辑代码 ## ms_asr.h中的宏定义和数据类型 ### 发布版本 ``` #define VERSION_RELEASE 0 ``` 默认公开发布的库文件为RELEASE版，失能了DBG相关宏功能 ### 推理类型 ``` #define INFER_ZHOUYI 0 //周易AIPU 推理 #define INFER_V83X 1 //V83X AWNN推理 #define INFER_CPU0 2 //CPU 推理 #define INFER_CPU1 3 //CPU 推理(弃用) ``` ### 调试选项 在release版里失能 ``` #define DBG_MICRAW (1<<0) //运行时dump原始麦克风音频到 micraw.pcm #define DBG_MIC (1<<1) //运行时dump 前端处理后的音频到 mic.pcm #define DBG_STRIP (1<<2) //显示边界信息 #define DBG_LVCSR (1<<3) //显示LVCSR解码详情 #define DBGT_PP (1<<4) //音频前端处理计时 #define DBGT_AM (1<<5) //AM模型运算计时 #define DBGT_KWS (1<<6) //关键词解码计时 #define DBGT_WFST (1<<7) //WFST解码计时 ``` ### 建模单元 声学模型建模单元，目前仅实现汉语识别的 CN_PNYTONE（含声调拼音） 其他宏定义预留 ``` #define CN_PHONE 0 #define CN_PNY 1 #define CN_PNYTONE 2 #define CN_HAN 3 #define EN_PHONE 4 #define EN_SW1K 5 #define EN_SW3K 6 #define EN_SW5K 7 //en subword: https://bpemb.h its.org/en/ ``` ### 量化方式 声学模型输出结果的量化方式 ``` #define QUANT_NONE 0 #define QUANT_INT8 1 #define QUANT_UINT8 2 ``` ### 常量定义 ``` #define BEAM_CNT (10) //每个时刻保留前BEAM_CNT个概率结果 #define ASR_KW_MAX_PNY (6) //每个关键词最多6个字 #define ASR_KW_MAX (100) //最多100个关键词 ``` ### 音频设备类型 目前支持 pcm, mic, wav 或者 用户自定义设备输入 ``` #define DEVICE_PCM 0 #define DEVICE_MIC 1 #define DEVICE_WAV 2 #define DEVICE_MIC2 3 #define DEVICE_MIC4 4 #define DEVICE_CUSTOM 5 ``` ### 音频接口类 当用户有自定义的音频输入设备，或者需要使用自己的声学前端处理程序，可以实现以下音频设备接口 初始化时使用 DEVICE_CUSTOM 来选择自定义设备。 ``` typedef struct{ int (*init)(char* device_name); //初始化音频设备/文件 int (*read)(int16_t* data_buf, int len); //读取指定长度音频到buf，返回读取到的数量 void (*clear)(void); //清缓存 void (*deinit)(void);\t\t\t\t\t\t//释放音频设备 }asr_device_t; ``` ### 解码器类型 解码器以位段形式表示，目前支持以下四种解码器（详细使用方式见下节） ``` #define DECODER_RAW 1 //raw解码器，返回AM输出的原始结果 #define DECODER_DIG 2\t\t //数字解码器，输出中文数字识别结果 #define DECODER_LVCSR 4\t\t //连续语音识别解码器，输出汉字结果 #define DECODER_KWS 8 //关键词识别解码器，输出当前时刻的各个关键词概率 #define DECODER_ALL 0xffff //选中所有解码器 ``` ### AM初始化参数 AM初始化参数，参考例程填写 ``` typedef struct{ char* model_name; int model_in_len; int strip_l; int strip_r; int phone_type; int agc; }am_args_t; ``` ### 拼音概率 AM输出结果为 pnyp_t 数组，每个时刻 BEAM_CNT个。 可使用 am_vocab[idx]获取对应下标的拼音的字符串形式 ``` typedef struct { uint32_t idx; //pny的下标 float p; }pnyp_t; ``` *** ## ms_asr.h中的函数接口 ### 初始化 初始化asr库，用户选择对应的音频设备，AM模型参数，和调试选项 当用户使用自定义音频设备时，device_type填 DEVICE_CUSTOM ，device_name 填对应的 asr_device_t指针 注意解码器设置由另外独立API设置 ``` int ms_asr_init(int device_type, char* device_name, am_args_t* am_args, int dbg_flag); ``` ### 释放 释放asr库相关资源 ``` void ms_asr_deinit(void); ``` ### 解码器设置 用户可以注册若干个解码器（当然也可以不注册），解码器的作用是解码声学模型的结果，并执行对应的用户回调 ``` typedef void (*decoder_cb_t)(void* data, int cnt); int ms_asr_decoder_cfg(int decoder_type, decoder_cb_t decoder_cb, void* decoder_args, int decoder_argc); ``` **DECODER_RAW** function: 输出原始AM的预测结果 decoder_args：None cb_data: pnyp_t 指针，最近一帧的拼音概率列表，每格时刻保留 BEAM_CNT个拼音 cb_len: 最近一帧的解码格数，即: pnyp_t cb_data[cb_len][BEAM_CNT] **DECODER_DIG** function：输出最近4s内的中文数字识别结果 decoder_args：blank_ms, 超过该值则在输出结果里插入一个'_'表示空闲静音 cb_data: 最近4s的中文数字识别结果，字符串形式，支持 0123456789 .(点) S(十) B(百) Q(千) W(万) cb_len: strlen(cb_data) **DECODER_KWS** function: 输出最近一帧所有注册的关键词的概率列表，用户可以观察概率值，自行设定阈值进行唤醒 decoder_args： ``` arg0: 关键词列表，以拼音间隔空格填写，如： char* my_kw_tbl[3] { (char*)\"xiao3 ai4 tong2 xue2\", (char*)\"tian1 mao1 jing1 ling2\", (char*)\"tian1 qi4 zen3 me yang4\" }; arg1: 关键词概率门限表 虽然回调会输出所有关键词的概率，但是也需要概率门限表来去除上一帧输出过的有效关键词来排重 按顺序排列输入即可 arg2: 关键词数量 arg3: 是否进行自动近音处理，置1则会自动将不同声调的拼音作为近音词来合计概率 ``` cb_data: 最近一帧注册的所有关键词的概率（float,0~1） cb_len: 关键词数量 > 注：cb_data中输出的值如果是负数，则表示对应的关键词上一帧刚输出过，需要排重。 相关函数： 手工注册静音词，每个拼音可以注册最多10个近音词。 注意，使用该接口注册近音词会覆盖使能 \"自动近音处理\" 里自动生成的近音表 ``` int ms_asr_kws_reg_similar(char* pny, char** similar_pnys, int similar_cnt); DEMO： char* similar_pnys[3] {(char*)\"xin1\", (char*)\"ting1\", (char*)\"jin1\"}; ms_asr_kws_reg_similar((char*)\"jing1\", similar_pnys, 3); ``` **DECODER_LVCSR** function: 输出连续语音识别结果（小于1024个汉字结果） decoder_args： ``` arg0: sfst_name, sfst文件路径（LG.fst） arg1: sym_name, sym文件路径（输出符号表） arg2: phones_txt, phones.bin的路径（拼音表） arg3: words_txt, words.bin的路径（词典表） arg4: beam, WFST搜索的beam大小，默认为5，建议在3~9之间，越大搜索空间越大，越精确但越慢 arg5: bg_prob, 在BEAM_CNT之外的背景拼音的默认概率值的自然对数的绝对值，默认为10 arg6: scale, acoustics_cost log(pny_prob)*scale arg7: is_mmap, 是否使用mmap方式加载WFST解码图。 使用mmap方式则无需加载sfst文件到内存，使用即时磁盘读取的方式读取解码图，速度较慢，beam< 5时可以实时解码 使用非mmap方式，读取整个sfst文件到内存，解码速度最快，beam上限可以到10 ``` cb_data: ``` data0: char* words, 识别的汉字结果字符串，注意编码方式根据输入的words.bin的编码方式而定，可以为GBK或者UTF 8 data1: char* pnys, 识别的拼音字符串结果 注意，字符串内可能有','或者'.'表示语句停顿，如不需要则自行滤除 ``` cb_len: 固定为2，表示返回了2个参数 ### 清缓存 重置内部缓存操作，在开启新的语音识别前清一次 ``` void ms_asr_clear(void); ``` ### 运行语音识别 frame: 每次run的帧数; 返回实际run的帧数 用户可以每次run 1帧，run完做其他处理；或者一个线程里一直run，由外部线程stop来停止 内部自动调用asr_device的read接口读入相应长度的数据进行出来 ``` int ms_asr_run(int frame); ``` ### 获取一帧的时间 返回一帧的时间 ms ``` int ms_asr_get_frame_time(void); ``` ### 获取声学模型词典 ``` void ms_asr_get_am_vocab(char** vocab, int* cnt); ``` ### 设置asr数据源 重新设置asr的数据源，一般在pcm/wav识别时使用，比如进行下一个wav文件识别 内部会自动进行缓存清除操作 ``` int ms_asr_set_dev(int device_type, char* device_name); ``` ### 单独运行WFST解码 输入 T_CNTxBEAM_CNT 个拼音结果，进行decoder推理，用于lm的测试 ``` void ms_asr_wfst_run(pnyp_t* pnyp_list); ``` ## 配置文件解析 例程使用opts.c来解析配置文件，用户可以在其上添加参数，或者自行编写配置解析函数。 例程的配置文件为极简的格式，行首#则记为注释(行尾#无效)， 一行参数使用':'分割，格式为 arg_name:arg_value 参数说明(行尾的#仅为文档里的说明使用，实际不含该注释)： ``` #device config device_type:wav #设备类型：wav,pcm,mic,custom device_name:1.2.wav #设备名 #am config model_name:asr_7332_192.bin #am模型路径 model_in_len:192 #模型输入长度 strip_l:6 #左右边界长度 strip_r:6 phone_type:pnytone #模型建模类型 agc:1 #是否使能AGC（自动增益控制） #lm config sfst_name:lg_6c.sfst #解码图文件路径 sym_name:lg_6c.sym #输出符号表路径 phones_txt:phones.bin#拼音表路径 words_txt:words.bin #词典表路径 font_path:./ #字体路径，可选 beam:8.0 #解码搜索宽度 bg_prob:10.0 #背景概率对数值的绝对值 scale:0.5 #声学分比例 is_mmap:0 #是否以mmap方式加载语言模型 #lib dbg dbg_micraw:0 #是否dump原始mic音频到micraw.pcm dbg_mic:0 #是否dump preproces后的音频到mic.raw dbg_strip:0 #是否显示边界信息 dbg_lvcsr:0 #是否打印wfst解码详情 dbgt_pp:0 #preprocess计时 dbgt_am:0 #am模型运算计时 dbgt_kws:0 #kws解码计时 dbgt_wfst:0 #wfst解码计时 #app config do_raw:0 #打印原始am模型结果 do_dig:0 #注册数字识别回调 do_kws:0 #注册关键词识别回调 do_lvcsr:1 #注册连续语音识别回调 #testbench config #跑分测试配置 #testpath:/mnt/kws/aishell_test_1_10/ #待测试wav目录，不测试则注释掉改行 testpny:1 #输出pny测试结果 testhan:1 #输出han测试结果 #testlm:lm_test.txt #LM测试文件（每行一句话的拼音字符串，空格分割，\\n换行） ```"},"/soft/Lichee/zh/MaixSense/application/Usages.html":{"title":"Armbian 配置及使用","content":"# Armbian 配置及使用 ## 配置网络 `nmtui` ![202108051626](./../assets/202108051626.gif) ## 配置SSH连接 系统已默认开启了ssh和ftp，需要在串口使用 `passwd root` 进行账号密码设置，才能使用 root 账号进行 SSH 连接。 ## MaixPy3 IDE 连接 MaixPy3 IDE 连接 MaixSense 只能使用远程连接，不能使用有线连接，而且每个人的网络环境都存在差异，可能存在连接不上的情况出现。 ### 准备 烧录好带有 MaixPy3 的 Armbian 系统 连接网络进行 MaixPy3更新，确保 MaixPy3 的版本大于 0.3.4。 运行 `ifconfig` 获取开发板的 IP 地址 ### 连接 在板子上运行 `python c \"import maix.mjpg;maix.mjpg.start()\"` 启动板子上的远程 RPyc 服务 在 IDE 中新建代码区，运行下面的连接代码 ```python $connect(\"192.168.43.44\") # 此处填入开发板的 IP 地址 import platform print(platform.uname()) ``` 运行输出结果如下： ![MaixPy3 IDE](./../assets/MaixPy3 IDE.jpg) ## 配置APT源 打开`armbian config`，选中Personal，选择Mirrors，找到合适的apt源，按住TAB键切换到ok，保存即可。\t\t ![202108061955](./../assets/202108061955.gif) ## 设置时区 打开`armbian config`，选中Personal，选择Timezone > Asia >Shanghai设置上海时间（不用找，Debian没有北京时间），按住TAB键切换到ok，保存即可。\t\t ![202108062005](./../assets/202108062005.gif) ## 设置中文显示 打开`armbian config`，选中Personal >Locales>下滑到最下面，空格选中zh.GBK和zh.UTF 8,，然后勾选zh_CN.UTF8设置为系统默认语言，按住TAB键切换到ok，保存，exit退出，下载中文字体，`apt get install fonts wqy zenhei`，重启后系统环境就变成中文的了。 ![202108062054](./../assets/202108062054.gif) ## 配置蓝牙 打开`armbian config`，选中Network，选择BTinstall安装蓝牙支持包。 ![202108071034](./../assets/202108071034.gif) 可以使用Xftp传输，安装完毕后断电重启即可。 然后就可以使用Bluetoothctl配置蓝牙。 常用命令： ```bash devices \t\t列出活动的蓝牙设备 paired devices \t\t列出已配对蓝牙设备 pairable <on/off> \t\t是否允许配对 discoverable <on/off> 是否允许被发现 discoverable timeout [value]设置暴露时间 pair [dev] 配对设备 trust [dev] 信任设备 untrust [dev] 取消设备信任 remove <dev> 移除设备 connect <dev> 连接设备 disconnect [dev] 断开设备连接 quit 退出 help \t\t\t\t查看帮助 ``` ### 连接蓝牙设备 使用`bluetoothctl`连接蓝牙设备。 ```bash scan on #扫描设备 scan off #停止扫描 trust XX:XX:XX:XX # 信任设备 pair XX:XX:XX:XX #配对设备 connect XX:XX:XX:XX #连接设备 ``` ![202108071610](./../assets/202108071610.gif) ### 设置蓝牙音频输入/输出 启用蓝牙音频前，需要先安装`pulseaudio`即及蓝牙组件 ```bash apt install pulseaudio apt install pulseaudio module bluetooth ``` 然后使用pactl查看是否有蓝牙输出设备 ```bash pactl list short sinks ``` 切换音频输出到蓝牙 ```bash pactl set default sink <dev> ``` log如下： ```bash maixsense:~:# apt install pulseaudio maixsense:~:# apt install pulseaudio module bluetooth maixsense:~:# pactl list short sinks 0\talsa_output.platform 7032000.codec.stereo fallback\tmodule alsa card.c\ts16le 2ch 44100Hz\tSUSPENDED 2\tbluez_sink.00_26_04_00_73_B1.a2dp_sink\tmodule bluez5 device.c\ts16le 2ch 44100Hz\tSUSPENDED maixsense:~:# pactl set default sink 2 ``` ![202108071726](./../assets/202108071726.gif) 然后就可以播放音频到蓝牙设备，或者通过蓝牙连接手机当作蓝牙音箱使用。 ## 配置音量 `alsamixer` ![202108071440](./../assets/202108071440.gif) 常用命令 ``` Help xxEsc 离开 ▒x xxF1 ? H 帮助 ▒x xxF2 / 系统信息 ▒x xxF3 回放控制 ▒x xxF4 捕获控制 ▒x xxF5 所有控制 ▒x xxTab 切换显示模式 ▒x xxF6 S 选择声卡 ▒x xxL 刷新屏幕 ▒x xxLeft 移动到上一个的控制 ▒x xxRight 移动到下一个的控制 ▒x xxUp/Down 改变音量 ▒x xx+ 改变音量 ▒x xxPage Up/Dn 大幅改变音量 ▒x xxEnd 设置音量为0 ▒x xx0 9 从0到9依次设置音量 ▒x xxQ W E 增加 左/全部/右声道音量 ▒x xxZ X C 减少 左/全部/右声道音量 ▒x xxB 左右声道平衡 ▒x xxM 切换静音 ▒x x< > 切换左/右静音 ▒x xxSpace 切换捕获 ▒x xx; ' 切换左/右捕获 ▒x ``` 如果需要控制蓝牙设备音量，需要使用`pactl` ，并且`pcatl`也支持控制声卡，所以推荐使用此app控制音量。 ```bash ##查看输入/输出设备索引 pactl list short sources/sinks ##设置输入/输出音量 pactl set source/sink volume index volume pactl set default source/sink ##设置默认输入/输出 ``` 示例，设置蓝牙耳机为输出设备，音量为10%,然后增加20%，最后减少30% ```bash maixsense:~:# pactl list short sinks 0\talsa_output.platform 7032000.codec.stereo fallback\tmodule alsa card.c\ts16le 2ch 44100Hz\tSUSPENDED 2\tbluez_sink.00_26_04_00_73_B1.a2dp_sink\tmodule bluez5 device.c\ts16le 2ch 44100Hz\tRUNNING ##蓝牙设备一般为bluez_sink maixsense:~:# pactl set default sink 2 maixsense:~:# pactl set sink volume 2 10% maixsense:~:# pactl set sink volume 2 +8192 maixsense:~:# pactl set sink volume 2 0x3000 ##可选 百分比，十进制数，十六进制数控制，效果相同，并且可以超过100% ``` ## 媒体播放 媒体播放常用mplayer apt下载mplayer`apt install mplayer` 然后执行`mplayer badapple_240p.mp4 vo fbdev2`播放视频 或者`mplayer G.E.M.邓紫棋\\ \\ 光年之外.flac`播放音频 在后面加上`< /dev/null > /dev/null 2>1 &`以便在后台播放 ![202108091128](./../assets/202108091128.gif) ## 编写c代码 ```c vim helloworld.c i #include <stdio.h> int main() { printf(\"Hello, world\\n\"); return 0; } esc :wq gcc hello.c o hello.o ./hello.o ``` ![202108091201](./../assets/202108091201.gif) ## 编写python代码 ```bash vim helloworld.py i print(\"hello world!\\n\") esc :wq python3 helloworld.py ``` ![202108091339](./../assets/202108091339.gif) ## 运行神经网络实例 获取1000类物体分类模型 下载站链接[zhouyi_test.tar.xz](https://dl.sipeed.com/shareURL/MaixII/MaixII A/example),使用任意方式上传到板子中 ```bash ##解压压缩包 tar xvf zhouyi_test.tar.xz ##授予执行权限 cd zhouyi_test chmod 777 run.sh ##执行1000类物体分类 ./run.sh ##后台执行1000类物体分类 ./run.sh < /dev/null > /dev/null 2> 1 ``` ## 使用python点亮第一个灯 安装GPIO的python支持库 ```bash pip install gpiod ``` 把led正极插入PH5,负极插入GND 编写代码 ``` bash vim led.py ``` 复制代码进去 ```python import time import gpiod as gpio PH_BASE (8 1)*32 # \"PH\" gpiochip1 gpio.chip(\"gpiochip1\") led gpiochip1.get_line((PH_BASE + 5)) # \"PH5\" config gpio.line_request() config.request_type gpio.line_request.DIRECTION_OUTPUT led.request(config) while led: led.set_value(0) time.sleep(1) print(\"led on\") led.set_value(1) time.sleep(1) print(\"led off\") ``` 执行代码 ```bash python3 led.py ``` 效果如下： ![202108091956](./../assets/202108091956.gif) ## 设置开机启动 启用开机自启动脚本 ```bash vim /lib/systemd/system/rc local.service ``` 在最后面添加 ```bash [Install] WantedBy multi user.target Alias rc.local.service ``` 编辑自启动脚本 ```bash vim /etc/rc.local ``` 在`exit 0`前面添加需要启动的服务 ```bash mplayer /root/badapple_240p.mp4 vo fbdev2 < /dev/null > /dev/null 2>1 & python3 /root/helloworld.py ``` 然后重启即可 注意，此脚本会在用户登录前执行，执行日志如下 ```bash [ OK ] Finished Permit User Sessions. [ 38.569457] rc.local[1322]: hello world! ``` ## 更多的使用方法 请到[MaixPy3](/soft/maixpy3/zh/readme.md)和[极术社区](https://aijishu.com/a/1060000000221780)中自行查看"},"/soft/Lichee/zh/MaixSense/application/Speech.html":{"title":"Maix-Speech 在R329上的应用","content":" title: Maix Speech 在R329上的应用 keywords: R329, Speech, 语音 Maix Speech 是专为嵌入式环境设计的离线语音库，设计目标包括：ASR/TTS/CHAT 不建议新手使用 ## 准备环境 Ubuntu 18.04 以上 gcc 7.5 以上， CMake 3.20以上， anaconda虚拟环境 在x86 (Linux)或其他架构的系统里编译，需要额外安装工具链和库(`Ubuntu` 为例) ``` sudo apt install build essential libasound2 dev ``` * 下载交叉编译工具链，并解压到合适的文件夹。例如 `R329`, 从[release](https://github.com/sipeed/Maix Speech/releases)下载 `r329_toolchain.tar.gz`, 并解压到一个合适的路径，比如 `/opt/r329_toolchain`。又比如 `v83x`, 在[这里](https://github.com/sipeed/libmaix)找到工具链下载链接并下载工具链，解压到一个文件夹，比如`/opt/toolchain sunxi musl`。 架构 前缀名 工具链 : : r329 aarch64 openwrt linux [release](https://github.com/sipeed/Maix Speech/releases) 下寻找 r329 toolchain v83x arm openwrt linux muslgnueabi [sipeed/libmaix](https://github.com/sipeed/libmaix) README 中寻找 armv7 arm linux gnueabihf [linaro(v3s)](https://wiki.sipeed.com/soft/Lichee/zh/Zero Doc/System_Development/uboot_build.html) 或者其它 arm linux gnueabihf toolchain armv7musl arm openwrt linux muslgnueabi [sipeed/libmaix (v83x)](https://github.com/sipeed/libmaix) README 中寻找 aarch64 aarch64 openwrt linux [release](https://github.com/sipeed/Maix Speech/releases) 下寻找 r329 toolchain riscv64 riscv64 unknown linux gnu ## 代码仓库: ``` git clone https://github.com/sipeed/Maix Speech ``` 对应的项目结构 ``` . ├── assets │ └── test_files # 提供的测试文件，方便上手测试 ├── components # 组件 │ ├── asr_lib # 组件 asr_lib │ │ ├── CMakeLists.txt # 组件配置文件 │ │ ├── include # 头文件 │ │ ├── Kconfig # 组件 menuconfig 配置文件 │ │ ├── lib # 各个平台的库文件 │ │ └── src # 源文件 │ └── utils # 工具类组件，包括了跑分、字体等 ├── Kconfig # 最顶级的 menuconfig 配置文件 ├── LICENSE # 开源协议（证书） ├── projects # 项目 │ └── maix_asr # ASR 项目 │ ├── CMakeLists.txt # 项目配置文件 │ ├── main # 项目里面的主组件 │ └── project.py # 构建脚本，方便输入命令 ├── README.md # 项目首页英文文档 ├── README_ZH.md # 项目首页中文文档 ├── tools # 项目构建相关代码，一般不用看 └── usage_zh.md # 使用方法 ``` ## 编译 * 在x86 (Linux) 或在其它架构的系统里编译时，例如`R329`或 `树莓派`应使用对应的`GCC` > conda 环境下工具链可能有问题，如果出现错误可以先尝试退出conda环境使用转用原生环境编译 ```bash{.line numbers} cd projects/maix_asr # 打开对应的文件夹 python project.py clean_conf # 清除工具链配置 python project.py menuconfig # 配置选择芯片架构（ARCH），默认是 x86 python project.py build #python project.py rebuild # 如果有新建文件需要使用 rebuild #python project.py build verbose # 打印详细构建过程 ./build/maix_asr # 测试下运行可执行文件，可以执行即可 python project.py clean # 清除构建内容 python project.py distclean # 彻底清除构建内容, 包括 menuconfig 内容 ``` * 其它架构（交叉编译） [前面](#准备环境)已经说明不同架构相应的编译工具链，在编译时需要配置一下相应的工具链信息。 需要配置： * 工具链可执行文件所在文件夹路径，比如`/opt/r329_toolchain/bin` `/opt/toolchain sunxi musl/bin` * 工具链前缀，可在前面的表格中找到， 比如`aarch64 openwrt linux ` ```bash{.line numbers} cd projects/maix_asr # 配置工具链位置和前缀， distclean 不会清除工具链配置, 这会在目录下生成一个 .config.mk 文件 python project.py toolchain 工具链可执行文件路径路径 toolchain prefix 前缀名 config # python project.py toolchain /opt/r329_toolchain/bin toolchain prefix aarch64 openwrt linux config python project.py menuconfig # 选择目标架构 python project.py build # python project.py clean_conf # 清除工具链配置 ``` 关于更详细地如何使用编译框架请看 [github.com/Neutree/c_cpp_project_framework](https://github.com/Neutree/c_cpp_project_framework) ## 运行语音识别例程 以 `x86(Linux)` 平台为例的快速验证 demo， 其它需要交叉编译的平台自行复制可执行文件到开发板的系统再运行: * 先保证编译通过， 可执行文件 `projects/maix_asr/build/maix_asr` 存在并且可以运行 * 在 [release 页面](https://github.com/sipeed/Maix Speech/releases) 找到 `am_7332.zip` 和 `lmM.zip` 文件并下载， 解压到`assets/test_files` 目录, 解压后的`assets`目录结构如下 ``` assets ├── image └── test_files ├── 1.2.wav ├── am_7332 ├── asr_wav.cfg └── lmM ``` 上面主要包含了两种模型 —— 声学模型`AM` 和 语言模型`LM`。每种模型又有几种模型大小选择，精度越大资源消耗越大。另外还有字体文件。 下面不同平台实时运行的典型配置： ```{.line numbers} Cortex A7 1.0GHz, < 128M 系统内存：am_3316 + lmS, is_mmap 1, beam<5 Cortex A7 1.0GHz, > 256M 系统内存：am_3316 + lmM, is_mmap 0, beam 5~10 Cortex A53 1.2GHz, > 256M 系统内存：am_3324 + lmM, is_mmap 0, beam 5~10 Cortex A72 1.5GHz, > 1G 系统内存：am_3332 + lmL, is_mmap 0, beam 5~10 ``` 带[NPU](https://baike.baidu.com/item/NPU/17905535)的硬件平台，选用对应转换好的 `NPU` 硬件加速的声学模型，比如`R329`需要下载对应的`r329_7332_192.bin`， 然后根据系统内存大小选择对应的语言模型。语言模型目前没有硬件加速，均使用 CPU 运算。 ```bash{.line numbers} cd assets/test_files #进入到 test_files 目录 ../../projects/maix_asr/build/maix_asr asr_wav.cfg #执行测试 #可以看到语音识别的结果 HANS: 一点 二三 四五 六七 八九 PNYS: yi4 dian3 er4 san1 si4 wu3 liu4 qi1 ba1 jiu3 ``` 如果是 `Windows` 需要 `GBK`编码则需要修改`asr_wav.cfg`中的 `words_txt:lmM/words_utf.bin` 为 `words_txt:lmM/words.bin` 。 测试其他 `wav` 文件只需要修改 `asr_wav.cfg` 中的 `device_name` 到对应测试 `wav` 路径即可。 测试其它模型，修改`model_name`指定文件路径即可。 **注意** wav 需要 **16KHz** 采样，**S16_LE** 的存储格式。另外还支持 `PCM` 或者 `MIC` 实时识别，详见 [usage_zh.md](./Speech_usage_zh.html) 中对 cfg 文件的介绍。 > 可以使用工具转换，比如 `arecord d 5 r 16000 c 1 f S16_LE audio.wav` ## 详细使用文档 请看[使用文档](./Speech_usage_zh.html) ## Maix ASR 模型选择 MAIX ASR **声学模型**按尺寸分为：7332,3332,3324,3316。 大小如下表： model7332333233243316 float(MB)44281810 int8(MB)1174.52.5 MAIX ASR **语言模型**可以自由选择，默认开放三种尺寸的模型：lm_s,lm_m,lm_l 每种模型分成 sfst, sym, phones, words 四部分，其中 sym,phones,words 仅用于输出字符串使用，无需加载入内存，仅放在磁盘。sfst为解码图文件（LG.fst的压缩版），可选载入内存或者mmap实时读取。 表中的wer表示 aishell 测试集的汉字转拼音作为输入，通过LM转汉字后的错误率 modellmSlmMlmLlmXL : :: :: :: :: : sfst12MB104MB750MB3700MB sym6.5MB59MB404MB1940MB phones12KB13KB13KB13KB words8.0MB72MB72MB107MB WER2.78%1.94%1.61%1.24% 以下是各个模型的benchmark pny wer表示带声调的拼音错误率，lmX表示加上对应语言模型后的汉字错误率 model/lenpny wer lmS 12M lmM 104MlmL 750M : : : : : : : : : : 7332 11MB 192 17.7 13.1 11.1 10.0 ali192 9.94 9.02 7.56 6.53 non flow 8.63 7.81 6.60 5.38 3332 7MB 128 16.4 13.3 11.9 11.0 192 11.6 8.73 7.22 6.48 non flow 10.6 8.46 6.71 5.94 3324 4.5MB 128 23.4 20.4 19.4 18.5 192 11.3 13.7 9.66 8.55 non flow 12.2 10.2 8.65 7.56 3316 2.5M 128 25.5 19.2 17.4 16.0 192 16.9 12.9 11.4 10.1 non flow 16.1 11.2 11.0 9.68 模型说明： 下划线后的数字表示选取的帧长度，如192表示一帧为192x8 768ms，asr库每采集完一帧后进行一次处理 帧长度关系到识别延迟，如192就会最大有768ms延迟，128则为512ms，可见帧长的模型错误率更优，但是延迟稍长 表中默认为流式识别，使用有限的上下文（一帧长度），noflow表示非流式识别（整体识别），可见非流式识别错误率大幅下降 ali表示对齐优化后的结果，即类sMBR处理后的结果，可见对齐训练后错误率大幅下降。 附件默认上传了192长度的流式识别模型，需要其他识别模型的可以联系矽速。 ## Maix Speech TTS * TODO ## Maix Speech CHAT * TODO ## TODO List [ ] Support English [ ] Test Conformer [ ] Support TTS [ ] Support CHAT ## License 项目使用 [Apache 2.0](./LICENSE) 开源协议，以及其引用和使用的开源项目的开源协议见 [LICENSE](./LICENSE) ## 致谢 MaixSpeech 借鉴和使用了一些优秀的开源项目，并咨询了一些业内大佬，包括： 1. WFST 解码 [Kaldi](http://kaldi asr.org/) 2. 前端推理框架 [MNN](https://github.com/alibaba/MNN) 3. ARM中国 周易团队,尤其是toby 4. wenet 彬彬大佬；原cvte大佬 pfluo； ## 其他 Maix Speech 目前以静态库形式提供给用户评估使用，有商业定制需求的用户可以发邮件到 <support@sipeed.com> 咨询"},"/soft/Lichee/zh/MaixSense/build_sys/config_system.html":{"title":"配置系统","content":"# 配置系统 ## Tina系统配置 Lichee MaixSense 的 Tina 系统配置和 M2dock 基本相同，这里不另作赘述。 ## armbian系统配置 R329 可以通过 otg 外接 HID 设备直接在屏幕上启动控制台进行操作，也可以通过常用的串口启动控制台。为了方便演示，这里以控制台为例； 通过 typec 数据线连接 Lichee MaixSense 和电脑，使用 Xshell 新建会话框，选中新弹出 COM，波特率设置115200，连接。 初始化结束后，需要输入登录密码，密码复杂度要求较高，请多次尝试（配置完后直接 `passwd d root` 就可以删除密码了。） > 目前公开带有 MaixPy3 名称 armbian 镜像输入 root 即可登录，不需要进行密码设置！ ```bash New to Armbian? Documentation: https://docs.armbian.com Support: https://forum.armbian.com New root password: ********** Repeat password: ********** ``` 然后设置默认 shell,一般选择 bash ```bash Choose default system command shell: 1) bash 2) zsh Shell: BASH ``` 然后可以设置一个非 root 用户日常操作用 ```bash Creating a new user account. Press <Ctrl C> to abort Please provide a username (eg. your forename): ll Create password: ********* Repeat password: ********* ``` ![2021080511 46 52](./../assets/2021080511 46 52.gif)"},"/soft/Lichee/zh/MaixSense/intro_cn.html":{"title":"施工中","content":" title: 施工中 "},"/soft/Lichee/zh/Nano-Doc-Backup/step_by_step/one_openbox.html":{"title":"入手lichee-pi-nano","content":"# 入手lichee pi nano ## 到荔枝淘宝购买 [此处购买](https://item.taobao.com/item.htm?spm a230r.1.14.7.2a311bf5BmOgwm&id 584657396198&ns 1&abbucket 8#detail) ## 拆箱 lichee pi nano kit套餐 : ![](./../static/step_by_step/nano_kit.jpg) lichee pi nano F(16M) : ![](./../static/step_by_step/nanoF(16).jpg) lichee pi nano F(8M) : ![](./../static/step_by_step/nanoF(8).jpg) lichee pi nano (9.9) : ![](./../static/step_by_step/nano(9.9).jpg) LCDC(带电容触摸) : ![](./../static/step_by_step/LCDC.jpg) LCD : ![](./../static/step_by_step/LCD.jpg) ## 准备工具 准备一个usb转ttl,用于查看console打印: ![](./../static/step_by_step/usb_to_ttl.jpg) 准备一根usb线,一般mp4那种,用于下载固件到spi\\_flash和sdram,方便调试. ![](./../static/step_by_step/micro_usb_line.jpg) # 焊接 焊接 ![](./../static/step_by_step/seal.jpg) ## 测试板子是否正常 使用一键镜像包构建启动固件并下载到spiflash或tf卡 教程地址: [一键烧录镜像包](./../build_sys/onekey.html) 固件下载完后是使用杜邦线连接nano和电脑, 在终端输入sudo minicom s,配置好串口参数(115200 8N1). 正常运行的打印截图 ![](../static/step_by_step/console_run_is_ok.png) 正常运行的液晶显示 ![](../static/step_by_step/lcd_run_is_ok.jpg)"},"/soft/Lichee/zh/Nano-Doc-Backup/step_by_step/two_sunxi-tools.html":{"title":"编译和使用sunxi-tools","content":"# 编译和使用sunxi tools ## 克隆sunxi tools git clone https://github.com/Icenowy/sunxi tools.git b f1c100s spiflash ## 编译sunxi tools 安装sunxi tools依赖库 sudo apt install libz libusb 1.0 0 dev 编译 make 安装 make install ## 使用sunxi tools 查看芯片信息 sudo sunxi fel ver AWUSBFEX soc 00001663(F1C100s) 00000001 ver 0001 44 08 scratchpad 00007e00 00000000 00000000 列出所有芯片的信息 sudo sunxi fel l 加载并执行uboot的spl sudo sunxi fel spl 文件名 把文件内容写入内存指定地址( p是显示写入进度) sudo sunxi fel p write 地址 文件名 调用指定地址的函数 sudo sunxi fel exec 地址 显示spiflash的信息 sudo sunxi fel spiflash info 读取spiflash指定地址的数据并写入到文件 sudo sunxi fel spiflash read 地址 长度 存放数据的文件路径 写入指定文件的指定长度的内容到spiflash的指定地址 sudo sunxi fel spiflash write 地址 长度 存放数据的文件路径"},"/soft/Lichee/zh/Nano-Doc-Backup/step_by_step/four_linux.html":{"title":"编译和配置linux","content":"# 编译和配置linux ## 克隆linux git clone https://github.com/Lichee Pi/linux.git depth 1 b nano 4.14 exp ## 载入默认配置 下载配置文件 wget http://nano.lichee.pro/_static/step_by_step/lichee_nano_linux.config 修改下载的配置文件名为.config mv lichee_nano_linux.config ./config 编译 make ARCH arm 系统默认的账号密码 账号：**root** 密码：**licheepi**"},"/soft/Lichee/zh/Nano-Doc-Backup/step_by_step/three_uboot.html":{"title":"编译和配置uboot","content":"# 编译和配置uboot ## 克隆uboot git clone https://github.com/Lichee Pi/u boot.git b nano v2018.01 ## 载入默认配置 如果需要生成在sdram里启动的uboot make ARCH arm licheepi_nano_defconfig 如果需要生成在spiflash里启动的uboot make ARCH arm licheepi_nano_spiflash_defconfig ## 编译时可能遇到的问题以及解决办法 **/bin/sh: 1: cc: not found** sudo apt install gcc **\\*\\*\\* Configuration file \".config\" not found!** 请检查当前用户是否有当前文件夹的读写权限,然后再次载入默认配置. **/bin/sh: 1: python: not found** sudo apt install python **unable to execute 'swig': No such file or directory** **error: command 'swig' failed with exit status 1** apt install swig **scripts/dtc/pylibfdt/libfdt\\_wrap.c:149:11: fatal error: Python.h:** **No such file or directory** apt install python dev **/bin/sh: 1: bc: not found** apt install bc ## 测试uboot"},"/soft/Lichee/zh/Nano-Doc-Backup/step_by_step/five_buidroot.html":{"title":"编译和配置buildroot","content":"编译和配置buildroot * * * * * 1. 克隆 请看系统适配篇里的根文件系统的编译"},"/soft/Lichee/zh/Nano-Doc-Backup/driver/touchscreen.html":{"title":"电容触摸屏适配","content":"电容触摸屏适配 本篇需要启动linux系统，所需用到的工具： ts lib ts_test ts_calibrate evtest 在前文设备树中，我们就已经对i2c接口的电容触摸屏做了初始化，以下是进行电容触摸屏的调整与测试： ``` ls /dev/input # 查看是否存在input/event0 # 若不存在，找到触摸模块并加载 insmod goodix.ko # 如根文件系统未找到goodix.ko，请在linux源码的output目录下查找并放入根文件系统下 # 若存在 evtest /dev/input/event0 # 使用evtest测试输入的xy坐标数据 # 直观的测试 ts_test # 触摸校准工具 ts_calibrate ``` 但是 ts_calibrate 仅仅是将校准参数写到 /etc/pointcrl文件中，适用于微调，tslib下的工具如 ts_test将会读取此校准文件而表现的触摸正常；而 evtest 读取原始数据、littlevGL程序调用 event0的输入时，并未去解析该参数文件。同样也有一定可能是该触摸屏内置参数即为错误的，难以进行校准。 测试时，发现xy轴输出互相调换了，请添加或去掉 gt911节点下 的 `touchscreen swapped x y` 属性 若是发现触摸屏输出跳动大，屏幕上有些地方检测不到输出，此处采取修改驱动的办法进行解决：通过 i2c 向 电容触摸芯片GT911 写入固定的参数(相当于重刷GT911的固件)； ``` // 找到一个加载模块时会调用到的函数 static void goodix_read_config(struct goodix_ts_data *ts) { u8 config[GOODIX_CONFIG_MAX_LENGTH]; int error, i; error goodix_i2c_read(ts >client, ts >chip >config_addr, config, ts >chip >config_len); /* end of the code user added */ u8 check_sum 0; //校验和 /* 800*480屏使用 */ u8 write2gt911[GOODIX_CONFIG_911_LENGTH] {0x42, 0xe0, 0x01, 0x20, 0x03, 0x0a, 0x35, 0x00, 0x01, 0x08, 0x28, 0x08, 0x5a, 0x46, 0x03, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x1a, 0x1e, 0x14, 0x89, 0x2a, 0x09, 0x57, 0x5c, 0xb5, 0x06, 0x00, 0x00, 0x00, 0x02, 0x01, 0x1d, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x82, 0x94, 0xc5, 0x02, 0x07, 0x00, 0x00, 0x04, 0x96, 0x4a, 0x00, 0x85, 0x54, 0x00, 0x77, 0x5f, 0x00, 0x6a, 0x6c, 0x00, 0x5f, 0x7a, 0x00, 0x5f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x10, 0x12, 0x14, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0f, 0x10, 0x12, 0x16, 0x18, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x24, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x52, 0x00}; /* 480*272屏使用 */ u8 write2gt911[GOODIX_CONFIG_911_LENGTH] {0x42, 0xe0, 0x01, 0x10, 0x01, 0x0a, 0x3d, 0x00, 0x02, 0x08, 0x28, 0x08, 0x64, 0x46, 0x03, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x1a, 0x1e, 0x14, 0x89, 0x2a, 0x09, 0xc8, 0xca, 0x40, 0x04, 0x00, 0x00, 0x00, 0x61, 0x02, 0x1d, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 0xfa, 0x94, 0xd5, 0xf4, 0x07, 0x00, 0x00, 0x04, 0x86, 0xa7, 0x00, 0x82, 0xb7, 0x00, 0x80, 0xc8, 0x00, 0x7d, 0xda, 0x00, 0x7c, 0xef, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x10, 0x12, 0x14, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0f, 0x10, 0x12, 0x16, 0x18, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x24, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x01}; write2gt911[GOODIX_CONFIG_911_LENGTH 1] 0x01; //update flag for (i 0; i < (GOODIX_CONFIG_911_LENGTH 2); i++) //校验和计算 check_sum + write2gt911[i]; write2gt911[184] (~check_sum) + 1; //checksum error goodix_i2c_write(ts >client, ts >chip >config_addr, write2gt911, GOODIX_CONFIG_911_LENGTH); dev_warn(&ts >client >dev, \"updated the user defined config \\n\", error); /* Let the firmware reconfigure itself, so sleep for 10ms */ usleep_range(10000, 11000); error goodix_i2c_read(ts >client, ts >chip >config_addr, config, ts >chip >config_len); for (i 0; i < GOODIX_CONFIG_911_LENGTH; i++) { printk(\"Config Reg 0x%.4X : 0x%.2x,\", i + 0x8047, config[i]); } /* end of the code user added */ /* 略 */ } ``` 将此驱动编译成模块，使用 `insmod`加载模块后作为修正屏幕参数所用，控制台将会输出gt911各寄存器的参数；修改完毕后使用`rmmod goodix.ko` 卸载模块，重新加载正常的驱动。 若再测试时，发现xy轴输出互相调换了，请添加或去掉gt911节点下的`touchscreen swapped x y` 属性 > **交流与答疑** > 对于本节内容，如有疑问，欢迎到 [模组使用交流帖](http://bbs.lichee.pro/d/24 ) 提问或分享经验。"},"/soft/Lichee/zh/Nano-Doc-Backup/contribution/introduction.html":{"title":"前言","content":"前言 本文档将详细介绍 **荔枝派Nano** 的协作方式，由群主设计目录框架，群友众包完成。 需要什么教程的朋友可以在这里留言，将会添加进TODO List里。 本文不定期更新开发者任务，有荔枝派相关的，也有其他小项目的，有兴趣的朋友可以在其下留言或者直接小窗联系群主QQ：715805855, 或者邮箱 <zepanwucai@gmail.com> 领取任务。 荔枝派Nano 目前有两种协作方式： 快餐型外包 教程文档撰写 `tips 1.` 普通简单任务请在一周内完成，困难任务酌情放宽时间。 `tips 2.` 每个任务同时可由多人认领，由最先完成者获取回报。也可组队认领，回报由队内协商分配。 **具体项目内容请参考下一节。**"},"/soft/Lichee/zh/Nano-Doc-Backup/contribution/doc_tips.html":{"title":"文档相关小事项","content":"文档相关小事项 当您通过联系群主或邮件领取到教程文档的编写任务后，为便于审批与统一文档风格，请您先阅读 [文档构建](build_doc.html) 我们支持您以Markdown或RestructedText语法书写教程；在您完成教程文档以后，可以： 在您的github页面上，发起 **Pull Request** ； 将您的文档文件，发送到 [群主的邮箱](mailto://zepanwucai@gmail.com) 后并联系群主； 我们将尽快审阅并校对教程内容，将您的教程尽快地同步更新到 [看云文档](http://www.kancloud.cn) 与 [文档中心](http://nano.lichee.pro) > 荔枝派 Nano的文档教程与任务尚待更新，届时将会汇总您的贡献投稿与荔枝派开发指南，以提供更好的文档内容"},"/soft/Lichee/zh/Nano-Doc-Backup/contribution/todolist.html":{"title":"TodoList","content":"TodoList > **warning** > > Todolist 尚在规划中..."},"/soft/Lichee/zh/Nano-Doc-Backup/contribution/build_doc.html":{"title":"文档构建","content":"文档构建 本文档选择使用Sphinx来进行构建，支持以 reStructuredText 和 Markdown 格式编写 本地构建 ### 拉取文档 若您是阅读者： 打开终端，运行以下命令: git clone https://github.com/Lichee Pi/xxx.git 若您是文档贡献者： > 建议您 fork 我们github上的文档项目后拉取到本地，便于发起 Pull Request。 ### 2. 安装依赖 首先我们需要通过pip安装Sphinx > pip install Sphinx > 若您没有安装pip，请参照 [pip 安装](http://pip.readthedocs.io/en/stable/installing/) 接着安装本文档的模块依赖 > pip install sphinx_rtd_theme > 用于支持文档主题 > pip install recommonmark 用于支持Markdown文本格式 ### 3. 构建 ``` cd Lichee Zero Doc zh CN # windows .\\make.bat html # linux make html ``` 构建完成，进入 \\_build \\> html \\> index.html 打开以浏览器浏览即可。 技术文档贡献 若您有意向贡献您的实践经验，请参照 [todolist](todolist.html) 以reStructuredText编写文档 .rst 文件是轻量级标记语言的一种，被设计为容易阅读和编写的纯文本，并且可以借助Docutils这样的程序进行文档处理，也可以转换为HTML或PDF等多种格式，或由Sphinx Doc这样的程序转换为LaTex、man等更多格式。 在本文档中， *.rst* 文件配合sphinx工具以及readthedoc主题，具有较为丰富的文本表现。 此外，与Markdown对比来看： > 1. RST更适合于构建完整较大的文档，Markdown更适用于构建单页应用 > 2. RST格式更为丰富，Markdown更为简洁 > 3. RST格式要求稍高于Markdown reStructuredText语法请参考 [quick reStructuredText](http://docutils.sourceforge.net/docs/user/rst/quickref.html#doctest blocks) 个人建议您也可以通过查看 [Read theDocs主题示例](https://sphinx rtd theme.readthedocs.io/en/latest/demo/demo.html#id27)，配合其[github](https://github.com/rtfd/sphinx_rtd_theme/edit/master/docs/demo/demo.rst)的编辑源码模式，可更直观地进行对照、借鉴。 另： RST的表格对于中文支持不好，个人推荐借助 [pytablewriter](http://pytablewriter.rtfd.io) 来生成中文表格 ``` # coding: utf 8 import pytablewriter writer pytablewriter.RstGridTableWriter() writer.table_name \"example_table\" writer.header_list ['水果', '价格', '数量'] writer.value_matrix [ ['香蕉', '1', '5'], ['苹果', '1', '6'], ['草莓', '1', '7'], ] writer.write_table() ``` > **渲染为：** ``` .. table:: + + + + 水果价格数量 + + + + 香蕉 1 5 + + + + 苹果 1 6 + + + + 草莓 1 7 + + + + ``` 以Markdown编写文档 Markdown语句较为简明，互联网上也有大量的辅助工具与教程； 个人推荐您使用 vscode配合插件Markdown All in One，或使用 [typora](https://www.typora.io/) ，笔者使用体验较为舒适 > **一点小提醒** > > 若您单纯使用Markdown书写，无需注意以下所有内容； > > 若您 **想用Markdown而不涉及rst及其语法** 构建您的 **个人文档** > 时，建议您使用 [Mkdocs](http://www.mkdocs.org/) 替代sphinx，参阅 [readthedocs buildprocess](http://docs.readthedocs.io/en/latest/builds.html#mkdocs)； > > 若您将Markdown文件加入sphinx的构建行列，请注意以下两条： > > 要使用sphinx所提供的特性时，如： > > >**Tip** > >15% if the service is good. > > >**Error** > >Does not compute. > > > 请将其标为代码片段，代码类型为：**eval\\_rst**，sphinx将会将此片段作为rst文本进行解析： > > > > ```eval_rst > > > > .. Tip:: 15% if the service is good. > > > > .. Error:: Does not compute. > > > > ``` > > sphinx对Markdown的表格支持不够完全，请使用上一条所用方法，以rst语法来绘制表格"},"/soft/Lichee/zh/Nano-Doc-Backup/contribution/task_tips.html":{"title":"快餐任务相关小事项","content":"快餐任务相关小事项 快餐任务是指由群主预先评估并规划后发布的小型外包任务，为兼顾新手与高手的开发周期，任务平均所需花费的时间将会控制在一定的小时数量内。 当您或您的团队确定了您的一个或几个（≤ 3个）项目意向，请及时联系群主以确认开发时长、内容与任务回报； 当您完成项目后，也请尽快联系 [群主](mailto://zepanwucai@gmail.com) ，并请您提供： 若为机械硬件或应用功能性开发项目，请摄录示例视频以展现任务效果； 若为驱动或移植开发，请打包环境配置文件、命令脚本、镜像等相关内容，交于群主验证； 请编写相关文档，如 API 接口文档、移植文档、使用说明书等以作资料收集（公开与否取决于您的意向）； 荔枝派将借助平台，使用任务流、时间轴的形式，协助各位开发者更直观地快速了解并管理自己的开餐任务。 最后，请参阅 [TodoList](./todolist.html) 以查看各项任务的进展情况与负责人。 > 荔枝派 Nano的快餐任务尚待更新，预计将于众筹开始一周之后陆续进行快餐任务的发布"},"/soft/Lichee/zh/Nano-Doc-Backup/get_started/first_eat.html":{"title":"前言","content":"# 前言 此篇为少量或无需配置的开发，可帮助您快速上手，串口输出、点屏等操作确认 Nano 完好~ 具体详细配置与解释说明，将在后文进行较为详细的介绍；如果您和笔者一样是个小白萌新，希望能给您的学习提供一点小小的tips；如果您已熟悉此流程，快速浏览即可 :) 笔者所用环境为： > ubuntu 16.04 LTS 64位 对于本节内容，如有疑问，欢迎到 [Bootloader 与 RTOS 使用交流帖](https://bbs.sipeed.com/) 提问或分享经验。 交叉编译除了编译器外需要安装一大堆依赖 > sudo apt get install gcc make cmake rsync wget unzip build essential git bc swig libncurses dev libpython3 dev libssl dev python3 distutils android tools mkbootimg y ## u boot 初体验 ### 安装交叉编译链 首先需要安装交叉编译链： 此处为获取7.2.1版本，您可获取其他版本或者通过链接直接下载 ```bash wget http://releases.linaro.org/components/toolchain/binaries/7.2 2017.11/arm linux gnueabi/gcc linaro 7.2.1 2017.11 x86_64_arm linux gnueabi.tar.xz tar vxJf gcc linaro 7.2.1 2017.11 x86_64_arm linux gnueabi.tar.xz sudo cp r ./gcc linaro 7.2.1 2017.11 x86_64_arm linux gnueabi /opt/ sudo vim /etc/bash.bashrc ``` 在文件末尾 添加以下内容 ``` PATH \"$PATH:/opt/gcc linaro 7.2.1 2017.11 x86_64_arm linux gnueabi/bin\" ``` 添加完毕 使路径生效 source /etc/bash.bashrc 此时可用 `arm linux gnueabi gcc v`进行测试；若普通用户状态下没有成功，通过 `sudo su`切换到root用户再尝试； ### 编译 u boot 然后从gitee上拉取对 Nano 进行了适配的 u boot： ``` sudo apt get install git git clone https://gitee.com/LicheePiNano/u boot.git cd u boot # 查看分支 git branch a # 切换到 Nano 分支 git checkout nano lcd800480 ``` u boot对于新手来说目录层级稍显复杂，您可参考下表进行快速的熟悉和目标文件定位 . ├── api //封装一些平台无关的操作，如字符串打印，显示，网络，内存 ├── arch //以平台架构区分 │ ├──arm │ │ └──cpu │ │ │ └──arm926ejs │ │ │ │ └──sunxi //cpu相关的一些操作，如定时器读取 │ │ │ │ │ └──u boot spl.lds //spl的放置方法 │ │ └──dts │ │ │ └──suniv f1c100s licheepi nano.dts // f1c100s芯片的一些配置 │ │ │ └──suniv f1c100s licheepi nano.dtb │ │ │ └──suniv f1c100s.dtsi │ │ │ └──suniv.dtsi │ │ └──lib //一些库文件 │ │ └──mach sunxi │ │ │ └──board.c //board_init_f │ │ │ └──dram_sun4i.c //ddr的操作，复位，时钟，延时，odt，etc. │ │ │ └──dram_helpers.c //ddr的设置及读写测试 ├── board │ ├──sunxi │ │ └──board.c //sunxi_board_init 入口 │ │ └──dram_suniv.c //DRAM的一些默认参数 ├── cmd //Uboot命令行的一些命令 ├── common //含spl ├── configs //menuconfig里的默认配置,比如各类驱动适配 │ ├── licheepi_nano_defconfig │ ├── licheepi_nano_spiflash_defconfig ├── disk //硬盘分区的驱动 ├── doc ├── drivers //外设驱动 ├── dts ├── examples ├── fs //多种文件系统 ├── include │ ├──configs │ │ └──sunxi_common.h //预配置的参数，如串口号等 │ │ └──suniv.h ├── lib //加密压缩等算法 ├── net //nfs,tftp等网络协议 ├── post ├── scripts 了解u boot大致结构后，我们就可以开始尝试编译了； ``` # 此处告知make采用arm linux gnueabi下的所有交叉编译工具，目标架构为Arm，设定各项默认配置为 nano 的spiflash支持版 make ARCH arm CROSS_COMPILE arm linux gnueabi f1c100s_nano_uboot_defconfig # 若不带spi flash的板子，请换成 licheepi_nano_defconfig # 进行可视化配置 make ARCH arm menuconfig ``` 若要在套餐中附带的LCD上输出显示，请通过配置 ARM architecture > Enable graphical uboot console on HDMI, LCD or VGA 为 **Y** 接着配置同级的 **LCD panel timing details** 为： **x:800,y:480,depth:18,pclk\\khz:33000,le:87,ri:40,up:31,lo:13,hs:1,vs:1,sync:3,vmode:0** 注：此块屏为为 800\\*480 规格，如为 480\\*272 请尝试如下配置: **x:480,y:272,depth:18,pclk\\khz:10000,le:42,ri:8,up:11,lo:4,hs:1,vs:1,sync:3,vmode:0** 并将 **LCD panel backlight pwm pin** 设为： PE6 （查自 Nano 原理图） ![LCD简单配置](./../static/get_started/LCD_set.png) ``` # 开始编译 make ARCH arm CROSS_COMPILE arm linux gnueabi j8 ``` 编译完成后，可一看到目录下多了一堆以u boot带头的文件，我们只需取 **u boot sunxi with spl.bin** 即可； ### 下载工具 sunxi tools 安装 在食用前，我们仍需要一个适配 Nano 的下载工具; ``` git clone b f1c100s spiflash https://github.com/Icenowy/sunxi tools.git cd sunxi tools make && sudo make install ``` 如果出现：`fel_lib.c:26:20: fatal error: libusb.h: No such file or directory`，那需要安装libusb： ``` sudo apt get install libusb 1.0 0 dev ``` 准备完软件，可以准备一下硬件:) 串口默认为 **UART0** ### 不插卡上电 新到的一片 Nano ，基本上是上电无反应的，LCD亮但无内容，此时 Nano 自动进入fel下载模式，可以通过命令 `sudo sunxi fel ver` 来确认有无成功进入fel模式。 此时有两种方式进行程序下载： 1.以 uboot file with spl形式进行（单次运行，测试时个人推荐） sunxi fel uboot /your/path/to/u boot sunxi with spl.bin 请自行修改到本机地址 2.烧进 spi flash （开机自启） sunxi fel p spiflash write 0 /your/path/to/u boot sunxi with spl.bin > note: 重新烧录或重进fel模式时，请在上电时拉低SPI flash 的 CS引脚 下载结束后，即可看到串口输出信息，LCD显示图标与简单信息。 此时在串口控制台（minicom、putty或其他）输入 `bdinfo` 将列出各种板子信息，如： arch_number 0x00000000 boot_params 0x80000100 DRAM bank 0x00000000 > start 0x80000000 > size 0x02000000 baudrate 115200 bps TLB addr 0x80FF0000 relocaddr 0x80F14000 reloc off 0xFF814000 irq_sp 0x80E09D90 sp start 0x80E09D80 FB base 0x81E89000 Early malloc usage: 118 / 400 fdt_blob 80e09da8 愉快地完成了 u boot 的初体验~ ## Xboot 初体验 xboot秉持一次编写到处运行的理念，集成各类驱动支持，支持lua虚拟机，是一款优秀的bootloader；xboot无需额外配置直接上手！ > 请到 [xboot](https://github.com/xboot) 下载README中给出的官方交叉编译器；请下载5.3.1版本，其5.3.0版本貌似不支持软浮点配置命令。 ``` git clone https://github.com/xboot/xboot.git cd xboot make CROSS_COMPILE /path/to/arm eabi PLATFORM arm32 f1c100s #请自行修改到本机地址 ``` 烧写到RAM中并运行 ``` sunxi fel spl xboot.bin sunxi fel p write 0x80000000 xboot.bin sunxi fel exec 0x80000000; ``` 或烧写到SPI Flash ``` sunxi fel p spiflash write 0 xboot.bin ``` ![](../static/get_started/xboot1.jpg) ``` _ _ _ _ ___ _____ _____ _ _ \\ \\/ / _ _ _ _ _ (C) 2007 2018 ) ( _ _ _ ____JIANJUN.JIANG__ /_/\\_\\_______________ _____________________ . . 此处为各类驱动加载成功的信息，此处略去 . . xboot: /$ ``` > 进入命令行后输入地址 /application/examples 将启动lua虚拟机运行Demo，可以算是xboot的酷炫小惊喜~ RTT 初体验 荔枝派 Nano 也得到了优秀国产物联网操作系统 **RT Thread** 的官方支持，有rtt相关知识或经验，我们就可以对 Nano 进行快速高效的开发； 首先我们来看 RT Thread 的目录结构: . ├── bsp // 板级支持包 │   ├── allwinner_tina // 荔枝派 Nano 板级支持 │   │   ├── applications // 用户应用程序 │   │   ├── drivers // 各类驱动 │   │   └── libcpu // cpu相关的一些操作，如进出中断等 │   │   └── rtconfig.py // scons编译配置 ├── components // 各类组件 包括C库、网络协议栈等 ├── documentation // 文档 ├── examples // 各类示例 ├── include // RTT库依赖 ├── libcpu // 各类cpu架构的支持 │   ├── arm │   │   ├── arm926 // Nano 所属架构 ├── src // 源码 └── tools // RTT工具 此处我们进行 RTT固件 的编译尝试； RTT官方已经给出由 [uestczyh222](mailto:lymz@foxmail.com) 所维护的 Nano固件[详细的编译、烧录过程](https://github.com/RT Thread/rt thread/blob/master/bsp/allwinner_tina/README.md)，搬运至此： ### 编译说明 环境 说明 PC操作系统 Linux/MacOS 编译器 arm none eabi gcc version 6.3.1 20170620 (release) 构建工具 scons 1) 下载源码 ``` git clone https://github.com/RT Thread/rt thread.git ``` 2) 配置工程并准备env ``` cd rt thread/bsp/allwinner_tina scons menuconfig source ~/.env/env.sh pkgs upgrade ``` 3 编译安装下载工具 ``` pushd /tmp git clone https://github.com/Icenowy/sunxi tools.git pushd sunxi tools git checkout b f1c100s origin/f1c100s make sudo make install popd popd ``` 4) 编译 scons 如果编译正确无误，会产生rtthread.elf、rtthread.bin文件。其中rtthread.bin需要烧写到设备中进行运行。 ### 烧写及执行 > **Note:**烧写工具目前仅支持Linux/MacOS环境,请在Linux/MaxOS环境下进行烧写操作 当正确编译产生出rtthread.bin映像文件后可以使用下面的方式来烧写到设备中。 #### 编译初始化引导文件 编译依赖 arm eabi gcc ``` pushd ../../.. git clone https://github.com/uestczyh222/tina spl.git pushd tina spl make cp output/f1c100s.bin ../rt thread/bsp/tina/tina spl.bin popd popd ``` #### 下载并运行 1. 短接 flash 1、4 脚(当flash中无可引导代码时无需此步骤) 2. 连接USB 3. 松开短接的引脚 4. 输入下列指令 ``` sudo sunxi fel p write 0x00000000 tina spl.bin sudo sunxi fel exec 0x00000000 sudo sunxi fel p write 0x80000000 rtthread.bin sudo sunxi fel exec 0x80000000 ``` #### 运行结果 如果编译 & 烧写无误，会在串口0上看到RT Thread的启动logo信息： \\ / RT Thread Operating System / \\ 3.0.2 build Feb 8 2018 2006 2017 Copyright by rt thread team periph_get_pll_clk:600000000 cpu_get_clk:408000000 ahb_get_clk:200000000 apb_get_clk:100000000 msh /> ## 开箱常见问题&结语 > 问题待收集... 如您有任何疑问，或有想要荔枝派提供某个方面的教程，请在[Sipeed社区](bbs.sipeed.com) 留言； 荔枝派3000人QQ交流大群：488268051 荔枝派Telegram电报群：[Lichee Pi](https://t.me/sipeed)"},"/soft/Lichee/zh/Nano-Doc-Backup/get_started/first_eye.html":{"title":"初见","content":"# 初见 ## 从硬件说起 荔枝派Nano（下面简称Nano）是一款精致迷你的 Arm9 核心板/开发板，可用于初学者学习linux或者商用于产品开发。 Nano 在与SD卡相当的尺寸上（25.4 * 33mm）提供了丰富的外设 （LCD,UART,SPI,I2C,PWM,SDIO,KEYADC...）和较为强劲的性能（24M\\~408MHz, 32MB DDR）。 Nano 延续并发展了Zero精巧的PCB设计，使得开发和使用非常方便： 1. 2.54mm排针直插面包板 2. 直插40P RGB LCD 3. 使用OTG口进行供电和数据传输(虚拟串口，更新固件等) 4. 可配合使用使用堆叠式的WiFi 模块联网 5. 可直接贴片 ### Nano 实物图 ![](./../static/get_started/nano.jpg) ### Nano 硬件参数 **硬件参数** CPU： 全志 F1C100s， ARM 926EJS , 最高 900MHz **内存：** 集成32MB DDR **存储：** 预留SOP8 SPI Flash焊盘（可定制贴片8\\~32MB SPI Nor Flash）; 板载 TF卡座，可TF启动。 **显示：** 通用 40P RGB LCD FPC座 可直插常见的40P 4.3/5/7寸屏幕（板载背光驱动），通过转接板可插50P 7/9寸屏 支持常见的272x480, 480x800, 1024x600等分辨率 板载电阻式触摸屏芯片，另配合底板可适配电容触摸屏 支持 720P 视频输出 支持 H.264 / MPEG 等视频流解码 **通信接口** SDIO，可搭配配套SDIO WiFi+BT 模块 SPI x2 TWI x3 UART x3 OTG USB x1 TV out **其它接口** PWM x2 LRADC x1 Speakerx2 + Mic x1 **电气特性** Micro USB 5V供电； 2.54mm 插针 3.3V\\~5V供电； 1.27mm 邮票孔供电 输出 3.3V ，可选择输入RTC电压 900MHz linux空载运行电流 54mA， 带屏运行电流 \\~250mA 存储温度 40\\~125℃，运行温度 20\\~70℃ **发热情况** ![运行linux压力测试时候的温度，仅稍高于体温，摸着温手不烫手](./../static/get_started/hot.jpeg) ### Nano 手册资料 #### 国内下载： [Nano 数据手册](https://dl.sipeed.com/shareURL/LICHEE/Nano/Document) [原理图](https://dl.sipeed.com/shareURL/LICHEE/Nano/Document) [百度云盘资料包](https://pan.baidu.com/s/1smzuGS9) [RT Thread SDK](https://github.com/RT Thread/rt thread) ### Nano 管脚定义 Nano 的管脚定义，可由下图简略说明： > 靠近 2.54mm 插针的两排，列出了其引脚功能与常见复用 > 中间两排，分别对应着两边 1.27mm 邮票空插针的引脚功能 ![Pin Map](./../static/lichee nano_1.jpg) 具体的引脚定义与可用重映射信息，还请参阅 [原理图](http://dl.sipeed.com/shareURL/LICHEE/Nano/Document) ## 说点软的 荔枝派 Nano 支持多个系统，可自由使用Linux、RT Thread、Xboot或裸机等进行操作。 ![linux 下运行 littlevgl Demo](./../static/get_started/TB29Aj_hH1YBuNjSszhXXcUsFXa_!!272610009.jpg) ![RT Thread UI示例](./../static/get_started/TB274cjbY3nBKNjSZFMXXaUSFXa_!!272610009.jpg) ![Xboot 示例](./../static/get_started/TB2D2Y7hH1YBuNjSszhXXcUsFXa_!!272610009.jpg) 荔枝派Nano 支持从SPI Flash中启动系统，便于降低成本，适宜商用开发。 ## 用到哪去 荔枝派Nano 的目标应用场景是： 使用较复杂的通信接口和协议的物联网应用 需要较美观，复杂逻辑的人机交互界面的应用 需要较多运算(相对于常用MCU)的应用场景 需要使用RTT、linux下的开源软件包进行快速开发的场景 高端极客玩家，在体积、性能、易用性 上取得平衡。 入门级玩家，软件工程师，使用熟悉的语言进行硬件diy。 ## 上手小说明 请在插拔 Micro USB 时尽量小心注意，建议您在到手后，向 USB母座的两个固定脚上堆锡 Nano 需要插卡启动（或者焊接spi flash），只插上 USB基本是无反应，屏幕无输出状态，但可在不插卡无 flash 状态下通过 USB 启动 U boot Nano 的系统调试串口是 UART0 ，即板子丝印上的的 “U0：Tx Rx” 标识的两个引脚 简单的可用性测试请参考 `下一节内容` ，需要您提前准备 1.一个 usb转ttl 的工具 2.焊好排针(可选) 3.接好串口 4.准备一根 Micro USB 数据线 随机附带了一小张二维码贴纸，扫一扫即可进入[本文档中心](https://wiki.sipeed.com/soft/Lichee/zh/Nano Doc Backup/index.html) ，您可将其贴于盒子表面或方便之处 如果您有什么疑问，请先翻阅一下对应文档下方的评论区，再联系我们或在评论区下记录您的疑惑，然后等待我们的回复；之后我们也会挑选出具有代表性的问题，在下一节汇总撰写这些问题的解决方法 如果收到板子后还有其他疑问，请在 **官方交流QQ群：488268051** 或 [Sipeed BBS](http://bbs.sipeed.com) 求助吐槽 ,在 [荔枝派Telegram电报群](https://t.me/sipeed) 讨论技术与获取资讯，感谢。"},"/soft/Lichee/zh/Nano-Doc-Backup/application/littlevgl.html":{"title":"LittlevGL 使用","content":"LittlevGL 使用 LittlevGL 简介 LittlevGL 是一个开源免费的GUI，支持触摸屏操作，移植简单方便，开发者一直在不断完善更新。LittlevGL 自带了丰富的控件：窗口、按键、标签、list、图表等，还可以自定义控件；支持很多特效：透明、阴影、自动显示隐藏滚动条、界面切换动画、图标打开关闭动画、平滑的拖拽控件、分层显示、反锯齿、仅耗少量内存的字体等等。 LittlevGL 常见于 MCU级别的设备，支持各类输入输出接口与芯片，支持使用GPU，以C编写，对于 Nano来说十分适合。 ![](https://littlevgl.com/home/main_cover.png) 具体的编写指导，请参考 [littlevGL官方文档](https://littlevgl.com/basics) LittlevGL 下载 建立LittlevGL工程文件夹，在此文件夹下进行以下操作: ``` git clone https://github.com/littlevgl/lvgl.git git clone https://github.com/littlevgl/lv_drivers.git git clone https://github.com/littlevgl/lv_examples.git ``` LittlevGL 工程配置 此处用到三个配置文件，分别是： > lvgl/lv\\_conf\\_templ.h > lv\\_drivers/lv\\_drv\\_conf\\_templ.h > lv\\_examples/lv\\_ex\\_conf\\_templ.h 将此三配置文件从模块文件夹中复制到项目文件夹，并将其命名为 > lv\\_conf.h > lv\\_drv\\_conf.h > lv\\_ex\\_conf.h 添加 main.c 文件 ``` #include \"lvgl/lvgl.h\" /* 添加 fb 支持 */ #include \"lv_drivers/display/fbdev.h\" int main(void) { /*LittlevGL init*/ lv_init(); /*Linux frame buffer device init*/ fbdev_init(); /*Add a display the LittlevGL sing the frame buffer driver*/ lv_disp_drv_t disp_drv; lv_disp_drv_init(&disp_drv); disp_drv.disp_flush fbdev_flush; /*It flushes the internal graphical buffer to the frame buffer*/ lv_disp_drv_register(&disp_drv); /* 选择示例启动 */ demo_create(); /*Handle LitlevGL tasks (tickless mode)*/ while(1) { lv_tick_inc(5); lv_task_handler(); usleep(5000); } return 0; } ``` 此时工程文件目录如下所示： ![](https://fdvad021asfd8q.oss cn hangzhou.aliyuncs.com/migrate/2018 04 09%2013 15 15%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png) LittlevGL 板级配置 ### lv\\_conf.h 首先在 lv\\_conf.h 中找到屏幕的定义，并进行修改； 此处修改为 800X480 或 480X272: ``` #define LV_HOR_RES (800) #define LV_VER_RES (480) ``` ### lv\\_drv\\_conf.h 再看到 lv\\_drv\\_conf.h，此文件中定义了输入输出设备的选择 main.c 中已经调用了 linux 下 framebuffer 设备，需要修改： `#define USE_FBDEV 1` 若有触摸屏，定义为从event0中解析触摸数据： `#define USE_EVDEV 1` ### lv\\_ex\\_conf.h 此配置文件定义你将要编译哪个应用示例： ``` #define USE_LV_BENCHMARK 0 #define USE_LV_DEMO 0 #define USE_LV_SYSMON 0 #define USE_LV_TERMINAL 0 #define USE_LV_TPCAL 0 ``` 选择一个示例，修改为 **1**; 对应的，我们要在 main.c 中进行修改，这里以demo作为示例： 1. 查看 lv\\_examples \\> lv\\_apps \\> demo \\> demo.c 2. 可以看到其创建函数为 **demo\\_creat()** 3. 修改 main.c 中 while(1)循环前的一句为 **demo\\_creat()** 配置完成。 ### 添加触屏支持 lv\\_drv\\_conf.h 中我们要先配置为从 event0 中读取数据； 此时要添加 event输入支持所需的结构体； ``` void demo_create(void) { lv_indev_drv_t indev_drv; lv_indev_drv_init(&indev_drv); /*Basic initialization*/ evdev_init(); indev_drv.type LV_INDEV_TYPE_POINTER; /*See below.*/ indev_drv.read evdev_read; /*See below.*/ lv_indev_drv_register(&indev_drv); /*Register the driver in LittlevGL*/ /*……………略……………*/ } ``` 其他配置或移植文档，请参考 [porting](https://littlevgl.com/porting) LittlevGL 编译 LittlevGL 示例程序需要自行编写Makefile或直接使用IDE自动寻找依赖关系进行编译； > Nano提供了docker镜像包，可通过docker直接使用cmake编译，编译具体步骤请看cmake部分； 笔者本处使用了Clion进行了交叉编译尝试，并附上仅使用cmake来进行编译的步骤； ### Clion 配置 Clion的安装配置本处不再赘述，此处描述交叉编译相关步骤 Clion配置工程后，会自动生成 **CMakeLists.txt** ,此文件为 cmake 编译配置文件(Clion使用了cmake来进行构建)； 修改此文件配置，使其使用交叉编译工具进行编译； ``` cmake_minimum_required(VERSION 3.10) # cmake 版本要高于或等于 3.10 project(Ui C) # 输出的二进制文件名 #set(CMAKE_C_STANDARD 11) # 注释掉原有的 SET(CROSS_COMPILE 1) # 设定交叉编译标志位 set(CMAKE_SYSTEM_NAME Linux) # 设定目标系统为 linux set(CMAKE_C_COMPILER \"/usr/bin/arm linux gnueabi gcc\") # 设定交叉编译链gcc所在位置 SET(TOOLCHAIN_DIR \"/usr/bin/\") # 设定交叉编译链目录 SET(CMAKE_FIND_ROOT_PATH \"/usr/arm linux gnueabi\" \"/usr/arm linux gnueabi/lib\" \"/usr/arm linux gnueabi/include\") # lib 与 include 的目录，使用 ``arm linux gnueabi gcc v`` 也可输出目录相关信息 link_directories(/home/biglion/project/buildroot/rootfs/lib) # 根文件系统的 lib (此处可参照cmake说明) # 依赖信息～略～ ``` 修改后，编译即可，可执行文件输出在 *cmake build debug* 文件夹下； ### Cmake 配置 若您在本地构建，请下载[CMakeLists.txt](https://fdvad021asfd8q.oss cn hangzhou.aliyuncs.com/migrate/CMakeLists.txt)并自行修改lib/include/编译链等目录,确认您的cmake版本高于或等于 3.10 (要从官网下载编译安装) 在docker镜像中，已配置好 cmake；只需修改 CMakeLists.txt 中，rootfs的 lib 的目录地址； >（比如先用 buildroot 构建好了根文件系统， > 1. rootfs.tar中包含了 lib ，可将rootfs.tar解压到某处或只取出lib > 再进行指定 > 2. 或者在 buildroot \\>output \\>target 目录下,也包含了lib） 只需： ``` cd xxx # 进入工程目录 mkdir build # 将生成信息等放进新建的目录，令目录结构更为清爽 cd build cmake .. # cmake 生成 makefile make # 执行编译 ``` 生成可执行二进制文件就在 build 文件夹下，将其放进tf卡的根文件系统所在位置下，运行即可。 也可使用 [pc\\_simulator](https://github.com/littlevgl/pc_simulator)进行效果预览； > 若在编译过程中有依赖缺失、函数未定义等情况，请自行寻找对应函数，并添加头文件: ) ### 隐藏屏幕log和指针 需要在uboot传入的参数中删去tty0输出和关闭指针，具体可参考*系统适配篇 uboot传递参数*章，具体命令如下 ```shell setenv bootargs console ttyS0,115200 panic 5 rootwait root /dev/mmcblk0p2 rw vt.global_cursor_default 0 ``` > **交流与答疑** > 对于本节内容，如有疑问，欢迎到 [GUI交流帖](http://bbs.lichee.pro/d/25 gui) 提问或分享经验。"},"/soft/Lichee/zh/Nano-Doc-Backup/application/blink.html":{"title":"一起来点灯","content":"一起来点灯 本文描述点灯的一种简易方法； 查询原理图可知，底板上的RGB LED灯，分别连接到： > 红 \\> PE6 > 蓝 \\> PE5 > 绿 \\> PE4 查询 User manual 并计算可知： > 端口 PE 的数据寄存器为 0x01C208a0 > 端口 PE 的控制寄存器为 0x01C20890 依此，借助devmem工具 可编写点灯脚本： ``` {.sourceCode .bash} #! /bin/bash # Some declare # 0x01C20890 > Pin control regesistor for Port E # 0x01C208a0 > Data regesister for Port E # devmem 0x01C20890 32 0x71117655 > 0x7???7655 红 蓝 绿 > PE6 PE5 PE4 # 本处操作的是 控制寄存器来控制开关，可改为 操作数据寄存器 控制LED开关 # End of declare devmem 0x01C208a0 32 0x00000004 trap 'onCtrlC' INT # 退出时的控制台输出 function onCtrlC () { devmem 0x01C208a0 32 0x00000074 echo ' ' echo 'Blink will at the end' exit } sleep 0.5 devmem 0x01C20890 32 0x77777655 # 关闭各端口 while true # 跑马灯开启 do devmem 0x01C20890 32 0x71177655 sleep 0.5 devmem 0x01C20890 32 0x77117655 sleep 0.5 devmem 0x01C20890 32 0x71717655 sleep 0.5 devmem 0x01C20890 32 0x71177655 sleep 0.5 devmem 0x01C20890 32 0x71717655 sleep 0.5 devmem 0x01C20890 32 0x77117655 sleep 0.5 done ``` > **交流与答疑** > > 欢迎到 [模组使用交流帖](http://bbs.lichee.pro/d/24 ) 提问或分享经验。"},"/soft/Lichee/zh/Nano-Doc-Backup/build_sys/kernel.html":{"title":"主线Linux编译","content":"# 主线Linux编译 ## 源码下载 完整下载命令为： git clone https://gitee.com/LicheePiNano/Linux.git git拉取有时速度很慢，建议做如下配置： 完整拉取linux极大，建议只拉取单层分支，减少等待时间： git clone depth 1 b master https://gitee.com/LicheePiNano/Linux.git ## 配置 使用./arch/arm/configs/f1c100s_nano_linux_defconfig配置文件 \tmake ARCH arm f1c100s_nano_linux_defconfig ## 进行编译 > 编译工具链为 arm linux gnueabi，工具链的安装请参考 uboot 编译部分 ``` make ARCH arm CROSS_COMPILE arm linux gnueabi j8\t#请自行修改编译线程数 make ARCH arm CROSS_COMPILE arm linux gnueabi j8 INSTALL_MOD_PATH out modules\t#请自行修改编译线程数 make ARCH arm CROSS_COMPILE arm linux gnueabi j8 INSTALL_MOD_PATH out modules_install\t#请自行修改编译线程数 ``` 编译成功后，生成文件所在位置： + 内核img文件：./arch/arm/boot/zImage + 设备树dtb文件:./arch/arm/boot/dts/suniv f1c100s licheepi nano.dtb + modules文件夹：./out/lib/modules 将zImage与dtb文件放入nano第一分区．"},"/soft/Lichee/zh/Nano-Doc-Backup/build_sys/build_flash_copy.html":{"title":"spi_flash编译","content":"# spi_flash编译 ## 创建工作文件夹 ``` mkdir ~/LicheePi_Nano cd ~/LicheePi_Nano ``` ## 安装交叉编译链 此处为获取7.2.1版本，您可获取其他版本或者通过链接直接下载 ``` wget http://releases.linaro.org/components/toolchain/binaries/7.2 2017.11/arm linux gnueabi/gcc linaro 7.2.1 2017.11 x86_64_arm linux gnueabi.tar.xz tar vxJf gcc linaro 7.2.1 2017.11 x86_64_arm linux gnueabi.tar.xz sudo cp r ./gcc linaro 7.2.1 2017.11 x86_64_arm linux gnueabi /opt/ sudo vim /etc/bash.bashrc ``` 在文件末尾 添加以下内容 PATH \"$PATH:/opt/gcc linaro 7.2.1 2017.11 x86_64_arm linux gnueabi/bin\" 使路径生效 source /etc/bash.bashrc 此时可用 arm linux gnueabi gcc v 进行测试；若普通用户状态下没有成功，通过 sudo su 切换到root用户再尝试； ## 安装必要的库 ``` sudo apt get install build essential subversion git core libncurses5 dev zlib1g dev gawk flex quilt libssl dev xsltproc libxml parser perl mercurial bzr ecj cvs unzip lib32z1 lib32ncurses5 lib32bz2 1.0 y sudo apt get install vim flex bison texinfo u boot tools lib32stdc++6 y sudo apt get install libusb 1.0 0 dev sudo apt get install mtd utils ``` ## 安装sunxi tools下载工具 获取源码 git clone https://gitee.com/LicheePiNano/sunxi tools.git 查看分支 ``` cd sunxi tools git branch a ``` 切换到 Nano 分支 git checkout f1c100s spiflash ## 编译并安装工具 make && sudo make install ## 编译UBOOT ### UBOOT下载 ``` cd ~/LicheePi_Nano git clone b nano lcd800480 https://gitee.com/LicheePiNano/u boot.git cd ~/LicheePi_Nano/u boot ``` ### UBOOT编译 ``` make ARCH arm f1c100s_nano_uboot_defconfig make ARCH arm CROSS_COMPILE arm linux gnueabi j8 ``` ## 编译Linux ### Linux下载 ``` cd ~/LicheePi_Nano git clone https://gitee.com/LicheePiNano/Linux.git cd ~/LicheePi_Nano/Linux ``` ### Linux编译 ``` make ARCH arm f1c100s_nano_linux_defconfig make ARCH arm CROSS_COMPILE arm linux gnueabi j8 make ARCH arm CROSS_COMPILE arm linux gnueabi j16 INSTALL_MOD_PATH out modules make ARCH arm CROSS_COMPILE arm linux gnueabi j16 INSTALL_MOD_PATH out modules_install ``` ## 编译Buildroot ### Buildroot下载 ``` cd ~/LicheePi_Nano wget https://buildroot.org/downloads/buildroot 2021.02.4.tar.gz tar xvf buildroot 2021.02.4.tar.gz cd ~/LicheePi_Nano/buildroot 2021.02.4 ``` ### Buildroot安装依赖 sudo apt get install linux headers $(uname r) ### Buildroot编译 make menuconfig ### Buildroot配置 ``` Target options Target Architecture (ARM (little endian)) Target Variant arm926t Toolchain C library (musl) # 使用musl减小最终体积 System configuration Use syslinks to /usr .... # 启用/bin, /sbin, /lib的链接 Enable root login # 启用root登录 Run a getty after boot # 启用登录密码输入窗口 make ``` ## 制作烧录镜像 下载脚本[nano_flash_dd.sh](https://dl.sipeed.com/shareURL/LICHEE/Nano/SDK) 更改脚本权限 ``` sudo su chmod +x nano_flash_dd.sh ``` 启动脚本 ./nano_flash_dd.sh 执行烧录 sudo sunxi fel p spiflash write 0 flashimg.bin"},"/soft/Lichee/zh/Nano-Doc-Backup/build_sys/bootargs.html":{"title":"uboot传递参数","content":"# uboot传递参数 ## 再探 Uboot 首先进入 uboot，控制台输入 `printenv` ，可看到控制台输出以下信息： arch arm baudrate 115200 board sunxi board_name sunxi 略去一些信息 boot_scripts boot.scr.uimg boot.scr bootcmd run distro_bootcmd cpu arm926ejs 通过此命令我们可以看到 uboot 自动配置了一些启动命令与参数，其中变量boot_scripts 指定了启动时要加载哪个命令文本文件，依据此处，我们进行boot.scr 的构建； ## 建立 boot.cmd 并确认参数 boot.scr 由 boot.cmd 生成，此处新建一个 boot.cmd 文件，并写入以下内容： ``` setenv bootargs console tty0 console ttyS0,115200 panic 5 rootwait root /dev/mmcblk0p2 rw load mmc 0:1 0x80C00000 suniv f1c100s licheepi nano.dtb load mmc 0:1 0x80008000 zImage bootz 0x80008000 0x80C00000 ``` 第一行setenv命令，设定了变量bootargs(启动参数)为：通过tty0和ttyS0串口输出启动信息；启动失败延迟5秒重启，根文件在TF卡的第二分区，可读写； 第二行指定了从TF中将设备树的dtb文件加载到0x80C00000的位置(地址参考自官方SDK) 第三行指定了将压缩后的内核zImage加载到0x80008000的位置 第四行为从加载地址启动内核的命令 ## 生成 boot.scr uboot > tools >mkimage ，通过该程序生成boot.scr 为使用方便，建议将其： cp ./mkimage /usr/local/bin/mkimage 生成 boot.scr mkimage C none A arm T script d boot.cmd boot.scr 最后将其放入第一分区 > **交流与答疑:** 对于本节内容，如有疑问，欢迎到 [Bootloader 与 RTOS使用交流帖](http://bbs.lichee.pro/d/21 bootloader rtos)提问或分享经验。"},"/soft/Lichee/zh/Nano-Doc-Backup/build_sys/rootfs.html":{"title":"根文件系统编译","content":"根文件系统编译 使用buildroot构建根文件系统 buildroot可用于构建小型的linux根文件系统。 大小最小可低至2M，与内核一起可以放入最小8M的spi flash中。 buildroot中可以方便地加入第三方软件包（其实已经内置了很多），省去了手工交叉编译的烦恼。 ### 下载安装 首先安装一些依赖，比如linux头文件： > `apt get install linux headers $(uname r)` 然后下载安装： ``` wget https://buildroot.org/downloads/buildroot 2021.02.4.tar.gz tar xvf buildroot 2021.02.4.tar.gz cd buildroot 2021.02.4/ make menuconfig ``` ### 配置 ``` make menuconfig 以下选项为基础配置： Target options Target Architecture (ARM (little endian)) Target Variant arm926t Toolchain C library (musl) # 使用musl减小最终体积 System configuration Use syslinks to /usr .... # 启用/bin, /sbin, /lib的链接 Enable root login # 启用root登录 Run a getty after boot # 启用登录密码输入窗口 (licheepi) Root password #　默认账户为root 密码为licheepi 另可自行添加或删除指定的软件包 ``` #### 一些配置的简单说明 Target options > Target Architecture Variant (arm926t) > // arm926ejs架构 [ ] Enable VFP extension support // Nano 没有 VFP单元，勾选会导致某些应用无法运行 Target ABI (EABI) > Floating point strategy (Soft float) > // 软浮点 System configuration > (Lichee Pi) System hostname // hostname (licheepi) Root password // 默认账户为root 密码为licheepi [*] remount root filesystem read write during boot // 启动时重新挂在文件系统使其可读写 ### 编译 make >有时候构建会出现莫名其妙的错误，make clean下会ok？ 编译的过程如果带上下载软件包的时间比较漫长，很适合喝杯茶睡个午觉；(buildroot不能进行多线程编译) 编译完成的镜像包，是 buildroot 2021.02.4/output/images/rootfs.tar ### 安装到第二分区 将镜像包复制到第二分区后，解压即可 ``` # 请修改设备号 sudo umount /dev/sdX2 sudo mount /dev/sdX2 /mnt sudo cp ./rootfs.tar /mnt/ sudo tar xf /mnt/rootfs.tar sudo rm /mnt/rootfs.tar sync sudo umount /dev/sdX2 ``` 另：检查 rootfs文件下的 /etc/inittab 是否已有以下声明： > `ttyS0::respawn:/sbin/getty L ttyS0 115200 vt100 # GENERIC_SERIAL // 串口登录使能` > **交流与答疑** > 对于本节内容，如有疑问，欢迎到[根文件系统编译交流帖](http://bbs.lichee.pro/d/27 ) 提问或分享经验。"},"/soft/Lichee/zh/Nano-Doc-Backup/build_sys/build_flash.html":{"title":"spi-flash 启动适配","content":"# spi flash 启动适配 对于从spi flash启动系统，需要对 uboot / dts /内核配置都有所修改，打包与烧写请参考[一键烧录及脚本使用说明](./onekey.html) 以下将以16M flash为例，介绍 spi flash 的适配过程。 ## 分区规划 下表为分区规划表： 分区序号分区大小分区作用地址空间及分区名 mtd0 1MB (0x100000) spl+uboot 0x0000000 0x0100000 : “uboot” mtd1 64KB (0x10000) dtb文件 0x0100000 0x0110000 : “dtb” mtd2 4MB (0x400000) linux内核 0x0110000 0x0510000 : “kernel” mtd3 剩余 (0xAF0000) 根文件系统 0x0510000 0x1000000 : “rootfs” ## uboot 修改 以下是对 uboot 进行适配的流程描述； ### bootcmd修改 在uboot源码目录下 进入 ./include/configs/ ``` #define CONFIG_BOOTCOMMAND \"sf probe 0:50000000; \" \\ \"sf read 0x80C00000 0x100000 0x4000; \" \\ \"sf read 0x80008000 0x110000 0x400000; \" \\ \"bootz 0x80008000 0x80C00000\" ``` 按照行数解释如下： > 1. 挂载 spi flash > 2. 读取 spi flash 1M（0x100000）位置 64KB(0x4000)大小的 dtb 到地址 > 0x80C00000 > 3. 读取 spi flash 1M+64K（0x110000）位置 4MB(0x400000)大小的 zImage > 到地址 0x80008000 > 4. 从 0x80008000 启动内核，从 0x80C00000 读取设备树配置 回到 uboot 源码一级目录，`make ARCH arm menuconfig` 进入TUI配置； 取消勾选 *[ ] Enable a default value for bootcmd* ### bootargs修改 勾选 *[\\*] Enable boot arguments；* 在下方一项中填入 bootargs 参数: console ttyS0,115200 panic 5 rootwait root /dev/mtdblock3 rw rootfstype jffs2 (root /dev/mtdblock3 指的是mtd设备第三分区，分区指定在dts中声明) ### dts 修改 修改内核源码目录下的 ./arch/arm/boot/dts/suniv f1c100s licheepi nano.dts ``` &spi0 { pinctrl names \"default\"; pinctrl 0 <&spi0_pins_a>; status \"okay\"; spi max frequency <50000000>; flash: w25q128@0 { #address cells <1>; #size cells <1>; compatible \"winbond,xt25f128b\", \"jedec,spi nor\"; reg <0>; spi max frequency <50000000>; partitions { compatible \"fixed partitions\"; #address cells <1>; #size cells <1>; partition@0 { label \"u boot\"; reg <0x000000 0x100000>; read only; }; partition@100000 { label \"dtb\"; reg <0x100000 0x10000>; read only; }; partition@110000 { label \"kernel\"; reg <0x110000 0x400000>; read only; }; partition@510000 { label \"rootfs\"; reg <0x510000 0xAF0000>; }; }; }; }; ``` 此处在dts中为mtd设备预先划分好了分区内容，内核将会自动解析 另一种通过bootargs传递给内核进行解析分区信息的方法，请参考 [Lichee Zerospi flash启动](http://zero.lichee.pro/%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/SPI_flash_build.html#id4) 内核配置修改 勾选 File systems ‣ Miscellaneous filesystems ‣ Journalling Flash File System v2 (JFFS2) support ![jffs2](https://box.kancloud.cn/3be64c60667c0aa3a906f095171d1fda_1396x746.png) 修改源码下的 ./drivers/mtd/spi nor.c \t添加对应spi flash；如 xt25f128b : ``` static const struct flash_info spi_nor_ids[] { \t... \t{ \"w25q128\", INFO(0xef4018, 0, 64 * 1024, 256, SECT_4K) },\t//在此行后添加 \t{ \"xt25f128b\", INFO(0x0bf4018, 0, 64 * 1024, 256, 0) },\t//添加新spi flash \t... } ``` ## 二进制bin 打包 以16M 大小flash镜像打包脚本为例： ``` #!/bin/sh UBOOT_FILE ./u boot/u boot sunxi with spl.bin DTB_FILE ./Linux/arch/arm/boot/dts/suniv f1c100s licheepi nano.dtb KERNEL_FILE ./Linux/arch/arm/boot/zImage ROOTFS_FILE ./buildroot 2021.02.4/output/images/rootfs.tar MOD_FILE ./Linux/out/lib/modules/4.15.0 rc8 licheepi nano+ dd if /dev/zero of flashimg.bin bs 1M count 16 &&\\ dd if $UBOOT_FILE of flashimg.bin bs 1K conv notrunc &&\\ dd if $DTB_FILE of flashimg.bin bs 1K seek 1024 conv notrunc &&\\ dd if $KERNEL_FILE of flashimg.bin bs 1K seek 1088 conv notrunc &&\\ mkdir rootfs tar xvf $ROOTFS_FILE C ./rootfs &&\\ cp r $MOD_FILE rootfs/lib/modules/ &&\\ #为根文件系统制作jffs2镜像包 # pad参数指定 jffs2大小 #由此计算得到 0x1000000(16M) 0x10000(64K) 0x100000(1M) 0x400000(4M) 0xAF0000 mkfs.jffs2 s 0x100 e 0x10000 pad 0xAF0000 d rootfs/ o jffs2.img &&\\ dd if jffs2.img of flashimg.bin bs 1K seek 5184 conv notrunc &&\\ rm rf rootfs &&\\ rm jffs2.img ``` 以上脚本通过对一个生成的16M空bin文件填充 uboot、dtb、kernel、rootfs 生成 16M 镜像，如需修改，请注意各个文件的大小，修改成对应地址（注意对齐）。 至此，SPI系统各部分已编译完成，通过sunxi fel进行烧写即可； ## bin 烧录 sudo sunxi fel p spiflash write 0 $YOUR_IMG_FILE 或请参考镜像包中的 write\\_flash.sh 烧录脚本； 启动后使用 账号：root 密码：licheepi 登录 > **交流与答疑** > 对于本节内容，如有疑问，欢迎到 [SPI Flash系统编译交流帖](http://bbs.lichee.pro/d/31 spi flash) 提问或分享经验。 ## 附录 1.启动日志 ``` U Boot 2018.01 05688 ga9729b3241 (Aug 18 2021 11:38:59 +0800) Allwinner Technology CPU: Allwinner F Series (SUNIV) Model: Lichee Pi Nano DRAM: 32 MiB MMC: SUNXI SD/MMC: 0 SF: Detected xt25f128b with page size 256 Bytes, erase size 4 KiB, total 16 MiB *** Warning bad CRC, using default environment Setting up a 800x480 lcd console (overscan 0x0) In: serial@1c25000 Out: serial@1c25000 Err: serial@1c25000 Net: No ethernet found. starting USB... No controllers found Hit any key to stop autoboot: 0 SF: Detected xt25f128b with page size 256 Bytes, erase size 4 KiB, total 16 MiB device 0 offset 0x100000, size 0x4000 SF: 16384 bytes @ 0x100000 Read: OK device 0 offset 0x110000, size 0x400000 SF: 4194304 bytes @ 0x110000 Read: OK ## Flattened Device Tree blob at 80c00000 Booting using the fdt blob at 0x80c00000 Loading Device Tree to 80e03000, end 80e07f36 ... OK Starting kernel ... [ 0.000000] Booting Linux on physical CPU 0x0 [ 0.000000] Linux version 4.15.0 rc8 licheepi nano+ (wangxi@ThinkPad X1 Carbon 6th) (gcc version 7.2.1 20171011 (Linaro GCC 7.2 2017.11)) #1 Tue Aug 17 19:20:35 CST 2021 [ 0.000000] CPU: ARM926EJ S [41069265] revision 5 (ARMv5TEJ), cr 0005317f [ 0.000000] CPU: VIVT data cache, VIVT instruction cache [ 0.000000] OF: fdt: Machine model: Lichee Pi Nano [ 0.000000] Memory policy: Data cache writeback [ 0.000000] random: fast init done [ 0.000000] Built 1 zonelists, mobility grouping on. Total pages: 8128 [ 0.000000] Kernel command line: console ttyS0,115200 panic 5 rootwait root /dev/mtdblock3 rw rootfstype jffs2 [ 0.000000] Dentry cache hash table entries: 4096 (order: 2, 16384 bytes) [ 0.000000] Inode cache hash table entries: 2048 (order: 1, 8192 bytes) [ 0.000000] Memory: 22688K/32768K available (6144K kernel code, 234K rwdata, 1344K rodata, 1024K init, 233K bss, 10080K reserved, 0K cma reserved, 0K highmem) [ 0.000000] Virtual kernel memory layout: [ 0.000000] vector : 0xffff0000 0xffff1000 ( 4 kB) [ 0.000000] fixmap : 0xffc00000 0xfff00000 (3072 kB) [ 0.000000] vmalloc : 0xc2800000 0xff800000 ( 976 MB) [ 0.000000] lowmem : 0xc0000000 0xc2000000 ( 32 MB) [ 0.000000] pkmap : 0xbfe00000 0xc0000000 ( 2 MB) [ 0.000000] modules : 0xbf000000 0xbfe00000 ( 14 MB) [ 0.000000] .text : 0x(ptrval) 0x(ptrval) (7136 kB) [ 0.000000] .init : 0x(ptrval) 0x(ptrval) (1024 kB) [ 0.000000] .data : 0x(ptrval) 0x(ptrval) ( 235 kB) [ 0.000000] .bss : 0x(ptrval) 0x(ptrval) ( 234 kB) [ 0.000000] SLUB: HWalign 32, Order 0 3, MinObjects 0, CPUs 1, Nodes 1 [ 0.000000] NR_IRQS: 16, nr_irqs: 16, preallocated irqs: 16 [ 0.000051] sched_clock: 32 bits at 24MHz, resolution 41ns, wraps every 89478484971ns [ 0.000120] clocksource: timer: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 79635851949 ns [ 0.000748] Console: colour dummy device 80x30 [ 0.000841] Calibrating delay loop... 203.16 BogoMIPS (lpj 1015808) [ 0.070249] pid_max: default: 32768 minimum: 301 [ 0.070574] Mount cache hash table entries: 1024 (order: 0, 4096 bytes) [ 0.070619] Mountpoint cache hash table entries: 1024 (order: 0, 4096 bytes) [ 0.072204] CPU: Testing write buffer coherency: ok [ 0.074118] Setting up static identity map for 0x80100000 0x80100058 [ 0.076819] devtmpfs: initialized [ 0.083560] clocksource: jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 19112604462750000 ns [ 0.083641] futex hash table entries: 256 (order: 1, 3072 bytes) [ 0.083927] pinctrl core: initialized pinctrl subsystem [ 0.086209] NET: Registered protocol family 16 [ 0.088156] DMA: preallocated 256 KiB pool for atomic coherent allocations [ 0.090104] cpuidle: using governor menu [ 0.114953] SCSI subsystem initialized [ 0.115342] usbcore: registered new interface driver usbfs [ 0.115497] usbcore: registered new interface driver hub [ 0.115726] usbcore: registered new device driver usb [ 0.116195] pps_core: LinuxPPS API ver. 1 registered [ 0.116226] pps_core: Software ver. 5.3.6 Copyright 2005 2007 Rodolfo Giometti <giometti@linux.it> [ 0.116296] PTP clock support registered [ 0.116864] Advanced Linux Sound Architecture Driver Initialized. [ 0.118475] clocksource: Switched to clocksource timer [ 0.147854] NET: Registered protocol family 2 [ 0.149563] TCP established hash table entries: 1024 (order: 0, 4096 bytes) [ 0.149647] TCP bind hash table entries: 1024 (order: 0, 4096 bytes) [ 0.149697] TCP: Hash tables configured (established 1024 bind 1024) [ 0.150083] UDP hash table entries: 256 (order: 0, 4096 bytes) [ 0.150159] UDP Lite hash table entries: 256 (order: 0, 4096 bytes) [ 0.150699] NET: Registered protocol family 1 [ 0.152849] NetWinder Floating Point Emulator V0.97 (double precision) [ 0.154808] Initialise system trusted keyrings [ 0.155331] workingset: timestamp_bits 30 max_order 13 bucket_order 0 [ 0.171845] jffs2: version 2.2. (NAND) (SUMMARY) © 2001 2006 Red Hat, Inc. [ 0.187710] Key type asymmetric registered [ 0.187756] Asymmetric key parser 'x509' registered [ 0.187980] Block layer SCSI generic (bsg) driver version 0.4 loaded (major 251) [ 0.188019] io scheduler noop registered [ 0.188037] io scheduler deadline registered [ 0.189023] io scheduler cfq registered (default) [ 0.189066] io scheduler mq deadline registered [ 0.189086] io scheduler kyber registered [ 0.190307] sun4i usb phy 1c13400.phy: Couldn't request ID GPIO [ 0.200698] suniv pinctrl 1c20800.pinctrl: initialized sunXi PIO driver [ 0.389750] Serial: 8250/16550 driver, 8 ports, IRQ sharing disabled [ 0.396809] console [ttyS0] disabled [ 0.417093] 1c25000.serial: ttyS0 at MMIO 0x1c25000 (irq 23, base_baud 6250000) is a 16550A [ 0.858241] console [ttyS0] enabled [ 0.869124] panel simple panel: panel supply power not found, using dummy regulator [ 0.900331] loop: module loaded [ 0.904340] SCSI Media Changer driver v0.25 [ 0.912459] m25p80 spi0.0: xt25f128b (16384 Kbytes) [ 0.917422] 4 ofpart partitions found on MTD device spi0.0 [ 0.923010] Creating 4 MTD partitions on \"spi0.0\": [ 0.927858] 0x000000000000 0x000000100000 : \"u boot\" [ 0.935841] 0x000000100000 0x000000110000 : \"dtb\" [ 0.943424] 0x000000110000 0x000000510000 : \"kernel\" [ 0.951257] 0x000000510000 0x000001000000 : \"rootfs\" [ 0.959588] ehci_hcd: USB 2.0 'Enhanced' Host Controller (EHCI) Driver [ 0.966129] ehci platform: EHCI generic platform driver [ 0.971774] ohci_hcd: USB 1.1 'Open' Host Controller (OHCI) Driver [ 0.978008] ohci platform: OHCI generic platform driver [ 0.983744] usbcore: registered new interface driver usb storage [ 0.990886] udc core: couldn't find an available UDC added [g_cdc] to list of pending drivers [ 1.000090] i2c /dev entries driver [ 1.058608] sunxi mmc 1c0f000.mmc: base:0x5e6e6c4f irq:19 [ 1.066298] usbcore: registered new interface driver usbhid [ 1.072015] usbhid: USB HID core driver [ 1.095111] NET: Registered protocol family 17 [ 1.099787] Key type dns_resolver registered [ 1.106510] Loading compiled in X.509 certificates [ 1.123050] sun4i drm display engine: bound 1e60000.display backend (ops 0xc0736c58) [ 1.131937] sun4i drm display engine: bound 1c0c000.lcd controller (ops 0xc0735f3c) [ 1.139747] [drm] Supports vblank timestamp caching Rev 2 (21.10.2013). [ 1.146355] [drm] No driver support for vblank timestamp query. [ 1.284852] Console: switching to colour frame buffer device 100x30 [ 1.324570] sun4i drm display engine: fb0: frame buffer device [ 1.331720] [drm] Initialized sun4i drm 1.0.0 20150629 for display engine on minor 0 [ 1.340961] usb_phy_generic usb_phy_generic.0.auto: usb_phy_generic.0.auto supply vcc not found, using dummy regulator [ 1.353037] musb hdrc musb hdrc.1.auto: MUSB HDRC host driver [ 1.358971] musb hdrc musb hdrc.1.auto: new USB bus registered, assigned bus number 1 [ 1.369307] hub 1 0:1.0: USB hub found [ 1.373247] hub 1 0:1.0: 1 port detected [ 1.378985] using random self ethernet address [ 1.383523] using random host ethernet address [ 1.389924] usb0: HOST MAC 22:8a:8d:91:11:6e [ 1.394315] usb0: MAC ea:69:6d:6e:87:be [ 1.398306] g_cdc gadget: CDC Composite Gadget, version: King Kamehameha Day 2008 [ 1.405900] g_cdc gadget: g_cdc ready [ 1.410628] cfg80211: Loading compiled in X.509 certificates for regulatory database [ 1.428340] cfg80211: Loaded X.509 cert 'sforshee: 00b28ddf47aef9cea7' [ 1.435272] vcc3v3: disabling [ 1.438260] ALSA device list: [ 1.441317] #0: Loopback 1 [ 1.445124] platform regulatory.0: Direct firmware load for regulatory.db failed with error 2 [ 1.453883] cfg80211: failed to load regulatory.db [ 1.562738] random: crng init done [ 2.123045] jffs2: notice: (1) jffs2_build_xattr_subsystem: complete building xattr subsystem, 0 of xdatum (0 unchecked, 0 orphan) and 0 of xref (0 dead, 0 orphan) found. [ 2.143057] VFS: Mounted root (jffs2 filesystem) on device 31:3. [ 2.151702] devtmpfs: mounted [ 2.161730] Freeing unused kernel memory: 1024K Starting syslogd: OK Starting klogd: OK Running sysctl: OK Initializing random number generator: OK Saving random seed: OK Starting network: OK Welcome to Buildroot buildroot login: ```"},"/soft/Lichee/zh/Nano-Doc-Backup/build_sys/build_index.html":{"title":"TF卡分区","content":"# TF卡分区 本章主要描述内核与根文件系统的构建； ## 在TF卡上构建系统 在前文我们已经成功构建了 bootloader，我们接下来需要放进TF卡的内容有： 第一分区： boot.scr zImage suniv f1c100s licheepi nano.dtb 第二分区： 根文件系统内容 在TF卡上构建系统之前，我们需要将TF卡进行分区与格式化； ``` sudo fdisk l # 首先查看电脑上已插入的TF卡的设备号 sudo umount /dev/sdXx # 若自动挂载了TF设备，请先卸载 sudo fdisk /dev/sdX # 进行分区操作 # 若已存分区即按 d 删除各个分区 # 通过 n 新建分区，第一分区暂且申请为32M(足够大了...)，剩下的空间都给第二分区 # w 保存写入并退出 sudo mkfs.vfat /dev/sdX1 # 将第一分区格式化成FAT sudo mkfs.ext4 /dev/sdX2 # 将第一分区格式化成EXT4 ``` 具体分区操作，可参考github上的 [write_all.sh](https://github.com/Zepan/ilichee/tree/master/%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6/%E9%95%9C%E5%83%8F%E7%83%A7%E5%86%99) 脚本 > Nano一键快速烧录镜像包地址为：<https://pan.baidu.com/s/1smzuGS9> ，便于快速验证，无需分区操作 后文 [一键烧录及脚本使用说明](./onekey.html) 将对各部分内容的构建进行详细描述； > 对于本章内容，如有疑问，欢迎到 [荔枝派 Nano](http://bbs.lichee.pro/t/nano) 提问或分享经验。"},"/soft/Lichee/zh/Nano-Doc-Backup/build_sys/devicetree.html":{"title":"设备树添加节点","content":"设备树添加节点 Nano 设备树简介 Nano的设备树在源码的 linux \\> arch \\> arm \\> boot \\> dts \\> suniv f1c100s licheepi nano.dts； 该文件描述了各类外设的定义与配置，以下做简要描述； 其中由 / { ... } 包裹的为根节点，定义了各类总线、外设的配置； &xxx { ... } 所包裹的内容为引用，其定义来自于 suniv.dtsi (suniv系列设备通用的定义) compatible 属性，将与驱动源码中的 compatible 定义对应，进行识别选择； 设备树各部分的编写，可参考 linux \\> Documentation \\> devicetree \\> bindings 下各个模组 设备树整体的详细介绍，请参考 [Device\\_Tree](https://elinux.org/Device_Tree_Reference) ,[zero文档](http://zero.lichee.pro/%E9%A9%B1%E5%8A%A8/Device_Tree_Intro.html)中也有较为详细的描述； 修改设备树中 LCD 配置 当前默认的 LCD配置 为480X272大小的屏幕， “qiaodian,qd43003c0 40”, “simple panel” 若要修改为适配800X480的屏，此处应当： / { }所包裹的根节点目录下，panel属性下的compatible，应修改为： “lg,lb070wv8”, “simple panel” linux > drivers > gpu > drm > panel下有许多屏幕的配置，可挑选合适的进行配置； 添加底板上的 RGB LED 节点配置 / { } 所包裹的根节点目录下进行添加 ``` leds { compatible \"gpio leds\"; blue_led { label \"licheepi:blue:usr\"; gpios <&pio 4 4 GPIO_ACTIVE_LOW>; /* PE4 */ }; green_led { label \"licheepi:green:usr\"; gpios <&pio 4 5 GPIO_ACTIVE_LOW>; /* PE5 */ default state \"on\"; }; red_led { label \"licheepi:red:usr\"; gpios <&pio 5 6 GPIO_ACTIVE_LOW>; /* PE6 */ }; }; ``` 添加电容触摸屏的支持 电容触摸屏的控制芯片为GT911，使用I2C接口，我们要在设备树文件中添加定义； （笔者此处直接在 suniv.dtsi 内进行修改） ``` // 添加在soc节点下 // 此处添加的属性与配置，来自于查找用户手册以及兼容设备 i2c0: i2c@1C27000 { compatible \"allwinner,sun6i a31 i2c\"; reg <0x01C27000 0x400>; interrupts <7>; clocks <&ccu CLK_BUS_I2C0>; resets <&ccu RST_BUS_I2C0>; pinctrl names \"default\"; pinctrl 0 <&i2c0_pins>; status \"disabled\"; #address cells <1>; #size cells <0>; }; // 在pio节点下，添加i2c引脚定义 i2c0_pins: i2c0 { pins \"PE11\", \"PE12\"; function \"i2c0\"; }; ``` 在suniv f1c100s licheepi nano.dts中添加引用 ``` /* 首先要添加的头文件： */ #include <dt bindings/input/input.h> #include <dt bindings/interrupt controller/irq.h> /* 添加引用 */ &i2c0 { pinctrl 0 <&i2c0_pins>; pinctrl names \"default\"; status \"okay\"; gt911: touchscreen@14 { compatible \"goodix,gt911\"; reg <0x14>; interrupt parent <&pio>; interrupts <4 10 IRQ_TYPE_EDGE_FALLING>; /* (PE10) */ pinctrl names \"default\"; pinctrl 0 <&ts_reset_pin>; irq gpios <&pio 4 10 GPIO_ACTIVE_HIGH>; /* (PE10) */ reset gpios <&pio 4 9 GPIO_ACTIVE_HIGH>; /* RST (PE9) */ /* touchscreen swapped x y */ }; }; &pio { ts_reset_pin: ts_reset_pin@0 { pins \"PE9\"; function \"gpio_out\"; }; }; ``` 完成添加～若测试的触摸屏的xy方向颠倒，请添加或去掉gt911节点下的*touchscreen swapped x y* 属性。 编译生成 dtb文件 make ARCH arm CROSS_COMPILE arm linux gnueabi dtbs j4 生成的 dtb文件 在 dts同级目录下，将其放入 TF卡第一分区。"},"/soft/Lichee/zh/Nano-Doc-Backup/build_sys/docker.html":{"title":"Docker开发环境","content":"# Docker开发环境 ## docker安装 ### 什么是docker？ Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从Apache2.0协议开源。Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。本节只简单介绍docker开发环境的搭建，想要详细了解docker，可以查看“[Docker 命令速查](./../../Zero Doc/Start/docker_command.html)”。简而言之，我帮你搞好了docker镜像，你就不用自己再费力搭建啦。 ### docker下载安装 ``` sudo apt get install docker.io docker version ``` 安装成功后可见版本信息 ``` Client version: 1.6.2 Client API version: 1.18 Go version (client): go1.2.1 Git commit (client): 7c8fca2 OS/Arch (client): linux/amd64 FATA[0000] Get http:///var/run/docker.sock/v1.18/version: dial unix /var/run/docker.sock: permission denied. Are you trying to connect to a TLS enabled daemon without TLS? ``` 默认情况下会报后面的错误，如果使用sudo就不会报错。不想每次都sudo的话，可以把用户加入到docker组。 如果还没有 docker group 就添加一个(默认安装后已经有了) sudo groupadd docker 将用户加入该 group 内。然后退出并重新登录就生效啦。 sudo gpasswd a ${your_user_name} docker 重启 docker 服务 sudo service docker restart 切换当前会话到新 group, 或者关掉终端重新连接也会生效 newgrp docker ## 安装荔枝派开发镜像 可通过两种方式导入lichee nano编译环境镜像 ### 通过百度网盘下载并导入lichee nano编译环境镜像 首先通过百度网盘下载[docker镜像](https://pan.baidu.com/s/1aYcGfzyz g4CbxGSsVREGQ) ； 再将镜像加载到 docker： ``` gunzip nano.tar.gz docker import nano.tar ``` ### 通过docker官方仓库拉取lichee nano编译环境镜像 ``` docker pull zepan/licheepi nano:1.0.0 ``` ### 镜像使用 载入镜像后查看镜像ID docker images 通过 id 运行某个命令 docker run xxxx IMAGE ID xxx ls 后台运行 docker 并使用 ssh 去连接到镜像(6666端口) docker run d p 6666:22 xxxx IMAGE ID xxx /usr/sbin/sshd D 这样就安装并开启的容器ssh服务，只需连接主机的6666端口，以root用户，licheepi密码登录即可进行开发操作。 ssh p 6666 root@127.0.0.1 要停止该docker镜像时： ``` # 查看正在运行的容器 docker ps # 根据 容器ID 进行停止 docker stop xxx CONTAINER ID xxx ``` > **交流与答疑** > 对于本节内容，如有疑问，欢迎到 [Docker使用与配置交流帖](http://bbs.lichee.pro/d/23 docker) 提问或分享经验。"},"/soft/Lichee/zh/Nano-Doc-Backup/build_sys/onekey.html":{"title":"一键烧录及脚本使用说明","content":"# 一键烧录及脚本使用说明 材料准备： 内存卡+读卡器+荔枝派Nano+支持完整指令集的x86设备一台（电脑） 镜像下载地址： [https://pan.baidu.com/s/1smzuGS9](https://pan.baidu.com/s/1smzuGS9) ## 一键烧录镜像命名规则 xx_xxx_xxxx.* xx:适用此镜像的pi的名称 xxx:这个镜像是下载到什么介质上 xxxx:这个镜像适用于什么分辨率的LCD上 *:bin一般是下载到flash上的，dd代表这个镜像使用dd打包。 ## 一键烧录镜像(Linux环境 TF卡启动) 镜像包中的image文件夹下的dd文件，已包含了相应的Bootloader、Kernel、文件系统等等，只需简单两步即可完成烧录； 1. 插上tf卡后，命令行执行 `sudo fdisk l` 查看tf卡盘号； 2. 执行 `sudo dd if /path/to/your dd image of /your/tf card && sync` 即可完成烧录 我们所提供的dd一键镜像包为兼容低存储的tf卡，仅为根文件系统留下有限的空间，若您需要存储某些大文件，请参阅后文 [脚本使用](# 3) ## 一键烧录镜像(Linux环境 16M spi flash 启动) 在flash内容为空的情况下（fel模式下的一种情况）进行烧录时，通过micro usb数据线将Nano与电脑连接，执行 sudo sunxi fel p spiflash write 0 Your Flash BIN 若flash中已有系统，可通过： 1. 短接flash的 1、4 两脚，然后重新上电，上电后松开短接，即可重新进入fel模式，进行再次下载 2. 在启动到内核前，回车进入uboot，执行 `sf probe 0;sf erase 0 0x100000;reset`即可重新进入fel模式 ## 一键烧录镜像(win环境 TF卡启动) 使用软件 **win32disk** 进行一键烧录，可到 [此处](http://www.onlinedown.net/soft/110173.html) 下载; ## 脚本的使用 镜像包内build文件夹下脚本，可通过使用配置脚本设置环境变量，帮助您进行固件烧写img构建 ### 变量配置一次摸清 此处请注意两个脚本文件： configs 文件夹下的脚本文件（固件配置） 和 本目录下的 **env.sh**（公共环境配置） 首先来看 env.sh: 根据提示，前5个变量需要我们进行修改，分别是： _TOP_DIR 镜像包所在的一级目录 _KERNEL_MAINDIR 主线Linux源码所在目录 _UBOOT_DEVDIR Uboot源码所在目录 _BR_DEVDIR Buildroot所在目录 _CP_CMD 复制命令(默认为docker拉取) 再来看configs文件夹下的脚本文件 ： **env xxxxx.sh** 默认加载 env.sh 中的行动 _SCREEN_PRAM 选择屏幕大小版本（通过注释切换）（目前仅提供了480x272与800x480两种） _CASE_NAME 各类文件的前缀名 _BOOT_DEV 默认启动设备 _KERNEL_TYPE 内核类型（主线或bsp） _KERNEL_VER 内核版本号（menuconfig可见） _DT_NAME 设备树名称 _ROOTFS_TYPE 自我定义 _IMG_SIZE 生成的镜像大小（越大，根文件系统剩余空间越多） _UBOOT_SIZE 导入的Uboot大小 _CFG_SIZEKB config文件大小（其值大小、是否为0与内核版本有关） _P1_SIZE 给第一分区划分的大小（以 M 为单位） > note: + 您若仅需烧写，修改好公共环境变量，固件配置可保持不变； + 您若需要编写自己的配置文件，请通过修改上述变量进行适配； ### 正确使用姿势 1. 按照上一节所述进行环境变量的配置 2. 执行以下命令 ```bash cd configs source env xxxxx.sh # 生效环境变量 cd .. # 返回上级目录 ``` 3. 使用 **write_all.sh /dev/sdX** (sdX修改为tf设备号)，一键对tf卡进行全套写入。 4. 若使用的是从 spi flash 启动，则 **write_spiflash.sh** 即可将镜像写入16M flash 5. 生成镜像时使用 **pack_tf_img.sh** 生成tf镜像文件,**pack_flash_img.sh** 生成spi flash镜像文件。 ### 分区操作脚本 write_all.sh 为tf卡创建全套内容 write_flash.sh 为spi flash写入全套内容 write_dd.sh 以dd镜像的方式写入全套内容（规定了分区信息）（生成方式见下一节） write_boot.sh 向tf卡dd进Uboot write_mkfs.sh 单纯的为两个分区进行硬盘格式化 write_p1.sh 单纯的向第一分区写入设备树内核等 write_p2.sh 单纯的向第二分区写入rootfs clear_partion.sh 擦除分区表 write_partion.sh 写入分区表 write_swap.sh 增加swap ### 镜像生成 脚本 镜像生成最简单的方法是借助tf卡，手动或使用脚本向tf写入完结构，再dd出来，但手动生成较为琐碎且不灵活，所以我们在这里提供了脚本文件： **pack_tf_img.sh** 和 **pack_flash_img.sh**，能够判断镜像大小是否符合启动要求，且借助loop模拟创建设备，快速高效。 使用方法： **sh pack_tf_img.sh** 或 **sh pack_flash_img.sh** 即可生成的镜像在 ./image 目录下； ### docker环境下拉取资源到本地 当您在docker环境下已经成功构建相应的系统各组件，以下脚本可以帮助到您： pull_uboot.sh —— 从docker环境中拉取UBOOT到原生环境 pull_kernel.sh —— 从docker环境中拉取(主线)Kernel与构建好的驱动模块到原生环境 pull_br.sh —— 从docker环境中拉取rootfs与配置文件到原生环境 >交流与答疑 >对于本节内容，如有疑问，欢迎到 [社区](https://wiki.sipeed.com/community.html) 提问或分享经验。"},"/soft/Lichee/zh/Nano-Doc-Backup/index.html":{"title":"荔枝派Nano 全流程指南","content":"# 荔枝派Nano 全流程指南 荔枝派 Nano，开启你的极客之心。这是一款仅有2.54cm * 3.3cm大小的精致小板，相当于一张SD卡大小，只要您愿意，即可将一颗极客芯随身携带。 ![](./static/lichee nano.jpg) 荔枝派Nano以不可能的价格，提供了以下的外设： 3 X TWI 2 X SPI 3 X UART SDIO USB OTG JTAG KEYADC RTP IR OWA out 他还额外支持下面的功能： CSI Camera Full HD Video Engine（H.264,H.263,JPEG/MJPEG,etc.） RGB LCD Interface CVBS Input/Output Audio Codec I2S/PCM SD/eMMc 这都得益于荔枝派Nano的主芯片 全志F1C100s；Arm9架构，16KB D Cache，32KB I Cache，支持从SPI Flash或TF卡启动，支持USB OTG载入更新。 荔枝派 Nano 延续了前一代的巧妙设计，2.54mm普通插针焊孔+1.27mm邮票孔贴片设计，方便您自己动手DIY的同时，也支持贴片生产，制作更为复杂的应用。 ![Pin Map](./static/Nano_pin.png) 此外，荔枝派自从初代One以来，不断适配外设，已有TF Wifi、RGB to VGA、40 pin RGB、 LCD、RGB to GPIO、Camera等经过广泛实践验证过的成熟模块。 ![](./static/VGA.jpg) 荔枝派Nano 现可以利用TF卡槽拓展WiFi模块 ![](./static/WIFI.png) 荔枝派 Nano 现已获得RT Thread的官方支持，您可应用RT Thread丰富的生态资源，快速高效地进行原型设计。 荔枝派提倡开发者协同开发，即将推出有偿外设驱动适配任务，以及提供快餐式外包项目，欢迎各位技术大神为开发者们贡献技术力量！ 欢迎各位加入 [荔枝派交流群`712961164`](https://jq.qq.com/?_wv 1027&k 2ymSdiUL) [荔枝派Telegram电报群](https://t.me/sipeed) [荔枝派社区](http://bbs.sipeed.com) "},"/soft/Lichee/zh/Lichee-RV/contribution/Dual_screen_display/environment.html":{"title":"使用 WSL2 编译 LicheeRV Tina BSP","content":" title: 使用 WSL2 编译 LicheeRV Tina BSP > 编辑于2022年3月28日 [原文链接](http://www.gloomyghost.com/live/20220130.aspx) [原文作者空间](http://www.gloomyghost.com/) 原创时间: 2022年1月30日 下载WSL镜像：链接：https://pan.baidu.com/s/1geVQFcTpkoVgc HNcHuENw 提取码：di1l WIndows上准备好WSL环境以及WSL2相关补丁。导入WSL镜像。 ```bash wsl import <Distro> <InstallLocation> <FileName> ``` 例如将Tina开发环境导入到 D:\\VirtVM\\Tina_build 并命名为 TinaBuild ```bash wsl import TinaBuild D:\\VirtVM\\Tina_build Tina_WSL2.tar.gz ``` 将镜像转换为WSL2版本。 ```bash wsl set version TinaBuild 2 ``` 进入 Tina 开发环境 ```bash cd tina d1 open source build/envsetup.sh lunch ``` 镜像相关： ``` 用户名: tina 密码: tina ``` ![](./assets/enviroument.png)"},"/soft/Lichee/zh/Lichee-RV/contribution/Dual_screen_display/sipeed_D1_docker.html":{"title":"使用sipeed提供的docker","content":" title: 使用sipeed提供的docker > 编辑于2022年4月2日 本文讲解如何使用sipeed提供的docker镜像来编译D1 ## 获取镜像 国内用户：[百度网盘](https://pan.baidu.com/s/1QJTaDw6kkTM4c_GAlmG0hg) 提取码：wbef 国外用户：[Mega](https://mega.nz/folder/lx4CyZBA#PiFhY7oSVQ3gp2ZZ_AnwYA) 提供上述两种镜像的获取方式 ## 导入镜像 成功下载完镜像之后需要解压成tar格式，然后再docker中导入 ```bash gzip d licheerv_d1_compile.tar.gz #解压成tar文件 sudo docker import licheerv_d1_compile.tar licheerv_d1_compile:latest #docker导入镜像 ``` ## 启动docker镜像 ```bash sudo docker run it licheerv_d1_compile:latest /bin/bash # 交互模式启动D1镜像编译环境 login #切换用户，为了下面能够正常进行 make 指令 ``` 接着会让输入用户名和密码。 用户名为`nihao`，密码是`sipeed123`。 ## 结语 完成上面的操作之后就可以开始编译D1镜像了。 其中编译环境位于 ~/sdk/tina d1 open_new/ 目录下。 其他编译操作可以参考官方网页 [编译和烧写](https://d1.docs.aw ol.com/study/study_4compile/)"},"/soft/Lichee/zh/Lichee-RV/contribution/Dual_screen_display/Dual_screen_display.html":{"title":"使用 LicheeRV 86 Panel 与 Tina BSP 实现 RGB 与 SPI 双屏显示","content":" title: 使用 LicheeRV 86 Panel 与 Tina BSP 实现 RGB 与 SPI 双屏显示 keywords: LicheeRV, SPI, RISCV, D1 > 编辑于2022年3月28日 [原文链接](http://www.gloomyghost.com/live/20220131.aspx) [原文作者空间](http://www.gloomyghost.com/) 原创时间: 2022年1月31日 Tina 提供了2种 SPI TFT 显示屏的驱动方式。 第一种是官方推荐的 fbdev 方式，使用 Framebuffer implementaion without display hardware of AW 进行 SPI屏幕的驱动。 另外一种是使用 fbtft 进行 SPI 屏幕驱动。 fbdev 方式由于 pinctrl 在新内核中调用方式出现修改，所以暂时无法使用。修改难度较大。 fbtft 虽然官方wiki表明不建议在 Linux 5.4 中使用，但是其实也是可以使用的，只需要修改一下 GPIO 的注册方式就行。 ## 环境搭建 下面三种方法选择一种即可 [使用sipeed提供的docker](./sipeed_D1_docker.html) [使用原文作者的环境](./environment.html) [使用D1官方环境](https://d1.docs.aw ol.com/study/study_2getsdk/) ## 先驱动 SPI 屏幕 这里驱动的屏幕所选择的是 ST7789V SPI ### 修改 FBTFT 驱动 进入 tina d1 open/lichee/linux 5.4/drivers/staging/fbtft 找到 fbtft core.c 首先加入将要使用到的头文件 ```c #include <linux/gpio.h> #include <linux/of_gpio.h> ``` 然后找到 static int fbtft_request_one_gpio() 函数，将已经弃用的端口绑定方法改为以下内容 ```c static int fbtft_request_one_gpio(struct fbtft_par *par, const char *name, int index, struct gpio_desc **gpiop) { struct device *dev par >info >device; struct device_node *node dev >of_node; int gpio, flags, ret 0; enum of_gpio_flags of_flags; if (of_find_property(node, name, NULL)) { gpio of_get_named_gpio_flags(node, name, index, &of_flags); if (gpio ENOENT) return 0; if (gpio EPROBE_DEFER) return gpio; if (gpio < 0) { dev_err(dev, \"failed to get '%s' from DT\\n\", name); return gpio; } flags (of_flags & OF_GPIO_ACTIVE_LOW) ? GPIOF_OUT_INIT_LOW : GPIOF_OUT_INIT_HIGH; ret devm_gpio_request_one(dev, gpio, flags, dev >driver >name); if (ret) { dev_err(dev, \"gpio_request_one('%s' %d) failed with %d\\n\", name, gpio, ret); return ret; } *gpiop gpio_to_desc(gpio); fbtft_par_dbg(DEBUG_REQUEST_GPIOS, par, \"%s: '%s' GPIO%d\\n\", __func__, name, gpio); } return ret; } ``` 找到 static void fbtft_reset() 函数，将 RST 信号最后拉高 ```c static void fbtft_reset(struct fbtft_par *par) { if (!par >gpio.reset) return; fbtft_par_dbg(DEBUG_RESET, par, \"%s()\\n\", __func__); gpiod_set_value_cansleep(par >gpio.reset, 1); msleep(10); gpiod_set_value_cansleep(par >gpio.reset, 0); msleep(200); gpiod_set_value_cansleep(par >gpio.reset, 1); msleep(10); } ``` 找到 static void fbtft_set_addr_win() 函数，添加地址偏移。否则会出现下图部分雪花屏现象。 ![](./assets/display_offset_situation.jpg) ```c static void fbtft_set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, \t\t\t int ye) { \tswitch(par >info >var.rotate) \t{ \t\tcase 0: xs+ 53;xe+ 53;ys+ 40;ye+ 40; \t\t\t\t break; \t\tcase 90: xs+ 40;xe+ 40;ys+ 53;ye+ 53; \t\t\t\t break; \t\tcase 180: xs+ 53;xe+ 53;ys+ 40;ye+ 40; \t\t\t\t break; \t\tcase 270: xs+ 40;xe+ 40;ys+ 53;ye+ 53; \t\t\t\t break; \t\tdefault : \t\t\t\t break; \t} \twrite_reg(par, MIPI_DCS_SET_COLUMN_ADDRESS, \t\t (xs >> 8) & 0xFF, xs & 0xFF, (xe >> 8) & 0xFF, xe & 0xFF); \twrite_reg(par, MIPI_DCS_SET_PAGE_ADDRESS, \t\t (ys >> 8) & 0xFF, ys & 0xFF, (ye >> 8) & 0xFF, ye & 0xFF); \twrite_reg(par, MIPI_DCS_WRITE_MEMORY_START); } ``` 当前目录下找到 fb_st7789v.c，参照STM32的初始化函数对初始化部分进行修改。 ```c static int init_display(struct fbtft_par *par) { par >fbtftops.reset(par); mdelay(50); write_reg(par,0x36,0x00); write_reg(par,0x3A,0x05); write_reg(par,0xB2,0x0C,0x0C,0x00,0x33,0x33); write_reg(par,0xB7,0x35); write_reg(par,0xBB,0x19); write_reg(par,0xC0,0x2C); write_reg(par,0xC2,0x01); write_reg(par,0xC3,0x12); write_reg(par,0xC4,0x20); write_reg(par,0xC6,0x0F); write_reg(par,0xD0,0xA4,0xA1); write_reg(par,0xE0,0xD0,0x04,0x0D,0x11,0x13,0x2B,0x3F,0x54,0x4C,0x18,0x0D,0x0B,0x1F,0x23); write_reg(par,0xE1,0xD0,0x04,0x0C,0x11,0x13,0x2C,0x3F,0x44,0x51,0x2F,0x1F,0x1F,0x20,0x23); write_reg(par,0x21); write_reg(par,0x11); mdelay(50); write_reg(par,0x29); mdelay(200); return 0; } ``` 将相关参数配置为屏幕实际大小 ```c static struct fbtft_display display { \t.regwidth 8, \t.width 135, \t.height 240, \t.gamma_num 2, \t.gamma_len 14, \t.gamma DEFAULT_GAMMA, \t.fbtftops { \t\t.init_display init_display, \t\t.set_var set_var, \t\t.set_gamma set_gamma, \t\t.blank blank, \t}, }; ``` ### 设备树修改 首先打开电路图，找到 SPI 屏幕的电路。 ![](./assets/SPI_Pins.jpg) 根据电路，在 tina d1 open_new/device/config/chips/d1/configs/nezha/board.dts0 文件中 找到 pio 节点，添加 SPI0 所用引脚；spi0_pins_a 作为数据时钟绑定，spi0_pins_b 作为 CS 的绑定，并上拉。RST、DC、背光引脚在这里不做声明。 ```dts &spi0 { \tclock frequency <100000000>; \tpinctrl 0 <&spi0_pins_a &spi0_pins_b>; \tstatus \"okay\"; st7789v@0 { \tstatus \"okay\"; \tcompatible \"sitronix,st7789v\"; reg <0>; spi max frequency <32000000>; rotate <90>; rgb; fps <30>; buswidth <8>; \t\treset <&pio PC 6 GPIO_ACTIVE_LOW>; \t dc <&pio PC 5 GPIO_ACTIVE_LOW>; \t\tled <&pio PD 18 GPIO_ACTIVE_HIGH>; debug <1>; }; }; ``` 最后，将不需要的屏幕关闭，方便调试 ```dts &disp { \tdisp_init_enable <0>; ...... } &lcd0 { \tlcd_used <0>; ...... } &hdmi { \thdmi_used <0>; ...... } ``` ### 内核配置 进入 kernel_menuconfig ，开启 FBTFT，关闭 RGB、MIPI 所使用的 DISP Driver Support(sunxi disp2) 输出。 ```menuconfig Device Drivers > \t Graphics support > \t \tFrame buffer Devices > \t \t\t <*> Support for frame buffer devices > \t \t\t Video support for sunxi > \t \t\t \t < > DISP Driver Support(sunxi disp2) \t [*] Staging drivers > \t \t <*> Support for small TFT LCD display modules > \t \t \t <*> FB driver for the ST7789V LCD Controller ``` 由于上面配置关闭了 DISP Driver Support(sunxi disp2) ，所用需要在 menuconfig 里将内核模块关闭，否则会出现找不到驱动的错误。 ```menuconfig Kernel modules > \tVideo Support > \t\t < > kmod sunxi disp....................................... sunxi disp support < > kmod sunxi g2d......................................... sunxi g2d support < > kmod sunxi hdmi....................................... sunxi hdmi support < > kmod sunxi uvc......................................... sunxi uvc support ``` 编译，打包，使用 fbviewer 进行测试 ```bash make j65535 pack fbviewer Yuzuki.jpg ``` ![](./assets/SPI_Display.jpg) ## 修改为双屏驱动 修改双屏也很简单，SPI 屏幕调试完成之后，将刚才关闭的各类驱动打开即可。 ### 配置设备树 找到 SPI0 节点，将背光 led 注释掉，查看电路图可知 RGB 屏幕和 SPI 屏幕使用的背光是同一个，这里不需要分开注册。 ```dts &spi0 { \tclock frequency <100000000>; \tpinctrl 0 <&spi0_pins_a &spi0_pins_b>; \tstatus \"okay\"; st7789v@0 { \tstatus \"okay\"; \tcompatible \"sitronix,st7789v\"; reg <0>; spi max frequency <32000000>; rotate <90>; rgb; fps <30>; buswidth <8>; \t\treset <&pio PC 6 GPIO_ACTIVE_LOW>; \t dc <&pio PC 5 GPIO_ACTIVE_LOW>; //\t\tled <&pio PD 18 GPIO_ACTIVE_HIGH>; debug <1>; }; }; ``` 把之前关闭的显示输出重新打开 ```dts &disp { \tdisp_init_enable <1>; ...... } &lcd0 { \tlcd_used <1>; ...... } &hdmi { \thdmi_used <1>; ...... } ``` ### 配置内核 进入 kernel_menuconfig ，开启 DISP Driver Support(sunxi disp2) 输出，并选择面板驱动。 ```menucnfig Device Drivers > \t Graphics support > \t \tFrame buffer Devices > \t \t\t <*> Support for frame buffer devices > \t \t\t Video support for sunxi > \t \t\t \t <*> DISP Driver Support(sunxi disp2) \t \t\t \t <*> HDMI2.0 Driver Support(sunxi disp2) \t \t\t \t \t HDMI2.0 PHY SELECT. (Allwinner PHY) > \t \t\t \t LCD panels select > \t \t\t \t \t\t [*] LCD support ST7701S RGB panel \t [*] Staging drivers > \t \t <*> Support for small TFT LCD display modules > \t \t \t <*> FB driver for the ST7789V LCD Controller ``` 在 menuconfig 里将内核模块重新打开。 ```menuconfig Kernel modules > \tVideo Support > \t\t <*> kmod sunxi disp....................................... sunxi disp support <*> kmod sunxi g2d......................................... sunxi g2d support <*> kmod sunxi hdmi....................................... sunxi hdmi support <*> kmod sunxi uvc......................................... sunxi uvc support ``` 编译，打包，测试。这里使用 ffmpeg 进行双屏播放 badapple.mp4 ![](./assets/Play_badapple.jpg) 附录：部分设备树完整参考（配置双屏后，HDMI禁用了） ```dts &pio { \t...前略... \tspdif_pins_b: spdif_sleep@0 { \t\tpins \"PB0\"; \t\tfunction \"io_disabled\"; \t\tdrive strength <20>; \t\tbias disable; \t}; \tspi0_pins_a: spi0@0 { \t\tpins \"PC2\", \"PC4\"; /*clk mosi*/ \t\tfunction \"spi0\"; \t\tdrive strength <10>; \t}; \tspi0_pins_b: spi0@1 { \t\tpins \"PC3\"; \t\tfunction \"spi0\"; \t\tdrive strength <10>; \t\tbias pull up; // only CS should be pulled up \t}; \tspi1_pins_a: spi1@0 { \t\tpins \"PD11\", \"PD12\", \"PD13\",\"PD14\", \"PD15\"; /*clk mosi miso hold wp*/ \t\tfunction \"spi1\"; \t\tdrive strength <10>; \t}; \tspi1_pins_b: spi1@1 { \t\tpins \"PD10\"; \t\tfunction \"spi1\"; \t\tdrive strength <10>; \t\tbias pull up; // only CS should be pulled up \t}; \tspi1_pins_c: spi1@2 { \t\tpins \"PD10\", \"PD11\", \"PD12\", \"PD13\",\"PD14\", \"PD15\"; \t\tfunction \"gpio_in\"; \t\tdrive strength <10>; \t}; \tledc_pins_a: ledc@0 { \t\tpins \"PC0\"; \t\tfunction \"ledc\"; \t\tdrive strength <10>; \t}; \tledc_pins_b: ledc@1 { \t\tpins \"PC0\"; \t\tfunction \"gpio_in\"; \t}; \t \t...后略... }； &spi0 { \tclock frequency <100000000>; \tpinctrl 0 <&spi0_pins_a &spi0_pins_b>; \tstatus \"okay\"; st7789v@0 { \tstatus \"okay\"; \tcompatible \"sitronix,st7789v\"; reg <0>; spi max frequency <32000000>; rotate <90>; rgb; fps <30>; buswidth <8>; \t\treset <&pio PC 6 GPIO_ACTIVE_LOW>; \t dc <&pio PC 5 GPIO_ACTIVE_LOW>; //\t\tled <&pio PD 18 GPIO_ACTIVE_HIGH>; debug <1>; }; }; /* disp init configuration disp_mode (0:screen0<screen0,fb0>) screenx_output_type (0:none; 1:lcd; 2:tv; 3:hdmi;5:vdpo) screenx_output_mode (used for hdmi output, 0:480i 1:576i 2:480p 3:576p 4:720p50) (5:720p60 6:1080i50 7:1080i60 8:1080p24 9:1080p50 10:1080p60) screenx_output_format (for hdmi, 0:RGB 1:yuv444 2:yuv422 3:yuv420) screenx_output_bits (for hdmi, 0:8bit 1:10bit 2:12bit 2:16bit) screenx_output_eotf (for hdmi, 0:reserve 4:SDR 16:HDR10 18:HLG) screenx_output_cs (for hdmi, 0:undefined 257:BT709 260:BT601 263:BT2020) screenx_output_dvi_hdmi (for hdmi, 0:undefined 1:dvi mode 2:hdmi mode) screen0_output_range (for hdmi, 0:default 1:full 2:limited) screen0_output_scan (for hdmi, 0:no data 1:overscan 2:underscan) screen0_output_aspect_ratio (for hdmi, 8 same as original picture 9 4:3 10 16:9 11 14:9) fbx format (4:RGB655 5:RGB565 6:RGB556 7:ARGB1555 8:RGBA5551 9:RGB888 10:ARGB8888 12:ARGB4444) fbx pixel sequence (0:ARGB 1:BGRA 2:ABGR 3:RGBA) fb0_scaler_mode_enable(scaler mode enable, used FE) fbx_width,fbx_height (framebuffer horizontal/vertical pixels, fix to output resolution while equal 0) lcdx_backlight (lcd init backlight,the range:[0,256],default:197 lcdx_yy (lcd init screen bright/contrast/saturation/hue, value:0~100, default:50/50/57/50) lcd0_contrast (LCD contrast, 0~100) lcd0_saturation (LCD saturation, 0~100) lcd0_hue (LCD hue, 0~100) framebuffer software rotation setting: disp_rotation_used: (0:disable; 1:enable,you must set fbX_width to lcd_y, set fbX_height to lcd_x) degreeX: (X:screen index; 0:0 degree; 1:90 degree; 3:270 degree) degreeX_Y: (X:screen index; Y:layer index 0~15; 0:0 degree; 1:90 degree; 3:270 degree) devX_output_type : config output type in bootGUI framework in UBOOT 2018. \t\t\t\t (0:none; 1:lcd; 2:tv; 4:hdmi;) devX_output_mode : config output resolution(see include/video/sunxi_display2.h) of bootGUI framework in UBOOT 2018 devX_screen_id : config display index of bootGUI framework in UBOOT 2018 devX_do_hpd : whether do hpd detectation or not in UBOOT 2018 chn_cfg_mode : Hardware DE channel allocation config. 0:single display with 6 \t\t\t\t channel, 1:dual display with 4 channel in main display and 2 channel in second display, 2:dual display with 3 channel in main display and 3 channel in second in display. */ &disp { \tdisp_init_enable <1>; \tdisp_mode <0>; \tscreen0_output_type <1>; \tscreen0_output_mode <4>; \tscreen1_output_type <3>; \tscreen1_output_mode <10>; \tscreen1_output_format <0>; \tscreen1_output_bits <0>; \tscreen1_output_eotf <4>; \tscreen1_output_cs <257>; \tscreen1_output_dvi_hdmi <2>; \tscreen1_output_range <2>; \tscreen1_output_scan <0>; \tscreen1_output_aspect_ratio <8>; \tdev0_output_type <1>; \tdev0_output_mode <4>; \tdev0_screen_id <0>; \tdev0_do_hpd <0>; \tdev1_output_type <4>; \tdev1_output_mode <10>; \tdev1_screen_id <1>; \tdev1_do_hpd <1>; \tdef_output_dev <0>; \thdmi_mode_check <1>; \tfb0_format <0>; \tfb0_width <0>; \tfb0_height <0>; \tfb1_format <0>; \tfb1_width <0>; \tfb1_height <0>; \tchn_cfg_mode <1>; \tdisp_para_zone <1>; \t/*VCC LCD*/ /*\tdc1sw supply <&reg_dc1sw>;*/ \t/*VCC DSI*/ /*\teldo3 supply <&reg_eldo3>;*/ \t/*VCC PD*/ /*\tdcdc1 supply <&reg_dcdc1>;*/ }; /* ;lcd0 configuration ;lcd_if: 0:hv(sync+de); 1:8080; 2:ttl; 3:lvds; 4:dsi; 5:edp; 6:extend dsi ;lcd_hv_if 0:Parallel RGB; 8:Serial RGB; 10:Dummy RGB; 11: RGB Dummy;12:CCIR656 ;lcd_hv_clk_phase 0:0 degree;1:90 degree;2:180 degree;3:270 degree ;lcd_hv_sync_polarity 0:vs low,hs low; 1:vs high,hslow; 2:vs low,hs high; 3:vs high,hs high ;lcd_hv_syuv_seq 0:YUYV; 1:YVYU; 2:UYVY; 3:VYUY ;lcd_cpu_if 0:18bit/1 cycle parallel(RGB666); 4:16bit/1cycle parallel (RGB565) ; 6:18bit/3 cycle parallel(RGB666); 7:16bit/2cycle parallel (RGB565) ;lcd_cpu_te 0:frame auto trigger; 1:frame triggered by te rising edge; 2:frame triggered by te falling edge; ;lcd_dsi_if 0:video mode; 1: Command mode; 2:video burst mode ;lcd_dsi_te 0:frame auto trigger; 1:frame triggered by te rising edge; 2:frame triggered by te falling edge; ;lcd_x: lcd horizontal resolution ;lcd_y: lcd vertical resolution ;lcd_width: width of lcd in mm ;lcd_height: height of lcd in mm ;lcd_dclk_freq: in MHZ unit ;lcd_pwm_freq: in HZ unit ;lcd_pwm_pol: lcd backlight PWM polarity ;lcd_pwm_max_limit lcd backlight PWM max limit(< 255) ;lcd_hbp: hsync back porch(pixel) + hsync plus width(pixel); ;lcd_ht: hsync total cycle(pixel) ;lcd_vbp: vsync back porch(line) + vysnc plus width(line) ;lcd_vt: vysnc total cycle(line) ;lcd_hspw: hsync plus width(pixel) ;lcd_vspw: vysnc plus width(pixel) ;lcd_lvds_if: 0:single link; 1:dual link ;lcd_lvds_colordepth: 0:8bit; 1:6bit ;lcd_lvds_mode: 0:NS mode; 1:JEIDA mode ;lcd_frm: 0:disable; 1:enable rgb666 dither; 2:enable rgb656 dither ;lcd_io_phase: 0:noraml; 1:intert phase(0~3bit: vsync phase; 4~7bit:hsync phase; ; 8~11bit:dclk phase; 12~15bit:de phase) ;lcd_gamma_en lcd gamma correction enable ;lcd_bright_curve_en lcd bright curve correction enable ;lcd_cmap_en lcd color map function enable ;deu_mode 0:smoll lcd screen; 1:large lcd screen(larger than 10inch) ;lcdgamma4iep: Smart Backlight parameter, lcd gamma vale * 10; ; decrease it while lcd is not bright enough; increase while lcd is too bright ;smart_color 90:normal lcd screen 65:retina lcd screen(9.7inch) ;Pin setting for special function ie.LVDS, RGB data or vsync ; name(donot care) port:PD12<pin function><pull up or pull down><drive ability><output level> ;Pin setting for gpio: ; lcd_gpio_X port:PD12<pin function><pull up or pull down><drive ability><output level> ;Pin setting for backlight enable pin ; lcd_bl_en port:PD12<pin function><pull up or pull down><drive ability><output level> ;fsync setting, pulse to csi ;lcd_fsync_en (0:disable fsync,1:enable) ;lcd_fsync_act_time (active time of fsync, unit:pixel) ;lcd_fsync_dis_time (disactive time of fsync, unit:pixel) ;lcd_fsync_pol (0:positive;1:negative) ;gpio config: <&pio for cpu or &r_pio for cpus, port, port num, pio function, pull up or pull down(default 0), driver level(default 1), data> ;For dual link lvds: use lvds2link_pins_a and lvds2link_pins_b instead ;For rgb24: use rgb24_pins_a and rgb24_pins_b instead ;For lvds1: use lvds1_pins_a and lvds1_pins_b instead ;For lvds0: use lvds0_pins_a and lvds0_pins_b instead ; */ &lcd0 { \tlcd_used <1>; \tlcd_driver_name \"st7701s_rgb\"; \tlcd_if <0>; \tlcd_hv_if <0>; \tlcd_width <70>; \tlcd_height <72>; \tlcd_x <480>; \tlcd_y <480>; \tlcd_dclk_freq <19>; \tlcd_hbp <60>; \tlcd_ht <612>; \tlcd_hspw <12>; \tlcd_vbp <18>; \tlcd_vt <520>; \tlcd_vspw <4>; \tlcd_backlight <50>; \tlcd_pwm_used <1>; \tlcd_pwm_ch <7>; \tlcd_pwm_freq <20000>; \tlcd_pwm_pol <1>; \tlcd_bright_curve_en <0>; \tlcd_frm <1>; \tlcd_io_phase <0x0000>; \tlcd_gamma_en <0>; \tlcd_cmap_en <0>; \tlcd_hv_clk_phase <0>; \tlcd_hv_sync_polarity <0>; \tlcd_rb_swap <0>; \tlcd_power \"vcc lcd\"; \tlcd_pin_power \"vcc pd\"; \tlcd_gpio_0 <&pio PG 13 GPIO_ACTIVE_HIGH>; \tlcd_gpio_1 <&pio PE 14 GPIO_ACTIVE_HIGH>; \tlcd_gpio_2 <&pio PE 12 GPIO_ACTIVE_HIGH>; \tlcd_gpio_3 <&pio PE 15 GPIO_ACTIVE_HIGH>; \tpinctrl 0 <&rgb18_pins_a>; \tpinctrl 1 <&rgb18_pins_b>; }; &hdmi { \thdmi_used <0>; \thdmi_power_cnt <0>; \thdmi_cts_compatibility <1>; \thdmi_hdcp_enable <1>; \thdmi_hdcp22_enable <0>; \thdmi_cec_support <1>; \thdmi_cec_super_standby <0>; \tddc_en_io_ctrl <0>; \tpower_io_ctrl <0>; }; ```"},"/soft/Lichee/zh/Lichee-RV/contribution/D1_Kubernetes.html":{"title":"RISCV64架构下 Kubernetes相关软件编译","content":" title: RISCV64架构下 Kubernetes相关软件编译 keywords: Sipeed, Kubernetes, RISCV, D1, docker 转载自知乎用户 [在路上](https://www.zhihu.com/people/zai lu shang 8 7) 原文链接 ： <https://zhuanlan.zhihu.com/p/443777923> ## 编译环境 * OS ：openEuler Linux 5.4.61 （openEuler镜像[下载地址](https://mirror.iscas.ac.cn/plct/openEuler D1 wifi hdmi docker 20210826.img.bz2)) * ARCH： riscv64 * 平台： 全志D1开发板 * go版本: go version go1.17 linux/riscv64 ## go和docker安装 详见教程：[在D1/openEuler上安装docker，并运行docker/Debian](https://zhuanlan.zhihu.com/p/406132856) docker安装前请先确认一下内核配置是否满足：`check config.sh` 安装完成docker后还是无法正常使用docker的话(报错与`libseccomp`相关)，建议重新安装一下`libseccomp`。 ## conntrack安装 ``` ## 安装支持包 yum install y bison yum install y flex ## 手动编译安装conntrack tools, 因为openEuler riscv64的软件源中还没有 git clone git://git.netfilter.org/conntrack tools ./configure prefix /usr/local/conntrack && make && make install ``` 编译conntrack tools会出现依赖包文件找不到的问题，根据提示进行安装即可。目前openEuler软件源有大部分的包，可直接下载软件以及对应的devel软件。依赖包源码下载地址：<https://git.netfilter.org/> ``` # 依赖包如果需要手动安装，一般默认安装路径为/usr/local/lib，需要把对应文件拷贝到以下位置中 /usr/include/libnetfilter_conntrack/ /usr/include/libnfnetlink/ /usr/lib64/libnetfilter_conntrack.la /usr/lib64/libnetfilter_conntrack.so /usr/lib64/libnetfilter_conntrack.so.3 /usr/lib64/libnetfilter_conntrack.so.3.1.3 /usr/lib64/pkgconfig/libnetfilter_conntrack.pc /usr/lib64/pkgconfig/libnfnetlink.pc ``` ## 编译Kubernetes 由于目前还没有基于riscv架构的kubernetes release包，因此需要从源码入手。 RISCV移植过的源码地址：<https://github.com/carlosedp/kubernetes/tree/riscv64_build> 对应的PR地址：<https://github.com/kubernetes/kubernetes/pull/86011> ``` # 全部编译 KUBE_BUILD_PLATFORMS linux/riscv64 make # 编译指定组件 KUBE_BUILD_PLATFORMS linux/riscv64 make all WHAT cmd/kubelet GOFLAGS v GOGCFLAGS \" N l\" ``` 编译完成后，可以在 `_output/local/bin/linux/riscv64/` 中找到需要的二进制文件 ``` [root@openEuler RISCV rare kubernetes]# ls l _output/local/bin/linux/riscv64/ total 1166679 rwxr xr x 1 root root 41711688 Nov 30 06:43 apiextensions apiserver rwxr xr x 1 root root 6227408 Nov 27 08:57 conversion gen rwxr xr x 1 root root 5961136 Nov 27 08:51 deepcopy gen rwxr xr x 1 root root 5944720 Nov 27 08:54 defaulter gen rwxr xr x 1 root root 107038704 Nov 30 06:44 e2e.test rwxr xr x 1 root root 116796584 Nov 30 06:42 e2e_node.test rwxr xr x 1 root root 38709064 Nov 30 06:44 gendocs rwxr xr x 1 root root 129439752 Nov 30 06:44 genkubedocs rwxr xr x 1 root root 135353224 Nov 30 06:42 genman rwxr xr x 1 root root 3285672 Nov 30 06:42 genswaggertypedocs rwxr xr x 1 root root 38704744 Nov 30 06:45 genyaml rwxr xr x 1 root root 7187536 Nov 30 06:42 ginkgo rwxr xr x 1 root root 1900544 Nov 27 09:09 go bindata rwxr xr x 1 root root 1801424 Nov 30 06:43 go runner rwxr xr x 1 root root 3366768 Nov 27 08:51 go2make rwxr xr x 1 root root 102367232 Nov 30 06:44 kube apiserver rwxr xr x 1 root root 95092736 Nov 30 06:43 kube controller manager rwxr xr x 1 root root 33816576 Nov 30 06:42 kube proxy rwxr xr x 1 root root 37289984 Nov 30 06:45 kube scheduler rwxr xr x 1 root root 35192832 Nov 30 06:44 kubeadm rwxr xr x 1 root root 39321600 Nov 30 06:44 kubectl rwxr xr x 1 root root 96825128 Nov 30 06:43 kubelet rwxr xr x 1 root root 95325544 Nov 30 06:43 kubemark rwxr xr x 1 root root 4674000 Nov 30 06:43 linkcheck rwxr xr x 1 root root 1572864 Nov 30 06:43 mounter rwxr xr x 1 root root 9751176 Nov 27 09:04 openapi gen ``` 本实验在全志D1的开发板上进行，系统采用的openEuler，由于CPU核数和存储的限制，以下是编译过程中可能遇到的错误： ### 相关错误及对应的解决办法 + **network: /usr/local/go/pkg/tool/linux_riscv64/compile: signal: killed** 问题重现： ``` go build k8s.io/kubernetes/vendor/github.com/Azure/azure sdk for go/services/network/mgmt/2019 06 01/network: /usr/local/go/pkg/tool/linux_riscv64/compile: signal: killed ``` 解决方法： 属于OOM错误，需要扩大swap分区 1.创建作为swap分区的文件:增加1GB大小的交换分区 >dd if /dev/zero of /root/swapfile bs 1M count 1024 2.格式化为交换分区文件 >mkswap /root/swapfile 3.启用交换分区文件 >swapon /root/swapfile + **_output/bin/deepcopy gen: Permission denied** 问题重现：编译kubernetes时遇到报错 >./hack/run in gopath.sh: line 33: _output/bin/deepcopy gen: Permission denied 解决方法： ``` yum install y rsync chmod +x _output/bin/deepcopy gen make clean make clean_generated ``` 然后重新 make 编译操作。 + **vendor/https://github.com/onsi/ginkgo/internal/remote/syscall_dup_unix.go:10:9: undefined: syscall.Dup2** 问题重现：编译kubernetes时遇到报错信息 ``` k8s.io/kubernetes/vendor/github.com/onsi/ginkgo/internal/remote/vendor/github.com/onsi/ginkgo/internal/remote/syscall_dup_unix.go:10:9: undefined: syscall.Dup2 ``` 解决方法： 这是由于kubernetes库 `go.mod` 中依赖 `ginkgo` ，但是 `go.mod` 中为 `ginkgo v1.10.1` 版本，而支持riscv的`ginkgo`版本从v1.11.0开始，因此在编译前需要将`go.mod`中的`ginkgo`版本修改为1.11.0 >github.com/onsi/ginkgo > github.com/onsi/ginkgo v1.11.0 + **tmp存储Out of Memory** 解决方法参考，如何增加 Linux 下临时文件夹 /tmp 的大小 http://xiehongfeng100.github.io/2016/01/18/ops how to increase tmp partition size/ ## 编译etcd etcd的RISCV移植已经并入主线可直接下载主线代码： https://link.zhihu.com/?target https%3A//github.com/etcd io/etcd 对应的PR地址：https://github.com/etcd io/etcd/pull/10834 ``` # 编译命令 GOOS linux GOARCH riscv64 ARCH riscv64 GO_BUILD_FLAGS ' v mod readonly' ./build.sh # 编译结果 [root@k8s 01 etcd]# ls l bin/ total 70377 rwxr xr x 1 root root 30298920 Nov 28 05:46 etcd rwxr xr x 1 root root 22962560 Nov 28 05:48 etcdctl rwxr xr x 1 root root 18803030 Nov 28 05:46 etcdutl ``` ### etcd编译过程中出现的问题 + **etcd on unsupported platform without ETCD_UNSUPPORTED_ARCH riscv64 set** 问题重现 安装etcd时出现`etcd on unsupported platform without ETCD_UNSUPPORTED_ARCH riscv64 set`，致使etcd启动失败。 解决方法： ``` vim etcd/server/etcdmain/etcd.go # 在最后checkSupportArch()函数中添加 if runtime.GOARCH \"amd64\" runtime.GOARCH \"arm64\" runtime.GOARCH \"riscv64\" runtime.GOARCH \"ppc64le\" runtime.GOARCH \"s390x\" { return } # 重新编译 GOOS linux GOARCH riscv64 ARCH riscv64 GO_BUILD_FLAGS ' v mod readonly' ./build.sh ``` 重启一下etcd即成功。 ## 编译flannel 尚未进行RISCV移植，目前只支持二进制编译。"},"/soft/Lichee/zh/Lichee-RV/get_started/flash.html":{"title":"Lichee RV 系统烧录","content":"# Lichee RV 系统烧录 系统镜像分为 Tina与Debian两种，Tina为专用小linux镜像，Debian为桌面级镜像 ## 准备 1. Lichee RV 核心板 2. TF 内存卡（建议使用[官方店](https://shop365481095.taobao.com/)的的内存卡，其他的卡可能会有各种奇怪的问题） 3. 烧录工具 [PhoenixCard](https://dl.sipeed.com/shareURL/LICHEE/D1/Lichee_RV/tool) 4. 系统镜像 国内用户：[Tina](https://dl.sipeed.com/shareURL/LICHEE/D1/Lichee_RV/SDK/image) 系统镜像或者 Debian 系统镜像 ([百度网盘](https://pan.baidu.com/s/1QJTaDw6kkTM4c_GAlmG0hg) 提取码：wbef) 国外用户：[Mega](https://mega.nz/folder/lx4CyZBA#PiFhY7oSVQ3gp2ZZ_AnwYA) 镜像词缀说明 含义 备注 LicheeRV Sipeed 专用的 RISCV D1 Linux 系列系统。 Tina 标记为 tina openwrt 系统。 debian 标记为 riscv debian 系统。 86panel [taobao 86panel](https://item.taobao.com/item.htm?spm a230r.1.14.18.30b534187YMsRx&id 663345415205&ns 1&abbucket 7#detail) dock [taobao dock](https://item.taobao.com/item.htm?spm a1z10.3 c s.w4002 21410578028.20.35765d54K9XCOt&id 666274331852) hdmi 表示屏幕默认输出到 HDMI 屏幕上。 800480 / 480P 表示屏幕默认输出到 LCD 屏幕上，分辨率可以是 800*480 或 480P (640X480)。 8723ds 表示该镜像支持 8723ds WIFI / BLE 驱动。 xr829 表示该镜像支持 xr829 WIFI / BLE 驱动。 waft 是否内置 waft 软件。 ## 烧录镜像 打开烧录软件 PhoenixCard，选择烧录的固件，将内存卡通过读卡器插入电脑中 ![](./../assets/flash.png) > 并不能保证每台电脑和每个人的内存卡都是可以烧录的，推荐烧录失败的时候直接购买官方的镜像卡。（全志的） 等待烧录结束，烧录 Tina 系统镜像会比较快，但是烧录 Debian 系统镜像是将会长一些，可能需要10多分钟。 ## 启动 插卡启动，可以在串口工具中查看到启动信息 ```shell BusyBox v1.27.2 () built in shell (ash) __ ___ _ __ _ / / /__ _(_)_ __ / / (_)__ __ ____ __ / /_/ / _ `/ /\\ \\ / / /__/ / _ \\/ // /\\ \\ / /_/ /_/\\_,_/_//_\\_\\ /____/_/_//_/\\_,_//_\\_\\ Maix Linux (Neptune, 5C1C9C53) ``` TIPS： 如果在烧录时提示格式化失败，或者烧过卡之后电脑上没有了盘符，可以按以下操作恢复执行： 1. 在此下载磁盘处理软件： https://www.diskgenius.cn/ 2. 电脑上显示不出的盘符，会在该软件里显示出来，使用该软件进行快速分区： ![attachmentId 2788](https://bbs.sipeed.com/storage/attachments/2021/12/17/K9SdDOalmpgIwFopjoUU7sV2zgp26E1d85EMwgXf.png) 3. 分区完成后，电脑上就能够看到盘符，PhoenixCard 里也能看到，在 PhoenixCard 里点击恢复卡即可恢复卡到正常状态 4. 按之前步骤继续烧录即可 ## 注意！ > 以下操作是在 Linux 系统中进行 如果烧录的镜像后缀与板子实际型号不符，下载对应的 boot_package_XXX.fex 来覆盖板级配置， 覆盖指令为： sudo dd if boot_package_XXX.fex of /dev/sdX bs 1K seek 16400 前面的镜像烧录，建议使用USB3.0的读卡器烧录，此时烧录100MB的Tina镜像约用时半分钟，烧录4GB的Debian镜像，约用时10分钟。 > Tina 系统登录用户名：root 密码：tina > Debian 系统登录用户名：sipeed 密码：licheepi"},"/soft/Lichee/zh/Lichee-RV/get_started/user.html":{"title":"基础上手","content":"# 基础上手 ## 点灯教程 当我们成功进入系统后，就可以进行基础的点灯操作啦！ （注：该教程不适用于 `86 panel`，因为对应引脚连接了外设，`86 panel` 用户可以拆下核心板来操作实验） 核心板的螺丝固定焊盘旁有一颗 LED ，查看原理图：https://dl.sipeed.com/shareURL/LICHEE/D1/HDK/Lichee_RV/2_Schematic 可知该 LED 连接的是 PC1，换算该 IO 的数字标号为：2*32+1 65，或者查看 IO 复用情况表： ``` cat /sys/kernel/debug/pinctrl/2000000.pinctrl/pinmux pins ... pin 64 (PC0): device 2008000.ledc function ledc group PC0 pin 65 (PC1): UNCLAIMED pin 66 (PC2): UNCLAIMED pin 67 (PC3): UNCLAIMED pin 68 (PC4): UNCLAIMED pin 69 (PC5): UNCLAIMED pin 70 (PC6): UNCLAIMED pin 71 (PC7): UNCLAIMED ``` 我们先导出该 GPIO： ``` echo 65 > /sys/class/gpio/export cd /sys/class/gpio/gpio65 ``` 然后再将该 IO 置为输出状态，即可操作其电平： ``` echo out>direction echo 1 > value #LED点亮 echo 0 > value #LED熄灭 ``` 至此我们就成功在 RISC V 64 D1上点灯啦~ 你也可以对 串行RGB LED WS2812 进行花式点灯： ``` cd /sys/class/leds/ echo 255 > /sys/class/leds/sunxi_led0r/brightness;echo 0 > /sys/class/leds/sunxi_led0g/brightness;echo 0 > /sys/class/leds/sunxi_led0b/brightness; echo 0 > /sys/class/leds/sunxi_led0r/brightness;echo 255 > /sys/class/leds/sunxi_led0g/brightness;echo 0 > /sys/class/leds/sunxi_led0b/brightness; echo 0 > /sys/class/leds/sunxi_led0r/brightness;echo 0 > /sys/class/leds/sunxi_led0g/brightness;echo 255 > /sys/class/leds/sunxi_led0b/brightness; ``` ## 外设功能验证 > 注意！！！ > 目前在 debian 系统下，蓝牙暂时不可以用！！ ### 音频功能 录音设备查看 ``` root@MaixLinux:~# arecord l **** List of CAPTURE Hardware Devices **** card 0: audiocodec [audiocodec], device 0: SUNXI CODEC 2030000.codec 0 [] Subdevices: 1/1 Subdevice 0: subdevice 0 card 1: snddmic [snddmic], device 0: 2031000.dmic dmic hifi dmic hifi 0 [] Subdevices: 1/1 Subdevice 0: subdevice 0 card 2: sndhdmi [sndhdmi], device 0: 2034000.daudio audiohdmi dai 20340a4.hdmiaudio 0 [] Subdevices: 1/1 Subdevice 0: subdevice 0 ``` 播放设备查看 ``` root@MaixLinux:~# aplay l **** List of PLAYBACK Hardware Devices **** card 0: audiocodec [audiocodec], device 0: SUNXI CODEC 2030000.codec 0 [] Subdevices: 1/1 Subdevice 0: subdevice 0 card 2: sndhdmi [sndhdmi], device 0: 2034000.daudio audiohdmi dai 20340a4.hdmiaudio 0 [] Subdevices: 1/1 Subdevice 0: subdevice 0 ``` 录放音测试： ``` arecord D hw:1,0 f S16_LE t wav d 3 t.wav aplay D hw:0,0 t.wav ``` 另外可以使用alsamixer 进行音量调整 ### USB功能 默认内核支持外挂U盘的驱动，插上U盘后可以使用 fdisk l 查看到新增的 /dev/sda 如果U盘没有被格式化，可以使用mkfs.vfat指令来格式化U盘，再使用mount指令挂载 默认Tina固件里的 /dev/mmcblk0p8 分区即可使用上述方式格式化后挂载，来提升可用空间 ### 有线网络 LicheeRV 86 Panel 支持百兆网络，使用套餐附送的网线尾线接上网线后，执行以下指令来连接有线网络 ``` ifconfig eth0 up udhcpc ieth0 ``` ### 无线网络 **使用 Tina 系统** LicheeRV 底板默认使用XR829或者RTL8723BS wifi模块，可以使用以下指令进行联网操作 先配置热点信息： ``` vim /etc/wifi/wpa_supplicant.conf network { ssid \"WiFi_name\" psk \"WiFi_password\" } ``` 配置完成后重启，ifconfig wlan0 up; udhcpc iwlan0 即可连上对应的wifi。连上网络后，你就可以使用ssh远程登录板卡，或者使用scp来进行文件传输啦~ **使用 debian 系统** 点击系统菜单 Preferenes Connman Settings，打开 Network Settings ，查看网络属性中的 Interface 是否为 wlan0。双击网络名称，并输入 WiFi 密码进行连接 ![](./../assets/RV/wifi 1.jpg) 连接网络成功之后，通过系统系统菜单 Preferenes Connman Settings，查看网络属性查看网络的 IP 地址 ![](./../assets/RV/wifi 2.jpg) ### 屏显触摸 LicheeRV系列支持以下显示屏： SPI屏\t\t1.14寸屏(TODO) RGB屏\t\t4.3寸 480x272；5.0寸 800x480； RGB+SPI屏\t4.0寸 480x480(st7701s); 4.0寸 720x720(nv3052c) MIPI屏\t\t8.0寸 1280x720(ILI9881C) Tina下可以通过以下指令测试屏幕显示： fbviewer xxx.jpg 如果需要调试屏幕驱动，可以使用以下指令查看屏幕驱动信息： ``` cat /sys/class/disp/disp/attr/sys screen 0: de_rate 300000000 hz, ref_fps:60 mgr0: 480x480 fmt[rgb] cs[0x204] range[full] eotf[0x4] bits[8bits] err[0] force_sync[0] unblank direct_show[false] iommu[1] dmabuf: cache[0] cache max[0] umap skip[0] overflow[0] \tlcd output\tbacklight( 50)\tfps:59.5\tesd level(0)\tfreq(60)\tpos(0)\treset(0)\t 480x 480 \terr:0\tskip:184\tirq:230715\tvsync:0\tvsync_skip:0 BUF enable ch[1] lyr[0] z[16] prem[N] a[globl 255] fmt[ 0] fb[ 480, 480; 480, 480; 480, 480] crop[ 0, 0, 480, 480] frame[ 0, 0, 480, 480] addr[ffe00000, 0, 0] flags[0x 0] trd[0,0] ``` 屏幕彩条测试：echo 1 > /sys/class/disp/disp/attr/colorbar 如果你购买的是86面板套餐，可以使用 ts_test进行触摸测试 > 注意触摸驱动有瑕疵，ts_test测试时松开后，光标会不动，但是终端仍会正常打印信息 ### 视频播放 最终我们可以尝试在LicheeRV上播放BadApple啦~[视频下载](https://dl.sipeed.com/shareURL/LICHEE/D1/Lichee_RV/MP4) Tina镜像中内置了ffmpeg软件包，ffmpeg是强大的多媒体库，可以用于录屏或者播放 录屏指令：ffmpeg f fbdev framerate 10 i /dev/fb0 record.avi 播放指令（分别是扬声器播放音频和hdmi播放音频）： ``` ffmpeg i /mnt/UDISK/badapple_640480_xvid.mp4 pix_fmt bgra f fbdev /dev/fb0 f alsa hw:0,0 ffmpeg i /mnt/UDISK/badapple_640480_xvid.mp4 pix_fmt bgra f fbdev /dev/fb0 f alsa hw:2,0 ``` 这里由于是CPU软解，所以测试最高分辨率约为720x540， 再高会变卡 <iframe src \"https://player.bilibili.com/player.html?aid 209723771&bvid BV1xa411r7PP&cid 457742249&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\"> </iframe> ### 麦克风阵列 如果你使用的是dock板，那么还可以外接麦克风阵列版进行声场成像演示： 直接执行debian系统下内置的micarr_0609指令即可 有麦克风阵列相关的二次开发需求，可以联系support@sipeed.com <iframe src \"https://player.bilibili.com/player.html?aid 849734125&bvid BV1HL4y1H7nv&cid 457750392&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\"> </iframe> ## Debian镜像体验 对于只接触过桌面级系统的开发者，推荐使用Debian镜像，可在上面的网盘里下载 LicheeRV_Debian_86_480p 为 480p的86盒板卡的debian镜像 LicheeRV_Debian_hdmi 为 dock的hdmi输出的debian镜像 如果是其他板卡或者屏幕，请自行使用对应的fex覆盖板级配置。 烧录完成后，插卡启动，稍等2分钟左右，屏幕上就会显示登录界面 ![登录界面](./../assets/LicheeRV_login_picture.png \"登录界面\") 输入用户名 sipeed，密码 licheepi，即可进入桌面 （使用USB HOST口外接键鼠输入） ![桌面样式](./../assets/desktop_appearance.png \"桌面样式\") 进入桌面后可以进行一些基础操作 ![基础操作](./../assets/Basic_operation.png \"基础操作\") 接下来让我们尝试在Debian下跑一下Hello World: ![运行自制程序](./../assets/Run_HelloWorld.png \"运行自制程序\") 另有720P高清屏的效果对比，有米的同学可以考虑入手： ![attachmentId 2738](https://bbs.sipeed.com/storage/attachments/2021/12/09/77KuMcmppgJn44doDQMYBBi8pPDRdKwkXm9HPit6.png) ![attachmentId 2739](https://bbs.sipeed.com/storage/attachments/2021/12/09/E1qugpwslyoHbknndO5KDqv3tjclx3GUWM5QDzN4.png) ## BSP SDK 开发指南 为了方便用户自行开发，矽速整理发布了 LicheeRV 的bsp开发docker镜像，大家使用该镜像可以快速开始D1的系统级开发。 在网盘中下载对应的docker文件后，解压到tar文件后导入到docker >docker import licheerv_d1_compile.tar licheerv_d1_compile:lastest 然后即可run该容器。用户名为`nihao`，密码为`sipeed123` 进入容器后的基础编译操作为： ``` cd ~/sdk/tina d1 open_new/ source build/envsetup.sh lunch #选1 make menuconfig #去掉里面的 alsa plugin选项，否则编译不过 make j8 #按实际CPU性能编译 pack #打包 ``` SDK内置了一些版型的dts，你可以自行选择编辑： `device/config/chips/d1/configs/nezha/board_xxx.dts` 其他SDK的开发说明，可以参见全志开发平台上下载的相关文档 https://open.allwinnertech.com/ 也可以加全志交流QQ群：`498263967` 如果需要自己下载SDK开发，参考全志在线相关网页：https://d1.docs.aw ol.com/en/ ## WAFT 开发指南 TODO"},"/soft/Lichee/zh/Lichee-RV/build_sys/Buildroot.html":{"title":"使用Buildroot","content":" title: 使用Buildroot keywords: debian, Rv, Problem, buildroot, img, sipeed > 编辑于2022年3月16日 ## 方式一：使用韦东山提供的Buildroot ### 准备工作 克隆Buildroot ``` git clone https://gitee.com/weidongshan/neza d1 buildroot.git ``` 进入Buildroot文件夹 ``` cd neza d1 buildroot/ ``` ### 配置和编译 加载配置文件 ``` make neza d1_defconfig ``` 如果需要进一步配置（如添加/删除软件，添加WiFi网卡驱动），可以执行： ``` make menuconfig ``` 如果你使用的是RV Dock WiFi版（出厂自带RTL8723DS），请前往Target packages下的Hardware handling勾选RTL8723DS。（建议连同Networking applications中的dhcpd和Network Manager中的nmtui勾选上）。如果你使用其他WiFi模块，需要根据WiFi模块所使用的芯片来选择相应的WiFi驱动。 其他软件包（如Vim，Qt5等）按需选择即可。 退出，保存，开始编译（编译时长取决于电脑性能，需要编译的软件数量和网速）。 ``` make all ``` 或 ``` make all j2 ``` （视情况输入或调整使用的线程数，如果您的电脑性能较好可以试试` j4`甚至更多） 如果出现以下内容: ``` INFO: hdimage(sdcard.img): adding partition 'boot0' from 'boot0_sdcard.fex' ... INFO: hdimage(sdcard.img): adding partition 'boot packages' from 'boot_package.fex' ... INFO: hdimage(sdcard.img): adding partition 'env' (in MBR) from 'env.fex' ... INFO: hdimage(sdcard.img): adding partition 'env redund' (in MBR) from 'env.fex' ... INFO: hdimage(sdcard.img): adding partition 'boot' (in MBR) from 'boot.vfat' ... INFO: hdimage(sdcard.img): adding partition 'rootfs' (in MBR) from 'rootfs.ext4' ... INFO: hdimage(sdcard.img): writing GPT INFO: hdimage(sdcard.img): writing hybrid MBR ``` 恭喜你，固件编译成功，这时候就可以使用Etcher来将该固件烧入SD卡里了。 ### 调试 然后将开发板和串口模块连接起来，并使用串口调试软件进行调试。 **注意：只需要接RX、TX和GND即可，RX接TX，TX接RX，别接错了。** 如果按下回车键后有内容输出，并且能够正常使用命令，恭喜你，喜提属于你自己的Linux。 如果需要联网，请参考： [联网教程](https://wiki.sipeed.com/hardware/zh/lichee/RV/user.html#%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C)的使用Tina系统（udhcpc需要替换成dhcpd） ## 方式二：使用官方Buildroot/其他大佬的Buildroot（适合喜欢折腾Buildroot的人） 目前官方版本的Buildroot已经支持全志D1（截至2022.02），但是默认C语言标准库是uClibc ng，就看个人喜好了，想要支持更多软件可以使用glibc，想要体积小一点的可以选uClibc ng，当然你得自己去摸索了，比如软件库啥的。 其他大佬的Buildroot列表： https://github.com/YuzukiHD/Buildroot YuzukiSBC （如果有其他的欢迎来补充）"},"/soft/Lichee/zh/Lichee-RV/intro_cn.html":{"title":"施工中","content":" title: 施工中 "},"/soft/Lichee/zh/MaixII/V83X/contribution/v83x_sdk_compile/V83x_sdk_kernel_compile.html":{"title":"V831/V833 的 SDK 的 kernel & package 的开发方法","content":" title: V831/V833 的 SDK 的 kernel & package 的开发方法 原文链接：https://www.cnblogs.com/juwan/p/15226245.html 作者：[人 類 開 源 補 完 計 劃](https://www.cnblogs.com/juwan) > 搬运时间：2022年3月11日 本次文章如下内容: [关于编译、测试、打包镜像的基础用法，以及常见的注意点](#关于编译测试打包镜像的基础用法以及常见的注意点) [关于 Tina Linux 的 kernel 和 package 的速成用法](#关于 tina linux 的 kernel 和 package 的速成用法) [关于适配和测试常见的基础外设驱动，从上层用户空间的软件到底层硬件寄存器之间的联系。](#关于适配和测试常见的基础外设驱动从上层用户空间的软件到底层硬件寄存器之间的联系) [拓展介绍给 SDK 加入没有的外设驱动调试和开发流程](#拓展介绍给 sdk 加入没有的外设驱动调试和开发流程) [总结一下](#总结一下) 内容可能有点多，需要的话以后可以再来查阅。 目前V833 SDK已经公开 https://github.com/Tina V833/tina V833 ## 关于编译、测试、打包镜像的基础用法，以及常见的注意点 配置基础编译系统的方法看 [R329 SDK 上手编译与烧录! ](https://wiki.sipeed.com/soft/Lichee/zh/MaixSense/contribution/R329_SDK_%E7%BC%96%E8%AF%91%E4%B8%8E%E7%83%A7%E5%BD%95.html)，最好用 ubuntu18 ~ 20 ，问题少一点，解决方法多一点。 在这里列一下必要的库，编译与测试环境在 ubuntu20 （wsl2）建议大于 8G 内存。 连接开发板 https://r329.docs.allwinnertech.com/devboardstudy/r329evb5studyadbuart/ 编译环境配置 https://r329.docs.allwinnertech.com/devboardstudy/r329evb5ubuntu/ 上面两篇参考资料废话很多，如果你已经有经验了，就直接开始吧。 基础环境的安装： > sudo apt get y install build essential asciidoc binutils bzip2 gawk gettext git libncurses5 dev libz dev patch python3 python2.7 unzip zlib1g dev lib32gcc1 libc6 dev i386 subversion flex uglifyjs git core gcc multilib p7zip p7zip full msmtp libssl dev texinfo libglib2.0 dev xmlto qemu utils upx libelf dev autoconf automake libtool autopoint device tree compiler g++ multilib antlr3 gperf wget curl swig rsync intltool busybox cmake Ubuntu20 要增强一下，补一下下面两个包 libffi6 （python3 需要）。 ``` wget http://mirrors.kernel.org/ubuntu/pool/main/libf/libffi/libffi6_3.2.1 8_amd64.deb sudo apt install ./libffi6_3.2.1 8_amd64.deb sudo apt get install uuid dev ``` 其他的，自己缺了就找一下。 以 Tina Linux 为例，它以 openwrt linux 系统为原型，所以编译方法是相通的，只是会多一点自己的特色。 有如下基础用法，这里只是简化和说明源头： source build/envsetup.sh ```bash before all lunch: lunch <product_name> <build_variant> build project m: Make from the top of the tree. mm: Build package in the current directory, but not their dependencies. mmb: Clean and build package in the current directory, but not their dependencies. p: Pack from the top of the tree. pd: Pack card0 from the top of the tree. mp: Make and pack from the top of the tree mpd: Make and pack card0 from the top of the tree mboot: Build boot0 and uboot, including uboot for nor. mboot0: Just build boot0. muboot: Build uboot, including uboot for nor. muboot_nor: Just build uboot for nor. mkernel: Build kernel. mlibc: Build c library. jump directory croot: Jump to the top of the tree. cboot: Jump to uboot. cboot0: Jump to boot0. cdts: Jump to device tree. cbin: Jump to uboot/boot0 bin directory. ckernel: Jump to kernel. cdevice: Jump to target. ccommon: Jump to platform common. cconfigs: Jump to configs of target. cout: Jump to out directory of target. ctarget: Jump to target of compile directory. crootfs: Jump to rootfs of compile directory. ctoolchain: Jump to toolchain directory. callwinnerpk: Jump to package allwinner directory. ctinatest: Jump to tinateset directory. godir: Go to the directory containing a file. grep file cgrep: Greps on all local C/C++ files. ``` 命令主要就用这几个就好。 croot 到工程根目录， cout 同理到 out 编译目录。 make 编译工程全部内容，mkernel 同理单独编译 kernel （mboot 同理）。 make menuconfig 和 make kernel_menuconfig 分别是配置 package 和 kernel 的所选功能的。 pack 打包当前的编译结果成一个 img 文件，供 livesuit 工具烧录。 全志的烧录工具网上多，不过在 linux 开发的话要看一下这个仓库 https://github.com/jake5253/allwinner livesuit 或这个 https://github.com/junhuanchen/sunxi livesuite （我改了一点说明在 ubuntu 20 上使用）。 cgrep test 是快速的 grep rn \"test\" 查代码用的。 > 由于硬件的 uboot 配置已经被适配过，所以可以不用特别关注启动方面的配置，极小概率会去修改的，之后有必要会代入说明。 现在我们具备了编译，打包，烧录的基础，顺便说一下一些常用的注意点。 make 只在 croot 的目录下有效，编译主要分 uboot kernel package 三大块的编译。 我们通常只需要关心 package 编译即可，编译系统和 openwrt 一致，这个可以从网上获取相关用法。 单包编译 `make package/allwinner/eyesee mpp/middleware/compile` 清理单包 `make package/allwinner/eyesee mpp/middleware/clean` > 参考资料 [在openwrt上编译一个最简单的ipk包](https://www.cnblogs.com/qingchen1984/p/6768602.html) 具体的包描述可以看目录下的 Makefile 和 Config.in ，如果想要加一个包，就可以通过仿照其他包加入编译系统，甚至是从 github 获取别人移植好的包。 例如给系统加入 libuv ，我们可以[github搜索](https://github.com/search?q define+Package%2Flibuv&type code) 到获得别人加入的。 这样一些软件包的编译规则就可以不用自己写了，这是一个软件包常用的偷懒小技巧，驱动代码有时候也可以这样操作，但自己最好熟悉整体的编译系统是最好的。 ```makefile # # Copyright (C) 2015 2017 OpenWrt.org # # This is free software, licensed under the GNU General Public License v2. # See /LICENSE for more information. # include $(TOPDIR)/rules.mk PKG_NAME: libuv PKG_VERSION: 1.42.0 PKG_RELEASE: 1 PKG_SOURCE: $(PKG_NAME) v$(PKG_VERSION).tar.gz PKG_SOURCE_URL: http://dist.libuv.org/dist/v$(PKG_VERSION)/ # PKG_HASH: 61a90db95bac00adec1cc5ddc767ebbcaabc70242bd1134a7a6b1fb1d498a194 PKG_BUILD_DIR: $(BUILD_DIR)/$(PKG_NAME) v$(PKG_VERSION) PKG_MAINTAINER: Marko Ratkaj <marko.ratkaj@sartura.hr> PKG_LICENSE: MIT PKG_LICENSE_FILES: LICENSE PKG_CPE_ID: cpe:/a:libuv_project:libuv CMAKE_INSTALL: 1 CMAKE_BINARY_SUBDIR: out/cmake PKG_BUILD_PARALLEL: 1 include $(BUILD_DIR)/package.mk include $(BUILD_DIR)/cmake.mk define Package/libuv SECTION: libs CATEGORY: Libraries TITLE: Cross platform asychronous I/O library URL: https://libuv.org/ DEPENDS: +libpthread +librt ABI_VERSION: 1 endef define Package/libuv/description libuv is a multi platform support library with a focus on asynchronous I/O. It was primarily developed for use by Node.js, but it's also used by Luvit, Julia, pyuv, and others. endef CMAKE_OPTIONS + DBUILD_TESTING OFF define Build/InstallDev \t$(call Build/InstallDev/cmake,$(1)) \t$(SED) 's,/usr/include,$$$${prefix}/include,g' $(1)/usr/lib/pkgconfig/libuv.pc \t$(SED) 's,/usr/lib,$$$${prefix}/lib,g' $(1)/usr/lib/pkgconfig/libuv.pc endef define Package/libuv/install \t$(INSTALL_DIR) $(1)/usr/lib/ \t$(CP) $(PKG_INSTALL_DIR)/usr/lib/libuv.so* $(1)/usr/lib/ endef $(eval $(call BuildPackage,libuv)) ``` 这里会演示和讲解一下上面这个包是如何参与编译和调试的，注意目录下 Config.in 主要影响 make menuconfig 搜索到这个包，如果勾选功能就会调起 Makefile 影响具体的编译，有一些常见的宏需要联系上下文获取，如 交叉编译的 gcc ，编译输出的目录，拷贝哪些资源和程序到 rootfs 下，有一些包如何和 kernel 模块联系，主要有纯粹软件包也有底层驱动包，还有 openwrt 提供的 luci feed 软件源，但这个对我们的使用影响很小，因为我们不是用作路由器的 web 服务。 > 如果到这里了还没有编译出系统镜像的，就不用继续往下看了，基本功都不过关。 ## 关于 Tina Linux 的 kernel 和 package 的速成用法 继续往下看的前提是你已经将系统编译出来并将其烧录系统启动进入终端了。 先从设备树的结点开始说起，如果你从来没有接触过设备树，可以在这里简单的了解一下。 设备树是一个存放驱动具体配置信息的文件，其中 dtb 是 dts 的编译产物，内核 kernel 可以通过 dts 去配置要加载的驱动的一些配置信息。 举个例子，如果你想要给系统添加一个 RTC 设备，那么可以在 device/config/chips/v833/configs/xxxx/board.dts 中依次定义树结点。 ```dts &twi4 { pcf8563: rtc@51 { compatible \"nxp,pcf8563\"; reg <0x51>; }; }; ``` 这样的配置意味着 kernel 在启动的时候要去负责调驱动程序，如果驱动成功则会注册一个 rtc 设备到 /dev/rtcX 中，可能是 /dev/rtc1 等等。 接着这个驱动会需要 twi4 的结点，因此会定义下面这个结点。 ```dts twi4: twi@0x07081400 { pinctrl 0 <&twi0_pins_a>; pinctrl 1 <&twi0_pins_b>; status \"okay\"; }; pinctrl@0300b000 { twi0_pins_a: twi0@0 { allwinner,pins \"PE16\", \"PE17\"; allwinner,pname \"twi0_scl\", \"twi0_sda\"; allwinner,function \"twi0\"; allwinner,muxsel <5>; allwinner,drive <1>; allwinner,pull <0>; }; twi0_pins_b: twi0@1 { allwinner,pins \"PE16\", \"PE17\"; allwinner,function \"io_disabled\"; allwinner,muxsel <7>; allwinner,drive <1>; allwinner,pull <0>; }; } ``` 其中 twi4 对应 /dev/i2c 4 的设备，其中 twi0_pins_a 和 twi0_pins_b 表示具体的 GPIO 引脚配置。 需要注意的是，驱动配置的字符串都是可以随意设计的，因为具体结点项的使用会在驱动代码中通过 of_property_read_xxxx 系列函数获取对应的配置描述，所以不同 SOC 的定义都会有所不同。 但为什么要这样配置呢？通常 SOC 厂家会提供底层的基础结点配置（如 sun8iw19p1.dtsi 类似于 .h 和 .c 的关系），开发的时候只需要继承其结点配置即可。 /linux 4.9/arch/arm/boot/dts/sun8iw19p1.dtsi /linux 4.9/arch/arm/boot/dts/sun8iw19p1 pinctrl.dtsi /linux 4.9/arch/arm/boot/dts/sun8iw19p1 clk.dtsi 但设备树结点具体怎么配置是要结合驱动程序来看的，可以参考我以前的这篇文章，[为 AW V831 配置 spidev 模块，使用 py spidev 进行用户层的 SPI 通信](https://www.cnblogs.com/juwan/p/14341406.html)。，这篇文章主要交代了如何在上层和底层以及外设输出测量做了说明和示范。 > 这里我可以拿一些 屏幕 、 摄像头 、外设设备之类的做一下演示。 ## 关于适配和测试常见的基础外设驱动，从上层用户空间的软件到底层硬件寄存器之间的联系。 有了基本的修改驱动和设备树的能力以后，我们来主动实现一些 SDK 没有的功能，首先要熟悉一下 SDK 的编译框架构成，以便于我们添加代码和模块进入。 先从 kernel 开始说起，kernel 里的驱动代码，我们需要掌握挂载、修改、调试它的认知。 对于 linux 的 module 模块的基础开发方法可以看这个仓库[linux_python_ioctl_driver](https://github.com/junhuanchen/linux_python_ioctl_driver)，基本用法就是 insmod 和 rmmod 、lsmod，在 X86 上稍微学习一下 IOCTL 的操作接口就行，，学会加载 .ko 释放、查看等等（这里可以简单演示一下）。 到这里要知道内核模块 .ko 不同于链接库 .so 模块的代码结构以及使用方法上的差异就行，大多数时候用不着写原始驱动，拿过来改改就行。 然后知道了这个以后，还需要知道一些调试模块的使用，例如 dmesg 、 debugfs 和 sysfs 的使用。 如何理解呢？拿屏幕操作来说吧。某个屏幕驱动出了问题，需要确认驱动的情况。 使用 dmesg 可以查看我们在 kernel 下写的 printk 输出的内容，只能看到输出的结果，不能进行交互。 想要交互，我们可以通过 debugfs 或 sysfs 与内核模块进行文件内容的交换，例如下述的这类用法作为参考。 ![img](./assets/dip_module_debugfs_interface.png) 访问这些文件进行读写就等于调用驱动代码的这些操作，驱动在加载的时候会去创建这些结点出来供用户空间调用和传递数据。下面是在/v831/lichee/linux 4.9/drivers/video/fbdev/sunxi/disp2/disp/dev_disp_debugfs.c的文件内容 ```C /* * Allwinner SoCs display driver. * * Copyright (C) 2016 Allwinner. * * This file is licensed under the terms of the GNU General Public * License version 2. This program is licensed \"as is\" without any * warranty of any kind, whether express or implied. */ #if defined(CONFIG_DISP2_SUNXI_DEBUG) #include \"dev_disp_debugfs.h\" static struct dentry *my_dispdbg_root; struct dispdbg_data { \tchar command[32]; \tchar name[32]; \tchar start[32]; \tchar param[64]; \tchar info[256]; \tchar tmpbuf[318]; }; static struct dispdbg_data dispdbg_priv; static void dispdbg_process(void) { \tunsigned int start; \tint err; \terr kstrtou32(dispdbg_priv.start, 10, &start); \tif (err) { \t\tpr_warn(\"Invalid para\\n\"); \t\treturn; \t} \tif (start ! 1) \t\treturn; \tif (!strncmp(dispdbg_priv.name, \"layer\", 5)) { \t\tchar *p dispdbg_priv.name + 5; \t\tchar *token p; \t\tunsigned int disp, chan, id; \t\tstruct disp_layer *lyr NULL; \t\tpr_warn(\"%s,%s\\n\", dispdbg_priv.command, dispdbg_priv.name); \t\ttoken strsep(&p, \" \"); \t\tif (!token) { \t\t\tpr_warn(\"Invalid para\\n\"); \t\t\treturn; \t\t} \t\terr kstrtou32(token, 10, &disp); \t\tif (err) { \t\t\tpr_warn(\"Invalid para\\n\"); \t\t\treturn; \t\t} \t\ttoken strsep(&p, \" \"); \t\tif (!token) { \t\t\tpr_warn(\"Invalid para\\n\"); \t\t\treturn; \t\t} \t\terr kstrtou32(token, 10, &chan); \t\tif (err) { \t\t\tpr_warn(\"Invalid para\\n\"); \t\t\treturn; \t\t} \t\ttoken strsep(&p, \" \"); \t\tif (!token) { \t\t\tpr_warn(\"Invalid para\\n\"); \t\t\treturn; \t\t} \t\terr kstrtou32(token, 10, &id); \t\tif (err) { \t\t\tpr_warn(\"Invalid para\\n\"); \t\t\treturn; \t\t} \t\tlyr disp_get_layer(disp, chan, id); \t\tif (lyr NULL) { \t\t\tsprintf(dispdbg_priv.info, \"get %s fail!\", \t\t\t\tdispdbg_priv.name); \t\t\treturn; \t\t} \t\tif (!strncmp(dispdbg_priv.command, \"enable\", 6)) { \t\t\t/* lyr >enable(lyr); */ \t\t} else if (!strncmp(dispdbg_priv.command, \"disable\", 7)) { \t\t\t/* lyr >disable(lyr); */ \t\t} else if (!strncmp(dispdbg_priv.command, \"getinfo\", 7)) { \t\t\tlyr >dump(lyr, dispdbg_priv.info); \t\t} else { \t\t\tsprintf(dispdbg_priv.info, \t\t\t\t\"not support command for %s!\", \t\t\t\tdispdbg_priv.name); \t\t\treturn; \t\t} ``` 意味着你可以通过这个接口产生的文件和内核进行数据交换，这层是属于直接显示驱动的，还有显示框架的功能可以使用，例如下图。 ![Img](./assets/0.png) 这里只是对屏幕显示驱动的调试做个一个示范，其他的也同理，细节可以参考 D1_Linux_Display_开发指南.pdf 一文。 如果这一切都十分正常的话，还是出现了错误，我们就需要检查一下寄存器了，这时候我们可以这样做。 这里我拿 定义 PWM 到绑定 GPIO 的寄存器配置做一个简单的示范。 首先知道用户空间提供的读写寄存器的接口，这个也和上述一致，只是底层开了这类接口给到 sysfs 了，可以参考 sunxi_dump_reg使用说明书.pdf ![Img](./assets/1.png) 我拿一个调试 pwm 设备的时候案例来举例，当把设备驱动、结点配置好了，驱动也写好了，当输出仍然没有反应，最终发现是寄存器的引脚 function 没有选到 pwm 而是 disable 的情况。 pwm 的控制方法如下： ```bash # pwm debug cat /sys/kernel/debug/pwm # pwm设置 echo 2 > /sys/class/pwm/pwmchip0/export && echo 100000 > /sys/class/pwm/pwmchip0/pwm2/period && echo 20000 > /sys/class/pwm/pwmchip0/pwm2/duty_cycle && echo 1 > /sys/class/pwm/pwmchip0/pwm2/enable echo 3 > /sys/class/pwm/pwmchip0/export && echo 100000 > /sys/class/pwm/pwmchip0/pwm3/period && echo 20000 > /sys/class/pwm/pwmchip0/pwm3/duty_cycle && echo 1 > /sys/class/pwm/pwmchip0/pwm3/enable ``` 现在我们来查阅 V833／V831_Datasheet_V1.1(For 索智).pdf 获取对应寄存器的地址信息，把输出的结果翻译过来，有时候发现某个设备的控制操作存在问题，直接对寄存器写入做最终配置，就可以检查到为什么了。 首先定位 GPIO 的基地址：0x0300B000 ![img](./assets/2.png) 接着定位到具有 pwm 功能的引脚 PD PH 组，如果是 PH 则地址偏移为 0x0300B000 + 0xfc (PH_CFG0) 0x0300B0FC。 ![img](./assets/3.png) 可以从该寄存器得知 PH 0:7 的功能选择情况，从图中可知其 四位 bit 为一组，现在我们可以用上述的方法对其进行修改和写入，从而实现的开和关，甚至是重新配置。 ```bash cd /sys/class/sunxi_dump/ echo 0x0300B0FC > dump cat dump root@sipeed:/# cd /sys/class/sunxi_dump/ root@sipeed:/sys/class/sunxi_dump# echo 0x0300B0FC > dump root@sipeed:/sys/class/sunxi_dump# cat dump 0x74471255 root@sipeed:/sys/class/sunxi_dump# # 0x74471255 > # 0b1110100010001110001001001010101 > # 0b 0111 0100 0100 0111 0001 0010 0101 0101 > # 0b 0111 0100 0100 0111 0001 0010 0111 0111 > # 0b1110100010001110001001001110111 > # 0x74471277 # 关闭最后两个 io 引脚的 function 的使用 cd /sys/class/sunxi_dump echo 0x0300B0FC 0x74471277 > write cat write root@sipeed:/# cd /sys/class/sunxi_dump root@sipeed:/sys/class/sunxi_dump# echo 0x0300B0FC 0x74471277 > write root@sipeed:/sys/class/sunxi_dump# cat write reg to_write after_write 0x0300b0fc 0x74471255 0x74471277 root@sipeed:/sys/class/sunxi_dump# ``` 以上上述操作就是打印寄存器和写入方法，通过这种方式可以跳过驱动和用户程序，直接将最终的寄存器配置结果设置上。 > 提供一种简单的方法 ```bash cat /sys/kernel/debug/pinctrl/pio/pinmux pins root@sipeed:/# cat /sys/kernel/debug/pinctrl/pio/pinmux pins Pinmux settings per pin Format: pin (name): mux_owner gpio_owner hog? pin 64 (PC0): sdc2 (GPIO UNCLAIMED) function sdc2 group PC0 pin 65 (PC1): sdc2 (GPIO UNCLAIMED) function sdc2 group PC1 pin 66 (PC2): (MUX UNCLAIMED) (GPIO UNCLAIMED) pin 67 (PC3): (MUX UNCLAIMED) (GPIO UNCLAIMED) pin 68 (PC4): sdc2 (GPIO UNCLAIMED) function sdc2 group PC4 pin 69 (PC5): sdc2 (GPIO UNCLAIMED) function sdc2 group PC5 pin 70 (PC6): sdc2 (GPIO UNCLAIMED) function sdc2 group PC6 pin 71 (PC7): sdc2 (GPIO UNCLAIMED) function sdc2 group PC7 pin 72 (PC8): sdc2 (GPIO UNCLAIMED) function sdc2 group PC8 pin 73 (PC9): sdc2 (GPIO UNCLAIMED) function sdc2 group PC9 pin 74 (PC10): (MUX UNCLAIMED) (GPIO UNCLAIMED) pin 75 (PC11): sdc2 (GPIO UNCLAIMED) function sdc2 group PC11 pin 96 (PD0): (MUX UNCLAIMED) (GPIO UNCLAIMED) pin 97 (PD1): soc@03000000:lcd0@01c0c000 (GPIO UNCLAIMED) function lcd0 group PD1 pin 98 (PD2): soc@03000000:lcd0@01c0c000 (GPIO UNCLAIMED) function lcd0 group PD2 pin 99 (PD3): soc@03000000:lcd0@01c0c000 (GPIO UNCLAIMED) function lcd0 group PD3 pin 100 (PD4): soc@03000000:lcd0@01c0c000 (GPIO UNCLAIMED) function lcd0 group PD4 pin 101 (PD5): soc@03000000:lcd0@01c0c000 (GPIO UNCLAIMED) function lcd0 group PD5 pin 102 (PD6): soc@03000000:lcd0@01c0c000 (GPIO UNCLAIMED) function lcd0 group PD6 pin 103 (PD7): soc@03000000:lcd0@01c0c000 (GPIO UNCLAIMED) function lcd0 group PD7 pin 104 (PD8): soc@03000000:lcd0@01c0c000 (GPIO UNCLAIMED) function lcd0 group PD8 pin 105 (PD9): (MUX UNCLAIMED) (GPIO UNCLAIMED) pin 106 (PD10): (MUX UNCLAIMED) (GPIO UNCLAIMED) pin 107 (PD11): (MUX UNCLAIMED) pio:107 pin 108 (PD12): (MUX UNCLAIMED) (GPIO UNCLAIMED) pin 109 (PD13): (MUX UNCLAIMED) (GPIO UNCLAIMED) pin 110 (PD14): (MUX UNCLAIMED) (GPIO UNCLAIMED) pin 111 (PD15): (MUX UNCLAIMED) (GPIO UNCLAIMED) pin 112 (PD16): (MUX UNCLAIMED) (GPIO UNCLAIMED) pin 113 (PD17): (MUX UNCLAIMED) (GPIO UNCLAIMED) pin 114 (PD18): soc@03000000:lcd0@01c0c000 (GPIO UNCLAIMED) function lcd0 group PD18 pin 115 (PD19): soc@03000000:lcd0@01c0c000 (GPIO UNCLAIMED) function lcd0 group PD19 pin 116 (PD20): (MUX UNCLAIMED) (GPIO UNCLAIMED) pin 117 (PD21): soc@03000000:lcd0@01c0c000 (GPIO UNCLAIMED) function lcd0 group PD21 pin 118 (PD22): soc@03000000:pwm9@0300a000 (GPIO UNCLAIMED) function pwm9 group PD22 pin 128 (PE0): csi1 (GPIO UNCLAIMED) function csi1 group PE0 pin 129 (PE1): sensor1 (GPIO UNCLAIMED) function csi_mclk1 group PE1 pin 130 (PE2): csi1 (GPIO UNCLAIMED) function csi1 group PE2 pin 131 (PE3): csi1 (GPIO UNCLAIMED) function csi1 group PE3 pin 132 (PE4): csi1 (GPIO UNCLAIMED) function csi1 group PE4 pin 133 (PE5): csi1 (GPIO UNCLAIMED) function csi1 group PE5 pin 134 (PE6): csi1 (GPIO UNCLAIMED) function csi1 group PE6 pin 135 (PE7): csi1 (GPIO UNCLAIMED) function csi1 group PE7 pin 136 (PE8): csi1 (GPIO UNCLAIMED) function csi1 group PE8 pin 137 (PE9): csi1 (GPIO UNCLAIMED) function csi1 group PE9 pin 138 (PE10): csi1 (GPIO UNCLAIMED) function csi1 group PE10 pin 139 (PE11): csi1 (GPIO UNCLAIMED) function csi1 group PE11 pin 140 (PE12): (MUX UNCLAIMED) (GPIO UNCLAIMED) pin 141 (PE13): (MUX UNCLAIMED) pio:141 pin 142 (PE14): (MUX UNCLAIMED) (GPIO UNCLAIMED) pin 143 (PE15): (MUX UNCLAIMED) (GPIO UNCLAIMED) pin 144 (PE16): twi4 (GPIO UNCLAIMED) function twi0 group PE16 pin 145 (PE17): twi4 (GPIO UNCLAIMED) function twi1 group PE17 pin 146 (PE18): uart2 (GPIO UNCLAIMED) function uart2 group PE18 pin 147 (PE19): uart2 (GPIO UNCLAIMED) function uart2 group PE19 pin 148 (PE20): (MUX UNCLAIMED) pio:148 pin 149 (PE21): (MUX UNCLAIMED) pio:149 pin 160 (PF0): sdc0 (GPIO UNCLAIMED) function sdc0 group PF0 pin 161 (PF1): sdc0 (GPIO UNCLAIMED) function sdc0 group PF1 pin 162 (PF2): sdc0 (GPIO UNCLAIMED) function sdc0 group PF2 pin 163 (PF3): sdc0 (GPIO UNCLAIMED) function sdc0 group PF3 pin 164 (PF4): sdc0 (GPIO UNCLAIMED) function sdc0 group PF4 pin 165 (PF5): sdc0 (GPIO UNCLAIMED) function sdc0 group PF5 pin 166 (PF6): (MUX UNCLAIMED) pio:166 pin 192 (PG0): sdc1 (GPIO UNCLAIMED) function io_disabled group PG0 pin 193 (PG1): sdc1 (GPIO UNCLAIMED) function io_disabled group PG1 pin 194 (PG2): sdc1 (GPIO UNCLAIMED) function io_disabled group PG2 pin 195 (PG3): sdc1 (GPIO UNCLAIMED) function io_disabled group PG3 pin 196 (PG4): sdc1 (GPIO UNCLAIMED) function io_disabled group PG4 pin 197 (PG5): sdc1 (GPIO UNCLAIMED) function io_disabled group PG5 pin 198 (PG6): (MUX UNCLAIMED) (GPIO UNCLAIMED) pin 199 (PG7): (MUX UNCLAIMED) (GPIO UNCLAIMED) pin 224 (PH0): uart3 (GPIO UNCLAIMED) function uart3 group PH0 pin 225 (PH1): uart3 (GPIO UNCLAIMED) function uart3 group PH1 pin 226 (PH2): (MUX UNCLAIMED) (GPIO UNCLAIMED) pin 227 (PH3): (MUX UNCLAIMED) (GPIO UNCLAIMED) pin 228 (PH4): (MUX UNCLAIMED) (GPIO UNCLAIMED) pin 229 (PH5): twi2 (GPIO UNCLAIMED) function twi2 group PH5 pin 230 (PH6): twi2 (GPIO UNCLAIMED) function twi2 group PH6 pin 231 (PH7): (MUX UNCLAIMED) (GPIO UNCLAIMED) pin 232 (PH8): (MUX UNCLAIMED) (GPIO UNCLAIMED) pin 233 (PH9): uart0 (GPIO UNCLAIMED) function uart0 group PH9 pin 234 (PH10): uart0 (GPIO UNCLAIMED) function uart0 group PH10 pin 235 (PH11): spi1 (GPIO UNCLAIMED) function spi1 group PH11 pin 236 (PH12): spi1 (GPIO UNCLAIMED) function spi1 group PH12 pin 237 (PH13): spi1 (GPIO UNCLAIMED) function spi1 group PH13 pin 238 (PH14): spi1 (GPIO UNCLAIMED) function spi1 group PH14 pin 239 (PH15): spi1 (GPIO UNCLAIMED) function spi1 group PH15 pin 256 (PI0): sensor0 (GPIO UNCLAIMED) function csi_mclk0 group PI0 pin 257 (PI1): twi1 (GPIO UNCLAIMED) function twi1 group PI1 pin 258 (PI2): twi1 (GPIO UNCLAIMED) function twi1 group PI2 pin 259 (PI3): (MUX UNCLAIMED) pio:259 pin 260 (PI4): (MUX UNCLAIMED) pio:260 root@sipeed:/# cat /sys/kernel/debug/pinctrl/r_pio/pinmux pins Pinmux settings per pin Format: pin (name): mux_owner gpio_owner hog? pin 352 (PL0): twi0 (GPIO UNCLAIMED) function s_twi0 group PL0 pin 353 (PL1): twi0 (GPIO UNCLAIMED) function s_twi0 group PL1 pin 354 (PL2): (MUX UNCLAIMED) (GPIO UNCLAIMED) pin 355 (PL3): (MUX UNCLAIMED) (GPIO UNCLAIMED) pin 356 (PL4): (MUX UNCLAIMED) (GPIO UNCLAIMED) pin 357 (PL5): (MUX UNCLAIMED) (GPIO UNCLAIMED) root@sipeed:/# ``` 其他寄存器同理，有时候设备树配置了但没有起作用的时候，不妨先用这个方法判断一下最底层的配置情况。 ## 拓展介绍给 SDK 加入没有的外设驱动调试和开发流程 这些事情常发生在换料的时候，例如屏幕、触摸、摄像头、WIFI，这些在 2020 ～ 2022 年之间价格波动较大的物料，所以也要掌握具体的适配和更新的能力。 拿到供应商的原料代码，大多数可能是用 MCU 、FPGA 等其他平台写的，也可能没有代码，就一些寄存器手册，这时候怎么写？ 例如平时拿到的资料可能是下面这样的： 某屏幕的配置资料 ```c \t.hfp 30; \t.hbp 30; \t.hsync 10; \t.horizontal_active_pixel 480; \t.vfp 20; \t.vbp 20; \t.vsync 10; .vertical_active_line 854; PCLK 30MHZ WriteComm (0xE8); WriteData (0x00); WriteData (0x0E); WriteComm (0xFF); WriteData (0x77); WriteData (0x01); WriteData (0x00); WriteData (0x00); WriteData (0x00); WriteComm (0x11); Delayms (120); WriteComm (0xFF); WriteData (0x77); WriteData (0x01); WriteData (0x00); WriteData (0x00); WriteData (0x13); WriteComm (0xE8); WriteData (0x00); WriteData (0x0C); Delayms (10); ``` ![Img](./assets/4.png) 某摄像头的配置资料 ```c static struct regval_list sensor_1080p20_regs[] { //window_size 1920*1080 mipi@2lane //mclk 24mhz,mipi_clk 594Mbps //pixel_line_total 2640,line_frame_total 1125 //row_time 35.55us,frame_rate 25fps /////////////////////////////////////////////////////////////// {0xfe, 0xf0}, {0xfe, 0xf0}, {0xfe, 0xf0}, {0xfe, 0x00}, {0xf2, 0x00},//[1]I2C_open_ena [0]pwd_dn {0xf3, 0x00},//0f//00[3]Sdata_pad_io [2:0]Ssync_pad_io {0xf4, 0x36},//[6:4]pll_ldo_set {0xf5, 0xc0},//[7]soc_mclk_enable [6]pll_ldo_en [5:4]cp_clk_sel [3:0]cp_clk_div ``` 基本上什么也做不了，我们要从这里提取我们需要的讯息，驱动 IC 型号和 datasheet ，模组的规格书等讯息。 如果是屏幕要确定驱动接口 im 的选择，确认通信的方式，并行 I8080 还是 mipi dsi 还是 spi 等其他的串行，进一步再确认输出图像的格式，RGB565 、 RGB888 等，如何调试屏幕可以看我的这篇 [理解 LCD 屏幕的驱动原理与调试过程，示例的驱动 IC 为 GC9308](https://www.cnblogs.com/juwan/p/13069102.html) ，展示整个屏幕的驱动过程。 和 D1_Tina_Linux_Display_开发指南.pdf ，主要是软件部分，硬件电路部分就让硬件去检查就行，自己优先确认 RESET 和 CLK 时序没问题就行。 可以参见 ./lichee/linux 4.9/drivers/video/fbdev/sunxi/disp2/disp/lcd/st7701s.c 为例。 如果是摄像头则要先确认 RESET 、 PWDN 、 I2C addr 、 MCLK 时钟的基础信息，再来确认配置流程和输出图像的格式，RAW BGGR 、YUV422 等。 可以参见 ./lichee/linux 4.9/drivers/video/fbdev/sunxi/disp2/disp/lcd/st7701s.c 为例。 上述两者只是简单介绍了通常调试时的基本观念，接下来就结合 Tina Linux 的底层接口来说明问题。 可以参见 ./lichee/linux 4.9/drivers/media/platform/sunxi vin/modules/sensor/gc0328.c 为例。 在不同平台上写任何驱动的时候，我们都需要对驱动框架有一个整体的认识，以屏幕和摄像头两个典型为例。 > 202x 年后 sunxi 的显示驱动框架以下述为概括 ![IMG](./assets/5.png) ![IMG](./assets/6.png) 通常来说，一些简单的场合我们可以直接使用 framebuffer 驱动产生的 /dev/fb0 进行屏幕的绘图，但经过了 display engine 框架后就具备了图层的概念，也比 fb 多出更多图像处理功能。 ![IMG](./assets/7.png) 知道这个以后，我们主要关注的是也仅仅只是驱动层部分，只需要将其对接进去框架就行，不管它是走 fb 还是走 de 都只是上层驱动接管的，用户再去调用就行。 所以移植测试的时候可以直接使用 fb 或 debugfs 测试，而不用担心用户层通过 mpp 的 vo 访问了 hwdisplay 后调用的 de 合成后显示是否会存在不一致的问题，lcd 驱动只需要完成驱动屏幕的配置即可。 所以根据实际情况进行寄存器的配置就行，具体要看 tcon 硬件资源的配置了，以及如何支持 lcd(hv/lvds/cpu/dsi) 的显示，主要看 lcd_if 的定义，这个可以从 LCD调试使用说明书.pdf 中得知。 ![Img](./assets/8.png) 至于为什么支持和支持多少，则要从 datasheet 中得知。 ![Img](./assets/9.png) 知道了底层的基本情况（不需要细看或背下来），我们可以在参考驱动中取得相应的设备树配置。 ```c /* * drivers/video/fbdev/sunxi/disp2/disp/lcd/s2003t46/s2003t46g.c * * Copyright (c) 2007 2018 Allwinnertech Co., Ltd. * Author: zhengxiaobin <zhengxiaobin@allwinnertech.com> * * This software is licensed under the terms of the GNU General Public * License version 2, as published by the Free Software Foundation, and * may be copied, distributed, and modified under those terms. * * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the * GNU General Public License for more details. * * lcd_used <1>; lcd_driver_name \"st7789v_cpu\"; lcd_backlight <150>; lcd_if <1>; lcd_x <240>; lcd_y <320>; lcd_width <108>; lcd_height <64>; lcd_dclk_freq <18>; lcd_pwm_used <1>; lcd_pwm_ch <8>; lcd_pwm_freq <50000>; lcd_pwm_pol <1>; lcd_pwm_max_limit <255>; lcd_hbp <60>; lcd_ht <298>; lcd_hspw <30>; lcd_vbp <340>; lcd_vt <336>; lcd_vspw <2>; lcd_frm <1>; lcd_io_phase <0x0000>; lcd_hv_clk_phase <0>; lcd_hv_sync_polarity <0>; lcd_hv_data_polarity <1>; lcd_gamma_en <0>; lcd_bright_curve_en <0>; lcd_cmap_en <0>; lcdgamma4iep <22>; lcd_cpu_mode <1>; lcd_cpu_te <1>; lcd_cpu_if\t <12>; lcd_hv_if\t \t <0>; lcd_hv_srgb_seq\t <0>; lcd_rb_swap\t\t\t <0>; lcd_gpio_0 <&pio PE 16 1 0 3 0>; lcd_gpio_1 <&pio PE 17 1 0 3 0>; pinctrl 0 <&rgb8_pins_a>; pinctrl 1 <&rgb8_pins_b>; */ #include \"st7789v_cpu.h\" ``` 这时候检查 menuconfig 配置并加入到设备树里就行了，如果发现没有反应，可以看 dmesg 或 直接打印 tcon 的寄存器来确认配置情况，屏幕驱动基本就到这里了，怎么测试就用 fbdisplay 就行，或者类似的 fb 显示。 关于摄像头这里我简单介绍一下基础的框架，由于 V831 / V833 是提供了 AW MPP IPC 媒体处理软件封装，可以大幅度的使用这些外设，如 vi vo ai ao isp ise 等，但并不是说脱离了 mpp 就不能用。 例如 sunxi 摄像头的 vin 驱动框架如下图：(上一代为 vfe 里面还可以看到代码) ，细节可以参见 SUNXI VIN模块使用文档.pdf 。 ![Img](./assets/10.png) 主要框架为 V4L2 框架，效果就是可以得到 /dev/videoX 设备进行摄像头数据的读取，可以通过 camerademo 或 sample_virvi 来调试摄像头输入，前者直接访问设备，后者经过 mpp 框架。 介绍一下摄像头的设备树 sensor0 和 sensor1 表示多个 sensor 通常为 前 和 后 摄像头 其中 sensorX_reset sensor0_pwdn 由 sensor_power.ko 统一管理，启动时经过 /etc/initd.d/S0mpp 统一加载注册。 sensor0_twi_cci_id 为绑定的 twi(i2c) 或 cci 用于配置摄像头的通路，如 sensor0_twi_cci_id <1>; 表示 使用 twi1 这个 /dev/i2c 1 的设备去访问摄像头，所以你可以用 i2cdetect y 1 来扫摄像头设备。 ```dts sensor0:sensor@0 { device_type \"sensor0\"; sensor0_twi_cci_id <1>; // sensor0_mname \"sp2305_mipi\"; // sensor0_twi_addr <0x78>; sensor0_mname \"gc2093_mipi\"; sensor0_twi_addr <0x6e>; // 0x6e 0xfd sensor0_phase <1>; // pwdn sensor0_mclk_id <0>; sensor0_pos \"rear\"; sensor0_isp_used <1>; sensor0_fmt <1>; sensor0_stby_mode <0>; sensor0_vflip <1>; sensor0_hflip <1>; sensor0_iovdd supply <>; // sensor0_iovdd supply <&reg_aldo2>; sensor0_iovdd_vol <1800000>; sensor0_avdd supply <>; sensor0_avdd_vol <2800000>; sensor0_dvdd supply <>; // sensor0_dvdd supply <&reg_dldo2>; sensor0_dvdd_vol <1200000>; sensor0_power_en <>; sensor0_reset <&pio PI 3 1 0 1 0>; sensor0_pwdn <&pio PI 4 1 0 1 0>; status\t \"okay\"; }; ``` 经过了摄像头的基础配置后，我们需要注意一下，摄像头的 ko 模块是外部注入到系统目录的（可见于 ./target/allwinner/xxxx/modules.mk ），而非包含在 kernel 内部的，好处就是可以放很多个摄像头模块，而不用重烧系统，更换设备树即可，如何更新设备树看 [关于 V831 / V833 Tina Linux 更新设备树（ dts > dtb ）的用法](https://www.cnblogs.com/juwan/p/14345372.html) 。 ```dts define KernelPackage/vin v4l2 SUBMENU: $(VIDEO_MENU) TITLE: Video input support (staging) DEPENDS: FILES: $(LINUX_DIR)/drivers/media/v4l2 core/videobuf2 core.ko FILES+ $(LINUX_DIR)/drivers/media/v4l2 core/videobuf2 dma contig.ko FILES+ $(LINUX_DIR)/drivers/media/v4l2 core/videobuf2 memops.ko FILES+ $(LINUX_DIR)/drivers/media/v4l2 core/videobuf2 v4l2.ko FILES+ $(LINUX_DIR)/drivers/media/platform/sunxi vin/vin_io.ko FILES+ $(LINUX_DIR)/drivers/media/platform/sunxi vin/vin_v4l2.ko FILES+ $(LINUX_DIR)/drivers/media/platform/sunxi vin/modules/sensor/gc2053_mipi.ko FILES+ $(LINUX_DIR)/drivers/media/platform/sunxi vin/modules/sensor/gc2093_mipi.ko FILES+ $(LINUX_DIR)/drivers/media/platform/sunxi vin/modules/sensor/sp2305_mipi.ko FILES+ $(LINUX_DIR)/drivers/media/platform/sunxi vin/modules/sensor/gc0328.ko FILES+ $(LINUX_DIR)/drivers/media/platform/sunxi vin/modules/sensor/gc2145.ko FILES+ $(LINUX_DIR)/drivers/media/platform/sunxi vin/modules/sensor_power/sensor_power.ko # FILES+ $(LINUX_DIR)/drivers/video/fbdev/sunxi/disp2/hdmi2/hdmi20.ko AUTOLOAD: $(call AutoProbe,videobuf2 core videobuf2 dma contig videobuf2 memops videobuf2 v4l2 vin_io vin_v4l2 sp2305_mipi gc2145 sensor_power) endef define KernelPackage/vin_v4l2/description Kernel modules for video input support endef $(eval $(call KernelPackage,vin v4l2)) ``` 经过这个配置以后，就会在 build 的时候将其打包到 lib/modules/4.9/ 目录下，然后在用户空间注册就行，但要记得在 menuconfig 选中这类 kmod_xxx 模块，不同于 kernel_menuconfig ，它的用途是从 kernel 中提取需要的模块（modules）。 ![Img](./assets/11.png) 接下来介绍一下摄像头的基础配置结构代码参考： ```c /* * A V4L2 driver for Raw cameras. * * Copyright (c) 2017 by Allwinnertech Co., Ltd. http://www.allwinnertech.com * * Authors: Chen weihong <chenweihong@allwinnertech.com> * * * This program is free software; you can redistribute it and/or modify * it under the terms of the GNU General Public License version 2 as * published by the Free Software Foundation. */ #include <linux/init.h> #include <linux/module.h> #include <linux/slab.h> #include <linux/i2c.h> #include <linux/delay.h> #include <linux/videodev2.h> #include <linux/clk.h> #include <media/v4l2 device.h> #include <media/v4l2 mediabus.h> #include <linux/io.h> #include \"camera.h\" #include \"sensor_helper.h\" MODULE_AUTHOR(\"zhj\"); MODULE_DESCRIPTION(\"A low level driver for GC2093sensors\"); MODULE_LICENSE(\"GPL\"); #define MCLK (24*1000*1000) #define V4L2_IDENT_SENSOR 0x2093 //define the registers #define EXP_HIGH\t\t0xff #define EXP_MID\t\t\t0x03 #define EXP_LOW\t\t\t0x04 #define GAIN_HIGH\t\t0xff #define GAIN_LOW\t\t0x24 /* * Our nominal (default) frame rate. */ #define ID_REG_HIGH\t\t0x03f0 #define ID_REG_LOW\t\t0x03f1 #define ID_VAL_HIGH\t\t((V4L2_IDENT_SENSOR) >> 8) #define ID_VAL_LOW\t\t((V4L2_IDENT_SENSOR) & 0xff) #define SENSOR_FRAME_RATE 30 #define HDR_RATIO 16 #define short_exp_max 124 /* * The GC2093i2c address */ #define I2C_ADDR 0x6e #define SENSOR_NUM 0x2 #define SENSOR_NAME \"gc2093_mipi\" #define SENSOR_NAME_2 \"gc2093_mipi_2\" ``` 有很多同类参考，主要看 sensor 厂家（gc ov imx sc）和 输出图像类型 (RAW YUV RGB)，可以不拘泥于实现的平台，关键看寄存器配置（static struct regval_list sensor_default_regs）和增益（gain）曝光（exp）的映射函数的实现，大多数 sensor 的实现都是乱写的，但目的就是要函数输入的值对应 sensor 的曝光呈现小到大的线性关系。 这里我演示一下几处关键注意的地方： ```c static int sensor_init(struct v4l2_subdev *sd, u32 val) { \tint ret; \tstruct sensor_info *info to_state(sd); \tsensor_dbg(\"sensor_init\\n\"); \t/*Make sure it is a target sensor */ \tret sensor_detect(sd); \tif (ret) { \t\tsensor_err(\"chip found is not an target chip.\\n\"); \t\treturn ret; \t} \tinfo >focus_status 0; \tinfo >low_speed 0; \tinfo >width 1920; \tinfo >height 1080; \tinfo >hflip 0; \tinfo >vflip 0; \tinfo >gain 0; \tinfo >exp 0; \tinfo >tpf.numerator 1; \tinfo >tpf.denominator 25;\t/* 30fps */ \tinfo >preview_first_flag 1; \treturn 0; } /* * Store information about the video data format. */ static struct sensor_format_struct sensor_formats[] { \t{ \t\t.desc \"Raw RGB Bayer\", \t\t.mbus_code MEDIA_BUS_FMT_SRGGB10_1X10, /*.mbus_code MEDIA_BUS_FMT_SBGGR10_1X10, */ \t\t.regs sensor_fmt_raw, \t\t.regs_size ARRAY_SIZE(sensor_fmt_raw), \t\t.bpp 1 \t}, }; #define N_FMTS ARRAY_SIZE(sensor_formats) static struct sensor_win_size sensor_win_sizes[] { \t#if 0 \t{ \t\t.width 1920, \t\t.height 1080, \t\t.hoffset 0, \t\t.voffset 0, \t\t.hts 2900, \t\t.vts 1350, \t\t.pclk 97.9 * 1000 * 1000, \t\t.mipi_bps 391.5 * 1000 * 1000, \t\t.fps_fixed 25, \t\t.bin_factor 1, \t\t.intg_min 1 << 4, \t\t.intg_max 1125 << 4, \t\t.gain_min 1 << 4, \t\t.gain_max 110 << 4, \t\t.regs sensor_1920x1080p30_regs, \t\t.regs_size ARRAY_SIZE(sensor_1920x1080p30_regs), \t\t.set_size NULL, \t\t.top_clk 300*1000*1000, \t\t.isp_clk 297*1000*1000, \t}, \t#endif \t{ \t\t.width 1920, \t\t.height 1080, \t\t.hoffset 0, \t\t.voffset 0, \t\t.hts 2816, \t\t.vts 1250, \t\t.pclk 176 * 1000 * 1000, \t\t.mipi_bps 704 * 1000 * 1000, \t\t.fps_fixed 25, \t\t.bin_factor 1, \t\t.if_mode MIPI_VC_WDR_MODE, \t\t.wdr_mode ISP_DOL_WDR_MODE, \t\t.intg_min 1 << 4, \t\t.intg_max 1250 << 4, \t\t.gain_min 1 << 4, \t\t.gain_max 48 << 4, \t\t.regs sensor_1920x1080p30_wdr_regs, \t\t.regs_size ARRAY_SIZE(sensor_1920x1080p30_wdr_regs), \t\t.set_size NULL, \t\t.top_clk 300*1000*1000, \t\t.isp_clk 351*1000*1000, \t}, }; /* * Code for dealing with controls. * fill with different sensor module * different sensor module has different settings here * if not support the follow function , retrun EINVAL */ static int sensor_g_exp(struct v4l2_subdev *sd, __s32 *value) { \tstruct sensor_info *info to_state(sd); \t*value info >exp; \tsensor_dbg(\"sensor_get_exposure %d\\n\", info >exp); \treturn 0; } static int sensor_s_exp(struct v4l2_subdev *sd, unsigned int exp_val) { \tstruct sensor_info *info to_state(sd); \t \tint tmp_exp_val exp_val / 16; \tint exp_short 0; unsigned int intt_long_h, intt_long_l,intt_short_h,intt_short_l; \t \tif (info >isp_wdr_mode ISP_DOL_WDR_MODE) \t{ //sensor_dbg(\"Sensor in WDR mode, HDR_RATIO %d\\n\", HDR_RATIO); if(tmp_exp_val<1*HDR_RATIO) \t { \t tmp_exp_val 1*HDR_RATIO ; \t } \t if(tmp_exp_val>1100) \t { \t\t tmp_exp_val 1100; \t } \t\texp_short tmp_exp_val / HDR_RATIO; \t\t \t intt_long_l tmp_exp_val & 0xff; \t intt_long_h (tmp_exp_val >> 8) & 0x3f; \t \t intt_short_l exp_short & 0xff; \t intt_short_h (exp_short >> 8) & 0x3f; \t\tsensor_write(sd,0x0003, intt_long_h); \t\tsensor_write(sd,0x0004, intt_long_l); \t\tsensor_print(\"sensor_set_long_exp 20210302 %x line Done!\\n\", tmp_exp_val); \t\tsensor_write(sd,0x0001, intt_short_h); \t\tsensor_write(sd,0x0002, intt_short_l); \t\tsensor_print(\"sensor_set_short_exp 20210302 %x line Done!\\n\", exp_short); \t} \telse \t{ \t\tsensor_dbg(\"exp_val:%d\\n\", exp_val); \t\tsensor_write(sd, 0x0003, (tmp_exp_val >> 8) & 0xFF); \t\tsensor_write(sd, 0x0004, (tmp_exp_val & 0xFF)); \t} \tinfo >exp exp_val; \treturn 0; } static int sensor_g_gain(struct v4l2_subdev *sd, __s32 *value) { \tstruct sensor_info *info to_state(sd); \t*value info >gain; \tsensor_print(\"sensor_get_gain 20210302 %x\\n\", info >gain); \treturn 0; } ``` vin 的 sensor_power 有两处地方，mpp 方面使用 ./linux 4.9/drivers/media/platform/sunxi vin/modules/sensor_power/sensor_power.c 自行管理，也可以直接的 V4L2 驱动内部的 static int sensor_power(struct v4l2_subdev *sd, int on) 函数进行管理，所以要注意 PWDN 和 RESET 的方向和执行的主体。 ```c static int sensor_power_on(struct sensor_power_dev *sensor_power) { \tif (sensor_power >id 0 sensor_power >id 1) { /* sensor0 or sensor1 power on */ \t\tsensor_set_pmu_channel(sensor_power, IOVDD, ON); \t\tsensor_set_pmu_channel(sensor_power, DVDD, ON); \t\tsensor_set_pmu_channel(sensor_power, AVDD, ON); \t\tusleep_range(1000, 1200); \t\tsensor_gpio_set_status(sensor_power, RESET, 1); \t\tsensor_gpio_set_status(sensor_power, PWDN, 1); \t\tsensor_gpio_write(sensor_power, RESET, SENSOR_GPIO_HIGH); \t\tsensor_gpio_write(sensor_power, PWDN, (sensor_power >phase) ? SENSOR_GPIO_HIGH : SENSOR_GPIO_LOW); \t\t usleep_range(1000, 1200); \t\tsensor_set_mclk(sensor_power, ON); \t\tvin_set_mclk_freq(sensor_power, sensor_power >mclk.frequency); \t\tusleep_range(1000, 1200); \t} \treturn 0; }; static void sensor_power_off(struct sensor_power_dev *sensor_power) { \tif (sensor_power >id 0 sensor_power >id 1) { /* sensor0 or sensor1 power off */ \t\tsensor_set_pmu_channel(sensor_power, IOVDD, OFF); \t\tsensor_set_pmu_channel(sensor_power, DVDD, OFF); \t\tsensor_set_pmu_channel(sensor_power, AVDD, OFF); \t\tsensor_gpio_set_status(sensor_power, RESET, 1); \t\tsensor_gpio_set_status(sensor_power, PWDN, 1); \t\tsensor_gpio_write(sensor_power, RESET, SENSOR_GPIO_LOW); \t\tsensor_gpio_write(sensor_power, PWDN, (sensor_power >phase) ? SENSOR_GPIO_LOW : SENSOR_GPIO_HIGH); \t\t \t\tsensor_set_mclk(sensor_power, OFF); \t\tusleep_range(1000, 1200); \t} } ``` 最后在进行 ISP 调试前先确认输出的是 RAW 图[【小技巧】如何从 datasheet 中得知自己的 sensor 是什么 RAW 输出 ](https://www.cnblogs.com/juwan/p/15077378.html)，还有 增益 曝光函数要检查一下边界，否则会出现 ISP 控制时不匹配的情况，至于 ISP 如何调试，可以参考 [摄像头 ISP 调试的经验之谈（以全志 AW hawkview 为例）](https://www.cnblogs.com/juwan/p/14865188.html)，该文只是介绍了基础，但具体如何调试我需要手把手演示和说明。 大部分情况下驱动外设都是修改适配一下，而不需要重造轮子，但要结合上层来进行调试，如触摸屏、摄像头、按键方面的驱动要通过上层程序接收输入。 当然很新的设计可能要重新设计框架，这种就比较少见了，本文只是速成培训教程。 MPP 框架的使用和调用，我会另外再出一篇文档。 ## 总结一下 到这里为止，我们应该能够学会和掌握修改 SDK 的能力了，但源码的细节还有框架的使用，以及一些芯片的资源的细节就需要自己琢磨琢磨了，如果有必要可以直接和我说需要什么资料或者什么部分看不懂，我会在资料里面补充的。 注意，本次培训材料不是教你如何写代码，只是向你介绍了全志现在的 Tina Linux 的整体情况，如果要加功能或修 bug 应该从哪些地方下手，其中代码上很细节的部分，可能亲自演示一下要比这样整理写出来更好。"},"/soft/Lichee/zh/linux/start/introduction.html":{"title":"Linux 简述","content":"# Linux 简述 为了更好的开发Lichee linux板子，有必要简单介绍一下linux。 编者水平有限，发现错误的话谢谢帮忙修改 ## 嵌入式linux简述 Linux，全称GNU/Linux，是一种免费使用和自由传播的类UNIX操作系统，其内核由林纳斯·本纳第克特·托瓦兹于1991年10月5日首次发布，它主要受到Minix和Unix思想的启发，是一个基于POSIX的多用户、多任务、支持多线程和多CPU的操作系统。它能运行主要的Unix工具软件、应用程序和网络协议。它支持32位和64位硬件。Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。Linux有上百种不同的发行版，如基于社区开发的debian、archlinux，和基于商业开发的Red Hat Enterprise Linux、SUSE、Oracle Linux等。 ——摘自[百度百科](https://baike.baidu.com/item/linux/27050) 一般移动设备使用的是linux为嵌入式linux，嵌入式linux是为了适配低端设备而将linux操作系统进行裁剪修改，使之能在嵌入式计算机系统上运行的一种操作系统。 ## 嵌入式Linux启动方式 Bootloader > kernel > rootfs > application ### Bootloader BootLoader是在操作系统内核运行之前运行。可以初始化硬件设备、建立内存空间映射图，从而将系统的软硬件环境带到一个合适状态，以便为最终调用操作系统内核准备好正确的环境。在嵌入式系统中，通常并没有像BIOS那样的固件程序（注，有的嵌入式CPU也会内嵌一段短小的启动程序），因此整个系统的加载启动任务就完全由BootLoader来完成。 ——摘自[百度百科](https://baike.baidu.com/item/Bootloader/8733520) Bootloader 就是一段初始化和引导程序，一般不同的硬件的 Bootloader 不会相同。 ### Kernel Linux 内核 (Kernel) 是 Linux 操作系统（OS）的主要组件，也是计算机硬件与其进程之间的核心接口。它负责两者之间的通信，还要尽可能高效地管理资源。 ——摘自[Red Hat](https://www.redhat.com/zh/topics/linux/what is the linux kernel) Kernel 是操作系统的核心。它管理着硬件资源，提供了软件操作硬件的接口。 ### Rootfs 根文件 (Rootfs) 系统首先是内核启动时所mount的第一个文件系统，内核代码映像文件保存在根文件系统中，而系统引导启动程序会在根文件系统挂载之后从中把一些基本的初始化脚本和服务等加载到内存中去运行。 ——摘自[百度百科](https://baike.baidu.com/item/%E6%A0%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F) 在 linux 系统中，所有的一切都是以文件形式存在的，系统启动后的所有东西都被挂载到根目录。 ### Application Application 就是 Linux 启动后所运行的程序，比如操作系统和用户程序都可以认为是application。 ## 嵌入式Linux相关知识点 Shell 基本操作 系统环境配置 (配置PATH) C 语言基础 交叉编译开发应用 (熟悉gcc,gdb等) 基础外设知识 驱动开发 系统移植"},"/soft/Lichee/zh/linux/start/buildroot.html":{"title":"Buildroot","content":"# Buildroot > 在深入介绍前先介绍一下 Buildroot ## Buildroot 简介 Buildroot 是在 linux 系统下使用交叉编译来简化和自动构建完整嵌入式 linux 系统的一种工具。它能够用来生成针对你目标设备的交叉编译工具链、内核镜像和 bootloader，Buildroot 可以独立用来生成上述任意组合（比如你可以用已有的工具链使用 Buildroot 来构建一个自己的根文件系统）。 ——摘自[Buildroot官方文档] [Buildroot官网](https://buildroot.org/)https://buildroot.org/ 和 [官方文档](https://buildroot.org/downloads/manual/manual.pdf) https://buildroot.org/docs.html 发现正点原子翻译了 Buildroot。参考链接放在下面了： https://alientek linux.coding.net/public/imx6ull/10_User_Manual/git/files 其他相关外部参考： [Arnold Lu@南京](https://www.cnblogs.com/arnoldlu/p/9553995.html)"}}