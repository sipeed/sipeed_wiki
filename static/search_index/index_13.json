{"/soft/maixpy/en/course/image/basic/acc_image_deal.html":{"title":"Hardware accelerated image processing","content":" title: Hardware accelerated image processing keywords: maixpy, k210, AIOT, edge computing desc: maixpy hardware accelerated image processing Using hardware to replace certain software parts can make the calculation faster. The methods of acceleration optimization have been done as follows: The following code respectively performs `edge search`, `sharpening`, and `embossing` on the image, and uses the convolution calculation to quickly obtain the result. ```python import sensor import image import lcd import time lcd.init(freq 15000000) sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) origin (0,0,0, 0,1,0, 0,0,0) edge ( 1, 1, 1, 1,8, 1, 1, 1, 1) sharp ( 1, 1, 1, 1,9, 1, 1, 1, 1) relievo (2,0,0,0, 1,0,0,0, 1) tim time.time() while True: img sensor.snapshot() img.conv3(edge) lcd.display(img) if time.time() tim >10: break tim time.time() while True: img sensor.snapshot() img.conv3(sharp) lcd.display(img) if time.time() tim >10: break tim time.time() while True: img sensor.snapshot() img.conv3(relievo) lcd.display(img) if time.time() tim >10: break lcd.clear() ```"},"/soft/maixpy/en/course/image/basic/display_images.html":{"title":"Show picture","content":" title: Show picture keywords: maixpy, k210, AIOT, edge computing desc: maixpy show picture Displaying the picture is very simple. You can use the `lcd` module directly and call the function to display it, as follows: ```python import lcd, image lcd.init() img image.Image(\"/sd/test.jpg\") lcd.display(img) ``` But different screen initialization sequence may be different. There are many optional parameters in `lcd.init`. See the description of API document for details. Common ones are as follows For IPS screens, you need to reverse the color: ```python lcd.init(type 2) ``` For the screen is not very good, you need to lower the frequency, or if you are good, you need to overclock: ```python lcd.init(freq 15000000) ``` In addition, you can also set the rotation direction of the screen: ```python lcd.rotation(2) ``` The parameters are `0～3`, which respectively represent clockwise rotation `0 degrees` `90 degrees` `180 degrees` `270 degrees` For more methods, please refer to [lcd document](/api_reference/machine_vision/lcd.md)"},"/soft/maixpy/en/course/image/basic/draw.html":{"title":"drawing and writing","content":" title: drawing and writing keywords: maixpy, k210, AIOT, edge computing desc: maixpy drawing, writing There are two ways, the second is recommended ## First, use the `lcd` module to draw directly on the screen ```python import image, lcd lcd.init() lcd.draw_string(0, 0, \"hello\") ``` For more functions and parameters, please refer to [lcd API Manual](/api_reference/machine_vision/lcd.md) ## Second, use the `image` module to draw in the memory, and use the `lcd.display` function to display the entire picture on the screen after drawing ```python import image, lcd lcd.init() img image.Image(size (320, 240)) img.draw_string(0,0, \"hello\") lcd.display(img) ``` For more functions and parameters, please see [image API manual](/api_reference/machine_vision/image/image.html), search for `image.draw` on the page to find all drawing functions For Chinese (multi language) support, please see [How to display Chinese](/course/image/image_draw_font/image_draw_font.md), or search for \"font\"."},"/soft/maixpy/en/course/image/image_draw_font/image_draw_font.html":{"title":"How to display Chinese","content":" title: How to display Chinese keywords: maixpy, k210, AIOT, edge computing desc: maixpy how to display Chinese MaixPy supports loading Unicode fonts. Unicode (Unicode, Universal Code, Single Code) is an industry standard in the field of computer science. The following languages ​​are supported: * A Latin capital letter \"A\" A * ß Latin lowercase letter \"Sharp S\" ß * þ Lowercase Latin letter \"Thorn\" þ (not supported by small fonts) * Δ Uppercase Greek letter \"Delta\" Δ * Й Capital Cyrillic \"Short I\" Й * ק Hebrew letter \"Qof\" ק * م Arabic letter \"Meem\" م * ๗ Thai number 7 ๗ * ቐ Ethiopian syllable \"Qha\" ቐ * あ Hiragana in Japanese \"A\" あ * ア Japanese Katakana \"A\" ア * Ye Simplified Chinese character \"叶\" Ye * Turn Traditional Chinese characters \"转\" to turn * 엽 Korean syllable text \"Yeob\" 엽 This functional interface is completed by using the `image.Image()` object. Please use the latest version of MaixPy firmware September 2, 2020. ## Font interface Use draw_font to print font strings, similar to `img.draw_font(10, 20, 8, 8, b'/x20/xFC/xFC/x2C/xAC/x4C/x4D/xA3')`. ```python import lcd, image lcd.init() img image.Image() tmp b'/x20/xFC/xFC/x2C/xAC/x4C/x4D/xA3' img.draw_font(10, 20, 8, 8, tmp, scale 1, color (255, 255, 255)) lcd.display(img) ``` Example reference [image_draw_font.py](https://gitee.com/Sipeed/maixpy_scripts/tree/master/multimedia/gui/image/demo_draw_font/image_draw_font.py). ## Font library interface Please use font_load / font_free to load or release the font first. This will improve the function of draw_string and support loading from the `xx.Dzk` file and Flash address. After that, draw_string will print the string through the font. Currently only `ASCII` / ` UTF 8` encoding. > Attached font file [0xA00000_font_uincode_16_16_tblr.Dzk](https://gitee.com/Sipeed/maixpy_scripts/tree/master/multimedia/gui/image/demo_draw_font/tools/0xA00000_font_uincode_16_16_tblr.Dzk) ```python import lcd, image lcd.init() img image.Image() # image.font_load(image.UTF8, 16, 16, 0xA00000) image.font_load(image.UTF8, 16, 16,'/sd/0xA00000_font_uincode_16_16_tblr.Dzk') img.draw_string(20, 90, b'こんにちは、世界', x_spacing 2, mono_space 1) image.font_free() lcd.display(img) ``` Example reference [image_draw_string.py](https://gitee.com/Sipeed/maixpy_scripts/tree/master/multimedia/gui/image/demo_draw_font/image_draw_string.py). ## display effect ![view_image_font](./view_image_font.jpg) ## Font Tool We will use [FontGenerator.zip](https://gitee.com/Sipeed/maixpy_scripts/tree/master/multimedia/gui/image/demo_draw_font/tools/FontGenerator.zip) in the root directory to export the font corresponding to the font, please See the figure below to complete the export operation. 1. Select the font encoding type as Unicode encoding, which will support the languages ​​of most countries. ![image 20200902180913322](./image 20200902180913322.png) 2. Select the scanning mode, which is the scanning and printing direction of 5 horizontal, up and down, then left and right fonts. ![image 20200902181130459](./image 20200902181130459.png) 3. Create the font library after configuring the required font style as shown in the figure below. ![image 20200902181311553](./image 20200902181311553.png) 4. Just save it in DZK format, the font data access method is shown in the text description ![image 20200902181442677](./image 20200902181442677.png) ## Font tool > Warning: It is not recommended to use font tools, and those who do not understand should not use it. Use [Pc2Lcd2002.zip](https://gitee.com/Sipeed/maixpy_scripts/tree/master/multimedia/gui/image/demo_draw_font/tools/Pc2Lcd2002.zip) in the directory to get the character string of the font. 1. Confirm that the software is in character mode. ![image 20200902175614964](./image 20200902175614964.png) 2. Set as shown in the figure to export the desired string. ​ ![image 20200902180153452](./image 20200902180153452.png) 3. After filling in the text, click to generate the font. ![image 20200902175948599](./image 20200902175948599.png) 4. Extract the font string and use it. ![image 20200902180505263](./image 20200902180505263.png) ``` This (0) is (1) test (2) test (3) /x00/x20/x10/x17/x00/x02/xF1/x10/x10/x10/x11/x12/x14/x28/x47/x00/x80/x40/x40/xFC/x10/x10/x20/xA0/x40 /xA0/x10/x08/x08/x00/xFE/x00 This 0 /x1F/x10/x10/x1F/x10/x10/x1F/x00/xFF/x01/x11/x11/x11/x29/x45/x83/xF0/x10/x10/xF0/x10/x10/xF0/x00/xFE /x00/x00/xF8/x00/x00/x00/xFE is 1 /x00/x27/x14/x14/x85/x45/x45/x15/x15/x25/xE5/x21/x22/x22/x24/x08/x04/xC4/x44/x54/x54/x54/x54/x54/x54 /x54/x54/x04/x84/x44/x14/x08 test 2 /x00/x20/x10/x10/x07/x00/xF0/x17/x11/x11/x11/x15/x19/x17/x02/x00/x28/x24/x24/x20/xFE/x20/x20/xE0/x20 /x10/x10/x10/xCA/x0A/x06/x02 try 3 ``` > You can use the graphics mode to draw your favorite font graphics, supporting 32 * 32 graphics. > > ![image 20200902181645277](./image 20200902181645277.png)"},"/soft/maixpy/en/course/image/basic_operation.html":{"title":"basic operations of the image","content":" title: basic operations of the image keywords: maixpy, k210, AIOT, edge computing desc: maixpy basic operations of images ## Coordinates ### Get/Set pixels We can get the value of a pixel through the image.get_pixel(x, y) method. image.get_pixel(x, y) For grayscale image: Return the grayscale value of (x,y) coordinates. For color images: return the (r, g, b) tuple of (x, y) coordinates. Similarly, we can use the image.set_pixel(x, y, pixel) method to set the value of a pixel. image.set_pixel(x, y, pixel) For grayscale image: Set the grayscale value of (x,y) coordinates. For color images: Set the (r, g, b) value of (x, y) coordinates. For example: ```python img sensor.snapshot() img.get_pixel(10,10) img.set_pixcel(10,10,(255,0,0))#Set the pixel of coordinate (10,10) to red (255,0,0) ``` ### Get the width and height of the image image.width() Returns the width of the image (pixels) image.height() Returns the height of the image (pixels) image.format() The grayscale image will return sensor.GRAYSCALE, and the color image will return sensor.RGB565. image.size() Returns the size of the image (byte) ### Image operation image.invert() Inversely, for a binarized image, 0 (black) becomes 1 (white), and 1 (white) becomes 0 (black). Note: The image can be another image object, or an image object read in from a (bmp/pgm/ppm) file. Both images must be the same size and type (grayscale image/color image). image.nand(image) Perform NAND operation with another picture. image.nor(image) Perform a NOR operation with another picture. image.xor(image) Perform an exclusive OR (XOR) operation with another picture. image.xnor(image) Perform XNOR operation with another image. image.difference(image) Subtract another picture from this picture. For example, for each pixel of each channel, subtract the absolute value operation. This function is often used for motion detection."},"/soft/maixpy/en/course/image/find_qrcodes.html":{"title":"MaixPy Find QR code","content":" title: MaixPy Find QR code keywords: maixpy, k210, AIOT, edge computing desc: maixpy MaixPy find QR code Recognize the two dimensional code from the picture. The common two dimensional code is QR Code. The full name of QR is Quick Response. It can store more information and represent more data types than the traditional bar code (Bar Code). ## Instructions The image module has implemented a method to find the QR code, you need to use a non minimum firmware version, you need to prepare a QR code, you can use [caoliao QR code](https://cli.im/) to generate the content you want . * Get pictures from the camera, and point the camera at the QR code ```python import image, sensor img sensor.snapshot() ``` * Find a list of all QR code objects (image.qrcode) from the picture ```python res img.find_qrcodes() ``` * Manipulate QR code objects E.g. print information ```python print(res[0].payload()) ``` For detailed API introduction, please refer to [API Image](../../api_reference/machine_vision/image/image.html). ## Routine Recognize the QR code. If the QR code cannot be recognized, please try to change the `sensor.vflip()` function parameter. ```python import sensor import image import lcd import time clock time.clock() lcd.init() sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.set_vflip(1) sensor.run(1) sensor.skip_frames(30) while True: clock.tick() img sensor.snapshot() res img.find_qrcodes() fps clock.fps() if len(res)> 0: img.draw_string(2, 2, res[0].payload(), color (0,128,0), scale 2) print(res[0].payload()) lcd.display(img) ```"},"/soft/maixpy/en/course/image/adaptive-histogram-equalization.html":{"title":null,"content":" title: keywords: maixpy, k210, AIOT, edge computing desc: maixpy ```python # Adaptive histogram equalization example # # This example shows how to use adaptive histogram equalization to improve the contrast in the image. #Adaptive histogram equalization divides the image into regions, and then equalizes the histograms in these regions, #To improve image contrast and global histogram equalization. #In addition, you can specify clipping limits to prevent the contrast from becoming wild. import sensor, image, time sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QQVGA) sensor.skip_frames(time 2000) clock time.clock() while(True): clock.tick() # clip_limit <0 provides you with normal adaptive histogram equalization, which may cause a lot of contrast noise... # clip_limit 1 Do nothing. For best results, please slightly higher than 1, as shown below. # The higher the value, the closer it is to the standard adaptive histogram equalization, and will produce huge contrast fluctuations. img sensor.snapshot().histeq(adaptive True, clip_limit 3) print(clock.fps()) ```"},"/soft/maixpy/en/course/image/sensor.html":{"title":"Sensor","content":" title: Sensor keywords: maixpy, k210, AIOT, edge computing desc: maixpy Sensor The sensor module is used to set the parameters of the photosensitive element. Use routine: Real time preview camera ```python import sensor #Introduction of the photosensitive element module sensor.reset()#Initialize the photosensitive element sensor.set_pixformat(sensor.RGB565)#Set to color sensor.set_framesize(sensor.QVGA)#Set the size of the image sensor.skip_frames()#Skip n photos, after changing the settings, skip some frames and wait for the photosensitive element to stabilize. while(True): img sensor.snapshot()#take a photo, img is an image object ``` Initialization ```python sensor.reset()# Initialize the photosensitive element #Set color/black and white sensor.set_pixformat()# Set the pixel mode. sensor.GRAYSCALE# Grayscale, 8bit per pixel. sensor.RGB565# Color, 16bit per pixel. ``` Set image size sensor.QQCIF# 88x72 sensor.QCIF# 176x144 sensor.CIF# 352x288 sensor.QQSIF# 88x60 sensor.QSIF# 176x120 sensor.SIF# 352x240 sensor.QQQQVGA# 40x30 sensor.QQQVGA# 80x60 sensor.QQVGA# 160x120 sensor.QVGA# 320x240 sensor.VGA# 640x480 ```python sensor.set_framesize()# Set the size of the image ``` Skip some frames sensor.skip_frames(n 10) Skip n photos, after changing the settings, skip some frames and wait for the sensor to stabilize. Get an image sensor.snapshot() takes a picture and returns an image object. Auto gain / white balance / exposure sensor.set_auto_gain() Automatic gain is turned on (True) or turned off (False). When using color tracking, you need to turn off automatic gain. sensor.set_auto_whitebal() Automatic white balance is turned on (True) or turned off (False). When using color tracking, you need to turn off the automatic white balance. sensor.set_auto_exposure(enable[\\, exposure_us]) enable Turn on (True) or turn off (False) automatic exposure. Open by default. If enable is False, you can use exposure_us to set a fixed exposure time (in microseconds). Set window ROI ```python sensor.set_windowing(roi) ``` ROI: Region Of Interest, the term \"region of interest\" in image processing. It is the area to be processed extracted from the image to be processed. ```python sensor.set_framesize(sensor.VGA) # high resolution sensor.set_windowing((240, 240)) #Take the 240*240 area in the middle ``` The format of roi is (x, y, w, h). Set flip ```python #Horizontal flip sensor.set_hmirror(True) # Flip vertically sensor.set_vflip(True) ```"},"/soft/maixpy/en/course/image/kernel-filter.html":{"title":"nuclear filtering","content":" title: nuclear filtering keywords: maixpy, k210, AIOT, edge computing desc: maixpy nuclear filtering ![image 20200812191240724](kernel filter.assets/image 20200812191240724.png) Routine ```python # Nuclear filtering # # This example demonstrates nuclear filtering. import sensor, image, time sensor.reset() # Initialize the sensor #Set the image color format, there are RGB565 color map and GRAYSCALE grayscale sensor.set_pixformat(sensor.GRAYSCALE) # or sensor.RGB565 #Set image pixel size sensor.set_framesize(sensor.QVGA) # or sensor.QQVGA (or others) sensor.skip_frames(time 2000) # Let the new settings take effect clock time.clock() # Track FPS frame rate kernel_size 1 # 3x3 1, 5x5 2, 7x7 3, etc. kernel [ 2, 1, 0, \\ 1, 1, 1, \\ 0, 1, 2] while(True): clock.tick() # Track the number of milliseconds that have passed between two snapshots(). img sensor.snapshot() # Take a picture and return the image # Run the kernel on every pixel of the image. # Run the kernel on each pixel of the image img.morph(kernel_size, kernel) print(clock.fps()) # Note: When connected to a computer, the frame rate will become half the speed. When the computer is not connected, the frame rate will increase. ```"},"/soft/maixpy/en/course/index.html":{"title":"MaixPy tutorial instructions","content":" title: MaixPy tutorial instructions keywords: maixpy, k210, AIOT, edge computing desc: maixpy MaixPy manual tutorial instructions Before reading this tutorial, please **be sure to look at the left hand table of contents [Getting started must see guide]** The tutorial is written on the basis that I have fully mastered the content of the previous Getting Started This tutorial mainly introduces how to use the functions included in MaixPy in modules, When watching the tutorial, you may need to learn together with API documentation and routine warehouse [MaixPy_scripts](https://github.com/sipeed/MaixPy v1_scripts)"},"/soft/maixpy/en/dnn/index.html":{"title":"Deep learning and KPU basic knowledge","content":" title: Deep learning and KPU basic knowledge keywords: maixpy, k210, AIOT, edge computing desc: maixpy deep learning and KPU basics ## What can I learn after reading this chapter? 1. Understand some basic content of deep learning 2. Understand the characteristics of KPU inside K210 3. Understand the problems that may be encountered during the use of KPU and the solutions to the problems ## Overview In this chapter, we will introduce some basic knowledge of deep learning and K210 internal KPU, as well as the problems that you are likely to encounter in this part. Deep learning and the application examples it covers are a very large field, and no one can make it clear with a document. I hope that this document can give you a certain understanding of deep learning, and if there is a problem beyond the description of this document, you can solve the problem through search engine queries and other means. ## About Deep Learning Before introducing deep learning, let's first introduce neural networks. ​ What is a neural network? It is an algorithmic mathematical model that imitates the behavioral characteristics of animal neural networks and performs distributed parallel information processing. Below, let us give a simple example to illustrate what it does. In fact, to some extent, when we were in elementary school, we had already begun to use neural network related ideas to solve practical problems. At this time, you may be full of question marks QAQ. Don't be afraid, let me come one by one. Now, suppose there is an equation `y kx + b`. I believe you must have seen this equation countless times. In fact, we can regard this equation as the \"model\" of the neural network, the unknown \"k\" as the weight of the neural network, and \"b\" as the bias of the neural network. At this time we need to train this neural network model. In fact, the training process is the process of solving the global optimal weights and biases on the data set. At this time, suppose this equation satisfies \"x 1, y 2\", \"x 2, y 4\". This satisfying condition is the data set mentioned above. Through the training of this network in the human brain, we can know that the optimal weight of the entire network is 2, and the optimal bias is 0. At this point, the training of the neural network is completed. However, it is worth mentioning that the ultimate goal of training is always prediction. Throughout the ages, so many neural networks have consumed a lot of computing resources to find suitable weights and biases. All are to be able to find a correspondence between input data and output data. For an excellent neural network, its input data should be random and uncertain (not trained in the data set). The output data is accurate and reliable. Going back to the above, we trained the neural network \"y 2x + 0\". At this time, the data x in the dataset is \"1\" and \"2\". At this time, in order to evaluate the performance of the model, we input the non data set data \"3\". At this time, through the neural network forward propagation, the output value \"6\" is obtained. So far, the prediction of the neural network model is completed. I used a very simple demo to explain what the neural network is doing. Let's take a look at the real neural network model. ![Fully connected neural network model](https://i.loli.net/2020/06/30/PVxMcSde8YJ4Q9b.jpg) The above picture shows a more common fully connected neural network model (Fully connected neural network). Comparing this network structure with the previous \"y 2x + 0\" network, we can find the following differences: 1. The number of input data is uncertain (there can be n inputs) 2. The number of output data is uncertain (there can be n outputs) 3. The number of parameters is uncertain (there can be n fully connected layers in the figure, and each layer can contain n neurons, resulting in the number of parameters being n) The model construction process can be regarded as the process of determining the number of parameters (when the network layer structure is determined, the number of parameters is also determined), and the model training process can be regarded as the process of determining the global optimal parameters on the data set. The prediction process of the model can be regarded as the process of input data * parameter prediction result. (*Represents some kind of calculation) After having a certain understanding of neural networks, deep learning will be introduced next. You can think of deep learning as an improved neural network algorithm. The relationship between it and several other terms is: machine learning is a subset of artificial intelligence, and deep learning and neural networks are a subset of machine learning. The difference between neural network and deep learning, as well as the advantages of deep learning, etc., due to limited space, can not be introduced here. If you are interested, you can query through search engines. ## About KPU The K210 SOC is equipped with a KPU (Neural Network Processor), which is a general neural network processor, which can realize convolutional neural network calculations with low power consumption, and always obtain the size, coordinates and type of the detected target. Detect and classify faces or objects. The KPU on the K210 has the following features: 1. Support fixed point models trained by mainstream training frameworks according to specific restriction rules 2. There is no direct limit to the number of network layers, and each layer of convolutional neural network parameters can be configured separately, including the number of input and output channels, input and output row width and column height 3. Support two convolution kernels 1x1 and 3x3 4. Support any form of activation function 5. The maximum supported neural network parameter size is 5.5MiB to 5.9MiB when working in real time 6. The maximum supported network parameter size during non real time work is (Flash capacity software volume) The internal structure of KPU is shown in the figure below. ![K210 KPU structure](https://i.loli.net/2020/06/30/Q9tPOjyMWFiTwxA.png) You can click [here](https://maixpy.sipeed.com/zh/libs/Maix/kpu.html?h kpu) to view related APIs and Demos of KPU under Maixpy. ## Common problems in the use of KPU ### 1. What size model can KPU load? When k210 runs c code, it can load about 6MB model. When running maixpy ​​(mini), a model of about 3MB can be loaded. When running maixpy ​​(full version), a model of about 2MB can be loaded. ### 2. What model can be loaded and run by KPU? The kmodel converted by nncase can be loaded and run by kpu. Click [here](https://github.com/kendryte/nncase/blob/master/docs/USAGE_ZH.md) for nncase instructions nncase tflite ops support click [here](https://github.com/kendryte/nncase/blob/master/docs/tflite_ops.md) Click [here](https://github.com/kendryte/nncase/blob/master/docs/FAQ_ZH.md) for nncase frequently asked questions ### 3. How can KPU load the model? 1. Load the model in the TF card ```python kpu.load(\"/sd/test.kmodel\") ``` 2. Load the model in Flash ```python kpu.load(offset) ``` The offset here is the offset address of the model in the flash. The model can be burned into the internal flash of the k210 through k flash ### 4. What should I do if an error \"memory overflow\" is reported? This problem is generally caused by the model being too large. You can try the following solutions in turn: 1. Change the firmware of maixpy ​​mini version 2. Perform model pruning optimization 3. Abandon the development under maixpy ​​firmware, and use Kanzhi C SDK for development. ### 5. What should I do if the error \"load error, only support kmodel v3/v4\" is reported? If this problem occurs, you can try the following solutions: 1. If loading the model in the flash, please make sure that the flash offset is filled in correctly and that there is no conflict with the maixpy ​​firmware. 2. If it is kmodel V4 converted using nncase 0.2.0, please try to convert using nncase 0.1.0 to generate kmodel V3. (As of 2020/06/30, the loading bug of kmodel v4 by maixpy ​​has not been fixed yet) ### 6. I want to select and load different models (for example, press the button to run the target classification, press the button again to run the target detection), how should I write the program? Because of the limited flash, it is recommended to load all k210 models into the TF card. Because the internal RAM is limited, before switching between different models for `kpu.load(k210model)`, please execute `kpu.deinit(k210model)` to release the model in SRAM. Otherwise it will report an error \"memory overflow\"."},"/soft/maixpy/en/dnn/ml_mnist.html":{"title":"mnist handwritten number recognition","content":" title: mnist handwritten number recognition keywords: maixpy, k210, AIOT, edge computing desc: maixpy mnist handwritten digit recognition ```python import sensor,lcd,image import KPU as kpu lcd.init() sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.set_windowing((224, 224)) #set to 224x224 input sensor.set_hmirror(0) #flip camera task kpu.load(0x200000) #load model from flash address 0x200000 sensor.run(1) img_lcd image.Image() while True: img sensor.snapshot() #lcd.display(img,oft (0,0)) #display large picture img1 img.to_grayscale(1) #convert to gray img2 img1.resize(28,28) #resize to mnist input 28x28 a img2.invert() #invert picture as mnist need a img2.strech_char(1) #preprocessing pictures, eliminate dark corner img2x2 img2.resize(28*2,28*2) #scale to display a img_lcd.draw_image(img2x2,0,0)#display small 28x28 picture a img2.pix_to_ai(); #generate data for ai #watch conv0 a kpu.set_layers(task, 1) fmap kpu.forward(task,img2) #run neural network model for i in range(0,16): tmp kpu.fmap(fmap,i) tmpx2 tmp.resize(14*2,14*2) #scale to display a img_lcd.draw_image(tmpx2,(i%8)*14*2,28*2+14*2*int(i/8)) #watch conv1 a kpu.set_layers(task, 2) fmap kpu.forward(task,img2) #run neural network model for i in range(0,32): tmp kpu.fmap(fmap,i) tmpx2 tmp.resize(7*2,7*2) #scale to display a img_lcd.draw_image(tmpx2,(i%16)*7*2,28*2+14*2*2+7*2*int(i/16)) #watch conv2 a kpu.set_layers(task, 8) fmap kpu.forward(task,img2) #run neural network model for i in range(0,10): tmp kpu.fmap(fmap,i) tmpx2 tmp.resize(4*2,4*2) #scale to display a img_lcd.draw_image(tmpx2,i*4*2,28*2+14*2*2+7*2*2) #watch softmax a kpu.set_layers(task, 11) fmap kpu.forward(task,img2) plist fmap[:] for i in range(0,10): cc int(plist[i]*256) a img_lcd.draw_rectangle(i*16, 28*2+14*2*2+7*2*2+4*2+10, 16, 16, color (cc, cc, cc), thickness 1, fill True) a img_lcd.draw_string(i*16+5, 28*2+14*2*2+7*2*2+4*2+10+16, str(i), color (255, 255, 255) , scale 2, mono_space False) #show result lcd.display(img_lcd,oft (0,0)) ```"},"/soft/maixpy/en/share/my_share/index.html":{"title":"MaixPy Experience Sharing —— XXX","content":" title: MaixPy Experience Sharing —— XXX keywords: maixpy, k210, AIOT, edge computing desc: maixpy MaixPy experience sharing XXX This catalog is mainly used for sharing your own experience or tutorials, and it can also be moved with the author's permission to reprint, and famous sources. ## To participate in sharing, you need to master the knowledge in advance * Use of git and github * Use of github PR (pull request) There is a brief introduction in the introductory tutorial, please learn by yourself for detailed usage If you are not confident to master these skills, you can submit [issue](https://github.com/sipeed/MaixPy_DOC/issues) to explain the problem or contribute experience, etc. We will help you to add ## How to add ### Clone document to local ``` git clone https://github.com/sipeed/MaixPy_DOC cd MaixPy_DOC ``` ### New directory Need to create a new directory dedicated to writing shared articles, Create a folder in the `MaixPy_DOC/docs/maixpy/zh/share/my_share/` directory, the folder name can only be in lowercase English and underscore, you can name it with your English name, such as `tom` or `lihua`, The following uses `MaixPy_DOC/docs/maixpy/zh/share/my_share/tom` as an example Of course, if you write an English document, you need to put it in the `MaixPy_DOC/docs/maixpy/en/share/my_share/tom` folder Create a file in this folder, name it `readme.md`, and use the `markdown` syntax to write and share in it, Create a `MaixPy_DOC/docs/maixpy/zh/share/my_share/tom/assets` directory to store pictures, The relative path is used to reference the pictures in the document. For example, if the path of an image is `MaixPy_DOC/docs/maixpy/zh/share/my_share/tom/assets/cover.jpg`, it will be in `MaixPy_DOC/docs/maixpy/zh/share/my_share/tom/readme.md `Use the following syntax to quote pictures in ``` ![Cover](./assets/cover.jpg) ``` Note, don’t enlarge files in the folder, and don’t use too big pictures, otherwise the document warehouse will be huge ### Write documentation To make the document look well formed and easier to read, To write a document **must** follow the grammar and format requirements: **See [document specification](../../contribute/doc_convention.html)** **Document template**, write an article according to the template, you can modify it according to your own situation ```markdown Author Contact Personal Homepage XXX XXXX@XXX.com [github/sipeed](http://github.com/sipeed) ## Introduction: Describe the background of this sharing, the final effect display, etc., you can use pictures, GIFs or videos to display, but don’t put too large images in the `assets` folder, otherwise users will not be able to load them for a long time due to internet speed problems. , It loses its meaning ## Preparation: ### Preliminary knowledge ### Software and hardware environment to be prepared #### Hardware Graphic description of the development board, peripheral modules, etc. used #### Software Graphic description of the software tools used, MaixPy version If you use third party software tools, you can attach the relevant name or download link ## Process, specific title customization ## Process, specific title customization ## Results It is recommended to add pictures to show the actual running effect ## to sum up Summary of this sharing ## Questions and feedback Can provide feedback ## Reference Indicate the articles and source code cited in the article in a list here * Cited article 1: https://www.sipeed.com ``` ### Add this share to the directory column on the left side of the document Open `MaixPy_DOC/docs/maixpy/zh/SUMMARY.md`, add your own share at the end, such as ``` ## Community & Share [Featured Tutorial](./share/recommend_articles.html) [Open source project](./share/open_projects.html) Everyone's experience sharing * [Participation in experience sharing/sharing template](./share/my_share/index.html) * [jerry's model training tutorial](./share/my_share/jerry/index.html) ``` The effect after adding your own card is: ``` ## Community & Share [Featured Tutorial](./share/recommend_articles.html) [Open source project](./share/open_projects.html) Everyone's experience sharing * [Participation in experience sharing/sharing template](./share/my_share/index.html) * [Model Training Tutorial jerry](./share/my_share/jerry/index.html) * [How to design your own model tom](./share/my_share/tom/index.html) ``` Note that there are two spaces in front of **\\***, not `tab` ### Submit After writing, submit the modification, and then submit the PR on github. After the PR is passed, the official document page will have this article"},"/soft/maixpy/en/share/recommend_articles.html":{"title":"MaixPy Featured Article","content":" title: MaixPy Featured Article keywords: maixpy, k210, AIOT, edge computing desc: maixpy MaixPy Featured Articles From the community **selected** articles, collect some good articles here to facilitate everyone to learn and communicate. In addition, if you have experience and want to share, you are also welcome to participate. After writing the article, submit [issue](https://github.com/sipeed/MaixPy_DOC/issues) to add Claim: * Related to MaixPy * Clear article directory hierarchy * The logic of the article is clear, and the introduction, effect, operation process, and summary of the sharing need to be stated, with pictures and texts You can also directly add experience sharing in the document according to [Participation in experience sharing/sharing template](../share/my_share/index.html). If it is well written, it will also be included on this page The article links are all included in the following posts to facilitate updates: [Selected Article Navigation](https://cn.bbs.sipeed.com/d/481) (Maybe Chienese article, you can use google translation to translate)"},"/soft/maixpy/en/share/open_projects.html":{"title":"Selected MaixPy related open source projects","content":" title: Selected MaixPy related open source projects keywords: maixpy, k210, AIOT, edge computing desc: maixpy MaixPy related open source project selection Here are some good MaixPy related open source projects to share, welcome to star If you also have a good MaixPy related open source project, welcome to submit [issue](https://github.com/sipeed/MaixPy_DOC/issues) for adding, Claim: * Related to MaixPy * The project has a complete and clear `README`, including introduction, effects, code, usage, etc. ## Model training Project Home Introduction Author [sipeed/maix_train](https://github.com/sipeed/maix_train) Classification and detection model training project [Sipeed](https://github.com/sipeed/maix_train/graphs/contributors) [lemariva/MaixPy_YoloV2](https://github.com/lemariva/MaixPy_YoloV2) Use Mobilenet+YOLOv2 to perform object detection on the Sipeed Maix Dock development board, see [blog](https://lemariva.com /blog/2020/01/maixpy object detector mobilenet and yolov2 sipeed maix dock) [lemariva](https://github.com/lemariva) [zhen8838/K210_Yolo_framework](https://github.com/zhen8838/K210_Yolo_framework) yolo v3 model training framework on k210 [zhen8838](https://github.com/zhen8838) [TonyZ1Min/yolo for k210](https://github.com/TonyZ1Min/yolo for k210) Train YOLO object detection model on windows [TonyZ1Min](https://github.com/TonyZ1Min) ## UI & System Project Home Introduction Author [sipeed/MaixUI](https://github.com/sipeed/MaixUI) An UI written with MaixPy scripts Sipeed [eggfly/M5StickVComputer](https://github.com/eggfly/M5StickVComputer) A pure Python application framework running on `M5StickV` [eggfly](https://github.com/eggfly) "},"/soft/maixpy/en/firmware/compile.html":{"title":"source code compilation","content":" title: source code compilation keywords: maixpy, k210, AIOT, edge computing desc: maixpy source code compilation The pre compiled firmware may not meet specific usage scenarios. If you need to modify the configuration, please configure and compile the required firmware ## Native environment compilation For the compilation method, please refer to the compilation instructions under the source code [build.md](https://github.com/sipeed/MaixPy v1/blob/master/build.md) ## Use docker environment to compile Docker can simplify development environment installation > If you have never used docker, please learn about docker by yourself, > If you haven't studied before, you can think of it as similar to a virtual machine, that is, a virtual machine with a compilation environment has been prepared for you, and you can download and run it directly to compile the source code The docker image has already packaged the environment, just pull the image and run it to start compiling, refer to [Use Docker to compile the source code](https://github.com/sipeed/MaixPy v1tree/master/tools/docker)"},"/soft/maixpy/en/firmware/online_compile.html":{"title":"Firmware online compilation","content":" title: Firmware online compilation keywords: maixpy, k210, AIOT, edge computing desc: maixpy firmware online compilation Online compilation does not need to build a compilation environment, just select the required modules and click compile, the compilation process will be completed in the cloud, and the firmware will be sent by email Visit [maixhub](https://www.maixhub.com/compile.html) for firmware customization"},"/soft/maixpy/en/firmware/why_customize_firware.html":{"title":"Why need firmware customization","content":" title: Why need firmware customization keywords: maixpy, k210, AIOT, edge computing desc: maixpy why need firmware customization Mainly to save memory. The memory of the chip is `6MiB` general purpose memory + `2MiB` AI dedicated memory, which is really very large compared to ordinary single chip microcomputers. If AI function is not used, we can use the entire `8MiB` memory. But because many times we need to run a model, a model may reach `3MiB` or even larger, and the firmware also needs to take up memory. So in order to run a larger model, we need to compromise and cut some unnecessary functions. In the previous chapter of firmware update, many firmware versions were introduced and compiled, including `minimum`, `with_v4_support`, `with_ide_support`, and `with_lvgl`, These firmwares may be used in different situations. such as: * Cut IDE code, if you don't need to connect MaixPy IDE, you can cut IDE part to save memory. * Cut the OpenMV function, the firmware is compatible with some functions of OpenMV, if you use the model, these functions may not be needed, you can cut it out. * Tailoring multithreading support, if you don't need multithreading support, you can trim this part to get more memory space. Therefore, if you are using a certain function, and you find the prompt `ImportError: no module named'XXX'`, it may be that you are using a firmware that does not include this function. For example, the `minimum` firmware does not include IDE and `image.find_blobs` Function, if this firmware is burned, it will be unable to connect for a long time if you connect to the `IDE` again. Using the function `image.find_blobs` will also prompt that the function definition cannot be found."},"/soft/maixpy/en/modules/grove/grove_rgb_led_ring.html":{"title":"Grove-RGB LED Ring (LED strip)","content":" title: Grove RGB LED Ring (LED strip) keywords: maixpy, k210, AIOT, edge computing desc: maixpy Grove RGB LED Ring (LED strip) <div class \"grove_pic\"> <img src \"../../../assets/hardware/module_grove/grove_led_ring.jpg\"> </div> The Grove RGB LED ring uses 3535 size LEDs, and the LEDs are embedded with embedded microcontrollers. Each WS2813 driver chip can be addressed and located inside the LED. Each LED is driven by a constant current, so even if the voltage changes, the color will be very consistent. ## Parameters Item Value Working voltage 3.3V/5V Quiet current 0.7mA/LED RGB channel constant current 16mA/LED Refresh frequency 2Hz Reset time >280μs Working temperature 25～85℃ Storage temperature 40～105℃ ## Instructions MaixPy has implemented the WS2812 driver in the modules module. * To create a ws2812 object, only a single signal line is needed ```python from modules import ws2812 led_io, led_num 24, 24 ws ws2812(led_io, led_num) ``` * Set the color of a certain light and display it ```python for i in range(led_num): ws.set_led(i, (0, 0, 0)) ws.display() ``` ## Routine [Grove RGB LED Ring example](https://github.com/sipeed/MaixPy v1_scripts/blob/master/modules/grove/ws2812/ws2812.py) ## More * API manual: [modules.ws2812](../../api_reference/extend/ws2812.html) * Module details: [Seeed Grove LED_ring](https://wiki.seeedstudio.com/Grove LED_ring/)"},"/soft/maixpy/en/modules/grove/grove_chainable_rgb_led.html":{"title":"Grove-Chainable RGB LED (Linkable LED lights)","content":" title: Grove Chainable RGB LED (Linkable LED lights) keywords: maixpy, k210, AIOT, edge computing desc: maixpy Grove Chainable RGB LED (linkable LED lights) <div class \"grove_pic\"> <img src \"../../../assets/hardware/module_grove/grove_rgb_led.jpg\"> </div> Grove Chainable RGB LED uses 2 wire transmission (data and clock) to communicate with the MCU. This 2 wire transmission can be used to cascade multiple modules. Built in clock regeneration can extend the transmission distance. The Grove module is suitable for any project based on colored LEDs. ## Parameters ItemValue Working voltage5V Electric current20mA Communication protocolserial communication ## Instructions * Import the RGB_LED class in the routine warehouse and create an RGB_LED object ```python from RGB_LED import RGB_LED led RGB_LED(clk_pin, data_pin, led_num, clk_gpiohs_num, data_gpiohs_num, True) ``` * Set the color of a light, the color value is rgb format ```python for i in range(led_num): led.set_RGB(i, r, g, b) ``` ## Routine [Grove Chainable RGB LED example](https://github.com/sipeed/MaixPy v1_scripts/tree/master/modules/grove/chainable_RGB_LED) ## More Module details: [Seeed Grove Chainable RGB LED](https://wiki.seeedstudio.com/Grove Chainable_RGB_LED/)"},"/soft/maixpy/en/modules/grove/grove_ultrasonic_ranger.html":{"title":"Grove-Ultrasonic Ranger (Ultrasonic Ranger)","content":" title: Grove Ultrasonic Ranger (Ultrasonic Ranger) keywords: maixpy, k210, AIOT, edge computing desc: maixpy Grove Ultrasonic Ranger (Ultrasonic Ranger) <div class \"grove_pic\"> <img src \"../../../assets/hardware/module_grove/ultrasonic.jpg\"> </div> Grove Ultrasonic Ranger is a non contact ranging module with a working frequency of 40KHz. The trigger and echo signals of Grove_Ultrasonic_Ranger share a SIG pin. ## Parameters Item Value Working voltage 3.2~5.2V Working current 8ma Ultrasonic frequency 40kHz Measuring range 2 350cm Resolution 1cm Output PWM Size 50mm x 25mm x 16mm Weight 13g Measurement angle 15° Working temperature 10~60°C Trigger signal 10uS TTL Echo signal TTL ## Instructions MaixPy has implemented ultrasonic driver in the modules module. * Import ultrasonic class and create object ```python from modules import ultrasonic device ultrasonic(fm.fpioa.GPIOHS0) ``` * Get the current measurement distance (cm) ```python distance device.measure(unit ultrasonic.UNIT_CM, timeout 3000000) ``` ## Routine [Grove Ultrasonic Ranger example](https://github.com/sipeed/MaixPy v1_scripts/tree/master/modules/grove/ultrasonic) ## More * API manual: [modules.ultrasonic](../../api_reference/extend/ultrasonic.html) * Module details: [Seeed Grove Ultrasonic_Ranger](https://wiki.seeedstudio.com/Grove Ultrasonic_Ranger/)"},"/soft/maixpy/en/modules/grove/index.html":{"title":"Grove","content":" title: Grove keywords: maixpy, k210, AIOT, edge computing desc: maixpy Grove Modules using Grove standard interfaces, Grove is a unified interface system used by the Seeed team, and currently supports a large number of modules. ## Grove interface The cables of the Grove interface have 4 colors, and users can quickly distinguish them according to the colors ![](../../../assets/hardware/module_grove/grove_interface.jpg) pin color description pin 1 yellow (for example, SCL on I2C Grove Connectors) pin 2 white (for example, SDA on I2C Grove Connectors) pin 3 Red VCC (All Grove ports are VCC in red) pin 4 black GND (all Grove ports are GND in black) Grove module mainly has 4 kinds of interfaces: 1. Grove Digital digital interface:<br/> The Grove digital interface consists of four standard wires of Grove plugs.<br/> The two signal lines are usually called D0 and D1.<br/> Most modules only use D0, but some (like LED Bar Grove displays) use both. Usually the core board will call the first Grove connector on the board as D0, and the second as D1. The first The connector will be connected to the DO/D1 pin of the main control chip, the second connector will be connected to the D1/D2 pin of the main control chip, and the following connectors will be deduced by analogy. pin Function Note pin1 Dn First digital input — pin2 Dn+1 The second digital input — pin3 VCC power supply pin 5V/3.3V — pin4 GND ground — 2. Grove UART :<br/> The Grove UART is a special digital input and output interface.<br/> It uses pins 1 and 2 for serial input and transmission. <br/> Pin 1 is the RX line (used to receive data, so it is input), Among them, pin 2 is the TX line (used to transmit data to the Grove module). pin Function Note pin1 RX Serial Receive pin2 TX Serial transmission pin3 VCC Power supply pin 5V/3.3V pin4 GND Ground 3. Grove I2C:<br/> There are many types of I2C Grove sensors available.<br/>The Grove on MaixCube only supports 3.3V sensors The Grove I2C connector has a standard layout. Pin 1 is the SCL signal, and pin 2 is the SDA signal pin Function Note pin1 SCL I2C clock pin2 SDA I2C data pin3 VCC Power supply pin, 5V/3.3V pin4 GND Ground For details, please refer to: [Grove_System](https://wiki.seeedstudio.com/cn/Grove_System/) ## Peripheral Module The following peripherals all use Grove interface * [Ultrasonic Ranger](./grove_ultrasonic_ranger.html) * [Chainable RGB LED light](./grove_chainable_rgb_led.html) * [RGB LED Ring strip](./grove_rgb_led_ring.html)"},"/soft/maixpy/en/modules/on_chip/pwm.html":{"title":"Use of PWM","content":" title: Use of PWM keywords: maixpy, k210, AIOT, edge computing desc: maixpy Use of PWM For details on PWM, please refer to [PWM API Document](../../api_reference/machine/pwm.html). ## Instructions * Import PWM and Timer modules from machine ```python from machine import Timer,PWM ``` * Create Timer and PWM ```python tim Timer(Timer.TIMER0, Timer.CHANNEL0, mode Timer.MODE_PWM) ch PWM(tim, freq 500000, duty 50, pin boad_info.LED_G) ``` * Change the duty cycle, the set pin will output waveforms with different duty cycles ```python ch.duty(duty) ``` ## Example Control the brightness of LED_G > `board_info` is related to the board, and different board configurations are different. [Manual configuration](../../api_reference/builtin_py/board_info.html) is required before use. ```python from machine import Timer,PWM import time from board import board_info from fpioa_manager import fm tim Timer(Timer.TIMER0, Timer.CHANNEL0, mode Timer.MODE_PWM) ch PWM(tim, freq 500000, duty 50, pin boad_info.LED_G) duty 0 dir True while True: if dir: duty + 10 else: duty 10 if duty>100: duty 100 dir False elif duty<0: duty 0 dir True time.sleep(0.05) ch.duty(duty) ```"},"/soft/maixpy/en/modules/on_chip/i2c.html":{"title":"Use of I2C","content":" title: Use of I2C keywords: maixpy, k210, AIOT, edge computing desc: maixpy the use of I2C For detailed introduction of I2C, please refer to [I2C API Document](../../api_reference/machine/i2c.html). ## Instructions ### Host Mode * Create I2C (software simulation or hardware) objects ```python from machine import I2C from fpioa_manager import fm # i2c I2C(I2C.I2C0, freq 100000, scl 28, sda 29) # hardware i2c i2c I2C(I2C.I2C4, freq 100000, scl 28, sda 29,gscl fm.fpioa.GPIOHS3,gsda fm.fpioa.GPIOHS2) # software i2c ``` * Scan slaves, return all slave addresses ```python devices i2c.scan() ``` * Read and write data to the slave ```python for device in devices: i2c.writeto(device, b'123') i2c.readfrom(device, 3) ``` ### Slave mode * Create slave callback function ```python count 0 def on_receive(data): print(\"on_receive:\",data) def on_transmit(): count count+1 print(\"on_transmit, send:\",count) return count def on_event(event): print(\"on_event:\",event) ``` * Create I2C object ```python from machine import I2C i2c I2C(I2C.I2C0, mode I2C.MODE_SLAVE, scl 28, sda 29, addr 0x24, addr_size 7, on_receive on_receive, on_transmit on_transmit, on_event on_event) ``` ## Example * Read all slave addresses and send and receive data respectively ```python from machine import I2C i2c I2C(I2C.I2C0, freq 100000, scl 28, sda 29) # software i2c devices i2c.scan() print(devices) for device in devices: i2c.writeto(device, b'123') i2c.readfrom(device, 3) ``` * Slave mode example ```python from machine import I2C count 0 def on_receive(data): print(\"on_receive:\",data) def on_transmit(): count count+1 print(\"on_transmit, send:\",count) return count def on_event(event): print(\"on_event:\",event) i2c I2C(I2C.I2C0, mode I2C.MODE_SLAVE, scl 28, sda 29, addr 0x24, addr_size 7, on_receive on_receive, on_transmit on_transmit, on_event on_event) ```"},"/soft/maixpy/en/modules/on_chip/timer.html":{"title":"Use of Timer","content":" title: Use of Timer keywords: maixpy, k210, AIOT, edge computing desc: maixpy the use of Timer (timer) For detailed introduction of Timer, please refer to [Timer API Document](../../api_reference/machine/timer.html). ## Instructions * Import Timer module from machine ```python from machine import Timer ``` * Create a Timer object ```python def on_timer(timer): print(\"time up:\",timer) print(\"param:\",timer.callback_arg()) tim Timer(Timer.TIMER0, Timer.CHANNEL0, mode Timer.MODE_PERIODIC, period 1, unit Timer.UNIT_S, callback on_timer, arg on_timer, start False, priority 1, div 0) ``` * Start the timer, at this time the timer will execute the callback function regularly ```python tim.start() ``` * Stop the timer ```python tim.stop() ``` ## Example Execute callback function regularly ```python from machine import Timer def on_timer(timer): print(\"time up:\",timer) print(\"param:\",timer.callback_arg()) tim Timer(Timer.TIMER0, Timer.CHANNEL0, mode Timer.MODE_PERIODIC, period 1, unit Timer.UNIT_S, callback on_timer, arg on_timer, start False, priority 1, div 0) print(\"period:\",tim.period()) tim.start() time.sleep(5) tim.stop() time.sleep(5) tim.restart() time.sleep(5) tim.stop() del tim ```"},"/soft/maixpy/en/modules/on_chip/i2s.html":{"title":"Use of I2S (Integrated Circuit Audio Bus)","content":" title: Use of I2S (Integrated Circuit Audio Bus) keywords: maixpy, k210, AIOT, edge computing desc: maixpy the use of I2S (integrated circuit built in audio bus) For a detailed introduction to the I2S audio bus, please refer to [I2S API Document](./../../api_reference/Maix/i2s.html). ## Instructions * Import I2S module from Maix ```python from Maix import I2S ``` * Create I2S object ```python i2s_dev I2S(device_num) ``` * Configuration parameters ```python i2s_dev.channel_config(rx.CHANNEL_0, rx.RECEIVER, align_mode I2S.STANDARD_MODE) i2s_dev.set_sample_rate(sample_rate) ``` * Read or play data ```python i2s_dev.record(256)#sampling points number must be smaller than 256 ``` ## Routine Collect data and play it directly ```python from Maix import I2S import time from fpioa_manager import * fm.register(20,fm.fpioa.I2S0_IN_D0)#GO fm.register(19,fm.fpioa.I2S0_WS) fm.register(18,fm.fpioa.I2S0_SCLK) fm.register(34,fm.fpioa.I2S2_OUT_D1) fm.register(35,fm.fpioa.I2S2_SCLK) fm.register(33,fm.fpioa.I2S2_WS) sample_rate 44*1000 rx I2S(I2S.DEVICE_0) rx.channel_config(rx.CHANNEL_0, rx.RECEIVER, align_mode I2S.STANDARD_MODE) rx.set_sample_rate(sample_rate) tx I2S(I2S.DEVICE_2) tx.channel_config(tx.CHANNEL_1, tx.TRANSMITTER, align_mode I2S.RIGHT_JUSTIFYING_MODE) tx.set_sample_rate(sample_rate) while True: audio rx.record(256)#sampling points number must be smaller than 256 tx.play(audio) ```"},"/soft/maixpy/en/modules/on_chip/uart.html":{"title":"Use of UART","content":" title: Use of UART keywords: maixpy, k210, AIOT, edge computing desc: maixpy use of UART For details on UART, please refer to [UART API Document](./../../api_reference/machine/uart.html) ## Instructions * Import UART module from machine ```python from machine import UART ``` * The pin used for configuration is UART function ```python fm.register(10, fm.fpioa.UART1_TX, force True) fm.register(11, fm.fpioa.UART1_RX, force True) ``` * Create UART object ```python uart UART(UART.UART1, 115200, 8, 1, 0, timeout 1000, read_buf_len 4096) ``` * Read and write data ```python uart.write(b'hello world') read_data uart.read() ``` ## Example Send back the data received by the serial port ```python from fpioa_manager import fm from machine import UART import time # need your connect hardware IO 10/11 to loopback fm.register(10, fm.fpioa.UART1_TX, force True) fm.register(11, fm.fpioa.UART1_RX, force True) uart UART(UART.UART1, 115200, 8, 1, 0, timeout 1000, read_buf_len 4096) uart.write(b'hello world') while True: read_data uart.read() if read_data: print(\"recv:\", read_data) uart.write(read_data) # send data back print(\"wait data: \") uart.deinit() del uart ```"},"/soft/maixpy/en/modules/on_chip/spi.html":{"title":"Use of SPI","content":" title: Use of SPI keywords: maixpy, k210, AIOT, edge computing desc: maixpy use of SPI For details about SPI, please refer to [SPI API Document](../../api_reference/machine/spi.html). ## Instructions ### Host Mode * Import SPI module from machine ```python from machine import SPI ``` * The pins used for configuration are chip select GPIO function and SPI function. ```python fm.register(25,fm.fpioa.GPIOHS10, force True)#cs cs GPIO(GPIO.GPIOHS10, GPIO.OUT) fm.register(28,fm.fpioa.SPI1_D0, force True)#mosi fm.register(26,fm.fpioa.SPI1_D1, force True)#miso fm.register(27,fm.fpioa.SPI1_SCLK, force True)#sclk ``` * Create SPI object ```python spi1 SPI(SPI.SPI1, mode SPI.MODE_MASTER, baudrate 10000000, polarity 0, phase 0, bits 8, firstbit SPI.MSB) ``` * Use chip select GPIO to select the slave, read and write data through SPI ```python cs.value(0) spi1.write_readinto(w, r) cs.value(1) ``` ### Slave mode K210 SPI slave mode only supports three wire communication, so this mode is not implemented in MaixPy. For slave mode, please refer to [SPI_SLAVE C SDK implementation](https://github.com/kendryte/kendryte standalone demo/tree/develop /spi_slave). ## Example * Select the chip select GPIO corresponding to the slave and send and receive data ```python from machine import SPI from fpioa_manager import fm from Maix import GPIO m.register(25,fm.fpioa.GPIOHS10, force True)#cs cs GPIO(GPIO.GPIOHS10, GPIO.OUT) fm.register(28,fm.fpioa.SPI1_D0, force True)#mosi fm.register(26,fm.fpioa.SPI1_D1, force True)#miso fm.register(27,fm.fpioa.SPI1_SCLK, force True)#sclk spi1 SPI(SPI.SPI1, mode SPI.MODE_MASTER, baudrate 10000000, polarity 0, phase 0, bits 8, firstbit SPI.MSB) w b'\\xFF' r bytearray(1) cs.value(0) print(spi1.write_readinto(w, r)) cs.value(1) ```"},"/soft/maixpy/en/modules/on_chip/gpio.html":{"title":"Use of GPIO","content":" title: Use of GPIO keywords: maixpy, k210, AIOT, edge computing desc: maixpy use of GPIO For detailed introduction of GPIO, please refer to [GPIO API Document](../../api_reference//Maix/gpio.html). ## Instructions * Register an IO as a GPIO function ```python from Maix import GPIO from fpioa_manager import fm fm.register(io_number,fm.fpioa.GPIO0) ``` * Set GPIO as input or output mode ```python gpio GPIO(GPIO.GPIO0,GPIO.OUT) ``` * Read or set GPIO level ```python gpio.value(1) ``` ## Example Turn on the LED > `board_info` is related to the board, and different board configurations are different. [Manual configuration](../../api_reference/builtin_py/board_info.html) is required before use. ```python import utime from Maix import GPIO from board import board_info from fpioa_manager import fm fm.register(board_info.LED_R,fm.fpioa.GPIO0) led_r GPIO(GPIO.GPIO0,GPIO.OUT) utime.sleep_ms(500) led_r.value(0) fm.unregister(board_info.LED_R) ```"},"/soft/maixpy/en/modules/on_chip/wdt.html":{"title":"Use of WDT (Watchdog)","content":" title: Use of WDT (Watchdog) keywords: maixpy, k210, AIOT, edge computing desc: maixpy the use of WDT (watchdog) For detailed introduction of WDT, please refer to [WDT API Document](../../api_reference/machine/wdt.html). ## Instructions The watchdog is mainly used to protect the normal operation of the system. The principle of action is that after the watchdog is started, a dog feeding operation must be executed regularly in the program. When the system is disturbed and cannot operate normally, the dog feeding operation cannot be executed regularly. At this time, the watchdog will generate an internal reset, allowing the system to restart. * Import WDT module from machine ```python from machine import WDT ``` * Define the callback function and create the WDT object ```python def on_wdt(self): print(self.context(), self) #self.feed() ## release WDT #self.stop() # test callback wdt wdt1 WDT(id 1, timeout 4000, callback on_wdt, context {}) ``` * Feed the dog ```python wdt1.feed() ``` *Dog feeding operation can be performed in the callback function* * Turn off watchdog ```python wdt1.stop() ``` ## Example 1. Close after feeding the dog once 2. Do not feed the dog to reset the system ```python import time from machine import WDT #''' # test default wdt wdt0 WDT(id 0, timeout 3000) print('into', wdt0) time.sleep(2) print(time.ticks_ms()) # 1.test wdt feed wdt0.feed() time.sleep(2) print(time.ticks_ms()) # 2.test wdt stop wdt0.stop() print('stop', wdt0) # 3.wait wdt work #while True: #print('idle', time.ticks_ms()) #time.sleep(1) #''' #''' def on_wdt(self): print(self.context(), self) #self.feed() ## release WDT #self.stop() # test callback wdt wdt1 WDT(id 1, timeout 4000, callback on_wdt, context {}) print('into', wdt1) time.sleep(2) print(time.ticks_ms()) # 1.test wdt feed wdt1.feed() time.sleep(2) print(time.ticks_ms()) # 2.test wdt stop wdt1.stop() print('stop', wdt1) # 3.wait wdt work #while True: #print('idle', time.ticks_ms()) #time.sleep(1) #''' #''' ## test default and callback wdt def on_wdt(self): print(self.context(), self) #self.feed() ## release WDT #self.stop() wdt0 WDT(id 0, timeout 3000, callback on_wdt, context []) wdt1 WDT(id 1, timeout 4000, callback on_wdt, context {}) ## 3.wait wdt work while True: #wdt0.feed() print('idle', time.ticks_ms()) time.sleep(1) #''' '''output into [MAIXPY]WDT:(800cc560; id 0, timeout 3000, callback 800abcf8, context 800abcf8) 550247 552247 stop [MAIXPY]WDT:(800cc560; id 0, timeout 3000, callback 800abcf8, context 800abcf8) into [MAIXPY]WDT:(800cc5e0; id 1, timeout 4000, callback 800cc5a0, context 800cc5c0) 554261 556261 stop [MAIXPY]WDT:(800cc5e0; id 1, timeout 4000, callback 800cc5a0, context 800cc5c0) idle 556268 idle 557269 idle 558269 [] [MAIXPY]WDT:(800cc680; id 0, timeout 3000, callback 800cc620, context 800cc640) idle 559275 {} [MAIXPY]WDT:(800cce40; id 1, timeout 4000, callback 800cc620, context 800cc6c0) idle 560282 idle 561283 [MAIXPY] Pll0:freq:806000000 [MAIXPY] Pll1:freq:398666666 [MAIXPY] Pll2:freq:45066666 [MAIXPY] cpu:freq:403000000 [MAIXPY] kpu:freq:398666666 [MAIXPY] Flash:0xef:0x17 [MaixPy] gc heap 0x800c9850 0x80149850(524288) [MaixPy] init end __ __ _____ __ __ _____ __ __ \\/ /\\ _ _ \\ \\ / / __ \\ \\ \\ / / \\ / / \\ \\ V / __) \\ \\_/ / \\/ / /\\ \\ > < ___/ \\ / / ____ \\ _ _ /. \\ _ _ /_/ \\_\\ _____ /_/ \\_\\ _ _ Official Site: https://www.sipeed.com Wiki: https://maixpy.sipeed.com MicroPython v0.5.1 174 gf18990aa3 dirty on 2021 01 11; Sipeed_M1 with kendryte k210 Type \"help()\" for more information. ''' ```"},"/soft/maixpy/en/modules/others/servo.html":{"title":"steering gear","content":" title: steering gear keywords: maixpy, k210, AIOT, edge computing desc: maixpy steering gear ## caveat!Please use an external power supply, do not use a computer to supply power to the steering gear. ## Instructions The steering gear needs to use PWM output with different duty ratios to control its rotation angle. First, you need to prepare the steering gear * Import the PWM module, create a PWM object, and connect the PWM output pin to the servo signal input ```python from machine import Timer,PWM tim Timer(Timer.TIMER0, Timer.CHANNEL0, mode Timer.MODE_PWM) S1 PWM(tim, freq 50, duty 0, pin 17) ``` * Output different duty cycle waveforms to control the servo ```python S1.duty((angle+90)/180*10+2.5) ``` PWM control API reference: [PWM API](../../api_reference/machine/pwm.html) ## Routine * Control the servo to rotate at different angles: [Servo](https://github.com/sipeed/MaixPy v1_scripts/blob/79a5485ec983e67bb8861305a52418b29e0dc205/modules/others/Servo/Servo.py) * Servo pan/tilt: [gimbal](https://github.com/sipeed/MaixPy v1_scripts/tree/master/application/gimbal)"},"/soft/maixpy/en/modules/others/onewire.html":{"title":"Use of onewire (single bus)","content":" title: Use of onewire (single bus) keywords: maixpy, k210, AIOT, edge computing desc: maixpy Use of onewire (single bus) ## Instructions * Import onewire module from modules ```python from modules import onewire ``` * Create onewire object ```python fm.register(14, fm.fpioa.GPIOHS2, force True) bus onewire(fm.fpioa.GPIOHS2) ``` * Search, read and write data and other operations ## Routine ds18b20 temperature reading: [onwire_ds18b20](https://github.com/sipeed/MaixPy v1_scripts/blob/80f4eb71d3481b6f119f25f39f7c9b37404b99ce/hardware/demo_onewire_ds18x20.py)"},"/soft/maixpy/en/modules/others/index.html":{"title":"other modules","content":" title: other modules keywords: maixpy, k210, AIOT, edge computing desc: maixpy other modules * [Binocular camera](./binocular_camera.html) * [esp32 ADC analog to digital conversion](./esp32_read_adc.html) * [HTPA infrared temperature measurement](./htpa.html) * [Serial infrared lens](./mlx90640.html) * [Servo](./servo.html)"},"/soft/maixpy/en/modules/others/mlx90640.html":{"title":"MLX90640 serial infrared lens module","content":" title: MLX90640 serial infrared lens module keywords: maixpy, k210, AIOT, edge computing desc: maixpy MLX90640 serial infrared lens module <div style \"center\"> <img src \"./../../../assets/hardware/other/mlx90640_hot_map3.jpg\"> <img src \"../../../assets/hardware/other/k210_mlx90640_hot_map2.jpg\"> </div> Can be used for non contact temperature measurement. ## Parameters * Resolution: 32x24 * Measuring range: 40°C~300°C * Temperature resolution: 0.1°C * Measurement accuracy: ±2°C * Repeatability: ±2°C * Response frequency: 8HZ * Working voltage: 3.3~5V * Working current: 42mA * Working temperature: 40°C~85°C * Size: 17.27mmx33mm ## Instructions The module uses serial port or I2C for communication. After confirming that the wiring is correct, the measurement data can be read from the serial port. ## Routine * Display infrared thermal imaging pictures on LCD: [demo mlx90640](https://github.com/sipeed/MaixPy v1_scripts/tree/master/modules/others/mlx90640) ## More * Module details: [Far infrared thermal sensor array (32x24 RES)](https://www.melexis.com/en/product/MLX90640/Far Infrared Thermal Sensor Array) * Detailed tutorial: [mlx90640](https://neucrack.com/p/189)"},"/soft/maixpy/en/modules/others/htpa.html":{"title":"HTPA thermal infrared temperature measurement module","content":" title: HTPA thermal infrared temperature measurement module keywords: maixpy, k210, AIOT, edge computing desc: maixpy HTPA thermal infrared temperature measurement module <img src \"./../../../assets/hardware/other/htpa32x32.png\"> <img src \"../../../assets/hardware/other/htpat_scale_240x240.png\"> Can be used for non contact temperature measurement. ## Parameters * Power supply voltage (DC): 3.3V * Current consumption: 5.5(±1.0)mA * Clock frequency (sensor): 5(±3)MHz * Ambient temperature range: 20 ~ 85℃ * Target temperature range: 20 ~ >1000°C * Frame rate (full frame): 2 ~ 27hz * Frame rate (quarter frame): 8 ~ 110hz * Noise equivalent temperature difference (best optics): 140mK@1Hz * Communication method: I2C ## Instructions MaixPy has implemented htpa in modules (you need to enable the module when the firmware is compiled to be available). * Import and create htpa ```python from machine import I2C from modules import htpa dev htpa(i2c I2C.I2C0, scl_pin 7, sda_pin 6, i2c_freq 1000000) ``` * Get the temperature of all points in the detection range ```python temperature dev.temperature() ``` API details refer to [modules.htpa](../../api_reference/extend/htpa.html) ## Routine * Draw temperature distribution graph on LCD: [htpa demo](https://github.com/sipeed/MaixPy v1_scripts/blob/79a5485ec983e67bb8861305a52418b29e0dc205/modules/others/heimann_HTPA_32x32/HTPA_32x32_demo.py) ## More * Module information: [32x32 Thermopile Array](https://www.heimannsensor.com/32x32) * Detailed tutorial: [thermal infrared heimann (Hyman) HTPA 32x32d](https://neucrack.com/p/199)"},"/soft/maixpy/en/modules/others/esp32_read_adc.html":{"title":"ESP32 ADC","content":" title: ESP32 ADC keywords: maixpy, k210, AIOT, edge computing desc: maixpy ESP32 ADC ## How to use ESP32 to get ADC analog Since K210 does not have the function of ADC to read analog quantity, this function can only be obtained from hardware such as ESP32 and ESP82XX. The most basic purpose of ADC is to realize a touchable button contact. ### ESP32 sample code ```python # Uasge see readme.md # from network_esp32 import wifi import time, network from Maix import GPIO from fpioa_manager import fm class wifi(): # IO map for ESP32 on Maixduino fm.register(25,fm.fpioa.GPIOHS10)#cs fm.register(8,fm.fpioa.GPIOHS11)#rst fm.register(9,fm.fpioa.GPIOHS12)#rdy print(\"Use Hareware SPI for other maixduino\") fm.register(28,fm.fpioa.SPI1_D0, force True)#mosi fm.register(26,fm.fpioa.SPI1_D1, force True)#miso fm.register(27,fm.fpioa.SPI1_SCLK, force True)#sclk nic network.ESP32_SPI(cs fm.fpioa.GPIOHS10, rst fm.fpioa.GPIOHS11, rdy fm.fpioa.GPIOHS12, spi 1) print(\"ESP32_SPI firmware version:\", wifi.nic.version()) # get ADC0 ADC1 ADC2 adc wifi.nic.adc((0,1,2)) print(adc) while True: try: # get ADC0~5 adc wifi.nic.adc() except Exception as e: print(e) continue for v in adc: print(\"%04d\" %(v), end \" \") print(': adc') ''' MicroPython v0.5.1 136 g039f72b6c dirty on 2020 11 18; Sipeed_M1 with kendryte k210 Type \"help()\" for more information. >>> raw REPL; CTRL B to exit >OK (2370, 3102, 3071) 2017 2753 0977 2709 0963 0855: adc 0617 0757 0150 0095 0133 0153: adc 1319 1478 0955 0939 0698 0619: adc 2403 3231 3299 3298 1483 0779: adc 1119 1815 1274 1315 0230 0255: adc 0951 0951 0295 0283 0319 0399: adc 2175 2769 2576 2579 1487 1104: adc 1995 2846 2647 2699 0839 0441: adc ''' ``` ### OSError: Get version fail Just try again, usually esp32 has not been initialized successfully. ```shell Traceback (most recent call last): File \"<stdin>\", line 15, in <module> File \"<stdin>\", line 24, in wifi OSError: Get version fail > ``` ### ESP82XX implementation ideas > The document does not explain this part of the content. Query the ADC value through AT+SYSADC. In Espressif's ESP82XX AT firmware, the default is GPIO12. Read the value directly to use."},"/soft/maixpy/en/modules/others/binocular_camera.html":{"title":"Binocular camera","content":" title: Binocular camera keywords: maixpy, k210, AIOT, edge computing desc: maixpy binocular camera ![](../../../assets/hardware/module/camera_binocular.png) ## Instructions Need to prepare a binocular camera * Import and initialize the binocular camera ```python import sensor sensor.binocular_reset() sensor.shutdown(False) sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.shutdown(True) sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) ``` * Turn on the camera and capture images ```python sensor.shutdown(True) img sensor.snapshot() ``` For API details, please refer to: [Sensor API](../../api_reference/machine_vision/sensor.html) ## Routine Capture image and display on LCD [demo_binocular](https://github.com/sipeed/MaixPy v1_scripts/blob/5a03ab549d06cd713f2c0d19f0c18fbd24c69025/hardware/demo_binocular.py)"},"/soft/maixpy/en/modules/sp_mod/sp_lcd1.14.html":{"title":"Use of SP_LCD1.14","content":" title: Use of SP_LCD1.14 keywords: maixpy, k210, AIOT, edge computing desc: maixpy Use of SP_LCD1.14 <img src \"../../../assets/hardware/module_spmod/sp_lcd1.14.png\"/> SP_LCD has a 1.14' inch LCD, 8P FPC (0.5mm pitch) interface TFT LCD screen, 180° viewing angle. ## Parameters * Screen size: 1.14 inches * Resolution: 240*135 * Color: 132 RGB channels * Communication interface: SPI * Effective display area: 21.7mm * 10.8mm * Working voltage: 2.5V~4.8V * Working temperature: 30°C~85°C For detailed module information, please refer to [LCD114 Specification and Data Manual](http://api.dl.sipeed.com/shareURL/MAIX/HDK/sp_mod/sp_lcd114) ## Instructions 1. Preparation: The development board with the latest firmware, sp_lcd114 module. 2. Run: Connect the module, modify the configuration surrounded by config in [Sample Code](https://github.com/sipeed/MaixPy v1_scripts/tree/master/modules/spmod/sp_lcd114), the module will display the picture after running. The procedure is as follows: ```python # init ips SPLCD114(spi1, cs, dc, rst, busy, IPS_WIDTH, IPS_HEIGHT, IPS_MODE) # create an'image' and fill it img image.Image() img.draw_rectangle(80, 80, 30, 30) # display ips.display(img) ``` The main steps are: * Initialization (the parameters from left to right are: SPI object, chip select pin, reset pin, busy flag pin, screen width, screen height, screen orientation). * Create Image. * Call display to display the picture (the incoming parameter is the Image object)."},"/soft/maixpy/en/modules/sp_mod/sp_rfid.html":{"title":"Use of SP_RFID","content":" title: Use of SP_RFID keywords: maixpy, k210, AIOT, edge computing desc: maixpy Use of SP_RFID <img src \"../../../assets/hardware/module_spmod/sp_rfid.png\"/> The FM17510 used in this module is a highly integrated non contact reader/writer chip working at 13.56MHz. It supports the non contact reader/writer mode conforming to the ISO/IEC 14443 TypeA protocol, and the program is compatible with MFRC522. ## Parameters * Support ISO/IEC 14443 TypeA reader mode * Reader mode supports M1 encryption algorithm * ISO14443 TYPEA supports communication rate 106kbps, 212kbps, 424kbps * Support SPI serial interface, up to 10Mbps * Voltage range 2.2V~3.6V * 64Byte transmit and receive buffer FIFO * Multiple low power consumption modes: Soft powerdown mode Hard powerdown mode * Built in CRC coprocessor * Support low power external card detection function * Working voltage: 2.2V~3.6V * Working temperature: 40°C~85°C For detailed module information, please refer to [RFID Specification and Data Manual](http://api.dl.sipeed.com/shareURL/MAIX/HDK/sp_mod/sp_rfid) ## Instructions 1. Preparation: The development board with the latest firmware, sp_rfid module, M1 card. 2. Run: Connect the module, modify the configuration surrounded by config in [Sample Code](https://github.com/sipeed/MaixPy v1_scripts/tree/master/modules/spmod/sp_rfid), and put the card close to the module antenna after running. See the card reading information printed by the terminal. The procedure is as follows: ```python # Init module MIFAREReader MFRC522(spi1, cs) # Scan for cards (status, ataq) MIFAREReader.MFRC522_Request(MIFAREReader.PICC_REQALL) # Get uid (status, uid) MIFAREReader.MFRC522_Anticoll() if status MIFAREReader.MI_OK: # Bind card by uid MIFAREReader.MFRC522_SelectTag(uid) # Authenticate block 0x11 by key status MIFAREReader.MFRC522_Auth(MIFAREReader.PICC_AUTHENT1A, 0x11, key, uid) if status MIFAREReader.MI_OK: # Write 16 bytes from block 0x11 MIFAREReader.MFRC522_Write(0x11, data) # Read 16 bytes from block 0x11 MIFAREReader.MFRC522_Read(0x11) '''output >>> [Warning] function is used by fm.fpioa.GPIOHS20(pin:36) Welcome to the MFRC522 data read/write example Card detected type: 0x400 Card read UID: 110,159,46,15 Size: 8 Sector 11 will now be filled with 1~16: 4 backdata &0x0F 0x0A 10 Data written start to read Sector 18 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15] Card detected type: 0x400 Card read UID: 110,159,46,15 Size: 8 Sector 11 will now be filled with 1~16: 4 backdata &0x0F 0x0A 10 Error while writing Data written ''' ``` It is mainly divided into several steps: * Create MFRC522 object (parameters: SPI object, chip selection pin). * Scan the card and get ATQA (i.e. card type code), ATQA corresponding card types are as follows: ATQA Type : : : 0x4400 Mifare_UltraLight 0x0400 Mifare_One(M1 S50) 0x0200 Mifare_One(M1 S70) 0x0800 Mifare_Pro(X) 0x4403 Mifare_DESFire * Get card UID * Binding the card through UID (anti collision, to ensure that the selected card can execute the transaction correctly, and is not affected by another card on site) * Authenticate a certain sector in the card (M1 (S50) default password is 16 0xff) * Read/write card information (take one block (16 bytes) as the basic read and write unit)"},"/soft/maixpy/en/modules/sp_mod/sp_tof.html":{"title":"Use of SP_TOF","content":" title: Use of SP_TOF keywords: maixpy, k210, AIOT, edge computing desc: maixpy use of SP_TOF <img src \"../../../assets/hardware/module_spmod/sp_tof.png\"/> The VL53L0X used by SP_TOF is a new generation of time of flight (ToF) laser ranging module, which can provide accurate distance measurement regardless of the reflectivity of the target, with a red laser sight to assist in observing the ranging point. ## Parameters * Measuring distance: up to 2000mm (dark environment), 1000mm (bright environment) * Working refresh rate: 50Hz * Measuring angle: 27° (front) * Communication interface: I2C * Working voltage: 2.6V~3.5V * Working temperature: 40°C~80°C For detailed module information, please refer to [TOF Specification and Data Manual](http://api.dl.sipeed.com/shareURL/MAIX/HDK/sp_mod/sp_tof) ## Instructions 1. Preparation: The development board with the latest firmware, sp_tof module. 2. Run: Connect the module, modify the configuration surrounded by config in [Sample Code](https://github.com/sipeed/MaixPy v1_scripts/tree/master/modules/spmod/sp_tof), and aim the laser aiming head to measure after running Click to see the distance information printed by the terminal. The procedure is as follows: ```python # create obj and read distance tof VL53L0X(i2c) while True: mm tof.read() utime.sleep_ms(100) print(mm) '''output >>> [41] 536mm 538mm 533mm 535mm 529mm 532mm ''' ``` The main steps are: * Create TOF object (parameter: I2C object). * The reading distance, if the reading distance is 8190, it means that the range has been exceeded."},"/soft/maixpy/en/modules/sp_mod/sp_ethernet.html":{"title":"Use of SP_Ethernet","content":" title: Use of SP_Ethernet keywords: maixpy, k210, AIOT, edge computing desc: maixpy use of SP_Ethernet <img src \"../../../assets/hardware/module_spmod/sp_ethernet.png\"> This module uses W5500 as the main control chip, which is an embedded Ethernet controller that integrates a full hardware TCP/IP protocol stack. ## Parameters * Working voltage: 2.6V~3.6V * Working current: <132mA * Sleep current: <15mA * Communication interface: SPI * Operating temperature range: 40℃ ~ 85℃ For detailed module information, please refer to [Ethernet Specification](http://api.dl.sipeed.com/shareURL/MAIX/HDK/sp_mod/sp_ethernet) ## Instructions 1. Preparation: The development board with the latest firmware, sp_ethernet module, and network cable. 2. Run: Connect the module, modify the configuration surrounded by config in [Sample Code](https://github.com/sipeed/MaixPy v1_scripts/tree/master/modules/spmod/sp_ethernet), the module will print the communication data after running. The procedure is as follows: ```python spi1 SPI(4, mode SPI.MODE_MASTER, baudrate 600 * 1000, polarity 0, phase 0, bits 8, firstbit SPI.MSB, sck WIZNET5K_SPI_SCK, mosi WIZNET5K_SPI_MOSI, miso WIZNET5K_SPI_MISO) # create wiznet5k nic nic network.WIZNET5K(spi spi1, cs WIZNET5K_SPI_CS) print(\"Static IP: \", nic.ifconfig()) ``` * Create SPI and use SPI to create WIZNET5K wired network card * Print current IP information Related API reference: [wiznet5k API](../../api_reference/machine/network.html#WIZNET5K_Module)"},"/soft/maixpy/en/modules/sp_mod/sp_bt.html":{"title":"Use of SP_BT","content":" title: Use of SP_BT keywords: maixpy, k210, AIOT, edge computing desc: maixpy use of SP_BT <img src \"../../../assets/hardware/module_spmod/sp_bt.png\"/> SP_BT is a Bluetooth serial port transparent transmission module with ultra low power characteristics and high reliability. It is controlled by AT commands. The Bluetooth version is BLE 5.0 (compatible with BLE4.0, BLE4.2) and the default serial port baud rate is 9600. ## Parameters * Receiving sensitivity: 97dm * Transmitting power: 4db (maximum) * Communication interface: UART * Antenna: Onboard antenna * Master slave support: slave * Working frequency: 2.4G * Working temperature: 40°C~85°C * Working voltage: 1.8V~3.6V For detailed module information, please refer to [BT Specification and Data Manual](http://api.dl.sipeed.com/shareURL/MAIX/HDK/sp_mod/sp_bt) ## Instructions for use 1. Preparation: The development board with the latest firmware, sp_bt module, Bluetooth debugging assistant. 2. Run: Connect the module, modify the configuration surrounded by config in [Sample Code](https://github.com/sipeed/MaixPy v1_scripts/tree/master/modules/spmod/sp_bt), use the Bluetooth debugging assistant to connect and send after running Data, you can view the received and sent information on the terminal. The procedure is as follows: ```python # set uart rx/tx func to io_6/7 fm.register(TX, fm.fpioa.UART1_TX) fm.register(RX, fm.fpioa.UART1_RX) # init uart uart UART(UART.UART1, 9600, 8, 1, 0, timeout 1000, read_buf_len 4096) set_name(uart, name) print(\"wait data: \") while True: read_data uart.read() if read_data: print(\"recv:\", read_data) uart.write(read_data) # send data back print(\"wait data: \") ``` The main steps are: * Initialize the serial port (the baud rate is 9600 by the module default baud rate) * Set the module broadcast name * Wait for connection, send back after receiving the data and printing ## Connection process * After the module is initialized, it is not connected (indicator: ACT flashes, STA is always off). * After the Bluetooth debugging assistant is connected, the module becomes connected (indicators: ACT is always on, STA is always on). * The services displayed by the Bluetooth debugging assistant after connection are as follows: <img src \"../../../assets/hardware/module_spmod/sp_bt_screenshot.png\" alt \"bt_server\"/> In the above figure, you can see that there is a service with a UUID of ffe0 that has two characteristics.Turn on the Write and Notify of the transparent transmission (ffe1) to start sending/receiving data."},"/soft/maixpy/en/modules/sp_mod/index.html":{"title":"SP-MOD","content":" title: SP MOD keywords: maixpy, k210, AIOT, edge computing desc: maixpy SP MOD ## SP MOD interface SP MOD is sipeed module, simplify PMOD, super module, Sipeed official main recommendation and use, 8P 2.54mm 2x4 double row female, support communication protocol as follows: ![](./../../../assets/hardware/module_spmod/sp_mod.svg) ## Peripheral Module The following modules all use SP MOD standard interface modules. * [SP_BT Bluetooth transparent transmission](./sp_bt.html) * [SP_LoRa Wireless Communication](./sp_lora.html) * [SP_RFID Radio Frequency Identification](./sp_rfid.html) * [SP_TOF Ranging](./sp_tof.html) * [SP_Eink Electronic Ink Screen](./sp_eink.html) * [SP_LCD1.14 IPS screen](./sp_lcd1.14.html) * [SP_Weather weather sensor](./sp_weather.html) * [SP_Ethernet wired network port](./sp_ethernet.html)"},"/soft/maixpy/en/modules/sp_mod/sp_weather.html":{"title":"Use of SP_WEATHER","content":" title: Use of SP_WEATHER keywords: maixpy, k210, AIOT, edge computing desc: maixpy Use of SP_WEATHER <img src \"../../../assets/hardware/module_spmod/sp_weather.png\"/> The SP_Weather weather module has two sensors, the magnetic sensor QMC7983, which is a three axis magnetic sensor with built in sensitivity compensation and NTC. It has excellent dynamic range and accuracy and ultra low power consumption. The temperature, humidity and air pressure sensor BME280 can simultaneously measure temperature Humidity and atmospheric pressure. ## Parameters ### Magnetic sensor QMC7983 * Magnetic induction range: ±30 Gauss * Accuracy: 1mG per LSB * RMS noise: 2mG * External interface: I2C, default address 0x2C, can be adjusted by selecting resistance * Working voltage: 2.6V~3.6V * Working temperature: 30°C ~ 85°C ### Temperature, Humidity and Pressure Sensor BME280 * The key parameters of the temperature sensor * Measuring range: 40°C~85 * Accuracy: range(°C)accuracy(°C) 25±0.5 0~65±1.0 20~0±1.25 40~ 20±1.5 * Key parameters of humidity sensor * Response time (τ63%): 1 s * Accuracy tolerance: ±3% relative humidity * Hysteresis: ±1% relative humidity * Key parameters of air pressure sensor * RMS noise: 0.2Pa (equivalent to 1.7cm) * Offset temperature coefficient: ±1.5 Pa/K (equivalent to ±12.6cm when the temperature changes at 1℃) * External interface: I2C, default address 0x76, can be adjusted by selecting resistance * Working voltage: 1.71V~3.6V * Working temperature: 30°C ~ 85°C For detailed module information, please refer to [Meteorological Module Specification and Data Manual](http://api.dl.sipeed.com/shareURL/MAIX/HDK/sp_mod/sp_weather) ## Instructions 1. Preparation: The development board with the latest firmware, sp_weather module. 2. Run: Connect the module, modify the configuration surrounded by config in [Sample Code](https://github.com/sipeed/MaixPy v1_scripts/tree/master/modules/spmod/sp_weather), you can see the magnetism printed on the terminal after running Sensor and air pressure temperature and humidity sensor data The procedure is as follows: ```python weather SPWEATHER(i2c i2c_bus) # create sp_weather while 1: time.sleep_ms(500) print(weather.qmc_read_xyz) # QMC7983 read data print(weather.bme_values) # BME280 read data '''output >>> I2C devices:[44, 118] 0x32 6 (228, 123, 156) ('31.0C', '1017.75hPa', '34.32%') (235, 130, 185) ('30.75C', '1017.74hPa', '34.31%') (235, 130, 161) ('30.7C', '1017.82hPa', '34.32%') ''' ``` The main steps are: * Create SPWEATHE (parameter: I2C object). * Read magnetic sensor data and temperature and humidity data. (The data read are all tuples)"},"/soft/maixpy/en/modules/sp_mod/sp_eink.html":{"title":"Use of SP_EINK","content":" title: Use of SP_EINK keywords: maixpy, k210, AIOT, edge computing desc: maixpy use of SP_EINK <img src \"../../../assets/hardware/module_spmod/sp_eink.png\"/> The GDEW0154M09 used by the SP_EINK module is a 1.54” electronic ink screen with a 24P FPC (0.5mm pitch) interface. ## Parameters * Screen size: 1.54 inches * Effective display area: 27.6mm * 27.6mm * Color: black/white/red display * Communication interface: SPI * Working temperature: 40°C~85°C * Working voltage: 2.3V~3.6V For detailed module information, please refer to [EINK Specification and Data Manual](http://api.dl.sipeed.com/shareURL/MAIX/HDK/sp_mod/sp_eink) ## Instructions 1. Preparation: The development board with the latest firmware, sp_eink module. 2. Run: Connect the module, modify the configuration surrounded by config in [Sample Code](https://github.com/sipeed/MaixPy v1_scripts/tree/master/modules/spmod/sp_eink), the module will display the picture after running. The procedure is as follows: ```python # init epd SPEINK(spi1, cs, dc, rst, busy, EPD_WIDTH, EPD_HEIGHT) epd.init() # create red image img_r image.Image() img_r img_r.resize(EPD_WIDTH, EPD_HEIGHT) img_r.draw_line(0, 0, 100, 100) # create black/white image img_bw image.Image() img_bw img_bw.resize(EPD_WIDTH, EPD_HEIGHT) img_bw.draw_line(100, 50, 200, 100) # display epd.display(img_r, img_bw) # sleep mode epd.sleep() ``` The main steps are as follows: * Create SPEINK object (parameters: SPI object, chip select pin, reset pin, busy flag pin, horizontal resolution, vertical resolution, screen rotation angle (0, 90, 180, 270)), initialize. * Create red and black images, set to screen size and fill the image. * Call display (parameters are: red image, black image), the screen will flash and the image will be displayed at this time. * Go to sleep."},"/soft/maixpy/en/modules/sp_mod/sp_lora.html":{"title":"Use of SP_LORA","content":" title: Use of SP_LORA keywords: maixpy, k210, AIOT, edge computing desc: maixpy use of SP_LORA <img src \"../../../assets/hardware/module_spmod/sp_lora.png\"/> SP_LoRa module uses M XL8 module, which has built in LoRaTM modem and adjustable power amplifier LoRa module, which has high performance and high reliability. ## Parameters * Working frequency: 370MHz~1200Mhz * Transmitting power: 20dBm (maximum) * Communication interface: SPI * Antenna: External antenna, IPEX or welding * Receiving sensitivity: 148dbm * RSSI dynamic range: 127dB * Working voltage: 1.8V~6.3V * Working temperature: 40°C~80°C For detailed module information, please refer to [LoRa Specification and Data Manual](http://api.dl.sipeed.com/shareURL/MAIX/HDK/sp_mod/sp_lora) ## Instructions 1. Preparation: Two development boards with the latest firmware burned, two sp_lora modules. 2. Run: Connect the module, modify the configuration surrounded by config in [sample code](https://github.com/sipeed/MaixPy v1_scripts/tree/master/modules/spmod/sp_lora), and run the two development boards to send and receive separately Function, you can view the received and sent information on the terminal. The procedure is as follows: ```python # init lora SX127x(spi spi1, pin_ss cs) # lora reset rst.value(0) time.sleep_ms(10) rst.value(1) time.sleep_ms(100) lora.init() ####### receiver ########## receive(lora) ######## sender ########### # send(lora) '''output mpfs [/flash]> runfile lora_send.py transfer 6400 of 14576 transfer 12800 of 14576 transfer 14576 of 14576 [Warning] function is used by fm.fpioa.GPIOHS7(pin:23) LoRa Sender Sending packet: Hello(0) mpfs [/sd]> runfile lora_recv.py transfer 6400 of 14576 transfer 12800 of 14576 transfer 14576 of 14576 [Warning] function us used by fm.fpioa.GPIOHS7(pin:23) LoRa Receiver [Memory free: 470080 allocated: 48064] *** Received message *** Hello(0) with RSSI: <bound_method 800d19e0 <SX127x object at 800f5700>.<function packetRssi at 0x800d3180>> ''' ``` The debugging and running tool used here is mpfshell, which is convenient to open two terminals to run scripts at the same time. The main steps are: * Create LoRa object (parameters: SPI object, chip selection pin) * Reset (pull the reset pin low or high), initialization. * Start sending or receiving."},"/soft/maixpy/en/api_reference/standard/ucollections.html":{"title":"ucollections-collection and container types","content":" title: ucollections collection and container types keywords: maixpy, k210, AIOT, edge computing desc: maixpy ucollections collections and container types This module implements a subset of the corresponding CPython module, as described below. For more information, please refer to the original CPython documentation [collections](https://docs.python.org/3.5/library/collections.html#module collections). This module implements advanced collections and container types to store/accumulate various objects. ## Class ### ucollections.deque(iterable, maxlen[, flags]) Deques (deques) is a list like container that supports O(1) append and pops from either side of the deque. Create new deques with the following parameters: * Iterable must be an empty tuple, and the new deque is created as empty. * Must specify maxlen, and the deque will be limited to this maximum length. Once the deque is full, any new items added will discard each other's items. * When adding items, the optional flag can be 1 to check overflow. In addition to supporting bool and len, the deque object has the following methods: #### `deque.append(x)` Add `x` to the right side of the deque. If overflow checking is enabled and there is no space left, an IndexError is raised. #### `deque.popleft()` Remove and return an item from the left side of the deque. If there are no items, an IndexError is raised. ### ucollections.namedtuple(name, fields) This is a factory function to create a new namedtuple type with a specific name and field set. namedtuple is a subclass of tuples. It can not only access its fields through numerical indexes, but also use symbolic field names to access attribute access syntax. Fields is a sequence of strings specifying the names of fields. For compatibility with CPython, it can also be a string named after a space separated field (but it is less efficient). Use example: ```python from ucollections import namedtuple MyTuple namedtuple(\"MyTuple\", (\"id\", \"name\")) t1 MyTuple(1, \"foo\") t2 MyTuple(2, \"bar\") print(t1.name) assert t2.name t2[1] ``` ### ucollections.OrderedDict(...) The `dict` type subclass, it remembers and preserves the order of the added keys. When the dict is iterated, the keys/items are returned in the order of addition: ```python from ucollections import OrderedDict # To make benefit of ordered keys, OrderedDict should be initialized # from sequence of (key, value) pairs. d OrderedDict([(\"z\", 1), (\"a\", 2)]) # More items can be added as usual d[\"w\"] 5 d[\"b\"] 3 for k, v in d.items(): print(k, v) ``` Output: ```python z 1 a 2 w 5 b 3 ```"},"/soft/maixpy/en/api_reference/standard/uos.html":{"title":"uos-basic \"operating system\" services","content":" title: uos basic \"operating system\" services keywords: maixpy, k210, AIOT, edge computing desc: maixpy uos basic \"operating system\" services This module implements a subset of the corresponding CPython module, as described below. For more information, please refer to the original CPython documentation: [os](https://docs.python.org/3.5/library/os.html#module os). The `uos` module contains functions for file system access and mounting, terminal redirection and copying, and `uname` and `urandom`. ## Common functions ### uos.uname() Return a tuple (perhaps a named tuple) containing information about the underlying machine and/or its operating system. The tuple has five fields in the following order, and each field is a string: * sysname the name of the underlying system * nodename node name (/board name) (can be the same as sysname) * release the version of the underlying system * version MicroPython version and build date * machine the identifier of the underlying hardware (for example, board, CPU) ### uos.urandom(n) Returns a bytes object containing n random bytes. Whenever possible, it is generated by a hardware random number generator. ## File system access ### uos.chdir(path) Change the current directory. ### uos.getcwd() Get the current directory. ### uos.ilistdir([dir]) This function returns an iterator and then generates tuples corresponding to the entries in the listed directories. If no parameter is passed, it lists the current directory, otherwise it lists the directory given by dir. Tuples have the form (name, type, inode[, size]): * name: is a string (if dir is a bytes object, then bytes), and is the name of the entry; * type: is an integer that specifies the type of entry, the directory is 0x4000, and the regular file is 0x8000; * inode: is an integer corresponding to the file inode, and it can be 0 for file systems without this concept. * Some platforms may return a 4 tuple containing the size of the entry. For file entries, size is an integer representing the size of the file, or 1 if unknown. The meaning of the current entry is currently undefined. ### uos.listdir([dir]) If there are no parameters, please list the current directory. Otherwise, list the given directory. ### uos.mkdir(path) Create a new directory. ### uos.remove(path) Delete Files. ### uos.rmdir(path) Delete the directory. ### uos.rename (old_path, new_path) Rename the file. ### uos.stat(path) Get the status of a file or directory. ### uos.statvfs(path) Get the status of the file system. Return a tuple containing file system information in the following order: * f_bsize file system block size * f_frsize fragment size * f_blocks the size of fs in f_frsize unit * f_bfree the number of free blocks * f_bavail the number of free blocks for unprivileged users * f_files number of inodes * f_ffree the number of free inodes * f_favail the number of free inodes for unprivileged users * f_flag mount flag * f_namemax maximum file name length Parameters related to inodes: `f_files`, `f_ffree`, `f_avail` and `f_flags` parameters may return '0` because they are not available in hardware specific implementations. ### uos.sync() Synchronize all file systems. ## Terminal redirection and copy ### uos.dupterm(stream_object, index 0) Copy or switch the MicroPython terminal (REPL) on the given `stream` class object. The stream_object parameter must implement the `readinto()` and `write()` methods. The stream should be in non blocking mode. If there is no data available for reading, `readinto()` should return'None`. After calling this function, all terminal output will be repeated on this stream, and any input available on the stream will be passed to the terminal input. The index parameter should be a non negative integer and specify the set replication slot. A given port can implement multiple slots (slot 0 will always be available), and in this case, terminal input and output are replicated on all set slots. If `None` is passed as a stream_object, the copy is canceled on the slot given by the index. This function returns the previous stream like object in the given slot. ## File system mount Some ports provide a virtual file system (VFS) and the ability to install multiple \"real\" file systems in this VFS. File system objects can be installed in the root directory of the VFS, or in subdirectories in the root directory. This allows dynamic and flexible configuration of the file system seen by the Python program. Ports with this function provide `mount()` and `umount()` functions, as well as various file system implementations that may be represented by the VFS class. ### uos.mount(fsobj, mount_point, *, readonly) Mount the file system object fsobj to the location in the VFS specified by the mount_point string. fsobj can be a VFS object with a mount() method or a block device. If it is a block device, the file system type is automatically detected (if the file system is not recognized, an exception will be raised). mount_point can be'/' to mount fsobj under the root directory, or'/ <name>' to mount to a subdirectory under the root directory. If readonly is \"True\", the file system is mounted as read only. During the mount process, the `mount()` method is called on the file system object. If mount_point is already mounted, `OSError(EPERM)` will be raised. ### uos.umount(mount_point) Unmount the file system. mount_point can be a string naming the location of the mount, or it can be a previously mounted file system object. During the unmounting process, the method `umount()` is called on the file system object. If mount_point cannot be found, `OSError (EINVAL)` will be raised. ### class uos.VfsFat(block_dev) Create a file system object formatted using the FAT file system. The storage of the FAT file system is provided by block_dev. You can use `mount()` to mount the object created by this constructor. #### static mkfs(block_dev) Build a FAT file system on block_dev. ## File system formatting In MaixPy, we provide an operation to format the flash file system. If users want to clear the flash file system, they can use the interface `flash_format` to achieve ### uos.flash_format() This interface does not need to pass in parameters, directly use will format the flash of the development board. Please note that formatting will clear all files, please make sure that all files in flash need to be deleted before use ## Block device A block device is an object that implements a block protocol, which is a set of methods described by the AbstractBlockDev class below. Specific implementations of this type usually allow access to memory like functions as hardware (such as flash memory). Specific file system drivers can use block devices to store data in their file system. ### class uos.AbstractBlockDev()...) The building block device object. The parameters of the constructor depend on the specific block device. #### readblocks(block_num, buf) Starting from the block given by the index block_num, read the block from the device into buf (byte array). The number of blocks to be read is given by the length of buf, which will be a multiple of the block size. #### writeblocks(block_num, buf) Starting from the block given by the index block_num, write the block in buf (byte array) to the device. The number of blocks to be written is given by the length of buf, which will be a multiple of the block size. #### ioctl(op, arg) Control the block device and query its parameters. The operation to be performed is given by op, which is one of the following integers: * 1 Initialize the device (arg is not used) * 2 Turn off the device (arg is not used) * 3 Synchronization device (arg is not used) * 4 Get the count of the number of blocks, it should return an integer (arg is not used) * 5 Get the number of bytes in the block, it should return an integer, or \"None\", in this case the default value 512 is used (arg is not used) ### Routine #### Routine 1 Taking fat32 as an example, the following class will implement a block device that uses `bytearray` to store its data in RAM: ```python class RAMBlockDev: def __init__(self, block_size, num_blocks): self.block_size block_size self.data bytearray(block_size * num_blocks) def readblocks(self, block_num, buf): for i in range(len(buf)): buf[i] self.data[block_num * self.block_size + i] def writeblocks(self, block_num, buf): for i in range(len(buf)): self.data[block_num * self.block_size + i] buf[i] def ioctl(self, op, arg): if op 4: # get number of blocks return len(self.data) // self.block_size if op 5: # get block size return self.block_size ``` or: ```python import uos bdev RAMBlockDev(512, 50) uos.VfsFat.mkfs(bdev) vfs uos.VfsFat(bdev) uos.mount(vfs,'/ramdisk') ``` #### Routine 2 Taking spiffs as an example, the following class will implement a block device, which uses `bytearray` to store its data in RAM: ```python class RAMFlashDev: def __init__(self): self.fs_size 256*1024 self.fs_data bytearray(256*1024) self.erase_block 32*1024 self.log_block_size 64*1024 self.log_page_size 4*1024 def read(self,buf,size,addr): for i in range(len(buf)): buf[i] self.fs_data[addr+i] def write(self,buf,size,addr): for i in range(len(buf)): self.fs_data[addr+i] buf[i] def erase(self,size,addr): for i in range(size): self.fs_data[addr+i] 0xff ``` ```python blkdev RAMFlashDev.RAMFlashDev() vfs uos.VfsSpiffs(blkdev) vfs.mkfs(vfs) uos.mount(vfs,'/ramdisk') ```"},"/soft/maixpy/en/api_reference/index.html":{"title":null,"content":" title: keywords: maixpy, k210, AIOT, edge computing desc: maixpy "},"/soft/maixpy/en/api_reference/extend/onewire.html":{"title":"modules.onewire (single bus)","content":" title: modules.onewire (single bus) keywords: maixpy, k210, AIOT, edge computing desc: maixpy modules.onewire (single bus) A single bus means that there is only a single signal line, which transmits data and clocks, and the data transmission is also bidirectional, saving IO ports. ## Construction method onewire(gpio_num) ### Parameters * `gpio_num`: GPIO number. ### return value * onewire object ## Instance method reset() Reset ### return value * bool type, whether it is successful. ## Instance method readbit() Read one bit of data ### return value * Int type, the data read. ## Instance method readbyte() Read a byte ### return value * Int type, the data read. ## Instance method readbuffer(n) Read the number of bytes of the specified length ### Parameters * `n`: int type, the number of bytes to be read ### return value * bytearray type, the byte array read ## Example method writebit(bit) Write a bit ### Parameters * `bit`: int type, bit data to be written ## Example method writebyte(byte) ### Parameters * `byte`: int type, byte data to be written ## Example method writebuffer(buf) ### Parameters * `buf`: bytearray type, data to be written ## Example method select(rom_in) Let the master specify a certain slave. ### Parameters * `rom_in`: bytearray type, which means that the 8byte ROM data of the slave will be specified. ## Example method search(diff_in) Search using F0H criteria ### Parameters * `diff_in`: int type, the preferred path for the first search ### return value * `list`: a list with elements (depth, roms), `depth` is the search depth, int type, `rom` is the device ROM code, list type. ## Example method skip() Skip ROM, suitable for single node ## Example method depower() Re enable IO ## Example method crc8(data_in) Calculate 8 bit cyclic redundancy check code ### Parameters * `data_in`: data to be verified ### return value * Return check code"},"/soft/maixpy/en/api_reference/extend/ultrasonic.html":{"title":"modules.ultrasonic (ultrasonic ranging module)","content":" title: modules.ultrasonic (ultrasonic ranging module) keywords: maixpy, k210, AIOT, edge computing desc: maixpy modules.ultrasonic (ultrasonic ranging module) Grove Ultrasonic Ranger (ultrasonic ranging module), only a single data cable is required <div class \"grove_pic\"> <img src \"./../../../assets/hardware/module_grove/ultrasonic.jpg\"> </div> ## Construction method ultrasonic(gpiohs) ### Parameters * `gpiohs`: gpiohs number, you need to use `fm` to register the pin first, for example ```python from fpioa_manager import * from modules import ultrasonic fm.register(board_info.D[6], fm.fpioa.GPIOHS0, force True) device ultrasonic(fm.fpioa.GPIOHS0) ``` ### return value Return object ## Method measure(unit, timeout) ### Parameters * `unit`: unit, take the value in the following constant * `timeout`: timeout time, in microseconds (us) ## Constant ### ultrasonic.UNIT_CM The unit of the returned distance, cm ### ultrasonic.UNIT_INCH The unit of the returned distance, feet"},"/soft/maixpy/en/api_reference/extend/index.html":{"title":"Peripheral Module","content":" title: Peripheral Module keywords: maixpy, k210, AIOT, edge computing desc: maixpy peripheral module The peripheral modules here mainly refer to off chip peripherals (as opposed to on chip peripherals, such as GPIO, I2C, etc.), such as LCD, camera, touch screen, etc. The image related information is temporarily placed in the [Machine Vision](../machine_vision/index.html) category, including the following peripheral modules * [lcd](../machine_vision/lcd.html): display image * [sensor](../machine_vision/sensor.html): Get camera data, named `sensor` and it is compatible with `openmv`, of course it is not exactly the same, please read the document Other peripheral modules include: * [touchscreen](./touchscreen.html): touch screen related operations, read the touch screen click status and get the click coordinates, etc. * [ws2812](./ws2812.html): WS2812 single bus light strip * [Thermal infrared temperature sensor](./htpa.html) * [Ultrasonic](./ultrasonic.html)"},"/soft/maixpy/en/api_reference/extend/htpa.html":{"title":"modules.htpa (HTPA thermal infrared temperature measurement module)","content":" title: modules.htpa (HTPA thermal infrared temperature measurement module) keywords: maixpy, k210, AIOT, edge computing desc: maixpy modules.htpa (HTPA thermal infrared temperature measurement module) Hyman HTPA 32x32 thermal infrared temperature measurement module <img src \"../../../assets/hardware/other/htpa32x32.png\"> ## Construction method htpa(i2c, scl_pin, sda_pin, i2c_freq) Create an instance ### Parameters * `i2c`: I2C number, such as `I2C.I2C0`, the value is [0, 2] (see `machine.I2C`) * `scl_pin`: I2C SCL pin * `sda_pin`: I2C SDA pin * `i2c_freq`: I2C clock frequency ### return value htpa object ## Instance method temperature() Get the sensor temperature value, which can only be called by the instance ### return value Array, length is the width x height of the sensor, such as `32x32` ## Instance method width() Get the sensor resolution width, which can only be called by the instance ### return value Integer, width ## Instance method height() Get the sensor resolution width, which can only be called by the instance ## Examples [heimann_HTPA_32x32](https://github.com/sipeed/MaixPy v1_scripts/tree/master/modules/others/heimann_HTPA_32x32)"},"/soft/maixpy/en/api_reference/extend/ws2812.html":{"title":"modules.ws2812 (WS2812 light strip)","content":" title: modules.ws2812 (WS2812 light strip) keywords: maixpy, k210, AIOT, edge computing desc: maixpy modules.ws2812 (WS2812 light strip) This module uses the `I2S` of `K210` to drive the module, so you need to pay attention to whether there is conflict during use Currently supports up to 12 street light strips ## Constructor ```python from modules import ws2812 class ws2812(led_pin 1,led_num 1,i2s_num I2S_DEVICE_2,i2s_chn I2S_CHANNEL_3,i2s_dma_chn DMAC_CHANNEL1) ``` Create a new `ws2812` object by specifying parameters ### Parameters * `led_pin`: The pin connected to the light strip data line, such as `board_info.D[4]` * `led_num`: How many lamp beads are in the strip * `i2s_num`: Which `I2S` device the object uses to drive, the default is `I2S_DEVICE_2`, the value range is `0 2` * `i2s_chn`: Which `I2S` channel the object uses, the default is `I2S_CHANNEL_3`, and the value range is `0 3` * `i2s_dma_chn`: DMA channel used by the object, users generally do not consider ## Method ### set_led Set the color of a certain led light ```python class_ws2812.set_led(num, color) ``` #### Parameters * `num`: the `N` lamp beads, starting from `0` * `color`: the assigned color of the lamp bead, which is of `tuple` type, (R,G,B) #### return value no ### display Start working, call after setting ```python class_ws2812.display() ``` #### Parameters no #### return value no ## Routine 0 All 30 LED lights are red ```python from modules import ws2812 class_ws2812 ws2812(board_info.D[4],30) for i in range(30): class_ws2812.set_led(i,(0xff,0,0)) class_ws2812.display() ``` ## Routine 1 Light with red gradient ```python from modules import ws2812 class_ws2812 ws2812(board_info.D[4],30) r 0 dir True while True: if dir: r + 1 else: r 1 if r> 255: r 255 dir False elif r<0: r 0 dir True for i in range(30): a class_ws2812.set_led(i,(r,0,0)) a class_ws2812.display() ``` > For the above example, see [`MaixPy_scripts`](https://github.com/sipeed/MaixPy v1_scripts/tree/master/modules/grove/ws2812)"},"/soft/maixpy/en/api_reference/extend/touchscreen.html":{"title":"touchscreen (touch screen)","content":" title: touchscreen (touch screen) keywords: maixpy, k210, AIOT, edge computing desc: maixpy touchscreen (touch screen) The `touchscreen` module contains basic reading touch screen operations Currently supported touch screens: * ns2009 (default) If you need to modify the driver model, you need to recompile the `MaixPy` source code to modify the pre compiled supported model ## Global functions ### init(i2c None, cal None) Initialize the touch screen > API may be changed later (mainly for changes to parameters of multiple drivers) #### Parameters * `i2c`: Currently supports the touch screen of `I2C` communication. Pass in the `I2C` instance object, this parameter may be renamed or cancelled later * `cal`: Calibration data, a tuple of `7` integer values, which can be obtained by the `touchscreen.calibrate()` function ### calibrate() Calibrate the screen so that the screen display and touch screen pixels can correspond #### return value Return a tuple of `7` integer values, which can be saved to the file system or `flash` and passed in during initialization, so that there is no need to calibrate every time ### read() Read the current screen state and the coordinate value of the pressed point #### return value A tuple `(status, x, y)` composed of `3` integer values, note that this value will always keep the previous state * `status`: status, the values ​​are `touchscreen.STATUS_PRESS`, `touchscreen.STATUS_MOVE`, `touchscreen.STATUS_RELEASE` * `x`: `x` axis coordinate * `y`: `y` axis coordinate ## Constant ### touchscreen.STATUS_PRESS The screen is pressed, the first value of the tuple returned by the `read()` function ### touchscreen.STATUS_MOVE The screen is pressed and moved, that is, press to move, the first value of the tuple returned by the `read()` function ### touchscreen.STATUS_RELEASE The screen is no longer held down, that is, there is no click, the first value of the tuple returned by the `read()` function ## Routine ## Routine 1: Drawing board Black background and white pen drawing board, use the `boot` button to clear the content > Cancel the comment of `ts.calibrate()` to start the touch screen calibration program > `board_info` is related to the board, and different board configurations are different. [Manual configuration](../builtin_py/board_info.html) is required before use. ```python import touchscreen as ts from machine import I2C import lcd, image from board import board_info from fpioa_manager import * board_info board_info() fm.register(board_info.BOOT_KEY, fm.fpioa.GPIO1) btn_clear GPIO(GPIO.GPIO1, GPIO.IN) lcd.init() i2c I2C(I2C.I2C0, freq 400000, scl 30, sda 31) ts.init(i2c) #ts.calibrate() lcd.clear() img image.Image() status_last ts.STATUS_IDLE x_last 0 y_last 0 draw False while True: (status,x,y) ts.read() print(status, x, y) if draw: img.draw_line((x_last, y_last, x, y)) if status_last! status: if (status ts.STATUS_PRESS or status ts.STATUS_MOVE): draw True else: draw False status_last status lcd.display(img) x_last x y_last y if btn_clear.value() 0: img.clear() ts.__del__() ```"},"/soft/maixpy/en/develop_kit_board/maix_go.html":{"title":"Maix Go","content":" title: Maix Go keywords: maixpy, k210, AIOT, edge computing desc: maixpy Maix Go ## Appearance and function introduction ### Appearance list ![Maix Go](../../assets/hardware/maix_go/Go.png) ### Onboard functions Project Description CPU: Dual core 64bit RISC V / 400MHz* (double precision FPU integration) Memory: 8MiB 64bit on chip SRAM Storage: 16MiB Flash, support micro SDXC expansion storage (max 128GB) Screen: 2.4 inch TFT, capacitive touch screen resolution: 320\\*240 Camera (package): 200W pixels (actual use 30W), 0V2640 model M12 camera TF card slot: Multimedia resource expansion, support large capacity storage ## Download Sipeed Maix Go data download: [Sipeed Maix Go](https://dl.sipeed.com/shareURL/MAIX/HDK/Sipeed Maix GO)"},"/soft/maixpy/en/develop_kit_board/maix_bit.html":{"title":"Maix Bit","content":" title: Maix Bit keywords: maixpy, k210, AIOT, edge computing desc: maixpy Maix Bit ## Appearance and function introduction ### Appearance list ![Maix Bit](../../assets/hardware/maix_bit/maix_bit.png) ### Onboard functions Project Description CPU: Dual core 64bit RISC V / 400MHz (double precision FPU integration) Memory: 8MiB 64bit on chip SRAM Storage: 16MiB Flash, support micro SDXC expansion storage (max 128GB) Screen (package): 2.4 inch TFT, screen resolution: 320\\*240 Camera (package): 200W pixels (actual use 30W), 0V2640 model M12 camera TF card slot: Multimedia resource expansion, support large capacity storage ### Pin Resources ![](./../../assets/hardware/maix_bit/maixbit_pin_maps.svg) ## Download Sipeed Maix Bit data download: [Sipeed Maix Bit](https://dl.sipeed.com/shareURL/MAIX/HDK/Sipeed Maix Bit) Sipeed Maix Bit specification download: [Sipeed Maix Bit](https://dl.sipeed.com/fileList/MAIX/HDK/Sipeed Maix Bit/Specifications/Sipeed_Maix_Bit_Specification_V2.0.pdf) Sipeed Maix Bit schematic download: <a href \"https://dl.sipeed.com/fileList/MAIX/HDK/Sipeed Maix Bit/Maix Bit%20V2.0(with%20MEMS%20microphone)/Maix Bit%20V2.0(Schematic).pdf\">Sipeed Maix Bitf</a>"},"/soft/maixpy/en/develop_kit_board/maix_cube.html":{"title":"MaixCube","content":" title: MaixCube keywords: maixpy, k210, AIOT, edge computing desc: maixpy MaixCube ## Overview SIPEED **MaixCube** can develop programming learning kit, MaixCube integrates 30W camera, expandable TF card slot, user buttons, IPS 1.3 inch display, 200mAh lithium battery, speaker, microphone, SPMOD, GROVE expansion interface, etc. on the hardware. MaixCube is equipped with MaixPy by default on the software. Users can easily use MicroPython syntax to quickly get started with AI IoT development, develop face recognition, object recognition and other AI applications. At the same time, it also reserves development and debugging interfaces, which can also be used as a powerful AI learning development board. ## Appearance and function introduction ### Appearance list ![Maix Cube](../../assets/hardware/maix_cube/maixcube_product_appearance.png) ### Onboard functions Project Description CPU: Dual core 64bit RISC V / 400MHz (double precision FPU integration) Memory: 8MiB 64bit on chip SRAM Storage: 16MiB Flash, support micro SDXC expansion storage (max 128GB) Screen: 1.3 inch **IPS** Screen: Resolution **240*240** Camera: Equipped with **0V7740** **30W** pixels **Sensor** Buttons: Reset button, power button (short press to turn on, long press *8S* to turn off), three way button USB: Type C interface, positive and negative blind plug Audio: Support audio recording, playback, driver IC (ES8374) Onboard sensors: Three axis acceleration sensor (MSA301) Lights: Onboard two RGB LEDs, one flashlight TF card slot: Multimedia resource expansion, support large capacity storage Power management: AXP173 control unit, 200mAh lithium battery, support user charge and discharge control ### Pin Resources ![Maix Cube](../../assets/hardware/maix_cube/maixcube_resources.png) ### Onboard expansion interface Maix Cube opens two highly expanded interfaces to users: one [SP MOD](../modules/sp_mod/index.html) and one [Grove](./../modules/grove/index.html) Interface, users can easily DIY ### Onboard I2C device MaixCube onboard I2C sensor/IC IC Device id I2C address (7 bit address) MaixPy read address Sample code ES8374 0x08 0x10 D(16) [code](https://github.com/sipeed/MaixPy v1_scripts/blob/79a5485ec983e67bb8861305a52418b29e0dc205/modules/others/es8374/es8374.py) MSA301 0x13 0x26 D(38) [code](https://github.com/sipeed/MaixPy v1_scripts/blob/7fea2359a7f0c05f586be915aa8e6112262e0caa/multimedia/gui/maixui/msa301.py) AXP173 0x68 0x34 D(52) [code](https://github.com/sipeed/MaixPy v1_scripts/blob/7fea2359a7f0c05f586be915aa8e6112262e0caa/multimedia/gui/maixui/pmu_axp173.py) ## Get started Because MaixCube comes with its own GUI demo interface and sample programs, you can play with the preset programs first when you get the board. After that, we will start to use MaixCube to get started with AIoT with MaixPy. Before development, we need to understand and prepare related tools to reduce the pitfalls we have to follow because of insufficient preparation. Steps to get started: 1. Download the required drivers and software 2. Connect the development board to the computer and install the USB driver 3. Update the latest firmware 4. Download and open the latest MaixPy IDE 5. Connect MaixPy IDE to the development board Run MaixPy sample program ### Software and hardware preparation Hardware preparation: **Computer** one **MaixCube** Development Board One **reliable** USB Type C data cable: pay attention to a **reliable** data cable Software preparation: USB driver: [Click me](https://dl.sipeed.com/MAIX/tools/driver) Kflash_gui: [https://dl.sipeed.com/MAIX/tools/kflash_gui](https://dl.sipeed.com/MAIX/tools/kflash_gui) MaixPy IDE: [https://dl.sipeed.com/MAIX/MaixPy/ide/_/v0.2.5](https://dl.sipeed.com/MAIX/MaixPy/ide/_/v0.2.5) Routine library: [https://github.com/sipeed/MaixPy v1_scripts](https://github.com/sipeed/MaixPy v1_scripts) ### install driver When we get the Maix Cube and connect to the computer, we can open the device manager to check whether the serial port driver has been installed. The methods to open the device manager are: This computer (right click) > Properties > Device Manager Start menu (right click) > Device Manager Control Panel > (Search) Device Manager <img src \"../../assetcs/../assets/get_started/win_device_1.png\" height \"400\"> 1. When our system is a Win10 system, the system will automatically install the driver for us, and if it is an old version of Win7, win8, we need to install it manually: ![](../../assetcs/../assets/get_started/win_device_2.png) 1. Open the link in the previous section to download the driver ![](../../assetcs/../assets/get_started/win_device_3.png) 1. Click Install ![](../../assets/get_started/drives.gif) 1. After the installation is complete, you can see in the device manager that two serial devices have been identified ![](../../assetcs/../assets/get_started/win_device_4.png) ### Update the firmware to the latest version After the user gets the development board, the on board firmware may not be the latest version by default, so there will be more or less bugs during use. We need to update the firmware version to the latest version at this time View update method: [Update Firmware](../get_started/upgrade_maixpy_firmware.html) ### Run the first program `Hello World` LCD real time preview Camera (when connecting with MaixPy IDE, select Maixduino) ```python import sensor, image, time, lcd sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.skip_frames(time 2000) sensor.set_hmirror(1) sensor.set_vflip(1) clock time.clock() lcd.init(type 2) lcd.rotation(2) while(True): clock.tick() img sensor.snapshot() print(clock.fps()) img.draw_string(60, lcd.height() 120, \"fps:\"+str(clock.fps()), lcd.GREEN, scale 2) lcd.display(img) ``` ## Download Sipeed Maix Cube data download: [Sipeed Maix Cube](https://dl.sipeed.com/shareURL/MAIX/HDK/Sipeed Maix Cube) Sipeed Maix Cube specification download: [Sipeed Maix Cube](https://dl.sipeed.com/fileList/MAIX/HDK/Sipeed Maix Cube/ProductSpecification/Sipeed%20Maix%20Cube%20Datasheet%20V1 .0.pdf) Sipeed Maix Cube schematic download: [Sipeed Maix Cube][Sipeed Maix Cube] [Sipeed Maix Cube]: https://dl.sipeed.com/fileList/MAIX/HDK/Sipeed Maix Cube/Maix Cube 2757/Maix Cube 2757(Schematic).pdf"},"/soft/maixpy/en/develop_kit_board/grove_ai_hat.html":{"title":"Grove AI HAT","content":" title: Grove AI HAT keywords: maixpy, k210, AIOT, edge computing desc: maixpy Grove AI HAT ## Appearance and function introduction ### Appearance at a glance ![Grove AI HAT](../../assets/hardware/grove_ai_hat/grove_ai_hat1.png) ### Onboard functions Project Description CPU: Dual core 64bit RISC V / 400MHz (double precision FPU integration) Memory: 8MiB 64bit on chip SRAM Storage: 16MiB Flash Screen (package): 2.4 inch TFT, capacitive touch screen resolution: 320\\*240 Camera (package): Equipped with **0V7740** **30W** pixels **Sensor** Buttons: Reset button, power button (short press to turn on, long press *8S* to turn off) USB: Type C interface, positive and negative blind plugging Onboard sensors: Three axis acceleration sensor (ADXL345BCCZ RL), ADC (ADS1115IDGS) ### Hardware onboard expansion interface The development version opens four [Grove](https://cn.maixpy.sipeed.com/eh/modules/grove/) interfaces to users, and users can easily DIY. ### Onboard I2C device Sensor Function I2C address (7 bit address) SCL SDA Sample code ADS1115 ADC 0x48 IO23 IO24 [script](./ads1115.py) ADXL345 Three axis accelerometer 0x53 IO23 IO24 [script](./adxl345.py) ## Download [Schematic](./Grove_AI_HAT_for_Edge_Computing_v1.0_SCH_190514.pdf)"},"/soft/maixpy/en/develop_kit_board/core_k210.html":{"title":"K210 module core board","content":" title: K210 module core board keywords: maixpy, k210, AIOT, edge computing desc: maixpy K210 module core board ![K210](./../../assets/hardware/k210/k210 front background.jpg) Kendryte K210 is a system on chip (SoC) that integrates machine vision and machine hearing capabilities. It uses TSMC's ultra low power 28 nanometer advanced manufacturing process, with dual core 64 bit processors, and has good power consumption performance and stability And reliability. The program strives for zero threshold development, which can be deployed in the user's products in the shortest time, giving the product artificial intelligence. Kendryte K210 is located in the SoC of the AI ​​and IoT market, and it is also a very convenient MCU. The Chinese meaning of Kendryte is **Kanzhi(堪智)**, and Kanzhi is derived from Geophysical Prospecting. The main application field of this chip is the Internet of Things field, and it is developed in the field of Internet of Things, so it is Prospecting; this chip mainly provides Artificial intelligence solutions are explored in the field of artificial intelligence, so they are intellectual exploration. Have machine vision capabilities With machine hearing ability Better low power vision processing speed and accuracy Equipped with a convolutional artificial neural network hardware accelerator KPU, which can perform convolutional artificial neural network operations with high performance TSMC 28nm advanced manufacturing process, temperature range 40°C to 125°C, stable and reliable Support firmware encryption, which is difficult to crack with ordinary methods Unique programmable IO array makes product design more flexible Low voltage, lower power consumption compared with systems with the same processing capacity 3.3V/1.8V dual voltage support, no level conversion required, cost saving 1. AI solutions ## 1.1. Machine Vision Kendryte K210 has machine vision capabilities and is a zero threshold machine vision embedded solution. It can perform convolutional neural network calculations with low power consumption. The chip can achieve the following machine vision capabilities: General target detection based on convolutional neural network Image classification task based on convolutional neural network Face detection and face recognition Get the size and coordinates of the detected target in real time Real time acquisition of the types of detected targets 1.2. Machine hearing Kendryte K210 has machine hearing capabilities. The chip comes with a high performance microphone array audio processor, which can perform real time sound source orientation and beamforming. The chip can achieve the following machine hearing capabilities: Sound source orientation Sound field imaging Beamforming Wake up Speech Recognition 1.3. Hybrid vision/auditory solutions Kendryte K210 can combine machine vision and machine hearing capabilities to provide more powerful functions. On the one hand, in the application, it can not only assist machine vision to track the target through sound source localization and sound field imaging, but also obtain the target position through general target detection. After assisting the machine hearing to perform beamforming on the position. On the other hand, the direction of the person can be obtained through the image from the camera, so that the microphone array can be directed to the person through beamforming. At the same time, the direction of a speaker can also be determined according to the microphone array , Turn the camera to point at the person. 2. Download Kendryte official website download page One of the must see datasheets Kendryte Github"},"/soft/maixpy/en/develop_kit_board/maix_duino.html":{"title":"MaixDuino","content":" title: MaixDuino keywords: maixpy, k210, AIOT, edge computing desc: maixpy MaixDuino ## Overview SIPEED MaixDuino is a development board compatible with Arduino based on our M1 module (main control: Kendryte K210) <br/>MaixDuino integrates camera, TF card slot, user buttons, TFT display, MaixDuino expansion interface, etc., users can use MaixDuino to easily build a face recognition access control system, and also reserve development and debugging interfaces, which can also be used As a powerful AI learning development board. ## Appearance and function introduction ### Appearance list ![MaixDuino](../../assets/hardware/maix_duino/maixduino_4.png) ### Onboard functions Project Description CPU: Dual core 64bit RISC V / 400MHz* (double precision FPU integration) Memory: 8MiB 64bit on chip SRAM Storage: 16MiB Flash, support micro SDXC expansion storage (max 128GB) Screen (package): 2.4 inch TFT, screen resolution: 320\\*240 Camera (package): 30W pixel GC0328 camera DVP: Standard Camera DVP 24PIN interface Power + USB: USB Type C interface ESP32: ESP32 SPI connection (ESP32 supports WIFI and Bluetooth), PAM8403A DAC: I2C DAC TF card slot: Multimedia resource expansion, support large capacity storage ### Pin Resources ![MaixDuino](../../assets/hardware/maix_duino/sipeed_maixduin_pins.png) ## Download Sipeed Maix Duino data download: [Sipeed Maix Duino](https://dl.sipeed.com/shareURL/MAIX/HDK/Sipeed Maixduino/) Sipeed Maix Duino specification download: [Sipeed Maix Duino](https://dl.sipeed.com/shareURL/MAIX/HDK/Sipeed Maixduino/Specifications) Sipeed Maix Duino schematic download: <a href \"https://dl.sipeed.com/fileList/MAIX/HDK/Sipeed Maixduino/Maixduino_2832/Maixduino_2832(Schematic).pdf\">Sipeed Maix Duino</a>"},"/soft/maixpy/en/develop_kit_board/get_hardware.md.deal.html":{"title":"How to choose a development board","content":" title: How to choose a development board keywords: maixpy, k210, AIOT, edge computing desc: maixpy How to choose a development board To start using MaixPy, you must need a K210 development board, you can get your favorite hardware from Sipeed's official Taobao store: [Sipeed Official Taobao Store](https://sipeed.taobao.com/) ## Required hardware ### A development board Since MaixPy has many early product lines, the specific development board and parameter list are as follows, users can choose the corresponding development board according to their own practical ability and needs > The onboard ROM of MaixPy series development board is 16MB SPI FLASH, RAM: 6MB (general purpose) + 2MB (KPU dedicated) <table border \"2\"> <tr> <th colspan 3>MaixPy series development board</th> </tr> <tr> <td>Description</td> <td>Physical image</td> <td>Description</td> </tr> <td>Maix Amigo</td> <td> <img src \"../../assets/hardware/maix_amigo/sipeed_maix_amigo_400x400.jpg\" height \"200\"> </p><a href \"https://sipeed.taobao.com/\">Click to buy Maix Amigo</a> </td> <td>3.5 inch large screen, reserved three Grove ports, three SPMOD ports (one of which is a gamepad port)</td> <tr> <td>Maix Cube</td> <td> <img src \"../../assets/hardware/maix_cube/sipeed_maix_cube_400x400.jpg\" height \"200\"> </p><a href \"https://sipeed.taobao.com/\">Click to buy Maix Cube</a> </td> <td>Mini development board, leads to Grove/Spmod interface</td> </tr> <tr> <td>Maix Dock(M1W)</td> <td> <img src \"../../assets/hardware/maix_dock/sipeed_maix_dock_m1w.jpg\" height \"200\"> </p><a href \"https://sipeed.taobao.com/\">Click to buy Maix Dock(M1W)</a> </td> <td>All pins are led out, using M1W module (integrated ESP8285)</td> </tr> <tr> <td>Maix Dock(M1)</td> <td> <img src \"../../assets/hardware/maix_dock/sipeed_maix_dock_m1.jpg\" height \"200\"> </p><a href \"https://sipeed.taobao.com/\">Click to buy Maix Dock(M1)</a> </td> <td>All pins lead out, using M1 module </td> </tr> <tr> <td>Maix Bit</td> <td> <img src \"../../assets/hardware/maix_bit/sipeed_maix_bit_400x400.jpg\" height \"200\"> </p><a href \"https://sipeed.taobao.com/\">Click to buy Maix Bit</a> </td> <td>All pins lead out, 2x20pin, the smallest system board</td> </tr> <tr> <td>Maix Duino</td> <td> <img src \"../../assets/hardware/maix_duino/sipeed_maix_duino_400x400.jpg\" height \"200\"> </p><a href \"https://sipeed.taobao.com/\">Click to buy Maix Duino</a> </td> <td>Compatible with Arduino, supports ESP32 WIFI, supports reading of 5 ADC channels of ESP32</td> </tr> <tr> <td>Maix GO</td> <td> <img src \"../../assets/hardware/maix_go/sipeed_maix_go_400x400.jpg\" height \"200\"> </p><a href \"https://sipeed.taobao.com/\">Click to buy Maix GO</a> </td> <td>Discontinued</td> </tr> <tr> <td>Maix Nano</td> <td> <img src \"../../assets/hardware/m1n/sipeed_maix_m1n_400x400.jpg\" height \"200\"></br> <img src \"../../assets/hardware/m1n/sipeed_maix_nano_400x400.jpg\" height \"200\"> </p><a href \"https://sipeed.taobao.com/\">Click to buy Maix Nano</a> </td> <td>Core development board</td> </tr> </table> ### USB Type C cable <img src \"../../assets/hardware/other/usb_type_c.png\" height \"300\" alt \"type_c\"> Type C was chosen because it supports positive and negative insertion, which is very friendly to development You can ask if it is included in the official purchase from Taobao. At present, most Android phones are also using Type C cables > **USB data cable note: ** Due to the uneven quality of USB cables on the market, the wires used (mainly the core material) are different, and the better data cable uses tinned copper, copper wire, copper foil wire, and bare wire. Copper, etc., the line resistance is small, the voltage drop at both ends of the data line is small, and copper clad steel, copper clad iron, the line resistance is large, the voltage drop at both ends of the data line is large, causing the actual voltage and current supplied to the development board Small, make the development board in an abnormal working state; therefore, it is recommended to use a reliable data cable (generally the quality of the data cable attached to the mobile phone is relatively reliable) ### Screen **The screen is strongly recommended to buy!** From Taobao official purchase, you can ask whether it is included. It is recommended that users buy a board or package with LCD to facilitate the visual display of the results when running the program later. Board type Screen driver IC Support resolution Whether to support touch Remarks Maix Cube(IPS) ST7789 240\\*240 Not supported Maix Amigo ILI9486 320\\*480 Support (FT6X36) Maix Amigo (IPS version) ILI9486 320\\*480 Support (FT6X36) Maix Nano (without screen) Maix Dock ST7789 320\\*240 Not Supported Maix Bit ST7789 320\\*240 Not Supported Maix Dock ST7789 320\\*240 Not Supported Maix Go ST7789 320\\*240 Support (FT6X36) ### camera On sale are: OV2640 (conventional, M12), OV7740, GC0328; Since the resolution supported by the K210 DVP interface is VGA (640*480 30W), you can actually use a camera with 30W pixels. As of MaixPy firmware version: `MaixPy 0.5.0_160`, the supported camera models are as follows Model Device id Pixel Description Remarks OV2640 0x2642 200W Better support OV7740 0x7742 30W Better support OV3660 0x3660 300W Compatible operation GC0328 0x9d 30W Better support GC2145 0x2145 200W Compatible operation MT9D111 0x1519 200W Can run, support is incomplete OV5640 0x5640 500W Better support As of the firmware version `MicroPython v0.5.0 173`, the related camera test conditions are as follows: Hardware model Monocular or binocular camera that passed the test M1/M1W Module Series (Maixduino, Dock, Go) OV2640, GC0328, OV7740, GC2145, OV5640 M1n Module Series (Nano, Cube) OV2640, GC0328, OV7740, GC2145, OV5640 MaixBit OV2640, GC0328, OV7740, GC2145, OV5640 Maix Amigo OV7740 (rear shot), GC0328 (front shot) The color mode of the current camera YUV422 RGB565 & YUV422 OV2640 OV5640 OV7740 GC2145 GC0328 You can ask for the model from Taobao official purchase, OV7740 frame rate is relatively high; OV2640 is relatively old, and the picture quality is slightly inferior to GC0328 > Note: Many users ask which one supports the highest frame rate when they come up. In fact, the frame rate will be different in addition to the hardware, and in the program you use, the frame rate will also be different due to the different processing procedures of the program, so The specific maximum frame rate cannot be marked here (so as not to mislead users). ### Micro SD card (TF card) (optional) Files can be manipulated without using a Micro SD card. A part of the internal Flash has been reserved as a file system, but the Flash speed is very slow! In order to facilitate the quick operation of picture files, you can choose to buy a `Micro SD` card, 　 MaixPy 　 built in SPI SD card protocol driver, When buying, try to choose a new Micro SD card with fast speed protocol, such as SD 2nd generation protocol, Class10 memory card Because the K210 does not have SDIO hardware peripherals, it uses SPI to communicate with the SD card. Of course, the quality of SD cards on the market is uneven, and the SPI mode may not be compatible. Try to buy a regular card. If you really need it, please customize it yourself. Drive~~ For example: the two cards on the left side of the picture below are not supported by MaixPy drivers, the middle and right ones are supported, but the class10 card in the middle has the fastest speed (up to 128GB tested available) > I have also tested several SanDisk, Kingston, and Samsung cards purchased online, and found that one of the Samsung cards cannot be used ![TF SDCard](../../assets/hardware/other/tf_sdcard.png) [**Sipeed official store SD card purchase link**](https://item.taobao.com/item.htm?spm a1z10.5 c.w4002 21231188711.12.5a7f7379ZEhEdC&id 587713418483), the card’s SPI protocol only It supports the V1 version, so the reading rate is low. It is recommended to buy other SD cards that support the SPI V2 protocol. The SD card can be selected in the Taobao store development board package. ### ST Link (used to update the firmware of STM32 on the development board Maix Go) (optional) If you buy a `Maix Go`, a `STM32` chip is integrated on it to simulate the `USB to serial port` tool and to simulate `JTAG`, if you want to update its firmware later, it is recommended to buy a `ST Link `Spare; if you don't need `JTAG` function, you don't need to buy it ### JTAG debugger (optional) **Note:** **!!! After burning key_gen.bin, the JTAG debugging function of K210 will be permanently disabled** `K210` This chip supports `JTAG` debugging. If you need the debugging function, you need to use the `JTAG` debugger. Please consult and purchase at the official Taobao store of `Sipeed`. If it is a `Maix Go` development board, you do not need to purchase a separate `JTAG` debugger. The `Maix Go` development board integrates a `STM32` chip, which can simulate `JTAG` (`STM32` uses `CMSIS DAP` or `open ec` firmware), `open ec` firmware is not currently supported, and will be supported in the future, please refer to the description of the `open ec` github project homepage"},"/soft/maixpy/en/develop_kit_board/get_hardware.html":{"title":"How to choose a development board","content":" title: How to choose a development board keywords: maixpy, k210, AIOT, edge computing desc: maixpy How to choose a development board To start using MaixPy, you must need a K210 development board, you can get your favorite hardware from Sipeed's official Taobao store: [Sipeed Official Taobao Store](https://sipeed.taobao.com/) ## Required hardware ### A development board Since MaixPy has many early product lines, the specific development board and parameter list are as follows, users can choose the corresponding development board according to their own practical ability and needs > The onboard ROM of MaixPy series development board is 16MB SPI FLASH, RAM: 6MB (general purpose) + 2MB (KPU dedicated) <table border \"2\"> <tr> <th colspan 3>MaixPy series development board</th> </tr> <tr> <td>Description</td> <td>Physical image</td> <td>Description</td> </tr> <td>Maix Amigo</td> <td> <img src \"../../assets/hardware/maix_amigo/sipeed_maix_amigo_400x400.jpg\" height \"200\"> </p><a href \"https://sipeed.taobao.com/\">Click to buy Maix Amigo</a> </td> <td>3.5 inch large screen, reserved three Grove ports, three SPMOD ports (one of which is a gamepad port)</td> <tr> <td>Maix Cube</td> <td> <img src \"../../assets/hardware/maix_cube/sipeed_maix_cube_400x400.jpg\" height \"200\"> </p><a href \"https://sipeed.taobao.com/\">Click to buy Maix Cube</a> </td> <td>Mini development board, leads to Grove/Spmod interface</td> </tr> <tr> <td>Maix Dock(M1W)</td> <td> <img src \"../../assets/hardware/maix_dock/sipeed_maix_dock_m1w.jpg\" height \"200\"> </p><a href \"https://sipeed.taobao.com/\">Click to buy Maix Dock(M1W)</a> </td> <td>All pins are led out, using M1W module (integrated ESP8285)</td> </tr> <tr> <td>Maix Dock(M1)</td> <td> <img src \"../../assets/hardware/maix_dock/sipeed_maix_dock_m1.jpg\" height \"200\"> </p><a href \"https://sipeed.taobao.com/\">Click to buy Maix Dock(M1)</a> </td> <td>All pins lead out, using M1 module </td> </tr> <tr> <td>Maix Bit</td> <td> <img src \"../../assets/hardware/maix_bit/sipeed_maix_bit_400x400.jpg\" height \"200\"> </p><a href \"https://sipeed.taobao.com/\">Click to buy Maix Bit</a> </td> <td>All pins lead out, 2x20pin, the smallest system board</td> </tr> <tr> <td>Maix Duino</td> <td> <img src \"../../assets/hardware/maix_duino/sipeed_maix_duino_400x400.jpg\" height \"200\"> </p><a href \"https://sipeed.taobao.com/\">Click to buy Maix Duino</a> </td> <td>Compatible with Arduino, supports ESP32 WIFI, supports reading of 5 ADC channels of ESP32</td> </tr> <tr> <td>Grove AI HAT</td> <td> <img src \"../../assets/hardware/grove_ai_hat/grove_ai_hat.jpg\" height \"200\"></br> </p><a href \"https://sipeed.taobao.com/\">Click to buy Grove AI HAT</a> </td> <td>Onboard accelerometer and high precision ADC, lead to multiple Grove/Spmod interfaces, which can be used as Raspberry Pi accessories</td> </tr> <tr> <td>Maix GO</td> <td> <img src \"../../assets/hardware/maix_go/sipeed_maix_go_400x400.jpg\" height \"200\"> </p><a href \"https://sipeed.taobao.com/\">Click to buy Maix GO</a> </td> <td>Discontinued</td> </tr> <tr> <td>Maix Nano</td> <td> <img src \"../../assets/hardware/m1n/sipeed_maix_m1n_400x400.jpg\" height \"200\"></br> <img src \"../../assets/hardware/m1n/sipeed_maix_nano_400x400.jpg\" height \"200\"> </p><a href \"https://sipeed.taobao.com/\">Click to buy Maix Nano</a> </td> <td>Core development board</td> </tr> </table> ### USB Type C cable <img src \"../../assets/hardware/other/usb_type_c.png\" height \"300\" alt \"type_c\"> Type C was chosen because it supports positive and negative insertion, which is very friendly to development You can ask if it is included in the official purchase from Taobao. At present, most Android phones are also using Type C cables > **USB data cable note: ** Due to the uneven quality of USB cables on the market, the wires used (mainly the core material) are different, and the better data cable uses tinned copper, copper wire, copper foil wire, and bare wire. Copper, etc., the line resistance is small, the voltage drop at both ends of the data line is small, and copper clad steel, copper clad iron, the line resistance is large, the voltage drop at both ends of the data line is large, causing the actual voltage and current supplied to the development board Small, make the development board in an abnormal working state; therefore, it is recommended to use a reliable data cable (generally the quality of the data cable attached to the mobile phone is relatively reliable) ### Screen **The screen is strongly recommended to buy!** From Taobao official purchase, you can ask whether it is included. It is recommended that users buy a board or package with LCD to facilitate the visual display of the results when running the program later. 板型 屏幕驱动 IC 支持分辨率 备注 Maix Cube(IPS) ST7789 240\\*240 Maix Amigo ILI9486 320\\*480 Maix Amigo(IPS version) ILI9486 320\\*480 Maix Nano(without screen) Maix Dock ST7789 320\\*240 Maix Bit ST7789 320\\*240 Maix Dock ST7789 320\\*240 Maix Go ST7789 320\\*240 Grove AI HAT ST7789 320\\*240 ### camera On sale are: OV2640 (conventional, M12), OV7740, GC0328; Since the resolution supported by the K210 DVP interface is VGA (640*480 30W), you can actually use a camera with 30W pixels. As of MaixPy firmware version: `MaixPy 0.5.0_160`, the supported camera models are as follows Model Device id Pixel Description Remarks OV2640 0x2642 200W Better support OV7740 0x7742 30W Better support OV3660 0x3660 300W Compatible operation GC0328 0x9d 30W Better support GC2145 0x2145 200W Compatible operation MT9D111 0x1519 200W Can run, support is incomplete OV5640 0x5640 500W Better support As of the firmware version `MicroPython v0.5.0 173`, the related camera test conditions are as follows: Hardware model Monocular or binocular camera that passed the test M1/M1W Module Series (Maixduino, Dock, Go) OV2640, GC0328, OV7740, GC2145, OV5640 M1n Module Series (Nano, Cube) OV2640, GC0328, OV7740, GC2145, OV5640 MaixBit OV2640, GC0328, OV7740, GC2145, OV5640 Maix Amigo OV7740 (rear shot), GC0328 (front shot) The color mode of the current camera YUV422 RGB565 & YUV422 OV2640 OV5640 OV7740 GC2145 GC0328 OV5642 You can ask for the model from Taobao official purchase, OV7740 frame rate is relatively high; OV2640 is relatively old, and the picture quality is slightly inferior to GC0328 > Note: Many users ask which one supports the highest frame rate when they come up. In fact, the frame rate will be different in addition to the hardware, and in the program you use, the frame rate will also be different due to the different processing procedures of the program, so The specific maximum frame rate cannot be marked here (so as not to mislead users). ### Micro SD card (TF card) (optional) Files can be manipulated without using a Micro SD card. A part of the internal Flash has been reserved as a file system, but the Flash speed is very slow! In order to facilitate the quick operation of picture files, you can choose to buy a `Micro SD` card, 　 MaixPy 　 built in SPI SD card protocol driver, When buying, try to choose a new Micro SD card with fast speed protocol, such as SD 2nd generation protocol, Class10 memory card Because the K210 does not have SDIO hardware peripherals, it uses SPI to communicate with the SD card. Of course, the quality of SD cards on the market is uneven, and the SPI mode may not be compatible. Try to buy a regular card. If you really need it, please customize it yourself. Drive~~ For example: the two cards on the left side of the picture below are not supported by MaixPy drivers, the middle and right ones are supported, but the class10 card in the middle has the fastest speed (up to 128GB tested available) > I have also tested several SanDisk, Kingston, and Samsung cards purchased online, and found that one of the Samsung cards cannot be used ![TF SDCard](../../assets/hardware/other/tf_sdcard.png) [**Sipeed official store SD card purchase link**](https://item.taobao.com/item.htm?spm a1z10.5 c.w4002 21231188711.12.5a7f7379ZEhEdC&id 587713418483), the card’s SPI protocol only It supports the V1 version, so the reading rate is low. It is recommended to buy other SD cards that support the SPI V2 protocol. The SD card can be selected in the Taobao store development board package. ### ST Link (used to update the firmware of STM32 on the development board Maix Go) (optional) If you buy a `Maix Go`, a `STM32` chip is integrated on it to simulate the `USB to serial port` tool and to simulate `JTAG`, if you want to update its firmware later, it is recommended to buy a `ST Link `Spare; if you don't need `JTAG` function, you don't need to buy it ### JTAG debugger (optional) **Note:** **!!! After burning key_gen.bin, the JTAG debugging function of K210 will be permanently disabled** `K210` This chip supports `JTAG` debugging. If you need the debugging function, you need to use the `JTAG` debugger. Please consult and purchase at the official Taobao store of `Sipeed`. If it is a `Maix Go` development board, you do not need to purchase a separate `JTAG` debugger. The `Maix Go` development board integrates a `STM32` chip, which can simulate `JTAG` (`STM32` uses `CMSIS DAP` or `open ec` firmware), `open ec` firmware is not currently supported, and will be supported in the future, please refer to the description of the `open ec` github project homepage"},"/soft/maixpy/en/develop_kit_board/maix_nano.html":{"title":"Maix Nano","content":" title: Maix Nano keywords: maixpy, k210, AIOT, edge computing desc: maixpy Maix Nano ## Appearance and function introduction ### Appearance list ![Maix Nano](../../assets/hardware/m1n/sipeed_maix_nano.png) ### Onboard functions Project Description CPU: Dual core 64bit RISC V / 400MHz* (double precision FPU integration) Memory: 8MiB 64bit on chip SRAM Storage: 16MiB Flash, support micro SDXC expansion storage (max 128GB) Screen: No screen Camera (package): 30W pixel GC0328 camera ### Hardware onboard expansion interface Maix Nano reserves a [SP_MOD](../modules/sp_mod/index.html) interface ## Download * M1n data download: [dl.sipeed.com](https://dl.sipeed.com/shareURL/MAIX/HDK/Sipeed M1n) * M1n schematic download: [Sipeed M1n Datasheet V1.0.pdf](https://dl.sipeed.com/fileList/MAIX/HDK/Sipeed M1n/Sipeed%20M1n%20Datasheet%20V1.0.pdf)"},"/soft/maixpy/en/develop_kit_board/maix_amigo.html":{"title":"MaixAmigo","content":" title: MaixAmigo keywords: maixpy, k210, AIOT, edge computing desc: maixpy MaixAmigo ## Overview SIPEED **MaixAmigo** can develop a programming learning kit, MaixAmigo integrates 30W pixel camera, expandable TF card slot, user button, 3.5'TFT display, 520mAh lithium battery, speaker, microphone, SPMOD, GROVE on the hardware Expansion interface, etc. MaixAmigo is equipped with MaixPy by default on the software. Users can easily use MicroPython syntax to quickly develop various AIoT developments such as face recognition and object classification. At the same time, it also reserves development and debugging interfaces, which can also be used as a powerful AI learning and development board. ## Appearance and function introduction ### Appearance list ![MaixAmigo](../../assets/hardware/maix_amigo/maix_amigo_0.png) ### Onboard functions Project Description CPU: Dual core 64bit RISC V / 400MHz* (double precision FPU integration) Memory: 8MiB 64bit on chip SRAM Storage: 16MiB Flash, support micro SDXC expansion storage (max 128GB) Screen: 3.5 inch TFT display, resolution: 320\\*480, support capacitive touch (FT6X36) Camera: OV7740 (rear camera) and GC0328 (front camera) 30W pixels each (maximum resolution VGA:640\\*480) Battery: Onboard rechargeable lithium polymer battery (capacity 520mAh) Onboard speaker and microphone Integrated single audio controller ES8374 1W 8Ω speaker Onboard interface: USB C \\*2 (K210 debug power supply interface + compatible STM32 core board USB interface) Onboard sensors: MSA301 three axis acceleration sensor Lights: Three monochromatic LED lights, one flashlight TF card slot: Multimedia resource expansion, support large capacity storage Battery: 520mAh Lithium Battery ### Pin Resources ![MaixAmigo](../../assets/hardware/maix_amigo/sipeed_maix_amigo_vi.jpg) ### Hardware onboard expansion interface MaixAmigo has opened two highly extended interfaces to users: three [SP MOD](./../modules/sp_mod/index.html) and three [Grove](./../modules/grove/index.html) .md) interface, users can easily do DIY. ### Onboard I2C device MaixAmigo onboard I2C sensor/IC IC Device id I2C address (7 bit address) MaixPy read address Sample code ES8374（Audio codec） 0x08 0x10 D(16) [code](https://github.com/sipeed/MaixPy v1_scripts/blob/79a5485ec983e67bb8861305a52418b29e0dc205/modules/others/es8374/es8374.py) MSA301 (Triple Axis Accelerometer) 0x13 0x26 D(38) [code](https://github.com/sipeed/MaixPy v1_scripts/blob/7fea2359a7f0c05f586be915aa8e6112262e0caa/multimedia/gui/maixui/msa301.py) AXP173 (Power management IC) 0x68 0x34 D(52) [code](https://github.com/sipeed/MaixPy v1_scripts/blob/7fea2359a7f0c05f586be915aa8e6112262e0caa/multimedia/gui/maixui/pmu_axp173.py) ## Get started MaixAmigo also uses MaixPy to get started with AIoT. Due to the particularity of the hardware, please use MaixPy after [Configure amigo hardware](https://github.com/sipeed/MaixPy v1_scripts/blob/master/board/config_maix_amigo.py)(If not configured, the photos taken by the camera will be noisy) . Before development, we need to understand and prepare related tools to reduce the pitfalls we have to follow because of insufficient preparation. Steps to get started: 1. Download the required drivers and software 2. Connect the development board to the computer and install the USB driver 3. Update the latest firmware 4. Download and open the latest MaixPy IDE 5. Connect MaixPy IDE to the development board Run MaixPy sample program ### Software and hardware preparation Hardware preparation: **Computer** one **MaixAmigo** Development Board One **reliable** USB Type C data cable: pay attention to a **reliable** data cable Software preparation: USB driver: [Click me](https://dl.sipeed.com/MAIX/tools/driver) Kflash_gui: [https://dl.sipeed.com/MAIX/tools/kflash_gui](https://dl.sipeed.com/MAIX/tools/kflash_gui) MaixPy IDE: [https://dl.sipeed.com/MAIX/MaixPy/ide/_/v0.2.5](https://dl.sipeed.com/MAIX/MaixPy/ide/_/v0.2.5) Routine library: [https://github.com/sipeed/MaixPy v1_scripts](https://github.com/sipeed/MaixPy v1_scripts) ### install driver When we get Maix Amigo and connect to the computer, we can open the device manager to check whether the serial port driver has been installed. The methods to open the device manager are: This computer (right click) > Properties > Device Manager Start menu (right click) > Device Manager Control Panel > (Search) Device Manager <img src \"../../assets/get_started/win_device_1.png\" height \"400\"> 1. When our system is a Win10 system, the system will automatically install the driver for us, and if it is an old version of Win7, win8, we need to install it manually: ![](../../assets/get_started/win_device_2.png) 1. Open the link in the previous section to download the driver ![](../../assets/get_started/win_device_3.png) 1. Click Install ![](../../assets/get_started/drives.gif) 1. After the installation is complete, you can see in the device manager that two serial devices have been identified ![](../../assets/get_started/win_device_4.png) ### Update the firmware to the latest version After the user gets the development board, the on board firmware may not be the latest version by default, so there will be more or less bugs during use. We need to update the firmware version to the latest version at this time View update method: [Update Firmware](../get_started/upgrade_maixpy_firmware.html) **If you use the amigo development board, please burn the dedicated amigo firmware greater than or equal to v0.6.2_12 (for example: maixpy_v0.6.2_12_gf18990aa3_amigo_tft(ips)_xxxx.bin). The difference from the standard maixpy ​​firmware is that it has built in amigo Hardware configuration (config.json), and the screen types are divided into ips and tft. Burning any screen type firmware can be started, but the display of different screens will be abnormal (the normal red maixpy ​​welcome page), so According to the actual situation, it can be burned and confirmed again. ** ### Run the first program `Hello World` LCD real time preview Camera (when connecting with MaixPy IDE, select Maixduino) ```python # * coding: UTF 8 * import sensor, image, time, lcd from fpioa_manager import fm # lcd.init(freq 20000000) while True: try: sensor.reset(choice 1) sensor.set_pixformat(sensor.YUV422) sensor.set_framesize(sensor.QVGA) sensor.skip_frames(time 2000) for i in range(100): img sensor.snapshot() lcd.display(img) except Exception as e: print(e) try: sensor.reset(choice 2) sensor.set_pixformat(sensor.YUV422) sensor.set_framesize(sensor.QVGA) sensor.skip_frames(time 2000) for i in range(100): img sensor.snapshot().rotation_corr(z_rotation +90) lcd.display(img) except Exception as e: print(e) ``` ## Download Maix Amigo data download: [Sipeed Amigo](https://dl.sipeed.com/shareURL/MAIX/HDK/Sipeed Amigo) Maix Amigo specification download: [Sipeed Amigo](https://dl.sipeed.com/shareURL/MAIX/HDK/Sipeed Amigo/ProductSpecification) Maix Amigo IPS version Schematic download: <a href \"https://dl.sipeed.com/fileList/MAIX/HDK/Sipeed Amigo/2970/Maix_Amigo_2970(Schematic).pdf\">Maix_Amigo_2970(Schematic).pdf</a> Maix Amigo TFT version Schematic download: <a href \"https://dl.sipeed.com/fileList/MAIX/HDK/Sipeed Amigo/2960/Maix_Amigo_2960(Schematic).pdf\">Maix_Amigo_2960(Schematic).pdf</a>"},"/soft/maixpy/en/develop_kit_board/develop_kit_board.html":{"title":"MaixPy series development board","content":" title: MaixPy series development board keywords: maixpy, k210, AIOT, edge computing desc: maixpy MaixPy series development board ## MaixPy Development Board At present, MaixPy series development boards have the following models: Maix Go Maix Dock Maix Duino Maix Bit Maix Cube Maix Amigo ## Difference comparison Model USB IC Core Module Remarks Maix Go <img src \"../../assets/dk_board/maix_go/Go.jpg\" width \"260\"> Maix Go STM32 M1W Maix Dock <img src \"../../assets/dk_board/maix_dock/Dan_Dock.png\" width \"260\"> CH340 M1/M1W Maix Duino <img src \"../../assets/dk_board/maix_duino/maixduino_0.png\" width \"260\"> CH552 M1 Maix Bit <img src \"../../assets/dk_board/maix_bit/BiT.png\" width \"260\"> CH552/CH340 Maix Cube <img src \"../../assets/dk_board/maix_cube/maixcube_2020 06 13_06 31 29.png\" width \"260\"> GD32/CH552 M1n Maix Amigo <img src \"\" width \"260\"> GD32 M1n "},"/soft/maixpy/en/develop_kit_board/core_module.html":{"title":"Sipeed M1/M1W (Lichee Dan)","content":" title: Sipeed M1/M1W (Lichee Dan) keywords: maixpy, k210, AIOT, edge computing desc: maixpy Sipeed M1/M1W (Lichee Dan) 1. M1/M1W ![M1/M1W](./../../assets/hardware/m1_m1w/M1_Dan.png) ![M1/M1W](./../../assets/hardware/m1_m1w/M1_pin.png) M1: K210 all pin leads, built in 8M SRAM in chip, built in 16M Flash in module M1W is the version with WiFi (esp8285) Module WIFI FLASH SRAM Description M1 None 16MiB 8MiB M1W ES8285 16MiB 8MiB M1n None 16MiB 8MiB 1. M1n ![M1n](./../../assets/hardware/m1n/M1n.png) The M1n core module adopts the M.2 golden finger interface and has a 24Pin FPC base onboard. Compared with M1/M1W, users can quickly integrate K210 into their own creative or commercial products. 1. Download Chip K210 Datasheet: Kendryte official website M1n data download: [dl.sipeed.com](https://dl.sipeed.com/shareURL/MAIX/HDK/Sipeed M1n) M1n schematic download: [Sipeed M1n Datasheet V1.0.pdf](https://dl.sipeed.com/fileList/MAIX/HDK/Sipeed M1n/Sipeed%20M1n%20Datasheet%20V1.0.pdf)"},"/soft/maixpy/en/develop_kit_board/module_microphone.html":{"title":"Sipeed Microphone","content":" title: Sipeed Microphone keywords: maixpy, k210, AIOT, edge computing desc: maixpy Sipeed Microphone <table border \"2\"> <tr> <th colspan 3>Sipeed microphone module</th> </tr> <tr> <td>Description</td> <td>Physical image</td> <td>Description</td> </tr> <td> Single microphone module </td> <td> <img src \"../../assets/hardware/module/microphone_taobao_400x400.jpg\" height \"200\"> </p> <a href \"https://sipeed.taobao.com/\">Click to buy microphone module</a> </td> <td> 1. Microphone IC: MSM261S4030H0</p> 2. Interface: 6P 2.54mm cable interface</p> 3. Power supply voltage: 3.3V@5mA</p> 4. Module size: 15.2mm*9.1mm</p> 4. Working temperature: 30℃~80℃</p> <tr> <tr> <td> Single microphone module </td> <td> <img src \"../../assets/hardware/module/mic_array_taobao.jpg\" height \"200\"> </p> <a href \"https://sipeed.taobao.com/\">Click to buy microphone module</a> </td> <td> 1. Microphone IC: 6 MSM261S4030H0</p> 2. Interface: 10Pfpc / 10 pin 2.54mm cable interface</p> 3. Power supply voltage: 5V@mA</p> 4. Module size: 15.2mm*9.1mm</p> 4. Working temperature: 30℃~80℃</p> </tr> </table> ## Sipeed Mic Array Mic Array microphone array, as of MaixPy version `MicroPython v0.5.0 218 g8053a70`, the pin io on the microphone array hardware supports custom configuration No. MaixGo (default configuration IO) Description MIC_D0 23 MIC_D1 22 MIC_D2 21 MIC_D3 20 MIC_WS 19 MIC_SCLK 18 LED_DAT 24 SK9822 DAT LED_CLK 25 SK9822 CLK ### Routine Sound source localization ```python from Maix import MIC_ARRAY as mic import lcd lcd.init() mic.init()#Default configuration # mic.init(i2s_d0 23, i2s_d1 22, i2s_d2 21, i2s_d3 20, i2s_ws 19, i2s_sclk 18, sk9822_dat 24, sk9822_clk 25)#Customizable configuration IO while True: imga mic.get_map() # Get sound source distribution image b mic.get_dir(imga) # Calculate and get the sound source direction a mic.set_led(b,(0,0,255))# Configure RGB LED color value imgb imga.resize(160,160) imgc imgb.to_rainbow(1) # Convert image to rainbow image a lcd.display(imgc) mic.deinit() ``` effect: <iframe width \"600\" height \"350\" src \"//player.bilibili.com/player.html?aid 37058760&cid 65120313&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\"> </iframe>"},"/soft/maixpy/en/develop_kit_board/maix_dock.html":{"title":"Maix Dock","content":" title: Maix Dock keywords: maixpy, k210, AIOT, edge computing desc: maixpy Maix Dock ## Appearance and function introduction ### Appearance list MaixDock(M1W) ![MaixDock(M1W)](../../assets/hardware/maix_dock/sipeed_maix_dock_m1w.jpg) MaixDock(M1) ![MaixDock(M1)](../../assets/hardware/maix_dock/sipeed_maix_dock_m1.jpg) ### Onboard functions Item Description CPU: Dual core 64bit RISC V / 400MHz* (double precision FPU integration) Memory: 8MiB 64bit on chip SRAM Storage: 16MiB Flash, support micro SDXC expansion storage (max 128GB) Screen (package): 2.4 inch TFT, screen resolution: 320\\*240 Camera (package): 30W pixel GC0328 camera WIFI: MaixDock(M1W) uses M1W (integrated ESP8285 WIFI SOC); MaixDock(M1) has no internal WIFI function TF card slot: Multimedia resource expansion, support large capacity storage ### Pin Resources ![](../../assets/hardware/maix_dock/maixdock_pin_maps.svg) ## Download Sipeed Maix Dock data download: [Sipeed Maix Dock](https://dl.sipeed.com/shareURL/MAIX/HDK/Sipeed Maix Dock) Sipeed Maix Dock specification download: [Sipeed Maix Dock](https://dl.sipeed.com/shareURL/MAIX/HDK/Sipeed Maix Dock/Specifications) Sipeed Maix Dock schematic download: [Sipeed Maix Dock][Sipeed Maix Dock](https://dl.sipeed.com/fileList/MAIX/HDK/Sipeed Maix Dock/Maix Dock_11.27/Maix Dock_11.27 schematic.pdf) ## Problems Maix Dock cannot use MobaXterm or other software which does not support manual serial port flow control for serial communication. To avoid wasting time, it is recommended to use MaixPy for communication. You can open terminal in MaixPy top menu bar tools >open terminals >new terminal >Connect to serial ports >select the correct serial port >baudrate 115200, to create a new terminal ![sipeed_maix_dock_terminal](../../assets/hardware/maix_dock/sipeed_maix_dock_terminal.png)"},"/soft/maixpy/en/maixpy_history.html":{"title":"MaixPy Development History","content":" title: MaixPy Development History keywords: maixpy, k210, AIOT, edge computing desc: maixpy MaixPy development history Write down the development history of this article, hoping to let future developers know what MaixPy has gone through, what are the reasons for some major changes, and when major progress has been made. The code submission history can be seen in the [historic](https://github.com/sipeed/MaixPy v1commits/historic) and [master](https://github.com/sipeed/MaixPy v1commits/master) branches ## September 2018 The MaixPy project was launched, and the opportunity was the completion of the K210 chip tapeout. So everyone wanted to make a set of easy to use software kits that allow more people to use AI development in embedded applications. Because of the ease of use of Micropython, and the k210 has 6+2MiB memory, the main frequency is 400MHz, and it is fully capable of controlling Micropython. Micropython is selected as the programming syntax Based on the development board Maix dock, the name is now called Lichee Pill, and the QQ group name is also called Lichee Pill Alchemy Group [xiaohui](https://github.com/xiaoxiaohuixxh) and [wipping](https://github.com/wipping) started to try to port Micropython ## December 2018 K210 SDK was replaced from freertos to standalone SDK, and the on chip peripheral driver adaptation was started [neucrack](https://github.com/neutree), [xel](https://github.com/xelll) and [zepan](https://github.com/Zepan) join the project team ## February 2019 Release the first version of the firmware [v0.1.1 beta](https://github.com/sipeed/MaixPy v1releases/tag/v0.1.1), support basic peripherals, inherit the image sensor lcd API of openmv, Equipped with some open source tools such as upyloader, armpy, etc., write documents and publish them on maixpy.sipeed.com In addition, there are also two new development boards, Maix bit and Maix Go. Xiaohui left the project team ## March 2019 Release the second version of the firmware [v0.2.4](https://github.com/sipeed/MaixPy v1releases/tag/v0.2.4), adding support for jpeg, wav, kpu, nes, avi, lvgl, etc. ## April 2019 Adapted to OpenMV IDE, which is MaixPy IDE, based on the original software, only USB communication is changed to serial communication supported by k210, and other functions remain unchanged The pre compiled firmware began to differentiate the function into multiple firmware, mainly considering the problem of insufficient memory in the running model wipping left the project team, zepan and xel focused on other project teams ## June 2019 The project structure was refactored. Previously, the code was directly added to the directory structure of micropython and the code was added to the port directory. However, there would be a problem, that is, updating the micropython program becomes more troublesome, and you need to separate the code added by micropython and MaixPy , And the old code structure is too messy, the Makefile is not very well written, and the build is slow. So with the current directory structure, cmake + kconfig is used to build the project, and each component is modularized, and you can choose whether to compile into the firmware. The compilation framework is [here](https://github.com/Neutree/ c_cpp_project_framework). But there are still some remaining problems. There are some legacy codes under the directory that are not fully coupled. ## July 2019 Added support for M5Stick V development board, maintained by [Martin Han](https://github.com/MarsTechHAN) ## December 2019 [Maixhub](https://www.maixhub.com) is online, used for online model training, only need to upload data set without writing code Hardware update: online M1N module, golden finger module ## April 2020 [Sugar Lao Duck](https://github.com/QinYUN575) Join the project team ## May 2020 [Big Rats](https://github.com/junhuanchen) Join the project team ## June 2020 Hardware update: Maix Cube development board is online ## July 2020 Add board level configuration files for different boards, put them in the file system, and read them after booting. This is mainly because Cube and Amigo add power chips. In order to use them normally, you must first set the power chip when booting. Hardware update: Maix Amigo development board is online, with a shell added ## November 2020 Reorganize the documents, more perfect documents and communities ## April 2024 The brand new [MaixPy v4](https://wiki.sipeed.com/maixpy/) update no longer uses MicroPython but has switched to standard CPython3 to better match the more powerful [MaixCAM](https://wiki.sipeed.com/maixcam) hardware. To differentiate it from the MicroPython version of MaixPy, the name has been changed to MaixPy v1, and its maintenance will be paused. Future updates will be considered if necessary. The new MaixPy v4 will adopt the name MaixPy."},"/soft/maixpy/en/get_started/install_driver/dock.html":{"title":"Maix Dock USB driver installation","content":" title: Maix Dock USB driver installation keywords: maixpy, k210, AIOT, edge computing desc: maixpy Maix Dock USB driver installation ## Linux Linux does not need to install the driver, the system comes with it, use `ls /dev/ttyUSB*` to see the device number ## Windows `Maix Dock` uses `CH340` as the driver chip.`Windows` users need to install the driver of `CH340`. Windows download [ch340 ch341 driver](https://api.dl.sipeed.com/shareURL/MAIX/tools/ch340_ch341_driver) and install it, and then you can see the serial device in the `Device Manager`"},"/soft/maixpy/en/get_started/install_driver/go.html":{"title":"Maix Go USB Driver Installation","content":" title: Maix Go USB Driver Installation keywords: maixpy, k210, AIOT, edge computing desc: maixpy Maix Go USB driver installation The firmware of this `STM32` chip is shipped with [open ec](https://github.com/sipeed/open ec) firmware by default. If there is no problem, one or two serial ports will appear, such as `Linux There are two serial ports `/dev/ttyUSB0` and `/dev/ttyUSB1` under `. Please use `/dev/ttyUSB1` when downloading and accessing the serial port. Windows is similar. If you need to re burn this firmware, you can download it from [github](https://github.com/sipeed/open ec/releases) or [download open ec firmware from the official website](http://dl.sipeed.com/ MAIX/tools/flash zero.bin), and then use `ST LINK` to connect the `SW` pins (`GND`, `SWDIO`, `SWCLK`) of `STM32` on the board to burn. (The `STM32` on the current version of the `Go` board does not support serial port programming. You can only use `ST LINK` for programming. If necessary, please purchase it yourself, or use a board to simulate it with `IO` ( Such as Raspberry Pi)) In addition to `open ec`, there is also `CMSIS DAP` firmware. Compared with `open ec`, it can simulate `JTAG` to debug the board. Currently, `open ec` does not support simulation of `JTAG`. Download the firmware from the official website](http://dl.sipeed.com/MAIX/tools/cmsis dap/), use `ST LINK` to burn it, there will be `/dev/ttyACM0` under `Linux` equipment > ST LINK has complete information on the programming method of `STM32`, please search by yourself **Please note that updating the firmware of STM32 is not the same as updating the firmware of MaixPy. Generally, there is no need to update the firmware of STM32. The default is enough. STM32 is just a USB to serial tool! ! ! Don't be confused. . . ** ## Linux Linux does not need to install the driver, the system comes with it, use `ls /dev/ttyUSB*` to see the device number ## Windows The development board uses a `STM32` to realize the analog serial port and the `JTAG` function. `Windows` needs to install the driver of special driver. USB driver: [Click me](https://dl.sipeed.com/MAIX/tools/driver) When we get the MaixPy development board and connect it to the computer, we can open the device manager to check whether the serial port driver has been installed. The methods to open the device manager are: This computer (right click) > Properties > Device Manager Start menu (right click) > Device Manager Control Panel > (Search) Device Manager <img src \"../../../assets/get_started/win_device_1.png\" height \"400\"> 1. When our system is a Windows 10 system, the system will automatically install the driver for us, and if it is an old version of Win7, win8, we need to install the USB driver manually: ![](../../../assets/get_started/win_device_2.png) 2. Open the link in the previous section to download the driver ![](../../../assets/get_started/win_device_3.png) 3. Click Install ![](../../../assets/get_started/drives.gif) 4. After the installation is complete, you can see in the device manager that two serial devices have been identified (only one serial port is available) ![](../../../assets/get_started/win_device_4.png)"},"/soft/maixpy/en/get_started/install_driver/duino.html":{"title":"Maix Duino USB Driver Installation","content":" title: Maix Duino USB Driver Installation keywords: maixpy, k210, AIOT, edge computing desc: maixpy Maix Duino USB driver installation ## Linux Linux does not need to install the driver, the system comes with it, use `ls /dev/ttyUSB*` to see the device number ## Windows The development board uses the `CH552` chip to realize the `USB` to serial port function. There is no `JTAG` simulation function. `Windows` needs to install the special driver. USB driver: [Click me](https://dl.sipeed.com/MAIX/tools/driver) When we get the MaixPy development board and connect it to the computer, we can open the device manager to check whether the serial port driver has been installed. The methods to open the device manager are: This computer (right click) > Properties > Device Manager Start menu (right click) > Device Manager Control Panel > (Search) Device Manager <img src \"../../../assets/get_started/win_device_1.png\" height \"400\"> 1. When our system is a Windows 10 system, the system will automatically install the driver for us, and if it is an old version of Win7, win8, we need to install the USB driver manually: ![](../../../assets/get_started/win_device_2.png) 2. Open the link in the previous section to download the driver ![](../../../assets/get_started/win_device_3.png) 3. Click Install ![](../../../assets/get_started/drives.gif) 4. After the installation is complete, you can see in the device manager that two serial devices have been identified (only one serial port is available) ![](../../../assets/get_started/win_device_4.png)"},"/soft/maixpy/en/get_started/install_driver/ft2232.html":{"title":"Driver Installation","content":" title: Driver Installation keywords: maixpy, k210, AIOT, edge computing desc: maixpy driver installation ## Linux Linux does not need to install the driver, the system comes with it, use `ls /dev/ttyUSB*` to see the device number ## Windows `Windows` users need to install the driver of special driver. USB driver: [Click me](https://dl.sipeed.com/MAIX/tools/driver) When we get the MaixPy development board and connect it to the computer, we can open the device manager to check whether the serial port driver has been installed. The methods to open the device manager are: This computer (right click) > Properties > Device Manager Start menu (right click) > Device Manager Control Panel > (Search) Device Manager <img src \"../../../assets/get_started/win_device_1.png\" height \"400\"> 1. When our system is a Windows 10 system, the system will automatically install the driver for us, and if it is an old version of Win7, win8, we need to install the USB driver manually: ![](../../../assets/get_started/win_device_2.png) 2. Open the link in the previous section to download the driver ![](../../../assets/get_started/win_device_3.png) 3. Click Install ![](../../../assets/get_started/drives.gif) 4. After the installation is complete, you can see in the device manager that two serial devices have been identified (only one serial port is available) ![](../../../assets/get_started/win_device_4.png)"},"/soft/maixpy/en/get_started/install_driver/nano.html":{"title":"Maix Nano USB Driver Installation","content":" title: Maix Nano USB Driver Installation keywords: maixpy, k210, AIOT, edge computing desc: maixpy Maix Nano USB driver installation ## Linux Linux does not need to install the driver, the system comes with it, use `ls /dev/ttyUSB*` to see the device number ## Windows The development board uses the `CH552` chip to realize the `USB` to serial port function, and `Windows` users need to install the special driver. USB driver: [Click me](https://dl.sipeed.com/MAIX/tools/driver) When we get the MaixPy development board and connect it to the computer, we can open the device manager to check whether the serial port driver has been installed. The methods to open the device manager are: This computer (right click) > Properties > Device Manager Start menu (right click) > Device Manager Control Panel > (Search) Device Manager <img src \"../../../assets/get_started/win_device_1.png\" height \"400\"> 1. When our system is a Windows 10 system, the system will automatically install the driver for us, and if it is an old version of Win7, win8, we need to install the USB driver manually: ![](../../../assets/get_started/win_device_2.png) 2. Open the link in the previous section to download the driver ![](../../../assets/get_started/win_device_3.png) 3. Click Install ![](../../../assets/get_started/drives.gif) 4. After the installation is complete, you can see in the device manager that two serial devices have been identified (only one serial port is available) ![](../../../assets/get_started/win_device_4.png)"},"/soft/maixpy/en/get_started/install_driver/bit.html":{"title":"Maix Bit USB Driver Installation","content":" title: Maix Bit USB Driver Installation keywords: maixpy, k210, AIOT, edge computing desc: maixpy Maix Bit USB driver installation ## Linux Linux does not need to install the driver, the system comes with it, use `ls /dev/ttyUSB*` to see the device number ## Windows The development board is divided into two versions, new and old, and different drivers need to be installed separately ### `Maix Bit` (old version) Windows download [ch340 ch341 driver](https://api.dl.sipeed.com/shareURL/MAIX/tools/ch340_ch341_driver) and install it, then you can see the serial device in the `Device Manager` ### `Maix Bit` new version with microphone (use `CH552`) development board The development board uses the `CH552` chip to realize the `USB` to serial port function. There is no `JTAG` simulation function. `Windows` needs to install the special driver. USB driver: [Click me](https://dl.sipeed.com/MAIX/tools/driver) When we get the MaixPy development board and connect it to the computer, we can open the device manager to check whether the serial port driver has been installed. The methods to open the device manager are: This computer (right click) > Properties > Device Manager Start menu (right click) > Device Manager Control Panel > (Search) Device Manager <img src \"../../../assets/get_started/win_device_1.png\" height \"400\"> 1. When our system is a Windows 10 system, the system will automatically install the driver for us, and if it is an old version of Win7, win8, we need to install the USB driver manually: ![](../../../assets/get_started/win_device_2.png) 2. Open the link in the previous section to download the driver ![](../../../assets/get_started/win_device_3.png) 3. Click Install ![](../../../assets/get_started/drives.gif) 4. After the installation is complete, you can see in the device manager that two serial devices have been identified (only one serial port is available) ![](../../../assets/get_started/win_device_4.png)"},"/soft/maixpy/en/get_started/get_started_fs.html":{"title":"Introduction to Storage System","content":" title: Introduction to Storage System keywords: maixpy, k210, AIOT, edge computing desc: maixpy storage system introduction The MaixPy storage system is roughly as shown in the figure below: ![](../../assets/get_started/memory.png) As can be seen from the above figure, the storage medium in MaixPy is mainly composed of `Flash` and `SD` cards, which are divided into three areas, namely MaixPy.bin firmware area, xxx.kmodel model area, and file system area: Flash is [ `spiffs`](https://github.com/pellepl/spiffs) (SPI Flash File System), SD card is Fatfs (FAT file system). ## MaixPy.bin firmware area It is used to store MaixPy.bin firmware, starting at 0x000000, because K210 will start to run the program from 0x000000. ## xxx.kmodel model area It usually starts at 0x300000. The reason why the model file is not burned in the file system of `Flash` (the file system will be explained later) is due to the following reasons: 1. The memory of the file system in `Flash` is not large enough to fit in a large model, and a larger model can be placed in an SD card. 2. Reading model files directly is faster than reading through the file system. There is no file system management in this area. You need to operate files based on the starting address during programming. For example, the reading method when the model is programmed at 0x500000: ```python KpuTask kpu.load(0x500000) ``` ## File system area Usually starting from 0xD00000, this area is managed by the file system. We reserve the space `3MiB` at the end of `Flash`, which will be managed by [`spiffs`](https://github.com/pellepl/spiffs), and Also supports `FAT32` (Fatfs) `SD` card. These file systems provide interfaces so that we can read and write files through **file name** instead of using **file start address** as in the model area. At the same time, it can also help us effectively manage storage media. For example, wear leveling (Flash has a wear life, please search for relevant knowledge) can give full play to the life of Flash. ### Use of MaixPy File System Because the file systems of `Flash` and `SD` cards are different and the interfaces are inconsistent, different file systems need to call different interfaces. At this time, the virtual file system (VFS) in MaixPy is used to solve this problem, `VFS `You can mount multiple file systems of different types, and provide a unified interface for users to operate these file systems, and users can ignore the differences between different file systems when using these interfaces. These interfaces are implemented in the `os` module. Examples of usage are as follows: ```python import uos print(\"files:\", uos.listdir(\"/flash\")) with open(\"/flash/test.txt\", \"w\") as f: f.write(\"hello text\") print(\"files:\", uos.listdir(\"/flash\")) with open(\"/flash/test.txt\", \"r\") as f: content f.read() print(\"read:\", content) ``` In the above example, the `spiffs` file system is automatically mounted to the `/flash` directory when booting. The user only needs to pass in the `\"/flash\"` directory name as a parameter when using the `os` interface to access the file system . Interpretation: * Import the `uos` module * List all files in the `/flash` directory * Write a file named `test.txt` to the `/flash` directory with the content of `hello text`, * List all files in the `/flash` directory, you will find the existence of `test.txt` * Read the content of the file into the `content` variable * Print the `content` variable and output `hello text`, which is the content of the file just written * This content is powered on after the development board is powered off, the correct content can still be read (the content will not be lost after the Flash is powered off) Of course, SD card is also supported. If you need to use it, SD card needs to meet the following points: * Support `SPI` mode. Most genuine cards on the market support this * The partitioned tables is `MBR (msdos)` * File system is `FAT32` * The **`**1TB**`** storage has been tested and is available sAfter inserting the `SD` after power off, the `SD` card will be mounted on `/sd` if it is powered on. If there are multiple partitions, the second partition name is `/sd2` Note that `/` (root directory) cannot write data, only write data to `/flash` or `/sd` If there is a `SD` card at boot, it will automatically switch the current directory to `/sd`, if not, it will automatically switch to `/flash`"},"/soft/maixpy/en/get_started/knowledge_prepare.html":{"title":"Essential basic knowledge","content":" title: Essential basic knowledge keywords: maixpy, k210, AIOT, edge computing desc: maixpy essential basic knowledge To start using `MaixPy`, we recommend at least the following basic knowledge (if not, you need to learn first): * Have enough patience and attentiveness, able to calm down to study technology, carefully review documents, and concentrate on writing code * With `Python` or `Micropython` foundation, will use `Python` basic syntax. * If you don’t know the `Python` syntax, but you have the basis of other programming languages, please use Baidu to search the `Python Tutorial` to learn the basic syntax part; * If you don’t know any programming language, then this document looks very difficult, please learn the basic syntax and usage of `Python` * There is at least one kind of MCU development foundation, and can understand the basic circuit diagram. At present, there is no tutorial for people with zero foundation in this document. > The reason for having MCU development experience is that this document has not taught some basic terms, such as what is `UART`? What is `I2S`? And in the future, most of these basic knowledge will not be elaborated (but in fact, if you are good at using search tools to learn, you can learn even if you don’t understand) * To understand what Micropython is, check here: [MicroPython language introduction](http://docs.micropython.org/en/latest/reference/index.html) * A general understanding of the difference between Micropython and Python can be found here: [The difference between MicroPython and CPython (Python3)](http://docs.micropython.org/en/latest/genrst/index.html) If the above points are not satisfied at all, it is recommended to make up the missing ones first, otherwise the learning and development process will be extremely difficult! ! ! !"},"/soft/maixpy/en/get_started/env_maixpyide.html":{"title":"MaixPy IDE installation and use","content":" title: MaixPy IDE installation and use keywords: maixpy, k210, AIOT, edge computing desc: maixpy MaixPy IDE installation and use ![maixpy_ide_start](../../assets/maixpy/maixpy_ide_start.png) ## About MaixPy IDE ![MaixPy IDE](../../assets/maixpy/maixpy_ide.png) First of all, you need to clarify: **MaixPy** uses `Micropython` script syntax, so it does not need to be compiled like `C` language. In fact, it can be used happily without `IDE`: Use the serial terminal tool, which has been installed before Using `IDE` will facilitate real time editing of scripts on the computer and upload to the development board, execute scripts directly on the development board, and view camera images on the computer in real time, save files to the development board, etc. Of course, the use of `IDE` will consume some resources for compression and transmission, so the performance will be reduced, and if MaixPy is down, there is no serial terminal to find the problem. ## MaixPy firmware To use `MaixPy IDE`, the firmware must be `v0.3.1` or higher, otherwise MaixPyIDE will not be connected. Try to check the firmware version and IDE version before use, and update to the latest version to ensure normal use ## Download the installation package [dl.sipeed.com](http://dl.sipeed.com/MAIX/MaixPy/ide/) Please refer to the `readme.txt` file in the latest version folder for the description of the file list. If the download speed is slow, please use the cdn link to download ## Installation #### If it is an installer (**recommended**, simple and convenient) `Windows` directly double click the `exe` file to run the installer; `Linux` command line to run the permission and then execute ```shell chmod +x maixpy ide linux x86_64 0.2.2.run ./maixpy ide linux x86_64 0.2.2.run ``` #### If it is a compressed package (`7z`) Unzip to folder > If the system does not support `7z`, you need to [download `7z` decompression tool](https://www.7 zip.org/), then use `7z` You can also double click the compressed package to decompress it under `Linux`! If you need to use the terminal to decompress, you can refer to the following command: ```bash sudo apt install p7zip full 7z x maixpy ide linux x86_64 0.2.2 installer archive.7z r omaixpy ide # ` o` is directly followed by the decompressed path, without spaces. ``` * After decompression, execute * If it is `Windows`: directly double click `maixpyide` to execute, you can right click to fix it to the start page or fix it to the taskbar for later use * `Linux`: execute ``` chmod +x setup.sh ./setup.sh ./bin/maipyide.sh ``` ## Test run Open MaixPy IDE, select the model of the development board in the upper toolbar. **Please select Maixduino to connect to amigo and cube development board**. `Tool > Select Board` (Tool >Select Board) Click `connect` to connect to `MaixPy IDE` ![connect icon.png](../../assets/maixpy/maixpy_connect_icon.png) After the connection is successful, the link button will change from green to red. ![connect success.png](../../assets/maixpy/maixpy_connect success.png) Below the link button is the run button, which will execute the `py` file in the current editing area. ![helloworld run.png](../../assets/maixpy/maixpy_helloworld.png) Click the run button (red) again to stop running the current code. ## upload files You can choose to send files in the **Tool/Tools** menu ## Note * After clicking the connection, do not use it with the terminal tool at the same time, otherwise the serial port will be occupied and cannot be opened * If you have been unable to successfully connect successfully, check: * Please check whether the development board model selection is wrong; * Observe whether there is any change on the development board screen, if there is no response, it may be the serial port selection error; * Try to upgrade to the latest [master branch firmware](http://cn.dl.sipeed.com/MAIX/MaixPy/release/master), and the latest MaixPy IDE software ## Find the reason according to the error message When the program runs incorrectly, a pop up box will prompt an error, but the error information may not be complete, please **look for more detailed error information in the terminal output** If necessary, please disconnect the IDE, and only use the serial terminal to run the program (maybe you need to save the program to a file first, and then run the file) to check and print to troubleshoot If you submit a problem (bbs, group, github issue, etc.), in order to solve the problem quickly, please be sure to bring the complete information described above"},"/soft/maixpy/en/get_started/upgrade_esp32_firmware.html":{"title":"Update onboard ESP32 firmware","content":" title: Update onboard ESP32 firmware keywords: maixpy, k210, AIOT, edge computing desc: maixpy update onboard ESP32 firmware ## Introduction: In the MaixPy series of development boards, MaixDuino has an ESP32 WIFI SOC onboard. By default, we don’t need to update the onboard ESP32 module, but we find that there are bugs in the use process and fix them, we need to update the repaired firmware. ## Update ESP32 firmware steps ### Preparation Hardware: MaixDuino, USB Type C data cable Software: ESPFLASH ESP32 firmware update tool: ESP32 **flash_download_tools** Download link: [**flash_download_tools**](https://www.espressif.com/zh hans/support/download/other tools) ESP32 MaixDuino firmware: Download link: [**flash_download_tools**](https://cn.dl.sipeed.com/MAIX/factory_firmware/) ### Update process: 1. Download **flash_download_tools**, ![flash_download_tools](../../assets/hardware/module_esp32/image 20200504164050916.png) ![flash_download_tools](../../assets/hardware/module_esp32/image 20200504164221705.png) 2. Download **MaixDuino ESP32 firmware** ![update esp32](../../assets/hardware/module_esp32/image 20200504164245329.png) 3. Connect MaixDuino, select ESP32 serial port (usually the serial port number is relatively large) 4. Set download options: 1. Configure the corresponding options as shown in the figure, and note that the **baud rate must be set to 115200** ![b6474ddd5340cc9b7cf6006f75974a7b.png](../../assets/hardware/module_esp32/image 20200504164320888.png) ![acf618a24b4cb8c5f8c2e98acc6cf11b.png](../../assets/hardware/module_esp32/image 20200504164450650.png) 5. Click **Start** to update the firmware and wait for the update to complete 6. Verify that the update is complete 1. Using XCOM, open the ESP32 serial port, click RST to reset ESP32, the flashing is successful as shown in the figure ![96e955badd7450e7b5ba58230ae12c48.png](../../assets/hardware/module_esp32/image 20200504164747839.png)"},"/soft/maixpy/en/get_started/get_started_upload_script.html":{"title":"Upload scripts & modules to the development board","content":" title: Upload scripts & modules to the development board keywords: maixpy, k210, AIOT, edge computing desc: maixpy upload scripts & modules to the development board Earlier we came into contact with the direct execution of `pye(\"filename.py\")` command to open an editor, which can directly edit files in the file system But slowly we will find that this method is only suitable for changing a small amount of code. When the amount of code is huge or we need highlighting support, it is not applicable. We need to write the code on the computer and upload it to the board. Inside the file system There are currently the following methods: ### Use MaixPy IDE to upload scripts to the development board Open `MaixPy IDE`, connect to the development board Edit the file, and then in the top `Tool` (tool) menu, click `Save the opened file as boot.py` to save the code to the `boot.py` file of the development board. Next time the development board is powered on This file will be executed automatically Of course, you can also use the `send file` function in the top `Tool` menu to send a file. It will be saved to the development board and the file name is the same as the file name on the computer. ) ![](../../assets/maixpy/maixpy_ide_tools.png) ## Use the graphical tool uPyLoader to upload and run scripts [uPyLoader](https://github.com/BetaRavener/uPyLoader) is an open source software, with which you can easily connect to MaixPy and upload, download, execute files, and monitor output at the same time. The functions are relatively complete Download the executable file: [release](https://github.com/BetaRavener/uPyLoader/releases) ![uPyLoader](../../assets/other/uPyLoader.png) Select the serial port and click the `Connect` button to connect to the board The software needs to be initialized the first time to run the software. Click `File >Init transfer files` to complete the initialization. This will create two files on the board, namely `__upload.py` and `__download.py`. Select the file to be uploaded on the left and click `Transfer` to upload to the file system of the board. On the right is the file in the board, click on `List files` to refresh the file list, select the file name, click on `Execute` to execute the script file Click on the above `View > terminal` to open the terminal to view the runtime output or send commands ## Use tool rshell Just like using the `linux` terminal, use the `cp` command of [rshell](https://github.com/dhylands/rshell) to simply copy files to the development board Install `rshell` according to the instructions of `rshell` project homepage ```python sudo apt get install python3 pip sudo pip3 install rshell rshell p /dev/ttyUSB1 # Here, choose the serial port according to the actual situation ``` ```python ls /flash cp ./test.py /flash/ #Copy the file test.py in the current directory of the computer to the flash root directory of the development board ``` Of course, there are more functions, please visit its [Project Homepage](https://github.com/dhylands/rshell) ## Use the command line tool ampy [ampy](https://github.com/pycampers/ampy) is a simple and easy to use command line tool to upload, download and execute files, and it is open source Note that this tool is running on the computer, not on the board Use `ampy help` to view help information Use the `ampy run file_in_PC.py` command to run the script directly on the board instead of uploading the script to the board ## SD（TF） Direct operation After copying to the SD card, execute `import filename` or `exec()` in the terminal to run the script ## SD card is automatically copied to Flash file system In order to copy the contents of the SD card to the Flash file system conveniently, only need to rename the file to be copied to the Flash file system to `cover.boot.py` or `cover.main.py`, and then put it in the root of the `SD` card Directory, the development board is powered off and inserted into the `SD` card, and then the development board is powered on, the program will automatically copy these two files to `/flash/boot.py` or `/flash/main.py`, so that even later Take out the `SD` card, the program is already in `/flash/boot.py` or `/flash/main.py`"},"/soft/maixpy/en/get_started/knowledge_git_github.html":{"title":"Introduction to git and github","content":" title: Introduction to git and github keywords: maixpy, k210, AIOT, edge computing desc: maixpy introduction to git and github Because in the process of learning MaixPy, git and github are used in many places, so here is a brief explanation of what they are and what are the differences. ## What is git Git is a code hosting **software**, used to manage the version of the code. such as: I changed the code today, and then I changed the code tomorrow. From now on, I can see the history of these two changes, and what content was changed, which line can be accurate to find problems later; Or I find that there is a problem with the code submitted for the second time, and I need to go back to the version after the first submission, which can be achieved with this tool; In addition, it is convenient for multiple people to modify the same code, can manage the code submitted by everyone, and it is not easy to cause confusion. No longer have to copy countless folders to back up changes! Git will create a hidden folder `.git` in the directory, all changes are stored in it, and this folder cannot be deleted. But it should be noted that the current git is mainly used to manage text files. It is not suitable to manage binary files, such as picture PDFs, etc., which will make the space occupied by the folder become large. For specific tutorials, you can see [here](https://git scm.com/), and Chinese tutorials can be viewed [here](https://www.liaoxuefeng.com/wiki/896043488029600/896067008724000) ## What is github [github](http://github.com/) is a **website** for sharing code. You can register on this website, then create a repository, put the code in this repository for public sharing, so that more people can use it, and even modify and optimize the code together. This is **open source**. Each warehouse can be managed separately using the software `git`, you can modify the code on your computer, then use `git` to submit, and then use `git` to push to the website of `github`, you can See the new content. The source address of MaixPy is: [https://github.com/sipeed/maixpy](https://github.com/sipeed/maixpy), which is a `git repository`. [Help](https://docs.github.com/en/free pro team@latest/github), Chinese [Help](https://docs.github.com/cn/free pro team@latest/github) In addition, there are several websites similar to `github` in China, such as [gitee](https://gitee.com/) ## The difference between git and github One is a software, the other is a website. It's just that this website uses git technology to manage the warehouse. ## Why can't I access github, or the access speed is very slow Github is a foreign website. Because of the long distance and line problems, some lines of some operators may be slow or even inaccessible. For example, the domain name `https://raw.githubusercontent.com/` used by github to store source files may not be accessible Solution: * Change the line, that is, change the network. For example, if you use a telecommunications network, you can change to China Mobile or China Unicom, change the mobile phone traffic, or change the location, etc. * Use VPN software, not taught here, please pay attention to legal use ## What is star On github, everyone can like and collect every public warehouse, that is, star, in the upper right corner of github ⭐ shaped button ![](../../assets/other/github_star.jpg) If you think the project is good, please give it a star. This will encourage developers to spend more time maintaining the warehouse, and also tell first time visitors that this is a good project and deserves attention. After star, you can find your star warehouse in your profile, so you can find it next time Having said that, everyone thinks that [MaixPy](https://github.com/sipeed/maixpy) is good, you can star one~ ## What is the master branch In each warehouse, there can be many branches, different branches can have different codes, and different branches can be merged with each other, which is convenient to save different versions of the code and facilitate teamwork. The master branch refers to the main branch. That is the most important branch, usually the master branch is displayed by default in the warehouse. ## What is submission Submit, called `commit` in English, means that every time you change the code of the warehouse, you submit it once and it will be recorded in the submission history. You can see what was submitted this time at any time later, or you can roll back the code here. Commits Each commit has an independent `commit ID`, such as `d28cb7ac7db5ad61c0738df95d733717deefda1d`, abbreviated as `d28cb7a` ## What is a submodule Submodule, called `submodule` in English, means that other warehouses can be referenced in the warehouse, which is equivalent to a soft link. You don't need to put actual code in the warehouse, just put a link. The advantage of this is that multiple warehouses can be managed separately. For example, `Warehouse 1` references `Warehouse 2` as a submodule. If the code of `Warehouse 2` is updated, `Warehouse 1` can choose to continue to use the old version of `Warehouse 2` Code, you can also choose to use the latest code of `Warehouse 2`, just update the submodule link For example, `MaixPy` uses `kendryte standalone sdk` as a submodule, see [here](https://github.com/sipeed/MaixPy v1tree/master/components/kendryte_sdk) ![submodule](../../assets/get_started/github_submodule.jpg) You can see that the icon of the folder here is not the same, it is just a link, click will jump to the corresponding warehouse instead of opening the folder directly So **MaixPy uses submodules** ## What is cloning In the repository on `github`, if you need to download it locally, you need to use clone, use ``` git clone address ``` Just clone the warehouse locally. The cloned local warehouse is actually a clone on github, which is exactly the same, and keeps historical records, etc. Of course, you don’t need to clone. The webpage has a download button, but the defect of downloading is that it will not include the history of the submitted code. Choose according to your own situation. It should be noted that when cloning a repository that contains submodules, because cloning will only clone the link of the submodule by default, the code of the submodule is not cloned locally, you need to clone like this ``` git clone address recursive ``` or ``` git clone address project_name cd project_name git submodule update init recursive ``` such as: ``` git clone https://github.com/sipeed/MaixPy recursive ``` ## What is issue That is the meaning of the question. On github, each warehouse has a special place for asking questions, such as [MaixPy's issue](https://github.com/sipeed/MaixPy v1issues) Everyone asks questions here, similar to forums, they will be recorded for easy reference ## What is fork On github, there is a fork button in the upper right corner of the warehouse page ![](/assets/other/github_star.jpg) Click to fork the warehouse to your own warehouse, which is equivalent to a copy. The reason why it is called fork is that after you fork into your own warehouse, you can modify your own warehouse at will, which is regarded as a development branch of the original fork warehouse. Derived from it but not the same as it ## What is PR That is, the pull request function on github is to participate in the code update of a warehouse. It is to fork into its own warehouse, then modify it, and submit and merge it into the forked source warehouse. The specific method can be learned by yourself"},"/soft/maixpy/en/get_started/knowledge_audio.html":{"title":"Audio processing background knowledge","content":" title: Audio processing background knowledge keywords: maixpy, k210, AIOT, edge computing desc: maixpy audio processing background knowledge ## What is sound (audio) > People are rational, and the world is emotional. What is audio, audio is vibration. The vibration of light particles forms light waves, namely light; And the vibration of universal objects forms sound waves, that is, sound ## Audio coding basics Number of channels (number of channels) That is, the number of sound channels. When recording the sound, simultaneously record the audio of different spatial positions, that is, record multi channel audio; Common audio files are divided into mono and stereo, that is, mono records audio at a single location, while stereo has left and right channels to record audio at different spatial locations, and can play different channels of audio through different speakers. In this way, the audio of different spatial positions is restored, and the human ear can feel the different spatial positions through audio (more spatial sense). Number of sampling bits That is, the sampling value or sampling value (that is, the sampling sample amplitude is quantized). It is a parameter used to measure the fluctuation of sound, and it can also be said to be the resolution of the sound card. The larger its value, the higher the resolution and the stronger the sound power. The number of sampling bits in a computer is generally divided into 8 bits and 16 bits, but please note that 8 bits does not mean dividing the ordinate into 8 parts, but divided into 2 to the 8th power, which is 256 parts; the same is true for 16 bits. It divides the ordinate into 2 to the 16th power of 65536. Sampling frequency That is, the sampling frequency, which refers to the number of times a sound sample is obtained per second. The higher the sampling frequency, the better the sound quality, and the more realistic the sound reproduction, but at the same time it occupies more resources. Due to the limited resolution of the human ear, too high a frequency cannot be distinguished. In the 16 bit sound card, there are 22KHz, 44KHz, etc., of which 22KHz is equivalent to the sound quality of ordinary FM broadcasting, and 44KHz is equivalent to the sound quality of CD. The current common sampling frequency does not exceed 48KHz. ## PCM of audio encoding processing PCM introduction At present, we all need to rely on audio files for audio playback on computers. The generation process of audio files is the process of sampling, quantizing and encoding sound information. The lowest frequency of the sound that human ears can hear is from From 20Hz to the highest frequency 20Khz, so the maximum bandwidth of the audio file format is 20Kzh. According to Nyquist's theory, only when the sampling frequency is higher than twice the highest frequency of the sound signal, can the sound represented by the digital signal be restored to the original sound, so the sampling rate of the audio file is generally 40~50KHZ, such as the most common The CD sound quality sampling rate is 44.1KHZ. The process of sampling and quantizing the sound is called Pulse Code Modulation, or PCM for short. From the above three concepts of sampling frequency, number of sampling bits, and number of channels, the three concepts can be derived from the following formula. PCM file in the computer The amount of storage space occupied: PCM audio data size (sampling frequency * number of sampling bits * channel * time)//8 (unit: Bytes). Since PCM data is the most primitive audio data, it is completely lossless to the sampled data. Although PCM data has excellent sound quality, its volume is still too large for computer storage. In order to solve this problem, a series of audio formats have been born. These audio formats use Different methods are used to compress audio data, including lossless compression (ALAC, APE, FLAC) and lossy compression (MP3, AAC, OGG, WMA). ## WAV Waveform Audio File Format (WAVE, or WAV known by the public because of its extension) is an encoding format developed by Microsoft and IBM to store audio streams on personal computers. The application software on the Windows platform is widely supported. The status is similar to AIFF in Macintosh computers. This format is one of the applications of the Resource Exchange File Format (RIFF), and the audio data modulated by pulse code is usually stored in blocks. It is also one of the designated specifications commonly used among music enthusiasts. Since this audio format is not compressed, there will be no distortion in sound quality, but the volume of the file is larger among many audio formats. All WAVs have a file header, which is the encoding parameter of the audio stream. WAV has no hard and fast rules on the encoding of audio streams. In addition to PCM, almost all encodings that support the ACM specification can encode WAV audio streams. WAV can also use a variety of audio encodings to compress its audio stream, but we are usually WAV whose audio stream is encoded by PCM, but this does not mean that WAV can only use PCM encoding. MP3 encoding can also be used in WAV. Like AVI, as long as the corresponding Decode is installed, you can enjoy these WAVs. Under the Windows platform, WAV based on PCM encoding is the best supported audio format. All audio software can perfectly support it. Because it can meet the requirements of higher sound quality, WAV is also the preferred format for music editing and creation. Suitable for saving music material. Therefore, WAV based on PCM encoding is used as an intermediary format, which is often used in the mutual conversion of other encodings, such as converting MP3 to WMA. **In MaixPy, the WAV file format supported by the aduio module is PCM_s16le (signed 16 bits little endian, signed 16 bits little endian)**"},"/soft/maixpy/en/get_started/get_started_boot.html":{"title":"boot script","content":" title: boot script keywords: maixpy, k210, AIOT, edge computing desc: maixpy boot script The system will create the `boot.py` file and `main.py` in the `/flash` or `/sd` (priority) directory, and automatically execute `boot.py` first, and then execute `main.py` (if If the SD card is detected, execute the SD card), edit the contents of these two scripts to achieve self startup. If you write an infinite loop (While True) program in `boot.py`, it will cause `main.py `Can't run (call `boot.py` first and then `main.py`), and re send `boot.py` without infinite loop to solve it. boot.py is mainly used to configure the hardware and only needs to be configured once. main.py can be used for the main running program. The corresponding specific implementation [code here](https://github.com/sipeed/MaixPy v1/blob/972059491227ece63fbfc2cd0e78fe13ee78427d/components/micropython/port/src/maixpy_main.c#L586 L595), if you have any questions, just look at the source . note: * The Micro SD card should be formatted as FAT (FAT32) file system * FAT formatted memory card will be mounted to `/sd`, and SPIFFS in internal Flash will be mounted to `/flash`"},"/soft/maixpy/en/get_started/get_started_led_blink.html":{"title":"Turn on the LED","content":" title: Turn on the LED keywords: maixpy, k210, AIOT, edge computing desc: maixpy turn on the LED The lighting program is the first program to learn all the development boards, just like learning all programming languages, it has a sacred meaning. ## Circuit As we all know, lighting an LED requires a power supply, a resistor, and an LED bulb, There are three LEDs on the Maix Dock development board, the wiring is as follows: ![](../../assets/hardware/maix_dock/LED_sch.png) For example, we want the red light to light up, that is, the LED connected to `LED_R`. As you can see in the picture, the anode of the LED has been connected to a 3.3V power supply, so we only need to make LED_R a low level LED to light up. > Note that here `LED_R` is an alias for this pin, which is actually connected to a pin of the chip, such as `Pin13` or `IO13` ## FPIOA (Field Programmable Input and Output Array) Maybe you have used some single chip microcomputers, and the manual stipulates the binding of pins and on chip peripheral functions (that is, the peripherals integrated in the chip, such as `GPIO`, `I2C`, `SPI`, etc.), or re Mapping. For example, it is stipulated that `I2C` can only use `Pin9` and `Pin10`. After the remapping function is enabled, only `Pin11` and `Pin12` can be used However, the pins (hardware pins) corresponding to the on chip peripherals of the hardware K210 used by MaixPy can be **arbitrarily mapped**. In contrast, the K210 hardware design and software design have more freedom. For example, `I2C` can use `Pin11` and `Pin12`, and can also be changed to any other pin > Pay attention to distinguish the difference between `GPIO` and `IO`. `IO` can also be called `Pin`, which is a hardware pin derived from the chip, and `GPIO` is a peripheral device that can control these Peripherals of `Pin/IO` Because of this powerful mapping function, when using pins, you need to add a step of mapping: ```python from fpioa_manager import fm # import library fm.register(28, fm.fpioa.GPIO0) ``` Here we map pin `28` to the function of `GPIO0`. After executing this command, pins `28` and `GPIO0` are mapped (bound). If you want to unmap (unbind), then Need to call the `fm.unregister` function, see the `API` documentation for details, not introduced here In addition, `Pin` and peripherals can only correspond **unique**, not one to many. It is necessary to map the same peripherals or pins repeatedly, otherwise the program may produce errors that are difficult to find (`BUG`) ## Code We need to use GPIO to control the LED The procedure is as follows: ```python from fpioa_manager import fm from Maix import GPIO io_led_red 13 fm.register(io_led_red, fm.fpioa.GPIO0) led_r GPIO(GPIO.GPIO0, GPIO.OUT) led_r.value(0) ``` Run the code in the terminal according to the previous method of running the code, and you will find that the LED light is lit! Next we analyze the code: * Import the `fm` object from the `fpioa_manager` package, which is mainly used for pin and peripheral mapping * Imported the class `GPIO` from package `Maix`, GPIO peripheral related operations * Define a variable `io_led_red`, the value is `13`, that is, `Pin13/IO13`, which pin of the chip is connected to the specific LED pin, please see the schematic in the previous development board introduction * Use the built in object `fm` (abbreviation of fpioa manager) to register the correspondence between the peripherals of the chip and the pins, 　here `fm.fpioa.GPIO0` is a GPIO peripheral of K210 (`pay attention to distinguish GPIO (external Set) and the difference between pins (real hardware pins)`), so `fm.fpioa.GPIO0` is registered to pin `IO13`; * Then define a `GPIO` object `led_r`, see the `GPIO` API documentation for specific parameters, and find it in the left sidebar. * Use `led_r.value(1)` or `led_r.value(0)` to set the high and low levels, because the low level is set here. According to the above schematic diagram, it can be seen that the low level is on and the LED is on Now you can light up the lights. Now you can try to use the `for` loop to achieve the `LED` flashing or running lights~ to make different transformation effects"},"/soft/maixpy/en/get_started/board_info.html":{"title":"Board","content":" title: Board keywords: maixpy, k210, AIOT, Edge_calculation, maixpy_start desc: maixpy Board > This documnet has passed in Maixpy 0.5.1 128 version This is a MaixPy board config module, it unifies Python code at the user level, masking hardware pin differences. Here is its example code: ```python from Maix import GPIO from fpioa_manager import fm from board import board_info print(board_info.LED_R) fm.register(board_info.LED_R, fm.fpioa.GPIO0, force True) led_r GPIO(GPIO.GPIO0, GPIO.OUT) led_r.value(0) ``` This code can run on all MaixPy device, while its board_info.LED_R is not all the same, which ensures sample code consistency. ## Board configuration method Copy the python code from the following links (like config_maix_bit.py), run it in MaixPy IDE, after this you have imported config.json of your downloaded hardware, this config.json will be stored on flash 1. Maix Bit [config_maix_bit.py](https://github.com/sipeed/MaixPy v1_scripts/tree/master/board/config_maix_bit.py) 2. Maix Dock [config_maix_dock.py](https://github.com/sipeed/MaixPy v1_scripts/tree/master/board/config_maix_dock.py) 3. Maix Go [config_maix_go.py](https://github.com/sipeed/MaixPy v1_scripts/tree/master/board/config_maix_go.py) 4. Maix Duino [config_maix_duino.py](https://github.com/sipeed/MaixPy v1_scripts/tree/master/board/config_maix_duino.py) 5. Maix Cube [config_maix_cube.py](https://github.com/sipeed/MaixPy v1_scripts/tree/master/board/config_maix_cube.py) 6. Maix Amigo [config_maix_amigo.py](https://github.com/sipeed/MaixPy v1_scripts/tree/master/board/config_maix_amigo.py) 7. Maix Nano > There is no peripheral on this hardware, so here is no config code about it. Your board will reboot after you run config code, after this you can use board_info.BOOT_KEY in your code. In fact board_info.BOOT_KEY is IO16, and we can know its definition from config.json. An error will occour if its resource doesn't not exist. For example, if there is no LED defined in board config.json, an error will occour if you try to run flash an led. ```python from board import board_info # see board/readme.md to config your sipeed's hardware. print(board_info.BOOT_KEY, board_info.BOOT_KEY 16) ``` ## Custome your own firmware You can use this interface code to adapt your hardware, refer to [MaixPy_scripts/board](https://github.com/sipeed/MaixPy v1_scripts/tree/master/board) to see the reference configuration file to know configuration method. ## board usage import configuration ```python from board import board_info board_info.load({ 'PIN10': 10, 'BOOT_KEY': 16, 'WIFI_TX': 6, 'WIFI_RX': 7, 'WIFI_EN': 8, }) print('PIN10:', board_info.PIN10) print('BOOT_KEY:', board_info.BOOT_KEY) print('WIFI_TX:', board_info.WIFI_TX) print('WIFI_RX:', board_info.WIFI_RX) print('WIFI_EN:', board_info.WIFI_EN) ``` and its result: ```shell PIN10: 10 BOOT_KEY: 16 WIFI_TX: 6 WIFI_RX: 7 WIFI_EN: 8 ``` > This is all"},"/soft/maixpy/en/get_started/maixpy_get_started_video.html":{"title":"MaixPy video tutorial","content":" title: MaixPy video tutorial keywords: maixpy, k210, AIOT, edge computing desc: maixpy MaixPy video tutorial The video briefly introduces the basic getting started process. In fact, the document will be more detailed. The video only provides a more intuitive reference for getting started. It will be easier for some people to watch the video to get started. In addition, the document version in this video is the originalVersion, the new document directory structure has been adjusted appropriately, please draw inferences about it: <iframe width \"800\" height \"600\" src \"//player.bilibili.com/player.html?aid 52613549&cid 92076022&page 1\" scrolling \"no\" border \"0\" frameborder \"no\"framespacing \"0\" allowfullscreen \"true\"> </iframe> It is recommended to enter [Bilibili](https://www.bilibili.com/video/av52613549?zw) to log in to see the high definition version. If the rhythm is too slow, you can right click to adjust the speed~"},"/soft/maixpy/en/get_started/upgrade_stm32_firmwave.html":{"title":"MaixGo updates the onboard STM32 debugger firmware","content":" title: MaixGo updates the onboard STM32 debugger firmware keywords: maixpy, k210, AIOT, edge computing desc: maixpy MaixGo Update onboard STM32 debugger firmware The MaixGo development board has an STM32 based debugger onboard"},"/soft/maixpy/en/get_started/knowledge_image.html":{"title":"Background knowledge of image processing","content":" title: Background knowledge of image processing keywords: maixpy, k210, AIOT, edge computing desc: maixpy background knowledge of image processing ## What is a camera? We have all seen various cameras, such as <img src \"../../assets/other/camera_mi.png\" height \"200\"> <img src \"../../assets/hardware/module/camera.png\" height \"200\"> So what is a camera, in the final analysis, is a device that converts optical signals into electrical signals. In computer vision, the simplest camera model is the `hole imaging model`: ![](../../assets/other/Pinhole camera.svg) The pinhole model is an ideal camera model and does not consider the field curvature, distortion and other issues in the actual camera. But in actual use, these problems can be solved by introducing `distortion parameters` in the calibration process, so the pinhole model is still the most widely used camera model. SC The image passes through the lens and shines on a photosensitive chip. The photosensitive chip can convert information such as the wavelength and intensity of the light into a digital signal that can be recognized by a computer (digital circuit). The `photosensitive element` looks like this: ![camera sensor](../../assets/other/sensor.png) (The square element in the middle is the photosensitive element) ## What are pixels and resolution? The photosensitive element is composed of many photosensitive points. For example, there are `640` x `480` points. Each point is a pixel. Collect and organize the pixels of each point to form a picture. Then the picture is The resolution is 640x480: ## What is frame rate The frame rate (FPS) is the number of pictures processed per second. If it exceeds 20 frames, the human eye can hardly distinguish the freeze. Of course, if used on a machine, the higher the frame rate, the better. ## What is color Physically, colors are electromagnetic waves of different wavelengths. ![sRGB rendering of the spectrum of visible light](../../assets/other/1920px Linear_visible_spectrum.svg.png) However, according to the visual effect of the human eye, the color of visible light can be described through RGB, CMYK, HSB, LAB color gamut. ## RGB three primary colors The principle of the three primary colors is not caused by physical reasons, but by human physiological reasons. There are several color discriminating cone photoreceptor cells in the human eye, which are the most sensitive to yellow green, green, and blue violet (or violet) light (wavelengths are 564, 534, and 420 nanometers, respectively). So RGB is often used on monitors to display pictures. LAB brightness contrast In the Lab color space, L brightness; the positive number of a represents red, the negative end represents green; the positive number of b represents yellow, and the negative end represents blue. Unlike the RGB color space, Lab colors are designed to approximate human vision. Therefore, the L component can adjust the brightness pair, and modify the output color scale of the a and b components for accurate color balance. Note: In MaixPy's algorithm for finding color patches, this LAB mode is used! Selection of light source If your machine is in the industry, or a device that runs for a long time 24 hours, maintaining a stable light source is crucial, especially in the color algorithm. When the brightness changes, the value of the entire color will change greatly! ## The focal length of the lens Because the image is optically refracted by the lens, it hits the photosensitive element. Then the lens determines the size and distance of the entire picture. One of the most important parameters is the focal length. ![focal_distance](../../assets/other/focal_distance.jpg) **Lens focal length**: refers to the distance from the principal point to the focal point behind the lens optics, which is an important performance index of the lens. The length of the lens focal length determines the size of the image taken, the angle of view, the depth of field and the perspective of the picture. When shooting the same subject at the same distance, the image formed by the long focal length of the lens is large, and the image formed by the short focal length of the lens is small. Note that the longer the focal length, the smaller the viewing angle. Another point is the distortion of the lens. Because of the optical principle, the distance between the lens and the lens is different at different positions on the photosensitive chip. Simply put, the distance is small, so fisheye effects (barrel distortion) appear at the edges. In order to solve this problem, algorithms can be used in the code to correct the distortion. Note: image.lens_corr(1.8) is used in MaixPy to correct the 2.8mm focal length lens. You can also directly use the distortionless lens. The non distortion lens adds an additional corrective lens part, and the price will naturally be much higher. ## Lens filter On the lens, there is usually a filter. ![camera sensor](../../assets/other/sensor_1.png) What does this filter do? We know that different colors of light have different wavelengths. In a normal environment, in addition to visible light, there are a lot of infrared light. In night vision, infrared light is used. However, in normal color applications, infrared light is not needed, because infrared light will also cause the photosensitive element to react, making the entire screen white. So we put a filter on the lens that can only pass through the wavelength of 650nm to filter the infrared light."},"/soft/maixpy/en/get_started/get_started_edit_file.html":{"title":"Edit and execute the file","content":" title: Edit and execute the file keywords: maixpy, k210, AIOT, edge computing desc: maixpy edit and execute files ## MaixPy has a built in file system As mentioned earlier, `MaixPy` supports `SPIFFS` used by `Flash` (currently does not support directory creation), by default, `3MB` is allocated to `SPIFF` (from the address of `flash` `0xD00000`, `3M`), boot Automatically mount to the `/flash` directory It also supports the `Micro SD (TF)` card of `FAT32` format `MBR` partition, and it will automatically hang under the `/sd` directory when booting up It should be noted that the root directory is only used to mount the Flash or SD card, and the specific files are in the `/flash` or `/sd` directory ## Why need to edit and execute the file In the previous experiment, we directly typed the code in the terminal to execute sentence by sentence. This is also simple and convenient. After we enter the command, it will execute immediately and get the returned result in time. This interactive method is called **`REPL (Read Eval Print Loop: Interactive interpreter) `**, The advantage of this method is that it is simple and convenient. It is very similar to the Linux terminal, except that the syntax used is replaced by MaixPy (Micropython) syntax. But in actual operation, we want the code to be saved in the file system, and we need to run the file directly, so that we don’t have to type the code every time, which reduces a lot of trouble. ## Edit and save the file ### Method 1: Use the built in editor [Micropython Editor(pye)](https://github.com/robert hh/Micropython Editor) In MaixPy, we have built in an open source editor [Micropython Editor(pye)](https://github.com/robert hh/Micropython Editor) Use `os.listdir()` to view the files in the current directory, Use `pye(\"hello.py\")` to create a file and enter the editing mode, and the instructions for using shortcut keys can be found in [here](https://github.com/robert hh/Micropython Editor/blob/master/Pyboard%20Editor.pdf) For example, we write code ```python print(\"hello maixpy\") ``` Then press `Ctrl+S` and press `Enter` to save, press `Ctrl+Q` to exit editing **Note**: The use of this editor has certain requirements for the serial tool used. The `BackSpace` key must be set to the `DEL` function, otherwise pressing `BackSpace` will call the same function as `Ctrl+H` ( That is character replacement). It is recommended to use `minicom` under Linux, you need to use `sudo minicom s` to set, refer to [previous tutorial](./env_serial_tools.html) The same is true under Windows, search the setting method according to the tool you use, such as `xshell` search `xshell How to set backspace to del` to get the result: `File` > `Properties` > `Terminal` > `Keyboard`, Change the sequence of delete and backspace to ASCII 127. ### Method 2: Use MaixPy IDE Open `MaixPy IDE`, connect the development board Edit the file, then in the top `Tool` menu, use the `send file` function in the top `Tool` menu to send the file, it will be saved to the development board and the file name is the same as the file name on the computer Of course, you can also click `Save the opened file as boot.py` to save the code to the `boot.py` file of the development board. This file will be executed automatically next time the development board is powered on. ![](../../assets/maixpy/maixpy_ide_tools.png) ### Method Three: Use the tool [uPyLoader](https://github.com/BetaRavener/uPyLoader) to read to the PC (computer), edit and then save to the development board Download the executable file: [release](https://github.com/BetaRavener/uPyLoader/releases) ![uPyLoader](../../assets/other/uPyLoader.png) Select the serial port and click the `Connect` button to connect to the board The first time you run the software, you need to initialize. Click on `File >Init transfer files` to complete the initialization. This will create two files in the board, namely `__upload.py` and `__download.py`. Then double click the file name to open the file and edit it. After editing, click `save` to save to the development board. ### Method 4: Use the tool [rshell](https://github.com/dhylands/rshell) to read it on the PC (computer) and edit it and then save it to the development board Follow the instructions of `rshell` [Project Homepage](https://github.com/dhylands/rshell) to install `rshell` ```shell sudo apt get install python3 pip sudo pip3 install rshell rshell p /dev/ttyUSB1 # Here, choose the serial port according to the actual situation ``` Edit file ```python ls /flash edit /flash/boot.py # The editor is used in the same way as vim ``` ## executable file Use `os.chdir()` to switch the current directory to the directory of the file, such as `os.chdir(\"/flash\")` ### Method 1: `import` Then execute `import hello` You can see the output `hello maixpy` Using this method is simple and easy to use, but it should be noted that currently `import` can only be used once. If the second `import`, the file will not be executed again. If you need to execute it multiple times, the following method is recommended And `import` will not execute the code under the condition of `if __name__ \"__main__\":`, you need to pay attention ### Method 2: `exec()` Use the `exec()` function to execute ```python with open(\"hello.py\") as f: exec(f.read()) ``` ### Method 3: Use **MaixPy IDE** to execute Open the file, and then click the execute button to execute it. **Note**: The execution code is similar to the `REPL` execution code, except that the program is sent to the development board and not saved to the file system. It is executed once ![](../../assets/maixpy/maixpy_connect success.png) ### Method 4: Use uPyLoader to execute After connecting, select the file and click the `excute` button to execute the file ### Method 5: Use ampy to run files on the computer directly [ampy](https://github.com/pycampers/ampy) Execute the command `ampy run file_in_PC.py` to execute the file located on the computer (the file will not be saved to the development board) ## Does MaixPy support mounting file systems to the computer? Not supported, because the chip k210 used has no USB function and cannot simulate a U disk device, so it cannot be a virtual U disk like Microbit and STM32 Micropython"},"/soft/maixpy/en/get_started/knowledge_micropython.html":{"title":"MicroPython background knowledge","content":" title: MicroPython background knowledge keywords: maixpy, k210, AIOT, edge computing desc: maixpy MicroPython background knowledge Since **MaixPy** is developed and built on top of **MicroPython**, The final interface provided to users is **Micropython**, so we need to be familiar with the basic knowledge and syntax of `MicroPython` at the beginning of development using MaixPy ## About MicroPython: MicroPython is a streamlined and efficient implementation of the programming language Python3. The syntax is consistent with Python3, but only a small part of the Python standard library is implemented. It is optimized and can be used in resource constrained environments such as MCU and WIFI SOC. So we To use MicroPython, you need to understand its syntax. If you have previous programming experience in **C/C++/Java** (or any other language), it is recommended [*(Liao Xuefeng's Python Tutorial).*](https://www.liaoxuefeng.com/wiki/1016959663602400) If you do not have any programming experience before, recommend [*(Learn Python in a Stupid Way).*](https://wizardforcel.gitbooks.io/lpthw/content/) ## REPL and serial port First, disconnect the connection between the development board and MaixPy IDE, otherwise the serial port will conflict! Open a terminal window in MaixPy IDE print('The quick brown fox','jumps over','the lazy dog') Output: ``` The quick brown fox jumps over the lazy dog ``` print() will print each string in turn, and will output a space when it encounters a comma \",\". Therefore, the output string is spelled like this: > The quick brown fox jumps over the lazy dog print() can also print integers or calculate results: ```python print(300) 300 print(100 + 200) 300 ``` Therefore, we can print the result of calculating 100 + 200 more beautifully: ```python print('100 + 200 ', 100 + 200) 100 + 200 300 ``` Note that for 100 + 200, the Python interpreter automatically calculates the result 300, but '100 + 200 'is a string instead of a mathematical formula, and Python treats it as a string. ## MicroPython basic syntax ### Variable In Python, the equal sign ` ` is an assignment statement, which can assign any data type to a variable. The same variable can be assigned repeatedly, and it can be a variable of different types, for example: ```python a 123 # a is an integer print(a) a 'ABC' # a becomes a string print(a) ``` This kind of language with variable types is called **dynamic language**, and its counterpart is **static language**. A static language must specify the variable type when defining a variable. If the type does not match when assigning a value, an error will be reported. For example, Java is a static language, and the assignment statement is as follows (// means comment): ```java int a 123; // a is an integer variable a \"ABC\";// Error: Cannot assign a string to an integer variable ``` Compared with static languages, dynamic languages ​​are more flexible for this reason. ### List One of the built in data types of Python is **list**: **list**.<br/> **list** is an ordered collection, elements can be added and deleted at any time. For example, to list the names of all classmates in the class, you can use a **list** to indicate: ```python classmates ['Michael','Bob','Tracy'] classmates ['Michael','Bob','Tracy'] ``` The variable classmates is a `list`.<br/> Use the `len()` function to get the number of list elements: ```python len(classmates) 3 ``` Use the index to access the elements at each position in the list, the index starts from 0: ```python classmates[0] 'Michael' classmates[1] 'Bob' classmates[2] 'Tracy' classmates[3] Traceback (most recent call last): File \"<stdin>\", line 1, in <module> IndexError: list index out of range ``` When the index exceeds the range, Python will report an IndexError error, so make sure that the index does not exceed the range, remember that the index of the last element is len(classmates) 1. If you want to get the last element, in addition to calculating the index position, you can also use 1 as an index to get the last element directly: ```python classmates[ 1] 'Tracy' ``` By analogy, you can get the second to last and third to last: ```python classmates[ 2] 'Bob' classmates[ 3] 'Michael' classmates[ 4] Traceback (most recent call last): File \"<stdin>\", line 1, in <module> IndexError: list index out of range ``` Of course, the fourth from last crossed the line. The list is a **variable** **ordered list**, so you can append elements to the list to the end: ```python classmates.append('Adam') classmates ['Michael','Bob','Tracy','Adam'] ``` You can also insert the element into a specified position, such as the position with index number 1: ```python classmates.insert(1,'Jack') classmates ['Michael','Jack','Bob','Tracy','Adam'] ``` To delete the element at the end of the list, use the pop() method: ```python classmates.pop() 'Adam' classmates ['Michael','Jack','Bob','Tracy'] ``` To replace an element with another element, you can directly assign it to the corresponding index position: ```python classmates[1] 'Sarah' classmates ['Michael','Sarah','Tracy'] ``` The data types of the elements in the list can also be different, for example: ```python L ['Apple', 123, True] ``` If there is no element in a list, it is an empty list with a length of 0: ```python L [] len(L) 0 ``` ### Tuple Another kind of ordered list is called tuple: **tuple**.<br/> Tuple is very similar to list, but once the `tuple` is initialized, it cannot be modified. For example, it also lists the names of classmates: ```python classmates ('Michael','Bob','Tracy') ``` Now, the **tuple** of classmates cannot be changed, and it does not have methods such as append(), insert(). The other methods of obtaining elements are the same as list, you can use classmates[0], classmates[ normally 1), but cannot be assigned to another element. What is the point of an immutable tuple? Because tuples are immutable, the code is safer. If possible, try to use tuple instead of list. The trap of tuple: When you define a tuple, the elements of the tuple must be determined at the time of definition, such as: ```python t (1, 2) t (1, 2) ``` However, to define a A tuple with only 1 element, if you define it like this: ```python t (1) t 1 ``` But at this time, the definition is not tuple, t is an integer variable, and the value of variable t is 1! <br/> This is because parentheses () can represent tuples and parentheses in mathematical formulas, which creates ambiguity.Therefore, Python stipulates that in this case, the calculation is based on parentheses, and the calculation result is naturally 1. Therefore, the definition of **tuple** with only 1 element must add a comma `,`, to disambiguate: ```python t (1,) t (1,) ``` When Python displays a tuple with only 1 element, it will also add a comma `,` to prevent you from misunderstanding it as a bracket in the sense of mathematical calculations. ### Conditional judgment The complete form of the if statement is: ``` if <condition judgment 1>: <Execute 1> elif <condition judgment 2>: <Execute 2> elif <condition judgment 3>: <Execute 3> else: <Execute 4> ``` such as: ```python age 20 if age > 6: print('teenager') elif age > 18: print('adult') else: print('kid') ``` ### Loop There are two types of Python loops, one is the `for...in` loop, which iterates over each element in a list or tuple in turn, see an example: ```python names ['Michael','Bob','Tracy'] for name in names: print(name) ``` Executing this code will print each element of names in turn: ```python Michael Bob Tracy ``` So the `for x in ...` loop is to substitute each element into the variable x, and then execute the statement of the indented block. If you want to calculate the sum of integers from 1 to 100, it is a bit difficult to write from 1 to 100. Fortunately, Python provides a range() function that can generate a sequence of integers, which can be converted to a list by the list() function.<br/> For example, the sequence generated by range(5) is an integer less than 5 starting from 0: ```python list(range(5)) [0, 1, 2, 3, 4] ``` range(101) can generate a sequence of 0 100 integers, calculated as follows: ```python sum 0 for x in range(101): sum sum + x print(sum) ``` The second type of loop is the **while loop**. For example, if we want to calculate the sum of all odd numbers within 100, we can use the while loop: ```python sum 0 n 99 while n> 0: sum sum + n n n 2 print(sum) ``` ### Data type conversion Python's built in common functions also include data type conversion functions, such as the int() function to convert other data types to integers: ```python >>> int('123') 123 >>> int(12.34) 12 >>> float('12.34') 12.34 >>> str(1.23) '1.23' >>> str(100) '100' >>> bool(1) True from machine import GPIO ``` ### Functions In Python, to define a function, use the `def` statement, write the function name, parentheses, the parameters in the parentheses and the colon `:` in turn, and then write the function body in the indented block, and the return value of the function is returned The statement returns. Let's write a function to calculate x2: ```python def power(x): return x * x ``` For the power(x) function, the parameter x is a positional parameter. When we call the power function, we must pass in one and only one parameter x: ```python power(5) 25 power(15) 225 ``` Now, what if we want to calculate x3? We can define another power3 function, but what if we want to calculate x4, x5...? We cannot define an infinite number of functions. You may think of it, you can modify power(x) to power(x, n) to calculate xn, just do it: ```python def power(x, n): s 1 while n> 0: n n 1 s s * x return s ``` For this modified power(x, n) function, any n th power can be calculated: ```python power(5, 2) 25 power(5, 3) 125 ``` The modified power(x, n) function has two parameters: x and n. These two parameters are positional parameters. When the function is called, the two values ​​passed in are assigned to the parameters x and n in order of position. ### Slice It is a very common operation to take some elements of a `list` or `tuple`. For example, a list is as follows: ```python L ['Michael','Sarah','Tracy','Bob','Jack'] ``` Take the first 3 elements and complete the slice with one line of code: ```python L[0:3] ['Michael','Sarah','Tracy'] ``` L[0:3] means that it starts from index 0 and ends at index 3, but does not include index 3. That is, indexes 0, 1, 2, are exactly 3 elements. If the first index is 0, it can also be omitted: ```python L[:3] ['Michael','Sarah','Tracy'] ``` You can also start at index 1, and take out 2 elements: ```python L[1:3] ['Sarah','Tracy'] ``` `tuple` is also a kind of list, the only difference is that `tuple` is immutable. Therefore, `tuple` can also be sliced, but the result of the operation is still `tuple`: ```python (0, 1, 2, 3, 4, 5)[:3] (0, 1, 2) ``` `String`'xxx' can also be regarded as a kind of `list`, each element is a character. Therefore, string can also be sliced, but the result of the operation is still a string: ```python 'ABCDEFG'[:3] 'ABC' ``` ### Object Python is **object oriented** programming, such as an LED light ```python from pyb import LED red_led LED(1) red_led.on() ``` LED is a **class**, red_led is an **object**, you can operate this object, such as turning on, turning off, and viewing the value. ### Module ### What is a module? As the code increases, the code in a file will become longer and more difficult to understand. In order to write maintainable code, we group many functions into different files. In Python, a `.py` file is called a **Module**. What are the benefits of modules? Easy to reuse code! If I wrote a module and you also wrote a module, we have two modules. We organize these modules so that everyone can write a lot less code! #### How to use modules? ```python import time time.sleep_ms(500) ``` `import time` is to import the `time` module. The module can be imported through the `import` statement. ### More Please search for more MicroPython basic syntax tutorials."},"/soft/maixpy/en/get_started/upgrade_esp8285_firmware.html":{"title":"Update onboard ESP8285 firmware","content":" title: Update onboard ESP8285 firmware keywords: maixpy, k210, AIOT, edge computing desc: maixpy update onboard ESP8285 firmware ## Introduction: At present, MaixPy series adopt M1W module as the core module development boards: MaixDock(M1W), MaixGo Normally we don’t need to update the firmware of the WIFI SOC ESP8285 inside the module, but if there is a bug in the use process, and a new version of the firmware is released, we can update the firmware > The ESP8285 in the M1W module used by MaixDock and MaixGo burns AT firmware by default ## Verify that ESP8285 can work normally MaixPy verifies whether ESP8285 is working properly > View the end of text routine External USB to serial module test Use USB to serial port module, connect according to the following table, and then power on M1W USB Module Description M1W GND GND Common ground K210 (IO6)/ESP8285 TX RX K210 (IO7)/ESP8285 RX TX k210 RST (ground before power on, pull down RST during the whole process) GND After power on, the board will output serial port (here XCOM, baud rate 115200) to verify whether ESP8285 starts normally ![image 20200805175207487](../../assets/hardware/module_esp8285/image 20200805175207487.png) ## AT command set ESP8285 and ESP8266 are the same series of products, using the same set of AT commands ESP8285/ESP8266/ESP32 latest AT command set https://github.com/espressif/esp at/blob/v2.0.0.0_esp8266/docs/ESP_AT_Commands_Set.md ## Update ESP8285 firmware steps Before burning ESP8285 firmware, first understand the ESP8285 burning principle: ### ESP8285 firmware burning principle When ESP8285 is powered on, it will determine the state of the boot stapping pin and determine the boot mode, such as: > ets Jan 8 2013,rst cause:1, boot mode:(3,2) The first digit (3) of the printed boot mode represents the current boot mode. Boot mode is determined by the 3 bit value of strapping pin [GPIO15, GPIO0, GPIO2]. As shown in the following table Show: 3 bit value of strapping pin/[GPIO15, GPIO0, GPIO2] Boot mode 7 / [1, 1, 1] SDIO HighSpeed ​​V2 IO 6 / [1, 1, 0] SDIO LowSpeed ​​V1 IO 5 / [1, 0, 1] SDIO HighSpeed ​​V1 IO 4 / [1, 0, 0] SDIO LowSpeed ​​V2 IO 3 / [0, 1, 1] Flash Boot 2 / [0, 1, 0] Jump Boot 1 / [0, 0, 1] UART Boot 0 / [0, 0, 0] Remapping Please see the following table for the IO level of ESP8285 entering different modes: Mode CH_PD(EN) RST GPIO15 GPIO0 GPIO2 TXD0 : : : : : : UART download mode High High Low Low High High Flash operating mode High High Low High High High Chip Test Mode Low That is, ESP8285 enters UART download mode, the first bit of the startup information mode should be mode:(1, X), as follows: > ets Jan 8 2013,rst cause:1, boot mode:(1,1) Taking MaixDock as an example, you can see the schematic diagram of MaixDock as follows: ![](../../assets/hardware/maix_dock/sipeed_maix_dock_sch_wifi.png) ![](../../assets/hardware/maix_dock/sipeed_maix_dock_sch_wifi_spi.png) ### Preparation > Here is MaixDock(M1W), Windows 10 system as an example Hardware: MaixDock, USB Type C data cable Software: ESP firmware update tool: ESP8285 **flash_download_tools** Espressif's official website download link: [**flash_download_tools**](https://www.espressif.com/zh hans/support/download/other tools) ESP8285 AT firmware: Download link: [**ESP8266 AT bin**](https://cn.dl.sipeed.com/MAIX/factory_firmware/) Espressif's official download link: [espressif_esp8266 at](https://www.espressif.com/zh hans/support/download/at?keys &field_type_tid%5B%5D 14) ![](../../assets/hardware/module_esp8285/image 20210105192007.png) ### Windows uses flash_download_tools to update ES8285 (here, MaixDock is taken as an example): 1. Follow the configuration below to connect to MaixDock, Connect the USB to serial port module and ESP8285, the connection method has been introduced above Before power on, GPIO0 needs to be pulled down, that is, the contact in the upper left corner next to the antenna is grounded to enter the UART download mode. ![](../../assets/hardware/maix_dock/maix_dock_2.jpg) 1. Open **flash_download_tools** 2. Download **MaixDock ESP8285 firmware** ![](../../assets/hardware/module_esp8285/flash_download_tool.png) 3. Select ESP8285 serial port (usually the serial port number is relatively large) 4. Set download options: Configure the corresponding options as shown in the figure, note that the baud rate must be set to 115200** ![](../../assets/hardware/module_esp8285/flash_download_tool_ESP8285.png) 5. Click **Start** to update the firmware and wait for the update to complete 6. Verify that the update is complete Use the XCOM baud rate of 115200, open the ESP8285 serial port, and output `AT\\r\\n`, as shown in the figure, it prompts `OK` to flash in successfully ![esp8285_at.png](../../assets/hardware/maix_dock/esp8285_at.png) ### LINUX uses esp_tool to update ES8285 (here, MaixDock is taken as an example): 1. Follow the configuration below to connect to MaixDock, ![](../../assets/hardware/maix_dock/sipeed_maix_dock_m1w_2.png) 2. Install esptool ```shell pip3 install esptool ``` 3. Download **MaixDock ESP8285 firmware** ```shell ls /dev/ttyUSB* # View USB serial port esptool port /dev/ttyUSB0 write_flash 0x0 ESP8285 AT V1.7.4_8Mbit_40Mhz.bin # Burn the firmware ``` 4. Verify that the update is complete Use XCOM baud rate 115200, open ESP8285 serial port, output `AT\\r\\n`, as shown in the figure, prompt `OK`, then flashing is successful ![esp8285_at.png](../../assets/hardware/maix_dock/esp8285_at.png) ### MaixPy routine test: ```python import network, time from machine import UART from Maix import GPIO from fpioa_manager import fm # En SEP8285 rst #fm.register(8, fm.fpioa.GPIOHS0, force True) #wifi_en GPIO(GPIO.GPIOHS0, GPIO.OUT) #wifi_en.value(1) # En SEP8285 rst fm.register(0, fm.fpioa.GPIOHS0, force True) wifi_io15 GPIO(GPIO.GPIOHS0, GPIO.OUT) wifi_io15.value(0) fm.register(8, fm.fpioa.GPIOHS1, force True) wifi_en GPIO(GPIO.GPIOHS1, GPIO.OUT) wifi_en.value(1) # for new MaixGO board, if not, remove it #fm.register(0, fm.fpioa.GPIOHS1, force True) #wifi_io15_en GPIO(GPIO.GPIOHS1, GPIO.OUT) #wifi_io15_en.value(0) fm.register(6, fm.fpioa.UART2_RX, force True) fm.register(7, fm.fpioa.UART2_TX, force True) uart UART(UART.UART2,115200,timeout 1000, read_buf_len 4096) def wifi_enable(en): global wifi_en wifi_en.value(en) def wifi_deal_ap_info(info): res [] for ap_str in info: ap_str ap_str.split(\",\") info_one [] for node in ap_str: if node.startswith('\"'): info_one.append(node[1: 1]) else: info_one.append(int(node)) res.append(info_one) return res #wifi_enable(0) time.sleep(2) nic network.ESP8285(uart) ap_info nic.scan() ap_info wifi_deal_ap_info(ap_info) ap_info.sort(key lambda x:x[2], reverse True) # sort by rssi for ap in ap_info: print(\"SSID:{:^20}, RSSI:{:>5}, MAC:{:^20}\".format(ap[1], ap[2], ap[3])) ```"},"/soft/maixpy/en/get_started/upgrade_maixpy_firmware.html":{"title":"Update MaixPy firmware","content":" title: Update MaixPy firmware keywords: maixpy, k210, AIOT, edge computing desc: maixpy update MaixPy firmware ## Prepare hardware: USB Type C data cable MaixPy development board PC (computer) software: MaixPy development board USB driver kflash_gui ## Confirm that the driver has been installed correctly Install the driver according to the previous instructions, and you can see the serial device in the computer, `Linux` and `Mac OS` execute `ls /dev/` to see the device number, for example, the name is `ttyUSB0` and `ttyUSB1` ; `Windows` view in device manager ## Get the upgrade tool * Download [kflash_gui](https://github.com/sipeed/kflash_gui/releases), you will get a compressed package > kflash_gui is cross platform and can work under multiple systems (including Windows, Linux, MacOS, and even Raspberry Pi) > If you use Kendryte's `Windows` version, some development versions may not be able to download successfully, please use the `kflash_gui` software to download * Unzip to a folder, double click `kflash_gui.exe`(/`kflsh_gui`) to run, under `Windows`, it is recommended to right click `fix to start page` or `fix to taskbar`, and create a new one under `Linux` A [kflash_gui.desktop](https://github.com/sipeed/kflash_gui/blob/master/kflash_gui.desktop), modify the file address, use the administrator to copy it to the `/usr/share/application` directory, and then You can see the application `kflash_gui` in the system menu interface * You can also use the command line version to download ```shell pip3 install kflash kflash help kflash p /dev/ttyUSB0 b 1500000 B goE maixpy.bin ``` ## Get the firmware * The released version of the firmware can be downloaded from the [github](https://github.com/sipeed/MaixPy v1releases) page * The latest submitted code is automatically constructed and generated firmware download: [master branch](http://dl.sipeed.com/MAIX/MaixPy/release/master/) Files with firmware ending in `.bin` or `.kfpkg` >`.kfpkg` is actually a packaged version of multiple `.bin` files, which can be packaged using `kflash_gui` or [manual packaging](http://blog.sipeed.com/p/390.html) ![MaixPy Firmware Type](../../assets/maixpy/firmware_type.png) Firmware naming instructions: File name Description Remarks `maixpy_vx.y.z_x_xxx*.bin` The default version of MaixPy firmware, contains most of the functions, supports connection to `MaixPy IDE`, Factory default firmware version `maixpy_vx.y.z_x_xxx*_m5stickv.bin` Firmware customized for M5Stickv, supports connection to `MaixPy IDE` — `maixpy_vx.y.z_x_xxx*_with_lvgl.bin` MaixPy firmware, supports connection to `MaixPy IDE`, with LVGL version. (LVGL is an embedded GUI framework, which is needed when writing interfaces) — `maixpy_vx.y.z_x_xxx*_minimum.bin` MaixPy minimum set of firmware, does not support `MaixPy IDE`, does not include `OpenMV` related algorithms and various peripheral modules — `maixpy_vx.y.z_x_xxx*_minimum_with_ide_support.bin` The smallest set of MaixPy firmware, supports connection to `MaixPy IDE`, does not include `OpenMV` related algorithms and various peripheral modules Run various models, it is recommended to use this `elf_maixpy_vx.y.z_x_xxx*.7z` elf files, ordinary users don’t need to care, used for crash debugging — `face_model_at_0x300000.kfpkg` Face model, placed at address 0x300000, can be downloaded separately from `.bin` for multiple downloads without conflict — ## Download the firmware to the development board * Open the `kflash_gui` application * Then select the firmware, setting options, and click to download. For more feature introduction and usage instructions, please refer to [kflash_gui project homepage](https://github.com/sipeed/kflash_gui) When using, please note that the serial port cannot be occupied by other software, select the correct development board and serial port number, you can appropriately reduce the baud rate and use the low speed mode to improve the download success rate ![](../../assets/kflash_gui/kflash_gui_download.png) ![](../../assets/kflash_gui_screenshot_download.png) > For the earliest `Maix Go`, if you confirm that the options are correct and you still cannot download, you can try to turn the three phase dial button to the `Down` position and keep downloading ### Sipeed RV JATG debugger [Sipeed USB JTAG/TTL RISC V debugger STLINK V2 STM8/STM32 simulator](https://item.taobao.com/item.htm?spm a1z10.3 c.w4002 21231188706.40.505a5d544ooyDY&id 595953803239) **FAQ of Programming FAQ** If you are using `kflash_gui` to burn the following problems ![Upgrade Error](../../assets/kflash_gui/kflash_gui_upgrade_error.png) You can check in the following order * Check if the `PC` has permission to open the port. For `win10`, you need to run `kflash_gui` as an administrator. * Check whether the port is selected correctly (if there are two device ports, usually choose the one with the smaller port number). * Check whether the port is occupied by other applications (such as `Maixpy ​​IDE`, `putty`, etc.), and other applications should be closed. * Check if the device is selected correctly. For `Maix Bit2.0` (including M1n module), `Maix Bit (with Mic )` should be selected. > Supplementary note: Regarding the problem of Maix Bit 2.0 two serial ports > > * Only one of the serial ports is valid for serial communication and ISP download programs. > * Maix Bit communicates with the PC through a serial port, through the CH552T chip to realize the USB virtual serial port function, and the chip can virtualize two serial ports, in Maix Bit (M1n module backplane), we only use one serial port, but some k210 products Both serial ports are used."},"/soft/maixpy/en/get_started/env_install_driver.html":{"title":"Install USB driver","content":" title: Install USB driver keywords: maixpy, k210, AIOT, edge computing desc: maixpy install USB driver Before officially using MaixPy, we need to install the serial port driver before proceeding with the next development and use; because the board is connected to the computer through a USB to serial device (K210 has no USB hardware support function). Install the driver according to the board's USB to serial chip model. > Operate the serial port under `Linux` or `Mac`, if you don’t want to use the `sudo` command every time, execute `sudo usermod a G dialout $(whoami)` to add yourself to the `dialout` user group, May need to log off or restart to take effect Description of the USB to serial port IC on the existing development board Development board model USB to serial port IC Description Installation tutorial Maix Go STM32 STM32 USB Driver [Go](install_driver/go.html) Maix Dock CH340 [Dock](install_driver/dock.html) Maix Duino CH552 CH552 USB Driver [Duino](install_driver/duino.html) Maix Bit CH552 (new version)/CH340 (old version) CH552 USB Driver [Bit](install_driver/bit.html) Maix Cube GD32(new version)/CH552(old version) CH552 USB Driver [Cube](install_driver/ft2232.html) Maix Amigo GD32 GD32 USB Driver [Amigo](install_driver/ft2232.html) Maix Nano CH552 CH552 USB Driver [Nano](install_driver/nano.html) Grove AI HAT GD32 GD32 USB Driver [Amigo](install_driver/ft2232.html) > Use the CH340 IC board to directly install the CH340 driver, and all others use the special driver. ## About the troubleshooting of USB serial ports If you do not see the serial port, please troubleshoot hardware problems in the following order. If there is a ding dong sound when plugged in to the computer, such as the sound of USB driver loading when the USB flash drive is inserted, it does not indicate that there is a problem with the serial chip on the hardware. Replace the cable and try again, replace the computer's USB port and try again, but still can't be loaded, replace the computer to confirm. If there is no way to burn the firmware, please troubleshoot hardware problems in the following order. Use serial port tool to check whether there is maixpy ​​firmware in the hardware Set 115200 baud rate to connect to the serial port, press the reset button (RST) to receive the data from the chip, no matter what it is, it means that the serial port chip is working normally, if not, it means the hardware is abnormal. Based on the above, proceed to burn the firmware. Before burning, press the BOOT button of the hardware and then press the reset button, then release the BOOT button. At this time, the burning will proceed normally. If not, the Flash is damaged. You can try to burn to SRAM. If the programming fails, it means the serial port chip is abnormal. If you still can’t solve the problem when you get here, the hardware is indeed defective ### Introduction to K210's programming mechanism We often call this a one key download circuit, which means that it can easily control the BOOT and RST pins through the completion of the RST and DTR of the control serial port to enter the burning mode. As described above, the hardware circuit is expected to be automatically completed by humans. Press RST after BOOT. This is strongly related to the hardware implementation. Based on this, the TX and RX data transmission will be carried out, so we actually need to use the function pins of the UART serial port. There are multiple types of triggers in Kflash. We can simply divide them into several types, low speed 115200 and high speed 1.500000 baud rate. The difference is based on the programming methods that match these two types of baud rates. Point, if you find that the download process fails, you can appropriately reduce the baud rate. This is caused by the unstable operation of the serial port chip, and the selection of the layout in the tool will only affect the triggering of the first stage of the programming mode, and after that The configured baud rate will be used in the programming firmware, usually not exceeding the communication programming speed with the flash, which is usually 50~60 KB/S. If you find that you cannot enter the programming mode anyway, either the programming version does not match, or there is a problem with the DTR RST pin of the serial chip (physically)."},"/soft/maixpy/en/get_started/env_serial_tools.html":{"title":"Use serial port tools","content":" title: Use serial port tools keywords: maixpy, k210, AIOT, edge computing desc: maixpy use serial port tool ## Connect the hardware Connect the Type C cable, one end of the computer and the other end of the development board Check whether the device has been correctly identified: Under Linux, you can use `ls /dev/ttyUSB*` or `ls /dev/ttyACM*` to check. If not, you can look for it with `ls /dev`. The specific device name is related to the serial port chip and driver. Use `sudo dmesg` to see if there is a device mount record In Windows, you can open the Device Manager to view If the device is not found, you need to confirm whether the driver is installed and the contact is good ## Use serial port tool ### Windows Commonly used serial terminal software for Windows includes [putty](https://www.putty.org/), [mobaxterm](https://mobaxterm.mobatek.net/), [xshell](https://xshell.en .softonic.com/) and other tools Putty Then select the serial port mode, then set the serial port and baud rate, and open the serial port. ![](../../assets/get_started/putty.png) Then click the Enter key, you can see the interactive interface of MaixPy `>>>` Type `help()` to view the help > Source of the above picture: [laurentopia's tutorial](https://github.com/laurentopia/Learning AI/wiki/MaixPy) Mobaxterm [MobaXterm](https://mobaxterm.mobatek.net/) is a very easy to use multi function terminal software under Windows (of course it also includes a serial terminal) ![Mobaxterm](../../assets/get_started/mobaxterm_serail_port.png) ![Mobaxterm](../../assets/get_started/mobaxterm.png) ### Linux Use tools such as `minicom` (recommended) or `screen` #### minicom ``` sudo apt update sudo apt install minicom sudo minicom s # Then follow the prompt to set the serial port number and baud rate 115200, etc., if you don’t understand, you can use the search tool to search # Set Backspace to DEL function # Set linewrap to Yes sudo minicom ``` Note that saving the default configuration file of minicom requires sudo permission, so use `sudo minicom s` ![minicom setting](../../assets/get_started/minicom_setting.png) ![minicom setting2](../../assets/get_started/minicom_setting2.png) Press `A` here to set up the device Press `E` to set the baud rate, the baud rate needs to be set to `115200` ![minicom setting3](../../assets/get_started/minicom_setting3.png) Press `A` and `R` here to switch the settings to the same as the settings in the figure. The first is to use the `pye` editor shortcut keys to not conflict with each other, and the second setting of automatic line wrapping is to display the complete output. Save and exit after setting. You don’t need to set it again next time. Just execute `sudo minicom`. If you don’t want to use `sudo` command every time, execute `sudo usermod a G dialout $(whoami)` Just add yourself to the `dialout` user group, you may need to log out or restart to take effect. Note that `sudo minicom s` still needs `sudo` if you need to modify the default configuration file After entering `minicom`, click the enter key or the reset button of the development board, you can see the interactive interface of MaixPy ![minicom](../../assets/get_started/minicom.png) Type `help()` to view the help To exit `minicom`, press `Ctrl+A` `X`, press `Enter` to confirm exit > In addition, the serial port number may change during the development process. You can specify the serial port number when executing minicom, so you don't need to set it every time the serial port number changes, for example: `minicom D /dev/ttyUSB1 b 115200 `"},"/soft/maixpy/en/get_started/get_started_power_on.html":{"title":"MaixPy Development Board Power","content":" title: MaixPy Development Board Power keywords: maixpy, k210, AIOT, edge computing desc: maixpy MaixPy development board power When we get the MaixPy development board ## Check the hardware Check whether the hardware is damaged, and whether the camera and the screen are connected properly. Do not connect the cable reversely. ## Connect the hardware Connect the Type C cable, one end of the computer and the other end of the development board Check whether the device has been correctly identified: In Windows, you can open the Device Manager to view Under Linux, you can use `ls /dev/ttyUSB*` or `ls /dev/ttyACM*` to view, if not, you can search for `ls /dev`. The specific device name is related to the serial port chip and driver If the device is not found, you need to confirm whether the driver is installed and the contact is good After power on, if it is a new factory development board, it may display a red background. The foreground is a simple MaixPy introduction, including the official website address. The screen is still, and it needs to be changed by the following programming. ## Check the firmware version Use **Serial Terminal** to open the serial port, and then reset, see the output version information, and [github](https://github.com/sipeed/MaixPy v1releases) or [master branch](http://dl. sipeed.com/MAIX/MaixPy/release/master/) firmware version comparison, consider upgrading to the latest version according to the current version such as: ```python [MaixPy] init end __ __ _____ __ __ _____ __ __ \\/ /\\ _ _ \\ \\ / / __ \\ \\ \\ / / \\ / / \\ \\ V / __) \\ \\_/ / \\/ / /\\ \\ > < ___/ \\ / / ____ \\ _ _ /. \\ _ _ /_/ \\_\\ _____ /_/ \\_\\ _ _ Official Site: https://www.sipeed.com Wiki: https://maixpy.sipeed.com MicroPython v0.5.0 12 g284ce83 on 2019 12 31; Sipeed_M1 with kendryte k210 Type \"help()\" for more information. ``` **View version number:** The version here is `v0.5.0 12 g284ce83`, you can also use the following code to view the version > **Note:** The firmware can be obtained from the download site [dl.sipeed.com](http://dl.sipeed.com/MAIX/MaixPy/release/master/) ```python import sys print(sys.implementation.version) ``` If you encounter problems during the development process, you can also try to update the firmware to the latest version first ## Execute code * After opening the serial port terminal, press the reset button of the development board to see the printed boot information and output ```shell >>> ``` That is, we are waiting for us to enter the code. If there is no such symbol, there may be a program running automatically when booting up. You can press `Ctrl+C` to cancel the running program * Then enter the program to execute ```python >>> print(\"hello world\") hello world >>> ``` ## Paste and execute multiple lines of code When we have multiple lines of code copied from other places, such as ```python import os f os.listdir() print(f) ``` * Copy the code first * Press `Ctrl+E` on the serial terminal * Paste the code * Press `Ctrl+D` (note that if you did not press `Ctrl+E` before, it is a software reset command, MaixPy will soft reset), and then you can see all the codes are executed ```python >>> ['boot.py','main.py','freq.conf'] >>> ``` > If the amount of data is relatively large, the serial port may lose data, which will result in a syntax error. You can try several times"},"/soft/maixpy/en/get_started/get_started_cam_lcd.html":{"title":"First program: Use screen and camera","content":" title: \"First program: Use screen and camera\" keywords: maixpy, k210, AIOT, edge computing desc: \"maixpy first program: use screen and camera\" The development board has a matching camera and screen, please check whether the hardware connection is correct before powering on(**Align according to the No. 1 pin marked on the cable**) Then power on, open the serial terminal, press the keyboard `Ctrl+E`, and paste the following code: ```python import sensor, lcd sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) sensor.skip_frames() lcd.init(freq 15000000) while(True): lcd.display(sensor.snapshot()) ``` Press the keyboard `Ctrl+D` to start running the code You will find that the screen is lit, and the picture taken by the camera is displayed If it displays `reset fail`, the camera is not connected well, or the camera is damaged, or check whether an unsupported camera is used The meaning of the above programs can be found in the API manual, which can be found in the directory on the left, or you can use the search box in the upper left corner to search. Now explain the above program: * `import sensor, lcd`: first import the built in `sensor` (camera) library and `lcd` (screen) library * `sensor.reset()`: Initialize the camera. If it fails, check the hardware * `sensor.set_pixformat(sensor.RGB565)`: Set the camera to `RGB565` format, the default is to use `RGB565` * `sensor.set_framesize(sensor.QVGA)`: The resolution is `QVGA`, that is, `320x240` * `sensor.run(1)`: start to run, it is not necessary to call it in the current version, the camera will automatically start to run after the above settings are completed * `sensor.skip_frames()`: The image quality is not stable when the camera is just started, so some images are skipped * `lcd.init(freq 15000000)`: Initialize the LCD, here is a parameter called `freq`, frequency, which specifies the clock frequency for driving the LCD, here is `15MHz`, which can be adjusted according to the hardware performance * `while(True)`: This is a loop, the code inside the loop will be run continuously * `sensor.snapshot()`: fetch a frame of image data from the camera, the return value is an image object * `lcd.display()`: display image to LCD * `lcd.display(sensor.snapshot())`: here is to execute the image acquisition in brackets first, and the return value is directly displayed as a parameter to the LCD"},"/soft/maixpy/en/contribute/app_doc_template.html":{"title":"MaixPy_DOC example tutorial template","content":" title: MaixPy_DOC example tutorial template keywords: maixpy, k210, AIOT, edge computing desc: maixpy MaixPy_DOC example tutorial template This article explains the specifications and precautions followed by document contributors in writing tutorials, please write documents based on this article; If you have any doubts about the template format and content, please go to the project repository [MaixPy_DOC](https://github.com/sipeed/MaixPy_DOC) to submit `ISSUE`. 🙇‍ Thank you for your enthusiastic support! About documentation tools > The document is written using `MarkDown` syntax, and the overall document project is built using `gitbook`; here it is recommended to use `Typora` and `VS Code` with `MarkDown` plug in as a text editor About document storage > Please save the example tutorial document to the path `./MaixPy_DOC/zh (here distinguish Chinese and English, Chinese: zh, English: en)/application/xxx (specific classification, please refer to the subsequent description for classification suggestions)/xxx (specific routine Name, it is recommended to use English name)`.md > It is recommended to use relative links for the pictures referenced in the document, and store the picture files in the folder `[file name].assets` in the same directory as the document; Establish storage path for document classification > The recommended naming (storage path) that is strongly related to hardware peripherals is: `` > The recommended naming (storage path) that is strongly related to image is: `image` > The recommended naming (storage path) strongly related to KPU is: `KPU` > The suggested naming (storage path) of a more comprehensive routine is: `demo` > The following is the content of the document template: # MaixPy Example Tutorial XXX ## I. Overview: > 1. Describe the effect of this routine > > 2. Briefly explain the operation steps > ## Two, preparation: > Explain the hardware and software environment to be prepared Preliminary knowledge Hardware > Graphic description of the development board && peripheral modules used Software > Graphic description of the software tools used, MaixPy version > If you use third party software tools, you can attach the relevant name or download link ### Specific steps ### code ```python xxxxx ``` ### Effect > It is recommended to add pictures to show the actual running effect ## Question && Feedback Contributor description: > Here is an entry point for contributors Author: Contact (Email): Blog:"},"/soft/maixpy/en/contribute/doc_convention.html":{"title":"Document contribution specification","content":" title: Document contribution specification keywords: maixpy, k210, AIOT, edge computing desc: maixpy document contribution specification There are several situations you may need to read this document: * Found that the document is wrong or there is content that needs to be added, and will want to participate in the modification * Submit tutorial/experience/open source project sharing etc. In order to make the document look uniform in style, the content is not repeated and there is no error, and the writing needs to follow the same specification, all contributors **must** write documents according to this article; If you have any doubts about the template format and content, please go to the project repository [MaixPy_DOC](https://github.com/sipeed/MaixPy_DOC) to submit `ISSUE`. 🙇‍ Thank you for your enthusiastic support! ## To participate in the contribution, you need to master the knowledge in advance * Use of git and github * Use of github PR (pull request) There is a brief introduction in the introductory tutorial, please learn by yourself for detailed usage If you are not confident to master these skills, you can submit [issue](https://github.com/sipeed/MaixPy_DOC/issues) to explain the problem or contribute experience, etc. We will help you to add ## Introduction to the file system The document is built using gitbook, and simple and efficient Markdown is used to write content. It is recommended to use `Typora` or `VS Code` with `MarkDown Preview Enhanced` plug in as the document editor The source code of the document is hosted at [github](https://github.com/sipeed/MaixPy_DOC) For the local preview method, see [README.md](https://github.com/sipeed/MaixPy_DOC/blob/master/README.md) of the document source code The documents are available in two languages, Chinese and English, respectively, placed in the `zh` and `en` folders, where `SUMMARY.md` is the directory item on the left side of the document, and the other `md` files are specific document files, root The `assets` directory under the directory contains image resource files common to two languages ## Markdown syntax If you haven’t touched the basic grammar of Markdown, please spend half an hour to learn it. I recommend the github tutorial: [github Markdown Tutorial](https://guides.github.com/features/mastering markdown/) In this article, we need to pay attention to the following points: ### The grammar tags of the heading category must be separated by spaces, and a blank line is required between the headline and the main body, for example: ```markdown ## This is a secondary heading * This is list item 1 * This is list item 2 ``` The following is not correct, and it may cause parsing errors and malformed formats. ```markdown ##This is the secondary title *This is list item 1 *This is list item 2 ``` ### All pages have only one first level title Since the catalog needs to be automatically generated, it is mainly to ensure that the automatically generated catalog is correct. Write each page like this ``` (At least one blank line is required, 2 lines are recommended) ## Level 2 heading 1 (The first level heading cannot be used here, and a # sign cannot be used. There is also no need to write a serial number, the serial number will be automatically generated) ( Skip a line ) text (At least one blank line) ### Third level heading (similar to second level heading, no need to write, it will be automatically generated) text ## Secondary Title 2 text ``` ### Title number All titles **do not need to write a number, **will be automatically generated** for example ``` ## Title One ### Subtitle 1 ## Title Two ``` final effect: ``` 1. Title One 1.1 Subheading 1 2. Title Two ``` If manually written, the final display will be repeated, so be careful! ### Link Due to the large number of pages and the need to link to resources such as pictures, relative paths are used when writing links. For example, the directory structure is as follows ``` assets/ (Put common resource files) pic000.png en/ get_started/ assets/ (Put the common resource file of md file in get_started directory) pic.png get_hardware.md how_to_read.md zh/ ``` If you paste an image in `get_hardware.md`, put the image in the `assets` folder, and use the following code to reference the image ``` ![pic](assets/pic.png) ![pic](../../assets/pic000.png) ``` ### Mixed Chinese and English When writing Chinese documents, try to use spaces to separate Chinese mixed with English, and try to use full width symbols for punctuation. Mainly to make the document more conspicuous. such as: ```markdown In Micropython, we often use `deinit` to represent the destructor, not to set the default value like STM32 ``` In Micropython, we often use `deinit` to represent the destructor, not to set the default value like STM32 ```markdown In Micropython, we often use deinit to represent the destructor instead of setting the default value like STM32 ``` In Micropython, we often use deinit to represent the destructor instead of setting the default value like STM32 ## table of Contents * Multiple languages ​​are placed in different directories, `en` and `zh` directories * The generated document directory is edited in the folder `SUMMARY.md` of the corresponding language * The source document folder should correspond to a folder as much as possible for a functional module, and the resource files (pictures) should be placed in the `assets` folder directory under the root directory of the corresponding md document, so that both Chinese and English documents can refer to the same pictures and generate The URL is the same, and it is more convenient to add, delete and modify at the same time. * At the same time, in order to be able to use both Chinese and English documents, try not to mark Chinese or English in the picture. You can mark the label, and then the document is explained with the label. The pictures for a specific language are placed in the `assets` directory under the current path: ``` assets/ (Put public resource files, both Chinese and English can be cited) en/ get_started/ assets/ (resource files of md files in the get_started directory, only for English use) get_hardware.md how_to_read.md zh/ ``` ## file name * The file name is special except `README.md`, other file names use lowercase + underscore naming method, such as `get_hardware.md` ## Chinese and English (multilingual) page file directory structure and file name are the same Since there is a multi language switch option in the last generated page, after clicking switch, the same path of the corresponding language will be directly accessed, so the directory structure and file name in Chinese and English must be the same. For example, when English is accessing `en/get_started/how_to_read.md`, after clicking the language switch button, it will automatically visit `zh/get_started/how_to_read.md`, if this file does not exist, it will report a `404` error! ## Contents and links Try to guide readers to use the table of contents, and use the jump links in the text with caution. If the links jump chaotically, the document will look messy and it will be more difficult to read. ## Module documentation content * The header of the file contains module introduction, resource introduction, usage notes, and routines * Need to point out the constructor, function, constant, etc. * **Note that you can't be lazy, just simply translate the function name again, you need to explain in detail the function of the function, the value range of the parameters and the points of attention** ## Multi version management In addition to supporting Chinese and English (multi language) documents (not automatic translation, manual modification is required), multi version management is also done. Each version is a branch, and there are requirements for the branch name, which are: * `master` branch is the main branch * `dev` branch is the development branch * Other historical versions of releases start with lowercase `v`, for example, create a branch called `v1.2` After creating a new branch, you need to modify the version link in `book.json` in the directory of each language version, otherwise readers cannot find the entry You can preview locally under the newly created branch (see the root directory `README.md` for preview method). Note that the page previewed at this time is the content of the current branch. If you want to preview the content of other branches locally, you need to switch to other branches before previewing That's it. After confirming that the correct modification is completed, push the branch to the remote (github), the automatic build system will automatically build and publish to the pages branch, and the effect can be seen after the construction is completed and the URL is accessed."},"/soft/maixpy/en/contribute/code_convention.html":{"title":"MaixPy programming specification","content":" title: MaixPy programming specification keywords: maixpy, k210, AIOT, edge computing desc: maixpy MaixPy programming specification This is a development guide for **MaixPy** developers. **MaixPy** as an open source software, it needs to be completed by different people in a cooperative way. This document is a guide for developers. **MaixPy** developers please follow this programming style. At the same time, users who use MaixPy can also use this document to understand some conventions in the MaixPy code so that they can easily grasp the implementation of MaixPy. ## Normative principles [x] Simple, avoid obscure syntax [x] Strict and logical thinking [x] Simple, concise naming and refined code [x] Performance, optimized by algorithm, compiler and hardware ## Directory structure && file name Directory Structure The entire project is divided into subdirectories according to functional modules, and each subdirectory is divided into header files and source file directories to make the structure clear and easy to understand. If the catalog name has no special requirements, please use all lowercase; the catalog name should reflect part of the meaning, and the components directory can reflect the meaning of components. File structure If there is no special requirement for the file name (if you quote other places, you can keep the corresponding name), please use all lowercase. In addition, in order to avoid the problem of duplicate file names, please try not to use generalized and frequently used names in some places. ## Header file definition C language header files need to define a symbol in order to avoid repeated inclusion. Please use the following definition of this symbol style of: ```c #ifndef __FILE_H__ #define __FILE_H__ /* header file content */ #endif ``` That is, \"__\" is used on both sides of the defined symbol to avoid duplication. In addition, it can also be changed according to whether the file name contains multiple words. Use \"_\" to connect. ## File header comment The header of each source file should include the corresponding copyright information, Change Log record: ```c /** * File: maixpy_main.h * This file is part of MaixPy * Copyright 2019 Sipeed Co.,Ltd. MaixPy Development Team * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE 2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ ``` For example, the above form is adopted. ## Structure definition Please use lowercase English names for structure names, and use \"_\" to connect words to words, for example: ```c struct lcd_config { int width; int height; }; ``` Among them, \"{\", \"}\" occupies a line independently, and the following member definitions are defined by indentation. For the type definition of structure, please use the structure name plus \"_t\" as the name, for example: ```c typedef struct lcd_config lcd_config_t; ``` ## Macro definition In MaixPy, please use uppercase English names as macro definitions, and use \"_\" between words to connect, for example: ```c #define MAIXPY_TRUE 1 ``` ## Function name, declaration Please use lowercase English for the function name, and use \"_\" to connect between words. Provide APIs for upper level applications Interface must be declared in the corresponding header file; if the function entry parameter is empty, void must be used as the entry parameter Number, for example: ```c maixpy_err_t lcd_init(void); ``` ## Comment writing Please use English as comments. Using Chinese comments will mean that you need to switch back and forth between Chinese and English input methods when writing code to interrupt the idea of ​​writing code. And the use of English annotations can better communicate with technicians outside of China. There should not be too many comments on the source code. More explanation should be what the code does. Only when individual key points need some corresponding suggestive comments to explain how a complex algorithm works. Comments on the statement can only be written above or on the right, other positions are illegal. ## Indentation and branching Please use 4 spaces for indentation. If there is no special meaning, please branch after \"{\" and use indentation on the next line, for example: ```c if (condition) { /* others */ } ``` The only exception is the switch statement. The switch case statement uses the alignment of the case statement with the switch. E.g: ```c switch (value) { case value1: break; case value2: break; defalut: break; } ``` The case statement is aligned with the previous switch statement, and the subsequent statements are indented. On the branch, if there is no special consideration, please **do not use more than two blank lines in a row** in the code. ## Braces and spaces From the perspective of code reading, it is recommended that each curly brace occupy a separate line instead of following the statement, for example: ```c if (condition) { /* others */ } ``` The matching braces occupies a single line, and the code will have a corresponding level when reading it without confusion. Space It is recommended to leave a space before the non function bracket call to distinguish it from the previous one, for example: ```c if (x < y) { /* others */ } for (index 0; index <MAX_NUMBER; index ++) { /* others */ } ``` It is recommended to leave a space before the brackets (including if, for, while, switch statements involved), and a space between the operator and the string in the operation expression. In addition, do not leave spaces on both sides of the expression in parentheses, for example: ```c if (x < y) { /* other */ } ``` The spaces on both sides of the brackets are not allowed. ## log information In MaixPy, the commonly used log method is printk, and the py terminal is mp_print, and after we increase or decrease the MaixPy function, it is recommended to delete or comment out the unnecessary printk But **note**, the final submitted code cannot contain `printk` and `printf` functions, they can only be used during debugging! ! ! Otherwise it will cause disconnection when using the IDE The log output should be designed to be turned off under normal circumstances (for example, it can be turned on by a variable or macro), and When the log is actually output, the log is an easy way to understand and locate the problem. The \"heavenly book\" log system is bad and unreasonable. ## Function In kernel programming, functions should be as concise as possible and only complete relatively independent simple functions. The implementation of the function should not be too long, and the implementation of the function should be too long. You should reflect on how you can modify (or split) the function to make the function more concise and understandable. ## Use astyle to format code automatically parameter: style allman indent spaces 4 indent preproc block pad oper pad header unpad paren suffix none align pointer name lineend linux convert tabs verbose ## Specification Reference AliOS Things [《AliOS Things Coding Style Guide》](https://github.com/alibaba/AliOS Things/wiki/AliOS Things Coding Style Guide) RT Thread [《RT Thread Programming Style》](https://github.com/RT Thread/rt thread/blob/master/documentation/coding_style_cn.md)"},"/soft/maixpy/en/thanks.html":{"title":"Thanks","content":" title: Thanks keywords: maixpy, k210, AIOT, edge computing desc: maixpy thanks * [MaixPy source code contributor](https://github.com/sipeed/MaixPy v1graphs/contributors) * [MaixPy_scripts sample code contributor](https://github.com/sipeed/MaixPy v1_scripts/graphs/contributors) * [Maixduino source code contributor](https://github.com/sipeed/Maixduino/graphs/contributors) * [MaixPy_DOC document contributor](https://github.com/sipeed/MaixPy_DOC/graphs/contributors)"},"/soft/maixpy/en/how_to_read.html":{"title":"How to read this article correctly","content":" title: How to read this article correctly keywords: maixpy, k210, AIOT, edge computing desc: maixpy how to read this article correctly **Note: Currently the only official document website: [maixpy.sipeed.com](https://wiki.sipeed.com/maixpy)** ## First, please read carefully the directory structure on the left sidebar to take a look at the contents of the document * **Introduction**: MaixPy's introduction, works display, and development history, etc. * **Getting Started**: The introductory tutorial for using MaixPy, including the basic knowledge, must be read to avoid many problems and save a lot of time for subsequent development * **Hand in hand tutorial**: Here is a step by step teaching of the use of various functions. It is useful for students who are just getting started and don’t know what to do. Read carefully. * **API Manual**: API manuals of each functional module, convenient to refer to during programming * **Standard Library**: micropython standard library, many APIs are compatible with python3 APIs * **machine**: machine related, restart control, machine UID, and various peripheral control * **Maix**: Some special modules, such as FPIOA, KPU, FFT, etc. * **Built in class**: Built in class written in mpy (short for micropython), which can be found in the source code project * **Machine Vision**: Some machine vision related modules, image sensor lcd is roughly compatible with OpenMV API, but will not be updated with OpenMV in real time later * **Additional Peripheral Modules**: The use of some peripheral modules, such as touch screen, ultrasonic, LED lights, etc. * **Built in applications**: Built in applications, such as NES game console (FC gamer), pye (built in document editor) * **Frequently Asked Questions FAQ**: Summary of frequently asked questions * **Advanced**: Some advanced gameplay, and how to participate in the modification of the document and the modification of the source code, or the contribution of the routine * **Community & Sharing**: Collect some good tutorials, works, open source projects, etc. from the community. You can also share your own works or tutorials according to the contribution instructions ## Important must read part **Introduction** and **Getting Started Guide**, be sure to read them completely, and you must read it first if you encounter problems **FAQ** ## Start learning * Just contact, you can read carefully from top to next page according to the table of contents on the left sidebar, just follow along, don’t skip the entry! ! ! * Learn how to update the firmware and how to write code. It is also very important to learn how to use a serial terminal. It is not recommended to rely too much on the IDE, especially when the program dies, the terminal may get more error messages, which is more conducive to solving the problem. When encountering problems and asking questions in the community, try to give complete information about the terminal operation * Each module/library document is accompanied by a simple routine at the end, or here: [MaixPy_script](https://github.com/sipeed/MaixPy v1_scripts) to find the examples you need, you can try to run it to see the effect ## Learn to search * Regarding the interface and parameters of the module, please refer to it according to your needs when using it. **There is a search box** in the upper right corner, which can be used well. At the same time, you can also use the browser's page search function, that is, press the keyboard <kbd> Ctrl +F </kbd>, then enter the content to be searched and press the confirm key * Please don’t worry if there is anything you can’t find, you can go to the [issue](https://github.com/sipeed/MaixPy v1issues) page of github to find (search and search) if anyone has mentioned it , If not, you can create a new issue, or go to [Forum](https://bbs.sipeed.com) to search for the issue, and don’t ask for help anymore, or contact technical support. ## FAQ of this document * PDF generation is added to the document, but try not to spread the PDF version, because the PDF cannot be updated in time after the content is updated, try to visit this website (`https://maixpy.sipeed.com`) to view the document * If the web page loads slowly, please try to refresh or wait, or change the line (try using a proxy or changing mobile phone data) * This document has two domain names: [`https://maixpy.sipeed.com`](https://wiki.sipeed.com/maixpy) and [`https://cn.maixpy.sipeed.com`](https://wiki.sipeed.com/maixpy), you can visit the other if you can’t access one * The document uses gitbook to automatically generate static pages from markdown. If you encounter some pages that cannot be accessed, please check whether the URL (path) is correct, and you can return to the home page ([`maixpy.sipeed.com`](https://wiki.sipeed.com/maixpy)) and enter again. For example, this URL is caused by a poor network condition and a quick click: ``` http://localhost:4000/zh/zh/how_to_read.html ``` The correct URL should be: ``` http://localhost:4000/zh/how_to_read.html ``` ## MaixPy FAQ * For frequently asked questions, please see [FAQ](./others/maixpy_faq.html) ## Other tutorials * In addition to the documentation, you can also browse [blog](http://blog.sipeed.com), tutorials written by [BBS](https://bbs.sipeed.com) users, or Baidu search, and various developers’ Blogs, there will be many development tutorials, development diaries, etc., you can refer to ## Questioning skills Ask questions in various places, whether it’s github or QQ groups, forums, or emails. When asking questions, try to provide complete steps to reproduce the problem. You should use the process you have gone through, how the problem occurred, and what the phenomenon is It must be fully explained. Don't be afraid of too many words. Think about the problem from the perspective of the solver. Can the developer solve the problem? It is convenient for developers to test and solve problems during their busy schedule! For more details, please see the next section [How to ask questions elegantly](./how_to_ask.html)"},"/soft/maixpy/en/index.html":{"title":"Introduction of MaixPy-v1","content":" title: Introduction of MaixPy v1 keywords: maixpy, k210, AIOT, edge computing desc: maixpy Introduction to MaixPy v1 documentation <div style \"font size: 1.2em;border: 2px solid green; border color:#c33d45;padding:1em; text align:center; background: #c33d45; color: white\"> <div> <span>The new version of MaixPy (v4) is now live, with full Python3 support, and more powerful features, see:</span> <a target \"_blank\" style \"color: #ffe0e0\" href \"https://wiki.sipeed.com/maixpy\"> wiki.sipeed.com/maixpy </a> <br> <div style \"height:0.4em\"></div> <span>New hardware product MaixCAM, major performance upgrade, see:</span> <a target \"_blank\" style \"color: #ffe0e0\" href \"https://wiki.sipeed.com/maixcam\"> https://wiki.sipeed.com/maixcam </a> </div> <div style \"padding: 1em 0 0 0\"> <a style \"color: white; font size: 0.9em; border radius: 0.3em; padding: 0.5em; background color: #a80202\" href \"https://item.taobao.com/item.htm?id 784724795837\">Taobao</a> <a style \"color: white; font size: 0.9em; border radius: 0.3em; padding: 0.5em; background color: #a80202\" href \"https://www.aliexpress.us/item/1005006912917562.html\">AliExpress</a> </div> </div> **The Maix I K210 series is being phased out; if you are planning to purchase a K210, please choose the MaixCAM immediately;** **K210 users are also encouraged to upgrade to MaixCAM** **In this document (under the path https://wiki.sipeed.com/soft/maixpy/en/), all references to MaixPy specifically refer to MaixPy v1.** <br> <br> <div class \"title_pic\"> <div class \"logo_maixpy\"> <img src \"../assets/maixpy/maixpy.png\" alt \"maixpy ​​logo\"> </div> <span class \"logo_sipeed\"> <img src \"../assets/sipeed/sipeed_logo_4.svg\" alt \"sipeed logo\"> </span> <span class \"logo_mpy\"> <img src \"../assets/maixpy/micropython.png\" alt \"micropython logo\"> </span> <br /> </div> <table role \"table\" class \"center_table\"> <thead> <tr> <th>Site navigation</th> <th>Address</th> </tr> </thead> <tbody> <tr> <td><strong>MaixPy v1</strong> official document website</td> <td><span class \"limit_width\">Official website:</span> <span class \"\"><a href \"https://wiki.sipeed.com/soft/maixpy/en/\" rel \"nofollow\"><strong>wiki.sipeed.com</strong></a></span><br><span class \"limit_width\">Chinese site: </span><span class \"\"><a href \"https://cn.maixpy.sipeed.com\" rel \"nofollow\"><strong>cn.maixpy.sipeed.com</strong></a></span> <br><span class \"limit_width\">English site: </span><span class \"\"><a href \"https://wiki.sipeed.com/soft/maixpy/en/\" rel \"nofollow\"><strong>en.maixpy.sipeed.com</strong></a></span> </td> </tr> <tr> <td><strong>MaixPy v1</strong> demo repository</td> <td><span class \"limit_width\">github:</span> <span class \"\"><a href \"https://github.com/sipeed/MaixPy v1_scripts\"><strong>github/maixpy_script </strong></a></span> <br><span class \"limit_width\">Domestic:</span><span class \"\"><a href \"https://gitee.com/Sipeed/maixpy_scripts \" rel \"nofollow\"><strong>gitee/maixpy_scripts</strong></a></span></td> </tr> <tr> <td>MaixPy v1 source code</td> <td><span class \"limit_width\"></span><span class \"\"><a href \"https://github.com/sipeed/MaixPy v1\"><strong>github: MaixPy v1</strong> </a></span></td> </tr> <tr> <td>Hardware data download</td> <td><span class \"limit_width\"></span><span class \"\"><a href \"http://dl.sipeed.com/MAIX/HDK\" rel \"nofollow\"><strong> dl.sipeed.com</strong></a></span></td> </tr> <tr> <td>Sipeed WIKI</td> <td><span class \"limit_width\"></span><span class \"\"><a href \"https://wiki.sipeed.com\" rel \"nofollow\"><strong>wiki.sipeed. com</strong></a></span></td> </tr> </tbody> </table> ## About MaixPy v1 [**MaixPy**](https://maixpy.sipeed.com/zh/wiki.sipeed.com/maixpy) is to port [Micropython](http://micropython.org/) to [K210](https://canaan creative.com/product/kendryteai) (a 64 bit dual core RISC V CPU with hardware FPU, convolution accelerator, FFT, Sha256) is a project that supports the normal operation of the MCU and integrates hardware acceleration. `AI` machine vision and microphone array, `1TOPS` computing power core module is less than `￥50`, in order to quickly develop intelligent applications in the field of `AIOT` with extremely low cost and practical size. > MicroPython is a parser based on the grammar of Python3. It contains most of the basic grammar of Python3. It mainly runs on embedded chips with limited performance and memory. (Note that Micropython does not include all the syntax of Python3) **MaixPy** makes programming on K210 easier and faster. We also open source the source code on [**github**](https://github.com/sipeed/MaixPy) There are many interesting things you can do with MaixPy. Specifically, you can <a href \"what_maix_do.html\" target \"_blank\">look here</a> ## Concise code example For example, if we need to scan the devices on the **I2C** bus, there is no need for complicated development environment and engineering, just send the following code through the serial port to achieve: ```python from machine import I2C # Import built in library i2c I2C(I2C.I2C0, freq 100000, scl 28, sda 29) # Define an I2C object, use I2C0, frequency 100kHz, SCL pin is IO28, SDA pin is IO29 devices i2c.scan() # call function to scan device print(devices) # print device ``` Similarly, we need to implement a **breathing light**, just the following code: > `board_info` is related to the board, and different board configurations are different. [Manual configuration](api_reference/builtin_py/board_info.html) is required before use. ```python from machine import Timer,PWM from board import board_info import time tim Timer(Timer.TIMER0, Timer.CHANNEL0, mode Timer.MODE_PWM) ch PWM(tim, freq 500000, duty 50, pin board_info.LED_G) duty 0 dir True while True: if dir: duty + 10 else: duty 10 if duty>100: duty 100 dir False elif duty<0: duty 0 dir True time.sleep(0.05) ch.duty(duty) ``` **Real time photos**: ```python import sensor import image import lcd lcd.init() sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) while True: img sensor.snapshot() lcd.display(img) ``` **AI Object Detection**: ```python import KPU as kpu import sensor sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.set_windowing((224, 224)) model kpu.load(\"/sd/mobilenet.kmodel\") # load model while(True): img sensor.snapshot() # take picture by camera out kpu.forward(task, img)[:] # inference, get one hot output print(max(out)) # print max probability object ID ``` please read doc before run it! ## The content of this document All about MaixPy, including: * How to choose and get a suitable module or development board * How to get started * Library and interface (API) document query * Detailed step by step tutorial * Sharing from the community (tutorial or open source project) **In order to avoid encountering difficult problems during the learning process, please read from top to bottom according to the directory structure on the left, especially the chapters written in the front, do not skip** ## Can run MaixPy development board First of all, we need to choose a development board that suits us. For the MaixPy model of each model, please click: [Development board and accessories purchase guide](./develop_kit_board/get_hardware.html), and there are also hardware parameters and corresponding development boards in the catalog. data To get these boards, you can visit the official website of Sipeed [www.sipeed.com](https://www.sipeed.com/), or [official Taobao shop](https://sipeed.taobao.com/) ## MaixPy source code `MaixPy` source code refers to the `Micropython` parser running on `K210`, written in `C language`, source code is hosted on [github](https://github.com/sipeed/MaixPy), if you just want to use MaixPy, you don't need to know the source code, but you can also give MaixPy project a star [here](https://github.com/sipeed/MaixPy); If you want to participate in the development of MaixPy’s built in functions, you can download for development, and welcome everyone to submit a PR This project is mainly maintained by &copy;<a href \"https://www.sipeed.com\" style \"color: #f14c42\">Sipeed</a> Co.,Ltd., and accepts contributions from the open source community, For specific contributions, see [Contributor List](https://github.com/sipeed/MaixPy v1graphs/contributors) ## Feedback For questions about this document or function or source code, you are also welcome to submit an issue: * [Feedback](https://github.com/sipeed/MaixPy v1issues) ## communicate with If you have any questions, try to submit `issue` to the feedback address above, so that you can leave a record. Others can also check it. Before submitting, search to see if anyone has raised the same issue. The following communication methods provide assistance: <table role \"table\"> <thead> <tr> <th>Communication method</th> <th>Address</th> </tr> </thead> <tbody> <tr> <td>issue(recommend)</td> <td><a href \"https://github.com/sipeed/MaixPy v1issues\">https://github.com/sipeed/MaixPy v1issues</a></td> </tr> <tr> <td>BBS</td> <td><a href \"https://bbs.sipeed.com\" rel \"nofollow\">https://bbs.sipeed.com</a></td> </tr> <tr> <td>MaixPy AI QQ group</td> <td>862340358</td> </tr> <tr> <td>telgram</td> <td><a href \"https://t.me/sipeed\" rel \"nofollow\">https://t.me/sipeed</a></td> </tr> <tr> <td>E mail (commercial cooperation)</td> <td><a target \"_blank\" rel \"noopener noreferrer\" href \"../assets/sipeed/support_email.jpg\"><img src \"../assets/sipeed/support_email.jpg\" alt \" email\" style \"max width:100%;\"></a></td> </tr> </tbody> </table> "},"/soft/maixpy/en/SUMMARY.html":{"title":"Summary","content":" title: Summary keywords: maixpy, k210, AIOT, edge computing desc: maixpy Summary * [Introduction](index.html) * [What can MaixPy do](./what_maix_do.html) * [MaixPy Development History](./maixpy_history.html) * [Thanks](./thanks.html) ## Getting started must see guide * [How to read this article correctly (important!!!)](./how_to_read.html) * [How to ask questions elegantly (important!!!)](./how_to_ask.html) * Development board and accessories selection guide [Development Board Selection Guide (Comparison)](./develop_kit_board/get_hardware.html) Development board introduction [Maix Dock](./develop_kit_board/maix_dock.html) [Maix Bit](./develop_kit_board/maix_bit.html) [Maix Amigo](./develop_kit_board/maix_amigo.html) [Maix Duino](./develop_kit_board/maix_duino.html) [Maix Cube](./develop_kit_board/maix_cube.html) [Maix Go](./develop_kit_board/maix_go.html) [Maix Nano](./develop_kit_board/maix_nano.html) Peripheral modules (accessories) [SP MOD](./modules/sp_mod/index.html) [Grove](./modules/grove/index.html) [Other](./modules/others/index.html) * Basic knowledge [MaixPy Grammar Basics](./get_started/knowledge_micropython.html) [git and github](./get_started/knowledge_git_github.html) [MaixPy image basics](./get_started/knowledge_image.html) [MaixPy Audio Basic Knowledge](./get_started/knowledge_audio.html) * Development environment preparation [Install Driver](./get_started/env_install_driver.html) [Maix Dock](./get_started/install_driver/dock.html) [Maix Bit](get_started/install_driver/bit.html) [Maix Amigo](get_started/install_driver/amigo.html) [Maix Cube](get_started/install_driver/cube.html) [Maix Go](get_started/install_driver/go.html) [Maix Nano](get_started/install_driver/nano.html) [Update MaixPy firmware](./get_started/upgrade_maixpy_firmware.html) [Use serial terminal tool](./get_started/env_serial_tools.html) [MaixPy IDE Instructions for Use](./get_started/env_maixpyide.html) Update WIFI module firmware [Update onboard ESP32 firmware](./get_started/upgrade_esp32_firmware.html) [Update onboard ESP8285 firmware](./get_started/upgrade_esp8285_firmware.html) * Get started [Power on](/get_started/get_started_power_on.md) [First program: Use screen and camera](./get_started/get_started_cam_lcd.html) [Second program: turn on the LED](./get_started/get_started_led_blink.html) [Storage System Introduction](./get_started/get_started_fs.html) [Edit and run script](./get_started/get_started_edit_file.html) [Upload script to development board](./get_started/get_started_upload_script.html) [Automatically run script at boot](./get_started/get_started_boot.html) [Development board configuration file](./api_reference/builtin_py/board_info.html) [Getting started video tutorial](./get_started/maixpy_get_started_video.html) * Firmware customization [Why custom firmware is needed](./firmware/why_customize_firware.html) [Online Compile](./firmware/online_compile.html) [Source code compilation](./firmware/compile.html) ## MaixPy hands on tutorial * [Tutorial Description](./course/index.html) * Basic image processing * Image acquisition and display * [Image Acquisition](./course/image/basic/get_images.html) * [Image display](./course/image/basic/display_images.html) * [MaixPy image and common operations](./course/image/basic/vary.html) * [Basic drawing, writing](./course/image/basic/draw.html) * [Hardware accelerated image processing](./course/image/basic/acc_image_deal.html) * MaixPy AI * [Basic knowledge of deep neural networks](./course/ai/basic/dnn_basic.html) * [MaixPy AI hardware acceleration basic knowledge](./course/ai/basic/maixpy_hardware_ai_basic.html) * Image Processing * [Face Detection](./course/ai/image/face_detect.html) * [1000 object classification](./course/ai/image/1000_type_classifier.html) * [Face Recognition](./course/ai/image/face_recognization.html) * [Self learning classification](./course/ai/image/self_learn_classifier.html) * Audio processing * [Speech recognition](./course/speech/recognizer_cnn.html) * Model training * Train your own classification and detection model * [MaixHub Cloud Training](./course/ai/train/maixhub.html) * [Local Training](./course/ai/train/local.html) * Traditional algorithm * Image Processing [Find color blocks](./course/image/find_color_blob.html) [QR code recognition](course/image/find_qrcodes.html) * Audio processing [FFT](course/speech/fft.html) [FFT waterfall chart](course/speech/fft_waterfall.html) [Keyword recognition](./course/speech/recognizer_mfcc.html) * Peripherals * On chip peripherals [I2C](modules/on_chip/i2c.html) [PWM](modules/on_chip/pwm.html) [SPI](modules/on_chip/spi.html) [Timer](modules/on_chip/timer.html) [UART](modules/on_chip/uart.html) [I2S](modules/on_chip/i2s.html) [WDT](modules/on_chip/wdt.html) * [SP MOD](./modules/sp_mod/index.html) [BT Bluetooth transparent transmission](./modules/sp_mod/sp_bt.html) [LoRa Wireless Communication](./modules/sp_mod/sp_lora.html) [RFID Radio Frequency Identification](./modules/sp_mod/sp_rfid.html) [TOF Ranging](./modules/sp_mod/sp_tof.html) [Eink electronic ink screen](./modules/sp_mod/sp_eink.html) [Lcd1.14 IPS screen](./modules/sp_mod/sp_lcd1.14.html) [Weather Weather Module](./modules/sp_mod/sp_weather.html) [Ethernet wired network port](modules/sp_mod/sp_ethernet.html) * [Grove](./modules/grove/index.html) [Ultrasonic Ranger](modules/grove/grove_ultrasonic_ranger.html) [Chainable RGB LED light](modules/grove/grove_chainable_rgb_led.html) [RGB LED Ring strip](modules/grove/grove_rgb_led_ring.html) * More peripherals [Sipeed Microphone Array](./develop_kit_board/module_microphone.html) [Dual camera module](modules/others/binocular_camera.html) [MLX90640 serial infrared lens](modules/others/mlx90640.html) [HTPA infrared lens](modules/others/htpa.html) [Servo](modules/others/servo.html) [ESP32 ADC](./modules/others/esp32_read_adc.html) [onwire single bus](modules/others/onewire.html) * More features * System [Main frequency, reset, etc.](./course/others/system.html) [Memory Configuration and View](./course/others/mem.html) * GUI [Multi language support including Chinese](./course/image/image_draw_font/image_draw_font.html) [Maix UI](./course/others/maixui.html) [Lvgl](./course/others/lvgl.html) [Editor pye](./course/others/pye.html) * The internet [Configure network card](./course/network/network_config.html) [Use socket communication](./course/network/socket_usage.html) * Multimedia [audio](./course/media/audio.html) [video](./course/media/video.html) * Game [NES game console](./api_reference/media/nes.html) ## API Manual * [Standard Library](./api_reference/standard/index.html) [cmath](./api_reference/standard/cmath.html) [gc](./api_reference/standard/gc.html) [math](./api_reference/standard/math.html) [sys](./api_reference/standard/sys.html) [ubinascii](./api_reference/standard/ubinascii.html) [ucollections](./api_reference/standard/ucollections.html) [uctypes](./api_reference/standard/uctypes.html) [uerrno](./api_reference/standard/uerrno.html) [uhashlib](./api_reference/standard/uhashlib.html) [uheapq](./api_reference/standard/uheapq.html) [ujson](./api_reference/standard/ujson.html) [uos](./api_reference/standard/uos.html) [ure](./api_reference/standard/ure.html) [usocket](./api_reference/standard/usocket.html) [ustruct](./api_reference/standard/ustruct.html) [utime](./api_reference/standard/utime.html) [uzlib](./api_reference/standard/uzlib.html) * [machine](./api_reference/machine/index.html) [I2C](./api_reference/machine/i2c.html) [PWM](./api_reference/machine/pwm.html) [SPI](./api_reference/machine/spi.html) [Timer](./api_reference/machine/timer.html) [UART](./api_reference/machine/uart.html) [network](./api_reference/machine/network.html) [WDT](api_reference/machine/wdt.html) * [Maix](./api_reference/Maix/index.html) [FPIOA](./api_reference/Maix/fpioa.html) [GPIO](./api_reference/Maix/gpio.html) [KPU](./api_reference/Maix/kpu.html) [FFT](./api_reference/Maix/fft.html) [I2S](./api_reference/Maix/i2s.html) [freq](./api_reference/Maix/freq.html) [utils](./api_reference/Maix/utils.html) * [helper](./api_reference/builtin_py/index.html) [fpioa_manager](./api_reference/builtin_py/fm.html) [board_info](./api_reference/builtin_py/board_info.html) [Micropython Editor](./api_reference/application/pye.html) * [media](./api_reference/machine_vision/index.html) [lcd](./api_reference/machine_vision/lcd.html) [sensor](./api_reference/machine_vision/sensor.html) [image](api_reference/machine_vision/image/image.html) [video](./api_reference/media/video.html) [audio](./api_reference/media/audio.html) [nes](./api_reference/media/nes.html) [lvgl](./course/others/lvgl.html) [isolated_word](./api_reference/machine_vision/isolated_word.html) [maix_asr](./api_reference/machine_vision/maix_asr.html) * [extend](./api_reference/extend/index.html) [touchscreen](./api_reference/extend/touchscreen.html) [modules.ultrasonic](./api_reference/extend/ultrasonic.html) [modules.ws2812](./api_reference/extend/ws2812.html) [modules.htpa](./api_reference/extend/htpa.html) [modules.onewire](./api_reference/extend/onewire.html) ## Frequently Asked Questions FAQ * [MaixPy Frequently Asked Questions FAQ](./others/maixpy_faq.html) * [MaixHub platform FAQ](./others/maixhub_faq.html) ## Advanced * Advanced development [Source directory structure](./course/advance/project_framework.html) [How to compile MaixPy project](course/advance/compile.html) [How to add a MaixPy module with C](./course/advance/add_c_module.html) [Packing File System](./course/advance/pack_fs.html) * Participate in contribution [Participate in document writing (specification)](./contribute/doc_convention.html) [Code Writing Specification](./contribute/code_convention.html) ## Community & Share [Featured Articles](./share/recommend_articles.html) [Open source project](./share/open_projects.html) Everyone's experience sharing * [Participation in experience sharing/sharing template](./share/my_share/index.html)"},"/soft/maixpy/en/how_to_ask.html":{"title":"How to ask questions gracefully","content":" title: How to ask questions gracefully keywords: maixpy, k210, AIOT, edge computing desc: maixpy how to ask questions gracefully ## When asking questions in various places, you will find several phenomena: * No one answered after asking the question * It took a long time for the question to be answered * The other party always dislikes himself too much ## Before asking questions, make sure that you have already studied Getting Started Guide The **Getting Started** chapter of this document is the basis of the basics of using `MaixPy`, no matter whether you have development experience, a big man or a novice, please be sure to read and operate it from front to back. Many problems will be solved in this process. Don’t ask questions in QQ groups, forums, issues, or emails at the beginning. Many problems explained in the document at the beginning may not receive timely answers from the community, which saves everyone’s attention. Time, but also for a better community environment, everyone grows better together, please understand each other ## When asking questions, try to do the following points, which will greatly increase the probability of the problem being solved quickly: ### Clear the problem, figure out what happened and what I did, including: * What effect and function do I want to achieve? * In order to achieve this effect, how did I do it, and what is the detailed process? * During the implementation process, what error occurred and what was the phenomenon (for example, what error was reported, what was the **complete** error content?) * Have I read the error message carefully? Does the error message indicate the cause and solution of the error? * Based on these error messages and careful thinking, can the problem be solved? * Search for documents, issues, and whether you can find solutions to problems with search engines ### If the problem cannot be solved by yourself, you need to ask others for advice, and you need to consider: * Who to ask, where to ask, who will be more likely to answer my question? And how about real time? * What data and phenomena should I provide him to be willing to help me solve the problem quickly? * Provide my purpose (to let the respondent know what you are doing) * Provide a complete implementation process, as well as the phenomena that occurred in the process (it is convenient for the respondent to follow your process to do it again, that is, the problem reproduces) * Give the wrong place and indicate where the phenomenon or result is different from what you expected! (Let the respondent know where it did not meet expectations) * Provide the error information that appears, it needs to be complete, as many screenshots as possible, more logs, don't cut a small picture stingly, or give a part of the log (because the respondent may not have done this for a long time , Forget some details, you need to quickly recall the screenshots and complete logs; and according to the detailed logs, you can quickly locate the problem) * How can I be more sincere when asking questions? Even if I am noob, everyone is willing to answer ### Question template Ask the question as elegant as possible, without adding extra modal particles, complaining vocabulary, consider every word and punctuation, and think about the question from the perspective of the answerer, how to let the answerer help him solve the problem quickly, the number of words is too few The description is unclear, too many words make people impatient #### Title Wherever you ask (including `QQ group`), draw up a title of about `30` for your question to clarify the central idea of ​​the question, including: * Question category, is it asking questions, submitting bugs, sharing experience, etc. Let everyone know what you want to do on the screen full of text * One sentence to clarify the central idea of ​​the problem, such as `Run the camera sample program, report an error reset fail, it may be a hardware problem` So the title after synthesis can look like this: * `[MaixPy question] Run the camera sample program and report an error reset fail. Could it be a hardware problem? Such a title must **not** appear: * `Ah ah ah ah why my board is not working again` * `Why my code can't run anymore` * `Why is my screen black?` * `[MaixPy question] I received the development board, the development board screen is red, a line of small characters, why? ` * `I run the xxx program and something went wrong` You can ask: * `[MaixPy question] My board cannot be started after I connected the power reversely. How can I tell where the board is burned? If so, how can I save it?`~ * `[MaixPy BUG] pix_to_ai did not convert the last pixel` #### Content First of all, from the perspective of the answerer, if the question is asked: * First of all, we must know what the other party is going to do and what goals to achieve * In order to achieve this goal, where did he refer to the steps to do it * What specific steps were actually taken, and then there was a problem at that step, so I can follow his steps to try to reproduce the phenomenon. If this problem seems to be difficult to solve and there are no steps to reproduce, it may take a lot of time to reproduce. Let’s put it aside and solve other problems first. * What is the specific problem? If he only tells the problem, how do I know what is wrong with him, maybe it is unwell? So this is very important. He needs to explain the phenomenon when the problem occurred, and indicate what is different from the expectation. Otherwise, I have to guess what is the difference between the comparison and the expectation. The time to solve the problem has increased. * If something goes wrong, I may need his log file so that I can look at the source code based on the log for analysis, otherwise it may be difficult to solve the problem, then this problem can be seen later In summary, you can ask questions like this: * Explain in detail your goals, what you want to do, and what the phenomenon should look like * Do I refer to any documents, codes or teaching? * How to reproduce the error: how to do it, write each step in detail until the problem occurs * Explain in detail the phenomenon when the error occurs, and how it is different from what was expected, it is necessary to prove that the problem does occur * Attached log files, screenshots, and even videos. The logs and screenshots must be complete. Don’t just take a small part. The answerer may find some problems you haven’t noticed from your complete logs and screenshots. This is very important ! * In addition, pay attention to the format of the pasted code, don’t display it messy after pasting, and it won’t enter your eyes. Try to copy and run it * Finally, I would like to express my gratitude to the community friends who answered the question"},"/soft/maixpy/en/what_maix_do.html":{"title":"What can MaixPy do","content":" title: What can MaixPy do keywords: maixpy, k210, AIOT, edge computing desc: maixpy What can MaixPy do Most of them integrated to MaixPy, or some of them include in [Maixduino](https://Maixduino.sipeed.com) or from other developers ## Face recognition <iframe width \"560\" height \"315\" src \"https://www.youtube.com/embed/hS_mcGptXeo\" frameborder \"0\" allow \"accelerometer; autoplay; encrypted media; gyroscope; picture in picture\" allowfullscreen></iframe> ## draw picture Turorial <iframe width \"560\" height \"315\" src \"https://www.youtube.com/embed/el6CB h9Lo0\" frameborder \"0\" allow \"accelerometer; autoplay; encrypted media; gyroscope; picture in picture\" allowfullscreen></iframe> ## Openmv and Record video <iframe width \"560\" height \"315\" src \"https://www.youtube.com/embed/fpJZIisYKao\" frameborder \"0\" allow \"accelerometer; autoplay; encrypted media; gyroscope; picture in picture\" allowfullscreen></iframe> ## MobileNet <iframe width \"560\" height \"315\" src \"https://www.youtube.com/embed/9hGWvLRDhrM\" frameborder \"0\" allow \"accelerometer; autoplay; encrypted media; gyroscope; picture in picture\" allowfullscreen></iframe> ## Face detection <iframe width \"560\" height \"315\" src \"https://www.youtube.com/embed/BGctumZuhao\" frameborder \"0\" allow \"accelerometer; autoplay; encrypted media; gyroscope; picture in picture\" allowfullscreen></iframe> ## NES gamer emulator <iframe width \"560\" height \"315\" src \"https://www.youtube.com/embed/y7 hM2UHuNw\" frameborder \"0\" allow \"accelerometer; autoplay; encrypted media; gyroscope; picture in picture\" allowfullscreen></iframe> ## MNIST <iframe width \"560\" height \"315\" src \"https://www.youtube.com/embed/WhJuCODEfpQ\" frameborder \"0\" allow \"accelerometer; autoplay; encrypted media; gyroscope; picture in picture\" allowfullscreen></iframe> ## Play video <iframe width \"560\" height \"315\" src \"https://www.youtube.com/embed/BbrdCNxnxv0\" frameborder \"0\" allow \"accelerometer; autoplay; encrypted media; gyroscope; picture in picture\" allowfullscreen></iframe> ## Feature map display <iframe width \"560\" height \"315\" src \"https://www.youtube.com/embed/jA6JQ3Wevdw\" frameborder \"0\" allow \"accelerometer; autoplay; encrypted media; gyroscope; picture in picture\" allowfullscreen></iframe> ## GBA game emulator <iframe width \"560\" height \"315\" src \"https://www.youtube.com/embed/kPpH_cA83 I\" frameborder \"0\" allow \"accelerometer; autoplay; encrypted media; gyroscope; picture in picture\" allowfullscreen></iframe> ## Game Quake I <iframe width \"560\" height \"315\" src \"https://www.youtube.com/embed/poBBrIWt_HE\" frameborder \"0\" allow \"accelerometer; autoplay; encrypted media; gyroscope; picture in picture\" allowfullscreen></iframe> [source code](https://github.com/elect gombe/quake k210) ## Game Doom <iframe width \"560\" height \"315\" src \"https://www.youtube.com/embed/fRjF498k2r4\" frameborder \"0\" allow \"accelerometer; autoplay; encrypted media; gyroscope; picture in picture\" allowfullscreen></iframe> [source code](https://github.com/elect gombe/k210 doom) ## MMD 3D rendering <iframe width \"560\" height \"315\" src \"https://www.youtube.com/embed/L7xmXQgnf3c\" frameborder \"0\" allow \"accelerometer; autoplay; encrypted media; gyroscope; picture in picture\" allowfullscreen></iframe> <video src \"http://dl.cdn.sipeed.com/k210_mmd.MOV\" controls \"controls\"> your browser does not support the video tag </video> [source code](https://github.com/elect gombe/k210_mmd) ## Gimbal face track <iframe width \"560\" height \"315\" src \"https://www.youtube.com/embed/7bpNVzFbGa0\" frameborder \"0\" allow \"accelerometer; autoplay; encrypted media; gyroscope; picture in picture\" allowfullscreen></iframe> ## Mic array <iframe width \"560\" height \"315\" src \"https://www.youtube.com/embed/Wb2Dnd Wk60\" frameborder \"0\" allow \"accelerometer; autoplay; encrypted media; gyroscope; picture in picture\" allowfullscreen></iframe> ## LittlevGL <iframe width \"560\" height \"315\" src \"https://www.youtube.com/embed/Bcwkg3qOwY8\" frameborder \"0\" allow \"accelerometer; autoplay; encrypted media; gyroscope; picture in picture\" allowfullscreen></iframe> ## FFT spectrum <iframe width \"560\" height \"315\" src \"https://www.youtube.com/embed/HvBVj QgaB8\" frameborder \"0\" allow \"accelerometer; autoplay; encrypted media; gyroscope; picture in picture\" allowfullscreen></iframe>"},"/soft/maixpy/en/others/maixpy_faq.html":{"title":"MaixPy FAQ","content":" title: MaixPy FAQ keywords: maixpy, k210, AIOT, edge computing desc: maixpy MaixPy FAQ ## What are the similarities and differences between MaixPy and C development, and how should I choose MaixPy is a scripting language based on Micropython. It does not need to be compiled and parsed at runtime. It is simpler and more convenient to write, but it is not as real as C language at runtime. So if you are a quick verification, novice, only python, less hair, etc., you can use MaixPy; those who are pursuing extreme performance efficiency or are familiar with C, and those who are not confident about the long term stability of MaixPy can use C language development ## MaixPy IDE cannot successfully connect to the development board **phenomenon:** ​ After getting the development board, I have been unable to connect to MaixPy IDE * Check whether the firmware supports IDE, early firmware and firmware with `minimum` in the name are not supported * Check whether the serial port is occupied (other software also opened the serial port) * After clicking the connection, do not use it with the terminal tool at the same time, otherwise the serial port will be occupied and cannot be opened * If you have been unable to successfully connect successfully, check: * Please check whether the development board model selection is wrong; * Observe whether there is any change on the development board screen, if there is no response, it may be the serial port selection error; * Try to upgrade to the latest [master branch firmware](http://cn.dl.sipeed.com/MAIX/MaixPy/release/master), and the latest MaixPy IDE software > MaixPy version number is lower than 0.5.0_v0 does not support connection to MaixPy IDE ## The document webpage cannot be opened and the speed is slow If you encounter some pages that cannot be accessed, please check whether the URL (path) is correct, and you can return to the home page (`maixpy.sipeed.com`) and re enter. For example, this URL is caused by clicking too quickly: ```shell http://localhost:4000/zh/zh/get_started/how_to_read.html ``` The correct URL should be: ```shell http://localhost:4000/zh/get_started/how_to_read.html ``` In addition, you can try another network line, such as connecting to a proxy, or changing mobile phone data. You can also use `cn.maixpy.sipeed.com` in China. ## The download speed of the download station is slow, and the file cannot be downloaded If you encounter slow download speed at the dl.sipeed.com download station, you can use the domestic synchronization server cn.dl.sipeed.com to download, the path is the same, and it is synchronized once a day; Some files provide CDN download links, which will be faster, for example, IDE has instructions in readme.txt ## Micro SD card cannot be read Micro SD cannot be read phenomenon and solutions: * Confirm whether the SD can be used normally on the computer, if not, the SD is damaged, * The computer can be used normally, read SD, but MaixPy development board cannot be used: SD card is not formatted as MBR partition FAT32 format * The computer can use the SD card normally. It is also confirmed that the disk format of the SD card is FAT32, but the MaixPy development board still cannot be used: Possible reasons: When some SDs leave the factory, there is no disk partition table in the sd, or the disk partition table type is not MBR Solution: Use a third party disk management software to convert the sd partition table type to MBR, and format the sd format to FAT32 > Here **Diskgenius** is used to convert the disk partition table format ![Diskgenius](../../assets/other/diskgenius.png) ![GPT type to MBR](../../assets/other/diskgenius_sd_gpt_to_mbr.png) ![MBR Type](../../assets/other/diskgenius_sd.png) * SD card does not support SPI protocol At present, the hardware can only support SPI protocol reading, try to buy a regular card For example: the two cards on the left side of the picture below are not supported by MaixPy drivers, the middle and right ones are supported, but the class 10 card in the middle has the fastest speed (up to 128GB tested and available) > I have also tested several SanDisk, Kingston, and Samsung cards purchased online, and found that one of the Samsung cards cannot be used ![](../../assets/hardware/other/tf_sdcard.png) ## How much capacity does the SD card support? We have tested that **`1TB`** storage capacity SD card is OK ## Use SD to load file, model is unsuccessful Phenomenon: We may encounter errors when loading the model during use. Possible cause of the problem: sd is not compatible and the mount is unsuccessful Verify whether the SD card is mounted: ```python import os print(os.listdir(\"/\")) >>['flash'] # SD card is not mounted >>['flash','sd'] # Successfully mount the SD card ``` ## Why is the frame rate reduced a lot when the IDE is connected K210 has no USB peripherals, so it can only use the serial port to communicate with the IDE. The speed is not as fast as the USB device, so it will affect the frame rate. You can turn off the IDE camera preview ## Why the camera image previewed on the IDE is blurry K210 has no USB peripherals, so it can only use the serial port to communicate with the IDE. The speed is not as fast as the USB device. Therefore, the picture is compressed. If you need to see a clear picture, please watch it on the screen of the development board, or save it as a picture and upload it to the computer View Therefore, the image preview function of the IDE is mainly for teaching and demonstration. It is usually recommended to use the screen. You can use the following code to set the preview quality ```python sensor.set_jb_quality(95) ``` This sets the quality of the preview image to 95%, but the frame rate will be significantly reduced ## How to increase the camera frame rate * Change to a better camera. For example, the frame rate of `ov7740` will be higher than that of `ov2640`. But the premise is that the camera circuit must be compatible with the circuit of the development board * Increase the camera clock frequency (`sensor.reset(freq )`), but be careful not to be too high, too high will make the picture worse * You can compile the source code yourself, turn on the camera double buffering option (by default), and `sensor.reset(dual_buff True)`, the frame rate will increase, but the memory consumption will increase accordingly (approximately 384KiB) ## IDE frame buffer imaging direction is incorrect, LCD display direction is incorrect Since MaixPy supports many hardware models, the display direction will be incorrect when using MaixPy IDE or LCD display, then we need to rotate the image at this time; Before correcting the display direction, we need to confirm whether the sensor direction is rotated (the image in the upper right corner of MaixPy IDE is the image directly output by the Sensor) or the LCD direction is rotated Correction method: Sensor direction correction: ```python # Set camera horizontal mirroring # `enable`: 1 means to turn on horizontal mirroring 0 means to turn off horizontal mirroring sensor.set_hmirror(enable) # Set the camera to mirror vertically # `enable`: 1 means turn on vertical mirroring 0 means turn off vertical mirroring sensor.set_vflip(enable) ``` lcd direction correction: ```python # Set `LCD` screen orientation # Parameters: `dir`: value range [0,3], rotate clockwise from `0` to `3` # Return value: current direction, value [0,3] lcd.rotation(dir) # Set whether `LCD` is mirrored # Parameters: `invert`: Whether to display in a mirror, `True` or `False` # Return value: The current setting, whether it is mirrored or not, returns `True` or `False` lcd.mirror(invert) ``` ## After burning MaixPy, K210 boots fail Phenomenon: We may encounter MaixPy cannot be started after burning MaixPy (it appears that the screen cannot be turned on, the screen shows white, etc.). The cause of the problem: A large part of this phenomenon is that the configuration file in the internal file system is read incorrectly, or the system configuration value we set (such as the gc heap value is too large) is incorrect and the system cannot be started. Solution: Erase the file system (erase all flash) Use kflash_gui to select the `erase` function in the upper right corner, then load the `MaixPy file system` template, the address becomes `0xD00000`, and the length becomes `3MiB` Or reburn the erase firmware: Click to download [K210 chip_erase.kfpkg](https://dl.sipeed.com/fileList/MAIX/MaixPy/release/Erase_all/K210 chip_erase.kfpkg) After erasing device do remember to reburn your target firmware ## Using JTAG debugger has been unable to connect to K210 Phenomenon: Using bare metal to develop K210, JTAG debugger has been unable to connect to K210 possible reason: 1. There is a problem with the OpenOCD debugging environment (the details are not explained here) 2. After burning key_gen.bin, the JTAG debugging function of K210 will be permanently disabled ## After downloading and saving the script to MaixPy internal flash, the board cannot update the firmware and cannot start the script Possible phenomenon: After downloading and saving the script to MaixPy internal flash, the board cannot update the firmware, and the board cannot start > The problem can be located from the hardware and software: Possible hardware reasons: ​ TODO: To be updated Possible software reasons: 1. GPIO16 is pulled up in the program, which causes the automatic download point circuit to fail to pull down GPIO16, making K210 enter ISP mode ## kflash cannot burn/update MaixPy firmware kflash_gui configuration options Development board model The wrong development board model is selected Burning space (SRAM/Flash) Wrong selection of burning space Baud rate & download speed mode Download baudrate is too high ## An error: type object 'board_info' has no attribute 'XX' Visit [Board_config](./../get_started/board_info.html) to reconfig your board. ## TF card format is right, but can't read tf card anf failed mount Use following to remount: ```python from machine import SDCard SDCard.remount() ``` Using following code to check whether succeed mounting tf card: ```python def sd_check(): import os try: os.listdir(\"/sd/.\") except Exception as e: return False return True print(sd_check()) ``` ## ValueError:[MAIXPY]kpu: load error:2002, ERR_KMODEL_VERSION: onlysupport kmodel V3/V4 now 1. Update firmware, using the latest MaixPy firmware with v3/v4 supported. The update way has been tole before. 2. Check the location you store the model whether matches your read location. For example, if you store the model on sd card, but you read your flash address 0x300000, this error will occour. 3. If you use model named with `.smodel`, you need redownload this model with your own machine key from maixhub. ## No any response when run boot.py in MaixPy IDE If you burn your model on flash, you should run boot.py in serial terminal. If is told `Out of memory`, you should store your model on sd card, then run your code (Make sure your sd card can well be mounted). ## ValueError: [MAIXPY]kpu: load error:2006, ERR. NO_ MEM: memory not enough This error means out of memory, use smaller size firmware to comsume less ram. There will be about 1M memory left because standard firmware consumes 2MB bytes, if you choose firmware which consumes 600kB you will have 3MB bytes memory left. Visit this demo [demo_view_mem.py](https://github.com/sipeed/MaixPy v1_scripts/blob/master/basic/demo_view_mem.py) to see how to know the rest memory. 1. Using mini firmware instead of which you used now, or you need to reduce your dataset used during training 2. Visit [memory manegment](./../course/others/mem.html) to manage your memory amd adjust it by garbage collector. ## OSEerror: [Errno 2] ENOENT This error means the file your code read is not at the correct path. If the file is on sd card, check whether sd card is well mounted. Using following codes to check whether sd card is mounted, it will return false if failling mounting. This maybe because your sdcard is not compatible with this board, or the file system format on sdcard is incorrect(It should be FAT32). It's suggested to use our official sdcard and if it can't work do contact with us we will response you soon. ```python def sd_check(): import os try: os.listdir(\"/sd/.\") except Exception as e: return False return True print(sd_check()) ``` Using following codes to remount ```python from machine import SDCard SDCard.remount() ``` ## Failed to open serial terminal, but it run in IDE 1. Check if the serial port is occupied, because only one application can use a serial port at a time 2. Using serial terminal contained in IDE ## ValueError: [MAIXPY]kpu: load error:2005,ERR_READ_FILE: read filefailed 1. Check if the name of model on sdcard matches it in the code, and its path whether matches. 2. Check whether your model downloaded address matches the load address in your code. ## Operations after burning key_gen.bin After burning key_gen.bin, use serial terminal connects with your board, and press reset key which is on your board. Then you will see a machine code prints out on your serial terminal. Or you can use the [serial terminal](/soft/maixpy/en/get_started/env_serial_tools.html#Use serial port tool) contained in MaixPy IDE connects with your board to see your machine code. After you get your machine code, you need to reburn your corresopnding firmware to reuse your board. ## Camera is not clear If you are using OV5642 while it doesn't shows very clear, you can adjust its focal length by rotating the lens. If the other camera is not very clear, you can do the same operation to adjust its focal too. But there is a limit to the camera display effect, so maybe sometiomes we can juse use other camera to get better image. ## Display incorrect, like blurred screen, incorrect color or single color Using kflash flashs your board with [K210 chip_erase.kfpkg](https://dl.sipeed.com/fileList/MAIX/MaixPy/release/Erase_all/K210 chip_erase.kfpkg), this will clear all data in your flash. And reburn your firmware to restart your board. When you reburn your model, make sure your model address matches it in your code. White blurred screen means wronf firmware, reburn correct firmware after erasing your your board to solve this Screen blurred screen may mean your camera is broken Red screen is the righe color, but there is no user's code running on it. ## TypeError: Can't convert to type when using IDE This error means the memory on board is not enough while contacts with IDE. Use the termial located on the top menu bar or allocate memory wisely to solve this. ## kpu:check img format err! Pay attention to your terminal !!! The content of gray font: kpu img w 320, h 240 but model w 224, h 224 means the requirement for this model is 224 224, but the input is 320 240 so we should resize all pictures into 224 224, and for 128 128 we need resize resolution of picture too. Use `sensor.set_windowing` to resize camera input or use `img.resize` to resize picture resolution ## ValueError input not support Check the Python code error line and check ValueError error. This normally happens when the type of input format mismatches the type target functions need, or because of lack of memory the object is to be None or that the class type was recycled. ## OSError reset failed This error means that the board failed to initialize the camera. from `sensor.reset()` we see that this function initializing the camera. ![os_error](./assets/maixpy_faq/os_error.png) 1. Camera connection wrong, so the board can not initialize the camera. 2. Camera is damaged, board can not initialize the camera. It's suggested to use camera provided by Sipeed, this can reduce many troubles like the different line sequence of camera to the board or the lack of your camrea driver on this board. ## What's the difference between kmodel and smodel? kmodel is a kind of model explaining the structure and parameters of this model. smodel requires Machine code; Machine code is a kind of encrypted way to encrypt the model. The development board can't use the smodel encrypted and generanted by other Machine code. ## How to run multiple models in the same time Try to run it in time sharing instead of in the same time If the RAM is big enough to load target models, then load them all and run rhem in time sharing. If the RAM is not big enough to load multiple models, try to load one model, and deinit it after finishing running it (use `kpu.deinit`), the load another model or rest models(if the RAM is big enough). Use `load_flash` mode to load model, read content from flash. ## How to load big model Beacuse the limit of RAM in K210, if need load big model, try to load it from flash and run it. The detailed usage can be found in github: [Click me](https://github.com/sipeed/MaixPy v1_scripts/tree/master/machine_vision/load_big_model) ## could not open port 'COMxx':Permission denied This happens when the serial port is occupied. Try to close application which is using this serial port, or try to reboot computer to close all applications to avoid serial port occupied. ## Maix Dock serial port connect failed Maix Dock cannot use MobaXterm or other software which does not support manual serial port flow control for serial communication. To avoid wasting time, it is recommended to use MaixPy IDE for communication. You can open terminal in MaixPy IDE top menu bar tools >open terminals >new terminal >Connect to serial ports >select the correct serial port >baudrate 115200, to create a new terminal. ![sipeed_maix_dock_terminal](./../../assets/hardware/maix_dock/sipeed_maix_dock_terminal.png) ## Error when burning K210 firmware via Kflash ![kflash_gui](./../../../../../news/MaixPy/mixly_application/accets/k210_usage/kflash_gui.jpg) Here are several solvement ways. 1. There is no `COM` port in computer device manager, try to install serial driver or change the USB cable. 2. THere is `COM` port in computer device manager, but it's occupied by other application. Replug the USB cable to stop serial port in use. 3. Update the Kflash into the latest version [Click me](https://dl.sipeed.com/shareURL/MAIX/tools/kflash_gui)。 4. Hold BOOT ket and RST key, release RST key first then release BOOT key manually to make K210 into burning mode 5. If all above fails, try to use another computer to avoid the error caused by USB hub or cable ## Black dot in camera image ![sensor_error](./../../../../../news/MaixPy/mixly_application/accets/k210_usage/sensor_error.png) The screen displays, but there is black dot in the image. This means the lens is dirty, try to disassemble the sensor and wipe it. ## RuntimeError：Sensor timeout! Rerun the code, or use another camera. ## Screen displays reverse colour Erase the firmware, and reburn the firmware, use the code `lcd.init(type 2)` to reverse the color again. [Click me](https://wiki.sipeed.com/soft/maixpy/en/course/image/basic/display_images.html?highlight reverse) to see the example. ## isolated_word module: Idle 2 Read [Keyword Identification](https://wiki.sipeed.com/soft/maixpy/en/course/speech/recognizer_mfcc.html) and [isolated_word API](https://wiki.sipeed.com/soft/maixpy/zh/api_reference/machine_vision/isolated_word.html) to know more. ## How to run TensorFlow `.h5/.tflite` model on K210 Read [Maixpy convert](https://wiki.sipeed.com/soft/maixpy/en/course/ai/basic/maixpy_hardware_ai_basic.html#Model conversion) to see how to convert the model into `.kmodel` format. ## How to check whether K210 is short circuit Measure the `1.8/3.3V` voltage, here are the measure points. ![board_voltage_checkpoint](./../../../../soft/maixpy/zh/others/assets/maixpy_faq/board_voltage_checkpoint.jpg) ## K210 image is overexposed or underexposed The camera explore can only be adjusted by camera OV2640 with code `sensor_exposure_control`. Use the translation assistant to read [Sensor explore control example](https://wiki.sipeed.com/news/MaixPy/sensor.html)。 ## How to mount K210 U disk on computer K210 Does NOT SUPPORT USB device, this chip contains no USB peripheral, can not simulate the U disk. ## Use power surge The board is short circuit, this makes use current surge. ## Loading model... The model requires much RAM, flash the minimal firmware to have a test, then try the normal firmware. ## OSError: [Errno 5] EIO 1. Check if the address of the I2C device is correct, it should be `0x20` instead of `20`. 2. Check if the format of the I2C write data is correct, it should use `b'\\x03'` and `b'\\x80'` instead of `b'x3'` and `b'x80'`. 3. Check if the I2C write command is correct, if you want to set the input/output mode of PCA9534, you should use `i2c.writeto_mem (0x20,0x3,b'\\x80')` instead of `i2c.writeto (0x20, 2, b'x80')`. 4. Check if the I2C wires are reliable, and there are no loose or broken connections. 5. Check if the I2C device is damaged or overheated. 6. Add some delays between the I2C initialization and usage, to make sure the I2C port is activated. ## AttributeError: 'Image' object has no attribute 'find_blobs' Flash the firmware bin named with `openmv`. Firmware named with `minimum` does not support this function. If this does not meet your command, you can compile the firmware by yourself."},"/soft/maixpy/en/others/open_projects.html":{"title":"Open source projects related to MaixPy","content":" title: Open source projects related to MaixPy keywords: maixpy, k210, AIOT, edge computing desc: maixpy open source projects related to MaixPy If you have any open source projects related to MaixPy, please let us know by email (support@sipeed.com) or [issues](https://github.com/sipeed/MaixPy_DOC/issues/new), or directly modify the document and submitPR Looking forward to your fun, interesting or practical works~~~"},"/soft/maixpy/en/others/maixhub_faq.html":{"title":"Maixhub FAQ","content":" title: Maixhub FAQ keywords: maixpy, k210, AIOT, edge computing desc: maixpy Maixhub FAQ ## How to make a data set Refer to the help document of the [maixhub](https://www.maixhub.com) training page ## What to do if the training fails After the training fails, please go to the user center or email to check the failure details"},"/soft/maixpy/en/course/ai/basic/maixpy_hardware_ai_basic.html":{"title":"Basic knowledge of MaixPy AI hardware acceleration","content":" title: Basic knowledge of MaixPy AI hardware acceleration keywords: maixpy, k210, AIOT, edge computing desc: maixpy Basic knowledge of MaixPy AI hardware acceleration ## Model usage and hardware acceleration principle Earlier, we learned that a model is a data organization and many parameters, and finally exists in the form of a file such as a file in the format of `kmodel`. And for this model to be used in the MaixPy program, the program must first understand the file format of `kmodel` and support the algorithm in the model, so that the input can be output after some split calculation processes according to the description of the model. Therefore, the key point is to support the algorithms in the model, called **operators**. In theory, we can use software to implement these operators, and then we can successfully run the model. The physical device that executes the software is the CPU. The network model is very computationally intensive. In addition, what we input is a picture. The picture itself has a huge amount of data. Even the main frequency of `K210` and `400MHz` cannot satisfy the smooth calculation model. Therefore, either upgrade the `CPU`, but the cost is too high, or make a dedicated hardware, let this hardware specialize in a specific algorithm, because it does not do general calculations like the `CPU`, so the speed will be very fast. , We usually use a dedicated graphics accelerator card called `GPU` to accelerate graphics calculations. On the `K210`, this dedicated hardware is called `KPU` (kendryte proccess unit). The first one is the company name, which is actually the same as other chips. The `NPU` does the same thing. In MaixPy, the code to derive the model has been integrated, and the `KPU` is used for calculation acceleration. There is no need to write a lot of code when using it. You only need to call a few functions to quickly run the model. ## About KPU Although KPU can accelerate model calculations, due to various factors such as cost, time, power consumption, volume, heat generation, application field positioning and other factors, its capabilities are not like the powerful `NPU` in the professional field, including every type Operator, it can only handle part of it. KPU implements the hardware acceleration of the four basic operations of convolution, batch normalization, activation, and pooling, but they cannot be used separately and are an integrated acceleration module. Therefore, inference models on KPU, the following requirements (if you do not need to train and design the model, you do not need to understand it carefully): 1. Memory limitations K210 has 6MB general RAM and 2MB KPU dedicated RAM. The input and output feature maps of the model are stored in 2MB KPU RAM. Weights and other parameters are stored in 6MB general purpose RAM. 2. Which operators can be fully accelerated by KPU? The following constraints need to be met. * Feature map size: the input feature map is less than or equal to 320x240 (WxH) while the output feature map is greater than or equal to 4x4 (WxH), and the number of channels is from 1 to 1024. * Same symmetric paddings (TensorFlow uses asymmetric paddings when stride 2 and the size is even). * For ordinary Conv2D and DepthwiseConv2D, the convolution kernel is 1x1 or 3x3, and the stride is 1 or 2. * MaxPool(2x2 or 4x4) and AveragePool(2x2 or 4x4). * Any element wise activation function (ReLU, ReLU6, LeakyRelu, Sigmoid...), KPU does not support PReLU. 3. Which operators can be partially accelerated by KPU? * Asymmetric paddings or valid paddings convolution, nncase will add necessary Pad and Crop before and after it. * Ordinary Conv2D and DepthwiseConv2D, the convolution kernel is 1x1 or 3x3, but stride is not 1 or 2. nncase will decompose it into KPUConv2D and a StridedSlice (may also need Pad). * MatMul, nncase will replace it with a Pad (to 4x4) + KPUConv2D (1x1 convolution sum) + Crop (to 1x1). * TransposeConv2D, nncase will replace it with a SpaceToBatch + KPUConv2D + BatchToSpace. Instructions are from [here](https://github.com/kendryte/nncase/blob/master/docs/FAQ_ZH.md) ## Model conversion As mentioned earlier, a model is actually a set of structure and parameter data. Different software can only recognize models in a specific format. KPU only recognizes models in `.kmodel` format. Generally, models trained on computers do not, such as `tensorflow` `.h5` format or `.tflite` format, to be used by `KPU`, it must be changed to `kmodel`, and use [nncase](https://github.com/kendryte/nncase) tool to achieve model conversion the goal of If you need to convert the model, see the introduction in this warehouse for specific usage ## kmodel V3 model and V4 model Due to the code update, two major versions were produced in the process, `V3` and `V4`, where the `V3` model refers to the use of [nncase v0.1.0 RC5](https://github.com/kendryte/nncase/ releases/tag/v0.1.0 rc5) The converted model; `V4` model refers to [nncase v0.2.0](https://github.com/kendryte/nncase/releases/tag/v0.2.0 beta4) Converted model There is a certain difference between the two, so now the two are publicly stored, `V3` has less code, less memory, and higher efficiency, but it supports fewer operators; `V4` supports more operators, but both Realized by software, no hardware acceleration, more memory usage, so each has its own strengths. MaixPy firmware can also choose whether to support `V4`. ## Use model kmodel in MaixPy 1. Load the model in the SD card (TF card) Put the model on the SD card, then load ```python import KPU as kpu m kpu.load(\"/sd/test.kmodel\") ``` 2. Load the model in Flash Download the model to Flash, then load ```python import KPU as kpu model_addr_in_flash 0x300000 m kpu.load(model_addr_in_flash) ``` Here `model_addr_in_flash` is the offset address of the model in Flash, and the model can be burned to the corresponding address of Flash through kflash.py or kflash_gui 3. Ready to enter In general, we will use images as input: * Directly use the data collected by the camera as input: ``` img sensor.snapshot() ``` Here `img` can be directly used as input, here need **note**: After the `snapshot` function collects the image, it will put the image data in two places (1) `RGB565` memory block, the image is stored in a memory in the form of `RGB565`, which is convenient for image processing functions. Note that the order in the memory is `[pixel 1 RGB, pixel 2 RGB...]` (2) `RGB888` memory block, the image is stored in another memory in the form of `R8G8B8`, note that the order in the memory is `[all pixels R, all pixels G, all pixels B]`, which we also call For `AI` memory **Among them, the data actually input as KPU is `RGB888` area**, this is explained in detail in the previous document [MaixPy image and common operations](/course/basic/image/vary.md) chapter * Read from file, or modified camera image The image collected directly from the camera will automatically fill the `RGB888` area, but when we use image processing functions such as `image.resize()`, only `RGB565` will be modified, and `RGB888` will not be modified, because it needs to modify two memory at the same time It takes a lot of time, and the input of `KPU` is `RGB888` memory, so when you need to perform `KPU` operations, you need to synchronize (refresh) the `RGB888` memory block, and use `img.pix_to_ai()` to synchronize , Otherwise the modification has no effect on `KPU`. such as: ```python img sensor.snapshot() img img.resize(240, 240) img.pix_to_ai() ``` ```python img image.Image(\"/sd/test.jpg\") img.pix_to_ai() ``` 4. Forward running model Run the model forward, that is, walk the model calculation in the direction from input to output, and get the output value through input: ```python feature_map kpu.forward(m, img) ``` Here we get the `feature_map`, which is a feature map. For example, the classification of `small balls` and `toys` we used earlier, the output feature map is two nodes, each node represents the probability of the corresponding object, we will feature Figure converted to `list` object ```python p_list feature_map[:] print(p_list) ``` You can get a result similar to `[0.9, 0.1]` ## Common problems in the use of KPU ### How big a model can KPU load? C language code running model: When k210 runs the c code, it can load the model <6MB, depending on the content of the C code. MaixPy running model: * When running MaixPy (minimum version), a model of about 4MB can be loaded. If you don’t use the camera and LCD, you can load up to 5MiB of models (because the buffer of the camera and LCD takes up a lot of memory, but the actual application is not very meaningful) * When running MaixPy (full version), it can load a model of about 2MiB * In addition, it also supports real time loading of models from `Flash`. In theory, as long as the single layer memory does not exceed 2MiB, the overall model can be infinitely large, but at the expense of computing speed. For usage, see [here](https://github.com/sipeed/MaixPy v1_scripts/tree/master/machine_vision/load_big_model). If you are interested in the principle and implementation, you can see [here](https://neucrack.com/p/313) ### What should I do if I report an error \"memory overflow\"? When this problem occurs, according to the system memory management mentioned earlier, there are generally two possibilities: 1. The place where the error is reported has nothing to do with the system heap. It may be caused by insufficient memory in `GC`, but increase the total memory size of `GC` appropriately 2. Caused by the model being too large. You can try the following solutions in turn: 1. Change the firmware of maixpy ​​mini version 2. Perform model pruning optimization 3. Use the `kpu.load_flash` interface to load the model in real time when running, but the execution efficiency is reduced a bit 4. If the memory is insufficient and the performance of `kpu.load_flash` cannot be satisfied, then you may need to use [C SDK](https://github.com/kendryte/kendryte standalone sdk) for development. ### What should I do if I report an error \"load error, only support kmodel v3/v4\"? If this problem occurs, you can try the following solutions: 1. If you are loading the model in the Flash, please make sure that the `flash offset` is filled in correctly and that there is no conflict with the address of the maixpy ​​firmware (the address of the model in the Flash is too high, and then when the firmware is programmed into the Flash, the firmware size Exceeded the starting address of the model, causing the model to be destroyed) 2. If it is `kmodel V4` converted with `nncase 0.2.0`, please try to convert with `nncase 0.1.0` to generate `kmodel V3` ### I want to select and load different models (for example, press the button to run the target classification, press the button again to run the target detection), how should I write the program? Because the internal RAM is limited, when you need to switch between different models for `kpu.load(address)`, please execute `kpu.deinit(k210model)` to release the memory occupied by the previous model, and then load the new model.Time shared memory"},"/soft/maixpy/en/course/ai/basic/dnn_basic.html":{"title":"Basic knowledge of deep neural network (DNN)","content":" title: Basic knowledge of deep neural network (DNN) keywords: maixpy, k210, AIOT, edge computing desc: maixpy basic knowledge of deep neural network (DNN) Here is the knowledge you need to know to use MaixPy AI related functions, so that you can understand the following content, so I won't introduce it in depth in this article. ## How to solve a problem lead the machine to solve the problem A question is usually divided into **input** and **output (result)** For example: A straight line in the coordinate system is as follows, the value of the above data point is known: ![y kx+b](../../../../assets/dnn/ykxb.jpg) Now ask the question, if the data point law does not change, enter an x ​​coordinate of 20, what is the value of y? According to everyone’s knowledge, we all know that this is a one variable linear equation (`y kx + b` can be solved). Bring in the values ​​of two points and calculate the equation as `y 3x + 10`, then when `x 20 The value of `, `y` is `70`, so the input is `20` and the output is `70`. Here is input (`20`) + algorithm (one variable linear equation) output (`70`). This is the basic method we use to solve a problem, so the key is to find the one that conforms to the law of data points on this line segment algorithm. Humans are very powerful, they will summarize and learn from these data, and finally get this algorithm (equation), and then other people can directly use this algorithm to quickly solve similar problems, then, is there a way to let the machine automatically To find this algorithm? ## How to let the machine summarize the algorithm To let the machine automatically summarize the algorithm, that is, machine learning (ML, Machine Learning), let's take a look at how humans get this algorithm (equation). * Step 1: First, there are a large number of data points, and then based on these data points, humans found that the straight line conforms to the algorithm `y kx + b`, which adapts to all straight lines, but found that there are two unknowns `k` and ` b`, this is the parameter that adapts to any straight line * Step 2: Then what kind of straight line is the specific, because the equation has two unknowns, namely the parameters, put the actual two data points into this equation, and get `k 3` and `b 10` * Step 3: Then we use the online data points that are not used in step 2 to try whether the algorithm (equation) is correct, and finally we find that they are all verified correctly * Step 4: Then you need to know the value of `y` of other points through the value of `x`, just substitute `y 3x + 10` So, can machine learning also use this step? * We thoughtfully designed an algorithm structure, adding that we happened to design it directly as `y kx + b`, we left two parameters for the specific straight line, let’s call this structure **model structure** for now, because There are unknown parameters, which we call the untrained model structure. Where `x` is called **input**, and `y` is called **output** * Now, we substitute a few points of our straight line into this equation, we call this process **training**, to get the algorithm `y 3x + 10`, there are no unknown parameters, we now call it It is a **model** or a trained model, where `kb` is the parameter in the model, and `y kx + b` is the structure of the model. The data points brought into training are called **training data**, and their collective name is **training data set** * Then, we use several data points on the line segment that are not used in the training process as input, substitute this model for calculation, and get the result, such as `x 10`, get `y 40`, and then compare the output Whether the value is consistent with expectations, here we find that `x 10, y 40` is indeed on the straight line in the figure, and this point is not used during training, indicating that the model we got passed this verification. The process is called **verification**, `x 10, y 40` This data is called verification data. If we use multiple sets of data to verify this model, the collective term for these data is called **validation data set** * Now, we have obtained a **model**, and verified this model with **validation data set**, which seems to be very accurate, then we can assume that this model basically satisfies our future. x`, requires the value of `y` at any point on the line in the figure, you can enter `x` to give the `y` coordinate of the corresponding point on the line. This process is actually **using the model**, this process is called **reasoning** In fact, this is regarded as machine learning. What we humans need is to design the structure of `y kx + b`, and give **training data set** and **validation data set**, after **training** And **verify** to get a model we think is available, and then use `input + model` to get the correct `output (result)`. ## What is a deep neural network? Deep neural network (DNN) is a technology in the field of machine learning (ML). I mentioned a relatively simple example. According to a straight line data to predict any point on the straight line, the structure of `y kx + b` is artificially designed and very simple. When used for complex data, it is not found Applied, such as \"Is this picture a ball or a toy\" ![小球](../../../../assets/dnn/ball.jpg) ![toy](../../../../assets/dnn/toy.jpg) In order to store the information of the next straight line in the model, the structure `y kx + b` is used, and the features of the straight line are all stored in the model. The features used to store a picture now, the linear structure of `y kx + b`, and the two parameters of `k and b` obviously cannot be satisfied. A better structure needs to be designed. The network ** appeared, a kind of mesh structure, which can better remember the characteristic information of the picture, and this mesh structure is multi layered, that is, it has depth, so it is called a deep neural network (DNN). , Deep neural network), so DNN is a network structure and a means to realize machine learning. Each layer is composed of multiple nodes, as shown in the figure below, a DNN contains **input layer**, **hidden layer**, **output layer**, where the hidden layer consists of three layers (`A[1] , A[2], A[3]`layer), but collectively referred to as hidden layers: ![Deep Neural Network](../../../../assets/dnn/dnn.jpg) **Input layer**: The figure is a deep neural network structure, `x` is the input, for example, `x` here can be a picture, the input has multiple nodes, each node can be a pixel value, here the input layer draws 7 nodes, add We have a picture with a resolution of `10 x 10`, so the input layer requires a total of `100` nodes. Here the input layer is a one dimensional structure, and the actual situation may have a multi dimensional structure. For example, if the input is a grayscale image with a resolution of `3x3`, this is actually a two dimensional structure, that is, a matrix with two rows and two columns (about the matrix Please study the concept by yourself, or understand it as a two dimensional array for the time being), such as: ``` [[109 138 110] [220 37 166] [32 243 67] ] ``` The value range of each pixel is ∈[0, 255], and then we flatten it into a one dimensional array of 9 data for the input layer ``` [109 138 110 220 37 166 32 243 67] ``` > In addition, the value of the input layer will generally be normalized to the range `[0, 1]` If it is a color picture, it is three dimensional, that is `height, width, color channel`, color channels such as `RGB` three color channels, that is, the input has a shape (including the dimensions and the number of data in each dimension), For example, the one dimensional input shape above is `(9)`, and other images usually use `(height, width, number of channels)` to represent the shape, such as `(10, 10, 3)` for resolution of `10 x 10` , And there are three color channels, such as `RGB`. Here for the sake of getting started, the principle only introduces one dimensional situation **Output layer**: `y` is the output. The output here has two values. You can understand that the achievement is the `list` of MaixPy's two floating point values. `[Y1, Y2]`, `Y1` is the probability of being a small ball`, value ∈[0, 1], `Y2` is `probability of being a toy`. So in the end, we use this model, which is to give it a picture. The machine calculates according to the structure and algorithm specified by this model to get a `list`, and we know what is in the picture based on the output value. **Hidden layer**: The hidden layer connecting the input layer and the output layer, as well as the connection in between, are responsible for calculating the input data into a reasonable output value. ## Rest in between, summary So far, you know what a **model** is: it is a set of data structures that save the shape of a network and the parameters inside. Usually, the data of this model can be saved as a file, such as `.h5. Files such as tflite.kmodel` are used to explain the shape structure and parameters of this model, but they are used by different software. People only need to design the model structure and parameters to solve a class of problems, such as common object classification, such as the distinction between a ball or a toy in a picture as mentioned above. There are many parameters in this model. Specifically, when an object needs to be identified, a data set of known classification is used to allow the machine to automatically train a set of appropriate model parameters. Then we can enter the data and let the model infer the type of the input data. Therefore, if we don’t need to train the model and directly use the model trained by others, we only need: * Confirm the requirements and find a ready made model, because the model has been trained, and the meaning of the input and output shapes has been determined * Confirm the input shape of the model, such as the model input resolution `10x10` color image, you need to pass the required image to an input layer when using it * Confirm the meaning of the output layer, such as the aforementioned recognition of balls and toys, and the final output is a list representing the probability of the object, such as `[0.9, 0.1]`, the first value represents the probability of a ball, Then we know that there is a 90% probability of a small ball in this picture, and only a 10% probability of a toy * Put the model into the inference program to run. Don’t worry about the specific procedure, it will be introduced in the next chapter At this point, you should roughly understand the following things: * What is machine learning * What is a deep neural network (simple concept) * What is the model * What is the input layer, the output layer, what are the meanings of the classification applications in the example above, and what is the shape of the layer? * So far, I may not know what model training is * If I need a model, I know how to confirm the demand So, **if you only want to be able to use the model and don’t need training, you can do it here**, and you don’t need to know anything about the model, just use it as a **black box toolbox**. can. If you want a deeper understanding, please continue to read the following content. ## Continue: Deep Neural Networks (Continued Now that we have designed a multi layer design, let's go deeper: **Data flow**, **weight**, **bias**: When the model is inferring, the data flows from the input layer to the output layer, which is the direction of these mesh arrows (section 3 mesh diagram). The calculation from the previous layer to the next layer of each arrow can use a familiar formula: `y wx + b`, call `w` as **weight** (weight), `b` as **bias** (bias), note that each arrow has a separate `w, b `, that is to say, the value of the node of the next layer is equal to the value of the node of the previous layer after the calculation of this formula, the node of the next layer has multiple nodes of the previous layer, it is equal to the value of all the nodes of the previous layer after this The sum of the calculated values ​​of the formula. After so many calculations, the result finally appeared in the form of a value in the output layer, and the whole reasoning was completed. **Activation function**: Although the above model can get results through input, it will be found that all layer calculations are linear functions, so no matter how many layers there are, the whole is actually a linear function, that is, `y0 w1x + b1` + `y w2y0 + b2 ` > `y w2(w1x + b1) + b2` > `y w2w1x + w2b1 + b2`, in fact it is still a linear function, then the meaning of multiple layers is gone, so we need to add in the middle Non linear functions make the network a little more complicated, so I will do tricks on each node. Before each node outputs data, use a non linear function to calculate it, such as `sigmod` or `relu` function. It’s actually very simple to hear the name. Looking at the picture below, in short, x and y are not linear: ![sigmod](../../../../assets/dnn/sigmod.jpg) ![relu](../../../../assets/dnn/relu.jpg) That is, until now, except for the input layer, the output value of all nodes needs to go through `Sigmod(∑(Wn * x + Bn))`, and output a floating point value **softmax**: When the output layer is finally output, because of the previous calculations, the value range is not very uniform. Although we can compare the size, the largest value is considered the answer, but for the sake of uniformity and intuitively know the possibility of each category (In addition, for the accuracy of training, I won’t talk about it here.) As mentioned earlier, the probability of a category we finally output has a value range ∈[0, 1], and the sum of all output values ​​is `1`, so All values ​​of the output layer are processed after the output layer, the formula is ![softmax](../../../../assets/dnn/softmax.jpg) At this point, the inference process from input to output is over ## Deep neural network training Earlier we briefly introduced the structure and composition of deep neural networks and the forward process from the input layer to the output layer. When we use the model, this is the forward process. Then, the model is set, and the parameters (such as `w, b`) in it are all random values. How to make it automatically train to get the values ​​of the parameters in the model? As we mentioned earlier, we use some data input with known results to get the parameters. Similarly, here we also input data with known results to get the first output result **Judging the output accuracy (accuracy) (or error/loss)** and **loss function**: The results are obtained in the output layer. For example, `[0.6, 0.4]` represents the probability of a small ball `0.9`, and the probability of a toy is `0.1`, but because it is data with known answers, the actual correct answer is `[ 1.0, 0.0]`, which obviously does not meet the requirements. Therefore, the error between the correct answer and the calculated answer is: `[0.4, 0.4]`, but one problem is that the range of the error value is not very attractive. If the value range of the error is ∈`[0, ∞] `Just fine. In high school mathematics, there is a function `y log10(x)`, the coordinate diagram is as follows: ![log10](../../../../assets/dnn/log10x.jpg) It is found that when `x` takes the value ∈`[0, 1]`, the value of ` y` is exactly ∈`[0, ∞]`, and our output result is also exactly ∈`[0, 1]`! Therefore, we directly calculate the error like this: `error log10(output)`, that is, the closer the output is to `1`, the closer the error is to `0`. This method is called `CEE, Cross Entropy Error)`, in addition to this method, there are other methods such as Mean Squared Error (MSE, Mean Squared Error), etc. At this point, we know the error between the current result and the actual result **Back propagation of error** and **Parameter optimization (weight update)**: Because the parameters of the model do not meet our expectations, we need to modify the parameters. We use backpropagation. Earlier we got the error, because the parameters are not correct enough, we use this error to modify the parameters in the model to achieve the effect of fine tuning the parameters in the model. It is as if you are turning on a faucet. If the water hits (that is, the error is large), tighten the switch a little bit, loosen it a little bit if it is smaller, and adjust it. Just like our forward calculation, this time we changed it to reverse. From back to front, we can get the error value at each node, and then update the parameters in the model according to a certain learning rate. I won't elaborate on it for the time being. In short, after a round of reverse adjustment of parameters, a new model is obtained **Measure the quality of the model: training set error and validation set error**: We use the data in the training data set to repeatedly perform forward inference to obtain the error, and then adjust the process in the reverse direction. After using the training data set, we may get a relatively small error, but this only shows that the model is The data is more accurate, and some new data may not be accurate, so we need to use some data that is not in the training set to **verify** the effect of the model: We use **validation data set** to forward inference and get the error, because the validation data set is not involved in training, which means that the parameters of the model and the validation data set have nothing to do with each other. We use the error obtained to constant the model The better or worse, the smaller the error, the better the effect **Multiple iterations**: If you have trained all the data sets and find that the error is still large, you can continue training with multiple training methods, that is, **multiple iterations**. After each iteration, use the verification data set to verify the effect. If the error of the training set and the error of the validation set are small enough, we can temporarily assume that the model has good results. **Test Set**: At this time, we can use another batch of new data to test the effect of our model, because this is brand new data, did not participate in the training and did not participate in the verification (that is, determine when to stop training), theoretically more Credibility. If the test error is small, then the training is considered successful **Optimize training**: If the final effect is not very good, there are many places to adjust, such as * The number of training iterations is not the more the better. Too much training on a batch of data sets may cause the model to be effective only for this batch of data, and the generalization ability is not enough, that is, **overfitting** * The learning rate of each training can also be adjusted * Check the data set, whether there are some data that affect the classification * Optimize the network structure, whether it is input or output or internal structure and parameters, according to different data and tasks can have a better design, also called **feature engineering** ## Said at the end At this point, you should roughly understand the following things: * What is machine learning * What is a deep neural network * What is the model * What is the input layer, the output layer, what are the meanings of the classification applications in the example above, and what is the shape of the layer? * What is training and what is its function * What are the data training set, validation set, and test set, where are they used, and what needs to be paid attention to * What is the standard to measure the quality of the model If you still don’t understand, you can understand it again carefully, or refer to related materials. If you find a better way to explain it, please follow the document contribution method in the left directory to participate in the contribution. ## Modify record Date Author Remarks 2020.11.17 [neucrack](https://neucrack.com) Initial version, introducing the basic concepts of deep neural networks according to MaixPy needs, first draft "},"/soft/maixpy/en/course/ai/train/maixhub.html":{"title":"Maixhub model training","content":" title: Maixhub model training keywords: maixpy, k210, AIOT, edge computing desc: maixpy Maixhub model training Now the new version of MaixHub website has been launched, visit [maixhub.com](http://maixhub.com), it not only supports k210 nncase model training, but also support more platforms and development boards, such as mobile phones, computers, V831, MCU and so on. It's also improved the training process, support the online annotation, one click upload dataset, more training parameters can be manually adjusted, as well as one click deployment to the device or other functions, login and experience! MaixHub provides model training functions and model sharing functions. You only need to prepare the data set to be trained, and do not need to build the training environment or prepare the code. By uploading the training dataset, you can quickly train the model, which is convenient to quickly make your own AI application, or learn the basic process and principle of AI training. In addition, you can also download your favorite models in MaixHub model library, or upload and share your own models, no matter they are trained in MaixHub, or trained by your own codes!"},"/soft/maixpy/en/course/ai/train/local.html":{"title":"Local model training","content":" title: Local model training keywords: maixpy, k210, AIOT, edge computing desc: maixpy local model training Local model training is performed using [sipeed/maix_train](https://github.com/sipeed/maix_train) this code, using Tensorflow as the training framework Main support: * Object classification model (using Mobilenet V1): Only identify what is the object in the picture * Object detection model (using YOLO V2): Find the figure body recognized in the picture, and find its coordinates and size at the same time ## System environment First, a computer with Linux system is required If your main system is Windows, you can use the following system environment: * You can use a virtual machine, `virtual box` or `vmware`, the system recommends installing `Ubuntu20.04` * Or install dual systems, please search and learn the installation method yourself, or see [this dual system installation tutorial](https://neucrack.com/p/330) You may want to develop under `Windows`, but it is strongly recommended to use `Linux` instead of `Windows`: * First of all, most model training frameworks support `Linux` first, and the difficulty of developing under `Linux` will be easier than developing under `Windows` * As a developer, learning to use `Linux` is a basic skill. Of course, unless you are a fan of `Windows`, then I believe you must have the ability to port software from other systems to `Windows` ## Software Installation Training can use CPU for training, but the speed is relatively slow. If you use a dedicated graphics card (GPU) for acceleration, the speed will be much faster. Individuals generally use `Nvidia` graphics cards, such as `RTX 3090`, of course, use ordinary` GTX 1060 6G memory `version can be used happily For the first contact, it is recommended to use the CPU for training first, the environment installation will be much easier, the following only talks about the method of CPU training, GPU please learn by yourself > For GPU usage, please refer to the official Tensorflow [GPU Usage Tutorial](https://tensorflow.google.cn/install/gpu). If you encounter problems with the graphics card driver, please refer to [here](https://neucrack.com/ p/252), if you encounter problems with [docker installation](https://tensorflow.google.cn/install/docker), you can also see [here](https://neucrack.com/p/116) The following method of use is excerpted from the warehouse’s [README](https://github.com/sipeed/maix_train/blob/master/README.md), if there are discrepancies, please refer to the warehouse’s `README`, pay attention to distinguish * Clone the training code to local ``` git clone https://github.com/sipeed/maix_train recursive ``` * Installation dependencies ``` cd maix_train pip3 install r requirements.txt ``` Chinese users can use Alibaba Cloud or Tsinghua's source, the download speed is faster ``` pip3 install r requirements.txt i https://mirrors.aliyun.com/pypi/simple/ ``` * Download [nncase v0.1.0 rc5](https://github.com/kendryte/nncase/releases/tag/v0.1.0 rc5) and unzip it to `maix_train/tools/ncc/ncc_v0.1`, guaranteed The path of the execution file is `maix_train/tools/ncc/ncc_v0.1/ncc` * Configuration project Initialize the project first ``` python3 train.py init ``` Then edit the `maix_train/instance/config.py` configuration according to your hardware situation ## Prepare the data set Prepare the data set, the image size is `224x224`, the format can refer to the data set example under `maix_train/datasets` ## Train classification model ``` python3 train.py t classifier z datasets/test_classifier_datasets.zip train ``` Or unzip the data set to a folder, specify the data set folder ``` python3 train.py t classifier d datasets/test_classifier_datasets train ``` ## Train the target detection model ``` python3 train.py t detector z datasets/test_detector_xml_format.zip train ``` ## Use model Like the model trained with `Maixhub`, a `zip` file will be generated in the `out` folder, which contains the results, copy **all** files to the root directory of the `SD` card, and then power on the development board Just run"},"/soft/maixpy/en/course/ai/image/1000_type_classifier.html":{"title":"1000 object classification models","content":" title: 1000 object classification models keywords: maixpy, k210, AIOT, edge computing desc: maixpy 1000 object classification models Can recognize 1000 objects ## Instructions * Use `minimum` version firmware * [Download model file](https://dl.sipeed.com/MAIX/MaixPy/model), download `mobilenet_0x300000.kfpkg` * Use `kflash_gui` to burn this file to `Flash`, the default address is `0x300000` * Save the file [labels.txt](https://github.com/sipeed/MaixPy v1_scripts/tree/master/machine_vision/mobilenet_1000_class/labels.txt) ([Alternate Link](https://en.bbs.sipeed.com /uploads/default/original/1X/d41ad9dfbe01f228abe726986fbf1baf4e288f2e.zip)) to the file system, see the introductory tutorial (use your ingenuity) for specific methods (reference answer: because there is too much content, if you use the REPL to copy and paste directly, data may be wrong. So use a tool to transfer. The easiest way is to put it on the SD card; if you want to put it in `/flash`, the minimum may not support IDE, you can use `upyloader` to send files) * Because this model has `4.2MiB`, which is relatively large, so the firmware of `minimum` is used, and the memory used by `GC` is not too large. You can set a smaller size in the following way and leave the memory for the model ```python from Maix import utils import machine utils.gc_heap_size(256*1024) machine.reset() ``` * Import model ```python import KPU as kpu task kpu.load(0x300000) ``` * Read in labels ```python f open('/sd/labels.txt','r') labels f.readlines() f.close() ``` * Initialize the camera, LCD You can set whether the camera is mirrored and whether the LCD is rotated according to your own hardware installation Slightly, please refer to the previous tutorial * Identify objects ```python fmap kpu.forward(task, img) plist fmap[:] pmax max(plist) max_index plist.index(pmax) ``` Here, the result of the operation is converted into a `list` object, and then the subscript of the maximum value is found. Through this subscript, we know what the label name is (`labels[max_index]`) * show result ```python img img.draw_string(0, 0, \"%.2f: %s\" %(pmax, labels[max_index].strip()), color (255, 0, 0)) lcd.display(img, oft (0,0)) print(fps) ``` See the complete example [maixpy_scripts](https://github.com/sipeed/MaixPy v1_scripts/tree/master/machine_vision/mobilenet_1000_class)"},"/soft/maixpy/en/course/ai/image/face_detect.html":{"title":"Face detection","content":" title: Face detection keywords: maixpy, k210, AIOT, edge computing desc: maixpy face detection Find the face in a picture, and frame the face, that is, know the position and size of the face Use the `YOLO V2` model to detect faces ## Instructions: * Download model: Go to [here](https://dl.sipeed.com/MAIX/MaixPy/model) to download the model file `face_model_at_0x300000.kfpkg` * Use kflash_gui to download the model to Flash, or put it in SD card * Load model ```python task kpu.load(0x300000) # task kpu.load(\"/sd/face.kmodel\") anchor (1.889, 2.5245, 2.9465, 3.94056, 3.99987, 5.3658, 5.155437, 6.92275, 6.718375, 9.01025) kpu.init_yolo2(task, 0.5, 0.3, 5, anchor) ``` Because the model of `YOLO V2` is used, it has a dedicated function interface, use `init_yolo2` to initialize the model The parameters are: * `kpu_net`: kpu network object, that is, the loaded model object, the return value of `KPU.load()` * `threshold`: Probability threshold, only if the probability of this object is greater than this value will the output result, value range: [0, 1] * `nms_value`: box_iou threshold, in order to prevent the same object from being framed in multiple boxes, when two boxes are framed on the same object, the intersection area of ​​the two boxes accounts for the proportion of the total occupied area of ​​the two boxes. When it is less than this value, take the box with the highest probability * `anchor_num`: the number of anchor points, fixed here as `len(anchors)//2` * `anchor`: The anchor point parameters are consistent with the model parameters. This parameter of the same model is fixed and bound to the model (it is determined when the model is trained) and cannot be changed to other values. Then enter the image data and run the model ```python code kpu.run_yolo2(task, img) ``` To get the result, see [here](https://github.com/sipeed/MaixPy v1_scripts/blob/master/machine_vision/face_find/demo_find_face.py) for the complete example API documentation see [Maix.KPU](/api_reference/Maix/kpu.md)"},"/soft/maixpy/en/course/ai/image/face_recognization.html":{"title":"Face recognition","content":" title: Face recognition keywords: maixpy, k210, AIOT, edge computing desc: maixpy face recognition In addition to detecting the position of the face, it can also identify who the person is (you need to target the person and press the button to learn) Effect video: [youtube](https://www.youtube.com/embed/hS_mcGptXeo) or [bilibili](https://www.bilibili.com/video/BV1bJ411Q7L6) <iframe src \"https://player.bilibili.com/player.html?aid 77466790&bvid BV1bJ411Q7L6&cid 132521878&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\" width 500 height 400> </iframe> ## Instructions * Download the model from [maixhub](https://www.maixhub.com/index/index/detail/id/235.html) and follow the instructions to obtain the model `smodel`, which is the encrypted version of `kmodel` * Download the model to the development board according to the method of the introductory tutorial * Run script [script](https://github.com/sipeed/MaixPy v1_scripts/blob/master/machine_vision/face_recognization/demo_face_recognization.py) ## Program understanding There are three models in common, namely: * Face detection model, which uses the same model as the previous face detection, that is, find the face * Face key point detection model, find the position of the eyes, nose and mouth of the face from the face found in the front * Face feature extraction model to obtain a feature value from a face picture Proceed as follows: * Face detected * Cut out the face, find the eyes, nose and mouth of the face, here is a picture of `128x128` * Rotate the face in the face image to the standard position * Use the feature extraction model to extract the feature value of the face With the previous foundation, the program here can be understood, and I will not elaborate on it. It just changed from using one model before to using three models in order, plus one more point. Simple image cropping and rotation processing are all calling `API`, look at the code carefully to know how the specific details are implemented"},"/soft/maixpy/en/course/ai/image/self_learn_classifier.html":{"title":"self learning classifier","content":" title: self learning classifier keywords: maixpy, k210, AIOT, edge computing desc: maixpy self learning classifier No need to train separately, learn the object features directly on the development board, and then use it directly Demo video: [youtube](https://www.youtube.com/watch?v aLW1YQrT 2A) or [bilibili](https://www.bilibili.com/video/BV1Ck4y1d7tx) ## Instructions * [Here](https://dl.sipeed.com/MAIX/MaixPy/release/master/maixpy_v0.5.0_33_gfcd6d8a) Download version > v0.5.0 33 firmware * [Download kmodel](https://maixhub.com/model/zoo/61) * Use [kflash_gui](https://github.com/sipeed/kflash_gui) to download firmware and model * Run [Sample script](https://github.com/sipeed/MaixPy v1_scripts/blob/master/machine_vision/self_learning_classifier/self_learning_classifier.py) > If use the lite version kmodel, you should add `fea_len` arg as `512` when create classifier object, when use the bigger kmodel this param is not needed: ```python classifier kpu.classifier(model, class_num, sample_num, fea_len 512) ``` Then start learning objects after running * Press the `boot button` on the development board to capture 3 categories `mobile`, `car`, `keyboard`, each category only needs to be captured once * Then capture 15 pictures, no order is required, such as capturing 5 pictures of `mobile phone`, 5 `cars`, 5 pictures of `keyboard` * Then it will automatically learn the features of these 15 pictures * The last recognized image category will be displayed in the upper left corner ## Save/load learned features * Use `classifier.save(path)` to save the learned features to the `path` file * Use `KPU.classifier.load()` to load features, refer to [self_learning_classifier_load.py](https://github.com/sipeed/MaixPy v1_scripts/blob/master/machine_vision/self_learning_classifier/self_learning_classifier_load.py) file"},"/soft/maixpy/en/course/speech/fft_waterfall.html":{"title":"FFT waterfall chart (rain chart)","content":" title: FFT waterfall chart (rain chart) keywords: maixpy, k210, AIOT, edge computing desc: maixpy FFT waterfall chart (rain chart) The FFT waterfall chart is the frequency distribution chart of the data over time. The following will introduce how to use MaixPy to draw the waterfall chart. ## Drawing method * Prepare time domain signals (such as audio data) ```python rx I2S(I2S.DEVICE_0) rx.channel_config(rx.CHANNEL_0, rx.RECEIVER, align_mode I2S.STANDARD_MODE) rx.set_sample_rate(sample_rate) audio rx.record(sample_points) ``` * Perform FFT operation (use FFT operation on the data and get its frequency distribution) ```python fft_points 512 fft_res FFT.run(audio.to_bytes(),fft_points) fft_amp FFT.amplitude(fft_res) ``` * Draw on image (due to the symmetry of the FFT result, only a part of it needs to be drawn) ```python hist_x_num 128 img image.Image(size (128,128)) for i in range(hist_x_num): img[i] fft_amp[i] ``` *Detailed API reference [I2S API](../../api_reference/Maix/i2s.html), [FFT API](../../api_reference/Maix/fft.html)* ## Routine > The following example is tested in firmware v0.5.1 MaixDock Acquire audio data in real time and draw it as an FFT waterfall chart [demo_fft_waterfall.py](https://github.com/sipeed/MaixPy v1_scripts/blob/master/hardware/demo_fft_waterfall.py) effect: ![](../../../assets/course/fft_waterfall.gif)"},"/soft/maixpy/en/course/speech/recognizer_mfcc.html":{"title":"isolated word","content":" title: isolated word keywords: maixpy, k210, AIOT, edge computing desc: maixpy isolated word > **This document has passed the MaixPy 0.5.1_128 minimum_speech_with_ide_support firmware test. Please make sure the hardware recording function is available before use.** This is an algorithm module for isolated word recognition. The user generates a vocabulary template through recording and loads it into the module, and then recognizes the vocabulary template loaded by the user through it, and returns the possibility of matching. Please refer to [STM32 based isolated word speech recognition ](https://gk969.com/stm32 speech recognition/). Isolated word recognition According to the way of pronunciation, there are three types: isolated word recognition, connected word recognition, and continuous speech recognition; the so called isolated word recognition (Isolated Word Recognition) means that when the sound to be recognized is issued, only one word in the vocabulary is included at a time Article. Vocabulary template We record a vocabulary spoken by the human voice and use algorithms to make it into a recognizable template, which is called a vocabulary template. Template matching Assuming that the algorithm module is loaded with a vocabulary template, after we input data to the algorithm module through recording, it will perform internal matching to obtain the most likely recognition result. > The specific identification process of this module is: pre filtering, ADC, framing, endpoint detection, pre emphasis, windowing, feature extraction, feature matching. Endpoint detection (VAD) uses a combination of short term amplitude and short term zero crossing rate. After detecting the effective speech, according to the human hearing perception characteristics, the Mel frequency cepstral coefficient (MFCC) of each frame of speech is calculated. Then the dynamic time warping (DTW) algorithm is used to match the feature template, and the recognition result is finally output. ## how to use? Current hardware support level: Maix BIT / DOCK / DUINO / GO. > As of 20201123, after the Cube & Amigo has passed ES8374, the microphone's noise floor is too high and it will be judged as a noisy environment, which needs to be repaired. ### Sample code out of the box Use the test case of maixduino/maixbit [isolated_word.py](https://github.com/sipeed/MaixPy v1_scripts/blob/master/multimedia/speech_recognizer/isolated_word.py), please read the code for the usage method, please pay attention to the microphone of the hardware Configuration and channel configuration. Maix DOCK can directly use the sample code [demo_isolated_word_on_maixdock.py](https://github.com/sipeed/MaixPy v1_scripts/blob/master/multimedia/speech_recognizer/demo_isolated_word_on_maixdock.py), just follow the on screen instructions to speak, see [ Test video](https://www.bilibili.com/video/BV1oz4y1C7yE?from search&seid 17464946072274851468). ### Module call flow In order to better use this module, please understand the usage process. #### Prepare I2S recording module Configure an I2S.DEVICE_0 device and set the CHANNEL_0 channel to the recording input. ```python from Maix import GPIO, I2S from fpioa_manager import fm fm.register(20,fm.fpioa.I2S0_IN_D0, force True) fm.register(18,fm.fpioa.I2S0_SCLK, force True) # dock 32 fm.register(19,fm.fpioa.I2S0_WS, force True) # dock 30 rx I2S(I2S.DEVICE_0) rx.channel_config(rx.CHANNEL_0, rx.RECEIVER, align_mode I2S.STANDARD_MODE) rx.set_sample_rate(16000) print(rx) ``` operation result: ```shell [MAIXPY]i2s0:(sampling rate 16003, sampling points 1024) [MAIXPY]channle0:(resolution 2, cycles 2, align_mode 1, mode 1) [MAIXPY]channle1:(resolution 0, cycles 0, align_mode 0, mode 0) [MAIXPY]channle2:(resolution 0, cycles 0, align_mode 0, mode 0) [MAIXPY]channle3:(resolution 0, cycles 0, align_mode 0, mode 0) ``` #### Create an isolated word module The parameters initialized by isolated_word are as follows: [dmac] The DMA channel used for recording. [Channel 2] is used by default. [i2s] Recording device, I2S.DEVICE_0 is used by default. [size] The capacity of vocabulary templates, which means the total number of templates that can be loaded. The default is 10. [shift] Channel selection. Maix series hardware recording devices usually use mono input. Set 0 as the left channel, so 1 is the right channel. ```python from speech_recognizer import isolated_word # default: maix dock / maix duino set shift 0 sr isolated_word(dmac 2, i2s I2S.DEVICE_0, size 10, shift 0) # maix bit set shift 1 print(sr.size()) print(sr) ## threshold sr.set_threshold(0, 0, 10000) ``` The results are as follows: ```shell 10 [MAIXPY] isolated_word:(80212a60) mfcc_dats 8023a060 size 10 i2s_device_number_t 0 dmac_channel_number_t 2 ``` #### Entry vocabulary template Call the following code: If the surrounding environment is very noisy, it will output 2 (isolated_word.Ready) to 3 (isolated_word.MaybeNoise) repeatedly, and you need to be in a quiet environment to enter the vocabulary template If the status is isolated_word.Speak, it means you can speak If you run sr.record(0) and its status changes to isolated_word.Done, it means the recording is complete and it will be saved to the template number 0. You can check the current module status through sr.state() ```python ## record and get & set while True: time.sleep_ms(100) print(sr.state()) if sr.Done sr.record(0): data sr.get(0) print(data) break if sr.Speak sr.state(): print('speak A') #sr.set(1, data) ``` In the same way, if you want to enter the second [Vocabulary Template], you only need to change the entry position, such as to sr.record(1) (the computer storage array starts counting from 0). #### Identify vocabulary templates Assuming that you have entered [Vocabulary Template], call the following code, it will continue to recognize the current voice and start matching the entered [Vocabulary Template], which is the so called isolated word speech recognition. ```python print('recognizer') while True: time.sleep_ms(200) #print(sr.state()) #print(sr.dtw(data)) if sr.Done sr.recognize(): res sr.result() print(res) ``` The final effect is to print out the best matching [word template] number and related data. For details, please check the result function usage. You can judge whether the recognition is reasonable according to the actual situation, such as whether the matching frame length/matching degree meets expectations , Too large or too small are unreasonable."},"/soft/maixpy/en/course/speech/fft.html":{"title":"FFT signal processing","content":" title: FFT signal processing keywords: maixpy, k210, AIOT, edge computing desc: maixpy FFT signal processing FFT is Fast Fourier Transform (Fast Fourier Transform), which converts time domain signals into frequency domain signals, and has a wide range of applications, such as eliminating audio image noise. ## Instructions k210 is equipped with a hardware FFT module, which supports 64 point, 128 point, 256 point and 512 point FFT. * Import FFT module ```python import FFT ``` * Input time domain data (such as audio data) and perform FFT operation ```python res FFT.run(data, points, shift) ``` For related API explanation, please refer to [FFT API](../../api_reference/Maix/fft.html) ## Routine Collect sound and perform FFT calculation, and display the calculated data as a histogram on the screen: [demo_fft_spectrum](https://github.com/sipeed/MaixPy v1_scripts/blob/master/hardware/demo_fft_spectrum.py) effect: <iframe width \"600\" height \"350\" src \"//player.bilibili.com/player.html?aid 44617696&cid 78104545&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\"> </iframe>"},"/soft/maixpy/en/course/speech/recognizer_cnn.html":{"title":"maix asr (automatic speech recognition)","content":" title: maix asr (automatic speech recognition) keywords: maixpy, k210, AIOT, edge computing desc: maixpy maix asr (automatic speech recognition) > **This document has passed the MaixPy 0.5.1_128 minimum_speech_with_ide_support firmware test. Please make sure that the recording function/call model is available before use.** This is a speech recognition module based on an acoustic model. When the user sets a vocabulary composed of pinyin and loads it into the module, the user can start recording to recognize the vocabulary input by the user and return a list of possible matching words. > I recently received some feedback on February 1, 2021, confirming that some students can't get results when running under the IDE. At this time, please switch to Menu>Run in the terminal to see the results. ## Instructions **Warning** Students who don't know how to use the recording and call the model, please learn the prerequisite skills before using this document. Burn acoustic model > After TODO, it will be stored in a unified link to the download station. Get the acoustic model [maix_asr_2900k_0x500000](https://github.com/sipeed/MaixPy v1_scripts/blob/master/multimedia/speech_recognizer/maix_asr_2900k_0x500000.kmodel) from here, and burn it to 0x500000 address. > Load the module without burning the model, it will core dump, don't ask how to report the error. Create recording equipment This module supports all Maix series hardware. We only need to configure an I2S.DEVICE_0 device and set CHANNEL_0 to the recording input. If it is Cube and amigo, you need to configure the specific audio decoder chip first, and then turn on the I2C recording device. ```python from Maix import GPIO, I2S from fpioa_manager import fm fm.register(20,fm.fpioa.I2S0_IN_D0, force True) fm.register(18,fm.fpioa.I2S0_SCLK, force True) # dock 32 fm.register(19,fm.fpioa.I2S0_WS, force True) # dock 30 rx I2S(I2S.DEVICE_0) rx.channel_config(rx.CHANNEL_0, rx.RECEIVER, align_mode I2S.STANDARD_MODE) rx.set_sample_rate(16000) print(rx) ``` Create an auxiliary class for maix_asr, you can skip it. ```python from speech_recognizer import asr class maix_asr(asr): asr_vocab [\"lv\", \"shi\", \"yang\", \"chun\", \"yan\", \"jing\", \"da\", \"kuai\", \"wen\", \"zhang\", \"de\", \"di\" , \"se\", \"si\", \"yue\", \"lin\", \"luan\", \"geng\", \"xian\", \"huo\", \"xiu\", \"mei\", \"yi\", \"ang\", \" ran\", \"ta\", \"jin\", \"ping\", \"yao\", \"bu\", \"li\", \"liang\", \"zai\", \"yong\", \"dao\", \"shang\", \"xia\" , \"fan\", \"teng\", \"dong\", \"she\", \"xing\", \"zhuang\", \"ru\", \"hai\", \"tun\", \"zhi\", \"tou\", \"you\", \" ling\", \"pao\", \"hao\", \"le\", \"zha\", \"zen\", \"me\", \"zheng\", \"cai\", \"ya\", \"shu\", \"tuo\", \"qu\" , \"fu\", \"guang\", \"bang\", \"zi\", \"chong\", \"shui\", \"cuan\", \"ke\", \"shei\", \"wan\", \"hou\", \"zhao\", \" jian\", \"zuo\", \"cu\", \"hei\", \"yu\", \"ce\", \"ming\", \"dui\", \"cheng\", \"men\", \"wo\", \"bei\", \"dai\" , \"zhe\", \"hu\", \"jiao\", \"pang\", \"ji\", \"lao\", \"nong\", \"kang\", \"yuan\", \"chao\", \"hui\", \"xiang\", \" bing\", \"qi\", \"chang\", \"nian\", \"jia\", \"tu\", \"bi\", \"pin\", \"xi\", \"zou\", \"chu\", \"cun\", \"wang\" , \"na\", \"ge\", \"an\", \"ning\", \"tian\", \"xiao\", \"zhong\", \"shen\", \"nan\", \"er\", \"ri\", \"zhu\", \" xin\", \"wai\", \"luo\", \"gang\", \"qing\", \"xun\", \"te\", \"cong\", \"gan\", \"lai\", \"he\", \"dan\", \"wei\" , \"die \", \"kai\", \"ci\", \"gu\", \"neng\", \"ba\", \"bao\", \"xue\", \"shuai\", \"dou\", \"cao\", \"mao\", \"bo\", \"zhou\", \"lie\", \"qie\", \"ju\", \"chuan\", \"guo\", \"lan\", \"ni\", \"tang\", \"ban\", \"su\", \"quan\", \"huan \", \"ying\", \"a\", \"min\", \"meng\", \"wu\", \"tai\", \"hua\", \"xie\", \"pai\", \"huang\", \"gua\", \"jiang\", \"pian\", \"ma\", \"jie\", \"wa\", \"san\", \"ka\", \"zong\", \"nv\", \"gao\", \"ye\", \"biao\", \"bie\", \"zui \", \"ren\", \"jun\", \"duo\", \"ze\", \"tan\", \"mu\", \"gui\", \"qiu\", \"bai\", \"sang\", \"jiu\", \"yin\", \"huai\", \"rang\", \"zan\", \"shuo\", \"sha\", \"ben\", \"yun\", \"la\", \"cuo\", \"hang\", \"ha\", \"tuan\", \"gong \", \"shan\", \"ai\", \"kou\", \"zhen\", \"qiong\", \"ding\", \"dang\", \"que\", \"weng\", \"qian\", \"feng\", \"jue\", \"zhuan\", \"ceng\", \"zu\", \"bian\", \"nei\", \"sheng\", \"chan\", \"zao\", \"fang\", \"qin\", \"e\", \"lian\", \"fa \", \"lu\", \"sun\", \"xu\", \"deng\", \"guan\", \"shou\", \"mo\", \"zhan\", \"po\", \"pi\", \"gun\", \"shuang\", \"qiang\", \"kao\", \"hong\", \"kan\", \"dian\", \"kong\", \"pei\", \"tong\", \"ting\", \"zang\", \"kuang\", \"reng\", \"ti \", \"pan\", \"heng\", \"chi\", \"lun\", \"kun\", \"han\", \"lei\", \"zuan\", \"man\", \"sen\", \"duan\", \"leng\", \"su i\", \"gai\", \"ga\", \"fou\", \"kuo\", \"ou\", \"suo\", \"sou\", \"nu\", \"du\", \"mian\", \"chou\", \"hen\" , \"kua\", \"shao\", \"rou\", \"xuan\", \"can\", \"sai\", \"dun\", \"niao\", \"chui\", \"chen\", \"hun\", \"peng\", \" fen\", \"cang\", \"gen\", \"shua\", \"chuo\", \"shun\", \"cha\", \"gou\", \"mai\", \"liu\", \"diao\", \"tao\", \"niu\" , \"mi\", \"chai\", \"long\", \"guai\", \"xiong\", \"mou\", \"rong\", \"ku\", \"song\", \"che\", \"sao\", \"piao\", \" pu\", \"tui\", \"lang\", \"chuang\", \"keng\", \"liao\", \"miao\", \"zhui\", \"nai\", \"lou\", \"bin\", \"juan\", \"zhua\" , \"run\", \"zeng\", \"ao\", \"re\", \"pa\", \"qun\", \"lia\", \"cou\", \"tie\", \"zhai\", \"kuan\", \"kui\", \" cui\", \"mie\", \"fei\", \"tiao\", \"nuo\", \"gei\", \"ca\", \"zhun\", \"nie\", \"mang\", \"zhuo\", \"pen\", \"zun\" , \"niang\", \"suan\", \"nao\", \"ruan\", \"qiao\", \"fo\", \"rui\", \"rao\", \"ruo\", \"zei\", \"en\", \"za\", \" diu\", \"nve\", \"sa\", \"nin\", \"shai\", \"nen\", \"ken\", \"chuai\", \"shuan\", \"beng\", \"ne\", \"lve\", \"qia\" , \"jiong\", \"pie\", \"seng\", \"nuan\", \"nang\", \"miu\", \"pou\", \"cen\", \"dia\", \"o\", \"zhuai\", \"yo\", \" dei\", \"n\", \"ei\", \"nou\", \"bia\", \"eng\", \"den\", \"_\"] def get_asr_list(string 'xiao ai fas tong xue'): return [__class__.asr_vocab.index(t) for t in string.split(' ') if t in __class__.asr_vocab] def get_asr_string(listobj [117, 214, 257, 144]): return' '.join([__class__.asr_vocab[t] for t in listobj if t <len(__class__.asr_vocab)]) def unit_test(): print(__class__.get_asr_list('xiao ai')) print(__class__.get_asr_string(__class__.get_asr_list('xiao ai fas tong xue'))) def config(self, sets): self.set([(sets[key], __class__.get_asr_list(key)) for key in sets]) def recognize(self): res self.result() # print(tmp) if res ! None: sets {} for tmp in res: sets[__class__.get_asr_string(tmp[1])] tmp[0] #print(tmp[0], get_asr_string(tmp[1])) return sets return None from machine import Timer def on_timer(timer): #print(\"time up:\",timer) #print(\"param:\",timer.callback_arg()) timer.callback_arg().state() try: # default: maix dock / maix duino set shift 0 t maix_asr(0x500000, I2S.DEVICE_0, 3, shift 0) # maix bit set shift 1 tim Timer(Timer.TIMER0, Timer.CHANNEL0, mode Timer.MODE_PERIODIC, period 64, callback on_timer, arg t) tim.start() #for i in range(50): #time.sleep_ms(100) #t.stop() #for i in range(50): #time.sleep_ms(100) #t.run() t.config({ 'xiao ai ya': 0.3, 'hao de ya': 0.2, 'ni hao ya': 0.3, }) print(t.get()) while True: #time.sleep(1) tmp t.recognize() # print(tmp) if tmp ! None: print(tmp) except Exception as e: print(e) finally: tim.stop() t.__del__() del t ``` Speak into the microphone We can see that the following words are defined in the code: ```python t.config({ 'xiao ai': 0.3, 'hao de': 0.2, 'ni hao': 0.3, }) print(t.get()) ``` That is, you can complete the recognition by saying [ni hao], [hao de], and [xiao ai] into the microphone within 6 seconds. The configuration items are two fields, and the length of the first field does not exceed six.Group Pinyin, the second field indicates the lowest threshold of recognition (matching threshold). If it is higher than this value, it will be printed, and if it is lower than this value, it will be discarded. At the beginning of the test, you can speak a little louder, see [Demo Video](https://www.bilibili.com/video/BV1C5411L7JC/) for specific effects, complete example: [test_maix_asr.py](https://github.com/sipeed/MaixPy v1_scripts/blob/d1d95a4d2fbe4c4b87d683c5fb79fda1fe3f9aae/multimedia/speech_recognizer/test_maix_asr.py)"},"/soft/maixpy/en/course/media/video.html":{"title":"Use of video","content":" title: Use of video keywords: maixpy, k210, AIOT, edge computing desc: maixpy video (video) use Detailed API reference: [video API](./../../api_reference/media/video.html) ## Instructions > MaixAmigo, MaixCube needs [Initialize ES8374 audio decoder chip](https://github.com/sipeed/MaixPy v1_scripts/blob/master/modules/others/es8374/es8374.py) before using audio * Create a video object, set the volume ```python import video v video.open(\"/sd/badapple.avi\") v.volume(50) ``` * Initialize lcd, used to play the screen ```python import lcd lcd.init() ``` * Create I2S to process audio objects ```python from Maix import GPIO, I2S i2s I2S(I2S.DEVICE_0) i2s.channel_config(i2s.CHANNEL_1, I2S.TRANSMITTER, resolution I2S.RESOLUTION_16_BIT, cycles I2S.SCLK_CYCLES_32, align_mode I2S.RIGHT_JUSTIFYING_MODE) fm.register(34, fm.fpioa.I2S0_OUT_D1, force True) fm.register(35, fm.fpioa.I2S0_SCLK, force True) fm.register(33, fm.fpioa.I2S0_WS, force True) ``` * Play video ```python while True: if v.play() 0: print(\"play end\") break ``` * Recycling objects ```python v.__del__() ``` ## Routine > The avi file address in the test case: [badapple.avi](https://api.dl.sipeed.com/shareURL/MAIX/MaixPy/assets) * Play avi files: [video_play](https://github.com/sipeed/MaixPy v1_scripts/blob/master/multimedia/video/demo_video_play.py) * Use the camera to record the video as an avi file and save it: [record_video](https://github.com/sipeed/MaixPy v1_scripts/blob/master/multimedia/video/demo_video_record.py) * Sequentially capture and display each frame of avi video: [video_capture](https://github.com/sipeed/MaixPy v1_scripts/blob/master/multimedia/video/demo_video_capture.py) * Amigo play avi files: [amigo_play_video](https://github.com/sipeed/MaixPy v1_scripts/blob/master/multimedia/video/amigo_play_video.py)"},"/soft/maixpy/en/course/media/audio.html":{"title":"the use of audio","content":" title: the use of audio keywords: maixpy, k210, AIOT, edge computing desc: maixpy audio (audio) use Detailed API reference: [audio API](./../../api_reference/media/audio.html) ## Instructions > MaixAmigo, MaixCube needs [Initialize ES8374 audio decoder chip](https://github.com/sipeed/MaixPy v1_scripts/blob/master/modules/others/es8374/es8374.py) before using audio * Create audio object ```python import audio player audio.Audio(path \"/sd/6.wav\") ``` * Create I2S objects (used to process audio objects) ```python from Maix import I2S # init i2s(i2s0) wav_dev I2S(I2S.DEVICE_0) # config i2s according to audio info wav_dev.channel_config(wav_dev.CHANNEL_1, I2S.TRANSMITTER,resolution I2S.RESOLUTION_16_BIT ,cycles I2S.SCLK_CYCLES_32, align_mode I2S.RIGHT_JUSTIFYING_MODE) ``` * Get audio object information and associate I2S object ```python # read audio info wav_info player.play_process(wav_dev) print(\"wav file head information: \", wav_info) ``` * Configure I2S objects according to audio information ```python sample_rate wav_info[1] wav_dev.set_sample_rate(sample_rate) ``` * Use the associated I2S object to play audio ```python # loop to play audio while True: ret player.play() if ret None: print(\"format error\") break elif ret 0: print(\"end\") break ``` * End playback ```python player.finish() ``` ## Routine > Test audio address: [6.wav](https://github.com/sipeed/MaixPy v1_scripts/blob/master/multimedia/audio/6.wav) * Play wav files: [play_wav](https://github.com/sipeed/MaixPy v1_scripts/blob/master/multimedia/audio/play_wav.py) * Record audio as a wav file and save: [record_wav](https://github.com/sipeed/MaixPy v1_scripts/blob/master/multimedia/audio/record_wav.py)"},"/soft/maixpy/en/course/network/network_config.html":{"title":"How to connect MaixPy to the Internet","content":" title: How to connect MaixPy to the Internet keywords: maixpy, k210, AIOT, edge computing desc: maixpy How to connect MaixPy to the Internet > Big Rat 2020 11 26 Edit Since it is called AIOT, it can't be without networking. MaixPy now supports W5X00 / EPS32 / ESPAT and other networking methods, as shown below. ESP32 needs to be equipped with [dedicated SPI firmware](https://github.com/sipeed/Maixduino_esp32_fimware) to support TCP / UDP client. ESPAT works with Espressif[AT firmware (esp at)](https://github.com/espressif/esp at), and only supports TCP clients. W5X00 can be configured + used by connecting to the Internet cable, and supports TCP/UDP client. Before using the Socket, please connect the network first. The wired one needs to resolve the DNS and IP address, gateway, and the wireless one needs to fill in the WIFI account (SSID) and password. Do not ask \"Bug found!!! How to access No problem with Baidu (I don’t have internet access). ## Computer Network Foundation > If you don't know these basics, you can't use it. It is recommended to know the following keywords when applying MaixPy network function: What are network and socket? What is TCP \\ UDP? What is HTTP \\ HTTPS \\ MQTT \\ FTP? From the perspective of pragmatism, in maixpy ​​(micropython), the content about the network is divided into the most basic two layer interface. ### network Responsible for managing the interface of the network card. The network card is a type of hardware interface that sends the network data protocol from the hardware and belongs to the category of hardware. For example: Usually the main function of a WIFI network card is to connect to a wireless router to help users connect to the Internet, while a wired network card helps users connect to the Internet through a network cable. They will complete gateway configuration, DNS resolution, Ping request and other operations at this layer. If it is used as a server, it will also complete functions such as wireless network distribution and domain name resolution. ### socket The difference from the network card is that the socket is only responsible for the transmission of the data protocol at the application layer. It is usually encapsulated by the bottom PCB connection block into the common socket socket interface module. It mainly provides the connection transmission method of TCP/IP and UDP. Users can perform network programming based on this interface. #### What are TCP and UDP? On the basis of socket, we are divided into two typical transmission interfaces, TCP and UDP. The main emphasis is on whether the communication between the two applications is connected. If the connection is not maintained, the UDP connection method is used. If a long connection with the server is required, then When using TCP connection, please note that UDP and TCP ports are independent of each other and do not need to be confused. > TCP has a streaming long connection retransmission mechanism, through several types of internal timers and data congestion windows, it can be ensured that user data will not be lost to a certain extent, but there are cases of overtime waiting. > UDP does not need to be connected, and the data is directly transmitted in the form of broadcast to the upper switch and router, so UDP packets have a certain degree of penetration, and can penetrate data packets outside without configuration in the upper network (actual situation Will be changed). #### What is HTTP \\ HTTPS \\ MQTT \\ FTP? Based on this, communication protocols such as HTTP protocol running on port 80, HTTP and other communication protocols transmitted on port 443, FTP file transfer protocol on port 21, and application transfer protocols such as MQTT and WebSocket based on this can be expanded, but they are all Based on the functions completed by the original socket interface, the only difference is the encapsulated application protocol. ### How to network? Please select the corresponding networking script according to your own network situation, you can run it directly, or upload it to the hardware as a class library to facilitate subsequent socket development. You can use a script similar to the following to complete the network configuration, which is in the sample code Can know the specific usage. General verification usage: ```python import network_esp32 print(network_esp32) print(dir(network_esp32)) from network_esp32 import wifi print(wifi) '''ouput >>> <module'network_esp32' from'network_esp32.py'> ['__class__','__name__','__file__','GPIO','network','time','board_info','fm','wifi'] <class'wifi'> MicroPython v0.5.1 140 g7bf6445e7 dirty on 2020 11 26; Sipeed_M1 with kendryte k210 Type \"help()\" for more information. >>> ''' ``` Real environment usage: ```python SSID \"Sipeed_2.4G\" PASW \"xxxxxxxx\" def enable_esp32(): from network_esp32 import wifi if wifi.isconnected() False: for i in range(5): try: # Running within 3 seconds of power up can cause an SD load error # wifi.reset(is_hard False) wifi.reset(is_hard True) print('try AT connect wifi...') wifi.connect(SSID, PASW) if wifi.isconnected(): break except Exception as e: print(e) print('network state:', wifi.isconnected(), wifi.ifconfig()) enable_esp32() def enable_espat(): from network_espat import wifi if wifi.isconnected() False: for i in range(5): try: wifi.reset() print('try AT connect wifi...') wifi.connect(SSID, PASW) if wifi.isconnected(): break except Exception as e: print(e) print('network state:', wifi.isconnected(), wifi.ifconfig()) #enable_espat() ``` #### Maixduino + ESP32 Use Maixduino's esp32 to connect to the network and upload the library [network_esp32.py](https://github.com/sipeed/MaixPy v1_scripts/blob/master/network/network_esp32.py). ```python # This file is part of MaixPY # Copyright (c) sipeed.com # # Licensed under the MIT license: # http://www.opensource.org/licenses/mit license.php # import time, network from Maix import GPIO from fpioa_manager import fm class wifi(): nic None def reset(force False, reply 5, is_hard True): if force False and __class__.isconnected(): return True try: # IO map for ESP32 on Maixduino fm.register(25,fm.fpioa.GPIOHS10)#cs fm.register(8,fm.fpioa.GPIOHS11)#rst fm.register(9,fm.fpioa.GPIOHS12)#rdy if is_hard: print(\"Use Hareware SPI for other maixduino\") fm.register(28,fm.fpioa.SPI1_D0, force True)#mosi fm.register(26,fm.fpioa.SPI1_D1, force True)#miso fm.register(27,fm.fpioa.SPI1_SCLK, force True)#sclk __class__.nic network.ESP32_SPI(cs fm.fpioa.GPIOHS10, rst fm.fpioa.GPIOHS11, rdy fm.fpioa.GPIOHS12, spi 1) print(\"ESP32_SPI firmware version:\", __class__.nic.version()) else: # Running within 3 seconds of power up can cause an SD load error print(\"Use Software SPI for other hardware\") fm.register(28,fm.fpioa.GPIOHS13, force True)#mosi fm.register(26,fm.fpioa.GPIOHS14, force True)#miso fm.register(27,fm.fpioa.GPIOHS15, force True)#sclk __class__.nic network.ESP32_SPI(cs fm.fpioa.GPIOHS10,rst fm.fpioa.GPIOHS11,rdy fm.fpioa.GPIOHS12, mosi fm.fpioa.GPIOHS13,miso fm.fpioa.GPIOHS14,sclk fm.fpioa.GPIOHS15) print(\"ESP32_SPI firmware version:\", __class__.nic.version()) # time.sleep_ms(500) # wait at ready to connect except Exception as e: print(e) return False return True def connect(ssid \"wifi_name\", pasw \"pass_word\"): if __class__.nic ! None: return __class__.nic.connect(ssid, pasw) def ifconfig(): # should check ip ! 0.0.0.0 if __class__.nic ! None: return __class__.nic.ifconfig() def isconnected(): if __class__.nic ! None: return __class__.nic.isconnected() return False if __name__ \"__main__\": # It is recommended to callas a class library (upload network_espat.py) # from network_esp32 import wifi SSID \"Sipeed_2.4G\" PASW \"xxxxxxxx\" def check_wifi_net(reply 5): if wifi.isconnected() ! True: for i in range(reply): try: wifi.reset(is_hard True) print('try AT connect wifi...') wifi.connect(SSID, PASW) if wifi.isconnected(): break except Exception as e: print(e) return wifi.isconnected() if wifi.isconnected() False: check_wifi_net() print('network state:', wifi.isconnected(), wifi.ifconfig()) # The network is no longer configured repeatedly import socket sock socket.socket() # your send or recv # see other demo_socket_tcp.py / udp / http / mqtt sock.close() '''ouput MicroPython v0.5.1 136 g039f72b6c dirty on 2020 11 18; Sipeed_M1 with kendryte k210 Type \"help()\" for more information. >>> >>> >>> raw REPL; CTRL B to exit >OK Use Hareware SPI for other maixduino [esp32_spi] use hard spi(1) hard spi esp32 set hard spi clk:9159090 Get version fail try AT connect wifi... Use Hareware SPI for other maixduino [Warning] function is used by unknown(pin:10) [Warning] function is used by unknown(pin:6) [Warning] function is used by unknown(pin:11) [esp32_spi] use hard spi(1) hard spi esp32 set hard spi clk:9159090 ESP32_SPI firmware version: 1.4.0 try AT connect wifi... network state: True ('192.168.0.180', '255.255.255.0', '192.168.0.1') > MicroPython v0.5.1 136 g039f72b6c dirty on 2020 11 18; Sipeed_M1 with kendryte k210 Type \"help()\" for more information. >>> >>> >>> raw REPL; CTRL B to exit >OK network state: True ('192.168.0.180', '255.255.255.0', '192.168.0.1') > MicroPython v0.5.1 136 g039f72b6c dirty on 2020 11 18; Sipeed_M1 with kendryte k210 Type \"help()\" for more information. >>> ''' ``` #### AT firmware of ESP82XX Use the AT firmware of ESP8266/85 to connect to the Internet and upload the library [network_espat.py](https://github.com/sipeed/MaixPy v1_scripts/blob/master/network/network_espat.py) > `board_info` is related to the board, and different board configurations are different. [Manual configuration](../../api_reference/builtin_py/board_info.html) is required before use. ```python # This file is part of MaixPY # Copyright (c) sipeed.com # # Licensed under the MIT license: # http://www.opensource.org/licenses/mit license.php # import time, network from Maix import GPIO from machine import UART from fpioa_manager import fm from board import board_info class wifi(): __is_m1w__ True uart None eb None nic None def init(): if __class__.__is_m1w__: fm.register(0, fm.fpioa.GPIOHS1, force True) M1wPower GPIO(GPIO.GPIOHS1, GPIO.OUT) M1wPower.value(0) # b'\\r\\n ets Jan 8 2013,rst cause:1, boot mode:(7,6)\\r\\n\\r\\nwaiting for host\\r\\n' fm.register(board_info.WIFI_EN, fm.fpioa.GPIOHS0) # board_info.WIFI_EN IO 8 __class__.en GPIO(GPIO.GPIOHS0,GPIO.OUT) fm.register(board_info.WIFI_RX,fm.fpioa.UART2_TX) # board_info.WIFI_RX IO 7 fm.register(board_info.WIFI_TX,fm.fpioa.UART2_RX) # board_info.WIFI_TX IO 6 __class__.uart UART(UART.UART2, 115200, timeout 1000, read_buf_len 8192) def enable(en): __class__.en.value(en) def _at_cmd(cmd \"AT\\r\\n\", resp \"OK\\r\\n\", timeout 20): __class__.uart.write(cmd) # \"AT+GMR\\r\\n\" time.sleep_ms(timeout) tmp __class__.uart.read() # print(tmp) if tmp and tmp.endswith(resp): return True return False def at_cmd(cmd \"AT\\r\\n\", timeout 20): __class__.uart.write(cmd) # \"AT+GMR\\r\\n\" time.sleep_ms(timeout) tmp __class__.uart.read() return tmp def reset(force False, reply 5): if force False and __class__.isconnected(): return True __class__.init() for i in range(reply): print('reset...') __class__.enable(False) time.sleep_ms(50) __class__.enable(True) time.sleep_ms(500) # at start> 500ms if __class__._at_cmd(timeout 500): break __class__._at_cmd() __class__._at_cmd('AT+UART_CUR 921600,8,1,0,0\\r\\n', \"OK\\r\\n\") __class__.uart UART(UART.UART2, 921600, timeout 1000, read_buf_len 10240) # important! baudrate too low or read_buf_len too small will loose data #print(__class__._at_cmd()) try: __class__.nic network.ESP8285(__class__.uart) time.sleep_ms(500) # wait at ready to connect except Exception as e: print(e) return False return True def connect(ssid \"wifi_name\", pasw \"pass_word\"): if __class__.nic ! None: return __class__.nic.connect(ssid, pasw) def ifconfig(): # should check ip ! 0.0.0.0 if __class__.nic ! None: return __class__.nic.ifconfig() def isconnected(): if __class__.nic ! None: return __class__.nic.isconnected() return False if __name__ \"__main__\": # It is recommended to callas a class library (upload network_espat.py) # from network_espat import wifi SSID \"Sipeed_2.4G\" PASW \"xxxxxxxx\" def check_wifi_net(reply 5): if wifi.isconnected() ! True: for i in range(reply): try: wifi.reset() print('try AT connect wifi...', wifi._at_cmd()) wifi.connect(SSID, PASW) if wifi.isconnected(): break except Exception as e: print(e) return wifi.isconnected() if wifi.isconnected() False: check_wifi_net() print('network state:', wifi.isconnected(), wifi.ifconfig()) # The network is no longer configured repeatedly import socket sock socket.socket() # your send or recv # see other demo_socket_tcp.py / udp / http / mqtt sock.close() '''ouput >>> raw REPL; CTRL B to exit >OK [Warning] function is used by fm.fpioa.GPIOHS1(pin:17) [Warning] function is used by fm.fpioa.GPIOHS0(pin:16) reset... try AT connect wifi... True could not connect to ssid Sipeed_2.4G reset... try AT connect wifi... True network state: True ('192.168.0.165', '255.255.255.0', '192.168.0.1', '0', '0','b0:b9:8a:5b:be:7f','Sipeed_2.4G' ) > MicroPython v0.5.1 136 g039f72b6c dirty on 2020 11 18; Sipeed_M1 with kendryte k210 Type \"help()\" for more information. >>> >>> >>> raw REPL; CTRL B to exit >OK network state: True ('192.168.0.165', '255.255.255.0', '192.168.0.1', '0', '0','b0:b9:8a:5b:be:7f','Sipeed_2.4G' ) > ''' ``` #### WIZNET5K by Spmod Use Spmod's WIZNET5K network card to connect to the Internet and upload the library [network_wiznet5k.py](https://github.com/sipeed/MaixPy v1_scripts/blob/master/network/network_wiznet5k.py) > vamoosebbf 2020 12 10 edit WIZNET5K is a wired network card module, you only need to plug in the network cable when using it, using the SPI protocol, this module is enabled by default in the complete firmware, but not in the minimum firmware. ```python spi1 SPI(4, mode SPI.MODE_MASTER, baudrate 600 * 1000, polarity 0, phase 0, bits 8, firstbit SPI.MSB, sck WIZNET5K_SPI_SCK, mosi WIZNET5K_SPI_MOSI, miso WIZNET5K_SPI_MISO) nic network.WIZNET5K(spi spi1, cs WIZNET5K_SPI_CS) print(\"Static IP: \", nic.ifconfig()) #dhcp Obtain IP dynamically, because the static IP has been set above, this step can be skipped. It should be noted that if you use DHCP, you must use an infinite loop like the following code, otherwise the acquisition will be unsuccessful while True: if(nic.dhclient()): print(\"DHCP IP:\", nic.ifconfig()) break; '''output >>> Static IP: ('192.168.0.117', '255.255.255.0', '192.168.0.1', '8.8.8.8') init dhcp DHCP IP: ('192.168.0.165', '255.255.255.0', '192.168.0.1', '8.8.8.8') ''' ``` ### Networking performance Please start using socket network programming after confirming the network and obtaining the IP address, and you have obtained the IP address as follows. ```shell network state: True ('192.168.0.165', '255.255.255.0', '192.168.0.1', '0', '0','b0:b9:8a:5b:be:7f','Sipeed_2.4G' ) ```"},"/soft/maixpy/en/course/network/socket_usage.html":{"title":"How to use Socket network programming","content":" title: How to use Socket network programming keywords: maixpy, k210, AIOT, edge computing desc: maixpy How to use Socket network programming > Big Rat 2020 11 26 edit, so far MaixPy's socket module has not yet implemented interfaces such as listen / bind / accept. ## How to use TCP and UDP clients to connect to the server Assuming that the basic content of [How to connect MaixPy to the network](./network_config.html) is known, run the sample code directly. * Warning: Don’t ask: \"Why can’t you access the network without a network connection!\" Please confirm the address and port before using the following client code. ### Prepare client code There are the following types of typical client code: TCP client [demo_socket_tcp_client.py](https://github.com/sipeed/MaixPy v1_scripts/blob/master/network/demo_socket_tcp_client.py) UDP client [demo_socket_udp_client.py](https://github.com/sipeed/MaixPy v1_scripts/blob/master/network/demo_socket_udp_client.py) TCP video transmission client [demo_socket_pic_client.py](https://github.com/sipeed/MaixPy v1_scripts/blob/master/network/demo_socket_pic_client.py) ### Prepare debugging tools (server code) Commonly used in network debugging assistants, or running the provided Python3 server script on your computer. TCP server [demo_socket_tcp_server.py](https://github.com/sipeed/MaixPy v1_scripts/blob/master/network/demo_socket_tcp_server.py) UDP server [demo_socket_udp_server.py](https://github.com/sipeed/MaixPy v1_scripts/blob/master/network/demo_socket_udp_server.py) TCP image transmission server [demo_socket_pic_server.py](https://github.com/sipeed/MaixPy v1_scripts/blob/master/network/demo_socket_pic_server.py) First start a network service with a known IP address and port, and wait for MaixPy as a client to send data to the server. ### Examples of typical client code TCP ```python import socket ADDR (\"192.168.0.107\", 60000) sock socket.socket() sock.connect(ADDR) sock.settimeout(1) while 1: sock.send(\"hello\\n\") #data sock.recv(10) # old maxipy have bug (recv timeout no return last data) #print(data) # fix try: data b\"\" while True: tmp sock.recv(1) print(tmp) if len(tmp) 0: raise Exception('timeout or disconnected') data + tmp except Exception as e: print(\"rcv:\", len(data), data) #time.sleep(2) sock.close() ``` UDP ```python import socket ADDR (\"192.168.0.107\", 60000) sock socket.socket(socket.AF_INET, socket.SOCK_DGRAM) sock.settimeout(1) while 1: try: sock.sendto(\"hello\\n\", ADDR) data, addr sock.recvfrom(1024) except Exception as e: print(\"receive error:\", e) continue print(\"addr:\", addr, \"data:\", data) time.sleep(2) sock.close() ''' >>> raw REPL; CTRL B to exit >OK network state: True ('192.168.0.186', '255.255.255.0', '192.168.0.1') addr: ('192.168.0.107', 60000) data: b'HELLO\\n' addr: ('192.168.0.107', 60000) data: b'HELLO\\n' addr: ('192.168.0.107', 60000) data: b'HELLO\\n' ''' ``` ### Other network functions The following are special function codes. #### esp32's ping [demo_esp32_ping.py](https://github.com/sipeed/MaixPy v1_scripts/blob/master/network/demo_esp32_ping.py) ```shell ESP32_SPI firmware version: 1.4.0 try AT connect wifi... network state: True ('192.168.0.180', '255.255.255.0', '192.168.0.1') ping baidu.com: 40 ms > MicroPython v0.5.1 136 g039f72b6c dirty on 2020 11 18; Sipeed_M1 with kendryte k210 Type \"help()\" for more information. >>> ``` #### ADC of esp32 [demo_esp32_read_adc.py](https://github.com/sipeed/MaixPy v1_scripts/blob/master/network/demo_esp32_read_adc.py) ```shell MicroPython v0.5.1 136 g039f72b6c dirty on 2020 11 18; Sipeed_M1 with kendryte k210 Type \"help()\" for more information. >>> raw REPL; CTRL B to exit >OK (2370, 3102, 3071) 2017 2753 0977 2709 0963 0855: adc 0617 0757 0150 0095 0133 0153: adc 1319 1478 0955 0939 0698 0619: adc 2403 3231 3299 3298 1483 0779: adc 1119 1815 1274 1315 0230 0255: adc 0951 0951 0295 0283 0319 0399: adc 2175 2769 2576 2579 1487 1104: adc 1995 2846 2647 2699 0839 0441: adc ``` > In fact, espAT also obtains ADC in this way, but it can only be used on designated pins. #### HTTP support [demo_http_get_jpg.py](https://github.com/sipeed/MaixPy v1_scripts/blob/master/network/demo_http_get_jpg.py) #### https support This function is not compiled by default, but what is provided is the use of HTTP, and HTTP and HTTPS are only the difference of the path url. Note that the IP resolution of https depends on the firmware of the network card and is not completed on the K210. [demo_socket_https.py](https://github.com/sipeed/MaixPy v1_scripts/blob/master/network/demo_socket_https.py) #### scan WIFI AP hotspot of esp32, 82XX [demo_esp32_ap_scan.py](https://github.com/sipeed/MaixPy v1_scripts/blob/master/network/demo_esp32_ap_scan.py) [demo_espat_ap_scan.py](https://github.com/sipeed/MaixPy v1_scripts/blob/master/network/demo_espat_ap_scan.py) ```python ''' >>> raw REPL; CTRL B to exit >OK SSID: Sipeed_2.4G, ENC: WPA/WPA2 PSK, RSSI: 57 SSID: ChinaNet Ffdj, ENC: WPA/WPA2 PSK, RSSI: 58 SSID: wea_615, ENC:WPA/WPA2 PSK, RSSI: 67 SSID: ChinaNet PnAN, ENC: WPA/WPA2 PSK, RSSI: 70 SSID: wea_613, ENC:WPA/WPA2 PSK, RSSI: 73 SSID: ChinaNet TnSG, ENC: WPA/WPA2 PSK, RSSI: 82 SSID: chipshine_GUEST, ENC:WPA/WPA2 PSK, RSSI: 83 SSID: ASUS, ENC: WPA/WPA2 PSK, RSSI: 86 SSID: gta888, ENC: WPA/WPA2 PSK, RSSI: 87 SSID: huahua, ENC: WPA/WPA2 PSK, RSSI: 88 > MicroPython v0.5.1 136 g039f72b6c dirty on 2020 11 18; Sipeed_M1 with kendryte k210 Type \"help()\" for more information. >>> ''' ``` #### mqtt support This is the code provided by the official repository of micropython. If it is for commercial use, please configure the socket as non blocking and add the MQTT keep alive protocol. [demo_socket_mqtt.py](https://github.com/sipeed/MaixPy v1_scripts/blob/master/network/demo_socket_mqtt.py) #### Update the AT firmware of ESP82XX > This is a function provided for the AT firmware, so you can understand it naturally. [demo_espat_ap_test.py](https://github.com/sipeed/MaixPy v1_scripts/blob/master/network/demo_espat_ap_test.py) [espat_upgrade.py](https://github.com/sipeed/MaixPy v1_scripts/blob/master/network/espat_upgrade.py)"},"/soft/maixpy/en/course/advance/project_framework.html":{"title":"Code frame structure","content":" title: Code frame structure keywords: maixpy, k210, AIOT, edge computing desc: maixpy code frame structure ## Directory Introduction Directory Sub directory Sub directory 2 Sub directory 3 Content summary assets Resource files projects Project files, one project per folder tools Tools components┐ components └ boards Board code └ drivers Drive └ micropython ┐ micropython related code └ core micropython source code └ port┐ maixpy ​​custom part source code └ builtin_py maixpy ​​default built in class └ include Porting some header files └ src Function module source code └ spiffs SPIFFS file system └ utils Tools (Function) > The current code is not very well structured in the `components/micropython/port/src` directory due to historical reasons. The future code should follow the current framework as much as possible to achieve a hierarchy ## Add code The project is organized using `CMake`, and the project supports multiple configurable options (`Kconfig`) * If you do not add folders and configuration items, you can add files and compile them in the existing folders * If you need to add modules, you can modify `CMakeLists.txt` to add content, you can refer to the less content [c_cpp_project_framework](https://github.com/Neutree/c_cpp_project_framework) * If you need to add configuration items, you can modify the `Kconfig` file to achieve the goal. All configuration items will generate macro definitions and add them to `global_config.h` (generated files) during compilation, and in `CmakeLists.txt` This macro definition can be used in all files. > For example, define `config BOARD_M5STICK` in Kconfig, in CMakeLists.txt, you can determine whether to compile specific code by judging whether CONFIG_BOARD_M5STICK is true. When compiling, you can choose whether to check it through `python3 project.py menuconfig`"},"/soft/maixpy/en/course/advance/compile.html":{"title":"How to complie","content":" title: How to complie keywords: maixpy, k210, AIOT, edge computing desc: maixpy How to complie This article is an open source project development document written to help some users who want to become developers. ## Get maixpy ​​open source project Please prepare the linux system environment (WSL on Windows is also possible), hook up the XXX proxy, enter `git clone https://github.com/sipeed/MaixPy` to pull the MaixPy warehouse code and submodules, and make sure to read the catalog after you get it [Build.md](https://github.com/sipeed/MaixPy v1/blob/master/build.md) document under. > Students who do not have an agent can use the github mirror station list (`https://github.com/rc1844/fastgithub`) to accelerate the pull of the maixpy ​​repository. Please do not use gitee to pull the maixpy ​​repository, which will drop the submodule repository. ``` juwan@juwan N85 N870HL:~$ git clone https://gitclone.com/github.com/sipeed/MaixPy Cloning to'MaixPy'... remote: Object count: 77517, completed. remote: Compressed object: 100% (20929/20929), complete. remote: Total 77517 (delta 56791), reused 76050 (delta 55761) Among the recipients: 100% (77517/77517), 53.62 MiB 972.00 KiB/s, completed. Processing delta: 100% (56791/56791), complete. juwan@juwan N85 N870HL:~$ cd MaixPy/ juwan@juwan N85 N870HL:~/MaixPy$ git submodule update recursive init The submodule'components/kendryte_sdk/kendryte standalone sdk' (https://github.com/sipeed/kendryte standalone sdk) has been registered to the path'components/kendryte_sdk/kendryte standalone sdk' The submodule'components/micropython/core' (https://github.com/micropython/micropython.git) has been registered to the path'components/micropython/core' The submodule'components/micropython/port/src/lvgl/lv_bindings' (https://github.com/littlevgl/lv_binding_micropython.git) has been registered to the path'components/micropython/port/src/lvgl/lv_bindings' The submodule'components/micropython/port/src/ulab/micropython ulab' (https://github.com/Neutree/micropython ulab.git) has been updated to the path'components/micropython/port/src/ulab/micropython ulab' sign up The submodule'components/spiffs/core' (https://github.com/pellepl/spiffs.git) has been registered to the path'components/spiffs/core' The submodule'tools/flash/kflash_py' (https://github.com/sipeed/kflash.py.git) has been registered to the path'tools/flash/kflash_py' The submodule'tools/kconfig/Kconfiglib' (https://github.com/ulfalizer/Kconfiglib.git) has been registered to the path'tools/kconfig/Kconfiglib' The submodule'tools/spiffs/mkspiffs' (https://github.com/igrr/mkspiffs.git) has been registered to the path'tools/spiffs/mkspiffs' Cloning to'/home/juwan/MaixPy/components/kendryte_sdk/kendryte standalone sdk'... Cloning to'/home/juwan/MaixPy/components/micropython/core'... ``` Note that there is no acceleration in pulling the sub repository after this, and you will try to pull it from github. You can also use the same method to pull the sub module location separately (defined in `.gitmodules`). This document cannot help you Solve network problems. > If https://gitclone.com is down, try to find other lines by yourself. How to confirm whether the final submodule is pulled completely, you can enter `git submodule status`, please do not compile if it is incomplete, there will be errors. ```shell juwan@juwan N85 N870HL:~/Desktop/maixpy$ git submodule status 7fdb511fe61026eec5874885de5981c4f60f664d components/kendryte_sdk/kendryte standalone sdk (v0.5.2 181 g7fdb511) ced340d739e84737dd5c8e6b4ab9af2ea44e29e7 components/micropython/core (v1.11 64 gced340d73) ddf09164ee1711a61169030a7ee8bf370ee5743f components/micropython/port/src/lvgl/lv_bindings (remotes/origin/dev 6.0 32 gddf0916) c315a571df49a19b843f7dffc300c21ccb7d4edd components/micropython/port/src/ulab/micropython ulab (0.24 27 gc315a57) ec68ba8208d7550860e4e78299d58a529b88bf85 components/spiffs/core (0.2 234 gec68ba8) 1ef6f4c0b2cb8b1872b6ffe9337f4e02d5487fa6 tools/flash/kflash_py (v1.0 79 g1ef6f4c) 53c72959ac4d71f99913e4b0eea99261a6585430 tools/kconfig/Kconfiglib (v12.12.1 14 g53c7295) 983970e40ff381d95d68a9bddff70c4d9921021b tools/spiffs/mkspiffs (0.2.3 6 g983970e) ``` ### Compile maixpy ​​open source project > This section assumes that you do not have any experience in building cross compilation chains. First press [build.md](https://github.com/sipeed/MaixPy v1/blob/master/build.md) to perform various operations in order. If you don’t speak English, you can open a translator. The steps are as follows: nstall the necessary compilation tools and Python modules for the linux environment, and make sure cmake / make / python3 are available. Set the toolchain toolchain to the directory `/opt/kendryte toolchain/` in the system to facilitate the SDK to find the compilation tool, and ensure that the /opt/kendryte toolchain/bin/riscv64 unknown elf gcc compilation tool exists. Enter `cd projects/maixpy_k210` under the specific hardware project of MaixPy and enter `python3 project.py build` to start compiling. This is the end of the entire compilation step. After successful compilation, you will get a build folder in the `projects/maixpy_k210` directory, which contains the following files: maixpy.bin will be burned to the K210 firmware at address 0x000000. maixpy.txt The content of the decompiled code corresponding to the current firmware, to help you check the information of the pointer address of the core dump. Other files are .a and .o intermediate files generated during the compilation process and can be ignored. ### Burn maixpy ​​firmware to your hardware Now you get the maixpy.bin firmware, insert the hardware, and then use `python3 project.py B goE p /dev/ttyUSB1 b 1500000 flash` to burn the hardware. Take the ` B` parameter as an example. ```shell juwan@juwan N85 N870HL:~/Desktop/maixpy/projects/maixpy_k210$ python3 project.py h SDK_PATH:/home/juwan/Desktop/maixpy maixpy usage: project.py [ h] [ p PORT] [ b BAUDRATE] [ t] [ n] [ s] [ B {dan,bit,bit_mic,goE,goD,maixduino,kd233,auto }] [ S] [ toolchain PATH] [ toolchain prefix PREFIX] [ config_file PATH] [ verbose] {config,build,rebuild,menuconfig,clean,distclean,clean_conf,flash} build tool, e.g. `python project.py build` ``` Among them, ` B goE` is the choice of version, and the optional items are `dan, bit, bit_mic, goE, goD, maixduino, kd233, auto` indicating the burning method, which has a lot to do with the specific hardware. Bit usually corresponds to the chip using CH340. maixduino usually corresponds to the chip using CH552. Specifically, you can try a variety of options, and you can also choose the BAUDRATE option of burning frequency 115200 and 1.500000. Of course, no matter which configuration, as long as it can be burned in, you need to check the help description of h for more usage methods. The common burning process is as follows: ```shell ➜ maixpy_k210_minimum git:(master) ✗ sudo kflash b 1500000 p /dev/ttyUSB0 build/maixpy.bin [sudo] fqr password: [INFO] COM Port Selected Manually: /dev/ttyUSB0 [INFO] Default baudrate is 115200, later it may be changed to the value you set. [INFO] Trying to Enter the ISP Mode... ._ [INFO] Automatically detected goE/kd233 [INFO] Greeting Message Detected, Start Downloading ISP Downloading ISP: 100.0% 10kiB/s [INFO] Booting From 0x80000000 [INFO] Wait For 0.1 second for ISP to Boot [INFO] Boot to Flashmode Successfully [INFO] Selected Baudrate: 1500000 [INFO] Baudrate changed, greeting with ISP again ... [INFO] Boot to Flashmode Successfully [INFO] Selected Flash: On Board [INFO] Initialization flash Successfully Programming BIN: 100.0% 47kiB/s [INFO] Rebooting... ``` ### Command line to connect hardware & run code You can basically use it up to this step. Here is a recommendation for some quick operations of linux or micropython during development. First, you can use minicom or picocom serial tool to enter the MicroPython terminal (add `&& picocom /dev/ttyUSB0 b 115200` after the burning command), then When entering micropython, you can press Ctrl + E to enter the paste mode, and then paste the code and enter Ctrl + D to end the input of the running code. ```python >>> hello world! >>> ``` In this way, you have completed quick verification and development, but if you want to debug a certain piece of functional code, you can upload the code directly through the command line via [mpfshell lite](https://github.com/junhuanchen/mpfshell lite) , Reset and run, and then report an error and debug. > Low level development of dynamic languages ​​often operate in this way, so we want to thank all developers who do interpreter interfaces for doing a lot of interface verification. ## MaixPy project application description Assuming that you already know how to use MaixPy project to develop, compile, and burn, then I will introduce the usage of some tools in depth, here only some common usage will be explained, and no detailed explanation will be expanded. ### Introduce cmake's project compilation method cmake is a tool that compiles and generates Makefile after writing code and rules through CMakeLists.txt. The usage and details are independent of Baidu. Here is a simple structured cmake project [Get_static_library_by_cmake](https://github.com/junhuanchen/Get_static_library_by_cmake.git) for You run and learn by reference. Before cmake, makefiles were used for project management. Until today, micropython officially still uses a double layer Makefile + inclue (makefile) project to manage multi version hardware. But MaixPy only adds micropython to its environment as a dependent library package, so in fact the software architecture design of MaixPy is built around the form of K210 software components. So you can go to the hello_world project in the maixpy ​​folder to see how it is composed. hello_world build compile main CMakeLists.txt config_defaults.mk project.py The MaixPy project has prepared a template for you to build the K210 project. Ignore the process of project construction here, and focus on the project configuration part that needs to be compiled and linked, that is, CMakeLists.txt under main. Its content is as follows. ```cmake ############### Add include ################## # list(APPEND ADD_INCLUDE \"include\" #) # list(APPEND ADD_PRIVATE_INCLUDE \"\") ############################################ ############ Add source files ################# list(APPEND ADD_SRCS \"src/main.cpp\" ) # aux_source_directory(src ADD_SRCS) # list(REMOVE_ITEM COMPONENT_SRCS \"src/test2.c\") ############################################ ###### Add required/dependent components ###### list(APPEND ADD_REQUIREMENTS kendryte_sdk) ############################################ ############ Add static libs ################## # list(APPEND ADD_STATIC_LIB \"lib/libtest.a\") ############################################ register_component() ``` You can see that `ADD_SRCS` links a `src/main.cpp` code file as the program entry. You can load modules from other places through `ADD_REQUIREMENTS`. For example, `list(APPEND ADD_REQUIREMENTS kendryte_sdk)` requests the SDK package `kendryte_sdk`. What if you want to link your own nncase library? What about other library codes? It can be directly changed to the code of `LINK_DIRECTORIES(/home/juwan/maixpy/projects/maixpy_old/main/src/nncase)` under the absolute path. The premise of this is that the library is provided by the cmake project of. > Here is a demonstration of how to call your own nncase library during compilation, and read the project after combining these key information. It should be easier to use. ### How to package the micropython spiffs file system and share it If you use MaixPy for development, you will find that MaixUI provides a file system file (img). When you flash the same img as the UI system, you will directly enter the UI interface after burning. You need to know that MicroPython is a program starting from 0x0. In the program, the VFS (virtual file system) will be constructed in the [0xD00000, (0xD00000 + 0x300000)) interval of Flash through spiffs, which is defined in maixpy/projects/maixpy_xxxxx/config_defaults.mk owned. ```makefile CONFIG_SPIFFS_SIZE 0x300000 CONFIG_SPIFFS_START_ADDR 0xD00000 ``` > Only the use of tools is discussed here, without detailed explanation of its implementation. And [spiffs](https://github.com/pellepl/spiffs) does not support directory structure, then we will find that the file name of ui's img in flash will have a name like `lib/core.py`, Under normal circumstances, it is impossible for us to create this file, so we need to package it with tools. There is a gen_spiffs_image.py script in the tools/spiffs/mkspiffs directory to complete the function of this packaged image. For usage, please refer to the instructions in tools/spiffs/README.md. Prepare an fs folder under the spiffs directory, which contains the code or resource file content you want to package. Execute `python gen_spiffs_image.py ../../projects/maixpy_k210/config_defaults.mk` to get the maixpy_spiffs.img binary file. Burn the img obtained above to 0xD00000 to restore the content in the micropython file system. If you make some small systems and publish them in this way, users will get the img file you provided and burn them in and you will immediately get the same environment as you. This is actually the same as publishing a system image based on a Linux system. of. Now, have you learned it? ### MaixPy's continuous integration service (Travis CI) Travis CI provides continuous integration services (Continuous Integration, CI for short). It binds the projects on Github, as long as there is new code, it will be automatically crawled. Then, provide a running environment, perform tests, complete the build, and deploy to the server. Mention that MaixPy uses travis + tools/release.sh to compile the project and upload the compilation directory to the release server to complete the daily build. This is common in the automated build and compilation of various packages. You may be interested Try it yourself. > [Continuous Integration Service Travis CI Tutorial](http://www.ruanyifeng.com/blog/2017/12/travis_ci_tutorial.html) ### How to better read open source project source code Having said that, from a personal point of view, in addition to the basic requirement of reading code, if you want to better read the source code, there are different organizational structures for different projects. Any beginner who has just entered the industry , You can use the project you have experienced as an entry point, and gradually establish a complete software engineering awareness from the aspects of project architecture, source code, compilation, testing, and software release. It is also a good method to conduct in depth knowledge learning around this, I hope you You can build a complete software engineering system through this article. ## Final reference bing.com + keyword + yourself"},"/soft/maixpy/en/course/advance/add_c_module.html":{"title":"How to add a MaixPy module in C","content":" title: How to add a MaixPy module in C keywords: maixpy, k210, AIOT, edge computing desc: maixpy How to add a MaixPy module in C ## Preliminary knowledge Everything is an object in `python` You need to know what module, type, function, and class are, what are the relationships and differences * module (module) In `MaixPy`, the functions of each category are put into a module, For example, the built in `uos`, `usys`, `machine`, In addition, our own new file, such as `test.py`, can also be a module, We use modules like this: ```python import uos import machine import test ``` > In C source code, it is `mp_type_module` * type (type) Used to represent a basic type, it can contain some methods or variables > In C source code, it is `mp_type_type` * class (class) A class is actually a `type`, for example ```python class A:pass print(type(A)) ``` Will output ``` <class'type'> ``` When `A` is instantiated ``` class A:pass a A() print(type(a)) ``` Will output ``` <class'A'> ``` Indicates that `a` is an instance (object) of `A` > Defining a class in C is actually defining a `mp_type_type` ## Add module in C Our goal is to realize that the following code can be used at the `MaixPy` level: ```python import my_lib print(my_lib.__name__) my_lib.hello() ``` ### Create a new folder in the `components/port/src` directory, for example, name it `my_lib` ### Then create a new `my_lib.c` file under the `my_lib` folder ### Edit `my_lib.c` to add code #### Define a module: ```c #include \"obj.h\" const mp_obj_module_t my_lib_module { .base {&mp_type_module }, .globals (mp_obj_dict_t*)&mp_module_my_lib_globals_dict, }; ``` Here `my_lib_module` is the defined `my_lib` module object, `mp_type_module` indicates that it is a module, `mp_module_my_lib_globals_dict` is the global variables and functions of the module. It is a `dict` object, which has our own definitions. It has not been defined yet #### Define module global variables ```c STATIC mp_obj_t hello() { mp_printf(&mp_plat_print, \"hello from my_lib\"); return mp_const_none; } MP_DEFINE_CONST_FUN_OBJ_0(my_lib_func_hello_obj, my_lib_func_hello); STATIC const mp_map_elem_t my_lib_globals_table[] { {MP_OBJ_NEW_QSTR(MP_QSTR___name__), MP_OBJ_NEW_QSTR(MP_QSTR_my_lib) }, {MP_OBJ_NEW_QSTR(MP_QSTR_hello), (mp_obj_t)&my_lib_func_hello_obj }, }; STATIC MP_DEFINE_CONST_DICT ( mp_module_my_lib_globals_dict, my_lib_globals_table ); ``` Here defines a set of key value pair arrays, key value pair values, `mp_map_elem_t` is defined as follows: ```c typedef struct _mp_map_elem_t { mp_obj_t key; mp_obj_t value; } mp_map_elem_t; ``` * The first value is `key`, and the type is `str` object, which is called by `my_lib.key` at the level of `MaixPy`. Here, `MP_OBJ_NEW_QSTR(MP_QSTR___name__)` is used to generate a `str` object with a value of `__name__`. You may have questions about where the `__name__` this `c` variable is defined. This is automatically generated by the tool during the compilation phase `Variables, in short, remember this can be written to generate a constant `str` object and save it in the firmware. * The second value is a number, and the type is an object, which can be `str/function/int/float/tuple/list/dict`, etc., in the following way: * `str`: Here is also the definition of a `str` type value `my_lib`, that is, using `my_lib.__name__` at the level of `MaixPy` to get the result `my_lib`. * `Other constant objects`: You can use `mp_obj_new_xxx`, such as `int` variable `mp_obj_new_int(10)`, function search in `obj.h` * `Function`: The corresponding value of `key``hello` here is `(mp_obj_t)&my_lib_func_hello_obj`, which is a function object. Note that it is not a `C` function. As mentioned earlier, everything in `python` is an object. A function object is used, and then the address is cast to `mp_obj_t`. This function object uses the macro definition of `MP_DEFINE_CONST_FUN_OBJ_0` to define the `C` function of `my_lib_func_hello` as the object of `my_lib_func_hello_obj`. Note that the `hello` function needs to return a value `mp_const_none`, and note that it cannot return `NULL` because `NULL` `Not a (`MaixPy`) object, this return value is the return value when the `hello()` function is called at the `MaixPy` level > In addition to `MP_DEFINE_CONST_FUN_OBJ_0`, which has no parameters, there are also `1/2/3/n` parameters, as well as keywords with keywords. Please refer to the source code to learn by analogy Then use the `MP_DEFINE_CONST_DICT` macro definition to turn the key value pair of `my_lib_globals_table` into a `dict` object that can be understood at the `MaixPy` level (`mp_map_elem_t` is only understandable at the `C` level) `mp_module_my_lib_globals_dict`, this object is also the previous step Used when defining modules in At this point, the definition of a module is complete. At the level of `MaixPy`, in theory, the following statement can be used to use ```python import my_lib print(my_lib.__name__) my_lib.hello() ``` But we haven't compiled #### Add the module to the firmware and compile it * Add at the end of the `my_lib.c` file: ```c MP_REGISTER_MODULE(MP_QSTR_my_lib, my_lib_module, MODULE_MY_LIB_ENABLED); ``` This line of code registers the module, but whether it is compiled into the firmware depends on whether the macro definition of `MODULE_MY_LIB_ENABLED` is defined as `1` in `mpconfigport.h` * So we open the `mpconfigport.h` file and add ```c #define MODULE_MY_LIB_ENABLED (1) ``` * Open `components/micropython/CMakeLists.txt` to edit Find the place where there is `############## Add source files ###############` Add after ```cmake append_srcs_dir(MPY_PORT_SRCS \"port/src/my_lib\") ``` At this point, the project will compile the folder `my_lib` to the firmware Then `python project.py rebuild` can compile the firmware, because there are new files, you must use the `rebuild` command instead of `build`, pay attention to the compilation prompt, if there is an error, pay attention to modify ## Add a type to the module A `my_lib` module was previously defined, now we want to define a class in `my_lib`, called `A`, as follows ```python import my_lib a my_lib.A() print(a.add(1, 2)) ``` I only talk about the general idea here, and then provide a sample, you can understand it if you are smart * Define a `mp_obj_type_t` object, just like the previous definition of `mp_obj_module_t` * Similarly, give this class object a `dict` object, as a member of this class, the member can be a constant or function or even another `type` object * Register this class object to the previous `my_lib` module The definition of `mp_obj_type_t` object and member definition can refer to the implementation in `port/src/standard_lib/machine/machine_i2c.c` > When defining `mp_obj_type_t`, there is a `make_new` member, this function is used to create a new object function will be called, such as `a my_lib.A(); a.add(1,2)` > If you don't create a new object and call the class method or variable directly, this function will not be called `A.var_a` For example, we define a `const mp_obj_type_t my_lib_A_type ...` Then add this object to `my_lib_globals_table` in `my_lib/my_lib.c` and map it to `key` `A` ```c {MP_ROM_QSTR(MP_QSTR_A), MP_ROM_PTR(&my_lib_A_type) }, ``` ## Note when writing firmware in C language * `mp_printf` vs `printk` vs `printf`: Because `IDE` uses the serial communication protocol, do not directly use the `printk` or `printf` function to print messages at the `C` level, **must** use the `mp_printf` function to print, otherwise it will cause the `IDE` to run When receiving unintelligible data and disconnecting! ! Of course, you can use `printk` for debugging, because this function will not trigger a system interrupt and can be called in the interrupt function, but it is only used for debugging and must be deleted when the code is actually submitted! !"},"/soft/maixpy/en/course/advance/pack_fs.html":{"title":"Packaging file system","content":" title: Packaging file system keywords: maixpy, k210, AIOT, edge computing desc: maixpy packaging file system Pack several files on the PC into a SPIFFS file system image, use kflash to burn to a specific address in flash, these files can be read directly on the development board (MaixPy) For details, please see the instructions: [pack SPIFFS for MaixPy](https://github.com/sipeed/MaixPy v1tree/master/tools/spiffs) Operation example GIF: ![pack fs](https://cdn.sipeed.com/pack_spiffs_ops.gif) GIF alternate link: [pack_spiffs_ops.gif](../../../assets/course/advance/pack_spiffs_ops.gif)"},"/soft/maixpy/en/course/others/pye.html":{"title":"pye (Micropython Editor)","content":" title: pye (Micropython Editor) keywords: maixpy, k210, AIOT, edge computing desc: maixpy pye (Micropython Editor) In MaixPy, we have built in an open source editor [Micropython Editor(pye)](https://github.com/robert hh/Micropython Editor) > Note that this function is not included in the `minimum` version of the firmware Use `os.listdir()` to view the files in the current directory, Use `pye(\"hello.py\")` to create a file and enter the editing mode, and the instructions for using shortcut keys can be found in [here](https://github.com/robert hh/Micropython Editor/blob/master /Pyboard%20Editor.pdf) For example, we write code ```python print(\"hello maixpy\") ``` Then press `Ctrl+S` and press `Enter` to save, press `Ctrl+Q` to exit editing **Note**: The use of this editor has certain requirements for the serial tool used. The `BackSpace` key must be set to the `DEL` function, otherwise pressing `BackSpace` will call the same function as `Ctrl+H` ( That is character replacement). It is recommended to use `minicom` under Linux, you need to use `sudo minicom s` to set, refer to [previous tutorial](./../../get_started/env_serial_tools.html) The same is true under Windows, search the setting method according to the tool you use, such as `xshell` search `xshell How to set backspace to del` to get the result: `File` > `Properties` > `Terminal` > `Keyboard`, Change the sequence of delete and backspace to ASCII 127."},"/soft/maixpy/en/course/others/maixui.html":{"title":"MaixUI basic usage guide","content":" title: MaixUI basic usage guide keywords: maixpy, k210, AIOT, edge computing desc: maixpy MaixUI basic usage guide How to consume MaixUI items correctly? ## Why develop it? What is its meaning and existence value? There is always a basic requirement for the UI framework under any chip, but because the K210 cannot continue to use the LVGL environment while supporting the Ai function, the UI loses its original meaning. That is, when you can't use QT or LVGL, you want to be able to use Python to write UI applications, so the image based MaixUI UI framework was born. ## Requirements for MaixUI Based on the latest MaixPy firmware, the following requirements will be met on October 7, 2020. Ensure that MicroPython's GC memory is recyclable and controllable at all times. Ensure that the UI component code is independent, not included in the firmware, and can be debugged and modified. Ensure system stability, ensure that code and hardware resources can be re entered, and no core dump phenomenon will occur. Run reentrant, which means running dynamic code to show UI style, similar to HTML5 / CSS design. Python's exception capture is fed back to the screen in real time to quickly locate the error line. UI related drawing functions can be used in multiple decorations or run independently. All MicroPython hardware drivers provided by the framework can independently run corresponding unit tests. When the framework is running, it allows dynamic loading of external UI applications that conform to the structure, and user defined applications can be obtained from storage or network. So in the most basic example, it will strictly control the memory usage to 512k ~ 1M and keep the drawing performance between 15 ~ 24fps. ## How to eat? Here, let’s start with the simplest entry code, the complete code is here [app_main.py](https://github.com/sipeed/MaixUI/blob/master/app/app_main.py). ```python # This file is part of MaixUI # Copyright (c) sipeed.com # # Licensed under the MIT license: # http://www.opensource.org/licenses/mit license.php # import time, gc, math, sys try: from core import agent, system from dialog import draw_dialog_alpha from ui_canvas import ui, print_mem_free from ui_container import container from wdt import protect from creater import get_time_curve except ImportError as e: sys.print_exception(e) from lib.core import agent, system from lib.dialog import draw_dialog_alpha from ui.ui_canvas import ui, print_mem_free from ui.ui_container import container from driver.wdt import protect from lib.creater import get_time_curve ``` They are the dependent code of import required to run it, and the following dependencies are: from core import agent, system Provide an agent soft timer and a global instance system soft timer object. from dialog import draw_dialog_alpha Provides drawing operations for a rounded border MessageBox control. from ui_canvas import ui, print_mem_free Provides a basic interface of UI canvas, through which to manage the overall unified drawing operation. from ui_container import container Provides a container module for running UI applications, which can be used to switch between different UI applications. from wdt import protect Watchdog, to ensure that the system can restart and recover after a core dump occurs. from creater import get_time_curve A curve generation function based on time or counter to maintain non linear animation effects. These two pieces of code are used to import the code loaded into different areas (under the root directory or folder of Flash/SD), so you only need to know how to import the code. You can use MaixPy IDE to send files, or use [mpfshell lite](https://github.com/junhuanchen/mpfshell lite) to put files to the flash or sd of the hardware. You can use an SD card reader, put the entire folder under the maixui warehouse into the SD card and start it. ### Define UI application Then introduce a typical basic application case, prepare the following code (class launcher static class). ```python class launcher: def load(): __class__.ctrl agent() __class__.ctrl.event(20, __class__.draw) def free(): __class__.ctrl None @ui.warp_template(ui.blank_draw) @ui.warp_template(ui.grey_draw) @ui.warp_template(ui.bg_in_draw) @ui.warp_template(ui.anime_in_draw) @ui.warp_template(ui.help_in_draw) #@ui.warp_template(taskbar.time_draw) #@ui.warp_template(taskbar.mem_draw) #@catch # need sipeed_button def draw(): height 100 + int(get_time_curve(3, 250) * 60) pos draw_dialog_alpha(ui.canvas, 20, height, 200, 20, 10, color (255, 0, 0), alpha 200) ui.canvas.draw_string(pos[0] + 10, pos[1] + 10, \"Welcome to MaixUI\", scale 2, color (0,0,0)) ui.display() def event(): __class__.ctrl.cycle() ``` Here, __class__ is similar to the this pointer in the instance class, through which the global variables of the current class can be accessed. The static class has three life cycle functions of load / free / event to provide to the UI container to maintain the continuous operation of the UI application. load will only be executed once and is used to initialize the UI application. free will only be executed once, for the release of UI applications. The event will be provided to the UI container to perform its operations in a loop. UI container refers to [ui/ui_container.py](https://github.com/sipeed/MaixUI/tree/master/ui/ui_container.py). Of course, you can also keep running without the UI container. You can see that the UI application defines the agent soft timer and sets the expected execution cycle of the drawing function to 20ms when it is loaded, and the setting will not be lower than the actual running cycle. ```python __class__.ctrl agent() __class__.ctrl.event(20, __class__.draw) ``` Then maintain the time sharing event (non blocking no block) owned by the soft timer ctrl in the event function, so based on this design you can make many time sharing tasks with different timings. ```python __class__.ctrl.cycle() ``` It can be executed periodically, or it can be used up and deleted, as shown below. ```python self.ctrl agent() # loop self.ctrl.event(5, self.draw) # once def into_launcher(self): container.reload(launcher) self.remove(into_launcher) self.ctrl.event(2000, into_launcher) ``` Then we see specific UI drawing events, which are different from hardware driven events such as buttons/touches, but no matter what kind of events, we expect it to end as soon as possible and hand over to the core of operation. ```python @ui.warp_template(ui.blank_draw) @ui.warp_template(ui.grey_draw) @ui.warp_template(ui.bg_in_draw) @ui.warp_template(ui.anime_in_draw) @ui.warp_template(ui.help_in_draw) #@ui.warp_template(taskbar.time_draw) #@ui.warp_template(taskbar.mem_draw) #@catch # need sipeed_button def draw(): height 100 + int(get_time_curve(3, 250) * 60) pos draw_dialog_alpha(ui.canvas, 20, height, 200, 20, 10, color (255, 0, 0), alpha 200) ui.canvas.draw_string(pos[0] + 10, pos[1] + 10, \"Welcome to MaixUI\", scale 2, color (0,0,0)) ui.display() ``` Here, we have one of the most basic draw() drawing functions, and five basic functions are decorated for it. In fact, the decoration is just good looking, it is actually equivalent to the following code, so whether to use it depends on your preference. ```python def draw(): ui.blank_draw() # prepare a blank image canvas object ui.grey_draw() # Draw gray on the canvas ui.bg_in_draw() # Draw a sipeed logo on the canvas with a built in background image. ui.anime_in_draw() # Load the animation effect of surrounding water waves on the canvas ui.help_in_draw() # Draw the built in help instructions on the canvas. height 100 + int(get_time_curve(3, 250) * 60) # Get time based sine curve value # Draw the effect of the MessageBox with a rounded border at the specified position, and get the starting point of the upper left corner of the border. pos draw_dialog_alpha(ui.canvas, 20, height, 200, 20, 10, color (255, 0, 0), alpha 200) # Print the string \"Welcome to MaixUI\" at the specified location. ui.canvas.draw_string(pos[0] + 10, pos[1] + 10, \"Welcome to MaixUI\", scale 2, color (0,0,0)) # Display the current canvas on the screen, and multiple executions will not affect it. After execution, the current canvas object will be released. ui.display() ``` The same is true for events connected to other buttons/touches/cameras. You can view the specific implementation of UI drawing here [ui/ui_canvas.py](https://github.com/sipeed/MaixUI/tree/master/ui/ui_canvas. py). ### Run UI framework Before actually entering the above business logic, we need to run the UI framework, so we need an entry function, such as the code in `if __name__ \"__main__\":`. ```python if __name__ \"__main__\": container.reload(launcher) while True: container.forever() ``` To explain, we see that the UI container (container.reload(launcher)) is used to load a UI application named launcher to run. You can view the specific implementation of the UI container here [ui/ui_container.py](https:// github.com/sipeed/MaixUI/tree/master/ui/ui_container.py). But just writing in this way is not stable enough, so we can use two while True to keep the program never exiting (unless the system core dump crashes). And the current fps value is obtained by the difference between last and the current tick_ms. It is recommended to close the print function in non debugging situations. It is very time consuming (ms level). ```python while True: while True: last time.ticks_ms() 1 while True: try: #time.sleep(0.1) print(1000 // (time.ticks_ms() last),'fps') last time.ticks_ms() except Exception as e: gc.collect() print(e) finally: try: ui.display() except: pass ``` Then we strengthen the stability of the environment, adding watchdog maintenance (protect.keep()) and GC memory collection (gc.collect()), and maintaining a global soft timer (system.parallel_cycle()) , Used as a global timer thread. ```python if __name__ \"__main__\": container.reload(launcher) while True: while True: last time.ticks_ms() 1 while True: try: #time.sleep(0.1) print(1000 // (time.ticks_ms() last),'fps') last time.ticks_ms() gc.collect() container.forever() system.parallel_cycle() protect.keep() #gc.collect() #print_mem_free() except KeyboardInterrupt: protect.stop() raise KeyboardInterrupt #except Exception as e: #gc.collect() #print(e) finally: try: ui.display() except: pass ``` You can use time.sleep(0.1) to reduce the execution rate of the UI container to observe whether the change state of the UI is in line with expectations. Sometimes changes higher than 15 fps are not perceived by the human eye, which can reduce unnecessary drawing processes. Compress the drawing process to improve performance. You can use except Exception as e: to ensure that any exception will not cause the UI framework to crash, but you can comment this out to catch possible exceptions when debugging. > By default, if the program does not execute protect.keep() for more than 10 seconds to reset the watchdog, the system will automatically restart. This starts when the wdt driver is imported. For details, please see [driver/wdt.py](https ://github.com/sipeed/MaixUI/tree/master/driver/wdt.py) driver. Finally, add catching KeyboardInterrupt exception events to ensure that the program can be stopped and re run after IDE or Ctrl + C input, and stop the watchdog event (protect.stop()), and also try to execute in finally ui.display() prevents the canvas from being released due to an exception in the drawing event and ensures that the image canvas object can always be released at the end of the loop. ```python try: protect.keep() except KeyboardInterrupt: protect.stop() raise KeyboardInterrupt except Exception as e: gc.collect() print(e) finally: try: ui.display() except: pass ``` The above is the most basic demonstration of the MaixUI framework. Although MaixUI will only provide Cube and Amigo application cases, it can be used as long as it is based on MaixPy, or in other words, the MicroPython environment that supports image interface objects can be used. I hope that we will be able to synchronize to CPython in the future, that is, we can synchronize UI style development on CPython to the MicroPython environment. This will complete the development efficiently, but the performance will not drop. ### At last This document describes how to run the most basic examples. If you want to see more examples, you can refer to [app_cube.py](https://github.com/sipeed/MaixUI/tree/master/app/app_cube.py) & [app_amigo .py](https://github.com/sipeed/MaixUI/tree/master/app/app_amigo.py) Two cases. > As of now on October 7, 2020, the App case for MaixPy's common functions has been completed, but this requires you to personally write and experience XD. The description only has a little simple interaction and animation display. The current running effect of app_main.py is as follows: ![](./image/app_main.gif)"},"/soft/maixpy/en/course/others/system.html":{"title":"System Control","content":" title: System Control keywords: maixpy, k210, AIOT, edge computing desc: maixpy system control ## Reset (reset) ```python import machine machine.reset() ``` ## Main frequency (cpu) You can set the main frequency of CPU and KPU, please refer to [Maix.freq](/api_reference/Maix/freq.md) module ```python from Maix import freq freq.set(cpu 400, kpu 400) ```"},"/soft/maixpy/en/course/others/mem.html":{"title":"Memory management","content":" title: Memory management keywords: maixpy, k210, AIOT, edge computing desc: maixpy memory management In MaixPy, two types of memory management are currently used, one is GC (garbage collection) and the other is system heap memory, both of which exist at the same time. For example: the chip has 6MiB of memory, adding the firmware uses the previous 2MiB, and the remaining 4MiB, the default `GC` uses 512KiB, and the rest is used for system heap memory management. * In the code written at the level of `mpy`, variables are stored in the memory block managed by `GC`, such as defining a variable `a [1,2,3,4]`, if the memory of `GC'` is insufficient, It will automatically trigger the execution of the `gc.collect()` function, and the `GC` will automatically destroy the unused variables, leaving space for new variables. > `GC` uses the method of `mark clear` to reclaim memory. If you are interested, please see [here](https://neucrack.com/p/46) * Because `GC` needs to scan the memory, if the rest is given to `GC` except for the memory occupied by the program, each scan will take a lot of time, so it is divided into two memory. Heap memory is controlled by code at the `C` level, mainly used for image memory, AI memory, LCD memory, and loading models into memory, etc. The total size of `GC` memory can be set. Therefore, the size of `GC` memory can be modified appropriately according to the specific usage, for example: * In order to load a larger model, you can set the `GC` memory setting smaller * If the allocation of new variables indicates insufficient memory, you can appropriately set the `GC` memory to be larger * If it is not enough, consider reducing the firmware size or optimizing the code Example of setting `GC` memory size: ```python from Maix import utils import machine print(utils.gc_heap_size()) utils.gc_heap_size(1024*1024) # 1MiB machine.reset() ``` Note that the modification needs to be restarted to take effect View memory allocation: ```python import gc print(gc.mem_free() / 1024) # stack mem import Maix print(Maix.utils.heap_free() / 1024) # heap mem ''' >>> raw REPL; CTRL B to exit >OK 352.0937 4,640.0 > MicroPython v0.5.1 136 g039f72b6c dirty on 2020 11 18; Sipeed_M1 with kendryte k210 Type \"help()\" for more information. >>> ''' ```"},"/soft/maixpy/en/course/others/lvgl.html":{"title":"lvgl","content":" title: lvgl keywords: maixpy, k210, AIOT, edge computing desc: maixpy LittlevGL **It is not recommended to use this module now, please have sufficient development level, and will not accept questions about the sharing of LVGL and AI functions, thank you for your cooperation (December 11, 2020)** Please use the bin firmware with LVGL to operate. Refer to the official document: [lvgl blog page](https://blog.littlevgl.com/2019 02 20/micropython bindings) ## Routine Reference [MaixPy_Scripts of github](https://github.com/sipeed/MaixPy v1_scripts/tree/master/multimedia/gui/lvgl)"},"/soft/maixpy/en/course/maixpy/demo_find_green_blob.html":{"title":"MaixPy finds color patches","content":" title: MaixPy finds color patches keywords: maixpy, k210, AIOT, edge computing desc: maixpy MaixPy finds color patches ## MaixPy finds color patches ```python import sensor import image import lcd import time lcd.init(freq 15000000) sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) green_threshold (0, 80, 70, 10, 0, 30) while True: img sensor.snapshot() blobs img.find_blobs([green_threshold]) if blobs: for b in blobs: tmp img.draw_rectangle(b[0:4]) tmp img.draw_cross(b[5], b[6]) c img.get_pixel(b[5], b[6]) lcd.display(img) ```"},"/soft/maixpy/en/course/image/image_counting-cells.html":{"title":"MaixPy achieves cell counting","content":" title: MaixPy achieves cell counting keywords: maixpy, k210, AIOT, edge computing desc: maixpy MaixPy for cell counting > counting cells Steps to achieve cell counting: Original image grayscale image corrosion expansion binarization threshold filtering operation counting ```python ```"},"/soft/maixpy/en/course/image/find_color_blob.html":{"title":"MaixPy Find color blocks","content":" title: MaixPy Find color blocks keywords: maixpy, k210, AIOT, edge computing desc: maixpy MaixPy find color blocks Find all color blocks of the specified color in the picture ## Instructions MaixPy has implemented a method to find color patches in the image module, and a non minimum firmware version is required. * Get pictures from the camera ```python import image, sensor img sensor.snapshot() ``` * Find a list of all color block objects (image.blob) from the picture, and the incoming color threshold parameters follow the LAB format (l_lo, l_hi, a_lo, a_hi, b_lo, b_hi) ```python green_threshold (0, 80, 70, 10, 0, 30) blobs img.find_blobs([green_threshold]) ``` * Manipulate color block objects Operate the color block object according to your own needs, for example, mark the color block object with a rectangular frame in the image ```python tmp img.draw_rectangle(b[0:4]) ``` For detailed API introduction, please refer to [API Image](../../api_reference/machine_vision/image/image.html). ## Routine Find the green patch ```python import sensor import image import lcd import time lcd.init() sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) green_threshold (0, 80, 70, 10, 0, 30) while True: img sensor.snapshot() blobs img.find_blobs([green_threshold]) if blobs: for b in blobs: tmp img.draw_rectangle(b[0:4]) tmp img.draw_cross(b[5], b[6]) c img.get_pixel(b[5], b[6]) lcd.display(img) ```"},"/soft/maixpy/en/course/image/basic/get_images.html":{"title":"get image","content":" title: get image keywords: maixpy, k210, AIOT, edge computing desc: maixpy get image You can get images from the camera, you can read picture files from the file system, or you can get pictures from the network ## Get from camera This part has been mentioned in the previous tutorial ``` import sensor, lcd sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) sensor.skip_frames() img sensor.snapshot() print(img) ``` * `import sensor`: first import the built in `sensor` (camera) library * `sensor.reset()`: Initialize the camera. If it fails, check the hardware * `sensor.set_pixformat(sensor.RGB565)`: Set the camera to `RGB565` format, the default is to use `RGB565` * `sensor.set_framesize(sensor.QVGA)`: The resolution is `QVGA`, that is, `320x240` * `sensor.run(1)`: start to run, it is not necessary to call it in the current version, the camera will automatically start to run after the above settings are completed * `sensor.skip_frames()`: The image quality is not stable when the camera is just started, so some images are skipped * `sensor.snapshot()`: fetch a frame of image data from the camera, the return value is an image object In addition to the above functions, you may also need to set the image to mirror (`hmirror`), such as the front camera; or flip up and down (`vflip`), and white balance, etc., see [sensor module API manual](/ api_reference/machine_vision/sensor.md) ## Read from file ```python import image img image.Image(\"/sd/test.jpg\") print(img) ``` Of course you can also save the picture to the file system` ```python img.save(\"/sd/test2.jpg\", quality 95) ``` ## Read from memory (or read from network) You can read the file to the memory first, depending on your application where you read it from, such as network, or serial port SPI, etc. Construct a `bytes` object ```python import image jpeg_buff b'\\xFF' # jpeg buffer img image.Image(jpeg_buff, from_bytes True) print(img) ``` ## Create a blank image directly ```python import image img image.Image(size (320, 240)) ``` This picture is a black blank image"},"/soft/maixpy/en/course/image/basic/vary.html":{"title":"Basic image transformation and common operations","content":" title: Basic image transformation and common operations keywords: maixpy, k210, AIOT, edge computing desc: maixpy basic image transformation and common operations Here is a brief introduction to the basic transformation operations of some frequently used images Rotate: ```python img.rotation_corr() ``` Change the image size: ```python img.resize() ``` For more image transformation, please see [image API](./../../../api_reference/machine_vision/image/image.html) ## Introduction to image buffer MaixPy has designed two buffers for the image, * One is the `RGB565` buffer, as the name suggests, is a memory that stores the information of this picture in the format of `RGB565`. Note that the order in the memory is `[pixel 1 RGB, pixel 2 RGB...]` * The other is the `RGB888` buffer, as the name implies, a memory that stores the information of this picture in the format of `RGB88`. Note that the order in the memory is `[all pixels R, all pixels G, all pixels B]`, we also call it `AI` memory The main reason for using two memory blocks here is that all image operations of the underlying code and `LCD` display are based on `RGB565`, but `KPU` needs the input of `RGB888`. ``` + + + + camera(sensor)+ + + + + v + + v + img.pix_to_ai() RGB565 + >+ RGB888 + + + + + + ^ v + + + + + + image ops KPU + + + + ``` When only the camera captures pictures, the hardware will automatically put a copy of the data into the `RGB888` memory area, and the other will not automatically fill the `RGB888` memory block. The software operation will only operate on the `RGB565` memory, and will not automatically update` RGB888`, (because the update takes time) This is worth noting, This means that every time we change the memory block of `RGB565`, for example, execute `img img.resize((224, 224))`, if you want `KPU` to use the changed image, you need to execute `img. pix_to_ai()` to manually update the image of `RGB565` to the area of ​​`RGB888`, and then you can call `kpu` related functions for model inference! The same update in the opposite direction also provides API: `img.ai_to_pix()`, which will update the data in the `RGB888` area to the `RGB565` area ## resize modify resolution ```python import image img image.Image(size (100, 100)) img2 img.resize(50, 50) print(img) print(img2) ``` ## Get and modify pixel value ```python import image img image.Image(size (10, 10)) print(\"pixel 0:\", img[0], img.get_pixel(0, 0)) img[0] (255, 0, 0) img img.set_pixel(1, 0, (255, 255, 10)) print(\"after pixel 0 change:\", img[0], img[1]) ``` The second pixel `B` set here is `10`, and it is actually found to be `8`. This is a normal phenomenon. As mentioned earlier, the storage in the memory uses `RGB565` for storage, so it will Error ## Copy image ```python import image img image.Image(size (10, 10)) img2 img.copy() img2[0] (255, 0, 0) print(img[0], img2[0]) ``` ## Crop image Also use the `copy` function ```python import image img image.Image(size (10, 10)) img2 img.copy(roi (0, 0, 5, 5)) img2[0] (255, 0, 0) print(img) print(img2) print(img[0], img2[0]) ``` ## Convert to bytes object Convert to `RGB565` string ```python import image img image.Image(size (10, 10)) img[0] (255, 0, 0) img_bytes img.to_bytes() print(\"bytes length: %d bytes[0]: %x%x\" %(len(img_bytes), img_bytes[0], img_bytes[1])) ``` The output value here is in the format of `RGB565`, which means that one pixel is stored in two bytes In addition, you can also compress the image to `JPEG` format first, and then convert it to `bytes` ```python import image img image.Image(size (10, 10)) img img.compressed(quality 20) jpeg_bytes img.to_bytes() print(\"bytes length: %d bytes[0]: %x%x\" %(len(jpeg_bytes), jpeg_bytes[0], jpeg_bytes[1])) ``` Using the `compressed` function here will not modify the original image, using the `compress()` function will modify the original image, but if the compressed size is larger than the original image, it will fail ## Convert to grayscale image ```python img img.to_grayscale(copy False) ``` Here the `copy` parameter means whether to re apply for a piece of memory without modifying the original image ## Convert to RGB565 color image Convert to a color image, note that only the format has become a color image, the picture is not a color image, if you need to convert a gray image to a color image, use `img.to_rainbow()` ```python img img.to_rgb565(copy True) ``` Here the `copy` parameter means whether to re apply for a piece of memory without modifying the original image If the original image is grayscale, it must be `True` ## Convert to color picture ```python img img.to_rainbow(copy True) ``` Here the `copy` parameter means whether to re apply for a piece of memory without modifying the original image If the original image is grayscale, it must be `True` ## Save to file system ```python img.save(\"/sd/test.jpg\", quality 95) img.save(\"/sd/test.bmp\") ``` ## Rotate ```python img.rotation_corr([x_rotation 0.0[, y_rotation 0.0[, z_rotation 0.0[, x_translation 0.0[, y_translation 0.0[, zoom 1.0]]]]]]) ``` The brackets are optional parameters, that is, which axis to rotate along a certain angle. If this function is not available in the firmware of the `minimum` version, the full version of the firmware can be used"},"/soft/maixpy/en/api_reference/machine/pwm.html":{"title":"machine.PWM","content":" title: machine.PWM keywords: maixpy, k210, AIOT, edge computing desc: maixpy machine.PWM PWM: Pulse width modulation module, PWM supported by hardware, you can specify any pin (0 to 47 pins) Each PWM depends on a timer, that is, when the timer is bound with the PWM function, it cannot be used as a normal timer. Because there are 3 timers, each timer has 4 channels, that is, a maximum of 12 PWM waveforms can be generated simultaneously ## Constructor ```python pwm machine.PWM(tim, freq, duty, pin, enable True) ``` Create a new PWM object with specified parameters ### Parameters * `tim`: Each PWM relies on a timer to generate waveforms, so a timer object needs to be passed here. The timer ID and channel number must be specified when the timer object is initialized * `freq`: PWM waveform frequency * `duty`: PWM duty cycle, refers to the percentage of the high level in the entire cycle, value: [0,100] * `[pin]`: PWM output pin. It is not necessary to set, but use [fm](../builtin_py/fm.html) to manage pin mapping in a unified manner. * `enable`: Whether to start generating the waveform immediately, the default bit is `True`, and the PWM waveform will be generated on the specified pin immediately after the object is generated ## Method ### init Similar constructor ```python pwm.init(tim, freq, duty, pin, enable True) ``` #### Parameters Same as constructor #### return value no ### freq Get or set PWM frequency ```python pwm.freq(freq) ``` #### Parameters * `freq`: PWM frequency, optional parameter, if no parameter is passed, the step setting will only return the current frequency value #### return value Actual PWM frequency currently set ### duty Get or set the PWM duty cycle ```python pwm.duty(duty) ``` #### Parameters * `duty`: PWM duty cycle is optional, if no parameter is passed, the step setting will only return the current duty cycle value #### return value The currently set PWM duty cycle value ### enable Enable PWM output to generate waveform on the specified pin immediately ```python pwm.enable() ``` #### Parameters no #### return value no ### disable Disabled PWM output, the specified pin no longer generates waveform ```python pwm.disable() ``` #### Parameters no #### return value no ### deinit/\\__del\\__ Log off the PWM hardware, release the occupied resources, and turn off the PWM clock ```python pwm.deinit() ``` #### Parameters no #### return value no #### Examples ```python pwm.deinit() ``` or ```python del pwm ``` ## Constant no ## Routine ### Routine 1 (breathing light) > `board_info` is related to the board, and different board configurations are different. [Manual configuration](../builtin_py/board_info.html) is required before use. ```python from machine import Timer,PWM import time from board import board_info tim Timer(Timer.TIMER0, Timer.CHANNEL0, mode Timer.MODE_PWM) ch PWM(tim, freq 500000, duty 50, pin board_info.LED_G) duty 0 dir True while True: if dir: duty + 10 else: duty 10 if duty>100: duty 100 dir False elif duty<0: duty 0 dir True time.sleep(0.05) ch.duty(duty) ``` ### Routine 2 > `board_info` is related to the board, and different board configurations are different. [Manual configuration](../builtin_py/board_info.html) is required before use. ```python import time import machine from board import board_info tim machine.Timer(machine.Timer.TIMER0, machine.Timer.CHANNEL0, mode machine.Timer.MODE_PWM) ch0 machine.PWM(tim, freq 3000000, duty 20, pin board_info.LED_G, enable False) ch0.enable() time.sleep(3) ch0.freq(2000000) print(\"freq:\",ch0.freq()) ch0.duty(60) time.sleep(3) ch0.disable() ```"},"/soft/maixpy/en/api_reference/machine/i2c.html":{"title":"machine.I2C","content":" title: machine.I2C keywords: maixpy, k210, AIOT, edge computing desc: maixpy machine.I2C I2C bus protocol, simply use two lines (SCL, SDA) to control multiple slaves (master mode). * Support master mode and slave mode * 7 bit/10 bit addressing mode * Standard mode < 100Kb/s * Fast mode < 400Kb/s * Super fast mode < 1000Kb/s * High speed mode 3.4Mb/s ## Constructor ```python class machine.I2C(id, mode I2C.MODE_MASTER, scl None, sda None, gscl None, gsda None, freq 400000, timeout 1000, addr 0, addr_size 7, on_recieve None, on_transmit None, on_event None) ``` Create a new I2C object with the specified parameters ### Parameters * `id`: I2C ID, [0~2] \\(I2C.I2C0~I2C.I2C2\\) [3~5] \\(I2C.I2C3~I2C.I2C5, I2C_SOFT\\) is the number of soft analog I2C * `mode`: Mode, master (`I2C.MODE_MASTER`) and slave (`I2C.MODE_SLAVE`) modes * `scl`: SCL pin, just pass the pin number directly, the value range: [0,47]. It is not necessary to set, but use [fm](../builtin_py/fm.html) to manage pin mapping in a unified manner. * `sda`: SDA pin, just pass the pin number directly, the value range: [0,47]. It is not necessary to set, but use [fm](../builtin_py/fm.html) to manage pin mapping in a unified manner. * `gscl`: GPIOHS corresponding to SCL, only need to be passed when using software to simulate I2C, the default is the same as `scl`. * `gsda`: GPIOHS corresponding to SDA, only need to be passed when using software to simulate I2C, the default is the same as `sda`. * `freq`: I2C communication frequency, supports standard 100Kb/s, fast 400Kb/s, and higher rates (hardware supports ultra fast mode 1000Kb/s, and high speed mode 3.4Mb/s) * `timeout`: timeout time, currently this parameter is reserved, the setting is invalid * `addr`: slave address, if it is in master mode, don’t need to set, slave mode means slave (local) address * `addr_size`: address length, supports 7 bit addressing and 10 bit addressing, the value is `7` or `10` * `on_recieve`: Receive callback function in slave mode * `on_transmit`: send callback function in slave mode * `on_event`: event function in slave mode (start event and end event) ## Method ### init Similar constructor ```python i2c I2C.init(id, mode Timer.MODE_MASTER, scl, sda, gscl, gsda, freq 400000, timeout 1000, addr 0, addr_size 7, on_recieve None, on_transmit None, on_event None) ``` #### Parameters Same as constructor #### return value no ### scan Scan the slave on the I2C bus ```python i2c.scan() ``` #### Parameters no #### return value list object, contains all scanned slave addresses ### readfrom Read data from the bus ```python i2c.readfrom(addr, len, stop True) ``` #### Parameters * `addr`: slave address * `len`: data length * `stop`: Whether to generate a stop signal, keep it, currently only the default value Ture can be used #### return value The read data, `bytes` type ### readfrom_into Read the data and put it in the specified variable ```python i2c.readfrom_into(addr, buf, stop True) ``` #### Parameters * `addr`: slave address * `buf`: `bytearray` type, the length is defined, the data read is stored here * `stop`: Whether to generate a stop signal, keep it, currently only the default value Ture can be used #### return value no ### writeto Send data to slave ```python i2c.writeto(addr, buf, stop True) ``` #### Parameters * `addr`: slave address * `buf`: The data to be sent * `stop`: Whether to generate a stop signal, keep it, currently only the default value Ture can be used #### return value Number of bytes sent successfully ### readfrom_mem Read slave register ```python i2c.readfrom_mem(addr, memaddr, nbytes, mem_size 8) ``` #### Parameters * `addr`: slave address * `memaddr`: slave register address * `nbytes`: the length to be read * `mem_size`: register width, the default is 8 bits #### return value Returns the read data of `bytes` type ### readfrom_mem_into Read the slave register value into the specified variable ```python i2c.readfrom_mem_into(addr, memaddr, buf, mem_size 8) ``` #### Parameters * `addr`: slave address * `memaddr`: slave register address * `buf`: `bytearray` type, the length is defined, the data read is stored here * `mem_size`: register width, the default is 8 bits #### return value no ### writeto_mem Write data to slave register ```python i2c.writeto_mem(addr, memaddr, buf, mem_size 8) ``` #### Parameters * `addr`: slave address * `memaddr`: slave register address * `buf`: the data to be written * `mem_size`: register width, the default is 8 bits #### return value no ### deinit/\\__del\\__ Log off the I2C hardware, release the occupied resources, and turn off the I2C clock ```python i2c.deinit() ``` #### Parameters no #### return value no #### Examples ```python i2c.deinit() ``` or ```python del i2c ``` ## Constant * `I2C0`: I2C 0 * `I2C1`: I2C 1 * `I2C2`: I2C 2 * `MODE_MASTER`: as the master mode * `MODE_SLAVE`: as a slave mode * `I2C_EV_START`: Event type, start signal * `I2C_EV_RESTART`: Event type, restart signal * `I2C_EV_STOP`: Event type, end signal ## Routine ### Example 1: Scan the slave device ```python from machine import I2C i2c I2C(I2C.I2C0, freq 100000, scl 28, sda 29) devices i2c.scan() print(devices) ``` ### Example 2: Read and write ```python import time from machine import I2C i2c I2C(I2C.I2C0, freq 100000, scl 28, sda 29) i2c.writeto(0x24,b'123') i2c.readfrom(0x24,5) ``` ### Example 3: Slave mode ```python from machine import I2C count 0 def on_receive(data): print(\"on_receive:\",data) def on_transmit(): count count+1 print(\"on_transmit, send:\",count) return count def on_event(event): print(\"on_event:\",event) i2c I2C(I2C.I2C0, mode I2C.MODE_SLAVE, scl 28, sda 29, addr 0x24, addr_size 7, on_receive on_receive, on_transmit on_transmit, on_event on_event) ``` ### Example 4: OLED(ssd1306 128x64) ```python import time from machine import I2C SSD1306_CMD 0 SSD1306_DATA 1 SSD1306_ADDR 0x3c def oled_init(i2c): i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xAE, mem_size 8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x20, mem_size 8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x10, mem_size 8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xb0, mem_size 8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xc8, mem_size 8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x00, mem_size 8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x10, mem_size 8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x40, mem_size 8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x81, mem_size 8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xff, mem_size 8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xa1, mem_size 8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xa6, mem_size 8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xa8, mem_size 8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x3F, mem_size 8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xa4, mem_size 8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xd3, mem_size 8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x00, mem_size 8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xd5, mem_size 8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xf0, mem_size 8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xd9, mem_size 8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x22, mem_size 8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xda, mem_size 8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x12, mem_size 8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xdb, mem_size 8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x20, mem_size 8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x8d, mem_size 8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x14, mem_size 8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xaf, mem_size 8) def oled_on(i2c): i2c.writeto_mem(SSD1306_ADDR, 0x00, 0X8D, mem_size 8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0X14, mem_size 8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0XAF, mem_size 8) def oled_off(i2c): i2c.writeto_mem(SSD1306_ADDR, 0x00, 0X8D, mem_size 8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0X10, mem_size 8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0XAE, mem_size 8) def oled_fill(i2c, data): for i in range(0,8): i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xb0+i, mem_size 8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x10, mem_size 8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x01, mem_size 8) for j in range(0,128): i2c.writeto_mem(SSD1306_ADDR, 0x40, data, mem_size 8) i2c I2C(I2C.I2C0, mode I2C.MODE_MASTER, freq 400000, scl 28, sda 29, addr_size 7) time.sleep(1) oled_init(i2c) oled_fill(i2c, 0xff) ```"},"/soft/maixpy/en/api_reference/machine/machine.html":{"title":"machine","content":" title: machine keywords: maixpy, k210, AIOT, edge computing desc: maixpy machine ## unique_id"},"/soft/maixpy/en/api_reference/machine/timer.html":{"title":"machine.Timer","content":" title: machine.Timer keywords: maixpy, k210, AIOT, edge computing desc: maixpy machine.Timer The hardware timer can be used to trigger tasks or process tasks regularly. After the set time is up, an interrupt can be triggered (call the callback function), and the accuracy is higher than the software timer. It should be noted that timers may behave differently in different hardware. MicroPython's Timer class defines the basic operation of executing a callback within a given time period (or executing a callback after a delay), and allows more non standard behaviors to be defined on specific hardware (so it cannot be ported to other boards). There are 3 timers, each timer has 4 channels available ## Constructor ```python tim machine.Timer(id, channel, mode Timer.MODE_ONE_SHOT, period 1000, unit Timer.UNIT_MS, callback None, arg None, start True, priority 1, div 0) ``` Create a new Timer object with the specified parameters ### Parameters * `id`: Timer ID, [0~2] \\(Timer.TIMER0~TIMER2\\) * `channel`: Timer channel, [Timer.CHANNEL0~Timer.CHANNEL3] * `mode`: Timer mode, `MODE_ONE_SHOT` or `MODE_PERIODIC` or `MODE_PWM` * `period`: Timer period, after starting the timer `period` time, the callback function will be called, (0,~) * `unit`: Set the unit of the period, the default bit is milliseconds (`ms`), `Timer.UNIT_S` or `Timer.UNIT_MS` or `Timer.UNIT_US` or `Timer.UNIT_NS` * `callback`: Timer callback function, defines two parameters, one is the timer object `Timer`, the second is the parameter `arg` that you want to pass in the definition object, please see the explanation of `arg` parameters for more > Note: The callback function is called in the interrupt, so please don't take too long in the callback function and do dynamic allocation switch interrupt etc. * `arg`: The parameter that you want to pass to the callback function as the second parameter of the callback function * `start`: Whether to start the timer immediately after the object is successfully constructed, `True`: start immediately, `False`: not start immediately, you need to call the `start()` function to start the timer * `priority`: hardware timer interrupt priority, related to a specific CPU, in K210, the value range is [1,7], the smaller the value, the higher the priority * `div`: hardware timer divider, value range [0,255], default is 0, clk_timer (timer clock frequency) clk_pll0 (phase locked loop 0 frequency)/2^(div+1) > clk_timer*period(unit:s) should be <2^32 and > 1 ## Method ### init Similar constructor ```python tim.init(id, channel, mode Timer.MODE_ONE_SHOT, period 1000, unit Timer.UNIT_MS, callback None, arg None, start True, priority 1, div 0) ``` #### Parameters Similar constructor #### return value no ### callback_arg Get the set parameters passed to the callback function, which can only be called by the `Timer` object, the class `Timer` cannot be called ### callback Get or set callback function ```python tim.callback(callback) ``` #### Parameters * `callback`: the set callback function, optional parameters, if no parameters are passed, only the previous callback function will be returned #### return value Current callback function #### Examples ```python def on_timer(timer): print(\"time up:\",timer) print(\"param:\",timer.callback_arg()) tim.callback(on_timer) print(on_timer, tim.callback()) ``` ### period Get or set the timing period ```python tim.period(period) ``` #### Parameters * `period`: Optional parameter, configure the period, if no parameter is passed, only the current period value will be returned #### return value Current period value #### Examples ```python tim.period(2000) print( tim.period()) ``` ### start Start timer ```python tim.start() ``` #### Parameters no #### return value no #### Examples ```python tim.start() ``` ### stop Stop timer ```python tim.stop() ``` #### Parameters no #### return value no ### restart Restart timer ```python tim.restart() ``` #### Parameters no #### return value no ### deinit/\\__del\\__ Log off the timer, log off the hardware occupation, turn off the hardware clock ```python tim.deinit() ``` #### Parameters no #### return value no #### Examples ```python tim.deinit() ``` or ```python del tim ``` ## Constant * `TIMER0`: Timer0 id * `TIMER1`: Timer1 id * `TIMER2`: Timer2 id * `CHANNEL0`: Timer channel 0 * `CHANNEL1`: Timer channel 1 * `CHANNEL2`: Timer channel 2 * `CHANNEL3`: Timer channel 3 * `MODE_ONE_SHOT`: Timer runs only once (callback once) * `MODE_PERIODIC`: Timer always runs (continuous callback) * `MODE_PWM`: The timer is not used as a callback function to generate PWM * `UNIT_S`: unit of second (s) * `UNIT_MS`: unit milliseconds (ms) * `UNIT_US`: unit microsecond (us) * `UNIT_NS`: unit nanosecond (ns) ## Routine ### Routine 1 Print information after 3 seconds ```python from machine import Timer def on_timer(timer): print(\"time up:\",timer) print(\"param:\",timer.callback_arg()) tim Timer(Timer.TIMER0, Timer.CHANNEL0, mode Timer.MODE_ONE_SHOT, period 3000, callback on_timer, arg on_timer) print(\"period:\",tim.period()) ``` ### Routine 2 Print messages every 1 second, stop for 5 seconds and restart again, turn off and log off the timer after 5 seconds ```python import time from machine import Timer def on_timer(timer): print(\"time up:\",timer) print(\"param:\",timer.callback_arg()) tim Timer(Timer.TIMER0, Timer.CHANNEL0, mode Timer.MODE_PERIODIC, period 1, unit Timer.UNIT_S, callback on_timer, arg on_timer, start False, priority 1, div 0) print(\"period:\",tim.period()) tim.start() time.sleep(5) tim.stop() time.sleep(5) tim.restart() time.sleep(5) tim.stop() del tim ```"},"/soft/maixpy/en/api_reference/machine/network.html":{"title":"network","content":" title: network keywords: maixpy, k210, AIOT, edge computing desc: maixpy network This module is used to initialize various network card drivers. The network card has the functions of connecting routing, disconnecting routing, viewing the connection information of the network card, and checking whether it is connected. To use `WiFi` please make sure that the antenna is connected ### [esp8285](##network.ESP8285(uart)) On some development boards, a network card module that uses `AT` to interact, such as `esp8285`, is connected to `k210` through a serial port Pin `8` is the enable pin. You can create a `GPIO` object to control its high and low levels to achieve enable and disable, or you can use it to reset (low first and then high), and you need to wait for a while after reset Time to operate, You can view the routine [network_espat.py](https://github.com/sipeed/MaixPy v1_scripts/blob/79a5485ec983e67bb8861305a52418b29e0dc205/network/network_espat.py) ### [esp32](##network.ESP32_SPI(cs,rst,rdy,mosi,miso,sclk)) Currently there is an `esp32` module in the `MaixDuino` development board which is connected to `k210` through `spi` There is also a separate `TF` plug in module ## network.ESP8285(uart) Construct an `ESP8285` network card object. To use this method, you need to pass in a `uart` object. On the `dock` and `GO` currently supported by `MaixPy`, the AT command module is used as the `WiFi`. So the `uart` object is the object that communicates with the `AT` module, you can check the `uart` module routine Calling this method will initialize `ESP8285` and throw an exception if it fails ### Parameters * `uart`: UART object communicating with AT module ### return value * `ESP8285`: NIC object ## ESP8285 ### connect(ssid, key) Connect hotspot (AP/router) #### Parameters * `ssid`: the `SSID` of the hotspot * `key`: hotspot password #### return value None, if an error occurs, an exception will be thrown ### 2.2. ifconfig View wifi connection information, currently network does not support setting network card configuration ``` nic.ifconfig() ``` #### Parameters no #### return value `tuple` type, elements are all strings: `(ip, netmask, gateway, dns_server, dhcp_server, mac, ssid)`, if not found or invalid, the value is `\"0\"` ### isconnected Check if wifi is connected ``` nic.isconnected() ``` #### Parameters no #### return value `True`: connected `False`: disconnect ### disconnect Disconnect wifi connection #### Parameters no #### return value no ### scan Scan the surrounding hotspot information #### Parameters no #### return value A `list` object, each element contains a string, the string comes from the response of the `AT` module, and the content is the same as described in the `AT command document` of `esp8285`, as follows: `ecn, ssid, rssi,mac, channel, freq offset, freq cali, pairwise_cipher, group_cipher, bgn, wps` * `ecn`: Encryption method * 0: OPEN * 1: WEP * 2: WPA_PSK * 3: WPA2_PSK * 4: WPA_WPA2_PSK *5: WPA2_Enterprise (Previously, AT does not support connecting to this encrypted AP) * `ssid`: string parameter, AP's SSID * `rssi`: signal strength * `mac`: string parameter, AP's MAC address * `channel`: channel number * `freq offset`: AP frequency offset, unit: kHz. Divide this value by 2.4 to get the ppm value * `freq cali`: frequency offset calibration value * `pairwise_cipher`: * 0: CIPHER_NONE * 1: CIPHER_WEP40 * 2: CIPHER_WEP104 * 3: CIPHER_TKIP * 4: CIPHER_CCMP * 5: CIPHER_TKIP_CCMP * 6: CIPHER_UNKNOWN * `group_cipher`: The definition is the same as `pairwise_cipher` * `bgn`: bit0 stands for b mode; bit1 stands for g mode; bit2 stands for n mode If the corresponding bit is 1, it means the mode is enabled; if the corresponding bit is 0, the mode is not enabled. * `wps`: 0, WPS is not enabled; 1, WPS is enabled For example: ``` info_strs ['4,\"ChinaNet lot0\", 79,\"c8:50:e9:e8:21:3e\",1, 42,0,4,3,7,1', '4,\"TOPSTEP2G4 \", 7 0,\"f8:e7:1e:0d:0d:f8\",1, 57,0,4,4,7,0'] ``` This may seem strange, because the information of each AP is a string of characters, and there are integers and strings in the information. The strings are enclosed in double quotes, so after you get this string, you need to process it again. Use again, such as: ```python def wifi_deal_ap_info(info): res [] for ap_str in info: ap_str ap_str.split(\",\") info_one [] for node in ap_str: if node.startswith('\"'): info_one.append(node[1: 1]) else: info_one.append(int(node)) res.append(info_one) return res info_strs ['4,\"ChinaNet lot0\", 79,\"c8:50:e9:e8:21:3e\",1, 42,0,4,3,7,1', '4,\"TOPSTEP2G4 \", 70,\"f8:e7:1e:0d:0d:f8\",1, 57,0,4,4,7,0'] info wifi_deal_ap_info(info_strs) print(info) ``` The output is: ``` [[4,'ChinaNet lot0', 79,'c8:50:e9:e8:21:3e', 1, 42, 0, 4, 3, 7, 1], [4,'TOPSTEP2G4', 70,'f8:e7:1e:0d:0d:f8', 1, 57, 0, 4, 4, 7, 0]] ``` Then for example, we need to get all the `SSID` of `AP` only need to use ``` for ap_info in info: print(ap_info[1]) ``` ### enable_ap(ssid, key, chl 5, ecn 3) * **Warning: As of November 26, 2020, MaixPy sockets have not yet implemented functions such as listen / bind / accpet. ** Open hotspot #### Parameters * `ssid`: SSID * `key`: password * `chl`: Channel number of WiFi signal * `ecn`: Encryption method, including `OPEN``WPA2_PSK`, etc., refer to the constant part of `ESP8285` on this page, the default value is `3`, which is `ESP8285.WPA2_PSK`, for example ```python nic network.ESP8285(uart) nic.enable_ap(\"maixpy\", \"12345678\", 5, nic.OPEN) ``` or ``` nic.enable_ap(\"maixpy\", \"12345678\", 5, network.ESP8285.OPEN) ``` ### disable_ap() Turn off hotspot ### Constant #### OPEN The hotspot encryption method does not require a password #### WPA_PSK The hotspot encryption method is `WPA_PSK` #### WPA2_PSK The hotspot encryption method is `WPA2_PSK` #### WPA_WPA2_PSK The encryption method of the hotspot is `WPA_WPA2_PSK` ## Routine Refer to [routines in the network directory](https://github.com/sipeed/MaixPy v1_scripts/tree/master/network) ## network.ESP32_SPI(cs,rst,rdy,mosi,miso,sclk) To construct an `ESP32_SPI` network card object, you need to pass in the corresponding `GPIOHS FUNC` If the number of incoming parameters is incorrect, an error will be returned **Note** If SPI and SD do not conflict on maixduino, you need to set ESP32_SPI as the hardware SPI configuration. ### Parameters * `fpioa_func` corresponding to pin function ### return value * `ESP32_SPI` network card object ## ESP32_SPI ### adc Read the `adc` value of the `esp32` module #### Parameters no #### return value `tunple`, the value of `adc` for 5 channels<br>The order is `\"PIN36\", \"PIN39\", \"PIN34\", \"PIN35\", \"PIN32\"` #### Routine [demo_esp32_read_adc.py](https://github.com/sipeed/MaixPy v1_scripts/blob/master/network/demo_esp32_read_adc.py) ## network.WIZNET5K(spi, cs) Construct a `WIZNET5K` network card object. To use this method, you need to pass in a `spi` object and a `cs` pin. Calling this method will initialize `WIZNET5K` and throw an exception if it fails ### Parameters * `spi`: Responsible for communication with WIZNET5K module * `cs`: spi communication chip selection footer ### return value * `WIZNET5K`: NIC object ## WIZNET5K ### dhclient DHCP dynamically obtain IP ``` nic.dhclient() ``` #### Parameters no #### return value * `True`: Get success * `False`: Get failed ### ifconfig ``` nic.ifconfig() ``` #### Parameters * No reference: query network card information * Incoming `(ip, netmask, gateway, dns_server)` string tuple: configure network card, `ip` ip address, `netmask` subnet mask, `gateway` gateway IP address, `dns_server` DNS service IP address . #### return value * No parameters: return `tuple`, the elements are all strings, `(ip, netmask, gateway, dns_server)`, if not found or invalid, the value is `\"0\"` * Pass parameter: return `None` ### isconnected Check if the network is connected ``` nic.isconnected() ``` #### Parameters no #### return value * `True`: already connected * `False`: disconnect #### Routine [network_wiznet5k.py](https://github.com/sipeed/MaixPy v1_scripts/blob/master/network/network_wiznet5k.py)"},"/soft/maixpy/en/api_reference/machine/index.html":{"title":"machine","content":" title: machine keywords: maixpy, k210, AIOT, edge computing desc: maixpy machine The machine library mainly contains various interfaces related to hardware, as follows: * [I2C](i2c.html) * [SPI](spi.html) * [Timer](timer.html) * [PWM](pwm.html) * [UART](uart.html) ## Method machine.unique_id() Get unique ID ### return value 32 byte unique ID ## Method machine.reset() Reboot"},"/soft/maixpy/en/api_reference/machine/uart.html":{"title":"machine.UART","content":" title: machine.UART keywords: maixpy, k210, AIOT, edge computing desc: maixpy machine.UART The uart module is mainly used to drive the asynchronous serial port on the development board, and uart can be configured freely. There are 3 uarts in k210, and each uart can be freely mapped. ## Construction ### Pin mapping Before using uart, we need to use fm to map and manage the chip pins. As shown below, set PIN10 as the sending pin of uart2 and PIN11 as the receiving pin of uart2 ``` fm.register(board_info.PIN10,fm.fpioa.UART2_TX) fm.register(board_info.PIN11,fm.fpioa.UART2_RX) ``` ### Constructor ``` uart machine.UART(uart,baudrate,bits,parity,stop,timeout, read_buf_len) ``` Create a new UART object with the specified parameters #### Parameters * `uart` UART number, use the specified UART, which can be completed by pressing the tab key in `machine.UART.` * `baudrate`: UART baud rate * `bits`: UART data width, support `5/6/7/8` (the default serial port used by REPL (UARTHS) only supports 8 bit mode), default `8` * `parity`: Parity bit, support `None`, `machine.UART.PARITY_ODD`, `machine.UART.PARITY_EVEN` (the default serial port (UARTHS) used by REPL only supports None), the default is `None` * `stop`: stop bit, support `1`, `1.5`, `2`, default `1` * `timeout`: Serial port receiving timeout time * `read_buf_len`: serial port receive buffer, serial port receives data through interrupt, if the buffer is full, it will automatically stop data receiving #### return value * UART object ## Method ### init It is used to initialize uart, which is generally initialized when constructing the object, here is used to reinitialize uart ``` uart.init(baudrate,bits,parity,stop,timeout, read_buf_len) ``` #### Parameters Same as constructor, but does not require the first UART number #### return value no ### read Used to read the data in the serial buffer ``` uart.read(num) ``` #### Parameters * `num`: The number of bytes read, generally fill in the buffer size, if the number of data in the buffer is not as large as `num`, then only the remaining data in the buffer will be returned #### return value * `bytes` type of data ### readline Used to read one line of serial buffer data ``` uart.readline(num) ``` * `num`: the number of rows read #### return value *`bytes` type of data ### write Used to send data using serial port ``` uart.write(buf) ``` #### Parameters * `buf`: Need to send to data #### return value * The amount of data written ### deinit Log off the UART hardware and release the occupied resources ``` uart.deinit() ``` #### Parameters no #### return value no ### repl_uart() Get the serial port object used for REPL #### return value The serial port object used for REPL, the default initialization bit is `115200 8 N 1` ## Routine ### Routine 1 Before running mileage, please make sure that `PIN15` has been connected to `PIN10`, and `PIN17` has been connected to `PIN9` After running the program, you can see the printed information of `baudrate:115200 bits:8 parity:0 stop:0 check Successfully` in the terminal ```python from fpioa_manager import fm from machine import UART fm.register(board_info.PIN15,fm.fpioa.UART1_TX) fm.register(board_info.PIN17,fm.fpioa.UART1_RX) fm.register(board_info.PIN9,fm.fpioa.UART2_TX) fm.register(board_info.PIN10,fm.fpioa.UART2_RX) uart_A UART(UART.UART1, 115200, 8, None, 1, timeout 1000, read_buf_len 4096) uart_B UART(UART.UART2, 115200, 8, None, 1, timeout 1000, read_buf_len 4096) write_str 'hello world' for i in range(20): uart_A.write(write_str) read_data uart_B.read() read_str read_data.decode('utf 8') print(\"string \",read_str) if read_str write_str: print(\"baudrate:115200 bits:8 parity:None stop:1 check Successfully\") uart_A.deinit() uart_B.deinit() del uart_A del uart_B ``` ### Routine 2 AT module serial port ```python fm.register(board_info.WIFI_RX,fm.fpioa.UART2_TX) fm.register(board_info.WIFI_TX,fm.fpioa.UART2_RX) uart machine.UART(machine.UART.UART2,115200,timeout 1000, read_buf_len 4096) ``` ### Routine 3 Modify the baud rate of the REPL serial port ```python from machine import UART repl UART.repl_uart() repl.init(1500000, 8, None, 1, read_buf_len 2048) ``` ### Routine 3 Modify the REPL serial port ```python from machine import UART fm.register(board_info.PIN15,fm.fpioa.UART1_TX) fm.register(board_info.PIN17,fm.fpioa.UART1_RX) uart machine.UART(UART.UART1, 115200) UART.set_repl_uart(uart) ```"},"/soft/maixpy/en/api_reference/machine/spi.html":{"title":"machine.SPI","content":" title: machine.SPI keywords: maixpy, k210, AIOT, edge computing desc: maixpy machine.SPI SPI (Serial Peripheral Interface) is a synchronous serial protocol composed of a master and a slave. The standard 4 wire mode consists of SCK (SCLK), CS (chip select), MOSI, MISO 4 wires connected to the master and slave On K210, SPI has the following characteristics: * There are 4 SPI devices. SPI0, SPI1, SPI3 can only work in master mode, and SPI2 can only work in slave mode. On MaixPy, SPI3 has been used to connect SPI Flash as a reserved hardware resource. * Support 1/2/4/8 line full duplex mode. In MaixPy, currently only supports standard (Motorola) 4 wire full duplex mode (ie SCK, MOSI, MISO, CS four pins) * The highest transmission rate 45M: 1/2 frequency, about 200Mbps * Support DMA * 4 hardware chip selects that can be configured with any pin ## Constructor ```python spi machine.SPI(id, mode SPI.MODE_MASTER, baudrate 500000, polarity 0, phase 0, bits 8, firstbit SPI.MSB, sck, mosi, miso, cs0, cs1, cs2, cs3) ``` Create a new SPI object with the specified parameters ### Parameters * `id`: SPI ID, value range [0,4], currently only supports 0, 1, 4, and can only be in master mode, 2 can only be used as a slave, currently not implemented, 3 reserved, 4 uses soft Simulate SPI (.SPI_SOFT) * `mode`: SPI mode, `MODE_MASTER` or `MODE_MASTER_2` or `MODE_MASTER_4` or `MODE_MASTER_8` or `MODE_SLAVE`, currently only supports `MODE_MASTER` * `baudrate`: SPI baud rate (frequency) * `polarity`: Polarity, the value is 0 or 1, which means the polarity of SPI when idle, 0 represents low level, 1 represents high level * `phase`: phase, the value bit is 0 or 1, indicating that the data is collected on the first or second edge of the clock, 0 means the first one, 1 means the second * `bits`: data width, the default value is 8, the value range is [4,32] * `firstbit`: Specify whether the transmission is in MSB or LSB order, the default is `SPI.MSB` * `sck`: SCK (clock) pin, the pin value can be passed directly, the value range: [0,47]. It is not necessary to set, but use [fm](../builtin_py/fm.html) to manage pin mapping in a unified manner. * `mosi`: MOSI (host output) pin, the pin value can be directly passed, the value range: [0,47]. It is not necessary to set, but use [fm](../builtin_py/fm.html) to manage pin mapping in a unified manner. * `miso`: MISO (host input) pin, the pin value can be directly passed, the value range: [0,47]. It is not necessary to set, but use [fm](../builtin_py/fm.html) to manage pin mapping in a unified manner. * `cs0`: CS0 (chip select) pin, the pin value can be directly passed, the value range: [0,47]. It is not necessary to set, but use [fm](../builtin_py/fm.html) to manage pin mapping in a unified manner. * `cs1`: CS1 (chip select) pin, the pin value can be directly passed, the value range: [0,47]. It is not necessary to set, but use [fm](../builtin_py/fm.html) to manage pin mapping in a unified manner. * `cs2`: CS2 (chip select) pin, the pin value can be directly passed, the value range: [0,47]. It is not necessary to set, but use [fm](../builtin_py/fm.html) to manage pin mapping in a unified manner. * `cs3`: CS3 (chip select) pin, the pin value can be directly passed, the value range: [0,47]. It is not necessary to set, but use [fm](../builtin_py/fm.html) to manage pin mapping in a unified manner. * `d0~d7`: data pins, used in non standard 4 wire mode, currently reserved. It is not necessary to set, but use [fm](../builtin_py/fm.html) to manage pin mapping in a unified manner. ## Method ### init Similar constructor ```python spi.init(id, mode SPI.MODE_MASTER, baudrate 500000, polarity 0, phase 0, bits 8, firstbit SPI.MSB, sck, mosi, miso, cs0) ``` #### Parameters Same as constructor #### return value no ### read Read data ```python spi.read(nbytes, write 0x00, cs SPI.CS0) ``` #### Parameters * `nbytes`: the length to be read * `cs`: select the chip select pin, the pins have been set for `cs0`~`cs3` during initialization, here only need to select `SPI.CS0`~`SPI.CS3`, the default is `SPI .CS0` * `write`: Because it is full duplex, set the value of the `MOSI` pin when reading, the default is `0x00`, that is, it is always low #### return value `bytes` type data ### readinto Read the data and put it in the specified variable ```python spi.readinto(buf, write 0x00, cs SPI.CS0) ``` #### Parameters * `buf`: `bytearray` type, the length is defined, the data is saved here after reading * `cs`: select the chip select pin, the pins have been set for `cs0`~`cs3` during initialization, here only need to select `SPI.CS0`~`SPI.CS3`, the default is `SPI .CS0` * `write`: Because it is full duplex, set the value of the `MOSI` pin when reading, the default is `0x00`, that is, it is always low #### return value no ### write send data ```python spi.write(buf, cs SPI.CS0) ``` #### Parameters * `buf`: `bytearray` type, which defines the data and length * `cs`: select the chip select pin, the pins have been set for `cs0`~`cs3` during initialization, here only need to select `SPI.CS0`~`SPI.CS3`, the default is `SPI .CS0` #### return value no ### write_readinto Send data and read data to variables at the same time, that is, full duplex ```python spi.write(write_buf, read_buf, cs SPI.CS0) ``` #### Parameters * `write_buf`: `bytearray` type, which defines the data and length to be sent * `read_buf`: `bytearray` type, which defines the storage location of the received data * `cs`: select the chip select pin, the pins have been set for `cs0`~`cs3` during initialization, here only need to select `SPI.CS0`~`SPI.CS3`, the default is `SPI .CS0` #### return value no ### deinit/\\__del\\__ Log off SPI, release hardware, turn off SPI clock ```python spi.deinit() ``` #### Parameters no #### return value no #### Examples ```python spi.deinit() ``` or ``` del spi ``` ## Constant * `SPI0`: SPI 0 * `SPI1`: SPI 1 * `SPI2`: SPI 2 * `MODE_MASTER`: as the master mode * `MODE_MASTER_2`: as the master mode * `MODE_MASTER_4`: as master mode * `MODE_MASTER_8`: as the master mode * `MODE_SLAVE`: as a slave mode * `MSB`: MSB, that is, send the high or high byte first * `LSB`: LSB, that is, send the low or low byte first * `CS0`: Chip select 0 * `CS1`: Chip Select 1 * `CS2`: Chip Select 2 * `CS3`: Chip Select 3 ## Routine ### Example 1: Basic read and write ```python from machine import SPI spi SPI(SPI.SPI1, mode SPI.MODE_MASTER, baudrate 10000000, polarity 0, phase 0, bits 8, firstbit SPI.MSB, sck 28, mosi 29, miso 30, cs0 27) w b'1234' r bytearray(4) spi.write(w) spi.write(w, cs SPI.CS0) spi.write_readinto(w, r) spi.read(5, write 0x00) spi.readinto(r, write 0x00) ```"},"/soft/maixpy/en/api_reference/machine/wdt.html":{"title":"machine.WDT","content":" title: machine.WDT keywords: maixpy, k210, AIOT, edge computing desc: maixpy machine.WDT MaixPy's WDT watchdog module is used to restart the system when the application crashes and eventually enters an unrecoverable state. Once started, when the hardware is running without regular feeding (feed), it will automatically reset after a timeout. ## Constructor ```python from machine import WDT wdt0 WDT(id 1, timeout 4000, callback on_wdt, context {}) ``` Create a new WDT object with specified parameters ### Parameters * `id`: When this watchdog object must be initialized, an ID (0 ~ 2) must be specified to distinguish the watchdog used. * `timeout`: Watchdog timeout time, in milliseconds (ms). * `callback`: (Optional) A callback function that can be executed after timeout. * `context`: (Optional) The parameters passed to the callback function. ## Method ### feed \"Feed\" the watchdog to prevent it from resetting the system. The app should use the call in the right place and make sure to \"feed\" the watchdog only after verifying that everything is working properly. ```python wdt0.feed() ``` #### Parameters no #### return value no ### stop Stop the current watchdog object ```python wdt0.stop() ``` #### Parameters no #### return value no ## Routine ### Routine 1 (Basic use) Feed the dog once and stop feeding the dog to reset the system ```python import time from machine import WDT #''' # test default wdt wdt0 WDT(id 0, timeout 3000) print('into', wdt0) time.sleep(2) print(time.ticks_ms()) # 1.test wdt feed wdt0.feed() time.sleep(2) print(time.ticks_ms()) # 2.test wdt stop # wdt0.stop() ``` ### Routine 2 (advanced use) Feed the dog in the callback function and the system runs normally ```python import time from machine import WDT def on_wdt(self): print(self.context(), self) self.feed() ## release WDT #self.stop() # test callback wdt wdt1 WDT(id 1, timeout 4000, callback on_wdt, context {}) print('into', wdt1) time.sleep(2) print(time.ticks_ms()) # 1.test wdt feed wdt1.feed() time.sleep(2) print(time.ticks_ms()) # 2.test wdt stop # wdt1.stop() # print('stop', wdt1) # 3.wait wdt work while True: print('idle', time.ticks_ms()) time.sleep(1) ```"},"/soft/maixpy/en/api_reference/builtin_py/pye.html":{"title":"Micropython Editor","content":" title: Micropython Editor keywords: maixpy, k210, AIOT, edge computing desc: maixpy Micropython Editor MaixPy firmware integrates a file editor [`pye`](https://github.com/robert hh/Micropython Editor), users can directly modify the files in the board through the serial terminal Instructions: ```python from pye_mp import pye pye(\"/sd/boot.py\") ```"},"/soft/maixpy/en/api_reference/builtin_py/board_info.html":{"title":"Board","content":" title: Board keywords: maixpy, k210, AIOT, edge computing desc: maixpy Board > **This document has passed the test of MaixPy 0.5.1 128. ** This is a MaixPy board level configuration module, which can unify Python code at the user level, thereby shielding many hardware pin differences. The effect is as follows: ```python from Maix import GPIO from fpioa_manager import fm from board import board_info print(board_info.LED_R) fm.register(board_info.LED_R, fm.fpioa.GPIO0, force True) led_r GPIO(GPIO.GPIO0, GPIO.OUT) led_r.value(0) ``` And this code supports all MaixPy hardware to run at the same time, and the printed board_info.LED_R is not the same, it ensures the consistency of the sample code. ### Board configuration method Copy the python code corresponding to the following link (such as config_maix_bit.py), put it in the IDE edit box and run it to complete the import of the \"your hardware\" configuration item (config.json), which will be stored on the flash Configuration file. After running the configuration code, it will automatically restart. At this time, board_info.BOOT_KEY can be called in the code. In fact, board_info.BOOT_KEY refers to IO 16. The corresponding definition can be seen in config.json. If the resource does not exist, an error will be reported. If there is no hardware defined by LED, an error will be reported when the running LED is on. ```python from board import board_info # see board/readme.md to config your sipeed's hardware. print(board_info.BOOT_KEY, board_info.BOOT_KEY 16) ``` ### Maix Bit [config_maix_bit.py](https://github.com/sipeed/MaixPy v1_scripts/tree/master/board/config_maix_bit.py) ### Maix Dock [config_maix_dock.py](https://github.com/sipeed/MaixPy v1_scripts/tree/master/board/config_maix_dock.py) ### Maix Go [config_maix_go.py](https://github.com/sipeed/MaixPy v1_scripts/tree/master/board/config_maix_go.py) ### Maix Duino [config_maix_duino.py](https://github.com/sipeed/MaixPy v1_scripts/tree/master/board/config_maix_duino.py) ### Maix Cube [config_maix_cube.py](https://github.com/sipeed/MaixPy v1_scripts/tree/master/board/config_maix_cube.py) ### Maix Amigo [config_maix_amigo.py](https://github.com/sipeed/MaixPy v1_scripts/tree/master/board/config_maix_amigo.py) ### Maix Nano > This has no hardware peripherals... So don't ask why there is no configuration code. ### Create your own hardware You can use this interface code to adapt to your hardware. For the configuration method, please refer to [MaixPy_scripts/board](https://github.com/sipeed/MaixPy v1_scripts/tree/master/board) There is a configuration file for your reference. ### How to use board Import configuration: ```python from board import board_info board_info.load({ 'PIN10': 10, 'BOOT_KEY': 16, 'WIFI_TX': 6, 'WIFI_RX': 7, 'WIFI_EN': 8, }) print('PIN10:', board_info.PIN10) print('BOOT_KEY:', board_info.BOOT_KEY) print('WIFI_TX:', board_info.WIFI_TX) print('WIFI_RX:', board_info.WIFI_RX) print('WIFI_EN:', board_info.WIFI_EN) ``` Call result: ```shell PIN10: 10 BOOT_KEY: 16 WIFI_TX: 6 WIFI_RX: 7 WIFI_EN: 8 ``` > That's it."},"/soft/maixpy/en/api_reference/builtin_py/index.html":{"title":"built-in class (builtin_py)","content":" title: built in class (builtin_py) keywords: maixpy, k210, AIOT, edge computing desc: maixpy built in class (builtin_py) The `builtin_py` library (builtin_py) is a user level interface that encapsulates the underlying classes of MaixPy, which is convenient for users to use MaixPy. It includes the following: * [fpioa_manager](fm.html) * [board_info](board_info.html) * [pye](pye.html) > `board_info` is related to the board, and different board configurations are different. [Manual configuration](board_info.html) is required before use. ```python from board import board_info from fpioa_manager import fm ```"},"/soft/maixpy/en/api_reference/builtin_py/fm.html":{"title":"fpioa_manager","content":" title: fpioa_manager keywords: maixpy, k210, AIOT, edge computing desc: maixpy fpioa_manager > **This document has passed the test of MaixPy 0.5.1 128. ** fpioa_manager: abbreviated as `fm`, this module is used to register the internal functions and pins of the chip, and help users to manage the internal functions and pin mapping relationships. ## How to understand [pin] mapping [internal function]? The external pins and internal functions on the K210 chip are independent of each other. The pins refer to many metal contacts drawn from the chip, which are also commonly known as function pins. It can be GPIO / PWM / ADC / I2C, etc. Function pins, the traditional cognition is that the internal functions corresponding to the pins cannot be changed, but they can be reused. The K210 can change the pin functions through mapping. See the diagram below to understand the specific mapping functions. First, you can map (MAP) the I2C SCL/SDA to the IO6/IO7 pin, so that I2C read and write operations can be performed on this pin. ``` + + + + < + < + I2C IO6 + + + + < + < + UART IO7 + + + + < + SPI IO8 + + + + < + I2S IO9 + + + + ``` Then you can map (MAP) the SCLK/MOSI/MISO/CS of SPI to the IO6/IO7/IO8/IO9 pin, and you can read and write SPI on this pin. ``` + + + + < < < I2C IO6 + + + + < < + UART IO7 + + + + + SPI < < + + IO8 + + < < + I2S IO9 + + + + ``` ## Instructions Call the register function to bind the pin to the specific hardware function (GPIO/I2C/UART/I2S/SPI), and call unregister when not in use to release the hardware function bound to the pin (or **function* *) This is different from the understanding of traditional single chip microcomputers. K210 can map pins within a certain range to specific hardware functions. As shown in the following code: ```python from fpioa_manager import fm fm.register(11, fm.fpioa.GPIO0, force True) fm.register(12, fm.fpioa.GPIOHS0, force True) fm.register(13, fm.fpioa.UART2_TX) fm.register(14, fm.fpioa.UART2_RX) # other code fm.unregister(11) fm.unregister(12) fm.unregister(13) fm.unregister(14) ``` **Precautions**: The following GPIOHS has been used by default in MaixPy, please don't use it unless necessary in the program. GPIOHS Function Description GPIOHS31 LCD_DC LCD control signal pin GPIOHS30 LCD_RST LCD reset chip pin GPIOHS29 SD_CS SD card SPI chip select GPIOHS28 MIC_LED_CLK SK9822_DAT GPIOHS27 MIC_LED_DATA SK9822_CLK In addition, the following pins have been registered when MaxiPy starts up, please pay attention. ### SD card * `Function`: SPI1_SCLK/SPI1_D0/SPI1_D1/GPIOHS29/SPI0_SS1 * `Pin`: PIN25/PIN26/PIN27/PIN28/PIN29 ### LCD * `Function`: SPI0_SS3/SPI0_SCLK/GPIOHS30/GPIOHS31 * `Pin`: PIN36/PIN37/PIN38/PIN39 ### sensor * `Function`: SCCB_SDA/SCCB_SCLK/CMOS_RST/CMOS_VSYNC/CMOS_PWDN/CMOS_HREF/CMOS_XCLK/CMOS_PCLK * `Pin`: PIN40/PIN41/PIN42/PIN43/PIN44/PIN45/PIN46/PIN47 ### REPL * `Function`: UARTHS_RX/UARTHS_TX * `Pin`: PIN4/PIN5 ## class `fm` ### register(pin, func, force True) * `pin`: Function mapping pin * `function`: Chip function * `force`: Forced allocation, if it is `True`, the same pin can be registered multiple times; `False` does not allow multiple registration of the same pin. The default is `True` to facilitate the use of `IDE` to run the program multiple times Set the peripheral function (func) corresponding to the pin (pin). The forced binding parameter (force True) is enabled by default. It will force the specified pin function to be replaced. If it finds the last bound pin, it will A warning is issued, but it does not affect the continued execution of the code. If force False is set, it will be found in the register that the hardware function has been used, and an exception will pop up at this time, which is convenient for in depth development. When some functions cannot be used. #### Instructions ```python from fpioa_manager import fm fm.register(16, fm.fpioa.GPIO2) fm.register(13, fm.fpioa.GPIO2) fm.register(12, fm.fpioa.GPIO2, force False) ``` It can be seen that the occupancy status of fm.fpioa.GPIO2(pin:16) and fm.fpioa.GPIO2(pin:13) are prompted. ```shell [Warning] function is used by fm.fpioa.GPIO2(pin:16) Traceback (most recent call last): File \"<stdin>\", line 5, in <module> File \"fpioa_manager.py\", line 20, in register Exception: [Warning] function is used by fm.fpioa.GPIO2(pin:13) ``` ### unregister(pin) Release the hardware function (GPIO/I2C/SPI/I2S/UART) on the pin. ### get_pin_by_function(pin) Get the hardware function bound on the pin. ### get_gpio_used() Get the usage status of all gpio, it only queries the GPIOHS / GPIO pin assignment, None means that the hardware function is not used. #### Instructions ```python from fpioa_manager import fm for item in fm.get_gpio_used(): print(item) ``` > Note: Each pin will have a default state ```shell ('fm.fpioa.GPIOHS0', 16) ('fm.fpioa.GPIOHS1', 17) ('fm.fpioa.GPIOHS2', 18) ('fm.fpioa.GPIOHS3', 19) ('fm.fpioa.GPIOHS4', 37) ('fm.fpioa.GPIOHS5', 38) ('fm.fpioa.GPIOHS6', 22) ('fm.fpioa.GPIOHS7', 23) ('fm.fpioa.GPIOHS8', 24) ('fm.fpioa.GPIOHS9', 25) ('fm.fpioa.GPIOHS10', None) ('fm.fpioa.GPIOHS11', 27) ('fm.fpioa.GPIOHS12', 28) ('fm.fpioa.GPIOHS13', 29) ('fm.fpioa.GPIOHS14', 30) ('fm.fpioa.GPIOHS15', 31) ('fm.fpioa.GPIOHS16', 32) ('fm.fpioa.GPIOHS17', 33) ('fm.fpioa.GPIOHS18', 34) ('fm.fpioa.GPIOHS19', 35) ('fm.fpioa.GPIOHS20', None) ('fm.fpioa.GPIOHS21', None) ('fm.fpioa.GPIOHS22', None) ('fm.fpioa.GPIOHS23', None) ('fm.fpioa.GPIOHS24', 40) ('fm.fpioa.GPIOHS25', 41) ('fm.fpioa.GPIOHS26', 42) ('fm.fpioa.GPIOHS27', 43) ('fm.fpioa.GPIOHS28', 44) ('fm.fpioa.GPIOHS29', 26) ('fm.fpioa.GPIOHS30', 46) ('fm.fpioa.GPIOHS31', 47) ('fm.fpioa.GPIO0', 8) ('fm.fpioa.GPIO1', 9) ('fm.fpioa.GPIO2', None) ('fm.fpioa.GPIO3', None) ('fm.fpioa.GPIO4', 12) ('fm.fpioa.GPIO5', 13) ('fm.fpioa.GPIO6', 14) ('fm.fpioa.GPIO7', 15) ``` ### help() Calling it will print out the following help description of \"Appendix: Peripheral Table\". See [FPIOA](../Maix/fpioa.html) for details."},"/soft/maixpy/en/api_reference/media/video.html":{"title":"video","content":" title: video keywords: maixpy, k210, AIOT, edge computing desc: maixpy video (video) Supports playback and recording of `avi` video ## Global functions ### open(path, record False, interval 100000, quality 50, width 320, height 240, audio False, sample_rate 44100, channels 1) Open a file to play or record #### Parameters * `path`: file path, such as `/sd/badapple.avi` * `record`: Whether to record, if you select `Ture`, the video will be recorded, otherwise it will be played. Default `False` * `interval`: The recording frame interval, the unit is microseconds, fps 1000000/interval, the default is `100000`, that is, `10` frames per second * `quality`: `jpeg` compression quality (`%`), default `50` * `width`: recording screen width, default `320` * `height`: Record screen height, default `240` * `audio`: Whether to record audio, default is `False` * `sample_rate`: Record audio sample rate, default `44100` (`44.1k`) * `channels`: the number of recorded audio channels, the default is `1`, which is mono #### return value Return an object, the object returned is different according to different formats. Currently only the `avi` format is supported, and objects created by the `avi` class are returned ## Class `avi` Returned by the `video.open()` function ### play() Play video, parse the data (audio or video) every time it is called #### return value * `0`: End of playback * `1`: Now playing * `2`: Pause (reserve) * `3`: The currently decoded frame is a video frame * `4`: The currently decoded frame is an audio frame ### capture(img) Capture video frames (sequential capture) #### Parameters * `img`: image object, used to store the captured image #### return value * `0`: The end of the video has been reached * `3`: The video frame is successfully captured ### volume(volume) Set volume #### Parameters * `volume`: volume value, value range: [0,100] #### return value Set volume value, value range [0,100] ### record() Record video and audio. Each time you call to record one frame, the function will limit the speed. If the recording interval is not reached, it will block before reaching the set interval. #### return value The length of the current frame of the recorded video ## Routine ### Example 1: Play `avi` video First of all, make sure that the video is `320x240` size, the video compression format is `mjpeg`, and the audio compression format is `PCM`. You can download the video that can be used for testing here: [badapple.avi](http://api.dl.sipeed.com/shareURL/MAIX/MaixPy/assets) ```python import video,time from Maix import GPIO fm.register(34, fm.fpioa.I2S0_OUT_D1) fm.register(35, fm.fpioa.I2S0_SCLK) fm.register(33, fm.fpioa.I2S0_WS) fm.register(8, fm.fpioa.GPIO0) wifi_en GPIO(GPIO.GPIO0,GPIO.OUT) wifi_en.value(0) v video.open(\"/sd/badapple.avi\") print(v) v.volume(50) while True: if v.play() 0: print(\"play end\") break v.__del__() ``` By default, `I2S0` is used to play audio, so you need to set the pin corresponding to `I2S0`. Turn off the WiFi because the WiFi of the `Dock` board interferes with the sound quality ### Example 2: Record `avi` video ```python import sensor, image, lcd, time lcd.init(freq 15000000) sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.set_hmirror(1) sensor.set_vflip(1) sensor.run(1) sensor.skip_frames(30) import video v video.open(\"/sd/capture.avi\", audio False, record 1, interval 200000, quality 50) tim time.ticks_ms() for i in range(50): tim time.ticks_ms() img sensor.snapshot() lcd.display(img) img_len v.record(img) # print(\"record\",time.ticks_ms() tim) print(\"record_finish\") v.record_finish() v.__del__() # play your record v video.open(\"/sd/capture.avi\") print(v) v.volume(50) while True: if v.play() 0: print(\"play end\") break print(\"play finish\") v.__del__() lcd.clear() ``` You can cancel the print mask to see if the actual recording interval has reached the set frame interval (for example, the `200000us` set here), the actual printing should be `200ms`, If the actual frame interval is greater than the set value, it means that the actual performance does not meet the set requirements. You need to increase the set frame interval to reduce the frame rate. In addition, removing the display and printing can also increase the frame rate to a certain extent. ### Example 3: Sequence `avi` to capture video frames and display ```python import lcd import video import image lcd.init() v video.open(\"/sd/badapple_320_240_15fps.avi\") print(v) img image.Image() while True: status v.capture(img) if status ! 0: lcd.display(img) else: print(\"end\") break; v.__del__() ```"},"/soft/maixpy/en/api_reference/media/nes.html":{"title":"NES game emulator","content":" title: NES game emulator keywords: maixpy, k210, AIOT, edge computing desc: maixpy NES game emulator The classic FC red and white game simulator, take us back to our childhood~~ **Warning, this module is only compiled and included in the standard firmware (> 2m), and not included in other firmware. If necessary, please recompile the firmware. ** ## Function ### init(rc_type nes.KEYBOARD, cs, mosi, miso, clk, repeat 16, vol 5) Initialize the `NES` emulator #### Parameters * `tc_type`: remote control type, keyboard (`nes.KEYBOARD`) (note that the serial port communicates with the computer, not directly connecting the USB keyboard to the development board) or handle (`nes.JOYSTICK`). > It is recommended to use the `PS2` handle, the experience will be better, the keyboard may not be able to press multiple keys at the same time when inputting through the serial tool, of course, you can also write a script on the PC to forward the key value to solve the problem (go [here] (https ://github.com/sipeed/MaixPy v1_scripts/tree/master/multimedia/nes) Looking for it?) * `cs`: If you use the `PS2` handle of the `SPI` interface, pass in the `cs` peripheral number (note that it is not a pin number, you need to map the pin first) * `mosi`: If you use the `PS2` handle of the `SPI` interface, pass in the `mosi` peripheral number (note that it is not a pin number, you need to map the pin first) * `miso`: If you use the `PS2` handle of the `SPI` interface, pass in the `miso` peripheral number (note that it is not a pin number, you need to map the pin first) * `clk`: If you use the `PS2` handle of the `SPI` interface, pass in the `clk` peripheral number (note that it is not a pin number, you need to map the pin first) * `repeat`: This parameter is only used when using the keyboard (/serial port), it refers to the repeat rate of the keys * `vol`: The volume during initialization, which can be adjusted by pressing the buttons later ### Basic example Run `NES` game `ROM` #### Parameters * `nes`: the path of the game `ROM`, such as `/sd/mario.nes` ```python try: nes.init(nes.INPUT) nes.load(\"/sd/mario.nes\") while True: nes.loop() finally: nes.free() ``` ## hot key ### Code input * `nes.input`: `(①No. handset handle, ②No. handset handle, menu function)` ### Keyboard (/serial port) * `Move`: `W A S D` * `A`: `J` * `B`: `K` * `start`: `M` or `Enter` * `option`: `N` or `\\` * `Exit`: `ESC` * `Volume `: ` ` * `Volume +`: ` ` * `Running Speed ​​ `: `R` * `Run speed +`: `F` ### Handle * `Move`: Arrow keys `< ` `^` `V` ` >` * `A`: `□` * `B`: `×` * `start`: `START` * `select`: `SELECT` * `Exit`: None * `Volume `: `R2` * `Volume +`: `R1` * `Run speed `: `L1` * `Run speed +`: `L2` ## Routine > \"mario.nes\" game file please search and download by yourself ## Example 0: Code input > January 28, 2021: It is now recommended to use Maix handle (I2C device) to play. The following code comment `nes.input(p1, p2, 0)` means to input the data of two handles. ```python import nes, lcd lcd.init(freq 15000000) try: nes.init(nes.INPUT) nes.load(\"mario.nes\") while True: # p1 i2c.readfrom(66, 1) # handle i2c addr # p2 i2c.readfrom(74, 1) # handle i2c addr # nes.input(p1, p2, 0) nes.loop() finally: nes.free() ``` ## Example 1: Keyboard (serial port) ```python import nes, lcd lcd.init(freq 15000000) nes.init(nes.KEYBOARD) nes.load(\"/sd/mario.nes\") while True: nes.loop() ``` ## Example 2: PS2 handle ```python import nes, lcd from fpioa_manager import fm fm.register(19, fm.fpioa.GPIOHS19) fm.register(18, fm.fpioa.GPIOHS18) fm.register(23, fm.fpioa.GPIOHS23) fm.register(21, fm.fpioa.GPIOHS21) lcd.init(freq 15000000) nes.init(nes.JOYSTICK, cs fm.fpioa.GPIOHS19, clk fm.fpioa.GPIOHS18, mosi fm.fpioa.GPIOHS23, miso fm.fpioa.GPIOHS21) nes.load(\"/sd/mario.nes\") while True: nes.loop() ```"},"/soft/maixpy/en/api_reference/media/audio.html":{"title":"audio","content":" title: audio keywords: maixpy, k210, AIOT, edge computing desc: maixpy audio (audio) Abstract audio object, which can be passed in as a parameter or directly use its method to play audio ## Module function ### Constructor Construct an `Audio` object ```python audio.Audio(array None, path None, points 1024) ``` #### Parameters The interface can pass in a parameter, each parameter will determine a different audio type * `array`: `bytearray` type data, which can be converted into audio objects, the default is `None` * `path`: Open audio file path, currently only supports `wav` format, default is `None`, **Note** The keyword `path`, `audio.Audio(\"/sd/1.wav\" needs to be marked) )`This is wrong! ! `audio.Audio(path \"/sd/1.wav\")` is correct * `points`: Open up an audio buffer with points sampling points, one sampling point is 32bit. If it is 0, the buffer will not be opened, and the default is 1024. #### return value Returns an `Audio` object ### to_bytes: bytes conversion function Convert the audio data in the audio object to an object of type `bytearray` ``` audio_data test_audio.to_bytes() ``` #### Parameters no #### return value The returned audio data `bytearray` object ### play_process: Play preprocessing function It is used to preprocess audio objects. The audio file needs to be parsed before playing, so preprocessing is required. Here you need to pass in an I2S device for playback ``` wav_info test_audio.play_process(i2s_dev) ``` #### Parameters * `i2s_dev`: i2s device for playback #### return value The header information of the wav file, `list` type, are `numchannels` (number of channels), `samplerate` (sampling rate), `byterate` (number of data bytes per second samplerate * numchannels * bitspersample / 8 ), `blockalign` (the number of bytes required for each sample numchannels * bitspersample / 8), `bitspersample` (the number of bits stored in each sample, 8: 8bit, 16: 16bit, 32: 32bit), `datasize `(audio data length) ### play: play function Read audio files and parse them for playback, generally used with loop #### Parameters no #### return value * `None`: The format does not support playback * `0`: End of playback * `1`: Now playing ### finish: Audio post processing function To complete the audio playback, this function must be called after the playback is completed to recover the resources allocated by the bottom layer #### Parameters no #### return value no ## Routine Play `wav` audio ```python from fpioa_manager import * from Maix import I2S, GPIO import audio # disable wifi fm.register(8, fm.fpioa.GPIO0) wifi_en GPIO(GPIO.GPIO0,GPIO.OUT) wifi_en.value(0) # register i2s(i2s0) pin fm.register(34,fm.fpioa.I2S0_OUT_D1) fm.register(35,fm.fpioa.I2S0_SCLK) fm.register(33,fm.fpioa.I2S0_WS) # init i2s(i2s0) wav_dev I2S(I2S.DEVICE_0) # init audio player audio.Audio(path \"/sd/6.wav\") player.volume(40) # read audio info wav_info player.play_process(wav_dev) print(\"wav file head information: \", wav_info) # config i2s according to audio info wav_dev.channel_config(wav_dev.CHANNEL_1, I2S.TRANSMITTER,resolution I2S.RESOLUTION_16_BIT ,cycles I2S.SCLK_CYCLES_32, align_mode I2S.RIGHT_JUSTIFYING_MODE) wav_dev.set_sample_rate(wav_info[1]) # loop to play audio while True: ret player.play() if ret None: print(\"format error\") break elif ret 0: print(\"end\") break player.finish() ```"},"/soft/maixpy/en/api_reference/machine_vision/lcd.html":{"title":"lcd (screen display)","content":" title: lcd (screen display) keywords: maixpy, k210, AIOT, edge computing desc: maixpy lcd (screen display) ## Function ### lcd.init(type 1, freq 15000000, color lcd.BLACK, invert 0, lcd_type 0) Initialize the `LCD` screen display #### Parameters * `type`: Type of device (reserved for future use): * `0`: None * `1`: lcd shield (default value) * `2`: Maix Cube * `5`: sipeed rgb screen adapter board > type is a key value parameter, which must be explicitly called by writing type in the function call * `freq`: the frequency of `LCD` (actually refers to the communication rate of `SPI`) * `color`: The color initialized by `LCD`, which can be a 16 bit `RGB565` color value, such as `0xFFFF`; or a `RGB888` tuple, such as `(236, 36, 36)`, which defaults to `lcd. BLACK` * `invert`: `LCD` inverted color display * `lcd_type`: lcd type: * `0`: default type * `1`: LCD_TYPE_ILI9486 * `2`: LCD_TYPE_ILI9481 * `3`: LCD_TYPE_5P0_7P0, a 5 inch or 7 inch LCD with a resolution of 800 * 480 (requires a sipeed adapter board) * `4`: LCD_TYPE_5P0_IPS, 5 inch IPS LCD with a resolution of 854*489 (requires sipeed adapter board) * `5`: LCD_TYPE_480_272_4P3, 4.3 inch LCD with a resolution of 480*272 (sipeed adapter board required) > MaixCube and MaixAmigo need to configure the power chip before using the LCD, otherwise the screen will be blurred. In this step, the MaixPy firmware will be configured automatically, no manual operation is required, the user only needs to understand. ### lcd.deinit() Log off the `LCD` driver and release the I/O pins ### lcd.width() Returns the width of `LCD` (horizontal resolution) ### lcd.height() Returns the height (vertical resolution) of `LCD`. ### lcd.type() Return the type of `LCD` (reserved for future use): 0: None 1: lcd Shield ### lcd.freq(freq) Set or get the frequency of `LCD` (SPI) #### Paremeters * `freq`: LCD (SPI) frequency #### Return LCD frequency ### lcd.set_backlight(state) Set the backlight status of `LCD`, turning off the backlight will greatly reduce the power consumption of the LCD expansion board > Not implemented #### Parameters * `state`: backlight brightness, value [0,100] ### lcd.get_backlight() Back to backlight state #### return value Backlight brightness, value [0,100] ### lcd.display(image, roi Auto) Display an image (GRAYSCALE or RGB565) on the LCD screen. roi is a rectangular tuple (x, y, w, h) of a region of interest. If not specified, it is the image rectangle If the roi width is smaller than the lcd width, use a vertical black border to center the roi in the center of the screen (that is, fill the unoccupied area with black). If the width of roi is greater than the width of lcd, the roi is at the center of the screen, and the mismatched pixels will not be displayed (that is, the LCD screen displays the center of roi in the form of a window). If the height of roi is less than the height of lcd, use a vertical black border to make roi in the center of the screen (that is, fill the unoccupied area with black). If the height of roi is greater than the height of lcd, the roi is at the center of the screen, and the mismatched pixels will not be displayed (that is, the LCD screen displays the center of roi in the form of a window). > roi is a key value parameter, which must be explicitly called by writing roi in the function call. * `oft`: Set the offset coordinate, after setting this coordinate, the surrounding will not be automatically filled ### lcd.clear() Clear the LCD screen to black or the specified color. #### Parameters * `color`: The color initialized by `LCD`, which can be a 16 bit `RGB565` color value, such as `0xFFFF`; or a tuple of `RGB888`, such as `(236, 36, 36)` ### lcd.direction(dir) It has been abandoned after `v0.3.1`, please use `lcd.rotation` and `lcd.invert` instead, do not use it unless necessary, the interface will still be reserved for debugging Set the screen orientation, and whether to mirror, etc. #### Parameters * `dir`: Under normal circumstances, `lcd.YX_LRUD` and `lcd.YX_RLDU` are recommended, and there are other values, just exchange `XY` or `LR` or `DU` ### lcd.rotation(dir) Set `LCD` screen orientation #### Parameters * `dir`: value range [0,3], rotate clockwise from `0` to `3` #### return value Current direction, value [0,3] ### lcd.mirror(invert) Set whether `LCD` is displayed on mirror #### Parameters * `invert`: Whether to display in mirror, `True` or `False` #### return value The current setting, whether to display in a mirror, return to `True` or `False` ### lcd.bgr_to_rgb(enable) Set whether to enable bgr color display #### Parameters * `enable`: Whether to enable bgr display, `True` or `False` ### lcd.fill_rectangle(x, y, w, h, color) Fill a rectangle area on `LCD` #### Parameters * `x`: start coordinate `x` * `x`: starting coordinate `y` * `w`: padding width * `h`: Fill height * `color`: Fill color, which can be a tuple, such as `(255, 255, 255)`, or `RGB565``uint16` value, such as red `0x00F8` ## Routine ### Example 1: Display English ```python import lcd lcd.init() lcd.draw_string(100, 100, \"hello maixpy\", lcd.RED, lcd.BLACK) ``` ### Example 2: Display picture ```python import lcd import image img image.Image(\"/sd/pic.bmp\") lcd.display(img) ``` ### Example 3: Display English by displaying pictures ```python import lcd import image img image.Image() img.draw_string(60, 100, \"hello maixpy\", scale 2) lcd.display(img) ``` ### Example 4: Display the image captured by the camera in real time ```python import sensor, lcd sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) sensor.skip_frames() lcd.init() while(True): lcd.display(sensor.snapshot()) ```"},"/soft/maixpy/en/api_reference/machine_vision/isolated_word.html":{"title":"isolated_word (isolated word MFCC module)","content":" title: isolated_word (isolated word MFCC module) keywords: maixpy, k210, AIOT, edge computing desc: maixpy isolated_word (isolated word MFCC module) ## Class (class) ### isolated_word The isolated_word construction parameters are as follows: `dmac`: DMA channel used for recording. [Channel 2] is used by default. `i2s`: Recording device, I2S.DEVICE_0 is used by default. `size`: The capacity of vocabulary templates, which means the total number of templates that can be loaded. The default is 10. `shift`: Channel selection. Maix series hardware recording devices usually use mono input. Set 0 as the left channel, so 1 is the right channel. ```python from speech_recognizer import isolated_word sr isolated_word(dmac 2, i2s I2S.DEVICE_0, size 10, shift 0) ``` ## Method (function) ### size Returns the total number of current word templates. ```python from speech_recognizer import isolated_word sr isolated_word() sr.size() ``` ### set_threshold Set the working parameters of the isolated word module. Parameter①: Noise threshold, used for short time zero crossing rate calculation Parameter ②: Short time zero crossing rate threshold, exceeding this threshold is regarded as entering the transition section. Parameter ③: Short term accumulation and threshold value. If the threshold is exceeded, it is regarded as entering the transition section. ```python from speech_recognizer import isolated_word sr isolated_word() sr.set_threshold(0, 0, 10000) ``` ### record Enter [Vocabulary Template]. Parameter ①: Save the entered template to the specified index location. ```python from speech_recognizer import isolated_word sr isolated_word() while True: if sr.Done sr.record(0): pass ``` ### state You can return to the following working status. Function Description Init The module has been initialized. Idle The module is idling and is not working. Ready Module recording is processing. MaybeNoise The module determines whether it is a noise environment. Speak The module waits for voice recording. Restrain The data entered by the module is illegal, and the module returns to the Speak state. Done The module voice recognition is successful, and the result can be obtained through result. ### recognize Recognize [word template]. ```python from speech_recognizer import isolated_word sr isolated_word() while True: if sr.Done sr.recognize(): print(sr.result()) ``` ### result Get [Vocabulary Template] and return an array of (matched template number, matched dtw value, current frame length, matched frame length). ```python from speech_recognizer import isolated_word sr isolated_word() print(sr.result()) ``` ### get Get 【Vocabulary Template】, and return (data frame length, data frame) array. #### return value * `frm_len`: data frame length * `frm_data`: data frame ```python from speech_recognizer import isolated_word sr isolated_word() print(sr.get(0)) ``` ### set Load [Vocabulary Template] into the module. ```python from speech_recognizer import isolated_word sr isolated_word() print(sr.set(1, sr.get(0))) ``` ### run Run the isolated word module (recording). ```python from speech_recognizer import isolated_word sr isolated_word() sr.run() ``` ### reset Reset the isolated word module. ```python from speech_recognizer import isolated_word sr isolated_word() sr.reset() ``` ### dtw Back to Dynamic Time Warping (DTW) algorithm Calculate the optimal matching value, the smaller the value, the better. #### return value * `dis`: Cumulative matching distance (int) ```python from speech_recognizer import isolated_word sr isolated_word() print(sr.dtw(sr.get(0))) ``` ### __del__ To release the orphan word module, it can be called actively, or it can be automatically collected by gc.collect(). ```python from speech_recognizer import isolated_word sr isolated_word() sr.__del__() del sr ```"},"/soft/maixpy/en/api_reference/machine_vision/index.html":{"title":"machine vision/hearing","content":" title: machine vision/hearing keywords: maixpy, k210, AIOT, edge computing desc: maixpy machine vision/hearing It mainly contains classes related to image, display, and voice, including: * [lcd](lcd.html) * [sensor](sensor.html) * [image](./image/image.html) * [video](video.html) * [isolated_word](isolated_word.html) * [maix_asr](maix_asr.html)"},"/soft/maixpy/en/api_reference/machine_vision/maix_asr.html":{"title":"maix_asr (voice recognition module)","content":" title: maix_asr (voice recognition module) keywords: maixpy, k210, AIOT, edge computing desc: maixpy maix_asr (speech recognition module) ## class (class) ### maix_asr The maix_asr construction parameters are as follows: [address] Flash address for programming the acoustic model. [i2s] Recording device, I2S.DEVICE_0 is used by default. [dmac] The DMA channel used for recording. [Channel 3] is used by default. [shift] Channel selection. Maix series hardware recording devices usually use mono input. Set 0 as the left channel, so 1 is the right channel. ```python from speech_recognizer import asr class maix_asr(asr): def config(self, sets): pass t maix_asr(0x500000, I2S.DEVICE_0, 3, shift 0) ``` The maix_asr module is an extended configuration interface auxiliary class that inherits the internal asr module, and is implemented as follows: ```python from speech_recognizer import asr class maix_asr(asr): asr_vocab [\"lv\", \"shi\", \"yang\", \"chun\", \"yan\", \"jing\", \"da\", \"kuai\", \"wen\", \"zhang\", \"de\", \"di\" , \"se\", \"si\", \"yue\", \"lin\", \"luan\", \"geng\", \"xian\", \"huo\", \"xiu\", \"mei\", \"yi\", \"ang\", \" ran\", \"ta\", \"jin\", \"ping\", \"yao\", \"bu\", \"li\", \"liang\", \"zai\", \"yong\", \"dao\", \"shang\", \"xia\" , \"fan\", \"teng\", \"dong\", \"she\", \"xing\", \"zhuang\", \"ru\", \"hai\", \"tun\", \"zhi\", \"tou\", \"you\", \" ling\", \"pao\", \"hao\", \"le\", \"zha\", \"zen\", \"me\", \"zheng\", \"cai\", \"ya\", \"shu\", \"tuo\", \"qu\" , \"fu\", \"guang\", \"bang\", \"zi\", \"chong\", \"shui\", \"cuan\", \"ke\", \"shei\", \"wan\", \"hou\", \"zhao\", \" jian\", \"zuo\", \"cu\", \"hei\", \"yu\", \"ce\", \"ming\", \"dui\", \"cheng\", \"men\", \"wo\", \"bei\", \"dai\" , \"zhe\", \"hu\", \"jiao\", \"pang\", \"ji\", \"lao\", \"nong\", \"kang\", \"yuan\", \"chao\", \"hui\", \"xiang\", \" bing\", \"qi\", \"chang\", \"nian\", \"jia\", \"tu\", \"bi\", \"pin\", \"xi\", \"zou\", \"chu\", \"cun\", \"wang\" , \"na\", \"ge\", \"an\", \"ning\", \"tian\", \"xiao\", \"zhong\", \"shen\", \"nan\", \"er\", \"ri\", \"zhu\", \" xin\", \"wai\", \"luo\", \"gang\", \"qing\", \"xun\", \"te\", \"cong\", \"gan\", \"lai\", \"he\", \"dan\", \"wei\" , \"die \", \"kai\", \"ci\", \"gu\", \"neng\", \"ba\", \"bao\", \"xue\", \"shuai\", \"dou\", \"cao\", \"mao\", \"bo\", \"zhou\", \"lie\", \"qie\", \"ju\", \"chuan\", \"guo\", \"lan\", \"ni\", \"tang\", \"ban\", \"su\", \"quan\", \"huan \", \"ying\", \"a\", \"min\", \"meng\", \"wu\", \"tai\", \"hua\", \"xie\", \"pai\", \"huang\", \"gua\", \"jiang\", \"pian\", \"ma\", \"jie\", \"wa\", \"san\", \"ka\", \"zong\", \"nv\", \"gao\", \"ye\", \"biao\", \"bie\", \"zui \", \"ren\", \"jun\", \"duo\", \"ze\", \"tan\", \"mu\", \"gui\", \"qiu\", \"bai\", \"sang\", \"jiu\", \"yin\", \"huai\", \"rang\", \"zan\", \"shuo\", \"sha\", \"ben\", \"yun\", \"la\", \"cuo\", \"hang\", \"ha\", \"tuan\", \"gong \", \"shan\", \"ai\", \"kou\", \"zhen\", \"qiong\", \"ding\", \"dang\", \"que\", \"weng\", \"qian\", \"feng\", \"jue\", \"zhuan\", \"ceng\", \"zu\", \"bian\", \"nei\", \"sheng\", \"chan\", \"zao\", \"fang\", \"qin\", \"e\", \"lian\", \"fa \", \"lu\", \"sun\", \"xu\", \"deng\", \"guan\", \"shou\", \"mo\", \"zhan\", \"po\", \"pi\", \"gun\", \"shuang\", \"qiang\", \"kao\", \"hong\", \"kan\", \"dian\", \"kong\", \"pei\", \"tong\", \"ting\", \"zang\", \"kuang\", \"reng\", \"ti \", \"pan\", \"heng\", \"chi\", \"lun\", \"kun\", \"han\", \"lei\", \"zuan\", \"man\", \"sen\", \"duan\", \"leng\", \"su i\", \"gai\", \"ga\", \"fou\", \"kuo\", \"ou\", \"suo\", \"sou\", \"nu\", \"du\", \"mian\", \"chou\", \"hen\" , \"kua\", \"shao\", \"rou\", \"xuan\", \"can\", \"sai\", \"dun\", \"niao\", \"chui\", \"chen\", \"hun\", \"peng\", \" fen\", \"cang\", \"gen\", \"shua\", \"chuo\", \"shun\", \"cha\", \"gou\", \"mai\", \"liu\", \"diao\", \"tao\", \"niu\" , \"mi\", \"chai\", \"long\", \"guai\", \"xiong\", \"mou\", \"rong\", \"ku\", \"song\", \"che\", \"sao\", \"piao\", \" pu\", \"tui\", \"lang\", \"chuang\", \"keng\", \"liao\", \"miao\", \"zhui\", \"nai\", \"lou\", \"bin\", \"juan\", \"zhua\" , \"run\", \"zeng\", \"ao\", \"re\", \"pa\", \"qun\", \"lia\", \"cou\", \"tie\", \"zhai\", \"kuan\", \"kui\", \" cui\", \"mie\", \"fei\", \"tiao\", \"nuo\", \"gei\", \"ca\", \"zhun\", \"nie\", \"mang\", \"zhuo\", \"pen\", \"zun\" , \"niang\", \"suan\", \"nao\", \"ruan\", \"qiao\", \"fo\", \"rui\", \"rao\", \"ruo\", \"zei\", \"en\", \"za\", \" diu\", \"nve\", \"sa\", \"nin\", \"shai\", \"nen\", \"ken\", \"chuai\", \"shuan\", \"beng\", \"ne\", \"lve\", \"qia\" , \"jiong\", \"pie\", \"seng\", \"nuan\", \"nang\", \"miu\", \"pou\", \"cen\", \"dia\", \"o\", \"zhuai\", \"yo\", \" dei\", \"n\", \"ei\", \"nou\", \"bia\", \"eng\", \"den\", \"_\"] def get_asr_list(string 'xiao ai fas tong xue'): return [__class__.asr_vocab.index(t) for t in string.split(' ') if t in __class__.asr_vocab] def get_asr_string(listobj [117, 214, 257, 144]): return' '.join([__class__.asr_vocab[t] for t in listobj if t <len(__class__.asr_vocab)]) def unit_test(): print(__class__.get_asr_list('xiao ai')) print(__class__.get_asr_string(__class__.get_asr_list('xiao ai fas tong xue'))) def config(self, sets): self.set([(sets[key], __class__.get_asr_list(key)) for key in sets]) def recognize(self): res self.result() # print(tmp) if res ! None: sets {} for tmp in res: sets[__class__.get_asr_string(tmp[1])] tmp[0] #print(tmp[0], get_asr_string(tmp[1])) return sets return None ``` ### function #### config You can configure the vocabulary list required for speech recognition. The maximum number is no more than 6 notes. If it exceeds, it will be ignored. The parameter is `'xiao ai ya': 0.3` corresponding Chinese pinyin string and the lowest probability of matching (threshold) And note that it does not distinguish between tones, so there is no difference between `you hao ya` and `ni hao ya`, so when designing, pay attention to whether the tone of the vocabulary will form new words. The use case is as follows: ```python t.config({ 'xiao ai ya': 0.3, 'hao de ya': 0.2, 'ni hao ya': 0.3, }) ``` #### recognize The vocabulary configured in the config function will be recognized. The use case is as follows: ```python tmp t.recognize() # print(tmp) if tmp ! None: print(tmp) ``` Return result: ```python { 'xiao ai ya': 0.9, 'xiao ai': 0.2, } ``` It is the same as the parameter in config, only given as the return value. You can see that there are two matching results of `小 爱 duck` and `小 爱`. #### state It is expected that the asr module can be executed within 100ms, it will return the current module status, and the return result can be ignored. The usage is as follows: ```python from machine import Timer def on_timer(timer): #print(\"time up:\",timer) #print(\"param:\",timer.callback_arg()) timer.callback_arg().state() # default: maix dock / maix duino set shift 0 t maix_asr(0x500000, I2S.DEVICE_0, 3, shift 0) # maix bit set shift 1 tim Timer(Timer.TIMER0, Timer.CHANNEL0, mode Timer.MODE_PERIODIC, period 64, callback on_timer, arg t) tim.start() ``` It can be seen that on_timer will execute the timer.callback_arg().state() function in a 64 ms cycle, where timer.callback_arg() is an instance of the maix_asr class. #### run Control module operation (recording). #### stop The control module stops (recording). #### __del__ Actively call the releaseable module, which can be actively collected by gc.collect()."},"/soft/maixpy/en/api_reference/machine_vision/image/image.html":{"title":"image (machine vision)","content":" title: image (machine vision) keywords: maixpy, k210, AIOT, edge computing desc: maixpy image (machine vision) Ported to `openmv`, same function as `openmv` ## Routine ### Routine 1: Find green ```python import sensor import image import lcd import time lcd.init() sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) green_threshold (0, 80, 70, 10, 0, 30) while True: img sensor.snapshot() blobs img.find_blobs([green_threshold]) if blobs: for b in blobs: tmp img.draw_rectangle(b[0:4]) tmp img.draw_cross(b[5], b[6]) c img.get_pixel(b[5], b[6]) lcd.display(img) ``` ### Example 2: Display fps ```python import sensor import image import lcd import time clock time.clock() lcd.init() sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) sensor.skip_frames(30) while True: clock.tick() img sensor.snapshot() fps clock.fps() img.draw_string(2,2, (\"%2.1ffps\" %(fps)), color (0,128,0), scale 2) lcd.display(img) ``` ### Example 3: Scan the QR code ```python import sensor import image import lcd import time clock time.clock() lcd.init() sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.set_vflip(1) sensor.run(1) sensor.skip_frames(30) while True: clock.tick() img sensor.snapshot() res img.find_qrcodes() fps clock.fps() if len(res)> 0: img.draw_string(2,2, res[0].payload(), color (0,128,0), scale 2) print(res[0].payload()) lcd.display(img) ``` > If a lens is used, the picture will be distorted and the picture needs to be corrected > Use the `lens_corr` function to correct, such as `2.8`mm, `img.lens_corr(1.8)` ## Function Function can also press `Ctrl+F` on this page and use the browser's search function to search `image.` to mark the function ### image.rgb_to_lab(rgb_tuple) Return the tuple of RGB888 format rgb_tuple (r, g, b) corresponding to the tuple (l, a, b) of LAB format. > RGB888 means 8 bits each for red, green and blue (0 255). In LAB, the range of L is 0 100, and the range of a/b is 128 to 127. ### image.lab_to_rgb(lab_tuple) Return the tuple in LAB format lab_tuple (l, a, b) and the corresponding tuple (r, g, b) in RGB888 format. > RGB888 means 8 bits each for red, green and blue (0 255). In LAB, the range of L is 0 100, and the range of a/b is 128 to 127. ### image.rgb_to_grayscale(rgb_tuple) Returns the gray value corresponding to the tuple rgb_tuple (r, g, b) in RGB888 format. > RGB888 means 8 bits each for red, green and blue (0 255). The gray value ranges from 0 255. ### image.grayscale_to_rgb(g_value) Returns the tuple (r, g, b) in RGB888 format corresponding to the gray value g_value. > RGB888 means 8 bits each for red, green and blue (0 255). The gray value ranges from 0 255. ### image.load_decriptor(path) Load a descriptor object from the disk. path is the path where the descriptor file is saved. ### image.save_descriptor(path, descriptor) Save the descriptor object descriptor to disk. path is the path where the descriptor file is saved. ### image.match_descriptor(descritor0, descriptor1[, threshold 70[, filter_outliers False]]) For LBP descriptors, this function returns an integer that reflects the difference between the two descriptors. This distance measurement is particularly necessary. This distance is a measure of similarity. The closer this measure is to 0, the better the matching of LBPF feature points. For ORB descriptors, this function returns a kptmatch object. See above. threshold is used to filter ambiguous matching services for ORB keys. A lower threshold value will be closely tied to the key point matching algorithm. The threshold value is between 0 100 (int). The default value is 70. filter_outliers is used to filter outliers for ORB key points. Feature points allow users to increase the threshold value. The default setting is False. ## HaarCascade class feature descriptor Haar Cascade feature descriptors are used in the `image.find_features()` method. It has no methods for users to call. ### Constructor class image.HaarCascade(path[, stages Auto]) Load a Haar Cascade from a Haar Cascade binary file (format suitable for OpenMV Cam). If you pass the \"frontalface\" string instead of a path, this constructor will load a built in frontalface Haar Cascade into memory. In addition, you can also load Haar Cascade into memory through \"eye\". Finally, this method returns the loaded Haar Cascade object, which is used to use image.find_features(). The default value of stages is the number of stages in Haar Cascade. However, you can specify a lower value to speed up the running of the feature detector, which of course will bring a higher false alarm rate. > You can make your own Haar Cascades to work with your OpenMV Cam. First, use Google to search for \"<thing> Haar Cascade\" to check if someone has made an OpenCV Haar Cascade for the object you want to detect. If not, then you need to do it yourself (huge workload). For how to make your own Haar Cascade, see here For how to convert OpenCV Haar Cascades into a mode that your OpenMV Cam can read, see this script Q: What is Haar Cascade? Answer: Haar Cascade is a series of comparative checks to determine whether an object is present in the image. This series of comparative inspections is divided into multiple stages, and the operation of the latter stage is based on the completion of the previous stage. Contrast checking is not complicated, but a process like checking whether the center of the image is slightly more vertical than the edges. Large scale inspections are carried out first in the early stage, and more and smaller areas are inspected in the later stage. Q: How are Haar Cascades made? Answer: Haar Cascades trains the generator algorithm through positive and negative images. For example, use hundreds of pictures containing cats (which have been marked as containing cats) and hundreds of pictures that do not contain cats (which have been marked differently) to train this generation algorithm. This generation algorithm will finally generate a Haar Cascades for detecting cats. ## Similarity Class Similarity Object The similarity object is returned by `image.get_similarity`. ### Constructor class image.similarity Please call the image.get_similarity() function to create this object. #### Method ##### similarity.mean() Returns the mean value of the similarity difference of 8x8 pixel block structure. The range is [ 1/+1], where 1 is completely different and +1 is completely the same. You can also get this value by index [0]. ##### similarity.stdev() Returns the standard deviation of the similarity difference of the 8x8 pixel block structure. You can also get this value via index [1]. ##### similarity.min() Returns the minimum value of the similarity difference of the 8x8 pixel block structure. Where 1 is completely different and +1 is completely the same. You can also get this value via index [2]. > By looking at this value, you can quickly determine whether any 8x8 pixel blocks between the two images are very different, that is, far below +1. ##### similarity.max() Returns the minimum value of the similarity difference of the 8x8 pixel block structure. Where 1 is completely different and +1 is completely the same. You can also get this value through index [3]. > By looking at this value, you can quickly determine whether any 8x8 pixel blocks between the two images are the same. That is much larger than 1. ## Histogram class histogram object The histogram object is returned by `image.get_histogram`. The grayscale histogram has a channel that contains multiple bins. All binaries are normalized so that their sum is 1. RGB565 has three channels containing multiple binary. All binaries are normalized so that their sum is 1. ### Constructor class image.histogram Please call the `image.get_histogram()` function to create this object. ### Method #### histogram.bins() Returns a list of floating point numbers in the gray histogram. You can also get this value by index [0]. #### histogram.l_bins() Returns the list of floating point numbers of the L channel of the RGB565 histogram LAB. You can also get this value by index [0]. #### histogram.a_bins() Returns the list of floating point numbers of the A channel of the RGB565 histogram LAB. You can also get this value via index [1]. #### histogram.b_bins() Returns the list of floating point numbers of channel B of RGB565 histogram LAB. You can also get this value via index [2]. #### histogram.get_percentile(percentile) Calculate the CDF of the histogram channel and return a value of the histogram passed in percentile (0.0 1.0) (floating point number). Therefore, if you pass in 0.1, the method will tell you which binary will make the accumulator cross 0.1 when it is added to the accumulator. This is very effective for determining the minimum value (0.1) and max (0.9) of the color distribution when there is no anomalous utility to spoil your adaptive color tracking results. #### histogram.get_threhsold() Use Otsu’s method to calculate the optimal threshold, dividing each channel of the histogram into two halves. This method returns an image.threshold object. This method is particularly useful for determining the optimal image.binary() threshold. #### histogram.get_statistics() Calculate the average, median, mode, standard deviation, minimum, maximum, lower quartile, and upper quartile of each color channel in the histogram, and return a statistics object. You can also use histogram.statistics() and histogram.get_stats() as aliases for this method. ## Percentile class percentage value object The percentage value object is returned by `histogram.get_percentile`. The gray percentage value has one channel. Do not use l_*, a_* or b_* methods. The RGB565 percentage value has three channels. Use the l_*, a_* and b_* methods. ### Constructor class image.percentile Please call the histogram.get_percentile() function to create this object. ### Method #### percentile.value() Returns the gray percentage value (the value range is 0 255). You can also get this value by index [0]. #### percentile.l_value() Returns the percentage value of the L channel of RGB565 LAB (value range is 0 100). You can also get this value by index [0]. #### percentile.a_value() Returns the percentage value of the A channel of RGB565 LAB (the value range is 128 127). You can also get this value via index [1]. #### percentile.b_value() Returns the percentage value of the B channel of RGB565 LAB (the value range is 128 127). You can also get this value via index [2]. ## Threhsold Class Threshold Object The threshold object is returned by histogram.get_threshold. Grayscale images have one channel. There are no l_*, a_*, and b_* methods. The RGB565 threshold has three channels. Use l_*, a_*, and b_* methods. ### Constructor class image.threshold Please call the histogram.get_threshold() function to create this object. #### Method #### threhsold.value() Returns the threshold of the grayscale image (between 0 and 255). You can also get this value by index [0]. #### threhsold.l_value() Return the L threshold (between 0 and 100) in the RGB565 image LAB. You can also get this value by index [0]. #### threhsold.a_value() Return the A threshold (between 128 and 127) in the RGB565 image LAB. You can also get this value via index [1]. #### threhsold.b_value() Return the B threshold (between 128 and 127) in the RGB565 image LAB. You can also get this value via index [2]. ## class Statistics – Statistical data object The statistical data object is returned by histogram.get_statistics or image.get_statistics. The grayscale statistics have one channel, using methods other than l_*, a_* or b_*. The RGB565 percentage value has three channels. Use the l_*, a_* and b_* methods. ### Constructor class image.statistics Please call histogram.get_statistics() or image.get_statistics() function to create this object. ### Method #### statistics.mean() Returns the average gray value (0 255) (int). You can also get this value by index [0]. #### statistics.median() Returns the median gray value (0 255) (int). You can also get this value via index [1]. #### statistics.mode() Returns the gray mode value (0 255) (int). You can also get this value via index [2]. #### statistics.stdev() Returns the gray standard deviation (0 255) (int). You can also get this value through index [3]. #### statistics.min() Returns the minimum value of gray scale (0 255) (int). You can also get this value via index [4]. #### statistics.max() Returns the maximum gray value (0 255) (int). You can also get this value via index [5]. #### statistics.lq() Returns the quarter value (0 255) (int) in grayscale. You can also get this value via index [6]. #### statistics.uq() Returns the quarter value of the gray scale (0 255) (int). You can also get this value via index [7]. #### statistics.l_mean() Returns the mean value of L (0 255) (int) in RGB5656 LAB. You can also get this value by index [0]. #### statistics.l_median() Returns the median (0 255) (int) of L in RGB5656 LAB. You can also get this value via index [1]. #### statistics.l_mode() Returns the mode (0 255) (int) of L in RGB5656 LAB. You can also get this value via index [2]. #### statistics.l_stdev() Returns the standard deviation value of L in RGB5656 LAB (0 255) (int). You can also get this value through index [3]. #### statistics.l_min() Returns the minimum value of L in RGB5656 LAB (0 255) (int). You can also get this value via index [4]. #### statistics.l_max() Returns the maximum value of L in RGB5656 LAB (0 255) (int). You can also get this value via index [5]. #### statistics.l_lq() Returns the lower quartile of L in RGB5656 LAB (0 255) (int). You can also get this value via index [6]. #### statistics.l_uq() Returns the upper quartile (0 255) (int) of L in RGB5656 LAB. You can also get this value via index [7]. #### statistics.a_mean() Returns the mean value (0 255) (int) of A in RGB5656 LAB. You can also get this value through index [8]. #### statistics.a_median() Returns the median value (0 255) (int) of A in RGB5656 LAB. You can also get this value via index [9]. #### statistics.a_mode() Returns the mode (0 255) (int) of A in RGB5656 LAB. You can also get this value via index [10]. #### statistics.a_stdev() Returns the standard deviation value (0 255) (int) of A in RGB5656 LAB. You can also get this value through the index [11]. #### statistics.a_min() Returns the minimum value of A in RGB5656 LAB (0 255) (int). You can also get this value through the index [12]. #### statistics.a_max() Returns the maximum value of A (0 255) (int) in RGB5656 LAB. You can also get this value through the index [13]. #### statistics.a_lq() Returns the lower quartile (0 255) (int) of A in RGB5656 LAB. You can also get this value through the index [14]. #### statistics.a_uq() Returns the upper quartile (0 255) (int) of A in RGB5656 LAB. You can also get this value via index [15]. #### statistics.b_mean() Returns the mean value of B in RGB5656 LAB (0 255) (int). You can also get this value via index [16]. #### statistics.b_median() Returns the median (0 255) (int) of B in RGB5656 LAB. You can also get this value via index [17]. #### statistics.b_mode() Returns the mode (0 255) (int) of B in RGB5656 LAB. You can also get this value through the index [18]. #### statistics.b_stdev() Returns the standard deviation of B in RGB5656 LAB (0 255) (int). You can also get this value through index [19]. #### statistics.b_min() Returns the minimum value (0 255) (int) of B in RGB5656 LAB. You can also get this value via index [20]. #### statistics.b_max() Returns the maximum value of B in RGB5656 LAB (0 255) (int). You can also get this value through the index [21]. #### statistics.b_lq() Returns the lower quartile of B in RGB5656 LAB (0 255) (int). You can also get this value through the index [22]. #### statistics.b_uq() Returns the upper quartile (0 255) (int) of B in RGB5656 LAB. You can also get this value through the index [23]. ## Blob class color block object The color block object is returned by `image.find_blobs`. ### Constructor class image.blob Please call the image.find_blobs() function to create this object. ### Method #### blob.rect() Returns a rectangular tuple (x, y, w, h), which is used in other image methods such as image.draw_rectangle of the color block bounding box. #### blob.x() Returns the x coordinate (int) of the bounding box of the color patch. You can also get this value by index [0]. #### blob.y() Returns the y coordinate (int) of the bounding box of the color patch. You can also get this value via index [1]. #### blob.w() Returns the w coordinate (int) of the bounding box of the color patch. You can also get this value via index [2]. #### blob.h() Returns the h coordinate (int) of the bounding box of the color patch. You can also get this value through index [3]. #### blob.pixels() Returns the number of pixels that are part of the color block (int). You can also get this value via index [4]. #### blob.cx() Returns the center x position of the color block (int). You can also get this value via index [5]. #### blob.cy() Returns the center x position of the color block (int). You can also get this value via index [6]. #### blob.rotation() Returns the rotation of the color block (unit: radians). If the color block resembles a pencil or pen, then this value is the only value between 0 180. If the color block is round, then this value has no effect. If this color block has no symmetry at all, you can only get a 0 360 degree rotation. You can also get this value via index [7]. #### blob.code() Returns a 16 bit binary number, where one bit is set for each color threshold, which is part of the color block. For example, if you use image.find_blobs to find three color thresholds, this color block can be set to 0/1/2 bits. Note: Unless you call image.find_blobs with merge True, you can only set one bit per color block. Then multiple color blocks with different color thresholds can be merged together. You can also use this method and multiple thresholds to implement color code tracking. You can also get this value through index [8]. #### blob.count() Returns the number of multiple color blocks merged into this color block. Only when you call image.find_blobs with merge True, this number is not 1. You can also get this value via index [9]. #### blob.area() Return the border area around the color block (w * h) #### blob.density() Returns the density ratio of this color patch. This is the number of pixels in the bounding box area of ​​the color block. In general, a lower density ratio means that the object is not locked well. ## Line class line object The line object is returned by `image.find_lines`, `image.find_line_segments` or `image.get_regression`. ### Constructor class image.line Please call image.find_lines(), image.find_line_segments(), or image.get_regression() function to create this object. ### Method #### line.line() Return a straight line tuple (x1, y1, x2, y2) for use in other image methods such as image.draw_line. #### line.x1() Returns the x coordinate component of the p1 vertex of the line. You can also get this value by index [0]. #### line.y1() Returns the p1 y component of the line. You can also get this value via index [1]. #### line.x2() Returns the p2 x component of the line. You can also get this value via index [2]. #### line.y2() Returns the p2 y component of the line. You can also get this value through index [3]. #### line.length() The length of the return line is sqrt(((x2 x1)^2) + ((y2 y1)^2). You can also get this value via index [4]. #### line.magnitude() Returns the length of the straight line after Hough transformation. You can also get this value via index [5]. #### line.theta() Returns the angle of the straight line after Hough transformation (0 179 degrees). You can also get this value via index [7]. #### line.rho() Returns the p value of the straight line after Hough transform. You can also get this value through index [8]. ## Circle class round object The circular object is returned by `image.find_circles`. ### Constructor class image.circle Please call the image.find_circles() function to create this object. ### Method #### circle.x() Returns the x position of the circle. You can also get this value by index [0]. #### circle.y() Returns the y position of the circle. You can also get this value via index [1]. #### circle.r() Returns the radius of the circle. You can also get this value via index [2]. #### circle.magnitude() Returns the size of the circle. You can also get this value through index [3]. ## Rect Class Rectangle Object The rectangle object is returned by `image.find_rects`. ### Constructor class image.rect Please call the image.find_rects() function to create this object. ### Method #### rect.corners() Returns a list of four tuples (x, y) consisting of the four corners of the rectangular object. The four corners are usually returned in clockwise order starting from the upper left corner. #### rect.rect() Returns a rectangle tuple (x, y, w, h), used in other image methods such as image.draw_rectangle of the bounding box of the rectangle. #### rect.x() Returns the x position of the upper left corner of the rectangle. You can also get this value by index [0]. #### rect.y() Returns the y position of the upper left corner of the rectangle. You can also get this value via index [1]. #### rect.w() Returns the width of the rectangle. You can also get this value via index [2]. #### rect.h() Returns the height of the rectangle. You can also get this value through index [3]. #### rect.magnitude() Returns the size of the rectangle. You can also get this value via index [4]. ## QRCode class QR code object The QR code object is returned by `image.find_qrcodes`. ### Constructor class image.qrcode Please call the image.find_qrcodes() function to create this object. ### Method #### qrcode.corners() Returns a list of four tuples (x, y) consisting of the four corners of the object. The four corners are usually returned in clockwise order starting from the upper left corner. #### qrcode.rect() Returns a rectangular tuple (x, y, w, h), used in other image methods such as image.draw_rectangle of the bounding box of the QR code. #### qrcode.x() Returns the x coordinate (int) of the bounding box of the QR code. You can also get this value by index [0]. #### qrcode.y() Returns the y coordinate (int) of the bounding box of the QR code. You can also get this value via index [1]. #### qrcode.w() Returns the w coordinate (int) of the bounding box of the QR code. You can also get this value via index [2]. #### qrcode.h() Returns the h coordinate (int) of the bounding box of the QR code. You can also get this value through index [3]. #### qrcode.payload() Returns the string of the QR code payload, such as URL. You can also get this value via index [4]. #### qrcode.version() Returns the version number (int) of the QR code. You can also get this value via index [5]. #### qrcode.ecc_level() Returns the ECC level of the QR code (int). You can also get this value via index [6]. #### qrcode.mask() Returns the mask (int) of the QR code. You can also get this value via index [7]. #### qrcode.data_type() Returns the data type of the QR code. You can also get this value through index [8]. #### qrcode.eci() Returns the ECI of the QR code. ECI stores the code of the data bytes stored in the QR code. If you want to process a QR code that contains more than standard ASCII text, you need to check this value. You can also get this value via index [9]. #### qrcode.is_numeric() If the data type of the QR code is digital, it returns True. #### qrcode.is_alphanumeric() If the data type of the QR code is alphanumeric, it returns True. #### qrcode.is_binary() If the data type of the QR code is binary, it returns True. If you are serious about handling all types of text, you need to check whether eci is True to determine the text encoding of the data. Usually it is just standard ASCII, but it may also be UTF8 with two byte characters. #### qrcode.is_kanji() If the data type of the QR code is Kanji, it returns True. After setting it to True, you need to decode the string yourself, because each character of the Kanji is 10 digits, and MicroPython does not support parsing this type of text. ## AprilTag Class – AprilTag Object The AprilTag object is returned by `image.find_apriltags`. ### Constructor class image.apriltag Please call the image.find_apriltags() function to create this object. ### Method #### apriltag.corners() Returns a list of four tuples (x, y) consisting of the four corners of the object. The four corners are usually returned in clockwise order starting from the upper left corner. #### apriltag.rect() Return a rectangular tuple (x, y, w, h), used in other image methods such as image.draw_rectangle of AprilTag bounding box. #### apriltag.x() Returns the x coordinate (int) of the AprilTag bounding box. You can also get this value by index [0]. #### apriltag.y() Returns the y coordinate (int) of the bounding box of AprilTag. You can also get this value via index [1]. #### apriltag.w() Returns the w coordinate (int) of the bounding box of AprilTag. You can also get this value via index [2]. #### apriltag.h() Returns the h coordinate (int) of the bounding box of AprilTag. You can also get this value through index [3]. #### apriltag.id() Returns the numeric ID of AprilTag. TAG16H5 > 0 to 29 TAG25H7 > 0 to 241 TAG25H9 > 0 to 34 TAG36H10 > 0 to 2319 TAG36H11 > 0 to 586 ARTOOLKIT > 0 to 511 You can also get this value via index [4]. #### apriltag.family() Return to AprilTag's digital home. image.TAG16H5 image.TAG25H7 image.TAG25H9 image.TAG36H10 image.TAG36H11 image.ARTOOLKIT You can also get this value via index [5]. #### apriltag.cx() Returns the center x position (int) of AprilTag. You can also get this value via index [6]. #### apriltag.cy() Returns the center y position (int) of AprilTag. You can also get this value via index [7]. #### apriltag.rotation() Returns the curl of AprilTag in radians (int). You can also get this value through index [8]. #### apriltag.decision_margin() Return the color saturation of AprilTag matching (value 0.0 1.0), where 1.0 is the best. You can also get this value via index [9]. #### apriltag.hamming() Returns the acceptable digital error value of AprilTag. TAG16H5 > can accept up to 0 bit errors TAG25H7 > can accept up to 1 bit error TAG25H9 > Accept up to 3 errors TAG36H10 > can accept up to 3 errors TAG36H11 > can accept up to 4 errors ARTOOLKIT > can accept up to 0 errors You can also get this value via index [10]. #### apriltag.goodness() Returns the color saturation of the AprilTag image (value 0.0 1.0), where 1.0 is the best. > Currently this value is usually 0.0. In the future, we can enable a function called \"tag refinement\" to realize the detection of smaller AprilTags. However, this feature now reduces the frame rate below 1 FPS. You can also get this value through the index [11]. #### apriltag.x_translation() Returns the transformation in the x direction from the camera. The unit of the distance is unknown. This method is useful for determining the position of AprilTag far away from the camera. However, factors such as the size of AprilTag and the lens you use will affect the determination of the attribution of the X unit. For ease of use, we recommend that you use a lookup table to convert the output of this method into useful information for your application. Note: The direction here is from left to right. You can also get this value through the index [12]. #### apriltag.y_translation() Returns the transformation in the y direction from the camera. The unit of the distance is unknown. This method is useful for determining the position of AprilTag far away from the camera. However, the size of the AprilTag and the lens you use will affect the determination of the Y unit. For ease of use, we recommend that you use a lookup table to convert the output of this method into useful information for your application. Note: The direction here is from top to bottom. You can also get this value through the index [13]. #### apriltag.z_translation() Returns the transformation in the z direction from the camera. The unit of the distance is unknown. This method is useful for determining the position of AprilTag far away from the camera. However, the size of the AprilTag and the lens you use will affect the determination of the Z unit. For ease of use, we recommend that you use a lookup table to convert the output of this method into useful information for your application. Note: The direction here is from front to back. You can also get this value through the index [14]. #### apriltag.x_rotation() Returns the rotation of AprilTag on the X plane in radians. Example: Looking at AprilTag, move the camera from left to right. You can also get this value via index [15]. #### apriltag.y_rotation() Returns the rotation of AprilTag in radians on the Y plane. Example: Visually observe AprilTag and move the camera from top to bottom. You can also get this value via index [16]. #### apriltag.z_rotation() Returns the rotation of the AprilTag in radians on the Z plane. Example: Look at AprilTag and rotate the camera. Note: This is just a renamed version of apriltag.rotation(). You can also get this value via index [17]. ## DataMatrix Class Data Matrix Object The data matrix object is returned by `image.find_datamatrices`. ## Constructor class image.datamatrix Please call the image.find_datamatrices() function to create this object. ### Method #### datamatrix.corners() Returns a list of four tuples (x, y) consisting of the four corners of the object. The four corners are usually returned in clockwise order starting from the upper left corner. #### datamatrix.rect() Return a rectangular tuple (x, y, w, h), used in other image methods such as image.draw_rectangle of the bounding box of the data matrix. #### datamatrix.x() Returns the x coordinate (int) of the bounding box of the data matrix. You can also get this value by index [0]. #### datamatrix.y() Returns the y coordinate (int) of the bounding box of the data matrix. You can also get this value via index [1]. #### datamatrix.w() Returns the w width of the bounding box of the data matrix. You can also get this value via index [2]. #### datamatrix.h() Returns the h height of the bounding box of the data matrix. You can also get this value through index [3]. #### datamatrix.payload() Returns the string of the payload of the data matrix. Example: string. You can also get this value via index [4]. #### datamatrix.rotation() Returns the curl (floating point number) of the data matrix in radians. You can also get this value via index [5]. #### datamatrix.rows() Returns the number of rows of the data matrix (int). You can also get this value via index [6]. #### datamatrix.columns() Returns the number of columns of the data matrix (int). You can also get this value via index [7]. #### datamatrix.capacity() Returns the number of characters that this data matrix can hold. You can also get this value through index [8]. #### datamatrix.padding() Returns the number of unused characters in this data matrix. You can also get this value via index [9]. ## BarCode Class Barcode Object The barcode object is returned by image.find_barcodes. ## Constructor class image.barcode Please call the image.find_barcodes() function to create this object. ### Method #### barcode.corners() Returns a list of four tuples (x, y) consisting of the four corners of the object. The four corners are usually returned in clockwise order starting from the upper left corner. #### barcode.rect() Return a rectangular tuple (x, y, w, h), used in other image methods such as image.draw_rectangle of the bounding box of the data matrix. #### barcode.x() Returns the x coordinate (int) of the bounding box of the barcode. You can also get this value by index [0]. #### barcode.y() Returns the y coordinate (int) of the bounding box of the barcode. You can also get this value via index [1]. #### barcode.w() Returns the w width (int) of the bounding box of the barcode. You can also get this value via index [2]. #### barcode.h() Returns the h height (int) of the bounding box of the barcode. You can also get this value through index [3]. #### barcode.payload() Returns the string of the payload of the barcode. Example: Quantity. You can also get this value via index [4]. #### barcode.type() Returns the enumeration type (int) of the barcode. You can also get this value via index [5]. image.EAN2 image.EAN5 image.EAN8 image.UPCE image.ISBN10 image.UPCA image.EAN13 image.ISBN13 image.I25 image.DATABAR image.DATABAR_EXP image.CODABAR image.CODE39 image.PDF417 To be enabled in the future (e.g. not yet available for normal use). image.CODE93 image.CODE128 #### barcode.rotation() Returns the curl (floating point number) of the barcode in radians. You can also get this value via index [6]. #### barcode.quality() Returns the number of times the barcode was detected in the image (int). When scanning a barcode, each new scan line can decode the same barcode. Each time this process is performed, the value of the barcode will increase accordingly. You can also get this value via index [7]. ## Displacement class displacement object The displacement object is returned by image.find_displacement. ### Constructor class image.displacement Please call the image.find_displacement() function to create this object. ### Method #### displacement.x_translation() Returns the x translation pixel between two images. This is a precise sub pixel, so it is a floating point number. You can also get this value by index [0]. #### displacement.y_translation() Returns the y translation pixel between two images. This is a precise sub pixel, so it is a floating point number. You can also get this value via index [1]. #### displacement.rotation() Returns the z shift pixel between two images. This is a precise sub pixel, so it is a floating point number. You can also get this value via index [2]. #### displacement.scale() Returns the arc of rotation between two images. You can also get this value through index [3]. #### displacement.response() Returns the quality of the result of displacement matching between two images. Range 0 1. Displacement objects with a response less than 0.1 may be noise. You can also get this value via index [4]. ## Kptmatch class – feature point object The feature point object is returned by `image.match_descriptor`. ### Constructor class image.kptmatch Please call the image.match_descriptor() function to create this object. ### Method #### kptmatch.rect() Return a rectangular tuple (x, y, w, h), used in other image methods such as image.draw_rectangle of the bounding box of the feature point. #### kptmatch.cx() Returns the center x position of the feature point (int). You can also get this value by index [0]. #### kptmatch.cy() Returns the center y position (int) of the feature point. You can also get this value via index [1]. #### kptmatch.x() Returns the x coordinate (int) of the bounding box of the feature point. You can also get this value via index [2]. #### kptmatch.y() Returns the y coordinate (int) of the bounding box of the feature point. You can also get this value through index [3]. #### kptmatch.w() Returns the w width (int) of the bounding box of the feature point. You can also get this value via index [4]. #### kptmatch.h() Returns the h height (int) of the bounding box of the feature point. You can also get this value via index [5]. #### kptmatch.count() Returns the number of matched feature points (int). You can also get this value via index [6]. #### kptmatch.theta() Returns the curl of the estimated feature point (int). You can also get this value via index [7]. #### kptmatch.match() Returns a list of (x, y) tuples matching key points. You can also get this value through index [8]. ## ImageWriter class ImageWriter object The ImageWriter object allows you to quickly write uncompressed images to disk. ### Constructor class image.ImageWriter(path) By creating an ImageWriter object, you can write uncompressed images to disk in the simple file format used for OpenMV Cams. Then the uncompressed image can be re read using ImageReader. ### Method #### imagewriter.size() Returns the size of the file being written. #### imagewriter.add_frame(img) Write an image to disk. Because the image is not compressed, it executes quickly, but it takes up a lot of disk space. #### imagewriter.close() Close the image stream file. You must close the file or the file will be damaged. ## ImageReader class – ImageReader object The ImageReader object allows you to quickly read uncompressed images from disk. ### Constructor class image.ImageReader(path) Create an ImageReader object to play back the image data written by the ImageWriter object. The frames played back by the ImageWriter object will be played back at the same FPS as when they were written to disk. ### Method #### imagereader.size() Returns the size of the file being read. imagereader.next_frame([copy_to_fb True, loop True]) Return the image object from the file written by ImageWriter. If copy_to_fb is True, the image object will be directly loaded into the frame buffer. Otherwise, the image object will be put into the heap. Note: Unless the image is small, the heap may not have enough space to store the image object. If loop is True, playback will restart after the last image of the stream is read. Otherwise, this method will return None after all frames have been read. Note: imagereader.next_frame tries to limit the playback speed by pausing the playback after reading the frame to match the frame recording speed. Otherwise, this method will quickly read and play all images at a speed of 200+FPS. #### imagereader.close() Close the file being read. You need to do this to prevent damage to the imagereader object. But because it is a read only file, the file will not be damaged when it is not closed. ## Image class image objects Image objects are the basic objects of machine vision operations. ### Constructor class image.Image(path[, copy_to_fb False]) Create a new image object from the file in path. Support image files in bmp/pgm/ppm/jpg/jpeg format. If copy_to_fb is True, the image will be directly loaded into the frame buffer, and you can load a large image. If False, the image will be loaded into the MicroPython heap, which is much smaller than the frame buffer. In OpenMV Cam M4, if copy_to_fb is False, you should try to keep the image size below 8KB. If True, the image can be up to 160KB. In OpenMV Cam M7, if copy_to_fb is False, you should try to keep the image size below 16KB. If True, the maximum image size can be 320KB. The image supports the \"[]\" notation. Let image[index] 8/16 bit value to allocate image pixels or image[index] and get an image pixel. If it is a 16 bit RGB565 grayscale image for RGB image, this pixel is 8 Bit. For JPEG images, \"[]\" allows you to access JPEG image color patches in the form of a compressed section array. Since the JPEG image is a compressed byte stream, the reading and writing of the data group is opaque. The image also supports read buffer operation. You can treat the image as a section array object and input the image into all types of MicroPython functions. If you want to transmit an image, you can pass it to the UART/SPI/I2C write function, which can realize automatic transmission. ### Method #### image.width() Returns the width of the image in pixels. #### image.height() Returns the height of the image in pixels. #### image.format() Return sensor.GRAYSCALE for grayscale images, sensor.RGB565 for RGB images, and sensor.JPEG for JPEG images. #### image.size() Returns the size of the image in bytes. #### image.get_pixel(x, y[, rgbtuple]) Grayscale image: returns the grayscale pixel value at (x, y) position. RGB565l: Returns the RGB888 pixel tuple (r, g, b) at position (x, y). Bayer image: Returns the pixel value at position (x, y). Does not support compressed images. > image.get_pixel() and `image.set_pixel()` are the only methods that allow you to manipulate Bayer mode images. The Bayer mode image is a text image. For even rows, the pixels in the image are R/G/R/G/ etc. For odd lines, the pixels in the image are G/B/G/B/ etc. Each pixel is 8 bits. #### image.set_pixel(x, y, pixel) Grayscale image: Set the pixel at position (x, y) to the grayscale value pixel. RGB image: Set the pixel at position (x, y) to RGB888 tuple (r, g, b) pixel. Does not support compressed images. > image.get_pixel() and `image.set_pixel()` are the only methods that allow you to manipulate Bayer mode images. The Bayer mode image is a text image. For even rows, the pixels in the image are R/G/R/G/ etc. For odd lines, the pixels in the image are G/B/G/B/ etc. Each pixel is 8 bits. #### image.mean_pool(x_div, y_div) Find the average value of x_div * y_div squares in the image and return the modified image composed of the average value of each square. This method allows you to quickly shrink the image on the original image. Does not support compressed images and bayer images. #### image.mean_pooled(x_div, y_div) Find the average value of x_div * y_div squares in the image and return a new image composed of the average value of each square. This method allows you to create a reduced image copy. Does not support compressed images and bayer images. #### image.midpoint_pool(x_div, y_div[, bias 0.5]) Find the midpoint value of the x_div * y_div square in the image, and return the modified image composed of the midpoint value of each square. A bias of 0.0 returns the minimum value of each region, and a ``bias'' of 1.0 returns the maximum value of each region. This method allows you to quickly shrink the image on the original image. Does not support compressed images and bayer images. #### image.midpoint_pooled(x_div, y_div[, bias 0.5]) Find the midpoint value of the x_div * y_div squares in the image, and return a new image composed of the midpoint value of each square. A bias of 0.0 returns the minimum value of each region, and a ``bias'' of 1.0 returns the maximum value of each region. This method allows you to create a reduced image copy. Does not support compressed images and bayer images. #### image.to_grayscale([copy False]) Convert the image to a grayscale image. This method will also modify the basic image pixels and change the image size in bytes, so it can only be performed on grayscale images or RGB565 images. Otherwise, copy must be True to create a new modified image on the heap. Return the image object so that you can call another method using. Notation. Does not support compressed images and bayer images. #### image.to_rgb565([copy False]) Convert the image to a color image. This method will also modify the base image pixels and change the image size in bytes, so it can only be performed on RGB565 images. Otherwise, copy must be True to create a new modified image on the heap. Return the image object so that you can call another method using. Notation. Does not support compressed images and bayer images. #### image.to_rainbow([copy False]) Convert the image to a rainbow image. This method will also modify the base image pixels and change the image size in bytes, so it can only be performed on RGB565 images. Otherwise, copy must be True to create a new modified image on the heap. The rainbow image is a color image, and has a unique color value for each 8 bit mask gray scale illumination value in the image. For example, it provides heat map colors for thermal images. Return the image object so that you can call another method using. Notation. Does not support compressed images and bayer images. #### image.compress([quality 50]) JPEG compresses the image appropriately. Compared with compressed save heap space, using this method uses a higher quality compression ratio at the cost of destroying the original image. quality is the compression quality (0 100) (int). #### image.compress_for_ide([quality 50]) JPEG compresses the image appropriately. Compared with compressed save heap space, using this method uses a higher quality compression ratio at the cost of destroying the original image. This method compresses the image, and then formats the JPEG data by encoding every 6 bits into bytes between 128 191, and converts it to OpenMV IDE for display. This step is done to prevent the JPEG data from being mistaken for other text data in the byte stream. You need to use this method to format the image data for display in the terminal window created by \"Open Terminal\" in OpenMV IDE. quality is the compression quality (0 100) (int). #### image.compressed([quality 50]) Return a JPEG compressed image—the original image is unprocessed. However, this method requires a large allocation of heap space, so image compression quality and image resolution must be very low. quality is the compression quality (0 100) (int). #### image.compressed_for_ide([quality 50]) Return a JPEG compressed image—the original image is unprocessed. However, this method requires a large allocation of heap space, so image compression quality and image resolution must be very low. This method compresses the image, and then formats the JPEG data by encoding every 6 bits into bytes between 128 191, and converts it to OpenMV IDE for display. This step is done to prevent the JPEG data from being mistaken for other text data in the byte stream. You need to use this method to format the image data for display in the terminal window created by \"Open Terminal\" in OpenMV IDE. quality is the compression quality (0 100) (int). #### image.copy([roi[, copy_to_fb False]]) Create a copy of the image object. Roi is a rectangular region of interest (x, y, w, h) to be copied. If not specified, the ROI will copy the entire image rectangle. But this does not apply to JPEG images. Remember that the image copy is stored in the MicroPython heap, not the frame buffer. Similarly, you need to control the image copy size below 8KB (OpenMV) or below 16KB (OpenMV Cam M7). If you want to use one copy operation to use all the heap space, this function will be abnormal. An image that is too large can easily trigger abnormalities. If copy_to_fb is True, this method replaces the frame buffer with an image. The frame buffer has much larger space than the heap and can hold large images. #### image.save(path[, roi[, quality 50]]) Save a copy of the image to the file system in path. Support image files in bmp/pgm/ppm/jpg/jpeg format. Note: You cannot save compressed images in jpeg format into uncompressed format. roi is a rectangular region of interest (x, y, w, h) to be copied. If not specified, the ROI will copy the entire image rectangle. But this does not apply to JPEG images. quality refers to the JPEG compression quality that saves the image as JPEG format when the image has not been compressed. #### image.clear() Set all pixels in the image to zero (very fast). Return the image object so that you can call another method using. Notation. Does not support compressed images. #### image.draw_line(x0, y0, x1, y1[, color[, thickness 1]]) Draw a line from (x0, y0) to (x1, y1) on the image. You can pass x0, y0, x1, y1 individually, or to tuples (x0, y0, x1, y1). color is an RGB888 tuple for grayscale or RGB565 images. The default is white. However, you can also pass the basic pixel value (0 255) of the grayscale image or the byte inverted RGB565 value of the RGB565 image. thickness Controls the thickness of the line in pixels. Return the image object so that you can call another method using. Notation. Does not support compressed images and bayer images. #### image.draw_rectangle(x, y, w, h[, color[, thickness 1[, fill False]]]) Draw a rectangle on the image. You can pass x, y, w, h individually or as a tuple (x, y, w, h). color is an RGB888 tuple for grayscale or RGB565 images. The default is white. However, you can also pass the basic pixel value (0 255) of the grayscale image or the byte inverted RGB565 value of the RGB565 image. thickness Controls the thickness of the line in pixels. Set fill to True to fill the rectangle. Return the image object so that you can call another method using. Notation. Does not support compressed images and bayer images. #### image.draw_ellipse(cx, cy, rx, ry, rotation[, color[, thickness 1[, fill False]]]) Draws an ellipse on the image. You may either pass cx, cy, rx, ry, and the rotation (in degrees) separately or as a tuple (cx, yc, rx, ry, rotation). color is an RGB888 tuple for Grayscale or RGB565 images. Defaults to white. However, you may also pass the underlying pixel value (0 255) for grayscale images or a RGB565 value for RGB565 images. thickness controls how thick the edges are in pixels. Pass fill set to True to fill the ellipse. Returns the image object so you can call another method using . notation. Not supported on compressed images or bayer images. #### image.draw_circle(x, y, radius[, color[, thickness 1[, fill False]]]) Draw a circle on the image. You can pass x, y, radius individually or as a tuple (x, y, radius). color is an RGB888 tuple for grayscale or RGB565 images. The default is white. However, you can also pass the basic pixel value (0 255) of the grayscale image or the byte inverted RGB565 value of the RGB565 image. thickness Controls the thickness of the line in pixels. Set fill to True to fill the circle. Return the image object so that you can call another method using. Notation. Does not support compressed images and bayer images. #### image.draw_string(x, y, text[, color[, scale 1[, x_spacing 0[, y_spacing 0[, mono_space True]]]]]) Draw 8x10 text from the position (x, y) in the image. You can pass x, y individually or as a tuple (x, y). text is the character string written into the image. The \\n, \\r, and \\r\\n end characters move the cursor to the next line. color is an RGB888 tuple for grayscale or RGB565 images. The default is white. However, you can also pass the basic pixel value (0 255) of the grayscale image or the byte inverted RGB565 value of the RGB565 image. You can increase the scale to increase the size of the text on the image. Only integer values ​​(for example, 1/2/3/etc). x_spacing allows you to add (if positive) or subtract (if negative) x pixels between characters to set the character spacing. y_spacing allows you to add (if it is a positive number) or subtract (if it is a negative number) y pixels between characters to set line spacing. mono_space defaults to True, which forces the text spacing to be fixed. For large text, this looks terrible. Set False to get non fixed width character spacing, which looks much better. Return the image object so that you can call another method using. Notation. Does not support compressed images and bayer images. #### image.draw_cross(x, y[, color[, size 5[, thickness 1]]]) Draw a cross on the image. You can pass x, y individually or as a tuple (x, y). color is an RGB888 tuple for grayscale or RGB565 images. The default is white. However, you can also pass the basic pixel value (0 255) of the grayscale image or the byte inverted RGB565 value of the RGB565 image. size controls the extension length of the crosshairs. thickness controls the pixel thickness of the edge. Return the image object so that you can call another method using. Notation. Does not support compressed images and bayer images. #### image.draw_arrow(x0, y0, x1, y1[, color[, thickness 1]]) Draw an arrow from (x0, y0) to (x1, y1) on the image. You can pass x0, y0, x1, y1 individually, or to tuples (x0, y0, x1, y1). color is an RGB888 tuple for grayscale or RGB565 images. The default is white. However, you can also pass the basic pixel value (0 255) of the grayscale image or the byte inverted RGB565 value of the RGB565 image. thickness Controls the thickness of the line in pixels. Return the image object so that you can call another method using. Notation. Does not support compressed images and bayer images. #### image.draw_image(image, x, y[, x_scale 1.0[, y_scale 1.0[, mask None[, alpha 256]]]]) Draw an image whose upper left corner starts at position x, y. You can pass x, y individually or to a tuple (x, y). x_scale controls the scale of the image in the x direction (floating point number). y_scale controls the scale of the image in the y direction (floating point number). mask is another image used as a pixel level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. You can use the mask mask for drawing operations. Alpha controls the transparency of the source image drawn into the target image. 256 is to draw an opaque source image, and a value less than 256 produces a blend between the source image and the target image. 0 means not to modify the target image. Does not support compressed images and bayer images. #### image.draw_keypoints(keypoints[, color[, size 10[, thickness 1[, fill False]]]]) Draw each point of a feature point object on the image. color is an RGB888 tuple for grayscale or RGB565 images. The default is white. However, you can also pass the basic pixel value (0 255) of the grayscale image or the byte inverted RGB565 value of the RGB565 image. size controls the size of feature points. thickness Controls the thickness of the line in pixels. Set fill to True to fill the feature points. Return the image object so that you can call another method using. Notation. Does not support compressed images and bayer images. #### image.flood_fill(x, y[, seed_threshold 0.05[, floating_threshold 0.05[, color[, invert False[, clear_background False[, mask None]]]]]]]) Fill the area of ​​the image from position x, y. You can pass x, y individually or to a tuple (x, y). seed_threshold controls the difference between the pixels in the filled area and the original starting pixels. floating_threshold controls the difference between the pixels in the filled area and any adjacent pixels. color is an RGB888 tuple for grayscale or RGB565 images. The default is white. However, you can also pass the basic pixel value (0 255) of the grayscale image or the byte inverted RGB565 value of the RGB565 image. Pass invert as True to refill all content outside the flood_fill connection area. Pass clear_background as True, and reset the remaining flood_fill pixels that have not been recolored. mask is another image used as a pixel level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask will be evaluated during flood_fill. Return the image object so that you can call another method using. Notation. Does not support compressed images and bayer images. This method is not available on OpenMV Cam M4. #### image.binary(thresholds[, invert False[, zero False[, mask None]]]) Set all pixels in the image to black or white according to whether the pixel is within the threshold in the threshold list thresholds. thresholds must be a list of tuples. [(lo, hi), (lo, hi), ..., (lo, hi)] Define the color range you want to track. For grayscale images, each tuple needs to contain two values the minimum gray value and the maximum gray value. Only the areas of pixels that fall between these thresholds are considered. For an RGB565 image, each tuple needs to have six values ​​(l_lo, l_hi, a_lo, a_hi, b_lo, b_hi) the minimum and maximum values ​​of LAB L, A and B channels, respectively. For ease of use, this function will automatically repair the minimum and maximum values ​​of exchange. In addition, if the tuple is greater than six values, the remaining values ​​are ignored. Conversely, if the tuple is too short, it is assumed that the remaining thresholds are in the maximum range. annotation To obtain the threshold of the tracked object, simply select (click and drag) the tracked object in the IDE frame buffer. The histogram will be updated accordingly to the area. Then just write down the starting and falling positions of the color distribution in each histogram channel. These will be the low and high values ​​of thresholds. Since the difference between the upper and lower quartiles is small, it is better to manually determine the threshold. You can also determine the color threshold by entering Tools > Machine Vision > Threshold Editor in OpenMV IDE and dragging the slider from the GUI window. invert Inversion threshold operation, pixels are matched outside the known color range instead of in the known color range. Set zero to True to make the threshold pixels zero and keep the pixels not in the threshold list unchanged. mask is another image used as a pixel level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Return the image object so that you can call another method using. Notation. Does not support compressed images and bayer images. #### image.invert() Change the binary image 0 (black) to 1 (white) and 1 (white) to 0 (black), flipping all the pixel values ​​in the binary image very quickly. Return the image object so that you can call another method using. Notation. Does not support compressed images and Bayer images. #### image.b_and(image[, mask None]) Use another image to perform a logical AND operation with this image. image can be an image object, the path of an uncompressed image file (bmp/pgm/ppm), or a scalar value. If a scalar value, the value can be an RGB888 tuple or a basic pixel value (for example, 8 bit grayscale of a grayscale image or byte reversed RGB565 value of an RGB image). mask is another image used as a pixel level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Return the image object so that you can call another method using. Notation. Does not support compressed images and bayer images. #### image.b_nand(image[, mask None]) Use another image to perform logical AND operation with this image. image can be an image object, the path of an uncompressed image file (bmp/pgm/ppm), or a scalar value. If a scalar value, the value can be an RGB888 tuple or a basic pixel value (for example, 8 bit grayscale of a grayscale image or byte reversed RGB565 value of an RGB image). mask is another image used as a pixel level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Return the image object so that you can call another method using. Notation. Does not support compressed images and bayer images. #### image.b_or(image[, mask None]) Use another image to perform a logical OR operation with this image. image can be an image object, the path of an uncompressed image file (bmp/pgm/ppm), or a scalar value. If a scalar value, the value can be an RGB888 tuple or a basic pixel value (for example, 8 bit grayscale of a grayscale image or byte reversed RGB565 value of an RGB image). mask is another image used as a pixel level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Return the image object so that you can call another method using. Notation. Does not support compressed images and bayer images. #### image.b_nor(image[, mask None]) Use another image to perform logical NOR operation with this image. image can be an image object, the path of an uncompressed image file (bmp/pgm/ppm), or a scalar value. If a scalar value, the value can be an RGB888 tuple or a basic pixel value (for example, 8 bit grayscale of a grayscale image or byte reversed RGB565 value of an RGB image). mask is another image used as a pixel level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Return the image object so that you can call another method using. Notation. Does not support compressed images and bayer images. #### image.b_xor(image[, mask None]) Use another image to perform a logical XOR operation with this image. image can be an image object, the path of an uncompressed image file (bmp/pgm/ppm), or a scalar value. If a scalar value, the value can be an RGB888 tuple or a basic pixel value (for example, 8 bit grayscale of a grayscale image or byte reversed RGB565 value of an RGB image). mask is another image used as a pixel level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Return the image object so that you can call another method using. Notation. Does not support compressed images and bayer images. #### image.b_xnor(image[, mask None]) Use another image to perform logical XOR operation with this image. image can be an image object, the path of an uncompressed image file (bmp/pgm/ppm), or a scalar value. If a scalar value, the value can be an RGB888 tuple or a basic pixel value (for example, 8 bit grayscale of a grayscale image or byte reversed RGB565 value of an RGB image). mask is another image used as a pixel level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Return the image object so that you can call another method using. Notation. Does not support compressed images and bayer images. #### image.erode(size[, threshold[, mask None]]) Delete pixels from the edge of the divided area. This method is implemented by convolving a kernel of ((size*2)+1)x((size*2)+1) pixels on the image. If the sum of the adjacent pixel sets is less than the threshold, the central pixel of the kernel Zero. If the threshold is not set, this method functions as the standard corrosion method. If the threshold is set, you can specify the specific pixels to be eroded, for example: set the threshold value 2 for pixels below 2. mask is another image used as a pixel level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Return the image object so that you can call another method using. Notation. Does not support compressed images and bayer images. #### image.dilate(size[, threshold[, mask None]]) Add pixels to the edges of the segmented area. This method is implemented by convolving a kernel of ((size*2)+1)x((size*2)+1) pixels on the image. If the sum of the adjacent pixel sets is greater than the threshold, the central pixel of the kernel is Set up. If the threshold is not set, this method functions as the standard corrosion method. If the threshold is set, you can specify the specific pixels to be eroded, for example: set the threshold value 2 for pixels below 2. mask is another image used as a pixel level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Return the image object so that you can call another method using. Notation. Does not support compressed images and bayer images. #### image.open(size[, threshold[, mask None]]) Perform erosion and dilation on the image in sequence. For more information, see image.erode() and image.dilate(). mask is another image used as a pixel level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Return the image object so that you can call another method using. Notation. Does not support compressed images and bayer images. #### image.close(size[, threshold[, mask None]]) Perform dilation and erosion on the image in sequence. For more information, see image.erode() and image.dilate(). mask is another image used as a pixel level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Return the image object so that you can call another method using. Notation. Does not support compressed images and bayer images. #### image.top_hat(size[, threshold[, mask None]]) Return the difference between the original image and the image after executing the image.open() function. mask is another image used as a pixel level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Does not support compressed images and bayer images. #### image.black_hat(size[, threshold[, mask None]]) Return the difference between the original image and the image after executing the image.close() function. mask is another image used as a pixel level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Does not support compressed images and bayer images. #### image.negate() Flip (digitally invert) all pixel values ​​in the image very quickly. Perform numerical conversion on the pixel value of each color channel. Example: (255 pixel). Return the image object so that you can call another method using. Notation. Does not support compressed images and bayer images. #### image.replace(image[, hmirror False[, vflip False[, mask None]]]) image can be an image object, the path of an uncompressed image file (bmp/pgm/ppm), or a scalar value. If a scalar value, the value can be an RGB888 tuple or a basic pixel value (for example, 8 bit grayscale of a grayscale image or byte reversed RGB565 value of an RGB image). Set hmirror to True to mirror the replacement image horizontally. Set vflip to True to flip the replacement image vertically. mask is another image used as a pixel level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Return the image object so that you can call another method using. Notation. Does not support compressed images and bayer images. #### image.add(image[, mask None]) Add two images to each other pixel by pixel. image can be an image object, the path of an uncompressed image file (bmp/pgm/ppm), or a scalar value. If a scalar value, the value can be an RGB888 tuple or a basic pixel value (for example, 8 bit grayscale of a grayscale image or byte reversed RGB565 value of an RGB image). mask is another image used as a pixel level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Return the image object so that you can call another method using. Notation. Does not support compressed images and bayer images. #### image.sub(image[, reverse False[, mask None]]) Subtract two images from each other pixel by pixel. image can be an image object, the path of an uncompressed image file (bmp/pgm/ppm), or a scalar value. If a scalar value, the value can be an RGB888 tuple or a basic pixel value (for example, 8 bit grayscale of a grayscale image or byte reversed RGB565 value of an RGB image). Setting reverse to True can reverse the subtraction operation from this_image image to image this_image. mask is another image used as a pixel level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Return the image object so that you can call another method using. Notation. Does not support compressed images and bayer images. #### image.mul(image[, invert False[, mask None]]) Multiply two images by pixel. image can be an image object, the path of an uncompressed image file (bmp/pgm/ppm), or a scalar value. If a scalar value, the value can be an RGB888 tuple or a basic pixel value (for example, 8 bit grayscale of a grayscale image or byte reversed RGB565 value of an RGB image). Set invert to True to change the multiplication operation from a*b to 1/((1/a)*(1/b)). In particular, this brightens the image instead of darkening it (for example, multiplication and burning operations). mask is another image used as a pixel level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Return the image object so that you can call another method using. Notation. Does not support compressed images and bayer images. #### image.div(image[, invert False[, mask None]]) Divide this image by another image. image can be an image object, the path of an uncompressed image file (bmp/pgm/ppm), or a scalar value. If a scalar value, the value can be an RGB888 tuple or a basic pixel value (for example, 8 bit grayscale of a grayscale image or byte reversed RGB565 value of an RGB image). Set invert to True to change the division direction from a/b to b/a. mask is another image used as a pixel level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Return the image object so that you can call another method using. Notation. Does not support compressed images and bayer images. #### image.min(image[, mask None]) At the pixel level, replace the pixels in this image with the smallest pixel value between this image and another image. image can be an image object, the path of an uncompressed image file (bmp/pgm/ppm), or a scalar value. If a scalar value, the value can be an RGB888 tuple or a basic pixel value (for example, 8 bit grayscale of a grayscale image or byte reversed RGB565 value of an RGB image). mask is another image used as a pixel level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Return the image object so that you can call another method using. Notation. Does not support compressed images and bayer images. This method is not available on OpenMV4. #### image.max(image[, mask None]) At the pixel level, replace the pixels in this image with the maximum pixel value between this image and another image. image can be an image object, the path of an uncompressed image file (bmp/pgm/ppm), or a scalar value. If a scalar value, the value can be an RGB888 tuple or a basic pixel value (for example, 8 bit grayscale of a grayscale image or byte reversed RGB565 value of an RGB image). mask is another image used as a pixel level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Return the image object so that you can call another method using. Notation. Does not support compressed images and bayer images. #### image.difference(image[, mask None]) Take the absolute value of the two images pixel by pixel. Example: For each color channel, change each pixel �� to ABS (this.pixel image.pixel). image can be an image object, the path of an uncompressed image file (bmp/pgm/ppm), or a scalar value. If a scalar value, the value can be an RGB888 tuple or a basic pixel value (for example, 8 bit grayscale of a grayscale image or byte reversed RGB565 value of an RGB image). mask is another image used as a pixel level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Return the image object so that you can call another method using. Notation. Does not support compressed images and bayer images. #### image.blend(image[, alpha 128[, mask None]]) Fuse another image image with this image. image can be an image object, the path of an uncompressed image file (bmp/pgm/ppm), or a scalar value. If a scalar value, the value can be an RGB888 tuple or a basic pixel value (for example, 8 bit grayscale of a grayscale image or byte reversed RGB565 value of an RGB image). Alpha controls how much other images are blended into this image. Alpha should be an integer value between 0 and 256. A value close to zero will blend more other images into this image, a value close to 256 is the opposite. mask is another image used as a pixel level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Return the image object so that you can call another method using. Notation. Does not support compressed images and bayer images. #### image.histeq([adaptive False[, clip_limit 1[, mask None]]]) Run the histogram equalization algorithm on the image. Histogram equalization normalizes the contrast and brightness in the image. If adaptive is passed as True, then an adaptive histogram equalization method will be run on the image, which is usually better than non adaptive histogram definition, but it takes longer to run. clip_limit provides a way to limit the contrast of adaptive histogram equalization. Use a small value (for example, 10) to generate a good histogram equalization contrast limited image. mask is another image used as a pixel level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Return the image object so that you can call another method using. Notation. Does not support compressed images and bayer images. #### image.mean(size, [threshold False, [offset 0, [invert False, [mask None]]]]]) Standard mean fuzzy filtering using box filters. Size is the size of the kernel. Take 1 (3x3 core), 2 (5x5 core) or higher. If you want to set the threshold adaptively on the output of the filter, you can pass the threshold True parameter to start the adaptive threshold processing of the image, which will be based on the brightness of the environment pixel (related to the brightness of the pixels around the kernel function). Set to 1 or 0. A negative offset value sets more pixels to 1, while a positive value only sets the strongest contrast to 1. Set invert to invert the result output of the binary image. mask is another image used as a pixel level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Return the image object so that you can call another method using. Notation. Does not support compressed images and bayer images. median(size, percentile 0.5, threshold False, offset 0, invert False, mask]) Run median filtering on the image. Under the condition of preserving the edges, the median filter is the best filter to smooth the surface, but it runs very slowly. Size is the size of the kernel. Take 1 (3x3 core), 2 (5x5 core) or higher. percentile controls the percentile of the value used in the kernel. By default, each pixel is replaced with the adjacent 50th percentile (center). You can set this value to 0 when using minimum filtering, 0.25 when using lower quartile filtering, 0.75 when using upper quartile filtering, and 1 when using maximum filtering. If you want to set the threshold adaptively on the output of the filter, you can pass the threshold True parameter to start the adaptive threshold processing of the image, which will be based on the brightness of the environment pixel (related to the brightness of the pixels around the kernel function). Set to 1 or 0. A negative offset value sets more pixels to 1, while a positive value only sets the strongest contrast to 1. Set invert to invert the result output of the binary image. mask is another image used as a pixel level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Return the image object so that you can call another method using. Notation. Does not support compressed images and bayer images. This method is not available on OpenMV Cam M4. #### image.mode(size[, threshold False, offset 0, invert False, mask]) Run a mode filter on the image, replacing each pixel with the pattern of neighboring pixels. This method works well on grayscale images. However, due to the non linear nature of this operation, many artifacts will be generated on the edges of the RGB image. Size is the size of the kernel. Take 1 (3x3 core) and 2 (5x5 core). If you want to set the threshold adaptively on the output of the filter, you can pass the threshold True parameter to start the adaptive threshold processing of the image, which will be based on the brightness of the environment pixel (related to the brightness of the pixels around the kernel function). Set to 1 or 0. A negative offset value sets more pixels to 1, while a positive value only sets the strongest contrast to 1. Set invert to invert the result output of the binary image. mask is another image used as a pixel level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Return the image object so that you can call another method using. Notation. Does not support compressed images and bayer images. This method is not available on OpenMV Cam M4. #### image.midpoint(size[, bias 0.5, threshold False, offset 0, invert False, mask]) Run midpoint filtering on the image. This filter finds the midpoint ((max min)/2) of the neighborhood of each pixel in the image. size is the size of the kernel. Take 1 (3x3 core), 2 (5x5 core) or higher. Bias controls the minimum/maximum degree of image blending. 0 only applies to minimum filtering, and 1 only applies to maximum filtering. You can use bias to perform minimum/maximum filtering on the image. If you want to set the threshold adaptively on the output of the filter, you can pass the threshold True parameter to start the adaptive threshold processing of the image, which will be based on the brightness of the environment pixel (related to the brightness of the pixels around the kernel function). Set to 1 or 0. A negative offset value sets more pixels to 1, while a positive value only sets the strongest contrast to 1. Set invert to invert the result output of the binary image. mask is another image used as a pixel level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Return the image object so that you can call another method using. Notation. Does not support compressed images and bayer images. This method is not available on OpenMV Cam M4. #### image.morph(size, kernel, mul Auto, add 0) Convolve the image through the filter kernel. This allows you to perform general convolution on the image. size controls the size of the kernel to ((size*2)+1)x((size*2)+1) pixels. kernel The kernel used to convolve the image, which can be a tuple or a list of values ​​[ 128:127]. mul is the number used to multiply the result of the convolution pixel. If not set, it will default to a value which will prevent scaling in the convolution output. add is the value used to add to the convolution result of each pixel. mul can adjust the global contrast, add can adjust the global brightness. If you want to set the threshold adaptively on the output of the filter, you can pass the threshold True parameter to start the adaptive threshold processing of the image, which will be based on the brightness of the environment pixel (related to the brightness of the pixels around the kernel function). Set to 1 or 0. A negative offset value sets more pixels to 1, while a positive value only sets the strongest contrast to 1. Set invert to invert the result output of the binary image. mask is another image used as a pixel level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Return the image object so that you can call another method using. Notation. Does not support compressed images and bayer images. #### image.gaussian(size[, unsharp False[, mul[, add 0[, threshold False[, offset 0[, invert False[, mask None]]]]]]]) Convolve the image by smoothing Gaussian kernel. size is the size of the kernel. Take 1 (3x3 core), 2 (5x5 core) or higher. If unsharp is set to True, this method will not only perform Gaussian filtering operations, but perform unsharp masking operations, thereby improving the image sharpness of the edges. mul is the number used to multiply the result of the convolution pixel. If not set, it will default to a value which will prevent scaling in the convolution output. add is the value used to add to the convolution result of each pixel. mul can adjust the global contrast, add can adjust the global brightness. If you want to set the threshold adaptively on the output of the filter, you can pass the threshold True parameter to start the adaptive threshold processing of the image, which will be based on the brightness of the environment pixel (related to the brightness of the pixels around the kernel function). Set to 1 or 0. A negative offset value sets more pixels to 1, while a positive value only sets the strongest contrast to 1. Set invert to invert the result output of the binary image. mask is another image used as a pixel level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Return the image object so that you can call another method using. Notation. Does not support compressed images and bayer images. This method is not available on OpenMV Cam M4. #### image.laplacian(size[, sharpen False[, mul[, add 0[, threshold False[, offset 0[, invert False[, mask None]]]]]]]) The image is convolved by edge detection Laplacian kernel. size is the size of the kernel. Take 1 (3x3 core), 2 (5x5 core) or higher. If sharpen is set to True, then this method will change to sharpen the image instead of outputting only the edge detection image that has not been thresholded. Increase the kernel size and then increase the image clarity. mul is the number used to multiply the result of the convolution pixel. If not set, it will default to a value which will prevent scaling in the convolution output. add is the value used to add to the convolution result of each pixel. mul can adjust the global contrast, add can adjust the global brightness. If you want to set the threshold adaptively on the output of the filter, you can pass the threshold True parameter to start the adaptive threshold processing of the image, which will be based on the brightness of the environment pixel (related to the brightness of the pixels around the kernel function). Set to 1 or 0. A negative offset value sets more pixels to 1, while a positive value only sets the strongest contrast to 1. Set invert to invert the result output of the binary image. mask is another image used as a pixel level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Return the image object so that you can call another method using. Notation. Does not support compressed images and bayer images. This method is not available on OpenMV Cam M4. #### image.bilateral(size[, color_sigma 0.1[, space_sigma 1[, threshold False[, offset 0[, invert False[, mask None]]]]]]) The image is convolved through a bilateral filter. The bilateral filter smoothes the image while maintaining the edges in the image. size is the size of the kernel. Take 1 (3x3 core), 2 (5x5 core) or higher. color_sigma controls how close the color is matched with the bilateral filter. Increase this value to increase color blur. space_sigma controls the degree of mutual blurring of pixels in space. Increase this value to increase pixel blur. If you want to set the threshold adaptively on the output of the filter, you can pass the threshold True parameter to start the adaptive threshold processing of the image, which will be based on the brightness of the environment pixel (related to the brightness of the pixels around the kernel function). Set to 1 or 0. A negative offset value sets more pixels to 1, while a positive value only sets the strongest contrast to 1. Set invert to invert the result output of the binary image. mask is another image used as a pixel level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Return the image object so that you can call another method using. Notation. Does not support compressed images and bayer images. This method is not available on OpenMV Cam M4. #### image.cartoon(size[, seed_threshold 0.05[, floating_threshold 0.05[, mask None]]]) Walk through the image and use the flood fills algorithm to fill all pixel areas in the image. This effectively removes texture from the image by flattening the colors in all areas of the image. For best results, the image should have a lot of contrast so that the areas do not penetrate each other too easily. seed_threshold controls the difference between the pixels in the filled area and the original starting pixels. floating_threshold controls the difference between the pixels in the filled area and any adjacent pixels. mask is another image used as a pixel level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Return the image object so that you can call another method using. Notation. Does not support compressed images and bayer images. This method is not available on OpenMV Cam M4. #### image.remove_shadows([image]) Remove the shadow from the image. If there is no \"shadow free\" version of the current image, this method will try to remove the shadow from the image, but there is no real shadow free image basis. This algorithm is suitable for removing shadows in a flat and uniform background. Please note that this method takes many seconds to run, and is only suitable for removing shadows in real time and dynamically generating a shadowless version of the image. Future versions of the algorithm will be applicable to more environments, but are equally slow. If a \"no shadow\" version of the current image appears, this method will use the \"true source\" background non shadow image to remove all shadows in the image to filter out the shadows. Non shadow pixels are not filtered out, so you can add new objects to the scene that did not exist before, and any non shadow pixels in those objects will be displayed. Return the image object so that you can call another method using. Notation. Only supports RGB565 images. This method is not available on OpenMV Cam M4. #### image.chrominvar() Remove the lighting effect from the image, leaving only the color gradient. Faster than image.illuminvar() but affected by shadows. Return the image object so that you can call another method using. Notation. Only supports RGB565 images. This method is not available on OpenMV Cam M4. #### image.illuminvar() Remove the lighting effect from the image, leaving only the color gradient. Slower than image.chrominvar() but not affected by shadows. Return the image object so that you can call another method using. Notation. Only supports RGB565 images. This method is not available on OpenMV Cam M4. #### image.linpolar([reverse False]) The image is reprojected from Cartesian coordinates to linear polar coordinates. Set reverse True to reproject in the opposite direction. Linear polar reprojection converts image rotation to x translation. Does not support compressed images. This method is not available on OpenMV Cam M4. #### image.logpolar([reverse False]) The image is reprojected from Cartesian coordinates to log polar coordinates. Set reverse True to reproject in the opposite direction. Log polar reprojection transforms the rotation of the image into x translation and scaling to y translation. Does not support compressed images. This method is not available on OpenMV Cam M4. #### image.lens_corr([strength 1.8[, zoom 1.0]]) Perform lens distortion correction to remove the fisheye effect of the image caused by the lens. strength is a floating point number, which determines the degree of de fishing effect on the image. By default, first try the value 1.8, and then adjust this value to make the image display the best effect. zoom is the value used to zoom the image. The default value is 1.0. Return the image object so that you can call another method using. Notation. Does not support compressed images and bayer images. #### img.rotation_corr([x_rotation 0.0[, y_rotation 0.0[, z_rotation 0.0[, x_translation 0.0[, y_translation 0.0[, zoom 1.0[, fov 60.0[, corners]]]]] ]]]) Correct the perspective problem in the image by 3D rotation of the frame buffer. `x_rotation` is the number of degrees that the image is rotated around the x axis in the frame buffer (that is, the image is rotated up and down). `y_rotation` refers to the number of degrees the image is rotated around the y axis in the frame buffer (ie, rotate the image left and right). `z_rotation` is the number of degrees the image is rotated around the z axis in the frame buffer (ie, the image is rotated to the appropriate position). `x_translation` is the number of units to move the image to the left or right after rotation. Because this conversion is applied to 3D space, the unit is not a pixel... `y_translation` is the number of units by which the image moves up or down after being rotated. Because this conversion is applied to 3D space, the unit is not a pixel... `zoom` is the multiple to zoom the image, 1.0 by default. `fov` is the field of view used internally before rotating the image in 3D space when performing 2D >3D projection. When this value is close to 0, the image is placed infinitely far from the viewport. When this value is close to 180, the image is placed in the viewport. Normally, you should not change this value, but you can modify it to change the 2D >3D mapping effect. `corners` is a list of four (x, y) tuples, representing four `corners` used to create four point correspondence homography, mapping the first `corner` to (0,0), and the second A `corner` (image_width 1, 0), a third `corner` (image_width 1 image_height 1) and a fourth `corner` (0, image_height 1). Then apply 3D rotation after the image is remapped. This parameter allows you to use rotation_corr to do things, such as bird's eye view conversion. E.g: ```python top_tilt 10 # if the difference between top/bottom_tilt become to large this method will stop working bottom_tilt 0 points [(tilt, 0), (img.width() tilt, 0), (img.width() 1 bottom_tilt, img.height() 1), (bottom_tilt, img.height() 1)] img.rotation_corr(corners points) ``` Return the image object so that you can use `.` to call another method. Does not support compressed images or Bayer images. #### image.get_similarity(image) Return a \"similarity\" object, describing two images using the SSIM algorithm to compare the similarity of the 8x8 pixel color patches between the two images. image can be an image object, the path of an uncompressed image file (bmp/pgm/ppm), or a scalar value. If a scalar value, the value can be an RGB888 tuple or a basic pixel value (for example, 8 bit grayscale of a grayscale image or byte reversed RGB565 value of an RGB image). Does not support compressed images and bayer images. This method is not available on OpenMV Cam M4. #### image.get_histogram([thresholds[, invert False[, roi[, bins[, l_bins[, a_bins[, b_bins]]]]]]]) Perform normalized histogram operations on all color channels of roi and return a histogram object. Please refer to the histogram object for more information. You can also use image.get_hist or image.histogram to call this method. If you pass the thresholds list, the histogram information will only be calculated from the pixels in the threshold list. thresholds must be a list of tuples. [(lo, hi), (lo, hi), ..., (lo, hi)] Define the color range you want to track. For grayscale images, each tuple needs to contain two values the minimum gray value and the maximum gray value. Only the areas of pixels that fall between these thresholds are considered. For an RGB565 image, each tuple needs to have six values ​​(l_lo, l_hi, a_lo, a_hi, b_lo, b_hi) the minimum and maximum values ​​of LAB L, A and B channels, respectively. For ease of use, this function will automatically repair the minimum and maximum values ​​of exchange. In addition, if the tuple is greater than six values, the remaining values ​​are ignored. Conversely, if the tuple is too short, it is assumed that the remaining thresholds are in the maximum range. annotation To obtain the threshold of the tracked object, simply select (click and drag) the tracked object in the IDE frame buffer. The histogram will be updated accordingly to the area. Then just write down the starting and falling positions of the color distribution in each histogram channel. These will be the low and high values ​​of thresholds. Since the difference between the upper and lower quartiles is small, it is better to manually determine the threshold. You can also determine the color threshold by entering Tools > Machine Vision > Threshold Editor in OpenMV IDE and dragging the slider from the GUI window. invert Inversion threshold operation, pixels are matched outside the known color range instead of in the known color range. Unless you need to use color statistics for advanced operations, just use the `image.get_statistics()` method instead of this method to view the pixel area in the image. roi is the rectangular tuple (x, y, w, h) of the region of interest. If not specified, the ROI is the image rectangle of the entire image. The operating range is limited to the pixels in the roi area. bins and other bins are the number of bins used for the histogram channel. For grayscale images, use bins, and for RGB565 images, use every other channel. The bin count of each channel must be greater than 2. In addition, setting the bin count to be greater than the number of unique pixel values ​​for each channel is meaningless. By default, the histogram will have the maximum number of bins per channel. Does not support compressed images and bayer images. #### image.get_statistics([thresholds[, invert False[, roi[, bins[, l_bins[, a_bins[, b_bins]]]]]]]) Calculate the average, median, mode, standard deviation, minimum, maximum, lower quartile and upper quartile of each color channel in roi, and return a data object. See the statistics object for more information. You can also use image.get_stats or image.statistics to call this method. If you pass the thresholds list, the histogram information will only be calculated from the pixels in the threshold list. thresholds must be a list of tuples. [(lo, hi), (lo, hi), ..., (lo, hi)] Define the color range you want to track. For grayscale images, each tuple needs to contain two values the minimum gray value and the maximum gray value. Only the areas of pixels that fall between these thresholds are considered. For an RGB565 image, each tuple needs to have six values ​​(l_lo, l_hi, a_lo, a_hi, b_lo, b_hi) the minimum and maximum values ​​of LAB L, A and B channels, respectively. For ease of use, this function will automatically repair the minimum and maximum values ​​of exchange. In addition, if the tuple is greater than six values, the remaining values ​​are ignored. Conversely, if the tuple is too short, it is assumed that the remaining thresholds are in the maximum range. annotation To obtain the threshold of the tracked object, simply select (click and drag) the tracked object in the IDE frame buffer. The histogram will be updated accordingly to the area. Then just write down the starting and falling positions of the color distribution in each histogram channel. These will be the low and high values ​​of thresholds. Since the difference between the upper and lower quartiles is small, it is better to manually determine the threshold. You can also determine the color threshold by entering Tools > Machine Vision > Threshold Editor in OpenMV IDE and dragging the slider from the GUI window. invert Inversion threshold operation, pixels are matched outside the known color range instead of in the known color range. You can use this method when you need to obtain information about a pixel area in an image. For example: If you want to use the frame difference method to detect motion, you need to use this method to determine the change of the image color channel, thereby triggering the motion detection threshold. roi is the rectangular tuple (x, y, w, h) of the region of interest. If not specified, the ROI is the image rectangle of the entire image. The operating range is limited to the pixels in the roi area. bins and other bins are the number of bins used for the histogram channel. For grayscale images, use bins, and for RGB565 images, use every other channel. The bin count of each channel must be greater than 2. In addition, setting the bin count to be greater than the number of unique pixel values ​​for each channel is meaningless. By default, the histogram will have the maximum number of bins per channel. Does not support compressed images and bayer images. #### image.get_regression(thresholds[, invert False[, roi[, x_stride 2[, y_stride 1[, area_threshold 10[, pixels_threshold 10[, robust False]]]]]]]]) Perform linear regression calculation on all threshold pixels of the image. This calculation is performed by the least square method, which is usually faster, but cannot handle any outliers. If robust is True, the Theil index will be used. The Theil index calculates the median of all slopes between all threshold pixels in the image. If you set too many pixels after threshold conversion, this N^2 operation may drop your FPS below 5 even on an 80x60 image. However, as long as the number of pixels to be set after the threshold conversion is small, linear regression is still effective even when more than 30% of the threshold pixels are abnormal values. This method returns an image.line object. How to easily use linear objects, please refer to the following blog post: https://openmv.io/blogs/news/linear regression line following thresholds must be a list of tuples. [(lo, hi), (lo, hi), ..., (lo, hi)] Define the color range you want to track. For grayscale images, each tuple needs to contain two values the minimum gray value and the maximum gray value. Only the areas of pixels that fall between these thresholds are considered. For an RGB565 image, each tuple needs to have six values ​​(l_lo, l_hi, a_lo, a_hi, b_lo, b_hi) the minimum and maximum values ​​of LAB L, A and B channels, respectively. For ease of use, this function will automatically repair the minimum and maximum values ​​of exchange. In addition, if the tuple is greater than six values, the remaining values ​​are ignored. Conversely, if the tuple is too short, it is assumed that the remaining thresholds are in the maximum range. > To obtain the threshold of the tracked object, just select (click and drag) the tracked object in the IDE frame buffer. The histogram will be updated accordingly to the area. Then just write down the starting and falling positions of the color distribution in each histogram channel. These will be the low and high values ​​of thresholds. Since the difference between the upper and lower quartiles is small, it is better to manually determine the threshold. You can also determine the color threshold by entering Tools > Machine Vision > Threshold Editor in OpenMV IDE and dragging the slider from the GUI window. invert Inversion threshold operation, pixels are matched outside the known color range instead of in the known color range. roi is the rectangular tuple (x, y, w, h) of the region of interest. If not specified, the ROI is the image rectangle of the entire image. The operating range is limited to the pixels in the roi area. x_stride is the number of x pixels to skip when calling the function. y_stride is the number of y pixels to skip when calling the function. If the bounding box area after regression is less than area_threshold, None is returned. If the number of pixels after regression is less than pixel_threshold, None is returned. Does not support compressed images and bayer images. #### image.find_blobs(thresholds[, invert False[, roi[, x_stride 2[, y_stride 1[, area_threshold 10[, pixels_threshold 10[, merge False[, margin 0[, threshold_cb None[, merge_cb None]]]]]]]]]]]) Find all the color blocks in the image and return a list of color block objects including each color block. Please observe the image.blob object for more information. thresholds must be a list of tuples. [(lo, hi), (lo, hi), ..., (lo, hi)] Define the color range you want to track. For grayscale images, each tuple needs to contain two values the minimum gray value and the maximum gray value. Only the areas of pixels that fall between these thresholds are considered. For an RGB565 image, each tuple needs to have six values ​​(l_lo, l_hi, a_lo, a_hi, b_lo, b_hi) the minimum and maximum values ​​of LAB L, A and B channels, respectively. For ease of use, this function will automatically repair the minimum and maximum values ​​of exchange. In addition, if the tuple is greater than six values, the remaining values ​​are ignored. Conversely, if the tuple is too short, it is assumed that the remaining thresholds are in the maximum range. annotation To obtain the threshold of the tracked object, simply select (click and drag) the tracked object in the IDE frame buffer. The histogram will be updated accordingly to the area. Then just write down the starting and falling positions of the color distribution in each histogram channel. These will be the low and high values ​​of thresholds. Since the difference between the upper and lower quartiles is small, it is better to manually determine the threshold. You can also determine the color threshold by entering Tools > Machine Vision > Threshold Editor in OpenMV IDE and dragging the slider from the GUI window. invert Inversion threshold operation, pixels are matched outside the known color range instead of in the known color range. roi is the rectangular tuple (x, y, w, h) of the region of interest. If not specified, the ROI is the image rectangle of the entire image. The operating range is limited to the pixels in the roi area. x_stride is the number of x pixels that need to be skipped when searching for a color block. After finding the color block, the straight line filling algorithm will accurately pixel. If the color block is known to be large, you can increase x_stride to increase the speed of finding the color block. y_stride is the number of y pixels that need to be skipped when searching for a color block. After finding the color block, the straight line filling algorithm will accurately pixel. If the color block is known to be large, y_stride can be increased to increase the speed of searching for the color block. If the bounding box area of ​​a color block is smaller than area_threshold, it will be filtered out. If the number of pixels of a color block is less than pixel_threshold, it will be filtered out. If merge is True, all color blocks that have not been filtered out are merged. The bounding rectangles of these color blocks overlap each other. Margin can be used to increase or decrease the size of the color block boundary rectangle in the intersection test. For example: the color blocks whose edges are 1 and the mutual boundary rectangle is 1 will be merged. Combining color blocks enables color code tracking. Each color block object has a code value code, which is a bit vector. For example: if you enter two color thresholds in image.find_blobs, the first threshold code is 1, the second code is 2 (the third code is 4, the fourth code is 8, and so on). The merged color block uses a logical OR operation on all codes so that you know the colors that produced them. This allows you to track two colors. If you use two colors to get a color block object, it may be a color code. If you use a strict color range and cannot fully track all pixels of the target object, you may need to merge color blocks. Finally, if you want to merge color blocks, but do not want to merge color blocks of two different threshold colors, just call image.find_blobs twice, and the color blocks of different threshold values ​​will not be merged. threshold_cb can be set to call the function of each color block after threshold filtering, so as to filter it from the list of color blocks to be merged. The callback function will receive one parameter: the color block object to be filtered. Then the callback function needs to return True to keep the color blocks or return False to filter the color blocks. merge_cb can be set as a function to call two color blocks to be merged to prohibit or permit the merge. The callback function will receive two parameters two color patch objects to be merged. The callback function must return True to merge color blocks, or return False to prevent color blocks from merging. Does not support compressed images and bayer images. #### image.find_lines([roi[, x_stride 2[, y_stride 1[, threshold 1000[, theta_margin 25[, rho_margin 25]]]]]]) Use Hough Transform to find all straight lines in the image. Return a list of image.line objects. roi is the rectangular tuple (x, y, w, h) of the region of interest. If not specified, the ROI is the image rectangle of the entire image. The operating range is limited to the pixels in the roi area. x_stride is the number of x pixels that need to be skipped during Hough transform. If the known straight line is larger, you can increase x_stride. y_stride is the number of y pixels that need to be skipped during Hough transform. If the known straight line is larger, you can increase y_stride. threshold controls the straight line detected from the Hough transform. Only return lines greater than or equal to threshold. The correct threshold value for the application depends on the image. Note: The magnitude of a straight line (magnitude) is the sum of the pixel sizes of all Sobel filters that make up the straight line. theta_margin controls the merging of the monitored lines. The part where the angle of the straight line is theta_margin is merged with the part where the p value of the straight line is rho_margin. rho_margin controls the merging of the monitored lines. The part where the angle of the straight line is theta_margin and the part where the p value of the straight line is rho_margin are merged. This method runs the Sobel filter on the image and uses the amplitude and gradient response of the filter to perform the Hough transform. No preprocessing of the image is required. However, cleaning the image filter can get more stable results. Does not support compressed images and bayer images. This method is not available on OpenMV Cam M4. #### image.find_line_segments([roi[, merge_distance 0[, max_theta_difference 15]]]) Use Hough Transform to find line segments in the image. Return a list of image.line objects. roi is a rectangular region of interest (x, y, w, h) to be copied. If not specified, ROI is the image rectangle. The operating range is limited to pixels in the roi area. merge_distance specifies the maximum number of pixels between two line segments that can be separated from each other without being merged. max_theta_difference is the maximum angle difference between the two line segments to be merged by the above merge_distancede. This method uses the LSD library (also used by OpenCV) to find line segments in the image. This is a bit slow, but very accurate, and the line segments will not jump. Does not support compressed images and bayer images. This method is not available on OpenMV Cam M4. #### image.find_circles([roi[, x_stride 2[, y_stride 1[, threshold 2000[, x_margin 10[, y_margin 10[, r_margin 10]]]]]]]) Use the Hough transform to find the circle in the image. Return a list of image.circle objects (see above). roi is a rectangular region of interest (x, y, w, h) to be copied. If not specified, ROI is the image rectangle. The operating range is limited to pixels in the roi area. x_stride is the number of x pixels that need to be skipped during Hough transform. If the circle is known to be larger, you can increase x_stride. y_stride is the number of y pixels that need to be skipped during Hough transform. If the circle is known to be larger, y_stride can be increased. threshold controls the circle detected from the Hough transform. Only return circles greater than or equal to threshold. The correct threshold value for the application depends on the image. Note: The size of a circle (magnitude) is the sum of the sizes of all Sobel filter pixels that make up the circle. x_margin controls the merging of the detected circles. The round pixels are the partial merge of x_margin, y_margin and r_margin. y_margin controls the merging of the detected circles. The round pixels are the partial merge of x_margin, y_margin and r_margin. r_margin controls the merging of the detected circles. The round pixels are the partial merge of x_margin, y_margin and r_margin. Does not support compressed images and bayer images. This method is not available on OpenMV Cam M4. #### image.find_rects([roi Auto, threshold 10000]) Use the same quad detection algorithm used to find AprilTAg to find rectangles in the image. Best for rectangles that contrast sharply with the background. AprilTag's quad detection can handle arbitrary scaling/rotation/cutting of rectangles. Returns a list of image.rect objects. roi is a rectangular region of interest (x, y, w, h) to be copied. If not specified, ROI is the image rectangle. The operating range is limited to the pixels in the roi area. Rectangles with a boundary size (by sliding the Sobel operator on all pixels on the edge of the rectangle and adding the value) less than threshold will be filtered from the returned list. The correct value of threshold depends on your application/scenario. Does not support compressed images and bayer images. This method is not available on OpenMV Cam M4. #### image.find_qrcodes([roi]) Find all QR codes in roi and return a list of image.qrcode objects. Please refer to the image.qrcode object for more information. In order for this method to run successfully, the QR code on the image needs to be relatively flat. By using the sensor.set_windowing function to zoom in the center of the lens, the image.lens_corr function to eliminate the barrel distortion of the lens or by changing the lens with a narrower field of view, you can get a flatter QR code that is not affected by lens distortion. Some machine vision lenses do not cause barrel distortion, but their cost is much higher than the standard lenses provided by OpenMV, which are distortion free lenses. roi is a rectangular region of interest (x, y, w, h) to be copied. If not specified, ROI is the image rectangle of the entire image. The operating range is limited to the pixels in the roi area. Does not support compressed images and bayer images. This method is not available on OpenMV Cam M4. image.find_apriltags([roi[, families image.TAG36H11[, fx[, fy[, cx[, cy]]]]]]) Find all AprilTags in roi, and return a list of image.apriltag objects. Please refer to the image.apriltag object for more information. Compared with two dimensional codes, AprilTags can be detected at longer distances, poorer light, and more distorted image environments. AprilTags can deal with all kinds of image distortion problems, but two dimensional codes cannot. In other words, AprilTags can only encode a digital ID as its payload. AprilTags can also be used for localization. Each image.apriltag object returns its three dimensional position information and rotation angle from the camera. The position information is determined by fx, fy, cx and cy, which are the focal length and center point of the image in the X and Y directions, respectively. > Use the built in tag generator tool of OpenMV IDE to create AprilTags. The label generator can create printable 8.5\"x11\" AprilTags. roi is a rectangular region of interest (x, y, w, h) to be copied. If not specified, ROI is the image rectangle of the entire image. The operating range is limited to the pixels in the roi area. families is the bit mask of the tag family to be decoded. Is a logical OR: image.TAG16H5 image.TAG25H7 image.TAG25H9 image.TAG36H10 image.TAG36H11 image.ARTOOLKIT The default setting is the best image.TAG36H11 tag family. Note: Each time you enable a tag family, the speed of find_apriltags will slow down slightly. fx is the focal length of the camera in the x direction in pixels. The value of the standard OpenMV Cam is (2.8 / 3.984) * 656, which is obtained by dividing the focal length in millimeters by the length of the photosensitive element in the X direction, and multiplying it by the number of pixels of the photosensitive element in the X direction (for OV7725 photosensitive element In terms of). fy is the focal length of the camera in the y direction in pixels. The value of the standard OpenMV Cam is (2.8 / 2.952) * 488, which is obtained by dividing the focal length in millimeters by the length of the photosensitive element in the Y direction, and multiplying it by the number of pixels of the photosensitive element in the Y direction (for OV7725 photosensitive element In terms of). cx is the center of the image, which is image.width()/2 instead of roi.w()/2. cy is the center of the image, ie image.height()/2, not roi.h()/2. Does not support compressed images and bayer images. This method is not available on OpenMV Cam M4. image.find_datamatrices([roi[, effort 200]]) Find all data matrices in roi and return a list of image.datamatrix objects. Please refer to the image.datamatrix object for more information. In order for this method to run successfully, the rectangular code on the image needs to be relatively flat. By using the sensor.set_windowing function to zoom in at the center of the lens, the image.lens_corr function to eliminate the barrel distortion of the lens, or by changing the lens with a narrower field of view, you can get a flatter rectangular code that is not affected by lens distortion. Some machine vision lenses do not cause barrel distortion, but their cost is much higher than the standard lens provided by OpenMV, which is a distortion free lens. roi is a rectangular region of interest (x, y, w, h) to be copied. If not specified, ROI is the image rectangle of the entire image. The operating range is limited to the pixels in the roi area. effort controls the time used to find a rectangle code match. The default value of 200 should apply to all use cases. But you may also increase detection at the expense of frame rate, or increase frame rate at the expense of detection. Note: If effort is set below about 160, you will not be able to perform any detection; instead, you can set it to any high value you need, but if the setting is higher than 240, the detection rate will not continue to increase. Does not support compressed images and bayer images. This method is not available on OpenMV Cam M4. #### image.find_barcodes([roi]) Find all one dimensional barcodes in roi and return a list of image.barcode objects. Please refer to the image.barcode object for more information. For best results, please use a window of 640 length and 40/80/160 width. The lower the verticality, the faster the running speed. Since the barcode is a linear one dimensional image, it only needs to have a higher resolution in one direction and a lower resolution in the other direction. Note: This function performs horizontal and vertical scanning, so you can use a window with a width of 40/80/160 and a length of 480. Finally, be sure to adjust the lens so that the barcode will be positioned where the focal length produces the clearest image. Fuzzy barcodes cannot be decoded. This function supports all one dimensional barcodes: image.EAN2 image.EAN5 image.EAN8 image.UPCE image.ISBN10 image.UPCA image.EAN13 image.ISBN13 image.I25 image.DATABAR (RSS 14) image.DATABAR_EXP (RSS Expanded) image.CODABAR image.CODE39 image.PDF417 image.CODE93 image.CODE128 roi is a rectangular region of interest (x, y, w, h) to be copied. If not specified, ROI is the image rectangle of the entire image. The operating range is limited to the pixels in the roi area. Does not support compressed images and bayer images. This method is not available on OpenMV Cam M4. image.find_displacement(template[, roi[, template_roi[, logpolar False]]]) Find the transformation offset of this image from the template. This method can be used to make optical flow. This method returns an image.displacement object that contains the result of the displacement calculation using phase correlation. roi is the rectangular area (x, y, w, h) to be processed. If not specified, it is equal to the image rectangle. template_roi is the rectangular area (x, y, w, h) to be processed. If not specified, it is equal to the image rectangle. roi and template roi must have the same w/h, but x/y can be anywhere in the image. You can slide the smaller rois on the larger image to get the optical flow gradient image. image.find_displacement usually calculates the x/y translation between two images. However, if you set logpolar True, it will find changes in rotation and scaling between the two images. The same image.displacement object results in two possible feedbacks. Does not support compressed images and bayer images. annotation Please use this method on images with the same length and width (such as ``sensor.B64X64''). This method is not available on OpenMV Cam M4. #### image.find_number(roi) Run LENET 6 CNN (Convolutional Neural Network) trained on the MINST dataset to detect numbers in 28x28 ROI located anywhere on the image. Return a tuple containing integers and floating point numbers, representing the detected number (0 9) and the detection confidence (0 1). roi is the rectangular tuple (x, y, w, h) of the region of interest. If not specified, the ROI is the image rectangle of the entire image. The operating range is limited to the pixels in the roi area. Only grayscale images are supported. annotation This method is experimental. If you run any CNN trained on PC using Caffe in the future, this method may be deleted. The latest firmware version 3.0.0 has removed this function. This method is not available on OpenMV Cam M4. #### image.classify_object(roi) Run CIFAR 10 CNN on the ROI of the image to detect airplanes, cars, birds, cats, deer, dogs, frogs, horses, boats and trucks. This method automatically scales the image to 32x32 internally to feed the CNN. roi is the rectangular tuple (x, y, w, h) of the region of interest. If not specified, the ROI is the image rectangle of the entire image. The operating range is limited to the pixels in the roi area. Only supports RGB565 images. annotation This method is experimental. If you run any CNN trained on PC using Caffe in the future, this method may be deleted. This method is not available on OpenMV Cam M4. image.find_template(template, threshold[, roi[, step 2[, search image.SEARCH_EX]]]) Try to use the normalized cross correlation (NCC) algorithm to find the first template match in the image. Returns the bounding box tuple (x, y, w, h) of the matching position, otherwise returns None. template is a small image object that matches this image object. Note: Both images must be grayscale. Threshold is a floating point number (0.0 1.0), where the smaller value increases the detection rate while increasing the false alarm rate. Conversely, a higher value will reduce the detection rate and at the same time reduce the false alarm rate. roi is the rectangular tuple (x, y, w, h) of the region of interest. If not specified, the ROI is the image rectangle of the entire image. The operating range is limited to the pixels in the roi area. step is the number of pixels that need to be skipped when searching for a template. Skipping pixels can greatly increase the speed of the algorithm. This method is only applicable to algorithms in SERACH_EX mode. search can be image.SEARCH_DS or image.SEARCH_EX. The algorithm used by image.SEARCH_DS to search for a template is faster than image.SEARCH_EX, but if the template is located around the edge of the image, the search may not succeed. image.SEARCH_EX can perform a more detailed search on images, but its running speed is much slower than image.SEARCH_DS. Only grayscale images are supported. #### image.find_features(cascade[, threshold 0.5[, scale 1.5[, roi]]]) This method searches images of all regions that match Haar Cascade and returns a list of bounding box rectangle tuples (x, y, w, h) about these features. If no features are found, a blank list is returned. cascade is a Haar Cascade object. See image.HaarCascade() for details. Threshold is a floating point number (0.0 1.0), where the smaller value increases the detection rate while increasing the false alarm rate. Conversely, a higher value will reduce the detection rate and at the same time reduce the false alarm rate. scale is a floating point number that must be greater than 1.0. A higher scale factor runs faster, but its image matching is relatively poor. The ideal value is between 1.35 1.5. roi is the rectangular tuple (x, y, w, h) of the region of interest. If not specified, the ROI is the image rectangle of the entire image. The operating range is limited to the pixels in the roi area. Only grayscale images are supported. #### image.find_eye(roi) Find the pupil in the area of ​​interest (x, y, w, h) around the eye. Returns a tuple containing the position of the pupil (x, y) in the image. If no pupil is found, return (0,0). Before using this function, first use image.find_features() and Haar operator frontalface to search for someone's face. Then use image.find_features and Haar operator find_eye to search for eyes on the face. Finally, call this method on each eye ROI returned after calling the image.find_features function to get the coordinates of the pupil. roi is the rectangular tuple (x, y, w, h) of the region of interest. If not specified, the ROI is the image rectangle of the entire image. The operating range is limited to the pixels in the roi area. Only grayscale images are supported. #### image.find_lbp(roi) Extract LBP (local binary mode) key points from the ROI tuple (x, y, w, h). You can use the image.match_descriptor function to compare two sets of key points to get the matching distance. roi is the rectangular tuple (x, y, w, h) of the region of interest. If not specified, the ROI is the image rectangle of the entire image. The operating range is limited to the pixels in the roi area. Only grayscale images are supported. #### image.find_keypoints([roi[, threshold 20[, normalized False[, scale_factor 1.5[, max_keypoints 100[, corner_detector image.CORNER_AGAST]]]]]]]) Extract ORB key points from the ROI tuple (x, y, w, h). You can use the image.match_descriptor function to compare two sets of key points to get the matching area. If no key point is found, None is returned. roi is the rectangular tuple (x, y, w, h) of the region of interest. If not specified, the ROI is the image rectangle of the entire image. The operating range is limited to the pixels in the roi area. threshold is a number that controls the number of extractions (values ​​0 255). For the default AGAST corner detector, this value should be around 20. For FAST corner detectors, this value is about 60 80. The lower the threshold, the more corner points you extract. normalized is a boolean value. If True, turn off the key point extraction in multi resolution. If you don't care about dealing with scaling issues and want the algorithm to run faster, set it to True. scale_factor is a floating point number that must be greater than 1.0. A higher scale factor runs faster, but its image matching is relatively poor. The ideal value is between 1.35 1.5. max_keypoints is the maximum number of keypoints that a keypoint object can hold. If the key point object is too large and causes memory problems, please lower the value. corner_detector is the corner detector algorithm used to extract the key points from the image. Can be image.CORNER_FAST or image.CORNER_AGAST. The FAST corner detector runs faster, but its accuracy is lower. Only grayscale images are supported. #### image.find_edges(edge_type[, threshold]) Turn the image into black and white, leaving only the edges as white pixels. image.EDGE_SIMPLE Simple threshold high pass filtering algorithm image.EDGE_CANNY Canny edge detection algorithm threshold is a binary tuple containing a low threshold and a high threshold. You can control the edge quality by adjusting this value. The default is (100, 200). Only grayscale images are supported. find_hog([roi[, size 8]]) Replace the pixels in the ROI with HOG (Histogram of Oriented Gradient) lines. roi is the rectangular tuple (x, y, w, h) of the region of interest. If not specified, the ROI is the image rectangle of the entire image. The operating range is limited to the pixels in the roi area. Only grayscale images are supported. This method is not available on OpenMV Cam M4. ## Constant ### image.SEARCH_EX Exhaustive template matching search. ### image.SEARCH_DS Faster template matching search. ### image.EDGE_CANNY Use the Canny edge detection algorithm to perform edge detection on the image. ### image.EDGE_SIMPLE Use threshold high pass filtering algorithm to detect the edge of the image. ### image.CORNER_FAST High speed and low accuracy corner detection algorithm for ORB key points ### image.CORNER_AGAST Low speed and high accuracy algorithm for ORB key points. ### image.TAG16H5 Bit mask enumeration of TAG1H5 tag group. Used for AprilTags. ### image.TAG25H7 Bit mask enumeration of TAG25H7 tag group. Used for AprilTags. ### image.TAG25H9 Bitmask enumeration of TAG25H9 tag group. Used for AprilTags. ### image.TAG36H10 Bit mask enumeration of TAG36H10 tag group. Used for AprilTags. ### image.TAG36H11 Bit mask enumeration of TAG36H11 tag group. Used for AprilTags. ### image.ARTOOLKIT The bit mask enumeration of the ARTOOLKIT tag group. Used for AprilTags. ### image.EAN2 EAN2 barcode type enumeration. ### image.EAN5 EAN5 barcode type enumeration. ### image.EAN8 EAN8 barcode type enumeration. ### image.UPCE UPCE barcode type enumeration. ### image.ISBN10 ISBN10 barcode type enumeration. ### image.UPCA UPCA barcode type enumeration. ### image.EAN13 EAN13 barcode type enumeration. ### image.ISBN13 ISBN13 barcode type enumeration. ### image.I25 I25 barcode type enumeration. ### image.DATABAR DATABAR barcode type enumeration. ### image.DATABAR_EXP DATABAR_EXP barcode type enumeration. ### image.CODABAR Enumeration of CODABAR barcode types. ### image.CODE39 CODE39 barcode type enumeration. ### image.PDF417 PDF417 barcode type enumeration (currently not working). ### image.CODE93 CODE93 barcode type enumeration. ### image.CODE128 CODE128 barcode type enumeration."},"/soft/maixpy/en/api_reference/machine_vision/sensor.html":{"title":"sensor (camera)","content":" title: sensor (camera) keywords: maixpy, k210, AIOT, edge computing desc: maixpy sensor (camera) sensor sensor module (here specifically refers to the camera module), for camera configuration and image capture, etc., used to control the development board camera to complete the camera task. ## Method ### Initialize the monocular camera Reset and initialize the monocular camera ```python sensor.reset([, freq 24000000[, set_regs True[, dual_buff False]]]) ``` #### Parameters * `freq`: Set the camera clock frequency, the higher the frequency, the higher the frame rate, but the image quality may be worse. The default is `24MHz`, if the camera has colored spots (ov7740), you can adjust it appropriately, such as `20MHz` * `set_regs`: Allow the program to write camera registers, the default is `True`. If you need to customize the reset sequence, you can set it to `False`, and then use the `sensor.__write_reg(addr, value)` function to customize the write register sequence * `dual_buff`: The default is `False`. Double buffering is allowed, which will increase the frame rate, but the memory usage will also increase (about 384KiB) * `choice`: Specify the type of camera to be searched, ov type (1), gc type (2), mt type (3), if this parameter is not passed, all types of cameras will be searched #### return value no ### Reset the binocular camera Reset and initialize the binocular camera > K210 has only one DVP interface and can only control one Sensor at a time. But we can use the `shudown` method to control the PWDN pin to select a specific Sensor. The remaining operations remain unchanged after the Sensor is specified. See Routine 2 ```python sensor.binocular_reset() ``` #### Parameters no #### return value no ### Set frame size Used to set the output frame size of the camera, k210 supports the maximum VGA format, and the image cannot be obtained if it is larger than VGA > The screen configured on the MaixPy development board is 320*240 resolution, and it is recommended to set it to QVGA format ``` sensor.set_framesize(framesize[, set_regs True]) ``` #### Parameters * `framesize`: frame size * `set_regs`: Allow the program to write camera registers, the default is `True`. If you need to customize the sequence of setting the frame size, you can set it to `False`, and then use the `sensor.__write_reg(addr, value)` function to customize the write register sequence #### return value * `True`: set successfully * `False`: setting error ### Set frame format Used to set the camera output format > The screen configured on the MaixPy development board uses RGB565, and it is recommended to set it to RGB565 format ``` sensor.set_pixformat(format[, set_regs True]) ``` #### Parameters * `format`: Frame format * `set_regs`: Allow the program to write camera registers, the default is `True`. If you need to customize the sequence of setting the pixel format, you can set it to `False`, and then use the `sensor.__write_reg(addr, value)` function to customize the write register sequence > Available frame formats are `GRAYSCALE`, `RGB565`, `YUV422` #### return value * `True`: set successfully * `False`: setting error ### Image capture control Image capture function control ``` sensor.run(enable) ``` #### Parameters * `enable`: 1 means start capturing images 0 means stop capturing images #### return value * `True`: set successfully * `False`: setting error ### Take an image Take a picture with the camera ``` sensor.snapshot() ``` #### Parameters no #### return value * `img`: The returned image object ### Camera control Turn off the camera / switch camera ``` sensor.shutdown(enable/select) ``` #### Parameters Monocular camera * `enable`: True means to turn on the camera False means to turn off the camera Binocular camera * `select`: switch camera by writing 0 or 1 #### return value no ### Frame skip Skip the specified number of frames or skip the image within the specified time, so that the camera image is stable after changing the camera settings ``` sensor.skip_frames(n, [, time]) ``` #### Parameters * `n`: skip n frames of images * `time`: skip the specified time, the unit is ms > If n and time are not specified, the method skips 300 milliseconds of frames; if both are specified, the method skips n number of frames, but will return after time milliseconds #### return value no ### Resolution width Get the camera resolution width ``` sensor.width() ``` #### Parameters no #### return value * `int` type of camera resolution width ### Resolution height Get the camera resolution height ``` sensor.height() ``` #### Parameters no #### return value * `int` type of camera resolution height ### Get frame buffer Get the current frame buffer ``` sensor.get_fb() ``` #### Parameters no #### return value * Objects of type `image` ### Get ID Get the current camera ID ``` sensor.get_id() ``` #### Parameters no #### return value * ID of type `int` ### Set the color bar test mode Set the camera to the color bar test mode > After the color bar test mode is turned on, the camera will output a color bar image, which is often used to check whether the camera bus is connected correctly. ``` sensor.set_colorbar(enable) ``` #### Parameters * `enable`: 1 means turn on the color bar test mode 0 means turn off the color bar test mode #### return value no ### Set contrast Set camera contrast ``` sensor.set_contrast(contrast) ``` #### Parameters * `constrast`: camera contrast, the range is [ 2,+2] #### return value * `True`: set successfully * `False`: setting error ### Set brightness Set camera brightness ``` sensor.set_brightness(brightness) ``` #### Parameters * `brightness`: Camera brightness, range [ 2,+2] #### return value * `True`: set successfully * `False`: setting error ### Set saturation Set camera saturation ``` sensor.set_saturation(saturation) ``` #### Parameters * `constrast`: camera saturation, the range is [ 2,+2] #### return value * `True`: set successfully * `False`: setting error ### Set automatic gain Set camera auto gain mode ``` sensor.set_auto_gain(enable,gain_db) ``` #### Parameters * `enable`: 1 means turn on auto gain 0 means turn off auto gain * `gain_db`: When auto gain is turned off, the set camera fixed gain value, the unit is dB > If you need to track the color, you need to turn off the automatic gain #### return value no ### Get the gain value Get the camera gain value ``` sensor.get_gain_db() ``` #### Parameters no #### return value * `float` type gain value ### Set horizontal mirroring Set camera horizontal mirroring ``` sensor.set_hmirror(enable) ``` #### Parameters * `enable`: 1 means enable horizontal mirroring 0 means turn off horizontal mirroring #### return value no ### Set the camera to flip vertically Set the camera to flip vertically ``` sensor.set_vflip(enable) ``` #### Parameters * `enable`: 1 means turn on vertical flip 0 means turn off vertical flip #### return value no ### Write register Write the specified value to the camera register ``` sensor.__write_reg(address, value) ``` #### Parameters * `address`: register address * `value`: write value #### return value no > Please refer to the camera data sheet for details ### Read register Read camera register value ``` sensor.__read_reg(address) ``` #### Parameters * `address`: register address #### return value * `int` type of register value > Please refer to the camera data sheet for details ### set_jb_quality Set the quality of the image transmitted to the IDE ``` sensor.set_jb_quality(quality) ``` #### Parameters `quality`: `int` type, image quality percentage (0~100), the larger the number, the better the quality ## Routine ### Routine 1 ```python # Monocular camera import sensor import lcd lcd.init() sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) while True: img sensor.snapshot() lcd.display(img) ``` ### Routine 2 ```python # Binocular camera import sensor import image import lcd import time lcd.init() sensor.binocular_reset() sensor.shutdown(0) # Select sensor 0 sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.shutdown(1) # Select sensor 1 sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) while True: sensor.shutdown(0) # Select sensor 0 img sensor.snapshot() lcd.display(img) time.sleep_ms(100) sensor.shutdown(1) # Select sensor 1 img sensor.snapshot() lcd.display(img) time.sleep_ms(100) ```"},"/soft/maixpy/en/api_reference/Maix/utils.html":{"title":"Maix.utils","content":" title: Maix.utils keywords: maixpy, k210, AIOT, edge computing desc: maixpy Maix.utils ## gc_heap_size([size]) Get or set the GC heap size, if the memory is not enough, you can consider setting it larger ### Parameters None or pass in the new GC heap size. * If there is no parameter, just get the heap size; * If there are parameters, set the heap size, and then automatically restart ### return value GC heap size Use case ```python import Maix # Maix.utils.gc_heap_size(0x80000) # The firmware default configuration is 500KB Maix.utils.gc_heap_size(0x96000) # 600KB ``` ## flash_read(flash_offset, size) Read data of size specified size (number of bytes) from internal flash ### Parameters flash_offset: flash address offset flash_offset: flash address offset ## heap_free() ```shell >>> Maix.utils.gc_heap_size() 524288 >>> Maix.utils.heap_free() 4374528 ``` The script test conditions in the article are: MaixDock MaixPy v0.5.0_246 (standard firmware)"},"/soft/maixpy/en/api_reference/Maix/i2s.html":{"title":"I2S","content":" title: I2S keywords: maixpy, k210, AIOT, edge computing desc: maixpy I2S The I2S module is mainly used to drive I2S devices. There are 3 I2S devices in k210, and each device has 4 channels. The pins need to be mapped and managed before use. ## Module function ### Constructor Create a new I2S object ``` from Maix import I2S i2s_dev I2S(device_num) ``` #### Parameters `device_num` I2S number, use the specified I2S, you can use `I2S.` to press the tab key to complete #### return value Returns an `I2S` object ### Channel configuration function Used to configure the I2S channel, the pins need to be mapped before ``` i2s_dev.channel_config(channel, mode, resolution, cycles, align_mode) ``` #### Parameters * `channel`: I2S channel number * `mode`: Channel transmission mode, there are a total of receiving and sending modes, recording is receiving, playing is sending * `resolution`: Channel resolution, that is, the number of received data bits * `cycles`: the number of single data clocks * `align_mode`: channel alignment mode #### return value no ### Set the sampling rate Used to configure I2S sampling rate ``` i2s_dev.set_sample_rate(sample_rate) ``` #### Parameters `sample_rate`: int type, sampling rate #### return value no ### Receive audio Use I2S to receive audio data ``` audio i2s_dev.record(points) ``` #### Parameters * `points`: The number of audio points collected at one time #### return value `audio`: an `audio` audio object ### Send audio Use I2S to send audio data ``` i2s_dev.play(audio) ``` #### Parameters * `audio`: The audio object sent #### return value no ## Routine ### Routine 1 Collect data and play it directly ```python from Maix import I2S import time from fpioa_manager import * fm.register(20,fm.fpioa.I2S0_IN_D0)#GO fm.register(19,fm.fpioa.I2S0_WS) fm.register(18,fm.fpioa.I2S0_SCLK) fm.register(34,fm.fpioa.I2S2_OUT_D1) fm.register(35,fm.fpioa.I2S2_SCLK) fm.register(33,fm.fpioa.I2S2_WS) sample_rate 44*1000 rx I2S(I2S.DEVICE_0) rx.channel_config(rx.CHANNEL_0, rx.RECEIVER, align_mode I2S.STANDARD_MODE) rx.set_sample_rate(sample_rate) tx I2S(I2S.DEVICE_2) tx.channel_config(tx.CHANNEL_1, tx.TRANSMITTER, align_mode I2S.RIGHT_JUSTIFYING_MODE) tx.set_sample_rate(sample_rate) while True: audio rx.record(256)#sampling points number must be smaller than 256 tx.play(audio) ``` ### Routine 2 The collected data is converted into Audio and played ```python from Maix import I2S from Maix import Audio from Maix import FFT import time from fpioa_manager import * fm.register(20,fm.fpioa.I2S0_IN_D0) fm.register(19,fm.fpioa.I2S0_WS) fm.register(18,fm.fpioa.I2S0_SCLK) fm.register(34,fm.fpioa.I2S2_OUT_D1) fm.register(35,fm.fpioa.I2S2_SCLK) fm.register(33,fm.fpioa.I2S2_WS) rx I2S(I2S.DEVICE_0) rx.channel_config(rx.CHANNEL_0, rx.RECEIVER, align_mode I2S.STANDARD_MODE) rx.set_sample_rate(16000) tx I2S(I2S.DEVICE_2) tx.channel_config(tx.CHANNEL_1, tx.TRANSMITTER, align_mode I2S.RIGHT_JUSTIFYING_MODE) tx.set_sample_rate(16000) while True: audio rx.record(256) audio_data audio.to_bytes() play_audio Audio(audio_data) tx.play(play_audio) ```"},"/soft/maixpy/en/api_reference/Maix/index.html":{"title":"Maix library","content":" title: Maix library keywords: maixpy, k210, AIOT, edge computing desc: maixpy Maix library * [FPIOA](fpioa.html) * [GPIO](gpio.html) * [KPU](kpu.html) * [FFT](fft.html) * [I2S](i2s.html) * [Audio](audio.html) * [freq](freq.html) * [utils](utils.html)"},"/soft/maixpy/en/api_reference/Maix/fft.html":{"title":"FFT operation","content":" title: FFT operation keywords: maixpy, k210, AIOT, edge computing desc: maixpy FFT operation FFT fast Fourier transform module, which performs Fourier transform on input data and returns the corresponding frequency amplitude. FFT fast Fourier operation can convert time domain signal into frequency domain signal ## Module function ### Operation function Input time domain data and perform Fourier transform ``` import FFT res FFT.run(data, points, shift) ``` #### Parameters * `data`: input time domain data, `bytearray` type * `points`: FFT calculation points, only supports 64, 128, 256 and 512 points * `shift`: shift, default is 0 #### return value `res`: Returns the calculated frequency domain data, presented as a `list` type. The list has `points` tuples, each tuple has 2 elements, the first element is the real part, and the second is Imaginary part ### Frequency function FFT ``` res FFT.freq(points, sample_rate) ``` #### Parameters * `points`: Calculate points * `sample_rate`: sample rate #### return value `res`: return a list, the list stores the frequency values ​​of all frequency points after the operation ### Amplitude function Used to calculate the amplitude of each frequency point after FFT operation. It is currently used as a test. Users can write their own amplitude processing functions in python ``` amp FFT.amplitude(FFT_res) ``` #### Parameters `FFT_res`: the result of function `run` #### return value `res`: Return a list that stores the amplitude of each frequency point ### Routine Collect sound and perform FFT calculation, and display the calculated data as a histogram on the screen Example code: https://github.com/sipeed/MaixPy v1_scripts/blob/master/hardware/demo_fft_spectrum.py"},"/soft/maixpy/en/api_reference/Maix/fpioa.html":{"title":"FPIOA (Field Programmable Input and Output Array)","content":" title: FPIOA (Field Programmable Input and Output Array) keywords: maixpy, k210, AIOT, edge computing desc: maixpy FPIOA (Field Programmable Input and Output Array) K210 supports each peripheral to be mapped to any pin at will, using FPIOA function to achieve. **note**: The following GPIOHS have been used by default, try not to use them unless necessary in the program: GPIOHS Function Description GPIOHS5 LCD_DC LCD read and write signal pin GPIOHS4 LCD_RST LCD reset chip pin GPIOHS29 SD_CS SD card SPI chip select GPIOHS28 MIC_LED_CLK SK9822_DAT GPIOHS27 MIC_LED_DATA SK9822_CLK ## Class `FPIOA` ### Method #### help(func) Display peripherals and their brief descriptions ##### Parameters * `func`: Peripheral name (function/number), no parameters can be passed, then all peripheral names will be displayed in the form of a table that is a brief description, this table can also be found at the end of this page ([Appendix: Peripheral ](#Appendix: peripheral table));</br> If you pass a parameter, pass an integer value, and print the name and description of the peripheral after finding the peripheral corresponding to the number,</br> For example, `FPIOA.JTAG_TCLK` or `fm.fpioa.JTAG_TCLK` (`fm` is introduced later on this page) or `0` such as: ```python from Maix import FPIOA fpioa FPIOA() fpioa.help() fpioa.help(0) fpioa.help(fpioa.JTAG_TCLK) fm.fpioa.help() fm.fpioa.help(fm.fpioa.JTAG_TCLK) ``` ##### Return Peripheral name and its brief description #### set_function(pin, func) Set the peripheral function corresponding to the pin, that is, pin mapping ##### Parameters * `pin`: pin number, value [0, 47], please see the circuit diagram for specific pin connections, you can also use `board_info.` and then press the `TAB` button to complete to get the common pins of the board, such as `board_info.LED_G` * `func`: Peripheral function, pass an integer value, you can get it through `fm.fpioa.help()` or check the [Appendix: Peripheral Table](#Appendix: Peripheral Table) table at the end of this page For example, you need to map the pin connected to the `green LED` to the `high speed GPIO0`: ```python fpioa FPIOA() fpioa.set_function(board_info.LED_G, fm.fpioa.GPIOHS0) ``` #### get_Pin_num(func) Get which pin the peripheral is mapped to ##### Parameters * `func`: Peripheral function, pass an integer value, you can get it through `fm.fpioa.help()` or check the [Appendix: Peripheral Table](#Appendix: Peripheral Table) table at the end of this page such as: ```python fpioa FPIOA() fpioa.set_function(board_info.LED_G, fm.fpioa.GPIOHS0) pin fpioa.get_Pin_num(fm.fpioa.GPIOHS0) if pin board_info.LED_G: print(\"set function ok\") ``` ## Appendix: Peripheral Table Peripheral Function (func) Brief Description JTAG_TCLK JTAG Test Clock JTAG_TDI JTAG Test Data In JTAG_TMS JTAG Test Mode Select JTAG_TDO JTAG Test Data Out SPI0_D0 SPI0 Data 0 SPI0_D1 SPI0 Data 1 SPI0_D2 SPI0 Data 2 SPI0_D3 SPI0 Data 3 SPI0_D4 SPI0 Data 4 SPI0_D5 SPI0 Data 5 SPI0_D6 SPI0 Data 6 SPI0_D7 SPI0 Data 7 SPI0_SS0 SPI0 Chip Select 0 SPI0_SS1 SPI0 Chip Select 1 SPI0_SS2 SPI0 Chip Select 2 SPI0_SS3 SPI0 Chip Select 3 SPI0_ARB SPI0 Arbitration SPI0_SCLK SPI0 Serial Clock UARTHS_RX UART High speed Receiver UARTHS_TX UART High speed Transmitter RESV6 Reserved function RESV7 Reserved function CLK_SPI1 Clock SPI1 CLK_I2C1 Clock I2C1 GPIOHS0 GPIO High speed 0 GPIOHS1 GPIO High speed 1 GPIOHS2 GPIO High speed 2 GPIOHS3 GPIO High speed 3 GPIOHS4 GPIO High speed 4 GPIOHS5 GPIO High speed 5 GPIOHS6 GPIO High speed 6 GPIOHS7 GPIO High speed 7 GPIOHS8 GPIO High speed 8 GPIOHS9 GPIO High speed 9 GPIOHS10 GPIO High speed 10 GPIOHS11 GPIO High speed 11 GPIOHS12 GPIO High speed 12 GPIOHS13 GPIO High speed 13 GPIOHS14 GPIO High speed 14 GPIOHS15 GPIO High speed 15 GPIOHS16 GPIO High speed 16 GPIOHS17 GPIO High speed 17 GPIOHS18 GPIO High speed 18 GPIOHS19 GPIO High speed 19 GPIOHS20 GPIO High speed 20 GPIOHS21 GPIO High speed 21 GPIOHS22 GPIO High speed 22 GPIOHS23 GPIO High speed 23 GPIOHS24 GPIO High speed 24 GPIOHS25 GPIO High speed 25 GPIOHS26 GPIO High speed 26 GPIOHS27 GPIO High speed 27 GPIOHS28 GPIO High speed 28 GPIOHS29 GPIO High speed 29 GPIOHS30 GPIO High speed 30 GPIOHS31 GPIO High speed 31 GPIO0 GPIO pin 0 GPIO1 GPIO pin 1 GPIO2 GPIO pin 2 GPIO3 GPIO pin 3 GPIO4 GPIO pin 4 GPIO5 GPIO pin 5 GPIO6 GPIO pin 6 GPIO7 GPIO pin 7 UART1_RX UART1 Receiver UART1_TX UART1 Transmitter UART2_RX UART2 Receiver UART2_TX UART2 Transmitter UART3_RX UART3 Receiver UART3_TX UART3 Transmitter SPI1_D0 SPI1 Data 0 SPI1_D1 SPI1 Data 1 SPI1_D2 SPI1 Data 2 SPI1_D3 SPI1 Data 3 SPI1_D4 SPI1 Data 4 SPI1_D5 SPI1 Data 5 SPI1_D6 SPI1 Data 6 SPI1_D7 SPI1 Data 7 SPI1_SS0 SPI1 Chip Select 0 SPI1_SS1 SPI1 Chip Select 1 SPI1_SS2 SPI1 Chip Select 2 SPI1_SS3 SPI1 Chip Select 3 SPI1_ARB SPI1 Arbitration SPI1_SCLK SPI1 Serial Clock SPI_SLAVE_D0 SPI Slave Data 0 SPI_SLAVE_SS SPI Slave Select SPI_SLAVE_SCLK SPI Slave Serial Clock I2S0_MCLK I2S0 Master Clock I2S0_SCLK I2S0 Serial Clock(BCLK) I2S0_WS I2S0 Word Select(LRCLK) I2S0_IN_D0 I2S0 Serial Data Input 0 I2S0_IN_D1 I2S0 Serial Data Input 1 I2S0_IN_D2 I2S0 Serial Data Input 2 I2S0_IN_D3 I2S0 Serial Data Input 3 I2S0_OUT_D0 I2S0 Serial Data Output 0 I2S0_OUT_D1 I2S0 Serial Data Output 1 I2S0_OUT_D2 I2S0 Serial Data Output 2 I2S0_OUT_D3 I2S0 Serial Data Output 3 I2S1_MCLK I2S1 Master Clock I2S1_SCLK I2S1 Serial Clock(BCLK) I2S1_WS I2S1 Word Select(LRCLK) I2S1_IN_D0 I2S1 Serial Data Input 0 I2S1_IN_D1 I2S1 Serial Data Input 1 I2S1_IN_D2 I2S1 Serial Data Input 2 I2S1_IN_D3 I2S1 Serial Data Input 3 I2S1_OUT_D0 I2S1 Serial Data Output 0 I2S1_OUT_D1 I2S1 Serial Data Output 1 I2S1_OUT_D2 I2S1 Serial Data Output 2 I2S1_OUT_D3 I2S1 Serial Data Output 3 I2S2_MCLK I2S2 Master Clock I2S2_SCLK I2S2 Serial Clock(BCLK) I2S2_WS I2S2 Word Select(LRCLK) I2S2_IN_D0 I2S2 Serial Data Input 0 I2S2_IN_D1 I2S2 Serial Data Input 1 I2S2_IN_D2 I2S2 Serial Data Input 2 I2S2_IN_D3 I2S2 Serial Data Input 3 I2S2_OUT_D0 I2S2 Serial Data Output 0 I2S2_OUT_D1 I2S2 Serial Data Output 1 I2S2_OUT_D2 I2S2 Serial Data Output 2 I2S2_OUT_D3 I2S2 Serial Data Output 3 RESV0 Reserved function RESV1 Reserved function RESV2 Reserved function RESV3 Reserved function RESV4 Reserved function RESV5 Reserved function I2C0_SCLK I2C0 Serial Clock I2C0_SDA I2C0 Serial Data I2C1_SCLK I2C1 Serial Clock I2C1_SDA I2C1 Serial Data I2C2_SCLK I2C2 Serial Clock I2C2_SDA I2C2 Serial Data CMOS_XCLK DVP System Clock CMOS_RST DVP System Reset CMOS_PWDN DVP Power Down Mode CMOS_VSYNC DVP Vertical Sync CMOS_HREF DVP Horizontal Reference output CMOS_PCLK Pixel Clock CMOS_D0 Data Bit 0 CMOS_D1 Data Bit 1 CMOS_D2 Data Bit 2 CMOS_D3 Data Bit 3 CMOS_D4 Data Bit 4 CMOS_D5 Data Bit 5 CMOS_D6 Data Bit 6 CMOS_D7 Data Bit 7 SCCB_SCLK SCCB Serial Clock SCCB_SDA SCCB Serial Data UART1_CTS UART1 Clear To Send UART1_DSR UART1 Data Set Ready UART1_DCD UART1 Data Carrier Detect UART1_RI UART1 Ring Indicator UART1_SIR_IN UART1 Serial Infrared Input UART1_DTR UART1 Data Terminal Ready UART1_RTS UART1 Request To Send UART1_OUT2 UART1 User designated Output 2 UART1_OUT1 UART1 User designated Output 1 UART1_SIR_OUT UART1 Serial Infrared Output UART1_BAUD UART1 Transmit Clock Output UART1_RE UART1 Receiver Output Enable UART1_DE UART1 Driver Output Enable UART1_RS485_EN UART1 RS485 Enable UART2_CTS UART2 Clear To Send UART2_DSR UART2 Data Set Ready UART2_DCD UART2 Data Carrier Detect UART2_RI UART2 Ring Indicator UART2_SIR_IN UART2 Serial Infrared Input UART2_DTR UART2 Data Terminal Ready UART2_RTS UART2 Request To Send UART2_OUT2 UART2 User designated Output 2 UART2_OUT1 UART2 User designated Output 1 UART2_SIR_OUT UART2 Serial Infrared Output UART2_BAUD UART2 Transmit Clock Output UART2_RE UART2 Receiver Output Enable UART2_DE UART2 Driver Output Enable UART2_RS485_EN UART2 RS485 Enable UART3_CTS UART3 Clear To Send UART3_DSR UART3 Data Set Ready UART3_DCD UART3 Data Carrier Detect UART3_RI UART3 Ring Indicator UART3_SIR_IN UART3 Serial Infrared Input UART3_DTR UART3 Data Terminal Ready UART3_RTS UART3 Request To Send UART3_OUT2 UART3 User designated Output 2 UART3_OUT1 UART3 User designated Output 1 UART3_SIR_OUT UART3 Serial Infrared Output UART3_BAUD UART3 Transmit Clock Output UART3_RE UART3 Receiver Output Enable UART3_DE UART3 Driver Output Enable UART3_RS485_EN UART3 RS485 Enable TIMER0_TOGGLE1 TIMER0 Toggle Output 1 TIMER0_TOGGLE2 TIMER0 Toggle Output 2 TIMER0_TOGGLE3 TIMER0 Toggle Output 3 TIMER0_TOGGLE4 TIMER0 Toggle Output 4 TIMER1_TOGGLE1 TIMER1 Toggle Output 1 TIMER1_TOGGLE2 TIMER1 Toggle Output 2 TIMER1_TOGGLE3 TIMER1 Toggle Output 3 TIMER1_TOGGLE4 TIMER1 Toggle Output 4 TIMER2_TOGGLE1 TIMER2 Toggle Output 1 TIMER2_TOGGLE2 TIMER2 Toggle Output 2 TIMER2_TOGGLE3 TIMER2 Toggle Output 3 TIMER2_TOGGLE4 TIMER2 Toggle Output 4 CLK_SPI2 Clock SPI2 CLK_I2C2 Clock I2C2 "},"/soft/maixpy/en/api_reference/Maix/freq.html":{"title":"Maix.freq","content":" title: Maix.freq keywords: maixpy, k210, AIOT, edge computing desc: maixpy Maix.freq Frequency module, support program to modify cpu and kpu frequency ## Method ### freq.set(cpu, pll1, kpu_div) Set cpu or kpu frequency, after setting it will automatically restart to take effect Please note that the performance of some peripherals may change after the frequency is set ```python from Maix import freq freq.set(cpu 400, pll1 400, kpu_div 1) ``` The configuration file will be saved in the file system `/flash/freq.conf`, please do not modify this file, if the file does not exist, it will be created automatically #### Parameters Parameters that are not set will retain their previous values **Note**: If the `cpu` frequency setting is less than `60MHz`, the default `REPL` serial port baud rate will be set to `9600` * `cpu`: The cpu frequency you want to set, the range is [26,600] (the chip is up to `800` but has voltage requirements. The series supported by `MaixPy` does not support up to `800`, the default is `400`, different boards May behave differently, not too high for stability * `pll1`: The output frequency of `pll1`, the value range is [26,1200] (the chip is up to 1800, MaixPy is limited to 1200), the default is `400` * `kpu_div`: `kpu` clock frequency division, value range [1,16], default `1`. `kpu` frequency `pll1`/`kpu_div`, for example, if you want to set the `kpu` frequency to `400`, you only need to set `pll1` to `400` and `kpu_div` to `1`. Note the `kpu` frequency range: [26,600] #### return value If the frequency has not changed, it returns to null. If the frequency changes, the machine will automatically restart. Before using this interface, please confirm whether the current situation can be restarted ### freq.get() Get the currently set frequency parameter #### return value `cpu` frequency and `kpu` frequency, returned as a tuple, such as `(400,400)` ### freq.get_cpu() Get the current frequency of `cpu` #### return value `cpu` frequency ### freq.get_kpu() Get the currently set `kpu` frequency #### return value Current `kpu` frequency"},"/soft/maixpy/en/api_reference/Maix/gpio.html":{"title":"GPIO","content":" title: GPIO keywords: maixpy, k210, AIOT, edge computing desc: maixpy GPIO General Purpose Input Output (General Purpose Input/Output) is abbreviated as GPIO, or bus extender. There are high speed GPIO (GPIOHS) and general purpose GPIO on K210 On K210, GPIO has the following characteristics: * High speed GPIO: The high speed GPIO is GPIOHS, 32 in total. It has the following characteristics: * Configurable input and output signals * Each IO has an independent interrupt source * Interrupt supports edge trigger and level trigger * Each IO can be assigned to one of the 48 pins on FPIOA * Configurable up and down * General GPIO: There are 8 general purpose GPIOs with the following characteristics: * 8 IOs use one interrupt source * Configurable input and output signals * Configurable trigger IO total interrupt, edge trigger and level trigger * Each IO can be assigned to one of the 48 pins on FPIOA **note**: The following GPIOHS has been used by default, try not to use it unless necessary in the program: GPIOHS Function GPIOHS31 LCD_DC GPIOHS30 LCD_RST GPIOHS29 SD_CS GPIOHS28 MIC_LED_CLK GPIOHS27 MIC_LED_DATA ## Constructor ```python class GPIO(ID, MODE, PULL, VALUE) ``` Create a new SPI object with the specified parameters ### Parameters * `ID`: the used GPIO pin (must use the constant in GPIO to specify) * `MODE`: GPIO mode • GPIO.IN is the input mode • GPIO.OUT is the output mode * `PULL`: GPIO pull up mode • GPIO.PULL_UP pull up ​• GPIO.PULL_DOWN pull down ​• GPIO.PULL_NONE neither pull up nor pull down ## Method ### value Modify/read GPIO pin status ```python GPIO.value([value]) ``` #### Parameters * `[value]`: Optional parameter, if this parameter is not empty, it returns the current GPIO pin status #### return value If the `[value]` parameter is not empty, return the current GPIO pin status ### irq Configure an interrupt handler to be called when the trigger source of `pin` is active. If the pin mode is pin.in, the trigger source is the external value on the pin. ```python GPIO.irq(CALLBACK_FUNC,TRIGGER_CONDITION,GPIO.WAKEUP_NOT_SUPPORT,PRORITY) ``` #### Parameters * `CALLBACK_FUNC`: Interrupt callback function, which is called when the interrupt is triggered, an entry function `pin_num` ​• PIN_NUM returns the GPIO pin number that triggered the interrupt (only GPIOHS supports interrupts, so the pin number here is also the pin number of GPIOHS) * `TRIGGER_CONDITION`: Interrupt trigger mode of GPIO pin ​• GPIO.IRQ_RISING rising edge trigger ​• GPIO.IRQ_FALLING falling edge trigger ​• GPIO.IRQ_BOTH triggers on both rising and falling edges #### return value no ### disirq Close interrupt ```python GPIO.disirq() ``` #### Parameters no #### return value no ### mode Set GPIO input and output mode ```python GPIO.mode(MODE) ``` #### Parameters * MODE • `GPIO.IN` input mode • `GPIO.PULL_UP` pull up input mode • `GPIO.PULL_DOWN` pull down input mode • `GPIO.OUT` output mode #### return value no ## Constant * `GPIO0`: GPIO0 * `GPIO1`: GPIO1 * `GPIO2`: GPIO2 * `GPIO3`: GPIO3 * `GPIO4`: GPIO4 * `GPIO5`: GPIO5 * `GPIO6`: GPIO6 * `GPIO7`: GPIO7 * `GPIOHS0`: GPIOHS0 * `GPIOHS1`: GPIOHS1 * `GPIOHS2`: GPIOHS2 * `GPIOHS3`: GPIOHS3 * `GPIOHS4`: GPIOHS4 * `GPIOHS5`: GPIOHS5 * `GPIOHS6`: GPIOHS6 * `GPIOHS7`: GPIOHS7 * `GPIOHS8`: GPIOHS8 * `GPIOHS9`: GPIOHS9 * `GPIOHS10`: GPIOHS10 * `GPIOHS11`: GPIOHS11 * `GPIOHS12`: GPIOHS12 * `GPIOHS13`: GPIOHS13 * `GPIOHS14`: GPIOHS14 * `GPIOHS15`: GPIOHS15 * `GPIOHS16`: GPIOHS16 * `GPIOHS17`: GPIOHS17 * `GPIOHS18`: GPIOHS18 * `GPIOHS19`: GPIOHS19 * `GPIOHS20`: GPIOHS20 * `GPIOHS21`: GPIOHS21 * `GPIOHS22`: GPIOHS22 * `GPIOHS23`: GPIOHS23 * `GPIOHS24`: GPIOHS24 * `GPIOHS25`: GPIOHS25 * `GPIOHS26`: GPIOHS26 * `GPIOHS27`: GPIOHS27 * `GPIOHS28`: GPIOHS28 * `GPIOHS29`: GPIOHS29 * `GPIOHS30`: GPIOHS30 * `GPIOHS31`: GPIOHS31 * `GPIO.IN`: input mode * `GPIO.OUT`: output mode * `GPIO.PULL_UP`: pull up * `GPIO.PULL_DOWN`: pull down * `GPIO.PULL_NONE`: neither pull up nor pull down * `GPIO.IRQ_RISING`: rising edge trigger * `GPIO.IRQ_FALLING`: falling edge trigger * `GPIO.IRQ_BOTH`: trigger on both rising and falling edges ### DEMO1: Turn on the LED > `board_info` is related to the board, and different board configurations are different. [Manual configuration](../builtin_py/board_info.html) is required before use. ```python import utime from Maix import GPIO from board import board_info from fpioa_manager import fm fm.register(board_info.LED_R,fm.fpioa.GPIO0) led_r GPIO(GPIO.GPIO0,GPIO.OUT) utime.sleep_ms(500) led_r.value() fm.unregister(board_info.LED_R) ``` ### DEMO2: Press the button to light up the LED > `board_info` is related to the board, and different board configurations are different. [Manual configuration](../builtin_py/board_info.html) is required before use. ```python import utime from Maix import GPIO from board import board_info from fpioa_manager import fm fm.register(board_info.LED_R,fm.fpioa.GPIO0) led_b GPIO(GPIO.GPIO0,GPIO.OUT) led_b.value(1) fm.register(board_info.BOOT_KEY, fm.fpioa.GPIOHS1) key GPIO(GPIO.GPIOHS1, GPIO.IN) utime.sleep_ms(100) while True: if key.value() 0: # Wait for the button to be pressed led_b.value(0) utime.sleep_ms(1000) break utime.sleep_ms(10) led_b.value(1) fm.unregister(board_info.LED_R) fm.unregister(board_info.BOOT_KEY) ``` ### DEMO3: Wait for the key to trigger an interrupt within 3 seconds > `board_info` is related to the board, and different board configurations are different. [Manual configuration](../builtin_py/board_info.html) is required before use. ```python import utime from Maix import GPIO from board import board_info from fpioa_manager import fm def test_irq(pin_num): print(\"key\", pin_num, \"\\n\") fm.register(board_info.BOOT_KEY, fm.fpioa.GPIOHS0) key GPIO(GPIO.GPIOHS0, GPIO.IN, GPIO.PULL_NONE) utime.sleep_ms(100) key.irq(test_irq, GPIO.IRQ_BOTH, GPIO.WAKEUP_NOT_SUPPORT,7) utime.sleep_ms(3000) # Wait for the trigger within 3 seconds key.disirq() # Disable interrupt fm.unregister(board_info.BOOT_KEY) ```"},"/soft/maixpy/en/api_reference/Maix/kpu.html":{"title":"KPU","content":" title: KPU keywords: maixpy, k210, AIOT, edge computing desc: maixpy KPU KPU is a general purpose neural network processor, which can realize convolutional neural network calculations with low power consumption, obtain the size, coordinates, and types of detected objects from time to time, and detect and classify faces or objects. * KPU has the following characteristics: * Support fixed point models trained by mainstream training frameworks according to specific restriction rules * There is no direct limit on the number of network layers, and each layer of convolutional neural network parameters can be configured separately, including the number of input and output channels, input and output row width and column height * Support two convolution kernels 1x1 and 3x3 * Support any form of activation function * When working in real time, the maximum supported neural network parameter size is 5.5MiB to 5.9MiB * The maximum supported network parameter size during non real time work is (Flash capacity software volume) ## Routine ### Run face detection Model download address: [http://dl.sipeed.com/MAIX/MaixPy/model](http://dl.sipeed.com/MAIX/MaixPy/model), download `face_model_at_0x300000.kfpkg` Complete example: [face_find](https://github.com/sipeed/MaixPy v1_scripts/tree/master/machine_vision/face_find) ### Running feature map Model download address: [http://dl.sipeed.com/MAIX/MaixPy/model](http://dl.sipeed.com/MAIX/MaixPy/model), download `face_model_at_0x300000.kfpkg` The model is an 8bit fixed point model, about 380KB in size, the layer information is: ``` 1 2 :160x120 3 4 5 6 :80x60 7 8 9 10: 40x30 11~16 :20x15 ``` ```python import sensor import image import lcd import KPU as kpu index 3 lcd.init() sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) task kpu.load(0x300000) img image.Image() info kpu.netinfo(task) layer info[index] w layer.wo() h layer.ho() num int(320*240/w/h) list [None]*num x_step int(320/w) y_step int(240/h) img_lcd image.Image() while True: img sensor.snapshot() fmap kpu.forward(task,img,index) for i in range(0,num): list[i] kpu.fmap(fmap,i) for i in range(0,num): list[i].stretch(64,255) for i in range(0,num): a img_lcd.draw_image(list[i],((i%x_step)*w,(int(i/x_step))*h)) lcd.display(img_lcd) kpu.fmap_free(fmap) ``` ## Module method ### load Load model from flash or file system ```python KPU.load(offset, file_path) ``` #### Parameters The `offset` and `file_path` parameters can only choose one of the two, no keywords are required, just pass the parameters directly * `offset`: the offset size of the model in the flash. For example, `0xd00000` means the model is burned at the beginning of 13M, and `0x300000` means at the place of `Flash` and `3M` * `file_path`: The model is the file name in the file system, such as `“/sd/xxx.kmodel”` ##### Return If it is loaded correctly, the return value will be returned, otherwise an error will be thrown. Please see the error message thrown. In addition, please refer to [here](https://github.com/sipeed/MaixPy v1/blob/fa3cf2c96353fa698e9386e42be8b3c9cf495114/components/kendryte_sdk/include/sipeed_kpu.h#L6 L23) If the error code is found to be less than the value of `2000`, the firmware version is too low, and the firmware version needs to be updated * `kpu_net`: kpu network object ### load_flash Same function as load method, ```python kpu.load_flash(model_addr, is_dual_buf, batch_size, spi_speed) ``` #### Parameters * `model_addr`: Flash addr's preprocessed model burned to the offset address in flash. Note that the model file [description](https://github.com/sipeed/MaixPy v1_scripts/blob/master/machine_vision/load_big_model/README_ZH.md) needs to be preprocessed here. * `is_dual_buf`: `0`, single buffer loading, using less RAM and slower speed to dynamically load the model file; `1`, enabling double buffer loading, requires larger RAM, and running speed is relatively fast . * `batch_size`: When setting `is_dual_buf` to 1, load batch_size needs to be set. The recommended value is `0x4000~0x10000`, which can test the best value of the model. If `is_dual_buf` is 0 then set to 0 * `spi_speed`: When using SPI flash to load the model file, we will temporarily set the flash to high speed mode and set the required spi clock frequency. The value should be < 80000000 (the actual frequency, the set value may not be equal to the actual frequency.) #### return value * `kpu_net`: kpu network object ### init_yolo2 Pass in initialization parameters for the `yolo2` network model, only used when `yolo2` is used ```python KPU.init_yolo2(kpu_net, threshold, nms_value, anchor_num, anchor) ``` such as: ```python import KPU as kpu task kpu.load(0x300000) anchor (1.889, 2.5245, 2.9465, 3.94056, 3.99987, 5.3658, 5.155437, 6.92275, 6.718375, 9.01025) kpu.init_yolo2(task, 0.5, 0.3, 5, anchor) ``` #### Parameters * `kpu_net`: kpu network object, that is, the loaded model object, the return value of `KPU.load()` * `threshold`: Probability threshold, only if the probability of this object is greater than this value will the output result, value range: [0, 1] * `nms_value`: box_iou threshold, in order to prevent the same object from being framed in multiple boxes, when two boxes are framed on the same object, the intersection area of ​​the two boxes accounts for the proportion of the total occupied area of ​​the two boxes. When it is less than this value, take the box with the highest probability * `anchor_num`: the number of anchor points, fixed here as `len(anchors)//2` * `anchor`: The anchor point parameters are consistent with the model parameters. This parameter of the same model is fixed and bound to the model (it is determined when the model is trained) and cannot be changed to other values. #### return value * `success`: `bool` type, success ### deinit Release the memory occupied by the model and release it immediately, but the variables are still there, you can use the way of `del kpu_net_object` to delete, In addition, you can also just use `del kpu_net_object` to mark that the object has been deleted. The next time `GC` performs memory collection or manually calls `gc.collect()`, the memory will be automatically released ```python KPU.deinit(kpu_net) ``` such as: ```python import KPU as kpu import gc task kpu.load(0x300000) kpu.deinit(task) del task gc.collect() ``` or: ```python import KPU as kpu import gc task kpu.load(0x300000) del task gc.collect() ``` #### Parameters `kpu_net`: `kpu_net` object returned by `KPU.load()` #### return value * `success`: `bool` type, success ### run_yolo2 ```python import KPU as kpu import image task kpu.load(offset or file_path) anchor (1.889, 2.5245, 2.9465, 3.94056, 3.99987, 5.3658, 5.155437, 6.92275, 6.718375, 9.01025) kpu.init_yolo2(task, 0.5, 0.3, 5, anchor) img image.Image() kpu.run_yolo2(task, img) #This is wrong, please refer to the routine ``` #### Parameters * `kpu_net`: kpu_net object returned by kpu_load * `image_t`: the image collected from the sensor ##### Return * `list`: list of kpu_yolo2_find ### forward Calculate the loaded network model to the specified number of layers, and output the feature map of the target layer ```python fmap KPU.forward(kpu_net, img, end_layer) ``` ```python import KPU as kpu task kpu.load(offset or file_path) ... fmap kpu.forward(task,img, 3) ``` #### Parameters * `kpu_net`: kpu_net object * `img`: image `image.Image` object * `end_layer`: Specify which layer is calculated to the network, the value starts from `0` ##### Return * `fmap`: Feature map object, containing feature maps of all channels in the current layer ### fmap Take the specified channel data of the feature map to the `image.Image` object ```python img KPU.fmap(fmap, channel) ``` #### Parameters * `fmap`: Feature map object * `channel`: Specify the channel number of the feature map, starting from `0` ##### Return * `img`: The grayscale image generated by the feature image corresponding to the channel, type `image.Image` ### fmap_free Release feature map object ```python KPU.fmap_free(fmap) ``` #### Parameters * `fmap`: Feature map object ##### Return * None ### netinfo Get the network structure information of the model ```python info_list kpu.netinfo(task) ``` #### Parameters * `kpu_net`: kpu_net object, `KPU.load()` return value ##### Return * `info_list`: information list of all layers, including information: * `index`: the number of the current layer in the network * `wi`: input width * `hi`: input height * `wo`: output width * `ho`: output height * `chi`: Number of input channels * `cho`: Number of output channels * `dw`: Whether it is a depth wise layer * `kernel_type`: Convolution kernel type, 0 is 1x1, 1 is 3x3 * `pool_type`: Pooling type, 0 no pooling; 1: 2x2 max pooling; 2:... * `para_size`: the number of bytes of the convolution parameter of the current layer ### set_outputs ```python success set_outputs(kput_net, out_idx, width, height, channel) ``` Manually set the shape of the output layer. For the V4 kmodel model converted from nncase v0.2.0, After `load`, you need to call this function to manually set the output layer shape, V3 model does not need #### Parameters * `kpu_net`: kpu_net object * `out_idx`: The following table of the output layer, starting from `0`, for example, the first output layer is `0` * `width`: layer width, if it is a one dimensional output, it is `1` * `height`: layer height, if it is a one dimensional output, it is `1` * `channnel`: The number of layer channels, if it is a one dimensional output, then here is the length of the one dimensional output ##### Return * `success`: Whether the setting is successful, if not, please pay attention to the output prompt information, refer to [error code](https://github.com/sipeed/MaixPy v1/blob/fa3cf2c96353fa698e9386e42be8b3c9cf495114/components/kendryte_sdk/include/sipeed_kpu.h#L6 L23) ### memtest Print memory usage, including `GC` memory and system heap memory * Note that executing this function will automatically execute `gc.collect()` to collect memory once, and then print the remaining memory of `GC` * The system heap memory is for reference only and may not be accurate. Sometimes it may appear that the memory has been released, but the display is still not released. The actual memory can be allocated to prevail. ```python KPU.memtest() ``` ### face_encode Quantify the feature map returned by `forward`. For more details, please see: [kpu issue](https://github.com/sipeed/MaixPy v1issues/342) ```python feature kpu.face_encode(fmap[:]) ``` #### Parameters `fmap[:]`: `list` type, convert the return value of the `forward` function into a list #### return value `feature`: `list` type, quantified list ### face_compare Compare the quantized value returned by face_encode with the entered face ```python score kpu.face_compare(record_ftrs[j], feature) ``` #### Parameters `record_ftrs[j] `: `list` type, with recorded face data `feature`: `list` type, face data to be compared, return value of `face_encode` #### return value `score`: `int` type, compare score (0~100), the higher the score, the greater the similarity"},"/soft/maixpy/en/api_reference/standard/uerrno.html":{"title":"uerrno — system error code","content":" title: uerrno — system error code keywords: maixpy, k210, AIOT, edge computing desc: maixpy uerrno — system error code This module implements a subset of the corresponding CPython module, as described below. For more information, please refer to the original CPython documentation: [errno](https://docs.python.org/3.5/library/errno.html#module errno). This module describes the error identifier of the `OSError` error. The specific code inventory depends on `Micropython porting`, and the error will be explained in the specific error function. ## Constant ### EEXIST, EAGAIN, etc. Error codes based on ANSI C / POSIX standards. All error codes begin with \"E\". As mentioned above, the code inventory depends on the port of MicroPython. Errors can usually be accessed as `exc.args[0]`, where `exc` is an instance of `OSError`. Example usage: ```python try: uos.mkdir(\"my_dir\") except OSError as exc: if exc.args[0] uerrno.EEXIST: print(\"Directory already exists\") ``` ### uerrno.errorcode The dictionary maps numeric error codes to strings with signed error codes (see above): ```python >>> print(uerrno.errorcode[uerrno.EEXIST]) EEXIST ```"},"/soft/maixpy/en/api_reference/standard/sys.html":{"title":"sys-system specific functions","content":" title: sys system specific functions keywords: maixpy, k210, AIOT, edge computing desc: maixpy sys system specific functions This module implements a subset of the corresponding CPython module, as described below. For more information, please refer to the original CPython documentation: [sys](https://docs.python.org/3.5/library/sys.html#module sys). ## Function ### sys.exit(retval 0) Terminate the current program with the given exit code. According to this, this function raises the \"SystemExit\" exception. If a parameter is given, its value is given as the parameter of `SystemExit`. ### sys.print_exception(exc, file sys.stdout) Use traceback to file like object files (or `sys.stdout` by default) to print exceptions. > **Difference from CPython** > This is a simplified version of a function that appears in the backtracking module of CPython. Unlike traceback.print_exception(), this function only accepts outliers instead of exception types, outliers and traceback objects; the file parameter should be positional; other parameters are not supported. A traceback module compatible with CPython can be found in micropython lib. ## Constant ### sys.argv The variable parameter list when the current program is started. ### sys.byteorder The byte order of the system (\"little endian\" or \"big endian\"`). ### sys.implementation An object containing information about the current Python implementation. For MicroPython, it has the following attributes: * name the string \"micropython\" * version tuple (major, minor, micro), e.g. (1, 7, 0) This object is the recommended way to distinguish MicroPython from other Python implementations (note that it may still not exist in very small ports). > **Difference from CPython** > CPython requires more attributes for this object, but the minimum requirement to actually be useful is implemented in MicroPython. ### sys.maxsize The maximum value that the native integer type can save on the current platform, or the maximum value that the MicroPython integer type can represent, if it is less than the platform maximum value (for the MicroPython port without long int support). This attribute is very useful for detecting the \"bitness\" of the platform (32 bit and 64 bit, etc.). It is recommended not to directly compare this attribute with a value, but to calculate the number of digits: ```python bits 0 v sys.maxsize while v: bits + 1 v >> 1 if bits> 32: # 64 bit (or more) platform ... else: # 32 bit (or less) platform # Note that on 32 bit platform, value of bits may be less than 32 # (e.g. 31) due to peculiarities described above, so use \"> 16\", # \"> 32\", \"> 64\" style of comparisons. ``` ### sys.modules Load the dictionary of the module. On some ports, it may not contain built in modules. ### sys.path A variable directory list for searching imported modules. ### sys.platform The platform on which MicroPython is running. For OS/RTOS ports, this is usually the identifier of the OS, for example, `\"LINUX\"`. For bare metal ports, it is the identifier of the circuit board, such as `\"pyboard\"` for the original MicroPython reference board. Therefore, it can be used to distinguish one board from another. If you need to check whether your program is running on MicroPython (compared to other Python implementations), please use `sys.implementation`. ### sys.stderr Standard error `stream`. ### sys.stdin Standard input `stream`. ### sys.stdout Standard output `stream`. ### sys.version The implemented Python version, returns a string ### sys.version_info The implemented Python version, which returns a tuple of integers"},"/soft/maixpy/en/api_reference/standard/uzlib.html":{"title":"uzlib — zlib decompression","content":" title: uzlib — zlib decompression keywords: maixpy, k210, AIOT, edge computing desc: maixpy uzlib — zlib decompression This module implements a subset of the corresponding CPython module, as described below. For more information, please refer to the original CPython documentation: [zlib](https://docs.python.org/3.5/library/zlib.html#module zlib). This module allows to decompress binary data compressed using the [DEFLATE](https://en.wikipedia.org/wiki/DEFLATE) algorithm (usually used in the zlib library and gzip archiver). Compression has not yet been implemented. ## Function ### decompress Unzip ```python uzlib.decompress(data, wbits 0, bufsize 0) ``` #### Parameters * `wbits`: DEFLATE dictionary window size used during compression (8 15, dictionary size is a power of 2 of this value). In addition, if the value is positive, the data is assumed to be a zlib stream (using the zlib header). Otherwise, if it is negative, it is assumed to be the original DEFLATE stream. * `bufsize`: The parameter is used for compatibility with CPython and can be ignored. #### return value Return the decompressed data as `bytes` type. ### DecompIO Create a stream wrapper that allows transparent decompression of compressed data in another stream. This allows processing of compressed streams with data larger than the available heap size. In addition to the values ​​described in decompress(), `wbits` can take the value 24..31 (16+8..15), which means that the input stream has a gzip header. ```python class uzlib.DecompIO(stream, wbits 0) ``` ## Difference from CPython This class is a MicroPython extension. It is included on a temporary basis and may be changed or deleted extensively in future versions."},"/soft/maixpy/en/api_reference/standard/uheapq.html":{"title":"uheapq-heap queue algorithm","content":" title: uheapq heap queue algorithm keywords: maixpy, k210, AIOT, edge computing desc: maixpy uheapq heap queue algorithm This module implements a subset of the corresponding CPython module, as described below.For more information, please refer to the original CPython documentation: [heapq](https://docs.python.org/3.5/library/heapq.html#module heapq). This module implements the heap queue algorithm. A heap queue is just a list that stores its elements in some way. ## Function ### heappush ```python uheapq.heappush(heap, item) ``` Put elements into the heap. ### heappop ```python uheapq.heappop(heap) ``` Pop the first element in the heap and return it.If the heap is empty, an `IndexError` is raised. ### heapify ```python uheapq.heapify(x) ``` Convert the list x to a heap.This is an in place (division exchange sort) operation."},"/soft/maixpy/en/api_reference/standard/usocket.html":{"title":"usocket – socket module","content":" title: usocket – socket module keywords: maixpy, k210, AIOT, edge computing desc: maixpy usocket socket module This module implements a subset of the corresponding CPython module, as described below. For more information, please refer to the original CPython documentation: [socket](https://docs.python.org/3.5/library/socket.html#module socket). This module provides access to the BSD socket interface > **Difference from CPython** > In order to improve efficiency and consistency, the socket object in MicroPython directly implements the `stream` (class file) interface. In CPython, you need to use the `makefile()` method to convert the socket into a file like object. MicroPython still supports this method (but no operation), so if it is compatible with CPython, be sure to use it. ## Socket address format The native socket address format of the `usocket` module is the opaque data type returned by the getaddrinfo function, which must be used to parse text addresses (including numeric addresses): ```python sockaddr usocket.getaddrinfo('www.micropython.org', 80)[0][ 1] # You must use getaddrinfo() even for numeric addresses sockaddr usocket.getaddrinfo('127.0.0.1', 80)[0][ 1] # Now you can use that address sock.connect(addr) ``` Using `getaddrinfo` is the most effective (in terms of memory and processing power), and it is also a portable way to use addresses. However, the `socket` module (note the difference from the native MicroPython `usocket` module described here) provides a CPython compatible way to specify addresses using tuples, as described below. Please note that depending on the `MicroPython port`, the socket module can be built in or needs to be installed from `micropython lib` (as in the case of \"MicroPython Unix port\"), and some ports still only accept numeric addresses in tuples Format and requires the use of the `getaddrinfo` function to resolve the domain name. In general: * Always use `getaddrinfo` when writing portable applications. * If your port supports fast hacking and interactive use, the tuple address described below can be used as a shortcut. The tuple address format of the `socket` module: * IPv4: (ipv4_address, port), where ipv4_address is a string with a dotted number IPv4 address, for example, \"8.8.8.8\", the port number and integer port number are in the range of 1 65535. Please note that domain names are not accepted as ipv4_address, they should be resolved first using usocket.getaddrinfo(). * IPv6: (ipv6_address, port, flowinfo, scopeid), where ipv6_address is a string with a colon number IPv6 address, for example: `\"2001:db8::1\"`, port is an integer port number in the range of 1 65535. flowinfo must be 0. scopeid is the interface scope identifier of the link local address. Please note that domain names are not accepted as ipv6_address, they should be resolved using `usocket.getaddrinfo()` first. The availability of IPv6 support depends on the `MicroPython port`. ## Method ### usocket.socket(af AF_INET, type SOCK_STREAM, proto IPPROTO_TCP) Create a new socket using the given address series, socket type and protocol number. Please note that in most cases there is no need to specify proto (not recommended because some MicroPython ports may omit the `IPPROTO_ *` constants). Instead, the type parameter will automatically select the required protocol: ```python # Create STREAM TCP socket socket(AF_INET, SOCK_STREAM) # Create DGRAM UDP socket socket(AF_INET, SOCK_DGRAM) ``` ### usocket.getaddrinfo(host, port, af 0, type 0, proto 0, flags 0) Convert the host / port parameter to a 5 tuple sequence, which contains all the necessary parameters for creating a socket to connect to the service. The parameters af, type and proto (which have the same meaning as the `socket()` function) can be used to filter which address is returned. If the parameter is not specified or is zero, all address combinations can be returned (requires filtering on the user side). The resulting 5 tuple list has the following structure: ```python (family, type, proto, canonname, sockaddr) ``` The following example shows how to connect to a given URL: ```python s usocket.socket() # This assumes that if \"type\" is not specified, an address for # SOCK_STREAM will be returned, which may be not true s.connect(usocket.getaddrinfo('www.micropython.org', 80)[0][ 1]) ``` It is recommended to use filter parameters: ```python s usocket.socket() # Guaranteed to return an address which can be connect'ed to for # stream operation. s.connect(usocket.getaddrinfo('www.micropython.org', 80, 0, SOCK_STREAM)[0][ 1]) ``` > Difference with CPython > If this function fails, CPython will raise a `socket.gaierror` exception (subclass of `OSError`). MicroPython does not have `socket.gaierror` and directly raises OSError. Please note that the error number of `getaddrinfo()` forms a separate namespace and may not match the error number in the `uerrno` module. In order to distinguish `getaddrinfo()` errors, they are represented by negative numbers, while standard system errors are positive numbers (the error number can be accessed using the `e.args[0]` attribute from the exception object). The use of negative values ​​is a temporary detail and may change in the future. ### usocket.inet_ntop(af, bin_addr) Convert the binary network address bin_addr of a given address family af into a text representation: ```python >>> usocket.inet_ntop(usocket.AF_INET, b\"\\x7f\\0\\0\\1\") '127.0.0.1' ``` ### usocket.inet_pton(af, txt_addr) Convert the text network address txt_addr of a given address family af into binary representation: ```python >>> usocket.inet_pton(usocket.AF_INET, \"1.2.3.4\") b'\\x01\\x02\\x03\\x04' ``` ## Constant ### usocket.AF_INET usocket.AF_INET6 Address family types. Availability depends on the specific `MicroPython port`. ### usocket.SOCK_STREAM usocket.SOCK_DGRAM The socket type. ### usocket.IPPROTO_UDP usocket.IPPROTO_TCP IP protocol number. Availability depends on the specific `MicroPython port`. Note that you do not need to specify them when calling `usocket.socket()`, because `SOCK_STREAM` socket type will automatically select `IPPROTO_TCP` and `SOCK_DGRAM` `IPPROTO_UDP`. Therefore, the only practical use of these constants is as a parameter to `setsockopt()`. ### usocket.SOL_* Socket option level (parameter of `setsockopt()`). The exact inventory depends on the `MicroPython port`. ### usocket.SO_* Socket options (parameters of `setsockopt()`). The exact inventory depends on the `MicroPython port`. ## Class socket ### Method #### socket.close() Mark that the socket is closed and release all resources. Once this happens, all future operations on the socket object will fail. If the protocol supports it, the remote end will receive the EOF indication. Sockets are automatically closed when they are garbage collected, but it is recommended that you \"close\" them immediately after finishing them. #### (maixpy ​​not implemented) socket.bind(address) Bind the socket to the address. The socket must not be bound. #### (maixpy ​​not implemented) socket.listen([backlog]) Make the server accept connections. If backlog is specified, it must be at least 0 (if low, set it to 0); and specify the number of unaccepted connections that the system will allow before rejecting new connections. If not specified, the default reasonable value is selected. #### (maixpy ​​not implemented) socket.accept() Accept the connection. The socket must be bound to an address and listen for connections. The return value is a pair (conn, address), where conn is a new socket object that can be used to send and receive data on the connection, and address is the address of the socket bound to the other end of the connection. #### socket.connect(address) Connect to the remote socket at the address. #### socket.send(bytes) Send data to the socket. The socket must be connected to the remote socket. Returns the number of bytes sent, which may be less than the data length (\"short write\"). #### socket.sendall(bytes) Send all data to the socket. The socket must be connected to the remote socket. Unlike `send()`, this method will try to send all data by continuously sending data blocks. The behavior of this method on non blocking sockets is undefined. Therefore, on MicroPython, it is recommended to use the `write()` method, which has the same \"no short write\" strategy to block the socket and will return the number of bytes sent on the non blocking socket. #### socket.recv(bufsize) Receive data from the socket. The return value is a byte object representing the received data. The maximum amount of data received at one time is specified by bufsize. #### socket.sendto(bytes, address) Send data to the socket. The socket should not be connected to the remote socket, because the target socket is specified by the address. #### socket.recvfrom(bufsize) Receive data from the socket. The return value is a pair (byte, address), where bytes is the byte object representing the received data, and address is the address of the socket that sends the data. #### socket.setsockopt(level, optname, value) Set the value of the given socket option. The required symbolic constants are defined in the socket module (SO_* etc.). The value can be an integer or a byte like object representing a buffer. #### socket.settimeout(value) Note: Not every port supports this method, see below. Prevent socket operations from setting timeouts. The value parameter can be a non negative floating point number representing seconds, or it can be None. If a non zero value is given, if the timeout value has elapsed before the operation is completed, subsequent socket operations will raise an \"OSError\" exception. If zero is given, the socket is in non blocking mode. If None is given, the socket is in blocking mode. Not every \"MicroPython port\" supports this method. A more portable and universal solution is to use the uselect.poll object. This allows multiple objects to be waited at the same time (not just on sockets, but on generic `stream` objects that support polling). example: ```python # Instead of: s.settimeout(1.0) # time in seconds s.read(10) # may timeout # Use: poller uselect.poll() poller.register(s, uselect.POLLIN) res poller.poll(1000) # time in milliseconds if not res: # s is still not ready for input, i.e. operation timed out ``` > Difference with CPython > CPython raises `socket.timeout` exception in case of timeout, which is a subclass of OSError. MicroPython directly raises an `OSError`. If you use `except OSError`: to catch exceptions, your code will be valid in both MicroPython and CPython. #### socket.setblocking(flag) Set the blocking or non blocking mode of the socket: if the flag is false, the socket is set to non blocking, otherwise it is set to blocking mode. This method is shorthand for certain `settimeout()` calls: `sock.setblocking(True)` is equivalent to `sock.settimeout(None)` `sock.setblocking(False)` i is equivalent to `sock.settimeout(0)` #### socket.makefile(mode 'rb', buffering 0) Returns the file object associated with the socket. The exact return type depends on the parameters given to makefile(). Support is limited to binary mode ('rb','wb' and'rwb'). CPython parameters: encoding, errors and newlines are not supported. > Difference with CPython > Since MicroPython does not support buffered streams, the value of the buffer parameter is ignored and treated as 0 (unbuffered). > Difference with CPython > Closing the file object returned by makefile() will also close the original socket. #### socket.read([size]) Read the size bytes from the slot. Return a bytes object. If no size is given, it will read all the data available in the socket until EOF; therefore, the method will not return until the socket is closed. This function attempts to read the requested data (there is no \"short read\"). However, for non blocking sockets, this may not be possible, and then less data will be returned. #### socket.readinto(buf[, nbytes]) Read bytes into buf. If nbytes is specified, at most multiple bytes are read. Otherwise, read at most len ​​(buf) bytes. Just like read(), this method follows the \"no short read\" strategy. Return value: The number of bytes read and stored in buf. #### socket.readline() Read a line, ending with a newline character. Return value: the row read. #### socket.write(buf) Write the byte buffer to the socket. This function will try to write all data to the socket (no \"short write\"). However, for non blocking sockets, this may not be possible, and the return value will be less than the length of buf. Return value: The number of bytes written. #### exception usocket.error MicroPython does not have this exception. > Difference with CPython > CPython used to have a `socket.error` exception and is now deprecated. It is an alias of `OSError`. In MicroPython, use `OSError` directly. ## Routine ### Example 1: Download the picture and display it > Note the need to set WiFi SSID and password ```python import socket import network import gc import os import lcd, image fm.register(board_info.WIFI_RX,fm.fpioa.UART2_TX) fm.register(board_info.WIFI_TX,fm.fpioa.UART2_RX) uart machine.UART(machine.UART.UART2,115200,timeout 1000, read_buf_len 4096) nic network.ESP8285(uart) nic.connect(\"Sipeed_2.4G\",\" \") sock socket.socket() addr socket.getaddrinfo(\"dl.sipeed.com\", 80)[0][ 1] sock.connect(addr) sock.send('''GET /MAIX/MaixPy/assets/Alice.bmp HTTP/1.1 Host: dl.sipeed.com cache control: no cache ''') img b\"\" sock.settimeout(5) while True: data sock.recv(4096) if len(data) 0: break print(\"rcv:\", len(data)) img img + data print(len(img)) img img[img.find(b\"\\r\\n\\r\\n\")+4:] print(len(img)) print(\"save to /sd/Alice.bmp\") f open(\"/sd/Alice.bmp\",\"wb\") f.write(img) f.close() print(\"save ok\") print(\"display\") img image.Image(\"/sd/Alice.bmp\") lcd.init() lcd.display(img) ``` ### Example 2: Sending pictures ```python import os import socket import network import gc fm.register(board_info.WIFI_RX,fm.fpioa.UART2_TX) fm.register(board_info.WIFI_TX,fm.fpioa.UART2_RX) uart machine.UART(machine.UART.UART2,115200,timeout 1000, read_buf_len 4096) nic network.ESP8285(uart) nic.connect(\"Sipeed_2.4G\",\" \") addr (\"192.168.0.183\", 3456) sock socket.socket() sock.connect(addr) sock.settimeout(5) f open(\"/sd/Alice.bmp\",\"rb\") while True: img f.read(2048) if not img or (len(img) 0): break sock.send(img) f.close() sock.close() ```"},"/soft/maixpy/en/api_reference/standard/ure.html":{"title":"ure-simple regular expression","content":" title: ure simple regular expression keywords: maixpy, k210, AIOT, edge computing desc: maixpy ure simple regular expression This module implements a subset of the corresponding CPython module, as described below. For more information, please refer to the original CPython documentation: [re](https://docs.python.org/3.5/library/re.html#module re). This module implements regular expression operations. The supported regular expression syntax is a subset of the CPython `re` module (actually a subset of POSIX extended regular expressions). ## Supported operators and special sequences * `.`: matches any character. * `[...]`: Match character set. Single characters and ranges are supported, including negative sets (eg `[^ a c]`). * `^`: Match the beginning of the string. * `$`: match the end of the string. * `?`: Match zero or one of the previous subpatterns. * `*`: Match zero or more of the previous subpattern. * `+`: Match one or more of the previous subpatterns. * `??`: The non greedy version of `? `, matches zero or one, and the preference is zero. * `*?`: A non greedy version of `*`, matching zero or more, preferring the shortest match. * `+?`: Non greedy \"+\" version, matching one or more, first matching the shortest. * ``: Match the left or right sub pattern of this operator. * `(...)`: grouping. Each group is capturing (the substring it captures can be accessed using the `match.group() method). * `\\d`: match numbers. Equivalent to `[0 9]`. * `\\D`: match non digits. Equivalent to `[^ 0 9]`. * `\\s`: * `\\S`: matches whitespace. Equivalent to `[^ \\t \\r]`. * `\\w`: ​​match \"word characters\" (ASCII only). Equivalent to `[A Za z0 9_]`. * `\\W`: match non \"word characters\" (ASCII only). Equivalent to `[^A Za z0 9_]`. * `\\`: escape character. Except for those listed above, any other characters after the backslash are literal. For example, `\\*` is equivalent to the literal `*` (not considered as the `*` operator). Please note that `\\r`, `\\n,`, etc. are not specially processed, and are equivalent to the text letters `r`, `n`, etc. Therefore, it is not recommended to use raw Python strings (`r\"\"`) for regular expressions. For example, `r\"\\r \\n\"` is equivalent to `\"rn\"` when used as a regular expression. To match the characters of CR followed by LF, use `\"\\r\\n\"`. ## Unsupported expression * Repeated calculation (`(m,n)`) * Named group (`(?P<name>...)`) * Non capturing group (`(?:...)`) * More advanced assertions (`\\b, \\B`) * Escaping special characters like `\\r`, `\\n` use Python's own escape * Other example: ```python import ure # As ure doesn't support escapes itself, use of r\"\" strings is not # recommended. regex ure.compile(\"[\\r\\n]\") regex.split(\"line1\\rline2\\nline3\\r\\n\") # Result: # ['line1','line2','line3','',''] ``` ## Method ### ure.compile(regex_str[, flags]) Compile the regular expression and return the [regex](http://docs.micropython.org/en/latest/library/ure.html?highlight ure#regex) object. ### ure.match(regex_str, string) Compile regex_str and match the string. The match always starts from the starting position in the string. ### ure.search(regex_str, string) Compile regex_str and search for it in the string. Unlike `match`, this will search the string to match the first position of the regular expression (if the regular expression is anchored, it can still be 0). ### ure.sub(regex_str, replace, string, count 0, flags 0) Compile regex_str and search for it in the string, replace all matches with replace, and return the new string. replace can be a string or a function. If it is a string, then escape sequences of the form `\\<number>` and `\\g<number>` can be used to expand to the corresponding group (or an empty string that does not match the group). If replace is a function, then it must take one parameter (match) and should return a replacement string. If count is specified and non zero, then the replacement will stop after many replacements. The flags parameter is ignored. Note: The availability of this function depends on the `MicroPython port`. ### ure.DEBUG The tag value displays debugging information about the compiled expression. (Availability depends on the `MicroPython port implementation`.) ## Regex Object The compiled regular expression. Use `ure.compile()` to create an instance of this class. ### regex.match(string) regex.search(string) regex.sub(replace, string, count 0, flags 0) Similar to the module level functions `match()`, `search()` and `sub()`. If the same regular expression is applied to multiple strings, the usage method will be more efficient. ### regex.split(string, max_split 1) Use regular expressions to split the string. If max_split is given, specify the maximum number of splits to perform. Returns a list of strings (if specified, there can be at most max_split + 1 elements). ## Match Object Match the objects returned by the `match()` and `search()` methods and pass them to the substitution function in sub(). ### match.group(index) Returns the matching (sub)string. The index of the entire match is 0, and the index of each capture group is 1 and higher. Only number groups are supported. ### match.groups() Return a tuple containing all substrings of the matched group. Note: The availability of this method depends on the `MicroPython port implementation`. ### match.start([index]) match.end([index]) Returns the index in the original string of the beginning or end of the matched substring group. The index defaults to the entire group, otherwise a group will be selected. Note: The availability of these methods depends on the `MicroPython port implementation`. ### match.span([index]) Return the 2 tuple `(match.start(index), match.end(index))`. Note: The availability of this method depends on the implementation of `MicroPython port`."},"/soft/maixpy/en/api_reference/standard/ustruct.html":{"title":"ustruct-Packing and unpacking primitive data types","content":" title: ustruct Packing and unpacking primitive data types keywords: maixpy, k210, AIOT, edge computing desc: maixpy ustruct packing and unpacking primitive data types This module implements a subset of the corresponding `CPython` module, as described below. For more information, please refer to the original CPython documentation: [struct](https://docs.python.org/3.5/library/struct.html#module struct). Supported size/byte order prefixes: `@`, `<`, `>`, `!`. Supported format codes: `b`, `B`, `h`, `H`, `i`, `I`, `l`, `L`, `q`, `Q`, `s`, ` P`, `f`, `d` (the latter 2 depends on floating point support). ## Function ### calcsize ```python ustruct.calcsize(fmt) ``` Returns the number of bytes required to store the given `fmt`. ### pack ```python ustruct.pack(fmt, v1, v2, ...) ``` Pack the values ​​`v1`, `v2`, `...` according to the format string `fmt`. The return value is a bytes object of the encoded value. ### pack_into ```python ustruct.pack_into(fmt, buffer, offset, v1, v2, ...) ``` According to the format string `fmt`, the values ​​`v1`, `v2`, `...` are packed into a buffer starting from offset. Counting from the end of the buffer may be negative. ### unpack ```python ustruct.unpack(fmt, data) ``` Unpack from `data` according to the format string `fmt`. The return value is a tuple of decompressed values. ### unpack_from ```python ustruct.unpack_from(fmt, data, offset 0) ``` According to the format string `fmt` starts from `offset` and unpacks from `data`. `offset` may be a negative number, counting from the end of the buffer. The return value is a tuple of decompressed values."},"/soft/maixpy/en/api_reference/standard/index.html":{"title":"Standard Library","content":" title: Standard Library keywords: maixpy, k210, AIOT, edge computing desc: maixpy standard library * [cmath](cmath.html) * [gc](gc.html) * [math](math.html) * [sys](sys.html) * [ubinascii](ubinascii.html) * [ucollections](ucollections.html) * [uctypes](uctypes.html) * [uerrno](uerrno.html) * [uhashlib](uhashlib.html) * [uheapq](uheapq.html) * [ujson](ujson.html) * [uos](uos.html) * [ure](ure.html) * [uselect](uselect.html) * [usocket](usocket.html) * [ustruct](ustruct.html) * [utime](utime.html) * [uzlib](uzlib.html)"},"/soft/maixpy/en/api_reference/standard/uctypes.html":{"title":"uctypes-access to binary data in a structured way","content":" title: uctypes access to binary data in a structured way keywords: maixpy, k210, AIOT, edge computing desc: maixpy uctypes access to binary data in a structured way This module implements \"external data interface\" for MicroPython. The idea behind it is similar to CPython's `ctypes` module, but the actual API is different, streamlined and optimized for small size. The basic idea of ​​this module is to define a data structure layout with data roughly the same as the functions allowed by the C language, and then use the familiar dot syntax to access it to reference subfields. > **Warning** > > The uctypes module allows access to any memory address of the machine (including I/O and control registers). Using it carelessly may cause crashes, data loss, and even hardware failure. > **Also refer to** > > **[ustruct](ustruct.html) module** > > Standard Python methods for accessing binary data structures (does not scale well to large and complex structures). Routine: ```python import uctypes # Example 1: Subset of ELF file header # https://wikipedia.org/wiki/Executable_and_Linkable_Format#File_header ELF_HEADER { \"EI_MAG\": (0x0 uctypes.ARRAY, 4 uctypes.UINT8), \"EI_DATA\": 0x5 uctypes.UINT8, \"e_machine\": 0x12 uctypes.UINT16, } # \"f\" is an ELF file opened in binary mode buf f.read(uctypes.sizeof(ELF_HEADER, uctypes.LITTLE_ENDIAN)) header uctypes.struct(uctypes.addressof(buf), ELF_HEADER, uctypes.LITTLE_ENDIAN) assert header.EI_MAG b\"\\x7fELF\" assert header.EI_DATA 1, \"Oops, wrong endianness. Could retry with uctypes.BIG_ENDIAN.\" print(\"machine:\", hex(header.e_machine)) # Example 2: In memory data structure, with pointers COORD { \"x\": 0 uctypes.FLOAT32, \"y\": 4 uctypes.FLOAT32, } STRUCT1 { \"data1\": 0 uctypes.UINT8, \"data2\": 4 uctypes.UINT32, \"ptr\": (8 uctypes.PTR, COORD), } # Suppose you have address of a structure of type STRUCT1 in \"addr\" # uctypes.NATIVE is optional (used by default) struct1 uctypes.struct(addr, STRUCT1, uctypes.NATIVE) print(\"x:\", struct1.ptr[0].x) # Example 3: Access to CPU registers. Subset of STM32F4xx WWDG block WWDG_LAYOUT { \"WWDG_CR\": (0, { # BFUINT32 here means size of the WWDG_CR register \"WDGA\": 7 << uctypes.BF_POS 1 << uctypes.BF_LEN uctypes.BFUINT32, \"T\": 0 << uctypes.BF_POS 7 << uctypes.BF_LEN uctypes.BFUINT32, }), \"WWDG_CFR\": (4, { \"EWI\": 9 << uctypes.BF_POS 1 << uctypes.BF_LEN uctypes.BFUINT32, \"WDGTB\": 7 << uctypes.BF_POS 2 << uctypes.BF_LEN uctypes.BFUINT32, \"W\": 0 << uctypes.BF_POS 7 << uctypes.BF_LEN uctypes.BFUINT32, }), } WWDG uctypes.struct(0x40002c00, WWDG_LAYOUT) WWDG.WWDG_CFR.WDGTB 0b10 WWDG.WWDG_CR.WDGA 1 print(\"Current counter:\", WWDG.WWDG_CR.T) ``` ## Define the structure layout The structure layout is defined by a \"descriptor\" a Python dictionary that encodes field names as keys and other attributes needed to access them as associated values: ```python { \"field1\": <properties>, \"field2\": <properties>, ... } ``` Currently, `uctypes` needs to specify the offset of each field. The offset is given in bytes from the beginning of the structure. The following are coding examples for various field types: * Scalar type: ```python \"field_name\": offset uctypes.UINT32 ``` In other words, the value is a scalar type identifier and is ORed with the field offset (in bytes) at the beginning of the structure. * Recursive structure: ```python \"sub\": (offset, { \"b0\": 0 uctypes.UINT8, \"b1\": 1 uctypes.UINT8, }) ``` That is, the value is a 2 tuple, the first element is the offset, and the second is the structure descriptor dictionary (note: the offset in the recursive descriptor is related to the structure it defines). Of course, the recursive structure can be specified not only through the literal dictionary, but also by referring to the structure descriptor dictionary (defined above) by name. * Array of primitive type: ```python \"arr\": (offset uctypes.ARRAY, size uctypes.UINT8), ``` That is, the value is a 2 tuple, the first element is the ARRAY flag and the offset are ORed, and the second is the number of elements in the scalar element type ORed array. *Aggregate type array: ```python \"arr2\": (offset uctypes.ARRAY, size, {\"b\": 0 uctypes.UINT8}), ``` That is, the value is a 3 tuple, the first element of which is the ARRAY flag, which is related to the offset, the second is the number of elements in the array, and the third is the element type descriptor. *Pointers to primitive types: ```python \"ptr\": (offset uctypes.PTR, uctypes.UINT8), ``` That is, the value is a 2 tuple, the first element is the PTR flag and the offset is ORed, and the second element is the scalar element type. *Pointer to aggregate type: ```python \"ptr2\": (offset uctypes.PTR, {\"b\": 0 uctypes.UINT8}), ``` That is, the value is a 2 tuple, the first element of which is the OR operation of the PTR flag and the offset, and the second element is the descriptor of the pointed type. *Bitfield: ```python \"bitf0\": offset uctypes.BFUINT16 lsbit << uctypes.BF_POS bitsize << uctypes.BF_LEN, ``` That is, value is a scalar value that contains a given positioning field (the type name is similar to a scalar type, but the prefix is ​​\"BF\"), which is ORed with the offset of the scalar value containing the bit field, and further compared with the bit position And the value of bit length is \"OR\" operation. The bit fields within the scalar value are shifted by BF_POS and BF_LEN bits respectively. The bit field position counts from the least significant bit (position with 0) of the scalar, and is the number of rightmost bits of the field (in other words, it is the number of bits that the scalar needs to be shifted to the right to extract the bit field). In the above example, first extract the UINT16 value at offset 0 (this detail may be important when accessing hardware registers, requiring specific access size and alignment), and then the rightmost bit is the lsbit bit of this UINT16 The bit field, and length is bitsize bits, will be extracted. For example, if lsbit is 0 and bitsize is 8, then it will effectively access the least significant byte of UINT16. Note that bit field operations are independent of the target byte order, especially the above example will access the least significant byte of UINT16 in little endian and big endian structures. But it depends on the least significant bit being numbered as 0. Some targets may use a different number in their native ABI, but \"uctypes\" always uses the standardized number described above. ## Module content ### class uctypes.struct(addr, descriptor, layout_type NATIVE) Instantiate the \"external data structure\" object based on the address of the structure in memory, the descriptor (encoded as a dictionary) and the layout type (see below). ### uctypes.LITTLE_ENDIAN The layout type of the little endian compression structure. (Packing means that each field occupies the number of bytes defined in the descriptor, that is, the alignment is 1). ### uctypes.BIG_ENDIAN The layout type of big endian compression structure. ### uctypes.NATIVE The layout type of the native structure data byte order and alignment conform to the ABI of the system running MicroPython. ### uctypes.sizeof(struct, layout_type NATIVE) Returns the size of the data structure in bytes. The struct parameter can be a structure class or a specific instantiated structure object (or its aggregate field). ### uctypes.addressof(obj) Returns the address of the object. The parameters should be bytes, byte arrays or other objects that support the buffer protocol (the address of the buffer is actually returned). ### uctypes.bytes_at(addr, size) Capture memory as bytes object with given address and size. Since the bytes object is immutable, the memory is actually copied and copied into the bytes object, so if the memory content changes later, the created object will retain the original value. ### uctypes.bytearray_at(addr, size) Capture the memory of the given address and size as a bytearray object. Unlike the bytes_at() function above, the memory is captured by reference, so it can also be written, and you will access the current value at the given memory address. ### uctypes.UINT8 uctypes.INT8 uctypes.UINT16 uctypes.INT16 uctypes.UINT32 uctypes.INT32 uctypes.UINT64 uctypes.INT64 The integer type of the structure descriptor. Provides 8, 16, 32, and 64 bit constants, including signed and unsigned. ### uctypes.FLOAT32 uctypes.FLOAT64 The floating point type of the structure descriptor. ### uctypes.VOID VOID is an alias of UINT8, used to conveniently define the void pointer of C: (uctypes.PTR, uctypes.VOID). ### uctypes.PTR uctypes.ARRAY Enter constants for pointers and arrays. Please note that the structure has no explicit constants, it is implicit: the aggregation type without the PTR or ARRAY flag is a structure. ## Structure descriptors and instantiated structure objects Given a structure descriptor dictionary and its layout type, you can use the `uctypes.struct()` constructor to instantiate a specific structure instance at a given memory address. Memory addresses usually come from the following sources: *The predefined address when accessing the hardware registers on the bare metal system. Look up these addresses in the data sheet of the specific MCU/SoC. *As the return value of calling some FFI (foreign function interface) functions. *From uctypes.addressof(), when you want to pass parameters to the FFI function, or access certain data of I/O (for example, data read from a file or network socket). ## Structure Object Structure objects allow access to a single field using standard dot notation: `my_struct.substruct1.field1. If the field is a scalar type, getting it will produce the original value (Python integer or floating point number) corresponding to the value contained in the field. Scalar fields can also be assigned to. If a field is an array, you can use the standard subscript operator [] to access its individual elements read and assign at the same time. If a field is a pointer, it can be dereferenced using the [0] syntax (corresponds to the C * operator, although [0] also applies to C). It also supports subscribing to pointers with other integer values ​​(but 0), with the same semantics as in C. All in all, access to structure fields usually follows C syntax, except for pointer dereference, when you need to use the [0] operator instead of *. ## Limit * Access to non scalar fields will cause intermediate objects to be allocated to represent them. This means that special attention should be paid to the layout of structures that need to be accessed when memory allocation is disabled (for example from interrupts). suggestions below: * Avoid access to nested structures. For example, instead of mcu_registers.peripheral_a.register1, a separate layout descriptor is defined for each peripheral and accessed as peripheral_a.register1. Or just cache specific peripherals: peripheral_a mcu_registers.peripheral_a. If the register consists of multiple bit fields, you need to cache the reference to a specific register: reg_a mcu_registers.peripheral_a.reg_a. * Avoid using other non scalar data, such as arrays. For example, use peripheral_a.register0 instead of peripheral_a.register[0]. Similarly, another method is to cache intermediate values, such as register0 peripheral_a.register [0]. * The offset range supported by the `uctypes` module is limited. The exact range of support is considered an implementation detail, and the general recommendation is to split the structure definition into a maximum value from a few kilobytes to tens of kilobytes. In most cases, this is a natural situation. For example, it does not make sense to define all MCU registers in a structure (expanded to 32 bit address space), but to define peripheral blocks through peripheral blocks. In some extreme cases, you may need to manually divide the structure of several parts (for example, if you access a native data structure with a multi megabyte array in the middle, although this will be a very synthetic situation). )"},"/soft/maixpy/en/api_reference/standard/cmath.html":{"title":"cmath – mathematical functions for complex numbers","content":" title: cmath – mathematical functions for complex numbers keywords: maixpy, k210, AIOT, edge computing desc: maixpy cmath – mathematical functions for complex numbers This module implements a subset of the corresponding CPython module, as described below. For more information, please refer to the original CPython documentation: [cmath](https://docs.python.org/3.5/library/cmath.html#module cmath). The `cmath` module provides some basic mathematical functions for dealing with complex numbers. ## Function ### cos ```python cmath.cos(z) ``` Returns the cosine of `z`. ### exp ```python cmath.exp(z) ``` Returns the exponent of `z`. ### log ```python cmath.log(z) ``` Returns the natural logarithm of `z`. The branch cuts along the negative real axis. ### log10 ```python cmath.log10(z) ``` Returns the base 10 logarithm of `z`. The branch cuts along the negative real axis. ### phase ```python cmath.phase(z) ``` Returns the phase, range ( pi, +pi) of the number \"z\". ### polar ```python cmath.polar(z) ``` Return the polar form of `z` as a tuple. ### rect ```python cmath.rect(r, phi) ``` Returns the complex number of the modulus `r` and the phase `phi`. ### sin ```python cmath.sin(z) ``` Returns the sine of `z`. ### sqrt ```python cmath.sqrt(z) ``` Returns the square root of `z`. ## Constants ### cmath.e The basis of natural logarithm ### cmath.pi Ratio of circumference to diameter"},"/soft/maixpy/en/api_reference/standard/math.html":{"title":"math-mathematical functions","content":" title: math mathematical functions keywords: maixpy, k210, AIOT, edge computing desc: maixpy math mathematical functions This module implements a subset of the corresponding CPython module, as described below. For more information, please refer to the original CPython documentation: [math](https://docs.python.org/3.5/library/math.html#module math). The `math` module provides some basic mathematical functions for handling floating point numbers. ## Function ### math.acos(x) Returns the arc cosine of `x`. ### math.acosh(x) Returns the inverse hyperbolic cosine of `x`. ### math.asin(x) Returns the arc sine of `x`. ### math.asinh(x) Returns the inverse hyperbolic sine of `x`. ### math.atan(x) Returns the arc tangent of `x`. ### math.atan2(y, x) Returns the principal value of the arctangent of `y` /`x`. ### math.atanh(x) Returns the inverse hyperbolic tangent of `x`. ### math.ceil(x) Returns an integer, \"x\" is rounded to positive infinity. ### math.copysign(x, y) Return `x` with the sign of `y`. ### math.cos(x) Returns the cosine of `x`. ### math.cosh(x) Returns the hyperbolic cosine of `x` ### math.degrees(x) Returns the radians `x` converted to degrees. ### math.erf(x) Error function that returns `x`. ### math.erfc(x) Returns the complementary error function of `x`. ### math.exp(x) Returns the exponent of `x`. ### math.expm1(x) Return `exp(x) 1`. ### math.fabs(x) Returns the absolute value of `x`. ### math.floor(x) Returns an integer, \"x\" is rounded towards negative infinity. ### math.fmod(x, y) Returns the remainder of `x` /`y`. ### math.frexp(x) Decompose floating point numbers into mantissa and exponent. The returned value is the tuple `(m, e)`, so that `x m * 2 ** e` is completely correct. If `x 0`, the function returns `(0.0,0)`, otherwise the relationship `0.5 < abs(m)<1` holds. ### math.gamma(x) Returns the gamma function of `x`. ### math.isfinite(x) If `x` is finite, it returns True. ### math.isinf(x) If `x` is infinite, it returns True. ### math.isnan(x) If `x` is not a number, it returns True ### math.ldexp(x, exp) Return `x *(2 ** exp)`. ### math.lgamma(x) Returns the natural logarithm of the gamma function of `x`. ### math.log(x) Returns the natural logarithm of `x`. ### math.log10(x) Returns the base 10 logarithm of `x`. ### math.log2(x) Returns the base 2 logarithm of `x`. ### math.modf(x) Returns a tuple of two floating point numbers, the fraction and integer part of \"x\". Both return values ​​have the same sign as `x`. ### math.pow(x, y) Return `x` to the power of'y`. ### math.radians(x) Returns the degree `x` converted to radians. ### math.sin(x) Returns the sine of `x`. ### math.sinh(x) Returns the hyperbolic sine of `x`. ### math.sqrt(x) Returns the square root of `x`. ### math.tan(x) Returns the tangent of `x`. ### math.tanh(x) Returns the hyperbolic tangent of `x`. ### math.trunc(x) Returns an integer, \"x\" is rounded towards 0. ## Constants ### math.e The basis of natural logarithm ### math.pi Ratio of circumference to diameter"},"/soft/maixpy/en/api_reference/standard/uhashlib.html":{"title":"uhashlib-hash algorithm","content":" title: uhashlib hash algorithm keywords: maixpy, k210, AIOT, edge computing desc: maixpy uhashlib hash algorithm This module implements a subset of the corresponding [CPython](http://docs.micropython.org/en/latest/reference/glossary.html#term cpython) module, as described below. For more information, please refer to the original CPython documentation: [hashlib](https://docs.python.org/3.5/library/hashlib.html#module hashlib). This module implements a hash algorithm for binary data. The exact list of available algorithms depends on the board. Among the algorithms that can be implemented: The latest modern hash algorithm of the SHA256 SHA2 series. It is suitable for password security purposes. Unless it has a specific code size limit, it is recommended to include it in the MicroPython kernel, and it is recommended that any development board provides this feature. There is hardware acceleration in K210, not software calculation [Example](https://github.com/sipeed/MaixPy v1_scripts/blob/master/basic/demo_sha256.py): ```python a bytes([0]*65) b hashlib.sha256(a) c b.digest() print(c) ``` ## Constructor ## Class uhashlib.sha256([data]) Create a SHA256 hash object and selectively feed data into it. ## Method ### hash.update(data) Enter more binary data into the hash. ### hash.digest() Returns the hash of all data passed through the hash as a bytes object. After calling this method, no more data can be fed into the hash. **Note**: In `micropython`, using this function will complete the final calculation, instead of simply displaying the result, it can only be called once. If you want to use this value multiple times, please save it to a variable ```python c b.digest() print(c) ``` Multiple calls will find that the return value is different ```python c b.digest() d b.digest() print(c d) # False ``` ### hash.hexdigest() This method is not implemented. Use `ubinascii.hexlify(hash.digest())` to get a similar effect."},"/soft/maixpy/en/api_reference/standard/ubinascii.html":{"title":"ubinascii-Binary/ASCII conversion","content":" title: ubinascii Binary/ASCII conversion keywords: maixpy, k210, AIOT, edge computing desc: maixpy ubinascii Binary/ASCII conversion This module implements a subset of the corresponding CPython module, as described below. For more information, please refer to the original CPython documentation: [binascii](https://docs.python.org/3.5/library/binascii.html#module binascii). The module implements the conversion between binary data and its various codes in ASCII format (two directions). ## Function ### ubinascii.hexlify(data[, sep]) Convert binary data to hexadecimal representation. Returns a byte string. #### Difference with CPython If the additional parameter sep is provided, it will be used as a separator between hexadecimal values. ### ubinascii.unhexlify(data) Convert hexadecimal data to binary representation. Returns a byte string. (Ie the inverse of hexlify) ### ubinascii.a2b_base64(data) Decode base64 encoded data, ignoring invalid characters in the input. Comply with [RFC 2045 s.6.8.](https://tools.ietf.org/html/rfc2045#section 6.8) Return a bytes object. ### ubinascii.b2a_base64(data) Encode binary data in base64 format, as described in [RFC 3548](https://tools.ietf.org/html/rfc3548.html). Returns the encoded data, followed by a newline character, as a bytes object."},"/soft/maixpy/en/api_reference/standard/utime.html":{"title":"utime-time related functions","content":" title: utime time related functions keywords: maixpy, k210, AIOT, edge computing desc: maixpy utime time related functions This module implements a subset of the corresponding CPython module, as described below. For more information, please refer to the original CPython documentation: [time](https://docs.python.org/3.5/library/time.html#module time). The `utime` module provides functions for obtaining the current time and date, measuring time intervals and delays. **Time Epoch**: The Unix ported version uses the POSIX system era of 1970 01 01 00:00:00 UTC. However, the embedded port version uses the epoch of 2000 01 01 00:00:00 UTC. **Maintain actual calendar date/time**: This requires a real time clock (RTC). On systems with underlying OS (including some RTOS), RTC may be implicit. Setting and maintaining the actual calendar time is the responsibility of the OS/RTOS and is done outside of MicroPython, it only uses the OS API to query the date/time. On bare metal porting, the system time depends on the `machine.RTC()` object. You can use `machine.RTC(). The datetime (tuple)` function sets the current calendar time and maintains it in the following ways: * Through a backup battery (may be an additional optional component on a specific circuit board). * Use network time protocol (need to be set by transplantation/user). * It is manually set by the user each time it is powered on (many boards maintain the RTC time during hard reset, but some may need to be set again in this case). If the system/MicroPython RTC is not used to maintain the actual calendar time, the functions that refer to the current absolute time below this requirement may not match expectations. ## Function ### utime.localtime([secs]) Convert the time in seconds since the epoch (see above) into an 8 tuple containing: (year, month, day, hour, minute, second, weekday, late) If seconds are not provided or none, then Used for the current time from RTC. * The year includes the century (for example, 2014). * Month is 1 12 * mday is 1 31 * Hours are 0 23 * Minutes are 0 59 * The second is 0 59 Working days from Monday to Sunday are 0 6 * yearday is 1 366 ### utime.mktime() This is the inverse function of local time. Its parameter is a complete 8 tuple, representing the time expressed in local time. It returns an integer, which is the number of seconds since January 1, 2000. ### utime.sleep(seconds) Sleep for the given number of seconds. Some circuit boards may accept seconds as floating point numbers to sleep for a few seconds. Please note that other boards may not accept floating point parameters because of their compatibility using `sleep_ms()` and `sleep_us()` functions. ### utime.sleep_ms(ms) The delay for a given number of milliseconds should be positive or 0. ### utime.sleep_us(us) The delay for a given number of microseconds should be positive or zero. ### utime.ticks_ms() Returns an incremental millisecond counter with an arbitrary reference point, which wraps around after a certain value. The wraparound value is not explicitly disclosed, but we will call it TICKS_MAX to simplify the discussion. The period of the value is TICKS_PERIOD TICKS_MAX + 1. TICKS_PERIOD is guaranteed to be a power of 2, but it may be different between different hardware migrations. The same period value is used for all `ticks_ms()`, `ticks_us()`, `ticks_cpu()` functions (for simplicity). Therefore, these functions will return values ​​in the range [0 .. TICKS_MAX], including the total TICKS_PERIOD value. Note that only non negative values ​​are used. In most cases, you should treat the values ​​returned by these functions as opaque. The only operations available are the `ticks_diff()` and `ticks_add()` functions, as described below. > Note: Performing standard mathematical operations (+, ) or relational operators (<, < , >,> ) directly on these values ​​will result in invalid results. Performing mathematical operations and then passing the result as a parameter to ticks_diff() or ticks_add() will also cause invalid results of the latter function. ### utime.ticks_us() Just like'ticks_ms()` above, but within a few microseconds. ### utime.ticks_cpu() Similar to `ticks_ms()` and `ticks_us()`, but with the highest resolution in the system. This is usually the CPU clock, which is why the function is named this way. But it does not have to be the CPU clock, but can use some other timing sources available in the system (for example, high resolution timers). The exact time unit (resolution) of this function is not specified at the'utime' module level, but the documentation for specific hardware may provide more specific information. This function is used for very detailed benchmarks or very tight real time loops. Avoid using it in portable code. ### utime.ticks_add(ticks, delta) The offset value is calculated according to the given number, which can be positive or negative. Given a ticks value, this function allows the ticks value delta ticks to be calculated after or after the module arithmetic definition of the tick value (see `ticks_ms()` above). The ticks parameter must be the direct result of calling the `ticks_ms()`, `ticks_us()` or `ticks_cpu()` function (or calling `ticks_add()` from before). However, delta can be any integer or numeric expression. ticks_add() is very useful for calculating the deadline of events/tasks. (Note: You must use the `ticks_diff()` function to handle the deadline.) example: ```python # Find out what ticks value there was 100ms ago print(ticks_add(time.ticks_ms(), 100)) # Calculate deadline for operation and test for it deadline ticks_add(time.ticks_ms(), 200) while ticks_diff(deadline, time.ticks_ms())> 0: do_a_little_of_something() # Find out TICKS_MAX used by this port print(ticks_add(0, 1)) ``` ### utime.ticks_diff(ticks1, ticks2) Measure the difference between the values ​​returned from the `ticks_ms()`, `ticks_us()`, or `ticks_cpu()` functions as a signed value that can be wrapped. The order of the parameters is the same as the subtraction operator. `ticks_diff(ticks1, ticks2)` has the same meaning as `ticks1 ticks2`. However, the value returned by functions such as `ticks_ms()` may wrap around, so using subtraction directly will produce incorrect results. This is why `ticks_diff()` is needed, which implements modular (or more specifically, ring) arithmetic and produces correct results even for surrounding values ​​(as long as they are not too far apart, see below). This function returns a **signed** value in the range [ TICKS_PERIOD / 2 .. TICKS_PERIOD / 2 1] (this is the typical range definition for twos complement signed binary integers). If the result is negative, it means that ticks1 is earlier than ticks2 in time. Otherwise, it means ticks1 occurs after ticks2. If ticks1 and ticks2 are separated from each other by no more than TICKS_PERIOD / 2 1 ticks, only ** is retained. If it is not true, an incorrect result will be returned. Specifically, if two scale values ​​are separated by TICKS_PERIOD / 2 1 scale, the value will be returned by this function. However, if the real time ticking TICKS_PERIOD/2 has been passed between them, the function will return TICKS_PERIOD/2, that is, the result value will wrap around to the negative range of possible values. Unofficial reason for the above restriction: Suppose you are locked in a room and cannot monitor the passage of time except for the standard 12 speed clock. Then, if you look at the watch face now and no longer look at it for 13 hours (for example, if you sleep for a long time), then once you read it again, you may feel that only 1 hour has passed. To avoid this error, please check the clock regularly. Your application should do the same. The metaphor of \"sleeping too long\" also directly maps to application behavior: don't let your application run any single task for too long. Run the task step by step and time between the two. `ticks_diff()` is designed to adapt to various usage patterns, including: * Timeout polling. In this case, the sequence of events is known, and you will only deal with the positive results of `ticks_diff()`: ```python # Wait for GPIO pin to be asserted, but at most 500us start time.ticks_us() while pin.value() 0: if time.ticks_diff(time.ticks_us(), start)> 500: raise TimeoutError ``` * Scheduling events. In this case, if the event expires, the ticks_diff() result may be negative: ```python # This code snippet is not optimized now time.ticks_ms() scheduled_time task.scheduled_time() if ticks_diff(scheduled_time, now)> 0: print(\"Too early, let's nap\") sleep_ms(ticks_diff(scheduled_time, now)) task.run() elif ticks_diff(scheduled_time, now) 0: print(\"Right at time!\") task.run() elif ticks_diff(scheduled_time, now) <0: print(\"Oops, running late, tell task to run faster!\") task.run(run_faster true) ``` > Note: Do not pass `time()` values ​​to `ticks_diff()`, you should use regular mathematical operations on them. But please note that `time()` may (also) overflow. This is called https://en.wikipedia.org/wiki/Year_2038_problem. ### utime.time() Returns the integer number of seconds since the epoch, assuming the basic RTC is set and maintained as described above. If RTC is not set, this function returns the number of seconds since the specific hardware migration reference time point (for embedded circuit boards without battery powered RTC, usually since power on or reset). If you want to develop portable MicroPython applications, you should not rely on this function to provide a higher precision than the second. If you need higher precision, use the `ticks_ms()` and `ticks_us()` functions. If you need calendar time, `localtime()` without parameters is a better choice. #### Difference with CPython In CPython, this function returns the number of seconds since the Unix epoch (1970 01 01 00:00 UTC), as a floating point number, usually with microsecond precision. With MicroPython, only the Unix port uses the same epoch, and if floating point precision allows, it returns sub second precision. Embedded hardware usually does not have floating point precision to represent long time ranges and sub second precision, so they use integer values ​​with second precision. Some embedded hardware also lacks a battery powered RTC, so it returns the number of seconds since the last power on or other relative hardware specific point (such as reset). ### time.ticks() Equivalent to `time.ticks_ms` ### time.clock() Get the `clock` object #### return value `clock` object ## clock object Returned by `time.clock()` ### clock.tick() Recording start time (ms), used with `clock.fps()` to calculate `fps` #### return value None ### clock.fps() Calculate the frame rate (`fps`) based on the time from the previous call to `clock.tick()` such as: ```python import sensor import time clock time.clock() sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) while True: clock.tick() sensor.snapshot() print(\"fps \",clock.fps()) ``` ### clock.reset() Reset all flags ### clock.avg() Calculate the time consumed per frame based on the time from the previous call to `clock.tick()`"},"/soft/maixpy/en/api_reference/standard/ujson.html":{"title":"ujson – JSON encoding and decoding","content":" title: ujson – JSON encoding and decoding keywords: maixpy, k210, AIOT, edge computing desc: maixpy ujson – JSON encoding and decoding This module implements a subset of the corresponding CPython module, as described below. For more information, please refer to the original CPython documentation: [json](https://docs.python.org/3.5/library/json.html#module json). This module allows conversion between Python objects and JSON data formats. ## Function ### dump ```python ujson.dump(obj, stream) ``` Serialize `obj` into a JSON string and write it to the given stream. ### dumps ```python ujson.dumps(obj) ``` Returns `obj` represented as a JSON string. ### load ```python ujson.load(stream) ``` Parse the given stream, interpret it as a JSON string and deserialize the data into Python objects. Return the result object. The parsing continues until the end of the file is encountered. If the data in the stream is not formed correctly, a ValueError will be raised. ### loads ```python ujson.loads(str) ``` Parse the JSON str and return an object. If the string format is wrong, ValueError is raised."},"/soft/maixpy/en/api_reference/standard/gc.html":{"title":"gc-memory recovery","content":" title: gc memory recovery keywords: maixpy, k210, AIOT, edge computing desc: maixpy gc memory recovery This module implements a subset of the corresponding CPython module, as described below. For more information, please refer to the original CPython documentation: [gc](https://docs.python.org/3.5/library/gc.html#module gc). ## Function ### gc.enable() Enable automatic garbage collection. ### gc.disable() Disable automatic garbage collection. Heap memory can still be allocated, and garbage collection can still be started manually using `gc.collect()`. ### gc.collect() Run garbage collection. ### gc.mem_alloc() Returns the number of bytes of heap RAM allocated. #### Difference to CPython This feature is a MicroPython extension. ### gc.mem_free() Returns the number of bytes of available heap RAM, or 1 if the remaining amount of heap is unknown. #### Difference with CPython This feature is a MicroPython extension. ### gc.threshold([amount]) Set or query other GC allocation thresholds. Generally, the collection is triggered only when the new allocation cannot be met, that is, under out of memory (OOM) conditions. If you call this function, in addition to OOM, a set will be triggered every time a large number of bytes are allocated (in total, because so many bytes were allocated last time). The amount is usually specified as less than the full heap size, with the intention to trigger the collection before the heap is exhausted, and hope that the early collection can prevent excessive memory fragmentation. This is a heuristic measurement whose effect varies from application to application, as well as the optimal value of the measurement parameter. Calling the function without parameters will return the current value of the threshold. A value of 1 indicates a disabled allocation threshold. #### Difference with CPython This function is a MicroPython extension. CPython has a similar function `set_threshold()`, but due to different GC implementations, its signature and semantics are different."},"/soft/maixpy/en/no_translate.html":{"title":"no translation","content":" title: no translation class: md_page <div id \"visit_from\"></div> <div id \"no_translate_hint\">This page not translated yet</div> <div> <span id \"visit_hint\">Please visit</span> <a id \"translate_src\"></a> </div> <div> <script> function getQueryVariable(variable) { var query window.location.search.substring(1); var vars query.split(\"&\"); for (var i 0;i<vars.length;i++) { var pair vars[i].split(\" \"); if(pair[0] variable){return pair[1];} } return(false); } var ref getQueryVariable(\"ref\"); var from getQueryVariable(\"from\"); var link document.getElementById(\"translate_src\"); var fromDis document.getElementById(\"visit_from\"); link.href ref; link.text ref; fromDis.innerHTML from; </script> </div>"}}