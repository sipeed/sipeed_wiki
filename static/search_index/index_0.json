{"/hardware/zh/longan/Nano/examples/printf.html":{"title":"串口打印","content":"串口打印 很多时候，串口打印都是一个非常方便的调试手段，通过串口打印的信息，可以方便的定位程序错误位置 本文基于 longan nano 演示如何实现 printf 通过串口打印 本文选择串口0作为串口打印信息的端口，外设使用前，自然需要进行初始化 ```c void init_uart0(void) {\t \t/* enable GPIO clock */ rcu_periph_clock_enable(RCU_GPIOA); /* enable USART clock */ rcu_periph_clock_enable(RCU_USART0); /* connect port to USARTx_Tx */ gpio_init(GPIOA, GPIO_MODE_AF_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_9); /* connect port to USARTx_Rx */ gpio_init(GPIOA, GPIO_MODE_IN_FLOATING, GPIO_OSPEED_50MHZ, GPIO_PIN_10); \t/* USART configure */ usart_deinit(USART0); usart_baudrate_set(USART0, 115200U); usart_word_length_set(USART0, USART_WL_8BIT); usart_stop_bit_set(USART0, USART_STB_1BIT); usart_parity_config(USART0, USART_PM_NONE); usart_hardware_flow_rts_config(USART0, USART_RTS_DISABLE); usart_hardware_flow_cts_config(USART0, USART_CTS_DISABLE); usart_receive_config(USART0, USART_RECEIVE_ENABLE); usart_transmit_config(USART0, USART_TRANSMIT_ENABLE); usart_enable(USART0); usart_interrupt_enable(USART0, USART_INT_RBNE); } ``` 这里首先的开启了端口时钟和串口时钟，在初始化完管脚后，就进行了串口的功能配置 我们一般比较关心的就是串口的波特率，这里设置成了 115200 然后我们还需要重新实现 _put_char ，将 printf 重映射 ```c int _put_char(int ch) { usart_data_transmit(USART0, (uint8_t) ch ); while ( usart_flag_get(USART0, USART_FLAG_TBE) RESET){ } return ch; } ``` 这样就可以快乐的使用 printf 了"},"/hardware/zh/longan/Nano/examples/badapple.html":{"title":"Bad Apple 演示视频","content":"Bad Apple 演示视频 本文目的是使用板载的 160*80 分辨率的 OLED 屏幕播放 bad apple 视频 ## 主要工作介绍 + 移植 OLED 屏幕的驱动 + 移植 tf 卡驱动和 fatfs 文件系统 + 将视频按自己需要的帧率转换为一帧帧的图片然后打包到 tf 卡 + 在 gd32v 上读取 tf 卡中的图片并进行显示 ### 屏幕驱动 使用硬件 SPI 驱动屏幕，首先需要初始化 SPI ```c void spi_config(void) { spi_parameter_struct spi_init_struct; /* deinitilize SPI and the parameters */ OLED_CS_Set(); spi_struct_para_init(&spi_init_struct); /* SPI0 parameter config */ spi_init_struct.trans_mode SPI_TRANSMODE_FULLDUPLEX; spi_init_struct.device_mode SPI_MASTER; spi_init_struct.frame_size SPI_FRAMESIZE_8BIT; spi_init_struct.clock_polarity_phase SPI_CK_PL_HIGH_PH_2EDGE; spi_init_struct.nss SPI_NSS_SOFT; spi_init_struct.prescale SPI_PSC_8; spi_init_struct.endian SPI_ENDIAN_MSB; spi_init(SPI0, &spi_init_struct); \tspi_crc_polynomial_set(SPI0,7); \tspi_enable(SPI0); } ``` 初始化完成后就可以实现数据指令的发送 ```c void LCD_Writ_Bus(u8 dat) { \tOLED_CS_Clr(); \twhile(RESET spi_i2s_flag_get(SPI0, SPI_FLAG_TBE)); spi_i2s_data_transmit(SPI0, dat); \twhile(RESET spi_i2s_flag_get(SPI0, SPI_FLAG_RBNE)); spi_i2s_data_receive(SPI0); \tOLED_CS_Set(); } void LCD_WR_DATA8(u8 dat) { \tOLED_DC_Set();//写数据 \tLCD_Writ_Bus(dat); } void LCD_WR_DATA(u16 dat) { \tOLED_DC_Set();//写数据 \tLCD_Writ_Bus(dat>>8); \tLCD_Writ_Bus(dat); } void LCD_WR_REG(u8 dat) { \tOLED_DC_Clr();//写命令 \tLCD_Writ_Bus(dat); } ``` `LCD_Writ_Bus` 完成了 SPI 的收发，通过控制命令数据线，完成命令和数据的发送 OLED 屏幕在使用前还需要设置它的一些参数，比如屏幕开启、数据帧的格式等等，这些在参数在屏幕初始化的时候，通过写命令再写数据的方式写入。想修改这些参数需要依靠屏幕配套的数据手册，不过一般可以参数屏幕生产商提供的例程中的参数。 ### tf 卡驱动和 fatfs 文件系统 tf 卡在 longan 上也是使用 SPI 驱动的。为了更快的访问速率，也是使用硬件 SPI 驱动。使用前也需要初始化，方式和屏幕的 SPI 初始化类似，就不再累述。 fatfs 是一个专为小型嵌入式设备设计的文件系统。fatfs 符合 ANSI C(C89)规范，并且和磁盘 I/O 层完全分离。 具体的移植也很简单，直接参照 fatfs 提供的 stm32 的工程移植进行 这里提供该工程的[下载地址](http://dl.sipeed.com/LONGAN/Nano/Firmware/badapple_demo_tools/ffsample.7z)，完整版可以去 fatfs 的[官网下载](http://elm chan.org/fsw/ff/ffsample.zip) 主要的工作在于实现 fatfs 的几个基本函数 `disk_initialize` `disk_status` `disk_read` `disk_ioctl` 这些函数又是基于 SPI 通信的，还需要修改 SPI 接收发送的实现 ```c static BYTE xchg_spi ( \tBYTE dat\t/* Data to send */ ) { \twhile(RESET spi_i2s_flag_get(SPI1, SPI_FLAG_TBE)); spi_i2s_data_transmit(SPI1, dat); \twhile(RESET spi_i2s_flag_get(SPI1, SPI_FLAG_RBNE)); return(spi_i2s_data_receive(SPI1)); /* Return received byte */ } static void rcvr_spi_multi ( \tBYTE *buff,\t\t/* Pointer to data buffer */ \tUINT btr\t\t/* Number of bytes to receive (even number) */ ) { \tdo \t{ \t\t*buff xchg_spi(0xff); \t\tbuff++; \t} while (btr ); } ``` ### 视频预解码 mp4 格式的视频，单片机因为没有硬件的加速，无法胜任解码播放的工作，所以只能靠手工预解码，相当于按照一定的帧率对原视频进行截图 这里需要使用到 PotPlayer XnViewMP 首先使用 PotPlayer 打开视频，快捷键 ctrl+G 打开连续截图 打开后如图 ![](./../assets/examples/potplayer.png) 其中格式一定要 BMP，尺寸按照屏幕的尺寸设置，时间我这里设置的是 100ms 也就是 1s 十帧的样子，采集数量就自己计算一下视频总时间再乘每秒帧数，我这里就是 219s * 10 2190 最后得到的图片是 32位 的 BMP，转换起来不方便，就用 XnViewMP 转换为 24位 的 BMP 打开 XnViewMP ，选择要转换的图片，快捷键 ctrl+U 打开批量转换，在动作中选择 24位 进行转换，如图 ![](./../assets/examples/XnViewMP.png) 然后就是将这些图片打包到 tf 卡，这里为了方便，修改了网上的一个开源项目 [bmp2hex](https://github.com/robertgallup/bmp2hex)，重新整理了一个工具，可以[点击下载](http://dl.sipeed.com/LONGAN/Nano/Firmware/badapple_demo_tools/tools_bmp2hex.zip) 使用方法很简单，把下载的这个压缩包放到之前生成的图片集中，进行解压 使用工具前需要确保所有图片的名字是 数字.bmp ，不是的话可以先运行一遍 rename.py 这个脚本，直接在命令行输入 `python rename.py` 即可 根据自己图片总数修改 genhex.py 这个脚本的第4行中的数字，比如我有 2190张 图片，这里的数字就写 2190 然后就运行这个脚本，在命令行输入 `python genhex.py`，时间可能比较久，需要耐心等待 最后运行完毕后会生成一个 bmp.bin 文件，将这个文件放入到 tf 卡中即可 ### 读取图片 最后的读取图片并显示其实很简单了，主要涉及到的就是文件操作，关于 fatfs 的 API [可以点击这里阅读](http://elm chan.org/fsw/ff/doc/open.html) 首先需要将 tf 卡挂载到文件系统，这里需要使用到 f_mount 这个函数 ```c fr f_mount(&fs, \"\", 1); ``` 挂载上后，就找到对应的文件然后打开，这里涉及到 f_open ```c fr f_open(&fil, \"bmp.bin\", FA_READ); ``` 文件打开后，就可以读取图片信息并显示了，这里 160*80 尺寸的 16位真彩图片，一张有 25600 字节，longan 上的处理器无法直接创建一个这么大的数组，所以只能分两次进行读取，每次读取完进行一次偏移，最后通过循环读取总共的 2189 张图片，这里涉及到 f_read f_lseek ```c for (int i 0; i<2189;i++) { fr f_read(&fil, image, sizeof(image), &br); LCD_ShowPicture(0,0,159,39); offset + 12800; f_lseek(&fil, offset); LEDB_TOG; fr f_read(&fil, image, sizeof(image), &br); LCD_ShowPicture(0,40,159,79); offset + 12800; f_lseek(&fil, offset); LEDB_TOG; } ``` 最后，本工程可以到 github 下载体验，[点击进行传送](https://github.com/sipeed/Longan_GD32VF_examples)"},"/hardware/zh/longan/Nano/Longan_nano.html":{"title":"Longan nano ","content":"# Longan nano ## 介绍 Longan Nano是基于兆易创新(GigaDevice)的GD32VF103CBT6(RISC V架构)芯片设计的极简开发板。开发板将芯片所有IO引出，设计小巧精致，板载Type C、LCD、SD卡、JTAG等接口，方便广大学生、工程师、极客爱好者们接触学习最新一代的 RISC V处理器。 ![Longan_nano_pin](./../../../assets/Longan/nano/Longan_nano.124.jpg) ## 参数 项目 参数 CPU 基于 RISC V 32 位内核的 GD32VF103CBT6 内核功耗 仅传统 Cortex M3 的 1/3 存储 128KB Flash, 32KB SRAM 外设 4 x general purpose 16 bit timer, 2 x basic 16 bit timer, 1 x advanced 16 bit timer,<br>Watchdog, RTC, Systick<br>3 x USART, 2 x I2C, 3 x SPI, 2 x I2S, 2 x CAN, 1 x USBFS (OTG), 2 x ADC (10 channel), 2 x DAC 按键 1 个复位按键和 1 个 BOOT 按键（连接到 GPIO） 屏幕接口 SPI 接口（标配 0.96 寸 160x80 RGB IPS LCD） 存储接口 板载 TF 卡座子 调试接口 2x4 排针引出 JTAG 调试接口和串口 晶振 8MHz 无源晶振 + 32.768KHz RTC 无源晶振 LED 板载 1 个 RGB LED GPIO 数量 2 引出 28 个 GPIO 到排针 ### 新版照片 ![](./../../../assets/Longan/nano/Longan nano_PINOUT.svg) ![](./../../../assets/Longan/nano/longan nano 1.png) ### 旧版照片 ![](./../../../assets/Longan/nano/longan_nano_pinout_old.png) ![](./../../../assets/Longan/nano/longan nano old.png) ## 使用 [Longan使用](/soft/longan/zh/readme.md) ## 产品技术支持 Longan Nano 开发板可以在多种场景实现客户不同方面的需要，在 AIoT 上已经广泛的使用，品质和性能在行业内已经有非常好的口碑，专业的技术团队为广大客户解决硬件设计和软件功能上的各种各样问题。专业技术支持和更详细资料请联系商务 <support@sipeed.com>。"},"/hardware/zh/longan/Nano/get_started/debug.html":{"title":"Debug 调试","content":"Debug 调试 ## 连接调试器 开发板 调试器 : : : : JTDO TDO JTDI TDI JTCK TCK JTMS TMS 3V3 3V3 GND GND ## 修改配置文件 修改工程配置文件 `platformio.ini`， 在下面添加 ```ini debug_tool jlink ``` 根据实际调试器型号选择。目前支持的调试器列表 * `jlink` * `gd link` * `ft2232` * `sipeed rv debugger` * `altera usb blaster` * `um232h` * `rv link` ## 一键调试 切换到 VS CODE 左侧的 `DEBUG` 界面， 点击绿色箭头即可进行调试。 ![](./../assets/pio_debug_longan.png)."},"/hardware/zh/longan/Nano/get_started/blink.html":{"title":"Blink 闪灯程序","content":" title: Blink 闪灯程序 ## 创建 Blink 工程 * 打开 PIO 主页 选择 `Project Examples` ![](http://blog.sipeed.com/wp content/uploads/2019/04/d977e844490e6ccc4625f701883a29f5.png) * 选择 `arduino blink` 点击 `Import` 导入示例程序 （初次导入需要下载架构文件及工具，需要等待较长时间） ![](http://blog.sipeed.com/wp content/uploads/2019/04/82943a6b74077e6210e2d9421cb5438f.png) * 导入成功后即可见到示例工程 ![](http://blog.sipeed.com/wp content/uploads/2019/04/1262373ca7b0b483e30dac1124adaabf.png) ## 工程配置文件 * 我们首先需要编辑工程配置文件 `platformio.ini` 根据自己的开发板型号，删掉其他开发板环境。 ![](./../assets/pio_ini_cfg.png) 配置示例 ```ini [env:sipeed longan nano] platform gd32v ;平台，选择gd32v framework arduino ;可选 gd32vf103 sdk 或 arduino board sipeed longan nano ; 开发板 monitor_speed 115200 ; 串口监视器波特率 upload_protocol serial ; 下载工具 默认串口， 可选 dfu、jlink、gd link 等 debug_tool jlink ; 调试工具 默认jlink ，可选 sipeed rv debugger 等 ``` PIO 可以在配置文件中实现设置宏定义， 控制编译流程等自定义功能，高级用法请参阅 [PIO 官方文档](https://docs.platformio.org/en/latest/projectconf.html). ## 一键编译 点击左下角的 `Build` 即可构建项目 ![](./../assets/pio_complie.png) ## 连接开发板 ### 串口 ISP 下载 * 准备 USB 转 串口下载器 * 连接开发板与下载器 * 修改 `platformio.ini` 文件， 添加下面一行内容： ```ini upload_protocol serial ``` * 开发板按住 `BOOT` 键，再按 `RESET` 键重启开发板后再松开 `BOOT` 键，进入下载模式。 ### JTAG 下载 * 准备J link 或 Sipeed RV 调试器 * 连接开发板 * 修改 `platformio.ini` 文件， 添加下面一行内容： ```ini upload_protocol jlink ``` 或者 ```ini upload_protocol sipeed rv debugger ``` ### USB DFU 下载 * **首次** 使用需要安装 libusb 驱动程序， 请参考此步骤 [使用 Zaidig 安装驱动](###使用zadig安装驱动). * 准备 USB Type c 数据线 * 使用数据线连接电脑与开发板 * 修改 `platformio.ini` 文件， 添加下面一行内容： ```ini upload_protocol dfu ``` * 开发板按住 `BOOT` 键，再按 `RESET` 键重启开发板后再松开 `BOOT` 键，进入 DFU 模式。 ## 一键下载 按照上面步骤选择好下载方式后，即可使用 PIO 内置工具一键下载。 点击左下角的 `Upload` 即可向开发板上传程序。 ![](./../assets/pio_upload.png) ### 使用Zadig安装驱动 PIO 内置 dfu util 下载工具，使用此工具需要为开发板安装 libusb 驱动。（注意： 与 GD 官方驱动不同） 建议通过 Zadig 安装 winusb 驱动。[下载地址](https://github.com/pbatard/libwdi/releases/download/b721/zadig 2.4.exe) 下载成功后打开 Zadig 在下拉栏中选择 GD32V， 替换驱动选择 WinUSB, 点击替换按钮，即可替换成功。 ![](./../assets/dfu_zadig.png) ### DFU 图形界面下载 下载DFU工具：<https://dl.sipeed.com/shareURL/LONGAN/Nano/Tools> 在里面找到 `GD32_MCU_Dfu_Tool_V3.8.1.5784_1.rar` 文件并下载 解压出两个文件夹： GD32 MCU Dfu Drivers_v1.0.1.2316 GD32 MCU Dfu Tool_v3.8.1.5784 先进入driver文件夹，安装对应的驱动文件，注意使用管理员权限运行 ![](./../assets/examples/how_to_install_dfu.png) 再回到Tools目录下运行 GD32 MCU Dfu Tool.exe 将 Longan Nano 插到电脑，按住板子上 Boot0 键的时候按下 reset 键。 就可以看到 DFU 工具中识别到了 GD32VF 芯片 选择对应的固件文件，并勾选烧录后校验，点击OK，即可进行烧录 烧录完成之后不会自动复位，需要自己手工按下复位按键(按下reset)。 ![](./../assets/examples/how_to_use_dfu.png)"},"/hardware/zh/longan/Nano/get_started/pio.html":{"title":"PIO 配置","content":"PIO 配置 ## 安装 VS CODE VS CODE 是一款比较常用的开发工具。前往[VScode官网](https://code.visualstudio.com/ \"VScode官网\")，下载安装对应操作系统版本的安装包即可。 ## 安装 PIO 插件 打开 VSCode > 点击左侧扩展 > 搜索 PlatformIO > 点击安装插件 > 等待安装完成 > 重启 VSCODE ![](http://blog.sipeed.com/wp content/uploads/2019/04/0d501a8515a735fba54e2f5de908cd1e.png) ## 安装 GD32V 平台定义 PIO 目前提供**命令行**与**图形界面**两种方式来安装。下面将分别介绍： （PS : 推荐命令行，因为能看到下载进度条。） ### 命令行 点击PIO图标 > 点击左下方的New Terminal > 在终端窗口中执行下面的安装指令 * 发布版 （稳定版本） ``` platformio platform install gd32v ``` * 开发版（与Github同步） ``` platformio platform install https://github.com/sipeed/platform gd32v ``` ![](./../assets/pio_install_gd32v.png) 注：受国内网络环境影响，安装过程需要较长时间，请耐心等待。 ### 图形界面 打开VS CODE > 点击左侧 PIO 图标 > 点击左下方的 Open 选项 > 点击 Platforms 页面 > 点击 Advanced Installation 打开添加窗口 ![](./../assets/pio_install_add_gd32v_step1.png) 在打开的窗口中输入下面的网址 ``` https://github.com/sipeed/platform gd32v.git ``` 点击 Install 即可添加完成。 ![](./../assets/pio_install_add_gd32v_step2.png) 耐心等待即可安装成功。 （安装失败多为网络原因， 请更换网络环境后再次尝试） ![](./../assets/pio_install_add_gd32v_step3.png)"},"/hardware/zh/longan/Nano/get_started/rv-link.html":{"title":"使用 RV-LINK","content":"使用 RV LINK ## 什么是 RV LINK **RV LINK** 是一个基于 RISC V 开发板的仿真器固件，通过烧写 **RV LINK** 固件， 可以将 **Sipeed Longan Nano** 开发板变成一个 `jtag` 调试器，用来调试另一块 Longan 或者其他支持 jtag 调试的开发板。 RV LINK 项目地址: [https://gitee.com/zoomdy/RV LINK](https://gitee.com/zoomdy/RV LINK) ## 烧写 RV LINK 固件 ### 使用 PlatformIO 工程一键烧录 * 下载 RV LINK 源码 项目源码下载地址：[http://dl.sipeed.com/LONGAN/Nano/Tools/RV LINK pio src v0.1.zip](http://dl.sipeed.com/LONGAN/Nano/Tools/RV LINK pio src v0.1.zip) 也可以从RV LINK官方项目下载: [https://gitee.com/zoomdy/RV LINK](https://gitee.com/zoomdy/RV LINK) * 使用 VSCODE 打开工程目录 将上面下载的源码解压到单独的文件夹 然后使用 VSCODE 打开源码文件夹 如下图所示： ![](./../assets/pio_open_rvlink.png) 通常使用 DFU 方式烧录固件，**不需要**修改配置文件。(使用 DFU 方式下载请安装 libusb 驱动, 参考[使用Zadig安装驱动](blink.md/#使用zadig安装驱动)) 如果需要更改烧录方式，可以通过修改 `platformio.ini` 文件来修改， 具体配置方式请参考：[修改工程配置文件](blink.md/#工程配置文件) * 使用 PIO 烧录固件 连接开发板，使开发板进入烧录模式后，点击左下角的箭头符号即可进行烧录。 烧录成功后，可以看到开发板上的绿灯闪烁，将开发板连接到电脑USB口之后，可以在设备管理器中看到多出了一个串口设备。此时 Longan 板子就成功变成了 RV LINK 调试器。 ### 其他烧录方式 参考文档： [将 Longan Nano 开发板变成 RISC V 仿真器](https://gitee.com/zoomdy/RV LINK/wikis/%E5%B0%86%20Longan%20Nano%20%E5%BC%80%E5%8F%91%E6%9D%BF%E5%8F%98%E6%88%90%20RISC V%20%E4%BB%BF%E7%9C%9F%E5%99%A8) ## 使用 RV LINK 调试 ### 连接开发板 将刷好 RV LINK 固件的开发板与待调试开发板 jtag 连线按下表连接 RV LINK 待调试开发板 : : : : JTDO JTDO JTDI JTDI JTCK JTCK JTMS JTMS 3V3 3V3 GND GND #### WIN7 用户安装 GD 串口驱动 见此链接[安装 USB 串口驱动](https://gitee.com/zoomdy/RV LINK/wikis/GDB%20%E4%BD%BF%E7%94%A8%20RV LINK%20%E4%BB%BF%E7%9C%9F%E5%99%A8%E8%B0%83%E8%AF%95%20RISC V%20%E7%A8%8B%E5%BA%8F?sort_id 1667650#%E5%AE%89%E8%A3%85 usb %E4%B8%B2%E5%8F%A3%E9%A9%B1%E5%8A%A8) ### 在 PlatformIO IDE 中使用 RV LINK RV LINK 在 PlatformIO IDE 可以和其他调试器一样，支持一键启动调试。 只需要在工程的 `platformio.ini` 配置文件中，指定调试器选项和调试器端口选项。 示例代码 ```ini [env:sipeed longan nano] platform gd32v framework gd32vf103 sdk board sipeed longan nano monitor_speed 115200 upload_protocol rv link ; rv link下载选项 debug_tool rv link ; rv link调试选项 debug_port COM2 ; 使用rv link 必填此项 调试器串口 ``` ### 在其他平台使用 RV LINK 参考 [RV LINK WIKI](https://gitee.com/zoomdy/RV LINK/wikis/)"},"/hardware/zh/longan/Nano/get_started/sipeed-debugger.html":{"title":"使用 Sipeed 调试器","content":" title: 使用 Sipeed 调试器 ## Sipeed rv debugger ## Sipeed rv debugger lite"},"/hardware/zh/longan/Zero/index.html":{"title":"","content":"敬请期待"},"/hardware/zh/longan/index.html":{"title":"Longon 开发板","content":"# Longon 开发板 龙眼系列开发板是sipeed基于国产mcu芯片来设计的板子。方便与MCU开发者快速上手使用免于设计板子的麻烦。"},"/hardware/zh/longan/h618/lpi3h/3_images.html":{"title":"镜像集合","content":" title: 镜像集合 keywords: Linux, Longan, H618, SBC, ARM, image update: date: 2023 04 07 version: v1.1 author: ztd content: Add Debian CLI image date: 2023 12 08 version: v1.0 author: ztd content: Release docs ## Sipeed官方镜像 ### Debian Sipeed 官方镜像基于 Debian 系统修改适配。 默认镜像的帐号密码配置如下： 账户：`root`，密码： `root`； 账户： `sipeed`，密码：`licheepi`； **注意，不建议用root用户登陆桌面。** ![debian](./assets/images/debian.png) ![debian_neofetch](./assets/images/debian_neofetch.png) #### Changelog 20231220： 发布初版镜像 20240106： 更新EMMC启动支持 20240110： 添加 SD、EMMC 启动可烧录镜像文件 修复 DNS 问题 20240226： 添加 GPIO sysfs 允许使用 root 用户登陆 SSH 添加 USB gadget 功能 20240407： 添加 Debian CLI 版本镜像 下载地址： 百度网盘：[点我](https://pan.baidu.com/s/1VGaARAq6dbicFy4VOytRuw) 提取码: cd68 Mega 云盘：[点我](https://mega.nz/folder/gt50zDoC#LgRvHVCzWTUgGohKoMtlqA) ### Android 12 20240226： 发布初版镜像（无wifi/bt支持） 下载地址： 百度网盘：[点我](https://pan.baidu.com/s/1t cNlIIU0P8VDmkC518W6Q) 提取码: rb4d Mega 云盘：[点我](https://mega.nz/folder/Z14klTRI#l4aMYdxgFzUf SirkvdOhg)"},"/hardware/zh/longan/h618/lpi3h/1_intro.html":{"title":"板卡介绍","content":" title: 板卡介绍 keywords: Linux, Longan, H618, SBC, ARM update: date: 2023 12 08 version: v1.0 author: ztd content: Release docs ## 简介 Longan Pi 3H 是基于 Longan Module 3H 核心板的 ARM Linux 开发板，以 H618 (Quad core ARM Cortex A53@1.5Ghz , 64 bit) 为主控核心，板载最大 4GB 64bit LPDDR4，支持 HDMI 4K 显示输出。支持千兆网口，板载 wifi6/BT。 ## 基础参数 <table> <thead> <tr> <th colspan 2>主控参数</th> </tr> </thead> <tbody> <tr> <td>主控芯片</td> <td>H618</td> </tr> <tr> <td>CPU 处理器</td> <td>ARM Cortex A53@1.5Ghz <br>· 每核支持 32 KB L1 I cache + 32 KB L1 D cache <br>· 四核共享 1MB L2 Cache</td> </tr> <tr> <td>图形处理器</td> <td>Arm Mali G31 <br>· OpenCL 2.0<br>· OpenGL ES 1.0/2.0/3.2<br>· Vulkan 1.1</td> </tr> <tr> <td>视频解码器</td> <td>· 支持 H.264 BP/MP/ HP@L4.2 解码，最大 4K 分辨率<br>· 支持 AVS2 JiZhun 10bit 解码，最大 4K 分辨率 <br>· 解码性能最大 4K@60fps </td> </tr> <tr> <td>视频编码器</td> <td>· 支持 H.264 BP/MP/HP 编码，最大 4K 分辨率<br>· 仅支持 I 帧和 P 帧<br>· 编码性能最大 4K@25fps </td> </tr> <tr> <th colspan 2>硬件特性</th> </tr> <tr> <td>RAM</td> <td>· 1/2/4 GB 64bits LPDDR4<br></td> </tr> <tr> <td>存储</td> <td>· eMMC: 可选空贴、32G<br>· 支持 TF 卡</td> </tr> <tr> <td>以太网</td> <td>· 千兆以太网接口</td> </tr> <tr> <td>USB</td> <td>· 2 x USBA Host <br>· 1 x USBC OTG</td> </tr> <tr> <td>显示接口</td> <td>· 1 x 标准 HDMI 接口 </td> </tr> <tr> <td>GPIO</td> <td>· UART<br>· IIC<br>· SPI</td> </tr> </tbody> </table> ### 硬件资料下载 [LonganPi3H硬件资料](https://dl.sipeed.com/shareURL/LONGAN/LonganPi3H) ## 其他链接 [Github](https://github.com/sipeed/LonganPi 3H SDK) [淘宝]() QQ群: Telegram:  论坛：Maixhub.com/discussion 联系邮箱：support@sipeed.com"},"/hardware/zh/longan/h618/lpi3h/2_unbox.html":{"title":"开箱体验","content":" title: 开箱体验 keywords: Linux, Longan, H618, SBC, ARM, unbox update: date: 2023 12 08 version: v1.0 author: ztd content: Release docs ## 开箱内容 ## 配件 TBD ## 组装板卡 ## 板卡硬件说明 ### 硬件资料下载 [板卡规格书]() [底板原理图]() [底板点位图]() [底板尺寸图]() [模型文件]() ## 其他链接 [Github](https://github.com/sipeed/LonganPi 3H SDK) [淘宝]() [Sipeed 下载站]() QQ群: Telegram:  论坛：Maixhub.com/discussion 联系邮箱：support@sipeed.com"},"/hardware/zh/longan/h618/lpi3h/7_develop_android.html":{"title":"Android 开发","content":" title: Android 开发 keywords: Android, Longan, H618, SBC, ARM, Kernel, SDK, Develop update: date: 2024 02 26 version: v1.0 author: ztd content: Release docs ## Android SDK TODO"},"/hardware/zh/longan/h618/lpi3h/5_desktop.html":{"title":"桌面系统基础使用","content":" title: 桌面系统基础使用 keywords: Linux, Longan, H618, SBC, ARM, Debian, Desktop update: date: 2023 12 08 version: v1.0 author: ztd content: Release docs ## 登录系统 本篇文档以默认的 Debian 桌面系统为例，介绍基础系统使用操作。 默认镜像的帐号密码配置如下： 账户： `sipeed`，密码：`licheepi`； 账户：`root`，密码： `root`； 镜像默认开启了自动登陆，登陆用户为 `sipeed`。 若不需要自动登陆，将 `/usr/share/lightdm/lightdm.conf.d/01_debian.conf` 文件中的 `autologin user sipeed` 注释掉即可。 ## 打开命令行 在 LonganPi 3H 的 Debian 图形化系统中，使用快捷键 `Ctrl` + `Alt` + `T` 三个组合键可以直接打开命令行终端，来快速方便地操作系统。 ## 连接网络 桌面系统默认使用 connman 来管理网络连接。 可以在左上角的应用菜单中找到 `connman settings`，点击后桌面右上角会出现一个网络图标，点击右上角的网络图标即可新建网络连接和查看网络连接信息： ![connman_enable](./assets/desktop/connman_enable.png) ### 连接有线网络 串口中可以通过 connmanctl 来启用有线网络连接和查看相关信息： ```shell connmanctl enable ethernet ``` LonganPi 3H 有一个千兆网络接口；将已经接通网络的网线插入到 LonganPi 3H 的网络接口中，就能实现连接有线网络了，可以点击右上角的图标看到连接信息： ![connman_connect_eth](./assets/desktop/connman_connect_eth.png) ### 连接无线网络 LonganPi 3H 板载无线模组，支持蓝牙和 wifi 。 图形界面方式： 点击右上角的网络图标，切换到 wifi 连接的页面，选中想要连接的 wifi 再点击 connect 即可： ![connman_connect_wifi](./assets/desktop/connman_connect_wifi.png) 命令行方式： 可以使用 connmanctl 来启用 wifi 连接和查看相关信息： ```shell connmanctl enable wifi ``` 打开命令行，使用 `wpa_supplicant` 可以连接 wifi。下面的步骤需要切换到 root 用户执行： ```shell sudo i nano /etc/wpa_supplicant.conf ``` 创建 wpa_supplicant.conf 文件并填入 wifi 的 ssid 和 psk 信息： ```txt network { ssid \"your_wifi_name\" #psk \"your_wifi_password\" } ``` 填写完成后运行下面的命令即可连接 wifi。 ```shell wpa_supplicant D nl80211 i 网卡名 c /etc/wpa_supplicant.conf & ``` 若连接后没有 IP 地址，用 dhcp 获取一个ip地址即可： ```shell dhclient ``` ## 连接蓝牙 串口中，可以通过 connmanctl 启用蓝牙连接和查看相关信息： ```shell connmanctl enable bluetooth ``` 桌面系统默认使用 blueman 来管理蓝牙连接。 找到桌面右上角的蓝牙图标，确认蓝牙功能已经打开，若没打开，右键单击蓝牙图标即可打开： ![bluetooth_icon.png](./assets/desktop/bluetooth_icon.png) 打开后，左键单击蓝牙图标，可以看到蓝牙设备扫描界面 点击该界面左上角的Search即可搜索蓝牙设备，将蓝牙键鼠、蓝牙耳机等设备的配对模式打开即可被扫描到。 右键选择想要连接的设备，即可连接。成功连接后还可以右键该设备，点击Trust，下次扫描到即可自动连接。 ![bluetooth_devices.png](./assets/desktop/bluetooth_devices.png) 若蓝牙图形管理界面无法搜索到设备，也可以现在命令行界面下使用`bluetoothctl`来进行配对，步骤如下： ```shell bluetoothctl scan on # 找到想要配对设备的mac地址 pair 目标设备的mac地址 connect 目标设备的mac地址 ``` ## 软件安装 在完成网络连接后，即可进行软件包的更新，安装。 ### 软件源 在 Debian 系统中，可以使用 apt (Advanced Packaging Tool) 来进行软件的安装。 安装软件的时候，会从系统指定的软件网站中搜索并下载目标软件，当目标网站访问困难（比如服务器距离太远或者服务器网络不佳）时，可以手动设置编辑软件源网站，改成距离自己当前最近的源，来减少下载时间。 软件源默认使用 `/etc/apt/sources.list` 文件里面的内容，有额外需要的话可以自行更改。 ### 升级软件 使用 `sudo apt update` 可以更新软件列表，一般在更换软件源之后需要使用这个命令。 使用这个命令前，先用 `date` 命令查看一下时间，若系统时间有误或连接网络后没有自动更新时间，可以手动更新一下，确保软件源内的软件包是最新版本： ```shell sudo date s \"20230717 12:00:00\" ``` 然后使用 `sudo apt upgrade package_name` 可以更新名称为 `package_name` 的软件。 ### 安装程序 可以借助于 apt 命令来安装软件；比如使用 `sudo apt install package_name` 命令来安装 `package_name`，将 `package_name` 替换成给你想要安装的软件包名称即可。 ## SSH 如果你的镜像里没有 ssh 或 sshd 指令，可以先通过以下指令安装： ```bash sudo apt install ssh openssh server ``` 安装之后即可使用 ssh 来远程登录到其它机器操作，或者在其它机器上使用 ssh 登录到 LicheePi 4A 还可以使用 scp 进行文件传输： ```bash scp demo.zip sipeed@192.168.1.9:~/ ``` ## 输入法 如果你需要进行非 ascii 的字符输入，就需要安装输入法，这里以中文输入法为例，其它语言请自行查找相关教程。 先安装 ibus libpinyin： ```bash sudo apt install y ibus libpinyin ``` > 注意这里会消耗约200MB磁盘空间 安装完后，重启板卡，即可在 Applications 下看到 `IBus Preference` 选项，点击进入设置。 ![pinyin_cfg0](./assets/desktop/pinyin_cfg0.png) 在出现的界面里点击 `Input Method`，点击 `Add`，选择 `Chinese`，选择 `Intelligent Pinyin`，点击 `Add`，即可添加中文拼音输入法。 ![pinyin_cfg1](./assets/desktop/pinyin_cfg1.png) 在右上角点击输入法图标，可见以下选项，选择 `Chinese Intelligent Pinyin` 即可。 ![pinyin_cfg2](./assets/desktop/pinyin_cfg2.png) 此时即可在系统中顺利输入中文。 ## 浏览器 系统内置了 Firefox 浏览器，点击桌面下方的浏览器图标即可使用： ![browser_location](./assets/desktop/browser_location.png) 效果如下： ![firefox_usage](./assets/desktop/firefox_usage.png) ## 播放器 可以通过命令安装 VLC 播放器： ```shell sudo apt install vlc ``` 安装完成后播放视频的效果如下： ![vlc_player_usage](./assets/desktop/vlc_player_usage.png) ## 编程开发 ### Python 系统已内置了 python3 环境，可以在终端直接运行 `python3` 命令： ![python_usage](./assets/desktop/python_usage.png) 如果需要安装Python包，则使用：`sudo apt install python3 XXX` 比如安装pyserial包：`sudo apt install python3 serial` 即可。 ### C 需要安装 `build essential` 包，占用约800MB磁盘空间 ```bash sudo apt install build essential ``` 然后即可使用 gcc 进行相关操作： ![gcc_usage](./assets/desktop/gcc_usage.png) ## 更多 欢迎投稿～ 投稿接受后可得￥5～150（$1~20）优惠券！"},"/hardware/zh/longan/h618/lpi3h/4_burn_image.html":{"title":"烧录镜像","content":" title: 烧录镜像 keywords: Linux, Longan, H618, SBC, ARM, image update: date: 2023 12 08 version: v1.0 author: ztd content: Release docs ## 准备工作 ### 获取镜像 参见上一章[镜像集合](https://wiki.sipeed.com/hardware/zh/longan/h618/lpi3h/3_images.html)，选取需要的镜像下载。 ### 获取烧录工具 烧录镜像至 SD 卡的工具常见的有 balenaEtcher，rufus 等，这里以 balenaEtcher 为例，首先去[balenaEtcher官网](https://etcher.balena.io/#download etcher)下载并安装该软件。 Linux 下也可以使用 dd 命令直接写入。 ## 烧录镜像 ### 烧录 Linux 镜像至 SD 卡 准备好要烧录的镜像后，打开 balenaEtcher，先选择要烧录的镜像文件： ![select_image](./assets/burn_image/select_image.png) 然后选择要烧录的目标设备： ![select_device](./assets/burn_image/select_device.png) 最后点击烧录，等待烧录完成后，就得到了包含启动镜像的 SD 卡： ![flash_image](./assets/burn_image/flash_image.png) Windows 系统和 Linux 的步骤类似。 ### 烧录 Linux 镜像至 EMMC **注意需要使用20240106及以上版本的镜像** 先准备一张启动 TF 卡，进入到系统，然后使用 SCP 等工具将 EMMC 镜像文件拷贝到 TF 卡的系统中，然后使用 dd 命令将镜像文件写入 EMMC： 如何确定EMMC在系统内的节点: ``` ls /dev/mmcblk* grep boot head n 1 sed e 's/boot0//g' ``` ```shell # 假设镜像文件复制到 /opt/ 目录下 # 将X替换为上面得到的节点 dd if /opt/your_image_file of /dev/mmcblkX sync ``` 等到烧录完成后，拔掉 SD 卡，即可从EMMC进入系统。 若要使用 EMMC 启动，并使用SD卡扩容，需要确保SD卡已格式化，其中不包含启动镜像，否则因为优先级的问题可能会变为SD卡启动。 ### 烧录安卓镜像至 SD 卡 **注意，安卓镜像不能使用 balenaEtcher 进行烧录，需要使用 PhoenixCard 烧录后才能启动。** 首先下载网盘中的 PhoenixCard 工具，打开后选择第二项：启动卡。将安卓镜像烧录到 TF 卡中即可使用。 ![flash_to_sd](./assets/burn_image/flash_to_sd.png) ### 烧录安卓镜像至 EMMC 打开 PhoenixCard，选择第一项：量产卡。烧录安卓镜像到 TF 卡中，然后将TF卡插入到底板，上电，此时会自动将安卓镜像烧录到 EMMC 中，等待烧录完成后拔掉 TF 卡即可使用 EMMC 的中安卓镜像。 ![flash_to_emmc](./assets/burn_image/flash_to_emmc.png)"},"/hardware/zh/longan/h618/lpi3h/8_test_report.html":{"title":"板卡测试","content":" title: 板卡测试 keywords: Linux, Longan, H618, SBC, ARM, test update: date: 2023 12 08 version: v1.0 author: ztd content: Release docs "},"/hardware/zh/longan/h618/lpi3h/6_peripheral.html":{"title":"外设使用","content":" title: 外设使用 keywords: Linux, Longan, H618, SBC, ARM, Peripheral update: date: 2023 12 08 version: v1.0 author: ztd content: Release docs ## SoC 相关 ### CPU 运行频率 ```shell sudo cat /sys/devices/system/cpu/cpu*/cpufreq/cpuinfo_cur_freq ``` 单位为 KHz 注意系统自带温控策略，当系统过于空闲或者温度过高时，都会降频。 ## PWM TODO ## GPIO ![io_map](./assets/peripheral/io_map.jpeg) ![pin_num](./assets/peripheral/pin_num.png) 参考上面的两个表格，可以找到要使用的 GPIO 对应的位置和序号，以点亮底板上的两个 LED 灯为例，可以使用命令在用户空间操作对应的 GPIO： 使用前先检查 GPIO 是否被占用 ```shell sudo cat /sys/kernel/debug/gpio ``` ```shell num 194 echo ${num} > /sys/class/gpio/export echo out > /sys/class/gpio/gpio${num}/direction echo 0 > /sys/class/gpio/gpio${num}/value num 196 echo ${num} > /sys/class/gpio/export echo out > /sys/class/gpio/gpio${num}/direction echo 0 > /sys/class/gpio/gpio${num}/value ``` 除了上述方法外，还可以通过 C 语言的 libgpiod 库来操作 GPIO，下面仍然以底板上的 LED 灯为例 ```c #include <gpiod.h> #include <stdio.h> #include <unistd.h> #include <stdlib.h> int main(int argc, char **argv) { int i; int ret; struct gpiod_chip * chip; struct gpiod_line * line; chip gpiod_chip_open(\"/dev/gpiochip0\"); if(chip NULL) { printf(\"gpiod_chip_open error\\n\"); return 1; } line gpiod_chip_get_line(chip, 194); if(line NULL) { printf(\"gpiod_chip_get_line error\\n\"); gpiod_line_release(line); } ret gpiod_line_request_output(line,\"gpio\",0); if(ret < 0) { printf(\"gpiod_line_request_output error\\n\"); gpiod_chip_close(chip); } for(i 0; i < 10; i++) { gpiod_line_set_value(line,1); sleep(1); gpiod_line_set_value(line,0); sleep(1); } gpiod_line_release(line); gpiod_chip_close(chip); return 0; } ``` 首先安装需要的依赖： ```shell sudo apt update sudo apt install build essential libgpiod dev gpiod ``` 编译后，需要使用 root 权限来执行程序： ```shell gcc gpio.c I /usr/include/ L /usr/lib/aarch64 linux gnu/ lgpiod o gpio sudo ./gpio ``` libgpiod 也提供了一些命令来操作 gpio，常用的命令如下： gpiodetect：列出所有的 GPIO 控制器 ```shell sudo gpiodetect ``` gpioinfo：列出 GPIO 控制器的引脚情况，可以查看哪些引脚已经被使用 ```shell sudo gpioinfo gpiochip0 ``` gpioset：设置 GPIO 引脚的状态 ```shell sudo gpioset gpiochip0 196 0 ``` gpioget：获取 GPIO 引脚状态 ```shell sudo gpioget gpiochip0 196 ``` ## UART ### 系统串口 LonganPi 3H 的系统串口是 UART0,在侧边插针中有引出。 ![uart_pin](./assets/peripheral/uart_pin.png) 你可以使用 USB 转串口模块连接该串口，即 `U0 RX` 和 `U0 TX`，注意交叉连接，以及 GND 连接(下图中还多接了一根供电线，若用 typeC 口供电可以不接这根供电线)。 ![uart_connect](./assets/peripheral/uart_connect.png) 连接完成后，即可使用串口工具进行通信，Windows 下推荐 `XShell`，`mobaterm`，Linux下推荐 `minicom` 设置串口波特率为 `115200`，即可在串口终端下登录并进行指令操作： > 注：刚连接后可以敲几个回车查看是否有反应，如果没有反应则检查接线或者串口配置 ### 一般串口 除系统串口 UART0 外，设备树中也默认使能了 UART1，UART2，UART3，UART4 串口，可以根据需要使用。 #### 查看串口设备 ```bash ls /dev/ttyS* ``` #### 查看串口的波特率等信息 ```bash stty F /dev/ttyS1 a ``` #### 设置串口波特率、数据模式 ```bash stty F /dev/ttyS1 ispeed 115200 ospeed 115200 cs8 ``` #### 查看串口数据 ```bash cat /dev/ttyS1 ``` #### 发送串口数据 ```bash echo \"LonganPi3H\" > /dev/ttyS1 ``` #### 其它方法 也可以使用`minicom`，或者pyserial库进行串口操作，请用户自行查找相关资料使用。若要使用非常见波特率，可以使用`picocom`。 ## I2C TODO ## SPI TODO ## HDMI 显示 LonganPi 3H 最高支持 4k 分辨率的显示，效果如图所示： ![hdmi_connect](./assets/peripheral/hdmi_connect.jpg) 若插入 HDMI 显示器后没有显示，可以尝试在命令行中使用 xrandr 来更换显示配置参数。 首先导出 DISPLAY 变量 ```shell export DISPLAY :0.0 ``` 然后用 xrandr 查看可用的参数： ```shell sipeed@lpi3h ce8e:~$ xrandr Screen 0: minimum 320 x 200, current 1920 x 1080, maximum 8192 x 8192 HDMI 1 connected 1920x1080+0+0 (normal left inverted right x axis y axis) 255mm x 220mm 1920x1080 60.00*+ 60.00 59.94 1400x1050 59.95 1280x1024 75.02 60.02 1440x900 59.90 1280x960 60.00 1152x864 75.00 1280x720 60.00 59.94 1024x768 75.03 70.07 60.00 832x624 74.55 800x600 72.19 75.00 60.32 56.25 640x480 75.00 72.81 66.67 60.00 59.94 720x400 70.08 ``` 根据上述命令的输出，我们可以尝试更换分辨率，帧率等配置，比如更换为 1440x900 分辨率： ```shell xrandr xrandr output HDMI 1 mode 1440x900 ``` 有些参数可能会导致屏幕不亮，遇到插入 HDMI 显示器无显示时，可以用这个命令来调整至能亮的显示参数，也可以在系统设置中的 Dispaly 图形化菜单中调节。 若发现使用较高分辨率时有闪屏问题，可以尝试在图形化的设置显示的菜单中降低刷新率。 ## HDMI 音频 TODO ## GPU TODO ## 其它 欢迎投稿～ 投稿接受后可得￥5～150（$1~20）优惠券！"},"/hardware/zh/longan/h618/lpi3h/7_develop_mainline.html":{"title":"主线 Linux","content":" title: 主线 Linux keywords: Linux, Longan, H618, SBC, ARM, Kernel, SDK, Develop update: date: 2024 05 08 version: v1.2 author: 0x754C content: Rewrite build script date: 2024 04 07 version: v1.1 author: ztd content: Add Debian & Ubuntu CLI image build instructions. date: 2023 12 08 version: v1.0 author: ztd content: Release docs 该文档以 Ubuntu 22.04 为例，演示如何搭建 LonganPi 3H 开发环境并进行主线Linux的开发。 在正式合并入主线前，需要拉取 Github 仓库，获取patch开发，预计将于 2024Q1 合并入主线Linux。 ## 环境配置 首先用 git 拉取仓库到本地 ```shell git clone https://github.com/sipeed/LonganPi 3H SDK.git ``` 然后根据README设置构建环境 ## 构建 进入到仓库所在目录，运行其中的脚本: ```shell cd LonganPi 3H SDK # 文件会输出在 build 目录下 ./mkatf.sh # 编译atf, 输出bin文件,用作uboot构建 ./mklinux.sh # 编译linux， 输出deb文件,用作rootfs构建 ./mkuboot.sh # 编译uboot, 输出bin文件,用作image构建 ./mkoverlay.sh # 打包overlay, 输出deb文件,用作rootfs构建 ./mkrootfs.sh # 打包rootfs, 输出tar文件,用作image构建 ./mkimage.sh # 打包启动镜像,输出img文件,最终文件 ls ./build/images/sdcard.img # 用于烧录的文件 ``` 接下来介绍 SDK 仓库的主要文件构成及其作用： `linux` 文件夹下，存放的是 kernel 的 patch 文件，在第一次运行 mklinux.sh 时会自动将这些 patch 打入到 kernel 源码中。 `uboot` 文件夹下，存放的是 uboot 的 patch 文件， 在第一次运行 mkuboot.sh 时会自动将这些 patch 打入到 uboot 源码中。 `overlay` 文件夹下有一些用于自定义镜像的文件，在运行 mkoverlay.sh 时会将这些文件打包为overlay.deb `mkrootfs.sh` 用于构建rootfs的tar归档文件 `mkimage.sh` 用于构建可以启动的SD卡镜像 构建完成后，可以参考[烧录镜像](https://wiki.sipeed.com/hardware/zh/longan/h618/lpi3h/4_burn_image.html)把得到的 img 镜像文件烧录到 TF 卡中。"},"/hardware/zh/longan/One/index.html":{"title":"","content":"敬请期待"},"/hardware/zh/maixface/mfst40/mfst40.html":{"title":"MF-ST40 人脸识别模块","content":" title: MF ST40 人脸识别模块 keywords: M1s DOCK ,BL808, M1s update: date: 2022 11 07 version: v0.1 author: wonder content: 初次编写 > 本产品不对个人技术支持，个人需求请购买 [M1s 模组](./../../maix/m1s/m1s_module.html) ## 产品概述 MF ST40 人脸识别模组基于博流 BL808 芯片设计，模组内部预留了 WIFI 功能、 SPI 屏幕接口、多路 UART 接口和 RTC 电路，较大地提高了用户整机产品的集成度。 购买链接：[淘宝](https://item.taobao.com/item.htm?id 690754113762) 产品图片： <table> <tr> <th align \"center\">模组图片</th> <th align \"center\">演示机图片</th> </tr> <tr> <td> <table> <tr> <td align \"center\">正面图</td> <td align \"center\">背部图</td> </tr> <tr> <td><img alt \"product_top\" src \"./assets/product_top.jpg\"></td> <td><img alt \"product_bottom\" src \"./assets/product_bottom.jpg\"></td> </tr> </table> </td> <td> <table> <tr> <td align \"center\">正面图</td> <td align \"center\">背部图</td> </tr> <tr> <td><img alt \"product_top_screen\" src \"./assets/product_top_screen.jpg\"></td> <td><img alt \"product_bottom_screen\" src \"./assets/product_bottom_screen.jpg\"></td> </tr> </table> </td> </tr> <table> ## 关键特性 主处理器：博流 808 双核 AI 芯片 核心算法：活体人脸识别 识别距离：0.35 0.9m 识别速度：上电到解锁 1.0 秒内 识别角度：H50° V70° 识别环境：无环境光也可以识别 功耗：单次解锁 0.36mWh 兼容主流锁孔、可选电子猫眼、可选音视频对讲 应用：门锁、考勤机、其他人脸识别终端产品 ## 相关资料 详细说明请查阅下方的 [规格书](https://dl.sipeed.com/shareURL/MaixFace/MF SF40/1_Specification) [规格书](https://dl.sipeed.com/shareURL/MaixFace/MF SF40/1_Specification) [原理图](https://dl.sipeed.com/shareURL/MaixFace/MF SF40/2_Schematic) [点位图](https://dl.sipeed.com/shareURL/MaixFace/MF SF40/3_Bit_number_map) [尺寸图](https://dl.sipeed.com/shareURL/MaixFace/MF SF40/4_Dimensional_drawing) [3D 模型文件](https://dl.sipeed.com/shareURL/MaixFace/MF SF40/5_3D_file) [芯片手册](https://dl.sipeed.com/shareURL/MaixFace/MF SF40/6_Chip_Manual) ## 注意事项 <table> <tr> <th>项目</th> <th>注意事项</th> </tr> <tr> <td>静电防护</td> <td>请避免静电打到 PCBA 上；接触 PCBA 之前请把手的静电释放掉</td> </tr> <tr> <td>容忍电压</td> <td> 每个 GPIO 的工作电压已经在原理图中标注出来，请不要让 GPIO 的实际工作的电压超过额定值，否则会引起 PCBA 的永久性损坏 </td> </tr> <tr> <td>FPC 座子</td> <td>在连接 FPC 软排线的时候，请确保排线无偏侈地完整地插入到排线中</td> </tr> <tr> <td>插拔</td> <td>请完全断电后才进行插拔操作</td> </tr> <tr> <td>避免短路</td> <td>请在上电过程中，避免任何液体和金属触碰到 PCBA 上的元件的焊盘，否则会导致路，烧毁 PCBA</td> </tr> </table> ## 技术支持 MF ST40 为商业合作产品，不对个人用户进行技术支持，个人用户建议使用 [M1s 模组](./../../maix/m1s/m1s_module.html)。 联系邮箱: `support@sipeed.com`"},"/hardware/zh/maixface/core_modules/k210_core_modules.html":{"title":"K210 核心模块","content":"# K210 核心模块 现有四款基于 K210 开发的 AIOT 模块：M1, M1w, M1n, MF0 特性说明： 这四款模块都是基于嘉楠堪智科技的边缘智能计算芯片K210（RISC V架构）设计的。主控芯片内置64位双核高性能低功耗处理器，每个核都有浮点运算单元（FPU），具备卷积人工神经网络智能硬件加速器（KPU）和快速傅里叶变换加速器（FFT）、搭载现场可编程IO阵列（FPIOA），支持多种主流AI编程框架。 ### Maix AIOT 模块差异对比 M1 M1w M1n MF0 外观 ![M1 模组](./../assets/mf_module/m1_m1w/sipeed_m1_module.png) ![M1W 模组](./../assets/mf_module/m1_m1w/sipeed_m1w_module.png) ![M1n 模组](./../assets/mf_module/m1n/sipeed_m1n_module.png) ![MF0 模组](./../assets/mf_module/mf0_mf0dock/sipeed_mf0_module.png) 尺寸 25.4x25.4x3.3（mm） 25.4x25.4x3.3（mm） 25.0x22.0x2.7（mm） 20.0x20.0x4.5（mm） 电压输出（提供给底板使用） 1.8V和3.3V 1.8V和3.3V 1.8V和3.3V 3.3V 最大功耗（非瞬态） 1.5W 3W 1.5W 1.5W WIFI功能 无 有（K210与ESP8285通过SPI接口和串口连接） 无 无 板载摄像头连接器 无 无 有（仅兼容单摄像头） 有（仅兼容单摄像头） 引脚形式 邮票孔 邮票孔 NGFF金手指 B KEY 2.54mm间距直插焊盘+SMD焊盘 是否引出摄像头信号 全引出 全引出 全引出 无 是否引出屏幕信号 全引出 全引出 全引出 无 引出普通IO口数量 48个（全引出） 48个（全引出） 44个（IO0 3没引出） 9个 ## 模块引脚定义 具体可下载规格书 M1/M1w: https://dl.sipeed.com/MAIX/HDK/Sipeed M1&M1W/Specifications M1n: https://dl.sipeed.com/MAIX/HDK/Sipeed M1n MF0: https://dl.sipeed.com/MAIX/HDK/Sipeed MF0/MF0 2802 ## M1/M1W(k210) ISP 模式(烧录模式) 更新 K210 时，需要让 K210 进入 ISP 模式，相关信息如下： ISP 引脚 ISP 引脚 描述 备注 BOOT (IO_16) 启动模式选择 低电平进入，ISP 模式 ISP_RX (IO_4) ISP 串口数据接收 ISP_TX (IO_5) ISP 串口数据发送 Boot 选择 **IO_16** 用于 **boot** 模式选择，上电时，拉高进入 **Flash** 启动，拉低进入 **ISP** 模式 Boot 选择引脚 拉高 拉低 IO_16 Flash 启动 ISP 模式 > K210 ISP 模式下，串口波特率建议配置为: 115200，1 停止位，8 数据位，不校验。 参考自动进入下载模式电路： ![](../../assets/mf_module/m1_m1w/K210_boot_reference.png) 参考来源： > 《K210技术规格书 v0.1.5》 > 2.5 特殊引脚: IO_16 用于 boot 模式选择，上电复位时，拉高进入 FLASH 启动，拉低进入 ISP 模式。复位后，IO_0、 IO_1、IO_2、IO_3 为 JTAG 引脚。IO_4、IO_5 为 ISP 引脚。 ## MF PCB 注意事项 使用 K210(M1/M1W) 自行设计人脸识别产品，请参考 [《MF 人脸识别模块 PCB 设计注意事项》](../mf_ml_module/mf_precautions.html)"},"/hardware/zh/maixface/mf_ml_module/mf_precautions.html":{"title":"MF PCB 设计注意事项","content":"# MF PCB 设计注意事项 ## 补光灯： 1、850nm 红外补光灯可以考虑选用 1W 或者 3W 功率的灯珠，因为更大功率的灯珠可以延长使用寿命、减少故障率和提高识别效果 2、红外灯珠和白光灯珠的驱动电路和元件参数，一定要根据实际灯珠选型和数量决定。因为不同的电路成本不一样，亮度感觉不一样，不同客户的需求不一样，因此客户需要根据实际情况选择和调整参数。强烈建议使用光度计去控制整个设计调试和批量生产的红外灯珠亮度的一致性 3、850nm 光线具有一定的穿透性。 目前已证实红外补光灯的 850nm 光线会从摄像头模组的四周和后背穿透进去，影响成像，进而影响屏幕画面或者影响识别效果。 因此必须在摄像头和补光灯之间，用 850nm 无法穿透的材料/喷漆/胶布等阻隔从灯珠散射到摄像头内部的红外光线。 另外，也可以通过拉开红外灯珠与摄像头的距离，距离保持 15mm 以上就能减少 80% 的负面影响，距离保持 20mm 以上，红外线就基本不会透射进摄像头了 4、红外补光灯与外壳前盖板（亚克力/塑料等材质）之间的距离应尽量少，即补光灯与盖板尽量紧贴。如果补光灯与盖板距离较大，会严重影响识别效果 5、在白光补光灯方面，尽量放置多个LED，使用均光板做柔光处理。均光板的面积尽量大。目前市面上的方案有圆圈跑道式的均光板，有小范围片状式的均光板，这个请客户的结构工程师在使用体验和外观设计上对此进行设计。如果不做柔光处理，白光补光灯会刺眼，并且使用户眼睛有十几秒的残影，使用体验不好 6、白光灯珠和红外灯珠的焊盘，需要连接到尽可能大的铜皮，以此提高散热性能 7、白光补光灯对地的电容应该去掉，否则会导致开灯的时候复位 ## 基本信息： 1、M1/M1w 模块底部的散热焊盘，需要连接到尽可能大的铜皮，以此提高散热性能 2、模块的 5V 是输入，外部给模块供电的；模块的 1.8V 和 3.3V 是模块内部 DC DC 生成的，主要是给模块内部核心元件使用的，其次是给模块外部的小电流元件使用（比如作为屏幕和摄像头的 1.8V 参考电压等小电流需求。不建议提供给模块外部的大电流元件使用） 3、如果需要做电容触摸，尽量把触摸芯片放到靠近手指触摸的位置之下。因为触摸芯片到触摸面板之间的走线长度，长度越长越难把握灵敏度、越容易受干扰 4、如果使用 M1w 模块，则需要遵守天线的摆放原则来摆放 IPEX 2.4G 天线，否则信号会有较大程度的损失 5、M1/M1w 模块的 RST、BANK6/7、摄像头 8 位数据和屏幕 8 位数据的工作电压和容忍电压都是 1.8V，BANK0/1/2/3/4/5 的工作电压和容忍电压都是 3.3V 耐压，一定不能超出耐压范围使用。如果要把 RST 引脚引出使用，强烈建议增加保护电路，以下两种电路都可以起到保护/兼容更高电平的作用： ![](./../assets/other/mf_precautions.png) 6、IO16（BOOT）要在底板加 10K 上拉电阻到 3.3V 7、FPIOA 允许用户将 255 个内部功能映射到芯片外围的 48 个自由 IO 上 8、M1 和 M1w 的区别是：M1 没有 WIFI，M1w 有 WIFI，M1w 模块的 IO0 IO3 这 4 个引脚是 K210 与 WIFI(ESP8285) 芯片之间的 SPI 连接，因此不能用作其他用途 9、请一定要在 PCB 上预留 M1/M1w 模块的 K210 和 WIFI 的下载接口，具体可以参考我们提供的标案原理图 ### 认证方面： 1、所有信号都要在靠近源端的地方预留串联磁珠或者RC 低通滤波电路，用来消除过冲和振铃。 RC 参数是 100R+100PF（这是屏幕信号的参数，其他信号必须根据实际测试决定，不能影响正常功能）。 低通 RC 形式是指：信号从源端输出先经过电阻/磁珠后经过电容，RC 元件靠近源端放置。 2、尽量在各路电源VCC预留串联焊盘，可能需要焊接磁珠或者电感，注意磁珠需要选择额定电流大于实际工作电流的 3、尽量在每个可能泄漏的位置、使用到的IO和电源线路等地方加上 ESD 二极管。ESD 二极管放置的位置根据ESD设计原则摆放 4、为了提高ESD防护性能，应该在屏幕到主板之间预留足够的位置放置导电泡棉。主板在该位置阻焊开窗。该位置应尽量接近供电电源的GND 5、PCB四周尽量打过孔，让过孔包围着PCB，元件需要远离可能的静电泄露点"},"/hardware/zh/maixface/mf_ml_module/mf5_product.html":{"title":"MF5","content":"# MF5 ## MF5 外观一览 ## MF5 板载接口 <table border \"2\"> <tr> <th colspan 6>MaixFace 5 引脚信息</th> </tr> <tr> <td colspan 3><img src \"./../assets/mf_module/mf5/mf5_if_1.png\" height 400></td> <td colspan 3><img src \"./../assets/mf_module/mf5/mf5_if_2.png\" height 400></td> </tr> <tr> <td>Maix Face Slik</td> <td>K210 IO</td> <td>ESP8285 IO</td> <td>Function</td> <td>Remark</td> <td>IO Voltage</td> </tr> <tr> <td>VIN</td> <td> </td> <td> </td> <td>电源输入正极</td> <td>12V</td> <td rowspan 22>3.3V</td> </tr> <tr> <td>GND</td> <td> </td> <td> </td> <td>电源输入负极</td> <td>电源GND</td> </tr> <tr> <td>NC</td> <td> </td> <td> </td> <td>继电器常闭触点</td> <td rowspan 3>继电器</td> </tr> <tr> <td>COM</td> <td> </td> <td> </td> <td>继电器公共触点</td> </tr> <tr> <td>NO</td> <td> </td> <td> </td> <td>继电器常开触点</td> </tr> <tr> <td>GND</td> <td> </td> <td> </td> <td>韦根接口RETURN</td> <td rowspan 3>韦根接口</td> </tr> <tr> <td>WGD0</td> <td>IO14</td> <td> </td> <td>韦根接口 D0</td> </tr> <tr> <td>WGD1</td> <td>IO15</td> <td> </td> <td>韦根接口 D1</td> </tr> <tr> <td>GND</td> <td> </td> <td> </td> <td>开门信号地</td> <td rowspan 2>开门信号 低电平: Open</td> </tr> <tr> <td>OPEN</td> <td>IO16</td> <td> </td> <td>开门信号输入</td> </tr> <tr> <td>3V3</td> <td> </td> <td> </td> <td>3.3V</td> <td rowspan 6>以太网/刷卡接口</td> </tr> <tr> <td>CS</td> <td>IO24</td> <td> </td> <td>SPI CS</td> </tr> <tr> <td>MISO</td> <td>IO2</td> <td> </td> <td>SPI MISO</td> </tr> <tr> <td>SCLK</td> <td>IO1</td> <td> </td> <td>SPI SCLK</td> </tr> <tr> <td>MOSI</td> <td>IO3</td> <td> </td> <td>SPI MOSI</td> </tr> <tr> <td>GND</td> <td> </td> <td> </td> <td>GND</td> </tr> <tr> <td>5V</td> <td> </td> <td> </td> <td>5V</td> <td rowspan 6>串口/K210下载</td> </tr> <tr> <td>RST</td> <td>IO54</td> <td> </td> <td>K210复位</td> </tr> <tr> <td>BOOT</td> <td>IO16</td> <td> </td> <td>K210进入ISP模式</td> </tr> <tr> <td>ISPTX</td> <td>IO5</td> <td> </td> <td>ISPTX</td> </tr> <tr> <td>ISPRX</td> <td>IO4</td> <td> </td> <td>ISPRX</td> </tr> <tr> <td>GND</td> <td> </td> <td> </td> <td>GND</td> </tr> </table> ## MF5 固件说明 MF5 为人脸识别门禁成品，默认烧录的固件不支持串口协议； 在烧录串口协议固件之后，协议串口为 WGD0 IO14(RX)，WGD1 1O15(TX)。"},"/hardware/zh/maixface/mf_ml_module/mf0_ml_module.html":{"title":"MF0 机器学习核心模组","content":"# MF0 机器学习核心模组 ## 软硬件概述 MF0 人脸识别模块外观一览 <table border \"3\"> <tr> <th colspan 3>MF0</th> </tr> <tr> <td width \"100\">描述</td> <td>正面视图</td> <td>背面视图</td> </tr> <tr> <td width \"100\">MF0</td> <td> <img src \"./../assets/mf_module/mf0_mf0dock/mf0_pin_map.png\" width \"600\" alt \"MF0 正面\"> Pin Map</br> </td> <td> <img src \"./../assets/mf_module/mf0_mf0dock/mf0_buttom.png\" width \"600\" alt \"MF0 背面视图\"> </td> </tr> <tr> <td>MF0 Dock</td> <td> <! <img src \"../assets/mf_module/mf1_bottom_v2(nand).png\" width \"600\" alt \"MF1(NAND Flash) 背面视图\"> > </td> <td> </td> </tr> </table> ### 模块特性： CPU ：RISC V 64bit 双核处理器, 400Mhz 标准频率（可超频） 图像识别：QVGA@60FPS/VGA@30FPS 深度学习框架：TensorFlow/Keras/Darknet 外设：FPIOA、UART、GPIO、SPI、I²C、I²S、WDT、TIMER、etc 2.54mm 间距 DIP/SMT 焊盘 能连接到面包板 板载摄像头连接器 ROM：4MByte RAM：6MByte （通用） + 2MByte （ KPU 专用） ### 硬件 pin No. 描述 24 用户 IO24 25 用户 IO25 26 用户 IO26，MF0_Dock(LCD_RST) 27 用户 IO27，MF0_Dock(LCD_CLK) 28 用户 IO28，MF0_Dock(LCD_DC) 29 用户 IO29，MF0_Dock(LCD_SDA) BOOT 上电 boot 模式选择（用户 IO16，不建议用户使用） IO5 用户 IO5（ISP_TX） IO4 用户 IO4（ISP_RX） EN MF0 电源使能引脚, 默认高电平使能 RST K210 复位引脚 VIN 外部供电电源 3.4 5.9V（推荐 5.0V） GND 外部供电电源地 3V3 模块电源 3.3V 输出 ## 协议 串口协议： MFO 默认烧录 HEX 协议固件 MF0 有两种协议固件，方便用户根据具体需求使用 HEX 格式串口协议固件 JSON 格式串口协议固件 HEX 例程 ### 串口协议助手 ## 更新 MF0 固件 MF0 硬件连接： No. USB 转串口模块 MF0 IO 备注 1 5V VIN 2 GND GND 3 TX IO4 4 RX IO5 5 DTR BOOT 6 RTS RST ![](./../assets/mf_module/mf0_mf0dock/mf0_flash.png) MF0 Dock 硬件连接： 根据下表连接之后，使用 kflash_gui 下载时，需要按下 boot 和 rst 按键，并先松开 rst 再松开 boot 按键，确保 K210 进入下载模式（ISP 模式） No. USB 转串口模块 MF0 Dock IO 备注 1 5V VIN 2 GND GND 3 TX IO4 4 RX IO5 ![](./../zh/maixface/assets/mf_module/mf0_mf0dock/mf0_dock_flash.png) 然后使用 kflash_gui 下载 MF0 固件 ![](./../zh/maixface/assets/mf_module/mf0_mf0dock/mf0_upgrade_firmwave.png)"},"/hardware/zh/maixface/mf_ml_module/mf1_ml_module.html":{"title":"MF 人脸识别模块 MF1","content":"# MF 人脸识别模块 MF1 ## **修改记录** 版本时间修改内容 1.02019.07.30初始版本 1.22020.08.1 ## 目录 [MF 人脸识别模块 MF1](#mf 人脸识别模块 mf1) [**修改记录**](#修改记录) [目录](#目录) [**硬件资源简介**](#硬件资源简介) [**功能简介**](#功能简介) <! [微信小程序模块](#微信小程序模块) > <! [二次开发](#二次开发) > <! [**Q&A**](#qa) > ## **硬件资源简介** <center class \"half\"> <img src \"./../assests/front.png\" width 50% /><img src \"assests/bottom.jpg\" width 50% /> </center> * CPU : **RISC V** 双核 64bit、内置FPU、频率 400Mhz 500Mhz * 图像识别：活体识别 * 双摄像头：红外（IR）+可见光（VIS） * 红外填充光：3W 红外发光二极管 * 显示器：1.33 英寸 IPS、分辨率 240*320显示屏 * 其他外设：电容触摸按钮/支持 3W 扬声器/MEMS 麦克风/SD NAND/RGB LED * 无线功能(可选) : 支持 2.4G 802.11.b/g/n、SPI 连接 * [淘宝购买](https://item.taobao.com/item.htm?spm a1z10.1 c.w4004 21231188695.25.27ba52b1bsusf7&id 599138281058) <div STYLE \"page break after: always;\"></div> ## **功能简介** ![MF1 引脚图](./../assets/mf_module/mf1/mf1_pin_map.png)"},"/hardware/zh/maixface/mf_ml_module/mf_update_firmwave.html":{"title":"MF 固件相关升级说明","content":"# MF 固件相关升级说明 在使用 **MF 人脸识别模块**过程中，如果存在固件存在 bug、有新功能固件 release、误擦除固件、字体资源、图片资源，那么就需要通过烧录还原固件。 ## MF 人脸识别模块固件、资源说明 **MF 人脸识别模块** 固件、字体资源、图片资源、说明如下： 类型 烧录地址 长度 说明 固件 0x000000 人脸模型 字体资源 图片资源 板级配置 0x7FF000 4 KB 人脸信息 0x800000 64 KB > 一般开发者在拿到 MF 模块之后，不需要关心该资源分布 MF 固件说明 固件分类 方向 协议 识别方式 wechat 固件类型数量 MF0 体验版模块 横版, 竖版 bin vis 2 MF1 离线版模块 横版，竖版 bin/json vis+ir 8 MF1_to_MF2 横版，竖版 bin/json vis+ir 8 MF2 微信半成品 横版，竖版 bin vis 支持 2 MF4 微信 (成品) 竖版 bin vis 支持 1 MF5 微信 (成品) 竖版 bin/json vis 支持 2 字体资源 图片资源 清除配信息 ## MF1 固件烧录(升级，还原出厂配置)步骤 在使用 **MF 人脸识别模块**过程中，如果存在固件存在 bug、有新功能固件 release、误擦除固件、字体资源、图片资源，那么就需要通过烧录还原固件。 烧录步骤： 1. 烧录 key_gen.bin 获取 key 2. 通过 support@sipeed.com 获取模型文件 3. 烧录模型文件 4. 烧录图片，字体资源， ### 准备： 在升级，还原出厂配置**MF 人脸识别模块** 之前我们需要准备软硬件。 **硬件准备：** **MF 人脸识别模块** USB Type C 数据线 **软件准备：** 烧录软件： kflash_gui(这里使用 kflash_gui v1.6.5 版本) 下载链接: Github: [kflash_gui](https://github.com/Sipeed/kflash_gui) Sipeed: [Sipeed 官方下载站 kflash_gui](https://dl.sipeed.com/MAIX/tools/kflash_gui/kflash_gui_v1.6.5) 烧录资源文件(根据情况烧录)：**MF 人脸识别模块固件**、算法模型文件、字体资源文件、图片资源文件 资源文件获取统一发送邮件到: Email: Support@sipeed.com 推荐发送邮件格式如下: > 问题类型: [MF 固件资源获取/（简短描述你的问题）] > > 使用硬件/固件版本: [MF0/MF1/MF2/MF4/MF5(这里标注使用的究竟是哪个模块、产品)] > > 内容: [最新固件获取/固件丢失/模型丢失(描述相关情况)] > > 机器码: [xxxxxxxxxxxxxxxxxxxxx(只有模型丢失时需要)] ### 烧录固件,资源文件 使用USB Type C 数据线 将**MF 人脸识别模块** 连接 电脑 ![MF1 connect USB](./../assets/mf_module/mf1/mf1_view.png) 打开 Kflash_gui 选择需要烧录的文件，选择版型(默认选择`自动选择`， 如果烧录失败则选择 `MaixDuino`)，选择串口号(CH522 有两个串口，失败则尝试另外一个)，配置波特率(默认选择 `150000`, 如果烧录失败则适当减低波特率,如 `115200`) ![image 20200806103433410](./../../maix/assets/kflash_gui/image 20200806103433410.png) ![image 20200806105056527](./../../maix/assets/kflash_gui/image 20200806105056527.png) ## 怎么获取 Key(机器码) 在使用过程中,如果模块的模型丢失或需要更换,需要发送 `Key` 到 <Support@sipeed.com> 推荐发送邮件格式如下: 首先下载 [key_gen.bin](https://fdvad021asfd8q.oss cn hangzhou.aliyuncs.com/Sipeed_M1/firmware/key_gen_v1.2.bin) 使用 `kflash_gui` 将固件 `key_gen.bin` 烧录到模块中之后,打开串口,波特率为`115200,8,N,1` > **[kflash_gui](https://github.com/Sipeed/kflash_gui/releases)** 为 K210 固件烧录工具, 源码: [**Sipeed/kflash_gui**](https://github.com/Sipeed/kflash_gui) 建议使用 [`XCOM`](tools/XCOM_V2.6.exe) 来看串口信息 轻点 `DTR` ,再松开,即可使模块复位,看到启动信息 <center class \"half\"> <img src \"../../../zh/maix/assets/other/how_to_get_key.png\" height 50% width 80% /> </center> ## MF 固件横竖版说明 由于采用的摄像头成像方向不同，相差 90度，摄像头寄存器无法配置旋转（软件旋转降低效率），故有横竖版两种固件； 如何确认摄像头对应的固件：（通过摄像头丝印区分） 横板 竖版 ![](./../assets/mf_module/mf1/mf_dual_camera_1.jpg) ![](./../assets/mf_module/mf1/mf_dual_camera_2.png) "},"/hardware/zh/maixzero/sense/start.html":{"title":"M0sense 上手使用","content":" title: M0sense 上手使用 keywords: M0sense update: date: 2023 02 03 version: v0.2 author: wonder content: 增加早期固件说明 date: 2022 11 28 version: v0.1 author: wonder content: 初次编辑 > 因为固件不同，m0sense 可能显示不出 U 盘，需要自己根据 [烧录 bin 文件](#烧录 bin 文件) 篇章的内容烧录后才能显示 U 盘。 ## 初见 > 因为固件不同，可能不会有频谱图显示。 通电后板子上的 led 亮起，且屏幕显示出周围环境音的频谱图。 <img src \"./assets/start/m0sense_start.jpg\" alt \"m0sense_start\" width \"45%\"> <img src \"./assets/start/m0sense_start_screen.jpg\" alt \"m0sense_start_screen\" width \"45%\"> ## U 盘烧录 对于 M0sense 我们提供了使用虚拟 U 盘拖拽烧录固件的方式。 > 因为固件不同，m0sense 可能显示不出 U 盘，需要自己根据 [烧录 bin 文件](#烧录 bin 文件) 篇章的内容烧录后才能显示 U 盘。 按住板子上的 BOOT 键后按下 RESET 键，就会在电脑上显示一个 U 盘了。 ![m0sense_udisk](./assets/start/m0sense_udisk.jpg) 直接将想要烧录的固件拖进 U 盘，成功烧录后 U 盘会自动弹出且板子会自动复位来重新加载新固件。 ![m0sense_drag_burn](./assets/start/m0sense_drag_burn.gif) 这边提供了几个 Demo 固件 [点我跳转](https://dl.sipeed.com/shareURL/Maix Zero/M0sense/7_Example_demos)，可以直接拖拽到 U 盘查看烧录结果，其对应的源码均可在 [github](https://github.com/sipeed/M0sense_BL702_example) 上面获取。 > 源码镜像地址： https://gitee.com/sipeed/M0sense_BL702_example 下面是这几个 demo 固件的说明与效果展示 ### hello_world.uf2 [点我下载](https://dl.sipeed.com/shareURL/Maix Zero/M0sense/7_Example_demos/hello_world) 通过 U 盘烧录方式将它烧录进板子后，可以通过串口软件打开板子串口，可以看到板子打印出的 `Hello,World` ![m0sense_hello_world](./assets/start/m0sense_hello_world.gif) ### blink_baremetal.uf2 [点我下载](https://dl.sipeed.com/shareURL/Maix Zero/M0sense/7_Example_demos/blink_baremetal) 拖拽到 U 盘烧录完后，断电重新连接一下板子，LED 开始闪灯。打开串口后会显示灯的状态。 打开串口软件 ![m0sense_blink_baremetal_uart](./assets/start/m0sense_blink_baremetal_uart.gif) LED 闪灯 ![m0sense_blink_baremetal_led](./assets/start/m0sense_blink_baremetal_led.gif) ### blink_rtos.uf2 [点我下载](https://dl.sipeed.com/shareURL/Maix Zero/M0sense/7_Example_demos/blink_rtos) 这个 demo 效果与上面的一样，只是是基于 RTOS 实现的，上面那个 demo 是裸机程序。 使用串口软件打开串口后才开始闪灯，关闭串口后灯的颜色会保持不变。 打开串口软件 ![m0sense_blink_baremetal_uart](./assets/start/m0sense_blink_baremetal_uart.gif) LED 闪灯 ![m0sense_blink_baremetal_led](./assets/start/m0sense_blink_baremetal_led.gif) ### lcd_flush.uf2 [点我下载](https://dl.sipeed.com/shareURL/Maix Zero/M0sense/7_Example_demos/lcd_flush) 烧录进板子后，板子配套的 lcd 背景色变化，打开串口会显示当前屏幕颜色的数值。 ![m0sense_lcd_flush](./assets/start/m0sense_lcd_flush.gif) ![m0sense_lcd_flush_uart](./assets/start/m0sense_lcd_flush_uart.gif) ### imu.uf2 [点我下载](https://dl.sipeed.com/shareURL/Maix Zero/M0sense/7_Example_demos/imu) 烧录进板子后，从串口可以看到板子上面 6 轴 IMU (惯性传感器)的数据。 ![m0sense_imu_uart](./assets/start/m0sense_imu_uart.gif) ### single_button_control.uf2 [点我下载](https://dl.sipeed.com/shareURL/Maix Zero/M0sense/7_Example_demos/single_button_control) 烧录到板子中后，按下 BOOT 键，LED 会切换颜色，串口会打印当前 LED IO 状态。 具体逻辑可以查看[源码](https://gitee.com/Sipeed/M0sense_BL702_example/blob/main/m0sense_apps/rtos_demos/single_button_control/main.c)。 ![single_button_control](./assets/start/single_button_control.gif) ![single_button_control_uart](./assets/start/single_button_control_uart.gif) ### audio_recording.uf2 [点我下载](https://dl.sipeed.com/shareURL/Maix Zero/M0sense/7_Example_demos/audio_recording) 烧录进板子后，串口会持续打印麦克风所获得的周围环境音的 16bit pcm 格式数据。 ![audio_recording](./assets/start/audio_recording.gif) ## SDK 环境搭建 M0sense 要求在 Linux 环境下进行编译。 ### 获取例程仓库 ```bash git clone https://gitee.com/Sipeed/M0sense_BL702_example.git ``` 最终结构树如下 ```bash sipeed@DESKTOP:~$ tree L 1 M0sense_BL702_example/ M0sense_BL702_example/ ├── LICENSE # 许可证文件 ├── README.md # 仓库说明 ├── bl_mcu_sdk # SDK 文件 ├── build.sh # 编译脚本 ├── m0sense_apps # 例程源码 ├── misc # 其他应用 └── uf2_demos # 例程文件 ``` ### 在例程目录下，获得 SDK 仓库 仓库很大，400M 以上。 ```bash cd M0sense_BL702_example git clone https://gitee.com/bouffalolab/bl_mcu_sdk ``` 最终得到的结构树应如下(截取部分)： ```bash sipeed@DESKTOP:~$ tree L 2 M0sense_BL702_example/ M0sense_BL702_example/ ├── LICENSE # 许可证文件 ├── README.md # 仓库说明 ├── bl_mcu_sdk # SDK 文件 │ ├── README_zh.md # SDK 中文说明 │ ├── ReleaseNotes # SDK 发布说明 │ ├── bsp │ ├── cmake │ ├── components │ ├── docs │ ├── drivers │ ├── examples │ ├── project.build │ ├── tools │ └── utils ├── build.sh # 编译脚本 ├── m0sense_apps # 例程源码 ├── misc # 其他应用 └── uf2_demos # 例程文件 ``` ### 在例程目录下，获取编译工具链 ```bash git clone https://gitee.com/bouffalolab/toolchain_gcc_sifive_linux ``` 最终得到的结构树应如下(截取部分)： ```bash sipeed@DESKTOP:~$ tree L 2 M0sense_BL702_example/ M0sense_BL702_example/ ├── LICENSE # 许可证文件 ├── README.md # 仓库说明 ├── bl_mcu_sdk # SDK 文件 │ ├── README_zh.md # SDK 中文说明 │ ├── ReleaseNotes # SDK 发布说明 │ ... ├── build.sh # 编译脚本 ├── m0sense_apps # 例程源码 ├── misc # 其他应用 ├── toolchain_gcc_sifive_linux # 编译工具链 │ ├── bin # 编译链可执行文件路径 │ ├── lib # 动态库文件 │ ... └── uf2_demos # 例程文件 ``` ### 在例程目录下，打补丁 首先确定是在 `M0sense_BL702_example` 目录下。 打补丁前需要先设置一下用户名和邮箱, 随便设置一个 ```bash cd bl_mcu_sdk git config user.email \"m0sense@sipeed.com\" git config user.name \"tinymaix\" ``` 设置完后可以打补丁了。 ```bash cd .. ./build.sh patch ``` 出现 `Apply patch for you!` 说明成功打补丁了，可以接着下面的操作了。 ![m0sense_patch](./assets/start/m0sense_patch.jpg) ### 配置编译工具链路径 以后每次开始编译都需要执行一次这个来配置下编译工具链路径。 首先需要知道 `M0sense_BL702_example` 的路径。 ```bash sipeed@DESKTOP:~$ pwd /home/lee/M0sense_BL702_example ``` 我们复制上面执行 `pwd` 后的结果（每个人的会不一样）然后在后面加上 `/toolchain_gcc_sifive_linux/bin`，然后执行下面的命令，就配置完路径了 ```bash PATH $PATH:/home/lee/M0sense_BL702_example/toolchain_gcc_sifive_linux/bin ``` 根据每个人电脑不同执行完上述命令后可以使用下面的命令 `riscv64 unknown elf gcc v` 来看所配置的工具链是不是正确了。 配置成功了的结果和下面类似。 ```bash sipeed@DESKTOP:~$ riscv64 unknown elf gcc v Using built in specs. COLLECT_GCC riscv64 unknown elf gcc COLLECT_LTO_WRAPPER /home/lee/M0sense_BL702_example/toolchain_gcc_sifive_linux/bin/../libexec/gcc/riscv64 unknown elf/10.2.0/lto wrapper Target: riscv64 unknown elf ``` 没有成功的话会提示没找到 `riscv64 unknown elf gcc`，自己再重新配置一下 ![m0sense_toolchain_notfound](./assets/start/m0sense_toolchain_notfound.jpg) ### 编译 demo 首次编译 demo 前，需要在自己的电脑上编译一下固件转换工具来为了直接 U 盘拖拽烧录。 确定自己是在 `M0sense_BL702_example` 目录下执行下面的命令。 ```bash sudo apt install gcc # 安装适用于自己电脑的 gcc gcc I libs/uf2_format misc/utils/uf2_conv.c o uf2_convert # 编译出固件转换工具 ``` 然后就可以编译 demo 了 ```bash ./build.sh m0sense_apps/blink/blink_baremetal ``` 最终生成的 U 盘烧录的 uf2 文件在 uf2_demos 目录下，bin 文件之类的在 bl_mcu_sdk/out 文件夹下。 ## SDK 编译注意事项 1. 第一次搭建环境最好自己编译一份 uf2 文件转换工具 2. 每次新开终端编译记得配置一下 [编译工具链路径](#配置编译工具链路径) 3. SDK 编译失败时确定自己是按照 [编译 demo](#编译 demo) 里面所说的使用 `./build.sh m0sense_apps/blink/blink_baremetal` 命令来执行编译的，而不是 `./build.sh m0sense_apps/blink/blink_baremetal/` （注意结尾处的 `/` ）命令 ## 烧录 bin 文件 有时候可能由于某些原因需要烧录 bin 文件，这里写一下烧录方法。 给 M0sense 烧录需要用到博流官方烧录工具，前往 https://dev.bouffalolab.com/download 下载名称为 `Bouffalo Lab Dev Cube` 的文件。解压后就得到了用来烧录板子的应用程序。 ![bouffalo_cube](./../../maix/m1s/other/assets/start/bouffalo_cube.png) 解压后的文件夹中主要关注 `BLDevCube`、 `BLDevCube macos` 和 `BLDevCube ubuntu` 三个文件，用于在不同系统启动这个烧录工具。 ![application](./../../maix/m1s/other/assets/start/application.png) 然后使用镊子或其他金属短接上板子上的 3.3V 引脚和 boot 引脚，然后在给板子通电，这样板子进入烧录模式了。可以在电脑设备管理器中看到出现了一个串口设备。 短接引脚 设备管理器中的串口设备 ![boot_mode](./assets/start/boot_mode.jpg) ![serial_device](./assets/start/serial_device.jpg) 接着打开 `BLDevCube` 烧录软件（根据自己系统选择），选择 `BL702` 芯片，在打开的软件界面选择 MCU 模式，选择想要烧录进去的固件。默认的固件可以在这里下载到: [Click me](https://dl.sipeed.com/shareURL/Maix Zero/M0sense/7_Example_demos/default_firmware) <table> <tr> <td><img src \"./../../maix/m1s/other/assets/start/select_bl702.png\" alt \"select_bl702\" style \"transform:rotate(0deg);\"></td> <td><img src \"./../../maix/m1s/other/assets/start/mcu_mode.png\" alt \"mcu_mode\" style \"transform:rotate(0deg);\" width \"70%\"></td> </tr> </table> 点击 `Refresh`，选择唯一的串口（如果看到的不是唯一串口，重新短接 boot 引脚和 3.3v 引脚后再上电使 M0sense 进入下载模式），设置波特率 2000000， 点击下载烧录。 ![burn_bl702](./assets/start/burn_bl702.png) 烧录结束后，重新插拔一次 USB 来重新启动 bl702 以应用新的固件。 ![finish_burn_702](./assets/start/finish_burn_702.png) ## 补充说明 板子上有 BOOT 按键和 BOOT 引脚这两处 BOOT 丝印说明。 <img src \"./assets/start/m0sense_boot_key.jpg\" width \"40%\" alt \"m0sense_boot_key\"> <img src \"./assets/start/m0sense_boot_silkprint.jpg\" width \"40%\" alt \"m0sense_boot_silkprint\"> 上面可以看出来两个有 BOOT 说明，在原理图中分别如下： ![boot_description](./assets/start/boot_description.png) 从 [原理图](https://dl.sipeed.com/shareURL/Maix Zero/M0sense/2_Schematic) 可以看到。两个按键分别连接到了 GPIO_2 和 AU_CHIP，根据芯片参考手册可以知道 `AU_CHIP` 引脚是芯片的复位引脚，因此对应着 Reset 按键， 所以另一个按键为自定义的软件 Boot 引脚，需要搭配[固件](https://dl.sipeed.com/shareURL/Maix Zero/M0sense/7_Example_demos/default_firmware)才能通过 U 盘烧录方式来快速烧录。 上面标识的原理图中， Boot_Strap 为芯片的硬件 BOOT 引脚，上电前将他拉高就可以进入完整固件烧录模式 （需要配合官方烧录工具来烧录固件）。 U 盘烧录模式是基于软件实现的一种特殊的烧录方式，串口烧录方式是芯片最原始的烧录方式。"},"/hardware/zh/maixzero/sense/maix_zero_sense.html":{"title":"M0sense 开发板","content":" title: M0sense 开发板 keywords: BL702 ,开发板 update: date: 2022 11 08 version: v0.1 author: wonder content: 初次编写文档 ## 概述 Sipeed M0sense 是基于[博流智能科技](http://www.bouffalolab.com/)的 BL702 芯片所设计的一款 AIOT 开发板，主控芯片为 Risc V 架构，支持低功耗蓝牙。板载一个 8P FPC 接口来连接 LCD 屏幕，额外配备了 1 个麦克风、1 个 RGB LED 和一颗六轴传感器芯片，引出了一路 USB 2.0 FS 到 Type C 座子。 购买链接：[淘宝](https://item.taobao.com/item.htm?id 693997918701) <img src \"./assets/m0sense_1.png\" alt \"m0sense_1.png\" > ## 视频 M1s Dock 和 M0Sense 总览； M0Sense 在 3:15 处开始，之前的为 M1s Dock 宣传视频. <iframe src \"//player.bilibili.com/player.html?aid 559937139&bvid BV1De4y117sP&cid 887814913&page 1&t 197\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\" > </iframe> ## 特点 主芯片 BL702 RISC V 144MHz 支持蓝牙规范 5.0/ 蓝牙低功耗 BLE 板载显示屏接口（可选配 0.68 寸 80x160 显示屏） 板载 1 个模拟麦克风、1 个 RGB LED、1 个 IMU 引出一路 USB 2.0 FS 到 USB Type C 接口 ## 参数 <table> <thead> <tr> <th colspan \"2\" > M0sense 开发板 </th> </tr> </thead> <tbody> <tr> <td rowspan \"6\" style \"white space:nowrap\">主控 BL702 处理器</td> </tr> <tr> <td>32 bits RISC V with FPU (Max Freq 144MHz)</td> </tr> <tr> <td>132KB RAM，192KB ROM, 512KB Flash</td> </tr> <tr> <td> · 2 个 32 位通用定时器 <br> · 8 个 DMA 通道 <br> · 1 个 SPI 主/从机 <br> · 2 个 UART <br> · 1 个 I2C 主机 <br> · 1 个 I2S 主/从机 <br> · 5 个 PWM 通道 <br> · 12 位通用 ADC <br> · 10 位通用 DAC <br> </td> </tr> <tr> <td>无线：<br> · 支持 2.4Ghz 蓝牙规范 V5.0<br> · 蓝牙低功耗 1Mbps 和 2Mbps </td> </tr> <tr> <td> USB 2.0 FS 引出到 USB Type C 接口用来下载固件 </td> </tr> <tr> <td rowspan \"6\" style \"white space:nowrap\"> 板载部件 </td> </tr> <tr> <td>显示屏接口（可选配 0.96 寸 80x160 显示屏）</td> </tr> <tr> <td>板载 1 个模拟麦克风</td> </tr> <tr> <td>1 个 RGB LED</td> </tr> <tr> <td>1 个 6 轴 IMU（QMI8658A）</td> </tr> <tr> <td>陶瓷天线</td> </tr> <tr> <td rowspan \"5\" style \"white space:nowrap\"> 其他说明 </td> </tr> <tr> <td> 3D 模型文件下载：<a href \"https://dl.sipeed.com/shareURL/Maix Zero/M0sense/5_3D_file\">点击跳转</a> </td> </tr> <tr> <td>外部供电需求 TYPE C 接口：5V±10% 0.5A</td> </tr> <tr> <td>温升: &lt;30K</td> </tr> <tr> <td>工作温度范围: 10℃ ~ 65℃</td> </tr> </tbody> </table> ## 尺寸 <img src \"./assets/m0sense_size.png\" alt \"m0sense_size\" width 55%> ## 引脚 <img src \"./assets/m0sense_pinmap.png\" alt \"m0sense_pinmap\" width 75%> ## 对比 <table> <thead> <tr> <th>项目</th> <th>Arduino Nano 33 BLE SENSE</th> <th>Sipeed M0sense</th> </tr> </thead> <body> <tr> <td> MCU </td> <td>nRF52840 (Cortex M4)</td> <td>BL702 (RV32)</td> </tr> <tr> <td>Freq</td> <td>64MHz</td> <td>144MHz</td> </tr> <tr> <td>SRAM</td> <td>256KB</td> <td>132KB</td> </tr> <tr> <td>蓝牙</td> <td>支持</td> <td>支持</td> </tr> <tr> <td>IIC/UART/SPI</td> <td>有</td> <td>有</td> </tr> <tr> <td>LED</td> <td>单色</td> <td>RGB 三色</td> </tr> <tr> <td>MIC</td> <td>有</td> <td>有</td> </tr> <tr> <td>IMU</td> <td>有</td> <td>有</td> </tr> <tr> <td>其他传感器</td> <td>APDS9960，LPS22HB，HTS221</td> <td></td> </tr> <tr> <td>LCD</td> <td></td> <td>可选 0.96 寸屏幕</td> </tr> <tr> <td>USB</td> <td>有</td> <td>有</td> </tr> <tr> <td>尺寸</td> <td>45mm x 18mm</td> <td>23mm x 18mm</td> </tr> <tr> <td>模型平台</td> <td>TFLite Micro + edge impulse</td> <td>TinyMaix + MaixHub</td> </tr> <tr> <td>价格</td> <td>$40</td> <td>$4</td> </tr> </body> </table> ## 软件描述 <table> <thead> <tr> <th colspan \"2\" > M0sense </th> </tr> </thead> <tbody> <tr> <td>OS</td> <td>FreeRTOS</td> </tr> <tr> <td>开发方式</td> <td>· 原生 C SDK<br>· MaixHAL C 模块<br>· PikaPython </td> </tr> <tr> <td>固件下载</td> <td>· USB虚拟串口下载<br>· USB虚拟磁盘拖拽更新</td> </tr> <tr> <td>AI 推理框架</td> <td>TinyMaix 推理框架</td> </tr> <tr> <td>AI 模型下载</td> <td>· <a href \"https://maixhub.com/\">MaixHub</a> 下载。支持 关键词唤醒，手势识别 等模型</td> </tr> <tr> <td>Sipeed 参考示例</td> <td>· https://github.com/sipeed/M0sense_BL702_example</td> </tr> </tbody> </table> ## 补充资料 [板卡规格书](https://dl.sipeed.com/shareURL/Maix Zero/M0sense/1_Specification) [板卡原理图](https://dl.sipeed.com/shareURL/Maix Zero/M0sense/2_Schematic) [板卡点位图](https://dl.sipeed.com/shareURL/Maix Zero/M0sense/3_Bit_number_map) [板卡尺寸图](https://dl.sipeed.com/shareURL/Maix Zero/M0sense/4_Dimensional_drawing) [3D 模型文件](https://dl.sipeed.com/shareURL/Maix Zero/M0sense/5_3D_file) [博流官方文档](https://dev.bouffalolab.com/home/) [BL702 数据手册](https://gitee.com/wonderfullook/bl_docs/tree/main/BL702_DS/zh_CN) (gitee) [BL702 参考手册](https://gitee.com/wonderfullook/bl_docs/tree/main/BL702_RM/zh_CN) (gitee) [例程](https://github.com/sipeed/M0sense_BL702_example) (Github) [Bouffalolab SDK](https://github.com/bouffalolab/bouffalo_sdk)(Github) 交流 QQ 群：`816177882` 。[点我加群](https://jq.qq.com/?_wv 1027&k CSnLIADN) 论坛：[bbs.sipeed.com](https://bbs.sipeed.com/) ## 注意事项 <table> <tr> <th>项目</th> <th>注意事项</th> </tr> <tr> <td>静电防护</td> <td>请避免静电打到 PCBA 上；接触 PCBA 之前请把手的静电释放掉</td> </tr> <tr> <td>容忍电压</td> <td> 每个 GPIO 的工作电压已经在原理图中标注出来，请不要让 GPIO 的实际工作的电压超过额定值，否则会引起 PCBA 的永久性损坏 </td> </tr> <tr> <td>FPC 座子</td> <td>在连接 FPC 软排线的时候，请确保排线无偏侈地完整地插入到排线中</td> </tr> <tr> <td>插拔</td> <td>请完全断电后才进行插拔操作</td> </tr> <tr> <td>避免短路</td> <td>请在上电过程中，避免任何液体和金属触碰到 PCBA 上的元件的焊盘，否则会导致路，烧毁 PCBA</td> </tr> </table> ## 联系 M0sense 可以在多种场景实现客户不同方面的需要，技术支持和商业合作请联系邮箱 [support@sipeed.com](support@sipeed.com)"},"/hardware/zh/maixzero/m0s/m0s.html":{"title":"M0S 模块","content":" title: M0S 模块 keywords: M0S, 模块, BL616, wifi6 update: date: 2023 01 13 version: v0.1 author: wonder content: 初次编写文档 ## 模块概述 Sipeed M0S 模块是基于[博流智能科技](http://www.bouffalolab.com/)的 BL616 芯片所设计的一款适用于超低功耗应用 IOT 模块，支持 Wifi6、蓝牙 5.2 和 zigbee 等无线协议，默认最高主频 320MHz，模块极小的封装体积和芯片多种低功耗模式和多种唤醒源满足不同的低功耗场景。 购买链接：[淘宝](https://item.taobao.com/item.htm?id 697403593463) <img src \"./assets/m0s/m0s_module_outlook.png\" alt \"m0s_module_outlook\" width 35%> ## 模块特点 无线三模一体： WiFi6 / 蓝牙 5.2 / Zigbee 高主频：默认最高 320MHz 低功耗：WiFi6 低功耗特性 DSP 加速：支持 RISC V P 扩展指令集，可在 TinyMaix 推理框架中获得近一倍加速 高速 USB：支持 USB2.0 HS OTG， 高达 480Mbps 丰富外设接口：支持 RGB LCD，DVP Camera，以太网 RMII，SDIO 等 小体积：10mmx11mm 面积上集成了陶瓷天线，并全引脚引出 ## 模块参数 <table> <thead> <tr> <th colspan \"2\" > M0S 模块 </th> </tr> </thead> <tbody> <tr> <td rowspan \"5\" style \"white space:nowrap\">主控 BL616 处理器</td> </tr> <tr> <td>RISC V CPU：默认 RV32GCP@320MHz </td> </tr> <tr> <td>内置 480KB SRAM + 4MB Flash</td> </tr> <tr> <td>无线：<br> 支持 Wi Fi6<br> 支持 Bluetooth 5.2 Dual mode(BT+BLE)<br> 支持 Zigbee </td> </tr> <tr> <td>USB 2.0 HS OTG</td> </tr> <tr> <td rowspan \"2\" style \"white space:nowrap\"> 板载部件 </td> </tr> <tr> <td>陶瓷天线</td> </tr> </tbody> <tr> <td rowspan \"4\" style \"white space:nowrap\"> 其他说明 </td> </tr> <tr> <td> 尺寸：10mm (W) x 11mm (H) </td> </tr> <tr> <td> 封装库文件 (KiCAD)：<a href \"https://dl.sipeed.com/shareURL/Maix Zero/M0S/M0S/4_Package\">点击跳转</a> </td> </tr> <tr> <td> 3D 模型文件下载：<a href \"https://dl.sipeed.com/shareURL/Maix Zero/M0S/M0S/3_3D_file\">点击跳转</a> </td> </tr> </tbody> </table> ## 引脚分布 ![m0s_pin_map](./assets/m0s/m0s_pin_map.png) ## 产品对比 型号 M0S 模块 ESP32 S3 N4 模块 : : : : 主控 BL616(RV32GCP) ESP32 S3 (LX7) 频率 320MHz 240MHz SRAM 480KB 520KB Flash 4MByte 4MByte Wifi WiFi6 WiFi4 蓝牙 BT5.2 BT5 USB USB2.0 HS OTG 480Mbps USB2.0 FS OTG 12Mbps IIC/UART/SPI 有 有 DVP Camera Yes Yes 尺寸 10mm x 11mm 18mm x 25.5mm 模型平台 TinyMaix + MaixHub ## 配套底板 <table> <thead> <tr> <th colspan \"2\" > M0S Dock </th> </tr> </thead> <tbody> <tr> <td> 核心 x 1 </td> <td> M0S 模块 </td> </tr> <tr> <td> 按键 x 1 </td> <td> 按住按键后给板子通电来烧录板卡 </td> </tr> <tr> <td> LED x 3 </td> <td> 一个电源 LED，两个用户自定义 LED </td> </tr> <tr> <td> TypeC 接口 x 1 </td> <td> 用来下载固件或实现其他 USB 功能 </td> </tr> <tr> <td> 外接 IO x 10 </td> <td> 八个引出到排针<br> 两个位于 TypeC 接口旁边 </td> </tr> <tr> <td> 原理图 </td> <td> <a href \"https://dl.sipeed.com/shareURL/Maix Zero/M0S/M0S_Dock/2_Schematic\"> 点我 </a></td> </tr> </tbody> </table> <img src \"./assets/m0s/m0s_dock_top.png\" width \"45%\"> <img src \"./assets/m0s/m0s_dock_bottom.png\" width \"45%\"> ## 软件描述 <table> <thead> <tr> <th colspan \"2\" > M0S 模块 </th> </tr> </thead> <tbody> <tr> <td>OS</td> <td>· 完备支持FreeRTOS </td> </tr> <tr> <td>开发方式</td> <td>· 原生C SDK<br>· MaixHAL C 模块<br>· PikaPython </td> </tr> <tr> <td>固件下载</td> <td>· 串口下载<br>· USB 下载</td> </tr> <tr> <td>AI 推理框架</td> <td>· TinyMaix 推理框架</td> </tr> <tr> <td>AI 模型下载</td> <td>· <a href \"https://maixhub.com/\"> MaixHub </td> </tr> <tr> <td>Sipeed 参考示例</td> <td>· https://github.com/sipeed/M0S_BL616_example</td> </tr> </tbody> </table> ## 相关资料 [M0S 规格书](https://dl.sipeed.com/shareURL/Maix Zero/M0S/M0S/1_Specification) [M0S 原理图](https://dl.sipeed.com/shareURL/Maix Zero/M0S/M0S/2_Schematic) [M0S 封装库](https://dl.sipeed.com/shareURL/Maix Zero/M0S/M0S/4_Package) [3D 模型文件](https://dl.sipeed.com/shareURL/Maix Zero/M0S/M0S/3_3D_file) [博流官方文档](https://dev.bouffalolab.com/home/) [BL616 数据手册](https://gitee.com/wonderfullook/bl_docs/tree/main/BL616_DS/zh_CN) (gitee) [BL616 参考手册](https://gitee.com/wonderfullook/bl_docs/tree/main/BL616_RM/zh_CN) (gitee) [M0S Dock 规格书](https://dl.sipeed.com/shareURL/Maix Zero/M0S/M0S_Dock/1_Specification) [M0S Dock 原理图](https://dl.sipeed.com/shareURL/Maix Zero/M0S/M0S_Dock/2_Schematic) [Sipeed Examples](https://github.com/sipeed/M0s_BL616_example)（github） [Bouffalolab SDK](https://github.com/bouffalolab/bouffalo_sdk) (github) SDK 使用指南: https://bl mcu sdk.readthedocs.io/zh_CN/latest/index.html 交流 QQ 群：`816177882` 。[点我加群](https://jq.qq.com/?_wv 1027&k CSnLIADN) 论坛：[bbs.sipeed.com](https://bbs.sipeed.com/) ## 注意事项 <table> <tr> <th>项目</th> <th>注意事项</th> </tr> <tr> <td>静电防护</td> <td>请避免静电打到 PCBA 上；接触 PCBA 之前请把手的静电释放掉</td> </tr> <tr> <td>容忍电压</td> <td>请不要让 GPIO 的实际工作的电压超过额定值，否则会引起 PCBA 的永久性损坏 </td> </tr> <tr> <td>插拔</td> <td>请完全断电后才进行插拔操作</td> </tr> <tr> <td>避免短路</td> <td>请在上电过程中，避免任何液体和金属触碰到 PCBA 上的元件的焊盘，否则会导致路，烧毁 PCBA</td> </tr> </table> ## 联系方式 M0S 模块可以在多种场景实现客户不同方面的需要，技术支持和商业合作请联系邮箱 [support@sipeed.com](support@sipeed.com)"},"/hardware/zh/maixzero/m0s/start.html":{"title":"","content":"<! title: M0S Dock keywords: M0S, 模块, BL616, wifi6 update: date: 2023 01 15 version: v0.1 author: wonder content: 初次编写文档 我们可以将 M0S Dock 当成小型开发板使用，这里以点灯教程来示范相关 SDK 的使用方法。 > M0S Dock 应当在 Linux 环境下进行开发，下面的操作均为在 ubuntu 中完成 ## 软件准备 ### 编译固件所需要的系统软件 ```bash sudo apt get install cmake git ``` ### 烧录固件所需要的软件 前往 https://dev.bouffalolab.com/download 下载名称为 `Bouffalo Lab Dev Cube` 的文件。解压后就得到了用来烧录板子的应用程序。 ![bouffalo_cube](./../../maix/m1s/other/assets/start/bouffalo_cube.png) 解压后的文件夹中主要关注 `BLDevCube`、 `BLDevCube macos` 和 `BLDevCube ubuntu` 三个文件，用于在不同系统启动这个图形化烧录工具。 ![application](./../../maix/m1s/other/assets/start/application.png) ## SDK 获取 >"},"/hardware/zh/maixzero/m0p/m0p_dock.html":{"title":"M0P Dock","content":" title: M0P Dock keywords: M0P ,Dock, bl618, BL618 update: date: 2023 03 09 version: v0.1 author: wonder content: 初次编写文档 ## 板卡概述 Sipeed M0P Dock 是使用 [Sipeed M0P](https://wiki.sipeed.com//hardware/zh/maixzero/m0p/m0p.html) 模组设计的开发板，主控是 [博流智能科技](http://www.bouffalolab.com/) 的 BL618 芯片，支持 Wifi6 和蓝牙 5.2 无线协议，默认最高主频 320MHz，支持 USB2.0 HS。板卡上有 DVP 接口来连接摄像头，有 FPC 座子来连接屏幕，有 TF 卡槽来扩展存储，还有一颗 WMM7027ATSN1 MEMS 麦克风用于自定义功能，板卡上还有电池充电管理电路，支持使用锂电池供电。 购买链接：[淘宝](https://item.taobao.com/item.htm?id 710359411812) <img src \"./assets/m0p_dock/m0p_dock_outlook.png\" alt \"m0p_dock_outlook\" width 15%> <img src \"./assets/m0p_dock/m0p_dock_outlook_back.png\" alt \"m0p_dock_outlook\" width 15%> ## 板卡特点 主芯片 BL618 RV32 320MHz RISC V 支持 2.4G WIFI6（IEEE 802.11 b/g/n/ax） 支持蓝牙 5.x 双模（BT+BLE）和 Zigbee / IEEE 802.15.4 USB 2.0 Type C（480Mhz）（可用作下载固件和USB转串口） DVP 摄像头连接器 SPI 屏幕连接器（可以连接3.92寸320x320方形电容触摸屏） 4.2V 锂电池充电电路 1 个 TF 卡连接器（SDIO接口） 1 个模拟麦克风、2 个 ADC 按键和 1 个状态指示灯 ## 板卡参数 <table> <tbody> <tr> <th colspan \"3\" style \"white space:nowrap\"> M0P Dock 参数 </td> </tr> <tr> <td rowspan \"18\" style \"white space:nowrap\"> M0P 模组 </td> </tr> <tr> <td colspan \"2\"> RISC V CPUs：RV32 320MHz </td> </tr> <tr> <td colspan \"2\"> SRAM: 480KB + 4MB </td> </tr> <tr> <td rowspan \"15\"> 支持接口 </td> </tr> <tr> <td>DVP Camera</td> </tr> <tr> <td>Display（QSPI、DBI）</td> </tr> <tr> <td>USB2.0 HS OTG(High Speed 480Mhz)</td> </tr> <tr> <td>SPI</td> </tr> <tr> <td>UART * 2</td> </tr> <tr> <td>IIC * 2</td> </tr> <tr> <td>IIS</td> </tr> <tr> <td>10bit GPDAC</td> </tr> <tr> <td>12~16bit GPADC</td> </tr> <tr> <td>ACOMP</td> </tr> <tr> <td>PWM</td> </tr> <tr> <td>SDIO2.0</td> </tr> <tr> <td>Audio Codec</td> </tr> <tr> <td> 无线：<br>· 支持Wi Fi 802.11 b/g/n/ax（WiFi6）<br>· 支持蓝牙 5.x 双模(BT+BLE)<br>· 支持Wi Fi / 蓝牙/ Zigbee 共存<br>（更详细的特性请查看芯片 <a href \"https://gitee.com/wonderfullook/bl_docs/tree/main/BL616_DS/zh_CN\"> datasheet</a>）</td> </tr> </td> </tr> <tr> <td colspan \"1\" rowspan \"11\" style \"white space:nowrap\"> 板载部件 </td> </tr> <tr> <td colspan \"2\">USB2.0 Type C 母座连接器: <br> 可用作USB通信、下载固件和USB转串口</td> </tr> <tr> <td colspan \"2\">DVP 摄像头连接器：<br> 通用接口，可以连接 GC0328 摄像头模组</td> </tr> <tr> <td colspan \"2\">SPI 屏幕连接器：<br>可以连接 3.92 寸 320x320 方形电容触摸屏</td> </tr> <tr> <td colspan \"2\">SPI FLASH（默认8MByte）</td> </tr> <tr> <td colspan \"2\">1 个 TF 卡连接器（SDIO接口）</td> </tr> <tr> <td colspan \"2\">1 个模拟麦克风：WMM7027ATSN1（全指向，灵敏度 38dB，信噪比 59dB ）</td> </tr> <tr> <td colspan \"2\">2 个 ADC 按键（在板子两侧）</td> </tr> <tr> <td colspan \"2\">1 个电源指示灯和 1 个状态指示灯</td> </tr> <tr> <td colspan \"2\">两侧排针引出所有 IO（出厂已经焊接好排针）</td> </tr> <tr> <td colspan \"2\">4.2V 锂电池充电电路：<br>· USB 给整板供电，整板给电池供电，电池与整板主电源之间有二极管防倒灌<br>· 电池电压低于 3.3V 时 BL618 芯片会被强制处于复位状态<br>· 只支持最大电压是 4.2V 的可充电锂电池，不支持最大电压小于 4.2V 的可充电锂电池及不可充电的电池</td> </tr> </tbody> </tbody> </table> ## 引脚分布 ![m0p_dock_pinmap](./assets/m0p_dock/m0p_dock_pinmap.png) STATE LED 接到 GPIO21 POW LED 接到 3.3V。板卡正常运行时亮起 ## 产品对比 M0P Dock ESP32 S3 DevKitC MCU 单核320Mhz RISC V 双核240Mhz SRAM 480KB + 4MB 512KB + 2MB(optional) ROM √ √ SPI Nor Flash 8MB(optional) 8MB(optional) WIFI IEEE 802.11 b/g/n/ax (WiFi6) IEEE 802.11 b/g/n BLE √ √ I2C/UART/SPI √ √ Microphone 模拟麦克风 × LCD 支持 3.92 英寸电容触摸屏 × Camera DVP camera × USB USB 2.0 High speed OTG（480Mbps） USB 2.0 Full speed OTG（12Mbps） 固件下载方式 USB USB ## 软件描述 <table> <thead> <tr> <th colspan \"2\" > M0P 模组 </th> </tr> </thead> <tbody> <tr> <td>OS</td> <td> 支持FreeRTOS</td> </tr> <tr> <td>开发方式</td> <td>· 原生C SDK<br>· MaixHAL C 模块<br>· PikaPython </td> </tr> <tr> <td> SDK </td> <td><a href \"https://github.com/bouffalolab/bouffalo_sdk\"> github </a></td> </tr> <tr> <td>Examples</td> <td><a href \"https://github.com/sipeed/M0P_BL618_examples\"> github </a></td> </tr> </tbody> </table> ## 板卡资料 [板卡规格书](https://dl.sipeed.com/shareURL/Maix Zero/M0P/M0P%20Dock/1_datasheet) [板卡原理图](https://dl.sipeed.com/shareURL/Maix Zero/M0P/M0P%20Dock/2_Schematic) [板卡尺寸图](https://dl.sipeed.com/shareURL/Maix Zero/M0P/M0P%20Dock/4_Dimensional_drawing) [板卡位号图](https://dl.sipeed.com/shareURL/Maix Zero/M0P/M0P%20Dock/3_Bit_number_map) [3D 模型文件](https://dl.sipeed.com/shareURL/Maix Zero/M0P/M0P%20Dock/5_3D_File) [博流官方文档](https://dev.bouffalolab.com/home/) [BL618 数据手册](https://gitee.com/wonderfullook/bl_docs/tree/main/BL616_DS/zh_CN) (gitee) [BL618 参考手册](https://gitee.com/wonderfullook/bl_docs/tree/main/BL616_RM/zh_CN) (gitee) [Sipeed Examples](https://github.com/sipeed/M0P_BL618_examples)（github） [Bouffalolab SDK](https://github.com/bouffalolab/bouffalo_sdk) (github) 交流 QQ 群：`816177882` 。[点我加群](https://jq.qq.com/?_wv 1027&k 4lroNFnI) 论坛：[bbs.sipeed.com](https://bbs.sipeed.com/) ## 注意事项 <table> <tr> <th>项目</th> <th>注意事项</th> </tr> <tr> <td>静电防护</td> <td>· 请注意避免静电打到 PCBA 上；接触 PCBA 之前请把手的静电释放掉 </td> </tr> <tr> <td>容忍电压</td> <td> 所有 GPIO 都是 3.3V 电平，请不要让 GPIO 的实际工作的电压超过额定值，否则会引起 PCBA 的永久性损坏 </td> </tr> <tr> <td>避免短路</td> <td>请在上电过程中，避免任何液体和金属触碰到 PCBA 上的元件的焊盘，否则会导致短路，烧毁 PCBA</td> </tr> <tr> <td>FPC 座子</td> <td>在连接 FPC 软排线的时候，请确保排线无偏移地完整地插入到排线中</td> </tr> <tr> <td>BOOT 模式选择</td> <td> 在启动时，芯片判定 BOOT 引脚的电平，选择两个启动选项之一<br> · BOOT 低电平：从 FLASH 加载固件<br> · BOOT 高电平：进入 USB 下载模式 </td> </tr> </table> ## 充电说明 板卡上板载了 TP4057 充电 IC，板卡底面有两个锂电池状态指示 LED。 <img src \"./assets/m0p_dock/m0p_dock_outlook_back.png\" alt \"m0p_dock_outlook\" width 45%> FULL LED：锂电池充电 IC 的 STDBY 脚，当电池充电结束后，该灯亮起 CHRG LED：处于充电状态时，该灯亮起 ## 联系方式 M0P Dock 开发板可以在多种场景实现客户不同方面的需要，技术支持和商业合作请联系邮箱 [support@sipeed.com](support@sipeed.com)"},"/hardware/zh/maixzero/m0p/m0p.html":{"title":"M0P 模组","content":" title: M0P 模组 keywords: M0P ,模组, bl618, BL618 update: date: 2023 03 09 version: v0.1 author: wonder content: 初次编写文档 ## 模组概述 Sipeed M0P 模组是基于[博流智能科技](http://www.bouffalolab.com/)的 BL618 芯片所设计的一款 AIOT 模组，支持 WIFI6、蓝牙 5.2 等无线协议，邮票孔的让它能快速应用在多种 AIOT 场合。 购买链接：[淘宝](https://item.taobao.com/item.htm?id 710359411812) <img src \"./assets/m0p/m0p_module_outlook.png\" alt \"m0p_module_outlook\" width 15%> ## 模组特点 主芯片 BL618 RV32 320MHz RISC V 支持 2.4G WIFI6（IEEE 802.11 b/g/n/ax） 支持蓝牙 5.x 双模（BT+BLE） 支持 Zigbee / IEEE 802.15.4 支持 USB 2.0 HS OTG（480Mhz） 支持IPEX一代天线座子和 PCB 板载天线 板载 SPI FLASH（可选容量） 邮票孔引出所有 IO ## 模组参数 <table> <thead> <tr> <th colspan \"3\"> M0P 模组 </th> </tr> </thead> <tbody> <tr> <td rowspan \"18\" style \"white space:nowrap\">主控 BL618 处理器</td> </tr> <tr> <td colspan \"2\">RISC V CPUs：RV32 320MHz</td> </tr> <tr> <td colspan \"2\">SRAM: 480KB + 4MB </td> </tr> <tr> <td rowspan \"15\"> 支持接口 </td> </tr> <tr> <td>DVP Camera</td> </tr> <tr> <td>Display（QSPI、DBI）</td> </tr> <tr> <td>USB2.0 HS OTG(High Speed 480Mhz)</td> </tr> <tr> <td>SPI</td> </tr> <tr> <td>UART * 2</td> </tr> <tr> <td>IIC * 2</td> </tr> <tr> <td>IIS</td> </tr> <tr> <td>10bit GPDAC</td> </tr> <tr> <td>12~16bit GPADC</td> </tr> <tr> <td>ACOMP</td> </tr> <tr> <td>PWM</td> </tr> <tr> <td>SDIO2.0</td> </tr> <tr> <td>Audio Codec</td> </tr> <tr> <td>无线：<br>· 支持Wi Fi 802.11 b/g/n/ax（WiFi6）<br>· 支持蓝牙 5.x 双模(BT+BLE)<br>· 支持Wi Fi / 蓝牙/Zigbee 共存</td> </tr> <tr> <td rowspan \"3\" style \"white space:nowrap\"> 板载部件 </td> </tr> <tr> <td colspan \"2\">板载 SPI FLASH： 8MByte</td> </tr> <tr> <td colspan \"2\">支持 IPEX 一代天线座子和 PCB 板载天线</td> </tr> </tbody> <tr> <td rowspan \"5\" style \"white space:nowrap\"> 其他说明 </td> </tr> <tr> <td colspan \"2\"> 尺寸：25.5mm (L) x 18mm (W) </td> </tr> <tr> <td colspan \"2\"> KICAD 格式封装文件下载：<a href \"https://dl.sipeed.com/shareURL/Maix Zero/M0P/M0P/4_Package\">点击跳转</a> </td> </tr> <tr> <td colspan \"2\">温升: &lt;30K</td> </tr> <tr> <td colspan \"2\">工作温度范围: 10℃ ~ 65℃</td> </tr> </table> ## 尺寸大小 <img src \"./assets/m0p/m0p_size.png\" alt \"m0p_size\" width 35%> ## 引脚分布 前往原理图查看：[点我](https://dl.sipeed.com/shareURL/Maix Zero/M0P/M0P/2_Schematic) ## 软件描述 <table> <thead> <tr> <th colspan \"2\" > M0P 模组 </th> </tr> </thead> <tbody> <tr> <td>OS</td> <td> 支持FreeRTOS</td> </tr> <tr> <td>开发方式</td> <td>· 原生C SDK<br>· MaixHAL C 模块<br>· PikaPython </td> </tr> <tr> <td> SDK </td> <td><a href \"https://github.com/bouffalolab/bouffalo_sdk\"> github </a></td> </tr> <tr> <td>Examples</td> <td><a href \"https://github.com/sipeed/M0P_BL618_examples\"> github </a></td> </tr> </tbody> </table> ## 模组资料 [模组规格书](https://dl.sipeed.com/shareURL/Maix Zero/M0P/M0P/1_datasheet) [模组原理图](https://dl.sipeed.com/shareURL/Maix Zero/M0P/M0P/2_Schematic) [模组封装库](https://dl.sipeed.com/shareURL/Maix Zero/M0P/M0P/4_Package) [模组尺寸图](https://dl.sipeed.com/shareURL/Maix Zero/M0P/M0P/3_Dimensional_drawing) [博流官方文档](https://dev.bouffalolab.com/home/) [BL618 数据手册](https://gitee.com/wonderfullook/bl_docs/tree/main/BL616_DS/zh_CN) (gitee) [BL618 参考手册](https://gitee.com/wonderfullook/bl_docs/tree/main/BL616_RM/zh_CN) (gitee) [Sipeed Examples](https://github.com/sipeed/M0P_BL618_examples)（github） [Bouffalolab SDK](https://github.com/bouffalolab/bouffalo_sdk) (github) 交流 QQ 群：`816177882` 。[点我加群](https://jq.qq.com/?_wv 1027&k 4lroNFnI) 论坛：[bbs.sipeed.com](https://bbs.sipeed.com/) ## 注意事项 <table> <tr> <th>项目</th> <th>注意事项</th> </tr> <tr> <td>静电防护</td> <td>· 请注意避免静电打到 PCBA 上；接触 PCBA 之前请把手的静电释放掉<br>· 在底板设计时，必须要从 ESD 防护角度进行设计（串电阻、加 ESD 二极管等）</td> </tr> <tr> <td>容忍电压</td> <td> 所有 GPIO 都是 3.3V 电平，请不要让 GPIO 的实际工作的电压超过额定值，否则会引起 PCBA 的永久性损坏 </td> </tr> <tr> <td>避免短路</td> <td>请在上电过程中，避免任何液体和金属触碰到 PCBA 上的元件的焊盘，否则会导致短路，烧毁 PCBA</td> </tr> <tr> <td>BOOT 模式选择</td> <td> 在启动时，芯片判定 BOOT 引脚的电平，选择两个启动选项之一<br> · BOOT 低电平：从 FLASH 加载固件<br> · BOOT 高电平：进入 USB 下载模式 </td> </tr> </table> ## 联系方式 M0P 模组可以在多种场景实现客户不同方面的需要，技术支持和商业合作请联系邮箱 [support@sipeed.com](support@sipeed.com)"},"/hardware/zh/maix/index.html":{"title":"Sipeed Hardware","content":" title: Sipeed Hardware keywords: Sipeed, Hardware, 矽速, 硬件资料, 文档, 资料下载 desc: 矽速科技的硬件资料站 # Maix—I [English](./../../en/maix/index.html) ## K210 核心模组 [M1/M1w](./core_module.html) [M1n](./core_modules/k210_core_modules.html) ## Maix 系列开发板 <table role \"table\" class \"center_table\"> <tbody> <tr> <th scope \"col\">型号</th> <th scope \"col\">图片</th> </tr> <tr> <td> Maix Go</td> <td><a href \"./maixpy_develop_kit_board/maix_go.html\" target \"_blank\"><img src \"./assets/dk_board/maix_go/Go.jpg\" width \"260\"></a></td> </tr> <tr> <td>Maix Dock</td> <td><a href \"./maixpy_develop_kit_board/Maix_dock.html\" target \"_blank\"><img src \"./assets/dk_board/maix_dock/Dan_Dock.png\" width \"260\"></a></td> </tr> <tr> <td>Maix Duino</td> <td><a href \"./maixpy_develop_kit_board/maix_duino.html\" target \"_blank\"><img src \"./assets/dk_board/maix_duino/maixduino_0.png\" width \"260\"></a></td> </tr> <tr> <td>Maix Bit</td> <td> <a href \"./maixpy_develop_kit_board/maix_bit.html\" target \"_blank\"><img src \"./assets/dk_board/maix_bit/Bit.png\" width \"260\"></a> </td> </tr> <tr> <td>Maix Cube</td> <td><a href \"./maixpy_develop_kit_board/maix_cube.html\" target \"_blank\"><img src \"./assets/dk_board/maix_cube/maix_cube.png\" width \"260\"></a></td> </tr> <tr> <td>Maix Amigo</td> <td><a href \"./maixpy_develop_kit_board/maix_Amigo.html\" target \"_blank\"><img src \"./assets/dk_board/maxi_amigo/maix_amigo_0.png\" width \"260\"></a></td> </tr> <tr> <td>Maix nano</td> <td><a href \"./maixpy_develop_kit_board/maix_nano.html\"><img src \"./assets/dk_board/maix_nano/maix_nano.jpg\" width \"260\" alt \"Maxi nano\"></a></td> </tr> </tbody> </table> ## 产品技术支持 Maix系列产品可以在多种场景实现客户不同方面的需要，在AIoT上已经广泛的使用，品质和性能在行业内已经有非常好的口碑，专业的技术团队为广大客户解决硬件设计和软件功能上的各种各样问题。专业技术支持和更详细资料请联系商务<support@sipeed.com>。"},"/hardware/zh/maix/maixpy_develop_kit_board/maix_go.html":{"title":"Maix Go","content":"# Maix Go ## 教程&快速上手 <a href \"/soft/maixpy/zh/\" target \"_blank\"> MaixPy </a> ## 描述 MAIX Go开发板是SiPEED公司MAIX产品线的一员，基于嘉楠堪智科技的边缘智能计算芯片K210(RISC V架构 64位双核)设计的一款AIOT开发板。设计成数码相机的样式，板载Type C接口和USB UART电路，用户可以直接通过USB Type C线连接电脑进行开发，配置128Mbit Flash、LCD、DVP、Micro SD卡等接口并把所有IO引出，方便用户扩展。 ## 外观 <img src \"./../assets/dk_board/maix_go/Go.jpg\" alt \"Maxi go\" > ## 特性 MAIX Go开发板以K210作为核心单元，功能非常很强大，芯片内置64位双核处理器，拥有8M的片上SRAM，在Al机器视觉、听觉性能方便表现突出，内置多种硬件加速单元(KPU、FPU，FFT等)，总算力最高可达1TOPS，可以方便地实现各类应用场景的机器视觉/听觉算法,也可以进行语音方向扫描和语音数据输出的前置处理工作。 ## 应用 智能家居，机器人清洁器，智能扬声器，电子门锁，家庭监控等; 医学行业应用，如辅助诊断，医学图像识别; 智能工业应用，如工业机械，智能分拣，电气设备监控等; 教育机器人，智能互动平台，教育效率检查等教育应用; 农业应用，如农业监测，病虫害监测，自动控制等 ## 参数 <table role \"table\" class \"center_table\"> <thead> <tr> <th colspan \"2\">K210 芯片基本参数</th> </tr> </thead> <tbody> <tr> <td>内核</td> <td>RISC V Dual Core 64bit, with FPU</td> </tr> <tr> <td>主频</td> <td>400MHz （可超频至600MHz）</td> </tr> <tr> <td>SRAM</td> <td>内置8M Byte</td> </tr> <tr> <td>图像识别</td> <td>QVGA@60fps/VGA@30fps</td> </tr> <tr> <td>语音识别</td> <td>麦克风阵列(8mics)</td> </tr> <tr> <td>网络模型</td> <td><li>支持YOLOv3<li>Mobilenetv2<li>TinyYOLOv2<li>人脸识别等</td> </tr> <tr> <td>深度学习框架</td> <td>支持TensorFlow \\ Keras \\ Darknet \\ Caffe 等主流框架</td> </tr> <tr> <td>外设</td> <td>FPIOA、 UART、 GPIO、 SPI、 I2C、I2S、 TIMER</td> </tr> <tr> <td>视频处理</td> <td><li>神经网络处理器(KPU)<li>FPU满足IEEE754 2008标准<li>音频处理器(APU)<li>快速傅里叶变换加速器(FFT)</td> </tr> </tbody> </table> <table role \"table\" class \"center_table\"> <thead> <tr> <th colspan \"2\" >开发板参数</th> </tr> </thead> <td> 板载资源</td> <td><li>三向拨轮按键 <li>RGB灯*1<li>1W 小喇叭<li>USB to UART<li>16Mbit Flash*1</td> </tr> <tr> <td>板载接口</td> <td><li>USB Type C接口<li>24PIN DVP摄像头接口<li>24PIN LCD接口<li>MicroSD卡槽<li>麦克风阵列接口<li>部分IO排针引脚引出</td> </tr> <tr> <td>尺寸</td> <td>60*88mm</td> </tr> <tr> <td>供电电压</td> <td>5.0V @ 300mA（供电电流需大于300mA）</td> </tr> <tr> <td>工作温度</td> <td> 30℃ ~85C</td> </tr> </table> <table role \"table\" class \"center_table\"> <thead> <tr> <th colspan \"2\">软件开发</th> <tr> </thead> <tr> <td>芯片操作系统</td> <td>FreeRTOS、RT Thread等</td> </tr> <tr> <td>开发环境</td> <td>MaixPy IDE、PlatformlO IDE、Arduino IDE等</td> </tr> <tr> <td>编程语言</td> <td>C，C++，MicroPython</td> </tr> </table> ## 资料下载 Sipeed Maix Go 资料下载：[Sipeed Maix Go](https://dl.sipeed.com/shareURL/MAIX/HDK/Sipeed Maix GO) ## 产品技术支持 Maix系列产品可以在多种场景实现客户不同方面的需要，在AIoT上已经广泛的使用，品质和性能在行业内已经有非常好的口碑，专业的技术团队为广大客户解决硬件设计和软件功能上的各种各样问题。专业技术支持和更详细资料请联系商务<support@sipeed.com>。"},"/hardware/zh/maix/maixpy_develop_kit_board/maix_hat.html":{"title":"Grove AI HAT","content":" title: Grove AI HAT keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy Grove AI HAT ## 外观及功能介绍 ### 外观一览 ![Grove AI HAT](./../../../../soft/maixpy/assets/hardware/grove_ai_hat/grove_ai_hat1.png) ### 板载功能 项目 说明 CPU： 双核 64bit RISC V / 400MHz (双精度FPU集成) 内存： 8MiB 64bit 片上 SRAM 存储： 16MiB Flash 屏幕（套餐）： 2.4 寸 TFT, 电容触摸屏幕分辨率：320\\*240 摄像头（套餐）： 搭载 **OV7740** 或 **OV5642** **30W** 像素 **Sensor** 按键： 复位按键，电源按键（短按开机，长按 *8S* 关机） USB： Type C 接口，正反盲插 板载传感器： 三轴加速度传感器（ADXL345BCCZ RL），ADC（ADS1115IDGS） ### 硬件板载扩展接口 该开发版对用户开放了四个 [Grove](https://wiki.sipeed.com/soft/maixpy/zh/modules/grove/index.html) 接口,用户可以很方便的进行 DIY。 ### 板载 I2C 设备 传感器 功能 I2C 地址(7位地址) SCL SDA 示例代码 ADS1115 ADC 0x48 IO23 IO24 [script](https://github.com/sipeed/MaixPy v1_scripts/tree/master/modules/others/ads1115) ADXL345 三轴加速度计 0x53 IO23 IO24 [script](https://github.com/sipeed/MaixPy v1_scripts/tree/master/modules/others/adxl345) ## 资源下载 [原理图](http://dl.sipeed.com/fileList/MAIX/HDK/Sipeed Grove_AI_HAT/Grove_AI_HAT_for_Edge_Computing_v1.0_SCH_190514.pdf)"},"/hardware/zh/maix/maixpy_develop_kit_board/maix_bit.html":{"title":"Maix Bit","content":"# Maix Bit ## 教程&快速上手 相关的使用教程入口<a href \"/soft/maixpy/zh/\" target \"_blank\"> MaixPy </a> ## 描述 MAIX Bit开发板是SiPEED公司MAIX产品线的一员，基于嘉楠堪智科技的边缘智能计算芯片K210(RISC V架构 64位双核)设计的一款AIOT开发板。经典两侧排针设计，可以直接配合面包板使用，板载Type C接口和USB UART电路，用户可以直接通过USB Type C线连接电脑进行开发，配置128Mbit Flash、LCD、DVP、Micro SD卡等接口并把所有IO引出，方便用户扩展。 ## 外观 <img src \"./../assets/dk_board/maix_bit/Bit.png\" alt \"Maxi bit\" > ## 特性 MaixBit开发板以K210作为核心单元，功能非常很强大，芯片内置64位双核处理器，拥有8M的片上SRAM，在Al机器视觉、听觉性能方便表现突出，内置多种硬件加速单元(KPU、FPU，FFT等)，总算力最高可达1TOPS，可以方便地实现各类应用场景的机器视觉/听觉算法,也可以进行语音方向扫描和语音数据输出的前置处理工作。 ## 应用 智能家居，机器人清洁器，智能扬声器，电子门锁，家庭监控等; 医学行业应用，如辅助诊断，医学图像识别; 智能工业应用，如工业机械，智能分拣，电气设备监控等; 教育机器人，智能互动平台，教育效率检查等教育应用; 农业应用，如农业监测，病虫害监测，自动控制等 ## 参数 <table role \"table\" class \"center_table\"> <thead> <tr> <th colspan \"2\">K210 芯片基本参数</th> </tr> </thead> <tbody> <tr> <td>内核</td> <td>RISC V Dual Core 64bit, with FPU</td> </tr> <tr> <td>主频</td> <td>400MHz （可超频至600MHz）</td> </tr> <tr> <td>SRAM</td> <td>内置8M Byte</td> </tr> <tr> <td>图像识别</td> <td>QVGA@60fps/VGA@30fps</td> </tr> <tr> <td>语音识别</td> <td>麦克风阵列(8mics)</td> </tr> <tr> <td>网络模型</td> <td><li>支持YOLOv3<li>Mobilenetv2<li>TinyYOLOv2<li>人脸识别等</td> </tr> <tr> <td>深度学习框架</td> <td>支持TensorFlow \\ Keras \\ Darknet \\ Caffe 等主流框架</td> </tr> <tr> <td>外设</td> <td>FPIOA、 UART、 GPIO、 SPI、 I2C、I2S、 TIMER</td> </tr> <tr> <td>视频处理</td> <td><li>神经网络处理器(KPU)<li>FPU满足IEEE754 2008标准<li>音频处理器(APU)<li>快速傅里叶变换加速器(FFT)</td> </tr> </tbody> </table> <table role \"table\" class \"center_table\"> <thead> <tr> <th colspan \"2\" >开发板参数</th> </tr> </thead> <td> 板载资源</td> <td><li>按键*2 <li>RGB灯*1<li>MEMS Microphone*1<li>USB to UART<li>128Mbit Flash*1</td> </tr> <tr> <td>板载接口</td> <td><li>USB Type C接口<li>24PIN DVP摄像头接口<li>24PIN LCD接口<li>MicroSD卡槽<li>所有IO排针引脚引出</td> </tr> <tr> <td>尺寸</td> <td>53.3*25.4mm</td> </tr> <tr> <td>供电电压</td> <td>5.0V @ 300mA（供电电流需大于300mA)</td> </tr> <tr> <td>工作温度</td> <td> 30℃ ~85℃</td> </tr> </table> <table role \"table\" class \"center_table\"> <thead> <tr> <th colspan \"2\">软件开发</th> <tr> </thead> <tr> <td>芯片操作系统</td> <td>FreeRTOS、RT Thread等</td> </tr> <tr> <td>开发环境</td> <td>MaixPy IDE、PlatformlO IDE、Arduino IDE等</td> </tr> <tr> <td>编程语言</td> <td>C，C++，MicroPython</td> </tr> </table> ## 资料下载 Sipeed Maix Bit 资料下载：[Sipeed Maix Bit](https://dl.sipeed.com/shareURL/MAIX/HDK/Sipeed Maix Bit/Maix Bit_V2.0_with_MEMS_microphone) Sipeed Maix Bit 规格书下载：[Sipeed Maix Bit](https://dl.sipeed.com/fileList/MAIX/HDK/Sipeed Maix Bit/Specifications/Sipeed%20Maix Bit%20%E8%A7%84%E6%A0%BC%E4%B9%A6%20V2.0.pdf) Sipeed Maix Bit 原理图下载：[Sipeed Maix Bit](https://dl.sipeed.com/fileList/MAIX/HDK/Sipeed Maix Bit/Maix Bit_V2.0_with_MEMS_microphone/Maix Bit_V2.0_Schematic.pdf) ## 软件开发 1. [MaixPy](https://wiki.sipeed.com/maixpy)：MicroPython 语言开发 2. C 语言 SDK: [kendryte standalone sdk](https://github.com/kendryte/kendryte standalone sdk) ## 产品技术支持 Maix系列产品可以在多种场景实现客户不同方面的需要，在AIoT上已经广泛的使用，品质和性能在行业内已经有非常好的口碑，专业的技术团队为广大客户解决硬件设计和软件功能上的各种各样问题。专业技术支持和更详细资料请联系商务<support@sipeed.com>。"},"/hardware/zh/maix/maixpy_develop_kit_board/maix_Amigo.html":{"title":"MaixAmigo","content":"# MaixAmigo ## 使用教程 <a href \"/soft/maixpy/zh/\" target \"_blank\"> MaixPy </a> ## 概述 SIPEED MaixAmigo 是基于我们 M1n 模块(主控:Kendryte K210)开发的一款集学习开发和商用一体的人脸识别产品. <br/>MaixAmigo 集成前后摄像头、TF卡槽、用户按键、TFT显示屏、锂电池、扬声器麦克风、扩展接口等, 用户可使用 MaixAmigo 轻松搭建一款人脸识别门禁系统, 同时还预留开发调试接口, 也能将其作为一款功能强大的 AI 学习开发板. ## MaixAmigo 外观及功能介绍 ### 外观一览 ![MaixAmigo](./../assets/dk_board/maxi_amigo/image 20200730120223557.png) ### 板载硬件功能介绍 3.5 寸 **TFT** 屏幕: 分辨率 **320x480*** 3.5 寸电阻触摸屏： FT6X36 芯片复位按键 电源按键: 短按开机, 长按 *8S* 关机 三个功能按键 Grove 接口: 板载 3 个**Grove** 数字接口, 传感器,控制器扩展无限可能~ SP MOD 接口: 板载 3 个更加强大,更高扩展性的 **SP MOD** 数字接口, I2C,SPI(标准,双线,四线模式)等接口均可以使用 后续支持乐高手柄功能 TF 卡槽: 多媒体资源扩展,支持大容量储存 摄像头: 搭载 **OV7740** **30W** 像素 与 **GC0328 30W 像素** **Sensor** Type C 接口: USB TypeC 电源、调试接口,正反盲插 电源管理控制单元: AXP173 板载 600mAh 锂电池,支持用户充放电控制 音频驱动 IC: ES8374 支持音频录制,播放 三轴加速度传感器: MSA301 ### 板载扩展接口 MaixAmigo 对用户开放了两个高度扩展的接口: SP MOD 与 Grove 接口, 用户可以很方便的进行 DIY #### SP MOD 接口 SP MOD 即为 sipeed module, simplify PMOD, super module 接口 接口描述 SP MODE 接口描述![spmod_interface_1](./../../../assets/spmod/spmod_interface_1.png) 硬件接口![spmod_interface_2](./../../../assets/spmod/spmod_interface_2.png) #### Grove 接口 Grove 接口的线缆有 4 种颜色, 用户可以根据颜色快速区别 ![grove_interface](./../assets/interface_grove/grove_interface.jpg) pin 颜色 描述 pin 1 黄色 (例如, I2C Grove Connectors上的SCL) pin 2 白色 (例如, I2C Grove Connectors上的SDA) pin 3 红色 VCC (所有的Grove接口红色都是VCC) pin 4 黑色 GND (所有的Grove接口红色都是GND) Grove模块主要有 4 种接口: Grove Digital 数字接口: Grove 数字接口由 Grove 插头的四条标准线组成. 两条信号线通常称为 D0 和 D1 . 大多数模块只使用 D0, 但有些(像LED Bar Grove显示屏)使用两者.通常核心板会将板卡上的第一个Grove连接头称为 D0, 第二个称为 D1.第一个接头会连接到主控芯片的 DO/D1 管脚, 第二个连接头会连接到主控芯片的D1/D2引脚, 后面的连接头以此类推. pin Function Note pin1 Dn 第一个数字输入 pin2 Dn+1 第二个数字输入 pin3 VCC 供电引脚 5V/3.3V pin4 GND 地 Grove Analog 模拟接口 Grove模拟接口由Grove插头的四条标准线组成. 两条信号线通常称为A0和A1. 大多数模块只使用A0，但有些（像LED Bar Grove显示屏）使用两者. 通常核心板会将板卡上的第一个Grove连接头称为A0，第二个称为A1。第一个接头会连接到主控芯片的AO/A1管脚，第二个连接头会连接到主控芯片的A1/A2引脚，后面的连接头以此类推. pin Function Note pin1 An 第一个模拟输入 pin2 An+1 第二个模拟输入 pin3 VCC 供电引脚 5V/3.3V pin4 GND 地 Grove UART : The Grove UART 是特殊的一种数字输入输出接口 它使用引脚 1 和引脚 2 进行串行输入和发送 引脚1是 RX 线(用于接收数据, 因此是输入) 其中引脚 2 是 TX 线(用于向 Grove 模块传输数据) pin Function Note pin1 RX 串行接收 pin2 TX 串行发送 pin3 VCC 供电引脚 5V/3.3V pin4 GND 地 Grove I2C: 有许多类型的 I2C Grove 传感器可用.MaixAmigo 上的 Grove 只支持 3.3V 传感器 Grove I2C 连接器具有标准布局.引脚 1 是SCL信号, 引脚 2 是SDA信号 pin Function Note pin1 SCL I2C 时钟 pin2 SDA I2C 数据 pin3 VCC 供电引脚, 5V/3.3V pin4 GND 地 ### 板载 I2C 设备 MaixAmigo 板载 I2C 传感器/IC IC 设备 id I2C 地址(7位地址) ES8374 0x08 0x10 MSA301 0x13 0x26 AXP173 0x68 0x34 ## 参数 Maix Amigo内置64位400Mhz双核高性能处理器,拥有8M的片上SRAM，16MiB FLASH大容量存储,轻松处理多媒体应用,在AI机器视觉、听觉性能方便表现突出，内置多种硬件加速单元（KPU、FPU，FFT等)，总算力最高可达1TOPS,可以方便地实现各类应用场景的机器视觉/听觉算法,也可以进行语音扫描和语音数据输出的前置处理工作 <table role \"table\" class \"center_table\"> <thead> <tr> <th colspan \"2\">K210 芯片基本参数</th> </tr> </thead> <tbody> <tr> <td>内核</td> <td>RISC V Dual Core 64bit, with FPU</td> </tr> <tr> <td>主频</td> <td>400MHz （可超频至600MHz）</td> </tr> <tr> <td>SRAM</td> <td>内置8M Byte</td> </tr> <tr> <td>摄像头帧率</td> <td>OV7740/QVGA@60fps/VGA@30fps</td> </tr> <tr> <td>语音识别</td> <td>离线语音识别，声场</td> </tr> <tr> <td>网络模型</td> <td><li>支持MobileNetV1/V2<li>人脸识别<li>ASR</td> </tr> <tr> <td>深度学习框架</td> <td>支持TensorFlow \\ Keras \\ Darknet \\ Caffe 等主流框架</td> </tr> <tr> <td>外设</td> <td>FPIOA、 UART、 GPIO、 SPI、 I2C、I2S、 TIMER</td> </tr> <tr> <td>硬件加速单元</td> <td><li>KPU卷积运算加速器<li>FPU浮点运算加速器<li>APU音频处理器<li>FFT傅里叶变换加速器</td> </tr> </tbody> </table> <table role \"table\" class \"center_table\"> <thead> <tr> <th colspan \"2\" >开发板参数</th> </tr> </thead> <td> 板载资源</td> <td><li>3.5寸TFT屏幕<li>复位按键*1<li>功能按键*3<li>前后摄像头*2<li>LED*3<li>加速度传感器*1</td> </tr> <tr> <td>板载接口</td> <td><li>USB Type C接口<li>音频接口(支持外接扬声器)<li>TF卡槽<li>Grove标准接口<li>SP MOD接口(支持SP MOD接口模块)</td> </tr> <tr> <td>尺寸</td> <td>104.3*63.3*16.5mm</td> </tr> <tr> <td>供电电压</td> <td>USB type或内部锂电池（520mAh）</td> </tr> </table> <table role \"table\" class \"center_table\"> <thead> <tr> <th colspan \"2\">软件开发</th> <tr> </thead> <tr> <td>软件环境</td> <td>MaixPy（microPython）</td> </tr> <tr> <td>开发环境</td> <td>MaixPy IDE、PlatformlO IDE、Arduino IDE等</td> </tr> <tr> <td>编程语言</td> <td>C，MicroPython</td> </tr> </table> ## 相关资料下载 Maix Amigo 资料下载：[Sipeed Amigo](https://dl.sipeed.com/shareURL/MAIX/HDK/Sipeed Amigo) Maix Amigo 规格书下载：[Sipeed Amigo](https://dl.sipeed.com/shareURL/MAIX/HDK/Sipeed Amigo/ProductSpecification) Maix Amigo IPS 版本 原理图下载：<a href \"https://dl.sipeed.com/fileList/MAIX/HDK/Sipeed Amigo/2970/Maix_Amigo_2970(Schematic).pdf\">Maix_Amigo_2970(Schematic).pdf</a> Maix Amigo TFT 版本 原理图下载：<a href \"https://dl.sipeed.com/fileList/MAIX/HDK/Sipeed Amigo/2960/Maix_Amigo_2960(Schematic).pdf\">Maix_Amigo_2960(Schematic).pdf</a> ## 软件开发 1. [MaixPy](https://wiki.sipeed.com/maixpy)：MicroPython 语言开发 2. C 语言 SDK: [kendryte standalone sdk](https://github.com/kendryte/kendryte standalone sdk) ## 产品技术支持 Maix系列产品可以在多种场景实现客户不同方面的需要，在AIoT上已经广泛的使用，品质和性能在行业内已经有非常好的口碑，专业的技术团队为广大客户解决硬件设计和软件功能上的各种各样问题。专业技术支持和更详细资料请联系商务<support@sipeed.com>。"},"/hardware/zh/maix/maixpy_develop_kit_board/maix_cube.html":{"title":"MaixCube","content":"# MaixCube ## 使用教程 <a href \"/soft/maixpy/zh/\" target \"_blank\"> MaixPy </a> ## 概述 SIPEED MaixCube 是基于我们 M1n 模块(主控:Kendryte K210)开发的一款集学习开发和商用一体的人脸识别产品. <br/>MaixCube 集成摄像头、TF卡槽、用户按键、TFT显示屏、锂电池、扬声器麦克、扩展接口等, 用户可使用 Maix Cube 轻松搭建一款人脸识别门禁系统, 同时还预留开发调试接口, 也能将其作为一款功能强大的 AI 学习开发板. ## MaixCube 外观及功能介绍 ### 外观一览 ![maixcube_product_appearance](./../assets/dk_board/maix_cube/maixcube_product_appearance.png) ### 板载功能介绍 电源管理控制单元: AXP173 板载 200mAh 锂电池,支持用户充放电控制 音频驱动 IC: ES8374 支持音频录制,播放 三轴加速度传感器: MSA301 Camera OV7740: 1.3 IPS LCD: RGB: 板载两颗 RGB LED USB Type C:Type C 接口,正反盲插 ### 板载扩展接口 Maix Cube 对用户开放了两个高度扩展的接口: SP MOD 与 Grove 接口, 用户可以很方便的进行 DIY #### SP MOD 接口 SP MOD 即为 sipeed module, simplify PMOD, super module 接口 接口描述 SP MODE 接口描述![spmod_interface_1](./../../../assets/spmod/spmod_interface_1.png) 硬件接口![spmod_interface_2](./../../../assets/spmod/spmod_interface_2.png) #### Grove 接口 Grove 模块接口 Grove 接口的线缆有 4 种颜色, 用户可以根据颜色快速区别 ![grove_interface](./../assets/interface_grove/grove_interface.jpg) 颜色 描述 pin 1 黄色 (例如, I2C Grove Connectors上的SCL) pin 2 白色 (例如, I2C Grove Connectors上的SDA) pin 3 红色 VCC (所有的Grove接口红色都是VCC) pin 4 黑色 GND (所有的Grove接口红色都是GND) Grove模块主要有 4 种接口: Grove Digital 数字接口: Grove 数字接口由 Grove 插头的四条标准线组成. 两条信号线通常称为 D0 和 D1 . 大多数模块只使用 D0, 但有些(像LED Bar Grove显示屏)使用两者.通常核心板会将板卡上的第一个Grove连接头称为 D0, 第二个称为 D1.第一个接头会连接到主控芯片的 DO/D1 管脚, 第二个连接头会连接到主控芯片的D1/D2引脚, 后面的连接头以此类推. pin Function Note pin1 Dn 第一个数字输入 pin2 Dn+1 第二个数字输入 pin3 VCC 供电引脚 5V/3.3V pin4 GND 地 Grove Analog 模拟接口 Grove模拟接口由Grove插头的四条标准线组成. 两条信号线通常称为A0和A1. 大多数模块只使用A0，但有些（像LED Bar Grove显示屏）使用两者. 通常核心板会将板卡上的第一个Grove连接头称为A0，第二个称为A1。第一个接头会连接到主控芯片的AO/A1管脚，第二个连接头会连接到主控芯片的A1/A2引脚，后面的连接头以此类推. pin Function Note pin1 An 第一个模拟输入 pin2 An+1 第二个模拟输入 pin3 VCC 供电引脚 5V/3.3V pin4 GND 地 Grove UART : The Grove UART 是特殊的一种数字输入输出接口 它使用引脚 1 和引脚 2 进行串行输入和发送 引脚1是 RX 线(用于接收数据, 因此是输入) 其中引脚 2 是 TX 线(用于向 Grove 模块传输数据) pin Function Note pin1 RX 串行接收 pin2 TX 串行发送 pin3 VCC 供电引脚 5V/3.3V pin4 GND 地 Grove I2C: 有许多类型的 I2C Grove 传感器可用.MaixAmigo 上的 Grove 只支持 3.3V 传感器 Grove I2C 连接器具有标准布局.引脚 1 是SCL信号, 引脚 2 是SDA信号 pin Function Note pin1 SCL I2C 时钟 pin2 SDA I2C 数据 pin3 VCC 供电引脚, 5V/3.3V pin4 GND 地 ### 板载 I2C 设备 MaixCube 板载 I2C 传感器/IC IC 设备 id I2C 地址(7位地址) ES83740x080x10 MSA3010x130x26 AXP1730x680x34 ## MaixCube参数 ![maixcube_resources](./../assets/dk_board/maix_cube/maixcube_resources.png) <table role \"table\" class \"center_table\"> <thead> <tr> <th colspan \"2\">K210 芯片基本参数</th> </tr> </thead> <tbody> <tr> <td>内核</td> <td>RISC V Dual Core 64bit, with FPU</td> </tr> <tr> <td>主频</td> <td>400MHz （可超频至500MHz）</td> </tr> <tr> <td>SRAM</td> <td>内置8M Byte</td> </tr> <tr> <td>摄像头帧率</td> <td>OV7740/QVGA@60fps/VGA@30fps</td> </tr> <tr> <td>语音识别</td> <td>离线语音识别，声场</td> </tr> <tr> <td>网络模型</td> <td><li>支持MobileNetV1/V2<li>人脸识别<li>ASR</td> </tr> <tr> <td>深度学习框架</td> <td>支持TensorFlow \\ Keras \\ Darknet \\ Caffe 等主流框架</td> </tr> <tr> <td>外设</td> <td>FPIOA、 UART、 GPIO、 SPI、 I2C、I2S、 TIMER</td> </tr> <tr> <td>硬件加速单元</td> <td><li>KPU卷积运算加速器<li>FPU浮点运算加速器<li>APU音频处理器<li>FFT傅里叶变换加速器</td> </tr> </tbody> </table> <table role \"table\" class \"center_table\"> <thead> <tr> <th colspan \"2\" >开发板参数</th> </tr> </thead> <td> 板载资源</td> <td><li>按键*3<li>摄像头*1<li>RGB LED*2 <li>1.3寸TFT屏幕<li>Electret Microphone*1<li>128Mbit Flash*1<li>加速度传感器*1<li>0.5W扬声器</td> </tr> <tr> <td>板载接口</td> <td><li>USB Type C接口<li>TF卡槽<li>Grove标准接口<li>SP MOD接口(支持SP MOD接口模块)</td> </tr> <tr> <td>尺寸</td> <td>40*40*18.6mm</td> </tr> <tr> <td>供电电压</td> <td>USB type或内部锂电池（200mAh）</td> </tr> </table> <table role \"table\" class \"center_table\"> <thead> <tr> <th colspan \"2\">软件开发</th> <tr> </thead> <tr> <td>软件环境</td> <td>MaixPy（microPython）</td> </tr> <tr> <td>开发环境</td> <td>MaixPy IDE、PlatformlO IDE、Arduino IDE等</td> </tr> <tr> <td>编程语言</td> <td>C，MicroPython</td> </tr> </table> ## 相关资料下载 Sipeed Maix Cube 资料下载：[Sipeed Maix Cube](https://dl.sipeed.com/shareURL/MAIX/HDK/Sipeed Maix Cube) Sipeed Maix Cube 规格书下载：[Sipeed Maix Cube](https://dl.sipeed.com/shareURL/MAIX/HDK/Sipeed Maix Cube/ProductSpecification/Sipeed%20Maix%20Cube%20Datasheet%20V1.0.pdf) Sipeed Maix Cube 原理图下载：[Sipeed Maix Cube.pdf](https://dl.sipeed.com/shareURL/MAIX/HDK/Sipeed Maix Cube/Maix Cube 2757) ## 软件开发 1. [MaixPy](https://wiki.sipeed.com/maixpy)：MicroPython 语言开发 2. C 语言 SDK: [kendryte standalone sdk](https://github.com/kendryte/kendryte standalone sdk) ## 产品技术支持 Maix系列产品可以在多种场景实现客户不同方面的需要，在AIoT上已经广泛的使用，品质和性能在行业内已经有非常好的口碑，专业的技术团队为广大客户解决硬件设计和软件功能上的各种各样问题。专业技术支持和更详细资料请联系商务<support@sipeed.com>。"},"/hardware/zh/maix/maixpy_develop_kit_board/maix_duino.html":{"title":"MaixDuino 开发板","content":"# MaixDuino 开发板 ## 概述 SIPEED MaixDuino 是基于我们 M1 模块(主控:Kendryte K210)开发的一款外形兼容 Arduino 的开发板 <br/>MaixDuino 集成摄像头、TF卡槽、用户按键、TFT显示屏、MaixDuino 扩展接口等, 用户可使用 MaixDuino 轻松搭建一款人脸识别门禁系统, 同时还预留开发调试接口, 也能将其作为一款功能强大的 AI 学习开发板. ## MaixDuino 外观及功能介绍 ### 外观一览 ![MaixDuino](./../assets/dk_board/maix_duino/maixduino_0.png) ![MaixDuino](./../assets/dk_board/maix_duino/maixduino_1.png) ![MaixDuino](./../assets/dk_board/maix_duino/maixduino_2.png) ### 引脚图 ![maixduino pins](../assets/dk_board/maix_duino/maixduino_pins_1080.png) ### 板载功能介绍 电源输入 DC05: 6~12V 直流 电源输入 + 程序下载调试接口: USB Type C 接口 DVP 24PIN: 标准 Camera DVP 24PIN 接口 TF 扩展槽: ESP32: ESP32 SPI 连接(ESP32 支持 WIFI 与 蓝牙) I2C DAC PA PAM8403A ![MaixDuino](./../assets/dk_board/maix_duino/maixduino_3.jpg) ## MaixDuino参数 Maixduino开发板以M1Al模块作为核心单元，功能非常很强大，模块内置64位双核处理器芯片，拥有8M的片上SRAM，在Al机器视觉、听觉性能方便表现突出，内置多种硬件加速单元(KPU、FPU，FFT等)，总算力最高可达1TOPS，可以方便地实现各类应用场景的机器视觉/听觉算法,也可以进行语音方向扫描和语音数据输出的前置处理工作。此外，开发板还配置了ESP32模块(WiFi+蓝牙一体)，简单的操作即可轻松联网。 <table role \"table\" class \"center_table\"> <thead> <tr> <th colspan \"2\">K210 芯片基本参数</th> </tr> </thead> <tbody> <tr> <td>内核</td> <td>RISC V Dual Core 64bit, with FPU</td> </tr> <tr> <td>主频</td> <td>400MHz （可超频至600MHz）</td> </tr> <tr> <td>SRAM</td> <td>内置8M Byte</td> </tr> <tr> <td>图像识别</td> <td>QVGA@60fps/VGA@30fps</td> </tr> <tr> <td>语音识别</td> <td>麦克风阵列(8mics)</td> </tr> <tr> <td>网络模型</td> <td><li>支持YOLOv3<li>Mobilenetv2<li>TinyYOLOv2<li>人脸识别等</td> </tr> <tr> <td>深度学习框架</td> <td>支持TensorFlow \\ Keras \\ Darknet \\ Caffe 等主流框架</td> </tr> <tr> <td>外设</td> <td>FPIOA、 UART、 GPIO、 SPI、 I2C、I2S、 TIMER</td> </tr> <tr> <td>视频处理</td> <td><li>神经网络处理器(KPU)<li>FPU满足IEEE754 2008标准<li>音频处理器(APU)<li>快速傅里叶变换加速器(FFT)</td> </tr> </tbody> </table> <table role \"table\" class \"center_table\"> <thead> <tr> <th colspan \"2\">ESP32模块</th> </tr> </thead> <tr> <td>主控</td> <td>ESP32 D0WDQ6(Xtensa 32 bit内核)</td> </tr> <tr> <td>无线标准</td> <td>802.11b/g/n</td> </tr> <tr> <td>无线频率</td> <td>2400MHz 2483.5MHz</td> </tr> <tr> <td>无线协议</td> <td>2.4G WiFi+双模蓝牙(BT&BLE4.2)</td> </tr> <tr> <td>天线</td> <td>PCB板载天线</td> </tr> </table> <table role \"table\" class \"center_table\"> <thead> <tr> <th colspan \"2\" >开发板参数</th> </tr> </thead> <td> 板载资源</td> <td><li>RGB灯*1<li>MEMS Microphone*1<li>USB转串口*1</td> </tr> <tr> <td>板载接口</td> <td><li>USB Type C接口<li>24PIN DVP摄像头接口<li>24PIN LCD接口<li>MicroSD卡槽<li>音频接口（支持外接3扬声器）<li>部分IO排针引脚引出</td> </tr> <tr> <td>尺寸</td> <td>60*88mm</td> </tr> <tr> <td>供电电压</td> <td>5.0V @ 300mA（供电电流需大于300mA)</td> </tr> <tr> <td>工作温度</td> <td> 30℃ ~85C</td> </tr> </table> <table role \"table\" class \"center_table\"> <thead> <tr> <th colspan \"2\">软件开发</th> <tr> </thead> <tr> <td>芯片操作系统</td> <td>FreeRTOS、RT Thread等</td> </tr> <tr> <td>开发环境</td> <td>MaixPy IDE、PlatformlO IDE、Arduino IDE等</td> </tr> <tr> <td>编程语言</td> <td>C，C++，MicroPython</td> </tr> </table> ## 资料相关链接 [MaixDuino 原理图](https://dl.sipeed.com/shareURL/MAIX/HDK/Sipeed Maixduino) <a href \"/soft/maixpy/zh/\" target \"_blank\"> MaixPy的使用教程入口 </a> （推荐） <a href \"/soft/maixduino/zh/\" target \"_blank\"> arduino的使用教程入口 </a> ## 软件开发 1. [MaixPy](https://wiki.sipeed.com/maixpy)：MicroPython 语言开发 2. C 语言 SDK: [kendryte standalone sdk](https://github.com/kendryte/kendryte standalone sdk) 3. [Maixduino](https://github.com/sipeed/Maixduino): 适配 Arduino 库开发环境 ## 产品技术支持 Maix系列产品可以在多种场景实现客户不同方面的需要，在AIoT上已经广泛的使用，品质和性能在行业内已经有非常好的口碑，专业的技术团队为广大客户解决硬件设计和软件功能上的各种各样问题。专业技术支持和更详细资料请联系商务<support@sipeed.com>。"},"/hardware/zh/maix/maixpy_develop_kit_board/maix_nano.html":{"title":"Maix nano","content":"# Maix nano ## 教程&快速上手 相关的使用教程入口<a href \"./../../../../soft/maixpy/zh/\" target \"_blank\"> MaixPy </a> ## 描述 MAIX Nano开发板是SiPEED公司MAIX产品线的一员，基于嘉楠堪智科技的边缘智能计算芯片K210(RISC V架构 64位双核)设计的一款AIOT开发板。开发板使用模块+底板方式设计，整洁小巧，板载Type C接口和USB UART电路，用户可以直接通过USB Type C线连接电脑进行开发，配置128Mbit Flash、LCD、DVP、Micro SD卡等接口并把所有IO引出，方便用户扩展。 ## 外观 <img src \"./../assets/dk_board/maix_nano/maix_nano.jpg\" alt \"Maxi nano\" > ## 特性 MAIX Nano开发板以K210作为核心单元，功能非常很强大，芯片内置64位双核处理器，拥有8M的片上SRAM，在Al机器视觉、听觉性能方便表现突出，内置多种硬件加速单元(KPU、FPU，FFT等)，总算力最高可达1TOPS，可以方便地实现各类应用场景的机器视觉/听觉算法,也可以进行语音方向扫描和语音数据输出的前置处理工作。 ## 应用 智能家居，机器人清洁器，智能扬声器，电子门锁，家庭监控等; 医学行业应用，如辅助诊断，医学图像识别; 智能工业应用，如工业机械，智能分拣，电气设备监控等; 教育机器人，智能互动平台，教育效率检查等教育应用; 农业应用，如农业监测，病虫害监测，自动控制等 ## 参数 ![maix_nano](./../assets/dk_board/maix_nano/maix_nano.png) <table role \"table\" class \"center_table\"> <thead> <tr> <th colspan \"2\">K210 芯片基本参数</th> </tr> </thead> <tbody> <tr> <td>内核</td> <td>RISC V Dual Core 64bit, with FPU</td> </tr> <tr> <td>主频</td> <td>400MHz （可超频至600MHz）</td> </tr> <tr> <td>SRAM</td> <td>内置8M Byte</td> </tr> <tr> <td>图像识别</td> <td>QVGA@60fps/VGA@30fps</td> </tr> <tr> <td>语音识别</td> <td>麦克风阵列(8mics)</td> </tr> <tr> <td>网络模型</td> <td><li>支持YOLOv3<li>Mobilenetv2<li>TinyYOLOv2<li>人脸识别等</td> </tr> <tr> <td>深度学习框架</td> <td>支持TensorFlow \\ Keras \\ Darknet \\ Caffe 等主流框架</td> </tr> <tr> <td>外设</td> <td>FPIOA、 UART、 GPIO、 SPI、 I2C、I2S、 TIMER</td> </tr> <tr> <td>视频处理</td> <td><li>神经网络处理器(KPU)<li>FPU满足IEEE754 2008标准<li>音频处理器(APU)<li>快速傅里叶变换加速器(FFT)</td> </tr> </tbody> </table> <table role \"table\" class \"center_table\"> <thead> <tr> <th colspan \"2\" >开发板参数</th> </tr> </thead> <td> 板载资源和接口</td> <td><li>DVP摄像头接口*1 <li>大部分IO通过金手指方式引出，方便二次开发<li>USB to UART<li>128Mbit Flash*1</td> </tr> <tr> <td>尺寸</td> <td>25.0*22.0mm</td> </tr> <tr> <td>供电电压</td> <td>5.0V @ 300mA（供电电流需大于300mA)</td> </tr> <tr> <td>工作温度</td> <td> 30℃ ~85C</td> </tr> </table> <table role \"table\" class \"center_table\"> <thead> <tr> <th colspan \"2\">软件开发</th> <tr> </thead> <tr> <td>芯片操作系统</td> <td>FreeRTOS、Standrad development ki等</td> </tr> <tr> <td>开发环境</td> <td>MaixPy IDE、PlatformlO IDE、Arduino IDE等</td> </tr> <tr> <td>编程语言</td> <td>C，C++，MicroPython</td> </tr> </table> ## 资料下载 M1n 资料下载：[dl.sipeed.com](https://dl.sipeed.com/shareURL/MAIX/HDK/Sipeed M1n) M1n 原理图下载：[Sipeed M1n Datasheet V1.0.pdf](https://dl.sipeed.com/fileList/MAIX/HDK/Sipeed M1n/Sipeed%20M1n%20Datasheet%20V1.0.pdf) ## 产品技术支持 Maix系列产品可以在多种场景实现客户不同方面的需要，在AIoT上已经广泛的使用，品质和性能在行业内已经有非常好的口碑，专业的技术团队为广大客户解决硬件设计和软件功能上的各种各样问题。专业技术支持和更详细资料请联系商务<support@sipeed.com>。"},"/hardware/zh/maix/maixpy_develop_kit_board/Maix_dock.html":{"title":"Maix Dock(M1/M1W)","content":"# Maix Dock(M1/M1W) ## 教程&快速上手 <a href \"/soft/maixpy/zh/\" target \"_blank\"> MaixPy </a> ## 描述 MAIX Dock开发板是SiPEED公司MAIX产品线的一员，基于嘉楠堪智科技的边缘智能计算芯片K210(RISC V架构 64位双核)设计的一款AIOT开发板。化繁为简的设计，整洁小巧，板载Type C接口和USB UART电路，用户可以直接通过USB Type C线连接电脑进行开发，配置128Mbit Flash、LCD、DVP、Micro SD卡等接口并把所有IO引出，方便用户扩展。 > 上电即可开机，不需要开机操作 <img src \"./../assets/dk_board/maix_dock/Maix_Dock.jpg\" alt \"11\" width \"300\"> ## 外观 <img src \"./../assets/dk_board/maix_dock/Maix_Dock_3.png\" alt \"11\" > <img src \"./../assets/dk_board/maix_dock/Maix_Dock_2.png\" alt \"11\" > ## 特性 MaixDock 开发是以M1W AI模块作为核心单元，功能非常强大。模块内置64位双核处理器芯片，拥有8M的片上SRAM，在AI机器视觉、听觉性能方面表现突出，内置多种硬件加速单元（KPU、FPU、FFT等），总算力最高可达1TOPS，可以方便地实现各类应用场景的机器视觉/听觉算法，也可以进行语言方向扫描和语言数据输出的前置处理工作。 ## 应用 智能家居，机器人清洁器，智能扬声器，电子门锁，家庭监控等; 医学行业应用，如辅助诊断，医学图像识别; 智能工业应用，如工业机械，智能分拣，电气设备监控等; 教育机器人，智能互动平台，教育效率检查等教育应用; 农业应用，如农业监测，病虫害监测，自动控制等 ## 参数 <table role \"table\" class \"center_table\"> <thead> <tr> <th colspan \"2\">K210 芯片基本参数</th> </tr> </thead> <tbody> <tr> <td>内核</td> <td>RISC V Dual Core 64bit, with FPU</td> </tr> <tr> <td>主频</td> <td>400MHz （可超频至600MHz）</td> </tr> <tr> <td>SRAM</td> <td>内置8M Byte</td> </tr> <tr> <td>图像识别</td> <td>QVGA@60fps/VGA@30fps</td> </tr> <tr> <td>语音识别</td> <td>麦克风阵列(8mics)</td> </tr> <tr> <td>网络模型</td> <td><li>支持YOLOv3<li>Mobilenetv2<li>TinyYOLOv2<li>人脸识别等</td> </tr> <tr> <td>深度学习框架</td> <td>支持TensorFlow \\ Keras \\ Darknet \\ Caffe 等主流框架</td> </tr> <tr> <td>外设</td> <td>FPIOA、 UART、 GPIO、 SPI、 I2C、I2S、 TIMER</td> </tr> <tr> <td>视频处理</td> <td><li>神经网络处理器(KPU)<li>FPU满足IEEE754 2008标准<li>音频处理器(APU)<li>快速傅里叶变换加速器(FFT)</td> </tr> </tbody> </table> <table role \"table\" class \"center_table\"> <thead> <tr> <th colspan \"2\" >开发板参数</th> </tr> </thead> <td> 板载资源</td> <td><li>按键*2 <li>RGB灯*1<li>MEMS Microphone*1<li>USB to UART<li>128Mbit Flash*1</td> </tr> <tr> <td>板载接口</td> <td><li>USB Type C接口<li>24PIN DVP摄像头接口<li>24PIN LCD接口<li>MicroSD卡槽<li>音频接口(支持外接2x3W扬声器)<li>所有IO排针引脚引出</td> </tr> <tr> <td>尺寸</td> <td>52.3*37.3mm</td> </tr> <tr> <td>供电电压</td> <td>5.0V @ 300mA（供电电流需大于300mA)</td> </tr> <tr> <td>工作温度</td> <td> 30℃ ~85C</td> </tr> </table> <table role \"table\" class \"center_table\"> <thead> <tr> <th colspan \"2\">软件开发</th> <tr> </thead> <tr> <td>芯片操作系统</td> <td>FreeRTOS、RT Thread等</td> </tr> <tr> <td>开发环境</td> <td>MaixPy IDE、PlatformlO IDE、Arduino IDE等</td> </tr> <tr> <td>编程语言</td> <td>C，C++，MicroPython</td> </tr> </table> ## 资料 Sipeed Maix Dock 资料下载：[Sipeed Maix Dock](https://dl.sipeed.com/shareURL/MAIX/HDK/Sipeed Maix Dock) Sipeed Maix Dock 规格书下载：[Sipeed Maix Dock](https://dl.sipeed.com/shareURL/MAIX/HDK/Sipeed Maix Dock/Specifications) Sipeed Maix Dock 原理图下载：[Sipeed Maix Dock](https://dl.sipeed.com/fileList/MAIX/HDK/Sipeed Maix Dock/Maix Dock_11.27/Maix Dock_11.27 schematic.pdf) ## 软件开发 1. [MaixPy](https://wiki.sipeed.com/maixpy)：MicroPython 语言开发 2. C 语言 SDK: [kendryte standalone sdk](https://github.com/kendryte/kendryte standalone sdk) ## 产品技术支持 Maix系列产品可以在多种场景实现客户不同方面的需要，在AIoT上已经广泛的使用，品质和性能在行业内已经有非常好的口碑，专业的技术团队为广大客户解决硬件设计和软件功能上的各种各样问题。专业技术支持和更详细资料请联系商务<support@sipeed.com>。"},"/hardware/zh/maix/maixpy_develop_kit_board/develop_kit_board.html":{"title":"Maix 系列开发板","content":"# Maix 系列开发板 ## Maix 系列开发板 目前 MaixPy 系列开发板有一下这几款型号: Maix Go Maix Dock Maix Duino Maix Bit Maix Cube Maix Amigo <style type \"text/css\"> th { background color: #fbfbfb; border: 2px solid #f1f1f1; } </style> ## 差异对比 <table> <tbody> <tr> <th width \"226\" scope \"col\" >&nbsp;</th> <th width \"226\" scope \"col\" ><a href \"maix_go.html\"><img src \"../assets/dk_board/maix_go/Go.jpg\" width \"200\" alt \"\"/></a></th> <th width \"226\" scope \"col\"><a href \"maix_bit.html\"><img src \"../assets/dk_board/maix_bit/Bit.png\" width \"200\" alt \"Bit\"/></a></th> <th width \"226\" scope \"col\"><a href \"maix_cube.html\"><img src \"../assets/dk_board/maix_cube/maix_cube_1.png\" width \"200\" alt \"maix_cube\"/></a></th> <th width \"226\" scope \"col\"><a href \"Maix_dock.html\"><img src \"../assets/dk_board/maix_dock/Dan_Dock.png\" width \"200\" alt \"\"/></a></th> <th width \"226\" scope \"col\"><a href \"maix_duino.html\"><img src \"../assets/dk_board/maix_duino/DSC_08141.png\" width \"200\" alt \"\"/></a></th> <th width \"226\" scope \"col\"><a href \"maix_Amigo.html\"><img src \"../assets/dk_board/maxi_amigo/amigo.png\" width \"200\" alt \"\"/></a> </th> </tr> <tr> <td>型号 </td> <td>Maix Go</td> <td>Maix Bit</td> <td>Maix Cube</td> <td><p>Maix Dock</p></td> <td>Maix Duino</td> <td>Maix Amigo</td> </tr> <tr> <td>USB IC</td> <td>STM32</td> <td>CH552/CH340</td> <td>GD32/CH552</td> <td>CH340</td> <td>CH552</td> <td>GD32</td> </tr> <tr> <td>核心模块</td> <td>M1</td> <td>M1</td> <td>M1n</td> <td>M1/M1W</td> <td>M1</td> <td>M1n</td> </tr> <tr> <td height \"48\">WIFI 功能</td> <td>M1W 模块集成 ESP8285</td> <td> </td> <td> </td> <td>Dock M1 (不支持 WIFI)<br/> Dock M1W(支持,M1W 模块集成 ESP8285)</td> <td>板载 ESP32 （支持 WIFI, 蓝牙功能暂时未支持）</td> <td> </td> </tr> </tbody> </table> ## 产品技术支持 Maix系列产品可以在多种场景实现客户不同方面的需要，在AIoT上已经广泛的使用，品质和性能在行业内已经有非常好的口碑，专业的技术团队为广大客户解决硬件设计和软件功能上的各种各样问题。专业技术支持和更详细资料请联系商务<support@sipeed.com>。"},"/hardware/zh/maix/m1s/m1s_module.html":{"title":"M1s 模组","content":" title: M1s 模组 keywords: M1s ,模组, bl808, BL808 update: date: 2022 11 09 version: v0.2 author: wonder content: 修改部分描述错误 增加注意事项 增加软件描述栏目 date: 2022 10 18 version: v0.1 author: wonder content: 初次编写文档 ## 模组概述 Sipeed M1s 模组是基于[博流智能科技](http://www.bouffalolab.com/)的 BL808 芯片所设计的一款 AIOT 模组，主控芯片包含三个核心，具有 WiFi/BT/BLE/Zigbee 等无线互联单元，包含多个 CPU 以及音频编码译码器、视频编码译码器和 AI 硬件加速器（BLAI 100），适用于各种高性能和低功耗应用领域。 购买链接：[淘宝](https://item.taobao.com/item.htm?id 691108452443) <img src \"./assets/m1s_module/m1s_module_outlook.png\" alt \"m1s_module_outlook\" width 35%> ## 模组特点 主芯片 BL808 RV64 480MHz + RV32 320MHz + NPU BLAI 100GOPS 板载 SPI FLASH（默认 16MByte） 支持 2.4G WIFI / BT / BLE 支持 IPEX 一代天线座子和 PCB 板载天线 邮票孔引出所有 IO ## 模组参数 <table> <thead> <tr> <th colspan \"2\" > M1s 模组 </th> </tr> </thead> <tbody> <tr> <td rowspan \"8\" style \"white space:nowrap\">主控 BL808 处理器</td> </tr> <tr> <td>三核异构RISC V CPUs：<br>· RV64GCV 480MHz <br>· RV32GCP 320MHz <br>· RV32EMC 160MHz</td> </tr> <tr> <td>AI NN 通用硬件加速器：<br>· BLAI 100 用于视频/音频检测/识别，100GOPS 算力</td> </tr> <tr> <td>内置 768KB SRAM + 64MB UHS PSRAM</td> </tr> <tr> <td>编解码：<br> MJPEG and H264(Baseline/Main)<br> 1920x1080@30fps + 640x480@30fps </td> </tr> <tr> <td>接口：<br> 摄像头接口 ：DVP 和 MIPI CSI<br> 显示接口：SPI、DBI、DPI(RGB)</td> </tr> <tr> <td>无线：<br> 支持 Wi Fi 802.11 b/g/n<br> 支持 Bluetooth 5.x Dual mode(BT+BLE)<br> 支持 Wi Fi / 蓝牙 共存</td> </tr> <tr> <td>USB 2.0 HS OTG</td> </tr> <tr> <td rowspan \"3\" style \"white space:nowrap\"> 板载部件 </td> </tr> <tr> <td>板载 SPI FLASH（可选容量）</td> </tr> <tr> <td>支持 IPEX 一代天线座子和 PCB 板载天线</td> </tr> </tbody> <tr> <td rowspan \"6\" style \"white space:nowrap\"> 其他说明 </td> </tr> <tr> <td> 尺寸：31mm (L) x 18mm (W) </td> </tr> <tr> <td> 3D 模型文件下载：<a href \"https://dl.sipeed.com/shareURL/MAIX/M1s/M1s/5_3D_file\">点击跳转</a> </td> </tr> <tr> <td>外部供电需求：<br>VDDIO4/VDDIO3/VDDIO1/ 和 3V3 这几路电源必须给模块提供才能正常工作</td> </tr> <tr> <td>温升: &lt;30K</td> </tr> <tr> <td>工作温度范围: 10℃ ~ 65℃</td> </tr> </tbody> </table> <img src \"./assets/m1s_module/m1s_module_size.png\" alt \"m1s_module_size\" width 35%> ## 主控核心 三核异构 M0，D0，LP。 M0 D0 LP 平头哥 [E907](https://occ.t head.cn/product?id 3900588052540035072)@320MHz 平头哥 [C906](https://occ.t head.cn/product?id 3817197695983423488)@480MHz 平头哥 [E902](https://occ.t head.cn/product?id 3806460569050419200)@160MHz ## 引脚分布 前往原理图查看：[点我](https://dl.sipeed.com/shareURL/MAIX/M1s/M1s/2_Schematic) <! <img src \"./assets/m1s_module/m1s_pins.png\" alt \"m1s_pins\" width 55%> > ## 产品对比 <table> <thead> <tr> <th style \"text align:left\">项目</th> <th style \"text align:left\">M1(K210)</th> <th style \"text align:left\">M1s(BL808)</th> <th style \"text align:left\">ESP32 S3 WROOM N16R8</th> </tr> </thead> <tbody> <tr> <td style \"text align:left\">CPU</td> <td style \"text align:left\">RV64@400MHz x2</td> <td style \"text align:left\">· RV64GCV@480MHz<br>· RV32GCP@320MHz<br>· RV32EMC@160MHz</td> <td style \"text align:left;white space:nowrap\">Xtensa LX7@240MHz x2</td> </tr> <tr> <td style \"text align:left\">RAM</td> <td style \"text align:left\">8MB SRAM</td> <td style \"text align:left;white space:nowrap\">· 768KB SRAM <br>· 64MB UHS PSRAM(2000MHz)</td> <td style \"text align:left\">· 512KB SRAM<br>· 8MB PSRAM</td> </tr> <tr> <td style \"text align:left\">Flash</td> <td style \"text align:left\">16MB</td> <td style \"text align:left\">16MB</td> <td style \"text align:left\">16MB</td> </tr> <tr> <td style \"text align:left\">OS</td> <td style \"text align:left\">· FreeRTOS<br>· No mmu Linux</td> <td style \"text align:left\">· FreeRTOS<br>· Linux</td> <td style \"text align:left\">RTOS</td> </tr> <tr> <td style \"text align:left\">NPU</td> <td style \"text align:left;white space:nowrap\">230GOPS with limited OPS</td> <td style \"text align:left;white space:nowrap\">100GOPS with rich OPS</td> <td style \"text align:left\"></td> </tr> <tr> <td style \"text align:left\">Camera</td> <td style \"text align:left\">DVP, up to VGA</td> <td style \"text align:left\">MIPI + DVP, up to 1080P h264</td> <td style \"text align:left\">DVP</td> </tr> <tr> <td style \"text align:left\">Display</td> <td style \"text align:left\">· SPI<br>· 8bits MCU LCD</td> <td style \"text align:left\">· SPI<br>· 8bits MCU LCD<br>· RGB LCD</td> <td style \"text align:left\">· SPI<br>· 8bits MCU LCD</td> </tr> <tr> <td style \"text align:left\">Audio</td> <td style \"text align:left\">I2S</td> <td style \"text align:left\">· I2S<br>· Analog Audio Input/Output</td> <td style \"text align:left\">I2S</td> </tr> <tr> <td style \"text align:left\">Wireless</td> <td style \"text align:left\"></td> <td style \"text align:left\">WIFI+BLE+Zigbee</td> <td style \"text align:left\">WIFI + BLE</td> </tr> <tr> <td style \"text align:left\">USB</td> <td style \"text align:left\"></td> <td style \"text align:left\">USB2.0 OTG HS</td> <td style \"text align:left\">USB1.1 OTG</td> </tr> <tr> <td style \"text align:left\">Accelerator</td> <td style \"text align:left\">FFT</td> <td style \"text align:left\">· Scaler<br>· OSD<br>· MJPED<br>· G2D<br>· H264</td> <td style \"text align:left\"></td> </tr> <tr> <td style \"text align:left\">Perpheral</td> <td style \"text align:left\">UART, SPI, IIC</td> <td style \"text align:left\">UART, SPI, IIC, SDIO ETH(RMII), ADC/DAC</td> <td style \"text align:left\">UART, SPI, IIC, SDIO, ADC</td> </tr> <tr> <td style \"text align:left\">Size</td> <td style \"text align:left\">25.4 x 25.4 mm</td> <td style \"text align:left\">31 x 18 mm</td> <td style \"text align:left\">25.5 x 18 mm</td> </tr> <tr> <td style \"text align:left\">Price</td> <td style \"text align:left\">$6</td> <td style \"text align:left\">$6</td> <td style \"text align:left\">$4.3(digikey)</td> </tr> </tbody> </table> ## 软件描述 <table> <thead> <tr> <th colspan \"2\" > M1s 模组 </th> </tr> </thead> <tbody> <tr> <td>OS</td> <td>· 完备支持FreeRTOS<br>· 基础支持Linux</td> </tr> <tr> <td>开发方式</td> <td>· 原生C SDK<br>· MaixHAL C 模块<br>· PikaPython </td> </tr> <tr> <td>固件下载</td> <td>· 串口下载<br>· 虚拟磁盘拖拽式更新</td> </tr> <tr> <td>AI 推理框架</td> <td>· 支持原生SDK的BLAI加速推理引擎<br>· 支持通用TinyMaix推理引擎</td> </tr> <tr> <td>AI 模型下载</td> <td>· <a href \"https://maixhub.com/\">MaixHub</a> 下载。支持 人脸检测，识别，姿态检测，手势检测 等</td> </tr> <tr> <td>Sipeed 参考示例</td> <td>· https://gitee.com/sipeed/M1s_BL808_example</td> </tr> </tbody> </table> ## 支持算子列表 <table> <thead> <tr> <th>Type</th> <th>Operators</th> <th>Applicable Subset Spec.</th> <th>Processor</th> </tr> </thead> <tbody> <tr> <td rowspan \"10\">Convolution</td> <td rowspan \"4\">Conv </td> <td>Kernel: 1x1,3x3,5x5,7x7</td> <td rowspan \"4\">:strong:<code>NPU</code></td> </tr> <tr> <td>Stride: 1x1, 2x2</td> </tr> <tr> <td>Dilation: 1x1, 2x2</td> </tr> <tr> <td>Pad: same</td> </tr> <tr> <td rowspan \"4\">Depthwise Conv</td> <td>Kernel: 1x1,3x3 (5x5, 7x7 TBD)</td> <td rowspan \"4\">:strong:<code>NPU</code></td> </tr> <tr> <td>Stride: 1x1, 2x2</td> </tr> <tr> <td>Dilation: 1x1 (2x2 TBD)</td> </tr> <tr> <td>Pad: same</td> </tr> <tr> <td rowspan \"2\">Transpose Conv</td> <td>Kernel: 3x3</td> <td rowspan \"2\">strong:<code>NPU</code></td> </tr> <tr> <td>Stride: 2x2</td> </tr> <tr> <td rowspan \"4\">Pooling</td> <td rowspan \"2\">MaxPool (NPU TBD)</td> <td>Kerenl: 2x2</td> <td rowspan \"2\">DSP</td> </tr> <tr> <td>Stride: 2x2</td> </tr> <tr> <td rowspan \"2\">MaxPool</td> <td>Kerenl: 3x3</td> <td rowspan \"2\">:strong:<code>NPU</code></td> </tr> <tr> <td>Stride: 1x1, 2x2</td> </tr> <tr> <td rowspan \"2\">Activation</td> <td>Relu</td> <td></td> <td>:strong:<code>NPU</code></td> </tr> <tr> <td>Relu 6</td> <td></td> <td>:strong:<code>NPU</code></td> </tr> <tr> <td rowspan \"5\">Other processing</td> <td>BatchNormalization</td> <td>fused with conv</td> <td>:strong:<code>NPU</code></td> </tr> <tr> <td>Add (shortcut)</td> <td></td> <td>:strong:<code>NPU</code></td> </tr> <tr> <td>Concat (route)</td> <td>Channel wise (AXIS 3 in BHWC)</td> <td>:strong:<code>NPU</code></td> </tr> <tr> <td>Fully Connected</td> <td></td> <td>:strong:<code>NPU</code></td> </tr> <tr> <td>Upsample</td> <td>Nearest</td> <td>:strong:<code>NPU</code></td> </tr> </tbody> </table> ## 模组资料 [模组规格书](https://dl.sipeed.com/shareURL/MAIX/M1s/M1s/1_Specification) [模组原理图](https://dl.sipeed.com/shareURL/MAIX/M1s/M1s/2_Schematic) [模组封装库](https://dl.sipeed.com/shareURL/MAIX/M1s/M1s/7_Package) [模组点位图](https://dl.sipeed.com/shareURL/MAIX/M1s/M1s/3_Bit_number_map) [模组尺寸图](https://dl.sipeed.com/shareURL/MAIX/M1s/M1s/4_Dimensional_drawing) [3D 模型文件](https://dl.sipeed.com/shareURL/MAIX/M1s/M1s/5_3D_file) [模组芯片数据手册](https://dl.sipeed.com/shareURL/MAIX/M1s/M1s/6_Chip_Manual) [博流官方文档](https://dev.bouffalolab.com/home/) [BL808 数据手册](https://gitee.com/wonderfullook/bl_docs/tree/main/BL808_DS/zh_CN) (gitee) [BL808 参考手册](https://gitee.com/wonderfullook/bl_docs/tree/main/BL808_RM/zh_CN) (gitee) [Sipeed SDK](https://gitee.com/sipeed/M1s_BL808_SDK) (gitee) [Sipeed Examples](https://gitee.com/sipeed/M1s_BL808_example)（gitee） [Bouffalolab SDK](https://github.com/bouffalolab/bouffalo_sdk)（Github） [Linux SDK](https://github.com/sipeed/M1s_BL808_Linux_SDK)（Github） 交流 QQ 群：`592731168` 。[点我加群](https://jq.qq.com/?_wv 1027&k uyKNhTeu) 论坛：[bbs.sipeed.com](https://bbs.sipeed.com/) [在线模型平台](https://maixhub.com/) ## 注意事项 <table> <tr> <th>项目</th> <th>注意事项</th> </tr> <tr> <td>静电防护</td> <td>请避免静电打到 PCBA 上；接触 PCBA 之前请把手的静电释放掉</td> </tr> <tr> <td>容忍电压</td> <td> 每个 GPIO 的工作电压已经在原理图中标注出来，请不要让 GPIO 的实际工作的电压超过额定值，否则会引起 PCBA 的永久性损坏 </td> </tr> <tr> <td>FPC 座子</td> <td>在连接 FPC 软排线的时候，请确保排线无偏侈地完整地插入到排线中</td> </tr> <tr> <td>插拔</td> <td>请完全断电后才进行插拔操作</td> </tr> <tr> <td>避免短路</td> <td>请在上电过程中，避免任何液体和金属触碰到 PCBA 上的元件的焊盘，否则会导致路，烧毁 PCBA</td> </tr> <tr> <td>设计建议</td> <td>为该模组设计底板时，建议先看这个帖子 <a href \"https://bbs.sipeed.com/thread/1721\">https://bbs.sipeed.com/thread/1721</a></td> </tr> <tr> <td>BANK 划分</td> <td> VDDIO1：GPIO 0 8，1.8V/3.3V<br> VDDIO2：GPIO 11 15，GPIO 40 41, 3.3V only<br> VDDIO3：GPIO 16 23，1.8V/3.3V<br> VDDIO4：GPIO 24 39，1.8V/3.3V<br> </td> </tr> <tr> <td>BOOT 模式选择</td> <td> 在启动时，芯片判定 BOOT 引脚的电平，选择两个启动选项之一<br> · BOOT 高电平：从 FLASH 存储启动 · BOOT 低电平：进入串口下载模式 </td> </tr> </table> ## 联系方式 M1s 模组可以在多种场景实现客户不同方面的需要，技术支持和商业合作请联系邮箱 [support@sipeed.com](support@sipeed.com)"},"/hardware/zh/maix/m1s/other/start.html":{"title":"M1s DOCK 上手","content":" title: M1s DOCK 上手 keywords: M1s DOCK ,BL808, M1s update: date: 2023 05 09 version: v0.5 author: wonder content: 默认固件更改 重新编写开箱 新出厂固件不提供 date: 2023 02 27 version: v0.4 author: wonder content: 增加 wifi 串流使用说明 date: 2022 12 20 version: v0.3 author: wonder content: 增加部分blai相关内容 <! date: 2022 12 12 version: v0.2 author: wonder content: 增加部分细节解释 date: 2022 11 23 version: v0.1 author: wonder content: 初次编辑 M1s Dock 设计精巧，可以用来所很多有意思的事，这里简单说明一下一些使用方法。要注意的是串口默认波特率 2000000。 通过板子上的 UART 口连接 PC，在 Windows 系统的设备管理器中显示有两个 Converter 设备。 ![start_bl808_uart_converter](./assets/start/start_bl808_uart_converter.png) > > ## 开箱 下面地开箱说明以 M1S Dock 带屏幕和摄像头的套餐为例。 打开 M1S Dock 的包装盒后，看到里面有如下内容： 一根 USB 数据线 一块 M1S Dock 两条排针 <img src \"./assets/start/unbox_m1s_dock.jpg\" alt \"unbox_m1s_dock\" width \"50%\"> ## 硬件准备 两根 TypeC 数据线 一个 M1s Dock 一台电脑 M1S Dock 搭载有两个 TypeC 接口。默认情况下 UART 口用做于电脑和 M1S Dock 的串口通信，OTG 口默认用于给板子上的 BL808 芯片里面的 C906 核心烧录固件。 <img alt \"m1s_doc_pin_map\" src \"./../assets/m1s_dock/m1s_doc_pin_map.png\"> 1. 上图中可以看到 `S1` 、 `S2` 两个按键，另外还有 `BOOT` 按键和 `RST` 按键 2. 上图中板子的左下角有 UART 口，默认有 USB 转双串口功能连接到 BL808 芯片的两个核心上 3. 上图中板子的右下角有 OTG 口，M1s Dock 默认固件将它作用于烧录 C906 核心的固件。 ## 上电说明 ![m1s_dock_power_supply](./assets/start/m1s_dock_power_supply.png) ## 初次通电 ### 板卡现象 首次对 M1s Dock 板子上电，按下板子上的 RST (复位) 按键。 ![m1s_dock_rst_key_position](./assets/start/m1s_dock_rst_key_position.png) 会有如下现象： ![default_firmware](./assets/start/default_firmware_20230509.png) 按下 ① 处所指向的按键，屏幕上 ④ 处 `btn` 会变成绿色，并且 ⑥ 处的数字会增加，最大为 100 ② 是摄像头，屏幕会默认显示摄像头所拍摄到的画面 按下 ③ 处所指向的按键，屏幕上另一个 `btn` 会变成绿色，并且 ⑥ 处的数字会减小，最小为 0 ⑤ 是出货时所测试的无线 wifi 功能及其强度检测，用户手中此处空白 ⑦ 是板载麦克风测试，麦克风在背面位于板载 LED 的对称位置 另一面的 LED 会闪烁。 ![led_brghtness](./assets/start/led_brghtness.jpg) ### OTG 口现象 > 通过 OTG 口连接 PC 的话会有一个大小为 3M 的 U 盘。 部分电脑可能会因为兼容性问题显示不出来这个 U 盘，但是可以通过[串口烧录](https://wiki.sipeed.com/hardware/zh/maix/m1s/other/start.html#%E4%B8%B2%E5%8F%A3%E7%83%A7%E5%BD%95) 来重新烧录一次 M1s Dock 来解决该问题。 ![default_udisk](./assets/start/default_udisk.jpg) 并且在 Windows 的设备管理器中会看到大容量存储设备，在 linux 系统中也会出现一个可移动设备。 ![udisk_device_manager](./assets/start/udisk_device_manager.jpg) 如果没有看到大容量存储设备或者 U 盘在电脑中显示，可以先更换数据线或者链接电脑其他 USB 接口来尝试解决问题，仍然看不到的话可以跳转到 [串口烧录](https://wiki.sipeed.com/hardware/zh/maix/m1s/other/start.html#%E4%B8%B2%E5%8F%A3%E7%83%A7%E5%BD%95) 来重新烧录一次 M1s Dock 来解决该问题；烧录的时候并且勾选烧录 `partition table`, `boot2`, `firmware` 三个选项，烧录结束后重新将板子连接电脑。 ### UART 口现象 > 通过 UART 口连接 PC 会显示有两个串口设备 ![dual_uart](./assets/start/dual_uart.jpg) 并且在 Windows 系统的设备管理器中可以看到两个 Converter 设备。 ![start_bl808_uart_converter](./assets/start/start_bl808_uart_converter.png) 没有串口设备的话更换 USB 数据线或者使用电脑别的 USB 口。 依旧没有的话可以查看 [给板载 bl702 进行烧录](https://wiki.sipeed.com/hardware/zh/maix/m1s/other/start.html#%E7%BB%99%E6%9D%BF%E8%BD%BD bl702 %E8%BF%9B%E8%A1%8C%E7%83%A7%E5%BD%95) 相关的内容来给 bl702 重新烧录一次固件。在 M1s Dock 上，我们使用 bl702 芯片作为 USB 转双串口芯片，由于某些原因串口功能不能正常使用的时候，可以重新烧录固件来解决这个问题。 只有一个串口设备的话也可以查看 [给板载 bl702 进行烧录](https://wiki.sipeed.com/hardware/zh/maix/m1s/other/start.html#%E7%BB%99%E6%9D%BF%E8%BD%BD bl702 %E8%BF%9B%E8%A1%8C%E7%83%A7%E5%BD%95) 章节并且重新烧录 bl702 来解决问题。 设置波特率为 2000000，分别打开两个串口，会看到不同的信息。 打开小号串口可以看到一直在打印信息： ![start_smaller_uart](./assets/start/start_smaller_uart.jpg) 打开大号串口可以进行简单的命令行交互： ![start_bigger_uart](./assets/start/start_bigger_uart.jpg) ## 烧录方法 想要让板子运行自己预期的程序，就要先知道怎么样烧录固件到板卡。 ### U 盘烧录 为了便捷烧录，我们准备了 U 盘烧录的方法来给快速地烧录 M1s Dock 上 bl808 的 C906 核心所运行的程序。 先使用 TypeC 数据线将电脑与板子的 OTG 口连接起来，再同时按住板子上面两侧的按键（已经在下面图片中指明），然后按一下板子上的 RST 键就可以进入 U 盘烧录模式。 <table> <tr> <td><img src \"./assets/start/udisk_burn.png\" alt \"udisk_burn\" style \"transform:rotate(0deg);\"></td> <td>同时按住两侧的按键然后按一下 RST 键来复位板子，并让它进入 U 盘烧录模式</td> </tr> </table> 另外，按住两侧按键的时候，从板子的 OTG 口板子给板子通电来启动板子也可以进入 U 盘下载模式。 <img src \"./assets/start/udisk_in_computer.png\" alt \"udisk_in_computer\" style \"transform:rotate(0deg);\"> 板子成功进入 U 盘烧录模式后在电脑上会显示出一个容量很小的磁盘，直接把固件 <a href \"https://dl.sipeed.com/shareURL/MAIX/M1s/M1s_Dock/7_Firmware/demo_bin\">点我跳转部分例程固件</a> 拖拽进去即可完成烧录。 <img src \"./assets/start/udisk_burn.gif\" alt \"udisk_burn\" style \"transform:rotate(0deg);\"> 文件存放进去后数秒后板子会重启，U 盘被弹出，表示烧录完成。 但是因为 bl702 固件的差异，可能需要按下 RST 按键才能成功加载固件。[点我查看 bl702 固件差异](https://wiki.sipeed.com/hardware/zh/maix/m1s/other/start.html#bl702 %E5%9B%BA%E4%BB%B6%E5%B7%AE%E5%BC%82) 。 ### 串口烧录 上面的 U 盘烧录方法适用于给 C906 核心烧录固件。当板子出现固件异常或者需要将板子的固件全部升级时，我们需要通过串口烧录这种方法来重新烧录 M1s Dock, 这可以解决所有问题。 使用 TypeC 数据线将电脑与板子的 UART 口连接起来，此时电脑上会出现两个串口 (如果出现鼠标不能动的现象请拔掉 USB 并且查看 [更新板载 bl702 固件](https://wiki.sipeed.com/hardware/zh/maix/m1s/other/start.html#%E7%BB%99%E6%9D%BF%E8%BD%BD bl702 %E8%BF%9B%E8%A1%8C%E7%83%A7%E5%BD%95) 相关内容来修复问题)。 #### 软件获取 给 M1s 烧录需要用到博流官方烧录工具，前往 https://dev.bouffalolab.com/download 下载名称为 `Bouffalo Lab Dev Cube` 的文件。解压后就得到了用来烧录板子的应用程序。 ![bouffalo_cube](./assets/start/bouffalo_cube.png) 备份链接：[Sipeed 下载站](https://dl.sipeed.com/shareURL/others/BouffaloLabDevCube) 解压后的文件夹中有 `BLDevCube`、 `BLDevCube macos` 和 `BLDevCube ubuntu` 三个文件，用于在不同系统启动这个图形化烧录工具。 ![application](./assets/start/application.png) 还有 `bflb_iot_tool`、`bflb_iot_tool macos`、`bflb_iot_tool ubuntu` 这三个程序，用于在不同系统通过命令行进行烧录。 #### 图形化界面烧录 根据自己的系统启动软件 `BLDevCube` 后选择 bl808 ，紧接着软件的 IOT 页面选择分区表文件[点我下载](https://dl.sipeed.com/fileList/MAIX/M1s/M1s_Dock/7_Firmware/partition/partition_cfg_16M_m1sdock.toml)（图里 ②）。 <table> <tr> <td><img src \"./assets/start/chip_selection.png\" alt \"chip_selection\" style \"transform:rotate(0deg);\"></td> <td><img src \"./assets/start/choose_partition.png\" alt \"choose_partition\" style \"transform:rotate(0deg);\" width \"70%\"></td> </tr> </table> 选择完上面的分区表文件后，烧录工具的可选项就变多了，主要关注 `boot2`, `firmware`, `d0fw` 三项。 <img src \"./assets/start/firmware_choose.png\" alt \"firmware_choose\" style \"transform:rotate(0deg);\"> 上图中，`boot2` 是固定的，位于 `BLDevCube\\chips\\bl808\\builtin_imgs\\boot2_isp_bl808_xxxx_xxx` 目录下，就是在解压的烧录程序文件夹的子目录里面，要选择名称带有 `debug` 的文件；`firmware` 是 E907 核心运行的固件 ；`d0fw`是 C906 核心运行的固件，前面的 U 盘烧录里面的固件就是给这个核心烧录的。E907 的固件文件和 C906 的固件文件均可以通过 [M1s_dock example](https://gitee.com/sipeed/M1s_BL808_example) 来编译得到。 首次烧录 `firmware` 和 `boot2` 都需要烧录进去，之后就可以按需烧录而不用全部勾选。 旧默认固件可以在 [这里下载到](https://dl.sipeed.com/shareURL/MAIX/M1s/M1s_Dock/7_Firmware/factory)，新默认固件不再提供。对应的旧默认固件测试方法查看 [旧固件测试](https://wiki.sipeed.com/hardware/zh/maix/m1s/other/start.html#%E6%97%A7%E5%9B%BA%E4%BB%B6%E5%BC%80%E7%AE%B1%E6%B5%8B%E8%AF%95) 正确的选择固件后，在窗口右侧点击一下 `Refresh` 来刷新串口，正常情况有两个串口号相邻的串口可供选择，如果没有两个串口请参考下面的 [烧录 BL702](https://wiki.sipeed.com/hardware/zh/maix/m1s/other/start.html#%E7%BB%99%E6%9D%BF%E8%BD%BD bl702 %E8%BF%9B%E8%A1%8C%E7%83%A7%E5%BD%95)来查看解决方法。在本烧录应用中，对 M1s Dock 操作均需要通过串口号较大的串口，而不是小号串口。 ![burn_steps](./assets/start/burn_steps.png) 按住板子上的 BOOT 键和 RST 键， 然后先松开 RST 键再松开 BOOT 键来使板子进入串口烧录模式。 <img src \"./assets/start/boot_rst.jpg\" alt \"boot_rst\" style \"transform:rotate(0deg);\" width \"40%\"> 点击下载 (Create & Download) 后会看到下图箭头中多指向的信息，在这之前我们需要操作硬件使它进入串口烧录模式。 ![burn_press_boot](./assets/start/burn_press_boot.jpg) 成功进入烧录模式会握手成功并且接下来会进行烧录。 <img src \"./assets/start/burn_press_boot_success.jpg\" alt \"burn_press_boot_success\" style \"transform:rotate(0deg);\" width \"70%\"> <img src \"./assets/start/finish_burning.png\" alt \"finish_burning\" style \"transform:rotate(0deg);\" width \"70%\"> 握手失败的话就重新点击烧录并且再次尝试。这种错误可能是按键释放顺序错误（应该先松开 RST 键再松开 BOOT 键，即在松开 RST 键的时候 boot 键应该是按下的状态）而导致板子没有进入串口烧录模式，软件等待超时而导致的。 <img src \"./assets/start/burn_press_boot_failed.jpg\" alt \"burn_press_boot_failed\" style \"transform:rotate(0deg);\" width \"70%\"> #### 命令行烧录 我们可以使用命令行来通过板子上的串口来对 M1s Dock 进行烧录。 在 `BLDevCube` 的文件夹下面，还有 `bflb_iot_tool`、`bflb_iot_tool macos`、`bflb_iot_tool ubuntu` 这三个程序，用于在不同系统通过命令行进行烧录。 下面是在 `Windows` 系统中通过命令行烧录的命令。其中 `firmware` 是 E907 核心的固件，可以在[旧默认固件](https://dl.sipeed.com/shareURL/MAIX/M1s/M1s_Dock/7_Firmware/factory)处下载得到；`pt` 文件是分区表文件，默认在 `M1s_BL808_example\\partition` 目录下，当然也可以 [点我](https://dl.sipeed.com/fileList/MAIX/M1s/M1s_Dock/7_Firmware/partition/partition_cfg_16M_m1sdock.toml) 直接下载到；`boot2` 文件默认位于 `BLDevCube\\chips\\bl808\\builtin_imgs\\boot2_isp_bl808` 目录下，是名称带有 `debug` 的文件；波特率为 2M，这样烧录的时候会快点；`port` 应指定为串口号较大的串口。 ```bash .\\bflb_iot_tool.exe chipname bl808 port COM38 baudrate 2000000 firmware \"firmware_20221212.bin\" pt \"M1s_BL808_example\\partition\\partition_cfg_16M_m1sdock.toml\" boot2 \"BLDevCube\\chips\\bl808\\builtin_imgs\\boot2_isp_bl808\\boot2_isp_debug.bin\" ``` 当然，在烧录前需要让 M1s Dock 进入下载模式：按住板子上的 BOOT 键和 RST 键， 然后先松开 RST 键再松开 BOOT 键。 ![command_burn_flash](./assets/start/command_burn_flash.jpg) 烧录完之后，可以参考前面的 [U 盘烧录](https://wiki.sipeed.com/hardware/zh/maix/m1s/other/start.html#U %E7%9B%98%E7%83%A7%E5%BD%95) 来给 C906 核心烧录固件。也可以自己根据烧录地址来烧录固件，烧录地址可以在 `partition_cfg_16M_m1sdock.toml` 文件查看到，也可以自己更改，此处不述。 ### 烧录时候的常见问题 #### BFLB IMG LOAD SHAKEHAND FAIL 这种情况是板子的 bl808 没有进入下载模式，确定自己在板子在运行时（已经通电）自己同时按下 RST 按键和 BOOT 按键，然后先松开 RST 键后松开 BOOT 键来时 bl808 进入下载模式。 ![uart_burn_bl808_shakehand_fail](./assets/start/uart_burn_bl808_shakehand_fail.jpg) 并且确定自己在下载的时候选择的是串口号大的那一个串口，而不是小号串口。 ![uart_burn_bl808_shakehand_fail_com_port](./assets/start/uart_burn_bl808_shakehand_fail_com_port.jpg) #### 只看到一个串口 这种情况是进入了板载 bl702 下载模式。需要注意的是不应该按住 BOOT 键然后给板子通电，这样会进入 bl702 的下载模式，只有一个串口显示在电脑中。给 bl808 通过串口烧录是在板子通电后，同时按下 RST 按键和 BOOT 按键，然后先松开 RST 键后松开 BOOT 键来时 bl808 进入下载模式。 ![uart_burn_bl808_only_one_port](./assets/start/uart_burn_bl808_only_one_port.jpg) #### 没有串口设备 确定自己连接的是板子上的 UART 接口，换一根数据线或者连接电脑另一个 USB 口。 #### 烧录单个固件 在烧录工具软件中，首次烧录要求将 `partition table`, `boot2`, `firmware`, `d0fw` 文件都勾选上并烧录进板子，以后如果想要烧录由 SDK 编译出来的单个固件，在对应的烧录选项中选择编译出来的文件就行： `firmware` 选择由 e907_demo 编译出来的最终固件。 `d0fw` 选择由 c906_demo 编译出来的最终固件。 `partition table` 和 `boot2` 每次烧录都要勾选中。 <table> <tr> <td>烧录 c906_demo 固件</td> <td>烧录 e907_demo 固件</td> </tr> <tr> <td><img src \"./assets/start/uart_burn_c906.jpg\" alt \"uart_burn_c906\"></td> <td><img src \"./assets/start/uart_burn_e907.jpg\" alt \"uart_burn_e907\"></td> </tr> </table> ## 烧录例程 下面的几个 Demo 都是从 M1s_bl808_example 里面编译出来的，适用于 bl808 里面的 C906 核心。 建议使用 U 盘烧录的方法烧录进板卡，直接体验一下这款板卡。 ### lvgl_demo [LVGL](https://lvgl.io/) (轻巧而多功能的图形库)是一个免费的开放源代码图形库，适合用于 mcu 构建图形界面。 Demo 文件：[点我](https://dl.sipeed.com/shareURL/MAIX/M1s/M1s_Dock/7_Firmware/demo_bin/lvgl_demo) 通过 U 盘烧录的方法烧录进 M1s Dock 后，屏幕显示着 lvgl 测试效果，设置波特率为 2000000，串口号较小的串口打印着最后一次触摸屏幕位置。 <img src \"./assets/start/example_lvgl.gif\" alt \"example_lvgl\" width \"45%\"> <img src \"./assets/start/example_lvgl.jpg\" alt \"example_lvgl\" width \"45%\"> ### image_processing_demo 一个简单的图像处理例子。 Demo 文件：[点我](https://dl.sipeed.com/shareURL/MAIX/M1s/M1s_Dock/7_Firmware/demo_bin/image_processing_demo) 通过 U 盘烧录的方法烧录进 M1s Dock 后，屏幕上显示摄像头画面，按下两侧的按键可以切换不同的图像算子。设置波特率为 2000000，串口号较小的串口显示着上次按键和其他信息。 按下复位键后串口号较小的串口会显示摄像头相关的配置信息，摄像头异常的话可以从串口信息看到。 <img src \"./assets/start/example_image_processing_demo.jpg\" alt \"example_image_processing_demo\" width \"45%\"> <img src \"./assets/start/example_image_processing_demo_uart.jpg\" alt \"example_image_processing_demo_uart\" width \"45%\"> ### tinymaix_mnist_demo [TinyMaix](https://github.com/sipeed/TinyMaix) 是面向单片机的超轻量级的神经网络推理库，即 TinyML 推理库，可以在任意单片机上运行轻量级深度学习模型。 Demo 文件：[点我](https://dl.sipeed.com/shareURL/MAIX/M1s/M1s_Dock/7_Firmware/demo_bin/tinymaix_mnist_demo) 通过 U 盘烧录的方法烧录进 M1s Dock 后，屏幕中间的红框识别数字。设置波特率为 2000000，串口号较小的串口打印着识别信息。 <img src \"./assets/start/example_tinymaix_mnist_demo.jpg\" alt \"example_tinymaix_mnist_demo\" width \"45%\"> <img src \"./assets/start/example_tinymaix_mnist_demo_uart.jpg\" alt \"example_tinymaix_mnist_demo_uart\" width \"45%\"> ### pikascript_demo [PikaScript](http://pikascript.com/) 是一个跨平台的超轻量级嵌入式 Python 引擎。 Demo 文件：[点我](https://dl.sipeed.com/shareURL/MAIX/M1s/M1s_Dock/7_Firmware/demo_bin/pikascript_demo) 通过 U 盘烧录的方法烧录进 M1s Dock 后，屏幕白屏，无内容。设置波特率为 2000000，打开串口号较小的串口来进行命令行交互。 在命令行中输入这些指令： ```bash arc lv.arc(lv.scr_act()) arc.set_end_angle(200) arc.set_size(150, 150) arc.center() ``` ![example_pikascript_demo_uart](./assets/start/example_pikascript_demo_uart.jpg) 然后可以看到屏幕上显示出来一些画面（忽略这糟糕的拍照）： ![example_pikascript_demo_screen](./assets/start/example_pikascript_demo_screen.jpg) ## SDK 编译 M1s 需要在 Linux 环境下进行编译 ### 安装编译所需要的相关软件 获取 SDK 需要用到 `git` 这个软件，编译 SDK 需要用到 `make` 这个软件，对应着后面文档检查自己的目录结构配置的时候需要用到 `tree` 这个软件。 下面是在 debian 系 Linux 发行版（比如 Ubuntu）中安装上述三个软件的示例命令。 ```bash sudo apt get install git make tree build essential ``` 其它 Linux 发行版本安装上述所需的三个软件所使用的命令自行网上查找解决。 ### 获取例程仓库 ```bash git clone https://gitee.com/Sipeed/M1s_BL808_example.git ``` 最终结构树如下 `tree L 1 M1s_BL808_example/` ![sdk_compile_tree_1](./assets/start/sdk_compile_tree_1.jpg) <! ```bash sipeed@DESKTOP:~$ tree L 1 M1s_BL808_example/ M1s_BL808_example/ ├── LICENSE # 许可证文件 ├── assets # 资源文件 ├── c906_app # C906 核心例程 ├── e907_app # E907 核心例程 ├── partition # 分区表文件 └── readme.md # 仓库说明 ``` > ### 获得 SDK 仓库 仓库很大，120M 以上。 ```bash git clone https://gitee.com/sipeed/M1s_BL808_SDK.git ``` 最终结构树如下 `tree L 1` ![sdk_compile_tree_2](./assets/start/sdk_compile_tree_2.jpg) <! ```bash sipeed@DESKTOP:~$ tree L 1 . ├── M1s_BL808_example # 例程文件夹 └── M1s_BL808_SDK # SDK 文件夹 ``` > ### 在 SDK 仓库文件夹下，获取编译工具链 根据例程仓库里面的 readme 的要求，工具链应存放在 M1s_BL808_SDK/toolchain 目录下 ```bash mkdir p M1s_BL808_SDK/toolchain cd M1s_BL808_SDK/toolchain git clone https://gitee.com/wonderfullook/m1s_toolchain.git ``` 修改工具链的名称为 `Linux_x86_64` ，然后返回到上两级目录 ```bash mv m1s_toolchain Linux_x86_64 cd ../../ ``` 这时得到的结构树应如下(截取部分)：`tree L 2` ![sdk_compile_tree_3](./assets/start/sdk_compile_tree_3.jpg) <! ```bash sipeed@DESKTOP:~$ tree L 2 . ├── M1s_BL808_example # 例程仓库文件夹 │ ├── LICENSE # 许可证文件 │ ├── assets # 资源文件 │ ├── c906_app # C906 核心例程 │ ├── e907_app # E907 核心例程 │ ├── partition # 分区表文件 │ └── readme.md # 仓库说明 └── M1s_BL808_SDK # SDK 仓库文件夹 ├── toolchain # 编译工具链 ... ``` > ### 配置编译工具链路径 首先确定 `M1s_BL808_SDK` 文件夹所在的路径： ```bash cd M1s_BL808_SDK pwd ``` ![sdk_compile_snapshot_1](./assets/start/sdk_compile_snapshot_1.jpg) <! ```bash sipeed@DESKTOP:~$ cd M1s_BL808_SDK sipeed@DESKTOP:~/M1s_BL808_SDK$ pwd /home/lee/bl808/M1s_BL808_SDK ``` > 我们复制上面执行 `pwd` 后的结果（每个人的会不一样），比如上面截图中的 pwd 命令的执行结果为 `/home/lee/bl808/M1s_BL808_SDK`，因此在配置 `BL_SDK_PATH` 路径时后面应该跟着 `/home/lee/bl808/M1s_BL808_SDK`。 > 以后每次开始编译都需要执行一次这个来配置下编译工具链路径（注意自行修改 BL_SDK_PATH 的值，并且 符号后面没有空格） ```bash export BL_SDK_PATH ``` ![sdk_compile_snapshot_2](./assets/start/sdk_compile_snapshot_2.jpg) 然后执行下面的命令就可以准备开始交叉编译了。 <! ```bash export BL_SDK_PATH /home/lee/bl808/M1s_BL808_SDK ``` > 注意是 `M1s_BL808_SDK` ，不是 `M1s_BL808_SDK/`，一般自动补全会导致这个错误。 ### 编译 demo 执行 M1s_BL808_example/c906_app 目录下的 build.sh ，后面追加上想要编译的 demo 就可以完成了。 Demo 如下（编辑于 2022 12 13）： ![sdk_compile_tree_4](./assets/start/sdk_compile_tree_4.jpg) <! ```txt c906_app ├── audio_recording ├── blai_mnist_demo ├── camera_bypass_lcd ├── camera_dump ├── camera_streaming_through_wifi ├── cli_demo ├── flash_demo ├── gpio_demo ├── hello_world ├── i2c_touch ├── image_processing_demo ├── lfs_demo ├── lvgl_demo ├── pikascript_demo ├── proj_config.mk ├── pwm_demo ├── spi_lcd ├── tinymaix_mnist_demo └── uvc_demo ``` > 下面是编译 lvgl_demo 的示例命令，其他 demo 的编译自己更改 ./build.sh 后面的名称。 ```bash cd M1s_BL808_example/c906_app ./build.sh lvgl_demo ``` 然后编译出来的固件就会在 M1s_BL808_example/c906_app/build_out 目录下，名称为 `d0fw.bin`，通过虚拟 U 盘拖拽烧录即可。 ![udisk_burn](./assets/start/udisk_burn.gif) 虚拟 U 盘找不到的话也可以通过博流官方烧录工具来使用串口下载，注意在 d0fw 框中应当勾选自己所编译出来的 `d0fw.bin` （下图仅做示例） ![uart_burn_c906](./assets/start/uart_burn_c906.jpg) ### 编译 firmware 执行 M1s_BL808_example/e907_app 目录下的 build.sh ，后面追加上 firmware 就可以编译了 ```bash cd M1s_BL808_example/e907_app ./build.sh firmware ``` 然后编译出来的固件就会在 M1s_BL808_example/e907_app/build_out 目录下，名称为 `firmware.bin`。 通过博流官方烧录工具来使用串口下载，注意在 firmware 框中应当勾选自己所编译出来的`firmware.bin` （下图仅做示例） ![uart_burn_e907](./assets/start/uart_burn_e907.jpg) ### 常见问题 1. 执行完 build.sh 后提示 `Makefile:14: *** BL_SDK_PATH not found, please enter: export BL_SDK_PATH {sdk_path}. Stop.`，查看 [配置编译工具链路径](https://wiki.sipeed.com/hardware/zh/maix/m1s/other/start.html#%E9%85%8D%E7%BD%AE%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE%E8%B7%AF%E5%BE%84) 来配置自己的 BL_SDK_PATH。 2. 编译出错 注意编译的时候使用的命令为 `./build.sh demo_name`，比如 `./build.sh hello_world`，而不是 `./build.sh hello_world/` （注意最后面的路径符号`/`） ## WIFI 串流摄像头 DEMO 一个简单的无线串流 Demo ### 软件环境 网络环境： PC 与板卡需要在同一网络环境中；M1s Dock 支持 2.4G 无线网络 PC 软件环境：`python3`， `OpenCV` 板卡固件要求：要求 [Firmware](https://dl.sipeed.com/shareURL/MAIX/M1s/M1s_Dock/7_Firmware/factory) 固件为 `firmware_20230227.bin`，通过烧录方法中的 [串口烧录](https://wiki.sipeed.com/hardware/zh/maix/m1s/other/start.html#%E4%B8%B2%E5%8F%A3%E7%83%A7%E5%BD%95) 说明的内容烧录 [Firmware](https://dl.sipeed.com/shareURL/MAIX/M1s/M1s_Dock/7_Firmware/factory) 固件 ![camera_stream_e907](./assets/start/camera_stream_e907.png) ### 代码修改 打开例程路径 `M1s_BL808_example/c906_app/camera_streaming_through_wifi` 中的 `main.c` 文件。 ![camera_stream_original_source_code](./assets/start/camera_stream_original_source_code.png) 注意到里面的 `m1s_xram_wifi_connect()` 和 `m1s_xram_wifi_upload_stream()` 函数。 手动将 `liuxo_desktop` 要连接到的 PC 已经连接上的网络，并且将 `12345678` 更改为目标网络的连接密码。 将 `10.42.0.1` 替换成 PC 所在目标网络中的 IP 地址。 比如在下面的示例中，PC 所在的名为 `Test` 网络中的 IP 为 `192.168.43.183`，并且名为 `Test` 的无线网络密码是 `testtest`。 ![camera_stream_source_code](./assets/start/camera_stream_source_code.png) 编辑完 `main.c` 文件后记得保存一下。 ### 固件编译和烧录 修改代码且保存后，根据上面的 [SDK 编译说明](https://wiki.sipeed.com/hardware/zh/maix/m1s/other/start.html#SDK %E7%BC%96%E8%AF%91) 来编译 `camera_streaming_through_wifi` 这个例程。 将编译得到的 `d0fw.bin` 固件通过 U 盘烧录的方式来快速的烧入到 M1s Dock 里面，打开大号串口，按下板子上面的复位键。 在板子成功连接到网络后它会在大号串口打印出自己的 IP 信息，并且 `Socket connect` 表示正在等待 PC 端应答。 ![camera_stream_socket_wait](./assets/start/camera_stream_socket_wait.png) ### PC 显示流 在 `M1s_BL808_example/c906_app/camera_streaming_through_wifi` 路径下，直接执行命令 `python3 main.py` 来使用 python 接收 M1s dock 的流并且调用 opencv 来显示画面。 ![camera_stream_success](./assets/start/camera_stream_success.png) ### 注意事项 1. 确认自己对 M1s Dock 烧录了修复 bug 后的 [firmware_20230227.bin](https://dl.sipeed.com/shareURL/MAIX/M1s/M1s_Dock/7_Firmware/factory) 固件 2. 确定板子连接到了目标网络；成功连接到网络后板子的大号串口会显示出板卡的 IP 地址 3. 确定板子与 PC 在同一网络，且正确地修改了 `main.c` 中 PC 的 IPV4 地址 ## Linux Demo 这是一个能在 M1s Dock 上能运行起来的简易 Linux Demo。 [点我](https://dl.sipeed.com/fileList/MAIX/M1s/M1s_Dock/7_Firmware/m1sdock_linux_20221116.zip) 下载 Linux 例子，按照压缩包里面 `steps.md` 操作步骤完成 Linux 系统烧录。 ![linux_opensbi](./assets/start/linux_opensbi.jpg) 使用 `root` 登录 ![linux_login](./assets/start/linux_login.jpg) 查看 CPU 信息 ![linux_cpuinfo](./assets/start/linux_cpuinfo.jpg) 相关的 Linux SDK 前往 [github](https://github.com/sipeed/M1s_BL808_Linux_SDK) 查看。 ## 使用 Jtag 可以在[淘宝店铺](https://sipeed.taobao.com/)购买到 Jtag 调试器来调试 M1s Dock. ![cklink_appearence](./assets/start/cklink_appearence.jpg) ### 连接设备 将 Jtag 插入到板子的 TF 卡槽中来连接设备。自弹式 TF 卡槽可以自动固定连接，尽量减少硬插拔避免 TF 卡槽损坏。 连接后的样式如下图所示。 ![cklink_connect_side](./assets/start/cklink_connect_side.jpg) ![cklink_connect_top](./assets/start/cklink_connect_top.jpg) 调试器和 M1s Dock 的 UART 口都需要与电脑连接上（如上图，板子上的 UART 口和调试器都连接了电脑）；仅调试器连接电脑会因为需要给 M1s Dock 供电而导致调试器很烫，并且我们需要通过串口在 M1s Dock 上开启 Jtag 功能才能调试。 ### 安装驱动 前往 [下载站](https://dl.sipeed.com/shareURL/MAIX/M1s/M1s_Dock/9_Driver/cklink) 下载适合自己电脑的驱动。 #### Windows 解压 `T Head DebugServer windows` 压缩包后，运行解压后的 `Setup` 程序来安装驱动。 ![cklink_windows_install_driver](./assets/start/cklink_windows_install_driver.jpg) 在确定安装目录界面，建议不要更改默认的安装位置。避免因错误安装到根目录后，卸载该程序导致全盘清空的悲剧。 ![cklink_windows_driver_path](./assets/start/cklink_windows_driver_path.jpg) 全部都安装，避免以后还需要别的组件。 ![cklink_windows_driver_components](./assets/start/cklink_windows_driver_components.jpg) 安装结束后，连接上了调试器的话可以在设备管理器中看到有 `CKlink Lite`。 ![cklink_windows_driver_device_manager](./assets/start/cklink_windows_driver_device_manager.jpg) 桌面上有一个调试软件的图标。 ![cklink_windows_driver_desktop_icon](./assets/start/cklink_windows_driver_desktop_icon.jpg) #### Linux 获得驱动：[点我](https://dl.sipeed.com/shareURL/MAIX/M1s/M1s_Dock/9_Driver/cklink) ![cklink_linux_list_file](./assets/start/cklink_linux_list_file.jpg) 解压所下载的压缩文件。 ```bash tar xvf T Head DebugServer* ``` 然后当前目录下会多出一个脚本文件。 ![cklink_linux_list_shell_file](./assets/start/cklink_linux_list_shell_file.jpg) 执行一下脚本，会显示说明，可以知道在脚本后面加上 ` i` 会安装软件，加上 ` u` 会卸载软件。 ``` ./T Head DebugServer linux x86_64 V5.16.5 20221021.sh ``` ![cklink_linux_script_help](./assets/start/cklink_linux_script_help.jpg) 开始安装驱动： ``` sudo ./T Head DebugServer linux x86_64 V5.16.5 20221021.sh i ``` ![cklink_linux_installation](./assets/start/cklink_linux_installation.jpg) 上图中有两处是我们手动输入的 `yes` ，在 `Set full installing path` 处直接回车确认的话它会被安装到默认路径下，有需要的话自己指定一下安装路径。 安装完后使用 `lsusb` 可以查看到 `CKlink Lite` 设备。 ![cklink_linux_lsusb](./assets/start/cklink_linux_lsusb.jpg) ### 调试设备 在调试设备前，我们需要先通过 M1s Dock 上面的大号串口来操作板子，开启板子的调试功能。 ![cklink_jtag_serial_choice](./assets/start/cklink_jtag_serial_choice.jpg) ![cklink_jtag_choice](./assets/start/cklink_jtag_choice.jpg) 从上面可以看到有两个 jtag 选项，执行 `jtag_cpu0` 就会对 C906 核心进行调试，执行 `jtag_m0` 就是对 E907 核心进行调试。 ![cklink_jtag_c906](./assets/start/cklink_jtag_c906.jpg) ![cklink_jtag_e907](./assets/start/cklink_jtag_e907.jpg) #### Windows 运行前面安装驱动后在桌面上的 T HeadDebugServer 程序，出现下面的提示的话说明没有连接上设备，可以自己检查： 确定已经在串口里面使能了核心的 jtag 调试 设备管理器里面的 `CKlink Lite` 设备，没有的话检查核心板与电脑的连接情况或者重新安装驱动 调试器已经被其他 T HeadDebugServer 程序打开 ![cklink_jtag_windows_no_target](./assets/start/cklink_jtag_windows_no_target.jpg) 点击下图箭头指向的 三角标志 可以连接设备： ![cklink_jtag_windows_run_debugger](./assets/start/cklink_jtag_windows_run_debugger.jpg) 出现下图所示的 Failed 的话说明连接失败，端口不可用，可以自己设置端口来连接设备。 ![cklink_jtag_windows_no_port](./assets/start/cklink_jtag_windows_no_port.jpg) 选择 Socket Setting，设置合适的端口。 ![cklink_jtag_windows_set_socket](./assets/start/cklink_jtag_windows_set_socket.jpg) ![cklink_jtag_windows_set_socket_1](./assets/start/cklink_jtag_windows_set_socket_1.jpg) 成功连接上的话箭头所指的地方会从 三角形 变成 圆形。 ![cklink_jtag_windows_success_connection](./assets/start/cklink_jtag_windows_success_connection.jpg) 到这里已经完成连接了，上面的图里是使用 `jtag_m0` 命令来调试 E907 核心，需要的话可以使用 `jtag_cpu0` 命令更改成调试 C906 核心。 接下来就可以用 gdb 等工具来调试了。 ![cklink_jtag_windows_gdb_debug](./assets/start/cklink_jtag_windows_gdb_debug.jpg) 此外，在调试工具的安装目录下，有命令行程序 `DebugServerConsole`。 ![cklink_jtag_windows_debugserverconsole](./assets/start/cklink_jtag_windows_debugserverconsole.jpg) 使用命令行执行可以看到用法并且操作它。 ```bash .\\DebugServerConsole.exe h ``` ![cklink_jtag_windows_debugserverconsole_help](./assets/start/cklink_jtag_windows_debugserverconsole_help.jpg) ```bash .\\DebugServerConsole.exe port 65535 ``` ![cklink_jtag_windows_debugserverconsole_port](./assets/start/cklink_jtag_windows_debugserverconsole_port.jpg) 就可以通过 65535 端口来调试了。 #### Linux 使用 `DebugServerConsole h` 可以查看使用帮助。 ![cklink_jtag_linux_debugserverconsole_help](./assets/start/cklink_jtag_linux_debugserverconsole_help.jpg) 在命令行运行命令后，可以通过 12345 端口来调试了。 ```bash DebugServerConsole port 12345 ``` ![cklink_jtag_linux_debugserverconsole](./assets/start/cklink_jtag_linux_debugserverconsole.jpg) ## blai npu ### 支持算子 <table> <thead> <tr> <th>Type</th> <th>Operators</th> <th>Applicable Subset Spec.</th> <th>Processor</th> </tr> </thead> <tbody> <tr> <td rowspan \"10\">Convolution</td> <td rowspan \"4\">Conv </td> <td>Kernel: 1x1,3x3,5x5,7x7</td> <td rowspan \"4\">:strong:<code>NPU</code></td> </tr> <tr> <td>Stride: 1x1, 2x2</td> </tr> <tr> <td>Dilation: 1x1, 2x2</td> </tr> <tr> <td>Pad: same</td> </tr> <tr> <td rowspan \"4\">Depthwise Conv</td> <td>Kernel: 1x1,3x3 (5x5, 7x7 TBD)</td> <td rowspan \"4\">:strong:<code>NPU</code></td> </tr> <tr> <td>Stride: 1x1, 2x2</td> </tr> <tr> <td>Dilation: 1x1 (2x2 TBD)</td> </tr> <tr> <td>Pad: same</td> </tr> <tr> <td rowspan \"2\">Transpose Conv</td> <td>Kernel: 3x3</td> <td rowspan \"2\">strong:<code>NPU</code></td> </tr> <tr> <td>Stride: 2x2</td> </tr> <tr> <td rowspan \"4\">Pooling</td> <td rowspan \"2\">MaxPool (NPU TBD)</td> <td>Kerenl: 2x2</td> <td rowspan \"2\">DSP</td> </tr> <tr> <td>Stride: 2x2</td> </tr> <tr> <td rowspan \"2\">MaxPool</td> <td>Kerenl: 3x3</td> <td rowspan \"2\">:strong:<code>NPU</code></td> </tr> <tr> <td>Stride: 1x1, 2x2</td> </tr> <tr> <td rowspan \"2\">Activation</td> <td>Relu</td> <td></td> <td>:strong:<code>NPU</code></td> </tr> <tr> <td>Relu 6</td> <td></td> <td>:strong:<code>NPU</code></td> </tr> <tr> <td rowspan \"5\">Other processing</td> <td>BatchNormalization</td> <td>fused with conv</td> <td>:strong:<code>NPU</code></td> </tr> <tr> <td>Add (shortcut)</td> <td></td> <td>:strong:<code>NPU</code></td> </tr> <tr> <td>Concat (route)</td> <td>Channel wise (AXIS 3 in BHWC)</td> <td>:strong:<code>NPU</code></td> </tr> <tr> <td>Fully Connected</td> <td></td> <td>:strong:<code>NPU</code></td> </tr> <tr> <td>Upsample</td> <td>Nearest</td> <td>:strong:<code>NPU</code></td> </tr> </tbody> </table> ### blai_mnist_demo 编译之后使用 U 盘拖拽烧录的方法将编译出来的[固件](https://dl.sipeed.com/shareURL/MAIX/M1s/M1s_Dock/7_Firmware/demo_bin/blai_mnist_demo)烧录进板子。前面说过编译出来的固件名称都是 `d0fw.bin`，且位于 `M1s_BL808_example/c906_app/built_out` 文件夹下。 ``` #c906_app ./build.sh blai_mnist_demo ``` ![udisk_burn](./assets/start/udisk_burn.gif) 烧录进去后（U 盘自动弹出就表示烧录完成）按下 RST 按键复位芯片来重新加载固件，此时查看通过串口号较小的串口（记住波特率为 2000000）查看会发现提示加载模型失败。 ![blai_mnist_demo_no_model](./assets/start/blai_mnist_demo_no_model.jpg) 因此我们要将模型上传到模型，从源码中可以看到对于这个 demo 我们要将模型存放到 flash 中。 ![blai_mnist_demo_fopen](./assets/start/blai_mnist_demo_fopen.jpg) 然后将板子的 OTG 口与电脑连接的话会看到一个大小为 7M 的 U 盘。 ![blai_mnist_demo_flash_disk](./assets/start/blai_mnist_demo_flash_disk.jpg) 按照源码的要求把文件存进去：在 U 盘里新建一个 models 文件夹，然后将 [mnist.blai](https://dl.sipeed.com/shareURL/MAIX/M1s/M1s_Dock/7_Firmware/demo_bin/blai_mnist_demo) 模型文件存放进去。 ```bash models └── mnist.blai ``` ![blai_mnist_demo_model_path](./assets/start/blai_mnist_demo_model_path.jpg) 按下板子上的复位键(RST)，复位板卡程序来使板卡重新加载模型。 小号串口显示模型加载成功，并且显示板子识别数字结果。板子屏幕显示摄像头捕获到的画面，且也显示识别结果。 ![blai_mnist_demo_uart](./assets/start/blai_mnist_demo_uart.jpg) ![blai_mnist_demo_recognition](./assets/start/blai_mnist_demo_recognition.jpg) ### tom_and_jerry_classification_demo 这是一个在 [MaixHub](https://maixhub.com/model/zoo/127) 上可下载的模型文件，我们可以在这个网站直接上传数据集、标注和生成模型文件再部署到板卡上，这里叙述一下怎么样将在 [MaixHub](https://maixhub.com/) 所下载的模型部署到 M1s Dock 上。 首先根据前面搭建 SDK 环境所描述的内容，编译出 [tom_and_jerry_classification_demo](https://dl.sipeed.com/fileList/MAIX/M1s/M1s_Dock/7_Firmware/demo_bin/tom_and_jerry_classification_demo.bin) 这个例程固件。 ```bash #c906_app ./build.sh tom_and_jerry_classification_demo ``` 然后通过 U 盘拖拽烧录的方法将编译出来的固件烧录进板子。 ![udisk_burn](./assets/start/udisk_burn.gif) 在 tom_and_jerry_classification_demo 里面的 `main.c` 源码中可以所加载的模型在 Flash 里面的 models 文件夹里面，且模型名称为 `tj.blai`。 ![tom_jerry_source_code](./assets/start/tom_jerry_source_code.jpg) 所以我们在 [MaixHub](https://maixhub.com/model/zoo/127) 下载到这个例程模型后，解压并将里面拓展名为 `.blai` 的文件重命名为 `tj.blai`。 ![tom_jerry_model_rename](./assets/start/tom_jerry_model_rename.gif) 然后将板子的 OTG 口与电脑连接的话会看到一个大小为 7M 的 U 盘。 ![blai_mnist_demo_flash_disk](./assets/start/blai_mnist_demo_flash_disk.jpg) 按照源码要求把上面重命名后所得到的 `tj.blai` 文件存放到 U 盘的 models 文件夹下：在 U 盘里新建一个 models 文件夹，然后将 `tj.blai` 这个模型文件存放进所创建的 models 文件夹中 。 ![tom_jerry_model_path](./assets/start/tom_jerry_model_path.jpg) 然后就可以使用 M1S Dock 来分辨 Tom 和 Jerry 了。 <img src \"./assets/start/tom_jerry_model_jerry.jpg\" alt \"tom_jerry_model_jerry\" width 42%> <img src \"./assets/start/tom_jerry_model_tom.jpg\" alt \"tom_jerry_model_tom\" width 42%> 因为模型文件比较大，所以识别略有压力。 ## 常见解答 ### 板子上为什么有一个额外的 BL702 芯片 BL702 芯片在这里担任着 USB 转双串口芯片功能。 因此有时候串口异常的话，可以上电前按住 BOOT 按键来给 BL702 重新烧录一下 USB 转双串口的固件。 ### 为什么要用双串口 根据 BL808 的手册可以知道里面有三颗核心，双串口分别连接到了其中的两颗核心，可以自己体验异构核心的执行顺序。 ### 为什么用虚拟 U 盘 虚拟 U 盘是基于固件出来的，目的是方便用户快速烧录体验 Demo。 把 BL808 里面的全部固件擦除后，就不会再有虚拟 U 盘了。 想要再次使用虚拟 U 盘的话，按照文档重新使用串口烧录的方法重新烧录一下默认的固件就行了。 ### 为什么要说明串口烧录 虚拟 U 盘是基于固件的，想要烧录这个固件就必须有一种烧录方式将它烧录进板子。 这里我们用串口烧录的方法来烧录最基础的固件到芯片里面的 FLASH 中。 ### 怎么样擦除 bl808 的固件 擦除固件需要使用到 [Bouffalo Lab Dev Cube](https://dev.bouffalolab.com/download) 这款软件，在打开软件后选择 BL808 芯片型号。 ![chip_selection](./assets/start/chip_selection.png) 首先在软件里面点开高级模式 ![erase_advanede_mode](./assets/start/erase_advanede_mode.jpg) 选择 FLASH 界面然后使板子进入下载模式（按住板子上的 BOOT 键和 RST 键， 然后先松开 RST 键再松开 BOOT 键），选择串口号较大的串口，勾选 Whole Chip，点击 `Erase Flash` 开始擦除。 ![erase_configurations](./assets/start/erase_configurations.jpg) 擦除的时候没有进度条，擦除完成的时候会直接显示 SUCCESS。 ![erase_success](./assets/start/erase_success.jpg) ### 烧录 BL808 时候提示 BFLB IMG LOAD SHAKEHAND FAIL 这种情况是板子的 bl808 没有进入下载模式，确定自己在板子在运行时（已经通电）自己同时按下 RST 按键和 BOOT 按键，然后先松开 RST 键后松开 BOOT 键来时 bl808 进入下载模式。 ![uart_burn_bl808_shakehand_fail](./assets/start/uart_burn_bl808_shakehand_fail.jpg) 并且确定自己在下载的时候选择的是串口号大的那一个串口，而不是小号串口。 ![uart_burn_bl808_shakehand_fail_com_port](./assets/start/uart_burn_bl808_shakehand_fail_com_port.jpg) ### 烧录 BL808 时候只看到一个串口 这种情况是进入了板载 bl702 下载模式。需要注意的是不应该按住 BOOT 键然后给板子通电，这样会进入 bl702 的下载模式，只有一个串口显示在电脑中。给 bl808 通过串口烧录是在板子通电后，同时按下 RST 按键和 BOOT 按键，然后先松开 RST 键后松开 BOOT 键来时 bl808 进入下载模式。 ![uart_burn_bl808_only_one_port](./assets/start/uart_burn_bl808_only_one_port.jpg) ### 烧录 BL808 时候没有串口设备 确定自己连接的是板子上的 UART 接口，换一根数据线或者连接电脑另一个 USB 口。 ![uart_burn_bl808_only_one_port](./assets/start/uart_burn_bl808_only_one_port.jpg) ### 烧录 BL808 时候只想要烧录单个固件 在烧录工具软件中，首次烧录要求将 `partition table`, `boot2`, `firmware`, `d0fw` 文件都勾选上并烧录进板子，以后如果想要烧录由 SDK 编译出来的单个固件，在对应的烧录选项中选择编译出来的文件就行： `firmware` 选择由 e907_demo 编译出来的最终固件。 `d0fw` 选择由 c906_demo 编译出来的最终固件。 `partition table` 和 `boot2` 每次烧录都要勾选中。 <table> <tr> <td>烧录 c906_demo 固件</td> <td>烧录 e907_demo 固件</td> </tr> <tr> <td><img src \"./assets/start/uart_burn_c906.jpg\" alt \"uart_burn_c906\"></td> <td><img src \"./assets/start/uart_burn_e907.jpg\" alt \"uart_burn_e907\"></td> </tr> </table> ### 编译 SDK 相关的常见问题 1. 执行完 build.sh 后提示 `Makefile:14: *** BL_SDK_PATH not found, please enter: export BL_SDK_PATH {sdk_path}. Stop.`，查看 [配置编译工具链路径](https://wiki.sipeed.com/hardware/zh/maix/m1s/other/start.html#%E9%85%8D%E7%BD%AE%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE%E8%B7%AF%E5%BE%84) 来配置自己的 BL_SDK_PATH。 2. 编译出错 注意编译的时候使用的命令为 `./build.sh demo_name`，比如 `./build.sh hello_world`，而不是 `./build.sh hello_world/` （注意最后面的路径符号`/`） ### 旧固件开箱测试 对 M1s Dock 板子上电，屏幕会显示摄像头所拍摄到的内容。 按下 `S1` 或者 `S2` 按键后屏幕上的数字会发生变化，那个数字表示着板子上 LED 的亮度百分比。 ![default_firmware](./assets/start/default_firmware.jpg) 可以看到下图中的 LED 亮度为 50% 时候的亮起状态。 ![led_brghtness](./assets/start/led_brghtness.jpg) ### 给板载 bl702 进行烧录 一般来说板子串口出问题才进行这里的烧录。 按住 BOOT 键后冷启动板子，就可以通过 UART 口烧录板载 bl702 了。 在给板子通电前按住板子上的 BOOT 按键，然后通过板子上的 UART USB 接口连接电脑，此时板载 bl702 进入下载模式，打开 `BLDevCube` 烧录软件（根据自己系统选择），选择 `BL702` 芯片，在打开的软件界面选择 MCU 模式，接着可以在 [这里](https://dl.sipeed.com/shareURL/MAIX/M1s/M1s_Dock/7_Firmware) 下载到 bl702 的固件，名称为 `usb2dualuart_bl702` 开头的就是我们需要烧录的文件。 固件差异可以查看 [bl702 固件差异](https://wiki.sipeed.com/hardware/zh/maix/m1s/other/start.html#bl702 %E5%9B%BA%E4%BB%B6%E5%B7%AE%E5%BC%82) <table> <tr> <td><img src \"./assets/start/select_bl702.png\" alt \"select_bl702\" style \"transform:rotate(0deg);\"></td> <td><img src \"./assets/start/mcu_mode.png\" alt \"mcu_mode\" style \"transform:rotate(0deg);\" width \"70%\"></td> </tr> </table> 点击 `Refresh`，选择唯一的串口（如果看到的不是唯一串口，记住是先按住 BOOT 键，再给板子通电），设置波特率 2000000， 点击下载烧录。 ![burn_bl702](./assets/start/burn_bl702.png) 烧录结束后，重新插拔一次 USB 来重新启动 bl702 以应用新的固件。 ![finish_burn_702](./assets/start/finish_burn_702.png) ### 给 bl702 烧录时没有串口 如果没有出现，就需要确认自己是在板子未通电的时候按住板子上的 BOOT 键后再通过板子上的 UART 接口来给板子通电。 Windows 用户可以在设备管理器中先查看一下有没有一个 `Bouffalo CDC` 设备。 Windows 10 以下的系统不会自动加载 USB CDC 驱动，需要自己手动搜索 `Windows7 CDC` 相关的问题解决。 ![burn_bl702_cdc_error](./assets/start/burn_bl702_cdc_error.png) ### 烧录固件后板卡没有启动 这种情况是 bl702 的固件差异导致的，有下面两个解决方法： 通电后，按下板子上的 RST 按键来启动 M1S Dock 重新烧录 bl702 的双串口固件 [烧录 bl702](https://wiki.sipeed.com/hardware/zh/maix/m1s/other/start.html#%E7%BB%99%E6%9D%BF%E8%BD%BD bl702 %E8%BF%9B%E8%A1%8C%E7%83%A7%E5%BD%95) ### bl702 固件差异 在 [下载站](https://dl.sipeed.com/shareURL/MAIX/M1s/M1s_Dock/7_Firmware) 中，有两个 bl702 可用的双串口固件，他们的差异如下： 固件名称 usb2dualuart_bl702_221118 usb2dualuart_bl702_20230221 来源 SIPEED 博流智能 详细说明 具有软复位功能，<br>不用按下 RST 按键就能运行 BL808 没有复位功能，<br>需要按下 RST 键才能启动 BL808 驱动情况 部分电脑可能需要手动安装 [驱动](https://dl.sipeed.com/shareURL/MAIX/tools/driver) <br>才能系统识别 免驱 [点我查看如何烧录 BL702 固件](https://wiki.sipeed.com/hardware/zh/maix/m1s/other/start.html#%E7%BB%99%E6%9D%BF%E8%BD%BD bl702 %E8%BF%9B%E8%A1%8C%E7%83%A7%E5%BD%95)"},"/hardware/zh/maix/m1s/other/questions.html":{"title":"M1s DOCK 常见问题","content":" title: M1s DOCK 常见问题 keywords: M1s DOCK ,BL808, M1s update: date: 2022 11 28 version: v0.1 author: wonder content: 初次编辑 ## c906_app/build_out/xxxxx/.map:No such file or directory 注意编译的时候使用的命令为 `./build.sh demo_name`，比如 `./build.sh hello_world`，而不是 `./build.sh hello_world/` （注意最后面的路径符号`/`）"},"/hardware/zh/maix/m1s/other/get_key.html":{"title":"M1s 获取机器码","content":" title: M1s 获取机器码 keywords: M1s DOCK ,BL808, M1s update: date: 2022 11 10 version: v0.1 author: wonder content: 初次编辑 在 [MaixHub](https://maixhub.com/) 下载模型的时候会要求输入机器码，这里说明一下怎么获得机器码。 如果进行下面步骤后没有得到机器码的话，查看[常见问题](#常见问题) ## 简述 简述步骤如下： 将开发板通过 UART 串口与电脑连接（电脑设备管理器中会出现两个串口） 使用任意串口工具，设置波特波特率为 2000000 （1 个 2 和 6 个 0），打开开发板在电脑中所显示的较大的串口号 按下开发板上的 RST 按键，在打印的串口信息如下（仅作示例） ```bash # 省略若干 [MTD] >>>>>> Hanlde info Dump >>>>>> name D0FW id 0 offset 0x00100000(1048576) size 0x00200000(2048Kbytes) xip_addr 0x580f0000 [MTD] <<<<<< Hanlde info End <<<<<< D0FW addr:0x580f0000 size:0x200000 MM CPU select PLL >MM CPU select 400Mhz UART CLK select MM XCLK >XCLK select XTAL I2C CLK select MM XCLK >XCLK select XTAL SPI CLK select 160Mhz MM BUS CLK select 160Mhz XCLK select XTAL irq handle: 3 reset ev CHIP KEY key:57F80642C3F97E2655772C48AF17455EC9E79BBF76C16EED4E0EC1096D664435 ``` 可以从最后面的 `CHIP KEY` 得到下载模型所需要的机器码了 > 每块板子的 `CHIP KEY` 都不一样，上面仅作示范参考，实际 `CHIP KEY` 根据每个人操作来获得。 ## 详述 1. 将板子的 UART 口通过 Type C 数据线与电脑连接起来 ![uart_connect](./assets/get_key/uart_connect.png) 2. 打开电脑串口工具（根据自己的串口软件自行更改），设置波特率为 2000000 （1 个 2 和 6 个 0），打开开发板在电脑上显示的较大串口号 <img src \"./assets/get_key/baudrate_2000000.png\" width 45% alt \"baudrate_2000000\"> <img src \"./assets/get_key/bigger_com_port.png\" width 45% alt \"bigger_com_port\"> 3. 打开串口；按下板子上面的 RST 按键。在串口打印信息的最后看到 `CHIP KEY` 。 <table> <tr> <th>按一下 RST 按键再松开</th> <th>串口软件显示出来机器码</th> </tr> <tr> <td><img src \"./assets/get_key/rst_key.png\" alt \"rst_key\"></td> <td><img src \"./assets/get_key/chip_key.png\" alt \"chip_key\"></td> </tr> </table> ## 常见问题 ### 串口乱码 确认自己设置的波特率为 2000000 （2M） ### 复位后的信息中没有 CHIP KEY 这种情况可以通过更新为最新固件来解决，[点我跳转到最新固件下载地址](https://dl.sipeed.com/shareURL/MAIX/M1s/M1s_Dock/7_Firmware/factory)，选择文件名为 `firmware` 开头的文件，烧录方法请参考[该网页](https://gitee.com/sipeed/M1s_BL808_example) (Gitee) 里面的 **Download e907 firmware** ### 没有显示出两个串口 可以参考[该网页](https://gitee.com/sipeed/M1s_BL808_example) (Gitee) 里面的 **Download bl702 firmware** 重新烧录一次串口固件，双串口固件下载地址为 [这里](https://dl.sipeed.com/shareURL/MAIX/M1s/M1s_Dock/7_Firmware)，其名称以 `usb2dualuart_bl702.bin` 开头 ### 没有显示出任何串口 首先应当确认自己所接通的是 UART 口，然后可以根据本篇所述的[没有显示出两个串口](#没有显示出两个串口)重新烧录一下串口固件"},"/hardware/zh/maix/m1s/other/others.html":{"title":"M1s DOCK 安装外壳","content":" title: M1s DOCK 安装外壳 keywords: M1s DOCK ,BL808, M1s update: date: 2022 11 22 version: v0.1 author: wonder content: 新建文档 这里说明一下摄像头和屏幕的拆装方法，并补充下外壳的安装方法。 ## 拆卸屏幕 默认发货的板卡的摄像头和屏幕是同一方向的，有时候因为一些原因比如调整摄像头方向需要拆卸屏幕，这里写一下注意事项。 屏幕与摄像头同向 摄像头放在背部 ![screen_camera_same](./assets/others/screen_camera_same.jpg) ![camera_in_back](./assets/others/camera_in_back.jpg) 屏幕与板卡是通过泡沫胶粘在一起的，因此拆卸屏幕的时候需要撕开泡沫胶。这时需要注意应该对屏幕背板的金属层用力，而不是扣屏幕边缘。 <table> <tr> <td><img alt \"sponge_glue_strip\" src \"./assets/others/sponge_glue_strip.jpg\" width \"150%\"></td> <td><img alt \"sponge_glue_strip_top\" src \"./assets/others/sponge_glue_strip_top.jpg\" width \"150%\"></td> <td>旁边两张图可以看到<br>屏幕与板子是通过泡沫胶粘在一起的</td> </tr> </table> <table> <tr> <td><img alt \"screen_back_plane\" src \"./assets/others/screen_back_plane.png\" width \"150%\"></td> <td>中间为屏幕背板金属层，<br>旁边的黑色部分为屏幕边缘，<br>拆卸的时候后需要对屏幕背板金属层用力</td> </tr> </table> <table> <tr> <td><img alt \"screen_connector\" src \"./assets/others/screen_connector.jpg\" ></td> <td>打开后注意屏幕与板子的连接方式如左图所示，<br>不要连接反了</td> </tr> </table> ## 更换摄像头方向 进行完前面的[拆卸屏幕](#拆卸屏幕)后，可以将摄像头调整的前后方向了。 唯一要注意的就是在连接摄像头排线的时候别接反了。 <table> <tr> <td><img alt \"camera_direction_connector\" src \"./assets/others/camera_direction_connector.jpg\" ></td> <td>连接的时候注意将摄像头上的 1 与板子上的 1 对上就行</td> </tr> </table> ## 安装外壳 在购买 M1s Dock 的时候可以选购外壳，这里补充一下组装方法。 摄像头有两个方向可以自行选择，下面会进行说明。 拆成散件，首先要讲板子的屏幕和摄像头都拆下来，并且把外壳打开。参考下图排布方式。 ![parts](./assets/others/parts.jpg) 摄像头有前后两种组装方式，分别是摄像头拍摄方向与屏幕相同和拍摄方向与屏幕相反。 ### 屏幕与摄像头方向相同 <table> <tr> <td><img alt \"insert_camera_front_1\" src \"./assets/others/insert_camera_front_1.jpg\" ></td> <td><img alt \"insert_camera_front_2\" src \"./assets/others/insert_camera_front_2.jpg\" ></td> <td>首先将摄像头嵌入在外壳里面，正常组装上之后摄像头会被轻微固定在外壳上，确保安装的时候无偏移，摄像头居中。</td> </tr> </table><br> <table> <tr> <td><img alt \"insert_screen_side_1.jpg\" src \"./assets/others/insert_screen_side_1.jpg\" ></td> <td><img alt \"insert_screen_side_2.jpg\" src \"./assets/others/insert_screen_side_2.jpg\" ></td> <td>板子与屏幕连接好后，将屏幕穿过外壳</td> </tr> </table><br> <table> <tr> <td>旋转外壳使板子上的 TF 卡槽<br>与外壳上的 SiPEED logo 同方向</td> <td>将两个 TypeC 口对准壳子上的孔，准备安装板子进外壳</td> <td>按压箭头指向的地方，首次按压的时候有一点紧，注意对准 TypeC 口。安装板子进入外壳</td> </tr> <tr> <td><img alt \"insert_screen_direction_1\" src \"./assets/others/insert_screen_direction_1.jpg\" ></td> <td><img alt \"insert_screen_direction_2\" src \"./assets/others/insert_screen_direction_2.jpg\" ></td> <td><img alt \"insert_screen_direction_3\" src \"./assets/others/insert_screen_direction_3.jpg\" ></td> </tr> </table><br> <table> <tr> <td><img alt \"insert_camera_interface\" src \"./assets/others/insert_camera_interface.jpg\" ></td> <td><img alt \"insert_camera_interface_1\" src \"./assets/others/insert_camera_interface_1.jpg\" ></td> <td>将摄像头排线弯曲，注意不是折叠，是弯曲。穿过板子的预留孔，连接上背面的座子。</td> </tr> </table><br> <table> <tr> <td>使用壳子上的双面胶固定好屏幕，背板固定在背部，注意背板的预留摄像头孔应对着模组。</td> <td><img alt \"fix_screen\" src \"./assets/others/fix_screen.jpg\" ></td> <td><img alt \"fix_panel\" src \"./assets/others/fix_panel.jpg\" ></td> </tr> </table><br> 到此就已经组装完毕了。 ### 屏幕与摄像头方向不同 <table> <tr> <td><img alt \"opposite_screen\" src \"./assets/others/opposite_screen.jpg\" ></td> <td><img alt \"opposite_cam\" src \"./assets/others/opposite_cam.jpg\" ></td> <td>首先将摄像头和屏幕安装到板子上，摄像头应与模组同方向</td> </tr> </table><br> <table> <tr> <td>将板子穿过壳子</td> <td>最终结果如下</td> <td>调整方向让板子的 TF 卡槽与壳子上的 SiPEED logo 方向相同</td> </tr> <tr> <td><img alt \"opposite_insert_screen_1\" src \"./assets/others/opposite_insert_screen_1.jpg\" ></td> <td><img alt \"opposite_insert_screen_2\" src \"./assets/others/opposite_insert_screen_2.jpg\" ></td> <td><img alt \"opposite_insert_screen_3\" src \"./assets/others/opposite_insert_screen_3.jpg\" ></td> </tr> </table><br> <table> <tr> <td>将两个 TypeC 口对准壳子上的孔，准备自装板子进外壳</td> <td>按压箭头指向的地方，首次按压的时候有一点紧，注意对准 TypeC 口。安装板子进入外壳</td> </tr> <tr> <td><img alt \"insert_screen_direction_2\" src \"./assets/others/insert_screen_direction_2.jpg\" ></td> <td><img alt \"insert_screen_direction_4\" src \"./assets/others/insert_screen_direction_4.jpg\" ></td> </tr> </table><br> <table> <tr> <td colspan \"3\">将摄像头穿过外壳，慢慢的滑动外壳来刚好将摄像头固定在板子模组上</td> </tr> <tr> <td><img alt \"opposite_fix_cam_1\" src \"./assets/others/opposite_fix_cam_1.jpg\" ></td> <td><img alt \"opposite_fix_cam_2\" src \"./assets/others/opposite_fix_cam_2.jpg\" ></td> <td><img alt \"opposite_fix_cam_3\" src \"./assets/others/opposite_fix_cam_3.jpg\" ></td> </tr> </table> 安装好屏幕，到这里就已经完成组装了。 ![opposite_fix_screen](./assets/others/opposite_fix_screen.jpg) ## 拆卸外壳 首先在屏幕背面，使用镊子或其他工具翘起来外壳，将其取下。 ![disassemble_shell](./assets/others/disassemble_shell.jpg) 使用镊子，在外壳 Logo 处的哪个孔哪里，把板子从外壳中翘出来。 <img src \"./assets/others/disassemble_hole.jpg\" alt \"disassemble_hole\" width \"45%\"> <img src \"./assets/others/disassemble_hole_1.jpg\" alt \"disassemble_hole_1\" width \"45%\"> 然后对屏幕的背板用力，将屏幕顶出外壳 ![disassemble_remove_screen](./assets/others/disassemble_remove_screen.jpg) 到此拆卸外壳结束。"},"/hardware/zh/maix/m1s/m1s_dock.html":{"title":"M1s DOCK 开发板","content":" title: M1s DOCK 开发板 keywords: M1s DOCK ,BL808, M1s, bl808 update: date: 2022 11 09 version: v0.2 author: wonder content: 修改部分描述错误 增加 SDK(github) 和 Example(github) 链接 增加注意事项 增加软件描述栏目 date: 2022 11 04 version: v0.1 author: wonder content: 初次编写 ## 产品概述 Sipeed M1s Dock 是基于 [Sipeed M1s](./m1s_module.html) 模组来设计的一款核心板，引出了 MIPI CSI、SPI LCD 等 FPC 接口，免去接线难的烦恼。使用最精简的设计，用于客户对模组进行模组评估，或者爱好者直接上手游玩等用途。 购买链接：[淘宝](https://item.taobao.com/item.htm?id 691108452443) <td><img alt \"m1s_dock.jpg\" src \"./assets/m1s_dock/m1s_dock.jpg\" width \"45%\"></td> ## 宣传视频 M1s Dock 和 M0Sense 总览：3:15 之前的都是 M1s Dock。 <iframe src \"//player.bilibili.com/player.html?aid 559937139&bvid BV1De4y117sP&cid 887814913&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\"> </iframe> ## 板卡特点 主芯片 BL808 RISC V 480Mhz + NPU BLAI 100 板载 USB 转 UART 调试器（可实现一键点击烧录，无需按实体按键） 板载显示屏座子（可选配 1.69 寸 240x280 电容触摸屏） 板载 MIPI 摄像头座子（可选配 200W 像素摄像头） 支持 2.4G WIFI / BT / BLE 板载 1 个模拟麦克风、1 个 LED、1 个 TF 卡座 引出一路 USB OTG 到 USB Type C 接口 ### 硬件参数 <table> <thead> <tr> <th colspan \"2\" > M1s Dock </th> </tr> </thead> <tbody> <tr> <td rowspan \"8\" style \"white space:nowrap\">M1s 模组</td> </tr> <tr> <td>三核异构RISC V CPUs：<br>· RV64GCV 480MHz <br>· RV32GCP 320MHz <br>· RV32EMC 160MHz</td> </tr> <tr> <td>AI NN 通用硬件加速器 —— BLAI 100 用于视频/音频检测/识别</td> </tr> <tr> <td>内置 768KB SRAM + 64MB UHS PSRAM</td> </tr> <tr> <td>编解码：<br> MJPEG and H264(Baseline/Main)<br> 1920x1080@30fps + 640x480@30fps </td> </tr> <tr> <td>接口：<br> 摄像头接口 ：DVP 和 MIPI CSI<br> 显示接口：SPI、DBI、DPI(RGB)</td> </tr> <tr> <td>无线：<br> 支持 Wi Fi 802.11 b/g/n<br> 支持 Bluetooth 5.x Dual mode(BT+BLE)<br> 支持 Wi Fi / 蓝牙 共存</td> </tr> <tr> <td>USB 2.0 HS OTG （引出到 USB Type C 接口）</td> </tr> <tr> <td rowspan \"5\" style \"white space:nowrap\"> 板载部件 </td> </tr> <tr> <td>板载 USB 转 UART 调试器（使用官方下载工具可实现一键点击烧录，无需按实体按键）</td> </tr> <tr> <td>板载 1 个显示屏座子（可选配 1.69 寸 240 x 280 电容触摸屏）</td> </tr> <tr> <td>板载 MIPI 摄像头座子（可选配 200W 像素摄像头）</td> </tr> <tr> <td>板载 1 个模拟麦克风、1 个 LED、1 个 TF 卡座 </td> </tr> <tr> <td rowspan \"5\" style \"white space:nowrap\"> 其他说明 </td> </tr> <tr> <td> 3D 模型文件下载：<a href \"https://dl.sipeed.com/shareURL/MAIX/M1s/M1s_Dock/5_3D_file\">点击跳转</a> </td> </tr> <tr> <td>外部供电需求 TYPE C 接口：5V±10% 0.5A</td> </tr> <tr> <td>温升: &lt;30K</td> </tr> <tr> <td>工作温度范围: 10℃ ~ 65℃</td> </tr> </tbody> </table> ### 主控核心 三核异构 M0，D0，LP。 M0 D0 LP 平头哥 [E907](https://occ.t head.cn/product?id 3900588052540035072)@320MHz 平头哥 [C906](https://occ.t head.cn/product?id 3817197695983423488)@480MHz 平头哥 [E902](https://occ.t head.cn/product?id 3806460569050419200)@160MHz ### 外设框图 <img alt \"m1s_dock_function_block_top\" src \"./assets/m1s_dock/m1s_dock_function_block_top.jpg\" width 20%> <img alt \"m1s_dock_function_block_top\" src \"./assets/m1s_dock/m1s_dock_function_block_top.jpg\" width 20%> ### 尺寸图 <img alt \"m1s_dock_size\" src \"./assets/m1s_dock/m1s_dock_size.png\" width 45%> ### 引脚图 <img alt \"m1s_doc_pin_map\" src \"./assets/m1s_dock/m1s_doc_pin_map.png\" width 45%> ## 产品对比 项目 Maix Bit ESP32 cam M1s Dock : : : : 处理器 K210 ESP32 M1s(BL808) 摄像头 0.3MP DVP GC0328 2MP DVP OV2640 with flash LED 2MP MIPI OV2685(two side) with flash LED 显示屏 2.4 inch 320x240 1.68 inch 280x240 带电容触摸 音频 I2S MEMS MIC Analog MEMS MIC + LineOut SD 卡槽 SPI 模式 SPI 模式 · SDHC 模式 <br>· JTAG 模式 按键 Reset <br> Boot Reset · Reset <br>· Boot <br>· User x 2 USB USB to Serial x 1 · USB to Dual Serial x 1 <br>· USB OTG HS 其他 4P x 1.25mm 连接器（串口） 引脚 2 x 18 pins,可用于面包板 2 x 8 pins 2 x 16 pins,可用于面包板 JTAG 可选 TF2JTAG 外壳 可选 尺寸 25 x 53 mm 27 x 41 mm 27 x 55 mm ## 软件描述 <table> <thead> <tr> <th colspan \"2\" > M1s Dock </th> </tr> </thead> <tbody> <tr> <td>OS</td> <td>· 完备支持 FreeRTOS<br>· 基础支持 Linux</td> </tr> <tr> <td>开发方式</td> <td>· 原生 C SDK<br>· MaixHAL C 模块<br>· PikaPython </td> </tr> <tr> <td>固件下载</td> <td>· 串口下载<br>· 虚拟磁盘拖拽式更新</td> </tr> <tr> <td>AI 推理框架</td> <td>· 支持原生 SDK 的 BLAI 加速推理引擎<br>· 支持通用 TinyMaix 推理引擎</td> </tr> <tr> <td>AI 模型下载</td> <td>· <a href \"https://maixhub.com/\">MaixHub</a> 下载。支持 人脸检测，识别，姿态检测，手势检测 等</td> </tr> <tr> <td>Sipeed 参考示例</td> <td>· https://gitee.com/sipeed/M1s_BL808_example</td> </tr> </tbody> </table> ## 支持算子列表 <table> <thead> <tr> <th>Type</th> <th>Operators</th> <th>Applicable Subset Spec.</th> <th>Processor</th> </tr> </thead> <tbody> <tr> <td rowspan \"10\">Convolution</td> <td rowspan \"4\">Conv </td> <td>Kernel: 1x1,3x3,5x5,7x7</td> <td rowspan \"4\">:strong:<code>NPU</code></td> </tr> <tr> <td>Stride: 1x1, 2x2</td> </tr> <tr> <td>Dilation: 1x1, 2x2</td> </tr> <tr> <td>Pad: same</td> </tr> <tr> <td rowspan \"4\">Depthwise Conv</td> <td>Kernel: 1x1,3x3 (5x5, 7x7 TBD)</td> <td rowspan \"4\">:strong:<code>NPU</code></td> </tr> <tr> <td>Stride: 1x1, 2x2</td> </tr> <tr> <td>Dilation: 1x1 (2x2 TBD)</td> </tr> <tr> <td>Pad: same</td> </tr> <tr> <td rowspan \"2\">Transpose Conv</td> <td>Kernel: 3x3</td> <td rowspan \"2\">strong:<code>NPU</code></td> </tr> <tr> <td>Stride: 2x2</td> </tr> <tr> <td rowspan \"4\">Pooling</td> <td rowspan \"2\">MaxPool (NPU TBD)</td> <td>Kerenl: 2x2</td> <td rowspan \"2\">DSP</td> </tr> <tr> <td>Stride: 2x2</td> </tr> <tr> <td rowspan \"2\">MaxPool</td> <td>Kerenl: 3x3</td> <td rowspan \"2\">:strong:<code>NPU</code></td> </tr> <tr> <td>Stride: 1x1, 2x2</td> </tr> <tr> <td rowspan \"2\">Activation</td> <td>Relu</td> <td></td> <td>:strong:<code>NPU</code></td> </tr> <tr> <td>Relu 6</td> <td></td> <td>:strong:<code>NPU</code></td> </tr> <tr> <td rowspan \"5\">Other processing</td> <td>BatchNormalization</td> <td>fused with conv</td> <td>:strong:<code>NPU</code></td> </tr> <tr> <td>Add (shortcut)</td> <td></td> <td>:strong:<code>NPU</code></td> </tr> <tr> <td>Concat (route)</td> <td>Channel wise (AXIS 3 in BHWC)</td> <td>:strong:<code>NPU</code></td> </tr> <tr> <td>Fully Connected</td> <td></td> <td>:strong:<code>NPU</code></td> </tr> <tr> <td>Upsample</td> <td>Nearest</td> <td>:strong:<code>NPU</code></td> </tr> </tbody> </table> ## 补充资料 [板卡规格书](https://dl.sipeed.com/shareURL/MAIX/M1s/M1s_Dock/1_Specification) [板卡原理图](https://dl.sipeed.com/shareURL/MAIX/M1s/M1s_Dock/2_Schematic) [板卡点位图](https://dl.sipeed.com/shareURL/MAIX/M1s/M1s_Dock/3_Bit_number_map) [板卡尺寸图](https://dl.sipeed.com/shareURL/MAIX/M1s/M1s_Dock/4_Dimensional_drawing) [3D 模型文件](https://dl.sipeed.com/shareURL/MAIX/M1s_Dock/M1s/5_3D_file) [板卡芯片数据手册](https://dl.sipeed.com/shareURL/MAIX/M1s/M1s_Dock/6_Chip_Manual) [触摸屏手册](https://dl.sipeed.com/shareURL/MAIX/M1s/M1s_Dock/6_Chip_Manual/touch_screen) [博流官方文档](https://dev.bouffalolab.com/home/) [BL808 数据手册](https://gitee.com/wonderfullook/bl_docs/tree/main/BL808_DS/zh_CN) (gitee) [BL808 参考手册](https://gitee.com/wonderfullook/bl_docs/tree/main/BL808_RM/zh_CN) (gitee) [Sipeed SDK](https://gitee.com/sipeed/M1s_BL808_SDK) (gitee) [Sipeed Examples](https://gitee.com/sipeed/M1s_BL808_example)（gitee） [Bouffalolab SDK](https://github.com/bouffalolab/bouffalo_sdk)（Github） [Linux SDK](https://github.com/sipeed/M1s_BL808_Linux_SDK)（Github） 交流 QQ 群：`592731168` 。[点我加群](https://jq.qq.com/?_wv 1027&k uyKNhTeu) 论坛：[bbs.sipeed.com](https://bbs.sipeed.com/) [在线模型平台](https://maixhub.com/) ## 注意事项 <table> <tr> <th>项目</th> <th>注意事项</th> </tr> <tr> <td>静电防护</td> <td>请避免静电打到 PCBA 上；接触 PCBA 之前请把手的静电释放掉</td> </tr> <tr> <td>容忍电压</td> <td> 每个 GPIO 的工作电压已经在原理图中标注出来，请不要让 GPIO 的实际工作的电压超过额定值，否则会引起 PCBA 的永久性损坏 </td> </tr> <tr> <td>FPC 座子</td> <td>在连接 FPC 软排线的时候，请确保排线无偏侈地完整地插入到排线中</td> </tr> <tr> <td>插拔</td> <td>请完全断电后才进行插拔操作</td> </tr> <tr> <td>避免短路</td> <td>请在上电过程中，避免任何液体和金属触碰到 PCBA 上的元件的焊盘，否则会导致路，烧毁 PCBA</td> </tr> </table> ## 联系 Sipeed M1s Dock 开发板可以在多种场景实现客户不同方面的需要，技术支持和商业合作请联系邮箱 [support@sipeed.com](support@sipeed.com)"},"/hardware/zh/maix/core_module.html":{"title":"Sipeed M1/M1W","content":" title: Sipeed M1/M1W keywords: maixpy, k210, AIOT, 边缘计算, M1/M1W desc: maixpy Sipeed M1/M1W ## M1/M1W M1/M1W模块是基于嘉楠堪智科技的边缘智能计算芯片 K210 (RISC V架构) 设计的一款AIOT模块。主控芯片内置64位双核高性能低功耗处理器，每个核都有浮点运算单元(FPU) ,具备卷积人工神经网络硬件加速器(KPU)和快速傅里叶变换加速器(FFT)、搭载现场可编程IO阵列(FPIOA)，支持多种主流Al编程框架。M1W模块内置标准802.11 b/g/n协议的ESP8285 WiFi芯片，可让模块轻松联网。 ![M1/M1W](./assets/m1_m1w/M1_Dan.png) ## 应用 智能家居，机器人清洁器，智能扬声器，电子门锁，家庭监控等; 医学行业应用，如辅助诊断，医学图像识别; 智能工业应用，如工业机械，智能分拣，电气设备监控等; 教育机器人，智能互动平台，教育效率检查等教育应用; 农业应用，如农业监测，病虫害监测，自动控制等 ## M1/M1W 参数 M1/M1W Al模块系统主要由电源(3 Channel DC DC)、Flash芯片(16M)电路、K210芯片和WiFi芯片四部分组成。K210作为核心单元，功能非常很强大，芯片内置64位双核处理器，拥有8M的片上SRAM。模块在Al机器视觉、听觉性能方便表现突出，芯片总算力可达1TOPS，芯片内置多种硬件加速单元(KPU、FPU，FFT等)，可以方便地实现各类应用场景的机器视觉/听觉算法,也可以进行语音方向扫描和语音数据输出的前置处理工作。M1W模块嵌入无线WiFi功能，可轻松实现联网控制。 <p><img loading \"M1/M1W\" src \"./assets/m1_m1w/M1_vs_M1W.png\" width 500 ></p> <p><img loading \"M1/M1W\" src \"./assets/m1_m1w/M1_pin.png\" width 500 ></p> <p><img loading \"M1/M1W\" src \"./assets/m1_m1w/M1W_2.png\" width 500 ></p> <table role \"table\" class \"center_table\"> <thead> <tr> <th colspan \"2\">K210 芯片基本参数</th> </tr> </thead> <tbody> <tr> <td>内核</td> <td>RISC V Dual Core 64bit, with FPU</td> </tr> <tr> <td>主频</td> <td>400MHz （可超频至600MHz）</td> </tr> <tr> <td>SRAM</td> <td>内置8M Byte</td> </tr> <tr> <td>图像识别</td> <td>QVGA@60fps/VGA@30fps</td> </tr> <tr> <td>语音识别</td> <td>麦克风阵列(8mics)</td> </tr> <tr> <td>神经网络模型</td> <td><li>支持YOLOv3<li>Mobilenetv2<li>TinyYOLOv2</td> </tr> <tr> <td>深度学习框架</td> <td>支持TensorFlow \\ Keras \\ Darknet \\ Caffe 等主流框架</td> </tr> <tr> <td>外设</td> <td>FPIOA、 UART、 GPIO、 SPI、 I2C、I2S、 TIMER</td> </tr> <tr> <td>视频处理</td> <td><li>神经网络处理器(KPU)<li>FPU满足IEEE754 2008标准<li>音频处理器(APU)<li>快速傅里叶变换加速器(FFT)</td> </tr> </tbody> </table> <table role \"table\" class \"center_table\"> <thead> <tr> <th colspan \"2\">模块软件</th> </tr> </thead> <tr> <td>操作系统</td><td>FreeRtos and Standrad development ki</td> </tr> <tr> <td>编程语言</td><td>MicroPython</td> </tr> <tr> <td>机器视觉</td><td>支持卷积神经网络</td> </tr> <tr> <td>机器听觉</td><td>高性能音频处理器(APU)</td> </tr> <tr> <td>开发环境</td><td>串口终端、MaixPy IDE</td> </tr> </table> <table role \"table\" class \"center_table\"> <thead> <tr> <th colspan \"2\">模块硬件</th> </tr> </thead> <tr> <td>尺寸</td><td>25.4*25.4*3.3mm</td> </tr> <tr> <td>引脚</td><td>72 PIN全引脚引出</td> </tr> <tr> <td>供电电压</td><td>5.0V @ 300mA（供电电流需大于300mA)</td> </tr> <tr> <td>工作温度</td><td> 30°C ~85°C</td> </tr> </table> <table role \"table\" class \"center_table\"> <thead> <tr> <th colspan \"2\">Wi Fi功能参数</th> </tr> </thead> <tr> <td>主控</td> <td>ESP8285</td> </tr> <tr> <td>无线标准</td><td>802.11 b/g/n</td> </tr> <tr> <td>频率范围</td><td>2400Mhz 2483.5Mhz</td> </tr> <tr> <td>天线</td><td>标准IPEX接口天线</td> </tr> <tr> <td>Wi Fi模式</td><td>支持Station / SoftAP /SoftAP+Station</td> </tr> </table> > 为了让Al模块能应用于更多场合，Sipeed团队还推出了无WiFi功能版本的M1模块，如果用户无需使用无线联网的功能，可以选择我们的M1模块。M1模块和M1W模块的AI功能一致，使用方法基本相同，主要区别就是M1W模块比M1模块多了WiFi功能。 ## 资料下载 芯片 K210 Datasheet: [Kendryte 官网](https://canaan creative.com/) M1W 资料下载: [dl.sipeed.com](https://dl.sipeed.com/shareURL/MAIX/HDK/Sipeed M1&M1W) ## 软件开发 1. [MaixPy](https://wiki.sipeed.com/maixpy)：MicroPython 语言开发 2. C 语言 SDK: [kendryte standalone sdk](https://github.com/kendryte/kendryte standalone sdk) ## 产品技术支持 Maix系列产品可以在多种场景实现客户不同方面的需要，在AIoT上已经广泛的使用，品质和性能在行业内已经有非常好的口碑，专业的技术团队为广大客户解决硬件设计和软件功能上的各种各样问题。专业技术支持和更详细资料请联系商务<support@sipeed.com>。"},"/hardware/zh/maix/M1n.html":{"title":"Sipeed M1n","content":" title: Sipeed M1n keywords: maixpy, k210, AIOT, 边缘计算, M1n desc: maixpy Sipeed M1/M1W ## M1n SiPEEDM1n是基于基于嘉楠堪智科技的边缘智能计算芯片K210(RISC v架构64位双核)设计的一款AIOT开发板。板载DVP双摄像头接口、Flash、并把大部分IO通过金手指方式引出，模块设计小巧精致、布局走线合理规范，用户可直接应用于商用产品，也可以通过转接板对此模块进行开发。 ![M1n](./assets/m1n/M1n_1.png) ## 应用 智能家居，机器人清洁器，智能扬声器，电子门锁，家庭监控等; 医学行业应用，如辅助诊断，医学图像识别; 智能工业应用，如工业机械，智能分拣，电气设备监控等; 教育机器人，智能互动平台，教育效率检查等教育应用; 农业应用，如农业监测，病虫害监测，自动控制等 ## M1n 参数 M1n模块以K210作为核心单元，功能非常很强大，芯片内置64位双核处理器，拥有8M的片上SRAM，在Al机器视觉、听觉性能方便表现突出，内置多种硬件加速单元(KPU、FPU，FFT等)，总算力最高可达1TOPs ,可以方便地实现各类应用场景的机器视觉/听觉算法,也可以进行语音方向扫描和语音数据输出的前置处理工作。 <p><img loading \"M1/M1W\" src \"./assets/m1n/M1n.png\" width 500 ></p> <table role \"table\" class \"center_table\"> <thead> <tr> <th colspan \"2\">K210 芯片基本参数</th> </tr> </thead> <tbody> <tr> <td>内核</td> <td>RISC V Dual Core 64bit, with FPU</td> </tr> <tr> <td>主频</td> <td>400MHz （可超频至600MHz）</td> </tr> <tr> <td>SRAM</td> <td>内置8M Byte</td> </tr> <tr> <td>图像识别</td> <td>QVGA@60fps/VGA@30fps</td> </tr> <tr> <td>语音识别</td> <td>麦克风阵列(8mics)</td> </tr> <tr> <td>网络模型</td> <td><li>支持YOLOv3<li>Mobilenetv2<li>TinyYOLOv2<li>人脸识别等</td> </tr> <tr> <td>深度学习框架</td> <td>支持TensorFlow \\ Keras \\ Darknet \\ Caffe 等主流框架</td> </tr> <tr> <td>外设</td> <td>FPIOA、 UART、 GPIO、 SPI、 I2C、I2S、 TIMER</td> </tr> <tr> <td>视频处理</td> <td><li>神经网络处理器(KPU)<li>FPU满足IEEE754 2008标准<li>音频处理器(APU)<li>快速傅里叶变换加速器(FFT)</td> </tr> </tbody> </table> <table role \"table\" class \"center_table\"> <thead> <tr> <th colspan \"2\">模块软件</th> </tr> </thead> <tr> <td>操作系统</td><td>FreeRtos and Standrad development ki</td> </tr> <tr> <td>编程语言</td><td>MicroPython</td> </tr> <tr> <td>机器视觉</td><td>支持卷积神经网络</td> </tr> <tr> <td>机器听觉</td><td>高性能音频处理器(APU)</td> </tr> <tr> <td>开发环境</td><td>串口终端、MaixPy IDE</td> </tr> </table> <table role \"table\" class \"center_table\"> <thead> <tr> <th colspan \"2\">模块硬件</th> </tr> </thead> <tr> <td>尺寸</td><td>22.0*25.0mm</td> </tr> <tr> <td>引脚</td><td>部分引脚金手指引出</td> </tr> <tr> <td>供电电压</td><td>5.0V @ 300mA（供电电流需大于300mA)</td> </tr> <tr> <td>工作温度</td><td> 30°C ~85°C</td> </tr> </table> ## 资料下载 芯片 K210 Datasheet: [Kendryte 官网](https://canaan creative.com/) M1n 资料下载: [Click me](https://dl.sipeed.com/shareURL/MAIX/HDK/Sipeed M1n) M1n 原理图下载：[Sipeed M1n Datasheet V1.0.pdf](https://dl.sipeed.com/fileList/MAIX/HDK/Sipeed M1n/Sipeed%20M1n%20Datasheet%20V1.0.pdf) ## 软件开发 1. [MaixPy](https://wiki.sipeed.com/maixpy)：MicroPython 语言开发 2. C 语言 SDK: [kendryte standalone sdk](https://github.com/kendryte/kendryte standalone sdk) ## 产品技术支持 Maix系列产品可以在多种场景实现客户不同方面的需要，在AIoT上已经广泛的使用，品质和性能在行业内已经有非常好的口碑，专业的技术团队为广大客户解决硬件设计和软件功能上的各种各样问题。专业技术支持和更详细资料请联系商务<support@sipeed.com>。"},"/hardware/zh/maixsense/maixsense-a010/mcu.html":{"title":"MS-A010 接入 MCU（Maix Bit）","content":"# MS A010 接入 MCU（Maix Bit） 此文详细说明一下 MaixSense a010 接入 K210 Bit 例程，用户可基于此篇快速进行二次开发。 [Maix Bit 购买链接指路](https://item.taobao.com/item.htm?spm a230r.1.14.11.681570a1yq4sJD&id 586580351110&ns 1&abbucket 10&mt ) []() ![ms_mscu](./assets/ms_mcu.jpg) ## 概述 MS A010 拥有强大的兼容性，可基于串口协议外接 Maix I Bit 这样的单片机开发板或树莓派之类的 linux 开发板来进行二次开发。 MAIX I BIT 开发板是 Sipeed Maix 中产品线的一员，基于嘉楠堪智科技的边缘智能计算芯片 K210 (RISC V 架构 64位双核) 设计的一款 AIOT 开发板。 ## 准备工作 首先，我们肯定要各自拥有一个 MS A010 模组和 Bit 开发板 如果没有的话，接入例程就此停步。 接下来 准备 4pin 端子线以及 USB type c 线一条。 ### 接线教程 接线需要了解 A010 的接口的引脚信息，"},"/hardware/zh/maixsense/maixsense-a010/code.html":{"title":"源码总览","content":"# 源码总览 [源码总览](#源码总览) [tof_mainpy](#tof_mainpy) [streampy](#streampy) [calvolumespy](#calvolumespy) ## tof_main_hostpy ```python import threading import queue import struct import time import numpy as np import cv2 import serial # 配置（按需修改） # Configuration (modify as needed) PORT \"/dev/ttyUSB0\" BAUD 921600 TIMEOUT 0.05 ENDIAN \"<\" # 如果设备是 big endian 改为 \">\" FRAME_HEAD b\"\\x00\\xFF\" ALLOWED_TAILS (0xCC, 0xDD) RAW_QUEUE_MAXSIZE 50 # 原始字节队列 FRAME_QUEUE_MAXSIZE 10 # 已解析完整 payload 队列 # 打开串口（若已有 Serial 对象可改为复用） # Open the serial port (if you already have a Serial object you can reuse it) ser serial.Serial(PORT, BAUD, timeout TIMEOUT) raw_queue queue.Queue(maxsize RAW_QUEUE_MAXSIZE) # 生产者 > 中继（原始 bytes） frame_queue queue.Queue(maxsize FRAME_QUEUE_MAXSIZE) # 中继 > 消费者（(resR,resC,payload)） stop_event threading.Event() ser.write(b\"AT+FPS 19\\r\") time.sleep(0.1) ######################## PAY ATTENTION HERE Start ######################## ser.write(b\"AT+DISP 2\\r\") # usb display on (FASTER IF YOU DO NOT NEED LCD) # ser.write(b\"AT+DISP 3\\r\") # lcd and usb display on (SLOWER) ######################## PAY ATTENTION HERE End ######################## time.sleep(0.1) def reader_thread(): \"\"\" 只负责从串口读取原始字节，尽量不断读取以避免内核串口缓冲区堆积。 将读取到的 bytes 块放入 raw_queue。若队列已满，丢弃最旧项以腾出空间。 Read only thread that reads raw bytes from the serial port as fast as possible to avoid the kernel serial buffer filling up. Puts received byte chunks into `raw_queue`. If the queue is full, the oldest entries are discarded to free space. \"\"\" while not stop_event.is_set(): try: n ser.in_waiting except Exception: break if not n: # 仍然尝试读取一点数据以触发 timeout # Still try to read a small amount to trigger the timeout try: data ser.read(256) except Exception: break else: try: data ser.read(min(4096, n)) except Exception: break if not data: time.sleep(0.001) continue # 确保能放入队列：若满则丢弃最旧项，保持流动 # Ensure the data can be put into the queue: if it's full, drop the oldest # items to keep the flow moving. try: while raw_queue.full(): try: raw_queue.get_nowait() # 丢弃最旧 except queue.Empty: break raw_queue.put_nowait(data) except Exception: # 若仍有异常，短暂休眠并继续 # If there's still an exception, sleep briefly and continue time.sleep(0.001) continue def relay_thread(): \"\"\" 从 raw_queue 读取原始 bytes，维护一个缓冲区，解析出完整帧并校验。 解析成功后把 (resR, resC, payload) 放入 frame_queue。 中继层负责查找帧头、计算整帧长度、校验 checksum 和 tail。 Relay thread: reads raw bytes from `raw_queue`, keeps an internal buffer, parses out complete frames and validates them. On successful parsing it puts tuples of (resR, resC, payload) into `frame_queue`. Responsibilities include finding the frame header, computing full frame length, and validating checksum and tail bytes. \"\"\" last_frameid 0 buf bytearray() while not stop_event.is_set() or not raw_queue.empty(): try: chunk raw_queue.get(timeout 0.1) except queue.Empty: continue buf + chunk # 在 buf 中循环解析尽可能多的完整帧 while True: idx buf.find(FRAME_HEAD) if idx < 0: # 没有帧头，避免 buf 无限制增长 if len(buf) > 8192: buf.clear() break if idx > 0: del buf[:idx] # 丢弃头之前的数据 # Discard any bytes before the header # 需要至少 4 字节以读取 dataLen（head 2 + len 2） # Need at least 4 bytes to read dataLen (head 2 + len 2) if len(buf) < 4: break # 读取 dataLen（2字节） try: dataLen struct.unpack(ENDIAN + \"H\", buf[2:4])[0] except struct.error: break # 计算整帧长度: head(2) + len(2) + dataLen + checksum(1) + tail(1) # Compute full frame length: head(2) + len(2) + dataLen + checksum(1) + tail(1) frameLen 2 + 2 + dataLen + 2 if len(buf) < frameLen: # 等待更多数据 break frame bytes(buf[:frameLen]) # 消耗缓冲区 del buf[:frameLen] # 校验尾和校验和 # Validate tail byte and checksum frame_tail frame[ 1] checksum_byte frame[ 2] calc_sum sum(frame[: 2]) & 0xFF if frame_tail not in ALLOWED_TAILS or checksum_byte ! calc_sum: # 非法帧丢弃，继续尝试下一个帧头位置 continue # 解析分辨率与 payload 偏移（保持原协议） # frame[14] rows, frame[15] cols # Parse resolution and payload offsets (protocol preserved) try: resR frame[14] resC frame[15] frameid struct.unpack(ENDIAN + \"H\", frame[16:18])[0] except IndexError: continue # print(f\"Received frame id: {frameid}, resolution: {resR}x{resC}\", flush True) # 根据原协议：dataLen 包含一些头部，payload 长度 dataLen 16（与原代码一致） # According to the original protocol: dataLen includes some header bytes, # so payload length dataLen 16 (keeps behavior consistent with the # original code). frameDataLen dataLen 16 data_start 20 data_end data_start + frameDataLen # payload 应位于 data_start:data_end，且在 checksum 前 if data_end > len(frame) 2: # 如果不满足则跳过 continue if frameid last_frameid: # 重复帧丢弃 # Drop duplicate frames continue last_frameid frameid payload frame[data_start:data_end] # 放入 frame_queue（若队列满则丢帧） # Put into `frame_queue` (if full, drop the frame) try: frame_queue.put_nowait((resR, resC, payload)) except queue.Full: # 丢帧以确保中继不会阻塞读取流程 # Drop frames to ensure the relay doesn't block the read flow continue def processor_thread(): \"\"\" 从 frame_queue 读取 payload，解码为图像并显示（或进一步处理）。 使用 OpenCV colormap 显示，按 'q' 退出。每隔5秒在命令行打印一次帧率。 Processor thread: reads payloads from `frame_queue`, decodes them into images and displays them (or further processes them). Uses OpenCV colormap for visualization. Press 'q' to quit. Prints FPS to the console every 5 seconds. \"\"\" cv2.namedWindow(\"frame\", cv2.WINDOW_AUTOSIZE) last_print time.time() interval_count 0 while not stop_event.is_set() or not frame_queue.empty(): try: res frame_queue.get(timeout 0.1) except queue.Empty: # 即使没有新帧，也检查是否到达打印间隔 # Even when there's no new frame, check whether the print interval # has been reached now time.time() if now last_print > 5.0: elapsed now last_print fps interval_count / elapsed if elapsed > 0 else 0.0 print(f\"[{time.strftime('%H:%M:%S')}] FPS: {fps:.2f} ({interval_count} frames in {elapsed:.2f}s)\", flush True) last_print now interval_count 0 continue try: resR, resC, payload res except Exception: continue # payload > numpy > reshape # Convert payload to numpy array and reshape according to resolution try: img_idx np.frombuffer(payload, dtype np.uint8) if img_idx.size ! resR * resC: # 长度不匹配则丢弃 # If size doesn't match, drop the frame continue img_idx img_idx.reshape((resR, resC)) except Exception: continue try: color_img cv2.applyColorMap(img_idx, cv2.COLORMAP_MAGMA) cv2.imshow(\"frame\", color_img) if cv2.waitKey(1) & 0xFF ord('q'): stop_event.set() break except Exception: # If display fails, skip this frame and continue continue # 帧计数并按间隔打印 FPS # Count frames and print FPS at intervals interval_count + 1 now time.time() if now last_print > 5.0: elapsed now last_print fps interval_count / elapsed if elapsed > 0 else 0.0 print(f\"[{time.strftime('%H:%M:%S')}] FPS: {fps:.2f} ({interval_count} frames in {elapsed:.2f}s)\", flush True) last_print now interval_count 0 cv2.destroyAllWindows() # 启动线程 # Start threads t_reader threading.Thread(target reader_thread, name \"serial reader\", daemon True) t_relay threading.Thread(target relay_thread, name \"serial relay\", daemon True) t_processor threading.Thread(target processor_thread, name \"frame processor\", daemon True) t_reader.start() t_relay.start() t_processor.start() try: while not stop_event.is_set(): time.sleep(0.1) except KeyboardInterrupt: stop_event.set() finally: stop_event.set() t_reader.join(timeout 1.0) t_relay.join(timeout 1.0) t_processor.join(timeout 1.0) try: ser.close() except Exception: pass cv2.destroyAllWindows() ``` ## tof_mainpy ```python from fpioa_manager import fm from machine import UART import lcd, image # lcd.init(invert True) lcd.init() img image.Image() fm.register(24, fm.fpioa.UART1_TX, force True) fm.register(25, fm.fpioa.UART1_RX, force True) uart_A UART(UART.UART1, 115200, 8, 0, 0, timeout 1000, read_buf_len 4096) def uart_readBytes(): return uart_A.read() def uart_hasData(): return uart_A.any() def uart_sendCmd(cmd): uart_A.write(cmd) uart_sendCmd(b\"AT+BAUD 5\\r\") uart_A.deinit() uart_A UART(UART.UART1, 921600, 8, 0, 0, timeout 1000, read_buf_len 4096) jetcolors [ (128, 0, 0), (132, 0, 0), (136, 0, 0), (140, 0, 0), (144, 0, 0), (148, 0, 0), (152, 0, 0), (156, 0, 0), (160, 0, 0), (164, 0, 0), (168, 0, 0), (172, 0, 0), (176, 0, 0), (180, 0, 0), (184, 0, 0), (188, 0, 0), (192, 0, 0), (196, 0, 0), (200, 0, 0), (204, 0, 0), (208, 0, 0), (212, 0, 0), (216, 0, 0), (220, 0, 0), (224, 0, 0), (228, 0, 0), (232, 0, 0), (236, 0, 0), (240, 0, 0), (244, 0, 0), (248, 0, 0), (252, 0, 0), (255, 0, 0), (255, 4, 0), (255, 8, 0), (255, 12, 0), (255, 16, 0), (255, 20, 0), (255, 24, 0), (255, 28, 0), (255, 32, 0), (255, 36, 0), (255, 40, 0), (255, 44, 0), (255, 48, 0), (255, 52, 0), (255, 56, 0), (255, 60, 0), (255, 64, 0), (255, 68, 0), (255, 72, 0), (255, 76, 0), (255, 80, 0), (255, 84, 0), (255, 88, 0), (255, 92, 0), (255, 96, 0), (255, 100, 0), (255, 104, 0), (255, 108, 0), (255, 112, 0), (255, 116, 0), (255, 120, 0), (255, 124, 0), (255, 128, 0), (255, 132, 0), (255, 136, 0), (255, 140, 0), (255, 144, 0), (255, 148, 0), (255, 152, 0), (255, 156, 0), (255, 160, 0), (255, 164, 0), (255, 168, 0), (255, 172, 0), (255, 176, 0), (255, 180, 0), (255, 184, 0), (255, 188, 0), (255, 192, 0), (255, 196, 0), (255, 200, 0), (255, 204, 0), (255, 208, 0), (255, 212, 0), (255, 216, 0), (255, 220, 0), (255, 224, 0), (255, 228, 0), (255, 232, 0), (255, 236, 0), (255, 240, 0), (255, 244, 0), (255, 248, 0), (255, 252, 0), (254, 255, 1), (250, 255, 6), (246, 255, 10), (242, 255, 14), (238, 255, 18), (234, 255, 22), (230, 255, 26), (226, 255, 30), (222, 255, 34), (218, 255, 38), (214, 255, 42), (210, 255, 46), (206, 255, 50), (202, 255, 54), (198, 255, 58), (194, 255, 62), (190, 255, 66), (186, 255, 70), (182, 255, 74), (178, 255, 78), (174, 255, 82), (170, 255, 86), (166, 255, 90), (162, 255, 94), (158, 255, 98), (154, 255, 102), (150, 255, 106), (146, 255, 110), (142, 255, 114), (138, 255, 118), (134, 255, 122), (130, 255, 126), (126, 255, 130), (122, 255, 134), (118, 255, 138), (114, 255, 142), (110, 255, 146), (106, 255, 150), (102, 255, 154), (98, 255, 158), (94, 255, 162), (90, 255, 166), (86, 255, 170), (82, 255, 174), (78, 255, 178), (74, 255, 182), (70, 255, 186), (66, 255, 190), (62, 255, 194), (58, 255, 198), (54, 255, 202), (50, 255, 206), (46, 255, 210), (42, 255, 214), (38, 255, 218), (34, 255, 222), (30, 255, 226), (26, 255, 230), (22, 255, 234), (18, 255, 238), (14, 255, 242), (10, 255, 246), (6, 255, 250), (2, 255, 254), (0, 252, 255), (0, 248, 255), (0, 244, 255), (0, 240, 255), (0, 236, 255), (0, 232, 255), (0, 228, 255), (0, 224, 255), (0, 220, 255), (0, 216, 255), (0, 212, 255), (0, 208, 255), (0, 204, 255), (0, 200, 255), (0, 196, 255), (0, 192, 255), (0, 188, 255), (0, 184, 255), (0, 180, 255), (0, 176, 255), (0, 172, 255), (0, 168, 255), (0, 164, 255), (0, 160, 255), (0, 156, 255), (0, 152, 255), (0, 148, 255), (0, 144, 255), (0, 140, 255), (0, 136, 255), (0, 132, 255), (0, 128, 255), (0, 124, 255), (0, 120, 255), (0, 116, 255), (0, 112, 255), (0, 108, 255), (0, 104, 255), (0, 100, 255), (0, 96, 255), (0, 92, 255), (0, 88, 255), (0, 84, 255), (0, 80, 255), (0, 76, 255), (0, 72, 255), (0, 68, 255), (0, 64, 255), (0, 60, 255), (0, 56, 255), (0, 52, 255), (0, 48, 255), (0, 44, 255), (0, 40, 255), (0, 36, 255), (0, 32, 255), (0, 28, 255), (0, 24, 255), (0, 20, 255), (0, 16, 255), (0, 12, 255), (0, 8, 255), (0, 4, 255), (0, 0, 255), (0, 0, 252), (0, 0, 248), (0, 0, 244), (0, 0, 240), (0, 0, 236), (0, 0, 232), (0, 0, 228), (0, 0, 224), (0, 0, 220), (0, 0, 216), (0, 0, 212), (0, 0, 208), (0, 0, 204), (0, 0, 200), (0, 0, 196), (0, 0, 192), (0, 0, 188), (0, 0, 184), (0, 0, 180), (0, 0, 176), (0, 0, 172), (0, 0, 168), (0, 0, 164), (0, 0, 160), (0, 0, 156), (0, 0, 152), (0, 0, 148), (0, 0, 144), (0, 0, 140), (0, 0, 136), (0, 0, 132), (0, 0, 128) ] def show(frameData, res): resR res[0] resC res[1] for y in range(resR): for x in range(resC): pixel_cmap_rgb jetcolors[frameData[y*resR + x]] img.set_pixel(110 + x, 70 + y, pixel_cmap_rgb) lcd.display(img) img.clear() FRAME_HEAD b\"\\x00\\xFF\" FRAME_TAIL b\"\\xCC\" from struct import unpack # send_cmd(\"AT+BINN 2\\r\") uart_sendCmd(b\"AT+DISP 5\\r\") uart_sendCmd(b\"AT+FPS 10\\r\") # while True: # if uart_hasData(): # print(uart_readBytes()) rawData b'' while True: if not uart_hasData(): continue rawData + uart_readBytes() idx rawData.find(FRAME_HEAD) if idx < 0: continue rawData rawData[idx:] # print(rawData) # check data length 2Byte dataLen unpack(\"H\", rawData[2: 4])[0] # print(\"len: \"+str(dataLen)) frameLen len(FRAME_HEAD) + 2 + dataLen + 2 frameDataLen dataLen 16 if len(rawData) < frameLen: continue # get data frame rawData[:frameLen] # print(frame.hex()) rawData rawData[frameLen:] frameTail frame[ 1] # print(\"tail: \"+str(hex(frameTail))) _sum frame[ 2] # print(\"checksum: \"+str(hex(_sum))) # check sum # spi has no checksum but i add one if frameTail ! 0xdd and _sum ! sum(frame[:frameLen 2]) % 256: continue frameID unpack(\"H\", frame[16:18])[0] # print(\"frame ID: \"+str(frameID)) resR unpack(\"B\", frame[14:15])[0] resC unpack(\"B\", frame[15:16])[0] res (resR, resC) # print(res) # frameData [ unpack(\"H\", frame[20+i:22+i])[0] for i in range(0, frameDataLen, 2) ] frameData [unpack(\"B\", frame[20+i:21+i])[0] for i in range(0, frameDataLen, 1)] show(frameData, res) del frameData ``` ## streampy ```python from PIL import Image import requests import matplotlib.pyplot as plt import struct import numpy as np import cv2 def frame_config_decode(frame_config): ''' @frame_config bytes @return fields, tuple (trigger_mode, deep_mode, deep_shift, ir_mode, status_mode, status_mask, rgb_mode, rgb_res, expose_time) ''' return struct.unpack(\"<BBBBBBBBi\", frame_config) def frame_config_encode(trigger_mode 1, deep_mode 1, deep_shift 255, ir_mode 1, status_mode 2, status_mask 7, rgb_mode 1, rgb_res 0, expose_time 0): return struct.pack(\"<BBBBBBBBi\", trigger_mode, deep_mode, deep_shift, ir_mode, status_mode, status_mask, rgb_mode, rgb_res, expose_time) def frame_payload_decode(frame_data: bytes, with_config: tuple): deep_data_size, rgb_data_size struct.unpack(\"<ii\", frame_data[:8]) frame_payload frame_data[8:] # 0:16bit 1:8bit, resolution: 320*240 deepth_size (320*240*2) >> with_config[1] deepth_img struct.unpack(\"<%us\" % deepth_size, frame_payload[:deepth_size])[ 0] if 0 ! deepth_size else None frame_payload frame_payload[deepth_size:] # 0:16bit 1:8bit, resolution: 320*240 ir_size (320*240*2) >> with_config[3] ir_img struct.unpack(\"<%us\" % ir_size, frame_payload[:ir_size])[ 0] if 0 ! ir_size else None frame_payload frame_payload[ir_size:] status_size (320*240//8) * (16 if 0 with_config[4] else 2 if 1 with_config[4] else 8 if 2 with_config[4] else 1) status_img struct.unpack(\"<%us\" % status_size, frame_payload[:status_size])[ 0] if 0 ! status_size else None frame_payload frame_payload[status_size:] assert(deep_data_size deepth_size+ir_size+status_size) rgb_size len(frame_payload) assert(rgb_data_size rgb_size) rgb_img struct.unpack(\"<%us\" % rgb_size, frame_payload[:rgb_size])[ 0] if 0 ! rgb_size else None if (not rgb_img is None) and (1 with_config[6]): jpeg cv2.imdecode(np.frombuffer( rgb_img, 'uint8', rgb_size), cv2.IMREAD_COLOR) if not jpeg is None: rgb cv2.cvtColor(jpeg, cv2.COLOR_BGR2RGB) rgb_img rgb.tobytes() else: rgb_img None return (deepth_img, ir_img, status_img, rgb_img) HOST '192.168.233.1' PORT 80 def post_encode_config(config frame_config_encode(), host HOST, port PORT): r requests.post('http://{}:{}/set_cfg'.format(host, port), config) if(r.status_code requests.codes.ok): return True return False def get_frame_from_http(host HOST, port PORT): r requests.get('http://{}:{}/getdeep'.format(host, port)) if(r.status_code requests.codes.ok): # print('Get deep image') deepimg r.content # print('Length {}'.format(len(deepimg))) (frameid, stamp_msec) struct.unpack('<QQ', deepimg[0:8+8]) # print((frameid, stamp_msec/1000)) return deepimg def show_frame(fig, frame_data: bytes): config frame_config_decode(frame_data[16:16+12]) frame_bytes frame_payload_decode(frame_data[16+12:], config) depth np.frombuffer(frame_bytes[0], 'uint16' if 0 config[1] else 'uint8').reshape( 240, 320) if frame_bytes[0] else None ir np.frombuffer(frame_bytes[1], 'uint16' if 0 config[3] else 'uint8').reshape( 240, 320) if frame_bytes[1] else None status np.frombuffer(frame_bytes[2], 'uint16' if 0 config[4] else 'uint8').reshape( 240, 320) if frame_bytes[2] else None rgb np.frombuffer(frame_bytes[3], 'uint8').reshape( (480, 640, 3)) if frame_bytes[3] else None ax1 fig.add_subplot(221) if not depth is None: # center_dis depth[240//2, 320//2] # if 0 config[1]: # print(\"%f mm\" % (center_dis/4)) # else: # print(\"%f mm\" % ((center_dis/5.1) ** 2)) # depth depth.copy() # l,r 200,5000 # depth_f ((depth.astype('float64') l) * (65535 / (r l))) # depth_f[np.where(depth_f < 0)] 0 # depth_f[np.where(depth_f > 65535)] 65535 # depth depth_f.astype(depth.dtype) # depth[240//2, 320//2 5:320//2+5] 0x00 # depth[240//2 5:240//2+5, 320//2] 0x00 ax1.imshow(depth, cmap 'jet_r') ax2 fig.add_subplot(222) if not ir is None: ax2.imshow(ir, cmap 'gray') ax3 fig.add_subplot(223) if not status is None: ax3.imshow(status) ax4 fig.add_subplot(224) if not rgb is None: ax4.imshow(rgb) if post_encode_config(frame_config_encode(1, 1, 255, 0, 2, 7, 1, 0, 0)): # 打开交互模式 plt.ion() figsize (12, 12) fig plt.figure('2D frame', figsize figsize) while True: p get_frame_from_http() show_frame(fig, p) # 停顿时间 plt.pause(0.001) # 清除当前画布 fig.clf() plt.ioff() ``` ## calvolumespy ```python from PIL import Image, ImageDraw import requests import matplotlib.pyplot as plt import struct import numpy as np import cv2 HOST '192.168.233.1' PORT 80 def depth2xyz(xp, yp, z, fx, fy, cx, cy, depth_scale 1000): # h,w np.mgrid[0:depth_map.shape[0],0:depth_map.shape[1]] z z/depth_scale x (xp cx)*z/fx y (yp cy)*z/fy # xyz np.dstack((x,y,z)) # xyz cv2.rgbd.depthTo3d(depth_map,depth_cam_matrix) return [x, y, z] def polygon_area(polygon): area 0 q polygon[ 1] for p in polygon: area + p[0] * q[1] p[1] * q[0] q p return abs(area) / 2.0 def get_lenscoeff(host HOST, port PORT): r requests.get('http://{}:{}/getinfo'.format(host, port)) if(r.status_code requests.codes.ok): lenscoeff_bin r.content (_fx,_fy,_cx,_cy) struct.unpack('<ffff', lenscoeff_bin[41:41+4*4]) # print((frameid, stamp_msec/1000)) return (_fx,_fy,_cx,_cy) diff_low 30 diff_high 500 fx 2.265142e+02 fy 2.278584e+02 cx 1.637246e+02 # cx cy 1.233738e+02 # cy (fx,fy,cx,cy) get_lenscoeff() def cal_volume(d_bk, d_bg): img_h, img_w d_bk.shape[0], d_bk.shape[1] d_bk d_bk.astype(np.float32) # cvt to mm d_bg d_bg.astype(np.float32) diff (d_bg d_bk).astype(np.int16) diff1 diff.copy() diff1 np.where(diff1 < diff_low, 0, diff1) diff1 np.where(diff1 > diff_high, 0, diff1) diff1 (np.where(diff1 > 0, 1, 0)*255).astype(np.uint8) # plt.imshow(diff1) # print(d_bk.shape) (240, 320) output np.zeros((img_h, img_w, 3), np.uint8) num_labels, labels, stats, centroids cv2.connectedComponentsWithStats( diff1, connectivity 8) # print('num_labels ',num_labels) # 连通域的信息：对应各个轮廓的x、y、width、height和面积 # print('stats ',stats) res list() max_stats list() for i in range(5): max_label 1+np.argmax(stats[1:, 4]) # print('stats[max_label] ', stats[max_label]) if i > 0 and stats[max_label][4] < 700: break max_stat stats[max_label] max_stats.append(max_stat) stats[max_label][4] 0 mask (labels max_label) # (np.random.rand(3)*255).astype(np.uint8) output[:, :, :][mask] [200, 0, 0] # plt.imshow(output) # kernel cv2.getStructuringElement(cv2.MORPH_RECT, (3, 3)) # eroded cv2.erode(output, kernel) # dilated cv2.dilate(output, kernel) kernel cv2.getStructuringElement(cv2.MORPH_RECT, (5, 5)) # output dilated output cv2.morphologyEx(output, cv2.MORPH_OPEN, kernel) output cv2.morphologyEx(output, cv2.MORPH_CLOSE, kernel) volumes [] # points [] # areas [] for yp in range(img_h): for xp in range(img_w): if mask[yp, xp]: x1, y1, z1 depth2xyz( xp, yp, d_bk[yp, xp], fx, fy, cx, cy, depth_scale 1) x0, y0, z0 depth2xyz( xp, yp, d_bg[yp, xp], fx, fy, cx, cy, depth_scale 1) x xp 1 if x < 0: x 0 y yp xl, yl, zl depth2xyz( x, y, d_bk[y, x], fx, fy, cx, cy, depth_scale 1) x xp+1 if x > img_w: x img_w 1 y yp xr, yr, zr depth2xyz( x, y, d_bk[y, x], fx, fy, cx, cy, depth_scale 1) x xp y yp 1 if y < 0: y 0 xt, yt, zt depth2xyz( x, y, d_bk[y, x], fx, fy, cx, cy, depth_scale 1) x xp y yp+1 if y > img_h: y img_h 1 xb, yb, zb depth2xyz( x, y, d_bk[y, x], fx, fy, cx, cy, depth_scale 1) area_a polygon_area( [[xt, yt], [xl, yl], [xb, yb], [xr, yr]])/2 dz z0 z1 dx z1/fx dy z1/fy area_b dx*dy*2/2 area (area_a+area_b)/2 # avg get better acc volume area*dz # areas.append(area) volumes.append(volume) # points.append((x1, y1, dz)) # areas np.array(areas) volumes np.array(volumes) # points np.array(points) res.append(\"{}:{} cm3\".format(i, int(np.sum(volumes)/1000))) # print(res) img_pil Image.fromarray(output) draw ImageDraw.Draw(img_pil) for i in range(len(max_stats)): max_stat max_stats[i] draw.rectangle([(max_stat[0], max_stat[1]), (max_stat[0] + max_stat[2], max_stat[1] + max_stat[3])], outline \"red\") draw.text((max_stat[0], max_stat[1]), res[i], fill (255, 255, 255)) output np.array(img_pil) return output def frame_config_decode(frame_config): ''' @frame_config bytes @return fields, tuple (trigger_mode, deep_mode, deep_shift, ir_mode, status_mode, status_mask, rgb_mode, rgb_res, expose_time) ''' return struct.unpack(\"<BBBBBBBBi\", frame_config) def frame_config_encode(trigger_mode 1, deep_mode 1, deep_shift 255, ir_mode 1, status_mode 2, status_mask 7, rgb_mode 1, rgb_res 0, expose_time 0): return struct.pack(\"<BBBBBBBBi\", trigger_mode, deep_mode, deep_shift, ir_mode, status_mode, status_mask, rgb_mode, rgb_res, expose_time) def frame_payload_decode(frame_data: bytes, with_config: tuple): deep_data_size, rgb_data_size struct.unpack(\"<ii\", frame_data[:8]) frame_payload frame_data[8:] # 0:16bit 1:8bit, resolution: 320*240 deepth_size (320*240*2) >> with_config[1] deepth_img struct.unpack(\"<%us\" % deepth_size, frame_payload[:deepth_size])[ 0] if 0 ! deepth_size else None frame_payload frame_payload[deepth_size:] # 0:16bit 1:8bit, resolution: 320*240 ir_size (320*240*2) >> with_config[3] ir_img struct.unpack(\"<%us\" % ir_size, frame_payload[:ir_size])[ 0] if 0 ! ir_size else None frame_payload frame_payload[ir_size:] status_size (320*240//8) * (16 if 0 with_config[4] else 2 if 1 with_config[4] else 8 if 2 with_config[4] else 1) status_img struct.unpack(\"<%us\" % status_size, frame_payload[:status_size])[ 0] if 0 ! status_size else None frame_payload frame_payload[status_size:] assert(deep_data_size deepth_size+ir_size+status_size) rgb_size len(frame_payload) assert(rgb_data_size rgb_size) rgb_img struct.unpack(\"<%us\" % rgb_size, frame_payload[:rgb_size])[ 0] if 0 ! rgb_size else None if (not rgb_img is None) and (1 with_config[6]): jpeg cv2.imdecode(np.frombuffer( rgb_img, 'uint8', rgb_size), cv2.IMREAD_COLOR) if not jpeg is None: rgb cv2.cvtColor(jpeg, cv2.COLOR_BGR2RGB) rgb_img rgb.tobytes() else: rgb_img None return (deepth_img, ir_img, status_img, rgb_img) def post_encode_config(config frame_config_encode(), host HOST, port PORT): r requests.post('http://{}:{}/set_cfg'.format(host, port), config) if(r.status_code requests.codes.ok): return True return False def get_frame_from_http(host HOST, port PORT): r requests.get('http://{}:{}/getdeep'.format(host, port)) if(r.status_code requests.codes.ok): # print('Get deep image') deepimg r.content # print('Length {}'.format(len(deepimg))) (frameid, stamp_msec) struct.unpack('<QQ', deepimg[0:8+8]) # print((frameid, stamp_msec/1000)) return deepimg def show_frame(fig, frame_data: bytes): config frame_config_decode(frame_data[16:16+12]) frame_bytes frame_payload_decode(frame_data[16+12:], config) depth np.frombuffer(frame_bytes[0], 'uint16' if 0 config[1] else 'uint8').reshape( 240, 320) if frame_bytes[0] else None # ir np.frombuffer(frame_bytes[1], 'uint16' if 0 config[3] else 'uint8').reshape( # 240, 320) if frame_bytes[1] else None # status np.frombuffer(frame_bytes[2], 'uint16' if 0 config[4] else 'uint8').reshape( # 240, 320) if frame_bytes[2] else None rgb np.frombuffer(frame_bytes[3], 'uint8').reshape( (480, 640, 3)) if frame_bytes[3] else None ax1 fig.add_subplot(122) if not depth is None: # center_dis depth[240//2, 320//2] # if 0 config[1]: # print(\"%f mm\" % (center_dis/4)) # else: # print(\"%f mm\" % ((center_dis/5.1) ** 2)) # depth depth.copy() # l,r 200,5000 # depth_f ((depth.astype('float64') l) * (65535 / (r l))) # depth_f[np.where(depth_f < 0)] 0 # depth_f[np.where(depth_f > 65535)] 65535 # depth depth_f.astype(depth.dtype) # depth[240//2, 320//2 5:320//2+5] 0x00 # depth[240//2 5:240//2+5, 320//2] 0x00 if not UPDATE_BG[1] is None: ax1.imshow(cal_volume(depth, UPDATE_BG[1])) else: ax1.imshow(depth) if UPDATE_BG[0]: UPDATE_BG[1] depth # ax2 fig.add_subplot(222) # if not ir is None: # ax2.imshow(ir, cmap 'gray') # ax3 fig.add_subplot(223) # if not status is None: # ax3.imshow(status) ax4 fig.add_subplot(121) if not rgb is None: ax4.imshow(rgb) UPDATE_BG [False, None] if post_encode_config(frame_config_encode(1, 0, 255, 0, 2, 7, 1, 0, 0)): # 打开交互模式 def on_key_press(event): if event.key ' ': UPDATE_BG[0] True elif event.key 'c': UPDATE_BG[1] None plt.ion() figsize (12, 12) fig plt.figure('2D frame', figsize figsize) fig.canvas.mpl_connect('key_press_event', on_key_press) print(\"按下空格键更新背景图，按下c键清空背景图\") while True: p get_frame_from_http() show_frame(fig, p) if UPDATE_BG[0]: UPDATE_BG[0] False print(\"update bg success!\") # 停顿时间 plt.pause(0.001) # 清除当前画布 fig.clf() plt.ioff() ```"},"/hardware/zh/maixsense/maixsense-a010/maixsense-a010.html":{"title":"MaixSense-A010","content":"# MaixSense A010 时间 负责人 更新内容 : : : : : : 2022.09.10 lyx 初次编写文档 2022.11.12 lyx 补充细节 ## 产品概述 ![ms_small](./assets/ms_s.jpg) **MaixSense A010** 是 **SIPEED** 推出由 **BL702** + 炬佑 **100x100 TOF** 所组成的 **3D** 传感器模组，最大支持 **100x100** 的分辨率和 **8** 位精度并自带 **240×135** 像素的 **LCD** 屏可实时预览 **colormap** 后的深度图。 ### 资料汇总 硬件资料：[点击查看下载](https://dl.sipeed.com/shareURL/MaixSense/MaixSense_A010) Github：[点击查看](https://github.com/sipeed/MaixSense_ROS) ## 产品开箱指南 ### 准备工作 **MaixSense A010** 采用串口协议对外提供接口以及传输数据。 我们提供的物理接口有 type c（虚拟串口）及 1.0mm 4pin 母座（UART）都能获取深度图数据用于集成. **产品接线说明** 通过 type c 接口连接 PC 端后，可以识别到 `/dev/ttyUSBx（Linux）`或 `COMx（Windows)`. ![ms_pinb](./assets/ms_pinb.jpg) 还可通过 usb2ttl 模组按照硬件引脚图（设备屏幕正面朝下）连接 4pin 母座。 <html> <img src \"./assets/ms_pin.jpg\" width 48%> <img src \"./asstes/../assets/ms_pinc.jpg\" width 48%> </html> <table> <tr> <td>MS A010</td> <td>TX</td> <td>RX</td> <td>GND</td> <td>5V</td> </tr> <tr> <td>usb2ttl 模块</td> <td>RX</td> <td>TX</td> <td>GND</td> <td>5V</td> </tr> </table> ### 上电互动预览 **按键功能**：左侧为“下一个”右侧为“切换”. **屏幕显示**：屏幕中心的 **+** 字是测距点，右上方会实时显示 **xx cm** 代表测距的距离。如镜头前近处有大面积物体时屏幕右上会显示 **“block!”**而其他情况为 **“open!”**. 将设备接入电源后，可在设备上自带 LCD 屏实时预览 color map 后的深度伪彩图。 ![ms_lcd](./assets/ms_lcd.jpg) ### PC 互动预览 在 PC 端上预览修改配置前需要先安装上位机软件 COMTOOL. **COMTOOL/Windows 系统**：[点击下载](https://dl.sipeed.com/shareURL/MaixSense/MaixSense_A010/software_pack/comtool) **COMTOOL/Linux 系统**：[需用户自行编译/点击跳转](https://github.com/sipeed/MetaSense ComTool) >注意：Win 7 及以下系统需装驱动，可自行前往 FTDI 官网下载。 打开 COMTOOL 软件后选择 `Graph` 界面，如果软件上方无 `Graph` 的话可在右上角 **+** 号处添加 `Graph`，创建后若居中部分为白无图，则**双击**左下角 `MaixSenseLite` 即可打开界面显示端口。 ![ms_comtool](./assets/ms_comtool.jpg) 在左侧 `Port` 选择小的端口和对应波特率（任意选择高波特率），点击 `open` 后再勾选下方 `USB` 即可接收大量数据,左下角处会显示 **Connected**. ![ms_comtool_two](./assets/ms_comtoolt.jpg) 设定 `Header` 为 `\\x00\\xFF` 即可解析正确的图像数据并观察到深度图，可以直观感受二维平面图像上的深度。 ![ms_comtoolh](./assets/ms_comtoolh.jpg) ### 互动配置说明 COMTOOL 上位机的配置控件说明 **Header**：设置识别包头 **RawCMD**：用户可以手动发送指令（USB 和 UART 串口行为相同） **ISP**：启动停止 **LCD**：显示自带屏的开启关闭 **USB**：串口传输深度图开启关闭 **UART**：串口传输深度图开启关闭 **ANTIMMI**：自动抗多机干扰开启关闭（易受干扰，关闭的效果都要更好些） **Binn**：可下拉设置 BINNING，Baud 设置 UART 波特率 **X、Y**：设置坐标：D 左侧多选框开启后显示出该摄像头的距离。 **Unit**：设置量化单位（16位量化到8位，比例缩小，设置太小的话会只能看清很近处的影像） **FPS**：设置出图帧率（不宜过高，根据对接设备的性能合理设置即可，减小帧率可以减少传输数据量） **Ev**：曝光间隙控制（最左代表 AE，其他是固定曝光时间） ## 案例：远近中物体实拍 设备自带 **LCD** 屏上电后可实时观察到远近中物体的深度值差异。 物体不同的放置位置形成距离的差异，设备捕捉到差异后转化为深度值并因距离的远近显示冷暖色调。 ![ms_](./assets/ms_carton.jpg) ## 案例：检测人流 实时高精度，大分辨率的监测人流量走动的情况并且快速统计出数据。 ![ms_people](./assets/ms people.jpg) >例程源码暂时还未开源，待整理公开。 ## 案例：键盘灯跟随 实现超酷炫的键盘灯跟随，设备实时跟踪手部的位置变化，再根据手部的位置映射键盘灯。 **键盘灯相关代码支持**：[点击查看](https://dl.sipeed.com/shareURL/others/maixsense_example) ![ma_lamp](./assets/ms_lamp.jpg) ## 案例：接入 MCU 因 **MaixSense A010** 拥有强大的兼容性，可基于串口协议外接 **K210 Maix bit** 这样的 **AIOT** 开发板或树莓派之类的 **Linux** 开发板来进行二次开发，为了方便用户的使用我们开放接入例程。 .. details::点击查看 K210 Maix Bit 介绍 Maix Bit 是 sipeed Maix 中产品线的一员，基于嘉楠堪智科技的边缘智能计算芯片 K210 设计的一款 AIOT 开发板。以 K210 作为核心单元，功能非常很强大，芯片内置 64 位双核处理器，拥有 8M 的片上 SRAM，在Al机器视觉、听觉性能方便表现突出，内置多种硬件加速单元(KPU、FPU，FFT等)，总算力最高可达 1TOPS，可以方便地实现各类应用场景的机器视觉/听觉算法,也可以进行语音方向扫描和语音数据输出的前置处理工作。 ![bit](./../../../../soft/maixduino/assets/BiT.png) **Maix Bit 购买传送门**：[点击查看](https://item.taobao.com/item.htm?spm a230r.1.14.11.681570a1yq4sJD&id 586580351110&ns 1&abbucket 10&mt ) **Maix Bit 资料传送门**：[更多详细资料](https://wiki.sipeed.com/hardware/zh/maix/maixpy_develop_kit_board/maix_bit.html) **Maix Bit 源码传送门**：[点击查看](./maixsense a010/../code.html#tof_mainpy) <! **MaixSense A010 外接 Maix Bit 例程**：[点击查看](http://wiki.sipeed.com/hardware/zh/maixsense/maixsense a010/mcu.html) > ![ms_mcu](./assets/ms_mcu.jpg) ## 二次开发：串口协议 可参考上方的案例：**MS A010 外接 K210 bit** **Host USB 源码传送门**：[点击查看](./code#tof_main_hostpy) **MaixSense A010 串口协议传送门**：[点击查看](http://wiki.sipeed.com/hardware/zh/maixsense/maixsense a010/at_command.html) ## 二次开发：接入 ROS ### 接入 ROS1 **1. 准备工作** 运行 ROS 前我们要准备适用的环境：`Linux` 系统。 可使用虚拟机 `virtual box` 或者 `vmware`：[点击获取](https://www.vmware.com/cn/products/workstation player/workstation player evaluation.html) 也可以自行安装双系统，安装方法请自行搜索或参考右侧：[双系统安装教程](https://neucrack.com/p/330) **2. 安装运行** ROS 接入包：[点击前往下载](https://dl.sipeed.com/shareURL/MaixSense/MaixSense_A010/software_pack/SDK) ```bash #解压缩 sipeed_tof_ms_a010.zip，并进入目录 cd ros1 source /opt/ros/*/setup.sh catkin_make source devel/setup.sh rosrun sipeed_tof_ms_a010 a010_publisher _device: \"/dev/ttyUSB0\" #之后终端会持续刷新显示[sipeed_tof]: Publishing，即正常工作 ``` ![ros_adb](./assets/ros_adb.jpg) **3. 可自行在 RQT 查看帧率** ![ms_rosone](./assets/ms_rosone.jpg) **4. RVIZ2 预览** 打开 `rviz2` 后，在界面左下角的 `Add` >`By topic` >`PointCloud2或/depth` >`Image 添加` >`Display/Global Options/Fixed Frame` 需要修改成 `tof`，才能正常显示点云，根据添加的内容，左侧会显示 `Image` 而中间则显示点云。 ![ms_rviz](./assets/ms_rviz.jpg) ### 接入 ROS2 **1. 准备工作** 运行 ROS 前我们要准备适用的环境：`Linux` 系统。 可使用虚拟机 `virtual box` 或者 `vmware`：[点击获取](https://www.vmware.com/cn/products/workstation player/workstation player evaluation.html) 也可以自行安装双系统，安装方法请自行搜索或参考右侧：[双系统安装教程](https://neucrack.com/p/330) > 如果环境同时安装了 ROS1，使用 ROS2 的话需要选额外择正确的版本。 ```bash ls /opt/ros ros@ros virtual machine:~/Desktop$ ls /opt/ros noetic rolling ``` **2. 安装运行** 我们提供了 ROS2 的接入功能包，用户需要在运行 ROS2 的系统上编译安装。 ROS 接入包：[点击前往下载](https://dl.sipeed.com/shareURL/MaixSense/MaixSense_A010/software_pack/SDK) ```bash #解压缩sipeed_tof_ms_a010.zip，并进入目录 cd ros2 source /opt/ros/*/setup.sh colcon build #（如提示缺少colcon时需要sudo apt install python3 colcon ros） source install/setup.sh ros2 run sipeed_tof_ms_a010 publisher ros args p device: \"/dev/ttyUSB0\" #之后终端会持续刷新显示[sipeed_tof]: Publishing，即正常工作 ``` **3. RQT 查看帧率** ![ms_rqt](asstes/../asstes/../assets/ms_rqt.jpg) **4. RVIZ2 预览** 打开 `rviz2` 后，在界面左下角的 `Add` >`By topic` >`PointCloud2或/depth` >`Image 添加` >`Display/Global Options/Fixed Frame` 需要修改成 `tof`，才能正常显示点云，根据添加的内容，左侧会显示 `Image` 而中间则显示点云。 ![ms_ros](assets/ms_ros.jpg)"},"/hardware/zh/maixsense/maixsense-a010/at_command.html":{"title":"MaixSense-A010 二次开发手册","content":"# MaixSense A010 二次开发手册 ## AT 指令表 AT                                                                                                                                                                                                                                             +ISP<br>Image Signal Processor :0: turn ISP off<br> 1: turn ISP on                                                                                                                                                                             +BINN<br>full binning           1: output 100x100 pixel frame<br> 2: output 50x50 pixel frame<br> 4: output 25x25 pixel frame<br>                                                                                                             +DISP<br>display mux           0: all off<br> 1: lcd display on<br> 2: usb display on<br> 3: lcd and usb display on<br> 4: uart display on<br> 5: lcd and uart display on<br> 6: usb and uart display on<br> 7: lcd, usb and uart display on +BAUD<br>uart baudrate         0: 9600<br> 1: 57600<br> 2: 115200<br> 3: 230400<br> 4: 460800<br> 5: 921600<br> 6: 1000000<br> 7: 2000000<br> 8: 3000000                                                                                     +UNIT<br>quantization unit     0: auto<br> 1 10: quantizated by unit(mm)                                                                                                                                                                     +FPS<br>frame per second       1 19: set frame per second                                                                                                                                                                                     +Save<br>save config           : save current configuration                                 句法： 输入执行注释 AT+ISP? \\r返回当前ISP状态 AT+ISP ? \\r返回所有支持的ISP状态 AT+ISP < MODE >\\r选择ISP状态 参数： < MODE > 含义 0 \"STOP ISP\" 立即关闭模组ISP，停止IR发射器 1 \"LAUNCH ISP\" 计划启动模组ISP，实际出图需等待1～2秒 ### BINN指令 句法： 输入 执行 注释 AT+BINN? \\r 返回当前BINN状态 AT+BINN ? \\r 返回所有支持的BINN状态 AT+BINN < MODE > \\r 选择BINN状态 参数： < MODE > 含义 1 \"1x1 BINN\" 1x1相当于无binning，实际出图分辨率为100x100。 2 \"2x2 BINN\" 2×2binning，4个像素点合并成1个，实际出图分辨率为50×50计划启动模组ISP，实际出图需等待1～2秒。 4 \"4x4 BINN\" 4×4binning，16个像素点合并成1个，实际出图分辨率为25×25。 ### DISP指令 请按需开启，避免资源过度占用 句法： 输入 执行 注释 AT+DISP? \\r 返回当前DISP状态 AT+DISP ? \\r 返回所有支持的DISP状态 AT+DISP < MODE > \\r 选择DISP状态 参数： < MODE > 含义 0 all off 1 lcd display on 2 usb display on 3 lcd and usb display on 4 uart display on 5 lcd and uart display on 6 usb and uart display on 7 lcd, usb and uart display on ### BAUD指令 句法： 输入 执行 注释 AT+BAUD? \\r 返回当前BAUD状态 AT+BAUD ? \\r 返回所有支持的BAUD状态 AT+BAUD < MODE > \\r 选择BAUD状态 参数： < MODE > 含义 0 9600 1 57600 2 115200 3 230400 4 460800 5 921600 6 1000000 7 2000000 8 3000000 ### UNIT指令 句法： 输入 执行 注释 AT+UNIT? \\r 返回当前UNIT值 AT+UNIT ? \\r 返回所有支持的UNIT值 AT+UNIT < UINT > \\r 选择UNIT值 参数： < UINT > 含义 0 \"DEFAULT UNIT\" 采用默认量化策略，因tof特性导致成像近处精度优于远距离处，故放大近距离处差异，采用5.1*sqrt(x)将16bit的原数据量化为8bit 1...9 \"QUANTIZE UNIT\" 代表以x mm为单位进行量化，取值越小细节越多，同时可视距离越短，请合理设置 ### FPS指令 句法： 输入 执行 注释 AT+FPS? \\r 返回当前FPS值 AT+FPS ? \\r 返回所有支持的FPS值 AT+FPS <FPS> \\r 选择FPS值 参数： < FPS > 含义 1...19 \"frame per second\" tof出图帧率，越大越流畅 ### SAVE指令 句法： 输入 执行 注释 AT+SAVE \\r 固化TOF摄像头当前配置，事后需要复位 多机和 AE 指令建议加入 ### ANTIMMI指令 句法： 输入 执行 注释 AT+ANTIMMI? \\r 返回当前ANTIMMI状态 AT+ANTIMMI ? \\r 返回所有支持的ANTIMMI状态 AT+ANTIMMI < MODE > \\r 选择ANTIMMI状态 参数： < MODE > 含义 1 disable anti mmi 0 auto anti mmi 1 41 manual anti mmi usb display on ### 图像数据包说明 上电默认启动ISP并在显示屏显示图像，同时输出图像数据到uart和usb 图像数据封装成包（未稳定）： 1. 包头2字节：0X00、0XFF 2. 包长度2字节：当前包剩余数据的字节数 3. 其他内容16字节：包括包序号、包长度、分辨率等等 4. 图像帧 5. 校验1字节：之前所有字节的“和”低八位 6. 包尾1字节：0XDD AT+UNIT? 可查询当前UNIT值。 设p为图像帧各像素值，主要有以下两种情况： 若UNIT非0，则该像素离TOF距离计算方法为 `p` x `UNIT` ; 若UNIT为0，则该像素离TOF距离计算方法为 (`p`/5.1)^2 。"},"/hardware/zh/maixsense/maixsense-a075v/maixsense-a075v.html":{"title":"MaixSense-A075V","content":"# MaixSense A075V 时间 负责人 更新内容 : : : : : : 2022.08.10 lyx 初次编写文档 2022.11.15 lyx 补充细节 ## 产品概述 ![mt_big](asstes/../assets/mt_big.jpg) **MaixSense A075V** 是一款具有 **320x240** 分辨率及 **RGB** 功能的 **3D TOF** 摄像机模组， 支持 **Linux** 下免驱的即插即用，可通过上位机显示彩色 **3D** 画面并记录点云 ## 产品开箱指南 ### 准备工作 在 Windows 系统上运行预览 **MaixSense A075V** 的话需要安装驱动。 **Windows 安装驱动教程**：[点击查看](./install_drivers.html) ### 网页上位机预览 >**注意**：模组上电前一定要确保网络环境中没有使用 `192.168.233.0/24` 的地址段， >**MaixSense A075V** 会使用 **RNDIS** 并设置自己的 `iP` 地址为 `http://192.168.233.1`. ![tof 07514](asstes/../assets/mt_pin.jpg) 根据上图将模组通电接入 `PC` 端，这时自带的风扇会开始工作以及镜头处会显示有蓝灯在闪烁，选择浏览器输入 `http://192.168.233.1` 预览 3D 点云图，上电后有延迟等待 `10s 15s` 系统和程序才会启动完成。 **使用网页上位机快速预览（正面和侧面）：** <html> <img src \"./assets/mt_examle.jpg\" width 48%> <img src \"./assets/mt_examleb.jpg\" width 48%> </html> 可选预览深度伪彩点云，取消勾选页面右侧的交互面板上的第一行 `RGB_Map` 即可。 ![mt_examlec](assets/mt_examlec.jpg) ### 互动配置 网页上位机交互面板提供了一系列配置和功能，可以实时预览变动的效果。 ![mt_examled](assets/mt_examled.jpg) **交互面板控件说明** **RGB_Map**：多选框 开关 RGB 映射，即关闭时只显示深度伪彩点云，打开时显示 RGB 映射点云。 **colorMap**：下拉栏 提供了几个伪彩映射选项(即 cmap )，推荐使用 jet，RGB_Map 关闭时有效。 **deepRangeMax** 和 **deepRangeMin** 滑动条是设定 cmap 的映射范围的，即只有位于 deepRangeMin 和 deepRangeMax 之间的数值（深度值）会通过 cmap，RGB_Map 关闭时有效。 **NormalPoint**：多选框 开关显示正常点（TOF 成像会有无效点，对应的相反描述），需要打开。 **OE_Points**：多选框 开关显示 OE 点，建议关闭。 **UE_Points**：多选框 开关显示 UE 点，建议关闭。 **Bad_Points**：多选框 开关显示无效点，建议关闭。 **SpatialFilter**：多选框 开关空间滤波，基于下面的 SpatialFilterSize 值和 SpatialFilterType 指定的算法进行处理。 **TemporalFilter**：多选框 开关时间滤波，基于下面的 TemporalFilteralpha 值做了一个时间上的平均。 **TemporalFilteralpha**：滑动条 设定时间滤波所需时长，适中即可，可自行尝试体验其它效果。 **SpatialFilterType**：下拉栏 设定空间滤波算法，提供高斯滤波（Gaussian）和双边滤波（Bilateral），双边滤波性能要求较高，不建议使用。 **SpatialFilterSize**：滑动条 设定空间滤波所需范围，适中即可，可自行尝试体验其它效果。 **FlyingPointFilter**：多选框 开关飞点过滤，基于下面的 FlyingPointThreshold 值作为过滤阈值，超过阈值的将被过滤掉，建议适中配置，否则有效点也会被剔除。 ### 保存数据 网页版上位机控件栏最下方提供两个按钮，用户可根据以下的说明去使用。 **SaveRaw**：可保存一帧 raw 数据，如果需要使用深度或 IR 或 RGB 数据进行二次开发的话，则需要了解 raw 的数据结构。不过我们也提供详细的 `jupyter notebook` 供用户和开发者使用和了解 raw 数据的处理过程。 **SavePointCloud**：可保存一帧 3D 点云图，保存格式为 `pcd` ，同样可以通过上述提供的脚本预览。 >注意：**raw** 数据可通过开放的接口获取，开发者进行解析即可基于此二次开发，但点云 **pointcloud** 是基于 **raw** 数据和相机内参进行计算得到的，无相应接口提供。 ### SSH 登录 除了直接使用网页上位机进行预览，我们还可以使用 SSH 进行登录操作。 .. details::点此展开查看 MobaXterm 介绍 MobaXterm 是在 Windows 下使用的全能终端管理软件，而 Linux 系统可以使用 ssh 远程被操作，使用 MobaXterm 进行 ssh 登陆板子直接编辑板内的代码或执行命令，也能方便的拖拽文件上传或下载到电脑里，类似的工具还有 vscode remote 远程登录 linux 服务器。 ![mobaxterm_ssh](./../../maixIII/assets/ssh.jpg) **MobaXterm**：[点击前往下载](mobaxterm.mobatek.net/download) 分别有付费与免费双版本，下载免费版本即可。 **MobaXterm 使用例程**：[点击查看](https://wiki.sipeed.com/hardware/zh/maixII/M2/tools/mobaxterm.html?highlight ssh) 根据上面网页预览的画面可以知道所使用的 ip 为 `192.168.233.1`, 所以我们可以使用这个 ip 和登录密码 `root` 来登录到 TOF 模组的终端系统中。 Windows：参照上文例程使用模组自带的 `ip` 地址 `192.168.233.1` 进行登录。 Linux：使用登录密码 `root` 直接使用以下的命令行登录终端进行操作。 ```bash ssh root@192.168.233.1 ``` ### 固件更新 替换 `/root/maix_dist` 下对应的文件即可。 [点击下载更新文件](https://dl.sipeed.com/shareURL/MaixSense/MaixSense_A075V/03_Firmware) ## 案例：远中近点云实拍 高精度的映射物品摆放距离的差异，点云图可直观清楚感受到更真实的可视化。 ![mt_cloud](assets/mt_cloud.jpg) ## 案例：避障小车 模组可搭载小车或无人机来回移动获取障碍物的远近深度值，并通过差异判断画面中是否有障碍物，做出快速反应并精准规避障碍物。 ![me_car](./../assets/me_car.jpg) >例程暂未开源，待整理公开 ## 案例：检测人流 可实时监控人流，进行更高精度以及大分辨率的统计。 ![me_pt](./../assets/me_pt.jpg) >例程暂未开源，待整理公开。 ## 二次开发：SDK 支持 ### python SDK 这是基于 `python 3` 软件开发工具包，MaixSense A075V 对外开发了 `http` 接口，我们可通过 `http` 请求获取到原生数据（包括深度图，ir 图，rgb 图），为了方便用户理解数据包的结构及获取还有解码的相关逻辑，因此我们提供封装了 `http` 请求和原生数据的解码相关函数，用户基于此可进行二次开发。 **SDK 获取方式**：[点击下载](https://dl.sipeed.com/fileList/others/maixsense_example/maixsense_075_tutorial.ipynb) **使用方式**：安装 `jupyter` 后连接模组打开我们提供的 `toturial.py` 即可。 ### 解包推流 理解了上述 `python SDK` 数据获取和解码的逻辑后，我们可以尝试进阶版，连续获取解码并调用第三方 `python` 图像库。例如：`matplotlib` 进行实时显示，而 `toturial.py` 给出了获取一帧数据的逻辑实现，通过 `plt` 显示并外套循环即可做到实时显示。 **解包推流**：[点此展开查看 stream.py 内容](./../maixsense a010/code.html#streampy) **使用方式**：装好所有的依赖包后即可 `python stream.py` 运行。 ![mt_sdk](assets/mt_sdk.jpg) ### 检测体积 基于第三方 `python` 包，理解了上述数据获取和解码的逻辑后再次进阶， 持续显示多帧并且再通过 `SDK` 获取模组内参数计算出粗略的点云，并进行累加得到物品的总体积。 >限制：要求俯视图可以看到除底面外的所有细节 **检测体积**：[点此展开查看 calVolumes.py 内容](./../maixsense a010/code.html#calvolumespy) **使用方式**：装好所有的依赖包后即可 `python calVolumes.py` 运行，命令行有后续操作提示。 ![mt_volumbs](assets/mt_volumbs.jpg) ## 二次开发：接入 ROS > 首先需要根据自己电脑安装对应版本的 ROS ### 接入 ROS1 **1. 准备工作** 运行 ROS 前我们要准备适用的环境：`Linux` 系统。 可使用虚拟机 `virtual box` 或者 `vmware`：[点击前往下载](https://www.vmware.com/cn/products/workstation player/workstation player evaluation.html) 也可以自行安装双系统，安装方法请自行搜索或参考右侧：[双系统安装教程](https://neucrack.com/p/330) **2. 安装运行** ROS1 接入包：[点击前往下载](https://dl.sipeed.com/shareURL/MaixSense/MaixSense_A075V/software/SDK) ```bash #解压缩sipeed tofv075 ros.zip，并进入目录 source /opt/ros/*/setup.sh catkin_make source devel/setup.sh rosrun sipeed_tof_cpp publisher #之后终端会持续刷新命令行 ``` ![mt_adb](./assets/mt_adb.jpg) **3. 可自行在 RQT 查看帧率** ![mt_rqta](./assets/mt_rqta.jpg) **4. RVIZ 预览** 打开 `rviz2` 后，在界面左下角的 `Add` >`By topic` >`PointCloud2或/depth` >`Image 添加` >`Display/Global Options/Fixed Frame` 需要修改成 `tof` 才能正常显示点云，根据添加的内容左侧会显示 **Image** 而中间则显示点云。 ![mt_ros](assets/mt_ros.jpg) ### 接入 ROS2 **1. 准备工作** 运行 ROS 前我们要准备适用的环境：`Linux` 系统。 可使用虚拟机 `virtual box` 或者 `vmware`：[点击获取](https://www.vmware.com/cn/products/workstation player/workstation player evaluation.html) 也可以自行安装双系统，安装方法请自行搜索或参考右侧：[双系统安装教程](https://neucrack.com/p/330) **2. 安装运行** 我们提供了 ROS2 的接入功能包，用户需要在运行 ROS2 的系统上编译安装。 ROS2 接入包：[点击前往下载](https://dl.sipeed.com/shareURL/MaixSense/MaixSense_A075V/software/SDK) ``` bash #解压缩sipeed tofv075 ros2.zip，并进入目录 source /opt/ros/*/setup.sh colcon build #（如提示缺少colcon时需要sudo apt install python3 colcon ros） source install/setup.sh ros2 run sipeed_tof_cpp publisher #之后终端会持续刷新显示[sipeed_tof]: Publishing，即正常工作 ``` **3. RQT 查看帧率** 打开 `RQT` 后选择 `Plugins` >`Topics` >`Topic Monitor`。 ![mt_rqt](asstes/../assets/mt_rqt.jpg) **4. RVIZ2 预览** 打开 `rviz2` 后，在界面左下角的 `Add` >`By topic` >`PointCloud2` 或 `/depth、/intensity、/rgb` >`Image 添加` >`Display/Global Options/Fixed Frame` 需要修改成 `“tof”` 才能正常显示点云。根据添加的内容左侧会显示 **Image** 而中间则显示点云。 **伪彩点云和 RGBD 融合的点云效果：** <html> <img src \"./assets/mt_rosb.jpg\" width 48%> <img src \"./assets/mt_rosc.jpg\" width 48%> </html>"},"/hardware/zh/maixsense/maixsense-a075v/install_drivers.html":{"title":"安装 RNDIS 驱动","content":"# 安装 RNDIS 驱动 > 编辑于 2022年8月9日 ## 说明 RNDIS 全称为 Remote Network Driver Interface Specification，即远程网络驱动接口规范，是在 USB 设备上跑 TCP/IP 一种规范。 ## 相关操作 在 Windows7 及其以上的操作系统中，均已经内置了 RNDIS，但是如果不进行一些特殊操作的话，电脑一般是识别不到相关符合 RNDIS 设备的。 ### 下载驱动 <! **Windows 驱动**：[点击获取](https://dl.sipeed.com/shareURL/MaixSense/Drivers) > **Windows 驱动**：[点击获取](https://dl.sipeed.com/fileList/MaixSense/Drivers/Ethernet_RNDIS_drivers_20220808.zip) ### 安装驱动 将目标设备与电脑通过 USB 接口连接起来，且能够在电脑的设备管理器中看到串行设备。如果没有看到有串行设备的话大概率是供电不足所导致的：对于台式机建议使用主机背部的 USB 接口；使用 USB hub 的话建议使用带有额外供电的；另外建议使用 USB 3.0 的数据口，因为 USB 2.0 驱动供电可能不足。 ![串行设备](./assets/install_drivers/serial.png) 右键它，选择更新驱动程序，接着在下面的界面中选择更新驱动程序 ![更新驱动](./assets/install_drivers/update.png) 这里我们选择下面的 `让我从计算机上的可用驱动列表中选出(L)` ![选择驱动](./assets/install_drivers/scan.png) 接着对于下面的图我们选择偏右下方的 `从磁盘安装(H)...` ![从磁盘安装](./assets/install_drivers/install.png) 然后在下面的对话框中选择右下角的浏览 ![浏览](./assets/install_drivers/path.png) 选中我们所下载且解压之后的文件夹里面，选择一个 .inf 文件后，点击右下角的 `打开` ![inf](./assets/install_drivers/inf.png) 接着会回退到下面的界面，这里直接右下角的点击下一页即可 ![下一页](./assets/install_drivers/next.png) 然后就会显示已经更新驱动了 ![结束安装驱动](./assets/install_drivers/finish.png) 重新拔插 USB 设备后，等待大概十秒左右，可以在系统的设备管理器里网络适配器中看到看到有 `RNDIS/Ethernet Gadget`，到此已经成功安装驱动了"},"/hardware/zh/maixsense/index.html":{"title":"MaixSense 系列","content":" title: MaixSense 系列 ## MaixSense 是什么? MaixSense 系列产品搭载 TOF 深度摄像头，目前有 MaixSense A010 和 MaixSense A075V 两款产品。 MS A010 是一款由 BL702 + 炬佑 100x100 TOF 模组所组成的极致性价比的 TOF 3D 传感器模组，最大支持 100x100 的分辨率和 8 位精度，并且带有 240×135 的 LCD 显示屏可实时预览 color map 后的深度图。 而 MS A075V 是一款具有 RGB 功能的 3D TOF 摄像机模组，该模组可以实现 Linux 免驱的即插即用，实现实时彩色 3D 显示。 <img src \"./assets/meta.jpg\" alt \"summary\" width 100%> 购买方式：[淘宝链接](https://item.taobao.com/item.htm?id 684566484141) <p style \"white space:nowrap\">MaixSense A010</p> <p style \"white space:nowrap\">MaixSense A075V</p> : : : ![me small](./assets/me_small.jpg) ![me big](./assets/me_big.jpg) 接口 1.25mm 串口连接器 \\*1<br>Type C USB2.0 \\*1 1.25mm 串口连接器 \\*1 <br>Type C USB2.0 \\*1 分辨率 TOF：100x100@30fps RGB：1600x1200@30fps<br>TOF：320x240@60fps 视场角 RGB：无<br>TOF：70°(H) * 60°(V) RGB：120°<br>TOF：55°(H)*72°(H) <p style \"white space:nowrap\">TOF 像素尺寸</p> 15um 激光发射器 40nm VCSEL 940nm,3W 测量范围 0.2 2.5m 0.15 1.5m 测量精度 &lt; 1%/cm &lt; 1%/cm ## MaixSense 能做什么？ ### 案例：远中近物体实拍 高精度的映射物品摆放距离的差异，点云图可直观感受到更真实的可视化。 <html> <img src \"./maixsense a010/assets/ms_cloud.jpg\" width 48%> <img src \"./maixsense a075v/assets/mt_cloud.jpg\" width 48%> </html> ### 案例：人流统计 可实时监控人流，进行高精度、大分辨率的统计。 <html> <img src \"./assets/me_p.jpg\" width 48%> <img src \"./assets/me_pt.jpg\" width 48%> </html> ### 案例：小车避障 可搭载于小车移动并判断画面是否有障碍物，模组自带 LCD 屏幕精准显示距离并做出反应规避障碍物。 ![me_car](./assets/me_car.gif) ### 案例：键盘灯跟随 实现超酷炫的键盘灯跟随，实时跟踪手部的位置，再根据手部的位置映射键盘灯。 ![ms_lamp](./maixsense a010/assets/ms_lamp.jpg) ### 案例：体积测量 通过 SDK 获取到的模组内参数后，计算粗略点云并累加总体积，达到体积测量的效果。 ![mt_volume](./maixsense a075v/assets/mt_volumbs.jpg) ### 案例：外接 MCU MS A010 拥有强大的兼容性，基于串口协议的数据传输。 可外接 K210 bit 这样的单片机开发板或树莓派之类的 linux 开发板来进行二次开发。 ![ms_mcu](./maixsense a010/assets/ms_mcu.jpg) ### 案例：接入 ROS1 + ROS2 双支持 ROS 系统，开放 ROS1+ROS2 接入功能包，可快速获得深度数据及深度图。 <html> <img src \"./assets/me_ross.jpg\" height 250 width 49%> <img src \"./assets/me_rosb.jpg\" width 49% height 250> </html> ## 快速了解 TOF 技术 1. TOF: 是一种距离测量的方法，通过测量发射器和反射器之间的超声波/微波/光等信号的“飞行时间”来计算两者之间的距离。 可以实现TOF测距的是TOF传感器。 最常用的是红外线或激光测距。 2. 物体之间的距离存在差异。 该模块通过捕获的深度值的差异来显示冷色和暖色。冷暖色随着距离的映射而变化，距离越近色调呈暖调（橘红）而越远色调呈冷调（蓝色）。 <html> <img src \"./assets/tof_two.jpg\" height 250 width 49%> <img src \"./assets/tof.jpg\" width 49% height 250> </html> ## 更多 关于 MS 010 更详细的资料获取：[点击跳转](https://wiki.sipeed.com/hardware/zh/maixsense/maixsense a010/maixsense a010.html) 关于 MS 075 更详细的资料获取：[点击跳转](https://wiki.sipeed.com/hardware/zh/maixsense/maixsense a075v/maixsense a075v.html)"},"/hardware/zh/cluster/NanoCluster/nomad_playbook.html":{"title":"Nomad 自动化部署","content":" title: Nomad 自动化部署 ## 简介 [**nomad playbook**](https://github.com/caiodelgadonew/nomad playbook) 是一个使用 Ansible 编写的自动化部署脚本，旨在快速搭建基于 HashiCorp Nomad 和 Consul 的集群环境。该项目支持一键部署单服务器 Nomad/Consul 集群，结合 Podman（或可选的 Docker）作为容器运行时，非常适合便携式 HomeLab 或小型边缘计算集群的快速部署与测试。 ## 链接 GitHub 项目地址：[https://github.com/caiodelgadonew/nomad playbook](https://github.com/caiodelgadonew/nomad playbook)"},"/hardware/zh/cluster/NanoCluster/use.html":{"title":"快速上手","content":" title: 快速上手 ## 硬件安装 ### ⚠️注意 目前有两种外壳样式在发货，如果您收到了红白配色的外壳，则几乎不需要执行下面的步骤，因为配件都已经预先安装好了。 ![case1](./assets/case1.png)![case2](./assets/case2.png) 如果您想自己打印新款外壳，可以在makerworld下载模型文件自己打印，链接是 https://makerworld.com.cn/zh/models/1311487 如果你想将三台Cluster安装在一个10英寸机柜上可以使用下面这个模型。 https://makerworld.com.cn/zh/models/1349837 ![case3](./assets/case3.png) ### LM3H 安装 先将散热片粘贴到主控芯片上，以提升散热效果。安装核心板时，请确保方向正确，以免损坏设备。 ![mount1](./assets/mount1.jpeg) 对准核心板上的金手指缺口与主板卡槽，使其对齐后轻轻放入，并均匀向下按压，直至听到 “喀哒” 声，确认核心板已牢固插入且无歪斜或松动。 ![mount2](./assets/mount2.jpeg) 如需拆卸核心板，请双手均匀握住核心板两侧，轻轻向上施力，避免单侧用力过大导致损坏。若核心板较紧，可先左右轻微晃动后再拔出，切勿生拉硬拽，以防损坏金手指或主板卡槽。 ### CM4、CM5 安装 先将 CM4 / CM5 安装到转接板上； ![cm4_mount1](./assets/cm4_mount1.jpeg) 再将转接板插入主板插槽。 ![cm4_mount2](./assets/cm4_mount2.jpeg) >若使用 **CM5** 且需支持 **USB3.0**，请间隔一个槽位安装，确保 USB3 通道正常工作。 ### M4N 安装 先将 M4N 核心板安装到转接板上； ![m4n_mount1](./assets/m4n_mount1.jpeg) 再将转接板插入主板插槽。 ![m4n_mount2](./assets/m4n_mount2.jpeg) ### 风扇安装 将风扇对准底板上预留的安装孔位插入： ![fan1](./assets/fan1.jpeg) 请确保风扇朝向正确，风向应朝向网口方向，以便更有效地带走 SOM 的热量： ![fan2](./assets/fan2.jpeg) 使用螺丝将风扇牢固固定在底板上： ![fan3](./assets/fan3.jpeg) 将风扇的电源排线插入底板上的风扇供电接口。请注意插头方向，确保红线为正极： ![fan4](./assets/fan4.jpeg) ## 电源供应 NanoCluster 支持 USB C PD 与 PoE 两种供电方式，支持双路热插拔 —— 即可同时连接 PD 与 PoE，在断开其中任意一方后系统依然稳定运行，支持在任意时刻插入或拔出任一电源。 默认支持 60W（20V/3A）PD 供电，使用带 e Marker 的线材可达 65W（20V/3.25A）。推荐使用标配的 PD 适配器及优质 USB C 线缆，以确保稳定供电。可选配 60W 峰值功率的 PoE 模块，持续输出功率约为 50W，适用于无独立供电接口的网络部署环境。 ### 最大支持配置（参考推荐功率）： 供电方式 最大支持配置 PD 支持 7× LM3H / CM4 / CM5 / M4N PoE 支持 7× LM3H / CM4；6× CM5 / M4N SSD 安装 最多支持 4 个带 SSD 的 SOM（因空间限制） <br> > **注：** CM5 / M4N 模块因功耗更高，在 PoE 模式下建议最多连接 6 个。 ### PD 接口说明 设备通过 USB C 接口支持 PD 协议供电，最大功率 65W。请使用原装适配器或符合 20V/3A 以上规格的电源适配器，确保设备正常启动并满载运行。 ![pd](./assets/pd_power.jpeg) ### PoE 模块安装说明 NanoCluster 可选配 PoE 模块，实现网络线供电，简化布线部署。请参考下图进行正确安装： ![poe1](./assets/poe1.jpeg) 将 PoE 模块与主板插槽对齐后小心插入，确保连接牢靠，不松动。 ![poe2](./assets/poe2.jpeg) >请使用符合标准的 PoE 交换机或 PoE 适配器，以保证稳定性和安全性。 ## 烧录镜像 ##### 核心板默认已预装系统，如需重新烧录系统，可按照以下步骤进行操作： ### LM3H 烧录 下载所需的固件镜像，并准备一台支持 USB OTG 的计算机及 USB 线。NanoCluster 目前使用的镜像与 Longan Pi 3H 兼容，可在此获取：[点击下载](https://wiki.sipeed.com/hardware/zh/longan/h618/lpi3h/3_images.html)。 将核心板插入 slot1 槽位后，使用 USB 线 连接 主板 OTG 接口（下方的接口）与计算机。按住 BOOT 按键，然后 上电或复位设备，即可进入 UMS 烧录模式。 ![flash_lm3h_1](./assets/flash_lm3h_1.jpeg) 准备好固件镜像后，打开 balenaEtcher，选择要烧录的镜像文件，确保核心板被识别为 U 盘，然后在 balenaEtcher 中选择目标设备。点击 “Flash” 按钮开始烧录，等待烧录完成后，安全弹出设备，断开 USB 连接并重启设备，即可进入新系统。 ![flash_lm3h_2](./assets/flash_lm3h_2.jpeg) ### CM4/CM5 烧录 1. 按照 [官方文档](https://www.raspberrypi.com/documentation/computers/compute module.html#set up the host device) 安装 `rpiboot` 工具。 2. 按住转接板上的 BOOT 按键，将 USB OTG 接口连接到主机。 3. 主机识别到 **BCM2711 (BCM2712) Boot** 设备后，运行 `rpiboot`，稍等片刻会自动弹出一个 U 盘设备。 4. 打开 [Raspberry Pi Imager](https://www.raspberrypi.com/software/)，选择所需镜像并烧录到该设备上即可。 ### M4N 烧录 可参考[系统烧录指南](https://wiki.sipeed.com/hardware/zh/maixIV/m4ndock/system update.html)进行烧录 ## 远程管理 主板配备一个网口用于连接交换机，集群内部设备通过交换机互联，并可通过 IP 地址进行控制和管理。 **如何获得设备的IP地址（以 LM3H 核心板为例）**: 先将网线连接至主板的网口，然后上电。预装的固件已启用 mDNS 服务，可在 PC 上启用 Avahi 服务，并使用 mDNS 扫描整个网络，即可获取 lpi3h 设备的 mDNS 域名信息。 ``` bash avahi browse art grep lpi3h ``` 然后使用: ``` bash ssh sipeed@lpi3h xxxx.local ``` 即可连接（将 xxxx 替换为使用 avahi browse 命令查看到的主机名） > lpi3h 为 LM3H 默认的 mDNS 主机名前缀，若使用的是 CM4 或 CM5，请根据所烧录的系统镜像自行调整主机名。 ## 串口连接 每个 SOM 都将系统串口引出至 2.54mm 插针，可通过串口转 USB 模块进行连接调试。 如需同时调试或控制多个 slot，推荐使用我们提供的 USB 转四串口扩展板。该扩展板将 slot3、slot5、slot6 和 slot7 的串口信号统一接入 slot1 的 USB 接口，便于集中管理与操作。 ![串口小板](./assets/uart.jpeg) > ⚠️ 由于串口扩展模块会部分遮挡风道，且模块本身仅支持 4 路串口，建议在使用该模块时，仅插入 4～5 个 SOM，以保证系统散热与调试稳定性。 ## 电源控制 slot1~7 的复位脚由 slot1 通过 **I2C 扩展的 IO** 进行控制，可实现远程开关机。 **使用 LM3H 控制复位方法示例：** ```bash # 复位交换机芯片（GPIO 0） sudo gpioset gpiochip2 0 0 && sudo gpioset gpiochip2 0 1 # 复位 slot2（LM3H） # 长按 8 秒实现关机 sudo gpioset gpiochip2 2 0 && sleep 8 && sudo gpioset gpiochip2 2 1 # 快速触发实现开机 sudo gpioset gpiochip2 2 0 && sleep 1 && sudo gpioset gpiochip2 2 1 # 复位 slot2（CM4） sudo gpioset gpiochip2 2 0 && sleep 1 && sudo gpioset gpiochip2 2 1 # 复位 slot2（CM5） # 使用 GPIO 电平变化模拟按下 CM5 的电源按键，可实现开关机： # 若系统为 Raspberry Pi OS Lite（无桌面）：短按一次即可关机。 # 若系统为 Raspberry Pi Desktop（有桌面）：需短按两次以触发关机。 # 模拟短按两次（Desktop 系统关机） sudo gpioset gpiochip2 2 0 && sleep 1 && sudo gpioset gpiochip2 2 1 sudo gpioset gpiochip2 2 0 && sleep 1 && sudo gpioset gpiochip2 2 1 # 模拟短按一次（开机） sudo gpioset gpiochip2 2 0 && sleep 1 && sudo gpioset gpiochip2 2 1 ``` >! 已知问题：若通过长按按键实现强制硬关机 CM5，系统将无法通过短按方式启动，需重新上电才能恢复。 > `gpiochip2` 表示 GPIO 控制器编号，后面的 `x 0` 表示将编号为 x 的 IO 设置为低电平，`x 1` 设置为高电平。 GPIO 编号 对应功能 0 交换机芯片复位 1~7 slot1~slot7 复位 **使用 CM4/CM5 控制复位方法示例：** 在 CM4 或 CM5 上启用 I2C 并加载 PCA9557 驱动，即可使用相同方式控制： 编辑 /boot/firmware/config.txt，添加以下内容： ``` txt dtparam i2c_arm on dtoverlay pca953x,addr 0x18,pca9557 ``` 保存并重启后，即可通过 gpioset 方法控制 slot 的复位。 > **CM4** 对应的 GPIO 控制器编号为：`gpiochip2` > **CM5** 对应的 GPIO 控制器编号为：`gpiochip14` 控制方法与 LM3H 相同，只需将 gpiochip 替换为实际平台对应的编号。 ## 风扇调速 LM3H / CM4 / CM5 均支持风扇调速，默认情况下 LM3H 会根据 CPU 温度自动调节转速, CM4 和 CM5 官方镜像默认风扇全速运行。以下为各平台的控制方法。 如果需要手动调节风扇，可通过 SSH 连接到 slot1 设备，并执行以下命令： ### LM3H 调速 ``` bash echo disabled sudo tee /sys/class/thermal/thermal_zone2/mode echo 4 sudo tee /sys/class/thermal/cooling_device0/cur_state ``` `cur_state` 取值范围为 0 ~ 4，对应不同转速。 如果要恢复自动调节，可使用以下命令: ``` bash echo enabled sudo tee /sys/class/thermal/thermal_zone2/mode ``` ### CM4 调速 将以下内容添加到 /boot/firmware/config.txt: ```bash dtoverlay pwm 2chan,pin 12,func 4,pin2 13,func2 4 ``` 重启后执行： ``` bash sudo pigpiod ``` Python 控制风扇： ```python import pigpio pi pigpio.pi() # 设置 PWM 频率和范围 pi.set_PWM_frequency(13, 50) pi.set_PWM_range(13, 200) # 设置风扇转速 pi.set_PWM_dutycycle(13, 0) # 不转 pi.set_PWM_dutycycle(13, 200) # 满速 ``` ### CM5 调速 Python 控制风扇： ```python import RPi.GPIO as GPIO GPIO.setmode(GPIO.BCM) GPIO.setup(13, GPIO.OUT) pwm GPIO.PWM(13, 50) # 50Hz 频率 pwm.start(0) # 不转 pwm.start(100) # 满速 ``` ## 散热控制 1. 建议将整机放置在通风良好、温度低于 **30 摄氏度** 的环境中，以减轻整体散热负担。 2. 推荐整机持续工作功率控制在 **50W 以内**，峰值功率不超过 **60W**，以匹配电源输出能力与系统散热性能。 3. 若未安装 SSD，整机空间与散热能力可支持 **最多 7 个 SOM 同时运行**。若安装 SSD，为确保良好的散热风道，建议 **间隔安装 SOM，最多 4 个**。 4. Slot7 处于机壳边缘，风扇风量较小，但具备充足的空间安装散热片。建议为该位置安装较大的散热片以增强散热效果。 ## 常见问题排查（FAQ） ### 设备无法开机 / 无法进入系统 确保使用至少支持 PD 20V 输出的电源适配器，避免使用主机 USB 供电，否则可能导致设备无法正常启动。检查电源输入接口旁的绿色指示灯是否亮起，若无反应，可能是电源适配器或供电线路问题。观察每个 slot 对应的蓝色电源指示灯，判断系统是否正常启动。 如果 **LM3H** 无法进入系统，可按住 BOOT 按键后上电或复位设备，检查是否进入 UMS 模式，并通过磁盘管理确认是否识别为 U 盘。若系统损坏或无法进入，可以重新[烧录镜像](https://wiki.sipeed.com/hardware/zh/cluster/NanoCluster/use.html#烧录镜像)；若无法进入 UMS 模式，请尝试[异常刷机](https://wiki.sipeed.com/hardware/zh/cluster/NanoCluster/use.html#异常刷机（LM3H）)。 若 **CM4/CM5** 无法正常启动系统，可参考[烧录镜像](https://wiki.sipeed.com/hardware/zh/cluster/NanoCluster/use.html#烧录镜像)部分重新烧录后再进行测试。 ### 网络连接异常（无法获取 IP） 如果成功进入系统但网络连接异常，无法获取 IP，请确保先插入网线再上电。交换机会在设备上电时检测网络接口，若上电后再插网线，可能导致接口无法正常识别。 ### 异常刷机（LM3H） 如果因某些原因导致 U Boot 损坏，设备无法正常进入 UMS 模式，可以通过 Fel 模式 手动恢复。使用 sunxi fel 或 xfel 工具，将 U Boot 加载至内存并启动 UMS 模式，然后进行刷机。 #### 进入 fel 模式 短接 slot1 的该处引脚与 GND，然后上电即可进入 FEL 模式（后续版本可能增加按键控制）。 ![fel](./assets/fel.jpeg) #### 安装 awusb 驱动 需要先安装全志的 [sunxi awusb](https://github.com/916BGAI/sunxi awusb) 驱动，用于识别 H618 芯片。 ``` bash sudo apt update sudo apt install dkms cd sunxi awusb sudo cp r ./ /usr/src/sunxi awusb 0.5 sudo dkms add m sunxi awusb v 0.5 sudo dkms build m sunxi awusb v 0.5 sudo dkms install m sunxi awusb v 0.5 sudo modprobe awusb sudo cp udev/50 awusb.rules /etc/udev/rules.d/ sudo udevadm control reload rules ``` ``` bash Bus 002 Device 005: ID 1f3a:efe8 Allwinner Technology sunxi SoC OTG connector in FEL/flashing mode ``` #### 获取 uboot 文件 下载已经编译好的 U Boot 文件：[点击下载](./assets/uboot.tar.gz) #### 使用 sunxi fel 编译安装 ``` bash git clone https://github.com/linux sunxi/sunxi tools.git cd sunxi tools make tools sudo make install ``` 烧录 U Boot ``` bash sudo sunxi fel uboot /path/u boot sunxi with spl.bin ``` 执行完成后，设备应能正常进入 UMS 模式，此时可继续烧录系统镜像。 #### 使用 xfel 编译安装 ``` bash sudo apt install libusb 1.0 0 dev git clone https://github.com/xboot/xfel.git cd xfel make sudo make install ``` 烧录 U Boot ``` bash xfel ddr lpddr4 xfel write 0x4a000000 /path/u boot dtb.bin xfel exec 0x4a000000 ``` 执行完成后，设备应能正常进入 UMS 模式，然后进行系统镜像烧录。 ### CM4 Lite 复位后无法启动 首批版本的 CM4 转接板在使用 CM4 Lite（无 eMMC）时，按照[电源控制](https://wiki.sipeed.com/hardware/zh/cluster/NanoCluster/use.html#电源控制)指引操作，可能导致复位后无法正常启动。此问题将在下一版硬件中修复。如遇该情况，建议使用 reboot 命令进行重启，替代复位操作。"},"/hardware/zh/cluster/NanoCluster/switch.html":{"title":"交换机管理","content":" title: 交换机管理 ## 简介 NanoCluster 搭载 JL6108 千兆交换机芯片，该芯片基于 **RISC V** 架构，既可作为即插即用的傻瓜交换机使用，也可作为可本地管理的二层交换机，支持通过 Web 进行配置。主要功能包括： **系统管理**：显示系统信息、支持重启、恢复出厂设置、固件升级 **网络配置**：支持静态 IP 和 DHCP 动态 IP 配置 **端口管理**：端口启用/禁用、链路速率设置、流控管理 **端口汇聚**：支持端口绑定，提高带宽利用率 **安全与隔离**：端口隔离、防止数据泄露 **流量监控**：端口 MIB 统计、流量分析 **环路保护**：防止网络环路，提升网络稳定性 **VLAN 配置**：支持 MTU VLAN、基于端口的 VLAN、802.1Q VLAN、PVID 设置 **QoS 配置**：基于端口、PCP、DSCP 进行流量优先级管理 **带宽与风暴控制**：支持基于端口的带宽限制与广播风暴抑制 > 默认固件的管理界面为英文，可通过 OTA 更新切换为中英文界面。 >! 目前交换机管理界面在 Linux 上存在响应异常。为获得更佳兼容性，建议优先通过 Windows 登录交换机管理界面。 ## 端口分配 集群底板通过 JL6108 交换机连接各个核心板（SOM），端口分配如下： ![端口分配](./assets/switch_ports.jpeg) 交换机端口 连接设备 Port 1 Slot 7 Port 2 Slot 6 Port 3 Slot 5 Port 4 Slot 4 Port 5 Slot 3 Port 6 Slot 2 Port 7 Slot 1 Port 8 集群底板 RJ45 接口（用于连接外部网络） ## 使用教程 1. **确保设备连接** 确保 NanoCluster 已上电，并通过网线将板载网口与管理主机相连。 2. **配置 IP 地址** 交换机的默认 IP 地址为 **10.10.11.10/24**，请确保管理主机的 IP 地址与其处于同一网段，例如 **10.10.11.x**（x 取值范围：1 254，且不能为 10），子网掩码设为 **255.255.255.0**。 ![IP 配置](./assets/ip.jpeg) 3. **访问管理界面** 在浏览器地址栏输入 `http://10.10.11.10` 并回车，即可进入交换机的登录界面。 ![登录界面](./assets/login.jpeg) 4. **登录管理系统** 在登录界面输入 **管理员账号和密码**（默认均为 `admin`），然后点击 **登录**，进入交换机管理界面首页。 ![管理系统首页](./assets/homepage.jpeg) ## 基本配置 ### 端口管理 JL6108 交换机提供端口状态管理功能，支持 **端口启用/禁用**、**速率设置**、**流控管理**。 **启用/禁用端口**：可在 **端口管理** 页面找到目标端口，选择“启用”或“禁用” **修改端口速率**：支持 10Mbps / 100Mbps / 1000Mbps 三种模式 **流控**：可开启端口流控，防止数据丢失 ![端口管理](./assets/portsetting.jpeg) ### VLAN 配置 VLAN（虚拟局域网）用于划分不同的网络区域，防止广播风暴，提高网络安全性。 #### 配置端口 VLAN 1. **进入端口 VLAN 界面** 在 Web 管理界面，依次进入：`VLAN` >> `端口 VLAN`，进入 VLAN 配置页面。 2. **启用端口 VLAN 功能** 勾选 **“端口 VLAN 使能”** 选项，并点击 **`应用`** 按钮。 3. **创建 VLAN 2 并配置端口成员** 在 **VLAN ID** 输入框中输入 **`2`** 勾选 **端口 2 ~ 4** 点击 **`应用`** 按钮以保存配置 4. **查看端口成员表** 配置完成后，**端口 2 ~ 4 将自动从 VLAN 1 中移除**，并加入 VLAN 2。 ![端口 VLAN 配置示例](./assets/vlan.jpeg) ### QoS 配置（流量优先级） QoS 用于保障高优先级流量（如视频会议、VoIP）的稳定性： 1. **进入“QoS 设置”** 2. 选择 **基于端口/802.1P/DSCP** 的 QoS 策略 3. 设置 **高/中/低优先级队列** 4. **保存设置**，QoS 规则生效 ![QoS 配置](./assets/qos.jpeg) ### OTA 更新 固件下载地址：[点击下载 OTA 固件](./assets/firmware.zip) 1. 打开 Web 管理界面，依次进入：`系统信息配置` → `系统升级` 2. 点击 **选择文件**，选择匹配的固件文件进行升级： **英文界面固件**：`lms_ota_en.fw` **中文界面固件**：`lms_ota_zh.fw` 3. 点击 **升级**，系统将显示升级进度并自动进行校验。 4. 升级完成后，设备将自动重启以应用新固件。 5. 若升级失败，可断电重启设备，重新输入管理地址进入升级页面，重复升级操作。 ![OTA](./assets/upgrade.jpeg) ## 更多配置 JL6108 交换机还支持更多高级功能，详细配置说明，请参考官方手册。 [点击此处查看完整手册](https://dl.sipeed.com/shareURL/Cluster/NanoCluster/06_Switch_JL6108) 我们提供基于 **RISC V** 架构的 **JL6108 SDK**，用户可以从以下链接下载 SDK 并进行自主开发。 [JL6108 SDK](https://dl.sipeed.com/shareURL/Cluster/NanoCluster/06_Switch_JL6108)"},"/hardware/zh/cluster/NanoCluster/k3s.html":{"title":"K3s 部署","content":" title: K3s 部署 ## 简介 [K3s](https://k3s.io/) 是轻量级的 Kubernetes。它易于安装，仅需要 Kubernetes 内存的一半，适用于资源有限的环境，特别是边缘计算、物联网等应用场景。 ## 部署教程 ### 准备环境 首先，确保集群的网络正常，并且能够访问互联网。你可以使用 SSH 远程登录到集群中的每台机器，执行后续安装命令。确保主节点和工作节点的 IP 地址固定，并且网络间能够互相访问。 ### 安装 K3s（主节点） K3s 的安装非常简单。你只需在主节点上运行以下命令： ``` bash curl sfL https://get.k3s.io sh ``` 如果下载很慢可以使用以下命令加速安装 ``` bash curl sfL https://rancher mirror.rancher.cn/k3s/k3s install.sh INSTALL_K3S_MIRROR cn sh ``` 该命令会自动下载并安装 K3s。安装过程完成后，通过以下命令检查 K3s 服务是否启动： ``` bash sudo systemctl status k3s ``` 如果显示 `active (running)`，表示 K3s 已成功启动。 ```bash sudo systemctl status k3s ● k3s.service Lightweight Kubernetes Loaded: loaded (/etc/systemd/system/k3s.service; enabled; preset: enabled) Active: active (running) since Mon 2025 02 17 12:07:15 CST; 3h 38min ago Docs: https://k3s.io Process: 8803 ExecStartPre /bin/sh xc ! /usr/bin/systemctl is enabled quiet nm cloud setup.service 2>/dev/null (code exited, status 0/SUCCESS) Process: 8805 ExecStartPre /sbin/modprobe br_netfilter (code exited, status 0/SUCCESS) Process: 8808 ExecStartPre /sbin/modprobe overlay (code exited, status 0/SUCCESS) Main PID: 8810 (k3s server) Tasks: 32 Memory: 583.2M CPU: 29min 49.755s CGroup: /system.slice/k3s.service ├─8810 \"/usr/local/bin/k3s server\" └─8895 \"containerd \" ``` ### 安装 K3s（工作节点） 在工作节点上安装 K3s 时，需要将工作节点与主节点连接。使用以下命令在工作节点上安装 K3s： ``` bash curl sfL https://get.k3s.io K3S_URL https://<主节点IP>:6443 K3S_TOKEN <主节点Token> sh ``` 上述命令中，`主节点IP` 需要替换为主节点的 IP 地址，`主节点Token` 是从主节点获取的令牌。你可以通过以下命令在主节点上查看令牌： ```bash sudo cat /var/lib/rancher/k3s/server/node token ``` 安装完成后，使用以下命令验证工作节点是否成功加入集群： ```bash sudo kubectl get nodes ``` 如果工作节点显示在列表中，且状态为 `Ready`，则表示工作节点成功加入集群。 ```bash sipeed@lpi3h a2d1:~$ sudo kubectl get nodes NAME STATUS ROLES AGE VERSION lpi3h 1967 Ready <none> 20h v1.31.5+k3s1 lpi3h 231e Ready <none> 20h v1.31.5+k3s1 lpi3h 4782 Ready <none> 56m v1.31.5+k3s1 lpi3h a2d1 Ready control plane,master 23h v1.31.5+k3s1 lpi3h ba13 Ready <none> 19h v1.31.5+k3s1 lpi3h c06b Ready <none> 21h v1.31.5+k3s1 ``` ### 部署应用 我们新建一个配置文件，用于运行 k3s 容器 ```bash nano hello kubernetes.yaml ``` 文件内容如下： ```yaml apiVersion: apps/v1 kind: Deployment metadata: name: hello kubernetes spec: replicas: 1 selector: matchLabels: app: hello kubernetes template: metadata: labels: app: hello kubernetes spec: containers: name: hello kubernetes image: paulbouwer/hello kubernetes:1.10.1 env: name: MESSAGE value: \"Hello Kubernetes\" ``` 然后使用这个配置文件启动一个容器 ```bash sudo kubectl apply f hello kubernetes.yaml ``` 查看 pods 状态 ```bash sudo kubectl get pods o wide NAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATES hello kubernetes 7fbb7f4899 zqs5x 1/1 Running 0 2m39s 10.42.0.114 arch <none> <none> ``` 通过浏览器访问 10.42.0.114:8080 ![hello_k3s](./assets/hello_k3s.jpeg)"},"/hardware/zh/cluster/NanoCluster/nanoctl.html":{"title":"NanoCtl","content":" title: NanoCtl ## 简介 **NanoCtl** 是一个由社区开发的 CLI 工具和守护进程，专为 Sipeed NanoCluster (CM5) 设计。它提供了一种轻量级、原生 Go 语言编写的解决方案来管理硬件接口，旨在替代复杂的脚本依赖。 通过它，用户可以轻松管理单个节点的电源状态，并利用智能算法控制散热风扇。 ![nanoctl](../../../zh/cluster/NanoCluster/assets/nanoctl.jpeg) ### 主要特性 * **电源管理**：通过 GPIO 控制单个插槽的电源，支持开机、优雅关机 (Graceful Shutdown)、强制关机和硬件复位。 * **智能风扇控制**：实现了 PID 控制器（比例 积分 微分算法），在保持精确目标温度的同时，确保风扇运行平稳且静音。 * **监控与指标**：支持将指标数据（如风扇 PWM 占空比、温度）导出到 Prometheus 或 OpenTelemetry (OTLP) 以进行可视化监控。 * **零依赖**：基于 Go 语言编写，编译为单个二进制文件，直接与 Linux GPIO 字符设备交互，无需额外运行环境。 ## 链接 **GitHub 项目**: [https://github.com/AlejandroPerez92/nanoctl](https://github.com/AlejandroPerez92/nanoctl)"},"/hardware/zh/cluster/NanoCluster/distcc.html":{"title":"distcc 部署","content":" title: distcc 部署 ## 简介 [distcc](https://github.com/distcc/distcc) 是一个分布式 C/C++ 编译系统，它通过将编译任务分发到多台机器上来加速编译过程。它允许你利用多台计算机的计算能力，更快速地编译代码，特别适用于大型代码库或资源受限的设备环境。 ## 部署教程 ### 服务端 对于 Debian 系统,可以直接使用包管理器安装 distcc ```bash sudo apt install distcc ``` 开启 distcc 服务 ```bash distccd daemon allow 192.168.0.0/24 # 允许特定 IP 范围的机器访问 ``` ### 客户端 ```bash sudo apt install distcc distcc pump ``` 配置 DISTCC_HOSTS 环境变量，指定可用的工作节点。可以在 .bashrc 中添加以下内容： ```bash export DISTCC_POTENTIAL_HOSTS 'localhost 192.168.0.240 192.168.0.243 192.168.0.245 192.168.0.246' ``` 然后，可以尝试编译一个简单的程序，检查 distcc 是否正常分发编译任务： ```bash distcc pump distcc o test test.c ``` ```bash sipeed@lpi3h a2d1:~/distcc$ distcc pump distcc o test test.c __________Using distcc pump from /usr/bin __________Found 4 available distcc servers __________Shutting down distcc pump include server ``` ## 编译测试 为了测试 distcc 是否能够有效地加速编译过程，我们使用 OpenSSL 来进行编译测试。OpenSSL 是一个广泛使用的 C 库，包含大量源代码，适合用来测试分布式编译的效果。 ```bash git clone https://github.com/openssl/openssl.git cd openssl ./config distcc pump make j20 CC distcc ``` 可以使用 distccmon text 查看当前编译任务的分发情况 ```bash sipeed@lpi3h 2193:~$ distccmon text 67535 Compile cmp_ctx.c 192.168.0.240[0] 67528 Compile cmp_asn.c 192.168.0.240[1] 67635 Compile cms_dh.c 192.168.0.240[2] 67569 Compile cmp_http.c 192.168.0.243[0] 67696 Compile cms_io.c 192.168.0.245[0] 67583 Compile cmp_server.c 192.168.0.245[1] 67561 Compile cmp_hdr.c 192.168.0.245[2] 67606 Compile cmp_vfy.c 192.168.0.245[3] 67657 Compile cms_enc.c 192.168.0.246[1] 67672 Compile cms_env.c 192.168.0.246[2] ``` ### 编译性能对比 在测试过程中，我们对 OpenSSL 项目分别使用了单机编译和分布式编译（5台机器），下面是两种方式的编译结果： ##### 单机编译（不使用 distcc） ```bash real 18m11.760s user 64m37.024s sys 5m56.326s ``` ##### 分布式编译（使用 distcc） ```bash real 6m32.262s user 18m39.468s sys 4m30.008s ``` 可以看到，使用 distcc 进行分布式编译后，编译时间显著缩短，从 18 分钟降至约 6 分钟。可见分布式编译的加速效果明显，同时也可以有效地减轻单个机器的负载。"},"/hardware/zh/cluster/NanoCluster/index.html":{"title":"简介","content":" title: 简介 ## 简介 NanoCluster 是矽速科技开发的超迷你集群板，板载 7 个 SOM 插槽，采用基于 RISC V 架构的千兆交换机互联，支持 USB C PD 供电，并可扩展 PoE 供电。同时，NanoCluster 提供独立的 UART 和电源控制，使其成为 HomeLab 用户入门分布式计算、Kubernetes 和 Docker 实践，以及边缘计算的理想选择。 NanoCluster 兼容矽速科技的 Longan Module 3H（4 × Cortex A53）、M4N（4 × Cortex A55 + NPU），以及树莓派的 Compute Module 4（4 × Cortex A72） 和 Compute Module 5（4× Cortex A76）。用户可以根据性能需求和预算自由选择核心板，也可以混合搭配不同架构的核心板，构建一个高度定制化的计算集群。 NanoCluster 采用开放的 SOM 接口标准，不仅支持官方核心板，也允许用户自行设计转接板，以适配自定义核心板或其他第三方 SOM 方案，极大提升了平台的灵活性。 <br> ![产品特写图](./assets/product.png) ## 技术规格 ### 底板 <table> <thead> <tr> <th colspan \"2\">硬件参数</th> </tr> </thead> <tbody> <tr> <td><strong>SOM 插槽</strong></td> <td>7× 双 M.2 M Key 立式插槽</td> </tr> <tr> <td><strong>供电</strong></td> <td>USB C 20V PD 供电，最大 60W，可选配 60W PoE 模块供电</td> </tr> <tr> <td><strong>以太网</strong></td> <td>板载 RISC V 千兆交换芯片 JL6108 高速互联，支持 Web 页面管理和 SDK 自定义功能开发</td> </tr> <tr> <td><strong>USB 接口</strong></td> <td>USB A Host（上），USB A OTG（下），与 Slot 1 连接</td> </tr> <tr> <td><strong>显示接口</strong></td> <td>HDMI 接口，与 Slot 1 连接</td> </tr> <tr> <td><strong>散热系统</strong></td> <td>配备 60mm 2Pin 风扇，高效散热</td> </tr> <tr> <td><strong>状态指示</strong></td> <td>7× SYS LED 指示灯，用于各个计算节点状态监测</td> </tr> <tr> <td><strong>串口通信</strong></td> <td>7× 独立 UART，便于调试与控制，可选配四串口 USB 模块</td> </tr> <tr> <td><strong>电源管理</strong></td> <td>Slot1 通过 IO 扩展芯片集中管理其他 Slot 及交换机电源</td> </tr> <tr> <td><strong>功耗</strong></td> <td>3.6 W</td> </tr> <tr> <td><strong>尺寸</strong></td> <td>PCBA：88x57mm，插满 SOM 并安装风扇后约 100x60x60mm</td> </tr> </tbody> </table> ![底板裸板特写图](./assets/bare_board.jpeg) ### SOM <table> <tr> <th>SOM</th> <th>LM3H</th> <th>M4N</th> <th>CM4</th> <th>CM5</th> </tr> <tr> <td>主控芯片</td> <td>H618</td> <td>AX650N</td> <td>BCM2711</td> <td>BCM2712</td> </tr> <tr> <td>内存</td> <td>2GB ~ 4GB</td> <td>8GB</td> <td>1GB ~ 8GB</td> <td>1GB ~ 16GB</td> </tr> <tr> <td>eMMC</td> <td>32GB</td> <td>32GB</td> <td>0GB ~ 64GB</td> <td>0GB ~ 64GB</td> </tr> <tr> <td>CPU</td> <td>4 × A53<br>1.5 GHz</td> <td>8 × A55<br>1.6 GHz</td> <td>4 × A72<br>1.5 GHz</td> <td>4 × A76<br>2.4 GHz</td> </tr> <tr> <td>GPU</td> <td>Mali G31</td> <td> </td> <td>VideoCore VI</td> <td>VideoCore VII</td> </tr> <tr> <td>NPU</td> <td> </td> <td>18TOPS INT8</td> <td> </td> <td> </td> </tr> <tr> <td>网络连接</td> <td>百兆</td> <td>千兆</td> <td>千兆</td> <td>千兆</td> </tr> <tr> <td>其它接口</td> <td>None</td> <td>下载接口 + M.2 SSD + USB 3.0</td> <td>下载接口 + M.2 SSD</td> <td>下载接口 + M.2 SSD + USB 3.0</td> </tr> <tr> <td>功耗<br>空载 /<br>满载 /<br>峰值</td> <td><nobr>1.2W/2.6W/3.7W</nobr></td> <td><nobr>3W/8.3W/9W</nobr></td> <td><nobr>3W/4.5W/4.6W</nobr></td> <td><nobr>4W/7.6W/8W</nobr></td> </tr> </table> ![SOM图](./assets/som.jpeg) ## 接口图示 ### 底板接口 ![接口图示](./assets/board_io.jpeg) ### SOM LM3H 核心板通过 7 × 双 M.2 M Key 立式插槽直接连接到底板。 M4N 核心板则先通过 BTB（板对板）连接器与转接板对接，再连接到底板。 <table> <tr> <th>SOM</th> <th>LM3H</th> <th>M4N</th> </tr> <tr> <td>正面</td> <td><img src \"./assets/lm3h_front.jpeg\" width \"250\"/></td> <td><img src \"./assets/m4n_front.jpeg\" width \"250\"/></td> </tr> <tr> <td>反面</td> <td><img src \"./assets/lm3h_back.jpeg\" width \"250\"/></td> <td><img src \"./assets/m4n_back.jpeg\" width \"250\"/></td> </tr> </table> ### 转接板 CM4 / CM5 转接板正面配有 BTB 连接器，支持连接 CM4 和 CM5 核心板，同时集成了 Boot 按键和用于烧录的 Type C 接口。背面包括一个 SD 卡槽、一个 M.2 NVMe 固态硬盘接口（兼容 2242 或 2230 尺寸），以及一个预留的 USB 焊盘，可选支持 CM5 的 USB 3.0。 M4N 转接板正面配有 BTB 连接器，用于连接 Sipeed M4N 核心板，同时配备 Boot 按键和用于烧录的 Type C 接口。背面包括一个 M.2 NVMe 固态硬盘接口（2242 或 2230），以及一个预留的 USB 焊盘，可选支持 USB 3.0。 <table> <tr> <th>转接板</th> <th>CM4 / CM5</th> <th>M4N</th> </tr> <tr> <td>正面</td> <td><img src \"./assets/cm4_adapter_front.jpeg\" width \"250\"/></td> <td><img src \"./assets/m4n_adapter_front.jpeg\" width \"250\"/></td> </tr> <tr> <td>反面</td> <td><img src \"./assets/cm4_adapter_back.jpeg\" width \"250\"/></td> <td><img src \"./assets/m4n_adapter_back.jpeg\" width \"250\"/></td> </tr> </table> ## 软硬件资料 ### 底板硬件资料 [点击查看](https://dl.sipeed.com/Cluster/NanoCluster) ### Longan Module 3H 资料 硬件资料可在此获取：[点击查看](https://dl.sipeed.com/shareURL/LONGAN/LonganPi3H)。系统构建与软件开发指南请参考：[点击这里](https://wiki.sipeed.com/hardware/zh/longan/h618/lpi3h/7_develop_mainline.html)。 ### M4N 资料 + [硬件相关资料](https://dl.sipeed.com/shareURL/MaixIV/M4N Dock) + [软件开发文档](https://dl.sipeed.com/shareURL/MaixIV/M4N Dock) + [软件开发SDK](https://github.com/AXERA TECH/ax650n_bsp_sdk) ### Raspberry Pi Compute Module 4 [点击查看](https://www.raspberrypi.com/products/compute module 4) ### Raspberry Pi Compute Module 5 [点击查看](https://www.raspberrypi.com/products/compute module 5) ## 购买入口 [淘宝](https://item.taobao.com/item.htm?id 977609765104) [速卖通](https://www.aliexpress.com/item/1005009393696842.html) ## 产品反馈 如果您在使用过程中有任何问题或建议，请通过以下渠道和我们反馈： + [Github issues](https://github.com/sipeed/NanoCluster)"},"/hardware/zh/lichee/K1/lm3a.html":{"title":"LicheePi Module 3A","content":" title: LicheePi Module 3A keywords: LicheePi, Sodimm, K1, RISCV, SBC update: date: 2024 07 30 version: v0.1 author: zepan content: 初次编写文档 ## 简介 LicheePi Module 3A 是一款采用 [进迭时空](https://spacemit.com/) 的 [K1](https://www.spacemit.com/key stone k1/) 作为主控的核心模组，主控核心包含八核X60 CPU (RV64GCV, 256bit Vector 1.0), 具备 2TOPS@int8 AI 算力，拥有 1080P 视频处理能力，最大支持 16GB LPDDR4X 内存和 128G eMMC 存储，支持双千兆以太网和1080P分辨率视频输出等特性，还支持PCIE Gen2x2。 LicheePi Module 3A 与LM4A 兼容，可以在底板上直接替换使用。 ![top](somtop.jpg) ![bot](sombot.jpg) ## 基本参数 <table> <thead> <tr> <th colspan 2>主控参数</th> </tr> </thead> <tbody> <tr> <td>主控芯片</td> <td>进迭 K1</td> </tr> <tr> <td>CPU</td> <td>RISC V 64GCV X60*8@1.6GHz <br>· Cluster0 2TOPS AI Power, 32K L1 Cache per core, 512K L2 Cache, 512KB TCM, Vector 256bit <br>· Cluster0 32K L1 Cache per core, 512K L2 Cache, Vector 256bit </td> </tr> <tr> <td>GPU</td> <td>· IMG BXE 2 32@819M <br>· OpenGL ES 3.2, OpenCL 3.0<br>· Vulkan 1.3<br>· 20GFLIPS </td> </tr> <tr> <td>NPU</td> <td>Cluster0 2TOPS@INT8 <br>· 支持 TensorFlow、ONNX、Caffe <br>· 支持 CNN、RNN、DNN 等</td> </tr> <tr> <td>Video</td> <td>H265&H264 @ 1080p 60fps decode/encode</td> </tr> <tr> <th colspan 2>硬件特性</th> </tr> <tr> <td>RAM</td> <td>· 8GB 32bits LPDDR4X<br>· 16GB 32bits LPDDR4X<br></td> </tr> <tr> <td>ROM</td> <td>eMMC: <br>· 32G<br>· 128G</td> </tr> <tr> <td>以太网</td> <td> 千兆 PHY x 2</td> </tr> <tr> <td>PCIe (x3)</td> <td>· PCIE PortA Gen2x1 (combo with USB3)<br>· PCIE PortB Gen2x2<br>· PCIE PortC Gen2x2</td> </tr> </tbody> </table> ## 相关链接 [Sipeed 下载站](https://dl.sipeed.com/shareURL/LICHEE/LicheePi3A)"},"/hardware/zh/lichee/K1/lc3a/lc3a.html":{"title":"LicheePi Cluster 3A","content":" title: LicheePi Cluster 3A keywords: LicheePi, Sodimm, K1, RISCV, SBC, Cluster update: date: 2024 07 30 version: v0.1 author: zepan content: 初次编写文档 ## 简介 Lichee Cluster 3A (以下简称 LC3A ) 是矽速科技研发的高性能 RISC V 集群计算平台，可以用于构建多节点计算集群，而且还是学习 Kubernetes、自动化、边缘人工智能计算、本地迷你服务器，托管应用程序、容器等的优秀工具。单个 Lichee Cluster 3A 最多可装配 7 个 LM3A 核心板，每个 LM3A 核心板含有 2TOPS@int8 AI 算力的 NPU，单核心板最大支持 16GB LPDDR4X 内存和 128G eMMC 存储，整个集群有强大的灵活性和可扩展性。 Lichee Cluster 3A 板载八口千兆交换机以提供高速连接，轻松将多个节点连接起来，组成强大的计算集群，还支持 USB3.0 和 SD 卡存储扩展，能够轻松地将扩展额外存储或者增加外围设备。 Lichee Cluster 3A 还带有 BMC (带外管理)，BMC 独立连接了每个 LM3A 的系统串口和复位引脚。BMC 可以从硬件上复位单个计算节点，还可以通过串口执行命令,比如执行 ser2net 或 kermit 来管理 Slot。 ## 技术规格 <table> <colgroup> <col class \"org left\" /> <col class \"org left\" /> </colgroup> <tr> <td class \"org left\">支持的核心板</td> <td class \"org left\"> <a href \"https://wiki.sipeed.com/lm3a\">LM3A</a> * 7</td> </tr> <tr> <td class \"org left\">CPU</td> <td class \"org left\"><strong>RiscV X60@1.6GHz * 8</strong> * 7</td> </tr> <tr> <td class \"org left\">GPU</td> <td class \"org left\">IMG™ B 系列 BXE 2 32 * 7</td> </tr> <tr> <td class \"org left\">NPU</td> <td class \"org left\">2TOPS@INT8 * 7</td> </tr> <tr> <td class \"org left\">RAM</td> <td class \"org left\">最大 16GB * 7</td> </tr> <tr> <td class \"org left\">EMMC</td> <td class \"org left\">最大 128GB * 7</td> </tr> <tr> <td class \"org left\">BMC</td> <td class \"org left\"><a href \"https://wiki.sipeed.com/Lichee RV\">SIPEED Lichee RV</a></td> </tr> <tr> <td class \"org left\">电源管理</td> <td class \"org left\"><a href \"https://wiki.sipeed.com/m0sense\"> Sipeed M0 Sense</a></td> </tr> <tr> <td class \"org left\">Ethernet</td> <td class \"org left\">千兆以太网1(Slot#1)<br>千兆以太网2(交换机)<br>百兆以太网(BMC)</td> </tr> <tr> <td class \"org left\">USB</td> <td class \"org left\">USB3.0 * 7 (LM4A)<br>USB2.0 * 1 (BMC)</td> </tr> <tr> <td class \"org left\">HDMI</td> <td class \"org left\">HDMI * 1 (Slot 1)</td> </tr> <tr> <td class \"org left\">SDCARD</td> <td class \"org left\">TF * 7</td> </tr> <tr> <td class \"org left\">电源支持</td> <td class \"org left\">支持 DC 口直流电源供电<br>支持 ATX 24PIN 电源</td> </tr> <tr> <td class \"org left\">RTC 供电</td> <td class \"org left\">CR2032 纽扣电池</td> </tr> <tr> <td class \"org left\">散热</td> <td class \"org left\">5V PWM 风扇接口 * 7<br>12V 4PIN PWM 风扇接口 * 1</td> </tr> <tr> <td class \"org left\">尺寸</td> <td class \"org left\">Mini ITX, 17 * 17 cm (6.7 * 6.7 inch)<br>可选配 MINI ITX 机箱, 20 * 12 * 22 cm</td> </tr> </table> ## 硬件系统 ### 主板介绍 ![lc43_top](./assets/lc3a_top.png) ### 主板框架图 ![lc4a_architecture](./assets/lc3a_architecture.png) LicheeRV SOM（D1 C906@1GHz）有5个原生串口，以及两个USB串口，分别独立连接到了7个SOM上。 每个 LM3A 的 RST/BOOT 均可通过模拟开关进行控制。 1号LM3A默认引出了第二千兆口和HDMI口，方便该SOM进行整个集群的任务分发操作。 主板可通过12V DC充电头供电（推荐12V9A以上），或者使用标准ATX电源供电。 ### 机箱介绍 推荐选配MINI ITX机箱，该机箱具备良好的外观和散热性能，方便计算集群的部署展示。 机箱适配MINI ITX主板，配备250W大功率电源，并安装了12cm静音风扇散热，可以保证CPU在满载运行时的温度低于70度。 ![lc3a_box](./assets/lc3a_box.png) ### 硬件安装指南 默认运输途中LC4A已经安装了所有SOM，如果你需要拆卸或者升级SOM，可以参考以下说明。 #### 安装核心板 向两侧拉开白色锁扣，插入前请确认缺口为止，避免方向错误导致损坏 ![lc3a_install_goldfinger](./assets/lc3a_install_goldfinger.png) 放入核心板后均匀的向下施加压力 ![lc3a_install_install_lm4a](./assets/lc3a_install_install_lm3a.png) 听到喀哒声后，确认白色锁扣正确扣上，安装完成。如果需要取出核心板，向两侧拉开白色锁扣即可。 ![lc3a_install_slot](./assets/lc3a_install_slot.jpeg) #### 安装BMC 安装烧录好镜像的SD卡到LicheeRV, 然后将LicheeRV的模块安装至交换机芯片旁边的座子,然后拧上螺丝. #### 插入电源 可选ATX电源供电或者DC电影供电。 确认ATX电源插座的卡扣已经扣紧，避免接触不良导致连接器升温 ![lc3a_power_atx20_cable](./assets/lc3a_power_atx20_cable.png) 插上跳线帽 ![lc3a_power_jumpwire](./assets/lc3a_power_jumpwire.png) #### 网络连接 集群系统对外主要连接两个网口：1. 板载千兆交换机网口 2. BMC网口 板载千兆交换机网口建议连接入用户所在内网或者主网络，用于集群获取所需网络数据。 BMC网口建议连入独立网络进行集群控制，更具安全性。 集群内部通过千兆交换机连接。 如何获得集群的IP地址: 预装的固件安装启用了mdns服务 在你的PC上启用avahi服务(Linux) 使用mdns扫描整个网络获得lc4a的mdns域名信息: ``` avahi browse art grep lc4a ``` 然后使用: ``` ssh debin@lc4aXXXX.local ``` XXXX为mac地址后四位，用于区分每个slot ## 软件系统 ### LM4A镜像 集群中的LM4A SOM可以直接使用LicheePi3A的镜像. 镜像烧录方法： 1. 按下BOOT按键的同时按一下RST按键，然后使用A TO A公头的USB线缆连接到电脑 2. 使用fastboot或者titian工具烧录 ### OpenBMC镜像 主板上的 LicheeRV SOM 运行 OpenBMC 来管理主板上的 SOM。 镜像下载地址: [点我跳转](https://dl.sipeed.com/shareURL/LICHEE/LicheeCluster4A/04_Firmware/bmc/bin) 镜像烧录方法: ``` bmaptool copy obmc phosphor image licheepi rv.wic.gz /dev/YOUR_SDCARD ``` 默认用户名: `root` 默认密码: `0penBmc` 0 是零，不是 O 如果需要开发定制，请下载PATCH: https://dl.sipeed.com/shareURL/LICHEE/LicheeCluster4A/04_Firmware/bmc/src 并应用到OpenBMC源码: ``` git clone https://github.com/openbmc/openbmc/ git checkout commit id git am xxx.patch ``` ### OpenBMC管理 从SSH访问Slot的串口: ``` ssh p 2301 root@bmcip # access first slot's serial port ``` * 端口 22: OpenBMC的shell * 端口 2301: slot1 的 SOL (Serial Over LAN) * 端口 2302: slot2 的 SOL * 端口 2303: slot3 的 SOL * 端口 2304: slot4 的 SOL * 端口 2305: slot5 的 SOL * 端口 2306: slot6 的 SOL * 端口 2307: slot7 的 SOL 每个Slot的串口输出到日志: ``` cat /var/log/obmc cons*.log ```"},"/hardware/zh/lichee/K1/lpi3a/1_intro.html":{"title":"板卡介绍","content":" title: 板卡介绍 keywords: Linux, Lichee, K1, SBC, RISCV update: date: 2024 07 30 version: v1.0 author: zepan content: Release docs ## 简介 LicheePi 3A 是基于 [Lichee Module 3A](http://wiki.sipeed.com/hardware/zh/lichee/K1/lm3a.html) 核心板的 高性能 RISC V Linux 开发板，以 [K1](https://www.spacemit.com/key stone k1/) 为主控核心（8xX60@1.6G， RV64GCV，2TOPS@int8 NPU， 20GFLOP GPU），板载最大 16GB 32bit LPDDR4X，128GB eMMC，支持 HDMI+MIPI 双1080P 显示输出，支持 16MP 摄像头接入，双千兆网口（其中一个支持POE供电）和 4 个 USB3.0 接口，以及2路 PCIE Gen2x2，多种音频输入输出。 ![lpi3a](./assets/intro/lpi3a.jpg) ![pcie](./assets/intro/pcie.png) LicheePi 3A 是目前极具性价比的中端 RISC V SBC。多核性能约为上一代 RISC V SBC [LPi4A](http://wiki.sipeed.com/hardware/zh/lichee/th1520/lpi4a.html)的80%, 单核性能约为 50% [GeekBench6](https://browser.geekbench.com/v6/cpu/compare/6718771?baseline 5822041) ![benchmark](./assets/intro/benchmark.png) ![geekbench6](./assets/intro/geekbench6.png) LicheePi 3A 可以用作典型的 RISC V 验证平台，其强大的性能可以较快速地实现本地编译，而无需使用 QEMU 进行编译。 LicheePi 3A 基本与LicheePi4A兼容，如果你购买过LicheePi4A，那么可以仅购买LM3A来装在LPi4A底板上（无M.2接口）。 ![desktop](./assets/intro/desktop.jpg) ## 基础参数 <table> <thead> <tr> <th colspan 2>主控参数</th> </tr> </thead> <tbody> <tr> <td>主控芯片</td> <td>进迭 K1</td> </tr> <tr> <td>CPU</td> <td>RISC V 64GCV X60*8@1.6GHz <br>· Cluster0 2TOPS AI Power, 32K L1 Cache per core, 512K L2 Cache, 512KB TCM, Vector 256bit <br>· Cluster0 32K L1 Cache per core, 512K L2 Cache, Vector 256bit </td> </tr> <tr> <td>GPU</td> <td>· IMG BXE 2 32@819M <br>· OpenGL ES 3.2, OpenCL 3.0<br>· Vulkan 1.3<br>· 20GFLIPS </td> </tr> <tr> <td>NPU</td> <td>Cluster0 2TOPS@INT8 <br>· 支持 TensorFlow、ONNX、Caffe <br>· 支持 CNN、RNN、DNN 等</td> </tr> <tr> <td>Video</td> <td>H265&H264 @ 1080p 60fps decode/encode</td> </tr> <tr> <th colspan 2>硬件特性</th> </tr> <tr> <td>RAM</td> <td>· 8GB 32bits LPDDR4X<br>· 16GB 32bits LPDDR4X<br></td> </tr> <tr> <td>存储</td> <td>· eMMC: 可选32G、 128G<br>· 支持 TF 卡<br>· 支持 NVMe SSD</td> </tr> <tr> <td>以太网</td> <td>· 2 x 千兆以太网接口，可选 POE</td> </tr> <tr> <td>PCIe (x3)</td> <td>· PCIE PortA Gen2x1 (combo with USB3)<br>· PCIE PortB Gen2x2<br>· PCIE PortC Gen2x2</td> </tr> <tr> <td>USB</td> <td>· USB3.0 x 4<br>· USB2.0 x 2</td> </tr> <tr> <td>音频接口</td> <td>· 1 x 3.5mm 耳机接口<br>· 一个扬声器接口<br>· 两个板载麦克风<br></td> </tr> <tr> <td>显示接口</td> <td>· 1 x HDMI1.4<br>· 1 x 4 lane MIPI DSI</td> </tr> <tr> <td>摄像头接口</td> <td>· 1 x 2 lane MIPI CSI<br>· 1 x 4 lane MIPI CSI</td> </tr> <tr> <td>GPIO</td> <td>· UART<br>· IIC<br>· SPI</td> </tr> </tbody> </table> ### 硬件资料下载 [板卡规格书](https://dl.sipeed.com/shareURL/LICHEE/LicheePi3A/01_Specification) [底板原理图](https://dl.sipeed.com/shareURL/LICHEE/LicheePi3A/02_Schematic) [底板点位图](https://dl.sipeed.com/shareURL/LICHEE/LicheePi3A/03_Bit_number_map) [底板尺寸图](https://dl.sipeed.com/shareURL/LICHEE/LicheePi3A/04_Dimensional_drawing) [模型文件](https://dl.sipeed.com/shareURL/LICHEE/LicheePi3A/05_3D_model) ## 其他链接 [淘宝](https://item.taobao.com/item.htm?id ) [Aliexpress](https://xxx) [Sipeed 下载站](https://dl.sipeed.com/shareURL/LICHEE/LicheePi3A) QQ群: 559614960 [点我自动加群](http://qm.qq.com/cgi bin/qm/qr?k 5YkapIhdtWHp8AEfM5_bFFYQIX3CUQN6) Telegram: https://t.me/linux4rv 论坛：Maixhub.com/discussion 联系邮箱：support@sipeed.com"},"/hardware/zh/lichee/K1/lpi3a/2_unbox.html":{"title":"开箱体验","content":" title: 开箱体验 keywords: Linux, Lichee, K1, SBC, RISCV, unbox update: date: 2024 07 30 version: v1.0 author: zepan content: Release docs ## 开箱内容 ### 基础套餐 你收到的包裹内是如下包装： ![package](./assets/unbox/package_v1.jpg) 打开白色纸盒，可以看到LicheePi3A板卡和基础配件（硅脂片+散热风扇+USB C线）： ![board](./assets/unbox/package_v1board.jpg) 如果开箱后发现缺少相关部件，请联系客服咨询。 ### 选配件 LicheePi 4A还有丰富的配件可供选择，如下图所示： ![accessory1](./assets/unbox/acc1.jpg) ![accessory2](./assets/unbox/acc2.jpg) 选购说明： 配件名选购说明 铝合金外壳适合作为小主机，软路由的外壳 10.1寸触摸屏1280x800 4lane MIPI，适合作为车机，安卓 调试使用 USB摄像头5MP USB摄像头，板载麦克风，适合作为openCV的摄像头使用 PoE电源模块5V2.4A PoE电源模块，网关类应用使用网线PoE供电 12V电源12V2A电源适配器，板卡外接很多耗电外设时选购 RV Debugger PlusUART+JTAG调试小板，连接系统串口终端调试用 ## 组装板卡 ### SOM安装 默认情况下 LM3A SOM 已经安装至主板上，如果你需要升级/替换 SOM，可按如下说明进行 SOM 的取出和安装 1. 取出 SOM: <table> <tr> <td colspan 2>先用手指往外拨动弹片解锁 SOM, 然后将 SOM 取出</td> </tr> <tr> <td><img src \"./assets/unbox/unlock_som.jpg\" alt \"unlock_som\"></td> <td><img src \"./assets/unbox/remove_som.jpg\" alt \"remove_som\"></td> </tr> </table> 2. 安装 SOM: <table> <tr> <td colspan 2>先把 SOM 斜着插入连接器插槽, 然后按压SOM，两边弹片会自动锁住SOM</td> </tr> <tr> <td><img src \"./assets/unbox/remove_som.jpg\" alt \"insert_som\"></td> <td><img src \"./assets/unbox/lock_som.jpg\" alt \"lock_som\"></td> </tr> </table> ### 散热器安装 LicheePi 3A 是高性能 SBC，需要安装主动散热器对 SOM 进行散热，否则在满载时可能由于核心过热而自动降频，无法达到最优性能。 1. 安装导热硅脂片 取出导热硅脂片，撕开两面薄膜，将硅脂片放置在下图位置并轻轻按压固定（硅脂片自己具备一定粘性可以固定住），注意完整覆盖住主芯片与两颗内存芯片 ![silicone_pad](./assets/unbox/silicone_pad.jpg) 2. 安装散热风扇 在硅脂片上对齐安装30mm的散热风扇，并轻轻按压固定住。 ![insert_fan](./assets/unbox/insert_fan.jpg) 3. 安装散热风扇电源 默认收到时应该已经插入好了风扇电源，如果风扇电源线脱出，请按下图所示插入，注意电源线顺序，装反风扇不会旋转。 注意，该位置上的插针电源受 linux 内核控制，需正确配置内核才会旋转，如果风扇不转，也可插到板卡下方的 20pin 插针的 5V + GND 处测试风扇好坏。 ![insert_fan_cable](./assets/unbox/insert_fan_cable.png) ### WIFI天线安装 默认情况下WIFI天线已经安装在主板上，如果脱出，请按照下图安装回去： ![insert_ant](./assets/unbox/insert_ant.png) ### 组装完成 组装完成后的状态如下所示： ![assemble_ok](./assets/unbox/insert_fan.jpg) ## 启动板卡 LicheePi 3A出库已预烧录了基础系统镜像，至此你已可以快速进行开机体验！ 使用 HDMI 线缆(自备)连接显示器(自备)与 LicheePi 3A 的 HDMI 口，使用配套的 USB C 线缆连接到至少 5V2A 输出的 USB 电源(自备)上，LicheePi 3A 即会开机启动，默认镜像会在 30s 内启动到桌面系统的登录界面, 第一次登录会进入用户帐号设置序列。 ![boot_login](./assets/unbox/boot_login.jpg) 默认镜像的帐号密码配置如下： 账户：`root`，密码： `bianbu`； 插入键鼠，输入用户名密码后即可登录体验，具体操作请查看后续章节。 如果按照上述操作，没能点亮显示器，进入系统，有以下可能请自查： 1. 检查电源电压是否正常，USB C 口连接是否正常，电源指示灯是否点亮 2. 检查散热器是否正常安装，风扇是否旋转 3. 检查 HDMI 是否稳固连接，显示器是否开机，以及可以尝试更换显示器测试 4. 也可能是出厂遗漏固件烧录，请按下章方法进行镜像烧录后再试 5. 如果以上均不奏效，请联系客服售后 ## POE模块安装说明 POE模块需要用户手工焊接安装，请按下图焊接： ![poe](./assets/unbox/poe.jpg) > 注意 POE模块焊接后无法装入铝合金外壳。 ## 板卡硬件说明 完成初次点亮板卡后，可以静下心来认识下 LicheePi 3A 的硬件，方便后期可能的维护工作。 ![pi_view](./assets/unbox/pi_view.png) ### 硬件资料下载 [板卡规格书](https://dl.sipeed.com/shareURL/LICHEE/LicheePi3A) ## 其他链接 [淘宝](https://item.taobao.com/item.htm?id 715508771884) [Aliexpress](https://xxx) QQ群: 559614960 [点我自动加群](http://qm.qq.com/cgi bin/qm/qr?k 5YkapIhdtWHp8AEfM5_bFFYQIX3CUQN6) Telegram: https://t.me/linux4rv 论坛：https://maixhub.com/discussion 联系邮箱：support@sipeed.com"},"/hardware/zh/lichee/K1/lpi3a/5_develop.html":{"title":"RISC-V Develop","content":" title: RISC V Develop keywords: Linux, Lichee, K1, SBC, RISCV, Kernel, SDK, Develop update: date: 2024 07 30 version: v1.0 author: zepan content: Release docs ## Linux 请参看进迭官方开发文档： [文档](https://bianbu linux.spacemit.com/) [项目地址](https://gitee.com/bianbu linux)"},"/hardware/zh/tang/Tang-Nano-9K/examples/lushaylabs/3_oled_101/oled_101.html":{"title":"Tang Nano 9K SSD1306 OLED 屏幕","content":" title: Tang Nano 9K SSD1306 OLED 屏幕 keywords: FPGA, Tang, Nano, 9K update: date: 2023 03 14 version: v0.1 author: wonder content: 新建文档 This is part 3 in our Tang Nano 9K series. In this article we will be starting a mini project creating an OLED text engine core. This series will go through the entire process from concept to implementation to demonstrate not just the code but also the design process and considerations taken when creating a multi component system. Part 1 (this part) will be an intro on the HW and creating the base driver so that we can display something to the screen. Part 2 will go over displaying text on our base OLED core including how to map ascii character codes to the screen data and using custom fonts.Part 3 will wrap up the project taking everything we did in the previous parts in order to build a reusable dynamic text engine that can be used by other cores to display their own data onto the screen. To follow along you will need a Tang Nano 9K and a 128x64 pixel screen with an SSD1306 driver using its 4 wire SPI configuration (the screen itself should have 7 pins). We will be using a 0.96\" OLED screen matching these requirements, you can get these along with a breadboard jumpers and the tang nano from our store <a href \"https://store.lushaylabs.com/collections/all products?ref lushay labs\">here</a>. ## The Plan In this part we are not going to think about the overall architecture or how the screen will communicate with the rest of the system. We will only be worried about being able to drive the screen using the FPGA building the physical driver for the OLED screen. To do this we first need to better understand how the screen works and how it expects to be communicated with. The screen we are using has an SSD1306 IC driver so we can go over its datasheet to get the information we need. [SSD1306 Datasheet](https://dl.sipeed.com/fileList/others/ssd1306/SSD1306.pdf) ## The SSD1306 Driver This driver IC is the interface between you and the actual OLED's underlying display. An OLED consists of many LEDs which need to be controlled individually to produce the desired picture. The driver is what connects to these LEDs and provides an interface where you can send it commands or data in order to update the display. Looking at the block diagram in the datasheet we can see how it works internally: ![block_diagram](./assets/block_diagram.jpg) Looking at the left side, we have a microcontroller which is what we will be communicating with. The pins we care about are the the first three and D0 and D1, the first three are reset, chip select and data/command flag and D0 is our SPI clock and D1 is our SPI data. All the other pins are used for alternate communication methods, like if interfacing with the screen over parallel connection. But since we are using the driver in it's 4 wire SPI mode we only need the 5 pins listed above. The MCU receives data from us, and then will decide whether the data is a command meant to control the display, or whether it was pixel data meant to update the contents of the display. Pixel data gets stored in the Graphics RAM which stores the contents for the entire display, the RAM propagates through the display driver to the actual pins controlling the individual OLEDs. The benefits of using a screen buffer in ram like this is that the screen can be updated independently of the device controlling it, and also you can just send an update to change a part of the image and the screen will remember the rest of the image. If the DC (data/command) flag was set to be a command, then the data will go to the command decoder to process and perform the command that you sent. Each \"transmission\" to the screen is a single byte, and if the data/command pin is set low that byte will be interpreted as a command and if set high the byte will be sent to the graphics ram to the current screen position stored in the ssd1306's memory. ### How Data is Stored The screen itself we are using has 128 x 64 pixels or 8192 individual pixels. The SSD1306 lets us configure how the ram is mapped to the display, but in general each byte controls a vertical line of 8 pixels. This means to control each of the 64 pixels in each column we need to set 8 bytes (again each byte controls 8 vertical pixels). The first byte will control the top left column, then we will increment by one and update the 8 pixels to the right and so on until we wrap around to the second row of 8 pixel columns: ![byte_structure](./assets/byte_structure.jpg) > 128 bytes per row 8 rows, each byte controlling 8 vertical pixels In the example above we sent 136 bytes with 0xFF (binary 11111111) this will result in the top row of 8 pixels being lit up across the whole screen, and in the first 8 columns we will have the top 16 pixels lit up. The least significant bit is the top pixel and the most significant bit is the bottom in each column, so a byte like 01010111 would create a column of pixels like the following: ![pixel_1](./assets/pixel_1.jpg) ### Command Bytes Like mentioned above the device has a set of commands that we can send it to do certain things. Inside the datasheet linked above we can see multiple tables including commands like the following: ![command_table](./assets/command_table.jpg) Each row contains a command and shows the byte or bytes (for multi byte commands) that need to be sent. A 1 or 0 means that bit needs to be a one or zero and when there is a parameter it will be marked with numbered letters and referenced on the right. For example to invert the screen (3rd command in the picture) we can see that we need to send 1010011x where the last bit can be either a one or zero. If we set it to a zero the command will set the display to normal mode, where a pixel set to zero will be off and a pixel set to 1 in the ram will be on. If we instead send a 1 as the last bit of the command, the screen will be inverted and a zero in RAM will cause a pixel to be lit up. We won't go through all the commands individually but by following the same approach you can decipher the rest of the command tables. In order to use the OLED display we first need to perform an initialization sequence where we send it all the commands required to setup all the configuration of the OLED. Once initialized we can start sending it pixel data and see the screen update. The last thing we need to go over before getting into the code is to go over the communication protocol itself, which in our case is SPI. ## SPI We will be communicating with the OLED screen over SPI. SPI is a serial protocol where 2 devices communicate with a data line for each direction and a common clock line. There are multiple modes in SPI, depending on whether you read on the rising / falling edge and whether the idle state of the clock is high or low. Multiple SPI devices can be connected together over the same wires and then each of the devices will have a separate chip select pin (CS) with which you can choose which device you are currently communicating with. With the SSD1306 driver we are using an extra wire to tell the device if the current byte being sent is data or a command. This is not part of the SPI protocol but is part of our communication interface we are building. From the datasheet we can see an example of how to communicate with the driver in this 4 wire SPI mode: ![spi_send](./assets/spi_send.jpg) The first line in the image is the chip select pin. Like mentioned above this pin signifies that we are currently communicating with this device, kind of like an enable pin. We pull it low at the start of our communication and put it back high when done. The next line is the Data/Command Flag, this can be either high or low, a high value means it is pixel data and a low value signifying a command. The third line just shows a combination of the data / clock pins just to show that multiple bytes can be sent without needing to change the chip select each time. Next we have a zoom in of how a single byte looks when being sent. The first of these lines is the clock pin the second is the data pin. We see here the clock pin can either be high or low while idle, but more importantly we see that the data should be updated on the falling edge and it will be read on the rising edge. We also see that the most significant bit of the byte we are sending should be sent first. With all that information we have everything we need to start building a driver core to interface with the OLED display. ## Creating the Driver core Like always to get started we can create a new project / folder in VSCode containing a constraints file with the tangnano9K pins we will be using, a verilog file for our driver core module and a Makefile to make building easier. ### Boilerplate **Constraints File** For the constraints file we can create a `tangnano9k.cst` file with the following: ![screen_contraints](./assets/screen_contraints.jpg) If creating manually it would look like this ```txt IO_LOC \"clk\" 52; IO_PORT \"clk\" PULL_MODE UP; IO_LOC \"io_cs\" 36; IO_PORT \"io_cs\" IO_TYPE LVCMOS33 PULL_MODE DOWN DRIVE 8; IO_LOC \"io_dc\" 39; IO_PORT \"io_dc\" IO_TYPE LVCMOS33 PULL_MODE DOWN DRIVE 8; IO_LOC \"io_reset\" 25; IO_PORT \"io_reset\" IO_TYPE LVCMOS33 PULL_MODE DOWN DRIVE 8; IO_LOC \"io_sdin\" 26; IO_PORT \"io_sdin\" IO_TYPE LVCMOS33 PULL_MODE DOWN DRIVE 8; IO_LOC \"io_sclk\" 27; IO_PORT \"io_sclk\" IO_TYPE LVCMOS33 PULL_MODE DOWN DRIVE 8; ``` We define the clock pin and we define the 5 pins we will need for interfacing with the OLED driver: 1. Chip Select `io_cs` 2. Data / Command `io_dc` 3. Reset Pin `io_reset` 4. SPI Data In to OLED `io_sdin` 5. SPI clock `io_sclk` I chose these pins just because they are consecutive there is no special function and any other 3.3v pins could have been chosen. ![tang_nano_oled_pins](./assets/tang_nano_oled_pins.jpg) **Makefile** This is only if you are not using the Lushay Code extension and instead run the toolchain manually. For the Makefile just create a file called `Makefile` with our standard project boilerplate: ```makefile BOARD tangnano9k FAMILY GW1N 9C DEVICE GW1NR LV9QN88PC6/I5 all: screen.fs # Synthesis screen.json: screen.v \tyosys p \"read_verilog screen.v; synth_gowin top screen json screen.json\" # Place and Route screen_pnr.json: screen.json \tnextpnr gowin json screen.json freq 27 write screen_pnr.json device ${DEVICE} family ${FAMILY} cst ${BOARD}.cst # Generate Bitstream screen.fs: screen_pnr.json \tgowin_pack d ${FAMILY} o screen.fs screen_pnr.json # Program Board load: screen.fs \topenFPGALoader b ${BOARD} screen.fs f # Generate Simulation screen_test.o: screen.v screen_tb.v \tiverilog o screen_test.o s test screen.v screen_tb.v # Run Simulation test: screen_test.o \tvvp screen_test.o # Cleanup build artifacts clean: \trm screen.vcd screen.fs screen_test.o .PHONY: load clean test .INTERMEDIATE: screen_pnr.json screen.json screen_test.o ``` For a better explanation on this makefile format you can take a look at our installation guide [here](./../1_installation_getting_started/installation_getting_started.html) where we go more in depth into this template. ## Implementing the Driver Core With the setup out of the way we can start implementing our driver with a verilog module. To use the screen like we saw above, we need to first initialize it, it is also recommended to reset the screen after its power stabilizes, this is to make sure it is in its proper reset state. So we will first wait a bit of time, then reset the screen, once reset we will send it all the initialization commands required to set it up and then the screen should be ready to start receiving and displaying pixel data. So our state machine will have the following steps: 1. Power Initialization Wait / Reset 2. Load Init Command Byte 3. Send Byte over SPI 4. Check Where to go from Sending 5. Load Pixel Data Byte The first stage will cover the power reset mentioned above, next we will have a state where we load the next command byte in the init sequence. Technically the next state would be to send the command byte over SPI, but there is no real difference between sending a command byte or sending a pixel byte so state 3 can be used for both. The only difference is which state to go to after sending the byte. In the case where there are more commands to send we would like to go to the state to load the next command otherwise we want to go to the state to load the next pixel byte. So step 4 will just check if there are more commands and if so go back to step 2 otherwise go to step 5. And step 5 just loads a pixel byte and links back to send it with step 3. ![states](./assets/states.jpg) We can create a file called `screen.v` with the following module outline: ```v module screen #( parameter STARTUP_WAIT 32'd10000000 ) ( input clk, output io_sclk, output io_sdin, output io_cs, output io_dc, output io_reset ); localparam STATE_INIT_POWER 8'd0; localparam STATE_LOAD_INIT_CMD 8'd1; localparam STATE_SEND 8'd2; localparam STATE_CHECK_FINISHED_INIT 8'd3; localparam STATE_LOAD_DATA 8'd4; endmodule ``` This is an empty module receiving the inputs we defined in the constraints file and defining the 5 states listed above. `STARTUP_WAIT` is an external parameter which is the number of clock cycles to wait before resetting the screen. It is an external parameter instead of a local parameter so that in simulation testing we don't have to wait as long. Next we can add some registers: ```v reg [32:0] counter 0; reg [2:0] state 0; reg dc 1; reg sclk 1; reg sdin 0; reg reset 1; reg cs 0; reg [7:0] dataToSend 0; reg [3:0] bitNumber 0; reg [9:0] pixelCounter 0; ``` We need a counter to count clock cycles and a register for the current state. Next we have a register for each of the inputs to drive them. Both the clock and reset pins are high on idle and `dc` we could have chosen either. Finally we have a register for the current byte we will be sending, a register to remember which bit of the current byte we are on and a register to keep track of which pixel of the screen we are on. Next let's create a register for holding all the init command bytes. We have a total of 15 init commands which take up a total of 23 bytes (some of the commands are 2 bytes). ```v localparam SETUP_INSTRUCTIONS 23; reg [(SETUP_INSTRUCTIONS*8) 1:0] startupCommands { 8'hAE, // display off 8'h81, // contast value to 0x7F according to datasheet 8'h7F, 8'hA6, // normal screen mode (not inverted) 8'h20, // horizontal addressing mode 8'h00, 8'hC8, // normal scan direction 8'h40, // first line to start scanning from 8'hA1, // address 0 is segment 0 8'hA8, // mux ratio 8'h3f, // 63 (64 1) 8'hD3, // display offset 8'h00, // no offset 8'hD5, // clock divide ratio 8'h80, // set to default ratio/osc frequency 8'hD9, // set precharge 8'h22, // switch precharge to 0x22 default 8'hDB, // vcom deselect level 8'h20, // 0x20 8'h8D, // charge pump config 8'h14, // enable charge pump 8'hA4, // resume RAM content 8'hAF // display on }; reg [7:0] commandIndex SETUP_INSTRUCTIONS * 8; ``` Besides for the init commands we also have a register which will remember which command we are currently on. Because the concat operator `{` and `}` place the most significant byte first, the first byte we write is actually placed at the end. We could have reversed the order we wrote the init commands and then started `commandIndex` at zero, but I think it is clearer to write the commands in order and then just start the current bit index at the last bit number. Next let's connect all the input wires to the registers we created for them. We could have also added the keyword `reg` to the input parameters themselves in which case it would have automatically created a register for us, but to make it more pronounced I separated it into two steps. ```v assign io_sclk sclk; assign io_sdin sdin; assign io_dc dc; assign io_reset reset; assign io_cs cs; ``` ### The State Machine For the state machine, let's work only on the rising edge of our clock to make things simpler. ```v always @(posedge clk) begin case (state) \t// states here endcase end ``` Next let's go through each of the states of our state machine one by one: **Load Init Command** ```v STATE_INIT_POWER: begin counter < counter + 1; if (counter < STARTUP_WAIT) reset < 1; else if (counter < STARTUP_WAIT * 2) reset < 0; else if (counter < STARTUP_WAIT * 3) reset < 1; else begin state < STATE_LOAD_INIT_CMD; counter < 32'b0; end end ``` Here we start with the reset set to 1 which is it's idle state and we wait a bit of time for the power to become stable. Then we wait the same period again this time reseting the screen by pulling the reset pin low. Finally we return the pin to high wait again a small amount to make sure the screen is ready to start receiving commands and move onto the next state resetting the counter to zero. The default `STARTUP_WAIT` is set to 10,000,000 so with a 27Mhz crystal we are looking at about a third of a second per step so for all three steps about a second. **Load Init Command** ```v STATE_LOAD_INIT_CMD: begin dc < 0; dataToSend < startupCommands[(commandIndex 1) :8'd8]; state < STATE_SEND; bitNumber < 3'd7; cs < 0; commandIndex < commandIndex 8'd8; end ``` Here we set the data / command bit to zero to signify that we are sending a command. We load the next command from the register we created with all the init command bytes. The syntax used here with the minus sign after the MSB tells it that we will not be placing the least significant bit but instead the length. Usually we use the syntax `[MSB:LSB]` to access memory here we are using `[MSB :LEN]` there is also the option with the a plus instead of a minus for `[LSB+:LEN]` Next we set the state to the send state as that is where we want to go next after loading a command byte. We set the bit number to the last bit as we saw from the datasheet we are sending most significant bit first in the SPI communication. Chip select is also set low to tell the screen we want to communicate with it now which essentially enables the screen to receive data over the SPI connection. The last line decrement the `commandIndex` by 8 as we have handled those 8 bits by loading them into `dataToSend`. **Sending a byte** ```v STATE_SEND: begin if (counter 32'd0) begin sclk < 0; sdin < dataToSend[bitNumber]; counter < 32'd1; end else begin counter < 32'd0; sclk < 1; if (bitNumber 0) state < STATE_CHECK_FINISHED_INIT; else bitNumber < bitNumber 1; end end ``` In order to simplify the implementation we will only be using the rising edge of our own clock, but the clock signal in SPI requires us to do things on both the rising and falling edge of the clock. So to get around this we will just use two of our clock cycles for each bit, one where the SPI clock will be pulled low and one where the SPI clock will be pulled high. In the first block we are setting the SPI clock low, and from the datasheet we saw we are supposed to change the data on the SPI data pin on the falling edge so we do that as well. On the second clock cycle of this state we will then reset the counter and pull the clock high, pulling it high will tell the screen to read the bit that we put on the data pin in the previous clock cycle. Lastly we check if we are already on the last bit, if so we go on to the next state, otherwise we decrement the `bitNumber` register to move to the next bit and continue sending in the current state. **Check Finished Init** ```v STATE_CHECK_FINISHED_INIT: begin cs < 1; if (commandIndex 0) state < STATE_LOAD_DATA; else state < STATE_LOAD_INIT_CMD; end ``` In this stage we are pulling the chip select high to tell the screen we are finished (not mandatory as we could have sent multiple bytes on the same chip select pulse). Next we check if `commandIndex` is 0 which would mean we sent all the commands and can move from here to loading the next pixel byte, otherwise go back and load the next command byte. **Load Pixel Data** ```v STATE_LOAD_DATA: begin pixelCounter < pixelCounter + 1; cs < 0; dc < 1; bitNumber < 3'd7; state < STATE_SEND; if (pixelCounter < 136) dataToSend < 8'b01010111; else dataToSend < 0; end ``` The last state loads the pixel bytes one at a time. We start by incrementing the `pixelCounter` to track which screen pixels we are. Next we set chip select to zero to re enable the screen communication. Data / Command flag is set to 1 to signify we will be sending data now not commands. Next we reset the bit number back to the last bit and the state we set back to the \"send byte\" state to send the next pixel byte. We don't currently have any image to display, so as an example to make sure everything is working we can simply use the byte example from above as a test where we send the screen 136 bytes of 01010111. We never need to reset pixelCounter since there are exactly 1024 bytes which exactly fits into 10 bits, so the `pixelCounter` register will automatically roll over back to zero on its own. That should be everything required to get the screen working, programming the Tang Nano 9K by clicking on the \"FPGA Toolchain\" button from the bottom bar and then selecting \"Build and Program\" from the menu. (Or `make load` if running manually). With our tangnano programmed you should get something like the following: ![img_5705](./assets/img_5705.jpg) ## Loading An Image In terms of Verilog, loading an image instead of our two static rows of lines is pretty easy. We first need a memory where we can store all our bytes: ```v reg [7:0] screenBuffer [1023:0]; initial $readmemh(\"image.hex\", screenBuffer); ``` Our memory has 1024 slots each of which hold a single byte. The second lines tells the toolchain to load a file called `image.hex` into this memory. And then we can change the last if / else of our load pixel state to the following: ```v dataToSend < screenBuffer[pixelCounter]; ``` So our entire state should look like this: ```v STATE_LOAD_DATA: begin pixelCounter < pixelCounter + 1; cs < 0; dc < 1; bitNumber < 3'd7; state < STATE_SEND; dataToSend < screenBuffer[pixelCounter]; end ``` Some would say the code is even simpler now. The trouble comes more in how to create the file `image.hex`. We know each byte needs to represent 8 vertical pixels and we need to scan across the image from the top left in rows of 8 pixels. So the task of loading an image is more a task of converting an image into the format we need in order to display it. Luckily we can create a simple node.js script to do the conversion for us. ### Preparing the Image Data To begin with we first need a png image with the same size as the screen 128 x 64 pixels in size. Since the screen only has a single color we will only be using the transparency value of a PNG image to determine whether or not to turn on a pixel. To convert our image we will be using a node.js library to parse the image called `pngjs`. To install the library you can run the following command from the project directory: ```javascript npm i pngjs ``` Next let's create a script called `generate_image.js` with the following: ```javascript const fs require(\"fs\"); const PNG require(\"pngjs\").PNG; fs.createReadStream(\"image.png\") .pipe(new PNG()) .on(\"parsed\", function () { const bytes []; for (var y 0; y < this.height; y+ 8) { for (var x 0; x < this.width; x+ 1) { let byte 0; for (var j 7; j > 0; j 1) { let idx (this.width * (y+j) + x) * 4; if (this.data[idx+3] > 128) { byte (byte << 1) + 1; } else { byte (byte << 1) + 0; } } bytes.push(byte); } } const hexData bytes.map((b) > b.toString('16').padStart(2, '0')); fs.writeFileSync('image.hex', hexData.join(' ')); }); ``` We start by including the library along with the filesystem package to load the file. The next line creates a read stream to load the image (named `image.png`) and then pipes it to a PNG instance from the `pngjs` library and the next block will be called once the entire image is ready and loaded in memory. Inside this `parsed` block we have three nested `for` loops, the outer one is to go over the vertical lines, as you can see from the end of the line, we skip each time by 8 lines as each 8 lines are stored in a single byte. The next `for` loop is for going through all the columns nothing special here. The final `for` loop is for incrementing through each of the 8 pixels in a vertical column. Each time we complete the inner loop it means we have gone through 8 vertical pixels and we can store a new byte moving onto the next vertical column in our row. We start the internal loop at the last bit so that we can shift each of the bits into `byte` from the right. Going through the internal loop we are simply getting the index for the current pixel. `this.data` is a long array of bytes where for each pixel we have 4 bytes, one for red, one for green, one for blue and one for the alpha channel. So the first line calculates this offset by figuring out which byte we are, this is the number of complete rows (or y offset) multiplied by 128 (the screen width) plus the current x offset. We then multiply by 4 since each pixel is 4 bytes (RGBA). Once we have the offset we check if the transparency (or 4th byte in our 4 byte pixel) is greater then 128 (out of 256) so if it is 50% or more transparent we will put a zero and the pixel will be turned off, otherwise we will put a 1 and the pixel will be highlighted. Other then that we have these two lines: ```javascript const hexData bytes.map((b) > b.toString('16').padStart(2, '0')); fs.writeFileSync('image.hex', hexData.join(' ')); ``` Where we take each of our bytes and convert them to hex (base 16) and we pad them from the left with zeros so that each byte will be exactly 2 hex characters. The final line outputs the hex data into a file called `image.hex` separating each hex byte with a space. With our hex file created and our code updated we should be able to reprogram our FPGA and get something like the following: ![screen_with_image](./assets/screen_with_image.jpg) ## Conclusion In this part we have created the physical driver core to interface with the 0.96\" OLED display and we have covered loading a simple image to it. In the next part we will take it a step further and \"generate\" the screen buffer on chip by converting ascii text into pixels implementing text and fonts into our core. Thank you for reading, if you have any questions or comments feel free to leave them below or message us on twitter <a href \"https://twitter.com/LushayLabs?ref lushay labs\">here</a>. To get any of the items used in this tutorial like the screen / tang nano or breadboard you can go to lushaylabs store <a href \"https://store.lushaylabs.com/collections/all products?ref lushay labs\">here</a> . As always all the examples can be found on github by following this <a href \"https://github.com/lushaylabs/tangnano9k series examples?ref lushay labs\">link</a>"},"/hardware/zh/tang/Tang-Nano-9K/examples/lushaylabs/8_sharing_resources/sharing_resources.html":{"title":"","content":""},"/hardware/zh/tang/Tang-Nano-9K/examples/lushaylabs/9_i2c_adc_and_micro_procedures/i2c_adc_and_micro_procedures.html":{"title":"","content":""},"/hardware/zh/tang/Tang-Nano-9K/examples/lushaylabs/7_generating_random_numbers/generating_random_numbers.html":{"title":"","content":""},"/hardware/zh/tang/Tang-Nano-9K/examples/lushaylabs/5_data_conversion_visualization/data_conversion_visualization.html":{"title":"","content":""},"/hardware/zh/tang/Tang-Nano-9K/examples/LCD.html":{"title":"驱动RGB屏幕","content":" title: 驱动RGB屏幕 > 编辑于2022.04.12 ## 先介绍时序 RGB LCD 显示协议和 VGA 类似，通信都有专用的行同步、场同步信号线。它们的主要区别是前者传输用的是数字信号，后者传输走的是模拟信号。 下面就介绍 VGA 的时序 ![](./../../assets/examples/lcd_pjt_1.png) 上图分别是 VGA 在数据传输中的行同步、场同步时序 从时序图中可以看出，不论是显示一行数据还是一列数据，都需要一个同步(sync)信号，数据的传输需要在两个同步信号的脉冲之间完成 每一行的数据包括显示前沿(back porch)、有效数据(active video)、显示后沿(front porch) 其中的有效数据就是我们常说的分辨率，而显示前后沿的参数需要参考具体的分辨率与帧数进行设置，相关参数可以参考典型参数，链接在此： http://www.tinyvga.com/vga timing 这块5寸屏幕的控制时序略有不同，相关参数的设置可以查看[规格书](https://dl.sipeed.com/fileList/TANG/Nano%209K/6_Chip_Manual/CN/LCD_Datasheet/5.0inch_LCD_Datashet%20RGB.pdf) 其他尺寸的屏幕相关规格书均可以在这里下载 [点我](https://dl.sipeed.com/shareURL/TANG/Nano%209K/6_Chip_Manual/CN/LCD_Datasheet) 下面提供了 LCD 相关时序的截图 ![](./../../assets/examples/lcd_pjt_2.png) ![](./../../assets/examples/lcd_pjt_3.png) 上面一张图是时序中的参数表，下面的图是时序图 从时序图中看出，这块屏幕可以不用设置前后沿，可以只设置消影(blanking)时间，通过实际的程序证明，两种方式都是可以的 ## 新建工程 具体新建工程的方法可以参考[点灯文章](LED.html) ## 生成屏幕时钟 这里需要用到高云半导体官方的IP核 ### rPll 板载的晶振时钟为 27MHz ，但是我们的屏幕要求 33.3MHZ 的时钟，所以我们需要使用对应的ip核来生成相应的时钟 这里需要使用到 `IP Core Generate` ，位置在 Tools > IP Core Generate ![](./../../Tang Nano 1K/assets/Gowin_IP_rpll.png) 双击 `rpll` ，在弹出窗口 language 选择 Verilog ，CLKIN 为 27MHz ，CLKOUT 为 33.00MHz。 ![](./../../Tang Nano 1K/assets/lcd_rpll.png) 点击ok后提示是否需要添加到当前工程，此时应当选择确定 ![](./../../Tang Nano 1K/Nano_1K_examples/led/assets/add_ip_file_in_project.png) 接着会出现一个例化的tmp文件，用来例化所设置的ip。比如下图中例子 ![](./../../Tang Nano/examples/led/assets/ip_examples.png) ## 屏幕驱动代码 **首先新建一个额外的verilog文件来保存下面要编写的代码** ### 端口定义 首先需要先定义出驱动屏幕所需要的端口 ```verilog module VGAMod ( input CLK, input nRST, input PixelClk, output LCD_DE, output LCD_HSYNC, output LCD_VSYNC, \toutput [4:0] LCD_B, \toutput [5:0] LCD_G, \toutput [4:0] LCD_R ); ``` 本例程使用RGB565作为驱动方式； ### 时序常量 接着定义出时序图上所要求的常量 ```verilog localparam V_BackPorch 16'd6; //0 or 45 localparam V_Pluse \t 16'd5; localparam HightPixel 16'd480; localparam V_FrontPorch 16'd62; //45 or 0 localparam H_BackPorch 16'd182; \t localparam H_Pluse \t 16'd1; localparam WidthPixel 16'd800; localparam H_FrontPorch 16'd210; localparam PixelForHS WidthPixel + H_BackPorch + H_FrontPorch; \t localparam LineForVS HightPixel + V_BackPorch + V_FrontPorch; ``` 首先是设置时序相关的参数：前沿、后沿、有效像素 关于显示前沿、后沿，前面也说了，可以合并为一个消影时间，就是可以把其中一个设置为0，另一个设置为消影时间。反正前后沿的时间加起来符合表中的时间要求就可以 ### 定义变量 定义一些变量能够容易编写程序 ```verilog reg [15:0] LineCount; reg [15:0] PixelCount; reg\t[9:0] Data_R; reg\t[9:0] Data_G; reg\t[9:0] Data_B; ``` ### 同步信号 这段代码产生同步信号，需要注意的是，这块屏幕的同步信号是负极性使能 ```verilog always @( posedge PixelClk or negedge nRST )begin if( !nRST ) begin LineCount < 16'b0; PixelCount < 16'b0; end else if( PixelCount PixelForHS ) begin PixelCount < 16'b0; LineCount < LineCount + 1'b1; end else if( LineCount LineForVS ) begin LineCount < 16'b0; PixelCount < 16'b0; end else PixelCount < PixelCount + 1'b1; end always @( posedge PixelClk or negedge nRST )begin if( !nRST ) begin \t\t\tData_R < 9'b0; \t\t\tData_G < 9'b0; \t\t\tData_B < 9'b0; end else begin \t\t\tend \tend //注意这里HSYNC和VSYNC负极性 assign LCD_HSYNC (( PixelCount > H_Pluse)&&( PixelCount < (PixelForHS H_FrontPorch))) ? 1'b0 : 1'b1; assign LCD_VSYNC ((( LineCount > V_Pluse )&&( LineCount < (LineForVS 0) )) ) ? 1'b0 : 1'b1; ``` ### 使能信号 这段代码设置 LCD 使能图像显示，这块屏幕需要控制一个管脚用作显示开关，实际这个信号就是传输图像有效的那 800*480 的数据时置 1 ```verilog assign LCD_DE ( ( PixelCount > H_BackPorch )&& ( PixelCount < PixelForHS H_FrontPorch ) && ( LineCount > V_BackPorch ) && ( LineCount < LineForVS V_FrontPorch 1 )) ? 1'b1 : 1'b0; //这里不减一，会抖动 ``` ### 测试彩条 这段代码用来产生 LCD 的测试数据，产生彩条显示 ```verilog localparam Colorbar_width WidthPixel / 16; assign LCD_R ( PixelCount < ( H_BackPorch + Colorbar_width * 0 )) ? 5'b00000 : ( PixelCount < ( H_BackPorch + Colorbar_width * 1 )) ? 5'b00001 : ( PixelCount < ( H_BackPorch + Colorbar_width * 2 )) ? 5'b00010 : ( PixelCount < ( H_BackPorch + Colorbar_width * 3 )) ? 5'b00100 : ( PixelCount < ( H_BackPorch + Colorbar_width * 4 )) ? 5'b01000 : ( PixelCount < ( H_BackPorch + Colorbar_width * 5 )) ? 5'b10000 : 5'b00000; assign LCD_G ( PixelCount < ( H_BackPorch + Colorbar_width * 6 )) ? 6'b000001: ( PixelCount < ( H_BackPorch + Colorbar_width * 7 )) ? 6'b000010: ( PixelCount < ( H_BackPorch + Colorbar_width * 8 )) ? 6'b000100: ( PixelCount < ( H_BackPorch + Colorbar_width * 9 )) ? 6'b001000: ( PixelCount < ( H_BackPorch + Colorbar_width * 10 )) ? 6'b010000: ( PixelCount < ( H_BackPorch + Colorbar_width * 11 )) ? 6'b100000: 6'b000000; assign LCD_B ( PixelCount < ( H_BackPorch + Colorbar_width * 12 )) ? 5'b00001 : ( PixelCount < ( H_BackPorch + Colorbar_width * 13 )) ? 5'b00010 : ( PixelCount < ( H_BackPorch + Colorbar_width * 14 )) ? 5'b00100 : ( PixelCount < ( H_BackPorch + Colorbar_width * 15 )) ? 5'b01000 : ( PixelCount < ( H_BackPorch + Colorbar_width * 16 )) ? 5'b10000 : 5'b00000; ``` **当然在最后的驱动文件最后别忘记换行加上 endmodule** 到这里驱动模块的编写已经完成了。 ## 在顶层模块中例化 **这里也是要新建verilog文件的** 新建文件之后直接把下面的内容复制进去保存即可 ```verilog module TOP //设置顶层模块 ( \tinput\t\t\tnRST, input XTAL_IN, \toutput\t\t\tLCD_CLK, \toutput\t\t\tLCD_HYNC, \toutput\t\t\tLCD_SYNC, \toutput\t\t\tLCD_DEN, \toutput\t[4:0]\tLCD_R, \toutput\t[5:0]\tLCD_G, \toutput\t[4:0]\tLCD_B ); // 列出需要的端口 \twire\t\tCLK_SYS;\t \twire\t\tCLK_PIX; //例化pll Gowin_rPLL chip_pll( .clkout(CLK_SYS), //output clkout //200M .clkoutd(CLK_PIX), //output clkoutd //33.00M .clkin(XTAL_IN) //input clkin );\t \tVGAMod\tVGAMod_inst //例化vga驱动 \t( \t\t.CLK\t\t(\tCLK_SYS ), \t\t.nRST\t\t(\tnRST\t\t), \t\t.PixelClk\t(\tCLK_PIX\t\t), \t\t.LCD_DE\t\t(\tLCD_DEN\t \t), \t\t.LCD_HSYNC\t(\tLCD_HYNC \t), \t.LCD_VSYNC\t(\tLCD_SYNC \t), \t\t.LCD_B\t\t(\tLCD_B\t\t), \t\t.LCD_G\t\t(\tLCD_G\t\t), \t\t.LCD_R\t\t(\tLCD_R\t\t) \t); \tassign\t\tLCD_CLK\t\t \tCLK_PIX; endmodule ``` ## 综合、约束、布局布线 ### 综合 完成上面步骤后转到“Process”界面下，对编辑好的代码进行综合，即运行“Synthesize” ![](./../nano_9k/nano_9k_synthsize.png) 运行的结果如下图出现 ![](./../../Tang Nano/assets/LED.png) 且下方结果栏不出现任何从报错，说明前面编辑的代码无误，如果有错，根据错误提示进行改正即可。 ### 约束 此处仅管脚约束 对应的管脚约束如下表格所示； 关于管脚约束方法可以参考[点灯文章(点我)](./LED.html)里面的约束方法。 感觉麻烦的话也可以直接复制准备好的[文件(点我)](./lcd_constrains.html)，将页面里的内容复制到工程目录里 .cst 文件中（如果没有.cst 文件那么自己新建一个**物理管脚约束文件**） 即可。 PORT I/O PIN PORT I/O PIN LCD_B[4] output 41 LCD_B[3] output 42 LCD_B[2] output 51 LCD_B[1] output 53 LCD_B[0] output 54 LCD_G[5] output 55 LCD_G[4] output 56 LCD_G[3] output 57 LCD_G[2] output 68 LCD_G[1] output 69 LCD_G[0] output 70 LCD_R[4] output 71 LCD_R[3] output 72 LCD_R[2] output 73 LCD_R[1] output 74 LCD_R[0] output 75 LCD_DEN output 33 LCD_SYNC output 34 LCD_HYNC output 40 LCD_CLK output 35 XTAL_IN input 52 nRST input 4 ### 布局布线 管脚约束之后需要在设置里面开启引脚复用才能完成布局布线。 具体位置在 软件顶部菜单栏 Project > Configuration > Place&Route > Dual Purpose Pin ![](./../../Tang Nano/examples/led/assets/enable_io_mux.png) 设置完上面的之后。 就可以进行布局布线(Place&Route)了。 结束后就可以给开发板验证代码内容了。 ## 烧录 布局布线结束后生成比特流，就可以烧录开发板了。 ## 结束 上面差不多叙述了所有代码。 整个工程可以在参考 [这里](https://github.com/sipeed/TangNano 9K example) ，对应在lcd_led目录下。 <p id \"back\"> <a href \"#\" onClick \"javascript :history.back( 1);\">返回上一页(Back)</a> </p>"},"/hardware/zh/tang/Tang-Nano-9K/examples/LED.html":{"title":"点灯LED","content":" title: 点灯LED > 编辑于2022年7月13日 这里我们用点亮板子上的LED来作为例程来快速熟悉一下高云半导体 IDE 的使用流程 ## 创建工程 新建工程：File >NEW >FPGA Dsign Project >OK ![创建工程](./../../Tang Nano/assets/LED 1.png) 弹出的选项框设置工程名称和路径（路径和文件名称要求是英文路径） ![设置名称](./../../Tang Nano/assets/LED 2.png) 选择正确的型号： ![选择设备](./../nano_9k/Tang_nano_9k_Device_choose.png) ## 准备代码 新建好工程之后接下来进行代码编辑，可以在下图箭头指示的地方新建 “Verilog File” ![](./../../Tang Nano/assets/LED 5.png) 给文件命名（要求写英文名，不然后续综合很容易报错） ![](./../../Tang Nano/assets/LED 6.png) 双击文件，可以在右侧的编辑框中进行代码的编写。 ![](./../../Tang Nano/assets/LED 7.png) 以流水灯为例，将下方的 “LED例程代码” 复制并粘贴到自己创建的文件中，也可以自己编写代码，例程代码地址： <https://github.com/sipeed/TangNano 9K example> 使用 git clone 后可以在 led/src/LED.v 文件夹内找到代码 ```verilog module led ( input sys_clk, // clk input input sys_rst_n, // reset input output reg [5:0] led // 6 LEDS pin ); reg [23:0] counter; always @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) counter < 24'd0; else if (counter < 24'd1349_9999) // 0.5s delay counter < counter + 1'b1; else counter < 24'd0; end always @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) led < 6'b111110; else if (counter 24'd1349_9999) // 0.5s delay led[5:0] < {led[4:0],led[5]}; else led < led; end endmodule ``` 上面代码完成后需要在 Project >Configuration >Place&Route >Dual Purpose Pin 中将 `Use DONE as regular IO` 勾选上，不然下面的综合会报错。 ![img_configuration](./../nano_9k/LED_Configuration.png) ## 综合、约束、布局布线 ### 综合 保存编辑的代码后转到 “Process” 界面，双击 “Synthesize” 来对我们所编写的代码进行综合。也可以鼠标右键点击看看有啥功能 ![Synthesize](./../nano_9k/nano_9k_synthsize.png) 运行的结果如下图一样 ![Finish_Synthesize](./../../Tang Nano/assets/LED.png) 且下方结果栏不出现任何从报错，说明前面编辑的代码无误，如果有错，根据错误提示进行改正即可。 ### 约束 此处没有涉及时钟约束 想让 Fpga 实现代码的功能，必须将代码中涉及的端口绑定到 Fpga 实际的引脚上。 如下图，在左边的工作区点击 process，然后双击 FloorPlanner （前面的综合如果运行失败，这一步无法进行） ![FloorPlanner](./../../assets/examples/led_pjt_2.png) 第一次打开会弹出缺少 .cst 文件.选择 “OK” 即可； ![.cst_file](./../../Tang Nano/assets/LED 9.png) 可以在这里下载到 Nano 9K 的原理图 [这里](https://dl.sipeed.com/shareURL/TANG/Nano%209K/2_Schematic) Nano 9K 的 led 部分的原理图如下所示 ![led原理图](./../nano_9k/LED_Pins.png \"nano 9k led pins\") 对于交互式管脚约束有两种方法 将对应的端口拖拽到芯片引脚上 在 IO 约束中输入端口对应的引脚编号 管教绑定的具体方法可以参考 [SUG935 1.3_Gowin设计物理约束用户指南.pdf](http://cdn.gowinsemi.com.cn/SUG935 1.3_Gowin%E8%AE%BE%E8%AE%A1%E7%89%A9%E7%90%86%E7%BA%A6%E6%9D%9F%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf)。 当然别忘了对着原理图把晶振引脚和全局复位按键引脚也绑定一下 下图是本例程管脚约束示例 ![引脚约束](./../nano_9k/LED_FloorPlanner.png) ### 布局布线 > 未开启管脚复用会提示 error2017， 前文提到过启用方法 [准备代码](#准备代码) 到 Process 下运行布局布线，即双击 `Place&Route` ，结果将如下所示： ![Place&Route](./../nano_9k/LED_Place&Route.png) ## 下载到设备 ### 开始下载 双击 Program Device 打开下载软件 ![Programmer](./../../Tang Nano 4K/assets/Open_Programmer.png) 接下来是连接芯片型号，烧录固件，可参照下图选择芯片(注意这里是9C)： ![选择](./../nano_9k/nano_9k_device_scan.png) 以烧录进SRAM为例进行说明，如下图： 设置下载方式： ![设置sram下载方式](./../nano_9k/nano_9k_sram_program.png \"设置sram下载方式\") 进行下载： ![进行sram下载](./../nano_9k/nano_9k_sram_download.png \"进行sram下载\") ### 结果展示 结果显示： ![流水灯](./../nano_9k/blink.gif) ## 其他 有固化需求的话设置下载到 flash 即可 ![固化](./../nano_9k/access_mode.png) 有问题可以前往[相关问题](./../../common doc/questions.html) 当然也欢迎在下面留言 <p id \"back\"> <a href \"#\" onClick \"javascript :history.back( 1);\">返回上一页(Back)</a> </p>"},"/hardware/zh/tang/Tang-Nano-9K/Tang-nano-9k.html":{"title":"Tang nano 9k 一些例程","content":" title: Tang nano 9k 一些例程 ~~对于Programmer(下载程序)建议使用 [这里](https://dl.sipeed.com/shareURL/TANG/programmer/archived) 的文件。~~ ~~下载后解压替换掉Gowin对应安装目录的Programmer文件夹即可。~~ ~~不会替换的话可以在下载解压后的Programmer程序中手动添加对应下载文件来进行烧录。~~ > 以上要求并非必需，1.9.9 版本也可以正常工作。 > 如果您愿意，也可以尝试最新版本的 IDE。 [点灯例程](./examples/LED.html) [驱RGB屏教程](./examples/LCD.html) [PicoRV 在9K上运行的示例](./examples/picorv.html) [⭐ **Lumorphix** ⭐](https://brisbanesilicon.com.au/products/lumorphix/beta releases/#beta release 02.0001) [litex在9K上使用示例](https://github.com/curliph/tang_nano_9k_test) [FPGA驱动SPI屏幕](https://github.com/sipeed/TangNano 9K example/tree/main/spi_lcd) [HDMI显示例程](https://github.com/sipeed/TangNano 9K example/tree/main/hdmi) [Picotiny在9K上使用示例](https://github.com/sipeed/TangNano 9K example/tree/main/picotiny) ~~驱动MIPI接口屏幕：待更新~~ （*由于需要额外的转接板，计划暂时取消，请期待25K的相关例程*） 其他（有什么想法可以提出来，可行的话或许会被采纳）"},"/hardware/zh/tang/Tang-Nano-9K/Nano-9K.html":{"title":"Tang Nano 9K","content":"# Tang Nano 9K > 编辑时间 2022年1月13日 ## 简介 Tang Nano 9K 是基于高云半导体 GW1NR 9 FPGA芯片设计的精简型开发板。它搭载的HDMI连接器、RGB接口屏幕连接器、SPI屏幕连接器、SPI FLASH和6个LED使得用户可以方便且快速地进行FPGA验证，RISC V软核验证和功能样机验证。GW1NR 9拥有的8640 LUT4 逻辑单元除了可以用来设计各种复杂的逻辑电路，还可以运行完整的PicoRV软核，满足了用户学习FPGA、验证软核和深度设计的各种需求。 ## 产品参数 类别 数值 逻辑单元(LUT4) 8640 寄存器(FF) 6480 分布式静态随机存储器 <br>SSRAM(bits) 17280 块状静态随机存储器 <br>B SRAM(bits) 468K 块状静态随机存储器数目<br>BSRAM（个） 26 用户闪存(bits) 608K PSRAM(bits) 64M 高性能DSP模块 支持9x9,18x18,36x36bit的乘法运算和54bit累加器 乘法器 <br>(18 x 18 Multiplier) 20 SPI FLASH 32M bits 灵活的PLL资源 2个锁相环（PLLs） 显示屏幕接口 HDMI接口, SPI屏幕接口和RGB屏幕接口 调试器 板载BL702芯片，为GW1NR 9提供USB JTAG下载和USB UART串口打印功能 IO • 支持4mA、8mA、16mA、24mA等驱动能力 <br>• 对每个I/O提供独立的Bus Keeper、上拉/下拉电阻及Open Drain输出选项 连接器 TF卡座子, 2x24P 2.54mm 排针焊盘 按键 2个用户可编程按键 LED 板载6个可编程LED ### 板载功能框图 ![Generated](./assets/clip_image008.jpg) ### 板子引脚图 ![Generated](./assets/clip_image010.gif) ## 前代对比 Tang Nano 9K 是 Sipeed 所推出的第五款 FPGA 开发板，与在售前代产品参数对比如下： 版型 Tang Nano 1K Tang Nano 4K Tang Nano 9K : : : : 外观图 <img src \"./../../../zh/tang/Tang Nano/assets/clip_image002.gif\" width \"180\" > <img src \"./../../../zh/tang/Tang Nano/assets/clip_image004.gif\" width \"180\" > <img src \"./../../../zh/tang/Tang Nano/assets/clip_image006.gif\" width \"180\" > 逻辑单元 (LUT4) 1152 4608 8640 硬核处理器 Cortex M3 板载晶振 27MHZ 27MHZ 27MHZ 屏幕接口 RGB 屏幕接口 HDMI 接口 HDMI 接口, <br>RGB 屏幕接口,<br>SPI 屏幕接口 摄像头接口 默认 OV2640 外部存储 仅预留焊盘 32Mbits SPI flash 32Mbits SPI flash TF 卡槽 有 下载器 板载 USB JTAG 板载 USB JTAG 板载 USB JTAG & USB UART ## 适用人群 用法 FPGA MCU FPGA+MCU : : : : 语言 Verilog HDL/Verilog C/C++ Verilog HDL/Verilog ， C/C++ 简介 上板验证用户HDL 用户将软核的比特流文件下载到芯片后可将<br>GW1NR 9当做普通的MCU来使用 烧入软核后可以进行双核开发 适用人群 初学者，FPGA开发者 RISC V开发者，Cortex M开发者 资深软硬件工程师 ## 上手指引 1. 安装IDE和填写正确的License：[点击这里](https://wiki.sipeed.com/soft/Tang/zh/common doc/get_started/install the ide.html) 2. 阅读：[SUG100 2.6_Gowin云源软件用户指南.pdf](http://cdn.gowinsemi.com.cn/SUG100 2.5_Gowin%E4%BA%91%E6%BA%90%E8%BD%AF%E4%BB%B6%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf) 3. 阅读这个[教程](./examples/LED.html)完成点灯实验。 建议新手在完成这一步之后，自己重新独立新建项目、编写代码，完成这个实验，并且按自己的想法修改点灯程序，增强对FPGA和硬件描述语言的理解。 建议在这个过程阅读以下内容，阅读完才进入下一步： Verilog代码规范（自行搜索，从初学就培养良好的代码规范是非常必要的） 下面的这些内容对于初学者来说是非常有用的，对未来深入学习 FPGA 很有帮助。 [SUG100 2.6_Gowin云源软件用户指南.pdf](http://cdn.gowinsemi.com.cn/SUG100 2.6_Gowin%E4%BA%91%E6%BA%90%E8%BD%AF%E4%BB%B6%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf) [SUG949 1.1_Gowin_HDL编码风格用户指南.pdf](http://cdn.gowinsemi.com.cn/SUG949 1.1_Gowin_HDL%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf) <a href \"http://cdn.gowinsemi.com.cn/UG286 1.9.1_Gowin%E6%97%B6%E9%92%9F%E8%B5%84%E6%BA%90(Clock)%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf\">UG286 1.9.1_Gowin时钟资源(Clock)用户指南.pdf</a> [SUG940 1.3_Gowin设计时序约束用户指南.pdf](http://cdn.gowinsemi.com.cn/SUG940 1.3_Gowin%E8%AE%BE%E8%AE%A1%E6%97%B6%E5%BA%8F%E7%BA%A6%E6%9D%9F%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf) [SUG502 1.3_Gowin_Programmer用户指南.pdf](http://cdn.gowinsemi.com.cn/SUG502 1.3_Gowin_Programmer%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf) [SUG114 2.5_Gowin在线逻辑分析仪用户指南.pdf](http://cdn.gowinsemi.com.cn/SUG114 2.5_Gowin%E5%9C%A8%E7%BA%BF%E9%80%BB%E8%BE%91%E5%88%86%E6%9E%90%E4%BB%AA%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf) 上面的都已经打包进了下载站[点我跳转](https://dl.sipeed.com/shareURL/TANG/Nano%209K/6_Chip_Manual/CN/%E9%80%9A%E7%94%A8%E6%8C%87%E5%BC%95)。可以点击压缩包全都下载下来 其他学习链接： + 在线免费教程：[菜鸟教程](https://www.runoob.com/w3cnote/verilog tutorial.html)（学习Verilog） + 在线免费FPGA教程：[Verilog](https://www.asic world.com/verilog/index.html) + 在线高云半导体官方视频教程：[点击这里](http://www.gowinsemi.com.cn/video_complex.aspx?FId n15:15:26) 1. 按照这个[教程](./examples/LCD.html)进行5寸RGB屏驱动实验（其他尺寸屏幕自行修改一下）。 如果用户自行无法完成这个实验，可以下载我们[9K例程](https://github.com/sipeed/TangNano 9K example)（适配9K板子+5寸屏）查看哪个步骤没做正确 注意：屏幕接线时需要注意排线的1脚对应连接器旁的1脚丝印 需要阅读的文档： rPLL IP核的说明文档：在IDE里>Tools>IP Core Generator>Hard Module>CLOCK>rPLL>点击弹出界面右下角的Help按键就会弹出说明文档 <details> <summary><font color \"#4F84FF\">点开查看说明位置</font></summary> <img src \"./../assets/ip reference.png\"> </details> SUG284 2.1E_Gowin IP Core Generator User Guide.pdf [5寸屏规格书](https://dl.sipeed.com/fileList/TANG/Nano%209K/6_Chip_Manual/EN/LCD_Datasheet/5.0inch_LCD_Datashet%20_RGB_.pdf)：(主要是获取CLK是33.3Mhz这个信息) ## 例程汇总 访问 [相关例程](./../common doc/examples.html) 查看所有说明 ## 硬件资料 [规格书](https://dl.sipeed.com/shareURL/TANG/Nano%209K/1_Specification) [原理图](https://dl.sipeed.com/shareURL/TANG/Nano%209K/2_Schematic) [位号图](https://dl.sipeed.com/shareURL/TANG/Nano%209K/3_Bit_number_map) [尺寸图](https://dl.sipeed.com/shareURL/TANG/Nano%209K/4_Dimensional_drawing) [3D 模型文件](https://dl.sipeed.com/shareURL/TANG/Nano%209K/5_3D_file) [部分手册](https://dl.sipeed.com/shareURL/TANG/Nano%209K/6_Chip_Manual) 硬件资料总链接：[点击这里](https://dl.sipeed.com/shareURL/TANG/Nano%209K) ## 注意事项 1. 如果有什么疑问，欢迎加群 `834585530`, 或者直接在本页下方留言讨论。 2. 有问题的话先去 [常见问题](https://wiki.sipeed.com/hardware/zh/tang/common doc/questions.html) 自查。 3. 避免使用JTAG、MODE、DONE等引脚。如果一定要使用这些引脚，请查看 [UG292 1.0原理图指导手册](http://cdn.gowinsemi.com.cn/UG293 1.0_GW1NZ%E7%B3%BB%E5%88%97FPGA%E4%BA%A7%E5%93%81%E5%8E%9F%E7%90%86%E5%9B%BE%E6%8C%87%E5%AF%BC%E6%89%8B%E5%86%8C.pdf) 4. 请注意避免静电打到PCBA上；接触PCBA之前请把手的静电释放掉 5. 每个GPIO的工作电压已经在原理图中标注出来，请不要让GPIO的实际工作的电压超过额定值，否则会引起PCBA的永久性损坏 6. 在连接FPC软排线的时候，请确保排线无偏移、完整地插入到排线中，且线序正确没有接反 7. 请在上电过程中，避免任何液体和金属触碰到PCBA上的元件的焊盘，否则会导致短路，烧毁PCBA 8. 使用途中需要注意复用的 IO，比如 HDMI 的 IO 默认被外部上拉，因此在排针上使用相关引脚的时候可能会与自己想要的结果不符。 ![nano_9k_hdmi_io](./assets/nano_9k_hdmi_io.png)"},"/hardware/zh/tang/tang-nano-20k/nano-20k.html":{"title":"Tang Nano 20K","content":" title: Tang Nano 20K keywords: FPGA, Tang, Nano, 20K update: date: 2023 02 27 version: v0.1 author: wonder content: 新建文档 ## 简介 Tang Nano 20K 是采用高云半导体 [GW2AR 18 QN88](http://www.gowinsemi.com.cn/prod_view.aspx?TypeId 10&FId t3:10:3&Id 167#GW2AR) 的一款核心板，芯片内部具有 20736 个逻辑查找表(LUT4) 和 15552 个寄存器(FF)，内部有两个 PLL，还带有多个 DSP 单元支持 18位 x 18位 的乘法运算来加速数字运算。板载 [BL616](https://bouffalolab.com/product/?type detail&id 21) 芯片来作为 FPGA JTAG 下载器和与 FPGA 通信的串口。板上默认使用 27MHz 晶振用于倍频出 HDMI 显示所需要的时钟，还额外搭载 MS5351 时钟发生芯片来随意生成多种所需要的时钟。 淘宝购买链接：[点我](https://item.taobao.com/item.htm?id 717932028073) ## 外观渲染图 <img src \"./assets/nano_20k/tang_nano_20k_3920_top.png\" width \"40%\"> <img src \"./assets/nano_20k/tang_nano_20k_3920_bot.png\" width \"40%\"> ## 详细参数 <table> <thead> \t<tr> \t\t<th style \"text align:center\">项目</th> \t\t<th style \"text align:center\">参数</th> \t\t<th style \"text align:center\">补充</th> \t</tr> </thead> <tbody> \t<tr> \t\t<td style \"text align:left\">FPGA 芯片</td> \t\t<td style \"text align:left\"><a href \"http://www.gowinsemi.com.cn/prod_view.aspx?TypeId 10&amp;FId t3:10:3&amp;Id 167#GW2AR\">GW2AR LV18QN88C8/I7</a> \t\t</td> \t\t<td style \"text align:left\"> \t\t\t<table> \t\t\t\t<tbody> \t\t\t\t\t<tr> \t\t\t\t\t<td>逻辑单元(LUT4)</td> \t\t\t\t\t<td>20736</td> \t\t\t\t</tr> \t\t\t\t<tr> \t\t\t\t\t<td>寄存器(FF)</td> \t\t\t\t\t<td>15552</td> \t\t\t\t</tr> \t\t\t\t<tr> \t\t\t\t\t<td>分布式静态随机存储器S SRAM(bits)</td> \t\t\t\t\t<td>41472</td> \t\t\t\t</tr> \t\t\t\t<tr> \t\t\t\t\t<td>块状静态随机存储器B SRAM(bits)</td> \t\t\t\t\t<td>828K</td> \t\t\t\t</tr> \t\t\t\t<tr> \t\t\t\t\t<td>块状静态随机存储器数目B SRAM(个)</td> \t\t\t\t\t<td>46</td> \t\t\t\t</tr> \t\t\t\t<tr> \t\t\t\t\t<td>32bits SDR SDRAM</td> \t\t\t\t\t<td>64M bits</td> \t\t\t\t</tr> \t\t\t\t<tr> \t\t\t\t\t<td>乘法器(18x18 Multiplier)</td> \t\t\t\t\t<td>48</td> \t\t\t\t</tr> \t\t\t\t<tr> \t\t\t\t\t<td>锁相环(PLLs)</td> \t\t\t\t\t<td>2</td> \t\t\t\t</tr> \t\t\t\t<tr> \t\t\t\t\t<td>I/O Bank 总数</td> \t\t\t\t\t<td>8</td> \t\t\t\t</tr> \t\t\t</tbody></table> \t\t</td> \t</tr> \t<tr> \t\t<td style \"text align:left\">板载下载器</td> \t\t<td style \"text align:left\">BL616</td> \t\t<td style \"text align:left\">· 给 FPGA 提供 JTAG 下载功能<br>· 提供 USB 转串口与 FPGA 通信<br>· 提供虚拟串口用于 FPGA 通过 SPI 通信<br>· 提供虚拟串口控制 MS5351 输出时钟</td> \t</tr> \t<tr> \t\t<td style \"text align:left\">时钟芯片</td> \t\t<td style \"text align:left\">MS5351</td> \t\t<td style \"text align:left\">给 FPGA 芯片提供额外的三路时钟<br> \t\t\t<a href \"https://wiki.sipeed.com/hardware/zh/tang/tang nano 20k/example/unbox.html#pll_clk\">点我查看 MS5351 配置方法</a> \t\t\t</td> \t</tr> \t<tr> \t\t<td style \"text align:left\">显示接口</td> \t\t<td style \"text align:left\">· 40Pins RGB lcd 连接器<br>· HDMI 接口</td> \t\t<td style \"text align:left\"></td> \t</tr> \t<tr> \t\t<td style \"text align:left\"> 单色 LED </td> \t\t<td style \"text align:left\"> 6 个 </td> \t\t<td style \"text align:left\"> 共阳极连接 </td> \t</tr> \t<tr> \t\t<td style \"text align:left\"> RGB LED </td> \t\t<td style \"text align:left\"> 1 个 </td> \t\t<td style \"text align:left\"> 型号是 WS2812 </td> \t</tr> \t<tr> \t\t<td style \"text align:left\"> 用户按键 </td> \t\t<td style \"text align:left\"> 2 个 </td> \t\t<td style \"text align:left\"> 用于自定义逻辑功能 </td> \t</tr> \t<tr> \t\t<td style \"text align:left\"> TF 卡槽 </td> \t\t<td style \"text align:left\"> 1 个 </td> \t\t<td style \"text align:left\"> 推拉式 </td> \t</tr> \t<tr> \t\t<td style \"text align:left\"> 功率放大器 </td> \t\t<td style \"text align:left\"> 1 个 </td> \t\t<td style \"text align:left\"> 型号是 MAX98357A，用于播放音频 </td> \t</tr> \t<tr> \t\t<td style \"text align:left\"> 存储 </td> \t\t<td style \"text align:left\"> 64Mbits Flash </td> \t\t<td style \"text align:left\"> 下载方式参考底部相关问题 </td> \t</tr> \t<tr> \t\t<td style \"text align:left\"> 尺寸 </td> \t\t<td style \"text align:left\"> 22.55mm x 54.04mm </td> \t\t<td style \"text align:left\"> 精确尺寸可以参考 3D 文件 </td> \t</tr> </tbody> </table> ## 外设框图 ![tang_nano_20k_functionalannotation](./assets/nano_20k/tang_nano_20k_functionalannotation.jpg) 下面是更详细的外设框图 <img src \"./assets/nano_20k/tang_nano_20k_functionalannotation_top.png\" width \"40%\" alt \"tang_nano_20k_functionalannotation_top\"> <img src \"./assets/nano_20k/tang_nano_20k_functionalannotation_bot.png\" width \"40%\" alt \"tang_nano_20k_functionalannotation_bot\"> ## 引脚框图 ![tang_nano_20k_pinlabel](./assets/nano_20k/tang_nano_20k_pinlabel.png) ## FPGA Jtag 触点指示图 我们在 Tang Nano 20K 上引出了 Jtag 触点，方便想要使用额外下载器的用户。 > Tang Nano 20K 板卡上是带有下载器的，这个测试点只是给有额外需要的人准备的。 ![tang_nano_20k_testpointlannotation](./assets/nano_20k/tang_nano_20k_testpointlannotation.png) ## 硬件资料 [板卡规格书](https://dl.sipeed.com/shareURL/TANG/Nano_20K/1_Datasheet) [板卡原理图](https://dl.sipeed.com/shareURL/TANG/Nano_20K/2_Schematic) [PCB BOM](https://dl.sipeed.com/shareURL/TANG/Nano_20K/3_Bit_number_map) (根据自己板子的版本查看里面的 html 文件) [板卡尺寸图](https://dl.sipeed.com/shareURL/TANG/Nano_20K/4_Dimensional_drawing) [板卡 3D 模型](https://dl.sipeed.com/shareURL/TANG/Nano_20K/4_Dimensional_drawing) [部分芯片手册](https://dl.sipeed.com/shareURL/TANG/Nano_20K/6_Chip_manual) ## 上手使用 安装 IDE > 编写代码 > 烧录进板子 安装 IDE [点我](https://wiki.sipeed.com/hardware/zh/tang/common doc/get_started/install the ide.html) 开箱说明 [点我](https://wiki.sipeed.com/hardware/zh/tang/tang nano 20k/example/unbox.html) 点灯上手指南 [点我](https://wiki.sipeed.com/hardware/zh/tang/tang nano 20k/example/led.html) 更多例程代码 [github](https://github.com/sipeed/TangNano 20K example) ### 其他学习资源 在线免费教程：[Verilog 教程](https://www.runoob.com/w3cnote/verilog tutorial.html)（学习Verilog） 在线免费 FPGA 教程：[Verilog](https://www.asic world.com/verilog/index.html) （英文网站） Verilog 刷题网站：[HDLBits](https://hdlbits.01xz.net/wiki/Main_Page)（英文网站） 在线高云半导体可参考视频教程：[点击这里](http://www.gowinsemi.com.cn/video_complex.aspx?FId n15:15:26) ## 交流方式 **交流论坛: [bbs.sipeed.com](https://bbs.sipeed.com)** **QQ 交流群：[834585530](https://jq.qq.com/?_wv 1027&k wBb8XUan)** 直接本页下方留言 商业邮箱 : [support@sipeed.com](support@sipeed.com) ## 常见问题 ### 怎么让固件上电启动 Tang Nano 20K 使用外部 Flash 来存放固件，所以想要让固件存在板子上我们需要烧录到外部 Flash. ![nano_20k_flash_mode](./assets/led/nano_20k_flash_mode.png) ### 更多问题前往 [Tang 常见问题](https://wiki.sipeed.com/hardware/zh/tang/common doc/questions.html) 查看"},"/hardware/zh/tang/tang-nano-20k/example/unbox.html":{"title":"Tang Nano 20K 开箱","content":" title: Tang Nano 20K 开箱 keywords: FPGA, Tang, Nano, 20K update: date: 2023 05 22 version: v0.1 author: wonder content: 新建文档 Tang Nano 20K 主要有游戏套餐和普通开发板两种购买选项。 ## 初次通电 Tang Nano 20K 默认的固件内容是 [litex](https://github.com/litex hub) ，并且可以在 [github](https://github.com/sipeed/TangNano 20K example/tree/main/litex) 直接下载固件。 上电后可以看到板卡上的六颗 LED 以流水灯样式运行着。 ![unbox_nano_20k_led_water_flow](./../assets/unbox/unbox_nano_20k_led_water_flow.gif) 通电后 win10 和 win11 会自动加载驱动，然后在电脑的设备管理器中可以看到至少有一个串口设备，这时可以使用 [Mobaxterm](https://mobaxterm.mobatek.net/) 这类支持串口的软件来打开开发板上的串口。 ![unbox_device_manager_serial_port](./../assets/unbox/unbox_device_manager_serial_port.png) 设置波特率为 115200，然后打开开发板上的串口，就能进入默认 litex 固件的终端了。 ![unbox_uart_litex_terminal](./../assets/unbox/unbox_uart_litex_terminal.png) 使用 `Tab` 自动补全命令操作可以看到有一些指令能够让我们直接使用。 ![unbox_uart_litex_command_list](./../assets/unbox/unbox_uart_litex_command_list.png) 以最简单的 leds 为例，输入 `leds` 命令。 ![unbox_uart_litex_leds_command_help](./../assets/unbox/unbox_uart_litex_leds_command_help.png) 可以看到它要求 `leds` 命令后面加上一个 value . 下面是在串口终端中输入了 `leds 62` 后板子上 led 的变化。 ![unbox_uart_litex_leds_command_control](./../assets/unbox/unbox_uart_litex_leds_command_control.png) 可以看到板子上只有一颗 LED 亮起。 ![unbox_uart_litex_leds_command](./../assets/unbox/unbox_uart_litex_leds_command.jpg) 如果输入的数字过大的话，它会在串口提示将 led 状态设置成了 `0xffffffff`。 ![unbox_uart_litex_leds_max_value](./../assets/unbox/unbox_uart_litex_leds_max_value.png) ## 隐藏功能 上面的 litex 相关的终端操作都是在 FPGA 上运行的，Tang Nano 20K 除了 GW2AR 18C FPGA 外，还有一个板载的 BL616 芯片，可以进入它的终端来进行其他操作。 和前面一样，在 Mobaxterm 中打开串口之后，可以使用组合键 `Ctrl + x` 然后 `Ctrl + c`，最后按下回车来进入 BL616 芯片终端。 ![unbox_uart_bl616_terminal](./../assets/unbox/unbox_uart_bl616_terminal.png) 然后按下回车就到了终端了。支持 tab 补全命令。 ![unbox_uart_bl616_command_list](./../assets/unbox/unbox_uart_bl616_command_list.png) 这里主要需要关注 `pll_clk` 和 `choose` 这两个命令。 ### pll_clk Tang Nano 20K 板子上带有一颗 MS5351 精准时钟发生器，它由 BL616 终端的 `pll_clk` 命令来控制。 ![unbox_uart_bl616_pllclk_command](./../assets/unbox/unbox_uart_bl616_pllclk_command.png) MS5351 支持三路时钟输出，在原理图中可以看到以下对应关系： ![unbox_uart_bl616_ms351_clk_pin](./../assets/unbox/unbox_uart_bl616_ms351_clk_pin.png) 上图表示 CLK0 时钟连接到了 FPGA 的 PIN10 引脚，CLK1 时钟连接到了 FPGA 的 PIN11 引脚，CLK2 时钟连接到了 FPGA 的 PIN13 引脚. 配置 CLK1 输出 50M 时钟 `pll_clk O1 50M` <table> <tr> <td><img src \"./../assets/unbox/unbox_uart_bl616_ms351_set_o1_clk_50m.png\" alt \"unbox_uart_bl616_ms351_set_o1_clk_50m\"></td> <td> ① 输入命令后可以看到下面有一些 log <br> ② 再次输入 `pll_clk` 查看当前的配置 <br> ③ 可以看到 O1 目前是 50M 配置 <br> ④ 此处的 [EN] 表示 O1 正常工作，[DIS] 表示被禁用 </td> </tr> </table> 禁用 CLK1 `pll_clk O1` <table> <tr> <td><img src \"./../assets/unbox/unbox_uart_bl616_ms351_disable_o1_clk.png\" alt \"unbox_uart_bl616_ms351_disable_o1_clk\"></td> <td> ① 查看当前配置状态 <br> ② CLK1 正常工作状态 <br> ③ 执行禁用 CLK1 指令 <br> ④ CLK1 被禁用 </td> </tr> </table> 保存配置 `pll_clk s` ![unbox_uart_bl616_ms351_save](./../assets/unbox/unbox_uart_bl616_ms351_save.png) 设置 CLK2 输出 100M 时钟并且保存 `pll_clk O2 100M s` ![unbox_uart_bl616_ms351_clk2_100m](./../assets/unbox/unbox_uart_bl616_ms351_clk2_100m.jpg) ### choose `choose` 命令在 BL616 芯片中的作用是选择 BL616 与 FPGA 的通信方式。 ![unbox_uart_bl616_choose_list](./../assets/unbox/unbox_uart_bl616_choose_list.png) 打开串口时默认使用的是 `uart` 模式。在使用命令 `Ctrl + x`和 `Ctrl + c`，再敲下回车后， BL616 退出串口模式，回到终端模式。 `uart` 模式测试 在 BL616 终端执行 `choose uart` 命令，BL616 与 FPGA 进行串口通信。 ![unbox_uart_bl616_choose_uart](./../assets/unbox/unbox_uart_bl616_choose_uart.png) 输入完命令后终端会看起来卡住了一样，实际上这是因为 FPGA 没有向 BL616 发送串口消息。 默认的固件没有被清除的话，继续敲击回车就会重新回到 litex 终端了。 与前面的叙述一样，使用组合键 `Ctrl + x`和 `Ctrl + c`，再敲下回车后， BL616 退出串口模式，回到终端模式。 ![unbox_uart_bl616_quit_uart_mode](./../assets/unbox/unbox_uart_bl616_quit_uart_mode.png) `spi` 模式测试 SPI 模式时，BL616 作为 FPGA 的 SPI 从机，接收 FPGA 发送过来的数据。 ## 游戏机套装 Tang Nano 20K 可以加载/运行开源 FPGA NES 模拟器 [NESTang](https://github.com/nand2mario/nestang)，下面简述使用步骤。源码可以查看 [Tang Nano 20K nestang github example](https://github.com/sipeed/TangNano 20K example/tree/main/nestang) 或者 [NESTang](https://github.com/nand2mario/nestang)。 ### 硬件准备 一块 Tang Nano 20K 至少一个 Joystick 手柄和手柄转接板 一张 TF 卡与一个读卡器 一个面包板 (用来组合固定住板子) HDMI 显示器 ### 环境准备 Windows：[Gowin Programmer](http://www.gowinsemi.com.cn/faq.aspx) ， [balenaEtcher](https://etcher.balena.io/) 和 `python` Linux: [Openfpgaloader](https://github.com/trabucayre/openFPGALoader) 和 `python` Linux 烧录方法可以参考 [Tang Nano 20K nestang github example](https://github.com/sipeed/TangNano 20K example/tree/main/nestang)，下面主要基于 Windows 系统来说明使用步骤。 ### 烧录 FPGA 固件 使用 [Gowin Programmer](http://www.gowinsemi.com.cn/faq.aspx) 将 [这个固件](https://dl.sipeed.com/shareURL/TANG/Nano_20K/7_Nestang/firmware) 烧录到 FPGA 的 Flash 中。 ![unbox_burn_nestang_firmware_into_flash](./../assets/unbox/unbox_burn_nestang_firmware_into_flash.png) ### 制作游戏镜像 使用 [这些文件](https://dl.sipeed.com/shareURL/TANG/Nano_20K/7_Nestang/script)（都要下载），将想要运行的 NES 游戏 转换成能被 FPGA 识别的文件镜像。 使用下面的命令来将 `1.nes` `2.nes` `3.nes` 三个 NES 游戏转换成游戏镜像文件 (games.img)。 ```bash python nes2img.py o games.img 1.nes 2.nes 3.nes ``` > 提示 PIL 不存在时，手动通过 pip 安装一下。 在当前目录下就有生成的游戏镜像文件 games.img 了。 ### 烧录游戏镜像 在 Tang Nano 20K 上，需要使用 TF 卡来存储游戏，因此需要将游戏镜像文件烧录到 TF 卡。 这里使用 [balenaEtcher](https://etcher.balena.io/) 这个软件。 打开这个软件，选择 `Flash from file`, 选中之前生成的游戏镜像文件 `games.img` <img src \"./../assets/unbox/unbox_burn_nestang_game_image_select_file.png\" alt \"unbox_burn_nestang_game_image_select_file\" width \"48%\"> <img src \"./../assets/unbox/unbox_burn_nestang_game_image_choose_game_image.png\" alt \"unbox_burn_nestang_game_image_choose_game_image\" width \"48%\"> 会弹出一个警告，此时点击继续。 <img src \"./../assets/unbox/unbox_burn_nestang_game_warn_no_partition_table.png\" alt \"unbox_burn_nestang_game_warn_no_partition_table\" width \"48%\"> 接下来选择烧录的 TF 卡，不要选错了盘符。勾选 TF 卡后点击图中 ② 处来结束选择。 <img src \"./../assets/unbox/unbox_burn_nestang_game_change_tfcard_select.png\" alt \"unbox_burn_nestang_game_change_tfcard_select\" width \"48%\"> <img src \"./../assets/unbox/unbox_burn_nestang_game_select_tf_card.png\" alt \"unbox_burn_nestang_game_select_tf_card\" width \"48%\"> 点击烧录，提示烧录成功后就可以取出 TF 卡并且将 TF 卡插入到 FPGA 了。 <img src \"./../assets/unbox/unbox_burn_nestang_game_burn_game_image.png\" alt \"unbox_burn_nestang_game_burn_game_image\" width \"48%\"> <img src \"./../assets/unbox/unbox_burn_nestang_game_finish_burn_game_image.png\" alt \"unbox_burn_nestang_game_finish_burn_game_image\" width \"48%\"> ### 组装板子 插入 TF 卡到板子中 ![unbox_burn_nestang_game_tf_card_onsert](./../assets/unbox/unbox_burn_nestang_game_tf_card_onsert.jpg) 将板卡和手柄转接板都连接在面包板上 ![unbox_burn_nestang_game_breadboard_connecting](./../assets/unbox/unbox_burn_nestang_game_breadboard_connecting.jpg) 注意上图的红色直线，那表明了手柄转接板与 FPGA 应当对应的引脚 连接上手柄和 HDMI 线 ![unbox_burn_nestang_game_connect_hdmi_cable](./../assets/unbox/unbox_burn_nestang_game_connect_hdmi_cable.jpg) > 连接双手柄时，玩家 ① 使用的是上图中右侧的手柄 ### 开始游戏 给 Tang Nano 20K 通上电，然后会显示出游戏菜单，里面的游戏数量和名称都是根据制作游戏镜像文件时所使用的 NES 游戏文件和名称来生成的。 ![unbox_burn_nestang_power_game](./../assets/unbox/unbox_burn_nestang_power_game.jpg) 按下手柄上的 `②` 或者 `O` 来启动游戏 按下 FPGA 板子上的 `S1` 来重新进入游戏选单 ## 编程使用 手把手教上手点灯 > [点我](https://wiki.sipeed.com/hardware/zh/tang/tang nano 20k/example/led.html)"},"/hardware/zh/tang/tang-nano-20k/example/led.html":{"title":"Tang Nano 20K 点灯","content":" title: Tang Nano 20K 点灯 keywords: FPGA, Tang, Nano, 20K update: date: 2023 03 24 version: v0.1 author: wonder content: 新建文档 这里我们用点亮板子上的LED来作为例程来快速熟悉一下高云半导体 IDE 的使用流程 对于软件开发来说，输出 `hello world` 就是入门了。对于硬件相关的开发而言，点灯就是同款入门。 ## 安装 IDE 参考 [安装IDE](https://wiki.sipeed.com/hardware/zh/tang/common doc/get_started/install the ide.html) 来完成我们需要准备的软件环境。 对于 Linux 用户的话建议使用 [openfpgaLoader](https://wiki.sipeed.com/hardware/zh/tang/common doc/get_started/flash_in_linux.html) 这软件来烧录这款设备。 ## 新建工程 文件 > 新建 > FPGA Design > Project <div> <img src \"./../../tang primer 20k/examples/assets/led_assets/new_project.png\" width 58% alt \"new_project\"> <img src \"./../../tang primer 20k/examples/assets/led_assets/fpga_project.png\" width 35% alt \"fpga_project\"> </div> 设置工程名称，要求只用英文的下划线命名，存放路径中不要有中文字符或者空格等特殊符号。 ![project_path](./../../tang primer 20k/examples/assets/led_assets/project_path.png) 然后在下面的芯片型号中选择 GW2AR LV18QN88C8/I7，使用上面的筛选能够更快地选择到正确的型号。注意 Device 那一栏为 GW2AR 18C。 ![device_choose](./../assets/led/nano_20k_device_device_choose.png) 然后点击确定后就可以进行最终项目预览了。确认无误后就完成工程创建了。 ## 编写代码 ### 新建文件 高云半导体 IDE 提供了三种新建文件的方法。在此我们直接使用快捷键 `Ctrl + N` 来新建文件，其他两种不在此讲述。 在弹出的窗口中选择 `Verilog File`，会 VHDL 的也可以选择下面的 `VHDL File`，这篇文章只用 Verilog 来做点灯示例。 <img src \"./../../tang primer 20k/examples/assets/led_assets/new_verilog_file.png\" width 50% alt \"new_verilog_file\"> 点击 OK 之后会提示让我们输入文件名称，此处以 `led` 为文件名做示范。 <img src \"./../../tang primer 20k/examples/assets/led_assets/file_name.png\" width 75% alt \"file_name\"> 到这里我们就完成文件的创建了，可以直接编写代码了。 ![nano_20k_created_file.png](./../assets/led/nano_20k_created_file.png.png) ### Verilog 简单说明 Verilog 是一种硬件描述语言，用来对数字电路进行抽象化描述。 Verilog 的基本设计单元是“模块”(module)。 一个模块是由两部分组成的：一部分描述接口，另一部分描述内部逻辑功能，即定义输入是如何影响输出的。 一个模块长成这样： ```v module module_name #(parameter) (port) ; function endmodule ``` 模块整体结构由 module 和 endmodule 组成，module 后面跟着的是模块的名称(module_name)，可传递变量参数(parameter)，端口及其方向的申明(port)，紧接着就是内部逻辑功能描述(function) ,最后用 endmodule 来表示这一个模块，描述完毕。 内部逻辑功能通常由 assign 和 always 块完成；其中 assign 语句描述逻辑功能，always 块常用于描述时序功能。 ### 阻塞赋值与非阻塞赋值 在时序逻辑描述中，赋值符号有 ` ` 和 `< ` 两种。注意 `< ` 在 if 判断语句中为小于或等于，不是赋值符号。 详细解释查看底部的 [阻塞赋值与非阻塞赋值区别](#阻塞赋值与非阻塞赋值区别) ### 代码思路 写代码前我们需要先想清楚代码目的：每隔 0.5S 灯闪一次。 对此所画的需求框图如下： ![block_method](./../../tang primer 20k/examples/assets/led_assets/block_method.png) 然后对于 0.5S 我们需要一个计数器来计时，LED 灯闪就是 IO 翻转 ![count_block](./../../tang primer 20k/examples/assets/led_assets/time_count.png) 把上面的思维框图具体到实际使用的话，就变成下面的样式了: ![clock_time_count](./../../tang primer 20k/examples/assets/led_assets/clock_time_count.png) 其中 Clock 为时钟源，用来给计时器提供准确的时间。 ### 代码描述 根据上文 Verilog 简单说明和所描述的框图，可以所要编写 Verilog 模块有 Clock 和 IO电平 两个端口； ```v module led( input Clock, output IO_voltage ); endmodule ``` 对于内部的计时模块，Primer 20K 核心板上的晶振为 27MHZ，因此我们每秒钟会有 27000000 个时钟上升沿，想要 0.5S 计数的话那么只需要计数 13500000 次上升沿就好。计数是从 0 开始的，数 13500000 的话就是从 0 数到 13499999。计数完后我们需要设置一个标志位，来通知 LED 的 IO 翻转一下电平。整体计数代码如下： ```v //parameter Clock_frequency 27_000_000; // 时钟频率为27Mhz parameter count_value 13_499_999; // 计时 0.5S 所需要的计数次数 reg [23:0] count_value_reg ; // 计数器 reg count_value_flag; // IO 电平翻转标志 always @(posedge Clock) begin if ( count_value_reg < count_value ) begin //没有计数到 0.5S count_value_reg < count_value_reg + 1'b1; // 继续计数 count_value_flag < 1'b0 ; // 不产生翻转标志 end else begin //计数到 0.5S 了 count_value_reg < 23'b0; // 清零计数器，为重新计数最准备 count_value_flag < 1'b1 ; // 产生翻转标志 end end ``` 对于 LED IO 电平翻转代码如下： ```v reg IO_voltage_reg 1'b0; // 声明 IO 电平状态用于达到计时时间后的翻转，并赋予一个低电平初始态 always @(posedge Clock) begin if ( count_value_flag ) // 电平翻转标志有效 IO_voltage_reg < ~IO_voltage_reg; // IO 电平翻转 else // 电平翻转标志无效 IO_voltage_reg < IO_voltage_reg; // IO 电平不变 end ``` 将上面的代码整合后就变成了下面的内容: ```v module led( input Clock, output IO_voltage ); /**********计时部分**********/ //parameter Clock_frequency 27_000_000; // 时钟频率为27Mhz parameter count_value 13_499_999; // 计时 0.5S 所需要的计数次数 reg [23:0] count_value_reg ; // 计数器 reg count_value_flag; // IO 电平翻转标志 always @(posedge Clock) begin if ( count_value_reg < count_value ) begin //没有计数到 0.5S count_value_reg < count_value_reg + 1'b1; // 继续计数 count_value_flag < 1'b0 ; // 不产生翻转标志 end else begin //计数到 0.5S 了 count_value_reg < 23'b0; // 清零计数器，为重新计数最准备 count_value_flag < 1'b1 ; // 产生翻转标志 end end reg IO_voltage_reg 1'b0; // 声明 IO 电平状态用于达到计时时间后的翻转，并赋予一个低电平初始态 /**********电平翻转部分**********/ always @(posedge Clock) begin if ( count_value_flag ) // 电平翻转标志有效 IO_voltage_reg < ~IO_voltage_reg; // IO 电平翻转 else // 电平翻转标志无效 IO_voltage_reg < IO_voltage_reg; // IO 电平不变 end /**********补充一行代码**********/ assign IO_voltage IO_voltage_reg; endmodule ``` 上面代码最后面补充了一行代码，是因为 IO_voltage 声明在了 port 位置，默认为 wire 型，想要将它与 reg 变量 IO_voltage_reg 连接起来，需要用到 assign 语句。 ## 综合，约束，布局布线 ### 综合 代码保存后，可以双击 IDE 内部的 Process > Synthesize 来进行代码综合，将 verilog 代码内容转换为综合网表。 ![synthesize](./../../tang primer 20k/examples/assets/led_assets/synthesize.png) 关于网表有兴趣的可以自己去查阅相关资料，此处不再额外说明。 ### 约束 综合完之后我们需要进行管脚约束，才能将所编写的模块端口与 FPGA 引脚相对应，并且实现模块的功能。 点击上图 Synthesize 上面的 FloorPlanner 来进行管脚约束。 ![floorplanner](./../../tang primer 20k/examples/assets/led_assets/floorplanner.png) 由于是首次创建，所以会弹出下面的对话框，点击 OK 后就弹出了图形化约束交互界面。 ![create_constrain_file](./../../tang primer 20k/examples/assets/led_assets/create_constrain_file.png) ![nano_20k_floorplanner_interface](./../assets/led/nano_20k_floorplanner_interface.png) 关于约束的方法可以查看 [SUG935 1.3_Gowin设计物理约束用户指南.pdf](http://cdn.gowinsemi.com.cn/SUG935 1.3_Gowin%E8%AE%BE%E8%AE%A1%E7%89%A9%E7%90%86%E7%BA%A6%E6%9D%9F%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf) 此处因个人喜所以仅使用下图中 IO Constranins 方法来约束引脚： ![floor_planner_ioconstrain](./../../tang primer 20k/examples/assets/led_assets/floor_planner_ioconstrain.png) 根据[核心板原理图](https://dl.sipeed.com/fileList/TANG/Primer_20K/02_Schematic/)，我们可以知道晶振所输入的引脚为 PIN04。 <img src \"./../assets/led/nano_20k_crystal_port.png\" alt \"nano_20k_crystal_port\" width 45%> 结合原理图上 LED 所连接的引脚，这里只对 LED0 进行操作 ![nano_20k_led_port](./../assets/led/nano_20k_led_port.png) 因此对于在 FloorPlanner 交互窗口下面的 IO Constranins 中将 PORT（端口）与 Location（引脚） 分别填入下面的值： ![nano_20k_io_constrain_value](./../assets/led/nano_20k_io_constrain_value.png) 输入完毕后快捷键 Ctrl + S 来保存一下引脚约束，然后接可以关闭 FloorPlanner 的交互图形界面了。 接着发现在工程项目里面多出来刚刚创建的 cst 文件了，里面的内容也比较好理解。 ![nano_20k_cst_content](./../assets/led/nano_20k_cst_content.png) ### 布局布线 完成约束后就要开始运行布局布线了，目的是为了把综合所生成的网表与我们自己定义的约束来通过 IDE 算出最优解然后将资源合理地分配在 FPGA 芯片上。 双击下图红框处的 Place&Route 就开始运行了。 ![nano_20k_place_route](./../assets/led/nano_20k_place_route.png)。 紧接着没有报错，全部通过。就可以开始进行烧录了。 ## 烧录固件 Tang Nano 20K 板卡上搭载了 BL616 芯片，用来烧录 FPGA 固件到板卡中。 在 [安装IDE](https://wiki.sipeed.com/hardware/zh/tang/common doc/get_started/install the ide.html) 的时候已经安装了驱动。因此我们将板子与电脑连接起来就行。 ![nano_20k_led_connect_debug](./../assets/led/nano_20k_led_connect_debug.png) ### 扫描设备 双击下图中的下载程序(Program Device) 来运行 Programmer 软件 ![open_programmer](./../../tang primer 20k/examples/assets/led_assets/open_programmer.png) 然后在打开的页面中点击一下 scan_device 来扫描到我们的设备。 ![nano_20k_scan_device](./../assets/led/nano_20k_scan_device.png) 点击 OK 后就可以接下来对 FPGA 进行操作了。 烧录相关的文档可以参考 [SUG502 1.3_Gowin_Programmer用户指南.pdf](http://cdn.gowinsemi.com.cn/SUG502 1.3_Gowin_Programmer%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf) ### 下载到 SRAM 一般来说这个模式是以用来快速验证所生成的固件是否满足自己目的的。 因为其烧录快的特性所以使用的较多，然是当然断电会丢失数据，所以如果想上电运行程序的话是不能选这个的。 点击 Operation 下面的功能框来打开设备设置界面，接着在 Operation 框中选择 SRAM Program 选项来设置为下载到 SRAM ，最后点击下面的那三个点点框来选择我们所生成的 .fs 下载固件。通常来说下载固件生成与工程文件目录下的 impl > pnr 目录下。 ![sram_mode](./../assets/led/nano_20K_sram_mode.png) 接着来点击红框处开始进行烧录 ![nano_20k_sram_download](./../assets/led/nano_20k_sram_download.png) 有问题的话可以前往 [常见问题](https://wiki.sipeed.com/hardware/zh/tang/common doc/questions.html) 自行排查。 到这里就下载完成了。 ### 下载到 Flash 上面说过下载到 SRAM 是为了快速验证，但是不能上电运行程序。 所以想要上电运行的话我们需要设置下载到 Flash。 和上面下载到 SRAM 的步骤几乎类似，先点开 Operation 下面的功能框来打开设备设置界面，接着在 Operation 框中选择 External Flash Mode 选项来设置为下载到外部 Flash ，最后点击下面的那三个点点框来选择我们所生成的 .fs 下载固件，通常来说下载固件生成与工程文件目录下的 impl > pnr 目录下。最后在下面的外部 Flash 选项中选择设备为 Generic Flash 。 ![nano_20k_flash_mode](./../assets/led/nano_20k_flash_mode.png) 接着来点击红框处开始进行烧录 ![nano_20k_flash_download](./../assets/led/nano_20k_flash_download.png) 然后我们的程序重新上电也能照样运行了。 ## 代码结果 如图所示，只有一个灯在闪。 ![nano_20k_led_blink](./../assets/led/nano_20k_led_blink.gif) ## 结语 到这里我们就已经完成了 FPGA 的 “Hello world” 了。以后的示例工程不会再叙述新建文件等操作了。 ## 阻塞赋值与非阻塞赋值区别 以下内容搬运自 `大猪蹄子` （有改动）： 编写一段简单的代码，对它进行简单的仿真： ```v module test( input CLK, input [3:0] A, output reg [3:0] B,C,D,E ); always@(posedge CLK) begin B < A; C < B; D A; E D; end endmodule ``` ![simulation_result](./../../tang primer 20k/examples/assets/led_assets/simulation_result.png) 根据仿真结果我们可以看出阻塞和非阻塞赋值的差别。这里对比 `B` `C` `D` `E` 四种结果。`< ` 叫做非阻塞赋值，同一个 `always` 中的 `< ` 会同时执行。这就造成了绿框内的情况：`B` 直接被赋予 `A` 的值同时 `C` 被赋予 `B` 的值。由于这两步是同时进行的，就导致 `C` 被赋予的值是 `B` 的旧值，也就造成了图中所示，`C` 的数据变化时钟要慢 `B` 一个时钟周期。再说阻塞赋值 ` `，也就是说同一个 `always` 中上一个 ` ` 语句执行完才会执行下一个 ` ` 语句。在这个代码中，上一个语句 `D` 已经被赋予了 `A` 的值，才执行把 `D` 的值赋给 `E`，所以 `D` 、`E` 的值在仿真中始终保持一致。 > 不过一般来说，不建议在时序逻辑中使用阻塞赋值 ` `。 也得出了额外两个结论： 第一，输入的数据不是完全有效，以时钟边沿时刻的输入数据为准。`posedge` 就是以上升沿执行，`negedge` 就是以下降沿执行。如果数据维持的时间小于一个时钟周期，就很有可能采集不到（如红框所示）。 第二、每次触发特定时钟边沿，对应的 `always` 块就会从头到尾执行一次代码（如绿框所示），而不是从中间某处执行。 ## 常见问题 前往 [Gowin 板卡常见问题查看](./../../common doc/questions.html)"},"/hardware/zh/tang/tang-console/mega-console.html":{"title":"Tang Console","content":" title: Tang Console keywords: FPGA, Tang, Console, 60K, 138K update: date: 2025 01 23 version: v0.1 author: Serika content: 新建文档 date: 2025 04 17 version: v0.2 author: Serika content: 加入Retro Console相关内容 date: 2025 09 25 version: v0.3 author: Serika content: 移除了无法使用的lic server IP地址 ## 产品概述 发售日期：2025年4月中旬 **游戏机相关内容：**[**点我**](./retro console) 淘宝购买链接：[点我](https://item.taobao.com/item.htm?id 740536508140) ## 板卡特点 注意，本页面主要以开发板视角介绍板卡，如需了解作为复古游戏机的**Retro Conssole**，请[**【移步这里】**](./retro console) 兼容多种SOM (**[Mega 138k](./../tang mega 138k/mega 138k)** & **[Mega 60k](./../*tang mega 60k/mega 60k)**) 更小更紧凑更经济 兼容 **RPi 5 PCIe FPC**（然而由於PCIe硬核和arm的PCIe控制器存在兼容性问题，需要在未来的软体更新中解决。） **PCIe Gen2/3 x 1** FPC连接器 **USB3 x 2** (Type A, Device, 5Gbps or 10Gbps) **USB2 x 2** (Type A, Host, 1.5Mbps or 12Mbps) **HDMI TX x 1** (1080P 30Hz/720P 60Hz) **Soft PHY USB2 x1** (Typc C, Device, 480Mbps) 板载3.7V锂离子电池（1S）充放电管理电路 **PMOD x 2** 标准间距，可使用双PMOD模组 ## 产品外观 <img src \"./assert/console_60k.jpg\" width \"45%\"> <img src \"./assert/console_138k.jpg\" width \"45%\"> ## 硬件参数 ### 硬件框图 <details> <summary><font color \"#4F84FF\">点击此处查看</font></summary> <br> <img src \"./assert/console_bdt.jpg\" width \"45%\"> <img src \"./assert/console_bdb.jpg\" width \"45%\"> </details> ### 核心板（SOM）参数 请根据实际安装的SOM，参考如下连接： **[Tang Mega 138k](./../tang mega 138k/mega 138k#核心板参数) 核心板** **[Tang Mega 60k](./../tang mega 60k/mega 60k#核心板参数) 核心板** ### 底板参数 项目 数量 备注 : LEDs 2(3+3) 电源指示灯x3 + 用户指示灯x3 (共计2颗RGB LED) Buttons 2+1 用户按键x2 + MODE（reconfig）按键x1 PCIe 1 1通道 8/5Gbps (取决于核心板) USB3 2 SERDES 通道，超速 @ 5Gbps (设备模式) USB2 1 IO Soft PHY，高速 @ 480Mbps (设备模式) DVI(HDMI) 1 兼容HDMI， 支持TX， 可通过修改实现RX PMOD 2 标准间距（800mil），支持双PMOD模组 ADC 2 两组独立输入通道（其中一组用于锂电池电压测量） RGB 接口 1 40P 0.5mm间距FPC，支持RGB88，支持RGB转VGA模组 microSD 插槽 1 支持4 bit SDIO/MMC 或 SPI 模式 电池连接器 1 支持 3.7V 锂离子电池， 内置电池充放电管理 风扇连接器 1 支持5V直流风扇，最大功率1W 扬声器连接器 1 支持2W扬声器，单声道输出 MS5351 1 为 Serdes 提供 RefClk，通过板载调试器的 UART 控制 USB JTAG & UART 1 板载调试器支持FPGA编程，并提供UART功能 2x20P 排针连接器 2 独立的2x20P排针，最多提供2x38个IO，可通过修改兼容DE10 Nano Kit ## 硬件资料 ~~[板卡规格书](https://dl.sipeed.com/shareURL/TANG/Console/01_Specification)~~ [板卡原理图](https://dl.sipeed.com/shareURL/TANG/Console/02_Schematic) [PCB BOM](https://dl.sipeed.com/shareURL/TANG/Console/03_Designator_drawing) [板卡尺寸图](https://dl.sipeed.com/shareURL/TANG/Console/04_Mechanical_drawing) [板卡 3D 模型](https://dl.sipeed.com/shareURL/TANG/Console/05_3D_file) [部分芯片手册](https://dl.sipeed.com/shareURL/TANG/Console/07_Datasheet) [全引脚约束](https://dl.sipeed.com/shareURL/TANG/Console/08_Misc) ## 上手使用 注意60K目前已经被教育版支持，需要下载 V1.9.11.03 或更新版本的教育版IDE使用。 商业版IDE需要 ≥V1.9.10.03。 如需将码流下载到flash中固化，推荐使用 **exFlash Erase,Program thru GAO Bridge 5A** 模式（需要≥V1.9.10.03），或者 **exFlash Erase,Program thru GAO Bridge Arora V** （需要≥V1.9.12）。 推荐使用单独的 **1.9.12 SP1** Programmer（aka. 云源编程器），在 **云源软件商业版** 的页面可以找到。这个单独的Programmer兼容性更好。 如果需要使用商用版IDE，Lic 可以在高云官网申请，或者使用Sipeed提供的在线Lic服务，在IDE中选择Float Lic，填写以下信息即可： ~~~ Server 01 ip: 106.55.34.119 port: 10559 ~~~ 如果上面的IP不能工作, 尝试使用 \"gowinlic.sipeed.com\" 域名对应的IP. 例程代码（Github）： [60K](https://github.com/sipeed/TangMega 60K example) [138K](https://github.com/sipeed/TangMega 138K example) [TangCores](https://github.com/nand2mario/tangcores) 特别鸣谢：**[nand2mario](https://github.com/nand2mario)** *** ### 其他学习资源 在线免费教程：[Verilog 教程](https://www.runoob.com/w3cnote/verilog tutorial.html)（学习Verilog） 在线免费 FPGA 教程：[Verilog](https://www.asic world.com/verilog/index.html) （英文网站） Verilog 刷题网站：[HDLBits](https://hdlbits.01xz.net/wiki/Main_Page)（英文网站） 在线高云半导体可参考视频教程：[点击这里](http://www.gowinsemi.com.cn/video_complex.aspx?FId n15:15:26) ## 交流方式 **交流论坛: [maixhub.com/discussion](https://maixhub.com/discussion)** **QQ 交流群：[834585530](https://jq.qq.com/?_wv 1027&k wBb8XUan)** 直接本页下方留言 商业邮箱 : [support@sipeed.com](support@sipeed.com) ## 注意事项 <table> <tr> <th>事项</th> <th>注意事项</th> </tr> <tr> <td>芯片型号</td> <td>Tang Console 60K 使用的 FPGA 芯片具体型号是 <b>GW5AT LV60PG484AC1/l0</b> <br>Tang Console 138K 使用的 FPGA 芯片具体型号是 <b>GW5AST LV138PG484AC1/l0</b> <br>在 IDE 中选择封装型号 <span><b>PBG484A</b></span> & <span><b>Device Version: B</b></span></td> </tr> <tr> <td>静电</td> <td>请避免静电打到 PCBA 上；接触 PCBA 之前请把手的静电释放掉</td> </tr> <tr> <td>容忍电压</td> <td> 使用 GPIO 排针引脚进行外部通信时，要确保 IO 电压是 3.3V，过高的电压会永久损坏 PCBA </td> </tr> <tr> <td>FPC 座子</td> <td>在连接 FPC 软排线的时候，请确保排线无偏侈地完整地插入到排线中 <br>在通电之前请仔细核对两端FPC 连接器的 <b>1号PIN</b> 的方向是否正确</td> </tr> <tr> <td>插拔</td> <td>请完全断电后才进行配件的插拔操作</td> </tr> <tr> <td>避免短路</td> <td>请在上电过程中，避免任何液体和金属触碰到 PCBA 上的元件的焊盘，否则会导致路，烧毁 PCBA</td> </tr> </table> ## 联系 Tang Console 可以在多种场景实现客户不同方面的需要，技术支持和商业合作请联系邮箱 [support@sipeed.com](support@sipeed.com) ## 常见问题 ### 板子电源指示灯亮了，Programmer提示No USB Cable Connection <details> <summary><font color \"#4F84FF\">点击查看详情</font></summary> <br> 1. 请检查USB线是否正确接入标记为 **MCU** 的USB C连接器 2. 尽量避免使用机箱前面板的USB连接器和没有独立供电的USB HUB 3. 检查自己是否正确安装FT2232的驱动：出现USB Serial Converter A/B <img src \"./../assets/FTDI_DEVICE.jpg\" alt \"flash_mode\" width 35%> 4. 通常情况下Windows会在联网后自动安装相应驱动。如果想要手动处理，请前往[相关问题](./../common doc/questions)查看相关内容 5. 尝试更新板载下载器的固件，请参考这里 **[【点我跳转】](./../common doc/update_debugger)** </details> ### IDE找不到型号GW5AT LV60PG484A 或 GW5AST LV138PG484A <details> <summary><font color \"#4F84FF\">点击查看详情</font></summary> <br> 1. IDE版本过老，必须更新商业版IDE ≥ 1.9.10.03，或教育版IDE ≥ 1.9.11.03。 </details> ### 如何下载到外部 FLASH（固化） {#burn_flash} <details> <summary><font color \"#4F84FF\">点击查看详情</font></summary> <br> 1. 进行如下选项设置： <img src \"./../assets/flash_mode_GAO.png\" alt \"flash_mode\" width 35%> </details> ### 烧录后没反应或者引脚现象不对 <details> <summary><font color \"#4F84FF\">点击查看详情</font></summary> <br> 1. 首先确定IDE选择了正确的型号 对于60K，**GW5AT LV60PG484AC1/10**，下图中的每一个参数都要求一致； <img src \"../tang mega 60k/assets/partno_60K.png\" alt \"device_choose\" width 35%> 对于138K，**GW5AST LV138PG484AC1/10**，下图中的每一个参数都要求一致； <img src \"../tang mega 138k/assets/partno_138K.png\" alt \"device_choose\" width 35%> 2. 然后检查自己的代码和对应的仿真波形是否满足要求，使用云源软件（GOWIN IDE）的GAO工具可以进行片上仿真。更多详情请参考GOWIN文档[SUG100](https://cdn.gowinsemi.com.cn/SUG100 4.0_Gowin%E4%BA%91%E6%BA%90%E8%BD%AF%E4%BB%B6%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf)中关于GAO工具的描述。 </details> ### PCB勘误 <details> <summary><font color \"#4F84FF\">点击查看详情</font></summary> <br> 记录 **Tang Console** 各版本中已知的PCB问题 如果您发现了设计的错误，请在**勘误页面**留言 [**点我前往**](./errata console) </details> </br> ### 更多问题及其解决办法前往[相关问题](./../common doc/questions)查看"},"/hardware/zh/tang/tang-console/errata-console.html":{"title":"Errata for Tang Console","content":" title: Errata for Tang Console keywords: FPGA, Tang, Console, 60K, 138K update: date: 2025 04 22 version: v0.1 author: Serika content: 新建文档 ## 勘误记录 ### PCB Version: 32001 <details> <summary><font color \"#4F84FF\">点击查看详情</font></summary> <br> 1. **BOT面** 关于 **电池连接器** 的丝印标注错误，下图中的标记 **`GND`** 和 **`BAT`** 应当互换（**TOP面** 的标记是正确的）； <img src \"./assert/errata/errata_GBL BAT.jpg\" alt \"flash_mode\" width 35%> </details> </br> ### PCB Version: 32001B <details> <summary><font color \"#4F84FF\">点击查看详情</font></summary> <br> 1. **BOT面** 关于 **电池连接器** 的丝印标注错误，下图中的标记 **`GND`** 和 **`BAT`** 应当互换（**TOP面** 的标记是正确的）； <img src \"./assert/errata/errata_GBL BAT.jpg\" alt \"flash_mode\" width 35%> </details> </br> ### PCB Version: 32001C <details> <summary><font color \"#4F84FF\">点击查看详情</font></summary> <br> 1. **BOT面** 关于 **电池连接器** 的丝印标注错误，下图中的标记 **`GND`** 和 **`BAT`** 应当互换（**TOP面** 的标记是正确的）； <img src \"./assert/errata/errata_GBL BAT.jpg\" alt \"flash_mode\" width 35%> </details> </br> ## 更改记录 ### PCB Version: 32001C TBD"},"/hardware/zh/tang/tang-console/retro-console.html":{"title":"Tang Console","content":" title: Tang Console keywords: FPGA, Tang, Console, Retro, 60K, 138K update: date: 2025 04 17 version: v0.1 author: Serika content: 新建文档 ## 产品概述 发售日期：2025年4月中旬 ~~预购链接：[**点我**](https://sipeed.com/tangconsole)~~（预购已结束，敬请期待零售版本） **开发板关内容：**[**点我**](./mega console) **Tang Core** 的开发者文档：[**点我**](https://nand2mario.github.io/tangcore/) ## 板卡特点 <details> <summary><font color \"#4F84FF\">点击查看详情</font></summary> <br> 兼容多种SOM (**[Mega 138k](./../tang mega 138k/mega 138k)** & **[Mega 60k](./../*tang mega 60k/mega 60k)**) 支持多种[**Tang Core**](https://github.com/nand2mario/tangcore)模拟器核心 **NESTang** Nintendo Entertainment System **SNESTang** Super Nintendo Entertainment System **GBATang** Game Boy Advance **MDTang** Sega Genesis/Mega Drive **SMSTang** Sega Master System **更多核心仍在开发中，将会陆续上线** 板载BL616 MCU 运行[**TangCore firmware for BL616**](https://github.com/nand2mario/firmware bl616/) 支持模拟器核心快速切换 ~~支持uSD卡存储~~(仍在调试中) **支持USB OTG**（目前需要带供电的OTG转接头或HUB） **USB OTG存储**（存放游戏ROM和模拟器核心，以及模拟器BIOS） **USB HID手柄** 可作为FPGA的调试器 板载两个USB A，可用于直接连接支持的USB手柄 支持DS2手柄（需要[**PMOD_DS2x2**](../tang PMOD/FPGA_PMOD#pmod_ds2x2)） </details> ## 产品外观 <details> <summary><font color \"#4F84FF\">点击查看详情</font></summary> <br> **Tang Retro Console Premium** (60k version) <img src \"./assert/retro console p_138k.jpg\" width \"45%\"> **Tang Retro Console** (60k version) <img src \"./assert/retro console_60k.jpg\" width \"45%\"> </details> ## 架构框图 <details> <summary><font color \"#4F84FF\">点击查看详情</font></summary> <br> 此处以60k SOM举例，138k同理 <img src \"./assert/tangcores.drawio.svg\" width \"45%\"> <img src \"./assert/console_bdt.jpg\" width \"45%\"> <img src \"./assert/console_bdb.jpg\" width \"45%\"> </details> ## 硬件参数 <details> <summary><font color \"#4F84FF\">点击查看详情</font></summary> ### 核心板（SOM）参数 请根据实际安装的SOM，参考如下连接： **[Tang Mega 138k](./../tang mega 138k/mega 138k#核心板参数) 核心板** **[Tang Mega 60k](./../tang mega 60k/mega 60k#核心板参数) 核心板** ### 底板参数 请参考**开发板关内容：**[**点我**](./mega console#底板参数) </details> *** ## 上手使用 此处以**Tang Retro Console**为例，讲解如使用Tang Console进行游玩 ### 准备工作 需要准备的东西如下： [x] Tang Console，138k或60k均可 [x] USB 2.0驱动器，或者SD卡+读卡器（推荐格式FAT32/exFAT，≤32GB） [x] USB C OTG 转换器，带有电源传输（推荐使用套餐中的USB C读卡器） [x] 可用的GBA原机BIOS（gba_bios.bin） [x] 最新的[**TangCore Release Package**](https://github.com/nand2mario/tangcore/releases) [x] 想要游玩的游戏ROM（Tang Retro Console Premium套餐包含的uSD卡中已有演示游戏） ### 安装MCU固件 对于已购买任何套餐Tang Console的用户来说，这一步不是必须的，因为出厂时已经完成 后续如有固件更新，请参考此处进行更新：[**点我**](../common doc/update_debugger#tang core 的额外说明) ### 存储介质准备 无论是采用SD卡还是USB驱动器，需要确保其容量≤32GB 同时格式化为FAT32/exFAT。 存储介质的内容如下方所示： ``` 📁 / ├── 📁 cores/ # 来自Tang Core发布版本的 `cores` 目录 │ ├── 📁 console60k/ │ └── 📁 console138k/ ├── 📁 nes/ # .nes rom 目录 ├── 📁 snes/ # .smc/.sfc 目录 ├── 📁 gba/ │ └── 🗎 gba_bios.bin # GBA BIOS 档案 ├── 📁 genesis/ # .bin/ 目录 └── 📁 sms/ # .sms 目录 ``` > ⚠ Console会过滤游戏ROM的后缀名，请务必将游戏ROM改成对应的后缀名 ⚠ 存储介质的内容不区分 **138k console** 和 **60k console**。其中 **`gba_bios.bin`** 需要用户自行下载后放入。 将想要游玩的游戏ROM放入对应的目录中即可。 ### 硬件组装 ❗注意：请先组装好所有配件再接通电源！ 1. **早鸟版本推荐的方式**（这种方式的全部配件都包含于 **Tang Console Retro Premium** 中） <img src \"./assert/retro console_assembly 1.jpg\" width \"45%\"> > 左侧：USB OTG读卡器+USB C电源 下方：USB手柄 **P1** 上方： HDMI输出 这种方式的好处是简洁，缺点是USB手柄这样接不太稳定 如遇到USB手柄不识别（尤其是在切换完毕模拟器core的时候），需要用户手动多拔插USB手柄几次 ***零售版 Console** 可以不使用 OTG 读卡器，将uSD卡装入机身自带的卡槽即可。因为 **零售版 Console** 机身自带的卡槽通过MUX连接到了 **BL616*** <br> 2. **零售版本推荐的方式** <details> <summary><font color \"#4F84FF\">点击查看详情</font></summary> <br> <img src \"./assert/retro console_assembly 0.jpg\" width \"45%\"> > 左下：USB OTG 左上：USB C电源 下方：USB手柄 **P1** 上方： HDMI输出 这种方式的好处是最简洁，缺点是USB手柄这样接不太稳定 如遇到USB手柄不识别（尤其是在切换完毕模拟器core的时候），需要用户手动多拔插USB手柄几次 手柄既可以连接到Console本身的USB连接器，也可以通过USB OTG连接到BL616 USB OTG转换器不是必须的，取决于你的用途 </details> <br> 3. **nand2mario**的方式 <details> <summary><font color \"#4F84FF\">点击查看详情</font></summary> <br> <img src \"./assert/retro console_assembly 2.jpg\" width \"45%\"> > 左侧：OTG USB驱动器+USB C供电 右侧： DS2 PMOD+DS2手柄 顶部: HDMI输出 这种方式的好处是稳定，缺点是太臃肿 如想要连接更加简洁，请尝试使用无线DS2手柄，并更换更小尺寸的USB驱动器 </br> </details> <br> 4. USB OTG HUB的方式 {#USB_OTG_HUB} <details> <summary><font color \"#4F84FF\">点击查看详情</font></summary> <br> <img src \"./assert/retro console_assembly 3.jpg\" width \"45%\"> > 左侧：USB C OTG HUB+USB驱动器+USB C供电+USB手柄 **P1** 顶部: HDMI输出 这种方式的好处比较稳定，缺点是十分臃肿 & USB HUB 可能有兼容性问题 已测试的USB HUB的兼容性列表：[点我](https://github.com/nand2mario/tangcore/wiki/Compatible USB Hubs) </br> </details> <br> ### 上电开机 1. 先按照上一步中组装好机器，然后再接通电源； 2. 等待一段时间，主菜单会出现； <details> <summary><font color \"#4F84FF\">点击查看详情</font></summary> <br> <img src \"./assert/retro console_menu.jpg\" width \"45%\"> </details> <br> 3. 使用游戏手柄进行导航，上下移动游标，左右进行翻页，`B`或`3`键确定，`A`或`2`键返回，在 `..`上按下`B`键可以返回上级菜单 <details> <summary><font color \"#4F84FF\">点击查看详情</font></summary> <br> <img src \"./assert/retro console_menu1.jpg\" width \"45%\"> </details> <br> 4. 选中一个模拟器标题，如**SNES**，按`B`键进入二级菜单，选择要游玩的游戏ROM，再次按下`B`键进入游戏 <details> <summary><font color \"#4F84FF\">点击查看详情</font></summary> <br> <img src \"./assert/retro console_menu2.jpg\" width \"45%\"> </details> <br> 5. HDMI输出会暂时消失，稍等片刻出现ROM加载画面，此时画面下方的标题会变成对应模拟器的名称（本例中为 **SnesTang**） <details> <summary><font color \"#4F84FF\">点击查看详情</font></summary> <br> <img src \"./assert/retro console_menu3.jpg\" width \"45%\"> </details> <br> 6. 稍等片刻ROM加载完毕后就会进入游戏，通常此时按下 `start` 键就可以开始游戏 <details> <summary><font color \"#4F84FF\">点击查看详情</font></summary> <br> <img src \"./assert/retro console_game.jpg\" width \"45%\"> </details> <br> 7. 在游戏中可以按 `→` + `select` 返回主菜单 8. 部分游戏ROM可能并不完全被模拟器兼容。如果遇到了问题，给Console重新上电即可 ### 其他资源 安装文档原文： [**点我**](https://nand2mario.github.io/tangcore/user guide/installation/) 特别鸣谢：**[fjpolo](https://github.com/fjpolo/GBTang)** **[harbaum](https://github.com/harbaum/MiSTeryNano)** **[nand2mario](https://github.com/nand2mario)** **[pgate1](https://github.com/pgate1/SNES_on_FPGA)** > 以上排名不分先后 ## 交流方式 **交流论坛:[maixhub.com/discussion](https://maixhub.com/discussion)** **QQ 交流群：[834585530](https://jq.qq.com/?_wv 1027&k wBb8XUan)** 电报群组：[t.me/sipeed](t.me/sipeed) Discord：[https://discord.gg/V4sAZ9XWpN](https://discord.gg/V4sAZ9XWpN) 直接本页下方留言 ## 注意事项 <table> <tr> <th>事项</th> <th>注意事项</th> </tr> <tr> <td>供电电压</td> <td>Tang Console 使用的 电源电压是 <b>DC +5V</b> <br>请避免供电电压超过<b>+5.5V</b>或低于<b>+3.4V</b> <br>请使用输出能力至少为<b>5V/2A</b>的<b>USB 适配器</b>供电</br></td> </tr> <tr> <td>静电</td> <td>请避免静电打到 PCBA 上，如非必要请勿随意自行拆解装置的外壳 <br>如需拆卸外壳，在接触 PCBA 之前请把手的静电释放掉，比如用自来水洗手</td> </tr> <tr> <td>容忍电压</td> <td>使用 GPIO 排针引脚进行外部通信时，要确保 IO 电压是 3.3V，过高的电压会永久损坏 PCBA <br>非专业用户请勿使用排针连接官方配件以外的任何设备或模组</td> </tr> <tr> <td>FPC 座子</td> <td>在连接 FPC 软排线的时候，请确保排线无偏侈地完整地插入到排线中 <br>在通电之前请仔细核对两端FPC 连接器的 <b>1号PIN</b> 的方向是否正确</td> </tr> <tr> <td>插拔</td> <td>除了USB A手柄和USB驱动器/读卡器 <br>请完全断电后才进行配件的插拔操作</td> </tr> <tr> <td>USB手柄</td> <td>USB A手柄连接到Console正面的USB A时不太稳定 <br>如遇USB手柄无法操作，请多插拔几次</td> </tr> <tr> <td>避免短路</td> <td>请在上电过程中，避免任何液体和金属触碰到 PCBA 上的元件的焊盘，否则会导致路，烧毁 PCBA</td> </tr> </table> ## 联系 技术支持和商业合作请联系邮箱 [support@sipeed.com](support@sipeed.com) ## 常见问题 ### USB手柄无法操作 <details> <summary><font color \"#4F84FF\">点击查看详情</font></summary> <br> 1. 目前在 *tang core* version `0.8` 中是已知问题，请重新拔插USB手柄后再尝试操作； 2. Console正面的USB A手柄的稳定性会在之后的固件更新中解决； 3. 目前最稳定连接方式为PMOD DS2手柄； 4. 请注意USB接口的丝印标记，位于右侧的标记为P2的手柄，有些游戏只能使用P1的手柄进行操作（使用DS2手柄时同理）； </details> ### 按下MODE键后UI消失 <details> <summary><font color \"#4F84FF\">点击查看详情</font></summary> <br> 1. 目前在 *tang core* version `0.8` 中是已知问题，会在未来的固件更新中解决； 2. 如果画面中游标 `>` 还在，可以尝试用手柄操作翻页或返回上级等操作强迫UI刷新； </details> ### 上电后显示 `Waiting for USB drive...` <details> <summary><font color \"#4F84FF\">点击查看详情</font></summary> <br> 1. 如果使用了USB HUB，这可能意味着HUB不兼容； 2. 请确保正确连接了USB驱动器/读卡器； 3. 请确保USB驱动器/读卡器的容量 **≤32GB**，且格式化为 **FAT32/exFAT**； <img src \"./assert/retro console_menu4.jpg\" width \"45%\"> </details> ### GBATang提示 `Cannot find /gba_bios.bin...` <details> <summary><font color \"#4F84FF\">点击查看详情</font></summary> <br> 1. 这意味着 **USB驱动器/存储卡** 中的`/GBA`目录下缺失了GBA原始的BIOS，可能会引起一些ROM的兼容性问题； 2. 因为版权问题，我们无法向您提供这份档案，您需要自行寻找`gba_bios.bin`并放入相应的位置； <img src \"./assert/retro console_menu5.jpg\" width \"45%\"> </details> ### 主菜单画面中的 ***`Options`*** 选项无法进入 <details> <summary><font color \"#4F84FF\">点击查看详情</font></summary> <br> 1. 这是因为 **[nand2mario](https://github.com/nand2mario)** 在 *tang core* version `0.8` & `0.9` 中尚未实现这一部分的功能； 2. 此功能会造之后的更新中逐步实现； </details> ### 更多问题及其解决办法前往Tang Core的文档中的 [Troubleshooting](https://nand2mario.github.io/tangcore/user guide/troubleshooting/) 页面查看 如果你不幸遇到了一个全新的问题，欢迎向我们反馈。 反馈方式请参考 [**这里**](#交流方式)。"},"/hardware/zh/tang/tang-mega-60k/mega-60k.html":{"title":"Tang Mega 60K Dock","content":" title: Tang Mega 60K Dock keywords: FPGA, Tang, Mega, 60K update: date: 2024 06 25 version: v0.1 author: Serika content: 新建文档 date: 2024 09 25 version: v0.2 author: Serika content: 修正PCIe部分总线宽度的描述 更新之前TBD的内容 date: 2025 09 25 version: v0.3 author: Serika content: 移除了无法使用的lic server IP地址 移除了错误的关于AE350的描述 移除了错误的关于MIPI C PHY的描述 修正了GT收发器速率的描述 修正了DDR3速率的描述 修正了Flash容量的描述 修正了PCIe通道的宽度描述 ## 产品概述 **Tang Mega 60K** 使用 22nm 制程 **GW5AT LV60P484A** FPGA 芯片，具有 59904 个查找表单元和 118 个 DSP 单元。含有四个速度范围在 270Mbps ~ 8.8Gbps 高速收发器，适合用于 PCIe 等高速口传递数据。此外，芯片含有硬核 PCIe 和 MIPI D PHY控制器，在使用 PCIe 的时候消耗更好的资源，并且得到更佳的性能。适用于高速通信、协议转换、高性能计算等场合。 60K Dock 和 138K Dock共用一套底板（TANG MEGA NEO），因此两者的外设完全相同。相比138K Dock，60K Dock具有较少的逻辑资源和更低的价格，并且包含MIPI D PHY 收发器（138K仅有MIPI D PHY RX）。这不仅能进一步降低高速通讯的成本，还带来了更好的影像处理系统集成的兼容性。 淘宝购买链接：[点我](https://item.taobao.com/item.htm?id 740536508140) ## 板卡特点 中等容量 LUT4 512MiB DDR3 内存 PCIe2.0 x 1* USB3.0 x 1(5Gbps) MIPI D PHY收发器 HDMI TX/RX x 1 千兆以太网 x 1 板载3.7V锂离子电池（1S）充放电管理电路 <a id \"target line\"></a> > **注意**：由于 GW5AT LV60 和 GW5AST LV138 的 SERDES 部分引脚排列不完全相同，因此本底板（NEO DOCK） 最初是为 GW5AST LV138 设计​​的。因此，对于 GW5AT LV60，虽然 PCIe AIC 金手指已扇出所有 SERDES 通道， 但由于 GW5AT LV60 上的 1 号通道和 3 号通道互换，PCIe 目前只能工作在 x1 模式下。 > *此问题可能在未来通过高云软件更新得到修复。* 淘宝购买链接：[点我](https://item.taobao.com/item.htm?id 740536508140) ## 产品外观 <img src \"./assets/mega_60k_top.png\" width \"45%\"> ## 硬件参数 ### 硬件框图 TBD ### 核心板参数 <table> \t<thead> \t\t<tr> \t\t\t<th style \"text align:center\">项目</th> \t\t\t<th style \"text align:center\">参数</th> \t\t\t<th style \"text align:center\">补充</th> \t\t</tr> \t</thead> \t<tbody> \t\t<tr> \t\t\t<td style \"text align:left\">FPGA 芯片</td> \t\t\t<td style \"text align:left\"><a href \"https://www.gowinsemi.com.cn/prod_view.aspx?TypeId 74&FId t3:10:3&Id 188#GW5AT\">GW5AT LV60PG484A</a> \t\t\t</td> \t\t\t<td style \"text align:left\"> \t\t\t\t<table> \t\t\t\t\t<tr> \t\t\t\t\t\t<td>逻辑单元(LUT4)</td> \t\t\t\t\t\t<td>59904</td> \t\t\t\t\t</tr> \t\t\t\t\t<tr> \t\t\t\t\t\t<td>寄存器(FF)</td> \t\t\t\t\t\t<td>59904</td> \t\t\t\t\t</tr> \t\t\t\t\t<tr> \t\t\t\t\t\t<td>分布式静态随机存储器S SRAM(Kbits)</td> \t\t\t\t\t\t<td>468</td> \t\t\t\t\t</tr> \t\t\t\t\t<tr> \t\t\t\t\t\t<td>块状静态随机存储器B SRAM(Kbits)</td> \t\t\t\t\t\t<td>2124</td> \t\t\t\t\t</tr> \t\t\t\t\t<tr> \t\t\t\t\t\t<td>块状静态随机存储器数目B SRAM(个)</td> \t\t\t\t\t\t<td>118</td> \t\t\t\t\t</tr> \t\t\t\t\t<tr> \t\t\t\t\t\t<td>乘法器(18x18 Multiplier)</td> \t\t\t\t\t\t<td>118</td> \t\t\t\t\t</tr> \t\t\t\t\t<tr> \t\t\t\t\t\t<td>锁相环(PLLs)</td> \t\t\t\t\t\t<td>8</td> \t\t\t\t\t</tr> <tr> <td>全局时钟</td> <td>16</td> </tr> <tr> <td>高速时钟</td> <td>20</td> </tr> <tr> <td>Transceivers</td> <td>4</td> </tr> <tr> <td>Transceivers 速率</td> <td>270Mbps 8.8Gbps</td> </tr> <tr> <td>PCIE 硬核</td> <td>1个<br>速度可选 x1, <s>x2, x4</s> PCIe 2.0 <a href \"#target line\">（原因）</a></td> </tr> <tr> <td>LVDS (Gbps)</td> <td>1.25</td> </tr> <tr> <td>DDR3 (Mbps)</td> <td>1100</td> </tr> <tr> <td>MIPI D PHY硬核</td> <td>2.5Gbps（RX），<br>8个数据通道，<br>2个时钟通道</td> </tr> <tr> <td>硬核处理器</td> <td>None</td> </tr> <tr> <td>ADC</td> <td>2</td> </tr> \t\t\t\t\t<tr> \t\t\t\t\t\t<td>I/O Bank 总数</td> \t\t\t\t\t\t<td>11</td> \t\t\t\t\t</tr> \t\t\t\t</table> \t\t\t</td> \t\t</tr> \t\t<tr> \t\t\t<td style \"text align:left\">内存</td> \t\t\t<td style \"text align:left\">512MiB DDR3</td> \t\t\t<td style \"text align:left\">512MiB x 1</td> \t\t</tr> \t\t<tr> \t\t\t<td style \"text align:left\">Flash</td> \t\t\t<td style \"text align:left\">64Mbits Flash x 1</td> \t\t\t<td style \"text align:left\">查看 <a href \"#burn_flash\">烧录到Flash</a></td> \t\t</tr> \t\t<tr> \t\t\t<td style \"text align:left\">调试接口</td> \t\t\t<td style \"text align:left\">JTAG + UART</td> \t\t\t<td style \"text align:left\">JST SH1.0 8Pins 连接器</td> \t\t</tr> \t\t<tr> \t\t\t<td style \"text align:left\">整体封装</td> \t\t\t<td style \"text align:left\">35mm x 45mm 大小</td> \t\t\t<td style \"text align:left\">BTB连接器连接核心板和底板</td> \t\t</tr> \t</tbody> </table> ### 底板参数 项目 数量 备注 : LED 4+8 4个电量指示灯+8个PMOD外接 WS2812 1 与 aRGB 灯带连接器同数据引脚 Buttons 3+1 3个用户按键+1个reconfig按键 PCIe 1 4 lane @ 5Gbps，CH569 16bit HSPI USB3 2 SuperSpeed @ 5Gbps GbE 1 千兆以太网 DVI RX 1 与 DVI TX 互相占用 DVI TX 1 与 DVI RX 互相占用 PMOD 2 与上边的40P排针和DVP复用 ADC 2 2个差分输入通道 aRGB CONN. 1 与 WS2812 同数据引脚 DVP Interface 1 与上侧的40P排针和PMOD复用 RGB Interface 1 支持 RGB888 屏幕 MIC ARRAY Interface 1 支持连接 Sipeed 6+1 麦克风阵列 SD Slot 1 1 bit SDIO/MMC 或SPI模式 BATT CONN. 1 支持3.7V锂电池，自带充放电管理 PWM FAN CONN. 1 支持5V PWM风扇，支持测速 Speaker CONN. 2 支持两个3W扬声器 3.5mm Headphone CONN. 1 立体声输出，无Mic MS5351 1 为 Serdes 提供 RefClk；通过底板上的串口来控制输出 USB JTAG & UART 1 支持烧录 FPGA，并且提供串口功能 40P 排针 2 上侧的40P排针与PMOD和DVP复用 电源开关 1 长按2s切换开关机状态 12V DC 1 规格DC5521 ## 硬件资料 ~~[板卡规格书](https://dl.sipeed.com/shareURL/TANG/Mega_138K_60K/01_Specification)~~ [板卡原理图](https://dl.sipeed.com/shareURL/TANG/Mega_138K_60K/02_Schematic) [PCB BOM](https://dl.sipeed.com/shareURL/TANG/Mega_138K_60K/03_Designator_drawing) [板卡尺寸图](https://dl.sipeed.com/shareURL/TANG/Mega_138K_60K/04_Mechanical_drawing) [板卡 3D 模型](https://dl.sipeed.com/shareURL/TANG/Mega_138K_60K/05_3D_file) [部分芯片手册](https://dl.sipeed.com/shareURL/TANG/Mega_138K_60K/07_Datasheet) [全引脚约束](https://dl.sipeed.com/shareURL/TANG/Mega_138K_60K/08_Misc) ## 上手使用 注意60K目前已经被教育版支持，需要下载 V1.9.11.03 或更新版本的教育版IDE使用。 商业版IDE需要 ≥V1.9.10.03。 如需将码流下载到flash中固化，推荐使用 **exFlash Erase,Program thru GAO Bridge 5A** 模式（需要≥V1.9.10.03），或者 **exFlash Erase,Program thru GAO Bridge Arora V** （需要≥V1.9.12）。 推荐使用单独的 **1.9.12 SP1** Programmer（aka. 云源编程器），在 **云源软件商业版** 的页面可以找到。这个单独的Programmer兼容性更好。 如果需要使用商用版IDE，Lic 可以在高云官网申请，或者使用Sipeed提供的在线Lic服务，在IDE中选择Float Lic，填写以下信息即可： ~~~ Server 01 ip: 106.55.34.119 port: 10559 ~~~ 如果上面的IP不能工作, 尝试使用 \"gowinlic.sipeed.com\" 域名对应的IP。 安装 IDE [点我](https://wiki.sipeed.com/hardware/zh/tang/common doc/get_started/install the ide.html) 例程代码 [github](https://github.com/sipeed/TangMega 60K example) ### 其他学习资源 在线免费教程：[Verilog 教程](https://www.runoob.com/w3cnote/verilog tutorial.html)（学习Verilog） 在线免费 FPGA 教程：[Verilog](https://www.asic world.com/verilog/index.html) （英文网站） Verilog 刷题网站：[HDLBits](https://hdlbits.01xz.net/wiki/Main_Page)（英文网站） 在线高云半导体可参考视频教程：[点击这里](http://www.gowinsemi.com.cn/video_complex.aspx?FId n15:15:26) ## 交流方式 **交流论坛: [maixhub.com/discussion](https://maixhub.com/discussion)** **QQ 交流群：[834585530](https://jq.qq.com/?_wv 1027&k wBb8XUan)** 直接本页下方留言 商业邮箱 : [support@sipeed.com](support@sipeed.com) ## 注意事项 <table> <tr> <th>事项</th> <th>注意事项</th> </tr> <tr> <td>芯片型号</td> <td>Tang Mega 60K 使用的 FPGA 芯片具体型号是 <b>GW5AT LV60PG484A</b> <br>在 IDE 中选择封装型号 <span><b>PBG484A</b></span> & <span><b>Device Version: B</b></span></br></td> </tr> <tr> <td>静电</td> <td>请避免静电打到 PCBA 上；接触 PCBA 之前请把手的静电释放掉</td> </tr> <tr> <td>容忍电压</td> <td> 使用 GPIO 排针引脚进行外部通信时，要确保 IO 电压是 3.3V，过高的电压会永久损坏 PCBA </td> </tr> <tr> <td>FPC 座子</td> <td>在连接 FPC 软排线的时候，请确保排线无偏侈地完整地插入到排线中 <br>在通电之前请仔细核对两端FPC 连接器的 <b>1号PIN</b> 的方向是否正确</td> </tr> <tr> <td>PCIe 金手指</td> <td>在测试 PCIe 金手指时候，确保是主机端与板卡都处于关机或者未通电的状态，否则可能会因为插入过程中的易位导致金手指短路。</td> </tr> <tr> <td>插拔</td> <td>请完全断电后才进行插拔操作</td> </tr> <tr> <td>避免短路</td> <td>请在上电过程中，避免任何液体和金属触碰到 PCBA 上的元件的焊盘，否则会导致路，烧毁 PCBA</td> </tr> </table> ## 联系 Tang Mega 60K 可以在多种场景实现客户不同方面的需要，技术支持和商业合作请联系邮箱 [support@sipeed.com](support@sipeed.com) ## 常见问题 ### 板子通电后底板只亮了四个指示灯，SOM的指示灯没亮 1. 请检查是否开启了板子的电源，**PWR按键**（HDMI接口旁边）长按2S开启电源； ### 板子通电后，底板Battery Indicator指示灯在闪烁 1. 正常现象，通常是最后一颗LED（靠近12V DC连接器）在闪烁； 2. 当板子连接3.7V锂电池时，这些LED将作为电池电量指示灯。 ### 长按PWR按钮 2s 后，底板指示灯全部熄灭又依次亮起 1. 检查自己的供电方式，出现这种情况意味着供电能力不足； 2. 解决方案（任选一种）： a. 同时连接板子的**USB 3.0**和**USB DEBUG**进行供电，即双5V USB电源供电； b. 连接12V DC电源对板子进行供电，如使用配件中的USB C转12V DC连接器，则需要连接有12V输出能力的PD电源； c. 连接3.7V锂电池对板子进行供电，注意电池电压必须≥3.6V且连续放电能力≥600mA。 ### 板子电源指示灯亮了，Programmer提示No USB Cable Connection 1. 请检查USB线是否正确接入标记为 **DEBUG USB2** 的USB C连接器 2. 尽量避免使用机箱前面板的USB连接器和没有独立供电的USB HUB 3. 检查自己是否正确安装FT2232的驱动：出现USB Serial Converter A/B <img src \"./../assets/FTDI_DEVICE.jpg\" alt \"flash_mode\" width 35%> 4. 通常情况下Windows会在联网后自动安装相应驱动。如果想要手动处理，请前往[相关问题](./../common doc/questions)查看相关内容 5. 尝试更新板载下载器的固件，请参考这里 **[【点我跳转】](./../common doc/update_debugger)** <img src \"./../assets/FTDI_DEVICE.jpg\" alt \"flash_mode\" width 35%> 4. 通常情况下Windows会在联网后自动安装相应驱动。如果想要手动处理，请前往[相关问题](./../common doc/questions)查看相关内容。 5. ### IDE找不到型号GW5AT LV60PG484A 1. IDE版本过老，必须更新商业版IDE ≥ 1.9.10.03，或教育版IDE ≥ 1.9.11.03。 ### 如何下载到外部 FLASH（固化） {#burn_flash} 1. 进行如下选项设置： <img src \"./../assets/flash_mode_GAO.png\" alt \"flash_mode\" width 35%> 2. 检查拨码开关的位置，正确的位置如下图所示： <img src \"./assets/dip key_defualt.png\" alt \"dip key_defualt\" width 35%> ### 烧录后没反应或者引脚现象不对 1. 首先确定IDE选择了正确的型号 **GW5AT LV60PG484AC1/10**，下图中的每一个参数都要求一致； <img src \"./assets/partno_60K.png\" alt \"device_choose\" width 35%> 2. 然后检查自己的代码和对应的仿真波形是否满足要求，使用云源软件（GOWIN IDE）的GAO工具可以进行片上仿真。更多详情请参考GOWIN文档[SUG100](https://cdn.gowinsemi.com.cn/SUG100 4.0_Gowin%E4%BA%91%E6%BA%90%E8%BD%AF%E4%BB%B6%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf)中关于GAO工具的描述。 ### 更多问题及其解决办法前往[相关问题](./../common doc/questions)查看"},"/hardware/zh/tang/tang-PMOD/FPGA_PMOD.html":{"title":"TANG PMOD","content":"# TANG PMOD ## 概述 TANG PMOD 模組是相容于 **Digilent Pmod™** 接口标准的FGPA拓展模块，可用于包含此接口的FPGA 开发板的功能扩展，如[Tang Mega 138K Pro Dock](../tang mega 138k/mega 138k pro.html) 和 [Tang Primer 25K Dock](../tang primer 25k/primer 25k.html) 等。 不同的模组提供不同的拓展功能，模组间可以任意组合搭配以实现各种需要的功能。 <div> <img src \"./assets/PMOD all.jpg\" width 45%> <img src \"./assets/25K_PMOD.jpg\" width 45%> <img src \"./assets/138K_PMOD.jpg\" width 45%> </div> 购买链接：[淘宝](https://item.taobao.com/item.htm?spm a1z10.5 c s.w4002 24984936573.29.19b22db2a329yr&id 746293292946) ## PMOD_LEDx8 简介：8个IO对应8个LED 例程：[pmod_digitalTube 2bit](https://github.com/sipeed/TangPrimer 25K example/tree/main/pmod_digitalTube 2bit) <div> <img src \"./assets/PMOD_LEDx8_top.jpg\" width 45%> <img src \"./assets/PMOD_LEDx8_bot.jpg\" width 45%> </div> ## PMOD_BTN4+4 简介：4个按键+四位拨码开关 例程：[pmod_digitalTube 2bit](https://github.com/sipeed/TangPrimer 25K example/tree/main/pmod_digitalTube 2bit) <div> <img src \"./assets/PMOD_BTN4+4_top.jpg\" width 45%> <img src \"./assets/PMOD_BTN4+4_bot.jpg\" width 45%> </div> ## PMOD_DTx2 简介：2位8段数码管 例程：[pmod_digitalTube 2bit](https://github.com/sipeed/TangPrimer 25K example/tree/main/pmod_digitalTube 2bit) <div> <img src \"./assets/PMOD_DTx2_top.jpg\" width 45%> <img src \"./assets/PMOD_DTx2_bot.jpg\" width 45%> </div> ## PMOD_DVI 简介：HDMI输出/输入（需要使用LVDS差分对） 例程：[nestang 25k](https://github.com/sipeed/TangPrimer 25K example/tree/main/nestang 25k) <div> <img src \"./assets/PMOD_DVI_top.jpg\" width 45%> <img src \"./assets/PMOD_DVI_bot.jpg\" width 45%> </div> ## PMOD_DVP 简介：8位DVP，支持M12镜头 例程：[Coming soon..](https://github.com/sipeed/TangPrimer 25K example/tree/main) <div> <img src \"./assets/PMOD_DVP_top.jpg\" width 45%> <img src \"./assets/PMOD_DVP_bot.jpg\" width 45%> </div> ## PMOD_TF CARD 简介：支持标准TF卡，带插拔检测 例程：[nestang 25k](https://github.com/sipeed/TangPrimer 25K example/tree/main/nestang 25k) <div> <img src \"./assets/PMOD_TF CARD_top.jpg\" width 45%> <img src \"./assets/PMOD_TF CARD_bot.jpg\" width 45%> </div> ## PMOD_HUB75E 简介：支持hub75e标准点阵 例程：[pmod_hub75e](https://github.com/sipeed/TangPrimer 25K example/tree/main/pmod_hub75e) <div> <img src \"./assets/PMOD_HUB75E_top.jpg\" width 45%> <img src \"./assets/PMOD_HUb75E_bot.jpg\" width 45%> <img src \"./assets/PMOD_HUb75E_sample1.jpg\" width 45%> <img src \"./assets/PMOD_HUB75E_sample2.jpg\" width 45%> </div> ## PMOD_DS2x2 简介：支持支持两个DS2手柄（没有震动） 例程：[nestang 25k](https://github.com/sipeed/TangPrimer 25K example/tree/main/nestang 25k) <div> <img src \"./assets/PMOD_DS2x2_top.jpg\" width 45%> <img src \"./assets/PMOD_DS2x2_bot.jpg\" width 45%> </div> # TANG 40P MODULE ## 概述 TANG 40P MODULE 模組是**部分相容**于DE10 Nano 40P接口标准的FGPA拓展模块，可用于包含此接口的FPGA 开发板的功能扩展。由于引脚数目更多，因此可以连接如双颗粒SDRAM模组和\\*DVP双目摄像模组等更为复杂的模组。 ## TANG_SDRAM 简介：32MB x2 16bit 143MHz SDRAM 例程：[nestang 25k](https://github.com/sipeed/TangPrimer 25K example/tree/main/nestang 25k) 原理图：[Tang_sdram_xsds_V1.1_Schematic](http://dl.sipeed.com/fileList/TANG/PMOD/Tang_sdram_xsds_V1.1_Schematic.pdf) <div> <img src \"./assets/TANG_SDRAM_top.jpg\" width 45%> <img src \"./assets/TANG_SDRAM_bot.jpg\" width 45%> </div> \\*注意，本模块不相容于Mister SDRAM V3.0，请仔细核对相应原理图 （差异在40P排母的第29和30脚） <div> <img src \"./assets/TANG_SDRAM_diff.jpg\" width 45%> </div> ## 硬件资料 原理图等均可在这里找到：[点击这里](https://dl.sipeed.com/shareURL/TANG/PMOD) ### 公开例程 github 链接： https://github.com/sipeed/TangPrimer 25K example ## 交流方式 **交流论坛: [maixhub.com](maixhub.com/discussion)** **QQ 交流群：[834585530](https://jq.qq.com/?_wv 1027&k wBb8XUan)** 直接本页下方留言 商业邮箱 : [support@sipeed.com](support@sipeed.com) ## 相关问题 TBD ### 更多问题及其解决办法前往[相关问题](./../common doc/questions.html)查看"},"/hardware/zh/tang/index.html":{"title":"Tang 系列开发板","content":" title: Tang 系列开发板 Tang 系列开发板主要有 Tang Nano 和 Tang Primer 两个系列。 Tang Nano Tang Primer Tang Nano 1K<br> Tang Nano 4K<br> Tang Nano 9K<br> Tang Nano 20K Tang Primer 20K<br> Tang Primer 20K Dock<br> Tang Primer 20K Lite<br> ## Tang Nano Tang Nano 系列板卡都有迷你的体积，板载了 Jtag 调试器，能够只通过一根 TypeC 数据线来烧录、仿真固件。多个可选的 FPGA 容量能够让你购买到最合适的 FPGA。 ### 参数 条目 <p style \"white space:nowrap\">Tang Nano 20K</p> <p style \"white space:nowrap\">Tang Nano 9K</p> <p style \"white space:nowrap\">Tang Nano 4K</p> <p style \"white space:nowrap\">Tang Nano 1K</p> : : : : 逻辑单元(LUT4) 20736 8640 4608 1152 寄存器（FF） 15552 6480 3456 864 S SRAM (bits) 41472 17280 B SRAM (bits) 828K 468K 180K 72K 用户闪存 (bits) 608K 256K 96K 锁相环 (PLL) 4 2 2 1 板载 Flash 32Mbits NOR Flash 32Mbits NOR Flash 32Mbits NOR Flash 预留焊盘 硬核处理器 Cortex M3 ### 外观 <table> <thead> <tr> <th style \"text align:center\">Tang Nano 20K</th> <th style \"text align:center\">Tang Nano 9K</th> </tr> </thead> <tbody> <tr> <td style \"text align:center\"><a href \"/nano20k\"><img src \"/hardware/assets/Tang/nano_20k/tang_nano_20k_3920_top.png\" alt \"Tang Nano 20K\"></a></td> <td style \"text align:center\"><a href \"./Tang Nano 9K/Nano 9K.html\"><img src \"./../../assets/Tang/Nano 9K/9K.png\" alt \"Tang Nano 9K\"></a></td> </tr> </tbody> <thead> <tr> <th style \"text align:center\">Tang Nano 4K</th> <th style \"text align:center\">Tang Nano 1K</th> </tr> </thead> <tbody> <tr> <td style \"text align:center\"><a href \"./Tang Nano 4K/Nano 4K.html\"><img src \"./../../assets/Tang/Nano_4K/Nano_4K.png\" alt \"Tang Nano 4K\"></a></td> <td style \"text align:center\"><a href \"./Tang Nano 1K/Nano 1k.html\"><img src \"./../../assets/Tang/Nano 1K/1K.png\" alt \"Tang Nano 1K\"></a></td> </tr> </tbody> </table> ## Tang Primer Tang Primer 系列开发板是为了便于用户直接连接并驱动外设所设计的开发板。 ### 参数 条目 <p style \"white space:nowrap\">Tang Primer 20K</p> <p style \"white space:nowrap\">Tang Primer 20K Dock</p> <p style \"white space:nowrap\">Tang Primer 20K Lite</p> : : : : 逻辑单元(LUT4) 20736 20736 20736 寄存器（FF） 15552 15552 15552 S SRAM (bits) 41472 41472 41472 B SRAM (bits) 828K 468K 180K 锁相环 (PLL) 2 2 2 板载 Flash 32Mbits NOR Flash 32Mbits NOR Flash 32Mbits NOR Flash LED (个) 6 ### 外观 Tang Primer 20K Tang Primer 20K Dock Tang Primer 20K Lite <img src \"./tang primer 20k/assets/20k_core.png\" alt \"20k_core\" width \"85%\"> ![dock up](./tang primer 20k/assets/dock up.png) ![20k_lite_home](./tang primer 20k/assets/20k_lite_home.png) ## 开发板选择建议 对于新手来说，建议使用 [Tang Nano 1K](https://wiki.sipeed.com/tang1k) 或者 [Tang Nano 9K](https://wiki.sipeed.com/tang9k) 来入门学习 FPGA。 会自己制作扩展板并且想要深入使用 FPGA 的话，可以选择 [Tang Nano 4K](https://wiki.sipeed.com/tang4k) 或者 [Tang Nano 20K](https://wiki.sipeed.com/nano20k)。 [Tang Primer 20K](https://wiki.sipeed.com/primer20k) 非常适合进行二次硬件设计，但是 DDR3 SODIMM 底座焊接有一定的难度， 如果自己不会制作扩展板，但是想要连接多个外设的话可以选择 [Tang Primer 20K Dock](https://wiki.sipeed.com/primer20k) 或者 [Tang Primer 20K Lite](https://wiki.sipeed.com/primer20k)。前者提供了足够多的可直接连接外设的接口，后者拥有足够多的排针引脚。 ## 全部参数对比 <table> <thead> <tr> <th style \"text align:left\"></th> <th style \"white space:nowrap\">Tang Primer 20K Dock</th> <th style \"white space:nowrap\">Tang Nano 20K</th> <th style \"white space:nowrap\">Tang Nano 9K</th> <th style \"white space:nowrap\">Tang Nano 4K</th> <th style \"white space:nowrap\">Tang Nano 1K</th> </tr> </thead> <tbody> <tr> <td style \"text align:left\">芯片系列 </td> <td style \"text align:left\">GW2A 18 </td> <td style \"text align:left\">GW2AR 18 </td> <td style \"text align:left\">GW1NR 9 </td> <td style \"text align:left\">GW1NSR 4C</td> <td style \"text align:left\">GW1NZ 1 </td> </tr> <tr> <td style \"text align:left\">芯片版本 </td> <td style \"text align:left\">C </td> <td style \"text align:left\">C </td> <td style \"text align:left\">C </td> <td style \"text align:left\"> </td> <td style \"text align:left\"> </td> </tr> <tr> <td style \"text align:left\">逻辑单元(LUT4)</td> <td style \"text align:left\">20736 </td> <td style \"text align:left\">20736 </td> <td style \"text align:left\">8640 </td> <td style \"text align:left\">4608 </td> <td style \"text align:left\">1152 </td> </tr> <tr> <td style \"text align:left\">寄存器(FF)</td> <td style \"text align:left\">15552 </td> <td style \"text align:left\">15552 </td> <td style \"text align:left\">6480 </td> <td style \"text align:left\">3456 </td> <td style \"text align:left\">864 </td> </tr> <tr> <td style \"text align:left\">分布式静态随机存储器<br>S SRAM (bits)</td> <td style \"text align:left\">41472</td> <td style \"text align:left\">41472</td> <td style \"text align:left\">17280</td> <td style \"text align:left\"></td> <td style \"text align:left\">4K</td> </tr> <tr> <td style \"text align:left\">块状静态随机存储器<br>B SRAM (bits)</td> <td style \"text align:left\">828K</td> <td style \"text align:left\">828K</td> <td style \"text align:left\">468K</td> <td style \"text align:left\">180K</td> <td style \"text align:left\">72K </td> </tr> <tr> <td style \"text align:left\">用户闪存</td> <td style \"text align:left\"></td> <td style \"text align:left\"></td> <td style \"text align:left\">608K</td> <td style \"text align:left\">256K</td> <td style \"text align:left\">64K</td> </tr> <tr> <td style \"text align:left\">乘法器（个）</td> <td style \"text align:left\">48</td> <td style \"text align:left\">48</td> <td style \"text align:left\">20</td> <td style \"text align:left\">16</td> <td style \"text align:left\"> </td> </tr> <tr> <td style \"text align:left\">大容量 RAM</td> <td style \"text align:left\">DDR SDRAM<br>容量 1G bits<br>位宽 16 bits</td> <td style \"text align:left\">SDR SDRAM<br>容量 64M bits<br>位宽 32 bits</td> <td style \"text align:left\">PSRAM<br>容量 64M bits<br>位宽 32 bits</td> <td style \"text align:left\">HyperRAM<br>容量 64M bits<br>位宽 8 bits</td> <td style \"text align:left\"></td> </tr> <tr> <td style \"text align:left\">锁相环 (PLL)</td> <td style \"text align:left\">4</td> <td style \"text align:left\">2</td> <td style \"text align:left\">2</td> <td style \"text align:left\">2</td> <td style \"text align:left\">1</td> </tr> <tr> <td style \"text align:left\">板载 Flash</td> <td style \"text align:left\">64Mbits Flash</td> <td style \"text align:left\">32Mbits Flash</td> <td style \"text align:left\">32Mbits Flash</td> <td style \"text align:left\">32Mbits Flash</td> <td style \"text align:left\"> </td> </tr> <tr> <td style \"text align:left\">硬核处理器</td> <td style \"text align:left\"></td> <td style \"text align:left\"></td> <td style \"text align:left\"></td> <td style \"text align:left\">Cortex M3</td> <td style \"text align:left\"></td> </tr> <tr> <td style \"text align:left\">摄像头接口</td> <td style \"text align:left\">有</td> <td style \"text align:left\"></td> <td style \"text align:left\"></td> <td style \"text align:left\">有</td> <td style \"text align:left\"></td> </tr> <tr> <td style \"text align:left\">HDMI 接口</td> <td style \"text align:left\">有</td> <td style \"text align:left\">有</td> <td style \"text align:left\">有</td> <td style \"text align:left\">有</td> <td style \"text align:left\"></td> </tr> <tr> <td style \"text align:left\">RGB 屏幕接口</td> <td style \"text align:left\">有</td> <td style \"text align:left\">有</td> <td style \"text align:left\">有</td> <td style \"text align:left\"></td> <td style \"text align:left\">有</td> </tr> <tr> <td style \"text align:left\">SPI 排线接口</td> <td style \"text align:left\">有</td> <td style \"text align:left\"></td> <td style \"text align:left\">有</td> <td style \"text align:left\"></td> <td style \"text align:left\"></td> </tr> <tr> <td style \"text align:left\">以太网口</td> <td style \"text align:left\">有</td> <td style \"text align:left\"></td> <td style \"text align:left\"></td> <td style \"text align:left\"></td> <td style \"text align:left\"></td> </tr> <tr> <td style \"text align:left\">USB 2.0</td> <td style \"text align:left\">有</td> <td style \"text align:left\"></td> <td style \"text align:left\"></td> <td style \"text align:left\"></td> <td style \"text align:left\"></td> </tr> <tr> <td style \"text align:left\">WS2812</td> <td style \"text align:left\">有</td> <td style \"text align:left\">有</td> <td style \"text align:left\"></td> <td style \"text align:left\"></td> <td style \"text align:left\"></td> </tr> <tr> <td style \"text align:left\">MS5351</td> <td style \"text align:left\"></td> <td style \"text align:left\">有</td> <td style \"text align:left\"></td> <td style \"text align:left\"></td> <td style \"text align:left\"></td> </tr> <tr> <td style \"text align:left\">特点</td> <td style \"text align:left\">大容量，多外设，能用于多种验证</td> <td style \"text align:left\">大容量，小体积，具有多路时钟可以使用</td> <td style \"text align:left\">价格实惠，能够进行软核试验</td> <td style \"text align:left\">内含 mcu 的 FPGA，板卡能够直接驱动摄像头</td> <td style \"text align:left\">最小系统板</td> </tr> <tr> <td style \"text align:left\">详细信息</td> <td style \"text align:left\"><a href \"https://wiki.sipeed.com/primer20k\">点我跳转</a></td> <td style \"text align:left\"><a href \"https://wiki.sipeed.com/nano20k\">点我跳转</a></td> <td style \"text align:left\"><a href \"https://wiki.sipeed.com/tang9k\">点我跳转</a></td> <td style \"text align:left\"><a href \"https://wiki.sipeed.com/tang4k\">点我跳转</a></td> <td style \"text align:left\"><a href \"https://wiki.sipeed.com/tang1k\">点我跳转</a></td> </tr> </tbody> </table>"},"/hardware/zh/tang/Tang-Nano-1K/examples/lcd_constrains.html":{"title":"LCD constrain file content","content":" title: LCD constrain file content <p id \"back\"> <a href \"#\" onClick \"javascript :history.back( 1);\">Previous page</a> </p> ```cst IO_LOC \"LCD_B[4]\" 24; IO_PORT \"LCD_B[4]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_B[3]\" 23; IO_PORT \"LCD_B[3]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_B[2]\" 22; IO_PORT \"LCD_B[2]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_B[1]\" 20; IO_PORT \"LCD_B[1]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_B[0]\" 19; IO_PORT \"LCD_B[0]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_G[5]\" 18; IO_PORT \"LCD_G[5]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_G[4]\" 17; IO_PORT \"LCD_G[4]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_G[3]\" 16; IO_PORT \"LCD_G[3]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_G[2]\" 15; IO_PORT \"LCD_G[2]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_G[1]\" 27; IO_PORT \"LCD_G[1]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_G[0]\" 28; IO_PORT \"LCD_G[0]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_R[4]\" 29; IO_PORT \"LCD_R[4]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_R[3]\" 30; IO_PORT \"LCD_R[3]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_R[2]\" 31; IO_PORT \"LCD_R[2]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_R[1]\" 34; IO_PORT \"LCD_R[1]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_R[0]\" 35; IO_PORT \"LCD_R[0]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_DEN\" 21; IO_PORT \"LCD_DEN\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_SYNC\" 32; IO_PORT \"LCD_SYNC\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_HYNC\" 33; IO_PORT \"LCD_HYNC\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_CLK\" 8; IO_PORT \"LCD_CLK\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"XTAL_IN\" 47; IO_PORT \"XTAL_IN\" IO_TYPE LVCMOS33 PULL_MODE UP; IO_LOC \"nRST\" 44; IO_PORT \"nRST\" IO_TYPE LVCMOS33 PULL_MODE UP; ``` <p id \"back\"> <a href \"#\" onClick \"javascript :history.back( 1);\">返回上一页(Back)</a> </p>"},"/hardware/zh/tang/Tang-Nano-1K/examples/LCD.html":{"title":"RGB LCD 示例","content":" title: RGB LCD 示例 > 编辑于2022年3月30日 ## 先介绍时序 RGB LCD 显示协议和 VGA 类似，通信都有专用的行同步、场同步信号线。它们的主要区别是前者传输用的是数字信号，后者传输走的是模拟信号。 下面就介绍 VGA 的时序 ![](./../../assets/examples/lcd_pjt_1.png) 上图分别是 VGA 在数据传输中的行同步、场同步时序 从时序图中可以看出，不论是显示一行数据还是一列数据，都需要一个对应的同步(sync)信号，数据的传输在两个同步信号的脉冲之间完成 每一行的数据包括显示前沿(back porch)、有效数据(active video)、显示后沿(front porch)三个阶段 其中的有效数据就是我们常说的分辨率，而显示前后沿的参数需要参考具体的分辨率与帧数进行设置，相关参数可以参考典型参数，链接在此： http://www.tinyvga.com/vga timing 这块5寸屏幕的控制时序略有不同，相关参数的设置可以查看[规格书](https://dl.sipeed.com/fileList/TANG/Nano%209K/6_Chip_Manual/CN/LCD_Datasheet/5.0inch_LCD_Datashet%20RGB.pdf) 其他尺寸的屏幕相关规格书均可以在这里下载 [点我](https://dl.sipeed.com/shareURL/TANG/Nano%209K/6_Chip_Manual/CN/LCD_Datasheet) 下面为这块 LCD 时序相关的截图 ![](./../../assets/examples/lcd_pjt_2.png) ![](./../../assets/examples/lcd_pjt_3.png) 上面一张图是时序中的参数表，下面的图是时序图 从时序图中看出，这块屏幕可以不用设置前后沿，可以只设置消影(blanking)时间，通过实际的程序证明，两种方式都是可以的 ## 新建工程 新建工程方法参考[自建点灯文章(点我)](./led/self_create.html) ## 生成屏幕时钟 这里需要用到高云半导体官方的IP核 ### pll 板载的晶振时钟为 27MHz ，但是我们的屏幕要求 33.3MHZ 的时钟，所以我们需要使用相应的ip核来生成需要的时钟 这里需要使用到 `IP Core Generate` ，位置在 Tools > IP Core Generate ![](./../assets/Gowin_IP_rpll.png) 双击 `rpll` ，在弹出窗口 language 选择 Verilog ，CLKIN 为 27MHz ，CLKOUT 为 33.00MHz。 ![](./../assets/lcd_rpll.png) 点击ok后提示是否需要添加到当前工程，此时应当选择确定 ![](./led/assets/add_ip_file_in_project.png) 接着会出现一个例化的tmp文件，用来例化所设置的ip。比如下图中例子 ![](./../../Tang Nano/examples/led/assets/ip_examples.png) ## 屏幕驱动代码 **首先新建一个额外的verilog文件来保存下面要编写的代码** ### 端口定义 首先需要先定义出驱动屏幕所需要的端口 ```verilog module VGAMod ( input CLK, input nRST, input PixelClk, output LCD_DE, output LCD_HSYNC, output LCD_VSYNC, \toutput [4:0] LCD_B, \toutput [5:0] LCD_G, \toutput [4:0] LCD_R ); ``` 本例程使用RGB565作为驱动方式； ### 时序常量 接着定义出时序图上所要求的常量 ```verilog localparam V_BackPorch 16'd6; //0 or 45 localparam V_Pluse \t 16'd5; localparam HightPixel 16'd480; localparam V_FrontPorch 16'd62; //45 or 0 localparam H_BackPorch 16'd182; \t localparam H_Pluse \t 16'd1; localparam WidthPixel 16'd800; localparam H_FrontPorch 16'd210; localparam PixelForHS WidthPixel + H_BackPorch + H_FrontPorch; \t localparam LineForVS HightPixel + V_BackPorch + V_FrontPorch; ``` 首先是设置时序相关的参数：前沿、后沿、有效像素 关于显示前沿、后沿，前面也说了，可以合并为一个消影时间，就是可以把其中一个设置为0，另一个设置为消影时间。反正前后沿的时间加起来符合表中的时间要求就可以 ### 计数变量 定义一些变量能够容易编写程序 ```verilog reg [15:0] LineCount; reg [15:0] PixelCount; reg\t[9:0] Data_R; reg\t[9:0] Data_G; reg\t[9:0] Data_B; ``` ### 同步信号 这段代码产生同步信号，需要注意的是，这块屏幕的同步信号是负极性使能 ```verilog always @( posedge PixelClk or negedge nRST )begin if( !nRST ) begin LineCount < 16'b0; PixelCount < 16'b0; end else if( PixelCount PixelForHS ) begin PixelCount < 16'b0; LineCount < LineCount + 1'b1; end else if( LineCount LineForVS ) begin LineCount < 16'b0; PixelCount < 16'b0; end else PixelCount < PixelCount + 1'b1; end always @( posedge PixelClk or negedge nRST )begin if( !nRST ) begin \t\t\tData_R < 9'b0; \t\t\tData_G < 9'b0; \t\t\tData_B < 9'b0; end else begin \t\t\tend \tend //注意这里HSYNC和VSYNC负极性 assign LCD_HSYNC (( PixelCount > H_Pluse)&&( PixelCount < (PixelForHS H_FrontPorch))) ? 1'b0 : 1'b1; assign LCD_VSYNC ((( LineCount > V_Pluse )&&( LineCount < (LineForVS 0) )) ) ? 1'b0 : 1'b1; ``` ### 使能信号 这段代码设置 LCD 使能图像显示，这块屏幕需要控制一个管脚用作显示开关，实际这个信号就是传输图像有效的那 800*480 的数据时置 1 ```verilog assign LCD_DE ( ( PixelCount > H_BackPorch )&& ( PixelCount < PixelForHS H_FrontPorch ) && ( LineCount > V_BackPorch ) && ( LineCount < LineForVS V_FrontPorch 1 )) ? 1'b1 : 1'b0; //这里不减一，会抖动 ``` ### 测试彩条 这段代码用来产生 LCD 的测试数据，产生彩条显示 ```verilog localparam Colorbar_width WidthPixel / 16; assign LCD_R ( PixelCount < ( H_BackPorch + Colorbar_width * 0 )) ? 5'b00000 : ( PixelCount < ( H_BackPorch + Colorbar_width * 1 )) ? 5'b00001 : ( PixelCount < ( H_BackPorch + Colorbar_width * 2 )) ? 5'b00010 : ( PixelCount < ( H_BackPorch + Colorbar_width * 3 )) ? 5'b00100 : ( PixelCount < ( H_BackPorch + Colorbar_width * 4 )) ? 5'b01000 : ( PixelCount < ( H_BackPorch + Colorbar_width * 5 )) ? 5'b10000 : 5'b00000; assign LCD_G ( PixelCount < ( H_BackPorch + Colorbar_width * 6 )) ? 6'b000001: ( PixelCount < ( H_BackPorch + Colorbar_width * 7 )) ? 6'b000010: ( PixelCount < ( H_BackPorch + Colorbar_width * 8 )) ? 6'b000100: ( PixelCount < ( H_BackPorch + Colorbar_width * 9 )) ? 6'b001000: ( PixelCount < ( H_BackPorch + Colorbar_width * 10 )) ? 6'b010000: ( PixelCount < ( H_BackPorch + Colorbar_width * 11 )) ? 6'b100000: 6'b000000; assign LCD_B ( PixelCount < ( H_BackPorch + Colorbar_width * 12 )) ? 5'b00001 : ( PixelCount < ( H_BackPorch + Colorbar_width * 13 )) ? 5'b00010 : ( PixelCount < ( H_BackPorch + Colorbar_width * 14 )) ? 5'b00100 : ( PixelCount < ( H_BackPorch + Colorbar_width * 15 )) ? 5'b01000 : ( PixelCount < ( H_BackPorch + Colorbar_width * 16 )) ? 5'b10000 : 5'b00000; ``` **当然在最后的驱动文件最后别忘记换行加上 endmodule** 到这里驱动模块的编写已经完成了。 ## 在顶层模块中例化 **这里也是要新建文件的** ```verilog module TOP //设置顶层模块 ( \tinput\t\t\tnRST, input XTAL_IN, \toutput\t\t\tLCD_CLK, \toutput\t\t\tLCD_HYNC, \toutput\t\t\tLCD_SYNC, \toutput\t\t\tLCD_DEN, \toutput\t[4:0]\tLCD_R, \toutput\t[5:0]\tLCD_G, \toutput\t[4:0]\tLCD_B ); // 罗列需要的端口 \twire\t\tCLK_SYS;\t \twire\t\tCLK_PIX; //例化pll Gowin_rPLL chip_pll( .clkout(CLK_SYS), //output clkout //200M .clkoutd(CLK_PIX), //output clkoutd //33.00M .clkin(XTAL_IN) //input clkin );\t \tVGAMod\tVGAMod_inst //例化vga驱动 \t( \t\t.CLK\t\t(\tCLK_SYS ), \t\t.nRST\t\t(\tnRST\t\t), \t\t.PixelClk\t(\tCLK_PIX\t\t), \t\t.LCD_DE\t\t(\tLCD_DEN\t \t), \t\t.LCD_HSYNC\t(\tLCD_HYNC \t), \t.LCD_VSYNC\t(\tLCD_SYNC \t), \t\t.LCD_B\t\t(\tLCD_B\t\t), \t\t.LCD_G\t\t(\tLCD_G\t\t), \t\t.LCD_R\t\t(\tLCD_R\t\t) \t); \tassign\t\tLCD_CLK\t\t \tCLK_PIX; endmodule ``` ## 综合、约束、布局布线 ### 综合 完成上面步骤后转到“Process”界面下，对编辑好的代码进行综合，即运行“Synthesize” ![](./../../Tang Nano 9K/nano_9k/nano_9k_synthsize.png) 运行的结果如下图出现 ![](./../../Tang Nano/assets/LED.png) 且下方结果栏不出现任何从报错，说明前面编辑的代码无误，如果有错，根据错误提示进行改正即可。 ### 约束 此处仅管脚约束 对应的管脚约束如下表格； 关于管脚约束可以参考[自建点灯文章(点我)](./led/self_create.html)里面的约束方法 如果感觉麻烦的话也可以直接复制准备好的[文件(点我)](./lcd_constrains.html)，将页面里的内容复制到工程目录里 .cst 文件中（如果没有.cst 文件那么自己新建一个）**物理管脚约束文件** 即可。 PORT PIN PORT PIN : : : : : : : : LED_B 10 LED_G 11 LED_R 9 LCD_B[4] 24 LCD_B[3] 23 LCD_B[2] 22 LCD_B[1] 20 LCD_B[0] 19 LCD_G[5] 18 LCD_G[4] 17 LCD_G[3] 16 LCD_G[2] 15 LCD_G[1] 27 LCD_G[0] 28 LCD_R[4] 29 LCD_R[3] 30 LCD_R[2] 31 LCD_R[1] 34 LCD_R[0] 35 LCD_DEN 21 LCD_SYNC 32 LCD_HYNC 33 LCD_CLK 8 XTAL_IN 47 nRST 44 ### 布局布线 管脚约束之后需要在设置里面开启引脚复用才能完成布局布线。 具体位置在 软件顶部菜单栏 Project > Configuration > Place&Route > Dual Purpose Pin ![](./led/assets/enable_io_mux.png) 设置完上面的之后。 就可以开始布局布线(Place&Route)了。 完成后就可以给开发板验证代码内容了。 ## 烧录 布局布线结束后生成比特流，就可以烧录开发板了。 ## 结束 上面差不多叙述了所需要的代码。 整个工程可以参考 [这里](https://github.com/sipeed/TangNano 1K examples/tree/main/example_lcd/) <p id \"back\"> <a href \"#\" onClick \"javascript :history.back( 1);\">返回上一页(Back)</a> </p>"},"/hardware/zh/tang/Tang-Nano-1K/examples/led/github_sourcecode.html":{"title":"使用github例程","content":" title: 使用github例程 首先获得仓库文件 https://github.com/sipeed/TangNano 1K examples 打开 TangNano 1K examples\\example_led\\led_prj 目录下的 led_prj.gprj 文件 在process界面直接双击 Place&Route ![](./assets/github_nano1K_place&route.png) 然后是进行连接板子，烧录固件。在Process界面双击`Program Device` 后打开烧录工具 ![](./assets/Open_Programmer_nano_1k.png) 接下来选择sram烧录即可验证程序。 ![](./assets/Success_led_nano_1k.png) <p id \"back\"> <a href \"#\" onClick \"javascript :history.back( 1);\">返回上一页(Back)</a> </p>"},"/hardware/zh/tang/Tang-Nano-1K/examples/led/lcd_constrains.html":{"title":"","content":" title: LCD 约束文件内容 ``` IO_LOC \"LED_B\" 10; IO_PORT \"LED_B\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LED_G\" 11; IO_PORT \"LED_G\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LED_R\" 9; IO_PORT \"LED_R\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_B[4]\" 24; IO_PORT \"LCD_B[4]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_B[3]\" 23; IO_PORT \"LCD_B[3]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_B[2]\" 22; IO_PORT \"LCD_B[2]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_B[1]\" 20; IO_PORT \"LCD_B[1]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_B[0]\" 19; IO_PORT \"LCD_B[0]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_G[5]\" 18; IO_PORT \"LCD_G[5]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_G[4]\" 17; IO_PORT \"LCD_G[4]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_G[3]\" 16; IO_PORT \"LCD_G[3]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_G[2]\" 15; IO_PORT \"LCD_G[2]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_G[1]\" 27; IO_PORT \"LCD_G[1]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_G[0]\" 28; IO_PORT \"LCD_G[0]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_R[4]\" 29; IO_PORT \"LCD_R[4]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_R[3]\" 30; IO_PORT \"LCD_R[3]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_R[2]\" 31; IO_PORT \"LCD_R[2]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_R[1]\" 34; IO_PORT \"LCD_R[1]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_R[0]\" 35; IO_PORT \"LCD_R[0]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_DEN\" 21; IO_PORT \"LCD_DEN\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_SYNC\" 32; IO_PORT \"LCD_SYNC\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_HYNC\" 33; IO_PORT \"LCD_HYNC\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_CLK\" 8; IO_PORT \"LCD_CLK\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"XTAL_IN\" 47; IO_PORT \"XTAL_IN\" IO_TYPE LVCMOS33 PULL_MODE UP; IO_LOC \"nRST\" 44; IO_PORT \"nRST\" IO_TYPE LVCMOS33 PULL_MODE UP; IO_LOC \"KEY\" 13; IO_PORT \"KEY\" IO_TYPE LVCMOS33 PULL_MODE UP; ```"},"/hardware/zh/tang/Tang-Nano-1K/examples/led/self_create.html":{"title":"点灯LED RGB","content":" title: 点灯LED RGB > 编辑于2022年4月13日 ## 新建项目 新建工程：File >NEW >FPGA Design Project >OK ![](./../../../Tang Nano/assets/LED 1.png) 弹出的选项框选择存储路径和工程名称（路径和文件名称要求是英文路径） ![](./../../../Tang Nano/assets/LED 2.png) 选择对应的型号： ![Tang_nano_1k_device_choose](./../../assets/Nano_1K_device_choose.png) ## 编写代码 新建工程之后接下来进行代码编辑，在Design工作栏内新建“Verilog File”,如下图所示： ![](./../../../Tang Nano/assets/LED 5.png) 为文件命名（要求写英文名，不然后续综合很容易报错）； 一般来说文件名称应该和文件内容模块名称相同 ![](./../../../Tang Nano/assets/LED 6.png) 双击文件，可以在右侧的编辑框中进行代码的编写。 ![](./../../../Tang Nano/assets/LED 7.png) 以流水灯为例，将下方的“LED例程代码”粘贴到自己的文件中，也可以自己编写自己的代码。 ```verilog module led ( input sys_clk, // clk input input sys_rst_n, // reset input output reg [2:0] led // 110 B, 101 G,001 R ); reg [23:0] counter; always @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) counter < 24'd0; else if (counter < 24'd1349_9999) // 0.5s delay counter < counter + 1'b1; else counter < 24'd0; end always @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) led < 3'b110; else if (counter 24'd1349_9999) // 0.5s delay led[2:0] < {led[1:0],led[2]}; else led < led; end endmodule ``` ## 综合、约束、布局布线 ### 综合 保存编辑的代码后转到“Process”界面下，对编辑好的代码进行综合，即双击“Synthesize” ![](./../../../Tang Nano 9K/nano_9k/nano_9k_synthsize.png) 运行之后如没有报错而且 Synthesize 变成下图里的图标 ![](./../../../Tang Nano/assets/LED.png) 说明前面编辑的代码无误；如果有错，根据错误提示进行改正即可。 ### 约束 此处未涉及时钟约束 想让 Fpga 实现代码的功能，必须将代码中涉及的 端口 绑定到 Fpga 实际的引脚上。 如下图，在左边的工作区点击 process，然后双击 FloorPlanner ![](./../../assets/examples/led_pjt_2.png) 在工程中第一次点击，可能会提示创建文件，点击确定即可 ![](./../../../Tang Nano/assets/LED 9.png) nano 1k的rgb led电路图如下所示 ![](./../../assets/Nano_1K_RGB_pins.png \"nano 1k rgb pins\") 对于交互式管脚约束有下图中的两种方法 将对应的端口拖拽到芯片引脚上 在IO约束中输入端口对应的引脚编号 因此在打开的界面中按照序号的顺序来进行相应的操作（两种方式选择一种即可） ![](./../../assets/RGB_LED_Constrains.png) 关于 FloorPlanner 更多的相关说明，可以参考 [SUG935 1.3_Gowin设计物理约束用户指南.pdf](http://cdn.gowinsemi.com.cn/SUG935 1.3_Gowin%E8%AE%BE%E8%AE%A1%E7%89%A9%E7%90%86%E7%BA%A6%E6%9D%9F%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf)。里面的内容都很有用 **完成约束后记得保存~** ### 布局布线 到“Process”下运行“Place&Route”，即运行管脚布局布线，运行结果如下图所示： ![](./../../assets/RGB_LED_Place&Route.png) 如果没有成功运行，那自己修修。 ## 烧录 成功完成上面步骤后就已经生成高云半导体的比特流文件了，可以进行下面的步骤来将文件烧录到板子了。 接下来是连接板子，烧录固件。在Process界面双击`Program Device` 后打开烧录工具 ![](./../../assets/Open_Programmer.png) 可以从下面的图中选择烧录模式；再此以烧录到SRAM作为示例 ![](./../../../Tang Nano/examples/led/assets/tang nano programmer config.png) 接下来选择运行即可验证程序。有固化需求的自行选择下载到flash即可。 点灯验证到此结束。 <p id \"back\"> <a href \"#\" onClick \"javascript :history.back( 1);\">返回上一页(Back)</a> </p>"},"/hardware/zh/tang/Tang-Nano-1K/examples/LED.html":{"title":"点灯","content":"# 点灯 > 编辑于2022年3月29日 ## 前言 此处提供两种方法点灯 对于文章中有什么疑问或者错误的地方欢迎到 [论坛](https://bbs.sipeed.com) 或 QQ群 提出 [使用github仓库](./led/github_sourcecode.html) [自己新建项目](./led/self_create.html) <p id \"back\"> <a href \"#\" onClick \"javascript :history.back( 1);\">返回上一页(Back)</a> </p>"},"/hardware/zh/tang/Tang-Nano-1K/Tang-nano-1k.html":{"title":"Tang nano 1k 一些例程","content":" title: Tang nano 1k 一些例程 对于Programmer(下载程序)建议使用 https://dl.sipeed.com/shareURL/TANG/programmer 里面的文件。 下载后解压替换掉Gowin对应安装目录的Programmer文件夹即可。 不会替换的话可以在下载解压后的Programmer程序中手动添加对应下载文件来进行烧录。 [点灯例程](./examples/LED.html) [驱屏教程](./examples/LCD.html)"},"/hardware/zh/tang/Tang-Nano-1K/Nano-1k.html":{"title":"Tang Nano 1K","content":"# Tang Nano 1K ## 概述 Tang Nano 1K 是基于高云半导体的小蜜蜂系列 GW1NZ LV1 FPGA设计的简约型开发板。开发板设计小巧精致，将芯片的所有资源都引出，板载Type C、USB JTAG、有源晶振、RGB(可接LCD屏、VGA等外设)等，并把所有IO资源引出，方便开发者拓展使用，非常适用于小型数字逻辑的设计和实验。 ![Nano 1](./../Tang Nano/assets/1k 1.jpg) ![Nano 2](./../Tang Nano/assets/1k 2.jpg) ## 参数 Tang Nano 1K 开发板板载的 GW1NZ LV1 FPGA芯片功能非常强大，具有较丰富的逻辑资源，支持多种 I/O 电平标准，内嵌块状静态随机存储器、锁相环、Flash 等资源，是一款具有非易失性的 FPGA 产品;另外，板载 27MHz 有源晶振，为 FPGA 各种时序操作提供了更精准的频率。 项目 参数 : : : : 核心 GW1NZ LV1 FPGA 逻辑单元(LUT4) 1152 寄存器(FF) 864 Block SRAM(bits) 72K B SRAM块个数 4 用户闪存(bits) 64K 锁相环PLL 1 I/O Bank总数 2 最多用户I/O数 48 核电压 1.2V ### 引脚图 ![pin_map](./../Tang Nano/assets/1k pin.png) ## 资料 [规格书](https://dl.sipeed.com/shareURL/TANG/Nano%201K/1_Specification) [原理图](https://dl.sipeed.com/shareURL/TANG/Nano%201K/2_Schematic) [点位图](https://dl.sipeed.com/shareURL/TANG/Nano%201K/3_Bit_number_map) [尺寸图](https://dl.sipeed.com/shareURL/TANG/Nano%201K/4_Dimensional_drawing) [3D 文件](https://dl.sipeed.com/shareURL/TANG/Nano%201K/5_3D_file) [芯片手册](https://dl.sipeed.com/shareURL/TANG/Nano%201K/6_Chip_Manual) [相关例程](https://wiki.sipeed.com/hardware/zh/tang/common doc/examples.html) ## 补充 1. 如果有什么疑问，欢迎加群 `834585530`, 或者去[论坛](bbs.sipeed.com)发帖。 2. 下载 FPGA 是要求使用 [这里](https://dl.sipeed.com/shareURL/TANG/programmer) 的 Programmer 软件。不然有极大概率不能下载固件到板子。 3. 有问题的话先去 [常见问题](./../common doc/questions.html) 自查，通常来说使用 [这里](https://dl.sipeed.com/shareURL/TANG/programmer) 的 Programmer 软件能解决 99% 问题。"},"/hardware/zh/tang/tang-primer-15k/primer-15k.html":{"title":"Tang Primer 15K Dock","content":" title: Tang Primer 15K Dock keywords: FPGA, Tang, Primer, 15K update: date: 2024 06 25 version: v0.1 author: Serika content: 新建文档 ## 概述 TBD 购买链接：[淘宝](https://sipeed.taobao.com) ## 核心板概览 TBD ## 基础参数 <table> \t<thead> \t\t<tr> \t\t\t<th style \"text align:center\">项目</th> \t\t\t<th style \"text align:center\">参数</th> \t\t\t<th style \"text align:center\">补充</th> \t\t</tr> \t</thead> \t<tbody> \t\t<tr> \t\t\t<td style \"text align:left\">FPGA 芯片</td> \t\t\t<td style \"text align:left\"><a href \"https://www.gowinsemi.com.cn/prod_view.aspx?TypeId 74&FId t3:10:3&Id 188#G15K\">GW5ART 15MG132P</a> \t\t\t</td> \t\t\t<td style \"text align:left\"> \t\t\t\t<table> \t\t\t\t\t<tr> \t\t\t\t\t\t<td>逻辑单元(LUT4)</td> \t\t\t\t\t\t<td>15120</td> \t\t\t\t\t</tr> \t\t\t\t\t<tr> \t\t\t\t\t\t<td>寄存器(FF)</td> \t\t\t\t\t\t<td>15120</td> \t\t\t\t\t</tr> \t\t\t\t\t<tr> \t\t\t\t\t\t<td>分布式静态随机存储器S SRAM(bits)</td> \t\t\t\t\t\t<td>118125</td> \t\t\t\t\t</tr> \t\t\t\t\t<tr> \t\t\t\t\t\t<td>块状静态随机存储器B SRAM(bits)</td> \t\t\t\t\t\t<td>630</td> \t\t\t\t\t</tr> \t\t\t\t\t<tr> \t\t\t\t\t\t<td>块状静态随机存储器数目B SRAM(个)</td> \t\t\t\t\t\t<td>35</td> \t\t\t\t\t</tr> \t\t\t\t\t<tr> \t\t\t\t\t\t<td>乘法器(18x18 Multiplier)</td> \t\t\t\t\t\t<td>28+12</td> \t\t\t\t\t</tr> \t\t\t\t\t<tr> \t\t\t\t\t\t<td>锁相环(PLLs)</td> \t\t\t\t\t\t<td>2</td> \t\t\t\t\t</tr> \t\t\t\t\t <td>全局时钟</td> <td>16</td> </tr> <tr> <td>高速时钟</td> <td>2</td> </tr> \t\t\t\t\t <tr> <td>Transceivers</td> <td>8</td> </tr> <tr> <td>Transceivers 速率</td> <td>270Mbps 12.5Gbps</td> </tr> <tr> <td>PCIE 硬核</td> <td>1个<br>速度可选 x1, x2, x4, x8 PCIe 2.0</td> </tr> <tr> <td>LVDS (Gbps)</td> <td>1.25</td> </tr> \t\t\t\t\t <td>MIPI D PHY硬核</td> <td>2.5Gbps（RX/TX），<br>4个数据通道，<br>1个时钟通道</td> </tr> <tr> <td>MIPI C PHY硬核</td> <td>2.5Gbps（RX/TX），<br> 5.75Gbps,RX/TX<br>3个三线数据通道</td> </tr> \t\t\t\t\t<tr> <td>PSRAM</td> <td>64Mb @ 667MHz</td> </tr> <tr> <td>ADC</td> <td>1</td> </tr> \t\t\t\t\t<tr> \t\t\t\t\t\t<td>GPIO Bank 总数</td> \t\t\t\t\t\t<td>4</td> \t\t\t\t</table> \t\t\t</td> \t\t</tr> \t\t<tr> \t\t\t<td style \"text align:left\">Flash</td> \t\t\t<td style \"text align:left\">64Mb</td> \t\t\t<td style \"text align:left\">查看 <a href \"#burn_flash\">烧录到Flash</a></td> \t\t</tr> \t\t<tr> \t\t\t<td style \"text align:left\">整体封装</td> \t\t\t<td style \"text align:left\">TBD</td> \t\t\t<td style \"text align:left\"></td> \t\t</tr> \t\t<tr> \t\t\t<td style \"text align:left\">普通IO</td> \t\t\t<td style \"text align:left\"> 53</td> \t\t\t<td style \"text align:left\"></td> \t\t</tr> \t\t<tr> \t\t\t<td style \"text align:left\"> MIPI IO </td> \t\t\t<td style \"text align:left\"> 10</td> \t\t\t<td style \"text align:left\"></td> \t\t</tr> \t</tbody> </table> ## Dock 底板产品图 TBD ## 板卡参数 <table> \t<thead> \t\t<tr> \t\t\t<th style \"text align:center\">项目</th> \t\t\t<th style \"text align:center\">参数</th> \t\t\t<th style \"text align:center\">备注</th> \t\t</tr> \t</thead> \t<tbody> \t\t<tr> \t\t\t<td style \"text align:left\">调试器</td> \t\t\t<td style \"text align:left\">TBD</td> \t\t\t<td style \"text align:left\"></td> \t\t</tr> \t\t<tr> \t\t\t<td style \"text align:left\">USB A</td> \t\t\t<td style \"text align:left\">TBD</td> \t\t\t<td style \"text align:left\"></td> \t\t</tr> \t\t<tr> \t\t\t<td style \"text align:left\"> IO插针 </td> \t\t\t<td style \"text align:left\"> TBD</td> \t\t\t<td style \"text align:left\"></td> \t\t</tr> \t\t<tr> \t\t\t<td style \"text align:left\"> PMOD </td> \t\t\t<td style \"text align:left\"> TBD</td> \t\t\t<td style \"text align:left\"></td> \t\t</tr> \t\t<tr> \t\t\t<td style \"text align:left\">按键</td> \t\t\t<td style \"text align:left\">TBD</td> \t\t\t<td style \"text align:left\"></td> \t\t</tr> \t\t<tr> \t\t\t<td style \"text align:left\">尺寸</td> \t\t\t<td style \"text align:left\">TBD</td> \t\t\t<td style \"text align:left\"></td> \t\t</tr> \t</tbody> </table> ## 硬件资料 规格书、原理图、尺寸图等均可在这里找到：[点击这里](https://dl.sipeed.com/shareURL/TANG/Primer_15K) [板卡规格书](https://dl.sipeed.com/shareURL/TANG/Primer_15K/01_Specification) [板卡原理图](https://dl.sipeed.com/shareURL/TANG/Primer_15K/02_Schematic) [板卡点位图](https://dl.sipeed.com/shareURL/TANG/Primer_15K/03_Designator_drawing) [板卡尺寸图](https://dl.sipeed.com/shareURL/TANG/Primer_15K/04_Mechanical_drawing) [3D 模型文件](https://dl.sipeed.com/shareURL/TANG/Primer_15K/05_3D_file) [核心板封装](https://dl.sipeed.com/shareURL/TANG/Primer_15K/06_PCB_Lib) [芯片部分资料](https://dl.sipeed.com/shareURL/TANG/Primer_15K/07_Datasheet) [走线长度表](https://dl.sipeed.com/shareURL/TANG/Primer_15K/08_Pin_Length_table) ## 上手简明 `准备开发环境` > `学习相关语法` > `查看开箱指南` > `基础代码编写` > `查看官方文档` 1. 安装 IDE ：[点击这里](./../common doc/get_started/install the ide.html) 2. 查看 [上手指南](https://wiki.sipeed.com/hardware/zh/tang/tang primer 20k/start.html) 来避免一些问题，并且从那里面可以开始进行代码实战。 3. 如果进行完上面的点灯操作后后感觉有压力，可以自己查漏补缺： 可以在下面的这些网站学习 Verilog: \t+ 在线免费教程：[Verilog 教程](https://www.runoob.com/w3cnote/verilog tutorial.html)（学习Verilog） \t+ 在线免费 FPGA 教程：[Verilog](https://www.asic world.com/verilog/index.html) （英文网站） \t+ Verilog 刷题网站：[HDLBits](https://hdlbits.01xz.net/wiki/Main_Page)（英文网站） \t+ 在线高云半导体可参考视频教程：[点击这里](http://www.gowinsemi.com.cn/video_complex.aspx?FId n15:15:26) 对 IDE 使用有疑问的话，可以查看官方的一些文档来熟悉相关内容 [SUG100 2.6_Gowin云源软件用户指南.pdf](http://cdn.gowinsemi.com.cn/SUG100 2.6_Gowin%E4%BA%91%E6%BA%90%E8%BD%AF%E4%BB%B6%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf) [SUG949 1.1_Gowin_HDL编码风格用户指南.pdf](http://cdn.gowinsemi.com.cn/SUG949 1.1_Gowin_HDL%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf) <a href \"http://cdn.gowinsemi.com.cn/UG286 1.9.1_Gowin%E6%97%B6%E9%92%9F%E8%B5%84%E6%BA%90(Clock)%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf\">UG286 1.9.1_Gowin时钟资源(Clock)用户指南.pdf</a> [SUG940 1.3_Gowin设计时序约束用户指南.pdf](http://cdn.gowinsemi.com.cn/SUG940 1.3_Gowin%E8%AE%BE%E8%AE%A1%E6%97%B6%E5%BA%8F%E7%BA%A6%E6%9D%9F%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf) [SUG502 1.3_Gowin_Programmer用户指南.pdf](http://cdn.gowinsemi.com.cn/SUG502 1.3_Gowin_Programmer%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf) [SUG114 2.5_Gowin在线逻辑分析仪用户指南.pdf](http://cdn.gowinsemi.com.cn/SUG114 2.5_Gowin%E5%9C%A8%E7%BA%BF%E9%80%BB%E8%BE%91%E5%88%86%E6%9E%90%E4%BB%AA%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf) 上面的所有文档都已经打包进了下载站[点我跳转](https://dl.sipeed.com/shareURL/TANG/Primer_20K/07_Chip_manual/CN/%E9%80%9A%E7%94%A8%E6%8C%87%E5%BC%95)，需要的话可以点击压缩包全都下载下来。 ## 例程汇总 注意15K需要使用 V1.9.9.04 或更新的IDE版本。 http://www.gowinsemi.com.cn/faq.aspx ### 公开例程 github 链接： https://github.com/sipeed/TangPrimer 15K example ## 交流方式 **交流论坛: [maixhub.com](maixhub.com/discussion)** **QQ 交流群：[834585530](https://jq.qq.com/?_wv 1027&k wBb8XUan)** 直接本页下方留言 商业邮箱 : [support@sipeed.com](support@sipeed.com) ## 相关问题 ### TBD TBD"},"/hardware/zh/tang/tang-primer-20k/examples/lcd.html":{"title":"","content":"# 施工中"},"/hardware/zh/tang/tang-primer-20k/examples/timing_decode_led_on.html":{"title":"Tang Primer 20K 译码器亮灯","content":" title: Tang Primer 20K 译码器亮灯 keywords: Tang Primer 20K ,例程, 上手 update: date: 2022 11 03 version: v0.1 author: wonder content: 初稿 ## 说明 在前面的 [译码器亮灯](./decode_led_on.html) 中，使用 verilog 语句来写出真值表达式来达到译码器的目的。这里介绍使用 case 语句来实现译码器功能。 在前面的 [译码器亮灯](./decode_led_on.html) 中，我们所需要的最终结果如下： <table> <tr> <th colspan \"2\"> 按键 </th> <th colspan \"4\">LED 电平状态</th> </tr> <tr> <td>S0</td> <td>S1</td> <td>LED0</td> <td>LED1</td> <td>LED2</td> <td>LED3</td> </tr> <tr> <td></td> <td></td> <td>0</td> <td></td> <td></td> <td></td> </tr> <tr> <td>0</td> <td></td> <td></td> <td>0</td> <td></td> <td></td> </tr> <tr> <td></td> <td>0</td> <td></td> <td></td> <td>0</td> <td></td> </tr> <tr> <td>0</td> <td>0</td> <td></td> <td></td> <td></td> <td>0</td> </tr> </table> ### case 语法 ## 操作 ### 引脚复用 READY DONE SSPI ### 端口和引脚 Port Direction Location key[0] input T10 key[1] input T3 led[0] output C13 led[1] output A13 led[2] output N16 led[3] output N14 ### 代码 .. tabset:: ## decode_led_on.v Verilog文件； 定义了两个按键输入端口，和四个输出端口。根据按键输入的状态，译码输出到对应的端口。 ```verilog module decode_led_on( input [1:0] key, output [3:0] led ); assign led[0] !( key[0] & key[1] ) ; assign led[1] !(!key[0] & key[1] ) ; assign led[2] !( key[0] &!key[1] ) ; assign led[3] ( key[0] key[1] ) ; endmodule ``` ## decode_led_on.cst 物理约束文件； 将 verilog 代码里的端口绑定到 FPGA 引脚上面 ```txt IO_LOC \"led[3]\" N14; IO_LOC \"led[2]\" N16; IO_LOC \"led[1]\" A13; IO_LOC \"led[0]\" C13; IO_LOC \"key[1]\" T3; IO_LOC \"key[0]\" T10; IO_PORT \"led[3]\" PULL_MODE UP DRIVE 8; IO_PORT \"led[2]\" PULL_MODE UP DRIVE 8; IO_PORT \"led[1]\" PULL_MODE UP DRIVE 8; IO_PORT \"led[0]\" PULL_MODE UP DRIVE 8; IO_PORT \"key[1]\" PULL_MODE UP; IO_PORT \"key[0]\" PULL_MODE UP; ``` ## 效果 默认只有 LED0 亮；按下 S0 按键 LED1 亮；按下 S1 按键 LED1 亮；按下 S0 和 S2 按键 LED3 亮； <table> <tr> <th colspan \"2\" >按键</th> <th colspan \"4\">LED 状态</th> </tr> <tr> <td>S0</td> <td>S1</td> <td>LED0</td> <td>LED1</td> <td>LED2</td> <td>LED3</td> </tr> <tr> <td></td> <td></td> <td>亮</td> <td></td> <td></td> <td></td> </tr> <tr> <td>按下</td> <td></td> <td></td> <td>亮</td> <td></td> <td></td> </tr> <tr> <td></td> <td>按下</td> <td></td> <td></td> <td>亮</td> <td></td> </tr> <tr> <td>按下</td> <td>按下</td> <td></td> <td></td> <td></td> <td>亮</td> </tr> </table> <p id \"back\"> <a href \"#\" onClick \"javascript :history.back( 1);\">返回上一页(Back)</a> </p>"},"/hardware/zh/tang/tang-primer-20k/examples/assign_led.html":{"title":"Tang Primer 20K Dock 亮一个灯","content":" title: Tang Primer 20K Dock 亮一个灯 tags: Tang Primer 20K Dock，上手 keywords: Primer, Tang, Dock， 入门，20K desc: Tang Primer 20K Dock 简单上手 update: date: 2022 09 29 version: v0.1 author: wonder content: 初稿 ## 安装 IDE 参考 [安装IDE](https://wiki.sipeed.com/hardware/zh/tang/common doc/get_started/install the ide.html) 来完成我们需要准备的软件环境。 Windows 用户建议额外下载一次高云教育版的编程器软件，这样可以避免烧录时因为 Programmer 软件版本不兼容 BL702 下载器而导致的奇怪问题。 对于 Linux 用户的话建议使用 [openfpgaLoader](https://wiki.sipeed.com/hardware/zh/tang/common doc/get_started/flash_in_linux.html) 这软件来烧录这款板子。 ## 新建工程 文件 > 新建 > FPGA Design > Project <div> <img src \"./assets/led_assets/new_project.png\" width 58% alt \"new_project\"> <img src \"./assets/led_assets/fpga_project.png\" width 35% alt \"fpga_project\"> </div> 设置工程名称，要求只用英文的下划线命名，存放路径中不要有中文字符或者空格等。 ![project_path](./assets/assign_led_assets/assign_led_on.png) 然后在下面的芯片型号中选择 GW2A LV18PG256C8/I7，使用上面的筛选能够更快地选择到正确的型号。注意 Device 那一栏为 GW2A 18C ![device_choose](./assets/led_assets/device_choose.png) 然后点击确定后就可以进行最终项目预览了。确认无误后就完成工程创建了。 ## 编写代码 ### 新建文件 高云半导体 IDE 提供了三种新建文件的方法。在此我们直接使用快捷键 `Ctrl + N` 来新建文件，其他两种不在此讲述。 在弹出的窗口中选择 `Verilog File`，会 VHDL 的也可以选择下面的 `VHDL File`，这篇文章只用 Verilog 来做点灯示例。 <img src \"./assets/led_assets/new_verilog_file.png\" width 50% alt \"new_verilog_file\"> 点击 OK 之后会提示让我们输入文件名称，此处以 `led` 为文件名做示范。 <img src \"./assets/led_assets/file_name.png\" width 75% alt \"file_name\"> 到这里我们就完成文件的创建了，可以直接编写代码了。 ![created_file](./assets/led_assets/created_file.png) ### Verilog 简单说明 Verilog 是一种硬件描述语言，用来对数字电路进行抽象化描述。 Verilog 的基本设计单元是“模块”(module)。 一个模块是由两部分组成的：一部分描述接口，另一部分描述内部逻辑功能，即定义输入是如何影响输出的。 一个模块长成这样： ```v module module_name #(parameter) (port) ; function endmodule ``` 模块整体结构由 module 和 endmodule 组成，module 后面跟着的是模块的名称(module_name)，可传递变量参数(parameter)，端口及其方向的申明(port)，紧接着就是内部逻辑功能描述(function) ,最后用 endmodule 来表示这一个模块，描述完毕。 内部逻辑功能通常由 assign 和 always 块完成；其中 assign 语句描述逻辑功能，always 块常用于描述时序功能。 ### 代码思路 根据我们的 Dock 底板 [原理图](https://dl.sipeed.com/shareURL/TANG/Primer_20K/02_Schematic)，可以看到我们将 IO 控制为底的时候，LED 会亮起来。 ![led_schematic](./assets/assign_led_assets/led_schematic.png) 知道怎么样能让灯亮起来后，就快点编写代码吧 ### 代码描述 ```v module assign_led_on( output led_voltage_level ); assign led_voltage_level 1'b0 ; endmodule ``` 上面的代码，定义了一个名为 assign_led_on 得模块，一个名为 led_voltage_level 的输出端口。 `assign` 语句约束了 led_voltage_level 的值，使其值保持为 0。后面再将这个端口绑定到 FPGA 芯片的引脚上后，就可以得到一个电平状态为低电平的引脚，借此来使 LED 亮起来。 ## 综合、约束、布局布线 ### 综合 代码保存后，可以双击 IDE 内部的 Process > Synthesize 来进行代码综合，将 verilog 代码内容转换为综合网表。 ![synthesize](./assets/assign_led_assets/synthesize.png) 关于网表有兴趣的可以自己去查阅相关资料，此处不再额外说明。 ### 约束 综合完之后我们需要进行管脚约束，才能将所编写的模块端口与 FPGA 引脚相对应，并且实现模块的功能。 点击上图 Synthesize 上面的 FloorPlanner 来进行管脚约束。 ![floorplanner](./assets/led_assets/floorplanner.png) 由于是首次创建，所以会弹出下面的对话框，点击 OK 后就弹出了图形化约束交互界面。 ![create_constrain_file](./assets/led_assets/create_constrain_file.png) ![floorplanner_intreface](./assets/led_assets/floorplanner_interface.png) 关于约束的方法可以查看 [SUG935 1.3_Gowin设计物理约束用户指南.pdf](http://cdn.gowinsemi.com.cn/SUG935 1.3_Gowin%E8%AE%BE%E8%AE%A1%E7%89%A9%E7%90%86%E7%BA%A6%E6%9D%9F%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf) 此处因个人喜所以仅使用下图中 IO Constranins 方法来约束引脚： ![floor_planner_ioconstrain](./assets/assign_led_assets/floor_planner_ioconstrain.png) 根据下面 Dock 底板原理图，决定点亮 LED4，对应在 FPGA 上的引脚为 L14。 ![led_port](./assets/assign_led_assets/led_port.png) 因此对于在 FloorPlanner 交互窗口下面的 IO Constranins 中将 PORT（端口）与 Location（引脚） 分别填入下面的值： ![io_constrain_value](./assets/assign_led_assets/io_constrain_value.png) 输入完毕后快捷键 Ctrl + S 来保存一下引脚约束，然后接可以关闭 FloorPlanner 的交互图形界面了。 接着发现在工程项目里面多出来刚刚创建的 cst 文件了，里面的内容也比较好理解。 ![cst_content](./assets/assign_led_assets/cst_content.png) ### 布局布线 完成约束后就要开始运行布局布线了，目的是为了把综合所生成的网表与我们自己定义的约束来通过 IDE 算出最优解然后将资源合理地分配在 FPGA 芯片上。 双击下图红框处的 Place&Route 就开始运行了。 ![place_route](./assets/assign_led_assets/place_route.png) 紧接着没有报错，全部通过。就可以开始进行烧录了。 ## 烧录固件 Dock 板载了下载器，在 [安装IDE](https://wiki.sipeed.com/hardware/zh/tang/common doc/get_started/install the ide.html) 的时候我们已经安装了驱动。因此我们将板子与电脑连接起来就行。 ![connected](./assets/led_assets/connected.png) 对于 Programmer 软件建议使用高云官网下载到 [点我跳转](http://www.gowinsemi.com.cn/faq.aspx) ，下载下图所示的高云云源编程器软件即可。 ![educational_edition_programmer](./assets/led_assets/educational_edition_programmer.png) ### 扫描设备 在使用 Dock 底板的时候不要忘记使能核心板，按下 1 号拨码开关即可。 ![Enable_core_board](./../assets/start/switch_1_on.png) 双击下图中的下载程序(Program Device) 来运行 Programmer 软件 ![open_programmer](./assets/led_assets/open_programmer.png) 然后在打开的页面中点击一下 scan_device 来扫描到我们的设备。 ![scan_device](./assets/led_assets/scan_device.png) 点击 OK 后就可以进行烧录操作了。 烧录相关的文档可以参考 [SUG502 1.3_Gowin_Programmer用户指南.pdf](http://cdn.gowinsemi.com.cn/SUG502 1.3_Gowin_Programmer%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf) 有问题的话可以前往 [常见问题](https://wiki.sipeed.com/hardware/zh/tang/common doc/questions.html) 自行排查。 ### 下载到 SRAM 一般来说这个模式是以用来快速验证所生成的固件是否满足自己目的的。 因为其烧录快的特性所以使用的较多，然是当然断电会丢失数据，所以如果想上电运行程序的话是不能选这个的。 点击 Operation 下面的功能框来打开设备设置界面，接着在 Operation 框中选择 SRAM Program 选项来设置为下载到 SRAM ，最后点击下面的那三个点点框来选择我们所生成的 .fs 下载固件。通常来说下载固件生成与工程文件目录下的 impl > pnr 目录下。 ![sram_mode](./assets/led_assets/sram_mode.png) 接着来点击红框处开始进行烧录 ![sram_download](./assets/led_assets/sram_download.png) 有问题的话可以前往 [常见问题](https://wiki.sipeed.com/hardware/zh/tang/common doc/questions.html) 自行排查。 到这里就下载完成了。 ### 下载到 Flash 上面说过下载到 SRAM 是为了快速验证，但是不能上电运行程序。 所以想要上电运行的话我们需要设置下载到 Flash。 和上面下载到 SRAM 的步骤几乎类似，先点开 Operation 下面的功能框来打开设备设置界面，接着在 Operation 框中选择 External Flash Mode 选项来设置为下载到外部 Flash ，最后点击下面的那三个点点框来选择我们所生成的 .fs 下载固件，通常来说下载固件生成与工程文件目录下的 impl > pnr 目录下。最后在下面的外部 Flash 选项中选择设备为 Generic Flash 。 ![flash_mode](./assets/led_assets/flash_mode.png) 接着来点击红框处开始进行烧录 ![flash_download](./assets/led_assets/flash_download.png) 然后我们的程序重新上电也能照样运行了。 有问题的话可以前往 [常见问题](https://wiki.sipeed.com/hardware/zh/tang/common doc/questions.html) 自行排查。 ## 代码结果 如图所示，只有 LED4 亮着。 ![led_blink](./assets/assign_led_assets/led4_on.png) ## 结语 到这里我们就已经完成了 FPGA 的 “Hello world” 了。以后的示例工程不会再叙述新建文件等操作了。 ## 常见问题 ### No Cable found 检查设备管理器里有没有下图这两个，没有的话需要安装 Programmer 驱动。 ![converter](./../../assets/questions/converter.png) ### No gowin device found 确认自己使能了核心板。 ### 成功烧录过一次外部 Flash 后 Programmer 软件无法再烧录 注意描述是成功烧录过一次 Flash。 这种情况默认为启用了错误的引脚复用而导致下载器不能再识别到 FPGA 的 JTAG。可以短接 Flash 的 1、4 引脚，让芯片上电时不能正常读 FLASH 。 ![flash_cs](./../assets/flash_cs.png) ### 更多问题及其解决办法前往[相关问题](./../common doc/questions.html)查看"},"/hardware/zh/tang/tang-primer-20k/examples/water_led.html":{"title":"Tang Primer 20K 流水灯","content":" title: Tang Primer 20K 流水灯 keywords: Tang Primer 20K ,例程, 上手 update: date: 2022 11 25 version: v0.1 author: wonder content: 初稿 ## 说明 本例程使用 Dock 底板上 LED0、LED1、LED2、LED3、LED4、LED5 共六个 LED 灯。 依次只点亮底板上一个 LED 灯，LED 灯切换间隔为 0.5S。 在前面的 [计数器亮灯中](./led.html)，已经点亮了一个灯了。这次只是将所点亮的灯的状态 “转移” 到别的灯上，这里使用环形 [移位寄存器](https://baike.baidu.com/item/%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8%E5%AD%98%E5%82%A8%E5%99%A8/22232752) 就可以完成灯的效果转移目标。在 FPGA 上，可以使用位拼接运算符 `{` 和 `}` 来实现移位寄存器的效果。 ### 移位寄存器 移位寄存器是是一种在若干相同时间脉冲下工作的以触发器为基础的器件，数据以并行或串行的方式输入到该器件中，然后每个时间脉冲依次向左或右移动一个比特，在输出端进行输出。 对于使用移位寄存器来实现流水灯，我们需要保证最低要有一个灯亮着，这个时候我们选择环形移位寄存器。将普通移位寄存器的输出作为它自己的输入即可看作为环形移位寄存器。 在 verilog 中，使用类似于下面的代码就可以很容易的实现上面的状态值转移表： ```v reg [5:0] q; always @(posedge clk or negedge rst_n) begin if (!rst_n) begin q[5:0] < 6'b000001; // 复位 end begin q[5:0] < {q[4:0],q[5]}; //最高位作为最低位输入 // q[5:0] < {q[0],q[5:1]}; //最低位作为最高位输入 end end ``` <! 对应的真值表状态转移如下： 其中以 M[5:0] 来表示底板上的 LED0 到 LED5；clk 表示移位脉冲，每 0.5s 一次；N[5:0] 表示经移动脉冲后的 LED0到 LED5 的状态值。 rst clk M[5:0] N[5:0] 0 x 000001 xxxxxx 0 1 000001 000001 0 1 000001 xxxxxx 0 1 000001 xxxxxx 0 1 000001 xxxxxx 0 1 000001 xxxxxx 0 1 000001 xxxxxx 在 verilog 中，使用类似于下面的代码就可以很容易的实现上面的状态值转移表： ```v always @(posedge clk or negedge rst_n) begin if (!rst_n) begin M[5:0] < 6'b000001; // 复位 N[5:0] < 6'b000001; // 复位 end else begin end end ``` > ## 操作 ### 引脚复用 READY DONE SSPI ### 端口和引脚 Port Direction Location rst_n input T10 Clock input H11 led[5] output L16 led[4] output L14 led[3] output N14 led[2] output N16 led[1] output A13 led[0] output C13 ### 代码 .. tabset:: ## water_led.v Verilog文件； 定义了一个复位输入，一个时钟输入和六个输出端口。复位有效时重置输出端口的电平状态。 ```verilog module led( input rst_n, input Clock, output [5:0] led ); /**********计时部分**********/ //parameter Clock_frequency 27_000_000; // 时钟频率为27Mhz parameter count_value 13_499_999; // 计时 0.5S 所需要的计数次数 reg [23:0] count_value_reg ; // 计数器 reg count_value_flag; // IO 电平标志 always @(posedge Clock or negedge rst_n) begin if (!rst_n) begin count_value_reg < 23'b0; // 清零计数器 count_value_flag < 1'b0 ; // 清零标志位 end else if ( count_value_reg < count_value ) begin //没有计数到 0.5S count_value_reg < count_value_reg + 1'b1; // 继续计数 count_value_flag < 1'b0 ; // 不产生移位标志 end else begin //计数到 0.5S 了 count_value_reg < 23'b0; // 清零计数器，为重新计数最准备 count_value_flag < 1'b1 ; // 产生移位标志 end end /**********电平状态移位部分**********/ reg [5:0] led_reg 6'b000001; //初始化输出 IO 电平状态 always @(posedge Clock or negedge rst_n) begin if (!rst_n) begin led_reg[5:0] < 6'b000001 ; // 复位后输出 IO 电平状态 end else if ( count_value_flag ) // 电平移位标志有效 led_reg[5:0] < { led_reg[4:0],led_reg[5] } ; // IO 电平移位 else // 电平移位标志无效 led_reg[5:0] < led_reg[5:0] ; // IO 电平不变 end /**********寄存器变量与端口连接**********/ assign led[5:0] led_reg[5:0] ; endmodule ``` ## water_led.cst 物理约束文件； 将 verilog 代码里的端口绑定到 FPGA 引脚上面 ```txt IO_LOC \"led[5]\" L16; IO_PORT \"led[5]\" PULL_MODE UP DRIVE 8; IO_LOC \"led[4]\" L14; IO_PORT \"led[4]\" PULL_MODE UP DRIVE 8; IO_LOC \"led[3]\" N14; IO_PORT \"led[3]\" PULL_MODE UP DRIVE 8; IO_LOC \"led[2]\" N16; IO_PORT \"led[2]\" PULL_MODE UP DRIVE 8; IO_LOC \"led[1]\" A13; IO_PORT \"led[1]\" PULL_MODE UP DRIVE 8; IO_LOC \"led[0]\" C13; IO_PORT \"led[0]\" PULL_MODE UP DRIVE 8; IO_LOC \"Clock\" H11; IO_PORT \"Clock\" PULL_MODE UP; IO_LOC \"rst_n\" T10; IO_PORT \"rst_n\" PULL_MODE UP; ``` ## 效果 按下 S0 按键，LED0 灭，其余 LED 均亮。 松开 S0 按键，LED0 到 LED5 依次只熄灭一个，LED5 熄灭后是 LED0 熄灭，形成了闭环的效果。 <! 松开 S0 按键按下 S0 按键 <img src \"./assets/key_led_on/led_off.png\" alt \"led_off\"><img src \"./assets/key_led_on/led_on.png\" alt \"led_on\"> > ## 补充 如果将 `water_led.v` 文件里最后部分的 ```verilog assign led[5:0] led_reg[5:0] ; ``` 改成 ```verilog assign led[5:0] ~led_reg[5:0] ; ``` 那么每次只会有一个 LED 亮起来，而不是五个 LED 亮着。 <p id \"back\"> <a href \"#\" onClick \"javascript :history.back( 1);\">返回上一页(Back)</a> </p>"},"/hardware/zh/tang/tang-primer-20k/examples/key_6leds_on.html":{"title":"Tang Primer 20K Dock 按键点六个灯","content":" title: Tang Primer 20K Dock 按键点六个灯 tags: Tang Primer 20K Dock，上手 keywords: Primer, Tang, Dock， 入门，20K desc: Tang Primer 20K Dock 基础进阶 update: date: 2022 11 27 version: v0.1 author: wonder content: 初稿 前面已经完成按键亮两个灯操作了，板子上还剩下五个 LED 可自定义操作，这次可以使用位拼接运算符 `{` `}` 来一起控制六个 LED。 ## 位拼接运算符 ### 例子① 语法： `assign c[5:0] {{3{1'b1}},{3{1'b0}}};` 等效于 `assign c[5:0] 6'b111000 ;` ### 例子② 语法： ```verilog wire [2:0] a 3'b111; wire [2:0] b 3'b000; wire [5:0] c {a,b} ; ``` 等效于 `assign c[5:0] 6'b111000 ;` ## 硬件电路说明 从 [原理图](https://dl.sipeed.com/shareURL/TANG/Primer_20K/02_Schematic) 中，可以知道以下信息： ### 按键电路： 根据 DOCK 底板原理图，可以看出当板载按键按下时，对应的 FPGA 引脚会为低电平输入。 板载按键电路原理图 板载按键与 FPGA 连接引脚图 ![key_schematic](./assets/key_led_on/key_schematic.png) ![key_pin](./assets/key_led_on/key_pin.png) ### LED 电路: 根据 LED 电路，可以知道当 FPGA 引脚为低电平的时候对应连接的 LED 会亮起来。 板载自定义 LED 电路原理图 板载自定义 LED 与 FPGA 连接引脚图 ![key_schematic](./assets/key_led_on/led_schematic.png) ![key_pin](./assets/key_led_on/led_pin.png) 所以直接将按键引脚的逻辑电平输出为 LED 的引脚逻辑电平就可以点亮 LED 灯。 ## 操作 ### 引脚复用 READY DONE SSPI ### 端口和引脚 Port Direction Location key input T10 led[5] output L16 led[4] output L14 led[3] output N14 led[2] output N16 led[1] output A13 led[0] output C13 ### 代码 .. tabset:: ## key_6leds_on.v Verilog文件； 定义了一个按键输入端口，和六个输出端口。六个输出端口的 IO 电平状态由输入端口决定。 ```verilog module key_6leds_on( input key, output [5:0] led ); assign led[5:0] {{3{key}},{3{~key}}}; // led[5:0] {key,key,key,~key,~key,~key}; endmodule ``` ## key_6leds_on.cst 物理约束文件； 将 verilog 代码里的端口绑定到 FPGA 引脚上面 ```txt IO_LOC \"led[5]\" L16; IO_PORT \"led[5]\" PULL_MODE UP DRIVE 8; IO_LOC \"led[4]\" L14; IO_PORT \"led[4]\" PULL_MODE UP DRIVE 8; IO_LOC \"led[3]\" N14; IO_PORT \"led[3]\" PULL_MODE UP DRIVE 8; IO_LOC \"led[2]\" N16; IO_PORT \"led[2]\" PULL_MODE UP DRIVE 8; IO_LOC \"led[1]\" A13; IO_PORT \"led[1]\" PULL_MODE UP DRIVE 8; IO_LOC \"led[0]\" C13; IO_PORT \"led[0]\" PULL_MODE UP DRIVE 8; IO_LOC \"key\" T10; IO_PORT \"key\" PULL_MODE UP; ``` ## 效果 松开 S0 按键，LED0、LED1 和 LED2 亮，LED3、LED4 和 LED5 灭。 按下 S0 按键，LED3、LED4 和 LED5 亮，LED0、LED1 和 LED2 灭。 <! 松开 S0 按键按下 S0 按键 <img src \"./assets/key_led_on/led_off.png\" alt \"led_off\"><img src \"./assets/key_led_on/led_on.png\" alt \"led_on\"> > <p id \"back\"> <a href \"#\" onClick \"javascript :history.back( 1);\">返回上一页(Back)</a> </p>"},"/hardware/zh/tang/tang-primer-20k/examples/led.html":{"title":"Tang Primer 20K Dock 点一个灯","content":" title: Tang Primer 20K Dock 点一个灯 tags: Tang Primer 20K Dock，上手 keywords: Primer, Tang, Dock， 入门，20K desc: Tang Primer 20K Dock 简单上手 update: date: 2022 09 21 version: v0.1 author: wonder content: 初稿 date: 2022 09 29 version: v0.2 author: wonder content: 修复部分错误 对于软件开发来说，输出 `hello world` 就是入门了。对于硬件相关的开发而言，点灯就是同款入门。 ## 安装 IDE 参考 [安装IDE](https://wiki.sipeed.com/hardware/zh/tang/common doc/get_started/install the ide.html) 来完成我们需要准备的软件环境。 对于 Linux 用户的话建议使用 [openfpgaLoader](https://wiki.sipeed.com/hardware/zh/tang/common doc/get_started/flash_in_linux.html) 这软件来烧录这款设备。 ## 新建工程 文件 > 新建 > FPGA Design > Project <div> <img src \"./assets/led_assets/new_project.png\" width 58% alt \"new_project\"> <img src \"./assets/led_assets/fpga_project.png\" width 35% alt \"fpga_project\"> </div> 设置工程名称，要求只用英文的下划线命名，存放路径中不要有中文字符或者空格等。 ![project_path](./assets/led_assets/project_path.png) 然后在下面的芯片型号中选择 GW2A LV18PG256C8/I7，使用上面的筛选能够更快地选择到正确的型号。注意 Device 那一栏为 GW2A 18C ![device_choose](./assets/led_assets/device_choose.png) 然后点击确定后就可以进行最终项目预览了。确认无误后就完成工程创建了。 ## 编写代码 ### 新建文件 高云半导体 IDE 提供了三种新建文件的方法。在此我们直接使用快捷键 `Ctrl + N` 来新建文件，其他两种不在此讲述。 在弹出的窗口中选择 `Verilog File`，会 VHDL 的也可以选择下面的 `VHDL File`，这篇文章只用 Verilog 来做点灯示例。 <img src \"./assets/led_assets/new_verilog_file.png\" width 50% alt \"new_verilog_file\"> 点击 OK 之后会提示让我们输入文件名称，此处以 `led` 为文件名做示范。 <img src \"./assets/led_assets/file_name.png\" width 75% alt \"file_name\"> 到这里我们就完成文件的创建了，可以直接编写代码了。 ![created_file](./assets/led_assets/created_file.png) ### Verilog 简单说明 Verilog 是一种硬件描述语言，用来对数字电路进行抽象化描述。 Verilog 的基本设计单元是“模块”(module)。 一个模块是由两部分组成的：一部分描述接口，另一部分描述内部逻辑功能，即定义输入是如何影响输出的。 一个模块长成这样： ```v module module_name #(parameter) (port) ; function endmodule ``` 模块整体结构由 module 和 endmodule 组成，module 后面跟着的是模块的名称(module_name)，可传递变量参数(parameter)，端口及其方向的申明(port)，紧接着就是内部逻辑功能描述(function) ,最后用 endmodule 来表示这一个模块，描述完毕。 内部逻辑功能通常由 assign 和 always 块完成；其中 assign 语句描述逻辑功能，always 块常用于描述时序功能。 ### 阻塞赋值与非阻塞赋值 在时序逻辑描述中，赋值符号有 ` ` 和 `< ` 两种。注意 `< ` 在 if 判断语句中为小于或等于，不是赋值符号。 详细解释查看底部的 [阻塞赋值与非阻塞赋值区别](#阻塞赋值与非阻塞赋值区别) ### 代码思路 写代码前我们需要先想清楚代码目的：每隔 0.5S 灯闪一次。 对此所画的需求框图如下： ![block_method](./assets/led_assets/block_method.png) 然后对于 0.5S 我们需要一个计数器来计时，LED 灯闪就是 IO 翻转 ![count_block](./assets/led_assets/time_count.png) 把上面的思维框图具体到实际使用的话，就变成下面的样式了: ![clock_time_count](./assets/led_assets/clock_time_count.png) 其中 Clock 为时钟源，用来给计时器提供准确的时间。 ### 代码描述 根据上文 Verilog 简单说明和所描述的框图，可以所要编写 Verilog 模块有 Clock 和 IO电平 两个端口； ```v module led( input Clock, output IO_voltage ); endmodule ``` 对于内部的计时模块，Primer 20K 核心板上的晶振为 27MHZ，因此我们每秒钟会有 27000000 个时钟上升沿，想要 0.5S 计数的话那么只需要计数 13500000 次上升沿就好。计数是从 0 开始的，数 13500000 的话就是从 0 数到 13499999。计数完后我们需要设置一个标志位，来通知 LED 的 IO 翻转一下电平。整体计数代码如下： ```v //parameter Clock_frequency 27_000_000; // 时钟频率为27Mhz parameter count_value 13_499_999; // 计时 0.5S 所需要的计数次数 reg [23:0] count_value_reg ; // 计数器 reg count_value_flag; // IO 电平翻转标志 always @(posedge Clock) begin if ( count_value_reg < count_value ) begin //没有计数到 0.5S count_value_reg < count_value_reg + 1'b1; // 继续计数 count_value_flag < 1'b0 ; // 不产生翻转标志 end else begin //计数到 0.5S 了 count_value_reg < 23'b0; // 清零计数器，为重新计数最准备 count_value_flag < 1'b1 ; // 产生翻转标志 end end ``` 对于 LED IO 电平翻转代码如下： ```v reg IO_voltage_reg 1'b0; // 声明 IO 电平状态用于达到计时时间后的翻转，并赋予一个低电平初始态 always @(posedge Clock) begin if ( count_value_flag ) // 电平翻转标志有效 IO_voltage_reg < ~IO_voltage_reg; // IO 电平翻转 else // 电平翻转标志无效 IO_voltage_reg < IO_voltage_reg; // IO 电平不变 end ``` 将上面的代码整合后就变成了下面的内容: ```v module led( input Clock, output IO_voltage ); /**********计时部分**********/ //parameter Clock_frequency 27_000_000; // 时钟频率为27Mhz parameter count_value 13_499_999; // 计时 0.5S 所需要的计数次数 reg [23:0] count_value_reg ; // 计数器 reg count_value_flag; // IO 电平翻转标志 always @(posedge Clock) begin if ( count_value_reg < count_value ) begin //没有计数到 0.5S count_value_reg < count_value_reg + 1'b1; // 继续计数 count_value_flag < 1'b0 ; // 不产生翻转标志 end else begin //计数到 0.5S 了 count_value_reg < 23'b0; // 清零计数器，为重新计数最准备 count_value_flag < 1'b1 ; // 产生翻转标志 end end reg IO_voltage_reg 1'b0; // 声明 IO 电平状态用于达到计时时间后的翻转，并赋予一个低电平初始态 /**********电平翻转部分**********/ always @(posedge Clock) begin if ( count_value_flag ) // 电平翻转标志有效 IO_voltage_reg < ~IO_voltage_reg; // IO 电平翻转 else // 电平翻转标志无效 IO_voltage_reg < IO_voltage_reg; // IO 电平不变 end /**********补充一行代码**********/ assign IO_voltage IO_voltage_reg; endmodule ``` 上面代码最后面补充了一行代码，是因为 IO_voltage 声明在了 port 位置，默认为 wire 型，想要将它与 reg 变量 IO_voltage_reg 连接起来，需要用到 assign 语句。 ## 综合，约束，布局布线 ### 综合 代码保存后，可以双击 IDE 内部的 Process > Synthesize 来进行代码综合，将 verilog 代码内容转换为综合网表。 ![synthesize](./assets/led_assets/synthesize.png) 关于网表有兴趣的可以自己去查阅相关资料，此处不再额外说明。 ### 约束 综合完之后我们需要进行管脚约束，才能将所编写的模块端口与 FPGA 引脚相对应，并且实现模块的功能。 点击上图 Synthesize 上面的 FloorPlanner 来进行管脚约束。 ![floorplanner](./assets/led_assets/floorplanner.png) 由于是首次创建，所以会弹出下面的对话框，点击 OK 后就弹出了图形化约束交互界面。 ![create_constrain_file](./assets/led_assets/create_constrain_file.png) ![floorplanner_intreface](./assets/led_assets/floorplanner_interface.png) 关于约束的方法可以查看 [SUG935 1.3_Gowin设计物理约束用户指南.pdf](http://cdn.gowinsemi.com.cn/SUG935 1.3_Gowin%E8%AE%BE%E8%AE%A1%E7%89%A9%E7%90%86%E7%BA%A6%E6%9D%9F%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf) 此处因个人喜所以仅使用下图中 IO Constranins 方法来约束引脚： ![floor_planner_ioconstrain](./assets/led_assets/floor_planner_ioconstrain.png) 根据[核心板原理图](https://dl.sipeed.com/fileList/TANG/Primer_20K/02_Schematic/)，我们可以知道晶振所输入的引脚为 H11。 <img src \"./assets/led_assets/crystal_port.png\" alt \"crystal_port\" width 45%> 然后结合底板上的 IO 丝印，决定用底板上的 FPGA 的 L14 引脚进行点灯，对应的 LED 编号为 LED4。 ![led_port](./assets/led_assets/led_port.png) 因此对于在 FloorPlanner 交互窗口下面的 IO Constranins 中将 PORT（端口）与 Location（引脚） 分别填入下面的值： ![io_constrain_value](./assets/led_assets/io_constrain_value.png) 输入完毕后快捷键 Ctrl + S 来保存一下引脚约束，然后接可以关闭 FloorPlanner 的交互图形界面了。 接着发现在工程项目里面多出来刚刚创建的 cst 文件了，里面的内容也比较好理解。 ![cst_content](./assets/led_assets/cst_content.png) ### 布局布线 完成约束后就要开始运行布局布线了，目的是为了把综合所生成的网表与我们自己定义的约束来通过 IDE 算出最优解然后将资源合理地分配在 FPGA 芯片上。 双击下图红框处的 Place&Route 就开始运行了。 ![place_route](./assets/led_assets/place_route.png)。 紧接着没有报错，全部通过。就可以开始进行烧录了。 ## 烧录固件 Dock 板载了下载器，在 [安装IDE](https://wiki.sipeed.com/hardware/zh/tang/common doc/get_started/install the ide.html) 的时候我们已经安装了驱动。因此我们将板子与电脑连接起来就行。 ![connected](./assets/led_assets/connected.png) 对于 Programmer 软件建议使用高云官网下载到 [点我跳转](http://www.gowinsemi.com.cn/faq.aspx) ，下载下图所示的 Programmer 软件即可。 ![educational_edition_programmer](./assets/led_assets/educational_edition_programmer.png) ### 扫描设备 在使用 Dock 底板的时候不要忘记使能核心板，按下 1 号拨码开关即可。 ![Enable_core_board](./../assets/start/switch_1_on.png) 双击下图中的下载程序(Program Device) 来运行 Programmer 软件 ![open_programmer](./assets/led_assets/open_programmer.png) 然后在打开的页面中点击一下 scan_device 来扫描到我们的设备。 ![scan_device](./assets/led_assets/scan_device.png) 点击 OK 后就可以进行烧录操作了。 烧录相关的文档可以参考 [SUG502 1.3_Gowin_Programmer用户指南.pdf](http://cdn.gowinsemi.com.cn/SUG502 1.3_Gowin_Programmer%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf) ### 下载到 SRAM 一般来说这个模式是以用来快速验证所生成的固件是否满足自己目的的。 因为其烧录快的特性所以使用的较多，然是当然断电会丢失数据，所以如果想上电运行程序的话是不能选这个的。 点击 Operation 下面的功能框来打开设备设置界面，接着在 Operation 框中选择 SRAM Program 选项来设置为下载到 SRAM ，最后点击下面的那三个点点框来选择我们所生成的 .fs 下载固件。通常来说下载固件生成与工程文件目录下的 impl > pnr 目录下。 ![sram_mode](./assets/led_assets/sram_mode.png) 接着来点击红框处开始进行烧录 ![sram_download](./assets/led_assets/sram_download.png) 有问题的话可以前往 [常见问题](https://wiki.sipeed.com/hardware/zh/tang/common doc/questions.html) 自行排查。 到这里就下载完成了。 ### 下载到 Flash 上面说过下载到 SRAM 是为了快速验证，但是不能上电运行程序。 所以想要上电运行的话我们需要设置下载到 Flash。 和上面下载到 SRAM 的步骤几乎类似，先点开 Operation 下面的功能框来打开设备设置界面，接着在 Operation 框中选择 External Flash Mode 选项来设置为下载到外部 Flash ，最后点击下面的那三个点点框来选择我们所生成的 .fs 下载固件，通常来说下载固件生成与工程文件目录下的 impl > pnr 目录下。最后在下面的外部 Flash 选项中选择设备为 Generic Flash 。 ![flash_mode](./assets/led_assets/flash_mode.png) 接着来点击红框处开始进行烧录 ![flash_download](./assets/led_assets/flash_download.png) 然后我们的程序重新上电也能照样运行了。 ## 代码结果 如图所示，只有一个灯在闪。 ![led_blink](./assets/led_assets/led_blink.gif) ## 结语 到这里我们就已经完成了 FPGA 的 “Hello world” 了。以后的示例工程不会再叙述新建文件等操作了。 ## 阻塞赋值与非阻塞赋值区别 以下内容搬运自 `大猪蹄子` （有改动）： 编写一段简单的代码，对它进行简单的仿真： ```v module test( input CLK, input [3:0] A, output reg [3:0] B,C,D,E ); always@(posedge CLK) begin B < A; C < B; D A; E D; end endmodule ``` ![simulation_result](./assets/led_assets/simulation_result.png) 根据仿真结果我们可以看出阻塞和非阻塞赋值的差别。这里对比 `B` `C` `D` `E` 四种结果。`< ` 叫做非阻塞赋值，同一个 `always` 中的 `< ` 会同时执行。这就造成了绿框内的情况：`B` 直接被赋予 `A` 的值同时 `C` 被赋予 `B` 的值。由于这两步是同时进行的，就导致 `C` 被赋予的值是 `B` 的旧值，也就造成了图中所示，`C` 的数据变化时钟要慢 `B` 一个时钟周期。再说阻塞赋值 ` `，也就是说同一个 `always` 中上一个 ` ` 语句执行完才会执行下一个 ` ` 语句。在这个代码中，上一个语句 `D` 已经被赋予了 `A` 的值，才执行把 `D` 的值赋给 `E`，所以 `D` 、`E` 的值在仿真中始终保持一致。 > 不过一般来说，不建议在时序逻辑中使用阻塞赋值 ` `。 也得出了额外两个结论： 第一，输入的数据不是完全有效，以时钟边沿时刻的输入数据为准。`posedge` 就是以上升沿执行，`negedge` 就是以下降沿执行。如果数据维持的时间小于一个时钟周期，就很有可能采集不到（如红框所示）。 第二、每次触发特定时钟边沿，对应的 `always` 块就会从头到尾执行一次代码（如绿框所示），而不是从中间某处执行。 ## 常见问题 ### No Cable found 检查设备管理器里有没有下图这两个，没有的话需要安装 Programmer 驱动。 ![converter](./../../assets/questions/converter.png) 确定有 converter 设备的话在确认用的是不是所要求使用的 Programmer, 本文[这里](#烧录固件)有写过。 ### No gowin device found 确认自己使能了核心板。 ### 其他问题 前往 [Gowin 板卡常见问题查看](./../../common doc/questions.html)"},"/hardware/zh/tang/tang-primer-20k/examples/gao.html":{"title":"Tang Primer 20K Dock 点一个灯仿真","content":" title: Tang Primer 20K Dock 点一个灯仿真 tags: Tang Primer 20K Dock，上手 keywords: Primer, Tang, Dock，入门，20K, GAO desc: 使用 GAO update: date: 2022 09 22 version: v0.1 author: wonder content: 初稿 "},"/hardware/zh/tang/tang-primer-20k/examples/decode_led_on.html":{"title":"Tang Primer 20K 译码器亮灯","content":" title: Tang Primer 20K 译码器亮灯 keywords: Tang Primer 20K ,例程, 上手 update: date: 2022 09 30 version: v0.1 author: wonder content: 初稿 ## 说明 本例程使用 Dock 底板上的 S0、S1 按键，和 LED0、LED1、LED2、LED3 四个 LED 灯。 使用两个按键来控制 4 个LED灯的状态，进行的操作与对应的结果如下： <table> <tr> <th colspan \"2\" >按键</th> <th colspan \"4\">LED 状态</th> <th >真值表达式</th> </tr> <tr> <td>S0</td> <td>S1</td> <td>LED0</td> <td>LED1</td> <td>LED2</td> <td>LED3</td> <td></td> </tr> <tr> <td></td> <td></td> <td>亮</td> <td></td> <td></td> <td></td> <td>$$ LED0 S0\\cdot S1 $$</td> </tr> <tr> <td>按下</td> <td></td> <td></td> <td>亮</td> <td></td> <td></td> <td>$$ LED1 \\overline{S0}\\cdot S1 $$</td> </tr> <tr> <td></td> <td>按下</td> <td></td> <td></td> <td>亮</td> <td></td> <td>$$ LED2 S0\\cdot \\overline{S1} $$</td> </tr> <tr> <td>按下</td> <td>按下</td> <td></td> <td></td> <td></td> <td>亮</td> <td>$$ LED3 \\overline{S0}\\cdot \\overline{S1} $$</td> </tr> </table> 从前面的 [按键亮灯](./examples/key_led_on.html) 已知：当 FPGA 与 LED 所连接的引脚为低电平时，对应的 LED 灯会亮；按下按键，对应的 FPGA 引脚为低电平状态。 上面那个表格的输出是以 1 为结果，为了根据原理图来点灯，需要将上面的真值表结果取反来实现最终的效果： <table> <tr> <th colspan \"2\"> 按键 </th> <th colspan \"4\">LED 电平状态</th> <th > 真值表达式 </th> </tr> <tr> <td>S0</td> <td>S1</td> <td>LED0</td> <td>LED1</td> <td>LED2</td> <td>LED3</td> <td></td> </tr> <tr> <td></td> <td></td> <td>0</td> <td></td> <td></td> <td></td> <td>$$ LED0 \\overline{S0\\cdot S1} $$</td> <! <td> LED1 ! ( S0 & S1 ) </td> > </tr> <tr> <td>0</td> <td></td> <td></td> <td>0</td> <td></td> <td></td> <td>$$ LED1 \\overline{\\overline{S0}\\cdot S1} $$</td> <! <td> LED1 ! (!S0 & S1 ) </td> > </tr> <tr> <td></td> <td>0</td> <td></td> <td></td> <td>0</td> <td></td> <td>$$ LED2 \\overline{S0\\cdot \\overline{S1}} $$</td> <! <td> LED2 ! ( S0 & !S1) </td> > </tr> <tr> <td>0</td> <td>0</td> <td></td> <td></td> <td></td> <td>0</td> <td>$$ LED3 \\overline{\\overline{S0}\\cdot \\overline{S1}} S0 S1 $$</td> <! <td> LED3 ( S0 S1 ) </td> > </tr> </table> ## 操作 ### 引脚复用 READY DONE SSPI ### 端口和引脚 Port Direction Location key[0] input T10 key[1] input T3 led[0] output C13 led[1] output A13 led[2] output N16 led[3] output N14 ### 代码 .. tabset:: ## decode_led_on.v Verilog文件； 定义了两个按键输入端口，和四个输出端口。根据按键输入的状态，译码输出到对应的端口。 ```verilog module decode_led_on( input [1:0] key, output [3:0] led ); assign led[0] !( key[0] & key[1] ) ; assign led[1] !(!key[0] & key[1] ) ; assign led[2] !( key[0] &!key[1] ) ; assign led[3] ( key[0] key[1] ) ; endmodule ``` ## decode_led_on.cst 物理约束文件； 将 verilog 代码里的端口绑定到 FPGA 引脚上面 ```txt IO_LOC \"led[3]\" N14; IO_LOC \"led[2]\" N16; IO_LOC \"led[1]\" A13; IO_LOC \"led[0]\" C13; IO_LOC \"key[1]\" T3; IO_LOC \"key[0]\" T10; IO_PORT \"led[3]\" PULL_MODE UP DRIVE 8; IO_PORT \"led[2]\" PULL_MODE UP DRIVE 8; IO_PORT \"led[1]\" PULL_MODE UP DRIVE 8; IO_PORT \"led[0]\" PULL_MODE UP DRIVE 8; IO_PORT \"key[1]\" PULL_MODE UP; IO_PORT \"key[0]\" PULL_MODE UP; ``` ## 效果 默认只有 LED0 亮；按下 S0 按键 LED1 亮；按下 S1 按键 LED1 亮；按下 S0 和 S2 按键 LED3 亮； <table> <tr> <th colspan \"2\" >按键</th> <th colspan \"4\">LED 状态</th> </tr> <tr> <td>S0</td> <td>S1</td> <td>LED0</td> <td>LED1</td> <td>LED2</td> <td>LED3</td> </tr> <tr> <td></td> <td></td> <td>亮</td> <td></td> <td></td> <td></td> </tr> <tr> <td>按下</td> <td></td> <td></td> <td>亮</td> <td></td> <td></td> </tr> <tr> <td></td> <td>按下</td> <td></td> <td></td> <td>亮</td> <td></td> </tr> <tr> <td>按下</td> <td>按下</td> <td></td> <td></td> <td></td> <td>亮</td> </tr> </table> <p id \"back\"> <a href \"#\" onClick \"javascript :history.back( 1);\">返回上一页(Back)</a> </p>"},"/hardware/zh/tang/tang-primer-20k/examples/xor_led_on.html":{"title":"异或逻辑亮灯","content":" title: 异或逻辑亮灯 keywords: Tang Primer 20K ,例程, 上手 update: date: 2022 10 11 version: v0.1 author: wonder content: 初次编辑 ## 原理 ### 异或逻辑介绍 异或（xor）是一个数学运算符。它应用于逻辑运算。异或的数学符号为“⊕”，计算机符号为“xor”。 其运算法则为：$$C A\\oplus B (\\overline{A}\\cdot B) (A\\cdot \\overline{B}) $$ 真值表为: <table> <tr> <td>变量 A</td> <td>0</td> <td>0</td> <td>1</td> <td>1</td> </tr> <tr> <td>变量 B</td> <td>0</td> <td>1</td> <td>0</td> <td>1</td> </tr> <tr> <td>结果 B</td> <td>0</td> <td>1</td> <td>1</td> <td>0</td> </tr> </table> 在 verilog 中，可以使用 `^` 来表示异或运算，所以可以写成$$C A\\oplus B A\\wedge B $$ 同理容易算出，四个信号的异或运算结果如下： $$E A\\oplus B\\oplus C\\oplus D A\\wedge B \\wedge C\\wedge D (((A\\wedge B )\\wedge C)\\wedge D)$$ 根据两项输入的运算方式来计算四项输入运算方法，不难得出以下真值表结果： <table><tr> <td>变量 A</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>1</td> <td>1</td> <td>1</td> <td>1</td> <td>1</td> <td>1</td> <td>1</td> <td>1</td> </tr> <tr> <td>变量 B</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>1</td> <td>1</td> <td>1</td> <td>1</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>1</td> <td>1</td> <td>1</td> <td>1</td> </tr> <tr> <td>变量 C</td> <td>0</td> <td>0</td> <td>1</td> <td>1</td> <td>0</td> <td>0</td> <td>1</td> <td>1</td> <td>0</td> <td>0</td> <td>1</td> <td>1</td> <td>0</td> <td>0</td> <td>1</td> <td>1</td> </tr> <tr> <td>变量 D</td> <td>0</td> <td>1</td> <td>0</td> <td>1</td> <td>0</td> <td>1</td> <td>0</td> <td>1</td> <td>0</td> <td>1</td> <td>0</td> <td>1</td> <td>0</td> <td>1</td> <td>0</td> <td>1</td> </tr> <tr> <td>结果 E</td> <td>0</td> <td>1</td> <td>1</td> <td>0</td> <td>1</td> <td>0</td> <td>0</td> <td>1</td> <td>1</td> <td>0</td> <td>0</td> <td>1</td> <td>0</td> <td>1</td> <td>1</td> <td>0</td> </tr> </table> ### 拨码开关说明 Tang Primer 20K DOCK 底板配备有一个 5P 的拨码开关。其中一号拨码开关被设计成核心板卡使能位；剩下四个拨码开关用于用户自定义编程功能。 拨码开关原理图 拨码开关与 FPGA 连接引脚图 ![dip_switch](./assets/xor_led_on/dip_switch.png) ![dip_switch_pin](./assets/xor_led_on/dip_switch_pin.png) 从上图 [原理图](https://dl.sipeed.com/shareURL/TANG/Primer_20K/02_Schematic) 可以知道，拨码开关连通时对应 FPGA 引脚为高电平输入。 将拨码开关四个角均作输入信号，并将其异或运算，得出一位结果。最终拨码开关状态与输出信号如下表： <table><tr> <td>开关 2</td> <td> </td> <td> </td> <td> </td> <td> </td> <td> </td> <td> </td> <td> </td> <td> </td> <td>1</td> <td>1</td> <td>1</td> <td>1</td> <td>1</td> <td>1</td> <td>1</td> <td>1</td> </tr> <tr> <td>开关 3</td> <td> </td> <td> </td> <td> </td> <td> </td> <td>1</td> <td>1</td> <td>1</td> <td>1</td> <td> </td> <td> </td> <td> </td> <td> </td> <td>1</td> <td>1</td> <td>1</td> <td>1</td> </tr> <tr> <td>开关 4</td> <td> </td> <td> </td> <td>1</td> <td>1</td> <td> </td> <td> </td> <td>1</td> <td>1</td> <td> </td> <td> </td> <td>1</td> <td>1</td> <td> </td> <td> </td> <td>1</td> <td>1</td> </tr> <tr> <td>开关 5</td> <td> </td> <td>1</td> <td> </td> <td>1</td> <td> </td> <td>1</td> <td> </td> <td>1</td> <td> </td> <td>1</td> <td> </td> <td>1</td> <td> </td> <td>1</td> <td> </td> <td>1</td> </tr> <tr> <td>输出结果</td> <td><font color \"#4F84FF\">0</font></td> <td><font color \"#4F84FF\">1</font></td> <td><font color \"#4F84FF\">1</font></td> <td><font color \"#4F84FF\">0</font></td> <td><font color \"#4F84FF\">1</font></td> <td><font color \"#4F84FF\">0</font></td> <td><font color \"#4F84FF\">0</font></td> <td><font color \"#4F84FF\">1</font></td> <td><font color \"#4F84FF\">1</font></td> <td><font color \"#4F84FF\">0</font></td> <td><font color \"#4F84FF\">0</font></td> <td><font color \"#4F84FF\">1</font></td> <td><font color \"#4F84FF\">0</font></td> <td><font color \"#4F84FF\">1</font></td> <td><font color \"#4F84FF\">1</font></td> <td><font color \"#4F84FF\">0</font></td> </tr> </table> 上表中，开关那一行中的空白表示开关断开，`1` 表示开关拨下。 ### 板载 LED 说明 根据 LED 电路，可以知道当 FPGA 引脚为低电平的时候对应连接的 LED 会亮起来。 板载自定义 LED 电路原理图 板载自定义 LED 与 FPGA 连接引脚图 ![key_schematic](./assets/key_led_on/led_schematic.png) ![key_pin](./assets/key_led_on/led_pin.png) 这里选择 LED0 作为结果引脚来验证代码现象。 ## 操作 ### 引脚复用 DONE ### 端口和引脚 Port Direction Location dip_switch[2] input E9 dip_switch[3] input E8 dip_switch[4] output T4 dip_switch[5] output T5 led[0] output C13 ### 代码 .. tabset:: ## xor_led_on.v Verilog文件； 定义了 4 个拨码开关输入端口，和 1 个 LED 输出端口。根据拨码开关输入的状态，异或运算后输出到对应的端口。 ```verilog module xor_led_on( input [5:2] dip_switch, output led ); assign led dip_switch[5] ^ dip_switch[4] ^dip_switch[3] ^ dip_switch[2] ; endmodule ``` ## xor_led_on.cst 物理约束文件； 将 verilog 代码里的端口绑定到 FPGA 引脚上面 ```txt IO_LOC \"led\" C13; IO_LOC \"dip_switch[5]\" T5; IO_LOC \"dip_switch[4]\" T4; IO_LOC \"dip_switch[3]\" E8; IO_LOC \"dip_switch[2]\" E9; IO_PORT \"led\" PULL_MODE UP DRIVE 8; IO_PORT \"dip_switch[5]\" PULL_MODE DOWN; IO_PORT \"dip_switch[4]\" PULL_MODE DOWN; IO_PORT \"dip_switch[3]\" PULL_MODE DOWN; IO_PORT \"dip_switch[2]\" PULL_MODE DOWN; ``` ## 效果 四个拨码开关 2、3、4、5 位有奇数个开关拨下是；LED0 熄灭，偶数个开关拨下时，LED0 点亮。 ## 补充说明 在高云 IDE 中，我们可以看到自己代码综合后所消耗芯片资源数量以及占比。 ![used_resource](./assets/xor_led_on/used_resource.png) 从这里面可以看到这次编写的代码消耗量 1 个 LUT，5 个 IO。 对于 CLS 的解释可以查看高云半导体官方文档 [UG288](http://cdn.gowinsemi.com.cn/UG288.pdf) 中的第二章。 Tang Primer 20K 的主控芯片 [GW2A LV18PG256C8/I7](http://www.gowinsemi.com.cn/prod_view.aspx?TypeId 10&amp;FId t3:10:3&amp;Id 167#GW2A) 内部基本逻辑单元为 LUT4。LUT 即为查找表（Look Up Table），本质上就是一个 RAM。它将数据事先写入 RAM 后，每个输入信号就相当于目标内容地址，找出地址对应的内容，然后输出。LUT4 指的是 4 个输入信号的查找表。其简单解释图如下： > 这里用一个4输入与门为例 <table> <tr> <td><img src \"./assets/xor_led_on/lut_actual.jpeg\"></td> <td><img src \"./assets/xor_led_on/lut_actual.jpeg\"></td> </tr> </table> 本地代码中，我们恰好 4 个输入和 1 个输出。所以使用 1 个 lut4 就够了。 ## 相关问题 ### 烧录代码后拨动拨码开关 LED 状态没有改变 这是因为拨码开关引脚上拉了，自己将物理约束文件 (.cst) 文件里面的 `PULL_MODE UP` 改成 `PULL_MODE DOWN` <p id \"back\"> <a href \"#\" onClick \"javascript:history.back( 1);\">返回上一页(Back)</a> </p>"},"/hardware/zh/tang/tang-primer-20k/examples/key_led_on.html":{"title":"Tang Primer 20K 按键亮灯","content":" title: Tang Primer 20K 按键亮灯 keywords: Tang Primer 20K ,例程, 上手 update: date: 2022 09 29 version: v0.1 author: wonder content: 初稿 ## 原理 从 [原理图](https://dl.sipeed.com/shareURL/TANG/Primer_20K/02_Schematic) 中，可以知道以下信息： ### 按键电路： 根据 DOCK 底板原理图，可以看出当板载按键按下时，对应的 FPGA 引脚会为低电平输入。 板载按键电路原理图 板载按键与 FPGA 连接引脚图 ![key_schematic](./assets/key_led_on/key_schematic.png) ![key_pin](./assets/key_led_on/key_pin.png) ### LED 电路: 根据 LED 电路，可以知道当 FPGA 引脚为低电平的时候对应连接的 LED 会亮起来。 板载自定义 LED 电路原理图 板载自定义 LED 与 FPGA 连接引脚图 ![key_schematic](./assets/key_led_on/led_schematic.png) ![key_pin](./assets/key_led_on/led_pin.png) 所以直接将按键引脚的逻辑电平输出为 LED 的引脚裸机电平就可以点亮 LED 灯。 ## 操作 ### 引脚复用 LED5 复用了 SSPI 引脚，需要手动前往 Project >Configuration >Place&Route >Dual Purpose Pin 中，勾选 `Use SSPI as regular IO` ![dual_purpose_pin](./assets/key_led_on/dual_purpose_pin.png) **后续文章中不再重复描述步骤，仅说明复用管脚，用户自行前往设置启用管脚复用。** ### 端口和引脚 Port Direction Location key input T10 led[5] output L16 led[4] output L14 ### 代码 .. tabset:: ## key_led_on.v Verilog文件； 定义了一个按键输入端口，和两个输出端口。将输入端口的 IO 电平状态输出到两个输出端口。 此处使用了位拓展语法。可以前往 [位拼接运算](./examples/key_6leds_on.md.html) 查看相关说明，但是本篇后续的文档规范还是应当继续阅读完。 ```verilog module key_led_on( input key, output [5:4] led ); assign led[5:4] {2{key}}; endmodule ``` ## key_led_on.cst 物理约束文件； 将 verilog 代码里的端口绑定到 FPGA 引脚上面 ```txt IO_LOC \"led[5]\" L16; IO_PORT \"led[5]\" PULL_MODE UP DRIVE 8; IO_LOC \"led[4]\" L14; IO_PORT \"led[4]\" PULL_MODE UP DRIVE 8; IO_LOC \"key\" T10; IO_PORT \"key\" PULL_MODE UP; ``` #### 代码用法 **仅本次说明，后续章节除了特定内容外，不再做说明。** 根据文件里所描述的文件类型，创建对应的文件，并且把文件内容复制进去。 发现这是一个 `物理约束文件` ![物理约束文件](./assets/key_led_on/cst_file.png) 新建一个 `物理约束文件` ![file_kind](./assets/key_led_on/file_kind.png) 将文件内容内容复制进去 ![file_content](./assets/key_led_on/file_content.png) 接着保存这个文件。 将所有代码中涉及到的文件创建、复制内容且保存后，就可以进行综合、布局布线操作来生成下载固件了。 具体创建工程操作参考 [Tang Primer 20K Dock 亮一个灯](./assign_led.html) ## 效果 按下 S0 按键，LED4 和 LED5 亮。松开 S0 按键，LED4 和 LED5 灭。 松开 S0 按键按下 S0 按键 <img src \"./assets/key_led_on/led_off.png\" alt \"led_off\"><img src \"./assets/key_led_on/led_on.png\" alt \"led_on\"> <p id \"back\"> <a href \"#\" onClick \"javascript :history.back( 1);\">返回上一页(Back)</a> </p>"},"/hardware/zh/tang/tang-primer-20k/example.html":{"title":"Tang Primer 20K 例程指南","content":" title: Tang Primer 20K 例程指南 keywords: Tang Primer 20K ,例程, 上手 update: date: 2022 09 29 version: v0.1 author: wonder content: 目录确定 ## LED 篇 Dock 底板上六个 LED 可以拿来做不少新手实验 组合逻辑操作： [约束亮灯](./examples/assign_led.html)（快速熟悉 IDE，必看） [按键亮灯](./examples/key_led_on.html) (后续文档规范，必看) [异或逻辑亮灯](./examples/xor_led_on.html) [译码器亮灯](./examples/decode_led_on.html)（数电表达式实现） <! [译码器亮灯](./examples/timing_decode_led_on.html)（ verilog case 语句实现） > [位拼接运算](./examples/key_6leds_on.html) 时序逻辑操作： [计数器亮灯](./examples/led.html) [流水灯](./examples/water_led.html) 呼吸灯 ## RGB LCD 篇 ## SPI LCD 篇 ## CAM LCD 篇 ## 余下工程 HDMI USB 示例 以太网"},"/hardware/zh/tang/tang-primer-20k/start.html":{"title":"Tang Primer 20K 开箱指南","content":" title: Tang Primer 20K 开箱指南 keywords: FPGA, Primer, Tang, 20K update: date: 2022 09 16 version: v0.1 author: wonder content: 首次编辑 持续施工中 Primer 20K 底板有 Lite 和 Dock 两款，这里分开说明一下 ## Dock 开箱指南 ### 注意事项 首先列出相关注意事项，来避免因为操作不当所产生的问题却花费大量时间但又未解决。 #### 使能核心板 对于 Dock 板，使用的时候需要注意将拨码开关 1 号位开启，以此来使能核心板。 使能核心板 未使能状态 补充说明 <img src \"./assets/start/switch_1_on.png\" alt \"switch_1_on\" width 100%><img src \"./assets/start/reset_led_on.png\" alt \"reset_led_on\" width 100%> 未使能核心板的话板子上的 0、1 号 LED 会一直亮着，且核心板不会正常启动。 #### 设备不工作 默认的包装盒里已经将核心板组装在底板上面了，但是有时候因为一些必要操作需要取下核心板。 然后再次组装回去后发现设备不再工作了，这个时候我们需要确认一下核心板与底板是否连接好。 正确的连接顺序是先将核心板斜插入到底板中，倾斜角度大概如如下图左图所示。确定从上面看到斜插入的核心板与底板均匀接触，可以从金手指裸露出来的均匀程度来判断。 <img src \"./assets/start/edge_view.png\" alt \"edge_view\" width 45%> <img src \"./assets/start/top_view.png\" alt \"top_view\" width 35%> 然后轻压翘起来的那一头，可以清脆的听见核心板被底板插槽固定住的声音。 如果按压时候觉得困难的话，可以尝试将核心板两侧稍微打磨一下，来消除由于生产工艺所带来的尺寸误差。 <img src \"./assets/start/clean_core_board.png\" alt \"clean_core_board\" width 20%> 将上图红框的两处侧边稍微打磨一下，来减少配合时的困难。 #### 硬件改版说明 对于 Dock 底板，可以从如下图所指的位置来了解当前自己所使用的板子版本。 ![version](./assets/start/dock version.png) 比如上面这张图的板子的版本号为 V3708 下面是有问题的版本修正： ##### V3708 LED2 与 LED3 的丝印错误，应当为： 外设 正确引脚 错误丝印 LED2 N16 B14 LED3 N14 N16 ### 开始使用 对于 Dock 底板，默认固件可进行如下操作： 按下 S0 按键，复位 RGB 屏幕、摄像头、HDMI 信号复位，且 3、4、5 号三个 LED 会常亮。 S2 到 S5 按键及 2 号到 5 号拨码开关控制 0、1、2 三个 LED 灯的状态 将 OV5640 摄像头与 4.3寸 RGB 屏幕连接到板子上（连接时注意断开板子电源），屏幕上面会显示摄像头所捕获到的画面。如果屏幕显示有撕裂现象的话，可以按下 S0 按键来同步一下输出画面。 默认固件中，将 3、4 号两个灯设置为时钟检测信号，可以通过这两个灯的状态来鉴别设备是否工作。 ### 实战使用 [点一个灯](./examples/led.html) ### 相关问题 使用中碰到问题可以先前往 [常见问题](https://wiki.sipeed.com/hardware/zh/tang/common doc/questions.html) 来查看解决方法。 ## Lite 开箱说明 ### 硬件版本说明 对于 Lite 底板，可以从如下图所指的位置来了解当前自己所使用的板子版本。 ![lite version](./assets/start/lite version.png) 比如上面这张图的板子的版本号为 3710 下面是有问题的版本修正： #### 3710 底板 R8 与 P9 之间为 P8 引脚。参考右图左上方，已标明 <div> <img src \"./assets/lite up.png\" alt \"lite up\" width 45%> <img src \"./assets/lite back.png\" alt \"lite back\" width 45%> </div> ### 实战使用 [点一个灯](https://wiki.sipeed.com/news/others/20k_lite_start/20k_lite_start.html) ### 相关问题 使用中碰到问题可以先前往 [常见问题](https://wiki.sipeed.com/hardware/zh/tang/common doc/questions.html) 来查看解决方法。"},"/hardware/zh/tang/tang-primer-20k/primer-20k.html":{"title":"Tang Primer 20K","content":"# Tang Primer 20K ## 概述 Tang Primer 20K 是基于 [GW2A LV18PG256C8/I7](http://www.gowinsemi.com.cn/prod_view.aspx?TypeId 10&amp;FId t3:10:3&amp;Id 167#GW2A) 所设计的一款 DDR3 sodimm 封装的核心板，额外准备了两个底板，分别为 Dock 底板和 Lite 底板。 <div> <img src \"./assets/20k_front.png\" width 45%> <img src \"./assets/20k_back.png\" width 45%> </div> 购买链接：[淘宝](https://item.taobao.com/item.htm?&id 680099020807) ## 基础参数 <table> \t<thead> \t\t<tr> \t\t\t<th style \"text align:center\">项目</th> \t\t\t<th style \"text align:center\">参数</th> \t\t\t<th style \"text align:center\">补充</th> \t\t</tr> \t</thead> \t<tbody> \t\t<tr> \t\t\t<td style \"text align:left\">FPGA 芯片</td> \t\t\t<td style \"text align:left\"><a href \"http://www.gowinsemi.com.cn/prod_view.aspx?TypeId 10&amp;FId t3:10:3&amp;Id 167#GW2A\">GW2A LV18PG256C8/I7</a> \t\t\t</td> \t\t\t<td style \"text align:left\"> \t\t\t\t<table> \t\t\t\t\t<tr> \t\t\t\t\t\t<td>逻辑单元(LUT4)</td> \t\t\t\t\t\t<td>20736</td> \t\t\t\t\t</tr> \t\t\t\t\t<tr> \t\t\t\t\t\t<td>寄存器(FF)</td> \t\t\t\t\t\t<td>15552</td> \t\t\t\t\t</tr> \t\t\t\t\t<tr> \t\t\t\t\t\t<td>分布式静态随机存储器S SRAM(bits)</td> \t\t\t\t\t\t<td>41472</td> \t\t\t\t\t</tr> \t\t\t\t\t<tr> \t\t\t\t\t\t<td>块状静态随机存储器B SRAM(bits)</td> \t\t\t\t\t\t<td>828K</td> \t\t\t\t\t</tr> \t\t\t\t\t<tr> \t\t\t\t\t\t<td>块状静态随机存储器数目B SRAM(个)</td> \t\t\t\t\t\t<td>46</td> \t\t\t\t\t</tr> \t\t\t\t\t<tr> \t\t\t\t\t\t<td>乘法器(18x18 Multiplier)</td> \t\t\t\t\t\t<td>48</td> \t\t\t\t\t</tr> \t\t\t\t\t<tr> \t\t\t\t\t\t<td>锁相环(PLLs)</td> \t\t\t\t\t\t<td>4</td> \t\t\t\t\t</tr> \t\t\t\t\t<tr> \t\t\t\t\t\t<td>I/O Bank 总数</td> \t\t\t\t\t\t<td>8</td> \t\t\t\t\t</tr> \t\t\t\t</table> \t\t\t</td> \t\t</tr> \t\t<tr> \t\t\t<td style \"text align:left\">内存</td> \t\t\t<td style \"text align:left\">128M DDR3</td> \t\t\t<td style \"text align:left\"></td> \t\t</tr> \t\t<tr> \t\t\t<td style \"text align:left\">Flash</td> \t\t\t<td style \"text align:left\">32Mbits NOR Flash</td> \t\t\t<td style \"text align:left\">查看 <a href \"#burn_flash\">烧录到Flash</a></td> \t\t</tr> \t\t<tr> \t\t\t<td style \"text align:left\">调试接口</td> \t\t\t<td style \"text align:left\">Jtag + Uart</td> \t\t\t<td style \"text align:left\">JST SH1.0 8Pins 连接器</td> \t\t</tr> \t\t<tr> \t\t\t<td style \"text align:left\">SD 卡槽</td> \t\t\t<td style \"text align:left\">一个</td> \t\t\t<td style \"text align:left\">推拉式</td> \t\t</tr> \t\t<tr> \t\t\t<td style \"text align:left\">显示接口</td> \t\t\t<td style \"text align:left\">8Pins spi lcd 连接器</td> \t\t\t<td style \"text align:left\"></td> \t\t</tr> \t\t<tr> \t\t\t<td style \"text align:left\">整体封装</td> \t\t\t<td style \"text align:left\">204P DDR3 Sodimm 金手指</td> \t\t\t<td style \"text align:left\"></td> \t\t</tr> \t\t<tr> \t\t\t<td style \"text align:left\">可用 IO</td> \t\t\t<td style \"text align:left\">一共 117 个</td> \t\t\t<td style \"text align:left\"></td> \t\t</tr> \t</tbody> </table> ## 底板对比 ### Dock 底板产品图 其中 LED2 和 LED3 所对应的引脚编号为 N16 和 N14。查阅右图左方，已标明。 <div> <img src \"./assets/dock up.png\" alt \"dock up\" width 45%> <img src \"./assets/dock back.png\" alt \"dock back\" width 45%> </div> ### Lite 底板产品图 底板 R8 与 P9 之间为 P8 引脚。参考右图左上方，已标明 <div> <img src \"./assets/lite up.png\" alt \"lite up\" width 45%> <img src \"./assets/lite back.png\" alt \"lite back\" width 45%> </div> ### 外设参数对比 <table> \t<thead> \t\t<tr> \t\t\t<th rowspan \"2\" colspan \"2\">项目</th> \t\t\t<th colspan \"2\">Dock</th> \t\t\t<th colspan \"2\">Lite</th> \t\t</tr> \t\t<tr> \t\t\t<th>数量</th> \t\t\t<th>补充说明</th> \t\t\t<th>数量</th> \t\t\t<th>补充说明</th> \t\t</tr> \t</thead> \t<body> \t\t<tr> \t\t\t<td colspan \"2\">RGB 接口</td> \t\t\t<td>1</td> \t\t\t<td>RGB565 40P FPC 连接器</td> \t\t\t<td></td> \t\t\t<td></td> \t\t</tr> \t\t<tr> \t\t\t<td colspan \"2\">DVP 接口</td> \t\t\t<td>1</td> \t\t\t<td>24P FPC 连接器</td> \t\t\t<td></td> \t\t\t<td></td> \t\t</tr> \t\t<tr> \t\t\t<td colspan \"2\">麦克风阵列接口</td> \t\t\t<td>1</td> \t\t\t<td>10P FPC 连接器</td> \t\t\t<td></td> \t\t\t<td></td> \t\t</tr> \t\t<tr> \t\t\t<td colspan \"2\">触摸接口</td> \t\t\t<td>1</td> \t\t\t<td>6P FPC 连接器</td> \t\t\t<td></td> \t\t\t<td></td> \t\t</tr> \t\t<tr> \t\t\t<td colspan \"2\">PMOD 接口</td> \t\t\t<td>4</td> \t\t\t<td></td> \t\t\t<td>4</td> \t\t\t<td></td> \t\t</tr> \t\t<tr> \t\t\t<td colspan \"2\">3.5mm 耳机接口</td> \t\t\t<td>1</td> \t\t\t<td>使用 LPA4809MSF 驱动</td> \t\t\t<td></td> \t\t\t<td></td> \t\t</tr> \t\t<tr> \t\t\t<td colspan \"2\">拨码开关</td> \t\t\t<td>1</td> \t\t\t<td>5P 拨码开关</td> \t\t\t<td></td> \t\t\t<td></td> \t\t</tr> \t\t<tr> \t\t\t<td colspan \"2\">滑动开关</td> \t\t\t<td>1</td> \t\t\t<td>切换板载 USB 功能</td> \t\t\t<td>2</td> \t\t\t<td>用户自定义功能</td> \t\t</tr> \t\t<tr> \t\t\t<td style \"white space:nowrap\" rowspan \"2\">Type C 接口</td> \t\t\t<td style \"white space:nowrap\">USB JTAG&UART</td> \t\t\t<td>1</td> \t\t\t<td>板载 BL702 芯片用来<br>下载比特流并提供串口功能</td> \t\t\t<td></td> \t\t\t<td></td> \t\t</tr> \t\t<tr> \t\t\t<td>自定义 USB</td> \t\t\t<td>1</td> \t\t\t<td>USB3317 芯片与滑动开关<br>来自定义该 USB 接口功能</td> \t\t\t<td></td> \t\t\t<td></td> \t\t</tr> \t\t<tr> \t\t\t<td colspan \"2\">无线天线</td> \t\t\t<td>1</td> \t\t\t<td>使用 BL702 芯片的无线功能</td> \t\t\t<td></td> \t\t\t<td></td> \t\t</tr> \t\t<tr> \t\t\t<td colspan \"2\">按键</td> \t\t\t<td>6</td> \t\t\t<td>一个用来烧录 BL702,<br>剩下五个用户自定义功能</td> \t\t\t<td>2</td> \t\t\t<td></td> \t\t</tr> \t\t<tr> \t\t\t<td colspan \"2\">LED</td> \t\t\t<td>6</td> \t\t\t<td></td> \t\t\t<td></td> \t\t\t<td></td> \t\t</tr> \t\t<tr> \t\t\t<td colspan \"2\">HDMI 接口</td> \t\t\t<td>1</td> \t\t\t<td></td> \t\t\t<td></td> \t\t\t<td></td> \t\t</tr> \t\t<tr> \t\t\t<td colspan \"2\">以太网接口</td> \t\t\t<td>1</td> \t\t\t<td>RTL8201F 芯片实现以太网功能</td> \t\t\t<td></td> \t\t\t<td></td> \t\t</tr> \t\t<tr> \t\t\t<td colspan \"2\">RGB LED</td> \t\t\t<td>1</td> \t\t\t<td>WS2812</td> \t\t\t<td></td> \t\t\t<td></td> \t\t</tr> \t</body> </table> ## 硬件资料 规格书、原理图、尺寸图等均可在这里找到：[点击这里](https://dl.sipeed.com/shareURL/TANG/Primer_20K) [板卡规格书](https://dl.sipeed.com/shareURL/TANG/Primer_20K/01_Specification) [板卡原理图](https://dl.sipeed.com/shareURL/TANG/Primer_20K/02_Schematic) [板卡点位图](https://dl.sipeed.com/shareURL/TANG/Primer_20K/03_Bit_number_map) [布线长度表](https://dl.sipeed.com/shareURL/TANG/Primer_20K/04_Net_Length) [板卡尺寸图](https://dl.sipeed.com/shareURL/TANG/Primer_20K/05_Dimensional_drawing) [核心板封装](https://dl.sipeed.com/shareURL/TANG/Primer_20K/06_Footprint) (KICAD) [芯片部分资料](https://dl.sipeed.com/shareURL/TANG/Primer_20K/07_Chip_manual) [3D 模型文件](https://dl.sipeed.com/shareURL/TANG/Primer_20K/08_Dimensions) ## 上手简明 `准备开发环境` > `学习相关语法` > `查看开箱指南` > `基础代码编写` > `查看官方文档` 1. 安装 IDE ：[点击这里](./../common doc/get_started/install the ide.html) 2. 查看 [上手指南](https://wiki.sipeed.com/hardware/zh/tang/tang primer 20k/start.html) 来避免一些问题，并且从那里面可以开始进行代码实战。 3. 如果进行完上面的点灯操作后后感觉有压力，可以自己查漏补缺： 可以在下面的这些网站学习 Verilog: \t+ 在线免费教程：[Verilog 教程](https://www.runoob.com/w3cnote/verilog tutorial.html)（学习Verilog） \t+ 在线免费 FPGA 教程：[Verilog](https://www.asic world.com/verilog/index.html) （英文网站） \t+ Verilog 刷题网站：[HDLBits](https://hdlbits.01xz.net/wiki/Main_Page)（英文网站） \t+ 在线高云半导体可参考视频教程：[点击这里](http://www.gowinsemi.com.cn/video_complex.aspx?FId n15:15:26) 对 IDE 使用有疑问的话，可以查看官方的一些文档来熟悉相关内容 [SUG100 2.6_Gowin云源软件用户指南.pdf](http://cdn.gowinsemi.com.cn/SUG100 2.6_Gowin%E4%BA%91%E6%BA%90%E8%BD%AF%E4%BB%B6%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf) [SUG949 1.1_Gowin_HDL编码风格用户指南.pdf](http://cdn.gowinsemi.com.cn/SUG949 1.1_Gowin_HDL%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf) <a href \"http://cdn.gowinsemi.com.cn/UG286 1.9.1_Gowin%E6%97%B6%E9%92%9F%E8%B5%84%E6%BA%90(Clock)%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf\">UG286 1.9.1_Gowin时钟资源(Clock)用户指南.pdf</a> [SUG940 1.3_Gowin设计时序约束用户指南.pdf](http://cdn.gowinsemi.com.cn/SUG940 1.3_Gowin%E8%AE%BE%E8%AE%A1%E6%97%B6%E5%BA%8F%E7%BA%A6%E6%9D%9F%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf) [SUG502 1.3_Gowin_Programmer用户指南.pdf](http://cdn.gowinsemi.com.cn/SUG502 1.3_Gowin_Programmer%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf) [SUG114 2.5_Gowin在线逻辑分析仪用户指南.pdf](http://cdn.gowinsemi.com.cn/SUG114 2.5_Gowin%E5%9C%A8%E7%BA%BF%E9%80%BB%E8%BE%91%E5%88%86%E6%9E%90%E4%BB%AA%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf) 上面的所有文档都已经打包进了下载站[点我跳转](https://dl.sipeed.com/shareURL/TANG/Primer_20K/07_Chip_manual/CN/%E9%80%9A%E7%94%A8%E6%8C%87%E5%BC%95)，需要的话可以点击压缩包全都下载下来。 ## 例程汇总 ### 公开例程 github 链接： https://github.com/sipeed/TangPrimer 20K example ### 部分教程 Lite 底板点灯 ：<a href \"https://wiki.sipeed.com/news/others/20k_lite_start/20k_lite_start.html\" target \"blank\">点我跳转</a> Dock 底板例程指南: [点我跳转](https://wiki.sipeed.com/hardware/zh/tang/common doc/questions.html) ## 交流方式 **交流论坛: [bbs.sipeed.com](https://bbs.sipeed.com)** **QQ 交流群：[834585530](https://jq.qq.com/?_wv 1027&k wBb8XUan)** 直接本页下方留言 商业邮箱 : [support@sipeed.com](support@sipeed.com) ## 补充说明 对于板子上的 bank 0、bank 1、bank 7 这 3 个 bank 电压，默认所接的是 3.3V，对应的 bank IO 会对外输出 3.3V 电压。如果需要输入自定义的 IO bank 电压，请拆除 R5 和 R9，请参考对应 Assembly [点我跳转](https://api.dl.sipeed.com/shareURL/TANG/Primer_20K/03_Bit_number_map/CoreModule) 图来确定 R5 和 R9 的位置。 ![io_vltage](./assets/io_vltage.png) 对应核心板原理图上在金手指处的说明如下 ![sodimm_voltage](./assets/sodimm_voltage.png) ## 相关问题 ### Dock 底板不工作 拨下 1 号拨码开关以使能核心板，不然底板会不工作且 LED0 和 LED1 常亮。 使能核心板 未使能核心板 ![switch_1_on](./assets/start/switch_1_on.png) ![reset_led_on](./assets/start/reset_led_on.png) <! <img src \"./assets/start/switch_1_on.png\" alt \"switch_1_on\" width 20%> > ### 如何下载到外部 FLASH {#burn_flash} 进行如下选项设置： <img src \"./assets/flash_mode.png\" alt \"flash_mode\" width 75%> ### 烧录后没反应或者引脚现象不对 首先确定选择了正确的型号，下图中的每一个参数都要求一致 <img src \"./assets/device_choose.png\" alt \"device_choose\" width 75%> 然后检查自己的代码和对应的仿真波形是否满足要求 ### 成功烧录过一次外部 Flash 后 Programmer 软件无法再烧录 注意描述是成功烧录过一次 Flash。 这种情况默认为启用了错误的引脚复用而导致下载器不能再识别到 FPGA 的 JTAG。可以短接 Flash 的 1、4 引脚，让芯片上电时不能正常读 FLASH 。 ![flash_cs](./assets/flash_cs.png) 如果有 dock 底板的话，可以直接操作一号拨码开关重新救活核心板，具体操作如下： 首先正常使能核心板，将拨码开关一号位拨下。然后在 Programmer 软件中，选择一个操作（烧写、擦除都可以），当 Programmer 软件中进度条出现的时候，快速将一号拨码开关拉高，然后再拉低重新使能核心板，这样就会发现 Programmer 可以正常烧录 FPGA 板卡了。 <table> \t<tr> \t\t<td><img src \"./assets/start/switch_1_on.png\" alt \"switch_1_on\"></td> \t\t<td> 首先使能核心板。</td> \t</tr> \t<tr> \t\t<td><img src \"./assets/start/progress_bar.jpg\" alt \"progress_bar\"></td> \t\t<td> 对板卡进行操作，出现进度条的时候快速拨动使能引脚。 </td> \t</tr> \t<tr> \t\t<td> \t\t<img src \"./assets/start/switch_1_off.jpg\" alt \"switch_1_off\" witdh \"25%\"> \t\t<img src \"./assets/start/switch_1_on.png\" alt \"switch_1_on\" witdh \"25%\"> \t\t</td> \t\t<td> 先向上拨动1号拨码开关，再向下拨动 </td> \t</tr> \t<tr> \t\t<td><img src \"./assets/start/progress_bar_running.jpg\" alt \"progress_bar_running\"><img src \"./assets/start/progress_bar_finishing.jpg\" alt \"progress_bar_finishing\"></td> \t\t<td> 然后就看到进度条正常，操作顺利 </td> \t</tr> </table> ### 更多问题及其解决办法前往[相关问题](./../common doc/questions.html)查看"},"/hardware/zh/tang/Tang-Nano-4K/examples/HDMI.html":{"title":"","content":""},"/hardware/zh/tang/Tang-Nano-4K/examples/LED.html":{"title":"Nano 4K 点灯","content":" title: Nano 4K 点灯 > 编辑于2022年3月31日 点灯简单示例 ## 新建项目 新建工程：File >NEW >FPGA Design Project >OK ![](./../../Tang Nano/assets/LED 1.png) 弹出的选项框选择存储路径和工程名称（路径和文件名称要求是英文路径） ![](./../../Tang Nano/assets/LED 2.png) 选择对应的型号： ![Tang_nano_4k_device_choose](./../assets/Nano_4K_device_choose.png) 可能有部分板子主控芯片型号为 C7/I6 ，用户自行选择一下即可 ## 编写代码 新建工程之后接下来进行代码编辑，在Design工作栏内新建“Verilog File”,如下图所示： ![](./../../Tang Nano/assets/LED 5.png) 为文件命名（要求写英文名，不然后续综合很容易报错）； 一般来说文件名称应该和文件内容模块名称相同 ![](./../../Tang Nano/assets/LED 6.png) 双击文件，可以在右侧的编辑框中进行代码的编写。 ![](./../../Tang Nano/assets/LED 7.png) 以点灯为例，将下方的 示例代码 粘贴到自己的文件中，也可以自己编写自己的代码。 ```verilog module led ( input sys_clk, input sys_rst_n, // reset input output reg led // LED ); reg [23:0] counter; //定义一个变量来计数 always @(posedge sys_clk or negedge sys_rst_n) begin // Counter block if (!sys_rst_n) counter < 24'd0; else if (counter < 24'd1349_9999) // 0.5s delay counter < counter + 1'b1; else counter < 24'd0; end always @(posedge sys_clk or negedge sys_rst_n) begin // Toggle LED if (!sys_rst_n) led < 1'b1; else if (counter 24'd1349_9999) // 0.5s delay led < ~led; // ToggleLED end endmodule ``` ## 综合、约束、布局布线 ### 综合 保存编辑的代码后转到“Process”界面下，对编辑好的代码进行综合，即双击“Synthesize” ![](./../../Tang Nano 9K/nano_9k/nano_9k_synthsize.png) 运行之后如没有报错而且 Synthesize 变成下图里的图标 ![](./../../Tang Nano/assets/LED.png) 说明前面编辑的代码无误；如果有错，根据错误提示进行改正即可。 ### 约束 此处未涉及时钟约束 想让 Fpga 实现代码的功能，必须将代码中涉及的 端口 绑定到 Fpga 实际的引脚上。 如下图，在左边的工作区点击 process，然后双击 FloorPlanner ![](./../../assets/examples/led_pjt_2.png) 在工程中第一次点击，可能会提示说创建文件，点击确定即可 ![](./../../Tang Nano/assets/LED 9.png) nano 4k的rgb led电路图如下所示 ![](./../assets/LED_Pin.png \"nano 4k rgb pins\") port I/O pin desc sys_clk input 45 时钟输入脚 sys_rst_n input 15 系统复位脚 led output 10 红灯 对于交互式管脚约束有下图中的两种方法 将对应的端口拖拽到芯片引脚上 在IO约束中输入端口对应的引脚编号 因此对应在管脚约束里的内容应该如下图 ![Led floorplanner](./../assets/LED_FloorPlanner.png) 关于 FloorPlanner 更多的相关说明，可以参考 [SUG935 1.3_Gowin设计物理约束用户指南.pdf](http://cdn.gowinsemi.com.cn/SUG935 1.3_Gowin%E8%AE%BE%E8%AE%A1%E7%89%A9%E7%90%86%E7%BA%A6%E6%9D%9F%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf)。里面的内容都很有用 完成之后记得保存一下 LED对应的IO10默认是mode Pin，无法直接约束，需要在顶部菜单栏 Project > Configuration >Palse&Route > Dual Purpose Pin, 勾选 Use MODE as regular IO,如下图 <img src \"./../tang/assets/../../../assets/Nano 4K/4K led 2.png\" alt \"image 20210810161934170\" style \"zoom:50%;\" /> ### 布局布线 完成脚约束后，接下来进行布局布线操作。 ![Place&&Route](./../assets/Place&Route.png) > 失败的话请从头再来一遍 ## 烧录到开发板 成功完成上面步骤后就已经生成高云半导体的比特流文件了，可以进行下面的步骤来将文件烧录到板子了。 接下来是连接板子，烧录固件，可参照下图选择版型： ![](./../assets/nano_4k_device_scan.png) 在Process界面双击`Program Device` 后打开烧录工具 ![](./../assets/Open_Programmer.png) 接下来选择 SRAM下载 即可验证程序。有固化需求的自行选择烧录到flash ![](./../assets/Programmer_device.png) <p id \"back\"> <a href \"#\" onClick \"javascript :history.back( 1);\">返回上一页(Back)</a> </p>"},"/hardware/zh/tang/Tang-Nano-4K/Tang-nano-4k.html":{"title":"Tang nano 4k 一些例程","content":" title: Tang nano 4k 一些例程 对于Programmer(下载程序)建议使用 https://dl.sipeed.com/shareURL/TANG/programmer 里面的文件。 下载后解压替换掉Gowin对应安装目录的Programmer文件夹即可。 不会替换的话可以在下载解压后的Programmer程序中手动添加对应下载文件来进行烧录。 参考工程[git仓库](https://github.com/sipeed/TangNano 4K example) 接好摄像头和HDMI显示器之后，将这个工程烧录到开发板上可以看到相应的现象。 [点灯例程](./examples/LED.html) HDMI显示工程：https://github.com/sipeed/TangNano 4K example/tree/main/camera_hdmi/project 摄像头内容显示在HDMI工程：https://github.com/sipeed/TangNano 4K example/tree/main/camera_hdmi/project Cortex m3点灯：待更新 Cortex m3串口通信：待更新 其他（有什么想法可以提出来，合适的话会被采纳）"},"/hardware/zh/tang/Tang-Nano-4K/Nano-4K.html":{"title":"Tang Nano 4K ","content":"# Tang Nano 4K ## Tang Nano 4K 开发板 Tang Nano 4K是基于[高云半导体](http://www.gowinsemi.com.cn/)的小蜜蜂系列 GW1NSR LV4C 设计的简约型开发板。开发板设计小巧精致，将芯片的所有资源都引出，板载Type C、USB JTAG、DVP、HDMI座子及其电路等，并把所有IO资源引出，方便开发者拓展使用，非常适用于小型数字逻辑的设计和实验。 ![Tang Nano 4K](./../Tang Nano/assets/4k 1.jpg) ![Tang Nano 4K](./../Tang Nano/assets/4k 2.jpg) ## 产品参数 Tang Nano 4K开发板板载的GW1NSR LV4C，是一款系统级封装芯片，内部集成了GW1NS系列可编辑逻辑器件产品和PSRAM存储芯片。 下表为与前代同系列产品对比图 型号 Tang Nano Tang Nano 4K FPGA芯片 GW1N 1 LV GW1NSR LV4C 逻辑单元 1152 4608 寄存器 864 3456 硬核处理器 无 Cortex M3 Block SRAM(bits) 72K 180K 用户闪存(bits) 96K 256K 锁相环PLL 1 2 I/O Bank 总数 4 4 最多用户I/O数 41 44 显示屏接口 标准40P RGB LCD接口 HDMI接口 摄像头接口 None 常见的DVP顺序接口 尺寸 58.4mm\\*21.3mm 60mm\\*22.86mm 下载接口 USB Type C接口 USB Type C接口 ### 引脚图 ![Pinmap](./../Tang Nano/assets/Tang_nano_4K_0813.png) ## 开发环境 安装 IDE [点我](https://wiki.sipeed.com/hardware/zh/tang/common doc/get_started/install the ide.html) ## 下载方式 Tang Nano 4K 开发板板载 BL702 芯片，为 GW1NSR 4C 提供 JTAG 调试功能，可以直接使用 IDE 里面的 Programmer 软件来下载固件到 FPGA。 ## 资料 [规格书](https://dl.sipeed.com/shareURL/TANG/Nano%204K/HDK/01_Specification) [原理图](https://dl.sipeed.com/shareURL/TANG/Nano%204K/HDK/02_Schematic) [点位图](https://dl.sipeed.com/shareURL/TANG/Nano%204K/HDK/03_Bit%20number%20map) [尺寸图](https://dl.sipeed.com/shareURL/TANG/Nano%204K/HDK/04_Dimensional%20drawing) [3D 文件](https://dl.sipeed.com/shareURL/TANG/Nano%204K/HDK/05_3D%20file) [芯片手册](https://dl.sipeed.com/shareURL/TANG/Nano%204K/HDK/06_Chip%20Manual) [相关例程](https://wiki.sipeed.com/hardware/zh/tang/common doc/examples.html) ## 补充 1. 如果有什么疑问，欢迎加群 `834585530`, 或者直接在本页下方留言讨论。 2. 有问题的话先去 [常见问题](https://wiki.sipeed.com/hardware/zh/tang/common doc/questions.html) 自查。 3. 对于 Cortex M3 硬核建议使用串口来打印调试信息来纠错，或者有能力的可以选择其他方式。 4. 对于板子上面的 IO 引脚使用，需要注意与 HDMI 引脚复用的 IO，可能因为外部上拉而导致排针上与 HDMI 复用的 IO 所表现的实际结果与自己想要的不符合。 ![nano_4k_hdmi_io](./assets/nano_4k_hdmi_io.png)"},"/hardware/zh/tang/tang-mega-138k/mega-138k.html":{"title":"Tang Mega 138K Dock","content":" title: Tang Mega 138K Dock keywords: FPGA, Tang, Mega, 138K update: date: 2024 06 25 version: v0.1 author: Serika content: 新建文档 date: 2024 09 25 version: v0.2 author: Serika content: 修正PCIe部分总线宽度的描述 更新GT收发器的最大速率为8.0Gbps ## 产品概述 **Tang Mega 138K** 使用 22nm 制程 **GW5AST LV138P484A** FPGA 芯片，具有 138240 个查找表单元和近 300 个 DSP 单元。含有四个速度范围在 270Mbps ~ 8.0Gbps 高速收发器，适合用于 PCIe 等高速口传递数据。此外，芯片含有硬核 PCIe，在使用 PCIe 的时候消耗更好的资源，并且得到更佳的性能。适用于高速通信、协议转换、高性能计算等场合。 相比138K Pro Dock，138K Dock具有更小的体积和更低的价格，并用USB3.0代替了SFP收发器。这不仅有效的降低了高速通讯的成本，还带来了更好的通用性。 淘宝购买链接：[点我](https://item.taobao.com/item.htm?id 740536508140) ## 板卡特点 大容量 LUT4 大容量 内存 PCIe3.0 x 4 USB3.0 x 1（5Gbps） RISC V 硬核（AE350 @800MHz） HDMI TX/RX x 1 千兆以太网 x 1 板载3.7V锂离子电池（1S）充放电管理电路 ## 产品外观 <img src \"./assets/mega_138k_top.png\" width \"45%\"> ## 硬件参数 ### 核心板参数 <table> \t<thead> \t\t<tr> \t\t\t<th style \"text align:center\">项目</th> \t\t\t<th style \"text align:center\">参数</th> \t\t\t<th style \"text align:center\">补充</th> \t\t</tr> \t</thead> \t<tbody> \t\t<tr> \t\t\t<td style \"text align:left\">FPGA 芯片</td> \t\t\t<td style \"text align:left\"><a href \"https://www.gowinsemi.com.cn/prod_view.aspx?TypeId 74&FId t3:10:3&Id 188#GW5AST\">GW5AST LV138PG484A</a> \t\t\t</td> \t\t\t<td style \"text align:left\"> \t\t\t\t<table> \t\t\t\t\t<tr> \t\t\t\t\t\t<td>逻辑单元(LUT4)</td> \t\t\t\t\t\t<td>138240</td> \t\t\t\t\t</tr> \t\t\t\t\t<tr> \t\t\t\t\t\t<td>寄存器(FF)</td> \t\t\t\t\t\t<td>138240</td> \t\t\t\t\t</tr> \t\t\t\t\t<tr> \t\t\t\t\t\t<td>分布式静态随机存储器S SRAM(Kbits)</td> \t\t\t\t\t\t<td>1080</td> \t\t\t\t\t</tr> \t\t\t\t\t<tr> \t\t\t\t\t\t<td>块状静态随机存储器B SRAM(Kbits)</td> \t\t\t\t\t\t<td>6120</td> \t\t\t\t\t</tr> \t\t\t\t\t<tr> \t\t\t\t\t\t<td>块状静态随机存储器数目B SRAM(个)</td> \t\t\t\t\t\t<td>340</td> \t\t\t\t\t</tr> \t\t\t\t\t<tr> \t\t\t\t\t\t<td>乘法器(18x18 Multiplier)</td> \t\t\t\t\t\t<td>298</td> \t\t\t\t\t</tr> \t\t\t\t\t<tr> \t\t\t\t\t\t<td>锁相环(PLLs)</td> \t\t\t\t\t\t<td>12</td> \t\t\t\t\t</tr> <tr> <td>全局时钟</td> <td>16</td> </tr> <tr> <td>高速时钟</td> <td>24</td> </tr> <tr> <td>Transceivers</td> <td>4</td> </tr> <tr> <td>Transceivers 速率</td> <td>270Mbps 8.0Gbps</td> </tr> <tr> <td>PCIE 硬核</td> <td>1个<br>速度可选 x1, x2, x4 PCIe 3.0</td> </tr> <tr> <td>LVDS (Gbps)</td> <td>1.25</td> </tr> <tr> <td>DDR3 (Mbps)</td> <td>800</td> </tr> <td>硬核处理器</td> <td>RiscV AE350_SOC</td> </tr> <tr> <td>ADC</td> <td>2</td> </tr> \t\t\t\t\t<tr> \t\t\t\t\t\t<td>IO Bank 总数</td> \t\t\t\t\t\t<td>10</td> \t\t\t\t\t</tr> \t\t\t\t</table> \t\t\t</td> \t\t</tr> \t\t<tr> \t\t\t<td style \"text align:left\">内存</td> \t\t\t<td style \"text align:left\">1GiB DDR3</td> \t\t\t<td style \"text align:left\">512MiB x 2</td> \t\t</tr> \t\t<tr> \t\t\t<td style \"text align:left\">Flash</td> \t\t\t<td style \"text align:left\">128/64Mbits Flash x 1</td> \t\t\t<td style \"text align:left\">查看 <a href \"#burn_flash\">烧录到Flash</a></td> \t\t</tr> \t\t<tr> \t\t\t<td style \"text align:left\">调试接口</td> \t\t\t<td style \"text align:left\">JTAG + UART</td> \t\t\t<td style \"text align:left\">JST SH1.0 8Pins 连接器</td> \t\t</tr> \t\t<tr> \t\t\t<td style \"text align:left\">整体封装</td> \t\t\t<td style \"text align:left\">35mm x 45mm 大小</td> \t\t\t<td style \"text align:left\">BTB连接器连接核心板和底板</td> \t\t</tr> \t</tbody> </table> > *注意：**128Mbits** Flash 版本将于周年更新（2025 年 10 月）及所有后续版本中提供。* ### 底板参数 项目 数量 备注 : LED 4+8 4个电量指示灯+8个PMOD外接 WS2812 1 与 aRGB 灯带连接器同数据引脚 Buttons 3+1 3个用户按键+1个reconfig按键 PCIe 1 4 lane @ 5Gbps，CH569 16bit HSPI USB3 2 SuperSpeed @ 5Gbps GbE 1 千兆以太网 DVI RX 1 与 DVI TX 互相占用 DVI TX 1 与 DVI RX 互相占用 PMOD 2 与上边的40P排针和DVP复用 ADC 2 2个差分输入通道 aRGB CONN. 1 与 WS2812 同数据引脚 DVP Interface 1 与上侧的40P排针和PMOD复用 RGB Interface 1 支持 RGB888 屏幕 MIC ARRAY Interface 1 支持连接 Sipeed 6+1 麦克风阵列 SD Slot 1 1 bit SDIO/MMC 或SPI模式 BATT CONN. 1 支持3.7V锂电池，自带充放电管理 PWM FAN CONN. 1 支持5V PWM风扇，支持测速 Speaker CONN. 2 支持两个3W扬声器 3.5mm Headphone CONN. 1 立体声输出，无Mic MS5351 1 为 Serdes 提供 RefClk；通过底板上的串口来控制输出 USB JTAG & UART 1 支持烧录 FPGA，并且提供串口功能 40P 排针 2 上侧的40P排针与PMOD和DVP复用 电源开关 1 长按2s切换开关机状态 12V DC 1 规格DC5521 ## 硬件资料 ~~[板卡规格书](https://dl.sipeed.com/shareURL/TANG/Mega_138K_60K/01_Specification)~~ [板卡原理图](https://dl.sipeed.com/shareURL/TANG/Mega_138K_60K/02_Schematic) [PCB BOM](https://dl.sipeed.com/shareURL/TANG/Mega_138K_60K/03_Designator_drawing) [板卡尺寸图](https://dl.sipeed.com/shareURL/TANG/Mega_138K_60K/04_Mechanical_drawing) [板卡 3D 模型](https://dl.sipeed.com/shareURL/TANG/Mega_138K_60K/05_3D_file) [部分芯片手册](https://dl.sipeed.com/shareURL/TANG/Mega_138K_60K/07_Datasheet) [全引脚约束](https://dl.sipeed.com/shareURL/TANG/Mega_138K_60K/08_Misc) ## 上手使用 注意138K目前**已经**被教育版支持，需要下载 V1.9.11.03 或更新版本的教育版IDE使用。 商业版IDE需要 ≥V1.9.9。 如需将码流下载到flash中固化，推荐使用 **exFlash Erase,Program thru GAO Bridge 5A** 模式（需要≥V1.9.11.03）， 或者 **exFlash Erase,Program thru GAO Bridge Arora V** （需要≥V1.9.12）。 推荐使用单独的 **1.9.12 SP1** Programmer（aka. 云源编程器），在 **云源软件商业版** 的页面可以找到。这个单独的 Programmer兼容性更好。 如果需要使用商用版IDE，Lic 可以在高云官网申请，或者使用Sipeed提供的在线Lic服务，在IDE中选择Float Lic，填写以下信 息即可： ~~~ Server 01 ip: 106.55.34.119 port: 10559 ~~~ 如果上面的IP不能工作, 尝试使用 \"gowinlic.sipeed.com\" 域名对应的IP。 ### 其他教程 安装 IDE [点我](https://wiki.sipeed.com/hardware/zh/tang/common doc/get_started/install the ide.html) 例程代码 [github](https://github.com/sipeed/TangMega 138K example) ### 其他学习资源 在线免费教程：[Verilog 教程](https://www.runoob.com/w3cnote/verilog tutorial.html)（学习Verilog） 在线免费 FPGA 教程：[Verilog](https://www.asic world.com/verilog/index.html) （英文网站） Verilog 刷题网站：[HDLBits](https://hdlbits.01xz.net/wiki/Main_Page)（英文网站） 在线高云半导体可参考视频教程：[点击这里](http://www.gowinsemi.com.cn/video_complex.aspx?FId n15:15:26) ## 交流方式 **交流论坛: [maixhub.com/discussion](https://maixhub.com/discussion)** **QQ 交流群：[834585530](https://jq.qq.com/?_wv 1027&k wBb8XUan)** 直接本页下方留言 前往**[Github项目主页](https://github.com/sipeed/TangMega 138K example)**提交issue 商业邮箱 : [support@sipeed.com](support@sipeed.com) ## 注意事项 <table> <tr> <th>事项</th> <th>注意事项</th> </tr> <tr> <td>芯片型号</td> <td>Tang Mega 138K 使用的 FPGA 芯片具体型号是 <b>GW5AST LV138PG484A</b> <br>在 IDE 中选择封装型号 <span><b>PBG484A</b></span> & <span><b>Device Version: B/C</b></span> <a href \"../common doc/questions#如何分辨器件辨版本\">点我查看如何分辨器件版本</a></br></td> > </tr> <tr> <td>静电</td> <td>请避免静电打到 PCBA 上；接触 PCBA 之前请把手的静电释放掉</td> </tr> <tr> <td>容忍电压</td> <td> 使用 GPIO 排针引脚进行外部通信时，要确保 IO 电压是 <b>3.3V</b>，过高的电压会永久损坏 PCBA </td> </tr> <tr> <td>FPC 座子</td> <td>在连接 FPC 软排线的时候，请确保排线无偏侈地完整地插入到排线中 <br>在通电之前请仔细核对两端FPC 连接器的1号PIN的方向是否正确</td> </tr> <tr> <td>PCIe 金手指</td> <td>在测试 PCIe 金手指时候，确保是主机端与板卡都处于关机或者未通电的状态，否则可能会因为插入过程中的易位导致金手指短路。</td> </tr> <tr> <td>插拔</td> <td>请完全断电后才进行插拔操作</td> </tr> <tr> <td>避免短路</td> <td>请在上电过程中，避免任何液体和金属触碰到 PCBA 上的元件的焊盘，否则会导致路，烧毁 PCBA</td> </tr> </table> ## 联系 Tang Mega 138K 可以在多种场景实现客户不同方面的需要，技术支持和商业合作请联系邮箱 [support@sipeed.com](support@sipeed.com) ## 常见问题 ### 板子通电后底板只亮了四个指示灯，SOM的指示灯没亮 1. 请检查是否开启了板子的电源，**PWR按键**（HDMI接口旁边）长按2S开启电源； ### 板子通电后，底板Battery Indicator指示灯在闪烁 1. 正常现象，通常是最后一颗LED（靠近12V DC连接器）在闪烁； 2. 当板子连接3.7V锂电池时，这些LED将作为电池电量指示灯。 ### 长按PWR按钮 2s 后，底板指示灯全部熄灭又依次亮起 1. 检查自己的供电方式，出现这种情况意味着供电能力不足； 2. 解决方案（任选一种）： a. 同时连接板子的**USB 3.0**和**USB DEBUG**进行供电，即双5V USB电源供电； b. 连接12V DC电源对板子进行供电，如使用配件中的USB C转12V DC连接器，则需要连接有12V输出能力的PD电源； c. 连接3.7V锂电池对板子进行供电，注意电池电压必须≥3.6V且连续放电能力≥600mA。 ### 板子电源指示灯亮了，Programmer提示No USB Cable Connection 1. 请检查USB线是否正确接入标记为 **DEBUG USB2** 的USB C连接器 2. 尽量避免使用机箱前面板的USB连接器和没有独立供电的USB HUB 3. 检查自己是否正确安装FT2232的驱动：出现USB Serial Converter A/B <img src \"./../assets/FTDI_DEVICE.jpg\" alt \"flash_mode\" width 35%> 4. 通常情况下Windows会在联网后自动安装相应驱动。如果想要手动处理，请前往[相关问题](./../common doc/questions)查看相关内容 5. 尝试更新板载下载器的固件，请参考这里 **[【点我跳转】](./../common doc/update_debugger)** <img src \"./../assets/FTDI_DEVICE.jpg\" alt \"flash_mode\" width 35%> 4. 通常情况下Windows会在联网后自动安装相应驱动。如果想要手动处理，请前往[相关问题](./../common doc/questions)查看相关内容。 ### IDE找不到型号GW5AT LV60PG484A 1. IDE版本过老，必须更新商业版IDE ≥ 1.9.9，或教育版IDE ≥ 1.9.11.03。 ### 如何下载到外部 FLASH（固化） {#burn_flash} 1. 进行如下选项设置： <img src \"./../assets/flash_mode_GAO.png\" alt \"flash_mode\" width 35%> 2. 检查拨码开关的位置，正确的位置如下图所示： <img src \"./assets/dip key_defualt.png\" alt \"dip key_defualt\" width 35%> ### 烧录后没反应或者引脚现象不对 1. 首先确定IDE选择了正确的型号 **GW5AST LV138PG484AC1/10**，下图中的每一个参数都要求一致（[器件版本](../common doc/questions#如何分辨器件辨版本)请按照实际选择）； <img src \"./assets/partno_138K.png\" alt \"device_choose\" width 35%> 2. 然后检查自己的代码和对应的仿真波形是否满足要求，使用云源软件（GOWIN IDE）的GAO工具可以进行片上仿真。更多详情请参考GOWIN文档[SUG100](https://cdn.gowinsemi.com.cn/SUG100 4.0_Gowin%E4%BA%91%E6%BA%90%E8%BD%AF%E4%BB%B6%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf)中关于GAO工具的描述。 ### 更多问题及其解决办法前往[相关问题](./../common doc/questions)查看"},"/hardware/zh/tang/tang-mega-138k/mega-138k-pro.html":{"title":"Tang Mega 138K Pro Dock","content":" title: Tang Mega 138K Pro Dock keywords: FPGA, Tang, Mega, 138K update: date: 2023 08 29 version: v0.9 author: wonder content: 新建文档 date: 2024 09 26 version: v0.91 author: Serika content: 更新FAQs ## 产品概述 **Tang Mega 138K** 使用 22nm 制程 **GW5AST LV138FPG676A** FPGA 芯片，具有 138240 个查找表单元和近 300 个 DSP 单元。含有八个速度范围在 270Mbps ~ 12.5Gbps 高速收发器，适合用于光纤或者 PCIE 等高速口传递数据。此外，芯片含有硬核 PCIE，在使用 PCIE 的时候消耗更好的资源，并且得到更佳的性能。适用于高速通信、协议转换、高性能计算等场合。 淘宝购买链接：[点我](https://item.taobao.com/item.htm?id 740536508140) ## 板卡特点 大容量 LUT 大容量 内存 PCIE3.0 x 4 SFP+ x 2 RISCV 硬核 ## 产品外观 <img src \"./assets/mega_138k_pro_top.png\" width \"45%\"> ## 硬件参数 ### 核心板参数 <table> \t<thead> \t\t<tr> \t\t\t<th style \"text align:center\">项目</th> \t\t\t<th style \"text align:center\">参数</th> \t\t\t<th style \"text align:center\">补充</th> \t\t</tr> \t</thead> \t<tbody> \t\t<tr> \t\t\t<td style \"text align:left\">FPGA 芯片</td> \t\t\t<td style \"text align:left\"><a href \"https://www.gowinsemi.com.cn/prod_view.aspx?TypeId 74&FId t3:10:3&Id 188#GW5AST\">GW5AST LV138FPG676A</a> \t\t\t</td> \t\t\t<td style \"text align:left\"> \t\t\t\t<table> \t\t\t\t\t<tr> \t\t\t\t\t\t<td>逻辑单元(LUT4)</td> \t\t\t\t\t\t<td>138240</td> \t\t\t\t\t</tr> \t\t\t\t\t<tr> \t\t\t\t\t\t<td>寄存器(FF)</td> \t\t\t\t\t\t<td>138240</td> \t\t\t\t\t</tr> \t\t\t\t\t<tr> \t\t\t\t\t\t<td>分布式静态随机存储器S SRAM(Kbits)</td> \t\t\t\t\t\t<td>1080</td> \t\t\t\t\t</tr> \t\t\t\t\t<tr> \t\t\t\t\t\t<td>块状静态随机存储器B SRAM(Kbits)</td> \t\t\t\t\t\t<td>6120</td> \t\t\t\t\t</tr> \t\t\t\t\t<tr> \t\t\t\t\t\t<td>块状静态随机存储器数目B SRAM(个)</td> \t\t\t\t\t\t<td>340</td> \t\t\t\t\t</tr> \t\t\t\t\t<tr> \t\t\t\t\t\t<td>乘法器(18x18 Multiplier)</td> \t\t\t\t\t\t<td>298</td> \t\t\t\t\t</tr> \t\t\t\t\t<tr> \t\t\t\t\t\t<td>锁相环(PLLs)</td> \t\t\t\t\t\t<td>12</td> \t\t\t\t\t</tr> <tr> <td>全局时钟</td> <td>16</td> </tr> <tr> <td>高速时钟</td> <td>24</td> </tr> <tr> <td>Transceivers</td> <td>8</td> </tr> <tr> <td>Transceivers 速率</td> <td>270Mbps 12.5Gbps</td> </tr> <tr> <td>PCIE 硬核</td> <td>1个<br>速度可选 x1, x2, x4, x8 PCIe 3.0</td> </tr> <tr> <td>LVDS (Gbps)</td> <td>1.25</td> </tr> <tr> <td>DDR3 (Mbps)</td> <td>1333</td> </tr> <tr> <td>MIPI D PHY硬核</td> <td>2.5Gbps（RX），<br>8个数据通道，<br>2个时钟通道</td> </tr> <tr> <td>硬核处理器</td> <td>RiscV AE350_SOC</td> </tr> <tr> <td>ADC</td> <td>2</td> </tr> \t\t\t\t\t<tr> \t\t\t\t\t\t<td>GPIO Bank 总数</td> \t\t\t\t\t\t<td>6</td> \t\t\t\t\t</tr> \t\t\t\t</table> \t\t\t</td> \t\t</tr> \t\t<tr> \t\t\t<td style \"text align:left\">内存</td> \t\t\t<td style \"text align:left\">1GB DDR3</td> \t\t\t<td style \"text align:left\">512MB x 2</td> \t\t</tr> \t\t<tr> \t\t\t<td style \"text align:left\">Flash</td> \t\t\t<td style \"text align:left\">128Mbits Flash x 2</td> \t\t\t<td style \"text align:left\">查看 <a href \"#burn_flash\">烧录到Flash</a></td> \t\t</tr> \t\t<tr> \t\t\t<td style \"text align:left\">调试接口</td> \t\t\t<td style \"text align:left\">Jtag + Uart</td> \t\t\t<td style \"text align:left\">JST SH1.0 8Pins 连接器</td> \t\t</tr> \t\t<tr> \t\t\t<td style \"text align:left\">整体封装</td> \t\t\t<td style \"text align:left\">50mm x 70mm 大小</td> \t\t\t<td style \"text align:left\">BTB连接器连接核心板和底板</td> \t\t</tr> \t</tbody> </table> ### 底板参数 项目 数量 备注 : LED 6 WS2812 1 按键 4 PCIe 1 4 lane @ 5Gbps SFP+ 2 千兆以太网 1 DVI RX 2 与 DVI TX 互相占用 DVI TX 2 与 DVI RX 互相占用 PMOD 3 ADC 2 MIPI CSI 2 4 LANE MIPI CSI aRGB 1 与 WS2812 同数据引脚 DVP Interface 1 RGB Interface 1 支持 RGB888 屏幕 MIC ARRAY Interface 1 支持连接 Sipeed 6+1 麦克风阵列 SD 卡槽 1 EEPROM 1 可存储必要信息 M.2 座子 1 预留，可以自己写外设驱动 PWM 风扇接口 1 扬声器接口 1 3.5mm 耳机接口 1 自定义 USB 1 无法给板子供电 MS5351 2 为 Serdes 提供 RefClk；通过底板上的串口来控制输出 USB JTAG&UART 1 支持烧录 FPGA，并且提供串口功能 40P 排针 1 电源开关 1 12V DC 1 ## 硬件资料 [板卡规格书](https://dl.sipeed.com/shareURL/TANG/Mega_138K_Pro/01_Specification) [板卡原理图](https://dl.sipeed.com/shareURL/TANG/Mega_138K_Pro/02_Schematic) [PCB BOM](https://dl.sipeed.com/shareURL/TANG/Mega_138K_Pro/03_Designator_drawing) [板卡尺寸图](https://dl.sipeed.com/shareURL/TANG/Mega_138K_Pro/04_Mechanical_drawing) [板卡 3D 模型](https://dl.sipeed.com/shareURL/TANG/Mega_138K_Pro/05_3D_file) [部分芯片手册](https://dl.sipeed.com/shareURL/TANG/Mega_138K_Pro/07_Datasheet) [内部走线长度](https://dl.sipeed.com/shareURL/TANG/Mega_138K_Pro/08_Pinout_Length_table) [全引脚约束](https://dl.sipeed.com/shareURL/TANG/Mega_138K_Pro/09_Misc) ## 上手使用 注意138K Pro目前未被教育版支持，需要下载 V1.9.9 或更新版本的商业版IDE使用。 V1.9.10.02版本的Programmer存在严重问题，无法正常下载本产品。 Lic 可以在高云官网申请，或者使用Sipeed提供的在线Lic服务，在IDE中选择Float Lic，填写以下信息即可： ~~~ Server 01 ip: 106.55.34.119 port: 10559 ~~~ 如果上面的IP不能工作, 尝试使用 \"gowinlic.sipeed.com\" 域名对应的IP. 安装 IDE [点我](https://wiki.sipeed.com/hardware/zh/tang/common doc/get_started/install the ide.html) 例程代码 [github](https://github.com/sipeed/TangMega 138KPro example) ### 其他学习资源 在线免费教程：[Verilog 教程](https://www.runoob.com/w3cnote/verilog tutorial.html)（学习Verilog） 在线免费 FPGA 教程：[Verilog](https://www.asic world.com/verilog/index.html) （英文网站） Verilog 刷题网站：[HDLBits](https://hdlbits.01xz.net/wiki/Main_Page)（英文网站） 在线高云半导体可参考视频教程：[点击这里](http://www.gowinsemi.com.cn/video_complex.aspx?FId n15:15:26) ## 交流方式 **交流论坛: [maixhub.com/discussion](https://maixhub.com/discussion)** **QQ 交流群：[834585530](https://jq.qq.com/?_wv 1027&k wBb8XUan)** 直接本页下方留言 前往**[Github项目主页](https://github.com/sipeed/TangMega 138KPro example)**提交issue 商业邮箱 : [support@sipeed.com](support@sipeed.com) ## 注意事项 <table> <tr> <th>事项</th> <th>注意事项</th> </tr> <tr> <td>芯片型号</td> <td>Tang Mega 138K Pro 使用的 FPGA 芯片具体型号是 <b>GW5AST LV138FPG676A</b> <br>在 IDE 中选择封装型号 <span><b>FCPBG676A</b></span> & <span><b>Device Version: B/C</b></span> <a href \"../common doc/questions#如何分辨器件辨版本\">点我查看如何分辨器件版本</a></br></td> </tr> <tr> <td>静电</td> <td>请避免静电打到 PCBA 上；接触 PCBA 之前请把手的静电释放掉</td> </tr> <tr> <td>容忍电压</td> <td> 使用 GPIO 排针引脚进行外部通信时，要确保 IO 电压是 3.3V，过高的电压会永久损坏 PCBA </td> </tr> <tr> <td>FPC 座子</td> <td>在连接 FPC 软排线的时候，请确保排线无偏侈地完整地插入到排线中 <br>在通电之前请仔细核对两端FPC 连接器的 <b>1号PIN</b> 的方向是否正确</td> </tr> <tr> <td>PCIe 金手指</td> <td>在测试 PCIe 金手指时候，确保是主机端与板卡都处于关机或者未通电的状态，否则可能会因为插入过程中的易位导致金手指短路。</td> </tr> <tr> <td>插拔</td> <td>请完全断电后才进行插拔操作</td> </tr> <tr> <td>避免短路</td> <td>请在上电过程中，避免任何液体和金属触碰到 PCBA 上的元件的焊盘，否则会导致路，烧毁 PCBA</td> </tr> <tr> <td>保护晶圆</td> <td>请在拆装散热片的过程中，避免裸露的晶圆收到任何冲击，在安装好散热片后请勿用力按压散热片。否则将导致晶圆损坏</td> </tr> </table> ## 联系 Tang Mega 138K 可以在多种场景实现客户不同方面的需要，技术支持和商业合作请联系邮箱 [support@sipeed.com](support@sipeed.com) ## 常见问题 ### 板子通电后电源指示灯没亮 1. 请检查是否开启了板子的电源开关。 2. 检查自己的供电方式。 ### 板子电源指示灯亮了，Programmer提示No USB Cable Connection 1. 请检查USB线是否正确接入标记为**JTAGUART**的USB C连接器 2. 尽量避免使用机箱前面板的USB连接器和没有独立供电的USB HUB 3. 检查自己是否正确安装FT2232的驱动：出现USB Serial Converter A/B <img src \"./../assets/FTDI_DEVICE.jpg\" alt \"flash_mode\" width 35%> 4. 通常情况下Windows会在联网后自动安装相应驱动。如果想要手动处理，请前往[相关问题](./../common doc/questions)查看相关内容 5. 尝试更新板载下载器的固件，请参考这里 **[【点我跳转】](./../common doc/update_debugger)** <img src \"./../assets/FTDI_DEVICE.jpg\" alt \"flash_mode\" width 35%> 4. 通常情况下Windows会在联网后自动安装相应驱动。如果想要手动处理，请前往[相关问题](./../common doc/questions)查看相关内容。 ### 如何下载到外部 FLASH {#burn_flash} 进行如下选项设置： <img src \"./../assets/flash_mode_GAO.png\" alt \"flash_mode\" width 35%> ### 烧录后没反应或者引脚现象不对 1. 首先确定IDE选择了正确的型号 **GW5AST LV138FPG676AC1/10**，下图中的每一个参数都要求一致. <img src \"./assets/partno_138K_pro.png\" alt \"device_choose\" width 35%> 2. 然后检查自己的代码和对应的仿真波形是否满足要求 ### 更多问题及其解决办法前往[相关问题](./../common doc/questions)查看"},"/hardware/zh/tang/Tang-Nano/examples/lcd_constrains.html":{"title":"LCD constrain file content","content":" title: LCD constrain file content <p id \"back\"> <a href \"#\" onClick \"javascript :history.back( 1);\">返回上一页(Back)</a> </p> ```cst IO_LOC \"LCD_B[4]\" 45; IO_PORT \"LCD_B[4]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_B[3]\" 44; IO_PORT \"LCD_B[3]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_B[2]\" 43; IO_PORT \"LCD_B[2]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_B[1]\" 42; IO_PORT \"LCD_B[1]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_B[0]\" 41; IO_PORT \"LCD_B[0]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_G[5]\" 40; IO_PORT \"LCD_G[5]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_G[4]\" 39; IO_PORT \"LCD_G[4]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_G[3]\" 38; IO_PORT \"LCD_G[3]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_G[2]\" 34; IO_PORT \"LCD_G[2]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_G[1]\" 33; IO_PORT \"LCD_G[1]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_G[0]\" 32; IO_PORT \"LCD_G[0]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_R[4]\" 31; IO_PORT \"LCD_R[4]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_R[3]\" 30; IO_PORT \"LCD_R[3]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_R[2]\" 29; IO_PORT \"LCD_R[2]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_R[1]\" 28; IO_PORT \"LCD_R[1]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_R[0]\" 27; IO_PORT \"LCD_R[0]\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_DEN\" 5; IO_PORT \"LCD_DEN\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_SYNC\" 46; IO_PORT \"LCD_SYNC\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_HYNC\" 10; IO_PORT \"LCD_HYNC\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"LCD_CLK\" 11; IO_PORT \"LCD_CLK\" IO_TYPE LVCMOS33 PULL_MODE UP DRIVE 8; IO_LOC \"nRST\" 14; IO_PORT \"nRST\" IO_TYPE LVCMOS33 PULL_MODE UP; IO_LOC \"XTAL_IN\" 35; IO_PORT \"XTAL_IN\" IO_TYPE LVCMOS33 PULL_MODE UP; ``` <p id \"back\"> <a href \"#\" onClick \"javascript :history.back( 1);\">返回上一页(Back)</a> </p>"},"/hardware/zh/tang/Tang-Nano/examples/2_lcd.html":{"title":"RGB LCD 示例","content":"# RGB LCD 示例 > 编辑于2022.04.12 ## 先介绍时序 RGB LCD 显示协议和 VGA 类似，通信都有专用的行同步、场同步信号线。它们的主要区别是前者传输用的是数字信号，后者传输走的是模拟信号。 下面就介绍 VGA 的时序 ![](./../../assets/examples/lcd_pjt_1.png) 上图分别是 VGA 在数据传输中的行同步、场同步时序 从时序图中可以看出，不论是显示一行数据还是一列数据，都需要一个对应的同步(sync)信号，数据的传输在两个同步信号的脉冲之间完成 每一行的数据包括显示前沿(back porch)、有效数据(active video)、显示后沿(front porch)三个阶段 其中的有效数据就是我们常说的分辨率，而显示前后沿的参数需要参考具体的分辨率与帧数进行设置，相关参数可以参考典型参数，链接在此： http://www.tinyvga.com/vga timing 这块5寸屏幕的控制时序略有不同，相关参数的设置可以查看[规格书](https://dl.sipeed.com/fileList/TANG/Nano%209K/6_Chip_Manual/CN/LCD_Datasheet/5.0inch_LCD_Datashet%20RGB.pdf) 其他尺寸的屏幕相关规格书均可以在这里下载 [点我](https://dl.sipeed.com/shareURL/TANG/Nano%209K/6_Chip_Manual/CN/LCD_Datasheet) 下面为这块 LCD 时序相关的截图 ![](./../../assets/examples/lcd_pjt_2.png) ![](./../../assets/examples/lcd_pjt_3.png) 上面一张图是时序中的参数表，下面的图是时序图 从时序图中看出，这块屏幕可以不用设置前后沿，可以只设置消影(blanking)时间，通过实际的程序证明，两种方式都是可以的 ## 新建工程 新建工程方法参考[自建点灯文章(点我)](./led/self_create.html) ## 生成屏幕时钟 这里需要用到高云半导体官方的IP核 板载的晶振时钟为 24MHz ，但是我们的屏幕要求 33.3MHZ 的时钟，所以我们需要使用对应的ip核来生成相应的时钟 ### pll 这里需要使用到 `IP Core Generate` ，位置在 Tools > IP Core Generate ![](./../../Tang Nano 1K/assets/Gowin_IP_rpll.png) 双击 `rPLL` ，在弹出窗口 language 选择 Verilog ，CLKIN 为 24MHz ，CLKOUT 为 200MHz，CLKOUTD 要选择 Enable，然后生成时钟为 33.33MHz，Tolerance 选择 0.2% ![](./../../assets/examples/lcd_pjt_5.png) 点击ok后提示是否需要添加到当前工程，此时应当选择确定 ![](./led/assets/add_ip_file_in_project.png) 接着会出现一个例化的tmp文件，用来例化所设置的ip。比如下图中例子 ![](./led/assets/ip_examples.png) ### osc **这一步可以不做** 系统的时钟可以由外部时钟提供，也可以使用 OSC 生成的时钟 同样也是使用 `IP Core Generate` 找到 `OSC` 并双击打开进行分频的设置 在帮助页面可以知道，GW1N 1 系列的 fpga 的 OSC 是从 240MHz 进行分频的，所以要产生 24MHz 的时钟，只需要进行 10 的分频 ## 屏幕驱动代码 **首先新建一个额外的verilog文件来保存下面要编写的代码** ### 端口定义 首先需要先定义出驱动屏幕所需要的端口 ```verilog module VGAMod ( input CLK, input nRST, input PixelClk, output LCD_DE, output LCD_HSYNC, output LCD_VSYNC, \toutput [4:0] LCD_B, \toutput [5:0] LCD_G, \toutput [4:0] LCD_R ); ``` 本例程使用RGB565作为驱动方式； ### 时序常量 接着定义出时序图上所要求的常量 ```verilog localparam V_BackPorch 16'd6; //0 or 45 localparam V_Pluse \t 16'd5; localparam HightPixel 16'd480; localparam V_FrontPorch 16'd62; //45 or 0 localparam H_BackPorch 16'd182; \t localparam H_Pluse \t 16'd1; localparam WidthPixel 16'd800; localparam H_FrontPorch 16'd210; localparam PixelForHS WidthPixel + H_BackPorch + H_FrontPorch; \t localparam LineForVS HightPixel + V_BackPorch + V_FrontPorch; ``` 首先是设置时序相关的参数：前沿、后沿、有效像素 关于显示前沿、后沿，前面也说了，可以合并为一个消影时间，就是可以把其中一个设置为0，另一个设置为消影时间。反正前后沿的时间加起来符合表中的时间要求就可以 ### 定义变量 定义一些变量能够容易编写程序 ```verilog reg [15:0] LineCount; reg [15:0] PixelCount; reg\t[9:0] Data_R; reg\t[9:0] Data_G; reg\t[9:0] Data_B; ``` ### 同步信号 这段代码产生同步信号，需要注意的是，这块屏幕的同步信号是负极性使能 ```verilog always @( posedge PixelClk or negedge nRST )begin if( !nRST ) begin LineCount < 16'b0; PixelCount < 16'b0; end else if( PixelCount PixelForHS ) begin PixelCount < 16'b0; LineCount < LineCount + 1'b1; end else if( LineCount LineForVS ) begin LineCount < 16'b0; PixelCount < 16'b0; end else PixelCount < PixelCount + 1'b1; end always @( posedge PixelClk or negedge nRST )begin if( !nRST ) begin \t\t\tData_R < 9'b0; \t\t\tData_G < 9'b0; \t\t\tData_B < 9'b0; end else begin \t\t\tend \tend //注意这里HSYNC和VSYNC负极性 assign LCD_HSYNC (( PixelCount > H_Pluse)&&( PixelCount < (PixelForHS H_FrontPorch))) ? 1'b0 : 1'b1; assign LCD_VSYNC ((( LineCount > V_Pluse )&&( LineCount < (LineForVS 0) )) ) ? 1'b0 : 1'b1; ``` ### 使能信号 这段代码设置 LCD 使能图像显示，这块屏幕需要控制一个管脚用作显示开关，实际这个信号就是传输图像有效的那 800*480 的数据时置 1 ```verilog assign LCD_DE ( ( PixelCount > H_BackPorch )&& ( PixelCount < PixelForHS H_FrontPorch ) && ( LineCount > V_BackPorch ) && ( LineCount < LineForVS V_FrontPorch 1 )) ? 1'b1 : 1'b0; //这里不减一，会抖动 ``` ### 测试彩条 这段代码用来产生 LCD 的测试数据，产生彩条显示 ```verilog localparam Colorbar_width WidthPixel / 16; assign LCD_R ( PixelCount < ( H_BackPorch + Colorbar_width * 0 )) ? 5'b00000 : ( PixelCount < ( H_BackPorch + Colorbar_width * 1 )) ? 5'b00001 : ( PixelCount < ( H_BackPorch + Colorbar_width * 2 )) ? 5'b00010 : ( PixelCount < ( H_BackPorch + Colorbar_width * 3 )) ? 5'b00100 : ( PixelCount < ( H_BackPorch + Colorbar_width * 4 )) ? 5'b01000 : ( PixelCount < ( H_BackPorch + Colorbar_width * 5 )) ? 5'b10000 : 5'b00000; assign LCD_G ( PixelCount < ( H_BackPorch + Colorbar_width * 6 )) ? 6'b000001: ( PixelCount < ( H_BackPorch + Colorbar_width * 7 )) ? 6'b000010: ( PixelCount < ( H_BackPorch + Colorbar_width * 8 )) ? 6'b000100: ( PixelCount < ( H_BackPorch + Colorbar_width * 9 )) ? 6'b001000: ( PixelCount < ( H_BackPorch + Colorbar_width * 10 )) ? 6'b010000: ( PixelCount < ( H_BackPorch + Colorbar_width * 11 )) ? 6'b100000: 6'b000000; assign LCD_B ( PixelCount < ( H_BackPorch + Colorbar_width * 12 )) ? 5'b00001 : ( PixelCount < ( H_BackPorch + Colorbar_width * 13 )) ? 5'b00010 : ( PixelCount < ( H_BackPorch + Colorbar_width * 14 )) ? 5'b00100 : ( PixelCount < ( H_BackPorch + Colorbar_width * 15 )) ? 5'b01000 : ( PixelCount < ( H_BackPorch + Colorbar_width * 16 )) ? 5'b10000 : 5'b00000; ``` **当然在最后的驱动文件最后别忘记换行加上 endmodule** 到这里驱动模块的编写已经完成了。 ## 在顶层模块中例化 **这里也是要新建verilog文件的** 新建文件之后直接把下面的内容复制进去保存即可 ```verilog module TOP //设置顶层模块 ( \tinput\t\t\tnRST, input XTAL_IN, \toutput\t\t\tLCD_CLK, \toutput\t\t\tLCD_HYNC, \toutput\t\t\tLCD_SYNC, \toutput\t\t\tLCD_DEN, \toutput\t[4:0]\tLCD_R, \toutput\t[5:0]\tLCD_G, \toutput\t[4:0]\tLCD_B ); // 列出需要的端口 \twire\t\tCLK_SYS;\t \twire\t\tCLK_PIX; //例化pll Gowin_rPLL chip_pll( .clkout(CLK_SYS), //output clkout //200M .clkoutd(CLK_PIX), //output clkoutd //33.00M .clkin(XTAL_IN) //input clkin );\t \tVGAMod\tVGAMod_inst //例化vga驱动 \t( \t\t.CLK\t\t(\tCLK_SYS ), \t\t.nRST\t\t(\tnRST\t\t), \t\t.PixelClk\t(\tCLK_PIX\t\t), \t\t.LCD_DE\t\t(\tLCD_DEN\t \t), \t\t.LCD_HSYNC\t(\tLCD_HYNC \t), \t.LCD_VSYNC\t(\tLCD_SYNC \t), \t\t.LCD_B\t\t(\tLCD_B\t\t), \t\t.LCD_G\t\t(\tLCD_G\t\t), \t\t.LCD_R\t\t(\tLCD_R\t\t) \t); \tassign\t\tLCD_CLK\t\t \tCLK_PIX; endmodule ``` ## 综合、约束、布局布线 ### 综合 完成上面步骤后转到“Process”界面下，对编辑好的代码进行综合，即运行“Synthesize” ![](./../../Tang Nano 9K/nano_9k/nano_9k_synthsize.png) 运行的结果如下图出现 ![](./../../Tang Nano/assets/LED.png) 说明前面编辑的代码无误；如果有错，根据错误提示进行改正即可。 ### 管脚约束 对应的管脚约束如下表格所示； 关于管脚约束方法可以参考[自建点灯文章(点我)](./led/self_create.html)里面的约束方法。 感觉麻烦的话也可以直接复制准备好的[文件(点我)](./lcd_constrains.html)，将页面里的内容复制到工程目录里 .cst 文件中（如果没有.cst 文件那么自己新建一个**物理管脚约束文件**） 即可。 PORT PIN PORT PIN PORT PIN : : : : : : : : : : : : LCD_CLK 11 nRST 14 XTAL_IN 35 LCD_B[4] 45 LCD_B[3] 44 LCD_B[2] 43 LCD_B[1] 42 LCD_B[0] 41 LCD_G[5] 40 LCD_G[4] 39 LCD_G[3] 38 LCD_G[2] 34 LCD_G[1] 33 LCD_G[0] 32 LCD_R[4] 31 LCD_R[3] 30 LCD_R[2] 29 LCD_R[1] 28 LCD_R[0] 27 LCD_DEN 5 LCD_SYNC 46 LCD_HYNC 10 ### 布局布线 管脚约束之后需要在设置里面开启引脚复用才能完成布局布线。 具体位置在 软件顶部菜单栏 Project > Configuration > Place&Route > Dual Purpose Pin ![](./led/assets/enable_io_mux.png) 设置完上面的之后。 就可以开始布局布线(Place&Route)了。 完成后就可以给开发板验证代码内容了。 ## 烧录 布局布线结束后生成比特流，就可以烧录开发板了。 ## 结束 上面差不多叙述了所有代码。 整个工程可以参考 [这里](https://github.com/sipeed/Tang Nano examples/tree/master/example_lcd) <p id \"back\"> <a href \"#\" onClick \"javascript :history.back( 1);\">返回上一页(Back)</a> </p>"},"/hardware/zh/tang/Tang-Nano/examples/led/github_sourcecode.html":{"title":"使用github例程","content":"# 使用github例程 首先获得仓库文件 https://github.com/sipeed/Tang Nano examples 打开 Tang Nano examples\\example_led\\led_prj 目录下的 led_prj.gprj 文件 在process界面右键选择 clean&Rerun all ![](./assets/github_place&route.png) 紧接着会报错（这是历史问题，有兴趣可以自己查查）。 顶部菜单栏 Project > Configuration > Syntheize 选择 GowinSyntheize 后点击**确定**，然后重新在 Place&Route 右键 clean&Rerun all ![](./assets/Change_Synthesis.png) 然后是进行连接板子，烧录固件。在Process界面双击`Program Device` 后打开烧录工具 ![](./assets/Open_Programmer.png) 接下来选择sram烧录即可验证程序。 ![](./assets/Success_led.png) <p id \"back\"> <a href \"#\" onClick \"javascript :history.back( 1);\">返回上一页(Back)</a> </p>"},"/hardware/zh/tang/Tang-Nano/examples/led/self_create.html":{"title":"自己点灯","content":"# 自己点灯 ## 新建项目 新建工程：File >NEW >FPGA Design Project >OK ![](./../../assets/LED 1.png) 弹出的选项框选择存储路径和工程名称（路径和文件名称要求是英文路径） ![](./../../assets/LED 2.png) 选择对应的型号： ![Tang_nano_1k_device_choose](./assets/Nano_device_choose.png) ## 编写代码 新建好工程之后接下来进行代码编辑，在Design工作栏内新建“Verilog File”,如下图所示： ![](./../../assets/LED 5.png) 为文件命名（要求写英文名，不然后续综合很容易报错）； 一般来说对于verolog文件建议文件名称与文件module名称应当相同 ![](./../../assets/LED 6.png) 双击新建的 .v 文件，可以在右侧的编辑框中编写代码。 ![](./../../assets/LED 7.png) ### Verilog 预备知识 这里只介绍接下来会用到的相关语法，更多的可以参考 《Verilog 数字系统设计教程》 Verilog 的基本设计单元是模块，一个模块是由两部分组成的，一部分描述接口，另一部分描述逻辑功能，即描述输出和输入的关系的。 模块就像我们平时提到的黑匣子，当我们实现了模块后，就不需要去关心模块内部，只需要根据模块定义的输入输出格式，将模块实例化，给模块提供输入，就可以让模块自己工作了 一个模块长成这样 ```v module module_name #(parameter) (port) ; Function description; endmodule ``` 模块整体结构由 module 和 endmodule 组成，module 后面跟着的是模块的名称，可传递变量参数，接口的定义，声明了端口的方向 模块内部有时候会使用内部的信号，内部信号有 wire 和 reg 类型 功能的定义可以通过 assign 和 always 块完成。 assign 是描述组合逻辑最常用的方法之一； always 可用于描述组合逻辑，也可描述时序逻辑 ### 示例代码 以流水灯为例；将下方的代码粘贴到自己的文件中，也可以自己编写代码。 ```verilog module led ( input sys_clk, input sys_rst_n, output reg [2:0] led // 110 B, 101 R, 011 G ); reg [23:0] counter; always @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) counter < 24'd0; else if (counter < 24'd1199_9999) // 0.5s delay counter < counter + 1'b1; else counter < 24'd0; end always @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) led < 3'b110; else if (counter 24'd1199_9999) // 0.5s delay led[2:0] < {led[1:0],led[2]}; else led < led; end endmodule ``` ## 综合、约束、布局布线 ### 综合 保存编辑的代码后转到“Process”界面下，对编辑好的代码进行综合，即双击“Synthesize” ![](./../../../Tang Nano 9K/nano_9k/nano_9k_synthsize.png) 运行之后如没有报错而且 Synthesize 变成下图里的图标 ![](./../../../Tang Nano/assets/LED.png) 说明前面编辑的代码无误；如果有错，根据错误提示进行改正即可。 ### 约束 此处未涉及时钟约束 想让 Fpga 实现代码的功能，必须将代码中涉及的 端口 绑定到 Fpga 实际的引脚上。 如下图，在左边的工作区点击 process，然后双击 FloorPlanner ![](./../../../assets/examples/led_pjt_2.png) 接下来通过 双击 Process 界面里的FloorPlanner来设置管脚约束。第一次打开会弹出缺少.cst文件.选择“OK”即可； ![](./../../assets/LED 9.pngassets/LED 9.png) nano 的 rgb led电路图如下所示 ![](./assets/nano_led_pins.png \"nano rgb pins\") 整个项目需要约束的引脚如下 port I/O pin desc sys_clk input 35 时钟输入脚 sys_rst_n input 15 系统复位脚 led[0] output 16 绿灯 led[1] output 17 蓝灯 led[2] output 18 红灯 对于交互式管脚约束有下图中的两种方法 将对应的端口拖拽到芯片引脚上 在IO约束中输入端口对应的引脚编号 在打开的界面中按照序号的顺序来进行相应的操作（两种方式选择一种即可） ![](./assets/pin_constrain_1.png) ![](./assets/pin_constrain_2.png) 直接编写约束文件方法用户自行研究 关于 FloorPlanner 更多的相关说明，可以参考 [SUG935 1.3_Gowin设计物理约束用户指南.pdf](http://cdn.gowinsemi.com.cn/SUG935 1.3_Gowin%E8%AE%BE%E8%AE%A1%E7%89%A9%E7%90%86%E7%BA%A6%E6%9D%9F%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf)。里面的内容都很有用 ### 布局布线 到“Process”下运行“Place&Route”，即运行管脚布局布线，运行结果如下图所示： ![](./assets/RGB_LED_Place&Route.png) ## 烧录 接下来是连接板子，烧录固件。在Process界面双击 `Program Device` 后打开烧录工具 ![](./assets/Open_Programmer.png) 可以在图中进行相应的修改 ![](./../../../../../zh/tang/Tang Nano/examples/led/assets/tang nano programmer config.png) 接下来选择sram烧录即可验证程序。 ![](./assets/Success_led.png) 点灯验证到此结束。 ## 结语 有问题的话可以在下方留言。 <p id \"back\"> <a href \"#\" onClick \"javascript :history.back( 1);\">返回上一页(Back)</a> </p>"},"/hardware/zh/tang/Tang-Nano/examples/1_led.html":{"title":"点灯","content":"# 点灯 > 编辑于2022年3月29日 ## 前言 本文提供两种方法点灯 [使用github仓库](./led/github_sourcecode.html) [自己新建项目](./led/self_create.html) <p id \"back\"> <a href \"#\" onClick \"javascript :history.back( 1);\">返回上一页(Back)</a> </p>"},"/hardware/zh/tang/Tang-Nano/Nano.html":{"title":"Tang Nano","content":"# Tang Nano ## 概述 Tang Nano是基于高云半导体的小蜜蜂系列GW1N 1 FPGA设计的简约型开发板。开发板设计小巧精致，将芯片的所有资源都引出，板载Type C、USB JTAG、PSRAM、RGB接口(可接LCD屏、VGA等外设)等，并把所有IO资源引出，方便开发者拓展使用，非常适用于小型数字逻辑的设计和实验。 ![](/hardware/assets/Tang/Nano/Tang_Nano.jpg) ## 参数 Tang Nano开发板板载的GW1N 1 FPGA芯片功能非常强大，具有较丰富的逻辑资源，支持多种I/O电平标准，内嵌块状静态随机存储器、锁相环、Flash等资源，是一款具有非易失性的FPGA产品;另外，板载64Mbits PSRAM，为FPGA提供了丰富的存储资源。 ![Nano](/hardware/assets/Tang/Nano/Tang Nano 4.png) 项目 参数 核心 GW1N 1 FPGA 逻辑单元(LUT4) 1152 寄存器(FF) 864 Block SRAM(bits) 72K B SRAM块个数 4 用户闪存(bits) 96K 锁相环PLL 1 I/O Bank总数 4 最多用户I/O数 41 核电压 1.2V ![Nano Pin](/hardware/assets/Tang/Nano/Tang Nano Pin.png) ## 产品技术支持 Tang Nano开发板可以在多种场景实现客户不同方面的需要，在AIoT上已经广泛的使用，品质和性能在行业内已经有非常好的口碑，专业的技术团队为广大客户解决硬件设计和软件功能上的各种各样问题。专业技术支持和更详细资料请联系商务<support@sipeed.com> ## 资料 [相关例程](./../common doc/examples.html#板型) [资料下载](https://dl.sipeed.com/shareURL/TANG/Nano)"},"/hardware/zh/tang/Tang-Nano/Tang-nano.html":{"title":"Tang nano 一些例程","content":" title: Tang nano 一些例程 对于Programmer(下载程序)建议使用 https://dl.sipeed.com/shareURL/TANG/programmer 里面的文件。 下载后解压替换掉Gowin对应安装目录的Programmer文件夹即可。 不会替换的话可以在下载解压后的Programmer程序中手动添加对应下载文件来进行烧录。 ## 例程 [点灯例程](./examples/1_led.html) [驱屏教程](./examples/2_lcd.html)"},"/hardware/zh/tang/Tang-Nano/start.html":{"title":"摄像头和HDIM屏幕显示","content":"# 摄像头和HDIM屏幕显示 具体工程[文件](https://github.com/sipeed/TangNano 4K example) 接好摄像头和HDMI显示器之后，将这个工程烧录到开发板上即可使用了。"},"/hardware/zh/tang/Tang-Nano/user.html":{"title":"一些例程","content":"# 一些例程 ## 点灯LED 1. 新建工程：File >NEW >FPGA Dsign Project >OK ![](./assets/LED 1.png) 2. 弹出的选项框选择存储路径和工程名称（路径和文件名称要求是英文路径） ![](./assets/LED 2.png) 3. 选择合适的型号： ![](./assets/LED 3.png)![](./assets/LED 4.png) 4. 新建好工程之后接下来进行代码编辑，在Design工作栏内新建“Verilog File”,如下图所示： ![](./assets/LED 5.png) 5. 为文件命名（要求写英文名，不然后续综合很容易报错） ![](./assets/LED 6.png)![](./assets/LED 7.png) 6. 双击文件，可以在右侧的编辑框中进行代码的编写。以编辑流水灯为例，将下方的“LED例程代码”粘贴到自己的文件中，也可以自己编写自己的代码，例程代码地址：<https://github.com/sipeed/TangNano 1K examples> ```v module led ( input sys_clk, input sys_rst_n, output reg [2:0] led // 110 R, 101 B, 011 G ); reg [31:0] counter; always @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin counter < 31'd0; led < 3'b110; end else if (counter < 31'd1350_0000) // 0.5s delay counter < counter + 1'b1; else begin counter < 31'd0; led[2:0] < {led[1:0],led[2]}; end end Endmodule ``` 7. 代码编辑结束后转到“Process”界面下，对编辑好的代码进行综合，即运行“Synthesize” ![](./assets/LED 8.png) 运行的结果如上图出现 ![](./assets/LED.png) 的形状，且下方结果栏不出现任何从报错，说明前面编辑的代码无误，如果有错，根据错误提示进行改正即可。 8. 接下来通过 打开“FloorPlanner”实现管脚约束（前面的综合如果运行失败，这一步无法进行），第一次打开会弹出缺少.cst文件： ![](./assets/LED 9.png) 选择“OK”即可； 初始界面如图：![](./assets/LED 10.png)![](./assets/LED 11.png) 9. 将界面转到“Package View”界面，点击下方“I/O Constraints”编辑引脚数据，如下图所示： ![](./assets/LED 12.png)![](./assets/LED 13.png) 引脚情况： ![](./assets/LED 14.png) 引脚分布情况： PORT I/O PIN DESE SYS_CLK INPUT 47 47 SYS RST N INPUT 13 LED[0] OUTPUT 9 LED[1] OUTPUT 10 LED[2] OUTPUT 11 10.将界面转到“Package View”界面，点击下方“I/O Constraints”编辑引脚数据，如下图所示： ![](./assets/LED 15.png) 11.到“Process”下运行“Place&Route”，即运行管脚布局布线，运行结果如下图所示： ![](./assets/LED 16.png) 12.接下来是进行连接板子，烧录固件，可参照下图选择版型： ![](./assets/LED 17.png) 13.以烧录进SRAM为例进行说明，如下图： ![](./assets/LED 18.png)![](./assets/LED 19.png) 最后运行： ![](./assets/LED 20.png) 14、结果显示： 【此处放置LED闪烁动图】 15、解说烧录到FLASH中的方式： ![](./assets/LED 21.png)![](./assets/LED 22.png) 点灯步骤到此结束。 > 说明： > 01、只测试过下载站下班的版本以及1.9.8版本测试正常，其他版本需用户自行确认。 > 02、不要使用中文路径 >错误：![](./assets/LED 23.png) ## 驱屏教程 例程代码地址：<https://github.com/sipeed/TangNano 1K examples> ![](./assets/pin 1.png)![](./assets/pin 2.png)![](./assets/pin 3.png) 引脚分布情况： PORT I/O PIN DESE KEY INPUT 13 47 LCD_B[0] INPUT 19 LCD_B[1] OUTPUT 20 LCD_B[2] OUTPUT 22 LCD_B[3] OUTPUT 23 LCD_B[4] OUTPUT 24 LCD_CLK OUTPUT 8 LCD_DEN OUTPUT 21 LCD_G[0] OUTPUT 28 LCD_G[1] OUTPUT 27 LCD_G[2] OUTPUT 15 LCD_G[3] OUTPUT 16 LCD_G[4] OUTPUT 17 LCD_G[5] OUTPUT 18 LCD_HYNC OUTPUT 33 LCD_R[0] OUTPUT 15 LCD_R[2] OUTPUT 34 LCD_R[3] OUTPUT 31 LCD_R[4] OUTPUT 30 LCD_R[4] OUTPUT 29 LCD_SYNC OUTPUT 32 LED_B OUTPUT 10 LED_G OUTPUT 11 LED_R OUTPUT 9 XTAL_IN INPUT 47 nRST INPUT 44 详细代码和工程建立步骤请参照LED点灯例程。"},"/hardware/zh/tang/tang-primer-25k/primer-25k.html":{"title":"Tang Primer 25K","content":"# Tang Primer 25K ## 概述 Tang Primer 25K 是基于 [GW5A LV25MG121](http://www.gowinsemi.com.cn/prod_view.aspx?TypeId 74&FId t3:10:3&Id 188) 所设计的一款极小封装的核心板（23x18mm），并配套全引脚引出(除MIPI高速脚外)的25K Dock底板。 极小的核心板尺寸可以应用于任何体积受限的场景。 简洁的底板可以连接USB手柄，插接40Pin SDRAM模块，3个PMOD接口可以连接HDMI显示器，PS2手柄组成典型的RetroGame主机形态。 也可以搭配Sipeed出的系列PMOD模块产品，作为FPGA大学教学使用。 <div> <img src \"./assets/25k_45.jpg\" width 45%> <img src \"./assets/25k_dock_45.jpg\" width 45%> </div> 购买链接：[淘宝](https://item.taobao.com/item.htm?id 746293292946) ## 核心板概览 <div> <img src \"./assets/25k_top.jpg\" width 45%> <img src \"./assets/25k_bot.jpg\" width 45%> </div> ## 基础参数 <table> \t<thead> \t\t<tr> \t\t\t<th style \"text align:center\">项目</th> \t\t\t<th style \"text align:center\">参数</th> \t\t\t<th style \"text align:center\">补充</th> \t\t</tr> \t</thead> \t<tbody> \t\t<tr> \t\t\t<td style \"text align:left\">FPGA 芯片</td> \t\t\t<td style \"text align:left\"><a href \"http://www.gowinsemi.com.cn/prod_view.aspx?TypeId 74&FId t3:10:3&Id 188\">GW5A LV25MG121C1/l0</a> \t\t\t</td> \t\t\t<td style \"text align:left\"> \t\t\t\t<table> \t\t\t\t\t<tr> \t\t\t\t\t\t<td>逻辑单元(LUT4)</td> \t\t\t\t\t\t<td>23040</td> \t\t\t\t\t</tr> \t\t\t\t\t<tr> \t\t\t\t\t\t<td>寄存器(FF)</td> \t\t\t\t\t\t<td>23040</td> \t\t\t\t\t</tr> \t\t\t\t\t<tr> \t\t\t\t\t\t<td>分布式静态随机存储器S SRAM(bits)</td> \t\t\t\t\t\t<td>Version A: 0K </br>Version B: 180K </td> \t\t\t\t\t</tr> \t\t\t\t\t<tr> \t\t\t\t\t\t<td>块状静态随机存储器B SRAM(bits)</td> \t\t\t\t\t\t<td>1008K</td> \t\t\t\t\t</tr> \t\t\t\t\t<tr> \t\t\t\t\t\t<td>块状静态随机存储器数目B SRAM(个)</td> \t\t\t\t\t\t<td>56</td> \t\t\t\t\t</tr> \t\t\t\t\t<tr> \t\t\t\t\t\t<td>乘法器(18x18 Multiplier)</td> \t\t\t\t\t\t<td>28</td> \t\t\t\t\t</tr> \t\t\t\t\t<tr> \t\t\t\t\t\t<td>锁相环(PLLs)</td> \t\t\t\t\t\t<td>6</td> \t\t\t\t\t</tr> \t\t\t\t\t<tr> \t\t\t\t\t\t<td>I/O Bank 总数</td> \t\t\t\t\t\t<td>8</td> \t\t\t\t\t</tr> \t\t\t\t\t<tr> \t\t\t\t\t\t<td><b>Device Version</b></td> \t\t\t\t\t\t<td><b>A</b></td> \t\t\t\t\t</tr> \t\t\t\t</table> \t\t\t</td> \t\t</tr> \t\t<tr> \t\t\t<td style \"text align:left\">Flash</td> \t\t\t<td style \"text align:left\">64Mbits NOR Flash</td> \t\t\t<td style \"text align:left\">查看 <a href \"#burn_flash\">烧录到Flash</a></td> \t\t</tr> \t\t<tr> \t\t\t<td style \"text align:left\">整体封装</td> \t\t\t<td style \"text align:left\">2x60P BTB 核心板</td> \t\t\t<td style \"text align:left\"></td> \t\t</tr> \t\t<tr> \t\t\t<td style \"text align:left\">普通IO</td> \t\t\t<td style \"text align:left\"> 75</td> \t\t\t<td style \"text align:left\"></td> \t\t</tr> \t\t<tr> \t\t\t<td style \"text align:left\"> MIPI IO </td> \t\t\t<td style \"text align:left\"> 4lane Data</td> \t\t\t<td style \"text align:left\"></td> \t\t</tr> \t</tbody> </table> ## Dock 底板产品图 <div> <img src \"./assets/25k_dock_top.jpg\" width 45%> <img src \"./assets/25k_dock_bot.jpg\" width 45%> </div> ## 板卡参数 <table> \t<thead> \t\t<tr> \t\t\t<th style \"text align:center\">项目</th> \t\t\t<th style \"text align:center\">参数</th> \t\t\t<th style \"text align:center\">备注</th> \t\t</tr> \t</thead> \t<tbody> \t\t<tr> \t\t\t<td style \"text align:left\">调试器</td> \t\t\t<td style \"text align:left\">板载高速调试器，支持JTAG+UART，使用USB C口烧录</td> \t\t\t<td style \"text align:left\"></td> \t\t</tr> \t\t<tr> \t\t\t<td style \"text align:left\">USB A</td> \t\t\t<td style \"text align:left\">一个，可作为USB1.1 Host接游戏手柄等HID设备</td> \t\t\t<td style \"text align:left\"></td> \t\t</tr> \t\t<tr> \t\t\t<td style \"text align:left\"> IO插针 </td> \t\t\t<td style \"text align:left\"> 一个2x20Pin 2.54插针</td> \t\t\t<td style \"text align:left\">支持SDRAM模块</td> \t\t</tr> \t\t<tr> \t\t\t<td style \"text align:left\"> PMOD </td> \t\t\t<td style \"text align:left\"> 3个</td> \t\t\t<td style \"text align:left\"></td> \t\t</tr> \t\t<tr> \t\t\t<td style \"text align:left\">按键</td> \t\t\t<td style \"text align:left\">2个</td> \t\t\t<td style \"text align:left\"></td> \t\t</tr> \t\t<tr> \t\t\t<td style \"text align:left\">尺寸</td> \t\t\t<td style \"text align:left\">64x40mm</td> \t\t\t<td style \"text align:left\"></td> \t\t</tr> \t</tbody> </table> ## 硬件资料 规格书、原理图、尺寸图等均可在这里找到：[点击这里](https://dl.sipeed.com/shareURL/TANG/Primer_25K) [板卡规格书](https://dl.sipeed.com/shareURL/TANG/Primer_25K/01_Specification) [板卡原理图](https://dl.sipeed.com/shareURL/TANG/Primer_25K/02_Schematic) [板卡点位图](https://dl.sipeed.com/shareURL/TANG/Primer_25K/03_Designator_drawing) [板卡尺寸图](https://dl.sipeed.com/shareURL/TANG/Primer_25K/04_Mechanical_drawing) [3D 模型文件](https://dl.sipeed.com/shareURL/TANG/Primer_25K/05_3D_file) [核心板封装](https://dl.sipeed.com/shareURL/TANG/Primer_25K/06_PCB_Lib) [芯片部分资料](https://dl.sipeed.com/shareURL/TANG/Primer_25K/07_Datasheet) [走线长度表](https://dl.sipeed.com/shareURL/TANG/Primer_25K/08_Pin_Length_table) ## 上手简明 `准备开发环境` > `学习相关语法` > `查看开箱指南` > `基础代码编写` > `查看官方文档` 1. 安装 IDE ：[点击这里](../common doc/get_started/install the ide.html) 2. 查看 [上手指南](https://wiki.sipeed.com/hardware/zh/tang/tang primer 20k/start.html) 来避免一些问题，并且从那里面可以开始进行代码实战。 3. 如果进行完上面的点灯操作后后感觉有压力，可以自己查漏补缺： 可以在下面的这些网站学习 Verilog: \t+ 在线免费教程：[Verilog 教程](https://www.runoob.com/w3cnote/verilog tutorial.html)（学习Verilog） \t+ 在线免费 FPGA 教程：[Verilog](https://www.asic world.com/verilog/index.html) （英文网站） \t+ Verilog 刷题网站：[HDLBits](https://hdlbits.01xz.net/wiki/Main_Page)（英文网站） \t+ 在线高云半导体可参考视频教程：[点击这里](http://www.gowinsemi.com.cn/video_complex.aspx?FId n15:15:26) 对 IDE 使用有疑问的话，可以查看官方的一些文档来熟悉相关内容 [SUG100 2.6_Gowin云源软件用户指南.pdf](http://cdn.gowinsemi.com.cn/SUG100 2.6_Gowin%E4%BA%91%E6%BA%90%E8%BD%AF%E4%BB%B6%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf) [SUG949 1.1_Gowin_HDL编码风格用户指南.pdf](http://cdn.gowinsemi.com.cn/SUG949 1.1_Gowin_HDL%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf) <a href \"http://cdn.gowinsemi.com.cn/UG286 1.9.1_Gowin%E6%97%B6%E9%92%9F%E8%B5%84%E6%BA%90(Clock)%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf\">UG286 1.9.1_Gowin时钟资源(Clock)用户指南.pdf</a> [SUG940 1.3_Gowin设计时序约束用户指南.pdf](http://cdn.gowinsemi.com.cn/SUG940 1.3_Gowin%E8%AE%BE%E8%AE%A1%E6%97%B6%E5%BA%8F%E7%BA%A6%E6%9D%9F%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf) [SUG502 1.3_Gowin_Programmer用户指南.pdf](http://cdn.gowinsemi.com.cn/SUG502 1.3_Gowin_Programmer%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf) [SUG114 2.5_Gowin在线逻辑分析仪用户指南.pdf](http://cdn.gowinsemi.com.cn/SUG114 2.5_Gowin%E5%9C%A8%E7%BA%BF%E9%80%BB%E8%BE%91%E5%88%86%E6%9E%90%E4%BB%AA%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf) 上面的所有文档都已经打包进了下载站[点我跳转](https://dl.sipeed.com/shareURL/TANG/Primer_20K/07_Chip_manual/CN/%E9%80%9A%E7%94%A8%E6%8C%87%E5%BC%95)，需要的话可以点击压缩包全都下载下来。 ## 例程汇总 注意25K需要使用 V1.9.9Beta 4 或更新的IDE版本。 http://www.gowinsemi.com.cn/faq.aspx ### 公开例程 github 链接： https://github.com/sipeed/TangPrimer 25K example ## 交流方式 **交流论坛: [maixhub.com](maixhub.com/discussion)** **QQ 交流群：[834585530](https://jq.qq.com/?_wv 1027&k wBb8XUan)** 直接本页下方留言 商业邮箱 : [support@sipeed.com](support@sipeed.com) ## 相关问题 ### 如何下载到外部 FLASH {#burn_flash} 进行如下选项设置： <img src \"./assets/flash_mode.png\" alt \"flash_mode\" width 75%> ### 烧录后没反应或者引脚现象不对 首先确定选择了正确的型号，下图中的每一个参数都要求一致 <img src \"./assets/partno.jpg\" alt \"device_choose\" width 75%> 然后检查自己的代码和对应的仿真波形是否满足要求 ### 更多问题及其解决办法前往[相关问题](./../common doc/questions.html)查看"},"/hardware/zh/tang/common-doc/update_debugger.html":{"title":"更新板载调试器（固件）","content":" title: 更新板载调试器（固件） keywords: Sipeed, Gowin, Tang, FPGA, Nano, Primer, Mega update: date: 2025 02 18 version: v0.8 author: Serika content: First release date: 2025 03 11 version: v0.9 author: Serika content: 9K pic fixed date: 2025 04 21 version: v0.91 author: Serika content: Added FaQ ## 概述 所有 Sipeed Tang 系列均有板载调试器（独立的 SOM 除外）。调试器是具有自己固件的独立 **MCU**。用户可以自行更新这些调试器的固件以获取功能更新和错误修复。 我们需要使用 [**BouffaloLabDevCube**](https://dev.bouffalolab.com/download/) 对这些板载调试器主控进行编程，有关 **博流MCU** 的 ***芯片 & 工具*** 的文档可以在此处找到 [【点我跳转】](https://dev.bouffalolab.com/document/)。 这里有一个简略的步骤说明： 首先，根据您所使用的操作系统，选择下载并安装相应版本的**更新工具**，如[**BouffaloLabDevCube**](https://dev.bouffalolab.com/download/)； 从 [**Sipeed 下载站**](https://dl.sipeed.com/shareURL/TANG/Debugger/onboard) 获取适用于您主板的更新调试器固件，请注意区分您的开发板的型号； 请参阅 [**博流智能官方网站**](https://dev.bouffalolab.com/download/) 上相应的官方文档来更新板载调试器的固件； 对于 **Windows** 用户，下方有详细的分步骤教程。其他操作系统的用户请参考 **Windows** 的步骤并根据实际情况相应变通。 ## 教程 ### 硬件准备 要将板载调试器置于 **DFU 模式**，请在打开电路板电源或使用电缆连接电路板的调试 USB 端口之前`按下` ***更新按钮*** 或`短接`相应的 ***测试点***。 请参阅下文了解相应的 ***更新按钮*** 和 ***测试点***。 #### **Tang nano 系列** **Tang nano 1K** 2 个 **`测试点`** 位于PCB的 **TOP** 面的左上角，按键`KEY B` 后面。 <!DOCTYPE html> <html lang \"zh CN\"> <head> <meta charset \"UTF 8\"> <title>CSS Indentation</title> <style> .indent { margin left: 0ch; /* wideof 0 characters */ } </style> </head> <body> <details class \"indent\"> <summary><font color \"#4F84FF\">点击此处查看nano 1K的下载器测试点的位置</font></summary> <img src \"./assets/hardware/nano1k_update.jpg\"> </details> </body> <br> </html> <! ![nano4k_update](./assets/hardware/nano1k_update.jpg) > **Tang nano 4K** 2 个 **`测试点`** 位于PCB的 **TOP** 面的左上角，`USB C` 连接器后面。 <!DOCTYPE html> <html lang \"zh CN\"> <head> <meta charset \"UTF 8\"> <title>CSS Indentation</title> <style> .indent { margin left: 0ch; /* wideof 0 characters */ } </style> </head> <body> <details class \"indent\"> <summary><font color \"#4F84FF\">点击此处查看nano 4K的下载器测试点的位置</font></summary> <img src \"./assets/hardware/nano4k_update.jpg\"> </details> </body> <br> </html> <! ![nano4k_update](./assets/hardware/nano4k_update.jpg) > **Tang nano 9K** 2 个 **`测试点`** 位于PCB的 **TOP** 面的中间左侧，`USB C` 连接器后面。 <!DOCTYPE html> <html lang \"zh CN\"> <head> <meta charset \"UTF 8\"> <title>CSS Indentation</title> <style> .indent { margin left: 0ch; /* wide of 0 characters */ } </style> </head> <body> <details class \"indent\"> <summary><font color \"#4F84FF\">点击此处查看nano 9K的下载器测试点的位置</font></summary> <img src \"./assets/hardware/nano9k_update.jpg\"> </details> </body> <br> </html> <! ![nano9k_update](./assets/hardware/nano9k_update.jpg) > **Tang nano 20K** **`更新按钮`** 位于PCB的 **TOP** 面的 HDMI 连接器后面的，旁边有丝印 **`UPDATE`**。 <!DOCTYPE html> <html lang \"zh CN\"> <head> <meta charset \"UTF 8\"> <title>CSS Indentation</title> <style> .indent { margin left: 0ch; /* wide of 0 characters */ } </style> </head> <body> <details class \"indent\"> <summary><font color \"#4F84FF\">点击此处查看nano 20K的下载器测更新按钮的位置</font></summary> <img src \"./assets/hardware/nano20k_update.jpg\"> </details> </body> <br> </html> <! ![nano20k_update](./assets/hardware/nano20k_update.jpg) > #### **Tang Primer 系列** **Tang Primer 20K Dock** **`更新按钮`** 位于PCB的 **TOP** 面的 HDMI 连接器后面的，旁边有丝印 **`UPDATE`**。 <!DOCTYPE html> <html lang \"zh CN\"> <head> <meta charset \"UTF 8\"> <title>CSS Indentation</title> <style> .indent { margin left: 0ch; /* wide of 0 characters */ } </style> </head> <body> <details class \"indent\"> <summary><font color \"#4F84FF\">点击此处查看Primer 20K Dock的下载器测更新按钮的位置</font></summary> <img src \"./assets/hardware/Primer20k_update.jpg\"> </details> </body> <br> </html> <! ![Primer20k_update](./assets/hardware/Primer20k_update.jpg) > **Tang Primer 25K Dock** 2 个 **`测试点`** 位于PCB的 **BOT** 面的左上角，丝印标记为 `3V3` 和 `TDO`。 <!DOCTYPE html> <html lang \"zh CN\"> <head> <meta charset \"UTF 8\"> <title>CSS Indentation</title> <style> .indent { margin left: 0ch; /* wide of 0 characters */ } </style> </head> <body> <details class \"indent\"> <summary><font color \"#4F84FF\">点击此处查看Primer 25K Dock的下载器测试点的位置</font></summary> <img src \"./assets/hardware/Primer25k_update.jpg\"> </details> </body> <br> </html> <! ![Primer25k_update](./assets/hardware/Primer25k_update.jpg) > ~~**Tang Primer 15K Dock**~~（尚未发布） ***TBD*** <!DOCTYPE html> <html lang \"zh CN\"> <head> <meta charset \"UTF 8\"> <title>CSS Indentation</title> <style> .indent { margin left: 0ch; /* wide of 0 characters */ } </style> </head> <body> <details class \"indent\"> <summary><font color \"#4F84FF\">点击此处查看Primer 15K Dock的下载器测试点的位置</font></summary> <img src \"./assets/hardware/Primer15k_update.jpg\"> </details> </body> <br> </html> <! ![Primer15k_update](./assets/hardware/Primer15k_update.jpg) > #### **Tang MEGA 系列**（包含Tang Console） **Tang MEGA NEO Dock**（包含 Tang MEGA 138K Dock） **`更新按钮`** 位于 PCB 的 **TOP** 面 `USB C` 连接器下方，丝印标记为 **DEBUG USB2**。 <!DOCTYPE html> <html lang \"zh CN\"> <head> <meta charset \"UTF 8\"> <title>CSS Indentation</title> <style> .indent { margin left: 0ch; /* wide of 0 characters */ } </style> </head> <body> <details class \"indent\"> <summary><font color \"#4F84FF\">点击此处查看MEGA NEO Dock的下载器测更新按钮的位置</font></summary> <img src \"./assets/hardware/Mega neo_update.jpg\"> </details> </body> <br> </html> <! ![Mega neo_update](./assets/hardware/Mega neo_update.jpg) > **Tang MEGA 138K Pro Dock** **`更新按钮`** 位于 `USB C` 连接器的左侧，在PCB的 **TOP** 面标记为 **JATGUART**。 <!DOCTYPE html> <html lang \"zh CN\"> <head> <meta charset \"UTF 8\"> <title>CSS Indentation</title> <style> .indent { margin left: 0ch; /* wide of 0 characters */ } </style> </head> <body> <details class \"indent\"> <summary><font color \"#4F84FF\">点击此处查看MEGA 138K Pro Dock的下载器更新按钮的位置</font></summary> <img src \"./assets/hardware/Mega 138kpro_update.jpg\"> </details> </body> <br> </html> <! ![Mega 138kpro_update](./assets/hardware/Mega 138kpro_update.jpg) > **Tang Console** **`更新按钮`** 位于 `USB C` 连接器的另一侧，在 PCB 的 **TOP** 面，是两个按钮中较矮的一个，丝印标记为 **`BOOT`**。 <!DOCTYPE html> <html lang \"zh CN\"> <head> <meta charset \"UTF 8\"> <title>CSS Indentation</title> <style> .indent { margin left: 0ch; /* wide of 0 characters */ } </style> </head> <body> <details class \"indent\"> <summary><font color \"#4F84FF\">点击此处查看 Console 的下载器测试点的位置</font></summary> <img src \"./assets/hardware/Mega console_update.jpg\"> </details> </body> <br> </html> <! ![Mega console_update](./assets/hardware/Mega console_update.jpg) > *** ### 软件准备 首先从 [**BouffaloLab 官网**](https://dev.bouffalolab.com/download/) 下载 **BouffaloLabDevCube**，最新版本为 **`1.9.0`** (2025 年 2 月 10 日) <details> <summary><font color \"#4F84FF\">点击查看图片详情</font></summary> <img src \"./assets/download_bldc.jpg\"> </details> <br> <! ![download_BLDevCube](./assets/download_bldc.jpg) > 解压下载的内容，并执行相应的可执行文件，在 Windows 下是 **`BLDevCube.exe`** <details> <summary><font color \"#4F84FF\">点击查看图片详情</font></summary> <img src \"./assets/run_bldc.jpg\"> </details> <br> <! ![run_BLDevCube](./assets/run_bldc.jpg) > 在弹出的窗口中，选择芯片型号为 BL616/618 <details> <summary><font color \"#4F84FF\">点击查看图片详情</font></summary> <img src \"./assets/model sel_bldc.jpg\"> </details> <br> <! ![model sel_BLDevCube](./assets/model sel_bldc.jpg) > 在新窗口中，选中 ***Single download option*** 下方的 **`Enable`** 复选框。单击 **`Browse`** 按钮选择要更新的固件档案 <details> <summary><font color \"#4F84FF\">点击查看图片详情</font></summary> <img src \"./assets/mainw_bldc.jpg\"> </details> <br> <! ![mainwindow_BLDevCube](./assets/mainw_bldc.jpg) > 让板载调试器进入 **DFU模式**，它应该是 BL702 或 BL616 的 CDC ACM 设备。在 Windows 上这会注册一个新的 COM 端口，在此示例中为 **`COM12`** 关于如何让板载调试器进入 **DFU模式**，请参考上一章节[【点我跳转】](#硬件准备) 对于 Linux 用户，CDC ACM 通常注册为 `/dev/ttyACMx` 对于 macOS 用户，它可能注册为 `/dev/tty.usbmodemxxxx` 或`/dev/cu.usbmodemxxxx` （每个 `x` 代表一位数字） <details> <summary><font color \"#4F84FF\">点击查看图片详情</font></summary> <img src \"./assets/new_com port.jpg\"> </details> <br> <! ![new_com port](./assets/new_com port.jpg) > 然后设置 **BLDevCube**，如下所示。设置固件档案位置、DFU 模式的端口，然后单击 **`Open UART`**，最后单击 **`Create & Download`**。 <details> <summary><font color \"#4F84FF\">点击查看图片详情</font></summary> <img src \"./assets/set_bldc.jpg\"> </details> <br> <! ![setting_BLDevCube](./assets/set_bldc.jpg) > 等待下载完成，如下图所示绿色进度条到100%，下方 **log** 提示 **`[All Success]`** 即为下载完成 <details> <summary><font color \"#4F84FF\">点击查看图片详情</font></summary> <img src \"./assets/complete_bldc.jpg\"> </details> <br> <! ![download_complete](./assets/complete_bldc.jpg) > *** ### 确认结果 完成以上步骤后，我们需要确认板载调试器的固件是否烧录成功。通常重新插拔 USB 线或重新给板子上电即可确认。 在 Windows 中，可以在设备管理器中看到两个新设备：**`USB Converter A`** 和 **`USB Converter B`**。 <details> <summary><font color \"#4F84FF\">点击查看图片详情</font></summary> <img src \"./assets/ftdi_dual.jpg\"> </details> <br> <! ![dual_usbconverter](./assets/ftdi_dual.jpg) > 要确认调试器固件版本，请双击任意一个 **`USB Converter`**，然后转到“Details”选项卡。然后从下拉菜单中选择 **`父系`** 或 **`上层`** 选项： <details> <summary><font color \"#4F84FF\">点击查看图片详情</font></summary> <img src \"./assets/detail_usbconverter.jpg\"> </details> <br> <! ![detail_usbconverter](./assets/detail_usbconverter.jpg) > 如下图所示，最后 10 位数字 **`2025102315`** 是调试器固件版本的序列号。 Linux 和 macOS 用户可以使用命令 **`dmesg`** 检查内核日志中的序列号。 <details> <summary><font color \"#4F84FF\">点击查看图片详情</font></summary> <img src \"./assets/serialnum_usbconverter.jpg\"> </details> <br> <! ![serialnum_usbconverter](./assets/serialnum_usbconverter.jpg) > *** ### **Tang Core** 的额外说明 <details> <summary><font color \"#4F84FF\">点击查看详情</font></summary> <br> 对于支持[**Tang Core**](https://nand2mario.github.io/tangcore/)的开发板而言（如[Tang Console](../tang console/mega console)），其能正常执行[**Tang Core**](https://nand2mario.github.io/tangcore/)功能需要同时依赖[**调试器固件**](#最新固件)和二级启动的[**TangCore firmware for BL616**](https://github.com/nand2mario/firmware bl616/) 共计两个固件。 [**调试器固件**](#最新固件)可以在本页面下方找到，而二级启动的[**TangCore firmware for BL616**](https://github.com/nand2mario/firmware bl616/)目前由 **[nand2mario](https://github.com/nand2mario)** 负责维护，其最新版本可以在[**TangCore Release Package**](https://github.com/nand2mario/tangcore/releases)中找到。 [**调试器固件**](#最新固件)写入 **flash** 的起始地址为 `0x0`，而[**TangCore firmware for BL616**](https://github.com/nand2mario/firmware bl616/)写入 **flash** 的地址为 `0x40000`。 原始的安装文档可以在 [**这里**](https://nand2mario.github.io/tangcore/user guide/installation/#firmware installation) 找到。 请注意：对于 **BL616** 而言，只有版本 **`2025030317`** 及之后的[**调试器固件**](#最新固件)支持二级启动功能。 </details> ### 最新固件 所有Tang系列板载调试器的最新固件序列号记录在这里： 开发板型号 MCU 型号 下载链接 串号 SHA256 杂凑/校验 nano 1K BL702 N/A N/A N/A nano 4K BL702 N/A N/A N/A Nano 9K BL702 N/A N/A N/A Primer 20K BL702 N/A N/A N/A nano 20K BL616 [点我](https://api.dl.sipeed.com/TANG/Debugger/onboard/BL616/2025030317/bl616_fpga_partner_20kNano.bin) 2025030317 [bl616_fpga_partner_20kNano.sha256](https://api.dl.sipeed.com/TANG/Debugger/onboard/BL616/2025030317/bl616_fpga_partner_20kNano.sha256) Primer 25K BL616 [点我](https://api.dl.sipeed.com/TANG/Debugger/onboard/BL616/2025030317/bl616_fpga_partner_25kDock.bin) 2025030317 [bl616_fpga_partner_25kDock.sha256](https://api.dl.sipeed.com/TANG/Debugger/onboard/BL616/2025030317/bl616_fpga_partner_25kDock.sha256) Mega NEO BL616 [点我](https://api.dl.sipeed.com/TANG/Debugger/onboard/BL616/2025030317/bl616_fpga_partner_NeoDock.bin) 2025030317 [bl616_fpga_partner_NeoDock.sha256](https://api.dl.sipeed.com/TANG/Debugger/onboard/BL616/2025030317/bl616_fpga_partner_NeoDock.sha256) Mega 138K Pro BL616 [点我](https://api.dl.sipeed.com/TANG/Debugger/onboard/BL616/2025030317/bl616_fpga_partner_138kproDock.bin) 2025030317 [bl616_fpga_partner_138kproDock.sha256](https://api.dl.sipeed.com/TANG/Debugger/onboard/BL616/2025030317/bl616_fpga_partner_138kproDock.sha256) Console BL616 [点我](https://api.dl.sipeed.com/TANG/Debugger/onboard/BL616/2025041420/bl616_fpga_partner_Console.bin) 2025041420 [bl616_fpga_partner_Console.sha256](https://api.dl.sipeed.com/TANG/Debugger/onboard/BL616/2025041420/bl616_fpga_partner_Console.sha256) ### 故障排除 如果您在使用过程中遇到任何问题，或者对文档有任何意见或建议，请随时向我们反馈。联系方式如下。 **交流论坛: [maixhub.com/discussion](https://maixhub.com/discussion)** **QQ 交流群：[834585530](https://jq.qq.com/?_wv 1027&k wBb8XUan)** **Telegram** : [t.me/sipeed](t.me/sipeed) **Reddit** : [reddit.com/r/GowinFPGA/](reddit.com/r/GowinFPGA/) 商业邮箱 : [support@sipeed.com](support@sipeed.com) 直接本页下方留言 >在大多数情况下，对于MCU相关的问题 ***博流智能*** 的官方文档足以进行故障排除。[【点击这里】](https://dev.bouffalolab.com/document/)以访问相关文档。 ### 常见问题 #### 更新固件后，未出现 **`USB Converter A`** 和 **`USB Converter B`**，依旧显示一个 **`COM`** 端口 1. 可能是BL616 efuse内容异常，请联络售后以获取换货相关的支持。"},"/hardware/zh/tang/common-doc/get_started/flash_in_linux.html":{"title":"Linux 下烧录方法","content":" title: Linux 下烧录方法 keyeords: Linux, FPGA, Gowin ## openFPGAloader 在Ubuntu系统下我们建议使用**openFPGALoader**烧写，其他发行版尚未验证。以下为具体步骤 ### 安装openFPGALoader 参考：https://trabucayre.github.io/openFPGALoader/guide/install.html 直接在linux命令行执行下面命令即可 ```bash # preprocess sudo apt get install libftdi1 2 libftdi1 dev libhidapi hidraw0 libhidapi dev libudev dev zlib1g dev cmake pkg config make g++ # compile git clone https://github.com/trabucayre/openFPGALoader.git cd openFPGALoader mkdir build cd build cmake ../ #build cmake build . j$(nproc) # install sudo make install ``` ### 烧录方法 检测板卡 ```bash $ sudo ./openFPGALoader detect # 对于这行命令应当在你上一步执行make install的目录下执行 # 下面是正常执行后显示的log Jtag frequency : requested 6.00MHz > real 6.00MHz index 0: idcode 0x100481b manufacturer Gowin family GW1N model GW1N(R) 9C irlength 8 ``` 下载码流 ```bash $ sudo ./openFPGALoader b tangnano9k f ../../nano9k_lcd/impl/pnr/Tang_nano_9K_LCD.fs # 其中的 b 表示目标板型号，具体可以参考下面表格 # f 表示下载到 flash，不加的话会下载到 sram 中 # 最后的是需要烧录的文件，应该找到对应目录下的 .fs 文件 # 下面是成功执行后的log write to flash Jtag frequency : requested 6.00MHz > real 6.00MHz Parse file Parse ../../nano9k_lcd/impl/pnr/Tang_nano_9K_LCD.fs: Done DONE Jtag frequency : requested 2.50MHz > real 2.00MHz erase SRAM Done erase Flash Done write Flash: [ ] 100.00% Done CRC check: Success ``` 其中 b表示目标板型，可以使用以下取值： Board name FPGA Memory Flash tangnano GW1N 1 QN48 OK Internal Flash tangnano1k GW1NZ 1 QN48 OK Internal Flash tangnano4k GW1NSR 4C QN48 OK Internal Flash tangnano9k GW1NR 9C QN88P OK Internal Flash tangnano20k GW2AR 18C QN88 OK External Flash tangprimer20k GW2A 18C BGA256 OK External Flash tangprimer25k GW5A 25A BGA121 OK External Flash tangmega60k GW5AT 60B BGA484 OK External Flash tangmega138k GW5AT 138B/C BGA484 OK External Flash "},"/hardware/zh/tang/common-doc/get_started/install-the-ide.html":{"title":"安装 IDE","content":" title: 安装 IDE keywords: Sipeed, Gowin, Tang, Nano, fpga, 矽速 update: date: 2025 07 12 version: v1.3 author: MDLZCOOL content: 修复器件型号错误 date: 2025 04 24 version: v1.2 author: Serika content: 完善板卡/器件型号 添加在线Lic Server date: 2023 05 25 version: v1.1 author: wonder content: 更新到 Gowin 1.9.8.11 IDE 编辑 IDE 支持器件 date: 2022 09 19 version: v1.0 author: wonder content: 根据高云半导体下载链接新页面重新截图 去掉了替换 Programmer 相关操作说明 date: 2025 09 25 version: v1.1 author: Serika content: 修正了教育版相关的说明和支持的器件型号 增加了辨识器件版本的方法 使用高云半导体的 FPGA 需要用到 GOWIN 这个软件，对应的软件文档链接： <http://www.gowinsemi.com.cn/down.aspx?FId n14:14:26> 根据自己系统选择安装对应版本的 IDE 对于 Linux 系统下载固件可以使用 Openfpgaloader，可以查看本页底部的 [Linux 下烧录](#burn in linux) 来进行烧录操作。 ## 安装软件 ### 下载软件 前往 http://www.gowinsemi.com.cn/faq.aspx 下载 IDE。 由于高云半导体的IDE在不断的更新中，下图为 2023 年 09 月 25 日截图 ![IDE](./assets/IDE 1.png) IDE 分为商业版和教育版： 商业版的 IDE 需要 license，需要向高云半导体官方自行申请。 教育版 IDE 不需要 license，直接点击下载就可以了。 教育版所支持的器件如下： ![educational_device](./assets/educational_device.png) 高云半导体的IDE在不断的更新中，上图为 2023 年 05 月 25 日截图。 目前在售的Tang系列板卡的FPGA型号如下： 芯片名称 芯片系列 芯片型号 适用板卡 GW1NZ LV1QN48C6/I5 GW1NZ GW1NZ Nano 1K GW1NSR LV4CQN48PC6/I5 GW1NSR GW1NSR 4C Nano 4K GW1NR LV9QN88PC6/I5 GW1NR GW1NR 9C Nano 9K GW2AR LV18QN88C8/I7 GW2AR GW2AR 18C Nano 20K GW2A LV18PG256C8/I7 GW2A GW2A 18C Primer 20K GW5AT LV15MG132C1/I0 GW5AT GW2A 15A Primer 15K GW5A LV25MG121NC1/I0 GW5A GW5A 25A Primer 25K GW5AT LV60PG484AC1/I0 GW5AT GW5AT 60B NEO/Console 60K GW5AST LV138PG484AC1/I0 GW5AST GW5AST 138B/C NEO/Console 138K GW5AST LV138FPG676AC1/I0 GW5AST GW5AST 138B/C Mega 138K Pro 上表中的板卡，除了 **Mega 138K Pro** 以外，均可在教育版的 IDE 中使用。 ~~对于购买了 Tang Nano （板载 jtag 芯片为 CH552），目前需要使用商业版的 IDE 且需要自行向高云半导体官方申请 license。~~ **Tang Mega 138K Pro** 目前需要使用商业版的 IDE 且需要自行向高云半导体官方申请 license。 **注意事项** 目前138K 的两种封装（PG484A 和 FPG676A）在2025年7月后芯片型号均由GW5AST 138B变更为GW5AST 138C，老的B步进的FPGA原厂已停产。 C步进的138K在IDE中需要选择 **Device Version: C**，不然无法使用SSRAM & 可能会有奇怪的兼容性问题。 **如何分辨器件辨步进** FPGA镭雕印记的第三行第五位，如果是字母 **C** 就是**Device Version: C**，如果是字母 **B** 就是**Device Version: B**。 这个方法适用于所有的 **GOWIN FPGA**。 <!DOCTYPE html> <html lang \"zh CN\"> <head> <meta charset \"UTF 8\"> <title>CSS Indentation</title> <style> .indent { margin left: 0ch; /* wideof 0 characters */ } </style> </head> <body> <details class \"indent\"> <summary><font color \"#4F84FF\">点击此处查看138K C PG484A器件版本印记</font></summary> <img src \"./assets/138K Ver.C.png\"> </details> </body> <br> </html> <!DOCTYPE html> <html lang \"zh CN\"> <head> <meta charset \"UTF 8\"> <title>CSS Indentation</title> <style> .indent { margin left: 0ch; /* wideof 0 characters */ } </style> </head> <body> <details class \"indent\"> <summary><font color \"#4F84FF\">点击此处查看138K B PG484A器件版本印记</font></summary> <img src \"./assets/138K Ver.B.png\"> </details> </body> <br> </html> <!DOCTYPE html> <html lang \"zh CN\"> <head> <meta charset \"UTF 8\"> <title>CSS Indentation</title> <style> .indent { margin left: 0ch; /* wideof 0 characters */ } </style> </head> <body> <details class \"indent\"> <summary><font color \"#4F84FF\">点击此处查看138K B FPG676A器件版本印记</font></summary> <img src \"./assets/138K Pro Ver.B.png\"> </details> </body> <br> </html> ### 开始安装 #### macOS 对于 macOS，只需下载 macOS 版 IDE 的 DMG 镜像，双击 DMG 文件进行挂载，然后将 `GOWIN_IDE.app` 拖放到您的 `Application` 文件夹中。 由于 GOWIN IDE DMG 镜像未签名，它可能会被 macOS Gatekeeper 拦截。要继续，您需要手动允许其运行。出现警告对话框时，请打开“系统设置”→“隐私和安全”，然后点击 “仍然打开”。 或者，您也可以通过终端使用以下命令移除 DMG 的隔离属性： ```zsh xattr c <path to dmg> ``` 之后，双击 DMG 进行挂载并运行。 #### Linux 系统 Linux 版本 IDE 下载解压后，打开 `IDE/bin` 文件夹，然后可执行文件 `gw_ide` 就在所解压路径的 `/IDE/bin/` 文件夹中，用命令行来运行即可；运行软件失败的话记得改软件的可执行权限 `chmod + x`。 #### Windows 系统 下载相应的 IDE 之后所得到的是一个压缩包程序；对于 Windows 版本的解压后里面是一个可执行程序，双击安装继续下面的步骤就行。下面的所有安装步骤均为 Windows 平台： <div class \"imbox\"> <img src \"./assets/IDE 2.png\" width 45%> <img src \"./assets/IDE 3.png\" width 45%> </div> 下图的两个都需要安装上。其中的 Gowin 为 IDE 本体， 另一个 programmer 相关的是烧录软件。 因为我们的下载器与 IDE 附带安装的 Programmer 可能不太兼容，使用中有问题的话可以前往 <a href \"./../questions.html#下载失败\" target \"blank\">programmer 相关里的下载失败</a> 来查看对应方法。 <! 由于我们所提供下载器会与新版的 IDE 不太兼容，因此建议前往 <a href \"./../questions.html#下载失败\" target \"blank\">programmer 相关里的下载失败</a> 来查看对应方法。 > <img src \"./assets/IDE 4.png\" width 50%> 下图的安装路径个人按照自己需要设置 <img src \"./assets/IDE 5.png\" width 50%> 安装中... <img src \"./assets/IDE 6.png\" width 50%> 下面这一步不要更改任何东西，按照默认的点击`Finish`就行，紧接着就是安装相关的驱动 <img src \"./assets/IDE 7.png\" width 50%> 上面的`Finish`后会出现下面的内容，这是安装驱动的。 <html> <div class \"imbox\"> <img src \"./assets/IDE 8.png\" width 45%> <img src \"./assets/IDE 9.png\" width 45%> </div> </html> 这里需要选择接受协议才能继续安装 <html> <div class \"imbox\"> <img src \"./assets/IDE 10.png\" width 45%> <img src \"./assets/IDE 11.png\" width 45%> </div> </html> 点击完成后桌面上会出现下面的图标 ![IDE](./assets/IDE 12.png) 到这里我们就完成了软件的安装 ## 使用 IDE ### license 相关 教育版本的 IDE 直接运行即可； 商业版的 IDE 需要自行前往 [点我](http://www.gowinsemi.com.cn/faq_view.aspx) 申请 license 后才能使用，其中申请license 时 MAC 最好填写本机的以太网网卡地址，避免以后可能因部分设置而导致 MAC 地址改变 license 验证失败。 ### 验证 license 打开高云半导体 IDE 的时候，在弹出的 license 管理中，选择自己本地 license 的文件，验证保存即可。 <img src \"./assets/IDE 13.png\" alt \"Broswer lic\" width 45%> <img src \"./assets/check.png\" alt \"Check lic\" width 45%> 然后就可以开始使用高云半导体 IDE 了。 Lic 可以在高云官网申请，或者使用Sipeed提供的在线Lic服务，在IDE中选择Float Lic，填写以下信息即可： ~~~ Server 01 ip: 106.55.34.119 port: 10559 ~~~ 如果上面的IP不能工作, 尝试使用 \"gowinlic.sipeed.com\" 域名对应的IP. ### Programmer <! 在烧录 FPGA 的时候可能因为安装 IDE 时所安装的 Programmer 软件不兼容我们所提供的下载器，因此对于 Windows 用户要求使用我们所提供的特定版本的 Programmer 软件，[点我](https://dl.sipeed.com/shareURL/TANG/programmer)跳转下载即可； > 如果下载固件失败的话，可以手动下载一下 Programmer 软件（云源编程器）来试试 [跳转地址](https://www.gowinsemi.com.cn/software/1) ![programmer_download](./assets/Gowin_Official_programmer_dl.png) 对于 Linux 用户可以用 Openfpgaloader, 查看本页最底部的相关说明即可。 ## 拓展 License 可以在高云官网申请，或者使用Sipeed提供的在线Lic服务，在IDE中选择Float Lic，填写以下信息即可： ~~~ Server 01 ip: 106.55.34.119 port: 10559 ~~~ 如果上面的IP不能工作, 尝试使用 \"gowinlic.sipeed.com\" 域名对应的IP. 获取 license 可能需要等待一段时间。在此期间可以看看高云半导体的官方文档。下面简单说明一下： 在 IDE 的安装路径下主要有如下内容：IDE 文件夹、Programmer 文件夹、uninst.exe； ![ide_folder](./assets/ide_folder.png) **IDE** 文件夹：这里主要说一下里面的 **doc** 文件夹，用户在安装完之后可以在这个文件夹里面看到高云提供的大多数文档高云半导体，主要内容如下图所示： ![IDE](./assets/doc folder.png) **Programmer** 文件夹：里面是烧录软件，也有相关的文档。 ![programmer](./assets/programmer folder.png) **uninst.exe**：卸载IDE <! ## 其他安装方法 下面是高云半导体官方所提供的 IDE 安装方法，有需要的话可以自行查阅 + [高云半导体软件简介和安装](http://cdn.gowinsemi.com.cn/%E9%AB%98%E4%BA%91%E8%BD%AF%E4%BB%B6%E7%AE%80%E4%BB%8B%E5%92%8C%E5%AE%89%E8%A3%85.pdf) > ## Burn in linux [Linux系统下烧录方法](./flash_in_linux)"},"/hardware/zh/tang/common-doc/index.html":{"title":"Tang Nano","content":"# Tang Nano ## 什么是 Tang Nano Tang Nano 是基于高云半导体小蜜蜂系列 GW1N 1 FPGA 的简约型开发板。 板载芯片为 GW1N LV1QN48C6/I5，搭载了 1152 LUT4 的逻辑资源，1 PLL 和 4 Block 合计 72Kbit SRAM，封装为 QFN48。开发板引出了所有 I/O 接口，适用于小型数字逻辑的设计和实验。 板载 64Mbits PSRAM，为 FPGA 提供了丰富的存储资源。 同时，该开发板具有 RGB接口，能够与 LCD屏、VGA转换器 等外设连接，非常适合于屏幕显示等类型的应用。 板子板载 24MHz 晶振和 USB转JTAG下载器，能够容易的连接电脑进行开发，而不需要外部的调试器和时钟输入。板载的 RGB LED 可用于指示和调试，同时 FPGA IOBANK 分组可调的IO电平使得开发板能够容易的对外部各种不同电平规范的器件接口。 **板载资源:** + GW1N 1 + 64Mbit QSPI PSRAM + RGB LED + RGB LCD 40P接口及驱动电路 + 24MHz晶振 + USB调试器，基于Type C通讯接口 ## 引脚定义 ![Nano 引脚](./assets/tang_nano_pinout_v1.0.0_w5676_h4000_large.png) ## 资源下载链接 + [高云半导体官方下载站](http://www.gowinsemi.com.cn/faq.aspx) + [下载站](http://dl.sipeed.com/TANG/Nano) + [Tang Nano 原理图](https://dl.sipeed.com/shareURL/TANG/Nano/HDK)"},"/hardware/zh/tang/common-doc/examples.html":{"title":"Tang Nano 系列例程","content":" title: Tang Nano 系列例程 tags: Tang Nano, example, guide keywords: Tang Nano，example update: date: 2023 01 09 author: wonder content: 添加 Tang Nano 9K Lushay Labs 跳转链接 ## 前言 基本上手使用和相关的历程 ## Tang Nano > 板载下载器为CH552 Github: https://github.com/sipeed/Tang Nano examples [点灯例程](./../Tang Nano/examples/1_led) [驱屏教程](./../Tang Nano/examples/2_lcd) ## Tang Nano 1K Github: https://github.com/sipeed/TangNano 1K examples [点灯例程](./../Tang Nano 1K/examples/LED) [驱屏教程](./../Tang Nano 1K/examples/LCD) ## Tang Nano 4K Github: https://github.com/sipeed/TangNano 4K example [点灯例程](./../Tang Nano 4K/examples/LED) （快速上手） [按键标志点灯](https://github.com/sipeed/TangNano 4K example/tree/main/key_blink)(github) [HDMI显示工程](https://github.com/sipeed/TangNano 4K example/tree/main/hdmi_720p)(github) [HDMI 显示摄像头内容](https://github.com/sipeed/TangNano 4K example/tree/main/camera_hdmi)(github) 在Nano 4K上运行GBA的工程：https://github.com/Martoni/GbHdmi litex 在 4K 支持：https://github.com/litex hub/litex boards 其他： 使用 Cortex M3 点灯例程：[Github](https://github.com/verilog indeed/gowin_fpga_tutorials) (英文) ## Tang Nano 9K Github: https://github.com/sipeed/TangNano 9K example [点灯例程](./../Tang Nano 9K/examples/LED) [驱RGB屏教程](./../Tang Nano 9K/examples/LCD) [PicoRV 在9K上运行的示例](./../Tang Nano 9K/examples/picorv) [FPGA驱动1.14 SPI屏幕工程](./../Tang Nano 9K/examples/spi_lcd) HDMI 示例：参考 [PicoRV 在9K上运行的示例](./../Tang Nano 9K/examples/picorv) litex 在 9K 支持：https://github.com/litex hub/litex boards [Lushay Labs](https://lushaylabs.com/) 有意做以太网、图形卡或者双核处理器的 FPGA 开发教程计划，有意者可以阅读本文末尾处他们提供的 [部分教程](#lushay labs) 来了解他们。有兴趣参与项目的话可以发邮件到 `contact@lushaylabs.com` ## Tang Nano 20K Github: https://github.com/sipeed/TangNano 20K example [开箱使用](https://wiki.sipeed.com/hardware/zh/tang/tang nano 20k/example/unbox.html) [点灯例程](https://wiki.sipeed.com/hardware/zh/tang/tang nano 20k/example/led.html) ## 哔哩哔哩视频 > 感谢 [ZQ坐看云起时](https://space.bilibili.com/375786914) 友情制作 <table> <tr><td><a href \"https://www.bilibili.com/video/BV1Jv4y1Q7u6/\" target \"_blank_\">TANG NANO 9K 开发板应用《1: 云源IDE安装》</a></td></tr> <tr><td><a href \"https://www.bilibili.com/video/BV1MK411z7it/\" target \"_blank_\">TANG NANO 9K 开发板应用《2: 云源软件基本使用》</a></td></tr> <tr><td><a href \"https://www.bilibili.com/video/BV1HW4y1K7mT/\" target \"_blank_\">TANG NANO 9K 开发板应用《3: 新建FPGA工程》</a></td></tr> <tr><td><a href \"https://www.bilibili.com/video/BV19d4y1h7CQ/\" target \"_blank_\">TANG NANO 9K 开发板应用《4：时钟分频器使用之IP调用法》</a></td></tr> <tr><td><a href \"https://www.bilibili.com/video/BV1YA411X7Tt/\" target \"_blank_\">TANG NANO 9K 开发板应用《5：时钟分频器使用之直接例化法》</a></td></tr> <tr><td><a href \"https://www.bilibili.com/video/BV1z24y1S7MX/\" target \"_blank_\">TANG NANO 9K 开发板应用《6：38译码器设计与测试》</a></td></tr> <tr><td><a href \"https://www.bilibili.com/video/BV19Y411m7XN/\" target \"_blank_\">TANG NANO 9K 开发板应用《7：高云逻辑分析仪之配置篇》</a></td></tr> <tr><td><a href \"https://www.bilibili.com/video/BV1m24y1S7f2/\" target \"_blank_\">TANG NANO 9K 开发板应用《8：高云逻辑分析仪之使用篇》</a></td></tr> <tr><td><a href \"https://www.bilibili.com/video/BV1dR4y1U7pJ/\" target \"_blank_\">TANG NANO 9K 开发板应用《9：存储器BSRAM使用方法介绍》</a></td></tr> <tr><td><a href \"https://www.bilibili.com/video/BV1bv4y1i7Ez/\" target \"_blank_\">TANG NANO 9K 开发板应用《10：高云逻辑分析仪调试BSRAM》</a></td></tr> <tr><td><a href \"https://www.bilibili.com/video/BV1L24y1i7k8/\" target \"_blank_\">TANG NANO 9K 开发板应用《11：BSRAM设置初始化数据》</a></td></tr> <tr><td><a href \"https://www.bilibili.com/video/BV1y8411K7ey/\" target \"_blank_\">TANG NANO 9K 开发板应用《12：基于BSRAM的pROM使用》</a></td></tr> <tr><td><a href \"https://www.bilibili.com/video/BV1hK411y7a4/\" target \"_blank_\">TANG NANO 9K 开发板应用《13：输入时钟CLK信号捕获技巧》</a></td></tr> <tr><td><a href \"https://www.bilibili.com/video/BV1V8411w7rw/\" target \"_blank_\">TANG NANO 9K 开发板应用《14：基于ST7789芯片1.14寸LCD屏幕驱动》</a></td></tr> <tr><td><a href \"https://www.bilibili.com/video/BV1534y1f75w/\" target \"_blank_\">TANG NANO 9K 开发板应用《15：基于ST7789芯片LCD寄存器配置和显示》</a></td></tr> <tr><td><a href \"https://www.bilibili.com/video/BV1Ld4y1n7R4/\" target \"_blank_\">TANG NANO 9K 开发板应用《16: 1.14寸LCD图片显示实验》</a></td></tr> <tr><td><a href \"https://www.bilibili.com/video/BV1C84y1n7mb/\" target \"_blank_\">TANG NANO 9K 开发板应用《17: 1.14寸LCD图片滚动实验》</a></td></tr> <tr><td><a href \"https://www.bilibili.com/video/BV11N411F7i1/\" target \"_blank_\">TANG NANO 9K 开发板应用《18：手搓简易标准SPI驱动及仿真》</a></td></tr> <tr><td><a href \"https://www.bilibili.com/video/BV1qs4y1V7D4/\" target \"_blank_\">TANG NANO 9K 开发板应用《19：SPI读flash P25Q32HS/W25Q32 芯片ID实验》</a></td></tr> <tr><td><a href \"https://www.bilibili.com/video/BV1ck4y1h7KZ/\" target \"_blank_\">TANG NANO 9K 开发板应用《20：SPI读写/擦除P25Q32HS/W25Q32实验》</a></td></tr> <tr><td><a href \"https://www.bilibili.com/video/BV1Nx4y1A7E7/\" target \"_blank_\">TANG NANO 9K 开发板应用《21：串口发送模块的实现》</a></td></tr> <tr><td><a href \"https://www.bilibili.com/video/BV1yL411S7T5/\" target \"_blank_\">TANG NANO 9K 开发板应用《22：串口接收模块的实现》</a></td></tr> <tr><td><a href \"https://www.bilibili.com/video/BV1xM411T7kv/\" target \"_blank_\">TANG NANO 9K 开发板应用《23：环形队列(FIFO)的实现》</a></td></tr> <tr><td><a href \"https://www.bilibili.com/video/BV1Xh4y1p7x7/\" target \"_blank_\">TANG NANO 9K 开发板应用《24：串口转SPI操作flash》</a></td></tr> <tr><td><a href \"https://www.bilibili.com/video/BV1rc411J7vP/\" target \"_blank_\">TANG NANO 9K 开发板应用《25：串口转SPI文件传输上位机》</a></td></tr> <tr><td><a href \"https://www.bilibili.com/video/BV1BM4y1t7xu/\" target \"_blank_\">TANG NANO 9K 开发板应用《26：PWM》</a></td></tr> </table> <table> <tr><td><a href \"https://www.bilibili.com/video/BV1iA411R7Zi/\" target \"_blank_\">iverilog + gtkwave 开源仿真工具《1：软件安装篇》</a></tr></td> <tr><td><a href \"https://www.bilibili.com/video/BV18y4y1R7eu/\" target \"_blank_\">iverilog + gtkwave 开源仿真工具《2：计数器仿真实验》</a></tr></td> </table> ## 其他上手说明 Tang Nano 9K 合作代理教程(英文)： ### Lushay Labs <a href \"https://learn.lushaylabs.com/tang nano series/\"><img src \"./assets/lushaylab_logo.png\" alt \"lushaylab_logo\" width \"35%\"></a> 1. [Installation & Getting Started](https://learn.lushaylabs.com/getting setup with the tang nano 9k/) 2. [Debugging & UART](https://learn.lushaylabs.com/tang nano 9k debugging/) 3. [OLED 101](https://learn.lushaylabs.com/tang nano 9k graphics/) 4. [Creating a Text Engine](https://learn.lushaylabs.com/tang nano 9k creating a text engine/) 5. [Data Conversion & Visualization](https://learn.lushaylabs.com/tang nano 9k data visualization/) 6. [Reading from the External Flash](https://learn.lushaylabs.com/tang nano 9k reading the external flash/) 7. [Generating Random Numbers](https://learn.lushaylabs.com/tang nano 9k generating random/) 8. [Sharing Resources](https://learn.lushaylabs.com/tang nano 9k sharing resources/) 9. [I2C, ADC and Micro Procedures](https://learn.lushaylabs.com/i2c adc micro procedures/) 10. [Our First CPU](https://learn.lushaylabs.com/tang nano 9k first processor/) ## 结语 有问题可以在相关页面下面留言，或者加入 QQ 群讨论，常见问题已被收录。 QQ 群：834585530 常见问题: [点我](https://wiki.sipeed.com/hardware/zh/tang/common doc/questions.html)"},"/hardware/zh/tang/common-doc/SUMMARY.html":{"title":"Summary","content":" title: Summary Tang nano系列开发板是基于[高云半导体](http://www.gowinsemi.com.cn/)FPGA设计的开发板，多种型号刚好可以满足不同的需求： Tang nano 1K 用极低的价格来让用户带领用户踏入FPGA领域 Tang nano 4K 带有一个Cortex m3的硬核，几乎是用户可以购买到的最低价的异构开发板 Tang nano 9K 配有极其丰富数量的逻辑单元，可以让用户在上面运行软核 ## 横向对比 型号 Tang Nano 1K Tang Nano 4K Tang Nano 9K 图片 ![Generated](./../Tang Nano/assets/clip_image002.gif) ![Generated](./../Tang Nano/assets/clip_image004.gif) ![Generated](./../Tang Nano/assets/clip_image006.gif) 逻辑单元（LUT4） 1152 4608 8640 硬核处理器 无 Cortex M3 无 有源晶振 27Mhz 27Mhz 27Mhz 显示接口 常见RGB屏幕接口 HDMI HDMI<br> 常见RGB屏幕接口<br> SPI屏幕接口 摄像头 无 可选OV2640 无 外置SPI FLASH 仅预留焊盘 默认焊接<br>32Mbit SPI FLASH 默认焊接<br>32Mbit SPI FLASH TF卡座 无 无 有 下载器 板载USB JTAG下载器 板载USB JTAG下载器 板载USB JTAG下载器&<br>USB UART通信接口 ## 准备 [IDE安装](./get_started/install the ide)"},"/hardware/zh/tang/common-doc/questions.html":{"title":"常见问题","content":" title: 常见问题 tags: Tang keywords: Programmer desc: update: date: 2022 06 29 version: v0.1 author: wonder content: 初次编写 date: 2022 09 23 version: v0.2 author: wonder content: 更新部分过期内容 date: 2022 10 19 version: v0.3 author: wonder content: 增加设置顶层相关说明 date: 2023 02 23 version: v0.4 author: wonder content: 补充 programmer 相关的说明 date: 2025 02 18 version: v0.5 author: Serika content: Primer系列和MEGA系列 相关的说明 增加更新板载调试器的内容跳转 date: 2023 05 18 version: v0.5 author: wonder content: 补充 programmer 相关的说明 date: 2023 09 30 version: v0.6 author: serika content: 补充 Device Version 相关的说明 这里汇总一些常见问题。 ## 器件相关 ### 如何分辨器件辨版本 FPGA镭雕印记的第三行第五位，如果是字母 **A** 就是**Device Version: A**，如果是字母 **B** 就是**Device Version: B** ，如果是字母 **C** 就是**Device Version: C**，以此类推。 这个方法适用于所有的 **GOWIN FPGA**，下图以138K Pro的 **GW5AST** 为例说明器件步进的标记位置。 <!DOCTYPE html> <html lang \"zh CN\"> <head> <meta charset \"UTF 8\"> <title>CSS Indentation</title> <style> .indent { margin left: 0ch; /* wideof 0 characters */ } </style> </head> <body> <details class \"indent\"> <summary><font color \"#4F84FF\">点击此处查看138K B FPG676A器件版本印记</font></summary> <img src \"./get_started/assets/138K Pro Ver.B.png\"> </details> </body> <br> </html> ## Programmer 相关 首先确定设备管理器中有两个 `converter` 设备和一个 `COM` 设备，这说明设备正常连接到电脑并且电脑成功加载驱动了。 <details> <summary><font color \"#4F84FF\">点开查看图片详情</font></summary> <img src \"./assets/qusetions/tang_bl702_device_convertor.png\"> </details> <! ![tang_bl702_device_convertor](./assets/qusetions/tang_bl702_device_convertor.png) > > 下载器都有 串口 和 Jtag 功能，但是要注意的是在使用串口的时候， Jtag 功能是不能用的。解决串口占用这种情况，重新插拔一下板卡的 USB 数据线就好了。 ### 只有两个 `convertor` <details> <summary><font color \"#4F84FF\">点开查看图片详情</font></summary> <img src \"./assets/qusetions/tang_bl702_device_convertor_no_com.png\"> </details> <! ![tang_bl702_device_convertor_no_com](./assets/qusetions/tang_bl702_device_convertor_no_com.png) > 如果出现没有 `COM` 设备但是有两个 `converter` 设备，可以 `鼠标右键点击` `converter B` > `属性` > `高级` > `加载 VCP` ，然后点击 `OK` ，重新插拔一下 USB 数据线就行了。 <details> <summary><font color \"#4F84FF\">点开查看图片详情</font></summary> <img src \"./assets/qusetions/tang_bl702_device_convertor_load_vcp.png\"> </details> <! ![tang_bl702_device_convertor_load_vcp](./assets/qusetions/tang_bl702_device_convertor_load_vcp.png) > ### 没有 `convertor` 调试器连接电脑后，需要十多秒时间加载驱动。不想等待加载驱动的话可以手动下载驱动并安装驱动 [点我跳转到驱动下载页面](https://dl.sipeed.com/shareURL/TANG/programmer)。 <details> <summary><font color \"#4F84FF\">点开查看图片详情</font></summary> <img src \"./assets/qusetions/no_convertor_install_driver.png\"> </details> <! ![no_convertor_install_driver](./assets/qusetions/no_convertor_install_driver.png) > ### 有 `convertor`，但是出现了感叹号（错误） <details> <summary><font color \"#4F84FF\">点开查看图片详情</font></summary> <img src \"./assets/convertor_with_error.png\"> </details> <! ![convertor_with_error](./assets/convertor_with_error.png) > 0. 感叹号可能是单一的 `USB Serial Conveter A` 或 `B`，也可能二者都有； 1. 请尝试上方所有的建议，卸载并重新安装FTDI驱动； 2. 如果上述方法都没有用，请尝试更新板载调试器的固件，参考[这篇指南](./update_debugger)。 ### 下载频率 要注意下载频率应该为 **`2.5M`** 或者更低的数值。不然很可能导致下载极其缓慢或者下载失败等问题。 <details> <summary><font color \"#4F84FF\">点开查看图片详情</font></summary> <img src \"./../assets/questions/cable.png\"> </details> <! <img src \"./../assets/questions/cable.png\"> > 点击下图中的 Frequency，设置频率小于或者等于 **`2.5M`** <details> <summary><font color \"#4F84FF\">点开查看图片详情</font></summary> <img src \"./../assets/questions/frequency.png\"> </details> <! <img src \"./../assets/questions/frequency.png\" > > 接着再点击 Save 即可 ### Error found <! 没有扫描到下载器或者驱动错误，要求使用 [这里](https://dl.sipeed.com/shareURL/TANG/programmer) 的压缩包文件。 下载后解压替换掉 Gowin IDE 对应安装目录的 Programmer 文件夹即可。 不会替换的话可以在下载解压后的 Programmer 程序中手动添加对应下载文件来进行烧录。 > <! 替换下载器软件后出现这个问题的话， > 确定设备管理器中的 `convertor` 和 `COM` 都存在时，可以先重启一下 programmer 软件。 ### Cable lost 这种情况一般是因为在烧录固件时，因为数据线与开发板连接不稳定导致的。可以重新烧录一下。 ### Cabel open failed <details> <summary><font color \"#4F84FF\">点开查看图片详情</font></summary> <img src \"./assets/qusetions/cable_open_failed.png\"> </details> <! ![cable_open_failed](./assets/qusetions/cable_open_failed.png) > 在板卡通电的时候需要 2~3s 时间来加载驱动，加载成功后电脑设备管理器中会显示出两个 converter 设备，这个时候就可以正常烧录了。 <details> <summary><font color \"#4F84FF\">点开查看图片详情</font></summary> <img src \"./../assets/questions/converter.png\"> </details> <! ![converter](./../assets/questions/converter.png) > 这里的意思是没有找到下载器，可以尝试使用高云半导体所提供的最新的教育版的编程器 [点我跳转](http://www.gowinsemi.com.cn/faq.aspx) 来尝试解决老版本 Programmer 软件的 bug。 使用新版本下载器后出现这个问题的话，可以先重启一下 programmer 软件；依旧没找到的话可以看看本篇开头的 converter 相关的内容。 <details> <summary><font color \"#4F84FF\">点开查看相关说明</font></summary> <img src \"./assets/educational_edition_programmer.png\"> </details> <! ![educational_edition_programmer](./../tang primer 20k/assets/start/educational_edition_programmer.png) > <! 参考上一步 No Gowin devices found 的操作后，再 programmer 里面进行下面操作： 点击顶部菜单栏的 Edit >Cable Setting >Cable >Query，然后 Save 即可 <details> <summary><font color \"#4F84FF\">点开查看操作步骤图片</font></summary> <img src \"./../assets/questions/cable.png\"> <p>点击下图中的 Query</p> <img src \"./../assets/questions/click_query.png\" > <p>接着再点击 Save 即可</p> </details> > ### No Gowin devices found <details> <summary><font color \"#4F84FF\">点开查看详情图片</font></summary> <img src \"./assets/qusetions/no_gowin_device_found.png\"> </details> <! ![no_gowin_device_found](./assets/qusetions/no_gowin_device_found.png) > 这里指的是没有扫描到高云设备，可以尝试使用高云半导体所提供的最新的教育版的编程器[【点我跳转】](http://www.gowinsemi.com.cn/faq.aspx)来尝试解决老版本 Programmer 不识别 Tang JTAG 的问题。 <details> <summary><font color \"#4F84FF\">点开查看图片详情</font></summary> <img src \"./assets/educational_edition_programmer.png\"> </details> <! ![educational_edition_programmer](./assets/educational_edition_programmer.png) > #### Nano 9K Nano 9K 在设计的时候将 JTAG_SEL 引脚连接到了 S2 按键上，根据高云手册可以知道 JTAGSEL_N 0 的时候，芯片的 Jtag 引脚可以正常使用。 <details> <summary><font color \"#4F84FF\">点开查看相关说明</font></summary> <img src \"./assets/qusetions/jtag_sel_function.jpg\"> </details> <! ![jtag_sel_function](./assets/qusetions/jtag_sel_function.jpg) > 在使用 Programmer 对 Nano 9K FPGA 板卡进行操作的时候按住 S2 按键就可以了。 #### Primer 20K 20K Dock 套件要注意拨动拨码开关使能核心板后，下载软件才可以通过底板识别到底板所插入的核心板。 <details> <summary><font color \"#4F84FF\">点开查看图片详情</font></summary> <table> <thead> <tr> <th>使能核心板</th> <th>未使能状态</th> <th>补充说明</th> </tr> </thead> <tbody> <tr> <td><img src \"./../tang primer 20k/assets/start/switch_1_on.png\" alt \"switch_1_on\" width \"100%\"></td> <td><img src \"./../tang primer 20k/assets/start/reset_led_on.png\" alt \"reset_led_on\" width \"100%\"></td> <td>未使能核心板的话板子上的 0、1 号 LED 会一直亮着，且核心板不会正常启动。</td> </tr> </tbody> </table> </details> <! 使能核心板 未使能状态 补充说明 <img src \"./../tang primer 20k/assets/start/switch_1_on.png\" alt \"switch_1_on\" width 100%><img src \"./../tang primer 20k/assets/start/reset_led_on.png\" alt \"reset_led_on\" width 100%> 未使能核心板的话板子上的 0、1 号 LED 会一直亮着，且核心板不会正常启动。 > >单独使用 20K 核心板和 RV Debugger Plus 下载器来下载固件出现这个错误时，可能是接线错了，自己根据下面的表格检查一下线序，或者检查一下核心板的 8pin 接口有没有被怼歪（有一次连接失败，发现是引脚歪了然后连接不上下载器了；不要大力出奇迹）。 20K 核心板 JTAG 引脚定义可以在背部看到。 <table> <tr> <td>核心板</td> <td>5V0</td> <td>TMS</td> <td>TDO</td> <td>TCK</td> <td>TDI</td> <td>RX</td> <td>TX</td> <td>GND</td> </tr> <tr> <td>调试器</td> <td>5V0</td> <td>TMS</td> <td>TDO</td> <td>TCK</td> <td>TDI</td> <td>TX</td> <td>RX</td> <td>GND</td> </tr> </table> <details> <summary><font color \"#4F84FF\">点开查看接线详情</font></summary> <img src \"./../tang primer 20k/examples/assets/led_assets/cable_connect.png\"> </details> <! ![cable_connect](./../tang primer 20k/examples/assets/led_assets/cable_connect.png) > 对于 20K 板卡来说可能是因为 JTAG 复用而导致主控芯片的 JTAG 引脚不再能被调试，[点我](./../tang primer 20k/primer 20k.html#dock 底板不工作)来查看相应解决办法 ### ID code mismatch <details> <summary><font color \"#4F84FF\">点开查看相关说明</font></summary> <img src \"./assets/qusetions/id_code_mismatch.png\"> </details> 这种情况是工程文件设置的芯片与实际下载芯片型号不一致而造成的。 重新设置工程中的芯片型号（比如工程设置、引脚约束、各个IP中的型号）。 板卡型号 芯片系列 芯片设备 封装 速度等级 Tang Nano GW1N GW1N 1 QN48 C6/I5 Tang Nano 1K GW1NZ GW1NZ 1 QN48 C6/I5 Tang Nano 4K GW1NSR GW1NSR 4C QN48P C6/I5 或者 C7/I6 Tang Nano 9K GW1NR GW1NR 9C QN88P C6/I5 Tang Nano 20K GW2AR GW2AR 18C QN88 C8/I7 Tang Primer 20K GW2A GW2A 18C PBGA256 C8/I7 Tang Primer 25K GW5A GW5A 25A MBGA121N C1/I0 Tang MEGA 60K GW5AT GW5AT 60B PG484A C1/I0 Tang MEGA 138K GW5A(S)T GW5AT 138B PG484A C1/I0 Tang MEGA 138K Pro GW5AST GW5AT 138B FPG676A C1/I0 <! <details> <summary><font color \"#4F84FF\">点开查看正确型号选择</font></summary> <p>Nano 9K 应当选择的型号</p> <img src \"./../Tang Nano 9K/nano_9k/Tang_nano_9k_Device_choose.png\" width 45%> <p>Primer 20K 应当选择的型号</p> <img src \"./assets/primer_20k_device_choose.png\" width 45%> </details> > <! 对于其他板子选择型号的时候与芯片丝印相对应就行。 > ### spi flash selected mismatch 以高云半导体小蜜蜂（芯片名称以 GW1N 开头的系列）家族芯片为主控的板卡芯片内部含有 FLASH，因此下载的时候将生成的固件烧录到芯片内部即可，将板载的 FLASH 芯片当作外设使用。 以高云半导体晨熙（芯片名称以 GW2A 开头的系列）家族和晨熙V（芯片名称以 GW5A 开头的系列）芯片为主控的板卡芯片内部无有 FLASH，因此下载的时候将生成的固件烧录到外部 FLASH，对此在 Programmer 界面所进行的下载模式与 FLASH 选择如下： <details> <summary><font color \"#4F84FF\">点开查看设置详情</font></summary> <table> <tr> <td rowspan \"2\"><img src \"./../tang primer 20k/examples/assets/led_assets/flash_mode.png\" alt \"flash_mode\"></td> <td style \"white space:nowrap\">操作（Operation）为 <br><code>exFlash Erase,Program thru GAO Bridge</code></td> </tr> <tr> <td>Flash 型号选择为 <code>Generic Flash</code></td> </tr> </table> </details> ### 下载卡住、下载非常慢 不要选中带有 Verify 选项的。 <details> <summary><font color \"#4F84FF\">点开查看相关说明</font></summary> <img src \"./../assets/questions/never_choose_verify.png\"> </details> <! ![never_choose_verify](./../assets/questions/never_choose_verify.png) > 另外自己注意设置一下下载频率，一般设置为 **`2.5MHZ`** 不会有异常 <details> <summary><font color \"#4F84FF\">点开查看操作步骤图片</font></summary> <img src \"./../assets/questions/cable.png\"> <p>点击下图中的 Frequency</p> <img src \"./../assets/questions/frequency.png\" > <p>接着再点击 Save 即可</p> </details> ### 找不到下载文件 一般来说生成的下载文件（拓展后缀为.fs）在工程目录下的 impl/pnr 文件夹里面。 <details> <summary><font color \"#4F84FF\">点开查看相关图文说明</font></summary> <img src \"./../assets/questions/fs_path.png\"> <p> 在上图中可以看到这个下载文件的路径为 /fpga_project1/impl/pnr/fpga_project1.fs </p> <p></p> <p> 其中 fpga_project1 为工程目录，impl 为 IDE 生成的目录，然后所需要的文件位于 pnr 文件夹内</p> <p></p> <p> 然后那个拓展名为 .fs 的文件就是下载到 fpga 的固件</p> </details> ### Directory *** has null character. 文件路径有不支持的字符。 关掉 IDE 检查文件路径，要求路径只包含英文和下划线，检查路径是否有空格 重新打开工程，清除综合缓存后再重新重新综合。 ### 烧录结束后没反应 一般这种情况是没有选择正确的烧录文件。可以自己先对应着各个板子点灯文档里所选择的芯片型号来检查一下自己的工程，然后看看自己的代码是否有问题。对于 20K 板卡来说可能是因为 JTAG 复用而导致主控芯片的 JTAG 引脚不再能被调试，[点我](./../tang primer 20k/primer 20k.html#dock 底板不工作)来查看相应解决办法 ## IDE 使用相关 ### 查看IP文档 在 IDE 里面的 IP 界面点击想要查看的 IP 文档后点击对应的语言即可跳转到对应的说明 <details> <summary><font color \"#4F84FF\">点开查看相关说明</font></summary> <img src \"./../assets/ip reference.png\"> </details> ### 修改设置过的 IP 在 IDE 里面的 IP 界面点击上方器件选型旁边的文件夹后打开已生成 IP 编辑界面 <details> <summary><font color \"#4F84FF\">点开查看相关说明</font></summary> <img src \"./../assets/ip reconfigure.png\"> </details> ### 设置 TOP 层 对于含有多个模块的工程，成功例化后，在 IDE > Hierarchy 页面右键想要设置为顶层的模块，然后选择 `Set As Top Module` 将它设置为顶层模块了。 <details> <summary><font color \"#4F84FF\">点开查看相关说明</font></summary> <img src \"./assets/set_top_module.png\"> </details> <! ![set_top_module](./assets/set_top_module.png) > 如果在 Hierarchy 页面出现下下表左图现象，这表明代码里有逻辑错误，比如 语法错误、例化错误 等等，点击右上角的 `RTL Anakysis Error` ，就可以在弹出的对话框里看到错误的类型代码以及错误的位置，如下表右图所示。 <details> <summary><font color \"#4F84FF\">点开查看错误详情</font></summary> <table> <tr> <td align \"center\">RTL Analysis Error</td> <td align \"center\">错误类型以及详情</td> </tr> <tr> <td><img src \"./assets/top_error.png\" alt \"top_module_error\" ></td> <td><img src \"./assets/error_detail.png\" alt \"error_detail\" ></td> </tr> </table> </details> ### 使用 GAO GAO 是高云半导体在线逻辑分析仪（Gowin Analyzer Oscilloscope）。安装高云 IDE 之后就能在对应的安装相对路径下看到相关文档了 <details> <summary><font color \"#4F84FF\">点开查看相关说明</font></summary> <img src \"./../assets/questions/gao.png\"> </details> <! ![gao](./../assets/questions/gao.png) > 使用高云半导体所提供的最新的教育版的编程器 [【点我跳转】](http://www.gowinsemi.com.cn/faq.aspx) 能够正常使用 GAO >因为 GAO 必须在 IDE 内才能打开，所以你需要自己替换掉安装时候的 Programmer 文件夹，并且确定替换后的路径与之前的相同。 <details> <summary><font color \"#4F84FF\">点开查看相关说明</font></summary> <img src \"./../tang primer 20k/assets/start/educational_edition_programmer.png\"> </details> <! ![educational_edition_programmer](./../tang primer 20k/assets/start/educational_edition_programmer.png) > ### macOS 如何使用GOWIN IDE 云半导体所提供的最新的教育版的**云源软件**已有macOS支持[【点我跳转】](http://www.gowinsemi.com.cn/faq.aspx)，并已支持 **Apple Silicon** 处理器的Mac。 ## OpenFPGA Loader相关 ### 无法通过OpenFPGA Loader下载码流 若通过GOWIN Programmer能正常下载，请尝试更新板载调试器的固件，参考[这篇指南](./update_debugger)； 若通过GOWIN Programmer也无法正常下载，请参考Programmer的[相关问题](#programmer 相关)进行排查。 ### OpenFPGA Loader"},"/hardware/zh/maixcam/microscope.html":{"title":"数码显微镜套餐","content":" title: 数码显微镜套餐 <div style \"width:100%; display:flex;justify content: center;\"> ![maixcam pro microscope](../../assets/maixcam/maixcam_microscope.png) </div> <div style \"padding: 1em 0 0 0; display: flex; justify content: center\"> <a target \"_blank\" style \"margin: 1em;color: white; font size: 0.9em; border radius: 0.3em; padding: 0.5em 2em; background color: #a80202\" href \"https://item.taobao.com/item.htm?id 878126152834\">淘宝</a> <a target \"_blank\" style \"margin: 1em;color: white; font size: 0.9em; border radius: 0.3em; padding: 0.5em 2em; background color: #a80202\" href \"https://wiki.sipeed.com/store\">速卖通</a> </div> ## 数码显微镜套餐 MaixCAM 显微套件可将你的MaixCAM / MaixCAM Pro 转化为便携式数码显微镜， 在各方面性能上都超越同价位数码显微镜，并具备开源特性，你可以打造属于你自己独有功能的数码显微镜！ MaixCAM 显微套餐 适用于 细小元件放大焊接，生物标本观察，显微堆叠摄影 等场景，更多应用方式等你来挖掘！ ### 单镜头套餐 仅包含10mm锥形镜头，10mm增距环 和 消光绒贴纸，适用于手持观察，或者你已有通用显微镜支架 ![单镜头套餐](../../assets/maixcam/micro_lens.jpg) 使用方法：将maixcam的原镜头旋下，更换上锥形镜头即可 如果需要更大放大倍数，可以先旋上10mm增距环，再旋上锥形镜头。 ![镜头安装方式](../../assets/maixcam/micro_lens_install.jpg) 镜头旋得越靠内，倍数越小，镜头距离物体越远（最远大概10cm左右） 镜头旋得越靠外，倍数越大，镜头距离物体越近（最近大概1cm左右） 安装方式 光学倍率 视野 适合观察的物体 10mm锥形镜头旋到最内 0.25X20.5x11.5mm适合观察PCB，焊接FPC 10mm锥形镜头旋到最外 0.6X8.5x4.8mm 适合观察芯片丝印，细小飞线焊接 10mm锥形镜头+10mm增距环旋到最内 1.0X 5.1x2.9mm 适合观察 芯片晶元整体，水蚤等较大浮游生物 10mm锥形镜头+10mm增距环旋到最外 2.0X2.56x1.44mm 适合观察 芯片晶元细节，典型生物细胞切片 1. 注意这里的倍率是光学倍率，非普通显微镜厂家宣称的几百倍，几千倍的虚标倍率。 2. 这里的视野以GC4653为例；如果是OS04A10,则等比例放大 3/1.8 1.67倍 安装完成后即可在MaixCAM内置的相机APP里对目标物体进行观察，拍摄。 如果光线不足，也可在APP左侧栏目打开闪光灯进行补光操作。 如果使用的时候发现画面内泛白，即说明镜头内有炫光，可以裁剪适合的消光绒片段，粘贴于锥形镜头内侧。 ![消光绒抑制炫光](../../assets/maixcam/xiaoguang.jpg) ### 手动支架套餐 包含以下内容： 1. 镜头：10mm锥形镜头， 10mm增距环 2. 支架：精密铝合金支架 散件 3. 生物标本：洋葱表皮标本， 白色载物台 4. 其它：消光绒 ![支架套餐](../../assets/maixcam/focusing_stand_suit.jpg) 镜头的安装方式参见上节。 支架组装及安放MaixCAM效果如下，在观察电路板等较大目标时一般不需要安装增距环： ![支架套餐](../../assets/maixcam/stand_install.jpg) 套餐内配有固定支架可以帮助固定MaixCAM Pro，安装方法如下 ![支架套餐](../../assets/maixcam/install_bracket.png) 用户还可以选配迷你加热台进行焊接操作： ![支架焊接](../../assets/maixcam/stand_solder.jpg) 在观察微小生物标本时，一般需要安装增距环，打开补光灯，有必要还可以使能相机APP中的对焦放大功能。 如下图所示，将附赠的洋葱表皮标本置于白色载物台上，打开补光灯和对焦放大功能观察的效果： ![支架拍摄洋葱表皮](../../assets/maixcam/stand_onion.jpg) 实拍效果展示： ![洋葱表皮](../../assets/maixcam/onion.jpg) ![松树茎横切](../../assets/maixcam/pine.jpg) ### 电动支架套餐 可能在未来推出，使用步进电机滑台实现电动自动对焦，堆栈拍摄功能。 <video playsinline controls muted preload style \"width:100%\" src \"../../assets/maixcam/micro_focus.mp4\"></video> ## 效果对比 ### 参数对照表 **MaixCAM显微套餐****当当狸M2B显微镜** Sensor分辨率 2560x1440 1600x1200 显示屏 2.4寸 640x480 4寸 800x480 交互操作 全屏触摸 物理按键+触摸按键 相对孔径 F1:2.5 更大更明亮 F1:4.5 照片拍摄 ✓ 可调参数 ✓ 固定参数 视频录制拍摄 MP4 体积更小 AVI 体积庞大 延时摄影 ✓ X 光学放大倍率 无增距环:0.25～0.6<br>加增距环: 1.0~2.0 0.42～0.92 最大放大倍率下<br>单像素物理尺寸1um 2.7um 支架 稳固铝合金支架 普通塑料支架 ### 实拍对比 每张对比图中，上图为 当当狸M2B显微镜 最大倍数拍摄效果，下图为 MaixCAM显微镜 最大倍数拍摄效果 ![c1](../../assets/maixcam/c1.jpg) ![c2](../../assets/maixcam/c2.jpg) ![c3](../../assets/maixcam/c3.jpg) ![c4](../../assets/maixcam/c4.jpg) ![c5](../../assets/maixcam/c5.jpg) ![c6](../../assets/maixcam/c6.jpg) <div style \"padding: 1em 0 0 0; display: flex; justify content: center\"> <a target \"_blank\" style \"margin: 1em;color: white; font size: 0.9em; border radius: 0.3em; padding: 0.5em 2em; background color: #a80202\" href \"https://item.taobao.com/item.htm?id 878126152834\">淘宝</a> <a target \"_blank\" style \"margin: 1em;color: white; font size: 0.9em; border radius: 0.3em; padding: 0.5em 2em; background color: #a80202\" href \"https://wiki.sipeed.com/store\">速卖通</a> </div>"},"/hardware/zh/maixcam/maixcam_pro.html":{"title":"MaixCAM-Pro -- 快速落地 AI 视觉、听觉应用","content":" title: MaixCAM Pro 快速落地 AI 视觉、听觉应用 <div style \"width:100%; display:flex;justify content: center;\"> ![maixcam pro](/static/image/maixcam_pro.png) </div> <div style \"padding: 1em 0 0 0; display: flex; justify content: center\"> <a target \"_blank\" style \"margin: 1em;color: white; font size: 0.9em; border radius: 0.3em; padding: 0.5em 2em; background color: #a80202\" href \"https://item.taobao.com/item.htm?id 846226367137\">淘宝</a> <a target \"_blank\" style \"margin: 1em;color: white; font size: 0.9em; border radius: 0.3em; padding: 0.5em 2em; background color: #a80202\" href \"https://www.aliexpress.com/store/911876460\">速卖通</a> </div> ## MaixCAM Pro 简介 MaixCAM 是为更好地落地 AI 视觉、听觉和 AIOT 应用而设计的一款硬件产品，一个能快速验证产品原型且能快速量产的平台。 提供了强大且高性价比的处理器，配套的摄像头、屏幕、WiFi 等，以及完善和非常易用的软件生态。 <div style \"display: flex; justify content: left\"> <a target \"_blank\" style \"margin: 1em;color: white; font size: 0.9em; border radius: 0.3em; padding: 0.5em 2em; background color: #a80202\" href \"https://wiki.sipeed.com/maixpy/\">更多功能介绍请看 MaixPy 主页</a> </div> <iframe src \"//player.bilibili.com/player.html?isOutside true&aid 113485669204279&bvid BV1ncmRYmEDv&cid 26768769718&p 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\"></iframe> **应用场景和人群**： * **AI算法落地**： AI 算法工程师可以快速将自己的 AI 模型部署到实体硬件（MaixCAM)上，提供易用的模型转换工具和 SDK。 * **STEM 教育**： 提供易用的 MaixPy SDK 和配套开发工具，以及在线模型训练平台，老师无需软硬件开发，专注教学，学生可以快速上手。 * **高校科研和教育**： 提供丰富的文档和教程，高校学生各个阶段的学生都有合适的学习路线，RISC V 和 AI 前沿技术也是科研的好帮手。 * **创客和工程师的原型开发利器**：精心设计的硬件，丰富的外设，超易用的软件，让你的有趣想法和产品快速落地，不用身陷基础软硬件开发的泥潭。 * **企业产品升级、落地**：无需昂贵的研发成本快速落地产品，或者用于辅助产品比如产线 QA，旧设备使用 AI 视觉实现智能化等。 * **竞赛好帮手**：MaixCAM + MaixPy + MaixCDK 可以快速实现很多创新和功能，适合作为比赛指定软硬件平台，选手也可以依靠生态的开发效率赢得比赛， Maix 系列产品和 MaixPy 已经被用在各种比赛中获得奖项。 ## MaixCAM Pro 硬件简介 > MaixCAM Pro 相比 [MaixCAM](./index.html) 重新设计了 PCB 和外壳以及有部分外设升级， 加粗为和 MaixCAM 的不同处 组件 描述 CPU 大核 1GHz RISC V C906 处理器（另外还有一个 1GHz ARM A53 核心可二选一使用），跑 Linux CPU 小核 700MHz RISC V C906， 跑 RTOS CPU 低功耗核 25~300MHz 8051 处理器，用于低功耗应用 NPU 1TOPS@INT8， 支持 BF16 模型，算子支持丰富，支持常见模型比如 Mobilenetv2, YOLOv5, YOLOv8等 内存 256MB DDR3 存储 TF 卡启动 / SD NAND 启动 摄像头 最高支持 5M 摄像头，官方支持 4M GC4653 和 OS04A10 摄像头（4 lane MIPI CSI 输入，22Pin 接口，支持拆分双路 CSI） 屏幕 **2.4 寸高清 IPS 电容触摸屏， 分辨率 640x480**（2 lane MIPI DSI 输出，标准 31pin 接口，6pin 电容触摸屏） 音频输出 板载PA功放 + **1W 喇叭** 音频输入 板载模拟硅麦，可直接收音 网络 板载 WiFi6 + BLE5.4 模组，可定制 以太网版本 USB Type C USB2.0，支持Device和Host模式，支持 USB 摄像头 IO 接口 **2.54mm PMOD 接口， 引出 12 个 IO + Vsys/3.3v/GND 接口 + 1.25mm 6pin扩展接口** 按键 1 x RST 按键 + 1 x USER（功能） 按键 + **1 x 电源按钮** LED 电源指示灯 + 用户 LED + **照明 LED** 编解码 H.264 / H.265 / MJPEG 硬解码， 支持 2k@30fps 编解码 外设 I2C/SPI/UART/ADC/PWM/WDT 等常见外设 电源 **独立电源管理芯片AXP2101，支持锂电池充放电管理，并且提供带锂电池版本** 外壳 **3D 打印+亚克力外壳， 1/4 英寸标准螺纹固定孔** IMU **板载六轴 IMU 传感器（三轴加速度+三轴角速度）** RTC **板载 BM8653 RTC 芯片+纽扣电池，断电时间仍然正确** 尺寸 **无电池版本外壳 67x51x12mm, 带电池版本厚度 16mm** ## MaixCAM 软件生态 我们不只是做了硬件，更为 MaixCAM 提供了一套完整的软件生态，包括： 名称 描述 图片/视频 **[MaixPy](https://wiki.sipeed.com/maixpy/)** Python 开发包， 提供丰富且使用简单的 API，针对 MaixCAM 进行优化，支持硬件加速，提供丰富文档教程 请看[MaixPy 主页](https://wiki.sipeed.com/maixpy/) [MaixVision](https://wiki.sipeed.com/maixvision) AI 视觉 IDE，编程、代码运行、图像实时预览，甚至图形化编程等等，大大降低开发环境搭建难度和使用门槛 ![MaixVision](../../assets/maixcam/maixvision.jpg) <video playsinline controls muted preload style \"width:100%\" src \"https://wiki.sipeed.com/maixpy/static/video/maixvision.mp4\"></video> [MaixHub](https://maixhub.com) 在线 AI 模型训练平台，无需 AI 知识和昂贵的训练设备，一键训练模型，一键部署到 MaixCAM ![MaixVision](../../assets/maixcam/maixhub.jpg) [MaixCDK](https://github.com/sipeed/MaixCDK) MaixPy 的 C++版本，熟悉 C/C++ 的开发者立刻上手 请看[MaixCDK 主页](https://github.com/sipeed/MaixCDK) [应用商城](https://maixhub.com/app) 提供各种应用和工具，无需开发直接下载使用，开发者也可以上传分享应用 请看 [MaixHub 应用商城](https://maixhub.com/app) [分享广场](https://maixhub.com/share) 开发者分享经验和项目 请看 [MaixHub 分享广场](https://maixhub.com/share) ## 资料汇总 ### MaixCAM 专属资料（Sipeed 提供） * [MaixCAM Pro 官方文档](https://wiki.sipeed.com/maixcam pro)（本文档） * [MaixPy 官方文档](https://wiki.sipeed.com/maixpy/)（Python SDK）（[MaixPy 源码](https://github.com/sipeed/MaixPy)） * [MaixCDK](https://github.com/sipeed/MaixCDK)（C/C++ SDK）（[MaixCDK 源码](https://github.com/sipeed/MaixCDK)） * [系统源码](https://github.com/sipeed/LicheeRV Nano Build) * [硬件相关资料](https://dl.sipeed.com/shareURL/MaixCAM/MaixCAM_Pro) * 外壳和支架：可以在[外壳文档](./assemble.html) 看到介绍，另外还开源了 外壳、支架等 3D 模型文件，请到[makerworld.com](https://makerworld.com/)（推荐） 或[makerworld.com.cn](https://makerworld.com.cn) 搜索 `MaixCAM`。 * 接口图： ![maixcam_pro_io](../../assets/maixcam/maixcam_pro_io.png) ### 芯片资料 MaixCAM Pro 其基于算能的SG2002 芯片，所以也可以参考它们的资料，也可以参考 Sipeed 的 LiecheeRV Nano 核心板文档。 >! 注意：MaixCAM Pro 可以使用 LicheeRV Nano 和 SG2002 的资料， 反之 **LicheeRV Nano 和其它 SG2002 芯片产品没法使用 MaixPy MaixCDK MaixVision 等软件**，请不要购买错误浪费时间和金钱。 > 如果你希望快速上手开发应用，请选择 MaixCAM, 如果你是资深 Linux 开发者，只想基于 SG2002 原厂资料开发，可以选择 LicheeRV Nano。 * [Datasheet](https://github.com/sophgo/sophgo doc/releases) （寄存器级别的资料） * [LicheeRV Nano 开发板资料](https://wiki.sipeed.com/hardware/zh/lichee/RV_Nano/1_intro.html) * [工具链下载](https://sophon file.sophon.cn/sophon prod s3/drive/23/03/07/16/host tools.tar.gz) * [算能 SDK 开发文档汇总](https://developer.sophgo.com/thread/471.html) * [算能 HDK 开发文档汇总](https://developer.sophgo.com/thread/472.html) * [算能 TPU 开发文档汇总](https://developer.sophgo.com/thread/473.html) * [算能 TDL 开发文档汇总](https://developer.sophgo.com/thread/556.html)（基于 TPU 的高层API 封装） ### 社区资料 * [MaixHub 应用商城](https://maixhub.com/app) * [MaixHub 分享广场](https://maixhub.com/share) * [makerworld.com](https://makerworld.com/)(推荐) 或者 [makerworld.com.cn](https://makerworld.com.cn) 搜索 `MaixCAM` * [Bilibili](https://bilibili.com) 搜索 `MaixCAM` 或者 `MaixPy` ## 购买 * [Sipeed 淘宝](https://sipeed.taobao.com/) * [AliExpress](https://www.aliexpress.com/store/911876460)"},"/hardware/zh/maixcam/tof_thermal.html":{"title":"ToF/热成像模块介绍","content":" title: ToF/热成像模块介绍 ## PMOD_Thermal32 PMOD_Thermal32 模块是符合PMOD接口标准的低成本热成像模块，可以直接插入MaixCAM系列的PMOD插槽上使用，并和与可见光摄像头组合，实现双光融合的功能。 **模块名** PMOD_Thermal32 **分辨率** 32x24 **测温范围** 40～450摄氏度 **视角** 55°x35° **帧率** 1~30fps **接口** I2C PMOD_Thermal32安装方式 平台 安装方法 MaixCAM Pro <img src \"../../assets/maixcam/pmod_thermal32.jpg\" width \"400\" height \"300\"> MaixCAM2 <img src \"../../assets/maixcam/pmod_thermal32_maixcam2.jpg\" width \"400\" height \"300\"> 单热成像伪彩显示 <img src \"../../assets/maixcam/th32_1.jpg\" width \"400\" height \"300\"> 热成像+可见光融合显示 <img src \"../../assets/maixcam/th32_2.jpg\" width \"400\" height \"300\"> 参考使用代码： https://github.com/sipeed/MaixPy/blob/main/examples/ext_dev/sensors/thermography_mlx90640/mlx90640_example.py ## PMOD_TOF100 PMOD_TOF100 模块是符合PMOD接口标准的低成本面阵TOF模块，可以直接插入MaixCAM系列的PMOD插槽上使用，并和与可见光摄像头组合，实现双光融合的功能。 **模块名** PMOD_TOF100 **分辨率** 100x100, 50x50, 25x25 **测距范围**0.2~2.5m **视角** 70°Hx60°V **激光发射器** 940nm VCSEL **帧率** 100x100 6fps, 50x50 22fps, 25x25 30fps **接口** SPI PMOD_TOF100安装方式 平台 安装方法 MaixCAM Pro <img src \"../../assets/maixcam/pmod_tof100.jpg\" width \"400\" height \"300\"> MaixCAM2 <img src \"../../assets/maixcam/pmod_tof100_maixcam2.jpg\" width \"400\" height \"300\"> 单深度伪彩显示 <img src \"../../assets/maixcam/tof100_1.jpg\" width \"400\" height \"300\"> 深度+可见光融合显示 <img src \"../../assets/maixcam/tof100_2.jpg\" width \"400\" height \"300\"> 参考使用代码： https://github.com/sipeed/MaixPy/blob/main/examples/ext_dev/sensors/tof100/tof100_example.py ## PMOD_Thermal160 PMOD_Thermal160 模块是符合PMOD接口标准的低成本热成像模块，可以直接插入MaixCAM系列的PMOD插槽上使用，并和与可见光摄像头组合，实现双光融合的功能。 **模块名** PMOD_Thermal160 **分辨率** 160x120 **测温范围** 20～120℃ **视角** 34°x26° **帧率** 25fps **接口** 图像接口:UART/USB 控制接口:I2C **NETD**<50mK @25℃ PMOD_Thermal160安装方式 平台 安装方法 MaixCAM Pro <img src \"../../assets/maixcam/maixcam_pmod_thermal160.jpg\" width \"400\" height \"300\"> MaixCAM2 <img src \"../../assets/maixcam/maixcam2_pmod_thermal160.jpg\" width \"400\" height \"300\"> > 参考代码在未来支持 ## PMOD_Thermal256 PMOD_Thermal256 模块是符合PMOD接口标准的低成本热成像模块，可以直接插入MaixCAM系列的PMOD插槽上使用，并和与可见光摄像头组合，实现双光融合的功能。 **模块名** PMOD_Thermal256 **分辨率** 256x192 **测温范围** 15～150℃ (高增益), 50～550℃ (低增益) **视角** 56°x42° **帧率** 25fps **接口** 图像接口:SPI 控制接口:I2C **NETD**<50mK @25℃ PMOD_Thermal256安装方式 平台 安装方法 MaixCAM Pro <img src \"../../assets/maixcam/maixcam_pmod_thermal256.jpg\" width \"400\" height \"300\"> MaixCAM2 <img src \"../../assets/maixcam/maixcam2_pmod_thermal256.jpg\" width \"400\" height \"300\"> 参考使用代码： https://github.com/sipeed/MaixPy/tree/main/examples/ext_dev/sensors/tiny1c_example.py > 如果要使用该示例，请先删除于`x3c_192x256`相关的代码"},"/hardware/zh/maixcam/maixcam2_isp.html":{"title":"MaixCAM2 ISP 调校","content":" title: MaixCAM2 ISP 调校 ## 对画面风格有要求，是否可自己调校 ISP 理论可以，只是比较复杂。 本文暂时也不会深入介绍，只是为你提供一种可能性，如果你没有做好碰壁的心里准备，那么可以认为不支持。 也欢迎多尝试和交流，以及贡献本篇文档。 ## 调校 ISP 方法简述 简单理解就是 ISP 运行时会加载配置文件读取参数（可以在系统`/opt/etc/`下面看到很多配置文件，比如`sc850sl_hdr_4lane_sipeed_0716.bin`）， 我们可以使用芯片原厂的 ISP 调校工具连接上开发板进行调校，最终得到配置文件替换原有的就可以了。 芯片官方文档和工具放在[下载站](https://dl.sipeed.com/shareURL/MaixCAM/MaixCAM2/Software/Tools)，下载阅读和使用即可。"},"/hardware/zh/maixcam/maixcam2_faq.html":{"title":"MaixCAM2 FAQ (常见问题)","content":" title: MaixCAM2 FAQ (常见问题) 下面找不到的问题，也可以参考[MaixPy FAQ](https://wiki.sipeed.com/maixpy/doc/zh/faq.html)。 ## 产品是带外壳形态，我不需要外壳，屏幕或者摄像头，能去掉量产吗 可以。 自带外壳、屏幕和摄像头是方便快速验证产品和想法，实际量产可以联系 Sipeed(support@sipeed.com 或者网店) 定制去掉部分器件，量大更优。 另外也提供核心板版本，有 PCB 设计能力可以自行直接购买核心板设计底板。 ## 购买的 4GB 内存版本的，怎么系统内显示只有 2GB / 1GB 内存 硬件是 `4GB` 内存，内存被分为了用户层内存和系统使用内存，在 `Linux`系统下用`free`命令看到的内存就是用户层内存， 系统使用的内存有一大部分被用来作为硬件专用内存了，比如`模型运行`、`摄像头`、`显示`等等。 我们可以修改`/boot/configs`文件里面的`maix_memory_cmm 1` 值来修改分配比例，` 1`是默认值， 比如我们可以修改为`3072`（不写单位，默认单位是`MiB`），那么将预留`3072MiB`给模型等硬件使用，剩下的给`Linux`系统。 **需要重启才能生效。** 更详细的请看[MaixPy 内存使用说明](https://wiki.sipeed.com/maixpy/doc/zh/pro/memory.html)。"},"/hardware/zh/maixcam/maixcam2_camera_lens.html":{"title":"MaixCAM2 摄像头和镜头的选择和使用","content":" title: MaixCAM2 摄像头和镜头的选择和使用 ## MaixCAM2 官方支持的摄像头传感器 参数\\型号 OS04D10 SC850SL OS04A10 分辨率和帧率 2568x1448@30fps (2K / 4M) 3856x2176@60fps(10bit下) (4K / 8M) 2688x1520@30fps(2K / 4M) 像素大小 1.998um x 1.998um 2.0um x 2.0um 2.9um x 2.9um 传感器尺寸 5130.864um x 2893.104um 7712um x 4352um 7841.6um x 4454.4um 镜头尺寸 1/3\" 1/1.8\" 1/1.79\" 镜头光圈 F2.5 F1.65 F1.65 输出格式 10bit RAW RGB 12/10/8bit RAW RGB 16/12/10bit RAW RGB 快门类型 卷帘快门 卷帘快门 卷帘快门 CRA 12° 9° 9° FOV D90° H81° V51° D100° H87° V49° D100° H87° V49° 最长曝光 0.5s 45s 动态范围 线性模式75dB<br>宽动态模式 > 100dB >120dB(2x/3x staggered HDR) 信噪比 39dB 灵敏度 5034 mV/lux·s 32,000 e /Lux sec (green pixelresponse at 530 nm illumination) 工作温度 30°C ～ 85°C<br>最佳 20°C ～ 60°C 30°C ～ 85°C<br>最佳 20°C ～ 60°C 30°C ～ 85°C 适用范围 分辨率更低，发热更低，画质优良，能满足一般 AI 检测识别应用 需要分辨率高，画质清晰，发热大一点 需要高清画质，彩光夜视，HDR等，发热比较大 > 夜视效果而言，OS04A10相元面积是SC850SL的两倍，SC850SL镜头光圈导致的进光量差异是OS04D10的两倍，所以 OS04A10 > SC850SL > OS04D10 > 但是大光圈会造成景深较小，50cm处景深约8cm，200cm处景深约60cm 更多摄像头传感器数据手册见[下载站](https://dl.sipeed.com/shareURL/MaixCAM/MaixCAM2/Hardware/sensors) ## 镜头和底座参数和更换 官方每个摄像头都配了一个标准 M12 镜头。 注意不同摄像头配的镜头参数不一样，如果你自己需要选购其它参数的镜头，可以根据上面摄像头传感器尺寸和下表出厂自带的镜头信息作为参考选择。 方便你选择新镜头，为了能在已有的传感器和底座上使用，需要着重注意的参数加粗表示了。 更多镜头和底座参数可以在[下载站](https://dl.sipeed.com/shareURL/MaixCAM/MaixCAM2/Hardware/sensors) 找找对应的数据手册。 需要注意的是，实际使用的镜头可能和手册稍微有区别，比如`OS04D10`和`SC850SL`自带的镜头都没用`650 IR Cut`，但是数据手册中有，以实际为准，忽略即可。 ### 镜头 ### MaixCAM2 官方套餐镜头 ![SC850SL 自带镜头](../../assets/maixcam/cam_len.png) 参数\\型号 OS04D10 SC850SL OS04A10 接口类型 **M12** **M12** **M12** 直径 12mm 12mm 12mm 螺纹间距 0.5mm 0.5mm 0.5mm 视场角 H 90°<br>V 81°<br>D 90° 水平H 86.7°<br>垂直V 48.8°<br>对角D 99.5° H88°<br>V49.9°<br>D100.2° 畸变 无畸变 有畸变, 25.6% 有畸变, 25.6% IR Cut 无 无 无 镜头尺寸 **1/3\"** **1/1.8\"** **1/1.8\"** CRA 12° 16.2° 16.2° 镜头总长(TTL) 22.28±0.2mm 22.28±0.2mm 焦距 **3.05** **4.9±5%mm** **4.9±5%mm** 光学后焦 3.1 6.41±0.2mm 6.41±0.2mm 机械后焦(法兰距) 3.1 **6.17±0.2mm** **6.17±0.2mm** 光圈数值 2.5 1.65±10% 1.6±10% 镜片构成 2G2P 4G4P 4G4P 解像标准 4MP 8MP 4MP ### 如何对焦 默认提供的 M12 镜头，是手动对焦镜头，需要手动拧动镜头进行对焦，如果画面模糊，可能就是没有对好焦。 注意是拧动镜头，部分镜头上还有一个环，那是用来辅助固定镜头的，防止对好焦后震动导致对焦变化。 可以先拧松固定环，再拧镜头对焦，对好焦后再将固定环拧紧以固定。 ### 是否可变焦 默认提供的 M12 镜头，是定焦镜头，只能对焦（清晰模糊），不能变焦（光学放大缩小画面），有需要可以自行购买 M12 变焦镜头，购买时参考后文的镜头选择文档。 ### 如何更换镜头 选择同样 M12 规格的镜头更换即可，大多数参数都是影响成像效果，但是`镜头的长度`和`底座的长度`以及`焦距`会影响到是否能对上焦，要保证： 1. 镜头拧到底前能对上焦： 即至少镜头拧到底后, `镜头底部到传感器的距离` 必须小于等于 `机械后焦(法兰距)`。比如法兰距很短，镜头也很短，底座太高了，可能就无法对焦。 2. 镜头拧到掉出底座前能对上焦：由`1/f 1/u + 1/v`, 物距`u`越小，像距`v`应该越大也就是镜头要远离传感器, 已知`u`无穷大时 `f v`，`u`减小时得到新的像距`v2`,对比`v`增加了距离`v_d`，也就是说镜头要往外移动`v_d`，为了保证镜头不掉出底座，`机械后焦(法兰距)` + `v_d` 后要小于底座的高度，否则现象就是镜头拧出了底座焦点仍然对不上近处目标物体。 > 如果搞不清楚，直接告诉镜头店家传感器参数和底座参数应该也可以帮你判定。 ### 底座 ![](../../assets/maixcam/cam_len_base.png) 底座一般不建议更换，因为和传感器 PCB 用胶水粘在一起不好拆卸，换镜头时适配底座即可。 参数\\型号 OS04D10 SC850SL OS04A10 IR Cut **650mm IR Cut** **650mm IR Cut** **650mm IR Cut** 高度 **12mm** **13mm<br>(12mm底座+1mm垫片)** **13mm<br>(12mm底座+1mm垫片)** * **IR Cut**: 过滤红外光，如果你要捕捉红外光得手动破坏这个过滤片或者更换底座，会比较麻烦。 ## 是否可以更换传感器 理论可以，官方适配的传感器是经过调教的，可以直接用，如果你要适配新的传感器，需要有 sensor 适配经验以增加驱动支持。 以及需要进行图像调教，过程比较复杂。 本文不提供教程，有能力的可以自行根据芯片原厂资料进行探索。 ## 不同摄像头实测效果对比 TODO:"},"/hardware/zh/maixcam/index.html":{"title":"MaixCAM -- 快速落地 AI 视觉、听觉项目","content":" title: MaixCAM 快速落地 AI 视觉、听觉项目 <script src \"/static/js/tailwind.js\"></script> <style> #content_body .h1 { font size: 2.2em; font weight: 800; } .flex_center { display:flex; flex direction: column; justify content: center; align items: center; } #content_body .card_item { color: #f0f5f9; background: linear gradient(90deg, #26d0ce, #1a2980); border radius: 1em; padding: 1em; margin: 1em 0.1em; } #content_body .card_item img { transition: transform 0.4s ease; } #content_body .item2 { width: 90%; align self: start; background: linear gradient( 45deg, #c471ed, #f64f59); } #content_body .item3 { width: 90%; align self: end; background: linear gradient( 45deg, #12c2e9, #c471ed); } #content_body .card_item:visited { color: #f0f5f9; } #content_body .card_item:hover { border radius: 1em; background: linear gradient(70deg, #26d0ce, #1a2980); padding: 1em; margin: 1em 0.1em; } #content_body .item2:hover { background: linear gradient( 20deg, #c471ed, #f64f59); } #content_body .item3:hover { background: linear gradient( 20deg, #12c2e9, #c471ed); } #content_body .card_item:hover > img { transform: rotate(10deg) scale(1.3) ; } .cams_wrapper { } .mask_wrapper { position: relative; } .mask { position: absolute; top: 0; left: 0; width: 100%; height: 100%; } .item_name { font size: larger; font weight: 800; } #content_body .btn_blue { margin: 1em; color: white; font size: 0.9em; border radius: 0.3em; padding: 0.5em 2em; background color: #0b4294; } #content_body .btn_blue:visited { color: white; } #content_body .btn_blue:hover { margin: 1em; color: white; font size: 0.9em; border radius: 0.3em; padding: 0.5em 2em; background color: #082a5e; } #content_body .btn_red { margin: 1em; color: white; font size: 0.9em; border radius: 0.3em; padding: 0.5em 2em; background color: #ad3838 } #content_body .btn_red:visited { color: white; } #content_body .btn_red:hover { margin: 1em; color: white; font size: 0.9em; border radius: 0.3em; padding: 0.5em 2em; background color: #630606; } .dark #content_body .card_item { color: #f0f5f9; } .dark #content_body a.card_item:visited { color: #f0f5f9; } .dark .card_item { background: #292929; } @media screen and (max width: 768px) { #content_body .item1 { flex direction: column reverse; } #content_body .item1 img { padding bottom: 1em; } #content_body .item2 { width: 98%; } #content_body .item3 { width: 98%; } } </style> <div style \"width:100%;\" class \"flex_center\"> <! ![MaixCAM](../../assets/maixcam/maixcam.jpeg) > </div> <div style \"margin bottom: 4em\"></div> <div class \"flex_center w full cams_wrapper\"> <div class \"flex flex row w full\"> <a href \"./maixcam2.html\" class \"flex flex row items center justify around w full card_item mask_wrapper item1\"> <div class \"item_name\">MaixCAM2</div> <img src \"/static/image/maixcam2_small.png\"> <div class \"mask\"></div> </a> </div> <div class \"flex flex row w full justify between\"> <div class \"flex_center flex row w 1/2 justify start\"> <a href \"./maixcam.html\" class \"flex_center card_item mask_wrapper item2\"> <img src \"/static/image/maixcam_small.png\"> <div class \"item_name pt 8\">MaixCAM</div> <div class \"mask\"></div> </a> </div> <div class \"flex_center flex row w 1/2 justify end\"> <a href \"./maixcam_pro.html\" class \"flex_center card_item mask_wrapper item3\"> <img src \"/static/image/maixcam_pro_small.png\"> <div class \"item_name pt 8\">MaixCAM Pro</div> <div class \"mask\"></div> </a> </div> </div> </div> <div class \"center mb 20\"></div> <div style \"padding: 1em 0 0 0; display: flex; justify content: center\"> <a target \"_blank\" class \"btn_blue\" href \"https://wiki.sipeed.com/maixpy/\">MaixPy </a> <a target \"_blank\" class \"btn_blue\" href \"https://wiki.sipeed.com/maixcdk/\">MaixCDK</a> <a target \"_blank\" class \"btn_blue\" href \"https://maixhub.com\">MaixHub 在线模型训练</a> <a target \"_blank\" class \"btn_blue\" href \"https://maixhub.com/app\">MaixHub 应用商店</a> </div> <div style \"padding: 1em 0 0 0; display: flex; justify content: center\"> <a target \"_blank\" class \"btn_red\" href \"https://item.taobao.com/item.htm?id 784724795837\">淘宝</a> <a target \"_blank\" class \"btn_red\" href \"https://www.aliexpress.com/store/911876460\">速卖通</a> </div>"},"/hardware/zh/maixcam/maixcam.html":{"title":"MaixCAM -- 快速落地 AI 视觉、听觉项目","content":" title: MaixCAM 快速落地 AI 视觉、听觉项目 <div style \"width:100%; display:flex;justify content: center;\"> ![MaixCAM](https://wiki.sipeed.com/maixpy/static/image/maixcam.png) </div> <div style \"padding: 1em 0 0 0; display: flex; justify content: center\"> <a target \"_blank\" style \"margin: 1em;color: white; font size: 0.9em; border radius: 0.3em; padding: 0.5em 2em; background color: #a80202\" href \"https://item.taobao.com/item.htm?id 784724795837\">淘宝</a> <a target \"_blank\" style \"margin: 1em;color: white; font size: 0.9em; border radius: 0.3em; padding: 0.5em 2em; background color: #a80202\" href \"https://www.aliexpress.com/store/911876460\">速卖通</a> </div> ## MaixCAM 简介 MaixCAM 是为更好地落地 AI 视觉、听觉和 AIOT 应用而设计的一款硬件产品，一个能快速验证产品原型且能快速量产的平台。 提供了强大且高性价比的处理器，配套的摄像头、屏幕、WiFi 等，以及完善和非常易用的软件生态。 <div style \"padding: 1em 0 0 0; display: flex; justify content: left\"> <a target \"_blank\" style \"margin: 1em;color: white; font size: 0.9em; border radius: 0.3em; padding: 0.5em 2em; background color: #a80202\" href \"https://wiki.sipeed.com/maixpy/\">更多功能介绍请看 MaixPy 主页</a> </div> <iframe src \"//player.bilibili.com/player.html?isOutside true&aid 113485669204279&bvid BV1ncmRYmEDv&cid 26768769718&p 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\"></iframe> > 视频中的为升级版本 [MaixCAM Pro](./maixcam_pro.html)，功能基本一致，外观和 PCB 有细微差别，具体请看 MaixCAM Pro 文档。 **应用场景和人群**： * **AI算法落地**： AI 算法工程师可以快速将自己的 AI 模型部署到实体硬件（MaixCAM)上，提供易用的模型转换工具和 SDK。 * **STEM 教育**： 提供易用的 MaixPy SDK 和配套开发工具，以及在线模型训练平台，老师无需软硬件开发，专注教学，学生可以快速上手。 * **高校科研和教育**： 提供丰富的文档和教程，高校学生各个阶段的学生都有合适的学习路线，RISC V 和 AI 前沿技术也是科研的好帮手。 * **创客和工程师的原型开发利器**：精心设计的硬件，丰富的外设，超易用的软件，让你的有趣想法和产品快速落地，不用身陷基础软硬件开发的泥潭。 * **企业产品升级、落地**：无需昂贵的研发成本快速落地产品，或者用于辅助产品比如产线 QA，旧设备使用 AI 视觉实现智能化等。 * **竞赛好帮手**：MaixCAM + MaixPy + MaixCDK 可以快速实现很多创新和功能，适合作为比赛指定软硬件平台，选手也可以依靠生态的开发效率赢得比赛， Maix 系列产品和 MaixPy 已经被用在各种比赛中获得奖项。 ## MaixCAM 硬件简介 以下为 MaixCAM 主要硬件参数，更详细的参数请看后文芯片数据手册。 此外还有另外一款 [MaixCAM Pro](./maixcam_pro.html) 组件 描述 CPU 大核 1GHz RISC V C906 处理器（另外还有一个 1GHz ARM A53 核心可二选一使用），跑 Linux CPU 小核 700MHz RISC V C906， 跑 RTOS CPU 低功耗核 25~300MHz 8051 处理器，用于低功耗应用 NPU 1TOPS@INT8， 支持 BF16 模型，算子支持丰富，支持常见模型比如 Mobilenetv2, YOLOv5, YOLOv8等 内存 256MB DDR3 存储 TF 卡启动 / SD NAND 启动 摄像头 最高支持 5M 摄像头，官方支持 4M GC4653 和 OS04A10 摄像头（4 lane MIPI CSI 输入，22Pin 接口，支持拆分双路 CSI） 屏幕 2.3 寸高清 IPS 电容触摸屏， 分辨率 552x368（2 lane MIPI DSI 输出，标准 31pin 接口，6pin 电容触摸屏） 音频输出 板载PA功放，可在排针上直接连接1W以内的喇叭 音频输入 板载模拟硅麦，可直接收音 网络 板载 WiFi6 + BLE5.4 模组，可定制 以太网版本 USB Type C USB2.0，支持Device和Host模式，支持 USB 摄像头 IO 接口 2 x 14pin 2.54 插针接口，间距 800mil，可直插面包板 按键 1 x RST 按键 + 1 x USER（功能） 按键 LED 电源指示灯 + 用户 LED 编解码 H.264 / H.265 / MJPEG 硬解码， 支持 2k@30fps 编解码 外设 I2C/SPI/UART/ADC/PWM/WDT 等常见外设 外壳 3D 打印外壳， 两个螺母固定孔，可固定在支架上 ## MaixCAM 软件生态 我们不只是做了硬件，更为 MaixCAM 提供了一套完整的软件生态，包括： 名称 描述 图片/视频 [MaixPy](https://wiki.sipeed.com/maixpy/) Python 开发包， 提供丰富且使用简单的 API，针对 MaixCAM 进行优化，支持硬件加速，提供丰富文档教程 请看[MaixPy 主页](https://wiki.sipeed.com/maixpy/) [MaixVision](https://wiki.sipeed.com/maixvision) AI 视觉 IDE，编程、代码运行、图像实时预览，甚至图形化编程等等，大大降低开发环境搭建难度和使用门槛 ![MaixVision](../../assets/maixcam/maixvision.jpg) <video playsinline controls muted preload style \"width:100%\" src \"https://wiki.sipeed.com/maixpy/static/video/maixvision.mp4\"></video> [MaixHub](https://maixhub.com) 在线 AI 模型训练平台，无需 AI 知识和昂贵的训练设备，一键训练模型，一键部署到 MaixCAM ![MaixVision](../../assets/maixcam/maixhub.jpg) [MaixCDK](https://github.com/sipeed/MaixCDK) MaixPy 的 C++版本，熟悉 C/C++ 的开发者立刻上手 请看[MaixCDK 主页](https://github.com/sipeed/MaixCDK) [应用商城](https://maixhub.com/app) 提供各种应用和工具，无需开发直接下载使用，开发者也可以上传分享应用 请看 [MaixHub 应用商城](https://maixhub.com/app) [分享广场](https://maixhub.com/share) 开发者分享经验和项目 请看 [MaixHub 分像广场](https://maixhub.com/share) ## 资料汇总 ### MaixCAM 专属资料（Sipeed 提供） * [MaixCAM 官方文档](https://wiki.sipeed.com/maixcam)（本文档） * [MaixPy 官方文档](https://wiki.sipeed.com/maixpy/)（Python SDK）（[MaixPy 源码](https://github.com/sipeed/MaixPy)） * [MaixCDK](https://github.com/sipeed/MaixCDK)（C/C++ SDK）（[MaixCDK 源码](https://github.com/sipeed/MaixCDK)） * [系统源码](https://github.com/sipeed/LicheeRV Nano Build) * [原理图](https://dl.sipeed.com/shareURL/LICHEE/LicheeRV_Nano/02_Schematic) * [摄像头和镜头](https://dl.sipeed.com/shareURL/MaixCAM/MaixCAM/Camera) * [核心板(LicheeRV Nano)硬件资料](https://dl.sipeed.com/shareURL/LICHEE/LicheeRV_Nano) * [MaixCAM 外壳模型](https://makerworld.com.cn/zh/models/467141) * [MaixCAM 支架模型](https://makerworld.com.cn/zh/models/467152) * 核心板引脚图： ![](http://wiki.sipeed.com/hardware/zh/lichee/assets/RV_Nano/intro/RV_Nano_3.jpg) * 外壳和支架：可以在[外壳文档](./assemble.html) 看到介绍，另外还开源了 外壳、支架等 3D 模型文件，请到[makerworld.com](https://makerworld.com/)（推荐） 或[makerworld.com.cn](https://makerworld.com.cn) 搜索 `MaixCAM`。 ### 芯片资料 MaixCAM 基于 Sipeed 的 LiecheeRV Nano 核心板， 其基于算能的SG2002 芯片，所以也可以参考它们的资料。 >! 注意：MaixCAM 可以使用 LicheeRV Nano 和 SG2002 的资料， 反之 **LicheeRV Nano 和其它 SG2002 芯片产品没法使用 MaixPy MaixCDK MaixVision 等软件**，请不要购买错误浪费时间和金钱。 > 如果你希望快速上手开发应用，请选择 MaixCAM, 如果你是资深 Linux 开发者，只想基于 SG2002 原厂资料开发，可以选择 LicheeRV Nano。 * [Datasheet](https://github.com/sophgo/sophgo doc/releases) （寄存器级别的资料） * [LicheeRV Nano 开发板资料](https://wiki.sipeed.com/hardware/zh/lichee/RV_Nano/1_intro.html) * [工具链下载](https://sophon file.sophon.cn/sophon prod s3/drive/23/03/07/16/host tools.tar.gz) * [算能 SDK 开发文档汇总](https://developer.sophgo.com/thread/471.html) * [算能 HDK 开发文档汇总](https://developer.sophgo.com/thread/472.html) * [算能 TPU 开发文档汇总](https://developer.sophgo.com/thread/473.html) * [算能 TDL 开发文档汇总](https://developer.sophgo.com/thread/556.html)（基于 TPU 的高层API 封装） ### 社区资料 * [MaixHub 应用商城](https://maixhub.com/app) * [MaixHub 分享广场](https://maixhub.com/share) * [makerworld.com](https://makerworld.com/)(推荐) 或者 [makerworld.com.cn](https://makerworld.com.cn) 搜索 `MaixCAM` * [Bilibili](https://bilibili.com) 搜索 `MaixCAM` 或者 `MaixPy` * [GitHub](https://github.com) 开源项目: github.com 搜：[MaixCAM](https://github.com/search?q maixcam&type repositoriese) / [MaixCAM2](https://github.com/search?q maixcam2&type repositoriese) / [MaixPy](https://github.com/search?q maixpy&type repositoriese) ## 购买 MaixCAM 目前有两个版本，详情请咨询 [Sipeed 淘宝](https://sipeed.taobao.com/) 或者 [AliExpress](https://www.aliexpress.com/store/911876460) 店家。"},"/hardware/zh/maixcam/maixcam2.html":{"title":"MaixCAM2 -- 快速落地 AI 视觉、听觉应用","content":" title: MaixCAM2 快速落地 AI 视觉、听觉应用 <style> #content_body .h1 { font size: 2.2em; font weight: 800; } .flex_center { display:flex; flex direction: column; justify content: center; align items: center; } .flex { display: flex; } .flex row { flex direction: row; } .items center { align items: center; } .justify center { justify content: center; } .justify around { justify content: space around; } .w full { width: 100%; } #content_body .card_item { color: #f0f5f9; background: linear gradient(90deg, #26d0ce, #1a2980); border radius: 1em; padding: 1em; margin: 1em 0.1em; } #content_body .card_item img { transition: transform 0.4s ease; } #content_body .card_item:visited { color: #f0f5f9; } #content_body .card_item:hover { border radius: 1em; /* background: linear gradient(70deg, #26d0ce, #1a2980); */ padding: 1em; margin: 1em 0.1em; } #content_body .card_item:hover > img { transform: rotate(1deg) scale(1.05) ; } .mask_wrapper { position: relative; } .mask { position: absolute; top: 0; left: 0; width: 100%; height: 100%; } .item_name { font size: larger; font weight: 800; } #content_body .btn_blue { margin: 1em; color: white; font size: 0.9em; border radius: 0.3em; padding: 0.5em 2em; background color: #0b4294; } #content_body .btn_blue:visited { color: white; } #content_body .btn_blue:hover { margin: 1em; color: white; font size: 0.9em; border radius: 0.3em; padding: 0.5em 2em; background color: #082a5e; } #content_body .btn_red { margin: 1em; color: white; font size: 0.9em; border radius: 0.3em; padding: 0.5em 2em; background color: #ad3838 } #content_body .btn_red:visited { color: white; } #content_body .btn_red:hover { margin: 1em; color: white; font size: 0.9em; border radius: 0.3em; padding: 0.5em 2em; background color: #630606; } .dark #content_body .card_item { color: #f0f5f9; } .dark #content_body a.card_item:visited { color: #f0f5f9; } .dark .card_item { background: #292929; } </style> <div style \"width:100%; display:flex;justify content: center;\"> <! ![maixcam2](/static/image/maixcam2_front_back.png) > </div> <div class \"flex_center w full\"> <div class \"flex flex row w full\"> <div class \"flex flex row items center justify around w full card_item mask_wrapper item1\"> <img src \"/static/image/maixcam2_front_back.png\" style \"width: 80%\"> </div> </div> </div> <div style \"padding: 1em 0 0 0; display: flex; justify content: center\"> <a target \"_blank\" class \"btn_red\" href \"https://sipeed.taobao.com\">淘宝</a> <a target \"_blank\" class \"btn_red\" href \"https://www.aliexpress.com/store/911876460\">速卖通</a> </div> <div class \"mb 10\"></div> ## MaixCAM2 简介 `MaixCAM2` 是为更好地落地 AI 视觉、听觉和 AIOT 应用而设计的一款硬件产品，一个能快速验证产品原型且能快速量产的平台。 ### **特点**： 1. **硬件性能突出**：双核`A53` + `12.8Tops@INT4 / 3.2Tops@INT8` + `4GB LPDDR4` + 多种硬件编解码器, `640x640` 分辨率下单独运行模型， `YOLO11n` 高达 `113FPS`, `YOLO11s` 高达 `62fps`。 以下为常见芯片跑 `YOLO11n` 的横评： ![](../../assets/maixcam/maixcam2_benchmark.jpg) 2. **配套一体化硬件**：最高配套 `4K 1/1.8\"` 摄像头、`640x480`高清触摸屏、双麦克风、`WiFi6`+`BLE5.4` 等，无需复杂硬件适配工作，上手即用。 3. **多种硬件形态**：提供带外壳的版本，不同配件配置，也提供`核心板`。 4. **离线 AI 大模型支持**： 除了支持`卷积模型`，也支持 `Transformer 模型`，上手即用的 `LLM / VLM / ASR / TTS`。 5. **完善和易用的软件生态**： 提供精心打磨的 [MaixPy](https://wiki.sipeed.com/maixpy)(`Python`) + [MaixCDK](https://wiki.sipeed.com/maixcdk)(`C++`) SDK, 丰富的文档和专业的配套 `IDE`、`云平台`。 ### 基于 `MaixCAM2`，你可以创造出： * **DIY 智能相机**：提供 `4K` 大底 `1/1.8\"` 传感器，支持 `JPEG / RAW / H.264 / H.265` 编码，提供易用的软件支持，配合 `NPU` 加速的 `AI` 功能，轻松 DIY 你的智能相机。 * **机器人**：双麦 + 高清摄像头 + 高清触摸屏 + 硬件加速的 `AI` + 丰富外设，支持`卷积模型`、`Transformer模型`，上手即用的 `YOLO / LLM / VLM / ASR / TTS`，适用从玩具到各专业领域智能机器人。 * **产线质检助手**：传统算法 OpenMV / OpenCV + 硬件加速的 `AI` 识别，轻松满足产线机器人高精度和实时性和低成本需求。 * **竞赛杀器**：各种比赛好帮手，强大的性能、小巧的体积，易用的 Python SDK（MaixPy） 和 C++ SDK（MaixCDK），光速出有竞争力的作品。已有许多同学使用 MaixCAM 获得各种比赛的最高奖项。 * **教育帮手**：高校科研、教学， STEM 启蒙，传播最新知识，启发未来科技。 * **更多**： 等你发掘～ ### 功能展示 **详细功能介绍请看：** <a target \"_blank\" class \"btn_red\" href \"https://wiki.sipeed.com/maixpy/\">MaixPy 主页</a> ## MaixCAM2 硬件参数 下表中加粗的是相比 MaixCAM / MaixCAM Pro （一代）的升级点。 组件 描述 CPU 大核 **1.2GHz A53 x2, 运行 Linux(Ubuntu)** CPU 小核 RISC V 32bit E907， 跑 RTT NPU **12.8Tops@INT4 / 3.2TOPS@INT8**， 支持卷积和**Transformer模型**，如 YOLO/**LLM/VLM** 等, **YOLO11n 640x640 帧率高达 113FPS** 内存 **1GB / 4GB LPDDR4** 可选 存储 **板载 32GB EMMC**， 板载 TF 卡槽 摄像头 最高支持 **8M(4K)@30fps** 摄像头，4 lane MIPI CSI 输入，22Pin 接口，支持拆分双路 CSI 屏幕 2.4 寸高清 IPS 电容触摸屏，分辨率 640x480（4 lane MIPI DSI 输出，标准 31pin 接口，6pin 电容触摸屏），最大 1080p@60fps 输出 音频输出 板载PA功放 + **1W 喇叭** 音频输入 板载**模拟硅麦 x2**，可直接收音 网络 板载 WiFi6 + BLE5.4 模组，**板载6pin FPC以太网接口(配合外接FPC 转 RJ45 模块使用)** USB Type C USB2.0，支持Device和Host模式，支持 USB 摄像头 IO 接口 2.54mm PMOD 接口， 引出 **20 个 IO** + Vsys/3.3v/GND 接口 + 1.25mm 6pin扩展接口，**核心板提供更多可用 IO** 按键 1 x 电源开关 + 1 x Func（功能） 按键 LED 电源指示灯 + 用户 LED + **照明 LED** 编解码 H.264 / H.265 / MJPEG 硬解码， 支持 **4k@30fps 编码，1080p@60fps解码** 外设 I2C/SPI/UART/ADC/PWM/WDT 等常见外设 电源 **支持锂电池充放电管理，并且提供带锂电池版本** 外壳 **外壳65x49x20mm， 1/4 英寸标准螺纹固定孔** IMU **板载六轴 IMU 传感器（三轴加速度+三轴角速度）** RTC **板载 BM8563EMA RTC 芯片+纽扣充电电池，断电时间仍然正确** 核心板 **提供只包含芯片核心电路 + DDR 的金手指核心板**，方便自行硬件定制 外壳尺寸 **66.5x50x21.2mm (不包括镜头)** ## MaixCAM2 软件生态 我们不只是做了硬件，更为 MaixCAM2 提供了一套完整的软件生态，包括： 名称 描述 图片/视频 **[MaixPy](https://wiki.sipeed.com/maixpy/)** Python 开发包， 提供丰富且使用简单的 API，针对 MaixCAM 进行优化，支持硬件加速，提供丰富文档教程 1. [MaixPy 主页](https://wiki.sipeed.com/maixpy/)<br>2. [MaixPy 源码](https://github.com/sipeed/MaixPy) [MaixVision](https://wiki.sipeed.com/maixvision) AI 视觉 IDE，编程、代码运行、图像实时预览，甚至图形化编程等等，大大降低开发环境搭建难度和使用门槛 ![MaixVision](../../assets/maixcam/maixvision.jpg) <video playsinline controls muted preload style \"width:100%\" src \"https://wiki.sipeed.com/maixpy/static/video/maixvision.mp4\"></video> [MaixHub](https://maixhub.com) 在线 AI 模型训练平台，无需 AI 知识和昂贵的训练设备，一键训练模型，一键部署到 MaixCAM ![MaixVision](../../assets/maixcam/maixhub.jpg) [MaixCDK](https://github.com/sipeed/MaixCDK) MaixPy 的 C++版本，熟悉 C/C++ 的开发者立刻上手 请看[MaixCDK 主页](https://github.com/sipeed/MaixCDK) [应用商城](https://maixhub.com/app) 提供各种应用和工具，无需开发直接下载使用，开发者也可以上传分享应用 请看 [MaixHub 应用商城](https://maixhub.com/app) [分享广场](https://maixhub.com/share) 开发者分享经验和项目 请看 [MaixHub 分享广场](https://maixhub.com/share) [本地大模型](https://wiki.sipeed.com/maixpy/doc/zh/mllm/basic.html) 本地运行离线大模型 请看[大模型使用说明](https://wiki.sipeed.com/maixpy/doc/zh/mllm/basic.html) ## 资料汇总 ### MaixCAM 专属资料（Sipeed 提供） * [MaixCAM2 官方文档](https://wiki.sipeed.com/maixcam2)（本文档） * [MaixPy 官方文档](https://wiki.sipeed.com/maixpy/)（Python SDK）（[MaixPy 源码](https://github.com/sipeed/MaixPy)） * [MaixCDK](https://github.com/sipeed/MaixCDK)（C/C++ SDK）（[MaixCDK 源码](https://github.com/sipeed/MaixCDK)） * [系统源码](https://github.com/sipeed/maix_ax620e_sdk) * [系统烧录](./maixcam2_os.html) * [摄像头和镜头](./maixcam2_camera_lens.html) * [硬件相关资料下载](https://dl.sipeed.com/shareURL/MaixCAM/MaixCAM2) * [核心板资料](https://dl.sipeed.com/shareURL/MaixCAM/MaixCAM2) * 外壳和支架：开源了 外壳、支架等 3D 模型文件，请到[makerworld.com](https://makerworld.com/)（推荐） 或[makerworld.com.cn](https://makerworld.com.cn) 搜索 `MaixCAM`/`MaixCAM2`。 * 引脚映射图： > 注意: 为了防止插入PMOD等模块时插错位置导致模块烧毁, 默认将 `A2` 引脚堵住作为防呆设计 ![maixcam2_pins](../../assets/maixcam/maixcam2_pins.jpg) ### 芯片资料 MaixCAM2 其基于爱芯的 AX630C 芯片，所以也可以参考它们的资料。 * [芯片原厂 资料下载](https://dl.sipeed.com/shareURL/MaixCAM/MaixCAM2) * [芯片原厂 AI 模型](https://huggingface.co/AXERA TECH) * [芯片原厂 GitHub](https://github.com/AXERA TECH) ### 配件 * [TOF测距和热成像模块](./tof_thermal.html) * [显微套件](./microscope.html) ### 社区 * [MaixHub 应用商城](https://maixhub.com/app) * [MaixHub 分享广场](https://maixhub.com/share) * [GitHub](https://github.com) 搜索 `MaixCAM` 或者 `MaixPy` * [Bilibili](https://bilibili.com) 搜索 `MaixCAM` 或者 `MaixPy` * [makerworld.com](https://makerworld.com/)(推荐) 或者 [makerworld.com.cn](https://makerworld.com.cn) 搜索 `MaixCAM` * QQ 群: 862340358 * Telegram: [MaixPy](https://t.me/maixpy) ## 购买 * [Sipeed 淘宝](https://sipeed.taobao.com/) * [AliExpress](https://www.aliexpress.com/store/911876460)"},"/hardware/zh/maixcam/os.html":{"title":"MaixCAM 系统烧录","content":" title: MaixCAM 系统烧录 ## 下载系统 按照[MaixPy 系统烧录文档](https://wiki.sipeed.com/maixpy/doc/zh/basic/upgrade.html) 中的说明，下载对应型号的系统镜像文件 和 注意备份数据。 ## 准备烧录工具 下载 [Etcher](https://etcher.balena.io/)（强烈推荐），安装并打开。 Windows 也可以用 [Win32DiskImager](https://sourceforge.net/projects/win32diskimager/) 或 [Rufus](https://rufus.ie/)。 如果 Etcher 无法烧录可以试试这两个。 ## 启动烧录工具 正常情况下双击应用图标启动应用即可，如果遇到了`出了点问题。如果源镜像曾被压缩过，请检查它是否已损坏 Error spawning the child process`，可能是权限不够造成的，右键应用图标，使用管理员身份打开即可。 ## 烧录 TF 卡 有两种方式烧录 TF 卡： * 如果 TF 里面烧录过系统（比如买的官方的 TF 卡套餐或者自己烧录过），建议使用 USB 更新系统的方法更快捷。（对于 MaixCAM 还可以避免拆外壳。） * 如果你使用自己的卡， 且从来没有烧录过系统，那么必须至少要先用 读卡器烧录一次，然后安装 TF 卡，后面就可以直接使用 USB 烧录镜像了。 ### 方法一： 读卡器烧录 TF 卡 * 直接取出 TF 卡，插入读卡器，然后插入电脑。 * 打开 Etcher，选择镜像文件，选择 TF 卡，点击`Flash`。 * 等待烧录完成，如果电脑弹出`使用驱动器 G: 中的光盘之前需要将其格式化`这样的字符，**不要**点击格式化磁盘！不然刚烧录好的系统又被格式化了！ 关掉窗口， 右键磁盘，选择弹出 TF 卡即可。 * 将 TF 卡插入 MaixCAM，然后上电，等待系统启动，第一次启动会慢一点，等待一会即可。 ### 方法二： USB 更新 TF 卡镜像 **注意使用 USB 只能更新系统不能用作第一次烧录。** 请保证 TF 里面已经用 读卡器烧录过系统，并且**系统能正常运行**之后才能用这种方式。 * 对于 **MaixCAM Pro**: * MaixCAM Pro 断电（电池版本长按关机键关机），保持 TF 卡插入。 * 按住设备的 `user` 按键不松开，然后开机（插入 USB 线连接到电脑，电池版本可以按一下电源按钮），等待 U 盘设备出现在电脑上，然后再松开`user`按键。 * 打开 `Etcher`，选择镜像文件，选择 U 盘设备，点击`Flash`。 * 等待烧录完成，如果电脑弹出`使用驱动器 G: 中的光盘之前需要将其格式化`这样的字符，**不要**点击格式化磁盘！不然刚烧录好的系统又被格式化了！ 关掉窗口， 右键磁盘，选择弹出 TF 卡即可。 * 重启设备，等待系统启动，第一次启动会慢一点，等待一会即可（等待屏幕显示内容，保险起见等待1分钟左右），启动过程中不要断电，防止正在开机处理的文件损坏（解决方法是重新烧录镜像） * 对于 **MaixCAM**: * MaixCAM 断电，保持 TF 卡插入。 * 按住设备的 `user` 按键不松开，插入 USB 线连接到电脑，（或者先插入 USB 线，然后按住 `user`按键不放，再按一下`reset`按钮立即松开`reset`）等待 U 盘设备出现在电脑上，然后再松开`user`按键。 * 打开 `Etcher`，选择镜像文件，选择 U 盘设备，点击`Flash`。 * 等待烧录完成，如果电脑弹出`使用驱动器 G: 中的光盘之前需要将其格式化`这样的字符，**不要**点击格式化磁盘！不然刚烧录好的系统又被格式化了！ 关掉窗口， 右键磁盘，选择弹出 TF 卡即可。 * 然后按一下 `reset` 按键或者重新上电，等待系统启动，第一次启动会慢一点，等待一会即可（等待屏幕显示内容，保险起见等待1分钟左右），启动过程中不要断电，防止正在开机处理的文件损坏（解决方法是重新烧录镜像） > 如果发现进不了 U 盘升级模式，可能是系统文件损坏，使用读卡器烧录 TF 卡即可。 ## 使用系统注意点 ### 强制关机 除了上诉情况使用`reset`按钮，平时正常使用系统时**不建议按`reset`按钮**，这个按钮是强制断电，如果你的系统正在写入内容到 TF 卡，可能会造成系统和数据损坏。 另外系统仍在运行，强制拔掉电源和按`reset`按钮的是同样的问题，尽量**先软件关机再拔电源**。 正常使用请**软件关机或者重启**，方法： * 方法一： 界面选择`设置` >`电源` 进行软件关机或者重启。 * 方法二： 终端使用`poweroff` 或者`reboot`命令进行软件关机或者重启。 * 方法三：其它软件调用，比如 `Python` 调用 `import os;os.system(\"poweroff\")` 进行关机或者重启。 * 方法四：对于 MaixCAM Pro, 长按电源键4秒会触发软件`maix`模块的软关机功能，继续长按到8秒才会触发强制断电关机（固件版本 > 4.8.0才支持）。 ### 文件写入和内容丢失问题 系统做了缓存机制，当你的代码在写入文件时，可能只是写入到了内存，过一段时间后系统自动写入到磁盘，如果在这中间断电了，那么内容就没有写入到磁盘（TF卡），下次开机就会发现之前写入的内容不存在。 解决方法： * 尽量不直接断电或者按`reset`按键，使用上面说的软关机。 * 保存重要的内容，可以手动调用强制写入内容到磁盘的 API，比如在 `Python` 里面可以用`os.sync()`来告诉系统把所有缓存的文件立即写入到磁盘，其它的方式比如写入指定文件，以及其它语言请自性搜索类似`Linux 刷新内容到磁盘`的关键词。"},"/hardware/zh/maixcam/faq.html":{"title":"MaixCAM FAQ (常见问题)","content":" title: MaixCAM FAQ (常见问题) 下面找不到的问题，也可以参考[MaixPy FAQ](https://wiki.sipeed.com/maixpy/doc/zh/faq.html)。 ## MaixCAM 和 LicheeRV Nano 有什么区别？ MaixCAM 可以使用 LicheeRV Nano 和 SG2002 的资料， 反之 **LicheeRV Nano 和其它 SG2002 芯片产品没法使用 MaixPy MaixCDK MaixVision 等软件**，请不要购买错误浪费时间和金钱。 如果你希望快速上手开发应用，请选择 MaixCAM, 如果你是资深 Linux 开发者，只想基于 SG2002 原厂资料开发，可以选择 LicheeRV Nano。 ## 官方淘宝店怎么没有购买链接？ 淘宝在遇到缺货时可能会关闭购买链接，有货后会自动开放购买链接，可以咨询官方客服。 ## 上电启动黑屏，屏幕无显示 * 检查是否安装了 TF（micro SD）卡。 * 检查 TF 卡里面是否烧录了最新的系统镜像（强烈推荐烧录到最新的系统镜像），具体烧录方法看文档。 * 检查 TF 卡是否完全插进到了 TF 卡口，确保没有缝隙和松动。 * 检查屏幕和摄像头排线是否正确扣紧了，不能出现松动现象。 * 检查板子上的电源灯（红灯）以及系统运行状态灯（蓝灯）是否亮起，如果红灯不亮则考虑硬件问题，比如无供电或者供电不足或者板子烧坏了。 * 用 USB 转 TTL 连接电脑和板子的串口，电脑打开串口助手，让板子重启，查看启动日志里面是否有报错。 > 如果没有日志输出，可以尝试交换一下 TX 和 RX 接线， 对于 MaixCAM, Type C 转 串口小板插的方向不一样 TX RX 可能反向，即不支持正反插。 * 芯片的 `UART0_TX` 引脚有一个特性，当 TX 被拉低时，系统无法启动，所以也检查一下 UART0_TX 是不是连接了什么电路在启动时被拉低了，释放再启动就好了。 * 另外还有一个问题， MaixCAM 使用的芯片的所有引脚，在开机前不要有任何电流灌入，否则会导致电路异常无法启动。举个例子：比如 MaixCAM 通过串口外接了一个 MCU， MCU 的 TX/RX 引脚如果是高电平，就会将电流灌入 MaixCAM 导致 MaixCAM 无法启动， 另外，如果 MCU 的 TX 引脚输出了低电平，也就是 MaixCAM 的 RX 引脚为低电平，也会导致 MaixCAM 无法启动。 解决办法： * 最简单的解决办法就是 MaixCAM 先上电，然后 MCU 再上电或者同时上电。 * 如果 MCU 先上电，可以在 MCU 的 TX/RX 引脚接一个二极管防止电流流进 MaixCAM，以及保证 MCU 的 TX 引脚设置为浮空输入。 ## 上电卡在启动界面，无法进入系统 可能是应用程序环境出现了问题或者硬件出现了问题，可以按照下面的步骤拍查： * 如果卡里有重要的数据，可以先想办法备份数据： * 先尝试用 MaixVision 扫描设备连接设备，用文件管理功能备份重要数据。 * 如果 MaixVision 无法连接，可以用读卡器备份数据，对于 Windows 无法直接看到系统内容，可以用 diskginus 读取。 * 重新烧录最新的系统，如果可以正常进系统了，说明是系统文件受到损坏，不是硬件问题。 * 重新烧录**最新**系统镜像如果还无法启动，有可能是硬件问题，可以： * 先检查摄像头连接是否正常。 * 再看 PCB 是否有明显的器件出现了问题，比如掉落、连锡、烧毁、短路 等问题。 * 开可以尝试用 USB 转 TTL 连接电脑和板子的串口（A16/A17引脚），电脑打开串口助手，让板子重启，查看启动日志里面是否有报错。 > 如果没有日志输出，可以尝试交换一下 TX 和 RX 接线， 对于 MaixCAM, Type C 转 串口小板插的方向不一样 TX RX 可能反向，即不支持正反插。"},"/hardware/zh/maixcam/assemble.html":{"title":"MaixCAM / MaixCAM-Pro 外壳","content":" title: MaixCAM / MaixCAM Pro 外壳 ## 简介 拿到手有几个配件需要**注意**： * **镜头盖**： 运输过程中保护镜头，使用时请取下，不让画面会是黑的。 * **屏幕保护膜**：为了防止运输刮花屏幕，有一个塑料薄膜，到手请直接撕掉，不然会严重影响观感。 * **镜头手动对焦**： 镜头支持手动对焦，轻轻旋动镜头即可实现手动对焦，如果画面模糊则可能对焦不正确。 * **外壳**：一个 3D 打印外壳，方便握持和安装，同时增加美观性。 ## 开源模型文件 * [MaixCAM 外壳模型](https://makerworld.com.cn/zh/models/467141)（推荐使用耐温70度的树脂进行光固化打印） * [MaixCAM 支架模型](https://makerworld.com.cn/zh/models/467152) * [MaixCAM Pro 外壳模型](https://makerworld.com.cn/zh/models/575886) * M2*5 自攻螺丝 6 颗 * H1.5 内六角螺丝刀 ## 文档 作为一个合格的开发者，应该学会自己看文档，很多问题文档里都有 <iframe src \"//player.bilibili.com/player.html?isOutside true&aid 112842648849057&bvid BV12EeDeaEGp&cid 500001626320975&p 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\"></iframe> ## MaixCAM ### 拆机与组装视频教程 不要再在群里问排线掉了怎么装，视频里很清楚 <iframe src \"//player.bilibili.com/player.html?isOutside true&aid 1053969814&bvid BV1WH4y1V7kL&cid 1527447268&p 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\"></iframe> ### MaixCAM 拆机 强烈建议选择带 TF 卡的套餐，出厂默认已经组装好了，可以跳过这一步直接使用。 出厂默认已经组装好了，如果你需要更换 TF 卡，或者焊接排针，可以尝试拆机。 这里有几点需要注意： * 拆机前请确保已经断电。 * CPU和外壳之间有导热垫，拆机时请注意不要搞掉。 * 注意不要破坏摄像头、触摸、屏幕的排线（比较容易松动），不要折断排线。 * 注意排线的方向，不要插反。 ### MaixCAM 更换TF卡 1. 向外抠开机身两侧卡扣即可分离前后盖 ![](../../assets/maixcam/assemble 1.jpg) 2. 将固定屏幕的外壳掀开后即可看见TF卡 ![](../../assets/maixcam/assemble 2.jpg) 3. 装回屏幕前请确认屏幕排线的连接是否正常，如果有歪斜，请先将排线重新插好 ![](../../assets/maixcam/assemble 3.jpg) ## MaixCAM Pro 对于 MaixCAM Pro，如非必要，不建议拆壳。 * 首先需要自备六角螺丝刀。 * 拧下背后的螺丝可以拆下背板。 * 要拆下 PCB 需要小心地将屏幕扣起来（留的缝隙处扣），注意后面有排线，不要扯断排线。 * 然后会看到螺丝钉，拧下就可以拆下PCB，如果是电池版，则可以看到电池在屏幕后面。 **注意**：拆下屏幕后会导致粘合屏幕和外壳的胶失去黏性，需要自己自行补胶才能牢固。"},"/hardware/zh/maixcam/maixcdk.html":{"title":"在 MaixCAM 上使用 MaixCDK","content":" title: 在 MaixCAM 上使用 MaixCDK ## 介绍 MaixCDK 是为 Maix 系列产品设计的一个方便开发者快速开发 AI 应用的 C++ SDK，有着简单易用的 API，支持各种 AI 相关的功能，以及多种外设操作。 具体请看 [MaixCDK](https://wiki.sipeed.com/maixcdk/)。 另外其 Python 版本的 SDK 是 [MaixPy](https://wiki.sipeed.com/maixpy/)，是一个更简单易用的 Python SDK。"},"/hardware/zh/maixcam/maixcam2_os.html":{"title":"MaixCAM2 系统烧录","content":" title: MaixCAM2 系统烧录 ## 获取系统文件 目前只提供了`.img`格式的镜像, 可能压缩后的后缀为`.img.xz`， 如果镜像大小大于`2G`则会被分卷压缩为`.img.7z.00x` [下载镜像(百度网盘)](https://pan.baidu.com/s/1nk60bNu5QhdNAsp7e_c xw) 提取码:`dshn` [下载镜像(MEGA)](https://mega.nz/folder/1tolGbba#ki5_NgGIc_omAv0zRU19Lg) **镜像选择说明**: 推荐选择：正常情况下出厂已经烧录过一次启动分区，所以可以直接用方法二烧录`.img`文件，遇到启动分区损坏的情况再考虑用方法一烧录。 1. `.axp`系统镜像 包含了完整的系统 `优点`：无论 EMMC 内是否有启动分区和系统都能成功烧录。<br />`缺点`：只支持Windows，烧录速度慢。 格式 <center>说明</center> : : : `maixcam2 xxx maixpy xxx.axp` `.axp`系统镜像, 包含了完整的系统，可以通过[AXDL](https://dl.sipeed.com/shareURL/MaixCAM/MaixCAM2/Software/Tools) 软件烧录 `maixcam2 xxx maixpy xxx.axp.7z.00x` 通过`7z`解压后可以得到`.axp`系统镜像, 使用了分卷压缩将镜像分割成多个文件来方便上传, 需要下载所有的分卷文件后才能解压 2. `.img`系统镜像 包含了完整的系统 `优点`：支持USB烧录和TF卡烧录，不受烧录系统和软件限制，速度快（TF > USB2.0 > AXDL）。<br />`缺点`: 只有在 EMMC 已经烧录过**启动分区**时才能正常使用。如果没有启动分区或者损坏，则需要用方法一烧录一次 `*.axp` 系统才能使用方法二。 格式 <center>说明</center> : : : `maixcam2 2026 01 27 maixpy v4.12.5.img` `.img`系统镜像,包含了完整的系统，使用通用工具比如`etcher / rufus / win32diskimager / imageUSB`等即可烧录。可以通过`TF卡烧录`或`USB烧录` `maixcam2 xxx maixpy xxx.img.7z.00x` 通过`7z`解压后可以得到`.img`系统镜像, 使用了分卷压缩将镜像分割成多个文件来方便上传, 需要下载所有的分卷文件后才能解压 `boot_parts_maixcam2 xxxx xx xx maixpy x.x.x.axp` 该文件是一个最小启动镜像, **一般不需要烧录**, 只有当板子无法通过TF卡烧录或USB烧录时, 参考烧录`.axp`格式的方法烧录这个文件后, 即可恢复TF卡烧录和USB烧录的功能. 3. TF卡系统镜像 包含了完整的系统, 但是只能从TF卡启动. 也就是把镜像烧录到TF卡上, 从TF卡加载系统. 适用于不需要`EMMC`的情况 `优点`: 不使用板载EMMC, 价格便宜 `缺点`: 受限于`TF`读取速度, 软件的读写时间会变慢 格式 <center>说明</center> : : : `maixcam2 2026 01 27 maixpy v4.12.5_sd.img` `.sd_img`系统镜像, 用于需要`TF卡`启动时烧录的镜像 `maixcam2 2026 01 27 maixpy v4.12.5_sd.img.7z.00x` 通过`7z`解压后可以得到`.sd_img`系统镜像, 使用了分卷压缩将镜像分割成多个文件来方便上传, 需要下载所有的分卷文件后才能解压 > `7z`解压方法说明: > > 如果是`linux`系统, 可以使用`7z`进行解压, 将所有分卷文件放到同一个文件夹下后, 执行'`7z x maixcam2 2025 12 22 maixpy v4.12.4.img.7z.001`' > 如果是`windows`系统, 将所有分卷文件放在同一个文件夹，然后对第一个文件（`.7z.001`或者`.7z`）右键，选择 7 Zip > 解压文件或提取到“指定文件夹”，软件会自动合并并解压，注意所有分卷必须完整且命名无误 ## 系统启动流程简介 为了让你更好理解烧录系统，这里介绍一下启动流程（简单版本）： 1. 开机上电，芯片内部程序(bootrom)检测`boot/Func`引脚是否拉低（MaixCAM2 的 `Func` 按键按下），如果拉低则进入 `AXDL` USB 下载固件模式，会等待 AXDL 软件通过 USB 通信至少 **5 秒以上**。 没有按下或者超过5s没有通信则正常启动。 2. 加载内部 `EMMC` 储存（`启动分区、系统和资料放在这里`）中的**启动分区**的固件，这个固件也会判断`boot/Func` 按键是否按下，如果按下，进入 USB / TF 升级模式。 没有按下则正常加载 `EMMC 中的系统`启动。 ## 烧录方法 ### 方法1: USB 烧录 .axp 系统到 EMMC 如文章开头所说，烧录分为三种方法，各有其优点，这里先详细介绍第一种。 #### 下载 AXDL 软件 下载 [AXDL](https://dl.sipeed.com/fileList/MaixCAM/MaixCAM2/Software/Tools/AXDL_V1.24.22.1.7z)。（只支持 Windows）。 下载 [AXDL 驱动](https://dl.sipeed.com/fileList/MaixCAM/MaixCAM2/Software/Tools/Driver_V1.20.46.1.7z), 解压后运行`DriverSetup.exe`安装驱动，如果安装完驱动后还是不能识别，请尝试重启电脑 打开 AXDL 软件界面 #### 准备系统 前面下载的`.axp`格式的系统，注意，一般提供两种`.axp`系统文件，如: * `maixcam2 2025 09 01 maixpy v4.11.9.axp`: **完整的** MaixCAM2 可以使用的`.axp` 文件，文件大小`8GB`左右。 * `boot_parts_maixcam2 2025 09 01 maixpy v4.11.9.axp`: **只包含启动分区**的烧录文件，文件大小`<50MB`。 也就是说你可以： * 选择一次 AXDL 烧录完整系统，烧录完即可启动运行系统。 * 你更喜欢 USB / TF 卡烧录的方式，但是启动分区意外受损（“变砖”），只想快速恢复**启动分区**，则选择`boot_parts_xxx.axp`再用方法二烧录完整系统。 #### 加载和烧录系统文件 * 点击加载系统文件按钮，选择加载下载的`.axp`格式的系统。 * 等待加载完毕后，点击开始按钮，就会开始自动检测 USB。 * 按住`boot/Func`按钮不放，再插上 USB 到电脑， AXDL 就会自动开始下载系统，然后松开按钮等待即可。 * 或者先插上 USB 到电脑，再按住`boot/Func`按钮不放，拨动电源开关重新上电，等 AXDL 检测到后再松开按钮。 * 下载过程中建议不要触碰 USB 线和板子，以免接触不良失败。 * 下载完成后会自动重启进入系统，第一次启动请至少等到启动进入主界面后才能断电，防止第一次文件初始化丢失。 ### 方法2: USB 烧录 .img 系统到 EMMC 相比烧录 `.axp`格式的文件，这种方式会更快更方便，任何操作系统都能烧录，而且速度更快（~ 40MiB/s）。 #### 选择合适的烧录软件 这里以 [Etcher](https://etcher.balena.io/) 为例，其它软件使用方法类似。 Windows 也可以用 [Win32DiskImager](https://sourceforge.net/projects/win32diskimager/) 或 [Rufus](https://rufus.ie/) 或 [imageUSB](https://www.osforensics.com/tools/write usb images.html)。 如果 Etcher 无法烧录可以试试这两个。 如果遇到了`出了点问题。如果源镜像曾被压缩过，请检查它是否已损坏 Error spawning the child process`，可能是权限不够造成的，右键应用图标，使用管理员身份打开即可。 如果仍然无法解决，或者烧录后无法启动，可以用`rufus`或者`win32diskimager`等其它软件烧录。 #### 加载和烧录系统文件 > 下载过程如果`Etcher`会报错`Missing partition table` `not a bootable image ...`即检测不到分区表，对于`MaixCAM2`是正常现象，点击`Continue`继续即可。 * 加载前面下载并解压后的系统，注意不要弄混了文件，比如`MaixCAM2`的镜像文件是`maixcam2 2025 09 01 maixpy v4.11.9.img`。 * 上电进入 USB / TF 卡升级模式，两种方式： * 方式1：USB 一端插电脑，然后另一端插上板子的`1秒内`按住`boot/Func`按钮不放，`3秒`后即可松开。 * 方式2：先关机，USB 连接电脑和板子，打开电源开关的`1秒内`按住`boot/Func`按钮不放，`3秒`后即可松开。 > 这里不先按住`Func`按钮再开机的原因是按住再开机会进入 AXDL 下载模式，要等待至少 5秒才能进入，太慢了。 * 然后等待几秒，就能在下载软件选择烧录磁盘，可以看到板子虚拟的 U盘设备了。另外也可以看到蓝色 LED 按照 `灭 亮 亮` 进行双闪。 * 点击软件的烧录(Flash)按钮，开始进行烧录（可能会需要管理员权限）。这时板子蓝色 LED开始`亮0.5s 灭0.5s`闪烁。 * 烧录过程或者完成后，如果电脑弹出`使用驱动器 G: 中的光盘之前需要将其格式化`这样的字符，**不要**点击格式化磁盘！不然刚烧录好的系统又被格式化了！ 关掉窗口即可。 * 等待烧录完毕，`蓝色 LED 会变成常亮`表示烧录完毕，软件可能还没完成，比如软件会读取 EMMC 内容检验是否出错（也可以跳过，不过校验是加一层保险，建议还是等待其校验完成）。 * 如果烧录软件不会自动弹出 U 盘，建议手动弹出 U盘保证数据都写入了。 * 手动重启（重新上电）即可进入新系统，第一次进入系统注意至少要等到进入主界面后才能关机断电，防止初始化出错。 ### 方法3: TF 卡烧录 .img 系统到 EMMC 方法和 USB 烧录 .img 类似，一般速度更快（取决于你的 TF卡速度，比如 `~ 90MiB/s`）。 #### 制作 TF 升级卡 * 使用读卡器将 TF 卡插到电脑。 * 格式化 TF 卡，至少创建一个主分区, 可以选择 `exFAT` 或者`ext4`格式（不要选择`FAT32`）, 一定要给TF分区。 * 将`xxx.img`文件拷贝到 TF 卡的第一个分区中。如果之前拷贝了其他`.img`文件, 需要删除旧的镜像文件 * 拷贝完成后需要**点击弹出 U 盘**保证数据玩全写入后再拔出读卡器，防止数据未写入完成导致系统文件损坏。 * 将 MaixCAM2 断电, 再将 TF 卡插入 MaixCAM2 * MaixCAM2上电开机, 并在`1秒内`按住`boot/Func`按钮不放。 * 开机后板子会自动检查 TF 卡中的系统文件，自动进行烧录，此时蓝色 LED开始`亮0.5s 灭0.5s`闪烁。 > 如果不是这样闪烁可能前面的步骤有误。 * 烧录完成后`蓝色 LED 会变成常亮`。如果`亮0.3s 灭0.3s`快闪则表示烧录失败（一般不会出现），不要关机，直接用方法二 USB 烧录补救，如果关机了可以再试试重启会不会进入升级模式，不会的话说明启动分区受损，就需用 AXDL 烧录启动分区了。 * 手动重启（重新上电）即可进入新系统，第一次进入系统注意至少要等到进入主界面后才能关机断电，防止初始化出错。 #### 加载和烧录系统文件 * 加载前面下载并解压后的系统，注意不要弄混了文件，比如`MaixCAM2`的镜像文件是`maixcam2 2025 09 01 maixpy v4.11.9.img`。 * 上电进入 USB / TF 卡升级模式，两种方式： * 方式1：USB 一端插电脑，然后另一端插上板子的`1秒内`按住`boot/Func`按钮不放，`3秒`后即可松开。 * 方式2：先关机，USB 连接电脑和板子，打开电源开关的`1秒内`按住`boot/Func`按钮不放，`3秒`后即可松开。 > 这里不先按住`Func`按钮再开机的原因是按住再开机会进入 AXDL 下载模式，要等待至少 10秒才能进入，太慢了。 * 然后等待几秒，就能在下载软件选择烧录磁盘，可以看到板子虚拟的 U盘设备了。另外也可以看到蓝色 LED 按照 `灭 亮 亮` 进行双闪。 * 点击软件的烧录(Flash)按钮，开始进行烧录（可能会需要管理员权限）。这时板子蓝色 LED开始`亮0.5s 灭0.s`闪烁。 * 等待烧录完毕，蓝色 LED 会变成常亮表示烧录完毕，软件可能还没完成，比如软件会读取 EMMC 内容检验是否出错，可以等待其校验完成。 * 手动重启（重新上电）即可进入新系统，第一次进入系统注意至少要等到进入主界面后才能关机断电，方式初始化出错。 ## 通过TF卡启动系统 不想使用`EMMC`时, 可以通过`TF`卡来启动系统, 需要下载`xxx_sd.img`格式镜像 ### 准备烧录工具 下载 [Etcher](https://etcher.balena.io/)（强烈推荐），安装并打开。 Windows 也可以用 [Win32DiskImager](https://sourceforge.net/projects/win32diskimager/) 或 [Rufus](https://rufus.ie/)。 如果 Etcher 无法烧录可以试试这两个。 ### 烧录镜像到TF卡 通过读卡器烧录镜像到TF卡 准备一张 32G以上的TF 卡，插入读卡器，然后插入电脑。 打开 Etcher，选择`xxx_sd.img`格式镜像文件，选择 TF 卡，点击`Flash`。 等待烧录完成，如果电脑弹出`使用驱动器 G: 中的光盘之前需要将其格式化`这样的字符，**不要**点击格式化磁盘！不然刚烧录好的系统又被格式化了！ 关掉窗口， 右键磁盘，选择弹出 TF 卡即可。 将 TF 卡插入 MaixCAM2，然后上电，等待系统启动，第一次启动会慢一点，等待一会即可。 注意: > 带`EMMC`的MaixCAM2,需要按住`Func`按钮再上电才会从`TF`卡加载镜像 ## 使用系统供电注意点 ### 断电和关机 除了上诉情况直接断电（包括拨动开关机按钮也是强制断电），平时正常使用系统时**不建议强制断电**来关机，如果你的系统正在写入内容到 TF 卡，可能会造成数据写入失败，以及系统有缓存机制，可能只是写入到内存，还没同步到磁盘。 另外系统仍在运行，强制拔掉电源和按`reset`按钮的是同样的问题，尽量**先软件关机再拔电源**。 正常使用请**软件关机或者重启**，方法： * 方法一： 主界面长按`Func`按钮选择关机，或者`设置` >`电源` 进行软件关机或者重启。 * 方法二： 终端使用`poweroff` 或者`reboot`命令进行软件关机或者重启。 * 方法三：其它软件调用，比如 `Python` 调用 `import os;os.system(\"poweroff\")` 进行关机或者重启。 ### 文件写入和内容丢失问题 系统做了缓存机制，当你的代码在写入文件时，可能只是写入到了内存，过一段时间后系统自动写入到磁盘，如果在这中间断电了，那么内容就没有写入到磁盘（TF卡），下次开机就会发现之前写入的内容不存在。 解决方法： * 尽量不直接断电或者按`reset`按键，使用上面说的软关机。 * 保存重要的内容，可以手动调用强制写入内容到磁盘的 API，比如在 `Python` 里面可以用`os.sync()`来告诉系统把所有缓存的文件立即写入到磁盘，其它的方式比如写入指定文件，以及其它语言请自性搜索类似`Linux 刷新内容到磁盘`的关键词。"},"/hardware/zh/maixcam/cameras.html":{"title":"摄像头介绍及拍摄效果","content":" title: 摄像头介绍及拍摄效果 ## 摄像头模块参数对比 **传感器型号** GC4653 OS04A10 SC035HGS **分辨率** 2560x1440 2688x1520 640x480 **尺寸** 1/3\" **1/1.79\"** 1/6\" **相元尺寸** 2.0um 2.9um 3.744um **快门类型** 卷帘快门 卷帘快门 **全局快门** **帧率** 30fps@2K, 60fps@720P 30fps@2K 180fps@VGA **最长曝光** 0.5s 45s TBD **灵敏度** 2.4V/Lux.s 32000e/Lux.s 6.5V/Lux.s **动态范围** 81dB 120dB 60dB **镜头焦距** 3.05mm 4.9mm **镜头光圈** F2.5 F1.65 **镜头畸变** 5% 25% **视场角** D90° H81° V51° D100° H87° V49° > 注意：OS04A10 相元大，镜头光圈大，夜视效果好；但是由于光圈大，它的景深很小，50cm处景深8cm，200cm处景深60cm * [传感器手册下载](https://dl.sipeed.com/shareURL/MaixCAM/Sensors) ## 传感器选型建议 1. GC4653, 适用于常规应用，画质表现不错，降分辨率到720P时可获得60fps的高帧率 2. OS04A10, 适用于对暗光有要求的场景（如天文摄影，暗场摄影，匀光摄影），噪点控制相对GC4653好很多，并且可达到接近1分钟的长曝光。sensor本身支持极高的帧率(2K@90fps,720p@180fps,360p@360fps,180p@720fps), 只是目前maixcam未调试 3. SC035HGS, 全局摄像头，不会有卷帘快门的果冻变形效应，适用于高速运动物体的抓拍，示例视频就是抓拍高速旋转的唱片上的二维码. ## 传感器实拍效果对比 测试项 GC4653 OS04A10 色卡色彩![gc4653_color](../../assets/maixcam/GC4653_color_1.jpg)![OS04A10_color](../../assets/maixcam/OS04A10_color_1.jpg) 远处细节![gc4653_far](../../assets/maixcam/GC4653_far_1.jpg)![OS04A10_far](../../assets/maixcam/OS04A10_far_1.jpg) 暗处表现![gc4653_dark](../../assets/maixcam/GC4653_dark_1.jpg)![OS04A10_dark](../../assets/maixcam/OS04A10_dark_1.jpg) 室内，走廊，楼梯间全黑环境下对比 <video playsinline controls muted preload style \"width:100%\" src \"../../assets/maixcam/comapre_gc4653_os04a10.mp4\"></video> **OS04A10拍摄星空延时摄影效果** 使用鱼眼镜头拍摄 <video playsinline controls muted preload style \"width:100%\" src \"../../assets/maixcam/os04a10_stars.mp4\"></video> **OS04A10长曝光拍摄M42星云效果** 使用400mm望远镜拍摄，15s曝光，多张叠加 ![OS04A10_m42](../../assets/maixcam/os04a10_m42.jpg) **OS04A10显微拍摄硅藻效果** 使用暗场显微镜拍摄，多张拼接 ![OS04A10_guizao](../../assets/maixcam/os04a10_guizao.jpg) 局部单张细节 ![OS04A10_guizao1](../../assets/maixcam/os04a10_guizao1.jpg)"},"/hardware/zh/kvm/NanoKVM_Pro/lcd.html":{"title":"NanoKVM Desk 触摸屏&旋钮","content":" title: NanoKVM Desk 触摸屏&旋钮 keywords: NanoKVM, Auxiliary Screen update: date: 2025 10 10 version: v0.1 author: zepan content: initial docs date: 2025 10 18 version: v0.2 author: bugu content: improve docs ## 简介 NanoKVM Pro Desk 配备了1.47inch 320x172的迷你显示屏，除了作为基础配置交互外，它还可以用不同方式显示用户自定义内容，作为副屏使用 ## HDMI 副屏 NanoKVM Pro工作时就是虚拟为显示器，所以可以采集HDMI图像并在自身屏幕上显示，实现HDMI副屏功能。 在UI中选择输出视频源为HDMI即可在小屏上输出采集的视频图像。 作为桌面摆件时，此功能可以作为桌面迷你副屏，性能监控，视频缩略图播放器等功能使用。 ![](./../../../assets/NanoKVM/pro/lcd/hdmi.jpg) <div style \"display: grid; grid template columns: 1fr 1fr; gap: 10px;\"> <video playsinline controls muted preload src \"../../../assets/NanoKVM/pro/lcd/cat.mp4\"></video> <video playsinline controls muted preload src \"../../../assets/NanoKVM/pro/lcd/video.mp4\"></video> </div> ## USB 副屏 目前 USB 副屏功能仅支持 Windows 系统。 1. 下载并解压 USB 副屏驱动程序。 https://github.com/sipeed/NanoKVM Pro/releases/download/v1.0.5/nanokvmpro_usb_graphic_win.zip 2. 在 Desk 上：从屏幕中点击 `Settings` → `USB` 进入 USB 配置页面，开启 `Panel`。 3. 在被控机上： 打开 `设备管理器` → `其他设备` 找到 `NanoKVMPro` → 右键 `属性` → `驱动程序` → `更新驱动程序` 选择 `浏览我的电脑以查找驱动程序` → `让我从计算机上的可用驱动程序列表中选取` 双击 `显示所有设备` 在 `Standard USB Host Controller` / `标准 USB 主机控制器` / `Standard system devices` / `标准系统设备` 中找到 `USB 复合设备 (USB Composite Device)` → 双击安装 > **注意**：不同版本 Windows 驱动位置可能有所差异，请耐心查找。 4. 完成后，`设备管理器` 的 `其他设备` 下会出现一个新的 `loop input to output` 设备。 5. 右键该设备 → `更新驱动程序` → `浏览我的电脑以查找驱动程序` → `浏览` → 选择 USB 副屏驱动文件夹 → `下一步` → 按提示完成安装。 > 如果在安装驱动时遇到\"Windows 已找到设备的驱动程序，但在尝试安装它们时遇到错误\"或类似错误，可以选择以下方法解决： > > **方法一：临时禁用驱动程序强制签名** > 1. 按住 `Shift` 键，点击 `开始菜单` → `重启` > 2. 进入高级启动选项后，选择 `疑难解答` → `高级选项` → `启动设置` → `重启` > 3. 重启后按 `F7` 或 `7` 选择 `禁用驱动程序强制签名` > 4. 系统启动后重新安装驱动程序 > 5. 该方法在较新的 Windows 11 版本上可能无法使用 > > **方法二：启用测试模式（需要关闭安全启动）** > 1. 进入 BIOS 设置界面，根据主板说明关闭安全启动 > 2. 以管理员身份打开 `命令提示符` 或 `PowerShell` > 3. 执行命令：`bcdedit /set testsigning on` > 4. 重启电脑后即可安装未签名驱动 > 5. 如需关闭测试模式，执行：`bcdedit /set testsigning off` 并重启 > > **注意**：测试模式下桌面右下角会显示\"测试模式\"水印，这是正常现象。 6. 驱动安装完成后，`显示适配器` 部分会出现一个新的 NanoKVM 显卡设备。 7. 在 Desk 上从屏幕中进入副屏页面，选择 USB，即可将 Desk 用作 USB 副屏。 8. 若需关闭，参考步骤 2 关闭 `Panel`。 9. 再次开启时，部分系统可能需要重新安装 USB 驱动。 ## 自定义显示 > 注：此功能需要 NanoKVM Desk 更新至 `1.1.5` 以及以上的应用版本 NanoKVM Desk 在`1.1.5` 版本中新增了用户自定义APP功能，通过长按屏幕/旋钮，切换到第四页面，可以看到所有的APP，默认预装三个Demo：`coin`、`conway`、`hello` [hello.py](../../../assets/NanoKVM/pro/lcd/hello.py) [conway.py](../../../assets/NanoKVM/pro/lcd/conway.py) [coin.py](../../../assets/NanoKVM/pro/lcd/coin.py) <div style \"display: grid; grid template columns: 1fr 1fr; gap: 10px;\"> <video playsinline controls muted preload src \"../../../assets/NanoKVM/pro/lcd/doom.mp4\"></video> <video playsinline controls muted preload src \"../../../assets/NanoKVM/pro/lcd/conway.mp4\"></video> </div> <div style \"display: grid; grid template columns: 1fr 1fr; gap: 10px;\"> <video playsinline controls muted preload src \"../../../assets/NanoKVM/pro/lcd/pao.mp4\"></video> <video playsinline controls muted preload src \"../../../assets/NanoKVM/pro/lcd/coin.mp4\"></video> </div> ### 如何构建自己的应用 NanoKVM Desk 会在系统 `/userapp` 目录下查找所有的文件夹，并将文件夹名称作为APP名称，建议文件夹名小于8个字符 `User APP` 界面下点击用户自定义用户程序后将会尝试启动文件夹内名为 `main.py` 的 Python 应用 此时小屏使用标准FB驱动，用户可以使用 `/dev/fb0` 来实现自定义的屏幕显示操作。 点击屏幕或按下旋钮将退出应用"},"/hardware/zh/kvm/NanoKVM_Pro/introduction.html":{"title":"简介","content":" title: 简介 keywords: NanoKVM, Remote desktop, Lichee, PiKVM, ARM, tool, PCIe update: date: 2025 8 25 version: v0.1 author: BuGu content: Release docs ## 简介 NanoKVM Pro 是 NanoKVM 的延续，作为 IP KVM 产品继承了 NanoKVM 系列的极致体积和强大扩展性，在性能上有了质的飞跃，更加适合远程办公场景。 为满足不同用户的需求，NanoKVM Pro 提供两种形态：NanoKVM Desk 与 NanoKVM ATX： ![](./../../../assets/NanoKVM/pro/introduce/combine.png) NanoKVM Desk 意为桌面版NanoKVM Pro，主体采用阳极氧化的磨砂金属外壳，前面板使用1.47寸触摸屏显示KVM核心信息，并且可以方便设置硬件功能，或作为mini副屏使用，搭配左侧无极旋钮获得更有质感的使用体验。 NanoKVM ATX 是NanoKVM Pro的机箱内版本，标配半高/全高挡板可安装在机箱内部，由于可以内置的USB线缆[3]和电源控制接口更方便主机用户安装。通过外部连接HDMI接口、网线和USB即可实现远程控制。 NanoKVM Pro 采用AX630作为主控核心，采用 ARM 1.2G 双核 A53 CPU；外置 1GB LPDDR4 内存为远程桌面连接提供强有力的计算支持。内置HDMI环出+采集芯片，最高提供4K60FPS的HDMI环出和4K45FPS视频采集[1]。得益于AX630高效且强大的图像处理架构，NanoKVM Pro可以以极低的延迟传输高分辨率画面，2K画面下典型延迟低至60ms[2]。 IP KVM系列产品是远程桌面的硬件外挂，通过HDMI捕捉画面，通过网络实时同步画面与键鼠操作，最后模拟键鼠完成对电脑的控制。由于该方式整个流程不需要主机软件，完全由外部硬件实现，因此NanoKVM可以实现对主机的BIOS级别控制，尤其在远程开关机、多系统切换、BIOS配置、远程装机等场景下有广泛的应用空间。 由于升级后的的强大性能，NanoKVM Pro 不仅为临时维护提供可靠支持，由于其低延迟高分辨率特性，还能在远程办公领域大展身手。后期我们将对 NanoKVM Pro 的软件进行持续升级，带来更方便的自动化/MCP功能和更广泛的兼容性。 为满足用户不同需求，NanoKVM Pro 提供 WiFi、PoE、屏幕边缘同步灯带等可选项，相关配置和价格请以购买页面为准。 ## 参数 产品 NanoKVM Pro NanoKVM GxxKVM JxxKVM 主控 AX630C SG2002 RV1126 RV1106 核心 <2xA53@1.2G> <1xC906@1.0G> <4xA7@1.5G> <1xA7@1.2G> 内存 1G LPDDR4X 256M DDR3 1G DDR3 256M DDR3 硬盘 32G eMMC 32G microSD 8G eMMC 16G eMMC 系统 NanoKVM+PIKVM NanoKVM GxxKVM JxxKVM 分辨率 4K@45fps, 2K@95fps[4] 1080P@60fps 4K@30fps, 2K@60fps 1080P@60fps HDMI环出 4K环出 × × × 视频编码 MJPG/H264/H265[5] MJPG/H264 MJPG/H264 MJPG/H264 音频传输 √ × √ × UEFI/BIOS支持 √ √ √ √ 模拟USB键盘鼠标 √ √ √ √ 模拟USB ISO √ √ √ √ IPMI √ √ √ × 网络唤醒(WOL) √ √ √ √ WebSSH √ √ √ √ 自定义脚本 √ √ × × 串行终端 2通道 2通道 无 1通道 存储性能 32G eMMC 300MB/s 32G MicroSD 12MB/s 8G eMMC 120MB/s 8G eMMC 60MB/s 以太网 1000M 100M 1000M 100M 机箱内形态 可选 ATX版本 可选 PCIe版本 × × WiFi 可选WiFi6 可选WiFi6 × × MicroSD 扩展 √ × × × ATX电源控制 √ √ +15$ +10$ 显示屏 1.47英寸 320x172 LCD<br>0.96英寸 128x64 OLED 0.96英寸 128x64 OLED 无 1.66英寸 280x240 更多功能 同步LED灯效, 智能助手 – – – 功耗 0.6A@5V 0.2A@5V 0.4A@5V 0.2A@5V 电源输入 USB C/PoE USB C/PoE/PCIe USB C USB C 尺寸 65x65x28mm 40x36x36mm 80x60x7.5mm 60x6x24 30mm ## 相关资料 + [NanoKVM Pro 镜像下载](https://github.com/sipeed/NanoKVM Pro/releases/latest) + [ATX上手指南](https://wiki.sipeed.com/hardware/zh/kvm/NanoKVM_Pro/atx_start.html) + [高级应用](https://wiki.sipeed.com/hardware/zh/kvm/NanoKVM_Pro/extended.html) + [常见问题](https://wiki.sipeed.com/hardware/zh/kvm/NanoKVM_Pro/faq.html) ## 购买入口 [淘宝](https://item.taobao.com/item.htm?id 994419942411) [速卖通](https://www.aliexpress.com/item/1005010048471263.html) [预售页面](https://sipeed.com/nanokvm/pro) ## 产品反馈 如果您在使用过程中有任何问题或建议，请通过以下渠道和我们反馈： + [Github issues](https://github.com/sipeed/NanoKVM Pro/issues) + [MaixHub 论坛](https://maixhub.com/discussion/nanokvm) + QQ 交流群: 703230713 > [1] 在仅环出场景下可以单独关闭采集功能来直接环出4K60的画面；环出+采集同时运行时可以达到4K30FPS； > [2] 延迟可能会受到网络带宽和网络节点等原因有所差异，实测数据来源于Sipeed实验室； > [3] USB HID接口可以机箱内部接线，也可以外部连接，二选一即可； > [4] 由于4K45FPS非标准下的模式，出厂默认采用4K30+2K60，后续更新解锁4K45FPS/2K95FPS/1080P144FPS的方法； > [5] 目前出厂支持H264/MJPEG模式，后续更新将提供H265支持；"},"/hardware/zh/kvm/NanoKVM_Pro/ledstrip.html":{"title":"屏同步氛围灯带","content":" title: 屏同步氛围灯带 keywords: NanoKVM, LED Strip update: date: 2025 10 07 version: v0.2 author: zepan content: improve docs date: 2025 09 05 version: v0.1 author: iawak9lkm content: Release docs ## 简介 屏同步氛围灯带是NanoKVM Pro的特色扩展配件。 当你将NanoKVM Pro用于桌面电脑时，NanoKVM Pro可以通过捕获的屏幕画面，控制LED灯带按屏幕边缘的色彩显示，实现梦幻的灯光渲染效果！ ![ledstrip_pic](../../../assets/NanoKVM/pro/ledstrip/ledstrip_pic.jpg) <video playsinline controls muted preload src \"../../../assets/NanoKVM/pro/ledstrip/sync_led2.mp4\"></video> > ⚠️ 注意：使用该功能，需要确保输入电源规格 **5V ≥ 3A** ## 套餐配件概览 如果您购买了灯带套餐，您将获得以下配件： ![ledstrip_ov](../../../assets/NanoKVM/pro/ledstrip/ledstrip_ov.jpg) 1. 一分二数据线 2. 灯带转接套件（含 6 个转接件和 3 根直角转接线） 3. 一卷 LED 灯带 ## 安装步骤 ### 确认安装方向 ![ledstrip_screen](../../../assets/NanoKVM/pro/ledstrip/ledstrip_screen.jpg) > 第④段为可选，支持三边模式和四边模式，根据您的需求来选择即可 > > 灯带采样顺序为：**屏幕左下角 → 左上角 → 右上角 → 右下角 → 左下角** 。 > 安装时请保持一致。绿色端为灯带的 Type C 接口，另一端通过转接线连接至 NanoKVM Pro。 ### 裁剪灯带 ![ledstrip_cut_st0](../../../assets/NanoKVM/pro/ledstrip/ledstrip_cut_st0.jpg) 根据屏幕长宽裁剪灯带。 > 对边的灯珠数量需要保持一致。 示例：屏幕高度 18 颗灯珠，宽度 30 颗灯珠。 * 第①段：18 颗 * 第②段：30 颗 * 第③段：18 颗 * 第④段：30 颗 裁剪时请沿红线位置（触点中间）对半剪开： ![ledstrip_cut_st1](../../../assets/NanoKVM/pro/ledstrip/ledstrip_cut_st1.jpg) ### 打开转接件 在下图右侧为转接件**侧视图**，红框处掰开转接件，效果如左图： ![ledstrip_con_st2](../../../assets/NanoKVM/pro/ledstrip/ledstrip_con_st2.jpg) ### 插入线材 将灯带和直角转接线分别插入转接件两侧，确保金属触点与转接件内的桥接金属对应。闭合转接件后固定。 ![ledstrip_con_st3](../../../assets/NanoKVM/pro/ledstrip/ledstrip_con_st3.jpg) 接入另一端直角转接线，**注意灯带箭头方向（信号传输方向）保持一致**。 重复此步骤，直至所有灯带完成连接。 ![ledstrip_con_st4](../../../assets/NanoKVM/pro/ledstrip/ledstrip_con_st4.jpg) ### 粘贴灯带 撕开灯带背部的双面胶保护膜，将其牢固粘贴在屏幕背面。 ![ledstrip_install](../../../assets/NanoKVM/pro/ledstrip/ledstrip_install.jpg) ### 连接到 NanoKVM Pro 连接示意如下： * ① 接 NanoKVM Pro PWR 接口 * ② 接灯带 * ③ 接电源适配器 > ⚠️ 注意：请确保输入电源规格 **5V ≥ 3A**。 ![ledstrip_pwr](../../../assets/NanoKVM/pro/ledstrip/ledstrip_pwr.jpg) ## 启用灯带 * 通过 Web 开启 1. 通过浏览器登录 NanoKVM 2. 依次进入 **设置 → 设备 → LED 灯带设置**, 开启功能，填写对应的LED数量 ![ledstrip_setting](../../../assets/NanoKVM/pro/ledstrip/ledstrip_setting.jpg) * 通过 Desk UI 开启 1. 进入 `Settings` 页面 2. 选择 `Ambilight` 进入二级设置页面 3. 配置灯带数量并开启 ## 效果展示 <video playsinline controls muted preload src \"../../../assets/NanoKVM/pro/ledstrip/sync_led2.mp4\"></video>"},"/hardware/zh/kvm/NanoKVM_Pro/app_diy.html":{"title":"DIY应用","content":" title: DIY应用 keywords: NanoKVM, Desk, Auxiliary Screen, DIY update: date: 2025 11 07 version: v1.0 author: bugu content: initial docs NanoKVM Desk是Sipeed推出的IPKVM产品，拥有AX630为核心（双核A53@1.2GHz，内置3.2Tops NPU@INT8）配置了1G LPDDR4内存和32GeMMC，同时支持TF卡扩展，并有可选的wifi、POE配置，除了强大的远程控制功能外，其拥有一块1.47寸触摸显示屏和旋钮，作为桌面摆件的形态有无限的DIY想象空间。 在`1.2.1`版本中，我们新增了**APP Hub**功能。通过该功能，您可以便捷下载[开源应用仓库](https://github.com/sipeed/NanoKVM UserApps)中的所有应用。 如果您有好的创意，也欢迎基于下方文档构建属于自己的应用并提交至开源仓库。我们会对提交的应用进行基础功能审核，一经通过，您开发的应用将可供所有NanoKVM Desk用户下载使用！ ## 如何构建你自己的应用 > 你可以将此文档发送给AI，来辅助生成你自己的应用！ ### 项目文件夹的介绍 NanoKVM Desk UserAPP会扫描 `/userapp` 目录下所有的文件夹，每一个文件夹就是一个APP，文件夹名称就是APP名称。文件夹内至少包含 `main.py` 和 `app.toml`。 `main.py` 是运行的代码，`app.toml` 是配置文件，其内容如下： ```toml [application] name \"XXX\" # 使用文件夹名，启动时显示(必须且与目录名一致) version \"1.0.0\" # 用作版本升级，启动时显示(必须为SemVer格式子集 MAJOR.MINOR.PATCH) descriptions \"Example\" # 用作App简短描述，在下载更新时显示(必须，用于用户快速了解app功能) [author] name \"Sipeed xxx\" # 填写作者名称，启动时显示(必须) email \"xxx@sipeed.com\" # 方便用户联系作者(可选) [interaction] requires_user_input false # 是否需要开放触摸屏以及旋钮事件；若为true，要求程序内必须有主动退出机制(可选) ``` ### 屏幕基础信息和使用方法 NanoKVM Desk的屏幕分辨率为320*172，通过 `/dev/fb0` 访问。设备配备了一个172x320像素的RGB565彩色显示屏，可通过帧缓冲设备 `/dev/fb0` 访问。应用程序可以直接绘制到该显示设备上。 #### 显示特性 **分辨率**: 172x320 像素（但逻辑屏幕是 320x172 见下面的旋转说明） **颜色深度**: 16 位 RGB565 格式 (红色 5 位，绿色 6 位，蓝色 5 位) **帧缓冲设备**: `/dev/fb0` **显示方向**: 物理显示屏为纵向模式，但应用程序通常创建横向图像 (320x172) 并逆时针旋转 90 度以供显示。 #### 基本显示用法 在 Python 应用程序中使用显示设备： 1. **设置物理显示尺寸的常量**: ```python PHYSICAL_WIDTH 172 PHYSICAL_HEIGHT 320 BPP 16 # 每像素位数 ``` 2. **创建与帧缓冲区接口的显示类**: ```python import mmap import os import numpy as np from PIL import Image, ImageDraw class RGB565Display: def __init__(self, fb_device \"/dev/fb0\"): self.physical_width PHYSICAL_WIDTH self.physical_height PHYSICAL_HEIGHT self.bpp BPP self.fb_size self.physical_width * self.physical_height * (self.bpp // 8) # 打开帧缓冲设备 self.fb_fd os.open(fb_device, os.O_RDWR) self.fb_mmap mmap.mmap( self.fb_fd, self.fb_size, mmap.MAP_SHARED, mmap.PROT_WRITE ) self.fb_array np.frombuffer(self.fb_mmap, dtype np.uint16).reshape( (self.physical_height, self.physical_width) ) def rgb_to_rgb565(self, r, g, b): \"\"\"将 8 位 RGB 转换为 RGB565 格式\"\"\" return ((r & 0xF8) << 8) ((g & 0xFC) << 3) (b >> 3) def clear_screen(self, color 0x0000): \"\"\"使用指定颜色清屏\"\"\" self.fb_array.fill(color) def _display_image(self, logical_img): \"\"\"旋转逻辑图像并在物理屏幕上显示\"\"\" # 将逻辑图像逆时针旋转 90 度以获得物理图像 physical_img logical_img.rotate(90, expand True) # 转换为 RGB565 并复制到帧缓冲区 rgb_array np.array(physical_img) r (rgb_array[:, :, 0] >> 3).astype(np.uint16) g (rgb_array[:, :, 1] >> 2).astype(np.uint16) b (rgb_array[:, :, 2] >> 3).astype(np.uint16) rgb565 (r << 11) (g << 5) b # 直接复制整个数组到帧缓冲区 self.fb_array[:, :] rgb565 def close(self): \"\"\"关闭资源\"\"\" self.fb_mmap.close() os.close(self.fb_fd) ``` 3. **在显示上绘制内容**: ```python def main(): display RGB565Display() try: # 创建逻辑横向图像 (320x172) logical_img Image.new(\"RGB\", (320, 172), (0, 0, 0)) draw ImageDraw.Draw(logical_img) # 绘制内容 (例如，矩形、文字) draw.rectangle([10, 10, 100, 100], fill (255, 0, 0)) # 红色矩形 # 显示图像 display._display_image(logical_img) # 等待一段时间 import time time.sleep(5) finally: display.close() if __name__ \"__main__\": main() ``` #### 显示用法的最佳实践 始终将逻辑横向图像 (320x172) 逆时针旋转以匹配物理纵向显示 (172x320) 尽可能使用高效的绘图方法以减少渲染时间 在 `finally` 块或上下文管理器中正确关闭资源，以防止资源泄漏 在绘制频繁更新的内容时考虑性能 (例如，动画) ### 输入事件基础信息和使用方法 NanoKVM Desk有旋钮旋转，按下和触摸三种输入事件。 > 如果要使用输入事件时，需要在 `app.toml` 中声明 `requires_user_input true`，同时在你的程序中必须有明确的主动退出机制，否则无法退出至NanoKVM UI； > 若你的程序不需要触摸或旋钮的输入事件，配置字段 `requires_user_input false` 或不写，NanoKVM UI将会在点击屏幕或按下按钮后退出程序。 #### 输入设备位置 **旋钮旋转事件**: `/dev/input/event0` ```shell root@kvm 72d6:~# evtest /dev/input/event0 Input driver version is 1.0.1 Input device ID: bus 0x19 vendor 0x0 product 0x0 version 0x0 Input device name: \"rotary@0\" Supported events: Event type 0 (EV_SYN) Event type 2 (EV_REL) Event code 0 (REL_X) Properties: Testing ... (interrupt to exit) Event: time 1762504082.820148, type 2 (EV_REL), code 0 (REL_X), value 1 Event: time 1762504082.820148, SYN_REPORT Event: time 1762504082.861754, type 2 (EV_REL), code 0 (REL_X), value 1 Event: time 1762504082.861754, SYN_REPORT Event: time 1762504084.692300, type 2 (EV_REL), code 0 (REL_X), value 1 Event: time 1762504084.692300, SYN_REPORT Event: time 1762504084.714448, type 2 (EV_REL), code 0 (REL_X), value 1 Event: time 1762504084.714448, SYN_REPORT ``` **旋钮按下、保持、抬起事件**: `/dev/input/event1` ```shell root@kvm 72d6:~# evtest /dev/input/event1 Input driver version is 1.0.1 Input device ID: bus 0x19 vendor 0x1 product 0x1 version 0x100 Input device name: \"gpio_keys\" Supported events: Event type 0 (EV_SYN) Event type 1 (EV_KEY) Event code 28 (KEY_ENTER) Key repeat handling: Repeat type 20 (EV_REP) Repeat code 0 (REP_DELAY) Value 250 Repeat code 1 (REP_PERIOD) Value 33 Properties: Testing ... (interrupt to exit) Event: time 1762504201.120498, type 1 (EV_KEY), code 28 (KEY_ENTER), value 1 Event: time 1762504201.120498, SYN_REPORT Event: time 1762504201.371193, type 1 (EV_KEY), code 28 (KEY_ENTER), value 2 Event: time 1762504201.721202, SYN_REPORT Event: time 1762504201.724694, type 1 (EV_KEY), code 28 (KEY_ENTER), value 0 Event: time 1762504201.724694, SYN_REPORT ``` **触摸屏事件**: `/dev/input/event2` ```shell root@kvm 72d6:~# evtest /dev/input/event2 Input driver version is 1.0.1 Input device ID: bus 0x18 vendor 0x0 product 0x0 version 0x0 Input device name: \"hyn_ts\" Supported events: Event type 0 (EV_SYN) Event type 1 (EV_KEY) Event code 325 (BTN_TOOL_FINGER) Event code 330 (BTN_TOUCH) Event type 3 (EV_ABS) Event code 47 (ABS_MT_SLOT) Value 0 Min 0 Max 5 Event code 48 (ABS_MT_TOUCH_MAJOR) Value 0 Min 0 Max 255 Event code 50 (ABS_MT_WIDTH_MAJOR) Value 0 Min 0 Max 200 Event code 53 (ABS_MT_POSITION_X) Value 0 Min 0 Max 172 Event code 54 (ABS_MT_POSITION_Y) Value 0 Min 0 Max 320 Event code 57 (ABS_MT_TRACKING_ID) Value 0 Min 0 Max 5 Event code 58 (ABS_MT_PRESSURE) Value 0 Min 0 Max 255 Properties: Property type 1 (INPUT_PROP_DIRECT) Testing ... (interrupt to exit) Event: time 1762504306.703328, type 1 (EV_KEY), code 330 (BTN_TOUCH), value 1 Event: time 1762504306.703328, type 3 (EV_ABS), code 57 (ABS_MT_TRACKING_ID), value 25 Event: time 1762504306.703328, type 3 (EV_ABS), code 57 (ABS_MT_TRACKING_ID), value 0 Event: time 1762504306.703328, type 3 (EV_ABS), code 53 (ABS_MT_POSITION_X), value 71 Event: time 1762504306.703328, type 3 (EV_ABS), code 54 (ABS_MT_POSITION_Y), value 165 Event: time 1762504306.703328, type 3 (EV_ABS), code 48 (ABS_MT_TOUCH_MAJOR), value 1 Event: time 1762504306.703328, type 3 (EV_ABS), code 50 (ABS_MT_WIDTH_MAJOR), value 1 Event: time 1762504306.703328, type 3 (EV_ABS), code 58 (ABS_MT_PRESSURE), value 10 Event: time 1762504306.703328, SYN_REPORT Event: time 1762504306.749866, type 3 (EV_ABS), code 57 (ABS_MT_TRACKING_ID), value 1 Event: time 1762504306.749866, type 1 (EV_KEY), code 330 (BTN_TOUCH), value 0 Event: time 1762504306.749866, SYN_REPORT ``` ### 示例 [开源仓库的apps目录下](https://github.com/sipeed/NanoKVM UserApps/tree/main/apps) 的两个示例，可能帮你更好的构建自己的应用： [hello](https://github.com/sipeed/NanoKVM UserApps/tree/main/apps/hello): 基本显示功能 [drawo](https://github.com/sipeed/NanoKVM UserApps/tree/main/apps/drawo): 带有触摸屏支持的绘图应用程序 ## 贡献到软件源 我们鼓励创建并上传自己的应用程序到[仓库](https://github.com/sipeed/NanoKVM UserApps)！这作为 NanoKVM Desk 的软件源，您的贡献使我们的生态系统更加丰富。 ### 如何上传您的应用程序 1. 创建一个 pull request，将您的应用程序放入 `apps` 文件夹 2. 您的应用程序将经过简单的审核流程（作为开源社区，我们只审核基本功能；安全性由开发者保证） 3. 一经批准，您的应用程序将在 NanoKVM Desk APP Hub 中提供 ### 如何上报UserAPP的问题 请在[开源仓库](https://github.com/sipeed/NanoKVM UserApps)的issus下报告问题，并@对应app下app.toml的作者"},"/hardware/zh/kvm/NanoKVM_Pro/cua.html":{"title":"实验性AI Agent","content":" title: 实验性AI Agent keywords: NanoKVM, AI Agent, Computer Use update: date: 2025 10 06 version: v0.1 author: zepan content: Release docs ## 简介 NanoKVM Pro 实验性引入了AI Agent功能，可以让用户快速体验当下热门的Computer Use Agent功能。 Computer Use是基于多模态AI大模型(VLM)，赋予用户使用自然语言自动化操控电脑的能力，而无需像以前那样进行复杂的脚本编程。 对于Computer Use概念，可以参考Anthropic发布的相关展示视频，和reddit上的一些使用体验： https://www.reddit.com/r/ClaudeAI/comments/1ga3uqn/mindblowing_experience_with_claude_computer_use <iframe width \"560\" height \"315\" src \"https://www.youtube.com/embed/ODaHJzOyVCQ\" frameborder \"0\" allowfullscreen></iframe> ## NanoKVM Pro的优势 NanoKVM Pro实现的Computer Use功能相对 Anthropic 的Computer Use有何优点呢？ 1. 开箱即用 1. NanoKVM Pro已经内置Computer Use应用，用户点击web页面按键即可体验运行，无需像Anthropic提供的demo那样要求用户进行前置复杂的环境搭建 2. 硬件级Computer Use 1. Anthropic是基于软件的方案，所以仅能局限于MacOS 11和Windows10以上的系统，不支持Linux/Android。 2. NanoKVM Pro的Computer Use是硬件级的，因为它作为IPKVM天生能硬件级获取屏幕截图和硬件级操控鼠标，所以可以支持Windows/MacOS/Linux,甚至Android等 3. 支持自部署 1. Anthropic 是闭源的大模型, 用户必须上传屏幕截图到他们服务器，所以无法进行一些隐私性的电脑操作。 2. NanoKVM Pro支持自定义的VLM模型接口，不仅可以对接在线的大模型接口，还可以对接到用户自部署的开源VLM服务器(openai接口形式)！ 3. 在几个月前，还没有能够实现基础computer use的开源VL模型，但是就在最近(2025.10), alibaba发布的最新开源VL模型：qwen3 vl 235b a22b instruct, qwen3 vl 30b a3b instruct 已经可以实现基础的computer use功能！ 4. 随着AI大模型的快速发展，我们相信明年的开源VL模型将具备更强大的能力，使得自部署实用性computer use成为现实！ 下面是NanoKVM Pro执行简单示意任务（下载esp32 datasheet， 设置dns）的手机录屏： <div class \"video row\"> <video playsinline controls muted preload src \"../../../assets/NanoKVM/pro/cua/download_esp32.mp4\"></video> <video playsinline controls muted preload src \"../../../assets/NanoKVM/pro/cua/set_dns.mp4\"></video> </div> <style> .video row { display: flex; gap: 12px; flex wrap: wrap; justify content: center; } .video row video { flex: 1; min width: 280px; aspect ratio: 9/16; } @media (max width: 600px) { .video row { flex direction: column; } } </style> 作为实验性功能，NanoKVM Pro的CUA目前是使用Python编写的独立服务，方便社区用户快速修改测试。 欢迎对AI Agent感兴趣且有开发能力的用户贡献代码：https://github.com/sipeed/nanokvm_cua ## 使用前的注意事项！！！ 在介绍如何体验使用之前，我必须在这里反复重申CUA功能在当前的局限性和危险性。 当前大模型的能力非常有限，且有不受控的**幻觉**，当它有硬件级的操控能力时，有可能在幻觉下对电脑造成**不可恢复的损坏**。 比如今年(2025)就有报道用户使用Anthropic 的Computer Use功能，结果被删除了数据库。 你在体验CUA功能时，**请保持在电脑旁**，关注AI所执行的指令，一旦发现将要执行危险操作，及时中断它。 另外，CUA功能需要连接到VLM模型服务器，用户需要付费购买相关服务商的VLM tokens额度，填入秘钥，或者自己部署VLM服务器。 **以上风险和费用情况请用户周知，使用CUA功能造成的一切电脑损失和额外费用，由用户自己承担。** ## 快速指南 ### 设置视频模式 CUA需要抓取屏幕截图，用户在使用CUA功能前，请切换\"视频模式\" 到 MJPEG 以及推荐设置桌面分辨率到1280x720: 1. VLA模型运算高分辨率的图像时间更久，产生的tokens费用更高 2. 更低的分辨率如800x600，会由于屏幕太小，导致CUA需要更多步骤操作，而增加费用和失败率 ![set_mjpeg](../../../assets/NanoKVM/pro/cua/set_mjpeg.jpg) ### 阅读注意事项 点击悬浮栏的\"Smart Assistant\"图标，会弹出CUA功能的注意事项。 我们再三强调请完全阅读理解CUA功能的风险后再执行。 ![note](../../../assets/NanoKVM/pro/cua/note.jpg) ### 安装依赖 CUA是实验性功能，同时也出于一些用户对这些隐私敏感性功能的顾虑，我们没有预装相关软件包。 首次体验该功能前，需要用户自己点击\"安装依赖\"按键进行相关软件包安装。 点击按键后，会在新页面中弹出终端页面，显示安装相关依赖包的进度，耐心等待完成即可。 ### 运行CUA服务 安装完依赖后，点击\"Try It Now\"按键即可开启CUA服务，等待5~10s后，就会弹出CUA功能的新窗口。（如果没有弹出，请检查是否chrome浏览器拦截了弹出窗口。） 注意目前的CUA服务会增大KVM的CPU消耗，可能导致原KVM窗口的操作卡顿。 出于安全性考虑，CUA服务同时仅允许一个实例运行，如果你复制CUA页面的网址在新标签页中打开，是无法查看到内容的。 同样处于安全性考虑，你关闭或者刷新CUA网页后，CUA服务会自动关闭，需要重新在主页面点击按键启动。 CUA网页是电脑，手机浏览器兼容的布局，电脑上的页面布局如下所示： ![web_pc](../../../assets/NanoKVM/pro/cua/web_pc.jpg) > 如果你是开发者，可以在终端使用 python /kvmapp/cua/cua_webapp.py auth 来手动运行 ### 填写CUA配置 首次使用前，请切换到设置页面，填写相关设置。 1. API Type 1. DashScope: 默认使用该API形式，较为轻量 https://www.aliyun.com/product/bailian 2. OpenAI: 最通用的API形式，特别是如果你要自部署VLM服务器，那么开源的vLLM/SGLang将提供该形式的API服务器 3. Genai：TODO 2. API Key 1. 填写你在VLM服务商处获得的API Key，如果是自部署的，也请填上你部署时设置的key 3. Base URL 1. 如果你使用的是openAI形式 API，需要填写服务器的URL 2. 比如 https://dashscope.aliyuncs.com/compatible mode/v1 3. 比如 https://192.168.0.xxx:8000/v1 4. Model Name 1. 填写你在VLM服务商处选择的VLM模型名称 2. 商业模型推荐：qwen3 vl plus 3. 开源模型如： qwen3 vl 235b a22b instruct, qwen3 vl 30b a3b instruct 4. 自部署模型，如使用vllm部署，请填写 served model name的名字 5. IMG_KEEP_N 1. 为节省tokens消耗，每次仅保留近IMG_KEEP_N次操作截图 6. MAX_ROUNDS 1. 单次任务允许的最大操作步骤，防止VLM无限死循环消耗过多tokens 7. Initial Prompt 1. 这是我们根据CUA任务编写的初始提示词，可以小心微调，不可以修改指令生成部分（除非你可以修改对应py脚本） 填写完成后，点击\"提交\"来生效配置。 ### 下达自动化任务 切回到Chat栏，在最下方的文本框中填入你希望执行的任务，点击\"send\"，即可观察CUA的自动化操作。 > 注意右侧窗口是只读预览窗口，无法进行键鼠操作。 建议的初次测试任务可以参考\"download raspberrypi datasheet\", \"set dns server to 8.8.8.8\" 聊天窗口中会显示每一步的屏幕截图和CUA操作指令。 如果发现CUA进入死循环需要提示，可以点击\"pause\"暂停，输入一些提示，再点击发送来纠正CUA。 如果发现CUA将执行危险操作，也可以通过pause暂停。 完成任务或者需要新开任务，点击\"Reset\"来重置状态。 ![chat_task](../../../assets/NanoKVM/pro/cua/chat_task.jpg) ## 自部署VLM模型 ### 硬件配置 得益于Qwen3 VL系列的发布，用户自部署VLM服务，实现CUA功能也成为了现实。 在2025年10月最新发布的Qwen3 VL系列开源模型的能力大幅提高，qwen3 vl 235b a22b instruct能力超越了去年的qwen vl max, qwen3 vl 30b a3b instruct超越了qwen2.5 vl 72b instruct, 都达到了完成基础电脑操作的能力门槛。 qwen3 vl 235b a22b instruct是较大模型，至少需要4xH100 (4x80 320GB) 来运行FP8模型，对于普通用户来说比较困难。 我们主要介绍 qwen3 vl 30b a3b instruct 的自部署演示。 qwen3 vl 30b a3b instruct 有30B参数，算上额外的上下文内存需求，至少需要40B*DataType的内存需求。 可能的几种部署方式： 1. 1x L40S, RTX6000, H1000, ... FP8 2. 2x RTX4090, RTX5090 FP8 3. 4xRTX3090 FP16 4. CPU with 48GB+ memory, 16+ core; Q4 其中测试了社区用户发布的[量化的Q4模型](https://huggingface.co/yairpatch/Qwen3 VL 30B A3B Thinking GGUF)似乎量化误差太大，无法精确点击图标，可能需要等待官方更新精确的AWQ模型。 所以对于个人用户来说，4xRTX3090或2xRTX4090/5090是比较实际的部署方案。 目前我们实际测试通过vllm部署，也可以尝试使用SGLang部署，它们都支持提供openAI形式的API服务。 **2025.10.15 更新** Qwen3 VL 8B和4B模型在今天发布了！ 经过测试, qwen3 vl 8b instruct 也能达到基础的CUA能力！ 所以个人用户自部署体验CUA的门槛降到了单张RTX3090，或 32GB以上内存的CPU，这是大部分数码爱好者都能达到的配置，快来体验吧！ ### vllm部署VLM 1. 安装vllm： https://docs.vllm.ai/en/stable/getting_started/installation/gpu.html 2. 下载FP16或者FP8权重： 1. https://modelscope.cn/models/Qwen/Qwen3 VL 30B A3B Instruct 2. https://modelscope.cn/models/Qwen/Qwen3 VL 30B A3B Instruct FP8 3. https://modelscope.cn/models/Qwen/Qwen3 VL 8B Instruct 3. 开启服务 4卡运行Qwen3 VL 30B A3B Instruct： ```shell vllm serve \\ /your_models_path//Qwen/Qwen3 VL 30B A3B Instruct \\ host 0.0.0.0 \\ port 8000 \\ tensor parallel size 4 \\ gpu memory utilization 0.90 \\ max model len 65536 \\ served model name qwen3 vl 30b a3b instruct \\ api key skxxxxxx ``` 单卡运行Qwen3 VL 8B Instruct ```shell vllm serve \\ /your_models_path//Qwen/Qwen3 VL 8B Instruct \\ host 0.0.0.0 \\ port 8000 \\ tensor parallel size 1 \\ gpu memory utilization 0.90 \\ max model len 32768 \\ served model name qwen3 vl 8b instruct \\ api key skxxxxxx ``` 然后在CUA页面中填上对应的信息即可完全本地使用啦！ 可以在服务器终端上看到相关运行信息： ``` (vllm) zp@server105:~/work/vllm$ vllm serve \\ \\ /home/zp/work/models/Qwen/Qwen3 VL 30B A3B Instruct \\ host 0.0.0.0 \\ port 8000 \\ tensor parallel size 4 \\ gpu memory utilization 0.90 \\ max model len 65536 \\ served model name Qwen3 VL 30B A3B Instruct\\ api key sk123 INFO 10 06 15:56:22 [__init__.py:216] Automatically detected platform cuda. (APIServer pid 41428) INFO 10 06 15:56:26 [api_server.py:1839] vLLM API server version 0.11.0 (APIServer pid 41428) INFO 10 06 15:56:26 [utils.py:233] non default args: {'model_tag': '/home/zp/work/models/Qwen/Qwen3 VL 30B A3B Instruct', 'host': '0.0.0.0', 'api_key': ['sk123'], 'model': '/home/zp/work/models/Qwen/Qwen3 VL 30B A3B Instruct', 'max_model_len': 65536, 'served_model_name': ['Qwen3 VL 30B A3B Instruct'], 'tensor_parallel_size': 4} (APIServer pid 41428) INFO 10 06 15:56:26 [model.py:547] Resolved architecture: Qwen3VLMoeForConditionalGeneration (APIServer pid 41428) `torch_dtype` is deprecated! Use `dtype` instead! (APIServer pid 41428) INFO 10 06 15:56:26 [model.py:1510] Using max model len 65536 (APIServer pid 41428) INFO 10 06 15:56:27 [scheduler.py:205] Chunked prefill is enabled with max_num_batched_tokens 2048. INFO 10 06 15:56:32 [__init__.py:216] Automatically detected platform cuda. (EngineCore_DP0 pid 41565) INFO 10 06 15:56:35 [core.py:644] Waiting for init message from front end. (EngineCore_DP0 pid 41565) INFO 10 06 15:56:35 [core.py:77] Initializing a V1 LLM engine (v0.11.0) with config: model '/home/zp/work/models/Qwen/Qwen3 VL 30B A3B Instruct', speculative_config None, tokenizer '/home/zp/work/models/Qwen/Qwen3 VL 30B A3B Instruct', skip_tokenizer_init False, tokenizer_mode auto, revision None, tokenizer_revision None, trust_remote_code False, dtype torch.bfloat16, max_seq_len 65536, download_dir None, load_format auto, tensor_parallel_size 4, pipeline_parallel_size 1, data_parallel_size 1, disable_custom_all_reduce False, quantization None, enforce_eager False, kv_cache_dtype auto, device_config cuda, structured_outputs_config StructuredOutputsConfig(backend 'auto', disable_fallback False, disable_any_whitespace False, disable_additional_properties False, reasoning_parser ''), observability_config ObservabilityConfig(show_hidden_metrics_for_version None, otlp_traces_endpoint None, collect_detailed_traces None), seed 0, served_model_name Qwen3 VL 30B A3B Instruct, enable_prefix_caching True, chunked_prefill_enabled True, pooler_config None, compilation_config {\"level\":3,\"debug_dump_path\":\"\",\"cache_dir\":\"\",\"backend\":\"\",\"custom_ops\":[],\"splitting_ops\":[\"vllm.unified_attention\",\"vllm.unified_attention_with_output\",\"vllm.mamba_mixer2\",\"vllm.mamba_mixer\",\"vllm.short_conv\",\"vllm.linear_attention\",\"vllm.plamo2_mamba_mixer\",\"vllm.gdn_attention\",\"vllm.sparse_attn_indexer\"],\"use_inductor\":true,\"compile_sizes\":[],\"inductor_compile_config\":{\"enable_auto_functionalized_v2\":false},\"inductor_passes\":{},\"cudagraph_mode\":[2,1],\"use_cudagraph\":true,\"cudagraph_num_of_warmups\":1,\"cudagraph_capture_sizes\":[512,504,496,488,480,472,464,456,448,440,432,424,416,408,400,392,384,376,368,360,352,344,336,328,320,312,304,296,288,280,272,264,256,248,240,232,224,216,208,200,192,184,176,168,160,152,144,136,128,120,112,104,96,88,80,72,64,56,48,40,32,24,16,8,4,2,1],\"cudagraph_copy_inputs\":false,\"full_cuda_graph\":false,\"use_inductor_graph_partition\":false,\"pass_config\":{},\"max_capture_size\":512,\"local_cache_dir\":null} (EngineCore_DP0 pid 41565) WARNING 10 06 15:56:35 [multiproc_executor.py:720] Reducing Torch parallelism from 44 threads to 1 to avoid unnecessary CPU contention. Set OMP_NUM_THREADS in the external environment to tune this value as needed. (EngineCore_DP0 pid 41565) INFO 10 06 15:56:35 [shm_broadcast.py:289] vLLM message queue communication handle: Handle(local_reader_ranks [0, 1, 2, 3], buffer_handle (4, 16777216, 10, 'psm_9b2ff0e4'), local_subscribe_addr 'ipc:///tmp/012ca9e5 5641 4fb7 a15a 3031d0bab01f', remote_subscribe_addr None, remote_addr_ipv6 False) INFO 10 06 15:56:39 [__init__.py:216] Automatically detected platform cuda. INFO 10 06 15:56:39 [__init__.py:216] Automatically detected platform cuda. INFO 10 06 15:56:39 [__init__.py:216] Automatically detected platform cuda. INFO 10 06 15:56:39 [__init__.py:216] Automatically detected platform cuda. INFO 10 06 15:56:44 [shm_broadcast.py:289] vLLM message queue communication handle: Handle(local_reader_ranks [0], buffer_handle (1, 10485760, 10, 'psm_c289f912'), local_subscribe_addr 'ipc:///tmp/1da89172 ec87 4616 92cb 37f804606ec3', remote_subscribe_addr None, remote_addr_ipv6 False) INFO 10 06 15:56:44 [shm_broadcast.py:289] vLLM message queue communication handle: Handle(local_reader_ranks [0], buffer_handle (1, 10485760, 10, 'psm_e3f33e50'), local_subscribe_addr 'ipc:///tmp/d22d4439 f2d4 4ad5 bf43 c8aefa75d97d', remote_subscribe_addr None, remote_addr_ipv6 False) INFO 10 06 15:56:44 [shm_broadcast.py:289] vLLM message queue communication handle: Handle(local_reader_ranks [0], buffer_handle (1, 10485760, 10, 'psm_202b7486'), local_subscribe_addr 'ipc:///tmp/8dfcea44 3e7d 46c0 881a bb2913de8283', remote_subscribe_addr None, remote_addr_ipv6 False) INFO 10 06 15:56:44 [shm_broadcast.py:289] vLLM message queue communication handle: Handle(local_reader_ranks [0], buffer_handle (1, 10485760, 10, 'psm_acb66435'), local_subscribe_addr 'ipc:///tmp/a79c13a7 b107 4974 bc22 d18fbb753f4a', remote_subscribe_addr None, remote_addr_ipv6 False) [Gloo] Rank 2 is connected to 3 peer ranks. Expected number of connected peer ranks is : 3 [Gloo] Rank 0 is connected to 3 peer ranks. Expected number of connected peer ranks is : 3 [Gloo] Rank 1 is connected to 3 peer ranks. Expected number of connected peer ranks is : 3 [Gloo] Rank 3 is connected to 3 peer ranks. Expected number of connected peer ranks is : 3 [Gloo] Rank 2 is connected to 3 peer ranks. Expected number of connected peer ranks is : 3 [Gloo] Rank 0 is connected to 3 peer ranks. Expected number of connected peer ranks is : 3 [Gloo] Rank 1 is connected to 3 peer ranks. Expected number of connected peer ranks is : 3 [Gloo] Rank 3 is connected to 3 peer ranks. Expected number of connected peer ranks is : 3 INFO 10 06 15:56:46 [__init__.py:1384] Found nccl from library libnccl.so.2 INFO 10 06 15:56:46 [pynccl.py:103] vLLM is using nccl 2.27.3 INFO 10 06 15:56:46 [__init__.py:1384] Found nccl from library libnccl.so.2 INFO 10 06 15:56:46 [pynccl.py:103] vLLM is using nccl 2.27.3 INFO 10 06 15:56:46 [__init__.py:1384] Found nccl from library libnccl.so.2 INFO 10 06 15:56:46 [pynccl.py:103] vLLM is using nccl 2.27.3 INFO 10 06 15:56:46 [__init__.py:1384] Found nccl from library libnccl.so.2 INFO 10 06 15:56:46 [pynccl.py:103] vLLM is using nccl 2.27.3 WARNING 10 06 15:56:46 [symm_mem.py:58] SymmMemCommunicator: Device capability 8.6 not supported, communicator is not available. WARNING 10 06 15:56:46 [symm_mem.py:58] SymmMemCommunicator: Device capability 8.6 not supported, communicator is not available. WARNING 10 06 15:56:46 [symm_mem.py:58] SymmMemCommunicator: Device capability 8.6 not supported, communicator is not available. WARNING 10 06 15:56:46 [symm_mem.py:58] SymmMemCommunicator: Device capability 8.6 not supported, communicator is not available. WARNING 10 06 15:56:46 [custom_all_reduce.py:144] Custom allreduce is disabled because it's not supported on more than two PCIe only GPUs. To silence this warning, specify disable_custom_all_reduce True explicitly. WARNING 10 06 15:56:46 [custom_all_reduce.py:144] Custom allreduce is disabled because it's not supported on more than two PCIe only GPUs. To silence this warning, specify disable_custom_all_reduce True explicitly. WARNING 10 06 15:56:46 [custom_all_reduce.py:144] Custom allreduce is disabled because it's not supported on more than two PCIe only GPUs. To silence this warning, specify disable_custom_all_reduce True explicitly. WARNING 10 06 15:56:46 [custom_all_reduce.py:144] Custom allreduce is disabled because it's not supported on more than two PCIe only GPUs. To silence this warning, specify disable_custom_all_reduce True explicitly. INFO 10 06 15:56:46 [shm_broadcast.py:289] vLLM message queue communication handle: Handle(local_reader_ranks [1, 2, 3], buffer_handle (3, 4194304, 6, 'psm_a8cdf3eb'), local_subscribe_addr 'ipc:///tmp/f25bfe61 de00 442b 9f93 e5edf37c4389', remote_subscribe_addr None, remote_addr_ipv6 False) [Gloo] Rank 0 is connected to 0 peer ranks. Expected number of connected peer ranks is : 0 [Gloo] Rank 0 is connected to 0 peer ranks. Expected number of connected peer ranks is : 0 [Gloo] Rank 0 is connected to 0 peer ranks. Expected number of connected peer ranks is : 0 [Gloo] Rank 0 is connected to 0 peer ranks. Expected number of connected peer ranks is : 0 [Gloo] Rank 0 is connected to 0 peer ranks. Expected number of connected peer ranks is : 0 [Gloo] Rank 0 is connected to 0 peer ranks. Expected number of connected peer ranks is : 0 [Gloo] Rank 0 is connected to 0 peer ranks. Expected number of connected peer ranks is : 0 [Gloo] Rank 0 is connected to 0 peer ranks. Expected number of connected peer ranks is : 0 [Gloo] Rank 0 is connected to 0 peer ranks. Expected number of connected peer ranks is : 0 [Gloo] Rank 0 is connected to 0 peer ranks. Expected number of connected peer ranks is : 0 [Gloo] Rank 0 is connected to 0 peer ranks. Expected number of connected peer ranks is : 0 [Gloo] Rank 0 is connected to 0 peer ranks. Expected number of connected peer ranks is : 0 [Gloo] Rank 0 is connected to 3 peer ranks. Expected number of connected peer ranks is : 3 [Gloo] Rank 2 is connected to 3 peer ranks. Expected number of connected peer ranks is : 3 [Gloo] Rank 1 is connected to 3 peer ranks. Expected number of connected peer ranks is : 3 [Gloo] Rank 3 is connected to 3 peer ranks. Expected number of connected peer ranks is : 3 INFO 10 06 15:56:46 [__init__.py:1384] Found nccl from library libnccl.so.2 INFO 10 06 15:56:46 [__init__.py:1384] Found nccl from library libnccl.so.2 INFO 10 06 15:56:46 [pynccl.py:103] vLLM is using nccl 2.27.3 INFO 10 06 15:56:46 [pynccl.py:103] vLLM is using nccl 2.27.3 INFO 10 06 15:56:46 [__init__.py:1384] Found nccl from library libnccl.so.2 INFO 10 06 15:56:46 [pynccl.py:103] vLLM is using nccl 2.27.3 INFO 10 06 15:56:46 [__init__.py:1384] Found nccl from library libnccl.so.2 INFO 10 06 15:56:46 [pynccl.py:103] vLLM is using nccl 2.27.3 INFO 10 06 15:56:46 [parallel_state.py:1208] rank 3 in world size 4 is assigned as DP rank 0, PP rank 0, TP rank 3, EP rank 3 INFO 10 06 15:56:46 [parallel_state.py:1208] rank 2 in world size 4 is assigned as DP rank 0, PP rank 0, TP rank 2, EP rank 2 INFO 10 06 15:56:46 [parallel_state.py:1208] rank 0 in world size 4 is assigned as DP rank 0, PP rank 0, TP rank 0, EP rank 0 INFO 10 06 15:56:46 [parallel_state.py:1208] rank 1 in world size 4 is assigned as DP rank 0, PP rank 0, TP rank 1, EP rank 1 WARNING 10 06 15:56:47 [topk_topp_sampler.py:66] FlashInfer is not available. Falling back to the PyTorch native implementation of top p & top k sampling. For the best performance, please install FlashInfer. WARNING 10 06 15:56:47 [topk_topp_sampler.py:66] FlashInfer is not available. Falling back to the PyTorch native implementation of top p & top k sampling. For the best performance, please install FlashInfer. WARNING 10 06 15:56:47 [topk_topp_sampler.py:66] FlashInfer is not available. Falling back to the PyTorch native implementation of top p & top k sampling. For the best performance, please install FlashInfer. WARNING 10 06 15:56:47 [topk_topp_sampler.py:66] FlashInfer is not available. Falling back to the PyTorch native implementation of top p & top k sampling. For the best performance, please install FlashInfer. (Worker_TP3 pid 41702) INFO 10 06 15:56:51 [gpu_model_runner.py:2602] Starting to load model /home/zp/work/models/Qwen/Qwen3 VL 30B A3B Instruct... (Worker_TP0 pid 41699) INFO 10 06 15:56:51 [gpu_model_runner.py:2602] Starting to load model /home/zp/work/models/Qwen/Qwen3 VL 30B A3B Instruct... (Worker_TP3 pid 41702) INFO 10 06 15:56:51 [gpu_model_runner.py:2634] Loading model from scratch... (Worker_TP2 pid 41701) INFO 10 06 15:56:51 [gpu_model_runner.py:2602] Starting to load model /home/zp/work/models/Qwen/Qwen3 VL 30B A3B Instruct... (Worker_TP3 pid 41702) INFO 10 06 15:56:51 [cuda.py:366] Using Flash Attention backend on V1 engine. (Worker_TP1 pid 41700) INFO 10 06 15:56:51 [gpu_model_runner.py:2602] Starting to load model /home/zp/work/models/Qwen/Qwen3 VL 30B A3B Instruct... (Worker_TP0 pid 41699) INFO 10 06 15:56:51 [gpu_model_runner.py:2634] Loading model from scratch... (Worker_TP0 pid 41699) INFO 10 06 15:56:51 [cuda.py:366] Using Flash Attention backend on V1 engine. (Worker_TP2 pid 41701) INFO 10 06 15:56:51 [gpu_model_runner.py:2634] Loading model from scratch... Loading safetensors checkpoint shards: 0% Completed 0/13 [00:00<?, ?it/s] (Worker_TP1 pid 41700) INFO 10 06 15:56:51 [gpu_model_runner.py:2634] Loading model from scratch... (Worker_TP2 pid 41701) INFO 10 06 15:56:52 [cuda.py:366] Using Flash Attention backend on V1 engine. (Worker_TP1 pid 41700) INFO 10 06 15:56:52 [cuda.py:366] Using Flash Attention backend on V1 engine. Loading safetensors checkpoint shards: 8% Completed 1/13 [00:02<00:24, 2.02s/it] Loading safetensors checkpoint shards: 15% Completed 2/13 [00:04<00:22, 2.02s/it] Loading safetensors checkpoint shards: 23% Completed 3/13 [00:06<00:20, 2.04s/it] Loading safetensors checkpoint shards: 31% Completed 4/13 [00:08<00:18, 2.05s/it] Loading safetensors checkpoint shards: 38% Completed 5/13 [00:10<00:16, 2.09s/it] Loading safetensors checkpoint shards: 46% Completed 6/13 [00:12<00:14, 2.08s/it] Loading safetensors checkpoint shards: 54% Completed 7/13 [00:13<00:09, 1.64s/it] Loading safetensors checkpoint shards: 62% Completed 8/13 [00:15<00:08, 1.78s/it] Loading safetensors checkpoint shards: 69% Completed 9/13 [00:17<00:07, 1.87s/it] Loading safetensors checkpoint shards: 77% Completed 10/13 [00:19<00:05, 1.94s/it] Loading safetensors checkpoint shards: 85% Completed 11/13 [00:20<00:03, 1.84s/it] Loading safetensors checkpoint shards: 92% Completed 12/13 [00:23<00:01, 1.91s/it] (Worker_TP2 pid 41701) INFO 10 06 15:57:16 [default_loader.py:267] Loading weights took 24.06 seconds (Worker_TP2 pid 41701) INFO 10 06 15:57:16 [gpu_model_runner.py:2653] Model loading took 14.7708 GiB and 24.325636 seconds (Worker_TP3 pid 41702) INFO 10 06 15:57:16 [default_loader.py:267] Loading weights took 25.29 seconds (Worker_TP1 pid 41700) INFO 10 06 15:57:17 [default_loader.py:267] Loading weights took 24.85 seconds Loading safetensors checkpoint shards: 100% Completed 13/13 [00:25<00:00, 1.97s/it] Loading safetensors checkpoint shards: 100% Completed 13/13 [00:25<00:00, 1.94s/it] (Worker_TP0 pid 41699) (Worker_TP0 pid 41699) INFO 10 06 15:57:17 [default_loader.py:267] Loading weights took 25.24 seconds (Worker_TP3 pid 41702) INFO 10 06 15:57:17 [gpu_model_runner.py:2653] Model loading took 14.7708 GiB and 25.534107 seconds (Worker_TP1 pid 41700) INFO 10 06 15:57:17 [gpu_model_runner.py:2653] Model loading took 14.7708 GiB and 25.147370 seconds (Worker_TP0 pid 41699) INFO 10 06 15:57:17 [gpu_model_runner.py:2653] Model loading took 14.7708 GiB and 25.517781 seconds (Worker_TP3 pid 41702) INFO 10 06 15:57:18 [gpu_model_runner.py:3344] Encoder cache will be initialized with a budget of 153600 tokens, and profiled with 1 video items of the maximum feature size. (Worker_TP2 pid 41701) INFO 10 06 15:57:18 [gpu_model_runner.py:3344] Encoder cache will be initialized with a budget of 153600 tokens, and profiled with 1 video items of the maximum feature size. (Worker_TP1 pid 41700) INFO 10 06 15:57:18 [gpu_model_runner.py:3344] Encoder cache will be initialized with a budget of 153600 tokens, and profiled with 1 video items of the maximum feature size. (Worker_TP0 pid 41699) INFO 10 06 15:57:18 [gpu_model_runner.py:3344] Encoder cache will be initialized with a budget of 153600 tokens, and profiled with 1 video items of the maximum feature size. (Worker_TP1 pid 41700) INFO 10 06 15:57:44 [backends.py:548] Using cache directory: /home/zp/.cache/vllm/torch_compile_cache/f062b114ba/rank_1_0/backbone for vLLM's torch.compile (Worker_TP1 pid 41700) INFO 10 06 15:57:44 [backends.py:559] Dynamo bytecode transform time: 12.36 s (Worker_TP2 pid 41701) INFO 10 06 15:57:44 [backends.py:548] Using cache directory: /home/zp/.cache/vllm/torch_compile_cache/f062b114ba/rank_2_0/backbone for vLLM's torch.compile (Worker_TP2 pid 41701) INFO 10 06 15:57:44 [backends.py:559] Dynamo bytecode transform time: 12.67 s (Worker_TP0 pid 41699) INFO 10 06 15:57:45 [backends.py:548] Using cache directory: /home/zp/.cache/vllm/torch_compile_cache/f062b114ba/rank_0_0/backbone for vLLM's torch.compile (Worker_TP0 pid 41699) INFO 10 06 15:57:45 [backends.py:559] Dynamo bytecode transform time: 12.90 s (Worker_TP3 pid 41702) INFO 10 06 15:57:45 [backends.py:548] Using cache directory: /home/zp/.cache/vllm/torch_compile_cache/f062b114ba/rank_3_0/backbone for vLLM's torch.compile (Worker_TP3 pid 41702) INFO 10 06 15:57:45 [backends.py:559] Dynamo bytecode transform time: 13.11 s (Worker_TP1 pid 41700) INFO 10 06 15:57:50 [backends.py:164] Directly load the compiled graph(s) for dynamic shape from the cache, took 4.849 s (Worker_TP2 pid 41701) INFO 10 06 15:57:50 [backends.py:164] Directly load the compiled graph(s) for dynamic shape from the cache, took 4.916 s (Worker_TP0 pid 41699) INFO 10 06 15:57:50 [backends.py:164] Directly load the compiled graph(s) for dynamic shape from the cache, took 4.527 s (Worker_TP3 pid 41702) INFO 10 06 15:57:50 [backends.py:164] Directly load the compiled graph(s) for dynamic shape from the cache, took 4.870 s (Worker_TP3 pid 41702) WARNING 10 06 15:57:52 [fused_moe.py:798] Using default MoE config. Performance might be sub optimal! Config file not found at ['/home/zp/work/vllm/.venv/lib/python3.12/site packages/vllm/model_executor/layers/fused_moe/configs/E 128,N 192,device_name NVIDIA_GeForce_RTX_3090.json'] (Worker_TP2 pid 41701) WARNING 10 06 15:57:52 [fused_moe.py:798] Using default MoE config. Performance might be sub optimal! Config file not found at ['/home/zp/work/vllm/.venv/lib/python3.12/site packages/vllm/model_executor/layers/fused_moe/configs/E 128,N 192,device_name NVIDIA_GeForce_RTX_3090.json'] (Worker_TP0 pid 41699) WARNING 10 06 15:57:52 [fused_moe.py:798] Using default MoE config. Performance might be sub optimal! Config file not found at ['/home/zp/work/vllm/.venv/lib/python3.12/site packages/vllm/model_executor/layers/fused_moe/configs/E 128,N 192,device_name NVIDIA_GeForce_RTX_3090.json'] (Worker_TP1 pid 41700) WARNING 10 06 15:57:52 [fused_moe.py:798] Using default MoE config. Performance might be sub optimal! Config file not found at ['/home/zp/work/vllm/.venv/lib/python3.12/site packages/vllm/model_executor/layers/fused_moe/configs/E 128,N 192,device_name NVIDIA_GeForce_RTX_3090.json'] (Worker_TP3 pid 41702) INFO 10 06 15:57:52 [monitor.py:34] torch.compile takes 13.11 s in total (Worker_TP1 pid 41700) INFO 10 06 15:57:52 [monitor.py:34] torch.compile takes 12.36 s in total (Worker_TP2 pid 41701) INFO 10 06 15:57:52 [monitor.py:34] torch.compile takes 12.67 s in total (Worker_TP0 pid 41699) INFO 10 06 15:57:52 [monitor.py:34] torch.compile takes 12.90 s in total (Worker_TP3 pid 41702) INFO 10 06 15:57:53 [gpu_worker.py:298] Available KV cache memory: 2.31 GiB (Worker_TP2 pid 41701) INFO 10 06 15:57:53 [gpu_worker.py:298] Available KV cache memory: 2.31 GiB (Worker_TP0 pid 41699) INFO 10 06 15:57:53 [gpu_worker.py:298] Available KV cache memory: 2.31 GiB (Worker_TP1 pid 41700) INFO 10 06 15:57:53 [gpu_worker.py:298] Available KV cache memory: 2.31 GiB (EngineCore_DP0 pid 41565) INFO 10 06 15:57:53 [kv_cache_utils.py:1087] GPU KV cache size: 100,752 tokens (EngineCore_DP0 pid 41565) INFO 10 06 15:57:53 [kv_cache_utils.py:1091] Maximum concurrency for 65,536 tokens per request: 1.54x (EngineCore_DP0 pid 41565) INFO 10 06 15:57:53 [kv_cache_utils.py:1087] GPU KV cache size: 100,752 tokens (EngineCore_DP0 pid 41565) INFO 10 06 15:57:53 [kv_cache_utils.py:1091] Maximum concurrency for 65,536 tokens per request: 1.54x (EngineCore_DP0 pid 41565) INFO 10 06 15:57:53 [kv_cache_utils.py:1087] GPU KV cache size: 100,752 tokens (EngineCore_DP0 pid 41565) INFO 10 06 15:57:53 [kv_cache_utils.py:1091] Maximum concurrency for 65,536 tokens per request: 1.54x (EngineCore_DP0 pid 41565) INFO 10 06 15:57:53 [kv_cache_utils.py:1087] GPU KV cache size: 100,752 tokens (EngineCore_DP0 pid 41565) INFO 10 06 15:57:53 [kv_cache_utils.py:1091] Maximum concurrency for 65,536 tokens per request: 1.54x Capturing CUDA graphs (mixed prefill decode, PIECEWISE): 100%█████████████████████████████████████████████████████████████████████████ 67/67 [00:11<00:00, 5.66it/s] Capturing CUDA graphs (decode, FULL): 100%████████████████████████████████████████████████████████████████████████████████████████████ 35/35 [00:06<00:00, 5.78it/s] (Worker_TP0 pid 41699) INFO 10 06 15:58:12 [gpu_model_runner.py:3480] Graph capturing finished in 19 secs, took 1.92 GiB (Worker_TP2 pid 41701) INFO 10 06 15:58:12 [gpu_model_runner.py:3480] Graph capturing finished in 19 secs, took 1.92 GiB (Worker_TP1 pid 41700) INFO 10 06 15:58:12 [gpu_model_runner.py:3480] Graph capturing finished in 19 secs, took 1.92 GiB (Worker_TP3 pid 41702) INFO 10 06 15:58:12 [gpu_model_runner.py:3480] Graph capturing finished in 19 secs, took 1.92 GiB (EngineCore_DP0 pid 41565) INFO 10 06 15:58:12 [core.py:210] init engine (profile, create kv cache, warmup model) took 54.87 seconds (APIServer pid 41428) INFO 10 06 15:58:17 [loggers.py:147] Engine 000: vllm cache_config_info with initialization after num_gpu_blocks is: 6297 (APIServer pid 41428) INFO 10 06 15:58:18 [api_server.py:1634] Supported_tasks: ['generate'] (APIServer pid 41428) WARNING 10 06 15:58:18 [model.py:1389] Default sampling parameters have been overridden by the model's Hugging Face generation config recommended from the model creator. If this is not intended, please relaunch vLLM instance with ` generation config vllm`. (APIServer pid 41428) INFO 10 06 15:58:18 [serving_responses.py:137] Using default chat sampling params from model: {'temperature': 0.7, 'top_k': 20, 'top_p': 0.8} (APIServer pid 41428) INFO 10 06 15:58:18 [serving_chat.py:139] Using default chat sampling params from model: {'temperature': 0.7, 'top_k': 20, 'top_p': 0.8} (APIServer pid 41428) INFO 10 06 15:58:18 [serving_completion.py:76] Using default completion sampling params from model: {'temperature': 0.7, 'top_k': 20, 'top_p': 0.8} (APIServer pid 41428) INFO 10 06 15:58:18 [api_server.py:1912] Starting vLLM API server 0 on http://0.0.0.0:8000 (APIServer pid 41428) INFO 10 06 15:58:18 [launcher.py:34] Available routes are: (APIServer pid 41428) INFO 10 06 15:58:18 [launcher.py:42] Route: /openapi.json, Methods: HEAD, GET (APIServer pid 41428) INFO 10 06 15:58:18 [launcher.py:42] Route: /docs, Methods: HEAD, GET (APIServer pid 41428) INFO 10 06 15:58:18 [launcher.py:42] Route: /docs/oauth2 redirect, Methods: HEAD, GET (APIServer pid 41428) INFO 10 06 15:58:18 [launcher.py:42] Route: /redoc, Methods: HEAD, GET (APIServer pid 41428) INFO 10 06 15:58:18 [launcher.py:42] Route: /health, Methods: GET (APIServer pid 41428) INFO 10 06 15:58:18 [launcher.py:42] Route: /load, Methods: GET (APIServer pid 41428) INFO 10 06 15:58:18 [launcher.py:42] Route: /ping, Methods: POST (APIServer pid 41428) INFO 10 06 15:58:18 [launcher.py:42] Route: /ping, Methods: GET (APIServer pid 41428) INFO 10 06 15:58:18 [launcher.py:42] Route: /tokenize, Methods: POST (APIServer pid 41428) INFO 10 06 15:58:18 [launcher.py:42] Route: /detokenize, Methods: POST (APIServer pid 41428) INFO 10 06 15:58:18 [launcher.py:42] Route: /v1/models, Methods: GET (APIServer pid 41428) INFO 10 06 15:58:18 [launcher.py:42] Route: /version, Methods: GET (APIServer pid 41428) INFO 10 06 15:58:18 [launcher.py:42] Route: /v1/responses, Methods: POST (APIServer pid 41428) INFO 10 06 15:58:18 [launcher.py:42] Route: /v1/responses/{response_id}, Methods: GET (APIServer pid 41428) INFO 10 06 15:58:18 [launcher.py:42] Route: /v1/responses/{response_id}/cancel, Methods: POST (APIServer pid 41428) INFO 10 06 15:58:18 [launcher.py:42] Route: /v1/chat/completions, Methods: POST (APIServer pid 41428) INFO 10 06 15:58:18 [launcher.py:42] Route: /v1/completions, Methods: POST (APIServer pid 41428) INFO 10 06 15:58:18 [launcher.py:42] Route: /v1/embeddings, Methods: POST (APIServer pid 41428) INFO 10 06 15:58:18 [launcher.py:42] Route: /pooling, Methods: POST (APIServer pid 41428) INFO 10 06 15:58:18 [launcher.py:42] Route: /classify, Methods: POST (APIServer pid 41428) INFO 10 06 15:58:18 [launcher.py:42] Route: /score, Methods: POST (APIServer pid 41428) INFO 10 06 15:58:18 [launcher.py:42] Route: /v1/score, Methods: POST (APIServer pid 41428) INFO 10 06 15:58:18 [launcher.py:42] Route: /v1/audio/transcriptions, Methods: POST (APIServer pid 41428) INFO 10 06 15:58:18 [launcher.py:42] Route: /v1/audio/translations, Methods: POST (APIServer pid 41428) INFO 10 06 15:58:18 [launcher.py:42] Route: /rerank, Methods: POST (APIServer pid 41428) INFO 10 06 15:58:18 [launcher.py:42] Route: /v1/rerank, Methods: POST (APIServer pid 41428) INFO 10 06 15:58:18 [launcher.py:42] Route: /v2/rerank, Methods: POST (APIServer pid 41428) INFO 10 06 15:58:18 [launcher.py:42] Route: /scale_elastic_ep, Methods: POST (APIServer pid 41428) INFO 10 06 15:58:18 [launcher.py:42] Route: /is_scaling_elastic_ep, Methods: POST (APIServer pid 41428) INFO 10 06 15:58:18 [launcher.py:42] Route: /invocations, Methods: POST (APIServer pid 41428) INFO 10 06 15:58:18 [launcher.py:42] Route: /metrics, Methods: GET (APIServer pid 41428) INFO: Started server process [41428] (APIServer pid 41428) INFO: Waiting for application startup. (APIServer pid 41428) INFO: Application startup complete. (APIServer pid 41428) INFO 10 06 15:58:23 [chat_utils.py:560] Detected the chat template content format to be 'openai'. You can set ` chat template content format` to override this. (APIServer pid 41428) INFO: 192.168.1.11:54734 \"POST /v1/chat/completions HTTP/1.1\" 200 OK (APIServer pid 41428) INFO 10 06 15:58:28 [loggers.py:127] Engine 000: Avg prompt throughput: 170.4 tokens/s, Avg generation throughput: 5.7 tokens/s, Running: 0 reqs, Waiting: 0 reqs, GPU KV cache usage: 0.0%, Prefix cache hit rate: 0.0% (APIServer pid 41428) INFO: 192.168.1.11:54734 \"POST /v1/chat/completions HTTP/1.1\" 200 OK (APIServer pid 41428) INFO: 192.168.1.11:54734 \"POST /v1/chat/completions HTTP/1.1\" 200 OK (APIServer pid 41428) INFO 10 06 15:58:38 [loggers.py:127] Engine 000: Avg prompt throughput: 642.9 tokens/s, Avg generation throughput: 9.9 tokens/s, Running: 0 reqs, Waiting: 0 reqs, GPU KV cache usage: 0.0%, Prefix cache hit rate: 56.3% (APIServer pid 41428) INFO 10 06 15:58:48 [loggers.py:127] Engine 000: Avg prompt throughput: 0.0 tokens/s, Avg generation throughput: 0.0 tokens/s, Running: 0 reqs, Waiting: 0 reqs, GPU KV cache usage: 0.0%, Prefix cache hit rate: 56.3% ```"},"/hardware/zh/kvm/NanoKVM_Pro/desk_start.html":{"title":"NanoKVM-Desk 上手指南","content":" title: NanoKVM Desk 上手指南 keywords: NanoKVM, Remote desktop, Lichee, PiKVM, ARM, tool, PCIe update: date: 2025 9 10 version: v0.1 author: iawak9lkm content: Release docs ## 接口定义 ![desk_interface](../../../assets/NanoKVM/pro/start/Desk Interface.png) ## 接线 1. 连接电源 > NanoKVM Pro 对电源要求略高，部分主板的USB接口无法提供充足的电流。 > 为保证 NanoKVM Pro 正常工作，强烈建议外接5V1A及其以上的电源（实际运行功耗约3W）。 > 如果需要配合灯带使用，强烈建议外接 5V3A 及其以上的电源。 ![desk_con_pwr](../../../assets/NanoKVM/pro/start/desk_con_pwr.jpg) 2. 连接USB HID接口： ![desk_con_hid](../../../assets/NanoKVM/pro/start/desk_con_hid.jpg) 3. 使用网线连接路由器/交换机和NanoKVM Pro，如果没有有线网络，可以跳过此步，开机后配置Wi Fi使用（需要购买带有WiFi的版本，配网操作详见后续配网章节） ![desk_con_eth](../../../assets/NanoKVM/pro/start/desk_con_eth.jpg) 4. 连接HDMI IN，如果主板仅有一个视频接口且有外接屏幕的需求，请将HDMI OUT连接至你的显示屏 ![desk_con_hdmi_in](../../../assets/NanoKVM/pro/start/desk_con_hdmi_in.jpg) > 注意 NanoKVM Pro 采集最大支持4K30FPS，内置的HDMI一分二会主动读取外接屏幕的分辨率和帧率，并向主机提供屏幕和采集端公共的模式列表， > 如果你连接了一个4K60FPS的显示屏，电脑会识别为一个最高支持4K30的屏幕（被采集端限制，可以关闭采集，让4K60直出显示器） > 如果你连接了一个1080P的显示屏，电脑会识别为一个最高1080P的屏幕（被环出显示器限制） 5. （非必须）连接ATX电源控制接口 ![desk_con_atx](../../../assets/NanoKVM/pro/start/desk_con_atx.jpg) 使用一条 USB C to A 数据线连接 KVM B 板和 NanoKVM Desk 的 ATX 接口。 KVM B 板带有通用的9Pin排母接口，可以直接插在主板上，机箱的开机按键、Power LED 等接口可接到 KVM B 的排针上，参考示意图（此处机箱仅连接开机线）： ![img](../../../assets/NanoKVM/unbox/new ATX B.png) ## UI 操作指南 ### 外观 Desk 版本正面配有两个可供交互的部件 * 1.47 寸 IPS 电容式触控 TFT 显示屏 * 带按钮的旋转编码器 ### 旋转编码器操作 旋转编码器支持以下动作： * **向左旋转**：焦点移动到左侧的可聚焦/可交互组件 * **向右旋转**：焦点移动到右侧的可聚焦/可交互组件 * **短按**：触发当前焦点组件的响应动作 * **长按**：若处于一级页面，则进入切换模式，显示切换页面 ### 触摸操作 触摸支持以下动作： * **向左滑动**：整体视图向左移动 * **向右滑动**：整体视图向右移动 * **短按**：触发被点击组件的响应动作 * **长按**：若处于一级页面，则进入切换模式，显示切换页面 ## 内网访问 ### 连接网络 1. **有线连接**：设备上电后，KVM 将自动通过路由器的 DHCP 获取 IP 地址，可直接使用，无需额外配置。 2. **Wi Fi 连接**： 1. 打开 `Settings` → `Wi Fi` 2. 短按 `Wi Fi` 开关 3. 如果未配置过 Wi Fi，KVM 会释放一个 Wi Fi 热点（AP），屏幕会显示该 AP 的信息 4. 使用手机或电脑选择该 AP 并输入密码，或通过扫码快速连接 5. 首次连接成功后，UI 会自动跳转并显示网页链接 6. 使用浏览器打开该链接或扫码网页二维码进入配网界面 > **注意**： > 在 AP 信息页面和网页链接页面之间可通过左右切换。 > 成功连接 Wi Fi 后且不关闭 Wi Fi 功能，每次开机将自动连接。 3. **USB NCM 连接**：如有需要，可通过 USB NCM 方式建立网络连接。 ### 访问网络 1. 连接成功后，首页将显示设备 IP 地址，显示优先级为以太网（ETH）优先，其次是 Wi Fi。若需查看某网卡的详细 IP，可前往 `Settings` 对应页面查看。 2. 在同一局域网内，使用主机浏览器（推荐 Chrome）输入设备 IP 地址即可访问页面。 ![ssl](../../../assets/NanoKVM/pro/start/SSL.png) > **提示**：首次访问时出现安全警告属正常现象。NanoKVM Pro 默认启用了 HTTPS 并使用自签名 SSL 证书以增强安全性。 3. 使用初始默认帐号 `admin`，密码 `admin` 登陆系统。**强烈建议您首次登陆后立即修改帐号和密码**。 4. 登陆成功后，检查图像显示、键鼠控制及开关机按钮功能是否正常。 ![4k](../../../assets/NanoKVM/pro/start/nanokvm4K.png) ## 远程连接 1. **Tailscale**：NanoKVM Pro 默认预装了 Tailscale 应用。您可在网页设置中登陆 Tailscale 帐号。所有已登陆 Tailscale 的设备将自动加入同一虚拟内网，并获得 `100.xxx.xxx.xxx` 的 IP。通过该 IP，您可以远程访问并控制您的主机。 2. **其他异地组网工具**：NanoKVM Pro 基于 Ubuntu 系统，支持使用 `apt` 安装第三方应用（如 ZeroTier）。请按照相关工具的官方文档完成安装与配置。 ## 安装到机柜 NanoKVM Pro Desk 预留了安装到机柜的可能性，但需要用户进行一些动手操作。 Desk底部脚垫下有四颗螺丝，其中靠后两颗可以作为结构固定螺丝。（注意前面两颗螺丝较短，且靠近PCBA内部元件，不建议用来固定） 我们提供Desk的3D模型，和参考的机柜转接板设计（单体和三联）在这里，你可以下载打印使用，或者自行设计。 [3d_zh](https://makerworld.com.cn/zh/models/1659366 nanokvm pro desk mo xing#profileId 1821374) [3d_en](https://makerworld.com/zh/models/1873387 nanokvm pro desk model#profileId 2005371) 安装步骤 1. 撕开靠后的脚垫，卸下原M2x6 mm的螺丝 （新批次的已经都使用了7mm螺丝） 2. 换上M2x7 mm的螺丝, 固定到转接板上 3. 将转接板固定到机柜边缘的螺丝孔上 安装好后的示意图： ![rack1](../../../assets/NanoKVM/pro/start/rack1.jpg) ![rack3](../../../assets/NanoKVM/pro/start/rack3.jpg) ## 散热和工作温度 为了工作寿命考虑，NanoKVM Pro Desk 使用被动散热方式。 KVM主体使用铝合金外壳，散热路径主要是从PCBA底部通过导热硅脂传递到外壳底部，然后通过外壳底部传热到 底部平面，或者传热到顶部表面散热。 所以KVM放到散热较好的金属上(如金属机箱，机柜)，或者放在通风的环境中，有助于散热。 KVM典型工作功耗为3 4W，外壳的工作温升在15 20℃，CPU工作温升在50℃左右。 所以放在桌面等手经常需要触摸的场景，建议工作温度在25℃内，这样外壳温度在45℃以内（由于外壳是金属，手摸的感觉比同温度的塑料热） 如果放在机柜等不需要手触摸的场景，建议工作温度在40℃内。 下图为室温26℃时的表面温度 ![temp](../../../assets/NanoKVM/pro/start/temperature.jpg)"},"/hardware/zh/kvm/NanoKVM_Pro/extended.html":{"title":"高级应用","content":" title: 高级应用 keywords: NanoKVM, Remote desktop, Lichee, PiKVM, ARM, tool, PCIe update: date: 2025 8 26 version: v0.1 author: BuGu content: Release docs date: 2025 9 11 version: v0.2 author: iawak9lkm content: Add new feature description ## 系统框架切换 NanoKVM Pro 除运行 NanoKVM 框架外，还完全适配了 PiKVM 软件框架。您可以根据使用需求灵活切换。 ### 从 NanoKVM 切换至 PiKVM NanoKVM Pro 出厂默认运行 NanoKVM 框架。切换步骤如下： 1. 进入 `设置` → `关于` → `切换设备` ![](./../../../assets/NanoKVM/pro/extended/SwitchtoPiKVM.png) 2. 点击切换按钮后，系统将自动重启并启动 PiKVM 框架（约需 30 秒）。如长时间未自动切换，请手动刷新网页 ![](./../../../assets/NanoKVM/pro/extended/PiKVMLogin.png) 3. PiKVM 框架下的默认账号密码同样为 `admin` / `admin` ![](./../../../assets/NanoKVM/pro/extended/PiKVM Setting.png) **注意事项：** > > 两个平台各自独立管理账号与密码，互不同步，强烈建议登录后立即修改默认密码 > PiKVM 框架下的部分功能需要通过网页终端实现，如 WiFi 配网、Tailscale 配置等 > NanoKVM 系统更新时，PiKVM 框架会同步更新 ### PiKVM 密码管理 PiKVM 目前不支持通过网页端 WebUI 修改密码，需要通过 SSH 或网页终端执行以下命令： ```shell # 修改 Linux 系统用户密码 passwd root # 修改 KVM 登录密码 kvmd htpasswd set admin # 用户管理命令 kvmd htpasswd add <user> # 添加新用户并设置密码 kvmd htpasswd list # 显示用户列表 kvmd htpasswd del <user> # 删除用户 ``` 更多使用方法请参考 [PiKVM 官方文档 认证管理](https://docs.pikvm.org/auth/)。 ### 配置 WiFi 网络 PiKVM 目前不支持通过网页端 WebUI 和 LCD 屏幕配置 WiFi。您可以选择以下任一方式： **方式一：切换到 NanoKVM 框架配置（推荐）** 切换至 NanoKVM 框架后使用网页端或 LCD 屏幕配置 WiFi，再切换回 PiKVM 框架 **方式二：使用命令行配置** 通过 SSH 或网页终端执行以下命令： ```shell # 连接到开放网络（无密码） /kvmcomm/scripts/wifi.sh connect_start <SSID> # 连接到加密网络（需要密码） /kvmcomm/scripts/wifi.sh connect_start <SSID> <PASSWORD> # 断开 WiFi 连接 /kvmcomm/scripts/wifi.sh connect_stop ``` ### 配置 Tailscale 网络 PiKVM 目前不支持通过网页端 WebUI 配置 Tailscale。请使用 NanoKVM 框架配置 Tailscale，再切换回 PiKVM 框架。 ### 从 PiKVM 切换回 NanoKVM 从 PiKVM 系统切换回 NanoKVM 同样简单： 1. 进入 `Options` → `Switch to NanoKVM` 2. 点击 `Switch Now` 按钮 ![](./../../../assets/NanoKVM/pro/extended/SwitchtoNanoKVM.png) 3. 系统将自动重启并启动 NanoKVM 框架（约需 30 秒）。如长时间未自动切换，请手动刷新网页 ### 更多功能 更多功能请参考 [PiKVM 官方文档](https://docs.pikvm.org/)。 ## SSH & mDNS ### SSH NanoKVM Pro 出厂默认关闭 SSH，以确保系统安全。若需要启用 SSH 服务或在预览新版本时使用，可以通过以下方式开启： **ATX/Desk**：从网页端 `设置` → `设备` → 开启 `SSH` **Desk**：从屏幕中点击 `Settings` → `SSH` 开启 `SSH` 默认帐号为 `root`，密码为 `sipeed`。若在 NanoKVM 界面中修改了网页帐号密码，SSH 密码会同步更新。 ### mDNS 如需开启或关闭 mDNS，可通过以下方式操作： **ATX/Desk**：从网页端 `设置` → `设备` → 开启/关闭 `mDNS` **Desk**：从屏幕中点击 `Settings` → `mDNS` 开启/关闭 `mDNS` ## HDMI 输入与环出 > 目前仅支持 Desk 版本屏幕中配置 > ATX/Desk 网页端近期会添加该功能 若暂时无需 HDMI 功能，可关闭以降低功耗。操作方式： Desk 从屏幕点击 `Settings` → `HDMI` 进入 HDMI 配置页面，有两个选项： **INPUT**：关闭后，Desk 停止采集 HDMI 输入信号。 **LOOP OUT**：关闭后，Desk 停止输出 HDMI 环出信号。 ## 屏幕调整 ### ATX 版本 目前支持 OLED 屏幕的以下功能： 短按 `USR` 按钮可开关 OLED 显示 ### Desk 版本 支持 LCD 屏幕的以下功能（均从屏幕中进行配置）： 调整背光亮度：`Settings` → `Brightness` 待机时钟：`Settings` → `Auto Clock` 关闭时，LCD 常亮 开启后，长时间无操作则切换为时钟显示 ## 恢复出厂设置 ### 快速恢复 **ATX**：长按 `USR` 按钮，直至屏幕显示 `Reset` 提示后松开 > 要求版本 ≥ `1.0.13` **Desk**：从屏幕中点击 `Settings` → `Help` 进入 Help 页面，然后连续点击重置按钮，直至显示 `0`，设备进入恢复模式 > **提示**：在设备完成重启并刷新屏幕前，请勿进行其他操作。 ### 深度恢复 详见 [FAQ](https://wiki.sipeed.com/hardware/zh/kvm/NanoKVM_Pro/faq.html#%E9%95%9C%E5%83%8F%E7%83%A7%E5%BD%95%E6%96%B9%E6%B3%95) 中 `镜像烧录方法` 章节。 ## USB 扩展功能 ### USB NCM NCM 功能可通过 USB 模拟网卡，方便用户直接通过 USB 登录 NanoKVM。开启方式如下： **ATX/Desk**：从网页端进入 `设置` → `设备` → 开启 `虚拟网卡` **Desk**：从屏幕中点击 `Settings` → `USB` 进入 USB 配置页面，开启 `NCM` ## 更新 NanoKVM Pro 会不定时推送新版本的应用，包含新功能和bug修复，您可以在`设置` >`检查更新`中更新应用版本。 ![](./../../../assets/NanoKVM/pro/extended/Update.png) 点击下载后会自动下载新应用的安装包，包含`kvmcomm_x.x.x_arm64.deb`、`nanokvmpro_x.x.x_arm64.deb`、`pikvm_x.x.x_arm64.deb` `kvmcomm_x.x.x_arm64.deb` 负责驱动 NanoKVM 和 PiKVM 框架中共用的硬件； `nanokvmpro_x.x.x_arm64.deb` NanoKVM 应用软件 `pikvm_x.x.x_arm64.deb` PiKVM 应用软件 打开预览更新功能将会获取到最新的实验版应用，通常包含更新的功能，但稳定性有待验证，建议下载预览更新前先打开SSH功能 您也可以下载特定的版本，并手动安装 ```shell # 以下载 1.1.6 版本为例 # 下载文件 sudo curl L https://cdn.sipeed.com/nanokvm/preview/nanokvm_pro_1.1.6.tar.gz sudo tar xz # 进入文件夹 cd nanokvm_pro_1.1.6 # 安装deb包 sudo apt install ./*.deb ``` > 1.1.5 及后续软件进行过一次架构调整，较低版本的NanoKVM Pro只能拉取到 1.1.5 ，更新后可再次拉取到最新的版本 ## 如何使用TF卡扩展存储 NanoKVM Desk 版后面板设计有TF卡槽，插入TF卡后可以扩展存储空间，并带来`虚拟U盘`的功能。 TF卡默认挂载与 NanoKVM 系统 `/sdcard` 目录下，当开启`虚拟U盘`后TF卡被同时挂载到USB复合出的大容量存储设备，可以借此功能向被控主机传递文件 > 注意： > ATX版本因挡板尺寸要求，无法暴露TF卡槽 > 首批Desk版本TF卡无法热拔插，请在关机状态下插入TF卡 > 虚拟U盘和镜像挂载功能不可同时开启 ## 如何远程装机 NanoKVM Pro 的 USB C 端口除模拟键鼠设备外，还模拟了一个U盘设备，可挂载指定的镜像，用于装机等需求，镜像可以上传至NanoKVM Pro中，可用空间约21G。 与普通U盘不同，NanoKVM的虚拟U盘内可同时存放多个镜像，开机之前可以通过 web 页面的选项选择要安装的系统镜像进行挂载。 按上述步骤连接远程主机与Nano KVM，在浏览器登录系统后，点击光盘图标，选中待安装的系统，即可实现ISO挂载 ![](./../../../assets/NanoKVM/guide/imgsl.png) 接下来开始装机操作，点击`开机（短按）`，迅速按键盘上的F11键（不同主机按键可能不同，请参照主机说明），选择对应的镜像启动并完成装机流程。 ![](./../../../assets/NanoKVM/guide/install.png) 注： 所有上传的镜像将储存于NanoKVM Pro的 `/data` 目录，用户可在 NanoKVM 终端内直接读写该分区 若挂载镜像出现问题，可以尝试在主机上弹出镜像后再点击挂载 ## 如何设置静态IP NanoKVM Pro 在`1.1.6`及以上版本中加入了以太网卡的静态IP设置功能，通过配置`/boot/eth.nodhcp`文件来主动赋予IP，详细设置方法如下： 在 NanoKVM Pro 中创建文件 `/boot/eth.nodhcp` ，然后按照以下规则进行编辑： 一行就是一个自定义 IP，格式为 `addr/netid gw[optional]` ； 可以分多行来预设多个静态 IP。 简化的步骤如下： ``` shell # 以下操作在 NanoKVM Pro 的网页终端或ssh终端完成 # 创建 /boot/eth.nodhcp 文件并写入配置 echo \"192.168.2.2/22\" > /boot/eth.nodhcp ``` > 系统启动时，会读取 `/boot/eth.nodhcp` 文件中的静态 IP 地址列表。设置流程如下： > > 1. **顺序检测**：系统将按行读取文件中的 IP，并依次检测其是否已被网络中的其他设备占用。 > 2. **检测机制**：优先使用 `arping` 进行检测；若系统中未安装 `arping`，则自动降级使用 `ping` 命令。 > 3. **设置可用 IP**：一旦发现首个未被占用的 IP，系统立即将其设置为本机静态地址，流程终止。 > 4. **后备方案**：若列表中所有 IP 均被占用，系统将转而尝试通过 DHCP 自动获取 IP。 > 5. **保底地址**：如果 DHCP 也无法分配地址（例如，网络中无 DHCP 服务器），系统将使用固定的保底地址 `192.168.90.1`。 ## 如何使用串口 NanoKVM Pro 提供两组可用串口 UART1/UART2（ATX版本受限挡板规范尺寸没有引出，仅保留内部焊盘） Desk 版本接口定义示意图如下： ![](./../../../assets/NanoKVM/pro/extended/UART.png) 网页端使用串口终端 **需要更新至 1.1.5 版本以上** 网页菜单栏 >终端 >串口中断 可以设置串口号以及波特率等选项 ![](./../../../assets/NanoKVM/pro/extended/UART 2.png) 仅发送串口指令 ```shell # 设置ttyS1为115200波特率 stty F /dev/ttyS1 115200 # 发送十六进制数据 0x11, 0x22, 0x33 echo n e '\\x11\\x22\\x33' > /dev/ttyS1 ``` ## 如何修改EDID EDID（扩展显示识别数据）是显示设备向主机提供的一组数据，包括设备信息、分辨率帧率列表、颜色特性、音频能力等。主机接受到 EDID 后按需调整显示器的设置 NanoKVM Pro 支持修改虚拟显示屏暴露的EDID，您可以克隆显示器的EDID或编写自己的EDID，来达到特殊的屏幕比例、刷新率或颜色特征 > 修改EDID后可能存在无法正常显示的风险，请谨慎修改。如果出现异常，请恢复默认EDID 写入方式： ```shell # 1. 准备edid文件，一般大小是256Byte，scp 到系统中 ls l /root/customize.bin # rw r r 1 1000 1000 256 Aug 19 14:44 /root/customize.bin # 2. 写入EDID cat /root/customize.bin > /proc/lt6911_info/edid # 3. 恢复默认EDID： cat /kvmcomm/edid/e18.bin > /proc/lt6911_info/edid ``` 1.2.0 版本中自带六个edid：以下是EDID的支持分辨率列表和最高帧率： 分辨率 宽高比 3840×2160@30Hz 3840×2160@39Hz 2560×1440@60Hz 1920×1080@60Hz 3840×2400@30Hz 3440×1440@60Hz 3840×2400 16:10 × × × × 30 FPS × 3840×2160 16:9 30 FPS 39 FPS × × 30 FPS 30 FPS 3840×1600 21:9 × × × × × 50 FPS 3440×1440 21:9 × × × × × 60 FPS 2560×1440 16:9 83 FPS 83 FPS 60 FPS × 60 FPS 60 FPS 2560×1080 21:9 × × × × × 75 FPS 1920×1200 16:10 60 FPS 60 FPS 60 FPS × 60 FPS × 1920×1080 16:9 120 FPS 125 FPS 60 FPS 60 FPS 60 FPS 60 FPS 1680×1050 16:10 60 FPS 60 FPS 60 FPS 60 FPS 60 FPS 60 FPS 1440×900 16:10 60 FPS 60 FPS 60 FPS 60 FPS 60 FPS 60 FPS 1280×1024 5:4 60 FPS 60 FPS 60 FPS 60 FPS 60 FPS 60 FPS 1280×960 4:3 60 FPS 60 FPS 60 FPS 60 FPS 60 FPS 60 FPS 1280×800 16:10 60 FPS 60 FPS 60 FPS 60 FPS 60 FPS 60 FPS 1280×720 16:9 120 FPS 120 FPS 60 FPS 60 FPS 60 FPS 60 FPS 1152×864 4:3 60 FPS 60 FPS 60 FPS 60 FPS 60 FPS 60 FPS 1024×768 4:3 60 FPS 60 FPS 60 FPS 60 FPS 60 FPS 60 FPS 800×600 4:3 120 FPS 120 FPS 60 FPS 60 FPS 60 FPS 60 FPS > 不在此列表的分辨率可能会出现显示错误或无法显示的问题 > 较低的分辨率可能会出现兼容性问题导致不显示或显示闪烁 ## 如何获取EDID Windows 1. 按 `Win+R` 打开运行窗口，输入 `regedit` 并确认。 2. 在注册表中导航至 `HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Enum\\DISPLAY`。 3. 找到对应显示器的 EDID 项，路径类似 `<厂商ID>_<型号>\\<实例ID>\\Device Parameters\\EDID`，记录完整路径。 4. 新建 `edid.ps1` 文件，输入以下内容： ```powershell $regPath \"HKLM:\\SYSTEM\\CurrentControlSet\\Enum\\DISPLAY\\<ID>\\<InstanceID>\\Device Parameters\" $edid (Get ItemProperty Path $regPath Name EDID).EDID [IO.File]::WriteAllBytes(\"C:\\Users\\Public\\edid.bin\", $edid) Write Host \"EDID exported to C:\\Users\\Public\\edid.bin\" ``` 5. 将 `<ID>` 和 `<InstanceID>` 替换为你的显示器信息。 6. 保存文件后右键选择“以 PowerShell 运行”。如果出现权限拒绝，可执行以下步骤： 以管理员身份打开 PowerShell。 执行 `Set ExecutionPolicy RemoteSigned` 并确认。 7. 成功执行后，EDID 文件将位于 `C:\\Users\\Public\\edid.bin`。 Linux ```bash # 将 <card> 替换为实际 DRM 卡名称，如 card0 或 card1 sudo cat /sys/class/drm/<card>/edid > ~/edid.bin ``` MacOS 1. 打开“终端”，执行以下命令读取显示设备信息： ```shell ioreg lw0 grep i EDID ``` 2. 在输出中找到形如以下内容的行： ```shell \"EDID\" <00ffffffffffff00...> ``` 其中 `< >` 内部的十六进制字符串即为 EDID 数据。 3. **完整复制** `< >` 中的十六进制字符串（不包含尖括号本身），假设内容为 `xxx`。 4. 执行以下命令，将 EDID 字符串转换为二进制文件： ```shell echo \"xxx\" xxd r p > ~/edid.bin ``` 5. 若命令执行成功，当前用户主目录下即可看到生成的 `edid.bin` 文件。 PowerShell 失败方法及排查 1. **权限不足**：确认以管理员身份运行 PowerShell。 2. **脚本执行策略限制**：执行 `Get ExecutionPolicy` 查看当前策略，必要时使用 `Set ExecutionPolicy RemoteSigned`。 3. **注册表路径错误**：确认 `DISPLAY` 下子项及实例 ID 与 `$regPath` 一致。 4. **EDID 属性不存在**：某些显示器或远程会话下可能无 EDID，建议直接在本机物理显示器上操作。 5. **文件写入失败**：确保 `C:\\Users\\Public\\` 可写，或修改为其他可写路径。 ## 如何修改USB信息 `1.2.0`版本以上支持自定义USB信息，方式如下： ```shell # 修改PID echo \"0xXXXX\" > /boot/usb.pid # 修改VID echo \"0xXXXX\" > /boot/usb.vid # 修改制造商 echo \"XXXX\" > /boot/usb.manufacturer # 修改产品名称 echo \"XXXX\" > /boot/usb.product # 应用 /kvmapp/scripts/usbdev.sh restart ``` ## 如何通过 USB 网卡共享网络 `1.2.11` 版本以上支持通过 USB 网卡共享网络，使被控主机能够通过 USB 连接访问 NanoKVM Pro 所在网络。 ```bash # 开启 usb 网卡（ncm 模式和 rndis 模式二选一） touch /boot/usb.ncm # touch /boot/usb.rndis # 设置网卡 IP 地址（可选，默认使用设备 id 生成固定 IP） echo \"10.10.10.1/24\" > /boot/ncm.ipv4 # 设置 DNS 服务器地址（可选，默认使用 8.8.8.8, 8.8.4.4） echo \"8.8.8.8 8.8.4.4\" > /boot/ncm.dns # 设置流量转发接口（eth0 为有线网卡，wlan0 为无线网卡） echo \"eth0\" > /boot/ncm.forward # 重启 USB 网卡生效 /kvmapp/scripts/usbdev.sh restart ``` ## 如何搭配上位机使用 NanoKVM Pro 的上位机应用程序，需要安装并运行在被控上位机中，为用户提供更多功能扩展与体验优化。 推荐直接使用预编译好的 Release 版本 进行安装，目前上位机还在开发完善中，后续会开源源码以供自行编译。 [下载地址](https://github.com/sipeed/NanoKVM Pro/releases/tag/v1.0.5) 安装完成后，启动应用程序，输入要配对的 NanoKVM Pro 的局域网 IP 地址进行确认即可。应用会在后台运行，可通过系统托盘图标右键关闭。 主要功能 自动隐藏被控机光标，提升远程控制体验 当上位机能连接到 NanoKVM Pro 时，会隐藏被控机光标 当上位机与 NanoKVM Pro 断开连接后一段时间后，光标会恢复显示 采集被控机 CPU 与内存使用情况，并传输给 NanoKVM Pro 在 Desk 版本中，可通过 Host Info 页面实时查看被控机状态 ## 关于延迟 NanoKVM Pro针对延迟进行了较大改进，任意分辨率下端到端延迟控制在100ms左右。 > 其它竞品表述的延迟非端到端延迟，而是单程延迟，实际端到端延迟远大于他们宣称的延迟。 > 实测表明选择不同帧率，对端到端的延迟影响不大，也就是说，1080P120和1080P30的延迟几乎一致。 视频模式 端到端延迟 Direct H264 100ms WebRTC H264 100ms MJPEG 100~150ms 注意，我们使用\"端到端\"延迟来体现用户实际感知的延迟： 从用户在本地浏览器窗口移动鼠标，到 浏览器中远程桌面鼠标开始移动的延迟。 你可以使用[这个py脚本](../../../assets/NanoKVM/pro/extended/lat_mouse.py)实测\"端到端\"延迟，将浏览器窗口全屏或者放到左边，保持当前远程桌面的背景颜色与鼠标指针颜色反差最大（比如黑色指针，则使用白色背景；白色指针则使用黑色背景） ``` python lat_mouse.py TEST_CNT RECORD_NAME ``` 4K30 webrtc的延迟测试记录： ![](./../../../assets/NanoKVM/pro/extended/4K30_latency.png)"},"/hardware/zh/kvm/NanoKVM_Pro/faq.html":{"title":"常见问题","content":"# 常见问题 ## 更新解决问题 NanoKVM Pro 会不定期更新应用，一些问题可能在新的应用中已经解决，所以请首先尝试更新应用 ## 系统启动 ### 绿色LED闪烁 绿色LED是 NanoKVM Pro 的电源指示，如果连接了供电能力较弱的电源，绿色LED会因电压不稳定而无法启动，请拔掉所有供电并更换电源 ### 切换 PiKVM 后无法正常工作 应用版本为 `1.2.9` 的部分设备在切换到 PiKVM 后可能会出现 PiKVM 反复重启的问题，请在 NanoKVM 的 Web 界面将应用版本更新至 `1.2.10` 或以上版本以解决该问题。 如果已经无法切换回 NanoKVM, 请参考[镜像烧录方法](#%E9%95%9C%E5%83%8F%E7%83%A7%E5%BD%95%E6%96%B9%E6%B3%95)重新烧录 NanoKVM Pro 镜像 ## 网络相关问题 ### WiFi 版本 NanoKVM Pro ATX/Desk 缺少WiFi配置界面 请在设置 >检查更新中更新至1.2.13或以上版本即可解决 如果因网络问题无法在网页更新，可以尝试通过重烧镜像方式解决：先下载[1.0.13](https://github.com/sipeed/NanoKVM Pro/releases/tag/v1.0.13)版本及以上的镜像,然后根据[操作步骤](https://wiki.sipeed.com/hardware/zh/kvm/NanoKVM_Pro/faq.html#%E9%95%9C%E5%83%8F%E7%83%A7%E5%BD%95%E6%96%B9%E6%B3%95)完成烧录 ### NanoKVM Pro ATX 无法通过 OLED 屏配网 在较早的版本\\[1\\]中，WiFi 版本 ATX 长按 `USR` 按键 OLED 可能会停留在 `Starting` 页面无法进入配网页面。 临时解决办法： 通过以太网连接设备后，登录 Web 界面，在 `设置` → `设备` → `Wi Fi` 中完成 Wi Fi 配网。 将 NanoKVM ATX 的 HID 接口连接到电脑。在 Windows 命令行执行 `ipconfig`（Linux 使用 `ifconfig`），找到新增的类似 `10.aaa.bbb.ccc` 的 IPv4 地址（例如 `10.223.155.100`）。通过 `10.aaa.bbb.1` 登录并访问 NanoKVM 的Web页面，在 `设置` → `设备` → `Wi Fi` 中完成 Wi Fi 配网。 在成功连接到网络后建议通过更新应用版本(> `1.2.9`)彻底修复该问题。 \\[1\\]: 具体版本为: `1.1.8` ~ `1.2.8` ## 视频相关问题 ### NanoKVM Pro 无法显示BIOS和登陆界面 主机有多个显示器时，一般会默认优先内置屏幕或DP接口屏幕显示BIOS和登陆界面，请查阅主板手册调整显示优先级，或使用环出接口连接你的显示器 ### DP转接器兼容性问题 DP转接器有被动和主动两种，被动DP转接器价格低廉，但可能存在兼容性风险，表现为分辨率列表与EDID不一致，主机唤醒无法启动屏幕等，使用重置HDMI功能可唤醒屏幕 ### 分辨率列表缺失，和EDID不符 主机显示设置中的分辨率列表由主机、EDID和（可能存在的）环出屏幕、视频转接器共同决定，可以在网页切换不同的EDID来实现最合理的兼容性 ### NanoKVM 小屏幕上HDMI图表亮起但无法在网页中看到画面 NanoKVM Pro具有采集和环出视频的功能，仅采集时默认向主机汇报最高4K30FPS的分辨率，连接环出显示器时会汇报一个公共的分辨率列表。 默认的分辨率帧率列表请参考[这里](https://wiki.sipeed.com/hardware/zh/kvm/NanoKVM_Pro/extended.html#%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9EDID) 连接视频转接器或拓展坞情况下可能会改变其内容，如汇报4K60FPS的采集能力导致无法采集，需要在主机系统设置中修改显示参数 Windows下一般在`设置` >`显示设置` >`高级显示设置` >选择`NanoKVM Pro`显示器 >`显示器属性` >`列出所有模式` >选择需要调整的模式 >点击应用或确认 ![](./../../../assets/NanoKVM/pro/faq/res.png) ### 画面较糊，不符合采集到的分辨率 上图中3号框：若出现桌面分辨率小于有源信号分辨率，可能会出现采集画面清晰度不符合预期的情况，也可以通过上述流程输出清晰的画面 ## 镜像烧录方法 ### USB 烧录 NanoKVM Pro 支持通过 USB 烧录镜像的方式来恢复或更新系统。 #### 准备工作 准备一根 USB 数据线 下载最新的 NanoKVM Pro 镜像文件 准备烧录工具（如 balenaEtcher、Rufus 或 dd 命令） #### 烧录步骤 1. **下载镜像与烧录工具** 访问 [NanoKVM Pro 发布页面](https://github.com/sipeed/NanoKVM Pro/releases/latest) 下载最新镜像文件 下载并安装烧录工具 [balenaEtcher](https://etcher.balena.io/) 2. **进入烧录模式** 使用 USB 数据线连接 NanoKVM Pro 的 HID 接口到电脑 先按住 NanoKVM 的 User 按键，然后接通电源（或者在通电状态下按下 Reset 按键），直到橙色 LED 灯熄灭 这时设备会进入烧录模式，橙色灯再次开始闪烁，查看电脑是否识别到新的磁盘设备 <div style \"display: flex; justify content: center; gap: 20px; flex wrap: wrap; align items: flex end;\"> <div style \"text align: center; flex: 1; max width: 400px; min width: 300px;\"> <img src \"./../../../assets/NanoKVM/pro/faq/update_win.jpeg\" alt \"Windows 识别设备\" style \"width: 100%; height: auto; object fit: contain; border radius: 4px; box shadow: 0 2px 8px rgba(0,0,0,0.1);\"> <p style \"margin top: 8px; margin bottom: 0; font style: italic; color: #666; font size: 16px;\">Windows 识别设备</p> </div> <div style \"text align: center; flex: 1; max width: 400px; min width: 300px;\"> <img src \"./../../../assets/NanoKVM/pro/faq/update_linux.jpeg\" alt \"Linux 识别设备\" style \"width: 100%; height: auto; object fit: contain; border radius: 4px; box shadow: 0 2px 8px rgba(0,0,0,0.1);\"> <p style \"margin top: 8px; margin bottom: 0; font style: italic; color: #666; font size: 16px;\">Linux 识别设备</p> </div> </div> 3. **使用 balenaEtcher 烧录**（推荐） 启动 balenaEtcher 点击 \"Flash from file\" 选择下载的镜像文件 点击 \"Select target\" 选择识别到的 NanoKVM Pro 设备 点击 \"Flash!\" 开始烧录 等待烧录完成并验证 <div align \"center\"> <img src \"./../../../assets/NanoKVM/pro/faq/flash.jpeg\" style \"width: 80%; height: auto; border radius: 4px; box shadow: 0 2px 8px rgba(0,0,0,0.1);\" alt \"flash\" > </div> 如果提示找不到分区表是正常现象，点击继续即可 <div align \"center\"> <img src \"./../../../assets/NanoKVM/pro/faq/miss_part.jpeg\" style \"width: 70%; height: auto; border radius: 4px; box shadow: 0 2px 8px rgba(0,0,0,0.1);\" alt \"miss_part\" > </div> 4. **使用命令行烧录** ```bash # 查找设备名 sudo fdisk l # 解压镜像文件（如果是 .xz 格式） xz dv 20250828_NanoKVMPro_1_0_10.img.xz # 烧录镜像（请替换 /dev/sdX 为实际的设备名） sudo dd if 20250828_NanoKVMPro_1_0_10.img of /dev/sdX bs 4M status progress sudo sync ``` 5. **重启设备** 烧录完成后，安全弹出设备 断开 USB 连接 重新接通电源，设备将自动启动新系统 #### 注意事项 确保选择正确的设备，避免误操作其他存储设备 烧录过程中不要断开电源或移除 USB 连接 首次启动可能需要较长时间进行初始化配置 如果橙色灯一直不亮，或者磁盘设备没有出现，请参考下面的方法使用 AXDL 烧录 ### AXDL 烧录 AXDL 是爱芯官方推出的镜像烧录工具，可以烧录 AXP 格式的系统镜像，目前仅支持 Windows 平台。 #### 准备工作 准备一根 USB 数据线 访问 [NanoKVM Pro 发布页面](https://github.com/sipeed/NanoKVM Pro/releases) 下载最新的 AXP 格式镜像文件 下载并安装 AXDL 工具和对应驱动 [下载地址](https://dl.sipeed.com/shareURL/MaixIV/M4N Dock/10_PC_Software) #### 烧录步骤 1. **连接设备** 使用 USB 数据线连接 NanoKVM Pro 的 HID 接口到电脑 2. **配置烧录工具** 打开 AXDL 工具 选择下载的 AXP 格式镜像文件 点击开始烧录按钮 <div align \"center\"> <img src \"./../../../assets/NanoKVM/pro/faq/axdl.jpeg\" style \"width: 80%; height: auto; border radius: 4px; box shadow: 0 2px 8px rgba(0,0,0,0.1);\" alt \"AXDL烧录工具界面\"> </div> 3. **进入烧录模式并开始烧录** 先按住 NanoKVM 的 User 按键，然后接通电源（或者在通电状态下按下 Reset 按键） 烧录将自动开始，等待进度条完成 直到提示烧录成功，整个过程完成 ### SD 卡烧录 NanoKVM Pro Desk 支持通过 SD 卡将镜像写入内置 eMMC 来恢复或更新系统。注意：目前仅支持将镜像从 SD 卡烧录到内置 eMMC，设备不能直接从 SD 卡启动。 #### 准备工作 准备一张容量至少 8 GB 的 SD 卡。 下载最新的 [NanoKVM Pro SD 镜像](https://github.com/sipeed/NanoKVM Pro/releases)（通常为 zip 压缩包），解压后取出其中的 `img` 文件。 准备烧录工具（如 `balenaEtcher`、`Rufus` 或使用命令行的 `dd`）。 准备一个 USB 读卡器以连接 SD 卡。 #### 烧录步骤 1. 使用 `balenaEtcher` 或 `dd` 将 `img` 镜像写入 SD 卡（具体写入方法参照上文“USB 烧录”部分）。 2. 将写好镜像的 SD 卡插入 NanoKVM Pro 的 SD 卡槽。 3. 断开 NanoKVM Pro Desk 的电源。 4. 按住 NanoKVM Pro Desk 的 `User` 按键，同时接通电源。 5. 当橙色 LED 开始匀速闪烁时，表示开始将 SD 卡中的镜像烧录到内置 eMMC。 6. 烧录完成后，橙色 LED 由闪烁变为常亮，表示烧录成功。 7. 断开电源并取出 SD 卡，重新接通电源后设备将从内置 eMMC 自动启动新系统。 ## Desk版本LCD不亮 这可能是由于运输过程中LCD的FPC排线松动导致。 点击 [此处](https://wiki.sipeed.com/nanokvmpro lcd) 查看问题和修复细节 ## 外观问题 ### 底部螺丝“缺失” 首批NanoKVM Desk因结构设计原因，下图左上角螺丝会影响WiFi连接的稳定性，在后期组装时该孔位留空 ![](./../../../assets/NanoKVM/pro/faq/screw.jpg)"},"/hardware/zh/kvm/NanoKVM_Pro/lcd_fix.html":{"title":"NanoKVM Desk LCD屏幕异常","content":" title: NanoKVM Desk LCD屏幕异常 ## 适用情况 1. 屏幕无法正常显示：开机无logo，但背面橙色LED正常闪烁 2. 屏幕触摸失灵：无论如何点击/长按/滑动都无反应 ## 问题原因 NanoKVM Desk 因运输颠簸，可能因屏幕FPC排线脱落/接触不良导致显示异常 ## 修复步骤 > ❗❗❗以下步骤涉及拆解，拆解有风险，请仔细阅读以下步骤后再小心操作❗❗❗ **材料准备** 1. 屏幕异常的 NanoKVM Desk 2. 螺丝刀 3. 窄垫片（可以用纸片替代） 4. 镊子 ![](../../../assets/NanoKVM/pro/lcd_fix/lcd_fix_00.jpg) **详细步骤** 1. 撕开底部两条硅胶垫（略微施加倾斜的拉力缓慢撕开可避免留胶）；拧开四颗螺丝，注意靠近屏幕一侧的螺丝是两颗短自攻螺丝，靠近尾部接口处的是两颗长M2螺丝，保存好胶垫和螺丝。 ![](../../../assets/NanoKVM/pro/lcd_fix/lcd_fix_01.jpg) 2. 屏幕支架通过底部和顶部4个卡扣固定在阳极氧化铝制外壳上，先从底部掰开屏幕盖板，再掰开顶部 > ❗❗❗此步骤风险较高，可能会扯断底部的屏幕排线，请控制力道❗❗❗ ![](../../../assets/NanoKVM/pro/lcd_fix/lcd_fix_02.jpg) ![](../../../assets/NanoKVM/pro/lcd_fix/lcd_fix_03.jpg) 3. 从接口后面板将 NanoKVM Desk 机芯推出 ![](../../../assets/NanoKVM/pro/lcd_fix/lcd_fix_04.jpg) 4. 用镊子去掉贴在屏幕FPC排线上的贴纸；挑开FPC座子上的黑色压紧座后取出屏幕排线 ![](../../../assets/NanoKVM/pro/lcd_fix/lcd_fix_05.jpg) ![](../../../assets/NanoKVM/pro/lcd_fix/lcd_fix_06.jpg) 5. 在FPC座子中塞入窄纸条；在纸条上插入屏幕FPC排线，插到底后锁紧座子 > 注：屏幕排线使用上接方式连接座子，即触点朝上 ![](../../../assets/NanoKVM/pro/lcd_fix/lcd_fix_07.jpg) ![](../../../assets/NanoKVM/pro/lcd_fix/lcd_fix_08.jpg) 6. 上电测试，启动时logo亮起 7. 组装外壳，注意屏幕支架套入铝壳后先卡紧顶面的卡扣，再卡紧底面 ![](../../../assets/NanoKVM/pro/lcd_fix/lcd_fix_03.jpg) ![](../../../assets/NanoKVM/pro/lcd_fix/lcd_fix_02.jpg) 8. 拧上螺丝，注意靠近屏幕测使用两颗较短螺丝，接口侧使用两颗较长螺丝；最后粘贴脚垫"},"/hardware/zh/kvm/NanoKVM_Pro/kvm_admin.html":{"title":"NanoKVM Admin","content":" title: NanoKVM Admin keywords: NanoKVM, Remote desktop, Lichee, PiKVM, ARM, tool update: date: 2025 11 20 version: v0.1 author: xwj content: Release docs ## 简介 NanoKVM Admin 是一款用于批量管理 NanoKVM 设备的工具。它旨在通过简洁的 Web 界面，帮助用户集中管理局域网内所有的 NanoKVM 设备。无论是拥有几台设备的家庭实验室用户，还是管理数十台设备的运维人员，NanoKVM Admin 都能让您轻松发现并一键访问您的 KVM 设备。 主要功能： 自动发现： 基于 mDNS 协议，一键扫描局域网内的 NanoKVM 设备。 手动添加： 支持手动添加特定 IP 地址的设备，适应复杂网络环境。 集中管理： 在统一的网页视图中查看所有设备。 快捷访问： 点击即可跳转至单台 NanoKVM 的访问页面。 ## 安装 在\"设置 账户\"中找到 NanoKVM Admin，点击\"安装\"并等待安装完成即可。 ![install](./../../../assets/NanoKVM/pro/kvmadmin/zh/install.jpg) 安装完成之后，可点击【访问】按钮打开页面。或在浏览器地址栏输入访问地址\"NanoKVM Pro的IP:8999\"（例如：`https://192.168.3.102:8999`）。 ![visit](./../../../assets/NanoKVM/pro/kvmadmin/zh/visit.jpg) ## 设备添加 NanoKVM Admin 提供了两种添加设备的方式，您可以根据实际情况选择。 ### 方式一：mDNS 自动扫描 适用于设备位于同一网段，且路由器支持 mDNS 广播的环境。 1. 确保 NanoKVM 设备均已开启 mDNS 发现功能。 2. 点击【发现设备】按钮。 3. 系统将自动搜索网络中在线的 NanoKVM 设备。 4. 搜索完成后，列表将显示发现的设备信息。 ![scan](./../../../assets/NanoKVM/pro/kvmadmin/zh/scan.jpg) ### 方式二：手动添加 适用于跨网段访问，或 mDNS 无法发现设备的情况。 1. 点击【添加设备】按钮。 2. 在弹出的对话框中填写设备信息。 3. 点击【确认】保存。 ![manual](./../../../assets/NanoKVM/pro/kvmadmin/zh/manual_add.jpg) ## 设备管理与访问 ### 设备仪表盘 添加完成后，所有设备将以列表形式展示在主页仪表盘上。您可以看到： IP 地址：设备的 IP 地址，该字段是唯一的并且不可编辑。 mDNS 地址：设备的 mDNS 地址。 在线状态：设备是否在线，服务会周期性地扫描局域网内的设备状态并更新。 其他信息：如 MAC 地址、来源等信息。 操作按钮：访问、编辑和删除按钮。 ![devices](./../../../assets/NanoKVM/pro/kvmadmin/zh/devices.jpg) ### 访问设备 需要控制某台设备时： 点击设备 IP 即可通过 IP 地址访问该设备。 点击设备 mDNS 即可通过 mDNS 地址访问该设备。 点击操作中的“访问”图标即可通过 IP 地址访问设备。 ### 编辑与删除 修改信息：点击操作中的“编辑”图标，即可修改设备 mDNS 和备注等信息。 删除设备：点击操作中的“删除”图标，即可将设备从管理列表中移除。 ## 用户管理 点击左侧的【用户列表】即可进入用户管理界面。在这里可以进行用户添加、编辑和删除操作。 ![users](./../../../assets/NanoKVM/pro/kvmadmin/zh/users.jpg) ## 服务管理 服务通过 systemctl 运行，可通过以下命令进行操作：`systemctl start/stop/restart kvmadmin.service`。 ### 服务信息 服务安装位置：`/kvmadmin` 服务配置文件：`/etc/kvmadmin/server.yaml` SQLite 数据库文件：`/etc/kvmadmin/kvm.db` ### 服务证书 修改配置文件 `/etc/kvmadmin/server.yaml` 中的 `cert.crt` 和 `cert.key` 参数，然后执行以下命令重启服务： ```bash systemctl restart kvmadmin.service ``` ### 卸载服务 在设置页面中点击【卸载】按钮即可卸载服务。该操作会删除所有安装文件和数据，请谨慎操作。 ![uninstall](./../../../assets/NanoKVM/pro/kvmadmin/zh/uninstall.jpg)"},"/hardware/zh/kvm/NanoKVM_Pro/atx_start.html":{"title":"ATX 上手指南","content":" title: ATX 上手指南 keywords: NanoKVM, Remote desktop, Lichee, PiKVM, ARM, tool, PCIe update: date: 2025 8 26 version: v0.1 author: BuGu content: Release docs ## 开箱 ### NanoKVM ATX 开箱清单 ![](./../../../assets/NanoKVM/pro/start/unbox1.png) ![](./../../../assets/NanoKVM/pro/start/unbox2.png) NanoKVM ATX包含： + NanoKVM ATX 主机配全高PCIe挡板+OLED *1； + HDMI 线缆 150cm *1； + HDMI 线缆 50cm *1； + USB TypeA to TypeC 100cm *2； + 4Pin 机箱内USB线 40cm *1； + ATX 9Pin 一分二开机线 30+30cm *1； + 小十字螺丝刀 *1； + 天线 *1（仅WiFi版）； ## 接口定义 ![](./../../../assets/NanoKVM/pro/start/ATX Interface.jpg) ## 接线 > ❗请在功能测试正常后再装入机箱，装入机箱时确保装入PCIe卡槽后两个按键可以正常按下并抬起，否则可能导致NanoKVM无法启动或功能异常 1. 连接电源，NanoKVM Pro 对电源要求略高，部分主板的USB接口无法提供充足的电流，为保证 NanoKVM Pro 正常工作，强烈建议外接5V1A及其以上的电源（实际运行功耗约3W）； ![](./../../../assets/NanoKVM/pro/start/01_Power.png) 2. 连接USB HID接口： + ATX版本：可以采用机箱内接线/外部C口接线两种方式 ![](./../../../assets/NanoKVM/pro/start/02_USB.png) > ❗❗❗首批用户（线缆和下图b有区别）若选择机箱内接线的方式，请查收邮件，并按照邮件的修改方式连接线缆，或者参考[此处](https://wiki.sipeed.com/nanokvmpro usb)修改线缆 ![](./../../../assets/NanoKVM/pro/start/cable.png) 3. 使用网线连接路由器/交换机和NanoKVM Pro，如果没有有线网络，可以跳过此步，开机后配置Wi Fi使用（需要购买带有WiFi的版本） ![](./../../../assets/NanoKVM/pro/start/05_ETH.png) 4. 连接HDMI IN，如果主板仅有一个视频接口且有外接屏幕的需求，请将HDMI OUT连接至你的显示屏； ![](./../../../assets/NanoKVM/pro/start/06_HDMI.png) > 注意 NanoKVM Pro 采集最大支持4K30FPS，内置的HDMI一分二会主动读取外接屏幕的分辨率和帧率，并向主机提供屏幕和采集端公共的模式列表， > 如果你连接了一个4K60FPS的显示屏，电脑会识别为一个最高支持4K30的屏幕（被采集端限制，可以关闭采集，让4K60直出显示器） > 如果你连接了一个1080P的显示屏，电脑会识别为一个最高1080P的屏幕（被环出显示器限制） 5. （非必须）连接ATX电源控制接口 ![](./../../../assets/NanoKVM/pro/start/07_ATX.png) ## 内网访问 ### 连接网络 1. 如果采用有线连接，上电后KVM将会获取一个由路由器DHCP分配的IP地址，可以跳过此步骤 2. WiFi连接 + ATX版本可以通过OLED实现配网，步骤如下 1. 连接NanoKVM ATX的AP：长按USR按钮，KVM会释放一个WiFi信号（AP），OLED上显示此IP的信息，可以扫描二维码快速连接 2. 登陆网页填写要连接的WiFi帐号密码：连接WiFi后OLED显示网页链接，可以手动输入网址或扫描二维码快速跳转到网页配网 3. 如果有需要也可以通过USB NCM网络连接 ### 访问页面 1. ATX版本：连接网络后OLED上显示本地IP地址（E IP是有线网络获取的IP；W IP是wifi网络获取的IP，默认自动切换显示）； 2. 同一内网环境下使用一台主机在浏览器（建议使用Chrome）上输入IP地址访问页面； ![](./../../../assets/NanoKVM/pro/start/SSL.png) > 出现此警告是正常现象，NanoKVM Pro开启了https来增强安全性，并使用自签名ssl证书 3. 初始默认帐号`admin`，密码`admin`可以登陆至系统内部，强烈建议您立即修改帐号密码； 4. 检查图像/键鼠/开关机按钮是否正常工作 ![](./../../../assets/NanoKVM/pro/start/nanokvm4K.png) ## 远程连接 1. NanoKVM Pro 默认安装了 Tailescale 应用，可以在网页设置中登陆你的 Tailscale 帐号。所有登陆 Tailscale 的设备会自动拉入同一虚拟的内网环境中，并给每一台设备分配`100.xxx.xxx.xxx`的IP，可以通过分配给 NanoKVM Pro 的 IP 远程访问并控制你的主机 2. 其他异地组网工具：NanoKVM Pro 基于Ubuntu，可以通过`apt`安装应用，如zerotier，请按照官网提示安装相关应用"},"/hardware/zh/kvm/NanoKVM_Pro/usb_connect.html":{"title":"USB 4Pin 如何修改","content":" title: USB 4Pin 如何修改 ## 方式一 按下图连接 ![](./../../../assets/NanoKVM/pro/usb/usb1.png) 注意：需要在下图指示的位置剪掉黑色5V线缆。避免线头触碰其他部件导致短路 ![](./../../../assets/NanoKVM/pro/usb/usb2.png) ## 方法二：需要调换部分线序 1. 使用镊子/牙签/小螺丝刀等工具，挑起1.27mm端子头的塑料片 ![](./../../../assets/NanoKVM/pro/usb/usb3.png) 2. 拔出线缆(按步骤1/2重复操作，4个线缆都要拔出) ![](./../../../assets/NanoKVM/pro/usb/usb4.png) 3. 按压这里 ![](./../../../assets/NanoKVM/pro/usb/usb5.png) 4. 使用镊子/牙签/小螺丝刀等工具，挑起2.54mm端子头的红色线缆的塑料片 ![](./../../../assets/NanoKVM/pro/usb/usb6.png) 5. 剪掉红色线两端，请一定要尽量把剪刀伸进热缩管剪，避免线头露出来 ![](./../../../assets/NanoKVM/pro/usb/usb7.png) ![](./../../../assets/NanoKVM/pro/usb/usb8.png) 6. 将1.27毫米的电线插入连接器，如下图所示 ![](./../../../assets/NanoKVM/pro/start/cable.png)"},"/hardware/zh/kvm/NanoKVM/introduction.html":{"title":"简介","content":" title: 简介 keywords: NanoKVM, Remote desktop, Lichee, PiKVM, RISCV, tool update: date: 2024 6 21 version: v0.1 author: BuGu content: Release docs date: 2024 8 14 version: v1.1 author: BuGu content: Update docs ## 简介 ![](./../../../assets/NanoKVM/introduce/NanoKVM_3.png) NanoKVM 是基于 LicheeRV Nano 的 IP KVM 产品，继承了 LicheeRV Nano 的极致体积 和 强大功能。 NanoKVM 包含一个 HDMI 输入接口，可以被电脑识别为显示器，捕捉电脑画面；一个 USB2.0 接口连接电脑主机，可被识别为键盘鼠标触摸板等HID设备，同时使用TF卡多余存储空间，挂载为一个U盘设备；全系标配一个百兆网口，用于视频和控制信号等的网络传输。另外Full版还带有ATX电源控制接口（USB C形态）方便远程控制和查看主机开关机状态；Full 版外壳下还带一个 OLED 显示屏，用于显示本机 IP 和 KVM 相关状态。 为满足用户不同需求，NanoKVM 提供两个版本： NanoKVM Lite 为基础版配置，适合 具有一定DIY能力的个人用户 和 有批量需求的企业用户。 NanoKVM Full 为完整版配置，带精致外壳和完整配件，内置开机即用的系统镜像卡，推荐个人用户购买。 ## 使用场景 ![](./../../../assets/NanoKVM/introduce/web_ui.gif) + 服务器管理：用于实时监控服务器，获取服务器运行状态，并对其加以控制； + 远程桌面、开关机：NanoKVM 摆脱主机必须联网和系统软件的限制，作为主机外置硬件，直接提供远程控制的功能； + 远程装机：NanoKVM模拟U盘设备，可挂载装机镜像安装系统，也可进入BIOS对电脑设置； + 远程串口（Full内测版未引出至接口）：NanoKVM引出两组串口，可配合IPMI使用，或连接其他开发板使用网页串口终端交互，此外用户可自行拓展更多配件 + 更多玩法功能将在后续开放（如直播推流机），敬请期待 ![](./../../../assets/NanoKVM/introduce/application.png) ## 参数 产品 NanoKVM (Lite) NanoKVM (Full) PiKVM V4 计算单元 LicheeRV Nano(RISCV) LicheeRV Nano(RISCV) CM4 (ARM) 分辨率 1080P @ 60fps 1080P @ 60fps 1080P @ 60fps 视频编码 MJPEG, H264(WIP) MJPEG, H264(WIP) MJPEG, H264 视频延迟 90～230ms 90～230ms 100～230ms UEFI/BIOS ✓ ✓ ✓ 模拟USB键鼠 ✓ ✓ ✓ 模拟USB存储 ✓ ✓ ✓ IPMI ✓ ✓ ✓ Wake on LAN ✓ ✓ ✓ Tailscale ✓ ✓ ✓ WebSSH ✓ ✓ ✓ 自定义脚本 ✓ ✓ ETH 100M/10M 100M/10M 1000M/100M/10M ATX电源控制 无，用户可自行连接 USB接口IO控制板 RJ45接口IO控制板 OLED显示 无，用户可自行扩展 128x64 0.96\" white 128x32 0.91\" white 串口终端 2路 2路 Micro SD卡 无，用户自备 有，开机即用 有 扩展配件 无 PoE WiFi/LTE 功耗 0.2A@5V 0.2A@5V Peak 2.6A@5V 电源输入 PC USB即可供电 PC USB即可供电 <br> 也支持额外辅助供电 需要DC 5V 3A供电 散热 静音无风扇 静音无风扇 需要风扇主动散热 尺寸 23x37x15mm <br> ～1/30 PiKVM V4 体积 40x36x36mm <br/> ～1/7 PiKVM V4 体积 120x68x44mm ## NanoKVM 软硬件资料 NanoKVM 基于 Sipeed [LicheeRV Nano](https://wiki.sipeed.com/hardware/zh/lichee/RV_Nano/1_intro.html) 核心板搭建，这部分硬件的规格书、原理图、尺寸图等均可在这里找到：[点击这里](http://cn.dl.sipeed.com/shareURL/LICHEE/LicheeRV_Nano) NanoKVM Lite 由 LicheeRV Nano E 和 HDMItoCSI 小板构成，NanoKVM FULL 在 NanoKVM Lite 基础上增加 NanoKVM A/B 板和外壳。HDMItoCSI板用于转换HDMI信号；NanoKVM A 包含 OLED、ATX控制输出（TypeC接口形式）、辅助供电（TypeC接口）以及ATX开关机、复位按键；NanoKVM B 一端连接A板，一端连接电脑ATX针脚，用于电脑的远程开关机。 NanoKVM Cube/PCIe 软件现已完全开源：[KVM应用开源位置](https://github.com/sipeed/NanoKVM)、 [镜像开源位置](https://github.com/sipeed/LicheeRV Nano Build/tree/NanoKVM) > NanoKVM 镜像在 LicheeRV Nano SDK 和 MaixCDK 基础上构建，可以兼容使用 LicheeRV Nano 的资料，反之 LicheeRV Nano 或其他 SG2002 产品无法使用KVM软件。如果您想在 NanoKVM 上构建 HDMI 输入相关应用，请与我们联系，以获得技术支持。 > NanoKVM Cube 硬件基于 LicheeRV Nano 搭建，为协调生产，贴片项目和 LicheeRV Nano 保持一致，在硬件上保留了显示屏、触摸、MIC和功放电路；为解决潜在的隐私问题，2.2.6应用/1.4.1镜像及以上版本将删除相关驱动。我们也将在未来的生产中剔除这些元件。 + [原理图](https://cn.dl.sipeed.com/shareURL/KVM/nanoKVM/HDK/02_Schematic) + [3D结构](https://cn.dl.sipeed.com/shareURL/KVM/nanoKVM/HDK/04_3D_file) + [NanoKVM 镜像下载](https://github.com/sipeed/NanoKVM/releases) ## 购买入口 [淘宝官方购买地址](https://item.taobao.com/item.htm?id 811206560480) [速卖通购买地址](https://www.aliexpress.com/item/1005007369816019.html) [预售页面](https://sipeed.com/nanokvm) ## 产品反馈 如果您在使用过程中有任何问题或建议，请通过以下渠道和我们反馈： + [Github issues](https://github.com/sipeed/NanoKVM) + [MaixHub 论坛](https://maixhub.com/discussion/nanokvm) + QQ 交流群: 703230713"},"/hardware/zh/kvm/NanoKVM/network/cloudflared.html":{"title":"使用 Cloudflare Tunnel（cloudflared）让 NanoKVM 安全远程访问","content":" title: 使用 Cloudflare Tunnel（cloudflared）让 NanoKVM 安全远程访问 keywords: NanoKVM, Remote desktop, Lichee, PiKVM, RISCV, tool update: date: 2025 11 16 version: v0.1 author: Johnnybyzhang content: Release docs Cloudflare Tunnel 能让 NanoKVM 通过 **仅出站连接** 安全地接入 Cloudflare，无需公网 IP、端口转发或开放入站防火墙规则。PiKVM 文档主要介绍 systemd 方案，而 NanoKVM 基于 BusyBox `init`，服务管理方式不同。 Cloudflare 未提供官方的 RISC‑V 架构 `cloudflared` 构建，因此在 NanoKVM 上的支持主要依赖社区贡献。 本指南参考了 PiKVM 社区文档，安全性细节不再重复展开。 > **适用对象**：使用 BusyBox/SysV `init` 的 NanoKVM 用户。\\ > **范围**：Token 模式隧道、RISC‑V 架构二进制、最简 `init.d` 服务脚本。 ## 前置准备 Cloudflare Zero Trust 账户，并创建 **远程托管 Tunnel**（Dashboard → Access → Tunnels → *Create Tunnel*），复制 **Tunnel Token**。 NanoKVM 终端访问权限。 RISC‑V 架构的 `cloudflared` 可执行文件（使用 Go 本地编译）。构建细节参考：[https://github.com/cloudflare/cloudflared/issues/621](https://github.com/cloudflare/cloudflared/issues/621) （可选）参考 PiKVM 的 Cloudflare Tunnel 文档：[https://docs.pikvm.org/cloudflared/](https://docs.pikvm.org/cloudflared/) > **安全提示**：Token 可以直接启动隧道，请妥善保管。 ## 获取 cloudflared 二进制文件 ### NanoKVM Pro（ARM 架构） 可直接从 Cloudflare/cloudflared 仓库下载，或使用PiKVM OS，并按照PiKVM的文档操作 ### NanoKVM（RISC‑V 架构） 可选择： 使用社区自动构建（源码公开透明）：[https://github.com/Johnnybyzhang/cloudflared riscv/releases](https://github.com/Johnnybyzhang/cloudflared riscv/releases) 按照官方仓库 Issue #621 的方法自行编译 ## 安装 cloudflared 建议通过 WebUI 挂载外部存储，将二进制文件放入系统可识别的 USB 设备中。 ```sh install m 0755 /data/cloudflared /usr/sbin/cloudflared /usr/sbin/cloudflared version ``` ## 最小化 Token 配置（推荐） 使用配置文件可避免 Token 暴露在进程列表里。 ```sh mkdir p /etc/cloudflared umask 077 cat >/etc/cloudflared/config.yml <<'YAML' no autoupdate: true token: YOUR_TUNNEL_TOKEN_HERE YAML chmod 600 /etc/cloudflared/config.yml ``` ### 前台一次性测试（便于排错） ```sh cloudflared tunnel config /etc/cloudflared/config.yml no autoupdate run ``` > **重要**：` config`、` logfile`、` no autoupdate` 等全局参数必须放在 **run 之前**。 ## BusyBox `init` 启动服务（非 systemd） 创建一个在网络初始化 **之后** 启动的最简 `init.d` 脚本。以下示例使用 `S45`，位于 `S40network` 之后。 ```sh cat >/etc/init.d/S45cloudflared <<'SH' #!/bin/sh PATH /usr/sbin:/usr/bin:/sbin:/bin DAEMON \"/usr/sbin/cloudflared\" CONF \"/etc/cloudflared/config.yml\" LOG \"/var/log/cloudflared.log\" PIDFILE \"/var/run/cloudflared.pid\" start() { [ x \"$DAEMON\" ] { echo \"cloudflared 未找到\"; exit 1; } [ f \"$CONF\" ] { echo \"配置文件缺失：$CONF\"; exit 1; } mkdir p /var/run printf \"启动 cloudflared: \" # cloudflared 会自行写入日志文件，这里只避免输出到控制台 \"$DAEMON\" tunnel config \"$CONF\" logfile \"$LOG\" no autoupdate run >/dev/null 2>&1 & echo $! >\"$PIDFILE\" echo \"OK\" } stop() { printf \"停止 cloudflared: \" if [ f \"$PIDFILE\" ] && kill 0 \"$(cat \"$PIDFILE\")\" 2>/dev/null; then kill \"$(cat \"$PIDFILE\")\" 2>/dev/null true sleep 2 kill 0 \"$(cat \"$PIDFILE\")\" 2>/dev/null && kill 9 \"$(cat \"$PIDFILE\")\" 2>/dev/null true rm f \"$PIDFILE\" echo \"OK\" else killall cloudflared 2>/dev/null && echo \"OK\" echo \"进程未运行\" fi } status() { if [ f \"$PIDFILE\" ] && kill 0 \"$(cat \"$PIDFILE\")\" 2>/dev/null; then echo \"cloudflared 正在运行（pid $(cat \"$PIDFILE\")）\" else echo \"cloudflared 已停止\"; exit 1 fi } case \"$1\" in start) start ;; stop) stop ;; restartreload) stop; start ;; status) status ;; *) echo \"用法: $0 {startstoprestartstatus}\"; exit 1 ;; esac exit 0 SH chmod +x /etc/init.d/S45cloudflared ``` ### 启动与验证 ```sh /etc/init.d/S45cloudflared start /etc/init.d/S45cloudflared status tail n 100 /var/log/cloudflared.log ``` > **为什么终端仍可能看到日志？**\\ > 如果你手动执行 `init.d` 脚本，子进程可能继承当前 TTY。示例中的 `>/dev/null 2>&1` 已能避免大部分输出；真正日志请查看 ` logfile` 指定的文件。 ## 网络与时间 仅需 **出站连接**：TCP/443（以及可选的 UDP/7844） 请确保系统时间准确（NTP），否则可能无法通过 TLS 验证 ## 排错提示（如自行编写 init.d 脚本） **“flag provided but not defined: config”** → ` config` 必须放在 `run` 前。 **无日志输出** → 检查 `/var/log/cloudflared.log` 是否存在并具备权限。 **无法正常停止** → 建议使用 ` pidfile`；如文件不存在则会执行 `killall` 回退方案。 **Token 安全** → 避免在命令行直接传入 ` token`。 ## 卸载 / 禁用 ```sh /etc/init.d/S45cloudflared stop chmod x /etc/init.d/S45cloudflared rm f /usr/sbin/cloudflared /etc/cloudflared/config.yml /var/log/cloudflared.log /var/run/cloudflared.pid ``` ## 参考资料 PiKVM Cloudflare Tunnel 文档：[https://docs.pikvm.org/cloudflared/](https://docs.pikvm.org/cloudflared/) cloudflared RISC‑V 构建讨论：[https://github.com/cloudflare/cloudflared/issues/621](https://github.com/cloudflare/cloudflared/issues/621)"},"/hardware/zh/kvm/NanoKVM/network/frp.html":{"title":"frp","content":" title: frp keywords: NanoKVM, Remote desktop, Lichee, PiKVM, RISCV, tool update: date: 2024 8 13 version: v0.1 author: xwj content: Release docs > 注意，直接在公网暴露服务十分危险！建议配置 HTTPS 后使用。 想要使用 frp，你需要自己编写配置文件，可以参考 [frp 文档](https://gofrp.org)。 这里给出一个示例，实现通过 frp [访问内网的 web 服务](https://gofrp.org/zh cn/docs/examples/vhost http/) ## 启动 frps 服务 首先你需要一台带有公网 IP 的服务器，然后在该服务上启动 frps 服务。 这里我们假设该服务器 IP 地址为 `20.190.1.1`。你可以将这个 IP 替换为你自己的公网 IP。 1. 下载 [frp](https://github.com/fatedier/frp/releases/download/v0.59.0/frp_0.59.0_linux_riscv64.tar.gzf) 并解压，解压完成后进入该文件夹： ```bash wget https://github.com/fatedier/frp/releases/download/v0.59.0/frp_0.59.0_linux_riscv64.tar.gz tar xzvf frp_0.59.0_linux_amd64.tar.gz cd frp_0.59.0_linux_amd64 ``` 2. 创建配置文件 `frps.yaml`： ```yaml bindPort: 7000 vhostHTTPPort: 8080 ``` 3. 运行 frps 服务： ```bash ./frps c frps.yaml ``` ## 启动 frpc 服务 1. 通过 SSH 登录到 NanoKVM； 2. 执行 `frpc v` 查看版本号，如果没有输出，则需要手动安装 frpc； 下载 [frp](https://github.com/fatedier/frp/releases/download/v0.59.0/frp_0.59.0_linux_riscv64.tar.gzf) 并解压； 将 `frpc` 文件移动到 `/usr/bin/` 目录 3. 创建配置文件 `/etc/kvm/frpc.yaml` ： ```yaml serverAddr: 20.190.1.1 # 你的公网 IP serverPort: 7000 proxies: name: nanokvm type: http localPort: 80 customDomains: 20.190.1.1 ``` 4. 启动 frpc 服务： ```bash frpc c /etc/kvm/frpc.yaml ``` frps 和 frpc 服务都启动后，在浏览器中输入 `20.190.1.1:8080`，就可以在公网中访问到 NanoKVM 了。 ## 配置域名 如果你想给 NanoKVM 配置一个域名，可以修改 `frpc.yaml` 文件： ```yaml serverAddr: 20.190.1.1 # 你的公网 IP serverPort: 7000 proxies: name: nanokvm type: http localPort: 80 customDomains: www.yourdomain.com # 你的域名 ``` 然后将域名 [`www.yourdomain.com`](http://www.yourdomain.com) 解析到 `20.190.1.1`。 使用浏览器打开 [`http://www.yourdomain.com:8080`](http://www.yourdomain.com:8080/) 即可访问到 `NanoKVM`。 ## 配置 HTTPS 可参考 frp 文档：[为本地 HTTP 服务启用 HTTPS](https://gofrp.org/zh cn/docs/examples/https2http/)。 1. 配置 `frps.yaml` 文件： ```yaml bindPort: 7000 vhostHTTPSPort: 443 ``` 2. 配置 `frpc.yaml` 文件 ```yaml serverAddr: 20.190.1.1 # 你的公网 IP serverPort: 7000 proxies: name: nanokvm type: https customDomains: yourdomain.com # 你的域名 plugin: type: https2http localAddr: 127.0.0.1:80 crtPath: ./server.crt # 证书路径 keyPath: ./server.key # 私钥路径 hostHeaderRewrite: 127.0.0.1 requestHeaders: set: x from where: frp ``` 3. 分别启动 frps 和 frpc 服务，然后在浏览器中访问 [`https://yourdomain.com`](https://yourdomain.com) 即可"},"/hardware/zh/kvm/NanoKVM/network/tailscale.html":{"title":"Tailscale","content":" title: Tailscale keywords: NanoKVM, Remote desktop, Lichee, PiKVM, RISCV, tool update: date: 2024 8 13 version: v0.1 author: xwj content: Release docs > **推荐将 NanoKVM 与 Tailscale 配合使用，来实现公网访问远程主机的目的。** *注意：v1.0.0 版本的镜像不支持 Tailscale。如果你的 NanoKVM 镜像版本是 v1.0.0，请先[更新镜像](https://wiki.sipeed.com/hardware/zh/kvm/NanoKVM/start/flashing.html)。* 目前 NanoKVM 已经内置了 Tailscale，只需要简单的操作即可开始使用。 有两种配置 Tailscale 的方式：在浏览器中配置和在终端中配置。 推荐在浏览器中进行配置。如果你需要更多的自定义功能，也可以在终端中进行配置。 ## 在浏览器中配置 1. 在浏览器中输入 NanoKVM 的 IP 并访问； 2. 点击设置 Tailscale： ![ipconfig](../../../../assets/NanoKVM/tailscale/setting.png) 3. 如果提示 Tailscale 未安装，请点击安装，并等待安装完成。如果显示已安装，则进行下一步： ![ipconfig](../../../../assets/NanoKVM/tailscale/install.png) 4. 点击登录，等待 Tailscale 启动并生成登录链接（该操作只需要执行一次，Tailscale 会开机自启）： ![ipconfig](../../../../assets/NanoKVM/tailscale/login.png) 5. 登录链接生成后，浏览器会自动打开该链接。如果未自动跳转，请手动访问生成的链接。然后登录 Tailscale 账号，并点击 `Connect` 将 NanoKVM 加入到你的账号。 ![ipconfig](../../../../assets/NanoKVM/tailscale/connect.png) 6. 现在可以在你的 Tailscale 账号下看到 NanoKVM 了。在公网环境中，运行 Tailscale，然后在浏览器中访问 `100.79.236.88 (替换为你的 Tailscale IP)`即可： ![ipconfig](../../../../assets/NanoKVM/tailscale/machines.png) ## 在终端中配置 1. 通过 SSH 登录到 NanoKVM； 2. 执行 `tailscale version` 检查 tailscale 是否已经安装。如果未安装，则手动进行安装： 下载 [Tailscale](https://pkgs.tailscale.com/stable/tailscale_latest_riscv64.tgz) 并解压； 将 `tailscale` 文件移动到 `/usr/bin/` 目录； 将 `tailscaled` 文件移动到 `/usr/sbin/` 目录。 3. 执行 `/etc/init.d/S98tailscaled restart` ，启动 tailscale 服务； 4. 执行 `tailscale login` ，等待登录链接生成，然后在浏览器中访问生成的链接； 5. 在浏览器中点击 `Connect` ，将 NanoKVM 加入到你的 Tailscale 账户； 6. 操作完成！现在就可以通过 Tailscale 访问 NanoKVM 了。"},"/hardware/zh/kvm/NanoKVM/network/static_ip.html":{"title":"静态 IP","content":" title: 静态 IP keywords: NanoKVM, Remote desktop, Lichee, PiKVM, RISCV, tool update: date: 2024 8 13 version: v0.1 author: xwj content: Release docs NanoKVM 默认通过 DHCP 获取 IP，这意味着 NanoKVM 的 IP 可能会发生变化。 如果你希望始终使用同一个 IP 来访问 NanoKVM，可以给 NanoKVM 设置一个静态 IP。 下面介绍两种方法设置静态IP： ## 通过路由器设置静态IP 路由器后台往往有设置设备静态IP的功能，如果您可以方便的进入路由器的管理页面，建议使用此方式。 在路由器管理后台可以找到带有`kvm`名字的设备，并直接设置IP。 ## 在NanoKVM中设置静态 IP 如果不方便进入路由器后台，也可以直接在NanoKVM中设置，方法如下 ### 设置静态IP 在 NanoKVM 中创建文件 `/boot/eth.nodhcp` ，然后按照以下规则进行编辑： 一行就是一个自定义 IP，格式为 `addr/netid gw[optional]` ； 可以分多行来预设多个静态 IP。 ```bash # 示例 192.168.0.101/24 192.168.0.1 # addr/netid gw 192.168.3.116/22 # addr/netid ``` 编辑并保存该文件后，执行 `/etc/init.d/S30eth restart` 命令使配置文件生效。 **注意**，如果所有预设的静态 IP 地址都被 arp 检测到已占用，则静态 IP 会设置失败。 此时会触发 DHCP 来获取 IP 地址。如果仍然获取失败，则会将 IP 强制设置成 `192.168.90.1/24`。 这是为了保证 NanoKVM 总有一个可用的 IP 地址，以便能通过网络来操作 NanoKVM。 如果 NanoKVM 没有分配到可用的 IP 地址，则需要手动修改 TF 卡中的文件，或者重新烧录镜像才能正常使用。 ### 取消静态IP设置 删除 `/boot/eth.nodhcp` 文件，即可取消静态 IP。NanoKVM 会重新通过 DHCP 来获取 IP。"},"/hardware/zh/kvm/NanoKVM/ipmi.html":{"title":"IPMI 操作文档","content":" title: IPMI 操作文档 keywords: IPMI, NanoKVM, Remote desktop, PiKVM, RISCV, tool > 💡 在开始操作前，请先将您的系统镜像更新至 [v1.4.2](https://github.com/sipeed/NanoKVM/releases/tag/v1.4.2) 或更高版本。 ## 项目概述 本项目提供了一个基于软件的 IPMI 模拟器。它允许用户通过标准的 IPMI 协议远程管理硬件设备的电源状态以及访问串口终端。 核心组件包括： **`ipmi_sim`**: 开源的 IPMI 模拟器主程序 (OpenIPMI 项目的一部分)。 **`ipmi sim.sh`**: 服务管理脚本，负责启动、停止和监控模拟器进程。 **`chassis_control.sh`**: 硬件抽象层脚本，通过 GPIO 直接控制物理硬件的电源和复位引脚。 **`lan.conf`**: IPMI 模拟器的配置文件，定义用户、网络接口和 SOL 串口参数。 ## 登录设备 在开始安装和配置之前，您需要先登录到 NanoKVM 的系统终端。支持以下两种方式： ### 方式一：网页终端 1. 在浏览器地址栏输入 NanoKVM 的 IP 地址，访问 Web 管理界面。 2. 在菜单栏中找到 **终端** 图标，并点击打开 **网页终端**。 ### 方式二：SSH 远程登录 如果您习惯使用命令行工具，可以通过 SSH 进行连接。 1. 打开您电脑上的终端。 2. 执行以下命令（请将 `<IP地址>` 替换为 NanoKVM 的实际 IP）： ```bash ssh root@<IP地址> ``` 3. 输入默认密码 `root` 完成登录。 ## 安装与部署 本服务默认安装在 `/etc/ipmi` 目录下。 ### 目录结构 确保您的系统包含以下文件结构： ```text /etc/ipmi/ ├── ipmi sim.sh # 服务控制脚本 ├── chassis_control.sh # 硬件控制脚本 ├── lan.conf # 配置文件 ├── sim.emu # 模拟器持久化数据 ``` ## 配置指南 ### 用户与密码 (`lan.conf`) 默认配置文件包含一个管理员账户。 **为了安全起见，建议在部署前修改默认密码。** 编辑 `/etc/ipmi/lan.conf` 文件末尾的部分： ```text # User 2: Admin user # 启用 用户名 密码 权限 会话数 认证方式 user 2 true \"admin\" \"admin\" admin 10 md5 ``` 修改 `\"admin\"` (第二个) 为您的自定义密码。 ### 串口重定向 (SOL) 如果需要通过 IPMI 查看设备串口输出，请在 `lan.conf` 中配置 `sol` 选项： ```text # 对应设备的物理串口，例如 /dev/ttyS1 sol \"/dev/ttyS1\" 115200 nortscts ``` ## 服务管理 使用 `ipmi sim.sh` 脚本来管理服务。 ### 常用命令 操作 命令 说明 : : : **启动服务** `/etc/ipmi/ipmi sim.sh start` 启动 IPMI 模拟器后台进程 **停止服务** `/etc/ipmi/ipmi sim.sh stop` 停止运行中的服务 **重启服务** `/etc/ipmi/ipmi sim.sh restart` 先停止再启动 **查看状态** `/etc/ipmi/ipmi sim.sh status` 检查服务是否运行及 PID **开机自启** `/etc/ipmi/ipmi sim.sh enable` 设置服务随系统启动自动运行 **取消自启** `/etc/ipmi/ipmi sim.sh disable` 取消开机自启 ### 示例 ```bash # 启用开机自启并立即启动服务 /etc/ipmi/ipmi sim.sh enable /etc/ipmi/ipmi sim.sh start ``` ## 客户端使用说明 (ipmitool) 您可以在任何支持 IPMI 的客户端上使用 `ipmitool` 进行远程管理。 **连接参数说明:** ` H`: 目标 IP 地址 (例如 NanoKVM 的 IP) ` U`: 用户名 (默认: admin) ` P`: 密码 (默认: admin) ` I`: 接口类型 (使用 `lanplus` 支持 IPMI 2.0) ` C`: 加密套件 (Cipher Suite)。**建议使用 ` C 3`** 以跳过漫长的协议协商过程。 ### 支持的命令列表 本项目目前仅支持以下核心 IPMI 命令： 类别 命令 (ipmitool) 说明 : : : **电源控制** `power status` 查看当前电源运行状态 (ON/OFF) `power on` 执行开机操作 `power off` 执行关机操作 (通常为强制断电，长按电源键) `power reset` 执行复位操作 (按下重启键) **串口 (SOL)** `sol activate` 启动远程串口会话 `sol deactivate` 终止远程串口会话 **管理** `mc info` 查看模拟器的 BMC 基本信息 ### 电源控制 ```bash # 查看电源状态 ipmitool H <IP> U admin P admin I lanplus power status # 开机 ipmitool H <IP> U admin P admin I lanplus power on # 关机 (直接断电) ipmitool H <IP> U admin P admin I lanplus power off # 重启 (复位) ipmitool H <IP> U admin P admin I lanplus power reset ``` ### 串口重定向 (SOL) 通过网络连接到设备的串口终端： ```bash # 激活 SOL 会话 ipmitool H <IP> U admin P admin I lanplus sol activate # 退出 SOL 会话 # 按键顺序: ~ + . (波浪号后跟点号) ``` 注意：如果 SOL 连接无法建立，请检查 `lan.conf` 中的串口设备路径是否正确，以及是否有其他程序占用了该串口。 ### 性能优化说明 默认情况下，`ipmitool` 会尝试与服务器协商加密协议，这可能导致每次执行命令前有数秒的卡顿。 **解决方法**：在命令中显式添加 ` C 3` 参数。 **优化后的常用命令示例：** ```bash # 1. 快速获取 BMC 信息 (推荐测试命令) ipmitool H <IP> U admin P admin I lanplus C 3 mc info # 2. 快速查看电源状态 ipmitool H <IP> U admin P admin I lanplus C 3 power status # 3. 快速激活串口 ipmitool H <IP> U admin P admin I lanplus C 3 sol activate ``` ## 故障排查 1. **服务无法启动** 检查端口 623 (UDP) 是否被占用：`netstat ln grep 623` 检查日志输出。尝试手动前台运行命令看报错信息。 2. **ipmitool 连接超时** 检查防火墙设置，确保 UDP 623 端口开放。 确认 `ipmi_sim` 进程正在运行 (`ps aux grep ipmi_sim`)."},"/hardware/zh/lichee/K1/lpi3a/8_credits.html":{"title":"致谢","content":" title: 致谢 keywords: Linux, Lichee, K1, SBC, RISCV, credits update: date: 2024 07 30 version: v1.0 author: zepan content: Release docs 本章节专门向 LicheePi 3A 作出贡献的个人和团体致谢！ 感谢你们的贡献让 RISC V 发展得更快更好！ （本文按个人意愿以真名或者网名进行致谢） ## 进迭 感谢进迭官方的支持！ ## PLCT Wu Wei：感谢吴老板大力支持！老板大气！ [Icenowy Zheng](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/log/?qt author&q Icenowy+Zheng)：冰激凌，YYDS，贡献了3A的AMD GPU支持！ 高涵：revyos之父！ ## Fedora 感谢 傅炜 红帽大使的大力支持！ ## Deepin 感谢 Yukari ！ ## openKylin 感谢 Bits ！ ## 开源社区 [Jisheng Zhang](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/log/?qt author&q Jisheng+Zhang): K1 主线化支持"},"/hardware/zh/lichee/K1/lpi3a/4_peripheral.html":{"title":"外设使用","content":" title: 外设使用 keywords: Linux, Lichee, K1, SBC, RISCV, Peripheral update: date: 2024 07 30 version: v1.0 author: zepan content: Release docs ## SoC 相关 ### CPU 运行频率 `sudo cat /sys/devices/system/cpu/cpu*/cpufreq/cpuinfo_cur_freq ` 单位为 KHz 注意系统自带温控策略，当系统过于空闲或者温度过高时，都会降频。请保持良好散热，使得 CPU 在 60 度以下，获得最佳性能。 ### 芯片温度 `cat /sys/class/thermal/thermal_zone0/temp` 单位为0.001摄氏度 ## UART ### 系统串口 LicheePi 3A 的系统串口是 UART0,在侧边插针中有引出。 你可以使用 USB 转串口模块连接该串口，即 `U0 RX` 和 `U0 TX`，注意交叉连接，以及 GND 连接。 ![ttl_link](./assets/peripheral/ttl_link.png) 连接完成后，即可使用串口工具进行通信，Windows 下推荐 `XShell`，`mobaterm`，Linux下推荐 `minicom` 设置串口波特率为 `115200`，即可在串口终端下登录并进行指令操作： > 注：刚连接后可以敲几个回车查看是否有反应，如果没有反应则检查接线或者串口配置 ![ttl_login](./assets/peripheral/ttl_login.png) ### 一般串口 LicheePi 4A的侧边插针中还引出了 UART1, 同样可以操作。 默认镜像中仅使能了 UART1, 其它串口可能需要重新配置设备树操作。 #### 查看串口设备 ```bash ls /dev/ttyS* ``` #### 查看串口的波特率等信息 ```bash stty F /dev/ttyS1 a ``` #### 设置串口波特率、数据模式 ```bash stty F /dev/ttyS1 ispeed 115200 ospeed 115200 cs8 ``` #### 查看串口数据 ```bash cat /dev/ttyS1 ``` #### 发送串口数据 ```bash echo \"12345\" > /dev/ttyS1 ``` #### 其它方法 也可以使用`minicom`，或者pyserial库进行串口操作，请用户自行查找相关资料使用。 ## I2C LicheePi 3A 上有多个 I2C 设备（I2C0/2/5/6），其中 I2C2 连接了codec芯片；I2C5连接IO扩展芯片，也连接到了插针；I2C6连接触摸屏和IO扩展芯片。 这里我们使用 i2c tools 来进行 i2c 验证操作，默认镜像未安装i2c tools，请先使用apt安装 `apt install i2c tools` 列出所有I2C总线： ```bash root@k1:~# i2cdetect l i2c 0 i2c spacemit i2c adapter I2C adapter i2c 2 i2c spacemit i2c adapter I2C adapter i2c 5 i2c spacemit i2c adapter I2C adapter i2c 6 i2c spacemit i2c adapter I2C adapter i2c 8 i2c spacemit i2c adapter I2C adapter ``` 检测 I2C 总线上的设备，可见 PCA9557PW 的 I2C 地址为 0x18，与原理图相符： ```bash sipeed@lpi4a:~$ sudo /sbin/i2cdetect r y 5 0 1 2 3 4 5 6 7 8 9 a b c d e f 00: 10: UU 20: 30: 40: 50: 60: 70: ``` 此外还可以使用 `i2cdump` 来 dump 指定 i2c 地址的所有寄存器，用 `i2cget` 来读出指定 i2c 地址的指定寄存器值，用 `i2cset` 来写入指定 i2c 地址的指定寄存器值。 不过由于 IO 扩展芯片已经被内核使用，所以无法直接使用这些命令验证。用户可以自行在 I2C2 上外接外设来验证。 ## SPI LicheePi3A上预留了两路SPI，一路是背面空贴的SPI Flash焊盘，一路是插针上的SPI。 SPI 常用的 ioctl 命令： SPI_IOC_MESSAGE：用于发送和接收 SPI 消息，可以用于读写数据、控制设备等操作 SPI_IOC_WR_MODE：用于设置 SPI 设备的工作模式, 如 CPOL、CPHA 等 SPI_IOC_RD_MODE：用于读取 SPI 设备的工作模式 SPI_IOC_WR_LSB_FIRST：用于设置 SPI 设备的字节顺序，即最高位先传输还是最低位先传输 SPI_IOC_RD_LSB_FIRST：用于读取 SPI 设备的字节顺序 SPI_IOC_WR_BITS_PER_WORD：用于设置 SPI 设备的数据位宽 SPI_IOC_RD_BITS_PER_WORD：用于读取 SPI 设备的数据位宽 SPI_IOC_WR_MAX_SPEED_HZ：用于设置 SPI 设备的最大时钟频率 SPI_IOC_RD_MAX_SPEED_HZ：用于读取 SPI 设备的最大时钟频率 SPI_IOC_WR_MODE32：用于设置 SPI 设备的 32 位模式, 如 CPOL、CPHA 等 SPI_IOC_RD_MODE32：用于读取 SPI 设备的 32 位模式 以上是一些常用的 SPI 设备 ioctl 命令，可以用于配置和控制 SPI 设备的各种参数。 打开/关闭 SPI 设备： ```c int open(const char *pathname, int flags); int close(int fd); ``` 需要引用的头文件： ```c #include<fcntl.h> #include<unistd.h> ``` 示例代码： ```c #include <stdint.h> #include <unistd.h> // C 语言标准头文件，定义了 POSIX API 的一部分，如文件操作、进程管理等 #include <stdio.h> #include <stdlib.h> #include <string.h> #include <getopt.h> #include <fcntl.h> // C 语言头文件，定义了文件控制相关的宏和函数 #include <sys/ioctl.h> // C 语言头文件，定义了 ioctl 函数和相关宏 #include <linux/types.h> // Linux 内核头文件，定义了内核中使用的一些基本数据类型 #include <linux/spi/spidev.h> // Linux SPI 子系统头文件，定义了 SPI 设备驱动程序使用的数据结构和 ioctl 命令 #define DATA_NUM 2 // 自定义数据长度 #define CHECK(ret, str) if (ret < 0) {printf(\"%s\\r\\n\", str); return ret;} static uint8_t bits 8; static uint32_t speed 1000000; // 1M Hz static int mode 0; int main(int argc, char *argv[]) { int ret, fd; fd open(\"/dev/spidev2.0\", O_RDWR); CHECK(fd, \"can't open device\"); // 打开具体 spi 设备 mode SPI_MODE_0 SPI_CS_HIGH; ret ioctl(fd, SPI_IOC_WR_MODE32, &mode); //设置 SPI 模式 CHECK(ret, \"can't set spi mode\"); ret ioctl(fd, SPI_IOC_RD_MODE32, &mode); //获取 SPI 模式设置 CHECK(ret, \"can't get spi mode\"); ret ioctl(fd, SPI_IOC_WR_BITS_PER_WORD, &bits); //设置 SPI 的 bit/word CHECK(ret, \"can't set bits per word\"); ret ioctl(fd, SPI_IOC_RD_BITS_PER_WORD, &bits); //获取 SPI 的 bit/word 设置 CHECK(ret, \"can't get bits per word\"); ret ioctl(fd, SPI_IOC_WR_MAX_SPEED_HZ, &speed); //设置 SPI 的最大传输速度 CHECK(ret, \"can't set max speed hz\"); ret ioctl(fd, SPI_IOC_RD_MAX_SPEED_HZ, &speed); //获取 SPI 的最大传输速度设置 CHECK(ret, \"can't get max speed hz\"); printf(\"spi mode: %d\\n\", mode); printf(\"bits per word: %d\\n\", bits); printf(\"max speed: %d Hz (%d KHz)\\n\", speed, speed/1000); //数据传输 uint8_t tx[] {0x11, 0x22}; uint8_t rx[DATA_NUM] {0}; struct spi_ioc_transfer tr { .tx_buf (unsigned long)tx, //定义发送缓冲区指针 .rx_buf (unsigned long)rx, //定义接收缓冲区指针 .len DATA_NUM, .delay_usecs 0, .speed_hz speed, .bits_per_word bits }; ret ioctl(fd, SPI_IOC_MESSAGE(1), &tr); //执行 spidev.c 中 ioctl 的 default 进行数据传输 CHECK(ret, \"can't send spi message\"); printf(\"tx: %.2X %.2X\\r\\n\", tx[0], tx[1]); printf(\"rx: %.2X %.2X\\r\\n\", rx[0], rx[1]); close(fd); return ret; } ``` ## USB LPi3A 具备4个USB3.0口，插入USB device即可工作，这里不再赘述。 注意，如果你使用的是LPi4A的底板，由于底板差异会导致默认镜像下USB A口无法使用，首次使用需要先连接串口或者网络，进入设备终端，替换dtb 在/boot/spacemit/6.1.15/下，将 k1 x_lpi3a_4a.dtb 覆盖到为 k1 x_lpi3a.dtb，重启即可使用USB ## ETH LicheePi4A 具有双千兆网口，其中 Eth0 还具备 PoE 功能。 ### PoE LicheePi 4A的Ethernet 0接口具有PoE功能，可通过PoE实现供电。 PoE供电模块需要自行购买，使用5V电压，35.6mm长度的规格，可以通过搜索“5V PoE 插针”关键词搜索得到。 当目视方向正对“POE POWER”标识时，针脚左边4根针脚定义从左到右依次为：VA1、VA2、VB1、VB2，右边为：GND、5VIN。 ## Speaker Audio LicheePi 4A 上有两个模拟硅麦，使用 ES7210 CODEC，以及有一路板载的扬声器，和立体声耳机，使用 ES8156 CODEC。 > 注：板载扬声器与立体声耳机使用了互斥设计，插入耳机后，音频输出自动切换到耳机，板载扬声器失能。 使用 aplay 和 arecord 可以进行简易录放测试， 注意板载扬声器是右声道。 ```bash #!/bin/bash echo \"Play Test Audio\" aplay Dhw:1,0 disco48.wav ``` 你还可以使用alsa相关工具，如`alsamixer`，进行音量调整等操作。 注意目前只支持48KHz音频播放。录音功能正在开发中。 ## MIPI CSI LicheePi 3A 背面有两个摄像头接口，24Pin的是兼容LPi4A的2lane摄像头接口，22Pin的是兼容树莓派的22Pin 4lane摄像头接口。 ## MIPI DSI LicheePi 3A 具有 MIPI DSI0 接口，支持 1080P 视频输出，可以选配 10.1 寸 1280x800 的触摸屏。 连接方式如下图，两根 fpc 软排线均为下接（排线末端金属触点的那一面朝下），其中触摸屏的转接小板在连接时需要注意方向，确认ToLPi4A 的那一头连接LPi4A的触摸软排线，ToLcdTP 的那一头连接屏幕： 软排线金属触点面示意图： ![fpc](./assets/peripheral/fpc.jpg) 注意在连接前，先拨起接口上用于固定排线的黑色翻盖，确认接好后再拨下。 触摸屏软排线连接： ![tpconnector_on_touchscreen](./assets/peripheral/tpconnector_on_touchscreen.jpeg) ![touchconnector_on_board](./assets/peripheral/touchconnector_on_board.jpeg) MIPI 屏软排线连接： ![mipi_dsi_connect](./assets/peripheral/mipi_dsi_connect.jpeg) 确认连接无误后，使用支持 MIPI 屏幕的固件（k1 x_lpi3a_lcd.dtb），开机即可看到 MIPI 屏幕显示。 ## JTAG K1 的 JTAG接口与TF卡信号复用，可使用TF转JTAG小板连接。 ## GPU 使用命令以下命令可以实时查看 GPU 的状态： ```shell sudo watch cat /sys/kernel/debug/pvr/status ``` ## 其它 欢迎投稿～ 投稿接受后可得￥5～150（$1~20）优惠券！"},"/hardware/zh/lichee/K1/lpi3a/3_burn_image.html":{"title":"烧录镜像","content":" title: 烧录镜像 keywords: Linux, Lichee, K1, SBC, RISCV, image update: date: 2024 07 30 version: v1.0 author: zepan content: Release docs ## 获取镜像 ### Bianbu 镜像 ![bianbu](./assets/image/bianbu.png) LicheePi3A 已被进迭官方bianbu镜像支持 可以到[进迭官方镜像站](https://archive.spacemit.com/image/k1/version/bianbu/)下载，注意请下载v1.0.11以上的镜像 ### Fedora 镜像 https://images.fedoravforce.com/LicheePi%203A ### openKylin 镜像 https://www.openkylin.top/downloads/index cn.html ### Deepin 镜像 https://ci.deepin.com/repo/deepin/deepin ports/cdimage/20240815/riscv64/ ## 获取烧录工具 LicheePi3A可使用fastboot或者titian烧录工具烧录。 [Windows](https://cloud.spacemit.com/prod api/release/download/tools?token titantools_for_windows_X86_X64) [Linux](https://cloud.spacemit.com/prod api/release/download/tools?token titantools_for_linux_64BIT_APPIMAGE) 进迭官网下载最新工具： https://developer.spacemit.com/#/Documentation 烧录指南： https://bianbu.spacemit.com/installation_and_upgrade ## 烧录eMMC ### 使用 Titan Flasher 刷机 板卡在启动时检测到BOOT键按下即可进入烧录模式，就是说，先按住BOOT键，再插电或者短按RESET键，即可进入烧录模式。 ![flash1](./assets/image/flash1.png) ![flash2](./assets/image/flash2.png) ![flash3](./assets/image/flash3.png) ### 使用Fastboot 刷机 以 .zip 结尾的 zip 固件，解压后可以用 fastboot 刷机。 **前提** 1. 设备已插上 USB 数据线，连接到 PC； 2. 电脑安装好 fastboot 命令。 **刷机步骤** 1. 解压固件 2. 下载刷机脚本 [flash all.zip](https://archive.spacemit.com/image/k1/flash all.zip)，并解压到固件目录； 3. 进入 fastboot 模式 ```reboot fastboot``` 等待设备重启并进入 fastboot 模式： 1. 运行 flash all 脚本，等待刷机完成； 2. Linux PC 运行 flash all.sh，注意先赋予可执行权限；Windows PC 运行 flash all.bat； 3. 刷机完成，重新上电即可进入系统。 ## 烧录TF卡 以 img.zip 结尾的固件为 sdcard 固件，解压后可以用 dd 命令或者 balenaEtcher 写入 sdcard。注意此固件不适用于 eMMC。 **步骤** 1. 将固件写入 sdcard； 2. 将 sdcard 插入设备； 3. 设备上电开机即可启动。 ## LPi4A 兼容设置 注意，如果你使用的是LPi4A的底板，由于底板差异会导致默认镜像下USB A口无法使用，首次使用需要先连接串口或者网络，进入设备终端，替换dtb 在/boot/spacemit/6.1.15/下，将 k1 x_lpi3a_4a.dtb 覆盖到为 k1 x_lpi3a.dtb，重启即可使用USB ## LCD支持 默认镜像仅开启了HDMI输出，如果需要LCD支持，则需要替换dtb 在/boot/spacemit/6.1.15/下，将 k1 x_lpi3a_lcd.dtb 覆盖到为 k1 x_lpi3a.dtb，重启即可使用LCD 注意此dtb必须接LCD才能使用"},"/hardware/zh/lichee/K1/lpi3a/6_application.html":{"title":"典型应用","content":" title: 典型应用 keywords: Linux, Lichee, K1, SBC, RISCV, application update: date: 2024 07 30 version: v1.0 author: zepan content: Release docs "},"/hardware/zh/lichee/K1/lpi3a/7_faq.html":{"title":"常见问题","content":" title: 常见问题 keywords: Linux, Lichee, K1, SBC, RISCV, Debian, Desktop update: date: 2024 07 30 version: v1.0 author: zepan content: Release docs ### LPi4A 兼容性设置 注意，如果你使用的是LPi4A的底板，由于底板差异会导致默认镜像下USB A口无法使用，首次使用需要先连接串口或者网络，进入设备终端，替换dtb 在/boot/spacemit/6.1.15/下，将 k1 x_lpi3a_4a.dtb 覆盖到为 k1 x_lpi3a.dtb，重启即可使用USB"},"/hardware/zh/lichee/Nano/Nano.html":{"title":"Lichee Nano","content":"# Lichee Nano ## 概述 Lichee Nano是基于全志科技的F1C100s(ARM 926EJS内核)高性能soC芯片设计的迷你开发板。开发板设计小巧精致，将芯片的所有资源都引出，板载USB、Flash、TF卡、4OP LCD接口等，并把所有IO资源引出，方便开发者拓展使用，非常适合初学者学习linux或者商用于产品开发。 > 默认用户名称:root 用户密码:licheepi <img src \"./../assets/Nano/Nano_2.png\" width 400> <img src \"./../assets/Nano/Nano_3.png\" width 400> ## 参数 ### F1C100s参数 Lichee Nano开发板板载的F1C100s芯片功能很强大，芯片内置32MBDDR，拥有SDIO、SPI、UART、Speaker、Mic等接口，支持外挂 8~32MB SPI Nor Flash;在视频处理方面表现出现，支持720P视频输出，支持H.264、MJPEG等高清格式的解码。 ![](./../assets/Nano/F1C100s.png) 项目 参数 CPU •ARM9 CPU architecture<br>•16KByte D Cache<br>•32KByte I Cache Memory •SIP 32MB DDR1<br>•SD2.0,eMMC 4.41 Video •H.264 1280x720@30fps decoding<br>•MPEG1/2/4 1280x720@30fps decoding<br>•MJPEG 1280x720@30fps encoding<br>•JPEG encode size up to 8192x8192 Camera •8 bit CMOS sensor interface<br>•CCIR656 protocol for NTSC and PAL Audio •Integrated analog audio codec with two DAC channels and one ADC channel,maximum 192kHz DAC sample rate and 48kHz ADC sample rate<br>•One I2S/PCM interface Display •LCD RGB interface up to 1280x720@60fps<br>•TV CVBS output, support NTSC/PAL, with auto plug detecting Connectivity •USB OTG, SDIO,IR, 3 x TWI, 2 x SPI, 3 x UART ### 开发板参数 项目 参数 CPU 全志 F1C100s， ARM 926EJS , 主频 408MHz， 可超频至 600Mhz 内存及存储 集成 32MB DDR<br>板载 16MB NOR FLASH， 可从 FLASH 启动<br>板载 TF 卡座，可从 TF 启动 显示 通用 40P RGB LCD FPC 0.5mm 座子<br>可直接使用常见的 40P 4.3/5/7 寸屏幕（板载背光驱动）<br>支持常见的 272x480, 480x800, 1024x600 等分辨率<br>板载电阻式触摸屏芯片 视频处理能力 H.264 1280x720@30FPS 解码<br>MPEG1/2/4 1280x720@30FPS 解码<br>MJPEG 1280x720@30 FPS 解码<br>JPEG encode size up to 8192x8192 通信接口 SDIO，可搭配配套 SDIO WiFi+BT 模块<br>SPI x2<br>TWI x3<br>UART x3<br>OTG USB x1<br>TV out 其它接口 PWM x2<br>LRADC x1<br>Speakerx2 + Mic x1 ![](./../assets/Nano/Nano_pin.png) ### 软件参数 开发环境 参数 Linux 支持3.10 BSP Linux<br>支持4.19 主线 Linux 裸机 Xboot 裸机 RT Thread ## 使用教程 [Lichee Nano](./../../../../soft/Lichee/zh/Nano Doc Backup/index.html) ## 产品技术支持 Lichee Nano 开发板可以在多种场景实现客户不同方面的需要，在AIoT上已经广泛的使用，品质和性能在行业内已经有非常好的口碑，专业的技术团队为广大客户解决硬件设计和软件功能上的各种各样问题。专业技术支持和更详细资料请联系商务 <support@sipeed.com>。"},"/hardware/zh/lichee/Zero/Zero.html":{"title":"Lichee Zero","content":"# Lichee Zero ## Lichee Zero 概述 Lichee Zero是基于全志科技的V3s(ARM Cortex A7内核)高性能CPL芯片设计的迷你开发板。开发板设计小巧精致，将芯片的所有资源都引出,板载USB、Flash、TF卡、4OP LCD接口等，并把所有IO资源引出，方便开发者拓展使用，适合初学者学习linux或者商用于产品开发。 核心板： <html> <div class \"imbox\"> <img src \"./../assets/Zero/Zero_1.png\" width 240> <img src \"./../assets/Zero/Zero_6.png\" width 240> <style> .imbox{ display:flex; flex direction: row; } </style> </div> </html> 核心板+扩展板： <html> <div class \"imbox\"> <img src \"./../assets/Zero/Zero_3.png\" width 240> <img src \"./../assets/Zero/Zero_4.png\" width 240> <style> .imbox{ display:flex; flex direction: row; } </style> </div> </html> ## 参数 ### V3s参数 V3s框架 ![](./../assets/Zero/V3s.png) 项目 参数 CPU ARM Cortex™ A7 最高1.2GHz Memory Integrated 64MB DRAM Audio Codec • Integrated 92dB audio codec<br>• Supports two ADC channels and two DAC channels<br>• Supports one low noise analog microphone bias outputs<br>• Supports one microphone input and one stereo microphone outpu Video • Supports 1080p@40fps or 1080p@30fps+VGA@30fps H.264 video encoding,<br>• Supports H.264 1080p@30fps decoding, MJPEG 1080@30fps decoding Video Input/Output • Supports 8/10/12 bit parallel CSI and 4 lane MIPI CSI2<br>• Supports up to 5M CMOS sensor<br>• Supports RGB/i80/LVDS LCD up to 1024x768 resolution Connectivity • 3 x SD card controllers<br>• LRADC/SPI/TWI/UART/PWM<br>• USB, EMAC+PHY ISP • Integrated ISP up to 5M pixels<br>• Supports two channel outputs for display and encoding respectively<br>• Supports various input and output formats<br>• Supports AE/AF/AWB<br>• Supports saturation adjustment/ noise reduction/ defect pixel correction/distortion correction ### Lichee Zero核心板参数 项目 参数 CPU V3s 内存 64MB DDR2 存储 预留 SOP8 SPI Flash焊盘 <br>板载TF卡座 显示 通用40P RGB LCD FPC座<br>可直插常见的40P 4.3/5/7寸屏幕（板载背光驱动)，通过转接板可插50P 7/9寸屏<br>支持常见的272x480,480x800,1024x600等分辨率板载电阻式触摸屏芯片，支持电阻屏<br>板载RGB LED 通讯接口 SDIO x2，可搭配配套SDIO WiFi+BT模块<br>SPl x1<br>12C x2<br>UART x3<br>100M Ether x1(含EPHY)<br>OTG USB x1<br>MIPI CSI x1 其他接口 <br>PWM x2<br>LRADC x1<br>Speakerx2+ Mic x1 电气特性 Micro USB 5V供电<br>2.54mm插针3.3V~5V供电<br>1.27mm邮票孔供电 ![](./../assets/Zero/Zero_8.png) ![](./../assets/Zero/Zero_10.png) ### Lichee Zero 拓展板 项目 参数 CPU V3s 内存 64MB DDR2 存储 预留 SOP8 SPI Flash焊盘 <br>板载TF卡座 显示 通用40P RGB LCD FPC座<br>可直插常见的40P 4.3/5/7寸屏幕（板载背光驱动)，通过转接板可插50P 7/9寸屏<br>支持常见的272x480,480x800,1024x600等分辨率板载电阻式触摸屏芯片，支持电阻屏<br>板载RGB LED 通讯接口 SDIO x2，可搭配配套SDIO WiFi+BT模块<br>SPI x1<br>I2C x2<br>UART x3<br>100M Ether x1(含EPHY)<br>OTG USB x1<br>MIPI CSI x1 其他接口 <br>PWM x2<br>LRADC x1<br>Speakerx2+ Mic x1 板载外设 以太网接口<br>3.5mm耳机接口<br>驻极体麦克风<br>额外TF卡卡槽<br>4个按键<br>MIPI接口 电气特性 Micro USB 5V供电<br>2.54mm插针3.3V~5V供电<br>1.27mm邮票孔供电 ![](./../assets/Zero/Zero_9.png) ## 使用教程 [Lichee Zero](./../../../../soft/Lichee/zh/Zero Doc/Start/board_intro.html) ## 产品技术支持 Lichee Zero 开发板可以在多种场景实现客户不同方面的需要，在 AIoT 上已经广泛的使用，品质和性能在行业内已经有非常好的口碑，专业的技术团队为广大客户解决硬件设计和软件功能上的各种各样问题。专业技术支持和更详细资料请联系商务 <support@sipeed.com>。"},"/hardware/zh/lichee/ZeroPlus/ZeroPlus.html":{"title":"Lichee ZeroPlus","content":"# Lichee ZeroPlus ## 概述 Lichee Zero Plus是基于全志科技的S3 (ARM Cortex A7内核)的高性能CPU芯片设计的高集成度核心板。 使用双NGFF金手指设计，引出134pin引脚，方便开发者拓展使用。S3是V3s的升级版，1.2GHz主频，内置128MB ddr3内存，引脚相对V3s全很多。 支持MIPI摄像头，普通并口摄像头，RGB屏幕，内置ePHY. <img src \"./../assets/Zero Plus/Plus_1.jpg\" width 400> ## 参数 ### 芯片 S3芯片架构 ![](./../assets/Zero Plus/Plus_2.png) 项目 参数 CPU • ARM® Cortex™ A7 @1.2GHz GPU • Supports 1080p@60fps or 2 channel 1080p@30fps H.264 video encoding, supports 8M JPEG encoding <br>• Supports H.264 1080p@60fps decoding, MJPEG 1080@30fps decoding ISP • Integrated ISP up to 8M pixels<br>• Supports two channel outputs for display and encoding respectively<br>• Supports various input and output formats<br>• Supports AE/AF/AWB<br>• Supports saturation adjustment/ noise reduction/ defect pixel correction/distortion correction Video Input/Output • Supports 8/10/12 bit parallel CSI and 4 lane MIPI CSI2<br>• Supports BT1120 input<br>• Supports up to 8M CMOS sensor<br>• Supports RGB/i80/LVDS LCD up to 1024x768 resolution<br>• Supports Allwinner's next gen SmartColor display technology for better visual effects for images & videos Memory • SIP 16 bit DDR3, up to 1333Mbp Audio Codec • Integrated 92dB audio codec<br>• Supports two ADC channels and two DAC channels<br>• Supports 3 MIC in, a stereo Line in, a headphone output and a stereo line out output Security Engine • Supports AES/DES Connectivity • 3 x SD card controllers<br>• LRADC/SPI/TWI/UART/PWM<br>• USB, EMAC+PHY ### 核心板 项目 参数 CPU ARM Cortex A7 处理器(1.2Ghz)， VFPv4 浮点处理器 内存 芯片内置 128Mbyte DDR3 内存 (时钟频率最高 672MHz) 存储 可选 SPI Nor Flash(8/16/32MB)，SD Nand(128/512MB)，eMMC(4/8GB)<br>Micro SD 卡 电源 5V 电源输入， 3 路 DCDC 稳压输出 (1.2,1.5,3.3) 复位 板载复位芯片 晶振 板载 24M 主晶振， 32.768KHz RTC 晶振 接口 NGFF M.2 B KEY x 2 共引出 67x2 134pin<br>板载 micro usb 接口和系统串口，可供下载固件及调试 系统支持 支持最新 Linux 5.2 mainline kernel, Linux 3.4 bsp kernel<br>支持 debian 发行版 ## 使用教程 [Lichee Zero](/soft/Lichee/zh/Zero Doc/Start/intro_cn.md) ## 产品技术支持 Lichee ZeroPlus 开发板可以在多种场景实现客户不同方面的需要，在 AIoT 上已经广泛的使用，品质和性能在行业内已经有非常好的口碑，专业的技术团队为广大客户解决硬件设计和软件功能上的各种各样问题。专业技术支持和更详细资料请联系商务 <support@sipeed.com>。"},"/hardware/zh/lichee/index.html":{"title":"Lichee Pi","content":" title: Lichee Pi > 编辑与2022年3月11日 Lichee 是 [Sipeed](https://www.sipeed.com/) 推出的开源产品，是为了能让用户获得优廉的linux设备，实战linux底层相关的内容的产品。 目前LicheePi相关核心板部分参数对比表格如下： 类别 Lichee RV Lichee Zero PlusLichee ZeroLichee nano : : : : : SOC Allwinner D1 Allwinner S3 Allwinner V3s Allwinner F1c100s CPU架构 玄铁 C906 Cortex™ A7 Cortex™ A7 ARM 926EJS 运行频率1GHz1.2GHz1.2GHz(max)600MHz(max) RAM 512MB DDR3 128Mbyte DDR3 64MB DRAM 32MB DDR FLASH可选SD nand可选SD Nand、<br>SPI Nor Flash<br>或者eMMC 预留<br>SOP8 SPI Flash<br>焊盘板载 16MB NOR FLASH TF连接器 有有有有 上述的款型都可以通过sd卡启动系统 其他参数过多，版面放不下，需要的话麻烦自行对比一下。 ## Lichee 核心版照片(Linux) ### Lichee Zero <div align \"center\"> <a href \"./Zero/Zero.html\" ><img src \"./assets/Zero/Zero_1.png\" width 400></a> </div> ### Lichee Nano <div align \"center\"> <a href \"./Nano/Nano.html\" ><img src \"./assets/Nano/Nano_2.png\" width 400></a> </div> ### Lichee Zero Plus <div align \"center\"> <a href \"./ZeroPlus/ZeroPlus.html\"><img src \"./assets/Zero Plus/Plus_1.jpg\" width 400></a> </div> ### Lichee RV <div align \"center\"> <a href \"./RV/RV.html\"><img src \"./assets/RV/D1 4.png\" width 400></a> </div>"},"/hardware/zh/lichee/RV_Nano/3_images.html":{"title":"LicheeRV Nano Image","content":" title: LicheeRV Nano Image keywords: riscv, licheerv,nano update: date: 2024 1 26 version: v0.1 author: 0x754C ## 镜像格式 镜像使用xz/lz4进行压缩，解压后使用rufs/win32diskimager/dd工具写入到SD卡 ## 基于官方SDK的镜像 [下载地址](https://github.com/sipeed/LicheeRV Nano Build/releases)"},"/hardware/zh/lichee/RV_Nano/1_intro.html":{"title":"LicheeRV Nano","content":" title: LicheeRV Nano keywords: riscv, licheerv,nano update: date: 2024 1 24 version: v0.1 author: BuGu content: Release docs date: 2024 1 26 version: v0.2 author: BuGu content: Update docs date: 2024 4 9 version: v1.0 author: BuGu content: Update docs ## 简介 LicheeRV Nano 是一款迷你尺寸的开发板（仅22.86*35.56mm），搭载算能SG2002处理器，大核1GHZ （RISC V/ARM可选）小核700MHZ RISC V，256MB DDR3内存，内置 1Tops NPU；板载MIPI CSI、MIPI DSI、SDIO、ETH、USB、SPI、UART、I2C等丰富的接口，可扩展多种多样的应用；直插/半孔设计，方便量产贴片。 ![](./../assets/RV_Nano/intro/RV_Nano_1.jpg) ## 参数 项目 参数 CPU 算能 SG2002； <br>大核：1GHz RISC V C906 / ARM A53 二选一； <br>小核：700MHz RISC V C906；<br>低功耗核：25～300M 8051 NPU 1TOPS INT8，支持 BF16 内存 内封 2Gbit (256MByte) DDR3 存储 TF卡 / SD NAND 二选一启动 （SD NAND 焊盘在 TF 卡槽下） 视频接口 视频输出：2 lane MIPI DSI 输出，标准 31pin 接口，支持 6pin 电容触摸屏 <br>视频输入： 4 lane MIPI CSI 输入，22Pin 接口，支持拆分双路 CSI 音频接口 音频输出： 板载PA功放，可在排针上直接连接1W以内的喇叭 <br>音频输入： 板载模拟硅麦，可直接收音 有线连接 E 后缀版本支持百兆 RJ45 连接器 无线连接 W 后缀版本支持 2.4G / 5.8G 双频 WiFi6 + BLE5.4 USB 1 x USB2.0 OTG Type C IO接口 2 x 14pin 2.54 插针接口，间距 800mil，可直插面包板 按键 1 x RST 按键 + 1 x BOOT 按键 指示灯 1 x 电源 LED，1 x 用户 LED 操作系统 Buildroot Linux / Debian 尺寸 22.86*35.56mm ![](./../assets/RV_Nano/intro/RV_Nano_3.jpg) ![](./../assets/RV_Nano/intro/RV_Nano_4.jpg) ## 版本对比 **配置** **基础系统** **麦克风/扬声器** **以太网** **WiFi6/BT5** : : : : : : : : : : **LicheeRV Nano B** Y Y N N **LicheeRV Nano E** Y Y Y N **LicheeRV Nano W** Y Y N Y **LicheeRV Nano WE** Y Y Y Y ## 硬件资料 规格书、原理图、尺寸图等均可在这里找到：[点击这里](http://cn.dl.sipeed.com/shareURL/LICHEE/LicheeRV_Nano) + [板卡规格书](http://cn.dl.sipeed.com/shareURL/LICHEE/LicheeRV_Nano/01_Specification) + [板卡原理图](http://cn.dl.sipeed.com/shareURL/LICHEE/LicheeRV_Nano/02_Schematic) + [板卡点位图](http://cn.dl.sipeed.com/shareURL/LICHEE/LicheeRV_Nano/03_Designator_drawing) + [板卡尺寸图](http://cn.dl.sipeed.com/shareURL/LICHEE/LicheeRV_Nano/04_Mechanical_drawing) + [3D 模型文件](http://cn.dl.sipeed.com/shareURL/LICHEE/LicheeRV_Nano/06_3D_file) + [核心板封装](http://cn.dl.sipeed.com/shareURL/LICHEE/LicheeRV_Nano/05_PCB_Lib) + [板卡芯片资料](http://cn.dl.sipeed.com/shareURL/LICHEE/LicheeRV_Nano/07_Datasheet) ## 软件资料 + [LicheeRV Nano SDK](https://github.com/sipeed/LicheeRV Nano Build) ## 算能资料汇总 + [datasheet](https://github.com/sophgo/sophgo doc/releases) + [编译工具链下载地址](https://sophon file.sophon.cn/sophon prod s3/drive/23/03/07/16/host tools.tar.gz) + [SDK开发文档汇总](https://developer.sophgo.com/thread/471.html) + [HDK 开发文档汇总](https://developer.sophgo.com/thread/472.html) + [TPU SDK 开发资料汇总](https://developer.sophgo.com/thread/473.html) + [TDL SDK开发指南：（提供的常用 AI 模型算法，基于 TPU SDK 的应用封装）](https://doc.sophgo.com/cvitek develop docs/master/docs_latest_release/CV180x_CV181x/zh/01.software/TPU/TDL_SDK_Software_Development_Guide/build/TDLSDKSoftwareDevelopmentGuide_zh.pdf) + [TDL SDK 开发资料汇总](https://developer.sophgo.com/thread/556.html) ## 版本区分 LicheeRV Nano 先后生产两个版本的硬件，分别为内测版（PCB识别号：70405），量产版（70415）。两者外观和性能上存在些许差异 ![](./../assets/RV_Nano/intro/CMP 70405 70415.jpg) 1. 4*0201电阻修改为0402排阻，方便焊接； 2. WiFi模组更换为有屏蔽罩的版本； 3. 增大电源处电容规格，提升电源质量； 4. 移动两颗电容到TF卡下，支撑TF卡，方便用户拔插； 5. 用丝印明确标出电阻位置，方便用户修改； 6. 标明PCB版本号。 ## 注意事项 + 内测版硬件（70405）NPU 仅支持工作在0.5T下，1.0T下运行不保证板卡运行的稳定性 + 内测版硬件（70405）的WIFI尚未完善匹配，速率较低，敬请谅解 + 若购买摄像头配件或WE版本套餐，包装内随附螺丝、焊接铜柱和螺丝刀，为避免焊接时烫伤，请参照[摄像头、WE网口小板安装指南](https://wiki.sipeed.com/hardware/zh/lichee/RV_Nano/2_unbox.html#WE%E5%B0%8F%E6%9D%BF%E7%9A%84%E5%AE%89%E8%A3%85) + 若购买3寸、4寸、10.1寸屏幕配件，包装内随附屏幕转接板以及排线，请参照[屏幕安装指南](https://wiki.sipeed.com/hardware/zh/lichee/RV_Nano/2_unbox.html#%E5%B1%8F%E5%B9%95%E7%9A%84%E5%AE%89%E8%A3%85) + 内测版WiFi模块旁有两颗电容距离较近，生产时存在贴合的可能，因引脚网络相同，无需担心短路问题 ![](./../assets/RV_Nano/intro/RV_Nano_5.jpg)"},"/hardware/zh/lichee/RV_Nano/2_unbox.html":{"title":"LicheeRV Nano","content":" title: LicheeRV Nano keywords: riscv, licheerv,nano update: date: 2024 1 24 version: v0.1 author: BuGu content: Release docs date: 2024 4 9 version: v1.0 author: BuGu content: Update docs ## LicheeRV Nano 套餐介绍 LicheeRV Nano根据网络分为四个版本： + 标准版（B）无网络配件 + 网口版（E）板载100M网口 + WiFi版（W）板载WiFi6/BT5.2模块，BT5.2功能默认不启用，如需使用蓝牙功能，需要贴此处4颗0201电阻或使用2B铅笔填涂短接 ![](./../assets/RV_Nano/unbox/BLE_RES.jpg) 注：70415及以上版本可使用0402*4的排阻短接 ![](./../assets/RV_Nano/unbox/BLE_RES_2.jpg) + WiFi网口版（WE）板载WiFi6/BT5.2模块，同时提供一个网口小板，通过铜柱与排线连接到开发板上 同时我们提供以下六种配件： + 摄像头 ![](./../assets/RV_Nano/unbox/Camera.jpg) 该摄像头（3754）左右螺丝固定孔不短路，铜柱推荐固定到第5个焊盘上 ![](./../assets/RV_Nano/unbox/Camera 5.jpg) + 3寸屏幕 ![](./../assets/RV_Nano/unbox/3inch.jpg) 屏幕分辨率为480*845，带触摸；包装附赠屏幕触摸转接板和排线 + 5寸屏幕 ![](./../assets/RV_Nano/unbox/5inch.jpg) 屏幕分辨率为480*845，不带触摸；排线可直接连接到LicheeRV Nano 31Pin屏幕接口上 + 7寸屏幕 ![](./../assets/RV_Nano/unbox/7inch.jpg) 屏幕分辨率为800*1280，带触摸；排线可直接连接到LicheeRV Nano 31Pin屏幕接口和6Pin触摸接口上 + 10寸屏幕 ![](./../assets/RV_Nano/unbox/10inch.jpg) 屏幕分辨率为800*1280，带触摸；包装附赠触摸转接板和排线，屏幕排线可直接连接到LicheeRV Nano 31Pin屏幕接口 ## 安装指南 ### WE小板的安装 + 焊接排线 1. 按照下图方向焊接排线 ![](./../assets/RV_Nano/unbox/WE1.jpg) 2. 使用万用表检测通断 ![](./../assets/RV_Nano/unbox/WE2.jpg) + 固定铜柱 1. 为避免焊接铜柱时烫手，可以先将将铜柱拧到网口小板上 ![](./../assets/RV_Nano/unbox/WE3.jpg) 2. 将铜柱插入第5个焊盘，可以提前在焊盘上涂抹锡膏，提升焊接后铜柱的稳定性 ![](./../assets/RV_Nano/unbox/WE4.jpg) 3. 在底部使用电烙铁焊接 ![](./../assets/RV_Nano/unbox/WE5.jpg) + 组装 1. 将排线接入网口小板的FPC座子，并锁紧 ![](./../assets/RV_Nano/unbox/WE6.jpg) 2. 用螺丝将网口小板固定到铜柱上 ![](./../assets/RV_Nano/unbox/WE7.jpg) ### 摄像头的安装 + 固定铜柱 1. 与上面固定方法类似：先将铜柱和螺丝拧到摄像头模组上 ![](./../assets/RV_Nano/unbox/CAM1.jpg) 2. 将铜柱插入第5个焊盘，可以提前在焊盘上涂抹锡膏，提升焊接后铜柱的稳定性 ![](./../assets/RV_Nano/unbox/CAM2.jpg) 3. 在底部使用电烙铁焊接 ![](./../assets/RV_Nano/unbox/CAM3.jpg) + 组装 1. 根据下图连接摄像头排线 ![](./../assets/RV_Nano/unbox/CAM4.jpg) 2. 螺丝固定 ![](./../assets/RV_Nano/unbox/CAM5.jpg) ### 屏幕的安装 + 3寸屏幕安装 ![](./../assets/RV_Nano/unbox/3inch 1.jpg) ![](./../assets/RV_Nano/unbox/3inch 2.jpg) + 5寸屏幕安装 ![](./../assets/RV_Nano/unbox/5inch 1.jpg) + 7寸屏幕安装 ![](./../assets/RV_Nano/unbox/7inch 1.jpg) ## 大核作为A53模式启动 LicheeRV Nano的大核支持作为RISC V（C906）或ARM（A53）启动，在开发板背面，SG2002芯片旁边有丝印圈出的短接电阻，如下图所示，默认贴在C906（RISC V）一侧 ![](./../assets/RV_Nano/unbox/A53 1.jpg) 若大核需要作为ARM启动，需要将该电阻挪至另外一边，如下图 ![](./../assets/RV_Nano/unbox/A53 2.jpg) 需注意，目前A53模式下的SDK视频编解码存在问题，测试镜像点击[这里](https://github.com/sipeed/LicheeRV Nano Build/releases/tag/20240326)下载 ## 屏幕背光 LicheeRV Nano适配不同尺寸的屏幕，其中3寸、2.3寸为单串LED；5寸为双串LED；7寸、10.1寸为四串LED。 ![](./../assets/RV_Nano/unbox/BL_RES_1.png) 如上图背光电阻默认使用两个10R 0201并联，适配5寸屏幕； 接入2.8/3寸屏幕会明显发烫，内测版70405需拆掉BL电阻（下图位置），70415及后续版本可通过PWM自动适配小尺寸屏幕； 接入7/10.1寸屏幕时屏幕略暗，若需达到100%亮度，要将该电阻修改为3.3R ![](./../assets/RV_Nano/unbox/BL_RES.png) ## 电池应用 LicheeRV Nano 上不包含锂电池充电电路，如果用户需要嵌入电池，同时希望使用 RV Nano 自带的 USB TypeC 充电，则需要断开VBUS与VSYS的电阻（下图位置），VBUS接口作为PMU的外部电源输入，VSYS接口连接PMU的VSYS。如有疑问，请联系我们获得支持。 ![](./../assets/RV_Nano/unbox/5V_RES.png)"},"/hardware/zh/lichee/RV_Nano/8_mmf_development_guide.html":{"title":"多媒体框架（MMF）开发指南","content":" title: 多媒体框架（MMF）开发指南 keywords: riscv, licheerv, nano, mmf update: date: 2024 02 04 version: v0.1 author: lxowalle ## 简述 本文用来介绍使用算能SDK开发MMF的方法，为想要上手开发MMF却无从下手的开发者提供一个开发思路。 MMF全称是多媒体软件架构（Multimedia Framework），这个架构将视频输入输出、音频输入输出、图像信号处理、硬件编解码等功能提供了统一格式的API，用户可以通过调用封装好的API来快速实现多媒体相关的功能。 ## 搭建MMF的开发环境 请参考`LicheeRV Nano >系统开发 >cvi_mmf_sdk`中介绍的方法来搭建MMF的开发环境 或者参考下面的指令 ```shell # 下载依赖 sudo apt install pkg config build essential ninja build automake autoconf libtool wget curl git gcc libssl dev bc slib squashfs tools android sdk libsparse utils android sdk ext4 utils jq cmake python3 distutils tclsh scons parallel ssh client tree python3 dev python3 pip device tree compiler libssl dev ssh cpio squashfs tools fakeroot libncurses5 flex bison # 下载sdk和工具链 git clone https://github.com/sipeed/LicheeRV Nano Build.git wget https://sophon file.sophon.cn/sophon prod s3/drive/23/03/07/16/host tools.tar.gz tar xvf host tools.tar.gz # 用build_middleware命令编译所有示例 cd LicheeRV Nano Build ln s ../host tools ./ source build/cvisetup.sh defconfig sg2002_licheervnano_sd build_middleware ``` 上述指令介绍了如何安装MMF相关的编译环境，以及如何编译SDK提供的MMF示例。 注意：你可能在编译sample_cvg时会失败，如果不需要使用这个示例，则删掉`LicheeRV Nano Build/middleware/v2/sample/cvg`文件夹后再重试。如果你需要这个demo，则使用build_all编译后再尝试，build_all需要编译整个sdk，因此编译时间较长 ## 开发资料 请参考`LicheeRV Nano >板卡介绍`中来找到大部分资料 对于MMF应用可以着重看下面的资料 [MMF媒体软件开发指南](https://doc.sophgo.com/cvitek develop docs/master/docs_latest_release/CV180x_CV181x/zh/01.software/MPI/Media_Processing_Software_Development_Reference/build/html/index.html)或者[Media Processing Software Development Reference](https://doc.sophgo.com/cvitek develop docs/master/docs_latest_release/CV180x_CV181x/en/01.software/MPI/Media_Processing_Software_Development_Reference/build/html/index.html) [SDK LicheeRV Nano Build](https://github.com/sipeed/LicheeRV Nano Build) ## 通过网络连接开发板 通过网络连接开发板的目的是为了让我们编译的固件可以被上传到板子中。 请参考`LicheeRV Nano >外设使用`中的方法来获取开发板的IP地址，三种方法任意实现其中一种即可：`网线连接`、`WIFI连接`、`USB RNDIS连接` ## 编译和运行一个示例 MMF内部封装了直接操作硬件的方法，因此稍有疏忽就有导致系统崩溃的可能，开发MMF一定要注意保持耐心和注重细节。建议是通过示例来修改出自己的程序。 以sample_vio为例 ```shell # 确保已经搭建好了MMF的基本编译环境，并且已经使用build_middleware编译过一次 # 编译sample_vio cd middleware/v2/sample/vio make # 上传到开发板(账户root，密码cvitek) scp sample_vio root@xxx.xxx.xxx.xxx:/root\t# xxx.xxx.xxx.xxx是板子的IP地址 # 登入开发板 ssh root@xxx.xxx.xxx.xxx # 如果需要使用显示屏，则需要运行fb_load.sh以确保加载了驱动（只需要执行一次） # 新版镜像不用执行这个，已经内置到uboot /opt/fb_load.sh # 运行示例 cd ~ ./sample_vio ``` 上述指令介绍了如何编译某一个MMF示例，以及上传示例到开发板和运行这个示例。开发者可以根据自己的应用来修改示例，最后开发出自己想要实现的功能。 ## 出现无法解决的问题怎么办 1. 请保持耐心、并仔细的参阅开发资料，尝试找到是否存在遗漏的地方。比如输入参数是否正确、资源是否真正的释放等。 2. 在[maixhub](https://maixhub.com/discussion)或github上发布你的问题。请整理好你想要实现的功能、遇到的问题、尝试过的解决方案以及复现方法，顺便一提，很多时候在整理思路的过程中就能找到解决的方法了。"},"/hardware/zh/lichee/RV_Nano/4_burn_image.html":{"title":"LicheeRV Nano Burn Image","content":" title: LicheeRV Nano Burn Image keywords: riscv, licheerv,nano update: date: 2024 1 26 version: v0.1 author: 0x754C ## 镜像格式 镜像使用xz进行压缩，解压后使用rufs/win32diskimager/dd工具写入到SD卡 ## Linux ``` # 将sdX替换为SD卡的节点 dd if xxx.img of /dev/sdX conv sync ``` ## Windows 使用7zip工具进行解压: https://www.7 zip.org/download.html 使用 rufs/win32diskiamger 写入到SD卡 https://rufus.ie/ https://sourceforge.net/projects/win32diskimager/"},"/hardware/zh/lichee/RV_Nano/6_develop_mainline.html":{"title":"LicheeRV Nano Develop","content":" title: LicheeRV Nano Develop keywords: riscv, licheerv,nano update: date: 2024 1 26 version: v0.1 author: 0x754C ## 芯片手册 datasheet: https://github.com/sophgo/sophgo doc/releases ## 芯片启动流程 1. bootrom(bl1) 判断sd卡第一个FAT分区内是否拥有 fip.bin，如果有，则执行2，如果没有，则进入usb烧录模式(提供一个ACM串口从机设备),bl1会初始化uart0，波特率128000 2. 加载fip.bin(bl2)里面的代码到0x0C000000(TPU SRAM)，跳转到bl2,初始化clock,DRAM,执行3 3. 加载opensbi到DRAM，执行，然后加载uboot到DRAM，执行，执行4 4. uboot加载第一个分区内的boot.sd文件到DRAM，如果文件没有问题,跳转到5 5. 跳转到boot.sd内提供的代码(通常是Linux内核) 一个简单的裸机HelloWorld demo，用于演示: 1. 最小化可以启动的fip.bin(bl2): 2. 启动C906小核 3. 一些外设的裸机驱动(TODO) 4. 启动8051(TODO) https://github.com/0x754C/sg200x bare ## cvi_mmf_sdk 基于算能官方SDK修改，如果要使用mmf框架，则必须使用这个SDK 源码: https://github.com/sipeed/LicheeRV Nano Build 构建环境搭建可以参考repo内的github cicd文件: https://github.com/sipeed/LicheeRV Nano Build/blob/main/.github/workflows/licheervnano host linux amd64.yml 文档: 编译工具链下载地址：https://sophon file.sophon.cn/sophon prod s3/drive/23/03/07/16/host tools.tar.gz 软件SDK下载地址： https://github.com/sophgo/cvi_mmf_sdk SDK开发文档汇总：https://developer.sophgo.com/thread/471.html HDK 开发文档汇总： https://developer.sophgo.com/thread/472.html TPU SDK 开发资料汇总：https://developer.sophgo.com/thread/473.html TDL SDK开发指南：（提供的常用 AI 模型算法，基于 TPU SDK 的应用封装） https://doc.sophgo.com/cvitek develop docs/master/docs_latest_release/CV180x_CV181x/zh/01.software/TPU/TDL_SDK_Software_Development_Guide/build/TDLSDKSoftwareDevelopmentGuide_zh.pdf https://developer.sophgo.com/thread/556.html 如何交叉编译HelloWorld: https://github.com/sipeed/LicheeRV Nano Build/blob/v4.1.0/build/boards/cv181x/cv1812cp_licheerv_nano_sd/readme.md#compile program use vendors toolchain ## 主线buildroot TODO 基于主线buildroot，提供更干净的构建环境 ## openwrt TODO 基于主线openwrt，面向将板子当作便携无线AP的用户。 ## alpine linux TODO 基于主线alpine linux,面向在板子上跑distro的用户。 ## 引脚复用 这些寄存器的描述可以在芯片手册中找到 提供两种方法修改引脚复用 1. 进入系统后读写/dev/mem修改pinumux: ``` devmem REG_ADDDRESS 32 VALUE ``` 2. 在uboot里面修改pinmux: 例如，wifi的pinmux: https://github.com/sipeed/LicheeRV Nano Build/blob/926bbe94f4f00059ce0ff3857cc72a708aa85122/build/boards/cv181x/cv1812cp_licheerv_nano_sd/u boot/cvi_board_init.c#L52 ## 初始化MIPI TX 算能SDK提供两种方式: 1. 在middleware中的用户空间demo中添加屏幕初始化序列. 2. 在uboot中添加屏幕的初始化序列.（目前使用这种方式） ## 初始化MIPI RX 算能SDK的MIPI RX目前只能在用户空间初始化，需要修改middleware中的代码"},"/hardware/zh/lichee/RV_Nano/5_peripheral.html":{"title":"LicheeRV Nano Peri Use","content":" title: LicheeRV Nano Peri Use keywords: riscv, licheerv,nano update: date: 2024 1 26 version: v0.1 author: 0x754C date: 2024 4 15 version: v0.2 author: BuGu ## 连接开发板 ### UART0 将UART串口连接到板子的 `GND `、`A16（TX） `、`A17（RX） ` 然后使用终端软件连接串口，波特率115200 在USB接口上的SBU1/2上也引出了UART0，可使用USB TypeC转接板引出RX0、TX0 #### 禁止 UART0 输出日志 首先将用户空间的输出转到别的tty设备上: ``` #include <stdlib.h> #include <unistd.h> #include <sys/ioctl.h> #include <fcntl.h> int main(int argc, char *argv[]) { int fd; if (argc < 2) { fprintf(stderr, \"usage: %s /dev/ttyX\\n\", argv[0]); exit(EXIT_FAILURE); } fd open(argv[1], O_RDWR); if (fd < 0) { perror(\"open\"); exit(EXIT_FAILURE); } ioctl(fd, TIOCCONS); close(fd); exit(EXIT_SUCCESS); } ``` ``` riscv64 unknown linux gcc tioccons.c o tioccons ./tioccons /dev/tty2 # 将/dev/console转接到tty2上 ``` 然后设置内核日志等级: ``` echo 0 > /proc/sys/kernel/printk ``` 测试方法: ``` echo userspace > /dev/console echo kernel > /dev/kmsg ``` 另一种方法是在/boot/uEnv.txt中加入以下内容将console换到别的tty上: ``` consoledev /dev/ttyX ``` ### UART1 UART2 UART3 UART1和2的引脚默认用作连接UART蓝牙芯片: ``` mmio_write_32(0x03001070, 0x1); // GPIOA 28 UART1 TX mmio_write_32(0x03001074, 0x1); // GPIOA 29 UART1 RX mmio_write_32(0x03001068, 0x4); // GPIOA 18 UART1 CTS mmio_write_32(0x03001064, 0x4); // GPIOA 19 UART1 RTS ``` 如果只想使用UART1，则不需要更改PINMUX，只需要连接 GPIOA28 GPIOA29 如果想要同时使用UART1和UART2的功能，则需要写入寄存器来设置引脚的PINMUX: 在Linux用户空间可以使用devmem工具来写入寄存器 shell: ``` devmem 0x03001070 32 0x2 # GPIOA 28 UART2 TX devmem 0x03001074 32 0x2 # GPIOA 29 UART2 RX devmem 0x03001068 32 0x6 # GPIOA 18 UART1 RX devmem 0x03001064 32 0x6 # GPIOA 19 UART1 TX ``` UART3 的引脚被默认复用为SDIO: ``` mmio_write_32(0x030010D0, 0x0); // D3 mmio_write_32(0x030010D4, 0x0); // D2 mmio_write_32(0x030010D8, 0x0); // D1 mmio_write_32(0x030010DC, 0x0); // D0 mmio_write_32(0x030010E0, 0x0); // CMD mmio_write_32(0x030010E4, 0x0); // CLK ``` 如果想要使用UART3的功能，则需要写入寄存器来设置引脚的PINMUX: 在Linux用户空间可以使用devmem工具来写入寄存器 shell: ``` devmem 0x030010D0 32 0x5 # GPIOP 18 UART3 CTS devmem 0x030010D4 32 0x5 # GPIOP 19 UART3 TX devmem 0x030010D8 32 0x5 # GPIOP 20 UART3 RX devmem 0x030010DC 32 0x5 # GPIOP 21 UART3 RTS ``` Linux系统中的串口使用: C: ``` /* TODO */ ``` shell: ``` stty F /dev/ttyS1 115200 # 设置UART1波特率为115200 stty F /dev/ttyS1 raw # 设置tty为RAW模式 echo n UUU > /dev/ttyS1 # 发送 UUU(0x55 0x55 0x55) hexdump C /dev/ttyS1 # 以HEX格式显示收到的数据 ``` ### usb rndis 网口 将板子的usb typec口连接到电脑时会提供一个usb rndis网卡设备(linux gadget 提供) PC会使用DHCP自动获取地址 将自动获取的IPv4地址最后一位换成1即是板子的IPv4地址: ``` 10.44.55.66 PC机的IPv4地址 10.44.55.1 板子的IPv4地址 ``` 然后使用 ssh root@板子的IP地址进行连接: 用户名: root 密码: root Windows 系统下，需要进行一些配置。 打开设备管理器，找到下面的选项： ![usb_rndis_step1](../assets/RV_Nano/peripheral/usb_rndis_step1.png) 选择更新驱动程序： ![usb_rndis_step2](../assets/RV_Nano/peripheral/usb_rndis_step2.png) 选择浏览我的电脑以查找驱动程序： ![usb_rndis_step3](../assets/RV_Nano/peripheral/usb_rndis_step3.png) 选择让我从计算机上的可用驱动程序列表中选取： ![usb_rndis_step4](../assets/RV_Nano/peripheral/usb_rndis_step4.png) 在设备类型列表中选择网络适配器： ![usb_rndis_step5](../assets/RV_Nano/peripheral/usb_rndis_step5.png) 厂商选择 Microsoft，型号选择远程NDIS兼容设备： ![usb_rndis_step6](../assets/RV_Nano/peripheral/usb_rndis_step6.png) 若弹出这个警告请点击确定： ![usb_rndis_step7](../assets/RV_Nano/peripheral/usb_rndis_step7.png) 更新成功后显示如下： ![usb_rndis_step8](../assets/RV_Nano/peripheral/usb_rndis_step8.png) 然后可在设备管理器中的网络适配器列表下找到远程NDIS兼容设备项： ![usb_rndis_step9](../assets/RV_Nano/peripheral/usb_rndis_step9.png) ### 网线连接 将网线连接到板子，板子开机时会使用DHCP自动获取地址 板子镜像默认启用了MDNS服务 使用命令: ``` avahi browse art grep licheervnano ``` 列出广播域中域名带有的licheervrvnano的设备 然后使用: ``` ssh root@licheervnano XXXX.local ``` 连接板子 ## SOC相关 查看SOC温度： ```shell cat /sys/class/thermal/thermal_zone0/temp ``` 查看SOC时钟： ```shell cat /sys/kernel/debug/clk/clk_summary ``` ## USB ### device 在sd卡第一个分区创建 usb.dev 文件，并且删掉 usb.host 文件: ``` touch /boot/usb.dev rm /boot/host.host ``` 如果需要启用acm虚拟串口: ``` touch /boot/usb.GS0 ``` 如果需要启用rndis虚拟网卡: ``` touch /boot/usb.rndis0 ``` 然后重启设备 ### host 在sd卡第一个分区创建 usb.host 文件，并且删掉 usb.dev 文件: ``` touch /boot/usb.host rm /boot/usb.dev ``` 然后重启设备，给排针的VBUS或VSYS供5V电源，连接设备到TYPEC口，在系统内使用lsusb检查设备是否连接 ## PWM ### 引脚复用 PWM的引脚默认被用作UART，如果想用作PWM，则需要设置寄存器: ``` devmem 0x03001064 32 2 # GPIOA19 PWM7 devmem 0x03001068 32 2 # GPIOA18 PWM6 ``` ### SYSFS方式操纵PWM ```shell # 如何获取PWM节点的位置: # SG2002有4个pwm chip: # pwmchip0 pwmchip4 pwmchip8 pwmchip12 # 每个chip里面有4路pwm # 假设我们要使用pwm7: # 4 < 7 < 8 # PWM7在pwmchip4中 cd /sys/class/pwm/pwmchip4/ # 7 4 3 echo 3 > export cd pwm3 # 设置period echo 10000 > period # 设置duty_cycle echo 5000 > duty_cycle # 使能pwm输出 echo 1 > enable # 然后使用逻辑分析仪接到PWM引脚，就可以看到PWM7引脚输出方波 ``` ## Audio licheerv nano 支持录音和播放，使用标准 ALSA 工具可以进行录音、播放等操作。 ### 录音 首先设置麦克风音量，范围：0 24 ```shell amixer Dhw:0 cset name 'ADC Capture Volume' 24 ``` 如果没有找到amixer工具，也可以使用alsamixer(tui) 设置完成后开始录音： ```shell arecord Dhw:0,0 d 3 r 48000 f S16_LE t wav test.wav & > /dev/null & ``` ### 播放 ```shell ./aplay D hw:1,0 f S16_LE test.wav ``` ## GPIO ### LicheeRV Nano引脚图&Linux GPIO编号： ![](./../assets/RV_Nano/intro/RV_Nano_3.jpg) 系统内GPIO查看： ```shell cat /sys/kernel/debug/gpio ``` ### GPIO操作 首先用 'devmem 0x0300xxxx 32 0xxx' 修改引脚的PINMUX到GPIO 寄存器查找方式（以A22为例）：在[此处](https://github.com/sophgo/sophgo doc/releases/download/sg2000 trm v1.0 beta/sg2000_trm_cn.pdf)下载SG2002寄存器手册，手册中查找XGPIOA[22]，在表格中对应到GPIO，shell命令： 'devmem 0x03001050 32 0x03' ```shell # xxx 为上图中Linux GPIO NUM，如A22：num 502 num xxx echo ${num} > /sys/class/gpio/export # GPIO 写 echo out > /sys/class/gpio/gpio${num}/direction echo 1 > /sys/class/gpio/gpio${num}/value echo 0 > /sys/class/gpio/gpio${num}/value # GPIO 读 echo in > /sys/class/gpio/gpio${num}/direction cat /sys/class/gpio/gpio${num}/value ``` 带WiFI模块的版本 GPIO P18 ~ P23 连接 WiFi 模块的 SDIO 接口，用于 WiFi 通信；GPIO A26 用作 WiFi EN，请避免使用这些引脚，普通版和仅网口版用户可自由定义这些引脚功能 GPIO A18、A19、A28、A29 由一颗0402*4排阻连接至WiFi模块的蓝牙接口，默认空贴，WiFi版用户可自由定义这些引脚的功能，若想启用蓝牙，请参照[此处](https://wiki.sipeed.com/hardware/zh/lichee/RV_Nano/2_unbox.html#LicheeRV Nano %E5%A5%97%E9%A4%90%E4%BB%8B%E7%BB%8D)焊接对应电阻 ## UART ### UART1/2 UART1和2的引脚默认用作连接UART蓝牙芯片: ```c mmio_write_32(0x03001070, 0x1); // GPIOA 28 UART1 TX mmio_write_32(0x03001074, 0x1); // GPIOA 29 UART1 RX mmio_write_32(0x03001068, 0x4); // GPIOA 18 UART1 CTS mmio_write_32(0x03001064, 0x4); // GPIOA 19 UART1 RTS ``` 如果想要同时使用UART1和UART2的功能，则需要写入寄存器来设置引脚的PINMUX: 在Linux用户空间可以使用devmem工具来写入寄存器 shell: ```shell devmem 0x03001070 32 0x2 # GPIOA 28 UART2 TX devmem 0x03001074 32 0x2 # GPIOA 29 UART2 RX devmem 0x03001068 32 0x6 # GPIOA 18 UART1 RX devmem 0x03001064 32 0x6 # GPIOA 19 UART1 TX ``` ### UART3 UART3 的引脚被默认复用为SDIO: ```c mmio_write_32(0x030010D0, 0x0); // D3 mmio_write_32(0x030010D4, 0x0); // D2 mmio_write_32(0x030010D8, 0x0); // D1 mmio_write_32(0x030010DC, 0x0); // D0 mmio_write_32(0x030010E0, 0x0); // CMD mmio_write_32(0x030010E4, 0x0); // CLK ``` 如果想要使用UART3的功能，则需要写入寄存器来设置引脚的PINMUX: 在Linux用户空间可以使用devmem工具来写入寄存器 shell: ```shell devmem 0x030010D0 32 0x5 # GPIOP 18 UART3 CTS devmem 0x030010D4 32 0x5 # GPIOP 19 UART3 TX devmem 0x030010D8 32 0x5 # GPIOP 20 UART3 RX devmem 0x030010DC 32 0x5 # GPIOP 21 UART3 RTS ``` Linux系统中的串口使用: C: ``` /* TODO */ ``` shell: ```shell stty F /dev/ttyS1 115200 # 设置UART1波特率为115200 stty F /dev/ttyS1 raw # 设置tty为RAW模式 echo n UUU > /dev/ttyS1 # 发送 UUU(0x55 0x55 0x55) hexdump C /dev/ttyS1 # 以HEX格式显示收到的数据 ``` ## I2C 插针上引出了 I2C1 和 I2C3，将设备连接到其上即可。 使用前需要先正确设置 PINMUX： ```shell # I2C1 devmem 0x030010D0 32 0x2 # GPIOP 18 I2C1 SCL devmem 0x030010DC 32 0x2 # GPIOP 21 I2C1 SDA # I2C3 devmem 0x030010E0 32 0x2 # GPIOP 22 I2C3 SCL devmem 0x030010E4 32 0x2 # GPIOP 23 I2C3 SDA ``` 然后可以使用 i2c tools 进行 i2c 外设的操作，镜像中已经预装。 带WiFi模块的板卡（W、WE版）I2C1和I2C3硬件上连接到WiFi模块的SDIO，存在I2C无法读写的可能，PINMUX到I2C时WiFi模块不可用，可使用以下命令恢复WiFi连接： ```shell # PINMUX到SDIO devmem 0x030010D0 32 0x0 devmem 0x030010DC 32 0x0 devmem 0x030010E0 32 0x0 devmem 0x030010E4 32 0x0 # 重启WiFi服务 /etc/init.d/S30wifi stop /etc/init.d/S30wifi start ``` 摄像头和触摸屏接口共用I2C4，可使用 'i2cdetect ry 4' 扫描设备。需注意I2C4处于1.8V电源域，连接其他设备时请注意电平匹配。 ## SPI SPI2默认被复用作SDIO: ``` mmio_write_32(0x030010D0, 0x0); // D3 mmio_write_32(0x030010D4, 0x0); // D2 mmio_write_32(0x030010D8, 0x0); // D1 mmio_write_32(0x030010DC, 0x0); // D0 mmio_write_32(0x030010E0, 0x0); // CMD mmio_write_32(0x030010E4, 0x0); // CLK ``` 如果想要使用SPI2，则需要更改PINMUX: ``` devmem 0x030010D0 32 0x1 # GPIOP 18 SPI2 CS devmem 0x030010DC 32 0x1 # GPIOP 21 SPI2 MISO devmem 0x030010E0 32 0x1 # GPIOP 22 SPI2 MOSI devmem 0x030010E4 32 0x1 # GPIOP 22 SPI2 SCK ``` 简单测试SPI: 将SPI的MISO和MOSI连起来，然后执行: ``` spidev_test D /dev/spidevN.N p 1234 v # 将N.N换成对应的BUS ``` 如果TX和RX的数据一样，则引脚复用没有问题 ## ADC LicheeRV Nano插针上引出了一路12位ADC，在板内已做分压处理，如图： ![ADC](../assets/RV_Nano/peripheral/adc.png) 经测试，ADC输入电压在0 4.6V时，对应ADC值为0000 4095 首先选择 ADC channel，这里以 ADC1 为例： ```shell echo 1 > /sys/class/cvi saradc/cvi saradc0/device/cv_saradc ``` 读取 ADC1 的值： ```shell cat /sys/class/cvi saradc/cvi saradc0/device/cv_saradc ``` ## LCD 将屏幕的排线接到板子的MIPI接口，注意线序 创建或编辑sd卡第一个分区中的uEnv.txt文件，添加或修改panel字段: 注：镜像将第一个分区已经挂载到/boot目录下，可在终端中直接操作： ```shell cd /boot touch uEnv.txt vi uEnv.txt # 使用 'i' 进入编辑 # 使用 'Esc',':wq'保存并退出 ``` 7寸屏（型号以屏幕丝印为准）: ``` panel zct2133v1 # 新屏 panel mtd700920b ``` 5寸屏（型号以屏幕丝印为准）: ``` panel st7701_dxq5d0019_V0 # 早期测试5寸屏使用： # panel st7701_dxq5d0019b480854 ``` 3寸屏: ``` panel st7701_d300fpc9307a ``` 2.3寸屏: ``` panel st7701_hd228001c31 ``` 如果想用framebuffer功能，则在sd卡第一个分区创建一个文件名为fb的文件: ``` touch /boot/fb ``` 然后加载驱动: ``` /etc/init.d/S04fb start ``` 调整屏幕背光亮度: ``` echo 0 > /sys/class/pwm/pwmchip8/pwm2/enable echo 5000 > /sys/class/pwm/pwmchip8/pwm2/duty_cycle # 50% echo 1 > /sys/class/pwm/pwmchip8/pwm2/enable # some example: #echo 2000 > /sys/class/pwm/pwmchip8/pwm2/duty_cycle # 20% #echo 4000 > /sys/class/pwm/pwmchip8/pwm2/duty_cycle # 40% #echo 7000 > /sys/class/pwm/pwmchip8/pwm2/duty_cycle # 70% #echo 9000 > /sys/class/pwm/pwmchip8/pwm2/duty_cycle # 90% ``` 测试屏幕显示: 首先按照上面的方法打开fb，然后执行: ``` fbpattern # 显示SIPEED LOGO和测试用的图案 ``` ## 触摸屏 将触摸屏排线接到板子的触摸屏接口，注意线序 如果是gt911芯片，则需要在第一个分区创建一个gt9xx文件: ``` touch /boot/gt9xx ``` 然后加载驱动 ``` /etc/init.d/S05tp start ``` 然后执行: ``` echo 1 evtest ``` 点击触摸屏会在终端看到具体坐标 ## WIFI 将天线安装到WIFI模块的天线座子上 ### STA 在sd卡第一个分区创建wifi.sta文件启用sta模式: ``` touch /boot/wifi.sta rm /boot/wifi.ap /boot/wifi.mon ``` 然后将AP的SSID和密码写入文件: ``` echo ssid > /boot/wifi.ssid echo pass > /boot/wifi.pass ``` 重启Wifi服务 ``` /etc/init.d/S30wifi stop /etc/init.d/S30wifi start ``` ### AP 在sd卡第一个分区创建wifi.ap文件启用ap模式: ``` touch /boot/wifi.ap rm /boot/wifi.mon /boot/wifi.sta ``` 然后将要创建AP的SSID和密码写入文件: ``` echo ssid > /boot/wifi.ssid echo pass > /boot/wifi.pass ``` 重启Wifi服务 ``` /etc/init.d/S30wifi stop /etc/init.d/S30wifi start ``` ### MON 在sd卡第一个分区创建wifi.mon文件启用监听模式: ``` touch /boot/wifi.mon rm /boot/wifi.ap /boot/wifi.sta ``` 重启Wifi服务 ``` /etc/init.d/S30wifi stop /etc/init.d/S30wifi start ``` 使用tcpdump或airodump ng来捕获报文 ## 摄像头 将摄像头安装到摄像头座子，注意线序 然后执行: ``` /mnt/system/usr/bin/sample_vio 6 # 将摄像头画面实时显示到屏幕 # 输入255回车，退出程序 ``` ``` /mnt/system/usr/bin/sensor_test # 摄像头测试程序，可以用来dump单张yuv图像 ``` 如果使用70405(内测版)的板子: ``` touch /boot/alpha # 内测版 # rm /boot/alpha # 正式版 cd /mnt/data cp sensor_cfg.ini.alpha sensor_cfg.ini # 内测版 # cp sensor_cfg.ini.beta sensor_cfg.ini # 正式版 ``` ## 按键 使用命令查看按键事件: ``` echo 0 evtest ``` 然后按下USER按键，可以在终端看到对应的事件报告 ## JTAG 需要下载平头哥的调试服务器: https://xuantie.t head.cn/community/download?id 4209675990638596096 如何安装: https://occ oss prod.oss cn hangzhou.aliyuncs.com/resource//1682234034575/T Head+Debugger+Server+User+Guide+%28ZH CN%29.pdf 准备一个Slogic Combo 8，切换到CKLINK模式，并连接到JTAG引脚: 如何连接: https://wiki.sipeed.com/hardware/zh/logic_analyzer/combo8/use_cklink_function.html RV Nano的JTAG引脚: ``` PA19 JTAG_TMS PA18 JTAG_TCK PA29 JTAG_TDO PA28 JTAG_TDI ``` 然后将调试器连接到电脑，切换到CKLINK模式，给板子上电，按住RESET按钮，然后松开的时候启动DebugServer: 下面是启动成功的输出: ``` user@lu:~$ DebugServerConsole debug connect setclk 10K + + T Head Debugger Server (Build: Aug 3 2023, Linux) User Layer Version : 5.16.11 Target Layer version : 2.0 Copyright (C) 2023 T HEAD Semiconductor Co.,Ltd. + + CONNECT: Start to connect target (Enter target_open). CONNECT: Detect JTAG port for RISC V cores. CONNECT: \tConfigure cJTAG with 2 wires CONNECT: \tConfigure CDI type to 2 wires. CONNECT: \tRead IDCODE Gets 0x0, Invalid IDCODE. CONNECT: \tConfigure CDI type to 5 wires. CONNECT: \tRead IDCODE Gets 0x10000b6f, Manufid is 0x5b7. CONNECT: \tT HEAD with ManufactueID 0x5b7 is found, Debug Arch maybe RISCV DM. CONNECT: JTAG Port: JTAG 5 CONNECT: Check the DEBUG ARCH automatically. CONNECT: \tRead IDCODE Gets 0x10000b6f, Manufid is 0x5b7. CONNECT: \tT HEAD with ManufactueID 0x5b7 is found, Debug Arch maybe RISCV DM. CONNECT: Try to connect target and get arch_ops. T HEAD: CKLink_Lite_V2, App_ver unknown, Bit_ver null, Clock 10.010KHz, 5 wire, With DDC, Cache Flush On, SN CKLink_Lite_Vendor FactoryAIOT. CONNECT: + Attempt to connect Debug Transport Module. + CONNECT: Read IDCODE. CONNECT: \tRead DTM IDCODE get 0x10000b6f, it is T HEAD implementation. CONNECT: Check whether DMIACC is supported. CONNECT: \tDMIACC is supported. CONNECT: Read DTM Debug Control and Status. CONNECT: \tRead DTMCS get 0x40b1. CONNECT: \tDM is implemented depends on spec 0.13 as DTMCS.version is 1. CONNECT: \tGet abits 11. CONNECT: \tGet idle delay 4. CONNECT: + Attempt to connect Debug Module Spec 0.13. + CONNECT: Try to connect the 1st debug module with base 0x0. CONNECT: Set DM Base to 0x0 CONNECT: Reset DM first: CONNECT: \tWrite DMCONTROL with 0 to make DM into a known state. CONNECT: \tWrite hasel, hartselhi, hartsello, dmactive all fileds in DMCONTROL with 1. CONNECT: \tRead DMCONTROL get 0x4000001. CONNECT: Check bit domain in DMCONTROL. CONNECT: \tDMCONTROL.dmactive is 1, normal. CONNECT: \tDMCONTROL.hasel is supported. CONNECT: \tGet HARTSELLEN is 0. CONNECT: Check DMSTATUS. CONNECT: \tRead DMSTATUS get 0x4c0ca2, dm version is 2. CONNECT: Get NextDM. CONNECT: \tRead NEXTDM get 0x400. CONNECT: Set dm_base to 0x0 for the 1st dm. CONNECT: \tDM has been authenticated. CONNECT: \tHasresethaltreq is supported. CONNECT: \tConfstrptrvalid is not valid. CONNECT: \tImpebreak is supported. CONNECT: Check SBCS. CONNECT: \tRead SBCS get 0x0. CONNECT: \tSystem bus access is not supported. CONNECT: Check ABSTRACTCS. CONNECT: \tRead ABSTRACTCS get 0x2000002. CONNECT: \tGet progbufsize 2, datacount 2. CONNECT: Check ABSTRACTAUTO. CONNECT: \tRead ABSTRACTAUTO get 0x0. CONNECT: \tWrite ABSTRACTAUTO with 0xffffffff. CONNECT: \tRead ABSTRACTAUTO get 0xffff0fff. CONNECT: \tAutoexecprogbuf is supported. CONNECT: \tAutoexecdata is supported. CONNECT: \tWrite ABSTRACTAUTO with 0x0. CONNECT: Check CPU count. CONNECT: Select to CPU 0 in 1st dm. CONNECT: \tWrite DM CONTROL with 0x1. CONNECT: \tRead DM STATUS get 0x4c0ca2, CONNECT: CPU 0 in 1st dm exists. CONNECT: \tRead DM HARTINFO get 0x200000. CONNECT: \tGet nscrash 2, dataaccess 0, datasize 0, dataaddr 0x0. CONNECT: Select to CPU 1 in 1st dm. CONNECT: \tWrite DM CONTROL with 0x10001. CONNECT: Select to CPU 1 in 1st dm failed as not hartsel can't write with 1. CONNECT: Try to connect the 2nd debug module with base 0x400. CONNECT: Set DM Base to 0x400 CONNECT: Reset DM first: CONNECT: \tWrite DMCONTROL with 0 to make DM into a known state. CONNECT: \tWrite hasel, hartselhi, hartsello, dmactive all fileds in DMCONTROL with 1. CONNECT: \tRead DMCONTROL get 0x4000001. CONNECT: Check bit domain in DMCONTROL. CONNECT: \tDMCONTROL.dmactive is 1, normal. CONNECT: \tDMCONTROL.hasel is supported. CONNECT: \tGet HARTSELLEN is 0. CONNECT: Check DMSTATUS. CONNECT: \tRead DMSTATUS get 0x4030a2, dm version is 2. CONNECT: Get NextDM. CONNECT: \tRead NEXTDM get 0x0. CONNECT: Set dm_base to 0x400 for the 2nd dm. CONNECT: \tDM has been authenticated. CONNECT: \tHasresethaltreq is supported. CONNECT: \tConfstrptrvalid is not valid. CONNECT: \tImpebreak is supported. CONNECT: Check SBCS. CONNECT: \tRead SBCS get 0x0. CONNECT: \tSystem bus access is not supported. CONNECT: Check ABSTRACTCS. CONNECT: \tRead ABSTRACTCS get 0x2000002. CONNECT: \tGet progbufsize 2, datacount 2. CONNECT: Check ABSTRACTAUTO. CONNECT: \tRead ABSTRACTAUTO get 0x0. CONNECT: \tWrite ABSTRACTAUTO with 0xffffffff. CONNECT: \tRead ABSTRACTAUTO get 0xffff0fff. CONNECT: \tAutoexecprogbuf is supported. CONNECT: \tAutoexecdata is supported. CONNECT: \tWrite ABSTRACTAUTO with 0x0. CONNECT: Check CPU count. CONNECT: Select to CPU 0 in 2nd dm. CONNECT: \tWrite DM CONTROL with 0x1. CONNECT: \tRead DM STATUS get 0x4030a2, CONNECT: CPU 0 in 2nd dm exists. CONNECT: \tRead DM HARTINFO get 0x200000. CONNECT: \tGet nscrash 2, dataaccess 0, datasize 0, dataaddr 0x0. CONNECT: Select to CPU 1 in 2nd dm. CONNECT: \tWrite DM CONTROL with 0x10001. CONNECT: Select to CPU 1 in 2nd dm failed as not hartsel can't write with 1. CONNECT: + Check cores. + CONNECT: Get low target with spec 0.13. CONNECT: Check infomations of every RISCV core. CONNECT: Select to CPU 0. CONNECT: \tAs multi cores, set debug module base to 0x0. CONNECT: Make CPU 0 into debug mode. CONNECT: \tAs multi cores, set debug module base to 0x0. CONNECT: Check xlen for CPU 0. CONNECT: \tGet xlen 64. CONNECT: Read misa get: 0xb4112d. CONNECT: Enumerate triggers. CONNECT: \tGet hwbkpt 4, wp 4. CONNECT: Set endian little(Always). CONNECT: Read CPUID. CONNECT: Read Marchid get:0x910090d. CONNECT: Try to get vlen and elen: CONNECT: vlen 128, elen 3(). CONNECT: Analyzing CPUID gets info: RISCV CPU Info: \tWORD[0]: 0x0910090d \tWORD[1]: 0x12046000 \tWORD[2]: 0x260c0001 \tWORD[3]: 0x30030076 \tWORD[4]: 0x42180000 \tWORD[5]: 0x50000000 \tWORD[6]: 0x60000853 \tMISA : 0x8000000000b4112d Target Chip Info: \tCPU Type is C906FDV, Endian Little, Vlen 128, Version is R2S1P6. \tDCache size is 64K, 4 Way Set Associative, Line Size is 64Bytes, with no ECC. \tICache size is 32K, 2 Way Set Associative, Line Size is 64Bytes, with no ECC. \tTarget is 1 core. \tMMU has 256 JTLB items. \tPMP zone num is 8. \tHWBKPT number is 4, HWWP number is 4. \tMISA: (RV64IMAFDCVX, Imp M mode, S mode, U mode) CONNECT: Get SATP.mode: CONNECT: 8 CONNECT: Get target description info from xml file: /usr/bin/T HEAD_DebugServer/tdescriptions/riscv/riscv c906fdv vlen128 tdesc.xml. CONNECT: Select to CPU 1. CONNECT: \tAs multi cores, set debug module base to 0x400. CONNECT: Make CPU 1 into debug mode. CONNECT: \tAs multi cores, set debug module base to 0x400. ERROR: CPU_1: Fail to enter debug mode. WARNING: CPU_1: DMSTATUS is 0x4030a2, interpret as: \tNdmResetPending: 0, StickyUnavail: 0, ImpEbreak: 1, AllHaveReset: 0 \tAnyHaveReset: 0 AllResumeAck: 0, AnyResumeAck: 0, AllNonexitent: 0 \tAnyNonexistent: 0, AllUnavail: 1, AnyUnavail: 1, AllRunning: 0 \tAnyRunning: 0, AllHalted: 0, AnyHalted: 0, Authenticated: 1 \tAuthBusy: 0, Hasresethaltreq: 1, Confstrptrvalid: 0, Version: 2. CONNECT: Select to CPU to group cur. CONNECT: \tAs multi cores, set debug module base to 0x0. + Debug Arch is RVDM. + CONNECT: + Get riscv_arch ops, executing arch_ops_init. + CONNECT: Executing riscv_ops_init. CONNECT: Select to CPU 0. CONNECT: \tAs multi cores, set debug module base to 0x0. CONNECT: Invalid icache & dcache. CONNECT: Escape CPU 1 as it is not normal. CONNECT: Set current cpu to the first which is normal. CONNECT: \tSet current cpu to 0. CONNECT: \tAs multi cores, set debug module base to 0x0. + CPU 0 + RISCV CPU Info: \tWORD[0]: 0x0910090d \tWORD[1]: 0x12046000 \tWORD[2]: 0x260c0001 \tWORD[3]: 0x30030076 \tWORD[4]: 0x42180000 \tWORD[5]: 0x50000000 \tWORD[6]: 0x60000853 \tMISA : 0x8000000000b4112d Target Chip Info: \tCPU Type is C906FDV, Endian Little, Vlen 128, Version is R2S1P6. \tDCache size is 64K, 4 Way Set Associative, Line Size is 64Bytes, with no ECC. \tICache size is 32K, 2 Way Set Associative, Line Size is 64Bytes, with no ECC. \tTarget is 1 core. \tMMU has 256 JTLB items. \tPMP zone num is 8. \tHWBKPT number is 4, HWWP number is 4. \tMISA: (RV64IMAFDCVX, Imp M mode, S mode, U mode) CONNECT: Connect target end(Leave target_open). GDB connection command for CPUs(CPU0): \ttarget remote 127.0.0.1:1025 \ttarget remote 192.168.2.18:1025 \ttarget remote 172.17.0.1:1025 **************** DebuggerServer Commands List ************** help/h \tShow help informations. ************************************************************* DebuggerServer$ ```"},"/hardware/zh/lichee/RV_Nano/7_test_report.html":{"title":"","content":""},"/hardware/zh/lichee/th1520/lbook4a/lbook4a.html":{"title":"LicheePi Book 4A","content":" title: LicheePi Book 4A keywords: LicheeBook, TH1520, RISCV, SBC, Laptop update: date: 2024 06 17 version: v0.1 author: Zepan content: 初次编写文档 ## 简介 Lichee Book 4A (以下简称 Book ) 是矽速科技研发的高性能 RISC V 轻型笔电，旨在让RISC V开发者提前体验RISC V产品在实际生活中的开发应用。 Lichee Book 4A 使用主流14inch笔电模具，集成了高性能RISC V TH1520 SOM(8+32/16+128可选), 14寸1920x1200高清屏，88键圆帽静音键盘，以及USB A，USB C，2280 SSD卡槽，TF卡槽，miniHDMI，3.5mm耳机孔，等丰富接口，是具备开放性和使用性为一体 的RISCV笔记本～ Lichee Book 4A 的软件支持也做到了较为完善的程度，默认搭载Debian操作系统，支持 Chrome浏览器，VSCode IDE，KiCAD PCB绘图软件，Office软件，4K播放器，多种游戏模拟器，基本满足日常工作学习使用。 Lichee Book 4A 使用了模块化的设计方式，如果你之前购买了LicheePi4A，则可以复用SOM到Book上～ 得益于模块化SOM设计，Lichee Book 4A 还能在将来通过更换模块的形式，升级到LM3A或者LM5A模块！ > 注意:高性能RISCV消费电子在当前(2024年)还是属于较为早期的阶段，Lichee Book 4A主要面向 RISC V 开发者体验开发使用，至少要求熟练的Linux操作经验，普通消费者是无法直接上手使用的。 > 如果你是没有Linux经验的普通用户，请不要购买。 ![lbook4a](./assets/lbook/lbook.jpg) ## 技术规格 <table> <colgroup> <col class \"org left\" /> <col class \"org left\" /> </colgroup> <tr> <td class \"org left\">SOM</td> <td class \"org left\"> <a href \"https://wiki.sipeed.com/lm4a\">LM4A</a> </td> </tr> <tr> <td class \"org left\">CPU</td> <td class \"org left\"><strong>RISC V RV64GCV C910@1.85GHz * 4</strong> </td> </tr> <tr> <td class \"org left\">GPU</td> <td class \"org left\">IMG™ B 系列 BXM 4 64 </td> </tr> <tr> <td class \"org left\">NPU</td> <td class \"org left\">4TOPS@INT8 </td> </tr> <tr> <td class \"org left\">Memory</td> <td class \"org left\"> 8GB or 16GB LPDDR4X </td> </tr> <tr> <td class \"org left\">Storage</td> <td class \"org left\"> 32GB or 128GB eMMC, NGFF 2280 SATA SSD </td> </tr> <tr> <td class \"org left\">Display</td> <td class \"org left\"> 14 inch 1920 x 1200 LCD, miniHDMI </td> </tr> <tr> <td class \"org left\">Inoput</td> <td class \"org left\"> 88 Keyboard, touchpad </td> </tr> <tr> <td class \"org left\">Camera</td> <td class \"org left\"> 0.3MP Front Camera </td> </tr> <tr> <td class \"org left\">Audio</td> <td class \"org left\"> 3.5mm Headphone, MEMS MIC, StereoSpeaker </td> </tr> <tr> <td class \"org left\">Network</td> <td class \"org left\"> WiFi6 + BT5.4 </td> </tr> <tr> <td class \"org left\">Interface</td> <td class \"org left\"> USB3.0 Type A, USB3.0 Type C, USB2.0 Type A, MicroSD Slot </td> </tr> <tr> <td class \"org left\"> Battery </td> <td class \"org left\"> 4500 mAh@7.6V </td> </tr> <tr> <td class \"org left\">Case</td> <td class \"org left\"> Silver plastic Case</td> </tr> <tr> <td class \"org left\">Size & Weight</td> <td class \"org left\">314x217x17mm 1.3Kg</td> </tr> <tr> <td class \"org left\">System</td> <td class \"org left\">Debian </td> </tr> </table> ## 上手指南 ### 开箱 收到货后的包装箱： ![unbox1](./assets/lbook4a/unbox1.jpg) 打开包装箱，取出两个部分，上面是笔记本本体，下面是12V2.5A电源适配器，和MiniHDMI线。 ![unbox2](./assets/lbook4a/unbox2.jpg) 取出主机，顶面如图所示： ![unbox3](./assets/lbook4a/unbox3.jpg) 底面如图所示，可以看到一个SSD盖板，旋出螺丝即可安装SSD；以及底面中心是风扇吸风口，本机使用热管+静音风扇散热，保证核心凉爽温度。 ![unbox4](./assets/lbook4a/unbox4.jpg) 侧面之一如图所示，接口从左到右依次为：TF卡，3.5mm耳机孔，USB2.0接口，电脑锁。 ![unbox5](./assets/lbook4a/unbox5.jpg) 侧面之二如图所示，接口从左到右依次为：USB3.0口，12V DC口，miniHDMI口，USB C口（兼顾下载/Host/充电） ![unbox6](./assets/lbook4a/unbox6.jpg) （如果你购买的是准系统套餐，则需要先查看后面的“SOM安装指南”安装好LM4A后再进行下面操作。） 打开主机，长按右上角电源键3s开机（看到屏幕背光亮起 或者 左侧电源指示灯亮起 即可松开） ![unbox8](./assets/lbook4a/unbox8.jpg) 如果背光一直未亮起，可能是运输过程中电量耗尽，可以尝试插上电源适配器后长按电源开机。 开机背光亮起约15s后，屏幕左上角会开始闪烁光标（表示已经进入内核） 再经过约20s后，开始进入Debian桌面系统的登录界面。 输入帐号 sipeed，默认密码 licheepi，进入桌面系统后，你可以测试 触摸板，键盘，摄像头等 是否工作，如有发现不能工作的，可以与客服联系。 默认系统为Debian，预装了 Chrome，Office， 等应用软件，你可以一一体验。 你可以使用sudo apt instal xxx 来安装软件，默认用户名密码为 sipeed，licheepi 其它一般性软件使用可以参考LicheePi4A的相关文档章节。 ### SSD使用指南 Book支持M.2 2280 SATA 接口的SSD，可以拆卸掉后壳的SSD盖板后安装 ![ssd1](./assets/lbook4a/ssd1.jpg) 如果你不计划使用SSD，可以手工关闭USB转SSD芯片来降低功耗（约0.6Watt），提升续航： 进入/boot/dtbs/linux image 5.10.113 zzz sipeed 20240531+/thead/，找到对应使用的dtb进行修改，如8GB内存版本： sudo dtc I dtb O dts o tmp.dts th1520 lpi4a plastic.dtb 编辑以下部分，将 enable active high; 改成 enable active low; 即可 ``` \treg_sata_vcc_5v: regulator sata vcc 5v en { \t\tstatus \"okay\"; \t\tcompatible \"regulator fixed\"; \t\tregulator name \"regulator sata vcc 5v en\"; \t\tregulator min microvolt <5000000>; \t\tregulator max microvolt <5000000>; \t\tvin supply <&reg_sys_vcc_5v>; \t\tgpio <&pcal6408ahk_c 1 1>; \t\tenable active low; \t\tregulator always on; \t}; ``` sudo dtc I dts O dtb o th1520 lpi4a plastic.dtb tmp.dts 然后重启即可关闭sata电源。 ### SOM安装指南 如果你选购了准系统套餐，则需要安装SOM模块。 需要自备十字螺丝刀，拆卸开后盖（需要先撕开两个脚垫，脚垫下面各有一个螺丝），安装好SOM模块，在CPU/DDR上方安装硅脂，放置热管，重新安装回后盖。 ![unbox7](./assets/lbook4a/unbox7.jpg) ## 系统 Book的镜像与LConsole的镜像一同发布，仅uboot不同，建议使用8+32及以上配置的SOM。 github仓库在： https://github.com/0x754C/sipeed th1520 laptop extra/releases linux image *.deb 是sipeed提供的内核安装包，如果只想升级内核可以安装这个，安装前记得更新到对应版本的uboot，以及备份文件。 sipeed th1520 laptop extra *.deb 是sipeed提供的附加文件安装包，包括配置文件，测试工具，和EC固件。 u boot with spl *.bin 是uboot文件，请选择你电路板对应型号的uboot进行烧写，烧写前记得备份文件，如果烧写错误的uboot可能会导致无法开机。 bootroot *.ext.xz 是分区镜像，如果想整个重新烧录，使用这个。 百度网盘： 链接: https://pan.baidu.com/s/1jkJ4YR7EhMRZ11XmccKDtg 提取码: qj1r Mega网盘： https://mega.nz/folder/p9BCTbLb#sWSZvLw6nrBmqujQXfvWrg 常见应用展示： ![sys1](./assets/lbook4a/sys1.png) Book 系统架构如下，细节可参照原理图或设备树文件。 ![sys2](./assets/lbook4a/sys2.png) ## 资料下载 Lichee Book 4A 与 Lichee Console 4A 为相同主板，共享一份硬件资料： [Sipeed 下载站](https://dl.sipeed.com/shareURL/LICHEE/LicheeConsole4A) ## 其他链接 [淘宝](https://item.taobao.com/item.htm?id 807162533118) [Aliexpress](https://www.aliexpress.com/item/3256807018240741.html) QQ群: 559614960 [点我自动加群](http://qm.qq.com/cgi bin/qm/qr?k 5YkapIhdtWHp8AEfM5_bFFYQIX3CUQN6) Telegram: https://t.me/linux4rv 论坛：Maixhub.com/discussion 联系邮箱：support@sipeed.com"},"/hardware/zh/lichee/th1520/lbook4a/4_burn_image.html":{"title":"烧录镜像","content":" title: 烧录镜像 keywords: Linux, Lichee, TH1520, Console, RISCV, image update: date: 2024 06 18 version: v0.1 author: Zepan content: Release docs ## 镜像下载: https://github.com/0x754C/sipeed th1520 laptop extra/releases 百度网盘： 链接: https://pan.baidu.com/s/1jkJ4YR7EhMRZ11XmccKDtg 提取码: qj1r Mega网盘： https://mega.nz/folder/p9BCTbLb#sWSZvLw6nrBmqujQXfvWrg ## 全量镜像 ### 通过 typeC 口烧录 1. 拆掉SSD后盖 2. 找到BOOT按键和RST按键 ![boot_and_rst_key](./assets/burn_image/boot_and_rst_key.jpg) 3. 按着BOOT按键，然后按键盘上的电源按键开机 （或者开机状态下按复位键），然后将 Book 连接 typec 口到烧录镜像的 PC。 ![typec_connect](./assets/burn_image/typec_connect.jpg) 1. 在烧录镜像的 PC 上下载用于烧录的镜像: 5. 执行烧录指令: ``` fastboot flash ram u boot with spl plastic8g.bin #根据购买的内存型号选择 fastboot reboot fastboot flash uboot u boot with spl plastic8g.bin fastboot flash boot boot.ext4 fastboot flash root root.ext4 ``` 10. 按下 BOOT 旁边的 RST 按键重启 Book 笔记本。"},"/hardware/zh/lichee/th1520/lc4a/lc4a.html":{"title":"LicheePi Cluster 4A","content":" title: LicheePi Cluster 4A keywords: LicheePi, Sodimm, TH1520, RISCV, SBC, Cluster update: date: 2023 09 07 version: v0.1 author: 0x754C content: 初次编写文档 ## 简介 Lichee Cluster 4A (以下简称 LC4A ) 是矽速科技研发的高性能 RISC V 集群计算平台，可以用于构建多节点计算集群，而且还是学习 Kubernetes、自动化、边缘人工智能计算、本地迷你服务器，托管应用程序、容器等的优秀工具。单个 Lichee Cluster 4A 最多可装配 7 个 LM4A 核心板，每个 LM4A 核心板含有 4TOPS@int8 AI 算力的 NPU，单核心板最大支持 16GB LPDDR4X 内存和 128G eMMC 存储，整个集群有强大的灵活性和可扩展性。 Lichee Cluster 4A 板载八口千兆交换机以提供高速连接，轻松将多个节点连接起来，组成强大的计算集群，还支持 USB3.0 和 SD 卡存储扩展，能够轻松地将扩展额外存储或者增加外围设备。 Lichee Cluster 4A 还带有 BMC (带外管理)，BMC 独立连接了每个 LM4A 的系统串口和复位引脚。BMC 可以从硬件上复位单个计算节点，还可以通过串口执行命令,比如执行 ser2net 或 kermit 来管理 Slot。 ## 技术规格 <table> <colgroup> <col class \"org left\" /> <col class \"org left\" /> </colgroup> <tr> <td class \"org left\">支持的核心板</td> <td class \"org left\"> <a href \"https://wiki.sipeed.com/lm4a\">LM4A</a> * 7</td> </tr> <tr> <td class \"org left\">CPU</td> <td class \"org left\"><strong>RiscV C910@1.85GHz * 4</strong> * 7</td> </tr> <tr> <td class \"org left\">GPU</td> <td class \"org left\">IMG™ B 系列 BXM 4 64 * 7</td> </tr> <tr> <td class \"org left\">NPU</td> <td class \"org left\">4TOPS@INT8 * 7</td> </tr> <tr> <td class \"org left\">RAM</td> <td class \"org left\">最大 16GB * 7</td> </tr> <tr> <td class \"org left\">EMMC</td> <td class \"org left\">最大 128GB * 7</td> </tr> <tr> <td class \"org left\">BMC</td> <td class \"org left\"><a href \"https://wiki.sipeed.com/Lichee RV\">SIPEED Lichee RV</a></td> </tr> <tr> <td class \"org left\">电源管理</td> <td class \"org left\"><a href \"https://wiki.sipeed.com/m0sense\"> Sipeed M0 Sense</a></td> </tr> <tr> <td class \"org left\">Ethernet</td> <td class \"org left\">千兆以太网1(Slot#1)<br>千兆以太网2(交换机)<br>百兆以太网(BMC)</td> </tr> <tr> <td class \"org left\">USB</td> <td class \"org left\">USB3.0 * 7 (LM4A)<br>USB2.0 * 1 (BMC)</td> </tr> <tr> <td class \"org left\">HDMI</td> <td class \"org left\">HDMI * 1 (Slot 1)</td> </tr> <tr> <td class \"org left\">SDCARD</td> <td class \"org left\">TF * 7</td> </tr> <tr> <td class \"org left\">电源支持</td> <td class \"org left\">支持 DC 口直流电源供电<br>支持 ATX 24PIN 电源</td> </tr> <tr> <td class \"org left\">RTC 供电</td> <td class \"org left\">CR2032 纽扣电池</td> </tr> <tr> <td class \"org left\">散热</td> <td class \"org left\">5V PWM 风扇接口 * 7<br>12V 4PIN PWM 风扇接口 * 1</td> </tr> <tr> <td class \"org left\">尺寸</td> <td class \"org left\">Mini ITX, 17 * 17 cm (6.7 * 6.7 inch)<br>可选配 MINI ITX 机箱, 20 * 12 * 22 cm</td> </tr> </table> ## 硬件系统 ### 主板介绍 ![lc4a_top](./assets/lc4a/lc4a_top.png) ### 主板框架图 ![lc4a_architecture](./assets/lc4a/lc4a_architecture.png) LicheeRV SOM（D1 C906@1GHz）有5个原生串口，以及两个USB串口，分别独立连接到了7个SOM上。 每个 LM4A 的 RST/BOOT 均可通过模拟开关进行控制。 1号LM4A默认引出了第二千兆口和HDMI口，方便该SOM进行整个集群的任务分发操作。 主板可通过12V DC充电头供电（推荐12V9A以上），或者使用标准ATX电源供电。 ### 机箱介绍 推荐选配MINI ITX机箱，该机箱具备良好的外观和散热性能，方便计算集群的部署展示。 机箱适配MINI ITX主板，配备250W大功率电源，并安装了12cm静音风扇散热，可以保证CPU在满载运行时的温度低于70度。 ![lc4a_box](./assets/lc4a/lc4a_box.png) ### 硬件安装指南 默认运输途中LC4A已经安装了所有SOM，如果你需要拆卸或者升级SOM，可以参考以下说明。 #### 安装核心板 向两侧拉开白色锁扣，插入前请确认缺口为止，避免方向错误导致损坏 ![lc4a_install_goldfinger](./assets/lc4a/lc4a_install_goldfinger.png) 放入核心板后均匀的向下施加压力 ![lc4a_install_install_lm4a](./assets/lc4a/lc4a_install_install_lm4a.png) 听到喀哒声后，确认白色锁扣正确扣上，安装完成。如果需要取出核心板，向两侧拉开白色锁扣即可。 ![lc4a_install_slot](./assets/lc4a/lc4a_install_slot.jpeg) #### 安装BMC 安装烧录好镜像的SD卡到LicheeRV, 然后将LicheeRV的模块安装至交换机芯片旁边的座子,然后拧上螺丝. #### 插入电源 可选ATX电源供电或者DC电影供电。 确认ATX电源插座的卡扣已经扣紧，避免接触不良导致连接器升温 ![lc4a_power_atx20_cable](./assets/lc4a/lc4a_power_atx20_cable.png) 插上跳线帽 ![lc4a_power_jumpwire](./assets/lc4a/lc4a_power_jumpwire.png) #### 网络连接 集群系统对外主要连接两个网口：1. 板载千兆交换机网口 2. BMC网口 板载千兆交换机网口建议连接入用户所在内网或者主网络，用于集群获取所需网络数据。 BMC网口建议连入独立网络进行集群控制，更具安全性。 集群内部通过千兆交换机连接。 如何获得集群的IP地址: 预装的固件安装启用了mdns服务 在你的PC上启用avahi服务(Linux) 使用mdns扫描整个网络获得lc4a的mdns域名信息: ``` avahi browse art grep lc4a ``` 然后使用: ``` ssh debin@lc4aXXXX.local ``` XXXX为mac地址后四位，用于区分每个slot ## 软件系统 ### LM4A镜像 集群中的LM4A SOM可以直接使用LicheePi4A的镜像. 如果需要使能USB，可以在Linux设备树中应用以下PATCH: [点我下载](https://dl.sipeed.com/fileList/LICHEE/LicheeCluster4A/04_Firmware/lpi4a/src/linux/0001 arch riscv boot dts lpi4a disable i2c io expander fo.patch) 或者直接使用预编译镜像：[点我下载](https://dl.sipeed.com/shareURL/LICHEE/LicheeCluster4A/04_Firmware/lpi4a/bin) 镜像烧录方法： 1. 按下BOOT按键的同时按一下RST按键，然后使用A TO A公头的USB线缆连接到电脑 2. 使用fastboot工具烧录 ### OpenBMC镜像 主板上的 LicheeRV SOM 运行 OpenBMC 来管理主板上的 SOM。 镜像下载地址: [点我跳转](https://dl.sipeed.com/shareURL/LICHEE/LicheeCluster4A/04_Firmware/bmc/bin) 镜像烧录方法: ``` bmaptool copy obmc phosphor image licheepi rv.wic.gz /dev/YOUR_SDCARD ``` 默认用户名: `root` 默认密码: `0penBmc` 0 是零，不是 O 如果需要开发定制，请下载PATCH: https://dl.sipeed.com/shareURL/LICHEE/LicheeCluster4A/04_Firmware/bmc/src 并应用到OpenBMC源码: ``` git clone https://github.com/openbmc/openbmc/ git checkout commit id git am xxx.patch ``` ### OpenBMC管理 从SSH访问Slot的串口: ``` ssh p 2301 root@bmcip # access first slot's serial port ``` * 端口 22: OpenBMC的shell * 端口 2301: slot1 的 SOL (Serial Over LAN) * 端口 2302: slot2 的 SOL * 端口 2303: slot3 的 SOL * 端口 2304: slot4 的 SOL * 端口 2305: slot5 的 SOL * 端口 2306: slot6 的 SOL * 端口 2307: slot7 的 SOL 每个Slot的串口输出到日志: ``` cat /var/log/obmc cons*.log ``` 对 LM4A 的电源管理： 启动/复位：（1 7 分别对应 slot 1 到 7） ``` /usr/libexec/phosphor state manager/muxctl.sh 1 boot /usr/libexec/phosphor state manager/muxctl.sh 2 reset ```"},"/hardware/zh/lichee/th1520/lpi4a/3_images.html":{"title":"镜像集合","content":" title: 镜像集合 keywords: Linux, Lichee, TH1520, SBC, RISCV, image update: date: 2026 01 30 version: v1.2 author: Kevin.MX content: Point RevyOS (Debian) images to docs.revyos.dev Remove/update outdated information date: 2023 10 23 version: v1.2 author: ztd content: Update image info and upload new images date: 2023 07 14 version: v1.1 author: ztd content: Update docs date: 2023 05 08 version: v1.0 author: wonder content: Release docs ## 内核支持 目前玄铁 SDK / RevyOS 使用 Linux 6.6 内核：https://github.com/revyos/th1520 linux kernel 主线 Linux 内核正在移植中，主要社区贡献者：`Jisheng Zhang ` ## RevyOS ![debian](./assets/images/debian.png) ![debian_neofetch](./assets/images/revyos_fastfetch.png) 下载地址： ISCAS 镜像站：[点我](https://mirror.iscas.ac.cn/revyos/extra/images/lpi4a/) 百度网盘（≤20240602）：[点我](https://pan.baidu.com/s/1xH56ZlewB6UOMlke5BrKWQ) Mega 云盘（≤20240602）：[点我](https://mega.nz/folder/phoQlBTZ#cZeQ3qZ__pDvP94PT3_bGA) 此文档关于 RevyOS 的信息可能不是最新，请访问 RevyOS 文档站获取最新消息：https://docs.revyos.dev/ 1. LPI4A_20240111_BASIC.zip 发布日期：2024年1月11日 内核：5.10 根文件系统：ext4, 4.3GB 主要预装软件包： 开发类 python3.11 办公类 libreoffice 套件 浏览器 chromium 媒体类 支持播放4K视频的播放器 Parole（支持硬件加速，推荐优先使用）、VLC、GIMP 更新记录： 20230706： HDMI 显示设备和 HDMI 音频设备识别问题 修复蓝牙问题，现在蓝牙设备功能正常，蓝牙耳机也能正常播放音频 修复桌面底部启动栏浏览器快捷方式不可用的问题，现在能点击这里进入 chromium 修复在长时间连接 USB 摄像头情况下，会导致 kernel panic 的问题 20230721： 修复16GB内存识别问题，需完全识别16GB内存请更新此镜像 20230912： 修复HDMI 音频在 chromium 下播放音质的问题 修复双屏异显时字体显示像素缺失的问题 20231023： 修复光标指针不准问题 修复NPU驱动 kernel 和 user 版本不匹配的问题 修复烧录4G以上根文件系统失败问题 20231214： 修复光标闪烁问题 添加 Wifi6 驱动支持 20240111： 修复MIPI屏幕亮度无法调节的问题 修复新 WIFI/BT 模块的蓝牙无法使用的问题 使用说明： 该镜像开启了自动登陆，默认登陆用户为 sipeed； 该镜像开启了免密码 sudo 功能； 该镜像会自动加载 NPU 相关的驱动，无需手动初始化; 该镜像同时支持 HDMI 和 MIPI 显示，需要通过启动菜单切换 启动菜单配置文件在 boot.ext4 中，路径为 /boot/extlinux/extlinux.conf。其中有三项，区别在于后缀，启动项1后缀为(HDMI only)，启动项2后缀为(HDMI and MIPI)，启动项3后缀为(rescue target)，若因为一些更改，导致无法正常进入系统，可以尝试使用启动项3进行修复。 默认启动项仅支持 HDMI 显示，有两种办法更换为支持 MIPI 显示的启动项： 1. 连接串口工具，在开机时会出现启动菜单，按下数字键2即可选择第二项启动，该方法仅针对当前这次启动生效； 2. 修改 extlinux.conf 文件，将文件中的 default l0 更改为 default l1 即可实现修改默认启动项为支持 MIPI 显示的镜像。 该压缩包包含两种 u boot 烧录时请注意文件名中的后缀和设备相关参数对应 u boot 带 16g 后缀的为支持 16g 内存的u boot，不带后缀的为支持 8g 内存的 u boot 已知问题： 2. LPI4A_20240111_FULL.zip 发布日期：2024年1月11日 内核：5.10 根文件系统：ext4, 9.7GB 主要预装软件包： 开发类 python3.11、GCC、VScode、Kicad（含示例工程）、AI环境（含预编译yolov5n/yolov5s可执行示例） 办公类 libreoffice 套件 浏览器 chromium 媒体类 支持播放4K视频的播放器 Parole（支持硬件加速，推荐优先使用；含示例4k视频）、VLC、GIMP、视频编辑软件 Kdenlive（含示例视频素材）、kodi 游戏 SuperTuxKart 其他 btop、neofetch 更新记录： 20230706： HDMI 显示设备和 HDMI 音频设备识别问题 修复蓝牙问题，现在蓝牙设备功能正常，蓝牙耳机也能正常播放音频 修复桌面底部启动栏浏览器快捷方式不可用的问题，现在能点击这里进入 chromium 修复在长时间连接 USB 摄像头情况下，会导致 kernel panic 的问题 20230721： 修复16GB内存识别问题，需完全识别16GB内存请更新此镜像 20230912： 修复HDMI 音频在 chromium 下播放音质的问题 修复双屏异显时字体显示像素缺失的问题 20231023： 修复光标指针不准问题 修复NPU驱动 kernel 和 user 版本不匹配的问题 修复烧录4G以上根文件系统失败问题 20231214： 修复光标闪烁问题 添加 Wifi6 驱动支持 20240111： 修复MIPI屏幕亮度无法调节的问题 修复新 WIFI/BT 模块的蓝牙无法使用的问题 使用说明： 该镜像占用空间较大，内测版由于 EMMC 容量只有 8G，故无法使用本镜像，内测版用户请使用 BASIC 版本镜像； 该镜像开启了自动登陆，默认登陆用户为 sipeed； 该镜像开启了免密码 sudo 功能； 该镜像会自动加载 NPU 相关的驱动，无需手动初始化; 该镜像同时支持 HDMI 和 MIPI 显示，需要通过启动菜单切换 启动菜单配置文件在 boot.ext4 中，路径为 /boot/extlinux/extlinux.conf。其中有三项，区别在于后缀，启动项1后缀为(HDMI only)，启动项2后缀为(HDMI and MIPI)，启动项3后缀为(rescue target)，若因为一些更改，导致无法正常进入系统，可以尝试使用启动项3进行修复。 默认启动项仅支持 HDMI 显示，有两种办法更换为支持 MIPI 显示的启动项： 1. 连接串口工具，在开机时会出现启动菜单，按下数字键2即可选择第二项启动，该方法仅针对当前这次启动生效； 2. 修改 extlinux.conf 文件，将文件中的 default l0 更改为 default l1 即可实现修改默认启动项为支持 MIPI 显示的镜像。 该压缩包包含两种 u boot 烧录时请注意文件名中的后缀和设备相关参数对应 u boot 带 16g 后缀的为支持 16g 内存的u boot，不带后缀的为支持 8g 内存的 u boot 已知问题： ## Sipeed官方镜像 LicheePi 4A 的镜像不定期更新中，初期的镜像可能不太稳定，或者无法发挥 TH1520 的完全性能，请关注本页面，获取最新镜像。 Sipeed 官方镜像基于 Debian 系统修改适配。 默认镜像的帐号密码配置如下： 账户：`debian`，密码： `debian`； 账户：`sipeed`，密码：`licheepi`； root 账户默认没有设置密码。 ### 内存问题修复说明 重要提示：2023.8.1 之前发出的 16GB 内存板存在错误图像，无法正确识别 16GB 内存（运行大型应用程序可能导致系统崩溃），请按照以下说明修复此错误。 请使用下面的命令烧录新的 u boot 到板子中，16G 内存使用的 u boot 在[网盘链接](https://pan.baidu.com/s/1xH56ZlewB6UOMlke5BrKWQ)中，也能在[这个链接](https://dl.sipeed.com/shareURL/LICHEE/licheepi4a/07_Tools)中下载 相关文件在 `20230803_tempfix.zip` 压缩包中。 （0721及以后版本的镜像内存能正常使用，无需替换为此处的文件） ```shell sudo ./fastboot flash ram ./images/u boot with spl lpi4a 16g.bin sudo ./fastboot reboot sleep 1 sudo ./fastboot flash uboot ./images/u boot with spl lpi4a 16g.bin # 若自己使用的 boot.ext4 中没有 16G ddr 对应的设备树，则需要再烧录 16G ddr 对应的 boot.ext4 sudo ./fastboot flash boot ./images/boot.ext4 ``` ### OpenWRT ![openwrt](./assets/images/openwrt.png) [Click me](https://github.com/ruyisdk/openwrt) ### Android ![android](./assets/images/android.png) Readme and image download link: [Click me](https://gitee.com/thead android/thead android) 预构建镜像下载地址： 百度网盘：[点我](https://pan.baidu.com/s/1xH56ZlewB6UOMlke5BrKWQ) Mega 云盘：[点我](https://mega.nz/folder/phoQlBTZ#cZeQ3qZ__pDvP94PT3_bGA) > 安卓13 SDK 仍处于初期状态，会逐步修复其中的问题 Sipeed 官方镜像的网盘下载链接中提供了 Android 13的预编译镜像文件，下载后烧录方式如下，fastboot工具请使用从这里下载的版本： https://developer.android.com/tools/releases/platform tools 网盘中也有提供 fastboot 的文件 ```shell #烧录uboot并初始化boot环境变量 fastboot flash ram u boot with spl.bin fastboot reboot fastboot flash uboot u boot with spl.bin #烧录各个分区 #在非boot烧写模式，可以在uboot的命令行中输入命令fastboot usb 0，单独烧录分区 fastboot flash bootpart bootpart.ext4 fastboot flash boot boot.img fastboot flash vendor_boot vendor_boot.img fastboot flash super super.img fastboot flash userdata userdata.img fastboot flash vbmeta vbmeta.img fastboot flash vbmeta_system vbmeta_system.img #初始化metadata和misc分区 fastboot erase metadata fastboot erase misc ``` ## 第三方镜像 这里整理了第三方提供的镜像，仅供用户体验，sipeed 不保证此类镜像的可用性，稳定性。 ### openEuler ![openEuler](./assets/images/openEuler.png) ![openeuler_neofetch](./assets/images/openeuler_neofetch.png) Download: [Click me](https://images.oerv.ac.cn/) Twitter: https://twitter.com/openEuler ### DeepinOS 深度 ![deepin](./assets/images/deepin.jpg) ![deepin_neofetch](./assets/images/deepin_neofetch.png) Readme and image download link: [Click me](https://deepin community.github.io/sig deepin ports/images/riscv64) ### openKylin ![openKylin](./assets/images/openkylin.png) ![oepnkylin_neofetch](./assets/images/oepnkylin_neofetch.png) Readme link: [Click me](https://github.com/aiminickwong/licheepi4a images) [openKylin V1.0 Download address](https://www.openkylin.top/downloads/index cn.html) ### armbian (official build framework, use RV64GC toolchain) ![armbian](https://cdn.armbian.com/wp content/uploads/2018/03/logo2.png) Project address: [Click me](https://github.com/armbian/build) Download and Infomations: [Click me](https://www.armbian.com/licheepi 4a/) ### armbian (unofficial build framework, use T Head optimized toolchain) ![armbian](https://cdn.armbian.com/wp content/uploads/2018/03/logo2.png) ![armbian_neofetch](./assets/images/armbian_neofetch.png) Project address: [Click me](https://github.com/chainsx/armbian riscv build) ### Fedora (Fedora V Force) Link: https://images.fedoravforce.org/LicheePi%204A ### Fedora (chainsx) ![fedora](./assets/images/fedora.png) ![fedora_neofetch](./assets/images/fedora_neofetch.png) Project address: [Click me](https://github.com/chainsx/fedora riscv builder) ### OpenWrt (unofficial) ![openwrt](./assets/images/openwrt.png) ![openwrt_unofficial](./assets/images/openwrt_unofficial.png) Project address: [Click me](https://github.com/chainsx/openwrt th1520) ### Ubuntu (rootfs only) ![ubuntu](./assets/images/ubuntu.png) [Click me](http://cdimage.ubuntu.com/ubuntu base/releases/22.04/release/) ![ubuntu_neofetch](./assets/images/ubuntu_neofetch.jpg) ### NixOS (unofficial) ![nixos](./assets/images/nixos.png) ![nixos_neofetch](./assets/images/nixos licheepi neofetch.jpg) Project address: [Click me](https://github.com/ryan4yin/nixos licheepi4a) ### Gentoo Project address: [Click me](https://wiki.gentoo.org/wiki/Project:RISC V) 下面链接说明如何从stage3制作一个Gentoo Linux系统 Deplay Gentoo Linux [Click me](https://wiki.gentoo.org/wiki/User:Dlan/RISC V/TH1520) ![gentoo](./assets/images/gentoo.jpg) ### slarm64 ![slarm64](./assets/images/slarm64.png) Project address: [Click me](https://gitlab.com/sndwvs/images_build_kit) Download: [Click me](https://dl.slarm64.org/slackware/images/lichee_pi_4a/) ### irradium [irradium](https://irradium.org/) source based Linux distribution [CRUX](https://crux.nu/) adhering to ideology keep it simple, has its own [package system](https://crux.nu/Main/Handbook3 7#ntoc29), also supports the [port system](https://crux.nu/Main/Handbook3 7#ntoc47). Project address: [Click me](https://gitlab.com/sndwvs/irradium.git) Download: [Click me](https://dl.irradium.org/irradium/images/lichee_pi_4a/)"},"/hardware/zh/lichee/th1520/lpi4a/12_faq.html":{"title":"常见问题","content":" title: 常见问题 keywords: Linux, Lichee, TH1520, SBC, RISCV, Debian, Desktop update: date: 2023 10 30 version: v1.2 author: ztd content: Update official development docs. date: 2023 10 23 version: v1.1 author: ztd content: Update NPU's FAQ date: 2023 09 22 version: v1.0 author: ztd content: Release docs ## 开箱体验 供电注意事项： 1. USB C仅支持5V输入，保险起见不要使用带快充功能的充电宝或者充电头供电 2. 排针的IO均为1.8V电平，请使用配送的串口小板或者支持1.8V的串口小板 3. 电脑USB一般只有5V1A，带不起来板子，板子至少需要5V2A，推荐5V3A的适配器供电，或者使用12V DC供电 4. USB 丝印旁的 LED 闪烁，说明电源不稳定或短路 正式版与内测版硬件差异、USB限流说明见[板卡硬件说明](https://en.wiki.sipeed.com/hardware/zh/lichee/th1520/lpi4a/2_unbox.html#%E6%9D%BF%E5%8D%A1%E7%A1%AC%E4%BB%B6%E8%AF%B4%E6%98%8E) ## 镜像集合 20230721之前版本的镜像，在16+128的核心板上存在无法正确识别内存大小的问题，需要更新镜像版本。若为20230706之后的版本，也可参考[镜像集合相关章节](https://wiki.sipeed.com/hardware/zh/lichee/th1520/lpi4a/3_images.html#%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98%E4%BF%AE%E5%A4%8D%E8%AF%B4%E6%98%8E)进行修复。 使用镜像前请仔细阅读wiki中镜像集合的使用说明，以保证下载的是预期镜像，比如使用10.1寸触摸屏需要烧录带MIPI后缀压缩包中的镜像。 安卓13镜像目前暂未进行外设支持，烧录后只有HDMI显示等基础功能。 ## 烧录镜像 Windows系统下烧录，请先确认驱动是否按照正确安装。若正确安装驱动，烧录时还是没有反应，可尝试更换 USB 线，注意使用的 USB 线必须是能供电和传输数据的线，并且烧录时使用的 USB 口尽量不要使用主机前面板的 USB 口，也不要使用笔记本电脑中的数据口，否则会因为供电原因导致识别不到设备。 想要切换启动模式，比如切换为从 SD 卡启动，正式版底板可以通过拨码开关（注意需要制作专用镜像）来切换，非正式版也可以通过传递启动参数来切换，详见[烧录镜像的对应章节](https://wiki.sipeed.com/hardware/zh/lichee/th1520/lpi4a/4_burn_image.html#U Boot)。 20231023后更新了大镜像烧录支持，从该版本起，烧录需要使用最新版本的 fastboot，可以在镜像集合的[网盘链接](https://pan.baidu.com/e/1xH56ZlewB6UOMlke5BrKWQ)中找到，文件名为 `burn_tools_support_bigimage.zip`。 ## 桌面系统基础使用 若桌面下方启动器的图标功能异常，可以自己手动配置为自己想要的方案，也可以使用如下命令恢复为默认配置，默认配置效果参考[桌面系统基础使用相关章节](https://wiki.sipeed.com/hardware/zh/lichee/th1520/lpi4a/5_desktop.html#%E6%B5%8F%E8%A7%88%E5%99%A8)： \t```shell \tcp /etc/xdg/xfce4/panel/default.xml /home/sipeed/.config/xfce4/xfconf/xfce perchannel xml/xfce4 panel.xml \tchown sipeed:sipeed /home/sipeed/.config/xfce4/xfconf/xfce perchannel xml/xfce4 panel.xml \t``` 若安装软件时遇到报错，请更新到最新镜像或参考[软件安装](https://en.wiki.sipeed.com/hardware/zh/lichee/th1520/lpi4a/5_desktop.html#%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85) 若在重启后发现开发板的 Wifi/BT 功能无法使用，或看不到 Wifi 设备，此时拔掉开发板的供电，完全断点后再上电重启即可。 ## 外设使用 1. 若要使用 NPU，请使用0920及以上版本的镜像； 2. 使用 JTAG 需要自行飞线，并在板子上设置 pinmux，参考[JTAG](https://en.wiki.sipeed.com/hardware/zh/lichee/th1520/lpi4a/6_peripheral.html#JTAG) 3. 在接入外设较多时（比如 HDMI，USB键鼠）尽量使用12V DC供电。电脑的USB口若本身接入外设较多，可能会没有多余的能力给开发板及开发板所连接的外设供电。 4. 在使用 NPU 进行推理时，第一次运行时会在板上进行一次优化，这个过程比较慢。之后会生成 shl.hhb.bm 文件，使用这个权重文件进行推理会比较快。 5. 针对于某些不支持 UHS 的 TF 卡，可能在读写大文件时会出现 I/O error，此时可以切换到 root 用户，执行下面的命令： ```shell apt update apt install device tree compiler cd /boot/dtbs/linux image 5.10.113 lpi4a/thead/ # 双屏则运行：cd /boot/dtbs/linux image 5.10.113 lpi4a/dual/thead/ dtc I dtb O dts light lpi4a.dtb o light lpi4a.dts # 16g注意将名字更换为light lpi4a 16gb.dtb(light lpi4a 16gb.dts) awk v RS \"}\" '/sd@ffe7090000/ {sub(\"max frequency <0xbcd3d80>;\", \"max frequency <100000000>;\")} {printf \"%s}\", $0}' light lpi4a.dts > temp.dts && mv temp.dts light lpi4a.dts # 16g注意将名字更换为light lpi4a 16gb.dtb(light lpi4a 16gb.dts) dtc I dts O dtb light lpi4a.dts o light lpi4a.dtb # 16g注意将名字更换为light lpi4a 16gb.dtb(light lpi4a 16gb.dts) sync ``` 修改设备树后，重启开发板即可。 6. 若连接上蓝牙鼠标后，移动时没有反应，可以尝试重启一下蓝牙服务： ```shell sudo systemctl restart bluetooth.service ``` ## 系统开发 ### revyos 1. 构建 kernel/uboot/opensbi 前，请检查这些环境变量是否设置好了 \t```shell \texport toolchain_tripe riscv64 unknown linux gnu \texport ARCH riscv \texport nproc 12 \texport GITHUB_WORKSPACE \"~/th1520_build\" \texport PATH \"/opt/Xuantie 900 gcc linux 5.10.4 glibc x86_64 V2.6.1/bin:$PATH\" \t``` \t以上环境变量请根据自身实际配置、文件路径等进行调整。 \t构建后，在安装相应文件时也请检查对应的文件夹是否创建了，以及路径是否正确，比如 `rootfs` ，`rootfs/boot` 目录是否创建。 2. 由于工具链版本不同，不同 SDK 下构建的二进制文件不能混用。 3. 构建完烧录后若USB等外设功能失效，请检查 Image 和 modules(模块目录放到板子上的/lib/modules目录下) 是否对上。 ### THead Yocto 1. 截至该 SDK 的 1.1.2 版本，使用 Docker 搭建该 SDK 的开发环境时需要更改 Dockerfile，具体改动参考[THead Yocto相关章节](https://wiki.sipeed.com/hardware/zh/lichee/th1520/lpi4a/7_develop_thead.html#%E6%90%AD%E5%BB%BAYocto%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83)： \t注释 Dockerfile 中 182 186 行： \t```shell \t# install npm \t#RUN cd $WORK_PATH \\ \t# && curl fsSL https://deb.nodesource.com/setup_lts.x bash \\ \t# && apt install y nodejs yarn \\ \t# && npm install aiot vue cli g \t``` \t再执行 \t```shell \tdocker build t linux dev base:base . \t``` \t \t容器安装完毕后，进入容器，再执行如下命令: \t```shell \tsudo apt update \tsudo apt install npm \tsudo apt install nodejs \t``` \t最后执行: \t```shell \tnpm v \tnodejs v \t``` \t有相关版本号输出即可。 3. 在使用 `MACHINE light lpi4a bitbake thead image linux` 命令构建镜像时，如果遇到在执行 `compile` 任务时崩溃，可能是内存不够。建议至少 32G 内存。 4. 由于网络原因，可能会出现下载失败或下载很慢的情况，推荐使用代理下载。 5. 若遇到如下报错： \t```text \tPlease use a locale setting which supports utf 8. \tPython can't change the filesystem locale after loading so we need a utf 8 when python starts or things won't work. \t``` \t请按照以下步骤解决： \t首先安装相应的依赖 \t```shell \tsudo apt get install locales \tsudo dpkg reconfigure locales \t``` \t然后在打印出来的列表中找到 `en_US.UTF8` 这一项（典型位置在第158项）,输入这一项对应的序号后回车，接下来也选择这一项后回车。 \t完成上述设置步骤后接着运行如下命令（也可考虑将下面的命令加入到docker的 `.bashrc` 中） \t```shell \tsudo locale gen en_US.UTF 8 \tsudo update locale LC_ALL en_US.UTF 8 LANG en_US.UTF 8 \texport LANG en_US.UTF 8 \t``` \t完成上述步骤后再编译就不会出现原来的报错。 5. 若遇到类似如下报错： \t```text \tplease install them in order to proceed: lz4c pzstd zstd \t``` \t是缺少相关依赖，直接安装即可 \t```shell \tsudo apt update && sudo apt install y zstd liblz4 tool \t``` ### Android 1. 对于国内用户，使用 Android SDK 下载源码时，若运行`repo init u https://gitee.com/thead android/local_manifests.git b main_2023_7_7`命令始终不成功，可以尝试运行以下命令后，再进行 `repo init` \t``` \texport REPO_URL 'https://mirrors.tuna.tsinghua.edu.cn/git/git repo/' \t``` 2. 使用 docker 环境编译时，可能会遇到如下报错： \t```shell \tBuild sandboxing disabled due to nsjail error. \t``` \t这个报错可以暂时忽略，不影响后面的编译步骤。若想运行 nsjail，可以尝试升级内核版本至5.XX或者启动 docker 时传入这些参数 ` security opt apparmor unconfined security opt seccomp unconfined security opt systempaths unconfined` 或 ` privileged`。 ## 开发文档 请在[该链接](https://dl.sipeed.com/shareURL/LICHEE/licheepi4a/09_Doc)中下载。"},"/hardware/zh/lichee/th1520/lpi4a/1_intro.html":{"title":"板卡介绍","content":" title: 板卡介绍 keywords: Linux, Lichee, TH1520, SBC, RISCV update: date: 2023 05 08 version: v1.0 author: wonder content: Release docs ## 简介 LicheePi 4A 是基于 [Lichee Module 4A](http://wiki.sipeed.com/hardware/zh/lichee/th1520/lm4a.html) 核心板的 高性能 RISC V Linux 开发板，以 [TH1520](https://www.t head.cn/product/yeying) 为主控核心（4xC910@1.85G， RV64GCV，4TOPS@int8 NPU， 50GFLOP GPU），板载最大 16GB 64bit LPDDR4X，128GB eMMC，支持 HDMI+MIPI 双4K 显示输出，支持 4K 摄像头接入，双千兆网口（其中一个支持POE供电）和 4 个 USB3.0 接口，多种音频输入输出（由专用 C906 核心处理）。 ![lpi4a](./assets/intro/lpi4a.png) LicheePi 4A 是截止目前（2023Q2）为止最强的 RISC V SBC。性能约为上一代 RISC V SBC [VisionFive2](https://www.starfivetech.com/en/site/boards)的2倍；未开启专用指令集加速的情况下，性能逼近基于 ARM A72 的树莓派 4，在开启相关指令集加速的情况下，可以与树莓派 4 持平。而且最高具备 16GB 超大内存，是树莓派 4 最高配置 8GB 内存的两倍！ ![benchmark](./assets/intro/benchmark.png) ![geekbench5](./assets/intro/geekbench5.png) LicheePi 4A 可以用作典型的 RISC V 验证平台，其强大的性能可以较快速地实现本地编译，而无需使用 QEMU 进行编译。 我们在近期（2023Q2）还会放出基于LM4A的集群计算板卡 LicheeCluster 4A，最大支持 7xLM4A 进行集群计算，编译，非常适合发行版编译农场场景，尽情期待。 在保持高性能的同时，我们也尽量进行了 CostDown 设计，8GB 内存版本价格在 ￥749~ 899（\\\\$100 ~ \\\\$130），16GB 内存版本在 ￥1100~1300 （\\\\$155 ~\\\\$185）, 性价比上超越了树莓派 4（8GB ~\\\\$150）! 无论你是否是 RISC V 粉丝，你都值得入手体验下 LicheePi 4A 这款划时代的高性能 RISC V SBC！ ![desktop](./assets/intro/desktop.png) ## 欢迎投稿 本文档为在线文档，托管在 github 上，大家可以点击右上角 `编辑本页` 链接来进行编辑~ 对成功提交文档的用户，我们视文档质量酌情提供 ￥5 ~ 150（\\\\$1 ~ 20）的优惠券~ ## 基础参数 <table> <thead> <tr> <th colspan 2>主控参数</th> </tr> </thead> <tbody> <tr> <td>主控芯片</td> <td>TH1520</td> </tr> <tr> <td>CPU处理器</td> <td>RISC V 64GCV C910*4@1.85GHz <br>· 每核支持 64KB I cache 和 64KB D Cache <br>· 四核共享 1MB L2 Cache <br>· 支持 TEE 和 REE，TEE/REE 支持核数启动时可配置<br>· 支持自定义且接口兼容 RISC V 的多核调试框架<br>· 独立电源域，支持 DVFS</td> </tr> <tr> <td>图形处理器</td> <td>· OpenCL 1.1/1.2/2.0<br>· OpenGL ES 3.0/3.1/3.2<br>· Vulkan 1.1/1.2<br>· Android NN HAL</td> </tr> <tr> <td>NPU处理器</td> <td>支持 4TOPS@INT8 通用 NNA 算力，主频 1GHz <br>· 支持 TensorFlow、ONNX、Caffe <br>· 支持 CNN、RNN、DNN 等</td> </tr> <tr> <td>视频解码器</td> <td>实时解码器，支持 H.265/H.264/VP9/8/7/6/AVS/AVS+/AVS2.0/VC1/MPEG4 <br>· 支持 H.264 BP/MP/HP@level 5.1 解码，最大 4K 分辨率<br>· 支持 H.265/HEVC Main Profile@level 5.1 解码，最大 4K 分辨率<br>· 支持 VP9 Profile 2 解码，最大 4K 分辨率<br>· 支持 AVS2.0 解码，最大 4K 分辨率<br>· 支持 VP6/7/8/AVS/AVS+/VC1/MPEG4 解码，最大 1920x1080 分辨率<br>· 解码性能最大 4K@75fps</td> </tr> <tr> <td>视频编码器</td> <td>· 支持 H.264 BP/MP/HP@level4.2 编码，最大 4K 分辨率<br>· 支持 H.265/HEVC Main Profile 编码，最大 4K 分辨率<br>· 仅支持 I 帧和 P 帧<br>· 编码性能最大 4K@40fps</td> </tr> <tr> <th colspan 2>硬件特性</th> </tr> <tr> <td>RAM</td> <td>· 8GB 64bits LPDDR4X<br>· 16GB 64bits LPDDR4X<br></td> </tr> <tr> <td>存储</td> <td>· eMMC: 可选 空贴、 8G、 32G、 128G<br>· 支持 TF 卡</td> </tr> <tr> <td>以太网</td> <td>· 2 x 千兆以太网接口，可选 POE</td> </tr> <tr> <td>USB</td> <td>· USB3.0 x 4<br>· USB2.0 x 1（仅用于烧录）</td> </tr> <tr> <td>音频接口</td> <td>· 1 x 3.5mm 耳机接口<br>· 一个扬声器接口<br>· 两个板载麦克风<br></td> </tr> <tr> <td>显示接口</td> <td>· 1 x HDMI2.0<br>· 1 x 4 lane MIPI DSI</td> </tr> <tr> <td>摄像头接口</td> <td>· 2 x 2 lane MIPI CSI<br>· 1 x 4 lane MIPI CSI</td> </tr> <tr> <td>GPIO</td> <td>· UART<br>· IIC<br>· SPI</td> </tr> </tbody> </table> ### 硬件资料下载 [板卡规格书](https://dl.sipeed.com/shareURL/LICHEE/licheepi4a/01_Specification) [底板原理图](https://dl.sipeed.com/shareURL/LICHEE/licheepi4a/02_Schematic) [底板点位图](https://dl.sipeed.com/shareURL/LICHEE/licheepi4a/03_Bit_number_map) [底板尺寸图](https://dl.sipeed.com/shareURL/LICHEE/licheepi4a/04_Dimensional_drawing) [模型文件](https://dl.sipeed.com/shareURL/LICHEE/licheepi4a/05_3D_model) ## 其他链接 [Github](https://github.com/sipeed/LicheePi4A) [淘宝](https://item.taobao.com/item.htm?id 715508771884) [Sipeed 下载站](https://dl.sipeed.com/shareURL/LICHEE/licheepi4a) QQ群: 559614960 [点我自动加群](http://qm.qq.com/cgi bin/qm/qr?k 5YkapIhdtWHp8AEfM5_bFFYQIX3CUQN6) Telegram: https://t.me/linux4rv 论坛：Maixhub.com/discussion 联系邮箱：support@sipeed.com"},"/hardware/zh/lichee/th1520/lpi4a/2_unbox.html":{"title":"开箱体验","content":" title: 开箱体验 keywords: Linux, Lichee, TH1520, SBC, RISCV, unbox update: date: 2023 05 08 version: v1.0 author: wonder content: Release docs ## 开箱内容 LicheePi 4A 分为两个版本，内测版与正式版。 内测版于 2023 年 5 月发售，仅有 8+8（DDR+eMMC）版本，各部分功能基本正常。 正式版于 2023 年 7 月发售，有 8+32,16+128 版本，也会针对内测版用户提出的相关建议进行局部微调优化，功能/镜像与内测版会保持一致。 ### 内测版 如果你是第一批内测版 LicheePi 4A 用户，你收到的包裹内将是如下包装： ![package_alpha](./assets/unbox/package_alpha.png) 打开塑料盒包装，你将看到如下的内容： ![unbox_alpha](./assets/unbox/unbox_alpha.png) 包裹在黑色泡棉内的就是 LicheePi 4A 主体，其余标号部件为： 1. 30x30mm 散热硅脂 2. 30mm 5V 散热风扇，右边已连接至风扇插针。如果松动脱出，请自行安装回去，注意红线为正极，装反后风扇不会转动。 3. 2.4G WiFi 天线，已安装至 IPEX 座子。如果松动脱出，请自行安装回去。 4. USB C 线缆，作为供电和下载镜像使用。 如果开箱后发现缺少相关部件，请联系客服咨询。 ### 正式版 如果你购买了正式版 LicheePi 4A，你收到的包裹内将是如下包装： ![package_v1](./assets/unbox/package_v1.jpg) 在包装侧面可以看到当前硬件的 内存/eMMC 版本，如果发现与你购买的版本不符，请与客服联系： ![package_v1mem](./assets/unbox/package_v1mem.jpg) 移除蓝色封盖，是白色纸盒包装： ![package_v1box](./assets/unbox/package_v1box.jpg) 打开白色纸盒，就可以看到LicheePi 4A板卡： ![package_v1board](./assets/unbox/package_v1board.jpg) 可以看到板卡上贴了两个二维码，在底板USB上贴的二维码为底板生产信息，代表了底板型号版本，生产日期，如： `LPI4A0 23070702067` 在SOM上贴的二维码为SOM生产信息，代表了 SOM型号版本，内存eMMC，MAC地址（第二个网口地址为此地址+1），生产日期，如： `LM4A0 16128 48DA3560003E 23071100318` 拿出开发板后，纸盒底部装着默认配件，USB线，散热器，散热硅脂： ![package_v1misc](./assets/unbox/package_v1misc.jpg) 如果开箱后发现缺少相关部件，请联系客服咨询。 ### 选配件 LicheePi 4A还有丰富的配件可供选择，如下图所示： ![accessory](./assets/unbox/accessory.jpg) 选购说明： 配件名选购说明 铝合金外壳适合作为小主机，软路由的外壳 10.1寸触摸屏1280x800 4lane MIPI，适合作为车机，安卓 调试使用 OV5693 摄像头 5MP摄像头，适合作为移动设备，如安卓的原生摄像头调试 USB摄像头5MP USB摄像头，板载麦克风，适合作为openCV的摄像头使用 PoE电源模块5V2.4A PoE电源模块，网关类应用使用网线PoE供电 12V电源12V2A电源适配器，板卡外接很多耗电外设时选购 RV Debugger PlusUART+JTAG调试小板，连接系统串口终端调试用 ## 组装板卡 ### SOM安装 默认情况下 LM4A SOM 已经安装至主板上，如果你需要升级/替换 SOM，可按如下说明进行 SOM 的取出和安装 1. 取出 SOM: <table> <tr> <td colspan 2>先用手指往外拨动弹片解锁 SOM, 然后将 SOM 取出</td> </tr> <tr> <td><img src \"./assets/unbox/unlock_som.png\" alt \"unlock_som\"></td> <td><img src \"./assets/unbox/remove_som.png\" alt \"remove_som\"></td> </tr> </table> 2. 安装 SOM: <table> <tr> <td colspan 2>先把 SOM 斜着插入连接器插槽, 然后按压SOM，两边弹片会自动锁住SOM</td> </tr> <tr> <td><img src \"./assets/unbox/insert_som.png\" alt \"insert_som\"></td> <td><img src \"./assets/unbox/lock_som.png\" alt \"lock_som\"></td> </tr> </table> ### 散热器安装 LicheePi 4A 是高性能 SBC，需要安装主动散热器对 SOM 进行散热，否则在满载时可能由于核心过热而自动降频，无法达到最优性能。 1. 安装导热硅脂片 取出导热硅脂片，撕开两面薄膜，将硅脂片放置在下图位置并轻轻按压固定（硅脂片自己具备一定粘性可以固定住），注意完整覆盖住主芯片与两颗内存芯片 ![silicone_pad](./assets/unbox/silicone_pad.png) 2. 安装散热风扇 在硅脂片上对齐安装30mm的散热风扇，并轻轻按压固定住。 ![insert_fan](./assets/unbox/insert_fan.png) 3. 安装散热风扇电源 默认收到时应该已经插入好了风扇电源，如果风扇电源线脱出，请按下图所示插入，注意电源线顺序，装反风扇不会旋转。 注意，该位置上的插针电源受 linux 内核控制，需正确配置内核才会旋转，如果风扇不转，也可插到板卡下方的 20pin 插针的 5V + GND 处测试风扇好坏。 ![insert_fan_cable](./assets/unbox/insert_fan_cable.png) ### WIFI天线安装 默认情况下WIFI天线已经安装在主板上，如果脱出，请按照下图安装回去： ![insert_ant](./assets/unbox/insert_ant.png) ### POE模块安装 该模块需额外购买，规格为35.6mm长度的5V PoE供电模块，焊接在开发板的POE POWER位置。 PoE模块安装如图所示： <table> <tr> <td><img src \"./assets/unbox/unbox_poe_0.jpg\" alt \"poe_back\"></td> <td><img src \"./assets/unbox/unbox_poe_1.jpg\" alt \"poe_front\"></td> </tr> </table> ### 组装完成 组装完成后的状态如下所示： ![assemble_ok](./assets/unbox/assemble_ok.png) ## 启动板卡 LicheePi 4A出库已预烧录了基础系统镜像，至此你已可以快速进行开机体验！ 注意：预烧录的系统镜像版本可能比较旧，体验不佳，完成上电体验后，可以根据下章教程进行镜像更新。 使用 HDMI 线缆(自备)连接显示器(自备)与 LicheePi 4A 的 HDMI 口，使用配套的 USB C 线缆连接到至少 5V2A 输出的 USB 电源(自备)上，LicheePi 4A 即会开机启动，默认镜像会在 30s 内启动到桌面系统的登录界面，或者自动使用sipeed账户登录到桌面。 ![boot_login](./assets/unbox/boot_login.png) 默认镜像的帐号密码配置如下： 账户：`debian`，密码： `debian`； 账户： `sipeed`，密码：`licheepi`； root 账户默认没有设置密码。 插入键鼠，输入用户名密码后即可登录体验，具体操作请查看后续章节。 如果按照上述操作，没能点亮显示器，进入系统，有以下可能请自查： 1. 检查电源电压是否正常，USB C 口连接是否正常，电源指示灯是否点亮 2. 检查散热器是否正常安装，风扇是否旋转 3. 检查 HDMI 是否稳固连接，显示器是否开机，以及可以尝试更换显示器测试 4. 也可能是出厂遗漏固件烧录，请按下章方法进行镜像烧录后再试 5. 如果以上均不奏效，请联系客服售后 ## 铝合金外壳安装说明 {#install_shell} ### 外壳配件概览 外壳配件应包含如下内容，如有缺失，请联系客服。 ![20230718_assemble_0](./assets/unbox/20230718_assemble_0.jpg) 从左到右分别是： 1. 3507涡轮风扇 2. 40x40x5mm 铝散热片 3. 小号十字螺丝刀 4. M3x5 平头螺丝 8颗 5. 外壳挡板x2 6. IPEX转SMA转接线 + SMA棒状天线 7. 30x30mm 导热硅脂片 8. 铝合金外壳x2 ### 安装散热片 1. 准备开发板 ![20230718_assemble_1](./assets/unbox/20230718_assemble_1.jpg) 2. 粘贴导热硅脂 ![20230718_assemble_2](./assets/unbox/20230718_assemble_2.jpg) 3. 按方向安装散热片 ![20230718_assemble_3](./assets/unbox/20230718_assemble_3.jpg) ### 安装盖板 1. 滑入开发板 ![20230718_assemble_4](./assets/unbox/20230718_assemble_4.jpg) 2. 安装天线到盖板 ![20230718_assemble_5](./assets/unbox/20230718_assemble_5.jpg) 3. 安装天线到PCB ![20230718_assemble_6](./assets/unbox/20230718_assemble_6.jpg) 4. 安装前盖板（2颗螺丝） ![20230718_assemble_7](./assets/unbox/20230718_assemble_7.jpg) 5. 撕开后盖板泡棉胶 ![20230718_assemble_8](./assets/unbox/20230718_assemble_8.jpg) 6. 安装后盖板（2颗螺丝） ![20230718_assemble_9](./assets/unbox/20230718_assemble_9.jpg) ### 安装风扇 1. 插入风扇电源线到板卡插针（上正下负），粘贴风扇到顶壳（注意风扇靠近外壳边缘粘贴，拉直连接线，否则会卡住外壳） ![20230718_assemble_10](./assets/unbox/20230718_assemble_10.jpg) 2. 从右侧小心向左侧盖住顶壳（务必注意方向，否则风扇插针会卡住） ![20230718_assemble_11](./assets/unbox/20230718_assemble_11.jpg) ### 安装剩余螺丝 ![20230718_assemble_12](./assets/unbox/20230718_assemble_12.jpg) ![20230718_assemble_13](./assets/unbox/20230718_assemble_13.jpg) ### 最终效果 ![last](./assets/unbox/last.png) ## POE模块安装说明 POE模块需要用户手工焊接安装，请按下图焊接： ![poe](./assets/unbox/poe.jpg) > 注意 POE模块焊接后无法装入铝合金外壳。 ## 板卡硬件说明 完成初次点亮板卡后，可以静下心来认识下 LicheePi 4A 的硬件，方便后期可能的维护工作。 ![pi_view](./assets/unbox/pi_view.png) ### 超频说明 TH1520 标称频率为 1.85GHz，我们仅保证你收到的板卡可以稳定工作在 1.85GHz。 如果你是发烧玩家，想进行超频操作，那么你有一定概率可以超频到 2GHz，但我们不保证在该频率下的稳定性。 经不完全测试，约有 80% 的 SOM 可以超频至 2GHz 启动系统，约有 50% 的 SOM 可以在 2GHz 下跑通压力测试。 ### USB 限流说明 由于系统最大电源输入能力为 12V2A，即约 24W，转换为 5V 后，大约有 20W 左右有效功率。 为了更好地为 SOM 供电（SOM 在超频满载情况下可达 12W 功率），所以 USB HUB 处进行了电流限制，限制了 1.5A 的电流（内测版硬件。正式版硬件会根据反馈调整此处电流限制），即 7.5W 功率。 再接入大量 USB 设备时可能会超出该电流限制，此时建议对 USB 设备进行外部辅助供电。 如果需要解除此处电流限制，请进行如下操作：TODO。 ### 正式版相对内测版差异说明 1. 新增USB C口输入处的高压保护，防止某些快充适配器输入高压烧毁SOM 2. 系统串口IO新增电平转换IC到3.3V，可以使用普通串口模块连接 3. 修复耳机，扬声器 自动切换电路 （内测版扬声器电路切换不到位而不稳定） 4. 耳机座中新增一路mic输入 5. 新增启动介质拨码开关（SOM底部），可选TF/eMMC启动 6. 其他细节丝印，元件微调 ### 硬件资料下载 [板卡规格书](https://dl.sipeed.com/shareURL/LICHEE/licheepi4a/01_Specification) [底板原理图](https://dl.sipeed.com/shareURL/LICHEE/licheepi4a/02_Schematic) [底板点位图](https://dl.sipeed.com/shareURL/LICHEE/licheepi4a/03_Bit_number_map) [底板尺寸图](https://dl.sipeed.com/shareURL/LICHEE/licheepi4a/04_Dimensional_drawing) [模型文件](https://dl.sipeed.com/shareURL/LICHEE/licheepi4a/05_3D_model) ## 其他链接 [Github](https://github.com/sipeed/LicheePi4A) [淘宝](https://item.taobao.com/item.htm?id 715508771884) [Sipeed 下载站](https://dl.sipeed.com/shareURL/LICHEE/licheepi4a) QQ群: 559614960 [点我自动加群](http://qm.qq.com/cgi bin/qm/qr?k 5YkapIhdtWHp8AEfM5_bFFYQIX3CUQN6) Telegram: https://t.me/linux4rv 论坛：bbs.sipeed.com 联系邮箱：support@sipeed.com"},"/hardware/zh/lichee/th1520/lpi4a/usage.html":{"title":"LicheePi 4A 基础上手","content":"# LicheePi 4A 基础上手 ## 需要的配件 为了更容易地使用 LicheePi 4A，需要准备以下的配件: HDMI 显示器，或者与 LicheePi 4A 拍套售卖的显示屏；图形化操作系统很方便操作。 键盘和鼠标；用来操作图形化系统。 电源适配器；最好购买与 LicheePi 4A 配套的电源适配器；这会给 LicheePi 4A 提供足够的供电。 ## 烧录系统 ### 获取镜像 百度网盘：[点我](https://pan.baidu.com/s/1jnjz0KO_xnO5R8tWlXtx0A) ### 烧录系统 烧录镜像需要使用 参考：https://gitee.com/thead yocto/light_deploy_images ## 串口登录 20230423 记录: > 当前图形化系统显示驱动有一些问题，先使用串口登录到系统后，删除 `/lib/libGLESv1_CM_PVR_MESA.so` 和`/lib/libGLESv2_PVR_MESA.so` 两个文件后，可以流畅的使用图形化系统了 使用串口连接上底板上 GPIO 的 `U0 RX` 和 `U0 TX`，然后打开串口软件，`Windows` 上可以使用 `mobaxterm`，`Linux` 系统可以使用 `minicom`。 设置波特率 `115200` 后打开选择并打开连接在电脑上的串口端口，然后在打开串口后的终端里可以敲击几次 **回车键** 来看看终端有没有反应. ![usage_serial_login_test](./assets/usage/usage_serial_login_test.png) 如果没有反应： 1. 检查 Lichee Pi 4A 的供电情况；如果底板 TypeC 附近的 LED 亮起来，说明供电正常。 2. 检查串口引脚接线情况；可以更换 `TX` 和 `RX` 接线来尝试排除串口接线错误导致串口不能正常通信的情况 3. 检查系统烧录情况；在底板 TypeC 接口与天线接口之间有一个复位按键，尝试按下后可以从串口终端中开到启动信息日志；多次重启说明系统有缺失，需要重新烧录镜像。 输入用户名 `sipeed`，密码 `licheepi` 就可以登录进系统了。 登录系统后，使用 `rm /lib/libGLESv1_CM_PVR_MESA.so` 和`rm /lib/libGLESv2_PVR_MESA.so` 命令来删除两处文件，暂时解决图形化系统卡顿的情况。 ![usage_login_remove_gpu_file](./assets/usage/usage_login_remove_gpu_file.png) ## 登录系统 将 Lichee Pi 4A 连接上显示器后，可以看到图形化交互界面了。 在登录界面，输入用户名 `sipeed`，密码 `licheepi` 就可以登录进系统了。 > 2023 年 4 月 25 日更新镜像的登录密码为 `licheepi` ![usage_login_userpasserward](./assets/usage/usage_login_userpasserward.png) ## 打开命令行 在 Lichee Pi 4A 的 Debian 图形化系统中，使用快捷键 `Ctrl` + `Alt` + `T` 三个组合键可以直接打开命令行终端，来快速方便地操作系统。 ![usage_debian_terminal_shell_hotkey](./assets/usage/usage_debian_terminal_shell_hotkey.png) ## 控制风扇 在 Lichee Pi 4A 上，风扇是通过 PWM 来控制的，使用 ## 连接网络 ### 连接有线网络 Lichee Pi 4A 由两个千兆网络接口；将已经接通网络的网线插入到 Lichee Pi 4A 的网络接口中节能实现连接有线网络了。 <table> <tr> <td>插上网线之前</td> <td>插上网线之后</td> </tr> <tr> <td><img src \"./assets/usage/usage_debian_ethernet_port_disconnect_one.png\" alt \"usage_debian_ethernet_port_connect_one\"></td> <td><img src \"./assets/usage/usage_debian_ethernet_port_connect_one.png\" alt \"usage_debian_ethernet_port_connect_one\"></td> </tr> <tr> <td colspan 2> 上面两张图对比可以看到：在接上网线前，系统中 <code>Ethernet Network</code> 下面显示着 <code>disconnected</code>, 接上网线后显示 <code>Wired connection </code></td> </tr> </table> ### 连接无线网络 Lichee Pi 4A 板载无线模组，支持蓝牙和 wifi 。 从状态栏中的 `Avaliable networks` 中查看自己想要连接到的无线网络，输入密码之后就自动连接上了。 <table> <tr> <td colspan 2><img src \"./assets/usage/usage_debian_select_wireless_network.png\" alt \"usage_debian_select_wireless_network\"></td> </tr> <tr> <td><img src \"./assets/usage/usage_debian_wireless_network_password.png\" alt \"usage_debian_wireless_network_password\"></td> <td><img src \"./assets/usage/usage_debian_wireless_network_connected.png\" alt \"usage_debian_wireless_network_connected\"></td> </tr> </table> 在输入密码的弹出窗口中，`Wi Fi adapter` 中的两个选项都能用来链接无线网络，选择一个即可。 <! ## 连接蓝牙 > ## 测试 USB 接口 使用桌面系统时，键盘鼠标正常使用就说明 USB 是正常的。 当然，只有命令行终端时，使用 `lsusb` 命令可以查看当前板卡上所连接的 USB 设备。 如下图，箭头所指的是已经接上 Lichee Pi 4A 的键盘。 ![usage_debian_lsusb_list_device](./assets/usage/usage_debian_lsusb_list_device.png) ## 挂载 U 盘 除了上面使用 `lsusb` 来查看 USB 接口的连接情况外，也可以使用 `dmesg` 命令来查看内核信息，进一步查看详细信息。 将一个 U 盘插入 Lichee Pi 4A 的 USB 口后，可以在命令终端窗口使用 `dmesg` 查看板卡硬件变动信息。 如下是连接 U 盘后，使用 `dmesg` 在命令行终端看到的最新信息（截取）。 ![usage_debian_udisk_dmesg](./assets/usage/usage_debian_udisk_dmesg.png) 上面的信息显示出了板卡的外设更改信息；从中可以看到有一个大容量 USB 存储设备连接到了 Lichee Pi 4A。 使用命令 `cat /proc/partitions grep \"sd*\"` 命令可以查看到 U 内部的分区个数 ![usage_debian_udisk_partition_detail](./assets/usage/usage_debian_udisk_partition_detail.png) 以上面的结果为例，其中 `sda` 指代的是整个 U 盘，`sda1` 和 `sda2` 表示的是 U 盘里面的两个分区。 先在桌面系统创建一个文件夹，然后使用 `mount` 命令将 U 盘的某一分区挂载到该文件夹下。 ```bash mkdir ~/Desktop/udisk # 在桌面创建一个名为 udisk 的文件夹 mount /dev/sda2 ~/Desktop/udisk # 挂载 U 盘的 sda2 分区到 udisk 文件夹 ``` <table> <tr> <td> 运行命令前 </td> <td> 运行命令后 </td> </tr> <tr> <td style \"white space:nowrap\"><img src \"./assets/usage/usage_debian_udisk_before_mount.png\" alt \"usage_debian_udisk_before_mount\"></td> <td style \"white space:nowrap\"><img src \"./assets/usage/usage_debian_udisk_after_mount.png\" alt \"usage_debian_udisk_after_mount\"></td> </tr> <tr> <td colspan 2> 运行命令后桌面新增了一个名为 udisk 的文件夹，使用鼠标双击打开 udisk 文件夹后可以看到文件夹里面的内容与 U 盘里面的实际内容一致 <img src \"./assets/usage/usage_debian_udisk_open_folder.png\" alt \"usage_debian_udisk_open_folder\"></td> </tr> </table> ## 挂载 TF 卡 将 tf 卡插入到 Lichee Pi 4A 底板，使用 ## 音频测试 ### 测试音频播放 Lichee Pi 4A 底板上有扬声器接口和 3.5mm 音频接口两处可以播放音频的地方。 要注意的是 3.5mm 音频接口和扬声器接口是互斥的：接上 3.5mm 音频设备后，板载的扬声器接口是被禁用的；断开 3.5mm 音频设备才能使用板载的扬声器。 系统内置了一些 wav 音频文件用来测试，直接使用 `aplay` 命令来播放音频文件就可以。 ![usage_debian_list_audio_file](./assets/usage/usage_debian_list_audio_file.png) 运行下面的命令后，可以从耳机孔音频设备中听到 `Rear` `Left` 两个单词的声音。 ```bash aplay /usr/share/sounds/alsa/Rear_Left.wav ``` ## 设置中文显示 ## 安装中文输入法 ## 更换软件源 在 Debian 系统中，可以使用 apt (Advanced Packaging Tool) 来进行软件的安装。 安装软件的时候，会从系统指定的软件网站中搜索并下载目标软件，当目标网站访问困难（比如服务器距离太远或者服务器网络不佳）时，可以手动设置编辑软件源网站，改成距离自己当前最近的源，来减少下载时间。 软件源默认使用 `/etc/apt/sources.list` 文件里面的内容，有额外需要的话可以自行更改。但是要注意需要使用支持 Risc V 架构的软件源。 ![usage_debian_apt_change_source](./assets/usage/usage_debian_apt_change_source.png) ## 升级软件 使用 `sudo apt update` 可以更新软件列表，一般在更换软件源之后需要使用这个命令。 然后使用 `sudo apt upgrade package_name` 可以更新名称为 `package_name` 的软件。 比如下面是使用 `sudo apt upgrade vim` 来更新 `vim` 这个软件的示例 ![usage_debian_apt_upgrade_vim](./assets/usage/usage_debian_apt_upgrade_vim.png) ## 安装程序 可以借助于 apt 命令来安装软件；比如使用 `sudo apt install package_name` 命令来安装 `package_name`，下面是使用 apt 来安装 `net tools` 的例子。 ![usage_debian_apt_install_nettools](./assets/usage/usage_debian_apt_install_nettools.png) 安装 `net tools` 后，就可以使用 `ifconfig` 命令了。 ![usage_debian_ifconfig_result_list](./assets/usage/usage_debian_ifconfig_result_list.png) 箭头指向的地方就是常说的 IP 地址了。 ## 更改开机 LOGO ## 操作 GPIO > 进阶使用 ## 获取设备 IP ## VNC 远程桌面 ## 通过 SSH 登录到系统 ### 远程登录到系统 ### 远程拷贝文件 ## Samba 文件共享 Samba 基于SMB/CIFS网络协议，不同设备之间可以通过该协议共享访问文件、串行端口等，这里通过它将 Windows 10 系统设备上的共享文件夹挂载至 Lichee Pi 4A。 下面的命令会自动安装 Samba 作为服务器和客户端的全部必需组件： ```bash sudo apt install samba samba common bin smbclient cifs utils ``` ## 搭建 FTP 服务 ## 配置 NGINX ## 安装 Docker ## 测试 GPU ## 编程语言体验 ### C ### Java ### Python ## 使用 Python 进行串口通信 ## 编译体验 Opencv ## 编译体验 Wiringpi ## 配置开机脚本 ### 开机自动挂载 U 盘"},"/hardware/zh/lichee/th1520/lpi4a/7_develop_android.html":{"title":"RISC-V Android","content":" title: RISC V Android keywords: Linux, Lichee, TH1520, SBC, RISCV, Kernel, SDK, Develop update: date: 2023 07 27 version: v1.1 author: ztd content: Update docs date: 2023 05 08 version: v1.0 author: wonder content: Release docs ## Android [项目地址](https://gitee.com/thead android/thead android) 本项目为安卓开源项目(AOSP)支持的仓库，其中包含了 LPi4A 发板的板级配置、外设HAL 层、内核、u boot 和预编译组件支持，其余组件则可直接从上游 AOSP 仓库拉取。 ### 注意事项 **此文档所使用的镜像功能并不完善，编译后只支持HDMI显示、有线网等基础功能，触摸屏、USB外设暂未支持。预计十月更新功能较完善的SDK、文档资料。** ### 快速上手 在下载安卓开源项目源代码之前，请检查您的工作环境，建议使用具有至少 250G 空闲磁盘空间、16GB+ 内存的 Linux 系统(推荐使用 Ubuntu 20.04 以上版本)的工作环境， 编译时间和主机的处理器核心数有关，建议使用有较多核心的主机。且由于网络原因，下载时间根据网络情况会有很大差别，推荐使用代理下载源码。 > 以下数据供参考： > 使用 E5 2699 CPU，内存 377GB 的机器编译，编译时间约为2小时（在Ubuntu22.04的docker环境下）。下载源码的时间约为3小时。 将安卓开源项目(主线版本)和开发板支持源代码下载到工作目录,使用固定版本上游代码: ```shell mkdir riscv android src && cd riscv android src repo init u https://gitee.com/thead android/local_manifests.git b main_2023_7_7 git clone https://gitee.com/thead android/local_manifests.git .repo/local_manifests b thead android community repo sync ``` 使用最新版本上游代码，可能会由于兼容性导致一些编译问题: ```shell mkdir riscv android src && cd riscv android src repo init u https://android.googlesource.com/platform/manifest b master git clone https://gitee.com/thead android/local_manifests.git .repo/local_manifests b thead android community repo sync ``` ### 编译源码 下载完成后，先安装一些编译会用到的依赖： ```shell sudo apt get install git core gnupg flex bison build essential zip curl zlib1g dev gcc multilib g++ multilib libc6 dev i386 libncurses5 lib32ncurses5 dev x11proto core dev libx11 dev lib32z1 dev libgl1 mesa dev libxml2 utils xsltproc unzip fontconfig python3 bc cpio rsync wget ``` 然后可以通过以下命令对系统进行构建： ```shell source build/envsetup.sh lunch lichee_pi_4a userdebug m j ``` 编译完成后，检查生成的文件： ```shell $ ls out/target/product/lichee_pi_4a/*img out/target/product/lichee_pi_4a/boot.img out/target/product/lichee_pi_4a/super_empty.img out/target/product/lichee_pi_4a/vendor_boot debug.img out/target/product/lichee_pi_4a/cache.img out/target/product/lichee_pi_4a/system.img out/target/product/lichee_pi_4a/vendor_boot test harness.img out/target/product/lichee_pi_4a/dtb.img out/target/product/lichee_pi_4a/system_ext.img out/target/product/lichee_pi_4a/vendor_boot.img out/target/product/lichee_pi_4a/dtbo unsigned.img out/target/product/lichee_pi_4a/userdata.img out/target/product/lichee_pi_4a/vendor_ramdisk debug.img out/target/product/lichee_pi_4a/dtbo.img out/target/product/lichee_pi_4a/vbmeta.img out/target/product/lichee_pi_4a/vendor_ramdisk test harness.img out/target/product/lichee_pi_4a/product.img out/target/product/lichee_pi_4a/vbmeta_system.img out/target/product/lichee_pi_4a/vendor_ramdisk.img out/target/product/lichee_pi_4a/ramdisk.img out/target/product/lichee_pi_4a/vendor bootconfig.img out/target/product/lichee_pi_4a/super.img out/target/product/lichee_pi_4a/vendor.img ``` ### 烧录至 LPi4A 开发板 使用fastboot对系统镜像进行烧写，adb和fastboot工具请使用从这里下载的版本： https://developer.android.com/tools/releases/platform tools 将需要烧录的文件拷贝到 fastboot 工具所在目录下，供fastboot使用： ```shell cp bootpart.ext4 boot.img super.img userdata.img vbmeta.img vbmeta_system.img vendor_boot.img <path_to_fastboot> ``` 开发板使用主要需要连接电源、串口、USB 和显示： 串口主要用于 U boot 和内核中的命令交互，可通过底板上 GPIO 的 U0 RX 和 U0 TX 连接，波特率为115200。USB Device 接口主要用于fastboot和adb工具的连接 MIPI DSI/HDMI 接口可以使用于连接屏幕显示 UI 界面。 对系统进行完整烧写需要按住开发板的boot按键同时按复位键进入boot烧写模式。使用刚刚下载下来的 fastboot 烧写： ```shell #烧录uboot并初始化boot环境变量 fastboot flash ram u boot with spl.bin fastboot reboot fastboot flash uboot u boot with spl.bin #烧录各个分区 #在非boot烧写模式，可以在uboot的命令行中输入命令fastboot usb 0，单独烧录分区 fastboot flash bootpart bootpart.ext4 fastboot flash boot boot.img fastboot flash vendor_boot vendor_boot.img fastboot flash super super.img fastboot flash userdata userdata.img fastboot flash vbmeta vbmeta.img fastboot flash vbmeta_system vbmeta_system.img #初始化metadata和misc分区 fastboot erase metadata fastboot erase misc ``` 典型烧录 log 如下： ```shell < waiting for any device > Sending 'ram' (982 KB) OKAY [ 0.261s] Writing 'ram' OKAY [ 0.002s] Finished. Total time: 0.268s Rebooting OKAY [ 0.001s] Finished. Total time: 0.402s < waiting for any device > Sending 'uboot' (982 KB) OKAY [ 0.044s] Writing 'uboot' OKAY [ 0.077s] Finished. Total time: 0.158s Sending 'bootpart' (8192 KB) OKAY [ 0.217s] Writing 'bootpart' OKAY [ 0.071s] Finished. Total time: 0.316s Warning: skip copying boot_a image avb footer (boot_a partition size: 65536, boot_a image size: 33554432). Sending 'boot_a' (32768 KB) OKAY [ 0.825s] Writing 'boot_a' OKAY [ 0.255s] Finished. Total time: 1.116s Sending 'vendor_boot_a' (32768 KB) OKAY [ 0.824s] Writing 'vendor_boot_a' OKAY [ 0.254s] Finished. Total time: 1.107s Sending sparse 'super' 1/9 (114684 KB) OKAY [ 2.872s] Writing 'super' OKAY [ 0.855s] Sending sparse 'super' 2/9 (114336 KB) OKAY [ 2.849s] Writing 'super' OKAY [ 0.880s] Sending sparse 'super' 3/9 (114684 KB) OKAY [ 2.947s] Writing 'super' OKAY [ 0.857s] Sending sparse 'super' 4/9 (114684 KB) OKAY [ 2.921s] Writing 'super' OKAY [ 0.862s] Sending sparse 'super' 5/9 (114684 KB) OKAY [ 2.875s] Writing 'super' OKAY [ 0.904s] Sending sparse 'super' 6/9 (110208 KB) OKAY [ 2.794s] Writing 'super' OKAY [ 0.859s] Sending sparse 'super' 7/9 (106652 KB) OKAY [ 2.679s] Writing 'super' OKAY [ 0.853s] Sending sparse 'super' 8/9 (109509 KB) OKAY [ 2.754s] Writing 'super' OKAY [ 2.400s] Sending sparse 'super' 9/9 (88872 KB) OKAY [ 2.251s] Writing 'super' OKAY [ 0.707s] Finished. Total time: 34.231s Sending 'userdata' (2652 KB) OKAY [ 0.085s] Writing 'userdata' OKAY [ 0.581s] Finished. Total time: 0.706s Sending 'vbmeta_a' (8 KB) OKAY [ 0.019s] Writing 'vbmeta_a' OKAY [ 0.021s] Finished. Total time: 0.078s Sending 'vbmeta_system_a' (4 KB) OKAY [ 0.019s] Writing 'vbmeta_system_a' OKAY [ 0.023s] Finished. Total time: 0.079s Erasing 'metadata' OKAY [ 0.087s] Finished. Total time: 0.132s Erasing 'misc' OKAY [ 0.029s] Finished. Total time: 0.071s ``` 当完成烧写后重新复位上电进入系统启动模式,可以通过串口/ADB访问系统的命令行，并可通过触屏或外接HDMI显示系统图像界面进行交互： ![licheepi4a_aosp](./assets/develop_android/licheepi4a_aosp.png) ### 常见问题 下载源码时，若运行 `repo init u https://gitee.com/thead android/local_manifests.git b main_2023_7_7` 命令始终不成功，可以尝试运行以下命令后，再进行 repo init ： ```shell export REPO_URL 'https://mirrors.tuna.tsinghua.edu.cn/git/git repo/' ``` 使用 docker 环境编译时，可能会遇到如下报错： ```shell Build sandboxing disabled due to nsjail error. ``` 这个报错可以暂时忽略，不影响后面的编译步骤。若想运行 nsjail，可以尝试升级内核版本至5.XX或者启动 docker 时传入这些参数 ` security opt apparmor unconfined security opt seccomp unconfined security opt systempaths unconfined` 或 ` privileged`。"},"/hardware/zh/lichee/th1520/lpi4a/7_develop_thead.html":{"title":"Yocto Linux","content":" title: Yocto Linux keywords: Linux, Lichee, TH1520, SBC, RISCV, Kernel, SDK, Develop update: date: 2023 07 17 version: v1.2 author: ztd content: Update docs date: 2023 05 12 version: v1.1 author: wonder content: Depart docs date: 2023 05 08 version: v1.0 author: wonder content: Release docs TH1520 的官方开发环境是平头哥的基于 yocto 的开发环境，大家可以在这里获取开发环境： https://gitee.com/thead yocto/ 本节简单介绍如何搭建 Linux Yocto 环境并使用 Yocto 构建可在开发板上运行的完整镜像。 **建议机器配置：内存64G以上，磁盘空间250G以上，编译时间因网络情况差异很大，在使用代理的情况下编译典型 linux 系统配置（最小系统加上必要的相关基础组件）时间约为8小时（CPU 为 i5 11400，时间供参考）** **不推荐没有 Yocto 使用经验的用户使用此 SDK** ## 搭建Yocto编译环境 Linux SDK 使用 Yocto 构建镜像。Yocto 编译环境使用 Ubuntu18.04，推荐在 Linux 上使用 Docker 部署,也可直接在 Ubuntu18.04 下搭建环境（见[T Head曳影1520Yocto用户指南.pdf](https://gitee.com/thead yocto/documents/blob/master/zh/user_guide/T Head%E6%9B%B3%E5%BD%B11520Yocto%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf)2.2）。 这里仅介绍 Linux 上使用 Docker 部署的方式。 使用官方脚本安装 docker \t```bash \tcurl fsSL https://get.docker.com bash s docker mirror Aliyun \t``` 下载 dockerfile 并修改用户名和 ID \t点击下载 [linux dev master.7z](https://gitee.com/thead yocto/documents/blob/master/linux dev master.7z) 并解压后，进入到 `linux dev master` 目录，打开 `Dockerfile`，找到如下语句 \t```bash \tENV DOCKER_USER2 \"your the same user name asyour host\"` \tENV USER2_ID \"your user id\" \t``` \t将 \"your the same user name asyour host\" 改为用户 host os 的用户名，\"your user id\" 的值填写一个纯数值，代表uid，可以填写为100。 构建 docker 镜像环境 \t```bash \tdocker build t linux dev base:base . \t``` \t构建时若遇到如下报错： \t```shell \tDockerfile:183 \t \t182 # install npm \t183 >>> RUN cd $WORK_PATH \\ \t184 >>> && curl fsSL https://deb.nodesource.com/setup_lts.x bash \\ \t185 >>> && apt install y nodejs yarn \\ \t186 >>> && npm install aiot vue cli g \t187 \t \tERROR: failed to solve: process \"/bin/sh c cd $WORK_PATH && curl fsSL https://deb.nodesource.com/setup_lts.x bash && apt install y nodejs yarn && npm install aiot vue cli g\" did not complete successfully: exit code: 100 \t``` \t \t则注释 Dockerfile 中 182 186 行： \t```shell \t# install npm \t#RUN cd $WORK_PATH \\ \t# && curl fsSL https://deb.nodesource.com/setup_lts.x bash \\ \t# && apt install y nodejs yarn \\ \t# && npm install aiot vue cli g \t``` \t再执行 \t```shell \tdocker build t linux dev base:base . \t``` \t \t容器安装完毕后，进入容器，再执行如下命令: \t```shell \tsudo apt update \tsudo apt install npm \tsudo apt install nodejs \t``` \t最后执行: \t```shell \tnpm v \tnodejs v \t``` \t有相关版本号输出即可。 \t该 docker 镜像可以编译 thead 发布的 buildroot、yocto 等 Linux SDK。用户 `thead` 默认密码为 `123`。 启动 docker \t```bash \tdocker run u thead dt name linux dev {your_name} v {your_lock_home}:{your_home} linux dev base:base /bin/bash \t``` \t{your_name} 为容器名称，起名时不要重名。 \t通过 v 选项可以挂载宿主机的目录，起到类似共享文件的作用，{your_lock_home} 为宿主机的本地路径，{your_home} 为挂载在 docker 里的路径。 查看启动的 docker 容器 \t```bash \tdocker ps grep linux dev base \t``` 就能够看到刚刚启动的 docker 容器。 登录 docker \t```bash \tdocker exec it linux dev {your_name} /bin/bash \t``` 下载开源软件包（仅在第一次获取 SDK 时才需要下载） \t构建固件时会从网上下载开源软件包，若网络较差，下载时间会比较长。为了加速这一过程，可以先到 gitee 下载离线开源软件包（假设下载到用户目录） \t```bash \tcd ~ \tgit clone https://gitee.com/thead yocto/yocto downloads.git \t``` 下载 Yocto 构建包 \t```bash \tgit clone https://gitee.com/thead yocto/xuantie yocto.git b Linux_SDK_V1.1.2 \t``` 加载目标设备的配置文件和环境变量（编译前记得检查是否加载） \t```bash \tcd xuantie yocto \tsource openembedded core/oe init build env thead build/light fm \t``` 将前面下载的开源软件包通过共享 downloads 目录的方式软链接到 SDK 目录 \t```bash \tln s ~/yocto downloads ../downloads \t``` 使用 patch 由于写文档时 xuantie yocto 的 commit d296c2345fe2c2521eb0e1a2772bcba637029bc8 还未合并下述 patch 中的改动，所以需要手动打 patch 来同步这些改动再进行后续开发。patch 文件请在[下载站](https://dl.sipeed.com/shareURL/LICHEE/licheepi4a/06_Patch)下载，请使用最新版本的patch 压缩包。 ### xuantie yocto 的 patch 0001 Allow download without logging in gitee.patch 允许在没有登录的情况下拉取 gitee仓库 使用方法： 在 xuantie yocto 路径下使用 patch ### kernel 的 patch 0001 pca9557.patch 使用 pca9557 替换 pcal9554 扩展芯片 0002 cpufreq to 2GHz.patch 修改电压频率表与 cpu_freq 驱动，调整频率上限到 2GHz 0003 remove audio pcal9554b.patch 删除一路 i2c 扩展芯片与 lpi4a 的改动同步 0004 sync audio patch.patch 同步音频设备改动 0005 8G ddr.patch 调整内存地址范围以支持 8G DRAM 0006 set cpu_max_frq 1.992GHz.patch 根据用户手册提供的频点调整频率(约有2成不能在该频率下稳定工作) 0007 set cpu_max_frq 1.848GHz.patch 所有1520能通过压力测试的频率 0012 riscv dts thead lpi4a add PWM Fan.patch 增加 PWM 风扇支持 0016 drm dc8200 disable gamma lut now.patch 失能 gamma lut，解决依赖问题 0017 drm verisilicon fix fbcon.patch 修复 fbcon 0018 riscv dts thead lpi4a change fan PWM frequency.patch 修改PWM频率参数，改善风扇噪声问题 0019 add mipi screec and touch support.patch 添加 mipi 720p 屏幕和触摸屏驱动支持 0020 add hdmi audio support.patch 添加 HDMI 音频驱动支持 0021 enable pwm fan.patch 使能 PWM 风扇 0022 add mipi camera ov5693 support.patch 添加 OV5693 摄像头设备树支持 使用方法： 注意：使用先需要构建一次固件，否则 xuantie yocto/thead build/light fm/tmp glibc 路径不存在 在 xuantie yocto/thead build/light fm/tmp glibc/work/light_lpi4a oe linux/linux thead/5.10.y r0/linux 5.10.y路径下使用 patch ### opensbi 的 patch 0001 lib sbi_illegal_insn Add emulation for fence.tso.patch 0002 lib sbi_illegal_insn Fix FENCE.TSO emulation infinit.patch 以上两个patch模拟实现 fence.tso 指令，修复llvm崩溃问题 使用方法： 注意：使用先需要构建一次固件，否则 xuantie yocto/thead build/light fm/tmp glibc 路径不存在 在 xuantie yocto/thead build/light fm/tmp glibc/work/light_lpi4a oe linux/opensbi/0.9 r0/git 下使用 patch ### uboot 的 patch 0001 ENV_SETTINGS.patch 删除第4 6个分区，为 rootfs 预留足够的空间，使用 systemd 启动系统; 0002 fix fix bootargs.patch 修复设置启动参数命令 0003 fix ftbfs.patch 修复 ftbfs 中的变量定义问题，更改后编译不会报错 使用方法： 注意：使用先需要构建一次固件，否则 xuantie yocto/thead build/light fm/tmp glibc 路径不存在 在 xuantie yocto/thead build/light fm/tmp glibc/work/light_lpi4a oe linux/u boot/1_2020.10 r0/git路径下使用 patch ### vi sensor 的 patch 0001 add OV5693 support.patch 添加OV5693摄像头驱动支持 使用方法： 注意：使用先需要构建一次固件，否则 xuantie yocto/thead build/light fm/tmp glibc 路径不存在 在 xuantie yocto/thead build/light fm/tmp glibc/work/riscv64 oe linux/vi sensor/1.0 r0/git 路径下使用patch ### roofs 的 patch bluetooth_fix.zip 修复蓝牙无法正常使用的问题，使用方法见压缩包内 readme.txt 至此，编译环境已经配置完成。 ## Machine/Target支持列表 在上面的加载环境变量步骤中，设置完成后可看到以下信息 ```bash ### Shell environment set up for builds. ### You can now run 'bitbake <target>' Common targets are: thead image linux thead image multimedia thead image gui machines: light beagle light b product light a val light lpi4a ``` 相关说明如下 target（SDK 支持的镜像列表）： 命名描述 thead image linux典型linux系统配置，最小系统加上必要的相关基础组件 thead image multimedia典型linux系统+视频视觉配置，加上视频子系统的组件（Gstreamer等） thead image gui加上GUI相关组件的完整配置版本，包括Gnome桌面、weston、QT等应用组件等等 **目前 thead image gui 选项编译出来的 GUI 相关组件仅用于功能性验证，进入不了图形化桌面** machines（SDK 支持的板级配置）： 命名描述 light a valTH1520 A EVB板 light b productTH1520 B EVB板 light beaglebeagleV Ahead开发板 light lpi4aLichee Pi 4A开发板 ## 构建镜像 构建命令格式如下： ```bash MACHINE {machine} bitbake {target} ``` 将其中的 {machine} 和 {target} 部分替换为上面两个表格中对应的命名即可。例如，编译一个在 LicheePi 4A 开发板上运行的典型 Linux 镜像的命令如下： ```bash MACHINE light lpi4a bitbake thead image linux ``` ### 构建镜像时可能会出现的问题 由于网络原因，这一步可能仍会出现下载失败或下载很慢的情况，有条件的话推荐使用代理。 报错信息 \t```bash \tPlease use a locale setting which supports utf 8. \tPython can't change the filesystem locale after loading so we need a utf 8 when python starts or things won't work. \t``` \t首先运行如下命令 \t```bash \tsudo apt get install locales \tsudo dpkg reconfigure locales \t``` \t然后在打印出来的列表中找到`en_US.UTF8`这一项（大概在第158项）,输入这一项对应的序号后回车，接下来也选择这一项后回车。 \t完成上述设置步骤后接着运行如下命令（也可考虑将下面的命令加入到docker的`.bashrc`中） \t```bash \tsudo locale gen en_US.UTF 8 \tsudo update locale LC_ALL en_US.UTF 8 LANG en_US.UTF 8 \texport LANG en_US.UTF 8 \t``` \t完成上述步骤后再编译就不会出现原来的报错。 报错信息 \t```bash \tplease install them in order to proceed: lz4c pzstd zstd \t``` \t安装对应的依赖即可 \t```bash \tsudo apt update && sudo apt install y zstd liblz4 tool \t``` ### 镜像打包 在 [light_deploy_images](https://gitee.com/thead yocto/light_deploy_images/tree/master/tarball) 仓库中，包含了一些预发布镜像。对于刚刚编译好的镜像，可以利用这个仓库中的 `sdk.sh` 脚本来进行打包。 首先切换到已经编译好的镜像中的 `light fm` 目录下，将该仓库中的 `sdk.sh` 移动到这里即可。直接运行该脚本 `./sdk.sh` 即可，打包后会生成相应的镜像，相应文件的位置以及镜像目录的结构参考 [light_deploy_images](https://gitee.com/thead yocto/light_deploy_images/tree/master/tarball) 仓库。 最后，可以将 docker 编译好的镜像及相关文件复制到先前通过 v 选项挂载的共享文件夹中，宿主机即可使用该文件进行烧录。 到这里，我们已经完成了编译和打包，得到了一个可以烧录到开发板中运行的镜像。 **使用该镜像时，需要手动到 uboot 中利用环境变量设置一个 MAC 地址，参考命令如下** ```shell # 将下列两个地址替换为你的 MAC 地址，eth1addr 的值为ethaddr 的值+1 setenv ethaddr XX:XX:XX:XX:XX:XX setenv eth1addr XX:XX:XX:XX:XX:XX env save ``` 简单介绍yocto中的常用概念和一些实用技巧。 ### 基础概念 Yocto用来构建定制的Linux镜像，有广泛的硬件支持，它是一个集合了很多工具的开源项目。 先对Yocto在构建镜像时的大致工作流程简单介绍： Fetch >Extract >Patch >Configure >Build >Install >Package Fetch：在编译时获取需要的源码。 Extract：对获取到的源码进行解压。 Patch：应用补丁以修复bug和添加新功能。 Configure：配置开发环境。 Build：构建镜像，编译链接。 Install：拷贝文件到目标目录。 Package：镜像打包。 下图展示了流程中的一些具体步骤： ![yocto_flows](./assets/develop_thead/yocto_flows.png) Yocto project的大概构成如下图，构建所用到的主要是OpenEmbedded构建系统（下文用OE简称），它的核心是任务执行器Bitbake。 ![yocto_structure](./assets/develop_thead/yocto_structure.png) 常用到的一些概念如下： recipes：以`.bb`结尾的文件，里面会包含下载软件包时需要的相关信息，如下载固定源码的文件位置，需要应用到该软件包的patch信息,编译需要的信息等。例如`xuantie yocto`的中的`gnome shell`，它的recipes文件存储在`/home/thead/xuantie yocto/meta openembedded/meta gnome/recipes gnome/gnome shell`目录下。 build directory：该目录即为构建时的输出目录，同时也会存放一些环境配置文件，`source`命令指定编译环境时就会生成该目录，默认命名为`build`，也可在`source`时更改为其他名字，如`sourece oe init build env mybuild`。 configurations：以`.conf`结尾的文件，主要是配置文件。比如存储在`build directory`的`conf`目录中的`local.conf`，在编译时可能会在根据需要更改其中一些参数。 layers：通常会在这里存储所需要的各种metadata(如，`.bb`文件，`patches`和一些其他的附加文件)，主要是用于告诉OE构建系统如何构建目标文件。将metadata按层分类有助于项目维护。 bitbake：OE构建系统中用来执行各种任务的任务执行器。 ## 常用操作 ### 常用task Yocto以package为单位管理开源软件组件，如需要编译某个package，方法如下： ```shell bitbake \"package name\" ``` 每个package都在recipes文件中定义支持的task，有些task如clean，是所有包通用的，可以用一下命令列出package支持的task： ```shell bitbake \"package name\" c listtasks ``` ### 查找编译后package的位置 Yocto集成了大量开源的package，这些 package 编译的时候的工作目录通常在以下目录： tmp glibc/work/riscv64 oe linux tmp glibc/work/${MACHINE} 例如 ```shell thead@b9461db16a58:~/xuantie yocto/thead build/light fm/tmp glibc/work/light_lpi4a oe linux/u boot$ tree L 2 . └── 1_2020.10 r0 ├── 0001 no strip fw_printenv.patch ├── build ├── deploy debs ``` 可以通过`bitbake e linux thead grep ^S `命令查找package目录。例如，查看内核的编译目录 ```shell $ bitbake e linux thead grep ^S S \"/home/thead/xuantie yocto/thead build/light fm/tmp glibc/work/light_a_val oe linux/linux thead/5.10.y r0/linux 5.10.y\" ``` 编译完成后文件输出的位置，例如，镜像编译完成后相关的各类文件都位于`light fm/tmp/glibc/work/light_lpi4a oe linux`下，例如镜像就位于该目录的`linux thead`下，最后只需要打包即可。 ### 编译时fetch包的速度过慢 在编译时，可能会遇到fetch包过慢问题，这是除了使用代理，也可以将包下载到本地，然后根据得到的包地址让fetch时直接使用本地的repo。例如： ```shell WARNING: bzip2 native 1.0.8 r0 do_fetch: Failed to fetch URL git://sourceware.org/git/bzip2 tests.git;name bzip2 tests;branch master, attempting MIRRORS if available ``` 那么可以使用如下命令找到包的下载地址 ```shell $ bitbake e bzip2 grep ^SRC_URI SRC_URI \"https://sourceware.org/pub/bzip2/bzip2 1.0.8.tar.gz git://sourceware.org/git/bzip2 tests.git;name bzip2 tests;branch master file://configure.ac;subdir bzip2 1.0.8 file://Makefile.am;subdir bzip2 1.0.8 file://run ptest \" ``` 得到地址后，手动将该仓库`clone`下来，然后找到它对应的`.bb`文件 ```shell $ find name bzip*.bb ./openembedded core/meta/recipes extended/bzip2/bzip2_1.0.8.bb ``` 在该文件中找到`SRC_URI`这一项 ```shell SRC_URI \"https://sourceware.org/pub/${BPN}/${BPN} ${PV}.tar.gz \\ git://sourceware.org/git/bzip2 tests.git;protocol file;name bzip2 tests;branch master \\ file://configure.ac;subdir ${BP} \\ file://Makefile.am;subdir ${BP} \\ file://run ptest \\ \" ``` 加上`protocol`指定为`file`，若需要切换分支，直接在`clone`下来的本地repo中`checkout`到对应的分支即可，修改好后，直接fetch这个包即可。 ```shell bitbake bzip2 c fetch ``` 若编译速度过慢，找到`build_directory`的`conf`目录下的`local.conf`文件，修改相应的参数即可，参考[此文档](https://docs.yoctoproject.org/dev manual/speeding up build.html?highlight bb_numbers)，例如，增加下载和编译时的速度，可以在文件中增加如下代码，将并行数量调大（注意根据CPU具体参数来） ``` BB_NUMBER_THREADS '16' PARALLEL_MAKE ' j 12' ``` yocto编译后对package有缓存机制，可以在后面编译时减少所花费的时间。 除此之外，也可在编译前提前下载好一些包，放入某个文件夹，然后在`build_directory`的`conf`文件夹的`local.conf`找到`DL_DIR`这一项，这就是共享文件夹，更改到指定目录或软链接共享即可。 ### 单独构建u boot 在编译时将源码下载到`light fm/tmp glibc/work/light_lpi4a oe linux/u boot/1_2020.10 r0/git`路径下（倒数第二级目录名为版本号），修改源码后执行该命令即可： ```shell bitbake u boot C compile ``` ### 单独构建opensbi 在编译时将源码下载到`light fm/tmp glibc/work/light_lpi4a oe linux/opensbi/0.9 r0/git`路径下，修改源码后执行该命令即可： ```shell bitbake opensbi C compile ``` 编译完成后，为了简化打包流程，在`light_deploy_images`提供了打包脚本`sdk.sh`。编译完成后，在`light fm`文件夹下创建一个`sdk`文件夹，将该镜像打包脚本下载到该文件夹下，运行即可。 打包后典型的目录结构应如下所示： ```shell . ├── deb │   ├── all │   ├── light_lpi4a │   └── riscv64 ├── images │   └── light lpi4a │   ├── boot.ext4 │   ├── light_fastboot_image_single_rank │   │   └── u boot with spl.bin │   ├── rootfs.thead image linux.ext4 │   └── vmlinux ├── sdk.sh └── tarball └── prebuild_light lpi4a.tar.gz ``` 烧录时主要是用`images`目录下的文件，如果少了哪个文件，也可以手动复制进去。`tarball`目录下为打包好的镜像文件的压缩包，`deb`目录下为软件包。 参考： [bitbake官方文档](https://docs.yoctoproject.org/bitbake.html?highlight bitbake) [yocto官方文档](https://docs.yoctoproject.org/overview manual/yp intro.html) [T Head 曳影 1520 Yocto 用户指南](https://gitee.com/thead yocto/documents/raw/master/zh/user_guide/T Head%E6%9B%B3%E5%BD%B11520Yocto%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97.pdf) ## 设备树解析 TODO ## 其他参考资料 **light_deploy_images 仓库：** 包含已经构建好可烧录的 Linux Image，打包镜像脚本以及其他相关工具，详见仓库。 仓库地址：[https://gitee.com/thead yocto/light_deploy_images](https://gitee.com/thead yocto/light_deploy_images) **documents 仓库：** 包含所有发布的 SDK 相关文档 仓库地址：[https://gitee.com/thead yocto/documents](https://gitee.com/thead yocto/documents) 欢迎投稿～ 投稿接受后可得￥5～150（$1~20）优惠券！"},"/hardware/zh/lichee/th1520/lpi4a/5_desktop.html":{"title":"桌面系统基础使用","content":" title: 桌面系统基础使用 keywords: Linux, Lichee, TH1520, SBC, RISCV, Debian, Desktop update: date: 2023 07 17 version: v1.1 author: ztd content: Update docs date: 2023 05 08 version: v1.0 author: wonder content: Release docs ## 登录系统 本篇文档以默认的 Debian 桌面系统为例，介绍基础系统使用操作。 将 LicheePi 4A 连接上显示器后，可以看到图形化交互界面了。 在登录界面，输入用户名 `sipeed`，密码 `licheepi` 就可以登录进系统了。 > 总共有三个用户，`root`，`debian`，`sipeed`，初始密码均为`licheepi` > 有些版本的`debian`用户的密码为`sipeed` **0714及以后版本的镜像，默认开启了自动登录，自动登录的用户为 `sipeed`** ![usage_login_userpasserward](./assets/desktop/usage_login_userpasserward.png) ## 打开命令行 在 LicheePi 4A 的 Debian 图形化系统中，使用快捷键 `Ctrl` + `Alt` + `T` 三个组合键可以直接打开命令行终端，来快速方便地操作系统。 **0714及以后版本的镜像，默认开启了免密码`sudo`** ![usage_debian_terminal_shell_hotkey](./assets/desktop/usage_debian_terminal_shell_hotkey.png) ## 连接网络 ### 连接有线网络 LicheePi 4A 由两个千兆网络接口；将已经接通网络的网线插入到 LicheePi 4A 的网络接口中节能实现连接有线网络了。 <table> <tr> <td>插上网线之前</td> <td>插上网线之后</td> </tr> <tr> <td><img src \"./assets/desktop/usage_debian_ethernet_port_disconnect_one.png\" alt \"usage_debian_ethernet_port_connect_one\"></td> <td><img src \"./assets/desktop/usage_debian_ethernet_port_connect_one.png\" alt \"usage_debian_ethernet_port_connect_one\"></td> </tr> <tr> <td colspan 2> 上面两张图对比可以看到：在接上网线前，系统中 <code>Ethernet Network</code> 下面显示着 <code>disconnected</code>, 接上网线后显示 <code>Wired connection </code></td> </tr> </table> ### 连接无线网络 LicheePi 4A 板载无线模组，支持蓝牙和 wifi 。 从状态栏中的 `Avaliable networks` 中查看自己想要连接到的无线网络，输入密码之后就自动连接上了。 <table> <tr> <td colspan 2><img src \"./assets/desktop/usage_debian_select_wireless_network.png\" alt \"usage_debian_select_wireless_network\"></td> </tr> <tr> <td><img src \"./assets/desktop/usage_debian_wireless_network_password.png\" alt \"usage_debian_wireless_network_password\"></td> <td><img src \"./assets/desktop/usage_debian_wireless_network_connected.png\" alt \"usage_debian_wireless_network_connected\"></td> </tr> </table> 在输入密码的弹出窗口中，`Wi Fi adapter` 中需要选择 `wlan0` 来连接网络。 ## 连接蓝牙 找到桌面右上角的蓝牙图标，确认蓝牙功能已经打开，若没打开，右键单击蓝牙图标即可打开： ![bluetooth_icon.png](./assets/desktop/bluetooth_icon.png) 打开后，左键单击蓝牙图标，可以看到蓝牙设备扫描界面 点击该界面左上角的Search即可搜索蓝牙设备，将蓝牙键鼠、蓝牙耳机等设备的配对模式打开即可被扫描到。 右键选择想要连接的设备，即可连接。成功连接后还可以右键该设备，点击Trust，下次扫描到即可自动连接。 ![bluetooth_devices.png](./assets/desktop/bluetooth_devices.png) 如果在配对后尝试连接蓝牙音频设备时遇到错误`br connection profile unavailable`，可以尝试**以普通用户权限**下执行下列命令： ```shell systemctl user enable pulseaudio systemctl user start pulseaudio sudo apt install bluetooth rfkill blueman bluez bluez tools pulseaudio module bluetooth ``` 若蓝牙图形管理界面无法搜索到设备，也可以现在命令行界面下使用`bluetoothctl`来进行配对，步骤如下： ```shell bluetoothctl scan on # 找到想要配对设备的mac地址 pair 目标设备的mac地址 connect 目标设备的mac地址 ``` 上述步骤也可以在蓝牙图形界面进行操作，但蓝牙图形界面能够展示的搜索到的蓝牙设备有限，此时可以先用 `bluetoothctl` 工具来进行搜索和配对，配对成功后图形界面就会出现这个设备，就可以切换到图形界面进行操作了。 ## 软件安装 在完成网络连接后，即可进行软件包的更新，安装。 ### 软件源 在 Debian 系统中，可以使用 apt (Advanced Packaging Tool) 来进行软件的安装。 安装软件的时候，会从系统指定的软件网站中搜索并下载目标软件，当目标网站访问困难（比如服务器距离太远或者服务器网络不佳）时，可以手动设置编辑软件源网站，改成距离自己当前最近的源，来减少下载时间。 软件源默认使用 `/etc/apt/sources.list` 文件里面的内容，有额外需要的话可以自行更改。但是要注意需要使用支持 Risc V 架构的软件源。 ![usage_debian_apt_change_source](./assets/desktop/usage_debian_apt_change_source.png) ### 升级软件 使用 `sudo apt update` 可以更新软件列表，一般在更换软件源之后需要使用这个命令。 使用这个命令前，先用 `date` 命令查看一下时间，若时间不对或连接网络后没有自动更新时间，可以手动更新一下，确保软件源内的软件包是最新版本： ```shell sudo date s \"20230717 12:00:00\" ``` 然后使用 `sudo apt upgrade package_name` 可以更新名称为 `package_name` 的软件。 比如下面是使用 `sudo apt upgrade vim` 来更新 `vim` 这个软件的示例 ![usage_debian_apt_upgrade_vim](./assets/desktop/usage_debian_apt_upgrade_vim.png) 若使用 `sudo apt update` 命令时遇到类似下面的提示信息： ```shell Ign:1 https://mirror.iscas.ac.cn/deepin riscv/deepin stage1 beige InRelease Ign:2 https://community packages.deepin.com/driver driver InRelease Ign:3 https://mirror.iscas.ac.cn/deepin riscv/deepin addons beige InRelease Ign:2 https://community packages.deepin.com/driver driver InRelease Ign:1 https://mirror.iscas.ac.cn/deepin riscv/deepin stage1 beige InRelease Ign:3 https://mirror.iscas.ac.cn/deepin riscv/deepin addons beige InRelease Ign:1 https://mirror.iscas.ac.cn/deepin riscv/deepin stage1 beige InRelease Ign:2 https://community packages.deepin.com/driver driver InRelease Ign:3 https://mirror.iscas.ac.cn/deepin riscv/deepin addons beige InRelease Err:2 https://community packages.deepin.com/driver driver InRelease Could not resolve 'community packages.deepin.com' Err:1 https://mirror.iscas.ac.cn/deepin riscv/deepin stage1 beige InRelease Could not resolve 'mirror.iscas.ac.cn' Err:3 https://mirror.iscas.ac.cn/deepin riscv/deepin addons beige InRelease Could not resolve 'mirror.iscas.ac.cn' Reading package lists... Done W: Failed to fetch https://mirror.iscas.ac.cn/deepin riscv/deepin stage1/dists/beige/InRelease Could not resolve 'mirror.iscas.ac' W: Failed to fetch https://mirror.iscas.ac.cn/deepin riscv/deepin addons/dists/beige/InRelease Could not resolve 'mirror.iscas.ac' W: Failed to fetch https://community packages.deepin.com/driver/dists/driver/InRelease Could not resolve 'community packages.deep' W: Some index files failed to download. They have been ignored, or old ones used instead. ``` 可以尝试如下命令进行修复： ```shell sudo apt get update fix missing ``` ### 安装程序 可以借助于 apt 命令来安装软件；比如使用 `sudo apt install package_name` 命令来安装 `package_name`，下面是使用 apt 来安装 `net tools` 的例子。 ![usage_debian_apt_install_nettools](./assets/desktop/usage_debian_apt_install_nettools.png) 安装 `net tools` 后，就可以使用 `ifconfig` 命令了。 ![usage_debian_ifconfig_result_list](./assets/desktop/usage_debian_ifconfig_result_list.png) 箭头指向的地方就是常说的 IP 地址了。 若在下载软件的过程中遇到类似下面的提示信息： ```shell W: GPG error: http://archive.ubuntu.com trusty updates Release: The following signatures couldn't be verified because the public key is not available: NO_PUBKEY 40976EAF437D05B5 NO_PUBKEY 3B4FE6ACC0B21F32 ``` 可以尝试用下列命令修复： ```shell sudo apt key adv keyserver keyserver.ubuntu.com recv keys '替换成报错中的NO_PUBKEY 后面的key值' # 或使用 gpg keyserver keyserver.ubuntu.com recv keys '替换成报错中的NO_PUBKEY 后面的key值' ``` ## SSH 如果你的镜像里没有 ssh 或 sshd 指令，可以先通过以下指令安装： ```bash sudo apt install ssh openssh server ``` 安装之后即可使用 ssh 来远程登录到其它机器操作，或者在其它机器上使用 ssh 登录到 LicheePi 4A 还可以使用 scp 进行文件传输： ```bash scp demo.zip sipeed@192.168.1.9:~/ ``` ## 输入法 如果你需要进行非 ascii 的字符输入，就需要安装输入法，这里以中文输入法为例，其它语言请自行查找相关教程。 先安装 ibus libpinyin： ```bash sudo apt install y ibus libpinyin ``` > 注意这里会消耗约200MB磁盘空间 安装完后，重启板卡，即可在 Applications 下看到 `IBus Preference` 选项，点击进入设置。 ![pinyin_cfg0](./assets/desktop/pinyin_cfg0.png) 在出现的界面里点击 `Input Method`，点击 `Add`，选择 `Chinese`，选择 `Intelligent Pinyin`，点击 `Add`，即可添加中文拼音输入法。 ![pinyin_cfg1](./assets/desktop/pinyin_cfg1.png) 在右上角点击输入法图标，可见以下选项，选择 `Chinese Intelligent Pinyin` 即可。 ![pinyin_cfg2](./assets/desktop/pinyin_cfg2.png) 此时即可在系统中顺利输入中文： ![pinyin_cfg3](./assets/desktop/pinyin_cfg3.png) > 注：在 0425 版本镜像中，可能会由于 GPU 支持问题，导致安装了输入法后，出现图形界面卡顿滞后的问题。 ## 办公软件 部分镜像里内置了基础的 Office 办公软件（LibreOffice）： ![office0](./assets/desktop/office0.png) LibreOffice Calc 即 XLS 功能： ![office_calc](./assets/desktop/office_calc.png) LibreOffice Impress 即 PPT 功能： ![office_impress](./assets/desktop/office_impress.png) LibreOffice Writer 即 WORD 功能： ![office_writer](./assets/desktop/office_writer.png) ## 浏览器 系统内置了 Chromium 浏览器，点击桌面下方的浏览器图标即可使用： ![browser_location](./assets/desktop/browser_location.png) > 若桌面下方启动栏图标显示异常，可以尝试使用以下命令修复： ```shell cp /etc/xdg/xfce4/panel/default.xml /home/sipeed/.config/xfce4/xfconf/xfce perchannel xml/xfce4 panel.xml chown sipeed:sipeed /home/sipeed/.config/xfce4/xfconf/xfce perchannel xml/xfce4 panel.xml ``` 使用搜索引擎： ![browser_search_engine_use](./assets/desktop/browser_search_engine_use.jpg) 观看在线视频： ![browser_play_video](./assets/desktop/browser_play_video.jpg) WebGL 支持测试： ![browser_webgl](./assets/desktop/browser_webgl.png) > 注：目前的 0714 镜像中，Chromium 下播放视频或音频时，若为 HDMI 音频输出，会有噪音，可以暂时切换为 Firefox 浏览器来播放。 使用下列命令安装 Firefox 浏览器和相关依赖： ```shell sudo apt install firefox ffmpeg ``` ## 播放器 系统内置了一些开源播放器，默认使用的播放器是支持播放 4K 视频的 Parole，**推荐优先使用支持硬件加速的播放器 Parole**。 使用 Parole 播放 4K 视频的效果如下： ![4k_video_play](./assets/desktop/4k_video_play.png) 同时还支持 kodi，使用效果如下： ![kodi_homepage](./assets/desktop/kodi_homepage.png) ![kodi_iconmenu](./assets/desktop/kodi_iconmenu.png) ![kodi_settings](./assets/desktop/kodi_settings.png) 也支持 mpv 播放器，可以使用如下命令安装： ```shell sudo apt update sudo apt install mpv ``` 此外，还预装了 VLC Player 播放器： ![player](./assets/desktop/player.png) 使用 VLC Player 查看 MP4 格式的视频效果如下： ![vlc_player_use](./assets/desktop/vlc_player_use.jpg) ## 编程开发 ### Python 系统已内置了 python3 环境，可以在终端直接运行： ![python](./assets/desktop/python.png) 如果需要安装Python包，则使用：`sudo apt install python3 XXX` 比如安装pyserial包：`sudo apt install python3 serial` 即可 ### C 需要安装 `build essential` 包，占用约800MB磁盘空间 ```bash sudo apt install build essential ``` 然后即可使用 gcc 进行相关编译操作： ![gcc](./assets/desktop/gcc.png) ## 扩展存储空间 内测版板载 eMMC 容量较小，留给用户的空间只有 2～3GB，如果需要进行大容量存储，则需要扩展存储空间，可选使用 USB 存储或者 TF 存储。 ### 挂载 U 盘 将一个 U 盘插入 LicheePi 4A 的 USB 口后，可以在命令终端窗口使用 `dmesg` 查看板卡硬件变动信息。 如下是连接 U 盘后，使用 `dmesg` 在命令行终端看到的最新信息（截取）。 ![usage_debian_udisk_dmesg](./assets/desktop/usage_debian_udisk_dmesg.png) 上面的信息显示出了板卡的外设更改信息；从中可以看到有一个大容量 USB 存储设备连接到了 LicheePi 4A。 使用命令 `cat /proc/partitions grep \"sd*\"` 命令可以查看到 U 盘内部的分区个数 ![usage_debian_udisk_partition_detail](./assets/desktop/usage_debian_udisk_partition_detail.png) 以上面的结果为例，其中 `sda` 指代的是整个 U 盘，`sda1` 和 `sda2` 表示的是 U 盘里面的两个分区。 先在桌面系统创建一个文件夹，然后使用 `mount` 命令将 U 盘的某一分区挂载到该文件夹下。 ```bash mkdir ~/Desktop/udisk # 在桌面创建一个名为 udisk 的文件夹 mount /dev/sda2 ~/Desktop/udisk # 挂载 U 盘的 sda2 分区到 udisk 文件夹 ``` <table> <tr> <td> 运行命令前 </td> <td> 运行命令后 </td> </tr> <tr> <td style \"white space:nowrap\"><img src \"./assets/desktop/usage_debian_udisk_before_mount.png\" alt \"usage_debian_udisk_before_mount\"></td> <td style \"white space:nowrap\"><img src \"./assets/desktop/usage_debian_udisk_after_mount.png\" alt \"usage_debian_udisk_after_mount\"></td> </tr> <tr> <td colspan 2> 运行命令后桌面新增了一个名为 udisk 的文件夹，使用鼠标双击打开 udisk 文件夹后可以看到文件夹里面的内容与 U 盘里面的实际内容一致 <img src \"./assets/desktop/usage_debian_udisk_open_folder.png\" alt \"usage_debian_udisk_open_folder\"></td> </tr> </table> ### 挂载 TF卡 将 TF 卡插入 LicheePi 4A 背面的 TF 卡槽中，即可在系统下看到 `/dev/mmcblk1` 设备 （/dev/mmcblk0 是 SOM 上的 eMMC） 如果 TF 卡尚未分区或者格式化，用户可以使用 `sudo fdisk /dev/mmcblk1` 指令进行分区， 然后使用 `sudo mkfs.ext4 /dev/mmcblk1p1` 或者 `sudo mkfs.vfat /dev/mmcblk1p1` 对新建的分区进行格式化操作。 如果想作为扩展分区使用，建议使用 ext4；如果想作为与 Windows 交换数据的 TF 卡，建议使用 vfat。 格式化好后，即可与上节内容一样进行挂载操作，确认是否挂载正常。 ### 设置开机挂载 验证手工挂载成功后，你可以进一步设置开机挂载。 只需要在 /etc/fstab 文件内加上需要开机自动挂载的设备信息即可，以下是在最后一行添加TF卡自动挂载的示例。 ```bash sipeed@lpi4a:~$ cat /etc/fstab # UNCONFIGURED FSTAB FOR BASE SYSTEM /dev/mmcblk0p3 / auto defaults 1 1 /dev/mmcblk0p2 /boot auto defaults 0 0 /dev/mmcblk1p1 /mnt auto defaults 0 2 ``` 第一个数字：0 表示开机不检查磁盘，1 表示开机检查磁盘； 第二个数字：0 表示交换分区，1 代表启动分区（Linux），2 表示普通分区 /dev/mmcblk1p1 也可使用磁盘 UUID，即写成 UUID xxxx xxx 的形式，UUID 可以使用`sudo blkid`查看： `/dev/mmcblk1p1: UUID \"033173ff b3ab 494c ab14 4dcd656a9214\" BLOCK_SIZE \"4096\" TYPE \"ext4\" PARTUUID \"8e4e28df 01\"` ## VNC远程桌面 安装需要的软件包，远程桌面使用轻量化的 Xfce 桌面环境。 ```shell sudo apt install xfce4 xfce4 goodies xorg dbus x11 x11 xserver utils sudo apt install tigervnc standalone server tigervnc common ``` 安装好之后，输入 `vncserver` 命令，配置相关密码，系统会提示配置密码，根据自身需要设置，第二个密码用于仅供查看的用户登录： ```shell sipeed@lpi4a:~$ vncserver You will require a password to access your desktops. Password: Verify: Would you like to enter a view only password (y/n)? n A view only password is not used ``` 相关密码会创建文件存储在 `~/.vnc` 中。 设置完密码后会接着显示下面的信息 ```shell New Xtigervnc server 'lpi4a:1 (sipeed)' on port 5901 for display :1. Use xtigervncviewer SecurityTypes VncAuth passwd /tmp/tigervnc.I5Af7X/passwd :1 to connect to the VNC server. ``` 注意上面输出中的主机名后有一个 `:1`，这表示 VNC 服务器的显示端口号。 VNC 服务器将会监听端口 `5901`，即 5900+1。类似的，运行 vncserver 命令创建第二个示例时，将使用下一个显示端口 `:2`，对于这个显示端口，监听的端口则为 `5902`。 接下来，先 kill 掉刚刚创建的 VNC 实例，先进行一些配置。 ```shell vncserver kill :1 ``` xstartup 文件是 TigerVNC 服务器启动时运行的脚本，创建并编辑文件 `~/.vnc/xstartup`，写入下面的内容： ```shell #!/bin/sh unset SESSION_MANAGER unset DBUS_SESSION_BUS_ADDRESS exec startxfce4 ``` 并赋予权限 ```shell chmod +x ~/.vnc/xstartup ``` 接下来增加 VNC 服务器的启动参数，创建并编辑 `~/.vnc/config` 文件，加入需要的启动参数，比如想要设置启动时的分辨率和 dpi，可以写入下面的内容： ```shell geometry your_prefer_resolution dpi your_prefer_dpi ``` 若因为防火墙连接不上 VNC，可以使用 ufw 来添加允许的端口，比如使用 VNC服务器的显示端口5901： ```shell sudo ufw allow 5901 ``` 最后，就可以运行 vnc 服务器了： ```shell vncserver localhost no ``` 接下来，为了访问远程主机（LPi4A），我们需要在本地主机（你正在使用的电脑）上下载安装 [vncviewer](https://www.realvnc.com/en/connect/download/viewer/)，安装完成后，启动 VNCviewer，在窗口顶部输入远程主机的 IP 地址和端口号（格式为 `你的IP地址:VNC服务器的显示端口号）： ![vnc_viewer_connect](./assets/desktop/vnc_viewer_connect.png) 默认会根据网络情况来设置远程桌面的画质，低画质时可能会导致远程桌面画面颜色异常，此时可以手动指定为高画质。 在第一次成功连接后，右键单击新出现的会话窗口，选择 properties： ![vnc_viewer_change_properties](./assets/desktop/vnc_viewer_change_properties.png) 修改 Options 选项中的 Picture quality 为 High： ![vnc_viewer_settings](./assets/desktop/vnc_viewer_settings.png) 显示的效果如下： ![vnc_viewer_use](./assets/desktop/vnc_viewer_use.png) ## btop btop 是一个兼顾美观与实用性的资源监视器，显示处理器、内存、磁盘、网络和进程的使用情况和统计​​信息。 使用以下命令可以安装： ```shell sudo apt install btop ``` 然后在命令行中运行 `btop` 命令即可使用，效果如下： ![btop_use](./assets/application/btop_use.png) ## 更多 欢迎投稿～ 投稿接受后可得￥5～150（$1~20）优惠券！"},"/hardware/zh/lichee/th1520/lpi4a/7_develop_openwrt.html":{"title":"OpenWrt","content":" title: OpenWrt keywords: Linux, Lichee, TH1520, SBC, RISCV, Kernel, SDK, Develop update: date: 2023 09 17 version: v1.1 author: ztd content: Update docs date: 2023 05 12 version: v1.0 author: wonder content: Release docs ## OpenWrt [项目地址](https://github.com/ruyisdk/openwrt) ## 构建 Ubuntu 上构建目前会存在一些问题，使用 Debian 能够顺利构建。仓库中提供 Debian 相应的 Dockerfile。 首先需要 clone 该项目源码： ```shell git clone https://github.com/ruyisdk/openwrt.git ``` 若你的机器之前没有配置过Docker环境，参考 [Docker 官方文档](https://www.yuque.com/za4k4z/uzn618/fvxfnefpbdsg15hk)的步骤： 卸载可能存在的 docker 版本： ```shell sudo apt get remove docker docker engine docker.io containerd runc ``` 安装 docker 依赖的基础软件： ```shell sudo apt get update sudo apt get install apt transport https ca certificates curl gnupg agent software properties common ``` 添加官方源： ```shell curl fsSL https://download.docker.com/linux/ubuntu/gpg sudo apt key add sudo add apt repository \"deb [arch amd64] https://download.docker.com/linux/ubuntu $(lsb_release cs) stable\" ``` 安装 docker： ```shell sudo apt get update sudo apt get install docker ce docker ce cli containerd.io ``` 然后进入到 docker build 目录中配置好相应环境并开始编译。 ```shell cd openwrt/docker build # 构建 Docker 镜像 sudo docker build t ruyisdk openwrt builder . # 使用 Docker 构建 Openwrt sudo docker run rm v \"$(cd .. && pwd)\":/workspace ruyisdk openwrt builder ``` 构建完成后，将构建好的镜像烧录至开发板中。 接下来可以参考 [Openwrt 官方文档](https://openwrt.org/docs/start)进行开发。 ## 参考 [Openwrt](https://github.com/ruyisdk/openwrt) [Docker Build](https://github.com/ruyisdk/openwrt/tree/lpi4a new/docker build) [Openwrt 官方文档](https://openwrt.org/docs/start)"},"/hardware/zh/lichee/th1520/lpi4a/11_credits.html":{"title":"致谢","content":" title: 致谢 keywords: Linux, Lichee, TH1520, SBC, RISCV, credits update: date: 2023 05 08 version: v1.0 author: wonder content: Release docs 本章节专门向 LicheePi 4A 作出贡献的个人和团体致谢！ 感谢你们的贡献让 RISC V 发展得更快更好！ （本文按个人意愿以真名或者网名进行致谢） ## 矽速 泽畔，阔爷，瀚宝，wonder，ztd，... ## 平头哥 春强，陈炜，穆呈，陆斌，... 特别感谢 陆斌 同学的全程沟通！ ## PLCT Wu Wei：感谢吴老板大力支持！老板大气！ [Icenowy Zheng](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/log/?qt author&q Icenowy+Zheng)：冰激凌，永远的神，手打 binary patch，真人快打！ 高涵：revyos之父！ Estela ad Astra：预订 OpenWRT！ ## 开源社区 [Jisheng Zhang](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/log/?qt author&q Jisheng+Zhang): TH1520 主线化支持 范文捷：Wine CE 作者，在 LPi4A 上进行相关移植测试。"},"/hardware/zh/lichee/th1520/lpi4a/4_burn_image.html":{"title":"烧录镜像","content":" title: 烧录镜像 keywords: Linux, Lichee, TH1520, SBC, RISCV, image update: date: 2023 05 08 version: v1.0 author: wonder content: Release docs ## 准备工作 ### 获取镜像 参见上一章“镜像集合”，选取需要的镜像下载。 以下的烧录方式以 Debian 单屏镜像 `LPI4A_20230721.zip`，16+128核心板为例。 ### 获取烧录工具 在镜像集合的网盘内可以获得 `burn_tool.zip`, 解压可得 win/linux/mac 三个系统下的 fastboot 烧录工具。 **注意：**20231023及之后版本的镜像，添加了大镜像文件烧录支持，需要配合最新版本的 fastboot 使用，最新版本的 fastboot 可以在[网盘链接](https://pan.baidu.com/e/1xH56ZlewB6UOMlke5BrKWQ)中找到，文件名为`burn_tools_support_bigimage.zip`。 ## 进入烧录模式 ### 内测版硬件 按住板上的BOOT按键不放，然后插入 USB C 线缆上电（线缆另一头接 PC ），即可进入 USB 烧录模式。 ![press_boot](./assets/burn_image/press_boot.png) 在 Windows 下使用设备管理器查看，会出现 “USB download gadget” 设备。 在 Linux 下，使用 `lsusb` 查看设备，会显示以下设备： `ID 2345:7654 T HEAD USB download gadget` ### 正式版硬件 注意检查底板的拨码开关是否为 EMMC 启动模式： ![switch_boot_mode](./assets/burn_image/switch_boot_mode.jpg) 确认无误后即可烧录，接下来的烧录步骤同内测版。 ### Windows 下驱动安装(禁用驱动签名) Windows 下烧录时，需要先进入高级启动模式，禁用数字签名。才能正常安装下面的驱动。 禁用数字签名请按照下面的步骤： **Win10** 1. 找到 WIN10 的设置，点击“设置”： ![win10_find_windows_settings](./assets/burn_image/win10_find_windows_settings.png) 2. 点击最后一个“更新和安全”，然后点击“恢复”： ![win10_click_the_restore](./assets/burn_image/win10_click_the_restore.png) 3. 点击“恢复”之后，在右边点击高级启动下面的“重新启动”，此时电脑会重新启动，如果有其他重要 程序在跑，请慎重： ![win10_click_the_restart](./assets/burn_image/win10_click_the_restart.png) **Win11** 1. 在设置中找到\"系统菜单\"，然后点击“恢复”。 ![win11_click_the_restore](./assets/burn_image/win11_click_the_restore.png) 2. 在右边点击高级启动下面的“重新启动”，此时电脑会重新启动，如果有其他重要 程序在跑，请慎重。 ![win11_click_the_restart](./assets/burn_image/win11_click_the_restart.png) **相同部分** 1. 重启之后会出现几个选项，点击选项“疑难解答”，然后点击“高级”，启动设置，重启。 ![click_the_advanced_option](./assets/burn_image/click_the_advanced_option.png) 2. 这会重启之后就跳出一个列表，其中有安全模式等选项，也包括这里我们关心的“禁止强制驱动程序签名”，选择“禁用强制驱动程序签名”，对应哪个数字就按那个数字，之后电脑会重新启动。 ![ban_the_signature](./assets/burn_image/ban_the_signature.png) 3. 重启之后，驱动就可以成功安装。若有提示点击继续安装即可。 fastboot 驱动安装具体步骤如下： a. 开发板通过 usb 连接到电脑。 b. 打开设备管理器出现“USB download gadget”设备。 ![before_install_driver](./assets/burn_image/before_install_driver.png) ![install_driver](./assets/burn_image/install_driver.png) ### Windows 下驱动安装(手动注入驱动) 烧录流程参考[RevyOS文档](https://docs.revyos.dev/)中所介绍的。这种方法不需要禁用驱动签名，比较方便。 按住板卡上的BOOT键后，将靠近BOOT键的Type C口接入电脑，板卡会进入刷写模式。 在Windows徽标右键，打开设备管理器，如果在“其他设备”处看到“USB download gadget”，即表明设备已被正确识别。但是未安装驱动程序。 为了打入fastboot驱动，需要下载[Google USB驱动（需要代理）](https://dl.google.com/android/repository/usb_driver_r13 windows.zip)，下载并解压到某一位置。 1. 右键设备管理器中的“USB download gadget”，点击“更新驱动程序” 2. 选择“浏览我的电脑以查找驱动程序” ![更新驱动程序步骤2](./assets/burn_image/driver update step 2.png) 3. 选择“让我从计算机上的可用驱动程序列表中选取” 4. 选中“显示所有设备”，并点击“下一步” ![更新驱动程序步骤4](./assets/burn_image/driver update step 4.png) 5. 点击“从磁盘安装” 6. 点击“浏览”，选中Google USB驱动下的inf文件，点击确定 ![更新驱动程序步骤6](./assets/burn_image/driver update step 6.png) 7. 选中“Android Bootloader Interface”，点击“下一步”，在弹出对话框中点击“是”，在弹出的Windows安全中心对话框中点击“安装” ![更新驱动程序步骤7](./assets/burn_image/driver update step 7.png) 8. 成功安装fastboot驱动 ![更新驱动程序步骤8](./assets/burn_image/driver update step 8.png) 完成上述操作后，即可继续下面的步骤。 ## 烧录镜像 进入烧录模式后，可使用 burn_tool.zip 内的 fastboot 进行烧录操作，注意可能需要先赋予 fastboot 可执行权限。 ### Windows 系统步骤 编辑 burn_tool.zip 文件夹里面的 `burn_lpi4a.bat` 文件，将对应的镜像路径更改成自己实际使用的镜像及名称。然后双击运行 `burn_lpi4a.bat` 就能够正常进行烧录了。 注意： 1. `fastboot.exe` 的路径也需要匹配上，不然会被提示找不到文件。 2. 如果你采用的是上面第二种方法手动打入的fastboot驱动，如果 `burn_lpi4a.bat` 卡在 `< waiting for any device >`，请检查设备管理器中是否出现了名为 `USB download gadget` 的未知设备。若是，按上面的步骤重新打入驱动即可。 ![target_burn_image_path](./assets/burn_image/target_burn_image_path.png) ### Linux 系统步骤 在按住BOOT按键的条件下，系统在reset启动后，会默认进入fastboot模式， 这时侯我们可以通过fastboot下载并启动u boot镜像的命令，来进入到u boot的fastboot烧录模式（相比Brom阶段，会有更大下载buffer，速度会更快） 下面的指令会检查并格式化分区，请务必执行，否则后面烧录 rootfs 会很慢。 `u boot with spl lpi4a.bin` 和 `u boot with spl lpi4a 16g.bin` 为u boot 固件，具体差异请参考镜像说明。 ```bash sudo ./fastboot flash ram ./images/u boot with spl lpi4a 16g.bin sudo ./fastboot reboot sleep 1 ``` 分别烧录下面三个镜像：启动引导镜像 uboot，启动分区 boot，操作系统根分区 root ```bash sudo ./fastboot flash uboot ./images/u boot with spl lpi4a 16g.bin sudo ./fastboot flash boot ./images/boot_sing.ext4 sudo ./fastboot flash root ./images/rootfs sing.ext4 ``` `boot sing.ext4` 和 `boot dual.ext4` 为 boot 分区，具体差异请参考镜像说明。它们主要包含以下内容： ```bash fw_dynamic.bin #opensbi Image #kernel image kernel release #commit id of kernel light_aon_fpga.bin #fw for E902 aon light_c906_audio.bin #fw for C906 audio light lpi4a.dtb # ddr8G dtb light lpi4a ddr16g.dtb # ddr16G dtb ``` `rootfs sing.ext4` 和 `rootfs mipi.ext4` 为根文件系统，默认为 Debian 系统。两者的具体差异请参考镜像说明。 烧录镜像的典型 log 输出如下： ![burn_image_progress_result](./assets/burn_image/burn_image_progress_result.png) <! ```bash (base) pc@n5105:~/work/$ sudo ./fastboot flash ram u boot with spl.bin Sending 'ram' (935 KB) OKAY [ 0.248s] Writing 'ram' OKAY [ 0.002s] Finished. Total time: 0.255s (base) pc@n5105:~/work/$ sudo ./fastboot reboot Rebooting OKAY [ 0.001s] Finished. Total time: 0.202s (base) pc@n5105:~/work/$ sudo ./fastboot flash uboot u boot with spl.bin Sending 'uboot' (935 KB) OKAY [ 0.054s] Writing 'uboot' OKAY [ 0.030s] Finished. Total time: 0.107s (base) pc@n5105:~/work/$ sudo ./fastboot flash boot boot_20230420.ext4 Sending 'boot' (40000 KB) OKAY [ 1.705s] Writing 'boot' OKAY [ 0.877s] Finished. Total time: 2.770s (base) pc@n5105:~/work/$ sudo ./fastboot flash root rootfs 20230425 001635 nogpu.ext4 Invalid sparse file format at header magic Sending sparse 'root' 1/37 (114572 KB) OKAY [ 4.793s] Writing 'root' OKAY [ 3.087s] Sending sparse 'root' 2/37 (105264 KB) OKAY [ 4.465s] Writing 'root' OKAY [ 2.330s] Sending sparse 'root' 3/37 (111970 KB) OKAY [ 4.814s] Writing 'root' OKAY [ 2.861s] Sending sparse 'root' 4/37 (114684 KB) OKAY [ 4.902s] Writing 'root' OKAY [ 2.658s] Sending sparse 'root' 5/37 (101490 KB) OKAY [ 4.305s] Writing 'root' OKAY [ 2.652s] Sending sparse 'root' 6/37 (114684 KB) OKAY [ 4.648s] Writing 'root' OKAY [ 2.657s] Sending sparse 'root' 7/37 (113862 KB) OKAY [ 4.755s] Writing 'root' OKAY [ 2.826s] Sending sparse 'root' 8/37 (111189 KB) OKAY [ 4.741s] Writing 'root' OKAY [ 2.695s] Sending sparse 'root' 9/37 (114625 KB) OKAY [ 4.865s] Writing 'root' OKAY [ 2.660s] Sending sparse 'root' 10/37 (104030 KB) OKAY [ 4.506s] Writing 'root' OKAY [ 4.108s] Sending sparse 'root' 11/37 (111701 KB) OKAY [ 4.744s] Writing 'root' OKAY [ 2.717s] Sending sparse 'root' 12/37 (107317 KB) OKAY [ 4.568s] Writing 'root' OKAY [ 2.583s] Sending sparse 'root' 13/37 (114629 KB) OKAY [ 4.830s] Writing 'root' OKAY [ 2.753s] Sending sparse 'root' 14/37 (109798 KB) OKAY [ 4.711s] Writing 'root' OKAY [ 2.778s] Sending sparse 'root' 15/37 (112203 KB) OKAY [ 4.795s] Writing 'root' OKAY [ 2.982s] Sending sparse 'root' 16/37 (112502 KB) OKAY [ 4.827s] Writing 'root' OKAY [ 2.991s] Sending sparse 'root' 17/37 (114110 KB) OKAY [ 4.849s] Writing 'root' OKAY [ 2.853s] Sending sparse 'root' 18/37 (114681 KB) OKAY [ 4.888s] Writing 'root' OKAY [ 2.802s] Sending sparse 'root' 19/37 (112042 KB) OKAY [ 4.799s] Writing 'root' OKAY [ 3.674s] Sending sparse 'root' 20/37 (109101 KB) OKAY [ 4.631s] Writing 'root' OKAY [ 2.582s] Sending sparse 'root' 21/37 (114225 KB) OKAY [ 4.623s] Writing 'root' OKAY [ 2.782s] Sending sparse 'root' 22/37 (114365 KB) OKAY [ 4.703s] Writing 'root' OKAY [ 2.667s] Sending sparse 'root' 23/37 (103529 KB) OKAY [ 4.133s] Writing 'root' OKAY [ 2.442s] Sending sparse 'root' 24/37 (114664 KB) OKAY [ 4.631s] Writing 'root' OKAY [ 2.581s] Sending sparse 'root' 25/37 (114550 KB) OKAY [ 4.749s] Writing 'root' OKAY [ 2.878s] Sending sparse 'root' 26/37 (114686 KB) OKAY [ 4.796s] Writing 'root' OKAY [ 2.853s] Sending sparse 'root' 27/37 (114466 KB) OKAY [ 4.800s] Writing 'root' OKAY [ 2.894s] Sending sparse 'root' 28/37 (110689 KB) OKAY [ 4.711s] Writing 'root' OKAY [ 2.616s] Sending sparse 'root' 29/37 (114687 KB) OKAY [ 4.880s] Writing 'root' OKAY [ 2.992s] Sending sparse 'root' 30/37 (110984 KB) OKAY [ 4.710s] Writing 'root' OKAY [ 2.451s] Sending sparse 'root' 31/37 (114685 KB) OKAY [ 4.920s] Writing 'root' OKAY [ 2.749s] Sending sparse 'root' 32/37 (114684 KB) OKAY [ 4.825s] Writing 'root' OKAY [ 2.503s] Sending sparse 'root' 33/37 (114684 KB) OKAY [ 4.816s] Writing 'root' OKAY [ 3.262s] Sending sparse 'root' 34/37 (114686 KB) OKAY [ 4.745s] Writing 'root' OKAY [ 2.825s] Sending sparse 'root' 35/37 (114684 KB) OKAY [ 4.913s] Writing 'root' OKAY [ 2.630s] Sending sparse 'root' 36/37 (114684 KB) OKAY [ 4.838s] Writing 'root' OKAY [ 2.593s] Sending sparse 'root' 37/37 (21324 KB) OKAY [ 0.926s] Writing 'root' OKAY [ 0.487s] Finished. Total time: 281.671s ``` > ## 启动机制 brom > U Boot SPL > U Boot > OpenSBI > Kernel 接下来简单介绍一下每个阶段，并展示使用串口工具连接开发板时能够看到的相应日志。 正式版开发板中，系统串口IO新增电平转换IC到3.3V，可以使用普通串口模块连接。 ### brom 该阶段的典型输出如下： ```shell brom_ver 8 [APP][E] protocol_connect failed, exit. ``` brom 阶段会从 SoC 的 ROM 中获取核心代码，并寻找下一阶段的 bootloader。 ### U Boot SPL 该阶段的典型输出如下： ```shell U Boot SPL 2020.01 gd6c9182f (Jul 07 2023 12:31:51 +0200) FM[1] lpddr4x dualrank freq 3733 64bit dbi_off n sdram init ddr initialized, jump to uboot image has no header ``` 这里的 U Boot SPL 中的 SPL 指的是 Secondary Program Loader，其中的 Secondary，也就是第二阶段，是相对于前面的 brom 来说的。 U Boot SPL 的主要功能是加载真正的 U Boot 运行，因为一些 SoC 中无法装下一个完整的 U Boot 镜像，那么就需要 U Boot SPL 来初始化外部 RAM 和环境，加载真正的 U Boot 到外部 RAM 中执行。 ### U Boot 该阶段的典型输出如下： ```shell U Boot 2020.01 gd6c9182f (Jul 07 2023 12:31:51 +0200) CPU: rv64imafdcvsu Model: T HEAD c910 light DRAM: 8 GiB C910 CPU FREQ: 750MHz AHB2_CPUSYS_HCLK FREQ: 250MHz AHB3_CPUSYS_PCLK FREQ: 125MHz PERISYS_AHB_HCLK FREQ: 250MHz PERISYS_APB_PCLK FREQ: 62MHz GMAC PLL POSTDIV FREQ: 1000MHZ DPU0 PLL POSTDIV FREQ: 1188MHZ DPU1 PLL POSTDIV FREQ: 1188MHZ MMC: sdhci@ffe7080000: 0, sd@ffe7090000: 1 Loading Environment from MMC... OK Error reading output register Warning: cannot get lcd en GPIO LCD panel cannot be found : 121 splash screen startup cost 15 ms In: serial Out: serial Err: serial Net: ethernet@ffe7070000 (eth0) using MAC address ae:be:2a:50:5e:89 eth0: ethernet@ffe7070000ethernet@ffe7070000:0 is connected to ethernet@ffe7070000. ethernet@ffe7060000 (eth1) using MAC address ae:be:2a:50:5e:8a , eth1: ethernet@ffe7060000 Hit any key to stop autoboot: 0 ``` 这个阶段，看到 `Hit any key to stop autoboot:` 时，在2秒倒计时结束前可以按回车键进入 U Boot，在这里可以设置各种环境变量，对于常用的环境变量举例设置如下： 设置 MAC 地址： ```shell setenv ethaddr ae:be:2a:50:5e:89 setenv eth1addr ae:be:2a:50:5e:8a saveenv ``` 将上述命令中的 MAC 地址替换为自己的 MAC 地址即可，注意 `eth1addr` 的值为 `ethaddr` 的值加1。 设置内核使用的设备树： ```shell setenv fdt_file light lpi4a.dtb saveenv ``` 上述命令中的 `light lpi4a.dtb` 替换为存放在 `boot.ext4` 中想使用的设备树的文件名。 设置完成后也可以使用 `printenv` 命令检查是否正确，然后输入 `boot` 命令即可进入内核。 此外，也可以在这里设置启动参数来选择启动方式，比如使用 SD 卡启动。 烧录镜像到 SD 卡中后，将 SD 卡插入开发板，进入到 U Boot： ```shell env set f set_bootargs 'setenv bootargs console ttyS0,115200 root /dev/mmcblk1 rootfstype ext4 rootwait rw earlycon clk_ignore_unused loglevel 7 eth ethaddr rootrwoptions rw,noatime rootrwreset {factory_reset} init /lib/systemd/systemd' env save ``` 上述步骤完成后，输入 `reset` 命令重启开发板，即可从 SD 卡启动系统。 对于正式版开发板则可以使用底板上的拨码开关来选择启动方式： ![switch_boot_mode](./assets/burn_image/switch_boot_mode.jpg) ### OpenSBI OpenSBI 的 sbi_init.c 文件中的一些初始化打印不会在启动 log 中展示出来，但能够在 Kernel 启动时看到一些关于 OpenSBI 的信息被打印出来： ```shell [ 0.000000] SBI specification v0.3 detected [ 0.000000] SBI implementation ID 0x1 Version 0x9 [ 0.000000] SBI v0.2 TIME extension detected [ 0.000000] SBI v0.2 IPI extension detected [ 0.000000] SBI v0.2 RFENCE extension detected [ 0.000000] SBI v0.2 HSM extension detected ``` OpenSBI 有三种 firmware，这里所使用的是 FW_DYNAMIC，它会根据前一个阶段传入的信息加载下一个阶段。OpenSBI 的 fw_dynamic.bin 固件被存放在 boot.ext4 中，这个阶段会引导内核启动。 ### Kernel 该阶段的典型 log 如下（由于太长，仅截取部分）： ```shell [ 0.000000] Linux version 5.10.113 g387b6863253c dirty [ 0.000000] OF: fdt: Ignoring memory range 0x0 0x200000 [ 0.000000] earlycon: uart0 at MMIO32 0x000000ffe7014000 (options '115200n8') [ 0.000000] printk: bootconsole [uart0] enabled [ 0.000000] efi: UEFI not found. [ 0.000000] Reserved memory: created CMA memory pool at 0x00000003e4000000, size 320 MiB [ 0.000000] OF: reserved mem: initialized node linux,cma, compatible id shared dma pool [ 0.000000] Zone ranges: [ 0.000000] DMA32 [mem 0x0000000000200000 0x00000000ffffffff] [ 0.000000] Normal [mem 0x0000000100000000 0x00000003ffffffff] [ 0.000000] Movable zone start for each node [ 0.000000] Early memory node ranges [ 0.000000] node 0: [mem 0x0000000000200000 0x000000000fffffff] [ 0.000000] node 0: [mem 0x0000000010000000 0x00000000166fffff] [ 0.000000] node 0: [mem 0x0000000016700000 0x0000000016ffffff] [ 0.000000] node 0: [mem 0x0000000017000000 0x0000000018ffffff] [ 0.000000] node 0: [mem 0x0000000019000000 0x000000001bffffff] [ 0.000000] node 0: [mem 0x000000001c000000 0x000000001dffffff] [ 0.000000] node 0: [mem 0x000000001e000000 0x000000001fffffff] [ 0.000000] node 0: [mem 0x0000000020000000 0x00000000207fffff] [ 0.000000] node 0: [mem 0x0000000020800000 0x00000003ffffffff] [ 0.000000] Initmem setup node 0 [mem 0x0000000000200000 0x00000003ffffffff] [ 0.000000] software IO TLB: mapped [mem 0x00000000fbfff000 0x00000000fffff000] (64MB) [ 0.000000] SBI specification v0.3 detected [ 0.000000] SBI implementation ID 0x1 Version 0x9 [ 0.000000] SBI v0.2 TIME extension detected [ 0.000000] SBI v0.2 IPI extension detected [ 0.000000] SBI v0.2 RFENCE extension detected [ 0.000000] SBI v0.2 HSM extension detected [ 0.000000] riscv: ISA extensions acdfimsuv [ 0.000000] riscv: ELF capabilities acdfimv [ 0.000000] percpu: Embedded 27 pages/cpu s73496 r8192 d28904 u110592 [ 0.000000] Built 1 zonelists, mobility grouping on. Total pages: 4128264 [ 0.000000] Kernel command line: console ttyS0,115200 root PARTUUID 80a5a8e9 c744 491a d [ 0.000000] Dentry cache hash table entries: 2097152 (order: 12, 16777216 bytes, linear) [ 0.000000] Inode cache hash table entries: 1048576 (order: 11, 8388608 bytes, linear) [ 0.000000] Sorting __ex_table... [ 0.000000] mem auto init: stack:off, heap alloc:off, heap free:off [ 0.000000] Memory: 15887448K/16775168K available (12390K kernel code, 5982K rwdata, 61) [ 0.000000] SLUB: HWalign 64, Order 0 3, MinObjects 0, CPUs 4, Nodes 1 [ 0.000000] rcu: Preemptible hierarchical RCU implementation. [ 0.000000] rcu: RCU restricting CPUs from NR_CPUS 8 to nr_cpu_ids 4. [ 0.000000] Trampoline variant of Tasks RCU enabled. [ 0.000000] Tracing variant of Tasks RCU enabled. [ 0.000000] rcu: RCU calculated value of scheduler enlistment delay is 25 jiffies. [ 0.000000] rcu: Adjusting geometry for rcu_fanout_leaf 16, nr_cpu_ids 4 [ 0.000000] NR_IRQS: 64, nr_irqs: 64, preallocated irqs: 0 [ 0.000000] riscv intc: 64 local interrupts mapped [ 0.000000] plic: interrupt controller@ffd8000000: mapped 64 interrupts with 4 handlers. [ 0.000000] random: get_random_bytes called from start_kernel+0x372/0x4d4 with crng_ini0 [ 0.000000] riscv_timer_init_dt: Registering clocksource cpuid [0] hartid [0] [ 0.000000] clocksource: riscv_clocksource: mask: 0xffffffffffffffff max_cycles: 0x1623s [ 0.000008] sched_clock: 64 bits at 3000kHz, resolution 333ns, wraps every 439804651109s [ 0.008693] Console: colour dummy device 80x25 ``` 都可以在启动内核后，可以替换设备树 DTB 文件、OpenSBI 固件、内核镜像文件 Image 等文件，它们位于 `/boot/` 目录下： ```shell sipeed@lpi4a:~$ ls /boot/ Image light lpi4a.dtb System.map 5.10.113 g387b6863253c dirty light_aon_fpga.bin config 5.10.113 g387b6863253c dirty light_c906_audio.bin fw_dynamic.bin vmlinuz 5.10.113 g387b6863253c dirty kernel commitid ``` ## 批量烧录 如果你有商业需求，需要批量烧录固件，可以使用 sipeed 提供的 ARM/RV 版 fastboot 制作离线批量烧录器。 如果你需要烧录的数量很大，也可以直接联系 support@sipeed.com，我们提供预烧录镜像服务。"},"/hardware/zh/lichee/th1520/lpi4a/8_application.html":{"title":"典型应用","content":" title: 典型应用 keywords: Linux, Lichee, TH1520, SBC, RISCV, application update: date: 2023 09 12 version: v1.2 author: ztd content: Add some NPU applications date: 2023 07 20 version: v1.1 author: ztd content: Update docs date: 2023 05 08 version: v1.0 author: wonder content: Release docs ## llama.cpp llama 是 META 开源的大语言模型，[llama.cpp](https://github.com/ggerganov/llama.cpp) 是 ggerganov 开源的纯 cpp 运行的 llama 推理项目。 感谢 llama.cpp 这个优秀的项目，我们可以在 LicheePi 4A 上运行 LLM。 笔者在早些时候稍微修改了 llama.cpp [https://github.com/Zepan/llama.cpp](https://github.com/Zepan/llama.cpp)，使其可以在更小内存（低至 700MB 左右）运行 7B 模型。 可以看到 TH1520 花费约 6s 计算一个 token（未使用 V 扩展加速，V 扩展加速预计可加速 4～8 倍，如果你加入了 V 扩展支持，欢迎投稿！） ![llama_th1520](./assets/application/llama_th1520.png) 同时还简单测试了下在入门级 C906 内核上运行7B模型的可行性，由于 D1 的内存过小，使用了 mmap 方式只读扩展，所以引入了大量低速 IO 操作，使得运行速度大为降低，最后仅 18s/token ![llama_d1](./assets/application/llama_d1.png) ## YOLOX 目标检测 本教程是一个如何在 LPi4A（LicheePi 4A） 开发板平台上部署 [YOLOX](https://github.com/Megvii BaseDetection/YOLOX) 模型完成目标检测的示例（CPU推理）。 教程中包括了： 在 LPi4A 开发版上安装 Python 环境 使用 YOLOX 项目中的源码执行模型 教程遵循通常的模型部署流程： 1. LPi4A 上的基础 Python 环境配置 2. 获取 yolox 源码和模型 3. 安装 yolox 所依赖的 python 包 4. LPi4A 上的使用 HHB onnxruntime 执行示例 **基础 Python 环境配置** **基本软硬件配置** 参考 LPi4A 的 《[开箱体验](https://wiki.sipeed.com/hardware/zh/lichee/th1520/lpi4a/2_unbox.html)》中的描述，正确安装好开发板，上电启动后以 root 权限进入。 确保已联网的状态下，更新 apt 源 ```bash sudo apt update ``` 安装一些软件，用于示例中后续使用 ```bash sudo apt install wget git vim ``` 安装 SHL 库 ```bash wget https://github.com/T head Semi/csi nn2/releases/download/v2.4 beta.1/c920.tar.gz tar xf c920.tar.gz cp c920/lib/* /usr/lib/riscv64 linux gnu/ rf ``` **Python 环境配置** LPi4A 烧录的系统中已默认安装 python 3.11 版本。可以使用如下命令确认 ```bash python version ``` 后续均以 python3.11 版本为例，其他版本在安装依赖时需要修改到对应版本的命令。 各种 python 程序软件依赖的软件包大多可通过 pip 安装，可以使用如下命令安装 pip ```bash apt install python3 pip ``` 安装其他python包之前，先安装 venv 包，用于创建python虚拟环境 ```bash apt install python3.11 venv ``` 创建 python虚拟环境，并激活 ```bash cd /root python3 m venv ort source /root/ort/bin/activate ``` 至此，基本 python 环境已经创建完成，与其他体系结构类似，可以直接通过 pip install 安装纯 python 包。 opencv 安装是会依赖其他 python 包，如果 pip 不能自动下载，则可以先手动安装依赖项的安装包。如何获取安装包可以参考 [下载 riscv whl](https://www.yuque.com/za4k4z/uzn618/zsp0krgg9dlp0fhx)。 **获取 YOLOX 模型** [YOLOX](https://github.com/Megvii BaseDetection/YOLOX) 是一个类 YOLO 的目标检测模型，有相当优异的性能表现。 可以直接下载 github 上的源码和模型 ```bash git clone https://github.com/Megvii BaseDetection/YOLOX.git cd YOLOX/demo/ONNXRuntime wget https://github.com/Megvii BaseDetection/YOLOX/releases/download/0.1.1rc0/yolox_s.onnx ``` **修改源码** 本教程将使用 HHB onnxruntime 执行模型，因此切换到。在源码中的 onnxruntime 示例目录，修改文件 demo/ONNXRuntime/onnx_inference.py 的开头新增两行代码 ```bash #!/usr/bin/env python3 # Copyright (c) Megvii, Inc. and its affiliates. +import sys +sys.path.insert(0, \"../../\") + import argparse import os ``` 代码中使用 sys.path.insert 指定搜索路径，以此免去从源码中安装 YOLOX 的安装包的操作。 **安装依赖包** RISC V 体系结构的 python 生态还有欠缺，未来完善之后，YOLOX 中依赖的包可以通过 [requirements.txt](https://github.com/Megvii BaseDetection/YOLOX/blob/main/requirements.txt) 文件直接安装。 本教程中的 YOLOX 示例依赖了较多的 python 包，下载预编译好的 python 包 ```bash git clone b python3.11 https://github.com/zhangwm pt/prebuilt_whl.git cd prebuilt_whl ``` 可以按照以下顺序，手工处理。 ```bash pip install numpy 1.25.0 cp311 cp311 linux_riscv64.whl pip install opencv_python 4.5.4+4cd224d cp311 cp311 linux_riscv64.whl pip install kiwisolver 1.4.4 cp311 cp311 linux_riscv64.whl pip install Pillow 9.5.0 cp311 cp311 linux_riscv64.whl pip install matplotlib 3.7.2.dev0+gb3bd929cf0.d20230630 cp311 cp311 linux_riscv64.whl pip install pycocotools 2.0.6 cp311 cp311 linux_riscv64.whl pip3 install loguru 0.7.0 py3 none any.whl pip3 install torch 2.0.0a0+gitc263bd4 cp311 cp311 linux_riscv64.whl pip3 install MarkupSafe 2.1.3 cp311 cp311 linux_riscv64.whl pip3 install torchvision 0.15.1a0 cp311 cp311 linux_riscv64.whl pip3 install psutil 5.9.5 cp311 abi3 linux_riscv64.whl pip3 install tqdm 4.65.0 py3 none any.whl pip3 install tabulate 0.9.0 py3 none any.whl ``` 安装过程中会涉及到其他纯 python 依赖包，pip 会自动从官方源下载。 **安装 HHB onnxruntime** HHB onnxuruntime 是移植了 SHL 后端（execution providers），让 onnxruntime 能复用到 SHL 中针对玄铁 CPU 的高性能优化代码。 ```bash wget https://github.com/zhangwm pt/onnxruntime/releases/download/riscv_whl/onnxruntime 1.14.1 cp311 cp311 linux_riscv64.whl pip install onnxruntime 1.14.1 cp311 cp311 linux_riscv64.whl ``` **执行** 在示例目录中执行 onnx_inference.py 示例 ```bash python3 onnx_inference.py m yolox_s.onnx i soccer.jpg o outdir s 0.3 input_shape 640,640 ``` `python3 onnx_inference.py m yolox_s.onnx i soccer.jpg o outdir s 0.3 input_shape640,640` 参数说明： m：指定模型 i：指定图片 o：指定输出目录 s：指定检测的阈值 input_shape：指定检测时使用的图片尺寸 **参考结果** 本教程中输入如下图，是运动员踢足球的图片，预期的检测结果是检测到两个人和一个足球。 > 图片来源于网络 ![yolox_detection_soccer_input.jpg](./assets/application/yolox_detection_soccer_input.jpg) 示例正常执行后，会在 outdir 目录下生成结果图片 soccer.jpg。图片中会用框画出检测到的目标，并标注概率，效果如下图： ![yolox_detection_soccer_output.jpg](./assets/application/yolox_detection_soccer_output.jpg) ## MobilenetV2 本教程是一个如何在 LicheePi4A 平台上部署 mobilenetv2 模型完成图像分类的示例。 教程中包括了： 使用 HHB 编译 onnx 模型为 LicheePi4A 上可用的二进制 在 LicheePi4A 上使用 opencv c++ 版本做 mobilenetv2 模型的预处理 在 LicheePi4A 上使用 CPU 和 NPU 的差异 ### NPU #### 环境配置 参考[外设使用](https://wiki.sipeed.com/hardware/zh/lichee/th1520/lpi4a/6_peripheral.html#NPU)文档搭建好 NPU 使用相关环境后，进入到 HHB 环境的 Docker 镜像中。 首先获取本节教程的模型，下载到示例目录 `/home/example/th1520_npu/onnx_mobilenetv2_c++` 下： [mobilenetv2 12.onnx](https://github.com/onnx/models/raw/main/validated/vision/classification/mobilenet/model/mobilenetv2 12.onnx) 并获取本次教程所使用的优化版本 opencv 所需的库文件，前往 [github仓库下载](https://xuantie.t head.cn/community/download?id 4112956065753141248)下载到上一级目录 `/home/example/th1520_npu/` 下。 ```shell cd /home/example/th1520_npu/ git clone https://github.com/zhangwm pt/prebuilt_opencv.git ``` #### 编译 **HHB 编译模型：** 将 ONNX 模型交叉编译成 NPU 上可执行的程序，需要使用 hhb 命令。注意，NPU 上仅支持8位或者16位定点运算，本示例中指定为 int8 非对称量化。编译时需要先进入到示例所在目录 `/home/example/th1520_npu/onnx_mobilenetv2_c++`： ```shell cd /home/example/th1520_npu/onnx_mobilenetv2_c++ hhb D model file mobilenetv2 12.onnx data scale 0.017 data mean \"124 117 104\" board th1520 postprocess save_and_top5 input name \"input\" output name \"output\" input shape \"1 3 224 224\" calibrate dataset persian_cat.jpg quantization scheme \"int8_asym\" ``` 选项说明： D ：指定 HHB 流程执行到生成可执行文件的阶段为止 model file ：指定当前目录中已经下载好的 mobilenet 模型 data mean ：指定均值 data scale ：指定缩放值 board ：指定目标平台为 th1520 input name： 模型的输入名 output name：模型的输出名 input shape：模型的输入大小 postprocess：保存输出结果，并且打印 top5 结果 calibrate dataset：指定量化时所需的校准图片 quantization scheme：指定量化方式为 int8 非对称 命令执行完成后，会在当前目录生成 hhb_out 子目录，里面的包括了 hhb_runtime，model.c 等多个文件： hhb.bm：HHB 的模型文件，包括了量化后的权重数据等信息 hhb_runtime：th1520 平台上的可执行文件，由目录中的c文件编译而成 main.c：临时文件，示例程序的参考入口 model.c：临时文件，模型结构文件，与模型结构相关 model.params：临时文件，权重数值 io.c：临时文件，读写文件的辅助函数 io.h：临时文件，读写文件的辅助函数声明 process.c：临时文件，图像预处理函数 process.h：临时文件，图像预处理函数声明 更详细的 HHB 选项说明可以参考 [HHB用户手册](https://www.yuque.com/za4k4z/oxlbxl/keyg70qggt5n3fpa)中的命令行选项说明。 **g++编译示例：** ```shell riscv64 unknown linux gnu g++ main.cpp I../prebuilt_opencv/include/opencv4 L../prebuilt_opencv/lib lopencv_imgproc lopencv_imgcodecs L../prebuilt_opencv/lib/opencv4/3rdparty/ llibjpeg turbo llibwebp llibpng llibtiff llibopenjp2 lopencv_core ldl lpthread lrt lzlib lcsi_cv latomic static o mobilenetv2_example ``` 编译命令正确执行完成后会在示例目录生成 mobilenetv2_example 文件。 #### 执行 交叉编译完成后，即可将程序执行所需的文件复制到开发板的目录中。可以使用 scp 命令： ```shell scp r ../onnx_mobilenetv2_c++ sipeed@你的开发板ip:~ ``` 先确认开发板中驱动是否加载： ```shell lsmod ``` 若在输出中有 `img_mem`，`vha` 和 `vha_info` 这三个模块，NPU驱动即加载成功。 参考 [YOLOX章节](https://wiki.sipeed.com/hardware/zh/lichee/th1520/lpi4a/8_application.html#YOLOX %E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B) 安装并配置好 python 虚拟环境： ```shell sudo apt update sudo apt install wget git vim wget https://github.com/T head Semi/csi nn2/releases/download/v2.4 beta.1/c920.tar.gz tar xf c920.tar.gz cp c920/lib/* /usr/lib/riscv64 linux gnu/ rf sudo apt install python3 pip sudo apt install python3.11 venv cd /root python3 m venv ort source /root/ort/bin/activate git clone b python3.11 https://github.com/zhangwm pt/prebuilt_whl.git cd prebuilt_whl pip install numpy 1.25.0 cp311 cp311 linux_riscv64.whl pip install opencv_python 4.5.4+4cd224d cp311 cp311 linux_riscv64.whl pip install kiwisolver 1.4.4 cp311 cp311 linux_riscv64.whl pip install Pillow 9.5.0 cp311 cp311 linux_riscv64.whl pip install matplotlib 3.7.2.dev0+gb3bd929cf0.d20230630 cp311 cp311 linux_riscv64.whl pip install pycocotools 2.0.6 cp311 cp311 linux_riscv64.whl pip3 install loguru 0.7.0 py3 none any.whl pip3 install torch 2.0.0a0+gitc263bd4 cp311 cp311 linux_riscv64.whl pip3 install MarkupSafe 2.1.3 cp311 cp311 linux_riscv64.whl pip3 install torchvision 0.15.1a0 cp311 cp311 linux_riscv64.whl pip3 install psutil 5.9.5 cp311 abi3 linux_riscv64.whl pip3 install tqdm 4.65.0 py3 none any.whl pip3 install tabulate 0.9.0 py3 none any.whl ``` 在开发板相应目录下运行刚刚编译好的示例： ```shell ./mobilenetv2_example ``` 执行完成后，会在终端上提示执行到的各个阶段： 1. 预处理 2. 模型执行 3. 后处理 mobilenetv2_example 执行会使用到的文件： persian_cat.jpg：输入图片 input_img.bin：预处理阶段，根据输入图片生成的中间结果 hhb_out/hhb_runtime：模型执行阶段使用的文件，由x86主机上 HHB 生成 hhb_out/hhb.bm：模型执行阶段使用的文件，由x86主机上 HHB 生成 input_img.bin_output0_1_1000.txt：模型执行阶段的输出文件，包括了模型执行输出的 1000 个结果数值 #### 参考结果 ```shell (ort) root@lpi4a:/home/sipeed/onnx_mobilenetv2_c++# ./mobilenetv2_example ********** preprocess image ********** ********** run mobilenetv2 ********** INFO: NNA clock:792000 [kHz] INFO: Heap :ocm (0x18) INFO: Heap :anonymous (0x2) INFO: Heap :dmabuf (0x2) INFO: Heap :unified (0x5) Run graph execution time: 7.87149ms, FPS 127.04 tensor info shape: 1 3 224 224 data pointer: 0x857ca0 tensor info shape: 1 1000 data pointer: 0x3fc9abe000 The max_value of output: 16.053827 The min_value of output: 8.026914 The mean_value of output: 0.001889 The std_value of output: 9.203342 top5: 283: 16.053827 281: 14.165141 287: 11.709850 285: 11.615416 282: 11.332113 ********** postprocess result ********** ********** probability top5: ********** n02123394 Persian cat n02123045 tabby, tabby cat n02127052 lynx, catamount n02124075 Egyptian cat n02123159 tiger cat ``` ### CPU 将上述 NPU 步骤中的 HHB 编译命令替换为： ```shell hhb D model file mobilenetv2 12.onnx data scale 0.017 data mean \"124 117 104\" board c920 postprocess save_and_top5 input name \"input\" output name \"output\" input shape \"1 3 224 224\" ``` g++ 编译后处理命令替换为： ```shell riscv64 unknown linux gnu g++ main.cpp I../prebuilt_opencv/include/opencv4 L../prebuilt_opencv/lib lopencv_imgproc lopencv_imgcodecs L../prebuilt_opencv/lib/opencv4/3rdparty/ llibjpeg turbo llibwebp llibpng llibtiff llibopenjp2 lopencv_core ldl lpthread lrt lzlib lcsi_cv latomic static o mobilenetv2_example ``` 再将编译的到的二进制文件发送到开发板上运行即可。参考结果如下： ```shell (ort) root@lpi4a:/home/sipeed/onnx_mobilenetv2_c++# ./mobilenetv2_example ********** preprocess image ********** ********** run mobilenetv2 ********** Run graph execution time: 79.77252ms, FPS 12.54 tensor info shape: 1 3 224 224 data pointer: 0x259240 tensor info shape: 1 1000 data pointer: 0x1c5200 The max_value of output: 16.843750 The min_value of output: 7.414062 The mean_value of output: 0.001131 The std_value of output: 9.056762 top5: 283: 16.843750 281: 13.789062 287: 12.257812 282: 10.898438 285: 10.765625 ********** postprocess result ********** ********** probability top5: ********** n02123394 Persian cat n02123045 tabby, tabby cat n02127052 lynx, catamount n02123159 tiger cat n02124075 Egyptian cat ``` ## Yolov5n ### NPU #### 环境配置 参考[外设使用](https://wiki.sipeed.com/hardware/zh/lichee/th1520/lpi4a/6_peripheral.html#NPU)文档搭建好 NPU 使用相关环境后，进入到 HHB 环境的 Docker 镜像中。 首先获取本节教程的模型，下载到示例目录 `/home/example/th1520_npu/yolov5n` 下： ```shell git clone https://github.com/ultralytics/yolov5.git cd yolov5 pip3 install ultralytics python3 export.py weights yolov5n.pt include onnx imgsz 384 640 ``` #### 编译 **HHB 编译模型：** 将 ONNX 模型交叉编译成 NPU 上可执行的程序，需要使用 hhb 命令。注意，NPU 上仅支持8位或者16位定点运算，本示例中指定为 int8 非对称量化。编译时需要先进入到示例所在目录 `/home/example/th1520_npu/yolov5n`： ```shell cd /home/example/th1520_npu/yolov5n hhb D model file yolov5n.onnx data scale div 255 board th1520 input name \"images\" output name \"/model.24/m.0/Conv_output_0;/model.24/m.1/Conv_output_0;/model.24/m.2/Conv_output_0\" input shape \"1 3 384 640\" calibrate dataset kite.jpg quantization scheme \"int8_asym\" ``` 选项说明： D ：指定 HHB 流程执行到生成可执行文件的阶段为止 model file ：指定当前目录中已经下载好的 yolov5 模型 data mean ：指定均值 data scale ：指定缩放值 board ：指定目标平台为 th1520 input name： 模型的输入名 output name：模型的输出名 input shape：模型的输入大小 postprocess：保存输出结果，并且打印 top5 结果 calibrate dataset：指定量化时所需的校准图片 quantization scheme：指定量化方式为 int8 非对称 命令执行完成后，会在当前目录生成 hhb_out 子目录，里面的包括了 hhb_runtime，model.c 等多个文件： hhb.bm：HHB 的模型文件，包括了量化后的权重数据等信息 hhb_runtime：th1520 平台上的可执行文件，由目录中的c文件编译而成 main.c：临时文件，示例程序的参考入口 model.c：临时文件，模型结构文件，与模型结构相关 model.params：临时文件，权重数值 io.c：临时文件，读写文件的辅助函数 io.h：临时文件，读写文件的辅助函数声明 process.c：临时文件，图像预处理函数 process.h：临时文件，图像预处理函数声明 更详细的 HHB 选项说明可以参考 [HHB用户手册](https://www.yuque.com/za4k4z/oxlbxl/keyg70qggt5n3fpa)中的命令行选项说明。 **g++编译示例：** ```shell riscv64 unknown linux gnu gcc yolov5n.c o yolov5n_example hhb_out/io.c hhb_out/model.c Wl, gc sections O2 g mabi lp64d I hhb_out/ L /usr/local/lib/python3.8/dist packages/hhb/install_nn2/th1520/lib/ lshl L /usr/local/lib/python3.8/dist packages/hhb/prebuilt/decode/install/lib/rv L /usr/local/lib/python3.8/dist packages/hhb/prebuilt/runtime/riscv_linux lprebuilt_runtime ljpeg lpng lz lstdc++ lm I /usr/local/lib/python3.8/dist packages/hhb/install_nn2/th1520/include/ mabi lp64d march rv64gcv0p7_zfh_xtheadc Wl, unresolved symbols ignore in shared libs ``` 编译命令正确执行完成后会在示例目录生成 yolov5n_example 文件。 #### 执行 交叉编译完成后，即可将程序执行所需的文件复制到开发板的目录中。可以使用 scp 命令： ```shell scp r ../yolov5n sipeed@你的开发板ip:~ ``` 先确认开发板中驱动是否加载： ```shell lsmod ``` 若在输出中有 `img_mem`，`vha` 和 `vha_info` 这三个模块，NPU驱动即加载成功。 参考 [YOLOX章节](https://wiki.sipeed.com/hardware/zh/lichee/th1520/lpi4a/8_application.html#YOLOX %E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B) 安装并配置好 python 虚拟环境： ```shell sudo apt update sudo apt install wget git vim wget https://github.com/T head Semi/csi nn2/releases/download/v2.4 beta.1/c920.tar.gz tar xf c920.tar.gz cp c920/lib/* /usr/lib/riscv64 linux gnu/ rf sudo apt install python3 pip sudo apt install python3.11 venv cd /root python3 m venv ort source /root/ort/bin/activate git clone b python3.11 https://github.com/zhangwm pt/prebuilt_whl.git cd prebuilt_whl pip install numpy 1.25.0 cp311 cp311 linux_riscv64.whl pip install opencv_python 4.5.4+4cd224d cp311 cp311 linux_riscv64.whl pip install kiwisolver 1.4.4 cp311 cp311 linux_riscv64.whl pip install Pillow 9.5.0 cp311 cp311 linux_riscv64.whl pip install matplotlib 3.7.2.dev0+gb3bd929cf0.d20230630 cp311 cp311 linux_riscv64.whl pip install pycocotools 2.0.6 cp311 cp311 linux_riscv64.whl pip3 install loguru 0.7.0 py3 none any.whl pip3 install torch 2.0.0a0+gitc263bd4 cp311 cp311 linux_riscv64.whl pip3 install MarkupSafe 2.1.3 cp311 cp311 linux_riscv64.whl pip3 install torchvision 0.15.1a0 cp311 cp311 linux_riscv64.whl pip3 install psutil 5.9.5 cp311 abi3 linux_riscv64.whl pip3 install tqdm 4.65.0 py3 none any.whl pip3 install tabulate 0.9.0 py3 none any.whl ``` 在开发板相应目录下运行刚刚编译好的示例： ```shell python3 inference.py ``` 执行完成后，会在终端上提示执行到的各个阶段： 1. 预处理：将原图填充缩放到 384 * 640 的大小 2. 模型执行和后处理：执行模型推理，并做 nms 等后处理 3. 画框：将检测结果画在 384 *640 尺寸的图上，并输出新图片 inference.py 执行会使用到的文件： kite.jpg：输入图片 image_preprocessed.bin：预处理阶段，根据输入图片生成的中间结果 yolov5n_example：模型执行阶段使用的文件，由x86主机上 gcc 编译生成 hhb_out/hhb.bm：模型执行阶段使用的文件，由x86主机上 HHB 生成 detect.txt：后处理阶段的输出文件，包括了图片中检测出来的 4 个目标 kite_result.jpg：输出图片，将检测框加入到输入图上的结果 #### 参考结果 ```shell (ort) root@lpi4a:/home/sipeed/yolov5n_npu# python3 inference.py ********** preprocess image ********** ******* run yolov5 and postprocess ******* INFO: NNA clock:792000 [kHz] INFO: Heap :ocm (0x18) INFO: Heap :anonymous (0x2) INFO: Heap :dmabuf (0x2) INFO: Heap :unified (0x5) Run graph execution time: 5.36258ms, FPS 186.48 detect num: 4 id: label score x1 y1 x2 y2 [0]: 0 0.895277 273.492188 161.245056 359.559814 330.644257 [1]: 0 0.887368 79.860062 179.181244 190.755692 354.304474 [2]: 0 0.815214 222.054550 224.477600 279.828979 333.717285 [3]: 33 0.563324 67.625580 173.948883 201.687988 219.065765 ********** draw bbox ********** [273.492188, 161.245056, 359.559814, 330.644257, 0.895277, 0] [79.860062, 179.181244, 190.755692, 354.304474, 0.887368, 0] [222.05455, 224.4776, 279.828979, 333.717285, 0.815214, 0] [67.62558, 173.948883, 201.687988, 219.065765, 0.563324, 33] ``` > 示例图片来源于网络。 ![yolov5n_detection_soccer_output](./assets/application/yolov5n_detection_soccer_output.jpg) ### CPU 将上述 NPU 步骤中的 HHB 编译命令替换为： ```shell hhb D model file yolov5n.onnx data scale div 255 board c920 input name \"images\" output name \"/model.24/m.0/Conv_output_0;/model.24/m.1/Conv_output_0;/model.24/m.2/Conv_output_0\" input shape \"1 3 384 640\" ``` gcc 编译后处理命令替换为： ```shell riscv64 unknown linux gnu gcc yolov5n.c static o yolov5n_example hhb_out/io.c hhb_out/model.c Wl, gc sections O2 g mabi lp64d I hhb_out/ L /usr/local/lib/python3.8/dist packages/hhb/install_nn2/c920/lib/ lshl static L /usr/local/lib/python3.8/dist packages/hhb/prebuilt/decode/install/lib/rv L /usr/local/lib/python3.8/dist packages/hhb/prebuilt/runtime/riscv_linux lprebuilt_runtime ljpeg lpng lz lstdc++ lm I /usr/local/lib/python3.8/dist packages/hhb/install_nn2/c920/include/ mabi lp64d march rv64gcv0p7_zfh_xtheadc ``` 再将编译的到的二进制文件发送到开发板上运行即可。参考结果如下： ```shell (ort) root@lpi4a:/home/sipeed/yolov5n_cpu# python3 inference.py ********** preprocess image ********** ******* run yolov5 and postprocess ******* Run graph execution time: 387.34067ms, FPS 2.58 detect num: 4 id: label score x1 y1 x2 y2 [0]: 0 0.901887 274.524475 158.559036 359.169312 332.431702 [1]: 0 0.879545 80.073883 184.767792 190.130157 349.906281 [2]: 0 0.845192 219.378418 221.662415 283.860413 333.798584 [3]: 33 0.666908 67.099136 174.128189 202.971451 220.213608 ********** draw bbox ********** [274.524475, 158.559036, 359.169312, 332.431702, 0.901887, 0] [80.073883, 184.767792, 190.130157, 349.906281, 0.879545, 0] [219.378418, 221.662415, 283.860413, 333.798584, 0.845192, 0] [67.099136, 174.128189, 202.971451, 220.213608, 0.666908, 33] ``` ## Yolov5s 参考 yolov5n 的编译步骤，只需将 yolov5n.onnx 文件替换为 yolov5s.onnx，并将 HHB 和 GCC 编译命令中的参数 `yolov5n.onnx` 更改为 `yolov5s.onnx` 即可。 ### 环境配置 在 x86 主机中，参考[外设使用](https://wiki.sipeed.com/hardware/zh/lichee/th1520/lpi4a/6_peripheral.html#NPU)文档搭建好 NPU 使用相关环境后，进入到 HHB 环境的 Docker 镜像中。 在 1520 上，参考 [YOLOX章节](https://wiki.sipeed.com/hardware/zh/lichee/th1520/lpi4a/8_application.html#YOLOX %E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B) 安装并配置好 python 虚拟环境。 ### CPU #### 编译过程 **HBB 编译** ```shell hhb D model file yolov5s.onnx data scale div 255 board c920 input name \"images\" output name \"/model.24/m.0/Conv_output_0;/model.24/m.1/Conv_output_0;/model.24/m.2/Conv_output_0\" input shape \"1 3 384 640\" ``` HHB 命令中截取到最后的卷积层为止，卷积层之后的后处理，由 yolov5s.c 文件处理。`yolov5s.c` 可以参考 yolov5n 示例下的 `yolov5n.c` 文件。 **GCC 编译** ```shell riscv64 unknown linux gnu gcc yolov5s.c static o yolov5s_example hhb_out/io.c hhb_out/model.c Wl, gc sections O2 g mabi lp64d I hhb_out/ L /usr/local/lib/python3.8/dist packages/hhb/install_nn2/c920/lib/ lshl static L /usr/local/lib/python3.8/dist packages/hhb/prebuilt/decode/install/lib/rv L /usr/local/lib/python3.8/dist packages/hhb/prebuilt/runtime/riscv_linux lprebuilt_runtime ljpeg lpng lz lstdc++ lm I /usr/local/lib/python3.8/dist packages/hhb/install_nn2/c920/include/ mabi lp64d march rv64gcv0p7_zfh_xtheadc ``` #### 参考结果 ```shell (ort) root@lpi4a:/home/sipeed/yolov5s# python3 inference.py ********** preprocess image ********** ******* run yolov5 and postprocess ******* Run graph execution time: 821.20135ms, FPS 1.22 detect num: 4 id: label score x1 y1 x2 y2 [0]: 0 0.932165 275.538910 159.163147 359.211151 329.072205 [1]: 0 0.888989 219.883255 222.074265 285.310486 334.005676 [2]: 0 0.840487 85.319901 184.137268 186.844284 346.103210 [3]: 33 0.783095 70.033737 176.102921 202.740250 218.405075 ********** draw bbox ********** [275.53891, 159.163147, 359.211151, 329.072205, 0.932165, 0] [219.883255, 222.074265, 285.310486, 334.005676, 0.888989, 0] [85.319901, 184.137268, 186.844284, 346.10321, 0.840487, 0] [70.033737, 176.102921, 202.74025, 218.405075, 0.783095, 33] ``` ### NPU #### 编译过程 参考 yolov5n 即可。 **HHB 编译** ```shell hhb D model file yolov5s.onnx data scale div 255 board th1520 input name \"images\" output name \"/model.24/m.0/Conv_output_0;/model.24/m.1/Conv_output_0;/model.24/m.2/Conv_output_0\" input shape \"1 3 384 640\" calibrate dataset kite.jpg quantization scheme \"int8_asym\" ``` **GCC 编译** HHB 命令中截取到最后的卷积层为止，卷积层之后的后处理，由 yolov5s.c 文件处理。`yolov5s.c` 可以参考 yolov5n 示例下的 `yolov5n.c` 文件。 ```shell riscv64 unknown linux gnu gcc yolov5s.c o yolov5s_example hhb_out/io.c hhb_out/model.c Wl, gc sections O2 g mabi lp64d I hhb_out/ L /usr/local/lib/python3.8/dist packages/hhb/install_nn2/th1520/lib/ lshl L /usr/local/lib/python3.8/dist packages/hhb/prebuilt/decode/install/lib/rv L /usr/local/lib/python3.8/dist packages/hhb/prebuilt/runtime/riscv_linux lprebuilt_runtime ljpeg lpng lz lstdc++ lm I /usr/local/lib/python3.8/dist packages/hhb/install_nn2/th1520/include/ mabi lp64d march rv64gcv0p7_zfh_xtheadc Wl, unresolved symbols ignore in shared libs ``` #### 参考结果 ```shell (ort) root@lpi4a:/home/sipeed/yolov5s_npu# python3 inference.py ********** preprocess image ********** ******* run yolov5 and postprocess ******* INFO: NNA clock:792000 [kHz] INFO: Heap :ocm (0x18) INFO: Heap :anonymous (0x2) INFO: Heap :dmabuf (0x2) INFO: Heap :unified (0x5) Run graph execution time: 9.85487ms, FPS 101.47 detect num: 4 id: label score x1 y1 x2 y2 [0]: 0 0.933075 276.321838 157.925751 358.274475 329.757538 [1]: 0 0.893568 219.203781 221.895264 286.790039 334.801636 [2]: 0 0.848185 83.283234 182.688538 187.325684 346.702515 [3]: 33 0.800765 68.743454 175.539230 204.108292 218.260056 ********** draw bbox ********** [276.321838, 157.925751, 358.274475, 329.757538, 0.933075, 0] [219.203781, 221.895264, 286.790039, 334.801636, 0.893568, 0] [83.283234, 182.688538, 187.325684, 346.702515, 0.848185, 0] [68.743454, 175.53923, 204.108292, 218.260056, 0.800765, 33] ``` ## BERT ### CPU #### 环境配置 参考[外设使用](https://wiki.sipeed.com/hardware/zh/lichee/th1520/lpi4a/6_peripheral.html#NPU)文档搭建好 NPU 使用相关环境后，进入到 HHB 环境的 Docker 镜像中。 首先获取模型，本教程中使用的模型来自 google bert 仓库，已转换成 onnx 版本的 BERT 模型，可以用如下命令下载到 `/home/example/c920/bert_small` 目录下: ```shell cd home/example/c920/bert_small wget https://github.com/zhangwm pt/bert/releases/download/onnx/bert_small_int32_input.onnx ``` #### 编译 **HHB 编译模型：** 将 ONNX 模型交叉编译成 NPU 上可执行的程序，需要使用 hhb 命令。注意，NPU 上仅支持8位或者16位定点运算，本示例中指定为 int8 非对称量化。编译时需要先进入到示例所在目录 `/home/example/c920/bert_small`： ```shell cd /home/example/c920/bert_small hhb model file bert_small_int32_input.onnx input name \"input_ids;input_mask;segment_ids\" input shape '1 384;1 384;1 384' output name \"output_start_logits;output_end_logits\" board c920 quantization scheme \"float16\" postprocess save_and_top5 D without preprocess ``` 选项说明： D ：指定 HHB 流程执行到生成可执行文件的阶段为止 model file ：指定当前目录中已经下载好的 bert 模型 data mean ：指定均值 data scale ：指定缩放值 board ：指定目标平台为 th1520 input name： 模型的输入名 output name：模型的输出名 input shape：模型的输入大小 postprocess：保存输出结果，并且打印 top5 结果 calibrate dataset：指定量化时所需的校准图片 quantization scheme：指定量化方式为 int8 非对称 命令执行完成后，会在当前目录生成 hhb_out 子目录，里面的包括了 hhb_runtime，model.c 等多个文件： hhb.bm：HHB 的模型文件，包括了量化后的权重数据等信息 hhb_runtime：th1520 平台上的可执行文件，由目录中的c文件编译而成 main.c：临时文件，示例程序的参考入口 model.c：临时文件，模型结构文件，与模型结构相关 model.params：临时文件，权重数值 io.c：临时文件，读写文件的辅助函数 io.h：临时文件，读写文件的辅助函数声明 process.c：临时文件，图像预处理函数 process.h：临时文件，图像预处理函数声明 更详细的 HHB 选项说明可以参考 [HHB用户手册](https://www.yuque.com/za4k4z/oxlbxl/keyg70qggt5n3fpa) 中的命令行选项说明。 编译命令正确执行完成后会在示例目录生成可执行文件，将该示例目录拷贝至开发板中即可运行。 ```shell scp r ../bert_small sipeed@你的ip:~ ``` #### 执行 执行示例程序的前置步骤同 YOLOv5n，此处不在赘述。 前置步骤准确无误后，即可在示例目录执行命令 ```shell python3 inference.py ``` #### 参考结果 本示例中的参考输入来自 SQuAD 数据集，SQuAD 是一个阅读理解数据集，由一组维基百科文章提出的问题组成，其中每个问题的答案都是来自相应阅读文章或问题的一段文本。 本示例的输入如下，文章内容描述了一次橄榄球比赛的赛况，提出的问题是谁参加了比赛。 ``` [Context]: Super Bowl 50 was an American football game to determine the champion of the National Football League (NFL) for the 2015 season. The American Football Conference (AFC) champion Denver Broncos defeated the National Football Conference (NFC) champion Carolina Panthers 24–10 to earn their third Super Bowl title. The game was played on February 7, 2016, at Levi's Stadium in the San Francisco Bay Area at Santa Clara, California. As this was the 50th Super Bowl, the league emphasized the \"golden anniversary\" with various gold themed initiatives, as well as temporarily suspending the tradition of naming each Super Bowl game with Roman numerals (under which the game would have been known as \"Super Bowl L\"), so that the logo could prominently feature the Arabic numerals 50. [Question]: Which NFL team represented the AFC at Super Bowl 50? ``` 根据阅读理解的结果，预期输出将是 Denver Broncos ```shell (ort) root@lpi4a:/home/sipeed/bert_small_cpu# python3 inference.py ********** preprocess test ********** [Context]: Super Bowl 50 was an American football game to determine the champion of the National Football League (N FL) for the 2015 season. The American Football Conference (AFC) champion Denver Broncos defeated the National Footba ll Conference (NFC) champion Carolina Panthers 24–10 to earn their third Super Bowl title. The game was played on Fe bruary 7, 2016, at Levi's Stadium in the San Francisco Bay Area at Santa Clara, California. As this was the 50th Sup er Bowl, the league emphasized the \"golden anniversary\" with various gold themed initiatives, as well as temporarily suspending the tradition of naming each Super Bowl game with Roman numerals (under which the game would have been k nown as \"Super Bowl L\"), so that the logo could prominently feature the Arabic numerals 50. [Question]: Which NFL team represented the AFC at Super Bowl 50? ******* run bert ******* Run graph execution time: 1713.15491ms, FPS 0.58 tensor info shape: 1 384 data pointer: 0x183d60 tensor info shape: 1 384 data pointer: 0x185380 tensor info shape: 1 384 data pointer: 0x1869a0 tensor info shape: 1 384 data pointer: 0x2a8610 The max_value of output: 3.826172 The min_value of output: 9.968750 The mean_value of output: 8.412353 The std_value of output: 5.128320 top5: 46: 3.826172 57: 3.142578 39: 1.303711 38: 1.179688 27: 0.624512 tensor info shape: 1 384 data pointer: 0x2a8300 The max_value of output: 3.617188 The min_value of output: 9.625000 The mean_value of output: 7.798176 The std_value of output: 4.820137 top5: 47: 3.617188 58: 3.482422 32: 2.523438 29: 1.541992 41: 1.473633 ********** postprocess ********** [Answer]: Denver Broncos ``` ## Docker 首先安装所需要的软件包 ```shell sudo apt get update sudo apt get install docker docker compose ``` 安装完成后，使用 `sudo docker info` 命令验证安装是否成功： ```shell sipeed@lpi4a:~$ sudo docker info Client: Context: default Debug Mode: false Server: Containers: 0 Running: 0 Paused: 0 Stopped: 0 Images: 0 Server Version: 20.10.24+dfsg1 Storage Driver: overlay2 Backing Filesystem: extfs Supports d_type: true Native Overlay Diff: true userxattr: false Logging Driver: json file Cgroup Driver: systemd Cgroup Version: 2 Plugins: Volume: local Network: bridge host ipvlan macvlan null overlay Log: awslogs fluentd gcplogs gelf journald json file local logentries splunk syslog Swarm: inactive Runtimes: io.containerd.runc.v2 io.containerd.runtime.v1.linux runc Default Runtime: runc Init Binary: docker init containerd version: 1.6.20~ds1 1+b1 runc version: 1.1.5+ds1 1+b1 init version: Security Options: seccomp Profile: default cgroupns Kernel Version: 5.10.113 gfac22a756532 Operating System: Debian GNU/Linux 12 (bookworm) OSType: linux Architecture: riscv64 CPUs: 4 Total Memory: 15.47GiB Name: lpi4a ID: MCKE:SEGQ:EBUX:ZMLC:P2WK:GIJ7:XAEQ:F56H:73HK:C3L5:IA5A:7GJI Docker Root Dir: /var/lib/docker Debug Mode: false Registry: https://index.docker.io/v1/ Labels: Experimental: false Insecure Registries: 127.0.0.0/8 Live Restore Enabled: false ``` 若想让普通用户也有 Docker 的执行权限，可以执行以下命令来实现： ```shell sudo groupadd docker sudo usermod aG docker $USER newgrp docker ``` 这些命令添加普通用户权限的用户名到 `docker` 用户组，并激活组权限。若不添加，则每次执行 Docker 相关命令时，需要以 sudo 权限来执行。 接下来，我们拉取 hello world 镜像体验 Docker 的使用： ```shell sipeed@lpi4a:~$ docker pull hello world Using default tag: latest latest: Pulling from library/hello world b102dd09f2b3: Pull complete Digest: sha256:926fac19d22aa2d60f1a276b66a20eb765fbeea2db5dbdaafeb456ad8ce81598 Status: Downloaded newer image for hello world:latest docker.io/library/hello world:latest ``` 接下来，启动刚刚拉取下来的容器： ```shell sipeed@lpi4a:~$ docker run hello world Hello from Docker! This message shows that your installation appears to be working correctly. To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the \"hello world\" image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal. To try something more ambitious, you can run an Ubuntu container with: $ docker run it ubuntu bash Share images, automate workflows, and more with a free Docker ID: https://hub.docker.com/ For more examples and ideas, visit: https://docs.docker.com/get started/ ``` 查看 hello world 镜像的相关信息： ```shell sipeed@lpi4a:~$ docker images hello world REPOSITORY TAG IMAGE ID CREATED SIZE hello world latest eb6f80695a28 2 months ago 4.98kB ``` 若要体验更完整的镜像，去[这里](https://hub.docker.com/)搜索想要使用的发行版名称，拉取即可。 ## K3s RISCV 该章节将展示如何在 LPi4A 上运行轻量级的 Kubernetes 发行版本 K3s。 先下载预编译的 K3s包： https://github.com/CARV ICS FORTH/k3s/releases 然后将下载下来的包合并为一个 `.gz` 文件并解压，完成后给 k3s 添加执行权限： ```shell wget https://github.com/CARV ICS FORTH/k3s/releases/download/20230721/k3s riscv64.gz.aa wget https://github.com/CARV ICS FORTH/k3s/releases/download/20230721/k3s riscv64.gz.ab wget https://github.com/CARV ICS FORTH/k3s/releases/download/20230721/k3s riscv64.gz.ac # 下面的命令需要root用户来执行 sudo i cat k3s riscv64.gz.* gunzip > /usr/local/bin/k3s chmod +x /usr/local/bin/k3s exit ``` 验证是否能成功运行，成功运行的典型输出如下： ```shell sipeed@lpi4a:~$ k3s NAME: k3s riscv64 Kubernetes, but small and simple USAGE: k3s riscv64 [global options] command [command options] [arguments...] VERSION: v1.27.3+k3s 9d376dfb dirty (9d376dfb) COMMANDS: server Run management server agent Run node agent kubectl Run kubectl crictl Run crictl ctr Run ctr check config Run config check token Manage bootstrap tokens etcd snapshot secrets encrypt Control secrets encryption and keys rotation certificate Manage K3s certificates completion Install shell completion script help, h Shows a list of commands or help for one command GLOBAL OPTIONS: debug (logging) Turn on debug logs [$K3S_DEBUG] data dir value, d value (data) Folder to hold state (default: /var/lib/r) help, h show help version, v print the version ``` 现在，下载并运行 k3s 的安装脚本： ```shell curl sfL https://get.k3s.io > k3s install.sh chmod +x k3s install.sh INSTALL_K3S_EXEC \"server disable metrics server\" INSTALL_K3S_SKIP_DOWNLOAD \"true\" bash x ./k3s install.sh ``` 运行完成后，使用如下命令检查 k3s 是否正常运行。典型输出如下： ```shell sipeed@lpi4a:~$ systemctl status k3s ● k3s.service Lightweight Kubernetes Loaded: loaded (8;;file://lpi4a/etc/systemd/system/k3s.service/etc/systemd) Active: active (running) since Mon 2023 07 31 06:48:34 UTC; 6s ago Docs: 8;;https://k3s.iohttps://k3s.io8;; Process: 3240 ExecStartPre /bin/sh xc ! /usr/bin/systemctl is enabled qu> Process: 3242 ExecStartPre /sbin/modprobe br_netfilter (code exited, status> Process: 3243 ExecStartPre /sbin/modprobe overlay (code exited, status 0/SU> Main PID: 3244 (k3s server) Tasks: 37 Memory: 529.5M CPU: 54.841s CGroup: /system.slice/k3s.service ├─3244 \"/usr/local/bin/k3s server\" └─3361 \"containerd ``` 接下来我们新建一个配置文件，运行 k3s 容器： ```shell vi hello lpi4a.yaml ``` 文件内容如下（参考https://raw.githubusercontent.com/CARV ICS FORTH/kubernetes riscv64/main/examples/hello kubernetes.yaml）： ```yaml apiVersion: v1 kind: Service metadata: name: hello spec: type: ClusterIP ports: port: 8080 selector: app: hello apiVersion: apps/v1 kind: Deployment metadata: name: hello spec: replicas: 1 selector: matchLabels: app: hello template: metadata: labels: app: hello spec: containers: name: hello kubernetes image: carvicsforth/hello kubernetes:1.10.1 env: name: MESSAGE value: \"Hello Lichee Pi 4A!\" ``` 然后使用这个配置文件启动一个容器。典型输入如下： ```shell sipeed@lpi4a:~$ sudo kubectl apply f hello lpi4a.yaml service/hello created deployment.apps/hello created ``` 然后查看 pods 情况（若输出中没显示 IP 地址，可以多等待一会儿再查看）： ```shell sipeed@lpi4a:~$ NAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATES hello 5b576d45d7 fdjgh 1/1 Running 0 16m 10.42.0.6 lpi4a <none> <none> ``` 接下来使用 curl 测试 k3s 容器是否运行成功，典型输出如下： ```shell sipeed@lpi4a:~$ curl 10.42.0.6:8080 <!DOCTYPE html> <html> <head> <title>Hello Kubernetes!</title> <link rel \"stylesheet\" type \"text/css\" href \"/css/main.css\"> <link rel \"stylesheet\" href \"https://fonts.googleapis.com/css?family Ubuntu:300\" > </head> <body> <div class \"main\"> <img src \"/images/kubernetes.png\"/> <div class \"content\"> <div id \"message\"> Hello Lichee Pi 4A! </div> <div id \"info\"> <table> <tr> <th>namespace:</th> <td> </td> </tr> <tr> <th>pod:</th> <td>hello 5b576d45d7 fdjgh</td> </tr> <tr> <th>node:</th> <td> (Linux 5.10.113 gfac22a756532)</td> </tr> </table> </div> <div id \"footer\"> paulbouwer/hello kubernetes:1.10.1 (linux/riscv64) </div> </div> </div> </body> </html> ``` 至此，k3s容器已经运行成功。 页面效果如下： ![k3s_hello_world](./assets/application/k3s_hello_world.png) <! 最后，修改配置文件使得容器能够被外部设备访问： ```shell apiVersion: v1 kind: Service metadata: name: hello spec: type: NodePort ports: port: 8080 targetPort: 8080 nodePort: 30080 protocol: TCP selector: app: hello apiVersion: apps/v1 kind: Deployment metadata: name: hello spec: replicas: 1 selector: matchLabels: app: hello template: metadata: labels: app: hello spec: containers: name: hello kubernetes image: carvicsforth/hello kubernetes:1.10.1 env: name: MESSAGE value: \"Hello Lichee Pi 4A!\" ``` 其中的 `nodePort` 为 30000 32767 中的任意一个数字。 更改后，应用新的配置文件： ```shell sipeed@lpi4a:~$ sudo kubectl apply f hello lpi4a.yaml service/hello configured deployment.apps/hello unchanged ``` > ## Minecraft Server 这里以`1.20.1`版本为例，LPi4A 作为 Server，电脑端（Ubuntu 22.04）作为 Client。 首先在[这里](https://github.com/fizzed/nitro/releases/tag/builds)下载由 Fizzed 优化的 nitro JDK 19，下载完成后解压，重命名文件夹并移动到 `/opt/` 目录下： ```shell tar xvf fizzed19.36 jdk19.0.1 linux_riscv64.tar.gz sudo mv fizzed19.36 jdk19.0.1 linux_riscv64 /opt/jdk_19 ``` 测试该 JDK 是否可用： ```shell sipeed@lpi4a:~$ /opt/jdk_19/bin/java version openjdk version \"19.0.1\" 2022 09 20 OpenJDK Runtime Environment Fizzed19.36 (build 19.0.1+10) OpenJDK 64 Bit Server VM Fizzed19.36 (build 19.0.1+10, mixed mode) ``` 若出现版本号则可用。若已经预装了别的版本的 JDK，那么可以更改下软连接，先查看原先的软链接信息，记录下方便后面改回来： ```shell sipeed@lpi4a:~$ ls /usr/bin/java l lrwxrwxrwx 1 root root 22 Apr 26 10:40 /usr/bin/java > /etc/alternatives/java ``` 然后更改软链接指向刚刚安装的 JDK： ```shell sudo rm /usr/bin/java sudo ln s /opt/jdk_19/bin/java /usr/bin/java ``` 使用命令验证软链接是否配置成功： ```shell java version ``` 出现版本，则配置成功。 接下来，在[这里](https://www.minecraft.net/zh hans/download)下载原版服务端 jar 文件到 LPi4A，注意版本为`1.20.1`，然后在 LPi4A 上先执行： ```shell java jar server.jar nogui ``` 若出现提示 ```shell [ServerMain/WARN]: Failed to load eula.txt [ServerMain/INF0]:You need to agree to the EULA in order to run the server. Go to e ula.txt for more info. ``` 则将当前目录下的 `eula.txt`文件中对应行改为的 false 改为 true： ```shell eula true ``` 保存后退出，重新启动服务器，第一次启动会比较慢，耐心等待，启动完成后会显示启动用时（下列用时并非第一次启动用时）： ```shell [03:51:02] [Server thread/INFO]: Time elapsed: 36394 ms [03:51:02] [Server thread/INFO]: Done (52.927s)! For help, type \"help\" ``` 接下来，在 PC 端启动客户端后即可连接，建议使用第三方客户端启动器 HMCL（下载链接https://hmcl.huangyuhui.net/download/）。 下载完成后，启动 HMCL： ```shell java jar HMCL 3.5.5.jar ``` 可以直接在启动器中下载`1.20.1`版本，并且配置好游戏账户，然后即可进入游戏，进入游戏后，输入 服务器 IP（LPi4A 的 IP）添加服务器后即可连接（确保电脑和 LPi4A 处于同一网络下），效果如下： ![mc_server_menu](./assets/application/mc_server_menu.png) ![mc_server_use](./assets/application/mc_server_use.png) > 注意，若想改回原来版本的 JDK，则执行： > ```shell > sudo rm /usr/bin/java > sudo ln s /opt/jdk_19/bin/java /etc/alternatives/java > ``` ## Wine CE 首先在[这里](https://gitee.com/wine ce/wine ce/releases/tag/v8.9)下载 `wine ce_dlls_8.9.0.all.tar.xz`，`wine ce_core_8.9.0.riscv64.tar.xz`这两个文件，这里假设下载到用户主目录（撰写该文档时最新版本为8.9）。 然后根据文档中的步骤进行安装： ```shell sudo apt install fonts liberation fonts wine glib networking libpulse0 gstreamer1.0 plugins good gstreamer1.0 x libaa1 libaom3 libasound2 plugins libcaca0 libcairo gobject2 libcodec2 1.0 libdav1d6 libdv4 libgdk pixbuf 2.0 0 libgomp1 libgpm2 libiec61883 0 libjack jackd2 0 libmp3lame0 libncurses6 libncursesw6 libnuma1 libodbc2 libproxy1v5 libraw1394 11 librsvg2 2 librsvg2 common libsamplerate0 libshine3 libshout3 libslang2 libsnappy1v5 libsoup2.4 1 libsoxr0 libspeex1 libspeexdsp1 libtag1v5 libtag1v5 vanilla libtwolame0 libva drm2 libva x11 2 libva2 libvdpau1 libvkd3d shader1 libvkd3d1 libvpx7 libwavpack1 libwebpmux3 libx265 199 libxdamage1 libxvidcore4 libzvbi common libzvbi0 mesa va drivers mesa vdpau drivers va driver all vdpau driver all vkd3d compiler sudo tar Jxvf wine ce_core_8.9.0.riscv64.tar.xz C /opt/ sudo tar Jxvf wine ce_dlls_8.9.0.all.tar.xz C /opt/ sudo ln sf /opt/wine ce/bin/wine /usr/bin/wine sudo ln sf /opt/wine ce/bin/winecfg /usr/bin/winecfg rm rf ~/.wine ``` 接下来进行一些初始化设置： ```shell winecfg ``` 这里使用的设置如下： ![wine_ce_settings](./assets/application/wine_ce_settings.png) 设置完成后，即可运行 Windows 下的程序，比如这里的命令运行 Windows 下的记事本 ```shell wine notepad.exe ``` ![wine_ce_use](./assets/application/wine_ce_use.png) ## 使用优化 GCC 工具链 实验性 feature 如果发现问题可以进行 [issue](https://github.com/revyos/revyos/issues) 申报。 安装步骤 ```shell # 增加优化源 sudo sed i '1ideb https://mirror.iscas.ac.cn/revyos/revyos c910v/ revyos c910v main' /etc/apt/sources.list # 更新软件 sudo apt update # 安装 gcc 10/gcc 13 sudo apt install y build essential # gcc 10 sudo apt install y gcc 13 g++ 13 # gcc 13 # 重启避免其他问题 sudo reboot ``` 测试 gcc 10 (gcc10.4 启用 xtheadc+v0p7) ```shell gcc v Using built in specs. COLLECT_GCC gcc COLLECT_LTO_WRAPPER /usr/lib/gcc/riscv64 linux gnu/10/lto wrapper Target: riscv64 linux gnu Configured with: ../src/configure v with pkgversion 'Debian 10.4.0 8revyos2.3' with bugurl file:///usr/share/doc/gcc 10/README.Bugs enable languages c,ada,c++,go,d,fortran,objc,obj c++,m2 prefix /usr with gcc major version only program suffix 10 program prefix riscv64 linux gnu enable shared enable linker build id libexecdir /usr/lib without included gettext enable threads posix libdir /usr/lib enable nls enable clocale gnu enable libstdcxx debug enable libstdcxx time yes with default libstdcxx abi new enable gnu unique object disable libitm disable libsanitizer disable libquadmath disable libquadmath support enable plugin enable default pie with system zlib enable libphobos checking release with target system zlib auto enable objc gc auto enable multiarch disable werror disable multilib with arch rv64gcv0p7_zfh_xtheadc with abi lp64d enable checking release build riscv64 linux gnu host riscv64 linux gnu target riscv64 linux gnu Thread model: posix Supported LTO compression algorithms: zlib zstd gcc version 10.4.0 (Debian 10.4.0 8revyos2.3) ``` 测试 gcc 13 (gcc13.2 启用 xthead extension) ```shell gcc 13 v Using built in specs. COLLECT_GCC gcc 13 COLLECT_LTO_WRAPPER /usr/libexec/gcc/riscv64 linux gnu/13/lto wrapper Target: riscv64 linux gnu Configured with: ../src/configure v with pkgversion 'Debian 13.2.0 1revyos1' with bugurl file:///usr/share/doc/gcc 13/README.Bugs enable languages c,ada,c++,go,d,fortran,objc,obj c++,m2 prefix /usr with gcc major version only program suffix 13 program prefix riscv64 linux gnu enable shared enable linker build id libexecdir /usr/libexec without included gettext enable threads posix libdir /usr/lib enable nls enable clocale gnu enable libstdcxx debug enable libstdcxx time yes with default libstdcxx abi new enable gnu unique object disable libitm disable libquadmath disable libquadmath support enable plugin enable default pie with system zlib enable libphobos checking release with target system zlib auto enable objc gc auto enable multiarch disable werror disable multilib with arch rv64gc_zfh_xtheadba_xtheadbb_xtheadbs_xtheadcmo_xtheadcondmov_xtheadfmemidx_xtheadfmv_xtheadint_xtheadmac_xtheadmemidx_xtheadmempair_xtheadsync with abi lp64d enable checking release build riscv64 linux gnu host riscv64 linux gnu target riscv64 linux gnu with build config bootstrap lto lean enable link serialization 16 Thread model: posix Supported LTO compression algorithms: zlib zstd gcc version 13.2.0 (Debian 13.2.0 1revyos1) ``` gcc 10/gcc 13 区别： 除了v0p7，其他优化都可以用 gcc 13 代替 gcc 10。 后者的优化可以主线报问题，是已经主线化的功能。 ## SuperTuxKart SuperTuxKart 是一款 3D 开源街机赛车游戏，有各种角色、赛道和模式可供选择。在 LPi4A 上也可以通过源码编译来体验： 首先安装依赖： ```shell sudo apt get install build essential cmake libbluetooth dev libsdl2 dev \\ libcurl4 openssl dev libenet dev libfreetype6 dev libharfbuzz dev \\ libjpeg dev libogg dev libopenal dev libpng dev \\ libssl dev libvorbis dev libmbedtls dev pkg config zlib1g dev ``` 接下来参考[文档](https://github.com/supertuxkart/stk code/blob/master/INSTALL.md#building supertuxkart on linux)步骤编译： ```shell # clone and configure src git clone https://github.com/supertuxkart/stk code stk code svn co https://svn.code.sf.net/p/supertuxkart/code/stk assets stk assets # go into the stk code directory cd stk code # create and enter the cmake_build directory mkdir cmake_build cd cmake_build # run cmake to generate the makefile cmake .. DBUILD_RECORDER off DNO_SHADERC on # compile make j$(nproc) ``` 编译完成后，在当前目录下的 `bin/` 文件夹中即可找到 `supertuxkart` 程序。运行即可： ```shell ./bin/supertuxkart ``` 效果如下： ![supertuxkart_play](./assets/application/supertuxkart_play.png) ## llama2.c [项目链接](https://github.com/karpathy/llama2.c) 我们可以根据项目链接文档中的步骤来运行一个 Llama 2 的小模型。 首先 clone 该项目，并切换到改项目目录下： ```shell git clone https://github.com/karpathy/llama2.c.git ``` 然后下载 model.bin 文件，并放到指定目录下： ```shell wget https://karpathy.ai/llama2c/model.bin P out ``` 然后编译并运行： ```shell gcc O3 o run run.c lm ./run out/model.bin ``` 可以得到如下输出： ```text <s> Once upon a time, there was a little girl named Lily. She loved to play with her dolls and teddy bea rs. One day, she saw her friend Lucy playing with her favorite doll. Lily: \"Lucy, can I play with you?\" Lucy: \"Sure, but can you be careful with my doll?\" Lily: \"Sure, I promise I won't break her.\" Lucy: \"That's very original. I really love it.\" Lily smiled and showed her doll to her mom. Her mom said, \"That's nice, Lily. Let's put your doll on the shelf and play with her some more.\" From that day on, Lily and her doll played together every day. They were the best of friends and didn 't break anyone's possession. <s> Once upon a time, there was a little boy named Timmy. Timmy loved to eat sandwiches. One day, Timmy' s mom made him a sandwich for lunch. It was so yummy and tasty! But then, something unexpected happen ed. Timmy's little sister spilled some juice on his sandwich. Tim achieved tok/s: 30.955260 ``` 也可以修改一些编译参数来加速： ```text sipeed@lpi4a:~/llama2.c$ gcc Ofast fopenmp run.c lm o run sipeed@lpi4a:~/llama2.c$ OMP_NUM_THEADS 4 ./run out/model.bin <s> Once upon a time, there was a boy named Tom. He liked to run fast. One day, he saw a big tree. Under the tree, he found a hole. Tom was curious. He looked inside and saw something shiny. Tom looked closer, and it was not a shiny thing. It was a key! He was very surprised. He took the key and ran home. He showed his mom the key. Tom's mom said the key was for a sneeze. The sneeze was a sneeze. Tom's mom put the key next to her p ocket. Tom said, \"Now you can have a sneeze too!\" Tom put his nose under his ears. He went home and took a nap. When he woke up, he had a small sneeze from the key. It was not food or water. Tom was happy and laughed. <s> Once upon a time, there was a bunny. The bunny was very restless and wanted to explore, so he hopped off his little house. The bunny hopped and hopped until he saw a shiny silver carrot. He was so excited to eat it, he achieved tok/s: 52.043098 ``` ### Stable Diffusion [项目地址](https://github.com/vitoplantamura/OnnxStream) 本示例通过这个项目在 LPi4A 上运行 Stable Diffusion。 首先，我们需要构建 XNNPACK： ```shell git clone https://github.com/google/XNNPACK.git cd XNNPACK git checkout 3f56c91b492c93676a9b5ca4dd51f528b704c309 mkdir build cd build cmake DXNNPACK_BUILD_TESTS OFF DXNNPACK_BUILD_BENCHMARKS OFF .. cmake build . config Release ``` 接下来，构建 Stable Diffusion example： ```shell git clone https://github.com/vitoplantamura/OnnxStream.git cd OnnxStream cd src mkdir build cd build cmake DXNNPACK_DIR <此处替换为clone的XNNPACK存放路径> .. cmake build . config Release ``` 现在我们得到了可运行的 Stable Diffusion example 文件 `sd` ，使用如下参数运行： ```shell ./sd models path . rpi ``` 其中，` models path` 是从该项目 Release 页面中下载的模型文件，可以放到 `sd` 文件的所在目录下。 运行时的配置如下： ```shell [start] positive_prompt: a photo of an astronaut riding a horse on mars negative_prompt: ugly, blurry output_png_path: ./result.png steps: 10 ``` 得到的结果为`result.png`文件，上述 prompt 得到的图片如下： ![onnxstream_result](./assets/application/onnxstream_result.png) ## PSP模拟器 [项目地址](https://github.com/hrydgard/ppsspp) 本示例通过这个项目在 LPi4A 上运行 PSP模拟器。 首先，我们需要构建 PPSSPP： ```shell #先安装所需要的包 sudo apt install build essential cmake libgl1 mesa dev libsdl2 dev libvulkan dev mesa common dev libglu1 mesa dev libsdl2 dev libcurl4 openssl dev git clone recurse submodules https://github.com/hrydgard/ppsspp.git cd ppsspp git submodule update init recursive git pull rebase https://github.com/hrydgard/ppsspp.git cmake . make j4 ``` 编译可能需要一段时间，出现以下输出时，编译成功： ```shell sipeed@lpi4a:~/ppsspp$ make j4 [ 0%] Built target unix_based_hardware_detection [ 0%] Built target utils [ 0%] Built target gason [ 1%] Built target snappy [ 1%] Built target cityhash [ 1%] Built target vma [ 2%] Built target png17 [ 3%] Built target udis86 [ 3%] Built target basis_universal [ 16%] Built target libzip [ 16%] Built target glew [ 16%] Built target sfmt19937 [ 17%] Built target kirk [ 18%] Built target xbrz [ 18%] Built target xxhash [ 19%] Generating something_that_never_exists [ 21%] Built target miniupnpc [ 25%] Built target libzstd_static Could NOT find Git (missing: GIT_EXECUTABLE) CMake Warning at git version.cmake:16 (message): git not found, unable to include version. [ 25%] Built target GitVersion [ 25%] Built target GenericCodeGen [ 25%] Built target OGLCompiler [ 25%] Built target OSDependent [ 31%] Built target armips [ 31%] Built target spirv cross core [ 34%] Built target rcheevos [ 35%] Built target cpu_features [ 35%] Built target discord rpc [ 36%] Built target spirv cross glsl [ 41%] Built target MachineIndependent [ 41%] Built target spirv cross cpp [ 41%] Built target spirv cross msl [ 41%] Built target spirv cross hlsl [ 41%] Built target glslang [ 42%] Built target SPIRV [ 58%] Built target Common [ 59%] Built target native [ 95%] Built target Core [100%] Built target PPSSPPSDL ``` 安装完之后可以试运行一下（root模式下）： ```shell ./PPSSPPSDL ``` 如图： ![game_result](./assets/application/psp1.png) 游戏下载： [psp游戏下载](https://playdreamcreate.com/) 下载完成： 我们只需要用到压缩包里的EBOOT.PBP文件 1.如果是使用图形界面则直接解压 2.如果使用命令行的话，需要将压缩包改成zip后缀再进行解压 ```shell mv [压缩包名] [压缩包名].zip unzip [压缩包名].zip ``` 开始游戏：在PPSSPPSDL命令下打开EBOOT.PBP即可 ```shell ./PPSSPPSDL ./game/01/EBOOT.PBP ``` 运行效果如图： ![game_result](./assets/application/psp_2.png) ![game_result](./assets/application/psp_3.png) ## opencv 的使用 首先安装依赖，以及python3环境 ```shell sudo apt install python3 python3 pip sudo apt install python3 opencv sudo apt install libqt5gui5 gles ``` opencv读取图片demo： ```shell #!/bin/bash import cv2 img2 cv2.imread('aContour.jpg', cv2.IMREAD_UNCHANGED) cv2.namedWindow('show_img', 0) # 定义窗口名称，三个函数（namedWindow、 resizeWindow、 imshow）中窗口名称要一致 cv2.resizeWindow('show_img', 736, 416) cv2.imshow(\"show_img\",img2) cv2.waitKey(0) cv2.destroyAllWindows() cv2.destroyWindow(\"show_img\") ``` 运行程序： ```shell python3 show_pic.py ``` 运行结果： ![opencv_result](./assets/application/opencv_o.png) PIL numpy opencv 综合测试demo： ```shell #!/bin/bash from typing import List, Any, Tuple import matplotlib.pyplot as plt import cv2 import numpy as np from PIL import Image from PIL import ImageFilter im Image.open('a.jpg') om im.filter(ImageFilter.CONTOUR) om.save('aContour.jpg') b np.random.randint(0, 255, (200, 300), dtype np.uint8) g np.random.randint(0, 255, (200, 300), dtype np.uint8) r np.random.randint(0, 255, (200, 300), dtype np.uint8) print(b) img np.empty([20,30,3],dtype np.uint8) bgr () rowlist [] collist: List[List[Tuple[Any, Any, Any]]] [] for row in range(200): rowlist [] for col in range(300): bgr (r[row][col],g[row][col],b[row][col]) rowlist.append(bgr) collist.append(rowlist) img np.asarray(collist) img2 cv2.imread('aContour.jpg', cv2.IMREAD_UNCHANGED) cv2.namedWindow('show_img', 0) cv2.resizeWindow('show_img', 736, 416) cv2.imshow(\"show_img\",img2) cv2.waitKey(0) cv2.destroyAllWindows() cv2.destroyWindow(\"show_img\") ``` 使用 USB 摄像头 demo ```python import cv2 # 打开摄像头 cap cv2.VideoCapture(0) # 检查是否成功打开摄像头 if not cap.isOpened(): print(\"无法打开摄像头\") exit() # 循环读取摄像头的每一帧图像 while True: # 从摄像头中获取一帧图像 ret, frame cap.read() # 检查是否读取成功 if not ret: print(\"无法获取图像\") break # 显示图像 cv2.imshow(\"USB Camera\", frame) # 等待按下 ESC 键退出 if cv2.waitKey(1) 27: break # 释放摄像头并关闭所有窗口 cap.release() cv2.destroyAllWindows() ``` ## ncnn 的使用 首先，git源码和安装相关的依赖库 ```shell git clone https://github.com/Tencent/ncnn.git cd ncnn git submodule update init sudo apt install build essential git cmake libprotobuf dev protobuf compiler libvulkan dev libopencv dev libqt5gui5 gles ``` 编译源码 ```shell cd ncnn mkdir p build cd build cmake DCMAKE_BUILD_TYPE Release DNCNN_VULKAN OFF DNCNN_BUILD_EXAMPLES ON .. make j$(nproc) ``` 下载相关的模型文件以及参数，将它们放在与可执行文件同个文件夹下 [下载链接](https://github.com/nihui/ncnn assets) ```shell ~/ncnn/build/example ``` ![ncnn2](./assets/application/ncnn2_o.png) 执行 ```shell ./nanodet a.jpg ``` 运行结果 ![ncnn_result](./assets/application/ncnn_result_o.png) ![ncnn_result](./assets/application/ncnn_pic_o.png) ## Kdenlive 的使用 安装步骤： ```shell sudo apt update sudo apt install libqt5gui5 gles sudo apt install kdenlive ``` 若通过上面的命令安装的 Kdenlive 无法正常运行，可以尝试运行下面的命令： ```shell sudo apt update sudo apt reinstall libqt5gui5 gles sudo apt reinstall kdenlive ``` 安装完成后即可使用命令打开 kdenlive： ```shell kdenlive ``` 视频编辑效果如下： ![kdenlive_use](./assets/application/kdenlive_use.png) ## GStreamer GStreamer 是一个基于管道的多媒体框架，基于 GObject，以 C 语言写成。凭借 GStreamer，可以很容易地创建各种多媒体功能组件，包括简单的音频回放、音频和视频播放、录音、流媒体和音频编辑。基于流水线设计，可以创建诸如视频编辑器、流媒体广播和媒体播放器等等的很多多媒体应用。 接下来，展示如何在 LPi4A 上运行 GStreamer 的 demo。 首先，需要安装相关的依赖： ```shell sudo apt install git build essential libgstreamer* gstreamer1.0 tools ``` 然后拉取相关源码仓库 ```shell git clone https://gitlab.freedesktop.org/gstreamer/gst docs ``` 进入到 `gst docs/examples/tutorials` 目录下，编译出 `basic tutorial 1` 可执行程序 ```shell cd gst docs/examples/tutorials gcc basic tutorial 1.c o basic tutorial 1 `pkg config cflags libs gstreamer 1.0` ``` 编译成功后会在当前目录下生成可执行程序，使用下面的命令运行即可看到效果： ```shell ./basic tutorial 1 ``` ![gstreamer_demo](./assets/application/gstreamer_demo.png) ## Kicad **注意，仅20231023及以上版本支持 kicad !** 首先安装 Kicad ： ```shell sudo apt update sudo apt install kicad ``` 安装完毕后，需要先运行以下命令才能运行 kicad： ```shell sudo switch gl gl4es rm ~/.cache ``` 打开 kicad： ```shell kicad ``` ![kicad_startpage](./assets/application/kicad_startpage.png) ![kicad_pcbview](./assets/application/kicad_pcbview.png) 在使用完 kicad 后，需要运行下面的命令以避免兼容性问题： ```shell sudo switch gl mesa rm ~/.cache ``` ## KODI 直接安装运行即可： ```shell sudo apt install kodi kodi ``` ![kodi_homepage](./assets/application/kodi_homepage.png) ![kodi_iconmenu](./assets/application/kodi_iconmenu.png) ![kodi_settings](./assets/application/kodi_settings.png) ## 其它 欢迎投稿～ 投稿接受后可得￥5～150（$1~20）优惠券！"},"/hardware/zh/lichee/th1520/lpi4a/13_XTAI.html":{"title":"玄铁多媒体AI软硬件融合平台","content":"# 玄铁多媒体AI软硬件融合平台 ## 平台简介 XTAI（XuanTie AI）是基于玄铁处理器与无剑芯片平台面向多媒体AI增强场景的全栈软硬件平台。该平台对RISC V vector、matrix及异构硬件引擎进行OpenCV、CSI NN算子库和TMedia接口的融合抽象，深度融合多媒体处理流程，形成面向业务的流水线设计，为用户在流水线不同环节实现AI增强优化。平台内置物体检测、分类、超分、大语言模型等各类应用算法。 ## 平台优势 ![image](https://alidocs.oss cn zhangjiakou.aliyuncs.com/res/4maOgdPd2WPjlWNX/img/c9db2034 5400 40cc bcb0 b0ce8842f61d.png) ## 平台功能 cxVision视频视觉应用pipeline引擎 * 视频流水线分布式串接 * 插件式算法开发，支持脚本描述定义流水线应用 * 40+通用插件库，支持采集、编解码、图像处理、AI推理等功能 * 支持插件动态加载及热更新 TMedia媒体库 * 高性能多媒体组件，支持Camera/AVCodec/VPSS/AIE等功能 * 多种流媒体协议，支持Http/RTSP/RTMP等 * 系统级视频帧存池管理 弹性算力抽象库 * 支持40+常用CV算子加速，兼容OpenCV接口，软硬协同优化 * 200+RISCV Vector优化算子，全链路算子覆盖 * CSI NN芯片对接抽象，方便生态伙伴二次开发 HHB AI编译部署工具 * 支持ONNX、Caffe、Pytorch、TensorFlow等主流模型转换 * 支持算子融合、算子拆分、常量折叠、量化信息传播、零点合并等计算图优化 * 支持多种对称和非对称定点量化，支持通道量化 * 支持代码生成、异构执行 * [HBB 产品页](https://xuantie.t head.cn/soft tools/tools/4197795688228130816?spm a2cl5.29101270.0.0.f056tR3JtR3JWW) 功能性能诊断工具 * 针对RISC V指令特性的自动插桩 * 系统性能及视频流水线插件的可视化诊断分析 * 模型模拟运行及算力分析统计 算法生态 * AI模型和应用例程一站式体验 * 检测、分类、分割、超分、手势等各类视觉AI模型支持 * 大模型支持（LLM、多模态等） ## 平台框图 ![image](https://alidocs.oss cn zhangjiakou.aliyuncs.com/res/4maOgdPd2WPjlWNX/img/0fa09641 a6ee 4e4e 93d7 e90c19fa422d.png) ## 资源下载 [SDK及手册](https://www.xrvm.cn/soft tools/application/mediaAI?spm a2cl5.14300690.0.0.28b0aUwbaUwbU0) ## 已支持的开发板 [矽速·LicheePi 4A](https://wiki.sipeed.com/licheepi4a)"},"/hardware/zh/lichee/th1520/lpi4a/7_develop_revyos.html":{"title":"revyos SDK","content":" title: revyos SDK keywords: Linux, Lichee, TH1520, SBC, RISCV update: date: 2023 07 03 version: v1.1 author: ztd Sipeed所使用的SDK是该文档中的SDK。 该SDK在本机配置编译环境使用`make`构建。且下述构建流程运行于ubuntu 22.04系统，请预留约20G空间。 ## 编译环境配置 首先安装所需的软件包并设置好环境变量 ```bash export xuetie_toolchain https://occ oss prod.oss cn hangzhou.aliyuncs.com/resource//1663142514282 export toolchain_file_name Xuantie 900 gcc linux 5.10.4 glibc x86_64 V2.6.1 20220906.tar.gz export toolchain_tripe riscv64 unknown linux gnu export ARCH riscv export nproc 12 #请根据自身CPU配置设置，该文档使用cpu为i5 11400 mkdir th1520_build && cd th1520_build export GITHUB_WORKSPACE \"~/th1520_build\" #本文假设均下载到用户目录下，可根据自身需要更改 sudo apt update && \\ sudo apt install y gdisk dosfstools g++ 12 riscv64 linux gnu build essential \\ libncurses dev gawk flex bison openssl libssl dev tree \\ dkms libelf dev libudev dev libpci dev libiberty dev autoconf device tree compiler sudo update alternatives install \\ /usr/bin/riscv64 linux gnu gcc riscv64 gcc /usr/bin/riscv64 linux gnu gcc 12 10 sudo update alternatives install \\ /usr/bin/riscv64 linux gnu g++ riscv64 g++ /usr/bin/riscv64 linux gnu g++ 12 10 ``` **注意，clone下面的repo时请检查是否为对应分支：** **kernel分支为lpi4a** **uboot分支为lpi4a** **opensbi分支为lpi4a** ## 构建kernel 首先请clone用到的repo，并建立好对应文件夹（下列路径均假设根目录为用户目录下） ```shell git clone https://github.com/revyos/thead kernel.git kernel ``` 配置编译工具链 ```shell wget ${xuetie_toolchain}/${toolchain_file_name} tar xvf ${toolchain_file_name} C /opt export PATH \"/opt/Xuantie 900 gcc linux 5.10.4 glibc x86_64 V2.6.1/bin:$PATH\" ``` 创建安装目标目录 ```shell mkdir rootfs && mkdir rootfs/boot ``` 编译内核 ```shell pushd kernel make CROSS_COMPILE ${toolchain_tripe} ARCH ${ARCH} revyos_defconfig make CROSS_COMPILE ${toolchain_tripe} ARCH ${ARCH} j$(nproc) make CROSS_COMPILE ${toolchain_tripe} ARCH ${ARCH} j$(nproc) dtbs if [ x\"$(cat .config grep CONFIG_MODULES y)\" x\"CONFIG_MODULES y\" ]; then sudo make CROSS_COMPILE ${toolchain_tripe} ARCH ${ARCH} INSTALL_MOD_PATH ${GITHUB_WORKSPACE}/rootfs/ modules_install j$(nproc) fi #sudo make CROSS_COMPILE ${toolchain_tripe} ARCH ${ARCH} INSTALL_PATH ${GITHUB_WORKSPACE}/rootfs/boot zinstall j$(nproc) ``` 构建perf（根据需要构建） ```shell make CROSS_COMPILE riscv64 unknown linux gnu ARCH riscv LDFLAGS static NO_LIBELF 1 NO_JVMTI 1 VF 1 C tools/perf/ sudo cp v tools/perf/perf ${GITHUB_WORKSPACE}/rootfs/sbin/perf thead ``` 记录 commit id ```shell git rev parse HEAD > kernel commitid sudo cp v kernel commitid ${GITHUB_WORKSPACE}/rootfs/boot/ ``` 安装内核、设备树到目标目录 ```shell sudo cp v arch/riscv/boot/Image ${GITHUB_WORKSPACE}/rootfs/boot/ sudo cp v arch/riscv/boot/dts/thead/{light lpi4a.dtb,light lpi4a 16gb.dtb} ${GITHUB_WORKSPACE}/rootfs/boot/ popd ``` 之后只需要把rootfs中内容拷贝或覆盖到对应目录即可，注意内核Image和内核module目录一定要对应，不然会因缺失内核模块导致外设功能失效。 从 commit `c56347a43e850de287a2249d3d9118910718527b` 开始，内核中默认包含 16GB 内存设备树，故 8G/16G 是共用一个 kernel，仅 uboot 有所区别。 ## 构建uboot 注意，此时仍在th1520_build目录下，且已经配置好环境变量和工具链，步骤参考构建kernel。 ```shell git clone https://github.com/revyos/thead u boot.git uboot ``` 然后开始执行编译命令。 需要注意的是，8G 与 16G 内存版本使用的 uboot 不同，所以对应的构建命令也不同，基于此仓库构建命令如下： ```shell pushd uboot # 构建16G内存版本使用的uboot make light_lpi4a_16g_defconfig make CROSS_COMPILE ${toolchain_tripe} ARCH ${ARCH} j$(nproc) find . name \"u boot with spl.bin\" xargs I{} cp av {} ${GITHUB_WORKSPACE}/rootfs/u boot with spl lpi4a 16g.bin make clean # 构建8G内存版本使用的uboot make light_lpi4a_defconfig make CROSS_COMPILE ${toolchain_tripe} ARCH ${ARCH} j$(nproc) find . name \"u boot with spl.bin\" xargs I{} cp av {} ${GITHUB_WORKSPACE}/rootfs/u boot with spl lpi4a.bin make clean popd ``` 烧录时注意烧录和你所使用的开发板所对应的 uboot。在烧录时请注意使用的命令，若使用的镜像版本为 `0912` 及以上版本，升级 uboot 只需要运行： ```shell sudo ./fastboot flash uboot u boot with spl lpi4a 16g.bin ``` 检查输出的文件 ```shell tree ${GITHUB_WORKSPACE}/rootfs ``` ## 构建opensbi 注意，此时仍在th1520_build目录下，且已经配置好环境变量和工具链，步骤参考构建kernel。 ```shell git clone https://github.com/revyos/thead opensbi.git opensbi ``` 然后开始执行编译命令 ```shell pushd opensbi make PLATFORM generic ARCH ${ARCH} CROSS_COMPILE ${toolchain_tripe} sudo install D p m 644 build/platform/generic/firmware/fw_dynamic.bin \\ \"${GITHUB_WORKSPACE}/rootfs/boot/\" popd ``` 检查输出的文件 ```shell tree ${GITHUB_WORKSPACE}/rootfs ``` 将目前构建好的kernel, uboot, opensbi相关文件打包为压缩包 ```shell tar zcvf kernel.tar.gz rootfs ``` 要使用构建的文件，则将压缩包中文件替换到相应位置即可。 将boot.ext4中要替换的文件删掉，然后rootfs/boot/下的文件放到boot.ext4中； 将rootfs/lib/modules/替换掉rootfs.ext4中的/lib/modules/目录； 若构建了perf了，将rootfs/sbin下的文件替换掉rootfs.ext4中/sbin下的文件； uboot直接烧录即可。 ## 支持 PTG omxil 库的 GStreamer 播放器适配文档 ### 概述 PTG 的 OpenMAX IL 库（下称 vpu omxil）可使 LicheePi 4A 能够流畅硬解码 4k 60fps 的视频，那么具体应该如何使用该库呢？本文将主要介绍 LicheePi 4A 开发板上 Parole 播放器的集成与使用，用户可根据本文来了解在 LicheePi 4A 上的适配过程 以 h264 的硬解为例，视频硬解的工作流程如图所示 ```text + + + + + + + + video stream + > omxh264dec + > video sink + + > player + + + + + + + GStreamer + + + + v + vpu omxil + + + + v + kernel module (driver) + + + v hardware ``` 1. 视频流（video stream）由 GStreamer 读入后经过一系列预处理，送到 GStreamer 的解码器 `omxh264dec` 中 2. omxh264dec 调用动态库，即 PTG 提供的 vpu omxil 库，该库通过驱动访问硬件（kernel module）进行硬解 3. 解码后的流传输到 GStreamer 的 video sink 中，并由播放器（player）呈现 ### GStreamer omxh264dec 解码测试 将 omxh264 解码的部分单独拎出来，大体的结构如下 ```text + + + + + + omxh264dec + + GStreamer + + + + + v + + + + vpu omxil + + libomxil bellagio + + + + v + memalloc vc8000 hantrodec vidmem kernel modules + + + v hardware ``` 我们依照自底向上的顺序构建图示的链条。本节的主要目的是使 omxh264dec 解码器能够运行，并不涉及到输出屏幕等内容。 #### 1. 驱动编译、安装以及硬件访问权限的设置 硬解码需要访问硬件，而访问硬件又需要驱动，所以需要编译并安装驱动 ##### 1.1 编译驱动 PTG 提供的驱动源： https://gitee.com/thead yocto/vpu vc8000e kernel https://gitee.com/thead yocto/vpu vc8000d kernel https://gitee.com/thead yocto/video_memory ##### 1.2 安装驱动 ```shell # depmod 分析可载入模块的依赖关系，在 /lib/modules/<kernel version>中添加modules.dep文件，以便后续 modprobe 使用 sudo depmod a sudo modprobe vidmem vc8000 hantrodec memalloc ## 如果 modprobe 安装有问题的话，可以尝试使用 insmod 安装 #cd /usr/lib/modules/$(uname r) #sudo insmod $(find . name *vidmem.ko*) #sudo insmod $(find . name *vc8000.ko*) #sudo insmod $(find . name *hantrodec.ko*) #sudo insmod $(find . name *memalloc.ko*) # 可选：设置开机加载模块 echo e \"\\nvidmem\\nhantrodec\\nmemalloc\\nvc8000\\n\" sudo tee a /etc/modules > /dev/null ``` ##### 1.3 设置硬件访问权限 安装内核模块后，/dev 目录下会出现 hantrodec vidmem vc8000 三个设备文件。默认情况下，用户对其没有访问权限，如果不修改权限的话，非 root 用户在打开 omxil 库时会报错。 ```shell # 生效一次 cd /dev sudo chmod 666 hantrodec vidmem vc8000 # 长期生效 cat << EOF sudo tee /lib/udev/rules.d/70 hantro.rules > /dev/null KERNEL \"vidmem\", MODE \"0666\" KERNEL \"hantrodec\", MODE \"0666\" KERNEL \"vc8000\", MODE \"0666\" EOF ``` ##### RevyOS 适配记录 如果要获取 RevyOS 特定版本的内核模块，可进入 [revyos/thead kernel](https://github.com/revyos/revyos/wiki/%E6%94%AF%E6%8C%81 PTG omxil %E5%BA%93%E7%9A%84 GStreamer %E6%92%AD%E6%94%BE%E5%99%A8%E9%80%82%E9%85%8D%E6%96%87%E6%A1%A3)，并在 GitHub CI 中下载 artifacts #### 2. 安装 vpu omxil 并调整配置 首先，请将 vpu omxil 下载并解压到 /usr/lib/omxil/ 中：[vpu omxil_1.2.1.tar.gz](https://drive.google.com/file/d/1pYgCVI7WltfpskltJ RqzVUCEC21FS56/edit?pli 1)。如下图所示，需要： 1. 将 vpu omxil 中的 OpenMax 组件注册到 libomxil bellagio 中 2. gst omx（该包提供了 omxh264dec 解码器） 调用 libomxil bellagio 的时候也需要知道调用的组件名称 ```text + + + + + + gst omx + > libomxil bellagio + > vpu omxil + + + + + + ``` ##### 2.1 将 vpu omxil 中的组件注册到 libomxil bellagio 中 ```shell sudo apt install libomxil bellagio bin libomxil bellagio0 # 注册组件 omxregister bellagio v /usr/lib/omxil/ ``` ##### 2.2 调整 gstomx.conf 的设置 调整 gstomx.conf 的设置以使解码器 omxh264dec 调用正确的组件，具体请查看针对 gst omx 的补丁： [gst omx 01 add libomxil config.patch](https://gist.github.com/Sakura286/26777ea8204c1819885e093806a4f7ca#file gst omx 01 add libomxil config patch) #### 3. 添加 dmabuf 补丁 请查看 PTG 提供的针对 gst omx 的 dmabuf 补丁： [gst omx 02 set dec out port dmabuf.patch](https://gist.github.com/Sakura286/26777ea8204c1819885e093806a4f7ca#file gst omx 02 set dec out port dmabuf patch) #### 4. GStreamer 解码初步测试 ```shell sudo apt install gstreamer1.0 omx generic gstreamer1.0 omx bellagio config gstreamer1.0 plugins bad gstreamer1.0 plugins base gstreamer1.0 gl gstreamer1.0 plugins good gstreamer1.0 tools # 1 基本解码 gst launch 1.0 filesrc location <test.mp4> ! qtdemux ! h264parse ! omxh264dec ! videoconvert ! fakesink sync false # 2 在终端中显示 fps # 参考：https://stackoverflow.com/questions/73948308 gst launch 1.0 filesrc location <test.mp4> ! qtdemux ! h264parse ! omxh264dec ! videoconvert ! fpsdisplaysink video sink fakesink text overlay false sync false v 2>&1 ``` `fakesink`会把前面的视频流全部吞掉，不输出画面（因而不会在 video sink 这一环节损失性能），但是结合fpsdisplaysink可以读取到解码的速度。正常日志如下： ```shell Setting pipeline to PAUSED ...[DBGT] vc8kdec compiled without trace support (ENABLE_DBGT_TRACE switch not enabled) Pipeline is PREROLLING ... Redistribute latency... OMX ! decoder_get_parameter OMX_ErrorNoMore (2) Pipeline is PREROLLED ... Setting pipeline to PLAYING ... New clock: GstSystemClockRedistribute latency... 0:01:39.5 / 0:01:49.4 (90.9 %) ``` **【TIP】** 如果有 [omxh264dec omxh264dec0: Could not initialize supporting library.](https://gist.github.com/Sakura286/015fae6792e160268db7ad8a697dd2df) 等字样的报错，可以安装`gst omx`、`libomxil bellagio`与`libc6`相关的 `debug symbol` 包，使用 `gdb` 启动上述命令进行调试。调试时，先断 `DWLInit`，然后再断 `open`，具体看是打开哪个地方的时候出错了。 ##### RevyOS 适配记录 RevyOS 适配过程中对于初始化动态库失败找到了如下三种原因： 1. 编译 vpu omxil 时使用的工具链与当前系统不兼容 2. 未使用`omxregister bellagio`注册 vpu omxil 3. 未调整 `/dev` 目录下 `hantrodec` `vc8000` `vidmem` 等设备的权限 ### B. 选用合适的 GStreamer video sink `video sink` 是视频流在整个 [GStreamer pipeline](https://gstreamer.freedesktop.org/documentation/tutorials/basic/concepts.html) 中的最后一步，其作用一般是将视频流输出到屏幕上。 前文中`fakesink`只是测试解码器是否正常工作的特殊 `video sink`，[可选的 video sink](https://gstreamer.freedesktop.org/documentation/tutorials/basic/platform specific elements.html?gi language c)非常多，常见的有 `autovideosink`，`ximagesink`，`xvimagesink`，`fbdevsink`，`waylandsink`，`glimagesink`，`gtkglsink`等，它们各在不同的插件包里，需要酌情安装： **video sink** **所属包名** waylandsink gstreamer1.0 plugins bad fbdevsink gstreamer1.0 plugins bad autovideosink gstreamer1.0 plugins good gtkglsink gstreamer1.0 plugins good ximagesink \\ xvimagesink gstreamer1.0 plugins base glimagesink gstreamer1.0 plugins base \\ gstreamer1.0 gl **【TIP】** 使用 `gst inspect 1.0 <video sink name>` 来查看对应 video sink 可用的选项 **【TIP】** 添加 ` gst debug level <lv>` 来获得更多的[输出日志](https://gstreamer.freedesktop.org/documentation/tutorials/basic/debugging tools.html#the debug log)，其中 `<lv>` 代表了从 1 到 6，啰嗦程度从低到高，建议在等级 4 及以下，否则日志会非常长 请尝试不同的 video sink ，并尝试不同的插件参数，以及给予不同的环境变量，直至找到可以流畅硬解 H264 的那一个。 #### RevyOS 适配记录 `**waylandsink**`：由于现在（20230720）RevyOS 采用了 Xfce 桌面，不可能支持 Wayland，故 `waylandsink`从原理上无法使用 `**fbdevsink**`与`**ximagesink**`：无法使用 `**xvimagesink**`：通过[流水线图](https://gstreamer.freedesktop.org/documentation/tutorials/basic/debugging tools.html#getting pipeline graphs)以及日志可以确定，playbin 或 autovideosink 会自动调用 xvimagesink，使用 perf 分析后可以发现，使用xvimagesink 不可避免地会进行大量的 memcpy 操作，严重降低解码性能；该问题在获得PTG的 dmabuf 补丁后依然存在，故无法使用 `**gtkglsink**`：[GTK3 不支持 EGL on X11](https://gitlab.gnome.org/GNOME/gtk/ /issues/738)，而 RevyOS 目前基于 x11，且只支持 EGL，故无法使用 剩下的只有`glimagesink`，根据 [Running and debugging GStreamer Applications](https://gstreamer.freedesktop.org/documentation/gstreamer/running.html#environment variables)，并观察其他使用到 glimagesink 的例子，可以猜测需要明确指定环境变量 `GST_GL_API`与 `GST_GL_PLATFORM` 由于 RevyOS 使用了 gles2+egl 的组合，使用如下的命令，成功硬解。 ```shell GST_GL_API gles2 GST_GL_PLATFORM egl gst launch 1.0 filesrc location <test.mp4> ! qtdemux ! h264parse ! omxh264dec ! videoconvert ! fpsdisplaysink video sink glimagesink sync false ``` 然而 GStreamer 被播放器调用时是无法通过环境变量来传递参数的，所以构建 gst plugins base 时应当传递额外的 meson 编译参数： ```shell Dgl_api [\\'gles2\\'] Dgl_platform [\\'egl\\'] ``` ### C. 播放器支持 GStreamer 的 pipeline 没有问题之后，就需要使播放器支持。不同播放器会使用到不同的 video sink，同样对 gstreamer 有着不同程度的依赖。 适配播放器时，最重要的工作便是①使播放器适配已验证的 video sink，或者②使 gstreamer pipeline 支持播放器指定的 video sink，此次 RevyOS 适配过程采用了①方案。 ```plain + + + + + + + + video stream + > omxh264dec + > video sink + + > player + + + + + + GStreamer + + ``` #### RevyOS 适配记录 根据 [https://gstreamer.freedesktop.org/apps/](https://gstreamer.freedesktop.org/apps/) 进行简单的排查 是否可用 是否更新 应用名 备注 ❌ Gnash Flash 播放器 ❌ GEntrans Debian 未收录 ❓ 20230226 Kaffeine ❌ 需要大量 KDE 相关组件 ✔️ 存在于[riscv64 仓库](https://buildd.debian.org/status/package.php?p kaffeine&suite sid)中 ❌ 在 Debian amd64 Gnome 上，播放窗口与控制窗口分离，且默认调用了 VLC 进行播放 ❌ Lcdgrilo Debian 未收录 ✔️ 20230218 Parole ✔️ For XFCE ❓ 不支持 Wayland，仅支持 x11 ✔️ Debian amd64 Gnome 验证通过 ✔️ 存在于[riscv64 仓库](https://buildd.debian.org/status/package.php?p parole&suite sid) 中 ❌ Songbird Debian 未收录 ❌ Snappy Debian 未收录 ❌ Totem 需要 GTK3，然而 GTK3 不支持 EGL on X11 最初选择的播放器是 Totem，但是发现 Totem 无法指定除了 gtkglsink 以外的 video sink，且 RevyOS 无法支持 随后选择了 Parole ，该软件由 GObject 编写，寻找其构建 parole_gst 对象时的方法 parole_gst_constructed，将 video sink 设置为前文已验证的 glimagesink，至此，粗略的适配工作完成。 ### 总结：RevyOS 适配工作 1. 编译驱动模块至内核，设置启动加载，设置设备权限 2. 将 PTG 提供的 omxil 二进制动态库文件打包为 th1520 vpu 1. 修改 th1520 vpu 的依赖，使其依赖 gst omx 、libomxil bellagio 等包 2. 设置了一些 postinstall 操作，例如使用 omxregister bellagio 注册组件等 3. 修改 gst omx 1. 增加 config 中对 vpu omxil 组件的支持 2. 应用 dmabuf 补丁 3. 增加对 h265 vp9 的支持 4. 修改 gst base 编译时的 gl 支持，限制为 gles2+egl 5. 修改 parole 以支持 glimagesink ### 本文所用资源 补丁集合： https://gist.github.com/Sakura286/26777ea8204c1819885e093806a4f7ca PTG omxil 库： https://drive.google.com/file/d/1pYgCVI7WltfpskltJ RqzVUCEC21FS56"},"/hardware/zh/lichee/th1520/lpi4a/6_peripheral.html":{"title":"外设使用","content":" title: 外设使用 keywords: Linux, Lichee, TH1520, SBC, RISCV, Peripheral update: date: 2023 09 12 version: v1.3 author: ztd content: Update NPU user guide date: 2023 08 18 version: v1.2 author: ztd content: Update JTAG user guide date: 2023 07 17 version: v1.1 author: ztd content: Update docs date: 2023 05 08 version: v1.0 author: wonder content: Release docs ## SoC 相关 ### CPU 运行频率 `sudo cat /sys/devices/system/cpu/cpu*/cpufreq/cpuinfo_cur_freq ` 单位为 KHz 注意系统自带温控策略，当系统过于空闲或者温度过高时，都会降频。请保持良好散热，使得 CPU 在 60 度以下，获得最佳性能。 ### 芯片温度 `cat /sys/class/thermal/thermal_zone0/temp` 单位为0.001摄氏度 ### CPU超频 TH1520 默认最大运行频率为 1.85GHz，但是经过初步测试发现，有 80% 左右的芯片可以在 2GHz 运行，有 50% 左右的芯片可以在 2GHz 通过压力测试。 这里放出简易超频步骤，仅供参考，不对稳定性和安全性做保证。 查看`/boot`下的文件： ```bash fw_dynamic.bin #opensbi Image #kernel image kernel release #commit id of kernel light_aon_fpga.bin #fw for E902 aon light_c906_audio.bin #fw for C906 audio light lpi4a.dtb #1.85GHz dtb light lpi4a_2Ghz.dtb #2GHz overclock dtb light lpi4a ddr2G.dtb #history dtb ``` 将 `light lpi4a_2Ghz.dtb` 拷贝覆盖为 `light lpi4a.dtb`，重启，即可修改开机后的最大频率。 注意有一定几率这样修改后无法启动，此时需要重新烧录固件来恢复。 如果成功启动，则可以查看下面的数值确认是否已成功超频： `sudo cat /sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_max_freq` ## PWM 以散热风扇所接的 PWM1 为例，可以通过如下代码获取风扇转速： ```bash cat /sys/class/hwmon/hwmon0/pwm1 ``` 风扇的PWM转速值范围在0到255之间，值越大风扇转速越大。你可以向PWM使能写入```1```来启用手动调速，并设置转速（如255）： ``` echo 0 > /sys/class/hwmon/hwmon0/pwm1_enable echo 255 > /sys/class/hwmon/hwmon0/pwm1 ``` 使用以下命令可以恢复自动调速： ```bash echo 2 > /sys/class/hwmon/hwmon0/pwm1_enable ``` 或是完全禁用风扇： ```bash echo 0 > /sys/class/hwmon/hwmon0/pwm1_enable ``` ## GPIO LicheePi 4A 板载 2x10pin 插针，其中有 16 个原生 IO，包括 6 个普通 IO，3 对串口，一个 SPI。 > 注意：SOC的所有原生IO均是1.8V电平，请注意电平转换。 > 插针上的串口输入侧已经进行了1/2分压处理，可以接3.3V的串口。 TH1520 SOC 具有4个GPIO bank，每个bank最大有32个IO： Bank Address kernel io num GPIO0 0xffec005000 456 487 GPIO1 0xffec006000 424 455 GPIO2 0xffe7f34000 392 423 GPIO3 0xffe7f38000 360 391 AO_GPIO 0xfffff41000 328 359 AO_GPIO4 0xfffff52000 296 327 AUDIO_GPIO0xffcb013000 其中 0x0 偏移处的 4Byte（32bit）是 GPIO 数据寄存器，0x4 偏移处的 4Byte（32bit）是 GPIO 方向寄存器 LicheePi 4A上的插针的 GPIO 对应关系为（以俯视底板正面为视角，TOP为左侧，BOTTOM为右侧）： ![io_map](./assets/peripheral/io_map.png) > 以文档的标注为准，内测版的丝印标注可能有误 GPIO 操作： > 注意，可能需要事先设置 pinmux ```bash num xxx echo ${num} > /sys/class/gpio/export echo out > /sys/class/gpio/gpio${num}/direction echo 1 > /sys/class/gpio/gpio${num}/value echo 0 > /sys/class/gpio/gpio${num}/value ``` GPIO 号的对应关系如下图所示： ![gpio_num](./assets/peripheral/gpio_num.png) 比如要操作插针上的4个 GPIO，对应关系如下，将上述代码的num改为想要操作的 GPIO 脚对应的数字即可: numIO Number 427IO 1_3 428IO 1_4 429IO 1_5 430IO 1_6 也可以直接操作寄存器： > devmem 可以从此处下载编译：https://github.com/VCTLabs/devmem2/blob/master/devmem2.c ```bash ./devmem 0xffe7f38000 w ``` 系统内GPIO信息查看： ```bash sipeed@lpi4a:~$ sudo cat /sys/kernel/debug/gpio ``` 下面是示例结果: ![peripheral_gpio_information](./assets/peripheral/peripheral_gpio_information.png) 接下来，以底板插针上的 GPIO1_3 为例，我们通过 libgpiod 在用户空间操作 gpio。首先安装 libgpiod： ```shell sudo apt update sudo apt install libgpiod dev ``` 使用 `vi gpio.c` 命令，将下面的代码写入文件： ```c #include <stdio.h> #include <stdlib.h> #include <unistd.h> #include <gpiod.h> int main() { int i; int ret; struct gpiod_chip * chip; struct gpiod_line * line; chip gpiod_chip_open(\"/dev/gpiochip1\"); if(chip NULL) { printf(\"gpiod_chip_open error\\n\"); return 1; } line gpiod_chip_get_line(chip, 3); if(line NULL) { printf(\"gpiod_chip_get_line error\\n\"); gpiod_line_release(line); } ret gpiod_line_request_output(line,\"gpio\",0); if(ret < 0) { printf(\"gpiod_line_request_output error\\n\"); gpiod_chip_close(chip); } for(i 0; i < 10; i++) { gpiod_line_set_value(line,1); sleep(1); gpiod_line_set_value(line,0); sleep(1); } gpiod_line_release(line); gpiod_chip_close(chip); return 0; } ``` 通过以下命令编译： ```shell gcc gpio.c I /usr/include/ L /usr/lib/riscv64 linux gnu/ lgpiod o gpio ``` 然后以 root 权限执行： ```shell sudo ./gpio ``` 此时用万用表测量底板上的 IO1_3 引脚，可以发现每隔一秒该引脚电压会发生变化。 <! ```bash sipeed@lpi4a:~$ sudo cat /sys/kernel/debug/gpio gpiochip8: GPIOs 296 327, parent: platform/fffff52000.gpio, fffff52000.gpio: AO_GPIO4 gpiochip7: GPIOs 328 359, parent: platform/fffff41000.gpio, fffff41000.gpio: AO_GPIO gpio 332 ( hubswitch ) out hi gpiochip6: GPIOs 360 391, parent: platform/ffe7f38000.gpio, ffe7f38000.gpio: GPIO3 gpiochip5: GPIOs 392 423, parent: platform/ffe7f34000.gpio, ffe7f34000.gpio: GPIO2 gpio 395 ( cs ) out hi ACTIVE LOW gpio 406 ( aon:soc_vdd5v_se_en ) out lo gpio 407 ( spi0 CS0 ) out hi ACTIVE LOW gpio 417 ( Volume Up Key ) in lo IRQ ACTIVE LOW gpio 421 ( aon:soc_wcn33_en ) out lo gpiochip4: GPIOs 424 455, parent: platform/ffec006000.gpio, ffec006000.gpio: GPIO1 gpio 443 ( Volume Down Key ) in hi IRQ ACTIVE LOW gpio 446 ( aon:soc_vbus_en ) out hi gpiochip3: GPIOs 456 487, parent: platform/ffec005000.gpio, ffec005000.gpio: GPIO0 gpio 457 ( spi2 CS0 ) out hi ACTIVE LOW gpio 486 ( aon:soc_vdd_3v3_en ) out hi gpiochip2: GPIOs 488 495, parent: i2c/3 0018, 3 0018, can sleep: IO expend 3 gpio 490 ( regulator hub vdd12 ) out hi gpio 491 ( regulator hub vcc5v ) out hi gpio 492 ( regulator pwr en ) out hi gpio 493 ( aon:soc_lcd0_vdd33_e) out hi gpio 494 ( aon:soc_lcd0_vdd18_e) out hi gpio 495 ( reset ) out hi ACTIVE LOW gpiochip1: GPIOs 496 503, parent: i2c/1 0018, 1 0018, can sleep: IO expend 2 gpio 496 ( aon:soc_cam2_dvdd12_) out lo gpio 501 ( wlan_default_wlan_po) out hi gpio 502 ( bt_default_poweron ) out lo gpiochip0: GPIOs 504 511, parent: i2c/0 0018, 0 0018, can sleep: IO expend 1 gpio 504 ( aon:soc_dvdd12_rgb ) out lo gpio 505 ( aon:soc_avdd28_rgb ) out lo gpio 506 ( aon:soc_dovdd18_rgb ) out lo gpio 507 ( aon:soc_dovdd18_ir ) out lo gpio 508 ( aon:soc_dvdd12_ir ) out lo gpio 509 ( aon:soc_avdd25_ir ) out lo gpio 510 ( aon:soc_cam2_dovdd18) out lo gpio 511 ( aon:soc_cam2_avdd25_) out lo ``` ### gpiod库的使用 gpiod库是一个可以在同户空间调用GPIO的库，方便用户在应用程序中对GPIO进行操作。 首先安装和部署GPIO库： ```shell sudo apt install wget wget https://git.kernel.org/pub/scm/libs/libgpiod/libgpiod.git/snapshot/libgpiod 2.0.tar.gz tar zxvf libgpiod 2.0.tar.gz cd libgpiod 2.0 sudo apt get install build essential pkg config m4 automake autoconf libtool autoconf archive sudo apt install gcc g++ export CC gcc export CXX g++ #部署库的相关文件到项目文件夹： prefix后面的路径要换成自己项目所在的路径，方便后续操作 ./autogen.sh enable tools yes prefix /home/sipeed/mylib_local make sudo make install ``` 如果执行：./autogen.sh enable tools yes prefix /home/sipeed/mylib_local 出现以下错误： ```shell aclocal: warning: couldn't open directory 'm4': No such file or directory #可以执行以下命令 mkdir m4 ./autogen.sh enable tools yes prefix /home/sipeed/mylib_local make make install ``` 开始操作GPIO： ```shell sudo vim gpio.c #gpio.c的内容如下： #include<stdio.h> #include<unistd.h> #include<gpiod.h> #define PIN_IO1_3 3 #define PIN_IO1_4 4 #define PIN_IO1_5 5 int main() { struct gpiod_chip *gchip; struct gpiod_line_info *glinein, *glineout; struct gpiod_line_settings *gline_settings_in, *gline_settings_out; struct gpiod_line_config *gline_config_in, *gline_config_out; struct gpiod_request_config *gline_request_config_in, *gline_request_config_out; struct gpiod_line_request *gline_request_in, *gline_request_out; int offset_in[1] {PIN_IO1_5}; int offset_out[2] {PIN_IO1_3, PIN_IO1_4}; int value; if ((gchip gpiod_chip_open(\"/dev/gpiochip4\")) NULL) { perror(\"gpiod_chip_open\"); return 1; } gline_settings_in gpiod_line_settings_new(); if ((value gpiod_line_settings_set_direction(gline_settings_in, GPIOD_LINE_DIRECTION_INPUT)) ! 0) { perror(\"gpiod_line_settings_set_direction\"); } gline_config_in gpiod_line_config_new(); value gpiod_line_config_add_line_settings(gline_config_in, offset_in, 1, gline_settings_in); gline_request_config_in gpiod_request_config_new(); gline_request_in gpiod_chip_request_lines(gchip, gline_request_config_in, gline_config_in); value gpiod_line_request_get_value(gline_request_in, PIN_IO1_5); printf(\"IO1 5 %d\\n\", value); gline_settings_out gpiod_line_settings_new(); if (gpiod_line_settings_set_direction(gline_settings_out, GPIOD_LINE_DIRECTION_OUTPUT) ! 0) { perror(\"gpiod_line_settings_set_direction\"); } gline_config_out gpiod_line_config_new(); gpiod_line_config_add_line_settings(gline_config_out, offset_out, 2, gline_settings_out); gline_request_config_out gpiod_request_config_new(); gline_request_out gpiod_chip_request_lines(gchip, gline_request_config_out, gline_config_out); value gpiod_line_request_set_value(gline_request_out, PIN_IO1_3, 1); value gpiod_line_request_set_value(gline_request_out, PIN_IO1_4, 0); printf(\"IO1 3 1, IO1 4 0\\n\"); sleep(1); for (int i 0; i < 10; i++) { value gpiod_line_request_get_value(gline_request_in, PIN_IO1_5); printf(\"IO1 5 %d\\n\", value); value gpiod_line_request_set_value(gline_request_out, PIN_IO1_3, 0); value gpiod_line_request_set_value(gline_request_out, PIN_IO1_4, 1); printf(\"IO1 3 0, IO1 4 1\\n\"); sleep(1); value gpiod_line_request_get_value(gline_request_in, PIN_IO1_5); printf(\"IO1 5 %d\\n\", value); value gpiod_line_request_set_value(gline_request_out, PIN_IO1_3, 1); value gpiod_line_request_set_value(gline_request_out, PIN_IO1_4, 0); printf(\"IO1 3 1, IO1 4 0\\n\"); sleep(1); } gpiod_chip_close(gchip); return 0; } ``` 保存，进行编译 ```shell gcc I/home/sipeed/mylib_local/include L/home/sipeed/mylib_local/lib o gpio gpio.c lgpiod ``` 执行前需要给一些设备权限 ```shell export LD_LIBRARY_PATH /home/sipeed/mylib_local/lib:$LD_LIBRARY_PATH export PATH /home/sipeed/mylib_local/bin:$PATH sudo chmod o+rw /dev/gpiochip4 sudo chmod o+rw /dev/spidev2.0 #可以直接放在一个.sh文件里面执行 ``` 运行程序： ```shell ./gpio ``` 控制台输出如下： ```shell sipeed@lpi4a:~/gpio$ ./gpio IO1 5 1 IO1 3 1, IO1 4 0 IO1 5 1 IO1 3 0, IO1 4 1 IO1 5 1 IO1 3 1, IO1 4 0 IO1 5 1 IO1 3 0, IO1 4 1 IO1 5 1 IO1 3 1, IO1 4 0 IO1 5 1 IO1 3 0, IO1 4 1 IO1 5 1 IO1 3 1, IO1 4 0 IO1 5 1 IO1 3 0, IO1 4 1 IO1 5 1 IO1 3 1, IO1 4 0 IO1 5 1 IO1 3 0, IO1 4 1 ``` > ## UART ### 系统串口 LicheePi 4A 的系统串口是 UART0,在侧边插针中有引出。 你可以使用 USB 转串口模块连接该串口，即 `U0 RX` 和 `U0 TX`，注意交叉连接，以及 GND 连接。 ![ttl_link](./assets/peripheral/ttl_link.png) 连接完成后，即可使用串口工具进行通信，Windows 下推荐 `XShell`，`mobaterm`，Linux下推荐 `minicom` 设置串口波特率为 `115200`，即可在串口终端下登录并进行指令操作： > 注：刚连接后可以敲几个回车查看是否有反应，如果没有反应则检查接线或者串口配置 ![ttl_login](./assets/peripheral/ttl_login.png) ### 一般串口 LicheePi 4A的侧边插针中还引出了 UART1/2/3, 同样可以操作。 默认镜像中仅使能了 UART1, 其它串口可能需要重新配置设备树操作。 > 注意：SOC串口电平为1.8V，刚好处于3.3V的高电平阈值附近，可能某些串口模块无法正确输入输出，建议使用我们提供配套串口模块，或者微调其他串口模块的3.3V电压到2.8V #### 查看串口设备 ```bash ls /dev/ttyS* ``` #### 查看串口的波特率等信息 ```bash stty F /dev/ttyS1 a ``` #### 设置串口波特率、数据模式 ```bash stty F /dev/ttyS1 ispeed 115200 ospeed 115200 cs8 ``` #### 查看串口数据 ```bash cat /dev/ttyS1 ``` #### 发送串口数据 ```bash echo \"12345\" > /dev/ttyS1 ``` #### 其它方法 也可以使用`minicom`，或者pyserial库进行串口操作，请用户自行查找相关资料使用。 ## I2C LicheePi 4A 上有多个 I2C 设备（I2C0/1/2/3），其中 0/1/3 用于连接 I2C IO 扩展芯片，I2C2 预留在对外插针上。 这里我们使用 i2c tools 来进行 i2c 验证操作，镜像默认预装了 i2c tools: ```bash sipeed@lpi4a:/usr$ ls /sbin/i2c* /sbin/i2c stub from dump /sbin/i2cdetect /sbin/i2cdump /sbin/i2cget /sbin/i2cset /sbin/i2ctransfer ``` 列出所有I2C总线： ```bash sipeed@lpi4a:~$ /sbin/i2cdetect l i2c 0 unknown Synopsys DesignWare I2C adapter N/A i2c 1 unknown Synopsys DesignWare I2C adapter N/A i2c 2 unknown Synopsys DesignWare I2C adapter N/A i2c 3 unknown Synopsys DesignWare I2C adapter N/A i2c 4 unknown Synopsys DesignWare I2C adapter N/A i2c 5 unknown Synopsys DesignWare I2C adapter N/A i2c 6 unknown Synopsys DesignWare I2C adapter N/A i2c 7 unknown DesignWare HDMI N/A ``` 检测 I2C 总线上的设备，可见 PCA9557PW 的 I2C 地址为 0x18，与原理图相符： ```bash sipeed@lpi4a:~$ sudo /sbin/i2cdetect r y 0 0 1 2 3 4 5 6 7 8 9 a b c d e f 00: 10: UU 20: 30: 40: 50: 60: 70: ``` ![i2c_io](./assets/peripheral/i2c_io.png) 此外还可以使用 `i2cdump` 来 dump 指定 i2c 地址的所有寄存器，用 `i2cget` 来读出指定 i2c 地址的指定寄存器值，用 `i2cset` 来写入指定 i2c 地址的指定寄存器值。 不过由于 IO 扩展芯片已经被内核使用，所以无法直接使用这些命令验证。用户可以自行在 I2C2 上外接外设来验证。 ## SPI LicheePi4A上预留了两路SPI，一路是背面空贴的SPI Flash焊盘，一路是插针上的SPI。 ```bash sipeed@lpi4a:~$ ls /dev/spidev2.0 /dev/spidev2.0 ``` <! ### 开始 注意IO驱动能力，Licheepi4A需要外置电平转化芯片，自用TXS0108E） 该例程所有程序均在板子上编译，如有需要交叉编，在编译的时候更换工具链即可。 以下例程的GPIO操作基于上面的GPIOD库。 #### 1.下载源码 ```shell git clone https://github.com/fffdee/ST7735_for_Licheepi4A.git ``` #### 2. 构建GPIOD库 安装所需要的依赖： ```shell sudo apt get install build essential pkg config m4 automake autoconf libtool autoconf archive sudo apt install gcc g++ gpiod cmake ``` 安装GPIOD库(源文件已安装,需要更改库路径参考以下操作)： ```shell tar zxvf libgpiod 2.0.tar.gz cd libgpiod 2.0 export CC gcc export CXX g++ #部署库的相关文件到项目文件夹： prefix后面的路径要换成自己项目所在的路径，方便后续操作 ./autogen.sh enable tools yes prefix /home/sipeed/TFT_demo/ make sudo make install #安装完毕 ``` #### 3.编译以及运行 ```shell cd TFT_demo cmake . make j4 #授予设备权限，每次开机执行一次即可 . exec.sh ./tft_demo ``` ### 效果图 ![效果图1](./assets/peripheral/tft_demo.png) > SPI 常用的 ioctl 命令： SPI_IOC_MESSAGE：用于发送和接收 SPI 消息，可以用于读写数据、控制设备等操作 SPI_IOC_WR_MODE：用于设置 SPI 设备的工作模式, 如 CPOL、CPHA 等 SPI_IOC_RD_MODE：用于读取 SPI 设备的工作模式 SPI_IOC_WR_LSB_FIRST：用于设置 SPI 设备的字节顺序，即最高位先传输还是最低位先传输 SPI_IOC_RD_LSB_FIRST：用于读取 SPI 设备的字节顺序 SPI_IOC_WR_BITS_PER_WORD：用于设置 SPI 设备的数据位宽 SPI_IOC_RD_BITS_PER_WORD：用于读取 SPI 设备的数据位宽 SPI_IOC_WR_MAX_SPEED_HZ：用于设置 SPI 设备的最大时钟频率 SPI_IOC_RD_MAX_SPEED_HZ：用于读取 SPI 设备的最大时钟频率 SPI_IOC_WR_MODE32：用于设置 SPI 设备的 32 位模式, 如 CPOL、CPHA 等 SPI_IOC_RD_MODE32：用于读取 SPI 设备的 32 位模式 以上是一些常用的 SPI 设备 ioctl 命令，可以用于配置和控制 SPI 设备的各种参数。 打开/关闭 SPI 设备： ```c int open(const char *pathname, int flags); int close(int fd); ``` 需要引用的头文件： ```c #include<fcntl.h> #include<unistd.h> ``` 示例代码： ```c #include <stdint.h> #include <unistd.h> // C 语言标准头文件，定义了 POSIX API 的一部分，如文件操作、进程管理等 #include <stdio.h> #include <stdlib.h> #include <string.h> #include <getopt.h> #include <fcntl.h> // C 语言头文件，定义了文件控制相关的宏和函数 #include <sys/ioctl.h> // C 语言头文件，定义了 ioctl 函数和相关宏 #include <linux/types.h> // Linux 内核头文件，定义了内核中使用的一些基本数据类型 #include <linux/spi/spidev.h> // Linux SPI 子系统头文件，定义了 SPI 设备驱动程序使用的数据结构和 ioctl 命令 #define DATA_NUM 2 // 自定义数据长度 #define CHECK(ret, str) if (ret < 0) {printf(\"%s\\r\\n\", str); return ret;} static uint8_t bits 8; static uint32_t speed 1000000; // 1M Hz static int mode 0; int main(int argc, char *argv[]) { int ret, fd; fd open(\"/dev/spidev2.0\", O_RDWR); CHECK(fd, \"can't open device\"); // 打开具体 spi 设备 mode SPI_MODE_0 SPI_CS_HIGH; ret ioctl(fd, SPI_IOC_WR_MODE32, &mode); //设置 SPI 模式 CHECK(ret, \"can't set spi mode\"); ret ioctl(fd, SPI_IOC_RD_MODE32, &mode); //获取 SPI 模式设置 CHECK(ret, \"can't get spi mode\"); ret ioctl(fd, SPI_IOC_WR_BITS_PER_WORD, &bits); //设置 SPI 的 bit/word CHECK(ret, \"can't set bits per word\"); ret ioctl(fd, SPI_IOC_RD_BITS_PER_WORD, &bits); //获取 SPI 的 bit/word 设置 CHECK(ret, \"can't get bits per word\"); ret ioctl(fd, SPI_IOC_WR_MAX_SPEED_HZ, &speed); //设置 SPI 的最大传输速度 CHECK(ret, \"can't set max speed hz\"); ret ioctl(fd, SPI_IOC_RD_MAX_SPEED_HZ, &speed); //获取 SPI 的最大传输速度设置 CHECK(ret, \"can't get max speed hz\"); printf(\"spi mode: %d\\n\", mode); printf(\"bits per word: %d\\n\", bits); printf(\"max speed: %d Hz (%d KHz)\\n\", speed, speed/1000); //数据传输 uint8_t tx[] {0x11, 0x22}; uint8_t rx[DATA_NUM] {0}; struct spi_ioc_transfer tr { .tx_buf (unsigned long)tx, //定义发送缓冲区指针 .rx_buf (unsigned long)rx, //定义接收缓冲区指针 .len DATA_NUM, .delay_usecs 0, .speed_hz speed, .bits_per_word bits }; ret ioctl(fd, SPI_IOC_MESSAGE(1), &tr); //执行 spidev.c 中 ioctl 的 default 进行数据传输 CHECK(ret, \"can't send spi message\"); printf(\"tx: %.2X %.2X\\r\\n\", tx[0], tx[1]); printf(\"rx: %.2X %.2X\\r\\n\", rx[0], rx[1]); close(fd); return ret; } ``` ## USB ### USB SSD 连接好 USB SSD： ![usb_ssd_connect](./assets/peripheral/usb_ssd_connect.jpg) 在系统中可以看到相应的设备： ![usb_ssd_use](./assets/peripheral/usb_ssd_use.png) ### USB 网卡 连接好 USB 网卡： ![usb_lan_connect](./assets/peripheral/usb_lan_connect.jpg) 右上角的网络图标会变为已连接有线网的状态： ![usb_lan_use](./assets/peripheral/usb_lan_use.png) 终端中使用`sudo ifconfig`命令，也可以看到相应设备的信息： ![check_usb_lan_ip](./assets/peripheral/check_usb_lan_ip.png) ### USB 摄像头 连接好 USB 摄像头： ![usb_cam_connect](./assets/peripheral/usb_cam_connect.jpg) 安装 guvcview 后，使用相应的命令，即可看到 USB 摄像头的图像流： ```shell sudo apt get install guvcview guvcview ``` ![usb_cam_use](./assets/peripheral/usb_cam_use.png) 按下 Ctrl+C 或点击 guvcview 窗口的 quit 按钮都可以结束图像流。 也可以使用 fswebcam 来直接在命令行中 dump USB 摄像头的图像。 ```shell sudo apt get install fswebcam fswebcam /dev/video0 image.jpg ``` 若要让 USB 摄像头自动存图，以下给出一个参考脚本。该脚本使用 uvccapture 工具，可以方便地根据需要调整拍摄参数。 首先安装这个工具 ```shell sudo apt install uvccapture ``` 这个工具支持各种参数，使用 ` x y` 调整拍摄分辨率，` B`调整亮度，` C`调整对比度，` S`调整饱和度，` o`可以指定拍摄图像存储路径，具体使用参考下面的脚本代码： ```shell #!/bin/bash # 检查是否传入了间隔时间参数 if [ z \"$1\" ]; then echo e \"未指定间隔时间参数，默认使用1秒间隔\" interval 1 else interval $1 fi # 检查是否传入了输出文件路径参数 if [ z \"$2\" ]; then echo e \"未指定输出文件路径参数，默认输出到当前目录下\" output_file \"$PWD\" else output_file $2 fi # 检查是否传入了拍摄次数参数 if [ z \"$3\" ]; then echo e \"未指定拍摄次数，默认拍摄10张\" num_executions 10 else num_executions $3 fi echo e \"脚本开始执行，按下q键停止\" for ((i 1; i < num_executions; i++)); do echo e \"capture img $i\" uvccapture x640 y480 m o$output_file/$image$i.jpg \t # 间隔指定时间再拍照 \t sleep $interval \t # 按下q键退出 \t read t 1 n 1 key \t if [[ $key \"q\" ]]; then \t break \t fi done echo e \"脚本执行结束\" ``` 上述脚本中也可以使用 fswebcam 来操作，做相应更改即可。 ### USB 声卡 TODO ## ETH LicheePi4A 具有双千兆网口，其中 Eth0 还具备 PoE 功能。 TODO ### PoE LicheePi 4A的Ethernet 0接口具有PoE功能，可通过PoE实现供电。 PoE供电模块需要自行购买，使用5V电压，35.6mm长度的规格，可以通过搜索“5V PoE 插针”关键词搜索得到。 当目视方向正对“POE POWER”标识时，针脚左边4根针脚定义从左到右依次为：VA1、VA2、VB1、VB2，右边为：GND、5VIN。 ## Speaker Audio LicheePi 4A 上有两个模拟硅麦，使用 ES7210 CODEC，以及有一路板载的扬声器，和立体声耳机，使用 ES8156 CODEC。 > 注：板载扬声器与立体声耳机使用了互斥设计，插入耳机后，音频输出自动切换到耳机，板载扬声器失能。 使用 aplay 和 arecord 可以进行简易录放测试， 注意板载扬声器是右声道。 ```bash #!/bin/bash echo \"Play Test Audio\" aplay /usr/share/sounds/alsa/Side_Right.wav # Record Audio echo \"Start record auido, auto replay after 3 seconds\" arecord Dhw:0,1 d 3 r 48000 f S16_LE t wav test.wav & > /dev/null & sleep 4 # Play Audio aplay test.wav echo \"Start Play\" ``` 你还可以使用alsa相关工具，如`alsamixer`，进行音量调整等操作。 ## HDMI 音频 > 注：早期镜像的HDMI音频不生效，请升级到较新版本使能HDMI音频功能。 点击屏幕右上角的喇叭图标，进入 Audio mixer，可以看到下面的界面： ![audiomixer](./assets/peripheral/audiomixer.png) 名字为 **Built in Audio** 设备即 HDMI 音频，可以在这个界面点击它对应的绿色对勾图标进行音频设备切换，也可以在直接单击小喇叭图标后进行设备的切换。 若确认连接无误，且使用的 HDMI 显示器支持 HDMI 音频功能，但没有在设备列表中看到相应设备，可以尝试运行以下命令： ```shell systemctl user restart pulseaudio.service ``` ## MIPI CSI LicheePi 4A 具有 CAM0/CAM1/CAM2 三个摄像头接口， CAM0 最大 4lane，CAM1/2 为 2lane，默认使用 CSI0 接口，接 OV5693 摄像头。 连接方式如下图所示，使用 CSI0 接口，摄像头金手指面朝下连接： ![mipi_csi_connect.jpg](./assets/peripheral/mipi_csi_connect.jpg) 目前暂时需要烧录专用的镜像测试，在文档镜像集合页面中的[百度网盘](https://pan.baidu.com/e/1xH56ZlewB6UOMlke5BrKWQ)，下载 /image/latest_20230714/LPI4A_YOCTO_CAM.zip 镜像文件。 烧录后，进入到 /usr/share/csi_hal/ 目录下，运行如下命令： ```shell ./cam_demo_simple 2 0 1 0 640 480 1 30 ``` 运行完成后，可以在当前目录看到dump下来的拍摄照片，典型命名为 demo_save_img_OV5693_ch0_0_* ，分辨率为640\\*480(当前仅支持640*480分辨率)，格式为 YUV420SP(NV12)，该格式下UV分量交织存储， bit depth 为 8bit，查看时注意相关参数配置是否正确。 Linux 下可以使用 YUView 设置相关参数查看图片；此外，还可以使用 python 处理相关参数后查看图片，参考代码如下： ```python import numpy as np import cv2 class nv12_to_jpg: def __init__(self): return def to_jpg(self, yuv_path, resolution): width, height resolution with open(yuv_path, 'rb') as f: yuvdata np.fromfile(f, dtype np.uint8) self.input_file yuv_path cv_format cv2.COLOR_YUV2RGB_NV21 bgr_img cv2.cvtColor(yuvdata.reshape((height*3//2, width)), cv_format) return bgr_img def save(self, img_data, output_path): cv2.imwrite(output_path, img_data) if __name__ \"__main__\": # 例：将10bit raw格式的图像转换为jpg格式 file_name input(\"请输入 raw 图片的文件名：\") input_str input(\"width 和 hight，用空格分隔：\") width, height map(int, input_str.split()) img nv12_to_jpg() jpg_data img.to_jpg(file_name, (width, height)) img.save(jpg_data, file_name+'nv12tojpg.jpg') ``` ## MIPI DSI LicheePi 4A 具有 MIPI DSI0 接口，支持 4K 视频输出，可以选配 10.1 寸 1280x800 或者 1920x1200 的屏幕。 连接方式如下图，两根 fpc 软排线均为下接（排线末端金属触点的那一面朝下），其中触摸屏的转接小板在连接时需要注意方向，确认ToLPi4A 的那一头连接LPi4A的触摸软排线，ToLcdTP 的那一头连接屏幕： 软排线金属触点面示意图： ![fpc](./assets/peripheral/fpc.jpg) 注意在连接前，先拨起接口上用于固定排线的黑色翻盖，确认接好后再拨下。 触摸屏软排线连接： ![tpconnector_on_touchscreen](./assets/peripheral/tpconnector_on_touchscreen.jpeg) ![touchconnector_on_board](./assets/peripheral/touchconnector_on_board.jpeg) MIPI 屏软排线连接： ![mipi_dsi_connect](./assets/peripheral/mipi_dsi_connect.jpeg) 确认连接无误后，使用支持 MIPI 屏幕的固件，开机即可看到 MIPI 屏幕显示。 若只使用 MIPI 屏幕，可以在系统设置中关闭 HDMI 显示，将 MIPI 屏幕设置为主屏幕，也可使用以下命令： ```shell xrandr output HDMI 1 off xrandr output DSI 1 rotate normal primary ``` 上述命令中 `rotate` 参数为屏幕的旋转方向，`normal` 表示为不旋转，即竖屏显示，若要继续横屏显示可以改为 `left` 或者 `right`。 若同时使用 MIPI 屏幕和 HDMI 屏幕，也可以根据上述命令来设置主屏幕和两个屏幕间的关系，例如下面的命令，将 HDMI 设置为主屏幕，MIPI 屏幕设置为主屏幕下方的扩展屏幕且为横屏显示： ```shell xrandr output HDMI 1 auto primary xrandr output DSI 1 rotate left below HDMI 1 ``` 上述的屏幕标识符和可供设置的分辨率可以直接输入 `xrandr` 命令来查看。 若修改设置后发现触摸屏的坐标不对，可以按照下面的步骤修正： 查看触摸屏设备对应的 ID ```shell xinput ``` ![list_touchsreen](./assets/peripheral/list_touchsreen.png) 这里可以看到是触摸屏设备 Goodix 7，那么则输入下面命令，将触摸设备映射到正确的屏幕上： ```shell xinput map to output 7 DSI 1 ``` 同样的，根据 ID，也可以使用下列命令来关闭相应的触摸设备： ```shell xinput disable 7 ``` 若只使用 HDMI 屏幕，先断电，将 MIPI 屏幕和触摸板的软排线都拔掉后再上电。再运行下面的命令（需要切换到 root 用户执行，直接 sudo 可能会遇到权限不够的问题）： ```shell echo off > /sys/class/drm/card0 DSI 1/status ``` ## JTAG 在核心板上预留了 JTAG 接口，但需要自己将 GND，TDI，TDO，TMS，TCK 飞线引出，需要引出的线示意图如下： ![jtag_connect_out](./assets/peripheral/jtag_connect_out.jpg) 连接调试器前，确定调试器处于 CKLink 模式。接下来，以[SLogic Combo 8](https://en.wiki.sipeed.com/hardware/zh/logic_analyzer/combo8/index.html) 和 RV Debugger Plus 为例。 对于 SLogic Combo 8，请参考[相应文档](https://en.wiki.sipeed.com/hardware/zh/logic_analyzer/combo8/use_cklink_function.html)切换为CKLink模式。 对于 RV Debugger Plus，请参考[该仓库](https://github.com/bouffalolab/bouffalo_sdk/tree/master/tools/cklink_firmware)刷入 CKLink 专用固件。**注意，使用时最好再接电平转换芯片，直连有烧毁风险。** 完成上述步骤后，通过排针用杜邦线连接到调试器 ![jtag_connect_pin](./assets/peripheral/jtag_connect_pin.jpg) 连接到 JTAG 调试器后，在串口中使用 memtool 工具设置一下 pinmux（这一步是在开发板上执行，memtool工具也是在开发板中安装）： ```shell sudo apt install memtool sudo memtool mw 0xfffff4a404 0 ``` 该 pinmux 设置会在关机后失效。因为 JTAG 引脚用作了 USB 路选的功能，在每次调试时设置一下 pinmux 即可。 接下来下载安装 debug server，在[平头哥官网下载](https://xuantie.t head.cn/community/download?id 4209675990638596096)。 下载完成后，参考[平头哥官方文档](https://occ oss prod.oss cn hangzhou.aliyuncs.com/resource//1682234034575/T Head+Debugger+Server+User+Guide+%28ZH CN%29.pdf)安装。 确认连接好设备，并且正确设置 pinmux 之后， 以 Linux 为例，使用命令 `DebugServerConsole` 打开 DebugServerConsole： ![open_debugserver](./assets/peripheral/open_debugserver.png) 即可看到成功连接： ![check_debugserver](./assets/peripheral/check_debugserver.png) ## GPU 使用命令以下命令可以实时查看 GPU 的状态： ```shell sudo watch cat /sys/kernel/debug/pvr/status ``` 在 xfce 桌面下，GPU 的状态如下： ![gpu_status_desktop](./assets/peripheral/gpu_status_desktop.png) 使用 Chromium 浏览器播放视频时，GPU 的状态如下： ![gpu_status_play_video](./assets/peripheral/gpu_status_play_video.png) ## NPU > **注意**：使用 NPU 驱动，需要使用[20230920](https://pan.baidu.com/e/1xH56ZlewB6UOMlke5BrKWQ)以上版本镜像，该镜像开机会自动加载 NPU 相关驱动。 LicheePi4A 板载了一颗支持 4TOPS@INT8 通用 NNA 算力，主频 1GHz 的 NPU。Wiki 中包含的支持 NPU 的示例如下： 示例名称示例功能使用模型接口HHB版本 Mobilenetv2 做图像分类图像分类mobilenetv2c/c++2.4及以上 YOLOv5 做目标检测目标检测YOLOv5python2.4及以上 RTMPose 做姿态估计姿态估计RTMPosepython2.6及以上 为了将上述示例中的模型交叉编译为 LicheePi4A 上的可执行程序，我们首先需要在自己的电脑上搭建 HHB 开发环境。 > 推荐环境：ubuntu20.04 系统，Docker 使用20.10.21版本。推荐使用 Docker 镜像来搭建环境。 ### 环境配置 **开发板配置** #### SHL 库安装 使用 pip 安装 ```shell pip3 install shl python ``` 安装后，使用 whereis 查看安装位置 ```shell python3 m shl whereis th1520 # 若使用纯 CPU 推理，则替换为 python3 m shl whereis c920 ``` 根据打印的位置，将目录中的动态库复制到 /usr/lib 目录中，比如，打印的是： ```shell /home/sipeed/ort/lib/python3.11/site packages/shl/install_nn2/th1520 ``` 可以使用复制命令： ```shell sudo cp /home/sipeed/ort/lib/python3.11/site packages/shl/install_nn2/th1520/lib/* /usr/lib/ ``` #### python 虚拟环境 需要先安装 python 虚拟环境，再使用 pip3 安装 python 包。 使用如下命令，安装 venv 包，用于创建python虚拟环境（以在 root 目录中创建 python 虚拟环境为例）： ```shell sudo i apt install python3.11 venv cd /root python3 m venv ort source /root/ort/bin/activate ``` #### HHB onnxruntime 安装 HHB onnxuruntime 是移植了 SHL 后端（execution providers），让 onnxruntime 能复用到 SHL 中针对玄铁 CPU 的高性能优化代码。 CPU 版本 ```shell wget https://github.com/zhangwm pt/onnxruntime/releases/download/riscv_whl_v2.6.0/hhb_onnxruntime_c920 2.6.0 cp311 cp311 linux_riscv64.whl pip install hhb_onnxruntime_c920 2.6.0 cp311 cp311 linux_riscv64.whl ``` NPU 版本 ```shell wget https://github.com/zhangwm pt/onnxruntime/releases/download/riscv_whl_v2.6.0/hhb_onnxruntime_th1520 2.6.0 cp311 cp311 linux_riscv64.whl pip install hhb_onnxruntime_th1520 2.6.0 cp311 cp311 linux_riscv64.whl ``` **x86主机配置** 首先要在自己的电脑上安装 Docker，先卸载可能存在的 Docker 版本： ```shell sudo apt get remove docker docker engine docker.io containerd runc ``` 安装Docker依赖的基础软件： ```shell sudo apt get update sudo apt get install apt transport https ca certificates curl gnupg agent software properties common ``` 添加官方源： ```shell curl fsSL https://download.docker.com/linux/ubuntu/gpg sudo apt key add sudo add apt repository \"deb [arch amd64] https://download.docker.com/linux/ubuntu $(lsb_release cs) stable\" ``` 安装 Docker： ```shell sudo apt get update sudo apt get install docker ce docker ce cli containerd.io ``` 安装完毕后，获取 HHB 环境的 Docker 镜像： ```shell docker pull hhb4tools/hhb:2.4.5 ``` 拉取镜像完毕后，使用下面的命令进入 Docker 镜像： ```shell docker run itd name your.hhb2.4 p 22 \"hhb4tools/hhb:2.4.5\" docker exec it your.hhb2.4 /bin/bash ``` 进入 Docker 镜像后，可使用下面的命令确认 HHB 版本： ```shell hhb version ``` 进入 Docker 镜像中后，还需要配置交叉编译环境。注意必须要使用这这里的工具链，否则编译出的二进制文件无法在 LicheePi4A 上运行。 ```shell export PATH /tools/Xuantie 900 gcc linux 5.10.4 glibc x86_64 V2.6.1 light.1/bin/:$PATH ``` clone NPU 示例代码： ```shell git clone https://github.com/zhangwm pt/lpi4a example.git ``` 至此，HHB 环境初步搭建完成。可以尝试以下的 NPU 示例： [Mobilenetv2 做图像分类](https://wiki.sipeed.com/hardware/zh/lichee/th1520/lpi4a/8_application.html#MobilenertV2) [YOLOv5 做目标检测](https://wiki.sipeed.com/hardware/zh/lichee/th1520/lpi4a/8_application.html#Yolov5n) NPU 相关 API 等其他信息，请查看[hhb tools 语雀文档](https://www.yuque.com/za4k4z)。 ## 其它 欢迎投稿～ 投稿接受后可得￥5～150（$1~20）优惠券！"},"/hardware/zh/lichee/th1520/lpi4a/7_develop_mainline.html":{"title":"Mainline Linux","content":" title: Mainline Linux keywords: Linux, Lichee, TH1520, SBC, RISCV, Kernel, SDK, Develop update: date: 2023 09 17 version: v1.1 author: ztd content: Update docs date: 2023 05 08 version: v1.0 author: wonder content: Release docs ## Mainline Linux 注意，目前主线 Linux 支持尚不完善，本文档也会根据完善进度进行相应的更新。 ### 前言 Linux 主线在 v6.5 rc1 版本加入了 部分补丁，以提供对 Lichee Pi 4A 的支持。本文介绍了为 LicheePi 4A 开发板构建并运行 Linux v6.5 rc1 的过程，实现的效果为：内核可以成功启动并进入 initramfs 命令行界面。 ### 软件版本 SoftwareVersion Linux6.5 rc1 U Boot2020.01 OpenSBI0.9 Buildroot2023.02.2 ### 构建 U Boot、OpenSBI U Boot 和 OpenSBI 主要使用了 Sipeed 官方提供的版本， 见 [RevyOS 文档](https://wiki.sipeed.com/hardware/zh/lichee/th1520/lpi4a/7_develop_revyos.html) 中构建 U Boot 和 OpenSBI 的相关部分。 ### 构建设备树 在尝试使用 Linux v6.5 rc1 自带的设备树进行启动时，系统会在初始化 PLIC 时报错： ```shell [ 0.000000] Oops load access fault [#1] [ 0.000000] epc : __plic_toggle+0x6a/0x72 ``` 由于无法验证该设备树是否存在 Bug，所以使用了 Sipeed 官方 SDK 编译的设备树。 根据 [RevyOS 文档](https://wiki.sipeed.com/hardware/zh/lichee/th1520/lpi4a/7_develop_revyos.html#%E6%9E%84%E5%BB%BAkernel) 构建内核后，设备树文件为： arch/riscv/boot/dts/thead/light lpi4a.dtb（对应8G内存核心板）;arch/riscv/boot/dts/thead/light lpi4a 16gb.dtb（对应16G内存核心板）。 ### 构建 initramfs 使用 Buildroot 构建 initramfs 较为简单，只需进行简单的配置，即可自动编译生成。 #### 配置处理器架构 在 Buildroot 目录下输入： ```shell make menuconfig ``` 选择架构为 RISC V： ```shell Target options > Target Architecture () > (X) RISCV ``` #### 配置文件系统类型 选择文件系统类型为 CPIO： ```shell Filesystem images > [*] cpio the root file system(for use as an initial RAM filesystem) ``` #### 配置内核 构建好 initramfs 后，需要在内核配置中使能 initramfs，并指定生成的 CPIO 文件的位置。 ```shell General Setup > [*] Initial RAM filesystem and RAM disk (initramfs/initrd) support () Initramfs source file(s) ``` ### 构建内核 构建 Linux v6.5 rc1 内核的过程与 [RevyOS 文档](https://wiki.sipeed.com/hardware/zh/lichee/th1520/lpi4a/7_develop_revyos.html#%E6%9E%84%E5%BB%BAkernel)中构建内核的过程基本一致，只是需要在配置内核时更改为使用 RISC V 架构下的 defconfig： ```shell make CROSS_COMPILE riscv64 unknown linux gnu ARCH riscv defconfig ``` #### 串口无法工作 在尝试使用直接编译的 Linux v6.5 rc1 内核在开发板上启动时，串口输出会卡住，不再继续显示，相关日志如下： ```shell [ 0.876673] Warning: unable to open an initial console. [ 0.884088] Freeing unused kernel image (initmem) memory: 3744K [ 0.895429] Run /init as init process ``` 下面将介绍该问题的解决思路和解决方法。 #### 解决思路 下面依次从根文件系统、内核启动参数、设备树、内核驱动这几个方面考虑可能出现问题的原因，并依次进行了排查。 ##### 根文件系统 针对该问题，最普遍的原因为：根文件系统中缺少 console 文件。因此需要在根文件系统的 /dev 目录下输入以下命令进行创建： ```shell mknod m 660 console c 5 1 mknod m 660 null c 1 3 ``` 打开 /dev 目录下发现并不缺少 console 文件，问题没能解决。进行测试时发现：使用构建好的内核文件和 initramfs 在 QEMU 模拟器上运行时，QEMU 模拟器可以正常启动，进入到 initramfs 的命令行界面，因此推断构建的 initramfs 可以正常使用。 ##### 内核启动参数 在内核启动时，需要由 Bootloader 为其传递一些命令行参数。其中 console 参数指定了内核启动后使用的输出端口，通常设置为 console ttyS0,115200。如果开发板串口提供的波特率不为 115200，则需要进行更改。 在使用了 U Boot 作为 Bootloader 时，可以在启动倒计时按下回车键，进入 U Boot 命令行界面， 输入 printenv 指令可以看到内核启动参数 bootargs，并可以通过 setenv 指令修改该参数。 在内核的启动日志中也会打印出启动参数，如： ```shell [ 0.000000] Kernel command line: console ttyS0,115200 rootwait rw earlycon init /lib/systemd/systemd ``` 同时需要注意，在内核启动时使用的 bootconsole 并不受启动参数 console 的影响。 ```shell [ 0.000000] earlycon: uart0 at MMIO32 0x000000ffe7014000 (options '115200n8') [ 0.000000] printk: bootconsole [uart0] enabled ``` ##### 设备树 随后考虑了设备树是否有问题，但使用的设备树为开发板厂家 Sipeed 提供的，并且可以成功启动厂家提供的 RevyOS（基于 Linux v5.10.113）。因此推断设备树可以正常使用。 ##### 内核驱动 其他因素已经排除的差不多，只剩内核相关的因素可能存在问题。而使用 QEMU 可以成功启动构建好的内核，因此基本将问题锁定在与开发板相关的因素。主要怀疑内核驱动与设备树的对应可能存在问题，最怀疑的是串口驱动。 重新分析启动日志后发现，存在下述输出： ```shell [ 0.674296] Serial: 8250/16550 driver, 4 ports, IRQ sharing disabled ``` 这句输出可以证明串口驱动被内核正常加载。而下述输出： ```shell [ 11.098262] platform ffe7014000.serial: deferred probe pending ``` 基本宣告了问题出现的真正原因：串口设备加载失败。 Linux 内核驱动采用平台设备驱动模型，驱动和设备分别被加载进内核，再进行匹配。因此驱动被成功加载，而串口加载失败，这种情况是可能的。导致 deferred probe pending 的原因可能为：该设备依赖的驱动没有被内核正确加载。随后分析设备树文件中串口相关部分： ```shell uart0: serial@ffe7014000 { /* Normal serial, for C910 log */ compatible \"snps,dw apb uart\"; …… interrupt parent <&intc>; …… clocks <&clk CLKGEN_UART0_SCLK>; …… }; intc: interrupt controller@ffd8000000 { compatible \"riscv,plic0\"; …… }; clk: clock controller@ffef010000 { compatible \"thead,light fm ree clk\"; …… }; ``` 通过在代码仓库中搜索 compatible 属性的值，来判断内核中是否存在驱动缺失的情况。 串口使用的驱动为：“snps,dw apb uart” 串口依赖的中断控制器 intc 使用的驱动为：“riscv,plic0” 串口依赖的时钟 clk 使用的驱动为：“thead,light fm ree clk” 通过搜索发现串口依赖的时钟 clk 使用的驱动 “thead,light fm ree clk” 缺失。 从 Sipeed 提供的内核中将相关驱动移植到 Linux v6.5 rc1 后，终于可以正常启动。 ##### 解决方法 1. 在 Sipeed 提供的内核中找到 drivers/clk/thead 文件夹，添加到 Linux v6.5 rc1 的 drivers/clk 文件夹下 2. 将 thead 文件夹中的 Kconfig 文件进行修改：将其中所有 SOC_THEAD 替换为 ARCH_THEAD 3. 修改 drivers/clk 下的 Kconfig 和 Makefile 文件，使之包含 thead 文件夹 4. 在 Sipeed 提供的内核中找到 include/dt bindings/clock 文件夹，添加以下头文件到 Linux v6.5 rc1 的相同文件夹下： light dspsys.h light fm ap clock.h light mpw clock.h light visys.h light vosys.h light vpsys.h 5. 修改 Linux v6.5 rc1 的 arch/riscv/configs/defconfig 文件，在最后添加 ```shell CONFIG_THEAD_CLK y CONFIG_CLK_LIGHT_FM y ``` 驱动移植完成后，再对内核重新编译即可烧录到开发板上正常启动。 ## 参考 [为 LicheePi 4A 开发板构建运行 Linux v6.5 rc1](https://tinylab.org/licheepi4a linux/) [How to troubleshoot deferred probe issues in Linux](https://blog.dowhile0.org/2022/06/21/how to troubleshoot deferred probe issues in linux/) [[PATCH v3 0/8] Add Sipeed Lichee Pi 4A RISC V board support](https://lore.kernel.org/linux riscv/20230617161529.2092 1 jszhang@kernel.org/) [烧录镜像](https://wiki.sipeed.com/hardware/zh/lichee/th1520/lpi4a/4_burn_image.html)"},"/hardware/zh/lichee/th1520/lpi4a/9_benchmark.html":{"title":"CPU 跑分测试","content":" title: CPU 跑分测试 keywords: Linux, Lichee, TH1520, SBC, RISCV, benchmark update: date: 2023 05 08 version: v1.0 author: wonder content: Release docs ## Dhrystone 平头哥官方数据，C910 为 5.6 分左右。 ![dmips](./assets/benchmark/dmips.png) ## CoreMarks 测试参数配置： ` funroll all loops finline limit 500 fgcse sm fno schedule insns msignedness cmpiv fno code hoisting mno thread jumps1 mno iv adjust addr cost mno expand split imm` 使用公版工具链，GCC 版本为`13.1.0`的测试结果（1.85GHz）： ```txt 2K performance run parameters for coremark. CoreMark Size : 666 Total ticks : 11989 Total time (secs): 11.989000 Iterations/Sec : 9175.077154 Iterations : 110000 Compiler version : GCC13.1.0 Compiler flags : O2 DPERFORMANCE_RUN 1 lrt funroll all loops finline limit 500 fgcse sm fno schedule insns msignedness cmpiv fno code hoisting mno thread jumps1 mno iv adjust addr cost mno expand split im Memory location : Please put data memory location here (e.g. code in flash, data on heap etc) seedcrc : 0xe9f5 [0]crclist : 0xe714 [0]crcmatrix : 0x1fd7 [0]crcstate : 0x8e3a [0]crcfinal : 0x33ff Correct operation validated. See README.md for run and reporting rules. CoreMark 1.0 : 9175.077154 / GCC13.1.0 O2 DPERFORMANCE_RUN 1 lrt funroll all loops finline limit 500 fgcse sm fno schedule insns msignedness cmpiv fno code hoisting mno thread jumps1 mno iv adjust addr cost mno expand split im / Heap ``` 使用平头哥专用工具链，GCC 版本为`10.4.0`的测试结果（1.85GHz）： ```txt 2K performance run parameters for coremark. CoreMark Size : 666 Total ticks : 15129 Total time (secs): 15.129000 Iterations/Sec : 13219.644392 Iterations : 200000 Compiler version : GCC10.4.0 Compiler flags : O2 march rv64gv0p7_zfh_xtheadc O3 funroll all loops finline limit 500 fgcse sm fno schedule insns msignedness cmpiv fno code hoisting mno thread jumps1 mno iv adjust addr cost mno expand split imm DPERFORMANCE_RUN 1 lrt Memory location : Please put data memory location here (e.g. code in flash, data on heap etc) seedcrc : 0xe9f5 [0]crclist : 0xe714 [0]crcmatrix : 0x1fd7 [0]crcstate : 0x8e3a [0]crcfinal : 0x4983 Correct operation validated. See README.md for run and reporting rules. CoreMark 1.0 : 13219.644392 / GCC10.4.0 O2 march rv64gv0p7_zfh_xtheadc O3 funroll all loops finline limit 500 fgcse sm fno schedule insns msignedness cmpiv fno code hoisting mno thread jumps1 mno iv adjust addr cost mno expand split imm DPERFORMANCE_RUN 1 lrt / Heap lrt / Heap ``` ![coremarks](./assets/benchmark/coremarks.png) ## Geekbench5 > 注：这里的测试使用公版工具链，若使用thead专用工具链，性能预计可提升50%以上 ![geekbench5](./assets/benchmark/geekbench5.png) https://browser.geekbench.com/v5/cpu/compare/21100603?baseline 21092115 ## 7 Zip LZMA [7 Zip LZMA Benchmark](https://7 cpu.com/) ![7z](./assets/benchmark/7z.png) ## OpenSSL ```bash openssl speed evp aes 256 cbc openssl speed evp aes 256 gcm openssl speed evp sha1 openssl speed evp sha256 ``` type 16bytes 64bytes 256bytes 1024bytes 8192bytes 16384bytes <p style \"white space:nowrap\">AES 256 CBC</p> 29206.05k 36957.73k 39648.85k 40407.72k 40624.13k 40768.21k <p style \"white space:nowrap\">AES 256 GCM</p> 24610.57k 28191.29k 29459.29k 29727.06k 29911.72k 29949.95k <p style \"white space:nowrap\">sha1</p> 9428.03k 30591.02k 72920.06k 113164.63k 135271.77k 137052.16k <p style \"white space:nowrap\">sha256</p> 6206.94k 17151.38k 34806.19k 47151.10k 52559.87k 53163.07k ## LLVM 编译脚本使用[scriptlets](https://github.com/AOSC Dev/scriptlets/tree/master/buildbot benchmark)仓库下的 `buildbot benchmark.bash`，CPU频率为1.843Ghz，内存为16G。 编译用时： ```text real 265m50.172s user 980m15.164s sys 60m51.329s ``` ## 其它 欢迎投稿～ 投稿接受后可得￥5～150（$1~20）优惠券！"},"/hardware/zh/lichee/th1520/lpi4a/10_test_report.html":{"title":"板卡性能测试","content":" title: 板卡性能测试 keywords: Linux, Lichee, TH1520, SBC, RISCV, report update: date: 2023 07 13 version: v1.1 author: ztd content: Update docs date: 2023 05 08 version: v1.0 author: wonder content: Release docs ## 功耗测试 ### 静态功耗 场景(静态) 电压 电流 功耗 备注 待机 12V 0.3A 3.6W 不接任何外设 待机 12V 0.32A 3.84W 开启风扇，后续所有测试中风扇均不关闭 单网口连接网线 12V 0.36A 4.32W 双网口连接网线 12V 0.39A 4.68W 连接 HDMI 显示器 12V 0.33A 3.96W ### 动态功耗 场景(动态) 电压 电流 功耗 备注 NPU运算 12V 0.39A 4.68W 仅连接串口、风扇，NPU 频率上限 0.792GHz 待机 12V 0.43A 5.16W 连接HDMI显示器、键盘、鼠标 使用一个网口 STRESS NG 压测<br>( CPU 矩阵运算) 12V 0.65A 7.8W CPU 频率上限 1.845GHz，电压 1V 浏览器播放视频 12V 0.6A 7.2W 使用 GPU、无硬件解码, chromium 浏览器 ## eMMC ```bash #4k写入 dd if /dev/zero of test bs 4k count 100000 oflag direct #4k读取 dd if test of /dev/null bs 4k count 100000 iflag direct #删除测试文件 rm test #连续写入(4MB) dd if /dev/zero of test bs 4096k count 100 oflag direct #连续读取(4MB) dd if test of /dev/null bs 4096k count 100 iflag direct #删除测试文件 rm test #连续写入(64MB) dd if /dev/zero of test bs 65536k count 10 oflag direct #连续读取(64MB) dd if test of /dev/null bs 65536k count 10 iflag direct #删除测试文件 rm test ``` **8GB eMMC** Test Item Result 4KB W 22.4 MB/s 4KB R 22.4 MB/s 4MB W 53.9 MB/s 4MB R 296 MB/s 64MB W 229 MB/s 64MB R 298 MB/s **32/128GB eMMC** Test Item Result 4KB W 24.0 MB/s 4KB R 40.3 MB/s 4MB W 209 MB/s 4MB R 296 MB/s 64MB W 229 MB/s 64MB R 298 MB/s ## LPDDR4X ![lpddr4x](./assets/test_report/lpddr4x.png) ## GbE `iperf3 c 192.168.3.18 t 15` ![iperf](./assets/test_report/iperf.png) ## WiFi 测试环境：室内空旷长走廊 测试方法：使用 iperf3，笔记本电脑作为 server，LPi4A 作为 client 测试设备：路由器使用 newifi D2, 笔记本电脑型号为 宏碁掠夺者战斧300 在路由器与 LPi4A 间隔不同距离的测试结果如下： 5m ![wifi_test_5m.png](./assets/test_report/wifi_test_5m.png) 10m ![wifi_test_10m.png](./assets/test_report/wifi_test_10m.png) 15m ![wifi_test_15m.png](./assets/test_report/wifi_test_15m.png) 20m ![wifi_test_20m.png](./assets/test_report/wifi_test_20m.png) 25m ![wifi_test_25m.png](./assets/test_report/wifi_test_25m.png) 30m ![wifi_test_30m.png](./assets/test_report/wifi_test_30m.png) ## Bluetooth 测试环境：室内近距离 测试方法：手机开启蓝牙共享网络，与开发板配对并连接蓝牙，使用iperf3测试 测试设备：小米13，LPi4A ![bluetooth_phone](./assets/test_report/bluetooth_phone.jpg) ![bluetooth_1520](./assets/test_report/bluetooth_1520.png) ## 温度 散热器: 风扇+铝散热片(25*25*5) 硅脂垫: Laird 500 待机状态： ![temp_idle](./assets/test_report/temp_idle.png) 压测结束： ![temp_press](./assets/test_report/temp_press.png) ## 浏览器测试 在 Chromium 中进行鱼缸测试，结果如图： ![web_browser_fishbowl](./assets/test_report/web_browser_fishbowl.png) ## GPU 使用 `glmark2` 的测试结果如下： ```shell root@lpi4a:~# glmark2 es2 glmark2 2021.12 OpenGL Information GL_VENDOR: Imagination Technologies GL_RENDERER: PowerVR B Series BXM 4 64 GL_VERSION: OpenGL ES 3.2 build 1.16@6099580 Surface Config: buf 32 r 8 g 8 b 8 a 8 depth 24 stencil 8 Surface Size: 800x600 windowed [build] use vbo false: FPS: 460 FrameTime: 2.174 ms [build] use vbo true: FPS: 434 FrameTime: 2.304 ms [texture] texture filter nearest: FPS: 489 FrameTime: 2.045 ms [texture] texture filter linear: FPS: 493 FrameTime: 2.028 ms [texture] texture filter mipmap: FPS: 776 FrameTime: 1.289 ms [shading] shading gouraud: FPS: 1055 FrameTime: 0.948 ms [shading] shading blinn phong inf: FPS: 1049 FrameTime: 0.953 ms [shading] shading phong: FPS: 832 FrameTime: 1.202 ms [shading] shading cel: FPS: 781 FrameTime: 1.280 ms [bump] bump render high poly: FPS: 481 FrameTime: 2.079 ms [bump] bump render normals: FPS: 1056 FrameTime: 0.947 ms [bump] bump render height: FPS: 730 FrameTime: 1.370 ms [effect2d] kernel 0,1,0;1, 4,1;0,1,0;:1 FPS: 456 FrameTime: 2.193 ms [effect2d] kernel 1,1,1,1,1;1,1,1,1,1;1,1,1,1,1;:2 FPS: 184 FrameTime: 5.435 ms [pulsar] light false:quads 5:texture false: FPS: 585 FrameTime: 1.709 ms [desktop] blur radius 5:effect blur:passes 1:separable true:windows 4: FPS: 177 FrameTime: 5.650 ms [desktop] effect shadow:windows 4: FPS: 405 FrameTime: 2.469 ms [buffer] columns 200:interleave false:update dispersion 0.9:update fraction 0.5:update method map: FPS: 135 FrameTime: 7.407 ms [buffer] columns 200:interleave false:update dispersion 0.9:update fraction 0.5:update method subdata: FPS: 160 FrameTime: 6.250 ms [buffer] columns 200:interleave true:update dispersion 0.9:update fraction 0.5:update method map: FPS: 197 FrameTime: 5.076 ms [ideas] speed duration: FPS: 442 FrameTime: 2.262 ms [jellyfish] <default>: FPS: 433 FrameTime: 2.309 ms [terrain] <default>: FPS: 31 FrameTime: 32.258 ms [shadow] <default>: FPS: 275 FrameTime: 3.636 ms [refract] <default>: FPS: 45 FrameTime: 22.222 ms [conditionals] fragment steps 0:vertex steps 0: FPS: 775 FrameTime: 1.290 ms [conditionals] fragment steps 5:vertex steps 0: FPS: 484 FrameTime: 2.066 ms [conditionals] fragment steps 0:vertex steps 5: FPS: 819 FrameTime: 1.221 ms [function] fragment complexity low:fragment steps 5: FPS: 1048 FrameTime: 0.954 ms [function] fragment complexity medium:fragment steps 5: FPS: 694 FrameTime: 1.441 ms [loop] fragment loop false:fragment steps 5:vertex steps 5: FPS: 1093 FrameTime: 0.915 ms [loop] fragment steps 5:fragment uniform false:vertex steps 5: FPS: 678 FrameTime: 1.475 ms [loop] fragment steps 5:fragment uniform true:vertex steps 5: FPS: 438 FrameTime: 2.283 ms glmark2 Score: 551 ``` ![gpu_test_glmark2](./assets/test_report/gpu_test_glmark2.png) 运行 `glxgears` 结果如下： ```shell es2gears_x11 ``` ![gpu_test_gears](./assets/test_report/gpu_test_gears.png) ## 其它 欢迎投稿～ 投稿接受后可得￥5～150（$1~20）优惠券！"},"/hardware/zh/lichee/th1520/index.html":{"title":"","content":""},"/hardware/zh/lichee/th1520/lm4a.html":{"title":"LicheePi Module 4A","content":" title: LicheePi Module 4A keywords: LicheePi, Sodimm, TH1520, RISCV, SBC update: date: 2023 03 31 version: v0.1 author: wonder content: 初次编写文档 ## 简介 LicheePi Module 4A 是一款采用 [平头哥半导体](https://www.t head.cn/) 的 [曳影1520](https://www.t head.cn/product/yeying) 作为主控的核心模组，主控核心包含四核玄铁 C910 CPU, 搭载 4TOPS@int8 AI 算力的 NPU，拥有 4K 视频处理能力，最大支持 16GB LPDDR4X 内存和 128G eMMC 存储，支持双千兆以太网和最大 4K 分辨率视频输出等特性，核心还额外包含一颗 C906 处理器用于音频处理。得益于 SODIMM 样式的封装， LicheePi Module 4A 可以用于多种场合，适用于多款底板。 ## 基本参数 <table> <thead> <tr> <th colspan 2>主控参数</th> </tr> </thead> <tbody> <tr> <td>主控芯片</td> <td>曳影 1520</td> </tr> <tr> <td>CPU处理器</td> <td>RISC V 64GCV C910*4@1.85GHz <br>· 每核支持 64KB I cache 和 64KB D Cache <br>· 四核共享 1MB L2 Cache <br>· 支持 TEE 和 REE，TEE/REE 支持核数启动时可配置<br>· 支持自定义且接口兼容 RISC V 的多核调试框架<br>· 独立电源域，支持 DVFS</td> </tr> <tr> <td>图形处理器</td> <td>· OpenCL 1.1/1.2/2.0<br>· OpenGL ES 3.0/3.1/3.2<br>· Vulkan 1.1/1.2<br>· Android NN HAL</td> </tr> <tr> <td>NPU处理器</td> <td>支持 4TOPS@INT8 通用 NNA 算力，主频 1GHz <br>· 支持 TensorFlow、ONNX、Caffe <br>· 支持 CNN、RNN、DNN 等</td> </tr> <tr> <td>视频解码器</td> <td>实时解码器，支持 H.265/H.264/VP9/8/7/6/AVS/AVS+/AVS2.0/VC1/MPEG4 <br>· 支持 H.264 BP/MP/HP@level 5.1 解码，最大 4K 分辨率<br>· 支持 H.265/HEVC Main Profile@level 5.1 解码，最大 4K 分辨率<br>· 支持 VP9 Profile 2 解码，最大 4K 分辨率<br>· 支持 AVS2.0 解码，最大 4K 分辨率<br>· 支持 VP6/7/8/AVS/AVS+/VC1/MPEG4 解码，最大 1920x1080 分辨率<br>· 解码性能最大 4K@75fps</td> </tr> <tr> <td>视频编码器</td> <td>· 支持 H.264 BP/MP/HP@level4.2 编码，最大 4K 分辨率<br>· 支持 H.265/HEVC Main Profile 编码，最大 4K 分辨率<br>· 仅支持 I 帧和 P 帧<br>· 编码性能最大 4K@40fps</td> </tr> <tr> <th colspan 2>硬件特性</th> </tr> <tr> <td>RAM</td> <td>· 8GB 64bits LPDDR4<br>· 16GB 64bits LPDDR4<br></td> </tr> <tr> <td>ROM</td> <td>eMMC: <br>· 0G<br>· 8G<br>· 32G<br>· 128G</td> </tr> <tr> <td>以太网</td> <td> 千兆 PHY x 2</td> </tr> </tbody> </table> ## 相关链接 [Github](https://github.com/sipeed/LicheePi4A) [Sipeed 下载站(暂时空白)]()"},"/hardware/zh/lichee/th1520/lcon4a/3_images.html":{"title":"镜像集合","content":" title: 镜像集合 keywords: Linux, Lichee, TH1520, Console, RISCV, image update: date: 2023 12 08 version: v1.0 author: ztd content: Release docs ## Sipeed官方镜像 https://github.com/0x754C/sipeed th1520 laptop extra/releases linux image *.deb 是sipeed提供的内核安装包，如果只想升级内核可以安装这个，安装前记得更新到对应版本的uboot，以及备份文件。 sipeed th1520 laptop extra *.deb 是sipeed提供的附加文件安装包，包括配置文件，测试工具，和EC固件。 u boot with spl *.bin 是uboot文件，请选择你电路板对应型号的uboot进行烧写，烧写前记得备份文件，如果烧写错误的uboot可能会导致无法开机。 bootroot *.ext.xz 是分区镜像，如果想整个重新烧录，使用这个。 ## Sipeed官方镜像(旧版) Sipeed 官方镜像基于 Debian 系统修改适配。 默认镜像的帐号密码配置如下： 账户： `sipeed`，密码：`licheepi`； 账户：`debian`，密码： `debian`； root 账户默认没有设置密码。 镜像下载： [百度网盘](https://pan.baidu.com/s/11xiphA 9OAGTaZBY8kTNEg) 提取码: h3gv [mega网盘](https://mega.nz/folder/p0oiwCqI#EFGgwRnoB9mX14pKI2pu4Q) 烧录方式请参考[烧录镜像](https://wiki.sipeed.com/hardware/zh/lichee/th1520/lcon4a/4_burn_image.html) ## PLCT官方镜像 https://github.com/revyos/mkimg th1520/releases 烧录方法同上"},"/hardware/zh/lichee/th1520/lcon4a/lcon4a.html":{"title":"LicheePi Console 4A","content":" title: LicheePi Console 4A keywords: LicheeConsole, TH1520, RISCV, SBC, Laptop update: date: 2023 10 27 version: v0.1 author: Zepan content: 初次编写文档 ## 简介 Lichee Console 4A (以下简称 Console ) 是矽速科技研发的高性能 RISC V 便携终端，旨在让RISC V开发者提前体验RISC V产品在实际生活中的应用。 Lichee Console 4A 在不到A5笔记本的尺寸下集成了高性能RISC V TH1520 SOM(8+32/16+128可选), 7寸1280x800电容触摸屏，72键键盘，以及USB A，USB C，2242 SSD卡槽，TF卡槽，miniHDMI，3.5mm耳机孔，以太网口 等丰富接口，真正做到了将RISC V开发终端塞进口袋里～ Lichee Console 4A 的软件支持也做到了较为完善的程度，默认搭载Debian操作系统，支持 Chrome浏览器，VSCode IDE，KiCAD PCB绘图软件，Office软件，4K播放器，多种游戏模拟器，基本满足日常工作学习使用。 Lichee Console 4A 使用了模块化的设计方式，如果你之前购买了LicheePi4A，则可以复用SOM到Console上。 > 注意:高性能RISCV消费电子在当前(2023年)还是属于较为早期的阶段，Lichee Console 4A主要面向 RISC V 开发者体验开发使用，至少要求熟练的Linux操作经验，普通消费者是无法直接上手使用的。 > 如果你是没有Linux经验的普通用户，请不要购买。 ![lcon4a](./assets/lcon4a/lcon4a.jpg) ## 技术规格 <table> <colgroup> <col class \"org left\" /> <col class \"org left\" /> </colgroup> <tr> <td class \"org left\">SOM</td> <td class \"org left\"> <a href \"https://wiki.sipeed.com/lm4a\">LM4A</a> </td> </tr> <tr> <td class \"org left\">CPU</td> <td class \"org left\"><strong>RISC V RV64GCV C910@1.85GHz * 4</strong> </td> </tr> <tr> <td class \"org left\">GPU</td> <td class \"org left\">IMG™ B 系列 BXM 4 64 </td> </tr> <tr> <td class \"org left\">NPU</td> <td class \"org left\">4TOPS@INT8 </td> </tr> <tr> <td class \"org left\">Memory</td> <td class \"org left\"> 8GB or 16GB LPDDR4X </td> </tr> <tr> <td class \"org left\">Storage</td> <td class \"org left\"> 32GB or 128GB eMMC, NGFF 2242 SATA SSD </td> </tr> <tr> <td class \"org left\">Display</td> <td class \"org left\"> 7 inch 1280 x 800 LCD, miniHDMI </td> </tr> <tr> <td class \"org left\">Inoput</td> <td class \"org left\"> Capacitive Touch, RedPoint, 72 Keyboard </td> </tr> <tr> <td class \"org left\">Camera</td> <td class \"org left\"> 2MP Front Camera </td> </tr> <tr> <td class \"org left\">Audio</td> <td class \"org left\"> 3.5mm Headphone, MEMS MIC, StereoSpeaker </td> </tr> <tr> <td class \"org left\">Network</td> <td class \"org left\"> WiFi6 + BT5.4, RJ45 GbE </td> </tr> <tr> <td class \"org left\">Interface</td> <td class \"org left\"> USB3.0 Type A, USB3.0 Type C, USB2.0 Type A, MicroSD Slot </td> </tr> <tr> <td class \"org left\"> Battery </td> <td class \"org left\"> 3000 mAh@7.6V </td> </tr> <tr> <td class \"org left\">Case</td> <td class \"org left\">Aluminum Alloy Case</td> </tr> <tr> <td class \"org left\">Size & Weight</td> <td class \"org left\">18.5 x 14 x 2 cm, 720g</td> </tr> <tr> <td class \"org left\">System</td> <td class \"org left\">Debian </td> </tr> </table> ## 上手指南 ### 开箱 打开包装盒，上层是LicheeConsole4A主机 ![unbox1](./assets/lcon4a/unbox1.png) 取下上层主机后，下层是12V3A电源适配器，和MiniHDMI线。 ![unbox2](./assets/lcon4a/unbox2.png) 取出主机，认识下主机侧面的接口： ![unbox3](./assets/lcon4a/unbox3.png) （如果你购买的是准系统套餐，则需要先查看后面的“SOM安装指南”安装好LM4A后再进行下面操作。） 打开主机，长按右上角电源键3s开机（看到屏幕背光亮起即可松开） ![unbox4](./assets/lcon4a/unbox4.png) 如果背光一直未亮起，可能是运输过程中电量耗尽，可以尝试插上电源适配器后长按电源开机。 开机背光亮起约10s后，屏幕会显示Linux企鹅图标和开机启动日志（早期镜像版本在此阶段竖屏显示） 日志打印约20s后，开始进入Debian桌面系统。 进入桌面系统后，你可以测试 屏幕触摸，指点杆，键盘 是否工作，如有发现不能工作的，可以与客服联系。 默认系统为Debian，预装了 Chrome，VSCode，Office，KiCAD，KODI，Parole 等应用软件，你可以一一体验。 你可以使用sudo apt instal xxx 来安装软件，默认用户名密码为 sipeed，licheepi 其它一般性软件使用可以参考LicheePi4A的相关文档章节。 ### SSD安装指南 Console支持M.2 2242 SATA 接口的SSD，可以拆卸掉后壳的SSD盖板后安装 ![ssd1](./assets/lcon4a/ssd1.jpg) ### SOM安装指南 如果你选购了准系统套餐，则需要安装SOM模块。 需要自备六角螺丝刀，拆卸开后盖，安装好SOM模块，在CPU/DDR上方安装硅脂，放置热管，再在热管上放置长条形硅脂片，重新安装回后盖。 详细安装可以参见下面章节的图片。 ## 系统 Console的镜像与LicheePi4A的镜像一同发布，默认为Full镜像，建议使用8+32及以上配置的SOM。如果使用8+8的SOM需要自行裁剪文件系统。 可以到[这里](https://wiki.sipeed.com/hardware/zh/lichee/th1520/lcon4a/3_images.html)下载镜像。 常见应用展示： ![sys1](./assets/lcon4a/sys1.png) Console 系统架构如下，细节可参照原理图或设备树文件。 ![sys2](./assets/lcon4a/sys2.png) ## 功耗相关 ### 供电 Console 整机功耗最大约11W，空载时约7~8W. 可以使用12V DC3.5mm接口供电，或者USB C口5V供电。 ### 续航 为了Console的续航和发热考虑，目前默认镜像的CPU主频上限限制到了1.5GHz。 在该主频下，实测使用时间在2~3小时。（stress ng 压测 2小时，亮屏空载3小时）。 默认屏幕亮度为50%，如果需要延长续航时间，可以降低屏幕亮度： ``` sudo i cd /sys/class/backlight/pwm backlight@0 echo xxx > brightness # xxx is brightness you want, 0~100 ``` 功耗组成（300MHz空载亮屏，50%亮度） ![heat1](./assets/lcon4a/power1.png) ### 散热 Console使用3cm涡轮风扇+10cm热管对CPU进行散热, 热管一端贴CPU，另一端由涡轮风扇散热，并且顶面使用导热硅脂接触底壳散热。 ![heat1](./assets/lcon4a/heat1.png) ![heat1](./assets/lcon4a/heat2.png) 在持续进行高负载工作下（如浏览器视频软解），CPU温度最终可达60～65度，底壳温度最高可达50度左右。 ![heat1](./assets/lcon4a/heat3.png) 如有更好的散热建议，可发送邮件到support@sipeed.com > 目前（2023.11）浏览器硬解尚未适配，所以在观看浏览器视频时会占用大量CPU，预计在12月份会合并入浏览器硬解功能。 ### 待机 Console的硬件电路设计中考虑了待机情况，对每个相关外设都加入了电源控制，但是目前(2023.11)TH1520的低功耗功能还未加入SDK，所以待机功能还需等待更新。 ### 关机 Console目前的关机功耗约为1.3mA，可支撑约3个月关机时间。 ## 资料下载 [Sipeed 下载站](https://dl.sipeed.com/shareURL/LICHEE/LicheeConsole4A) ## 其他链接 [淘宝] (https://item.taobao.com/item.htm?id 754766940927) [Aliexpress](https://www.aliexpress.us/item/3256805987954160.html) QQ群: 559614960 [点我自动加群](http://qm.qq.com/cgi bin/qm/qr?k 5YkapIhdtWHp8AEfM5_bFFYQIX3CUQN6) Telegram: https://t.me/linux4rv 论坛：Maixhub.com/discussion 联系邮箱：support@sipeed.com"},"/hardware/zh/lichee/th1520/lcon4a/setup_guide.html":{"title":"组装指南","content":" title: 组装指南 keywords: Lichee, TH1520, Console, RISCV, update: date: 2023 12 19 version: v1.0 author: sinky content: 新建文档 **购买A套餐用户收到配件如下，请先核对收到的产品配件是否齐全** 后壳x1、SSD盖板x1、SSD盖板螺丝x1、螺丝刀x1、导热垫x2、热管x1、后盖螺丝x6 ![配件](assets/lcon4a/配件.jpg) 图中所示十字批头请自备 # 组装步骤 1. 将核心板插入主板 将其中一片导热垫置于下图所示TH1520核心位置。 ![安装导热垫1](assets/lcon4a/安装导热垫1.jpg) 2. 剥离导热垫离型膜 ![安装导热垫2](assets/lcon4a/安装导热垫2.jpg) 3. 将另一片导热垫从中间剪开备用 4. 将热管放置于核心板和风扇中间**（尽量靠近风扇以保证散热效果）**如下图所示。 ![放置铜管](assets/lcon4a/放置铜管.jpg) 5. 将剪开的两块散热垫放置于热管上，用于将热量导出至外壳，如图所示。![放置铜管散热](assets/lcon4a/放置铜管散热.jpg) 为保证热管固定牢固，建议使用胶带对热管中部进行固定。 7. 插入电池连接排线**（注意电池排线的方向）** <img src \"assets/lcon4a/链接电池排线.png\" alt \"链接电池排线\" style \"zoom:150%;\" /> 7. 将后壳盖回，此处建议先将后方对齐后按压较为方便。 ![组装后盖1](assets/lcon4a/组装后盖1.jpg) ![组装后盖2](assets/lcon4a/组装后盖2.jpg)**扣合另一边时可使用拆机片辅助会更为省力** 8. 将后壳扣回后，取出随机附带的6颗后盖螺丝及配送的螺丝刀，拧紧后壳固定螺丝，拧紧螺丝时建议同时按压后盖以保证卡扣不会弹开。 ![后盖固定螺丝](assets/lcon4a/后盖固定螺丝.jpg) **此处应注意固定SSD盖板的螺丝与后壳固定螺丝为不同尺寸** 至此组装完成，开机使用即可 # SSD安装 1.使用十字螺丝刀取下SSD盖板 ![取下SSD盖板螺丝](assets/lcon4a/取下SSD盖板螺丝.jpg) 2.准备NGFF接口的2242尺寸SSD ![ssd](assets/lcon4a/ssd.png) 3.旋下SSD固定螺丝 ![取下ssd固定](assets/lcon4a/取下ssd固定.jpg) 4.将SSD插入，**此处由于空间较小，建议先将SSD放入机身，垂直于接口用力将SSD插入** ![放入ssd](assets/lcon4a/放入ssd.jpg) ![插入ssd](assets/lcon4a/插入ssd.jpg) 5.插入到位后，旋上SSD固定螺丝，盖上SSD盖板，旋上盖板固定螺丝即可 ![固定ssd](assets/lcon4a/固定ssd.jpg) ![装回ssd盖板](assets/lcon4a/装回ssd盖板.JPG) ![固定SSD盖板](assets/lcon4a/固定SSD盖板.jpg)"},"/hardware/zh/lichee/th1520/lcon4a/4_burn_image.html":{"title":"烧录镜像","content":" title: 烧录镜像 keywords: Linux, Lichee, TH1520, Console, RISCV, image update: date: 2023 12 08 version: v1.0 author: ztd content: Release docs ## 镜像下载: https://github.com/0x754C/sipeed th1520 laptop extra/releases ## 全量镜像 ### 通过 typeC 口烧录 1. 拆掉SSD后盖 2. 找到BOOT按键和RST按键 ![boot_and_rst_key](./assets/burn_image/boot_and_rst_key.png) 3. 按着BOOT按键，然后按键盘上的电源按键开机，然后将 console 连接 typec 口到烧录镜像的 PC。 ![typec_connect](./assets/burn_image/typec_connect.png) 4. 在烧录镜像的 PC 上下载用于烧录的镜像: [点我下载](https://wiki.sipeed.com/hardware/zh/lichee/th1520/lcon4a/3_images.html) 5. 执行烧录指令: ``` fastboot flash ram u boot with spl console.bin fastboot reboot fastboot flash uboot u boot with spl console.bin fastboot flash boot boot.ext4 fastboot flash root root.ext4 ``` 10. 按下 BOOT 旁边的 RST 按键重启 Console 笔记本。 ### 通过 u boot 进行网络烧录 1. console 连接网线（注意和用于烧录镜像的 PC 处于同一局域网中） 2. 用串口工具连接 console 上的串口，上电，进入到 uboot 命令行中 3. console 执行 dhcp 命令分配一个 ip 地址 4. console 执行 fastboot udp 开启监听 5. 烧录镜像的 PC 机上运行如下命令 ```shell ./fastboot s udp:board_ip flash uboot uboot xxxx.bin ./fastboot s udp:board_ip flash boot boot xxxx.ext4 ./fastboot s udp:board_ip flash root root xxxx.ext4 ``` 效果如下： ![fastboot_udp](./assets/burn_image/fastboot_udp.png)"},"/hardware/zh/lichee/th1520/lcon4a/6_peripheral.html":{"title":"外设使用","content":" title: 外设使用 keywords: Linux, Lichee, TH1520, Console, RISCV, Peripheral update: date: 2023 12 14 version: v1.0 author: ztd content: Release docs ## SSD SSD 电源默认关闭，可以使用以下命令打开，即可看到 SSD 硬盘。 ```shell sh /opt/ssd power cycle.sh ``` ## 屏幕&触摸 若遇到屏幕旋转方向不对，或者触摸位置不准，可以运行以下脚本： ```shell sh /opt/touch setup.sh ```"},"/hardware/zh/lichee/RV/flash.html":{"title":"Lichee RV 烧录系统","content":"# Lichee RV 烧录系统 系统镜像分为 Tina与Debian两种，Tina为专用小linux镜像，Debian为桌面级镜像 ## 准备 1. Lichee RV 核心板 2. TF 内存卡（建议使用[官方店](https://shop365481095.taobao.com/)的的内存卡，其他的卡可能会有各种奇怪的问题） 3. 烧录工具 [PhoenixCard](https://dl.sipeed.com/shareURL/LICHEE/D1/Lichee_RV/tool) 4. 系统镜像下载 国内用户：[百度网盘](https://pan.baidu.com/s/1QJTaDw6kkTM4c_GAlmG0hg) 提取码：wbef 国外用户：[Mega](https://mega.nz/folder/lx4CyZBA#PiFhY7oSVQ3gp2ZZ_AnwYA) 镜像词缀说明 含义 备注 LicheeRV Sipeed 专用的 RISCV D1 Linux 系列系统。 Tina 标记为 tina openwrt 系统。 debian 标记为 riscv debian 系统。 86panel [taobao 86panel](https://item.taobao.com/item.htm?spm a230r.1.14.18.30b534187YMsRx&id 663345415205&ns 1&abbucket 7#detail) dock [taobao dock](https://item.taobao.com/item.htm?spm a1z10.3 c s.w4002 21410578028.20.35765d54K9XCOt&id 666274331852) hdmi 表示屏幕默认输出到 HDMI 屏幕上。 800480 / 480P 表示屏幕默认输出到 LCD 屏幕上，分辨率可以是 800*480 或 480P (640X480)。 8723ds 表示该镜像支持 8723ds WIFI / BLE 驱动。 xr829 表示该镜像支持 xr829 WIFI / BLE 驱动。 waft 是否内置 waft 软件。 ## 烧录镜像 ### 烧录步骤 烧录前最好使用[SD card Formatter](https://www.sdcard.org/downloads/formatter/eula_windows/SDCardFormatterv5_WinEN.zip)先把内存卡格式化一次，格式化的时候注意不要选择错了镜像。 打开烧录软件 [PhoenixCard](https://dl.sipeed.com/shareURL/LICHEE/D1/Lichee_RV/tool)，选择烧录的固件，将内存卡通过读卡器插入电脑中 选择 `启动卡` 选项 选择正确的盘符 点击 `烧卡` 根据状态栏的颜色可以判断烧录结果：红色的话说明烧录失败了，建议使用[SD card Formatter](https://www.sdcard.org/downloads/formatter/eula_windows/SDCardFormatterv5_WinEN.zip)格式化后再重新烧录一次；绿色则表示一切正常。 ![](./../assets/RV/flash.png) 要注意 Windows 默认打不开 linux 的文件系统，所以对于烧录过 linux 镜像的 sd 卡在 Windows 上会不能直接被打开，且被提示需要格式化之类的。 这时可以使用[SD card Formatter](https://www.sdcard.org/downloads/formatter/eula_windows/SDCardFormatterv5_WinEN.zip)来格式化 sd 卡来恢复到 Windows 系统可用的状态。 对于嵌入式 linux，建议持有两张以上的 sd 卡。 > 并不能保证每台电脑和每个人的内存卡都是可以烧录的，烧录失败的话建议购买官方的镜像卡。 等待烧录结束；烧录 Tina 系统镜像会比较快，烧录 Debian 系统镜像将会久一点，可能多用10分钟。 ### 烧录失败相关 如果在烧录时提示格式化失败，或者使用烧录过的卡但是电脑上没有显示盘符，可以按以下操作来解决： 1. 在此下载磁盘处理软件： https://www.diskgenius.cn/ 2. 电脑上显示不出的盘符，会在该软件里显示出来，使用该软件进行快速分区： ![attachmentId 2788](./../assets/RV/Diskgenius.png) 3. 分区完成后，电脑上就能够看到盘符，PhoenixCard 里也能看到，在 PhoenixCard 里点击恢复卡即可恢复卡到正常状态 4. 按之前步骤继续烧录即可 ## 启动 启动后若提示需要用户名和密码的话的分别如下： Tina 系统登录用户名：`root` 密码：`tina` Debian 系统登录用户名：`root` 密码：`licheepi` 插卡启动，可以在串口工具中查看到启动信息: debian 启动的打印信息 <details> <summary><font color \"#4F84FF\">点开查看部分debian启动日志</font></summary> <pre><code class \"language shell\"> [270]HELLO! BOOT0 is starting! [273]BOOT0 commit : 27369ab OpenSBI v0.6 ____ _____ ____ _____ / __ \\ / ____ _ \\_ _ _ __ ___ _ __ (___ _) '_ \\ / _ \\ '_ \\ \\___ \\ _ < __ _) __/ ____) _) _ \\____/ .__/ \\____ ______/____/_____ _ </code></pre> </details> Tina 启动的打印信息 <details> <summary><font color \"#4F84FF\">点开查看Tina启动日志</font></summary> <pre><code class \"language shell\"> BusyBox v1.27.2 () built in shell (ash) __ ___ _ __ _ / / /__ _(_)_ __ / / (_)__ __ ____ __ / /_/ / _ `/ /\\ \\ / / /__/ / _ \\/ // /\\ \\ / /_/ /_/\\_,_/_//_\\_\\ /____/_/_//_/\\_,_//_\\_\\ Maix Linux (Neptune, 5C1C9C53) root@MaixLinux:/# </code></pre> </details> ## 相关问题 [点我跳转](./problems.html)"},"/hardware/zh/lichee/RV/RV.html":{"title":"Lichee RV - Nezha CM","content":"# Lichee RV Nezha CM ## 概述 Lichee RV Nezha CM是模块化设计的核心计算模组，搭载全志D1主控芯片(基于平头哥玄铁C906处理器），512MB DDR3内存，可选启动介质为TF卡或者SDNAND芯片，并使用两组M.2B KEY 67 Pin金手指引出所有l0，方便量产使用，也方便安装替换。 ![](./../assets/RV/D1 4.jpg) ![](./../assets/RV/D1 back.jpg) ## 参数 项目 参数 CPU 全志 D1 阿里平头哥 玄铁 C906 内核，主频 1GHz 内存 16bit 512MB DDR3，时钟频率 792MHz 存储 板载 TF 卡连接器，可插入 TF 卡作为存储，已测试能够识别1TB容量的卡； <br>预留 SD NAND 焊盘（与 8pin LCD 接口冲突，用于商业应用定制） 显示接口 MIPI：引出 4 lane MIPI DSI 至金手指 <br>RGB：引出 RGB888（部分与 DSI 复用） 至金手指 <br>MCU(I80)：引出 I80 接口至金手指 <br>SPI：板载 8pin SPI 液晶屏接口，可扩展 1.14 英寸液晶屏 音频接口 模拟音频耳机输出(HPOUT)： 引出至金手指 <br>模拟音频线路输入(LINEIN)： 引出至金手指 <br>数字音频 (I2S/SPDIF)： 引出至金手指 <br>模拟麦克风接口(MIC3)： 引出至金手指 <br>数字麦克风接口(DMIC)： 引出至金手指 以太网 引出 RMII/RGMII 接口至金手指（与部分 GPIO 复用） USB 板载 TYPE C USB OTG 接口(USB0) <br>USB HOST 引出至金手指(USB1) GPIO 剩余 GPIO 全部引出至金手指 按键 • FEL 按键（进入下载模式） 指示灯 • 一个电源指示灯 <br>• 一个用户指示灯（高电平有效） PCB 板层 4 层 固定方式 通过两组 M.2 B KEY 金手指连接器与底板连接，使用一颗 M2 螺丝紧固 支持开发语言 C/C++, Python, Golang, etc... 系统镜像 Tina Linux(基于OpenWRT 14.07)、 Debian、YoC (RTOS ) ![](./../assets/RV/D1 pin.png) ## 底板之间的对比 项目 Lichee RV Dock Lichee RV Panel : : SOC 全志D1（XuanTie C906 RISC V） 全志D1（XuanTie C906 RISC V） 内存 1GByte 1GByte 无线网络 可选择：<br> 2.4G WIFI+BT<br> 无（可以自行焊接其他型号的WIFI模块调试）\t 2.4G WIFI+BT 有线网络 无\t 支持100M以太网 影像输出 HDMI连接器 <br>SPI接口屏幕连接器 <br>连接屏幕转接板，可以实现：<br> 常用RGB接口屏幕连接器（含TP引脚）（支持我们店铺的4.3寸/5.0寸屏）<br> MIPI接口屏幕连接器（兼容Nezha开发板适配的8寸屏） sRGB接口屏幕连接器（含TP引脚）（支持标配的4寸IPS屏带TP） <br>MIPI接口屏幕连接器（兼容Nezha开发板适配的8寸屏） USB端口 \"1个USB OTG(核心板板载的USB C座子) <br> 1个USB Host(底板板载的USB A座子) 1个USB OTG(核心板板载的USB C座子) <br>1个USB Host(底板板载的USB C座子) 拓展接口 支持麦克风阵列板<br>大部分GPIO通过2x20P直插焊盘引出 小部分GPIO通过直插焊盘引出 音频 板载3W音频功放 <br>板载驻极体麦克风电路 板载3W音频功放 <br>板载2个MEMS数字麦克风 按键\t 1个FEL按键（进入下载模式）<br>1个RST按键（复位）<br>1个用户按键 1个FEL按键（进入下载模式） LED 1个电源指示灯<br>1个2812 RGB LED 1个电源指示灯 外壳 无 有3D打印外壳 尺寸 65.0mm x 40.0mm 86.0mm x 86.0mm ## 连接1.14寸屏幕 ![](./../assets/RV/D1 1.png)![](./../assets/RV/D1 2.png)![](./../assets/RV/D1 3.png) > 目前 1.14 显示屏是点不亮的，需要等待后续的更新; ## 系统烧录 [烧录教程](./flash.html) ## 注意事项 当前核心板的USB Type C连接器使用CC引脚作为自动OTG的识别引脚，但是与USB C to C 数据线的识别存在冲突，只能使用A to C数据线，可在硬件上改动器件进行切换，共有两种工作方式，具体特性对应如下： Type C工作模式 OTG（出厂默认产品） CC识别（需要改动硬件） : : : : 电阻R30与电阻R31 不贴 贴装5.1K 1% 0402电阻 二极管D3与D4 贴装4148二极管 不贴 是否兼容C to C数据线 否 是 是否兼容A to C 数据线 是 是 是否支持自动OTG切换 是 否 如需使用C to C数据线，则需要改动TypeC接口周围的器件对应CC识别模式，并在需要扩展外置USB设备时手动切换为HOST模式。核心板正面位号图如下，供参考： > ① 换上5.1K 1% 0402电阻，② 拆除二极管 ![](./../assets/RV/other.png) ![](./../assets/RV/D1Core2.png) ## 资料下载 [硬件资料下载](https://dl.sipeed.com/shareURL/LICHEE/D1/Lichee_RV/HDK) Debian 系统镜像请到 >[百度网盘](https://pan.baidu.com/s/1QJTaDw6kkTM4c_GAlmG0hg)(提取码：`wbef`) >[Mega netdisk](https://mega.nz/folder/lx4CyZBA#PiFhY7oSVQ3gp2ZZ_AnwYA) [源码获取](/hardware/zh/lichee/RV/user.html#BSP SDK 开发指南) ## 相关问题 [licheeRV debian镜像相关问题](https://wiki.sipeed.com/hardware/zh/lichee/RV/problems.html#apt %E7%9B%B8%E5%85%B3)"},"/hardware/zh/lichee/RV/86_panel.html":{"title":"Lichee 86 Panel","content":"# Lichee 86 Panel ## 概述 Lichee RV 86 Panel是为智能家居中控应用场景而设计的开发套件。在硬件上，套件包含了LicheeRV 核心板（全志D1+512MB DDR3)、4英寸 IPS 显示屏+电容触摸屏、WIFI + BT、以太网、双数字硅麦和 GPIO 拓展接口等。 在软件上，我们提供了 Linux 系统（OpenWRT 及 Debian )和阿里 WAFT 开发环境( WAFT 是阿里基于 WebAssembly 和自研的渲染引擎打造的一款面向 AIOT 的高性能应用框架)。 ![裸板视图](./../assets/RV/86_2.png) ## 参数 项目 参数 核心模块 Sipeed LicheeRV 哪吒计算条 显示 默认搭配为4英寸480\\*480 IPS标清电容触摸屏<br>可选升级为4英寸720\\*720 IPS高清电容触摸屏<br>预留8英寸1280\\*800 IPS电容触摸屏接口 音频 板载1W小扬声器，双路数字硅麦 网络 XR829 WIFI+BT无线模块<br>RTL8201F百兆以太网<br>预留板载RJ45以太网接口 USB 核心板带有USB C OTG接口 <br>底板预留USB C HOST 与USB转串口电路 电源 支持5V,12V供电(板载DC DC ) 扩展引脚 双2x8Pin 2.54mm 排针，预留FPCIO引出 外壳 选配86盒3D打印外壳，图纸开源 尺寸 86x86mm 适用场景 智能家居中控，WAFT UI评估 开发框架 支持WAFT (WebAssembly Framework For Things）环境 系统支持 支持 OpenWRT及 Debian系统 开发资源 提供原厂SDK的 Docker开发镜像 ![板子功能](./../assets/RV/86_pin.png) ## 相关链接 [下载站](https://dl.sipeed.com/shareURL/LICHEE/D1/Lichee_RV_86_panel) [烧录系统](./flash.html) [相关使用](./user.html) ## 产品技术支持 Lichee RV 86 Panel 可以在多种场景实现客户不同方面的需要，品质和性能在行业内已经有非常好的口碑，专业的技术团队为广大客户解决硬件设计和软件功能上的各种各样问题。专业技术支持和更详细资料请联系商务 <support@sipeed.com>。"},"/hardware/zh/lichee/RV/ubuntu.html":{"title":"LicheeRV ubuntu","content":" title: LicheeRV ubuntu keywords: ubuntu, riscv, lichee update: date: 2022 12 01 version: v0.1 author: wonder content: 初次编辑 Ubuntu 提供了可以在 LicheeRV 上面运行的镜像，它的烧录方法与并不是使用 PhoenixCard，因此这边专门说明一下使用方法。 有显示器的话可以接键盘来使用命令行操作该系统，没有的话只能通过串口来操作板子。 ## Ubuntu 介绍 Ubuntu 是基于另一个 Linux 发行版 Debian 发展而来，网上大多数 linux 相关的教程也是基于 ubuntu 的，这点对于新手很友好，遇到问题的时候可以比较快地找到解决办法。 因为 D1 的性能有限，所以只提供命令行版本，需要的话自行安装、适配桌面也是能有 GUI 的。 <img src \"./../assets/RV/ubuntu/d1_ubuntu_desktop.jpg\" alt \"d1_ubuntu_desktop\" width \"45%\"> <img src \"./../assets/RV/ubuntu/d1_ubuntu_desktop_picture.jpg\" alt \"d1_ubuntu_desktop_picture\" width \"45%\"> 上图为 D1 Dock Pro 板卡，与普通的 Dock 底板是不同的，底板上自带了串口，可以仅使用一根数据线来进行板卡与电脑的串口通信。相关外设可以看下图的标注。 <img src \"./../assets/RV/ubuntu/dock_pro_top_block.jpg\" alt \"dock_pro_top_block\" width \"45%\"> <img src \"./../assets/RV/ubuntu/dock_pro_bottom_block.jpg\" alt \"dock_pro_bottom_block\" width \"45%\"> 可以在官方淘宝店咨询卖家购得该板卡。 ## 操作步骤 ### 获取镜像 提供了百度网盘下载方式。 百度网盘: https://pan.baidu.com/s/1n Y1EoOCdfV4QzaHXY61Wg ### 烧录软件 前往 [balenaEtcher](https://www.balena.io/etcher/) 官网下载软件或者[下载站](https://dl.sipeed.com/shareURL/others/balenaEtcher)下载，其中下载站仅提供 Windows 版本软件，其他系统想用这个软件自行前往 [balenaEtcher](https://www.balena.io/etcher/) 官网下载。 ### 烧录系统 准备一张容量 8G 以上的内存卡，读写速度快一些的卡能带来更好的体验。 将 TF 卡与电脑连接起来，使用读卡器或者其他方式都可以。下图的电脑上的 TF 卡槽仅做示例，电脑上没有 TF 卡读取插槽的话依然是需要准备读卡器的。 <table> <tr> <th colspan \"2\"> 将 TF 卡与电脑连接 </th> </th> </tr> <tr> <td>使用读卡器来连接 TF 卡和电脑</td> <td>直接使用电脑上的 TF 卡插槽来连接</td> </tr> <tr> <td><img src \"./../assets/RV/ubuntu/d1_ubuntu_sdcard_reader.jpg\" alt \"d1_ubuntu_sdcard_reader\" ></td> <td><img src \"./../assets/RV/ubuntu/d1_ubuntu_sdcard_computer_reader.jpg\" alt \"d1_ubuntu_sdcard_computer_reader\" ></td> </tr> </table> 打开 balenaEtcher，选择所下载的镜像文件，选择 TF 卡，点击烧录： ![d1_ubuntu_burn_image](./../assets/RV/ubuntu/d1_ubuntu_burn_image.gif) 要注意的是烧录的时候别选错了 TF 卡。 ![d1_ubuntu_burn_image_sdcard_choose](./../assets/RV/ubuntu/d1_ubuntu_burn_image_sdcard_choose.png) 烧录时间有点久，烧录结束后会出现下图的提示。如果不是 Successful 的话就需要重新烧录。 ![d1_ubuntu_finish_burn_image](./../assets/RV/ubuntu/d1_ubuntu_finish_burn_image.png) ## 启动系统 烧录完系统且看到 Successful 字样后，可以将 TF 卡插到板子上启动了。 ![dock_pro_ubuntu](./../assets/RV/ubuntu/dock_pro_ubuntu.jpg) 使用串口可以查看启动信息，并且操作板卡。 <img src \"./../assets/RV/ubuntu/d1_ubuntu_boot_opensbi.jpg\" alt \"d1_ubuntu_boot_opensbi\" width \"45%\"> <img src \"./../assets/RV/ubuntu/ubuntu_boot.jpg\" alt \"ubuntu_boot\" width \"45%\"> 等待启动一段时间后，使用 `root` 作为用户名和密码就可以登录进板卡了， ![d1_ubuntu_login](./../assets/RV/ubuntu/d1_ubuntu_login.jpg) ## 连接 wifi 然后使用 `nmcli` 命令来连接 2.4G 无线网络。 查看周围的 wifi ```bash nmcli dev wifi ``` ![d1_ubuntu_wifi_scan](./../assets/RV/ubuntu/d1_ubuntu_wifi_scan.jpg) 使用命令行来连接 wifi，语法为 `nmcli dev wifi connect (网络名称） password (密码）` ```bash nmcli dev wifi connect Sipeed_Guest password 12345678 ``` ![d1_ubuntu_wifi_connect](./../assets/RV/ubuntu/d1_ubuntu_wifi_connect.jpg) 出现 successfully 就表示连接上了，后面可以正常使用 `apt` 等软件了 ![d1_ubuntu_install_tree](./../assets/RV/ubuntu/d1_ubuntu_install_tree.jpg) ## 点灯 在这个 ubuntu 系统上，我们可以向之前使用 tina 系统时一样，控制核心板上的 led 灯。相关代码和结果如下所示： 点亮板卡上的 LED : ```bash echo 1 > /sys/class/leds/\\:status/brightness ``` 上面的命令中的 `:` 使用了 \"\\\" 进行转义，不然会报错。 ![d1_ubuntu_led_on](./../assets/RV/ubuntu/d1_ubuntu_led_on.jpg) 熄灭板卡上的 LED : ```bash echo 0 > /sys/class/leds/\\:status/brightness ``` ![d1_ubuntu_led_off](./../assets/RV/ubuntu/d1_ubuntu_led_off.jpg) ## 结语 在 Ubuntu 官方所提供的镜像上[点我跳转](https://wiki.ubuntu.com/RISC V/LicheeRV)，我们这边补上了 wifi 驱动免去了自行编译的麻烦。 ## 常见问题 ### 没有 HDMI 输出 板卡使用 ubuntu 镜像在启动时不会直接输出 HDMI， 而是会在相关的服务启动后 HDMI 屏幕在会有输出，另外部分 HDMI 屏幕不会兼容并显示出 LicheeRV HDMI 命令行。 下图是分别用串口 (ttyS0) 和 HDMI 显示器终端 (tty1) 登录 LicheeRV ubuntu 的拍照截图 ![d1_ubuntu_console_hdmi](./../assets/RV/ubuntu/d1_ubuntu_console_hdmi.jpg)"},"/hardware/zh/lichee/RV/user.html":{"title":"基础上手","content":"# 基础上手 ## Dock 相关使用 ### 连接板子 我们可以很容易看到底板背部上有串口的 TX 和 RX 引脚标识。因此可以使用 ttl 电平的串口来使板子与电脑进行通信（Tina和Debian均适用）。 对于 Tina 系统可以使用核心板上的 typec 接口和电脑上的 adb 终端来进行连接 对于 Debian 系统可以外接键盘和鼠标来直接操作 #### Debian 相关事项 启动会比较慢，取决于TF卡的速度。 用户名为 `root` 密码是 `licheepi` **使用串口与 debian 系统连接的话会一直打印内核信息。解决方法是：** 使用root权限编辑 `/etc/rsyslog.conf` 并且把文件最后一行中的 `*.emerg` 改成 `#*.emerg` 重启 rsyslog 服务，直接执行 `/etc/init.d/rsyslog restart` 即可 **想要在图形化界面中调出命令行的方法：** 键盘执行 `Alt+F2` 打开运行，接着在里面输入 `termit` 即可打开命令行终端。 ### 点灯示例 当我们成功进入系统(Tina和debian均可)后，就可以进行基础的点灯操作啦！ 核心板的螺丝固定焊盘旁有一颗 LED ，查看尺寸图很容易看到： <details> <summary><font color \"#4F84FF\">点开查看尺寸图</font></summary> <img src \"./../assets/RV/rv_coreboard_dimension.png\"> </details> 从[原理图](https://dl.sipeed.com/shareURL/LICHEE/D1/Lichee_RV/HDK/2_Schematic)可以查到 LED 连接的是 PC0 引脚，根据简单的公式 ('C' 'A')x32 + 0 2x32+0 64 当然我们也可以查看 pinmux pins 文件中的内容来知道 IO 复用情况表： ```bash cat /sys/kernel/debug/pinctrl/2000000.pinctrl/pinmux pins ... pin 64 (PC0): device 2008000.ledc function ledc group PC0 #这里可以看到是LED引脚 pin 65 (PC1): UNCLAIMED pin 66 (PC2): UNCLAIMED pin 67 (PC3): UNCLAIMED pin 68 (PC4): UNCLAIMED pin 69 (PC5): UNCLAIMED pin 70 (PC6): UNCLAIMED pin 71 (PC7): UNCLAIMED ... ``` 我们先导出该 GPIO： ```bash echo 64 > /sys/class/gpio/export #导出GPIO64 ``` 然后再将该 IO 置为输出状态，即可操作其电平： ```bash echo out>/sys/class/gpio/gpio64/direction #设置IO为输出 echo 1 > /sys/class/gpio/gpio64/value #输出高电平 echo 0 > /sys/class/gpio/gpio64/value #输出低电平 ``` 上面的是最简单的使用 IO 的操作了，就不细说了吧。 不使用IO的话就取消导出 ```bash echo 64 > /sys/class/gpio/unexport #取消导出GPIO64 ``` 至此我们就成功在 RISC V 64 D1上点灯啦~ 你也可以对 串行RGB LED WS2812 进行花式点灯： ```bash echo 255 > /sys/class/leds/sunxi_led0r/brightness #红灯亮 echo 0 > /sys/class/leds/sunxi_led0r/brightness #红灯灭 echo 255 > /sys/class/leds/sunxi_led0g/brightness #绿灯亮 echo 0 > /sys/class/leds/sunxi_led0g/brightness #绿灯灭 echo 255 > /sys/class/leds/sunxi_led0b/brightness #蓝灯亮 echo 0 > /sys/class/leds/sunxi_led0b/brightness #蓝灯灭 ``` ### 外设功能验证 #### 音频功能 录音设备查看 使用 `arecord l` 命令 ```bash root@MaixLinux:~# arecord l **** List of CAPTURE Hardware Devices **** card 0: audiocodec [audiocodec], device 0: SUNXI CODEC 2030000.codec 0 [] Subdevices: 1/1 Subdevice 0: subdevice 0 card 1: snddmic [snddmic], device 0: 2031000.dmic dmic hifi dmic hifi 0 [] Subdevices: 1/1 Subdevice 0: subdevice 0 card 2: sndhdmi [sndhdmi], device 0: 2034000.daudio audiohdmi dai 20340a4.hdmiaudio 0 [] Subdevices: 1/1 Subdevice 0: subdevice 0 ``` 播放设备查看 使用 `aplay l` 命令 ```bash root@MaixLinux:~# aplay l **** List of PLAYBACK Hardware Devices **** card 0: audiocodec [audiocodec], device 0: SUNXI CODEC 2030000.codec 0 [] Subdevices: 1/1 Subdevice 0: subdevice 0 card 2: sndhdmi [sndhdmi], device 0: 2034000.daudio audiohdmi dai 20340a4.hdmiaudio 0 [] Subdevices: 1/1 Subdevice 0: subdevice 0 ``` 录音播放测试： ```bash arecord D hw:1,0 f S16_LE t wav d 3 t.wav #录音 ``` ```bash aplay D hw:0,0 t.wav #播放录音 ``` 另外可以使用 alsamixer 进行音量调整 <details> <summary><font color \"#4F84FF\">点开查看运行alsamixer</font></summary> <pre><code class \"language shell\">┌────────────────────────────── AlsaMixer v1.2.4 ──────────────────────────────┐ │ Card: audiocodec F1: Help │ │ Chip: F2: System information │ │ View: F3:[Playback] F4: Capture F5: All F6: Select sound card │ │ Item: Headphone [dB gain: 24.00] Esc: Exit │ │ │ │ ┌──┐ ┌──┐ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ → │ │ │ │ │ → │ │ │ │▒▒│ → │ │ │ │▒▒│ → │ │ │ │▒▒│ → │ │ │ │▒▒│ → │ │▒▒│ │▒▒│ → │ │▒▒│ │▒▒│ │ │ │▒▒│ │▒▒│ │ │ ├──┤ ┌──┐ ┌──┐ Off ┌──┐ ┌──┐ ┌──┐ └──┘ │ │ │MM│ │MM│ │MM│ │MM│ │MM│ │MM│ │ │ └──┘ └──┘ └──┘ └──┘ └──┘ └──┘ │ │ 25 63 │ │ &lt;Headphon>FMINL ga FMINR ga ADC1 ADC ADC1 Inp ADC1 Inp ADC1 Inp ADC1 vol │ └──────────────────────────────────────────────────────────────────────────────┘</code></pre> </details> #### USB功能 默认内核支持外挂U盘的驱动，插上U盘后可以使用 `fdisk l` 指令查看到新增的 /dev/sda 设备 <br> 如果U盘没有被格式化，应该使用mkfs.vfat指令来格式化U盘，再使用mount指令挂载U盘。 #### 无线网络 ##### **使用 Tina 系统** LicheeRV 底板默认使用 XR829 或者 RTL8723BS wifi 模块，可以使用以下指令进行联网操作 先配置热点信息：需要手动在 /etc/wifi 目录下的 wpa_supplicant.conf 文件里添加下面内容 ```bash network { ssid \"WiFi_name\" psk \"WiFi_password\" } ``` 配置完成后重启一下(执行 `reboot` 命令即可)，重启完成后执行 `ifconfig wlan0 up; udhcpc iwlan0 &` 后即可连上对应的wifi。 连上网络后，就可以使用 ssh (自己记得设置一下密码)来远程登录板卡，或者使用 scp 来进行文件传输。 ##### **使用 debian 系统** > Debian 不支持命令行联网 点击系统菜单 Preferenes Connman Settings，打开 Network Settings ，查看网络属性中的 Interface 是否为 wlan0。双击网络名称，并输入 WiFi 密码进行连接 ![](./../assets/RV/wifi 1.jpg) 成功连接网络之后，通过系统系统菜单 Preferenes Connman Settings，查看网络属性查看网络的 IP 地址 ![](./../assets/RV/wifi 2.jpg) #### 屏显触摸 LicheeRV系列可以使用以下显示屏： SPI屏\t\t1.14寸屏(TODO) RGB屏\t\t4.3寸 480x272；5.0寸 800x480； RGB+SPI屏\t4.0寸 480x480(st7701s); 4.0寸 720x720(nv3052c) MIPI屏\t\t8.0寸 1280x720(ILI9881C) 如果需要调试屏幕驱动，可以使用以下指令查看屏幕驱动信息： 以下信息根据烧录镜像的不同而打印的不一样。 ```bash cat /sys/class/disp/disp/attr/sys screen 0: de_rate 300000000 hz, ref_fps:60 mgr0: 480x480 fmt[rgb] cs[0x204] range[full] eotf[0x4] bits[8bits] err[0] force_sync[0] unblank direct_show[false] iommu[1] dmabuf: cache[0] cache max[0] umap skip[0] overflow[0] \tlcd output\tbacklight( 50)\tfps:59.5\tesd level(0)\tfreq(60)\tpos(0)\treset(0)\t 480x 480 \terr:0\tskip:184\tirq:230715\tvsync:0\tvsync_skip:0 BUF enable ch[1] lyr[0] z[16] prem[N] a[globl 255] fmt[ 0] fb[ 480, 480; 480, 480; 480, 480] crop[ 0, 0, 480, 480] frame[ 0, 0, 480, 480] addr[ffe00000, 0, 0] flags[0x 0] trd[0,0] ``` 屏幕彩条测试：`echo 1 > /sys/class/disp/disp/attr/colorbar` #### 视频播放 我们可以尝试在LicheeRV上播放BadApple啦~ [视频文件下载](https://dl.sipeed.com/shareURL/LICHEE/D1/Lichee_RV/MP4) Tina镜像中内置了ffmpeg软件包；ffmpeg是强大的多媒体库，可以用于录屏或者播放 录屏指令： ```bash ffmpeg f fbdev framerate 10 i /dev/fb0 record.avi ``` 播放指令（分别是扬声器播放音频和hdmi播放音频）： ```bash ffmpeg i /mnt/UDISK/badapple_640480_xvid.mp4 pix_fmt bgra f fbdev /dev/fb0 f alsa hw:0,0 ffmpeg i /mnt/UDISK/badapple_640480_xvid.mp4 pix_fmt bgra f fbdev /dev/fb0 f alsa hw:2,0 ``` 这里由于是CPU软解，所以测试最高分辨率约为720x540， 再高会变卡 <iframe src \"https://player.bilibili.com/player.html?aid 209723771&bvid BV1xa411r7PP&cid 457742249&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\"> </iframe> #### 麦克风阵列(仅debian系统) 将板子与麦克风阵列连接好后（需要注意不要将排线接反和不要把引脚接反。），直接执行内置的 `micarr_0609` 指令即可即 ```bash sudo ./micarr_0609 ``` 有麦克风阵列相关的二次开发需求，可以联系 support@sipeed.com ![](./../assets/RV/mic_array_picture.jpg) <iframe src \"https://player.bilibili.com/player.html?aid 849734125&bvid BV1HL4y1H7nv&cid 457750392&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\"> </iframe> ## 86Panel 如果烧录后显示不正确或者不对劲的话，前往[相关问题](./problems.html)纠错一下 下面仅进行简单的操作。另外上面 dock 板子的操作同样适用于 86Panel。 对于使用 tina 系统的是没有 GUI 界面的。因此下面使用 debian 简单展示一下屏幕 烧录 debian 系统后，插卡启动，等待2分钟左右，屏幕上就会显示登录界面 ![登录界面](./../assets/RV/LicheeRV_login_picture.png \"登录界面\") 输入用户名 sipeed，密码 licheepi，即可进入桌面 （使用USB HOST口外接键盘鼠标进行输入） ![桌面样式](./../assets/RV/desktop_appearance.png \"桌面样式\") 进入桌面后可以进行一些基础操作 Alt+F2 可以打开 运行 ，接着输入 termit 即可打开命令行终端 ![基础操作](./../assets/RV/Basic_operation.png \"基础操作\") 接下来让我们尝试在Debian下跑一下Hello World: ![运行自制程序](./../assets/RV/Run_HelloWorld.png \"运行自制程序\") 另有720P高清屏的效果对比，有米的朋友可以考虑入手。 注意使用的时候应当烧录一下板级配置文件来成功显示，具体请看[86panel显示异常](problems.html#86 panel 烧录后屏幕无反应显示不对) 实际显示效果如下： ![高清显示_1](./../assets/RV/display_1.png) ![高清显示_2](./../assets/RV/display_2.png) ### 点灯操作 由于 86Panel 的核心板的 LED 与底板外设复用了，因此不能直接使用核心板的灯了。 将直插型 LED 正确地与预留的 IO 焊盘连接好后可以参考 dock 底板点灯的方式来点灯。 ### 连接网络 #### 有线网络 86 Panel 支持百兆网络，使用套餐附送的网线接上板子网口后，执行以下指令来连接有线网络 ```bash ifconfig eth0 up udhcpc ieth0 ``` #### 无线网络 可以参考 Dock 底板连接[网络的方法](#无线网络) ### 其他 与 dock 底板相关操作一致 ### 触摸屏测试 <font color #16B2C>仅 tina 系统内置 触摸demo</font> 如果你购买的是86面板套餐，可以使用 ts_test 进行触摸测试。 > 注意触摸驱动有瑕疵，ts_test测试时松开后，光标会不动，但是终端仍会正常打印信息 ```bash root@MaixLinux:/# ts ts_calibrate ts_harvest ts_print_mt ts_test ts_verify ts_finddev ts_print ts_print_raw ts_test_mt tshowimg ``` ## BSP SDK 开发指南 为了方便用户自行开发，矽速整理发布了 LicheeRV 的bsp开发docker镜像，大家使用该镜像可以快速开始D1的系统级开发。 国内用户：[百度网盘](https://pan.baidu.com/s/1QJTaDw6kkTM4c_GAlmG0hg) 提取码：wbef 国外用户：[Mega](https://mega.nz/folder/lx4CyZBA#PiFhY7oSVQ3gp2ZZ_AnwYA) 在网盘中下载对应的docker文件后，解压到tar文件后导入到docker ```bash gzip d licheerv_d1_compile.tar.gz #解压成tar文件 docker import licheerv_d1_compile.tar licheerv_d1_compile:latest #docker导入镜像 ``` 成功运行后应当重新登陆一次；用户名为 `nihao`，密码为 `sipeed123` ```bash sudo docker run it licheerv_d1_compile:latest /bin/bash # 交互模式启动D1镜像编译环境 login #切换用户 ``` 进入容器后的基础编译操作为： ```bash cd ~/sdk/tina d1 open_new/ source build/envsetup.sh lunch #选1 make menuconfig #去掉里面的 alsa plugin 选项，否则编译不过 # alsa plugins 在 menuconfig 中的位置如下 #. #└── Libraries # └── alsa plugins make j8 #按实际CPU性能编译 pack #打包 ``` SDK内置了一些版型的dts，你可以自行选择编辑： device/config/chips/d1/configs/nezha/board_xxx.dts 其他SDK的开发说明，可以参见全志开发平台上下载的相关文档 https://open.allwinnertech.com/ 也可以加全志交流QQ群：`498263967` 如果需要自己下载SDK开发，参考全志在线相关网页：https://d1.docs.aw ol.com/ ## WAFT 开发指南 TODO"},"/hardware/zh/lichee/RV/problems.html":{"title":"相关问题","content":" title: 相关问题 keywords: debian, Rv, Problam, apt, img, sipeed ## apt 相关 在使用默认debian镜像时，如果进行apt操作，发现以下报错： > GPG error: http://ftp.ports.debian.org/debian ports sid InRelease: The following signatures couldn't be verified because the public key is not available: NO_PUBKEY E852514F5DF312F6 说明内置的密钥到期了，需要手工更新下密钥；下面是两种下载密钥的方式： 网页下载：https://packages.debian.org/sid/all/debian ports archive keyring/download wget方式 `wget http://ftp.cn.debian.org/debian/pool/main/d/debian ports archive keyring/debian ports archive keyring_2022.02.15_all.deb` 将密钥拷贝（使用scp或者lrzsz工具）到LicheeRV板上，执行： > sudo dpkg i debian ports archive keyring_2022.02.15_all.deb 即可更新密钥，然后可以正常进行apt更新：`sudo apt get update` ## 启动无反应 确认自己在使用 PhoenixCard 的时候选择的是 `启动卡` ![](./../assets/RV/flash.png) 对于使用Tina系统的是可以用adb终端来连接进行通信 直接将电脑与核心板相连即可 ![](./../assets/RV/adb shell.png) 对于debian系统只能使用串口来通信 ## 86 panel 烧录后屏幕无反应/显示不对 需要在linux系统中使用下面命令来和对应的fex文件来覆盖板级配置 fex下载地址 https://dl.sipeed.com/shareURL/LICHEE/D1/Lichee_RV/SDK/board 覆盖指令为 ```bash sudo dd if boot_package_XXX.fex of /dev/sdX bs 1K seek 16400 ``` 上面命令中的 sdX 为 TF 卡在 linux 系统中的命名。 有问题的话可以去[论坛](https://bbs.sipeed.com/)发帖"},"/hardware/zh/lichee/RV/Dock.html":{"title":"Lichee Dock","content":"# Lichee Dock ## 概述 Lichee RV Dock 是为开源开发者而设计的一款功能**集成度高**、**体积小**且价格亲民的RISC V Linux开发板套件。它不仅支持 **HDMI 输出**，搭配屏幕转接板更可以支持多种的屏幕显示（**MIPI、RGB和MCU接口**）。它同时具备丰富的外设，包括一个主机 **USB A** 接口，**2.4G Wi Fi+BT** 模块，一个模拟麦克风和扬声器插口等。使用者拿到套件之后，无需等待和焊接，即可用套件连接显示器和 USB 设备快速上手开发各种有趣且实用的 Linux 应用，较大地**加速了**开发者的试研和开发工作。除此之外，用户还可以利用开发板的多种显示接口，无线功能和 GPIO ，搭配板载麦克风和扬声器，快速实现各种创意。 ![外观图](./../assets/RV/RV Dock.jpg) ## 参数 项目 参数 支持的核心板 Lichee RV 核心板 显示输出接口 板载一个显示输出连接器；<br>RGB屏幕信号和MIPI屏幕信号连接到2x20P排针焊盘 <br>（可以使用我们的屏幕转接板驱动RGB接口或者MIPI接口的屏幕） 网络连接 板载2.4G WIFI+BT模组、2.4G 贴片天线、IPEX连接器 USB 板载一个USB type A母座 音频 板载扬声器驱动电路（最高支持4Ω3W扬声器）和扬声器连接器<br>板载驻极体麦克风电路 存储 预留了一个SOP8焊盘，SPI协议，默认不焊接元件 拓展连接器 板载30P FPC连接器，可以直接连接到我们的Mic Array R6 麦克风阵列板 GPIO拓展 通过2x20P 2.54mm 焊盘引出GPIO供用户使用 LED 板载一个WS2812 RGB LED<br>板载一个电源指示灯 按键 板载一个复位RST按键<br>板载一个用户按键 ## 相关链接 [规格书](https://dl.sipeed.com/shareURL/LICHEE/D1/Lichee_RV Dock/1_Datasheet) [原理图](https://dl.sipeed.com/shareURL/LICHEE/D1/Lichee_RV Dock/2_Schematic) [点位图](https://dl.sipeed.com/shareURL/LICHEE/D1/Lichee_RV Dock/3_Bitmap) [尺寸图](https://dl.sipeed.com/shareURL/LICHEE/D1/Lichee_RV Dock/4_Dimensions) [3D 模型文件](https://dl.sipeed.com/shareURL/LICHEE/D1/Lichee_RV Dock/5_3D) [使用教程](./flash.html) ## 产品技术支持 Lichee RV Dock 可以在多种场景实现客户不同方面的需要，品质和性能在行业内已经有非常好的口碑，专业的技术团队为广大客户解决硬件设计和软件功能上的各种各样问题。专业技术支持和更详细资料请联系商务 support@sipeed.com。"},"/hardware/zh/lichee/One/index.html":{"title":"","content":"敬请期待"},"/hardware/zh/index.html":{"title":"Sipeed 开源产品速览","content":" title: Sipeed 开源产品速览 请在左边导航栏中选择您的产品。 或者查看 [首页](/)。"},"/hardware/zh/tang/Tang-primer/Tang-primer-summary.html":{"title":"Tang Primer","content":"# Tang Primer Tang Primer 系列 FPGA 是 Sipeed 使用国产 FPGA 芯片作为主控所设计的大容量板卡。 <table> <thead> <tr> <th>Tang primer 20K</th> <th>Tang primer </th> </tr> </thead> <tr> <td><a href \"./../tang primer 20k/primer 20k.html\"><img src \"./../tang primer 20k/assets/primer_20k.png\" width 320></a></td> <td><a href \"./Tang primer.html\"><img src \"./../../../assets/Tang/permier/Tang_permier.jpg\" width 320></a></td> </tr> </table>"},"/hardware/zh/tang/Tang-primer/Tang-primer.html":{"title":"Tang Primer","content":"# Tang Primer ## 介绍 Lichee Tang Primer是基于安路科技的EG4S20BG256 FPGA芯片设计的简约型开发板。开发板设计小巧精致，将芯片的所有资源都引出，板载Micro USB、USB JTAG、TF卡槽、DVP摄像头接口、RGB(可接LCD屏、VGA等外设)等，并把部分IO资源引出，非常方便开发者拓展使用，开放RISC V IP内核。 ![Tang_permier](./../../../assets/Tang/permier/Tang_permier_1.png) ## 管脚定义 ![Tang_permier_2](./../../../assets/Tang/permier/Tang_permier_2.png) ![Tang_permier_3](./../../../assets/Tang/permier/Tang_permier_3.png) ## 参数 项目 参数 FPGA芯片 EG4S20BG256 逻辑单元数量 23520 寄存器数量(FF) 19600 Total Configuration SRAM (bits) 4,988,928 EM SDR SDRAM 2M X 32bits 锁相环PLL 1 I/O Bank总数 1 最多用户I/O数 193 核电压 1.2V 板载FPC40P座 可接RGB LCD、VGA转接口、高速DAC等模块 板载FPC20P座 可接DVP摄像头、高速ADC模块 引出IO 标准2.54mm和半邮票孔接口，引出芯片大部分IO资源 板载IIC电阻触摸芯片屏控制器 NS2009 ## 产品技术支持 Tang Permier开发板可以在多种场景实现客户不同方面的需要，在AIoT上已经广泛的使用，品质和性能在行业内已经有非常好的口碑，专业的技术团队为广大客户解决硬件设计和软件功能上的各种各样问题。专业技术支持和更详细资料请联系商务support@sipeed.com。 ## 资料 [烧录相关使用](/soft/Tang/zh/index_bak.md) [资料下载](https://dl.sipeed.com/shareURL/TANG/Primer)"},"/hardware/zh/tang/Tang-primer/get_started/fpga_download.html":{"title":"FPGA码流烧录","content":"# FPGA码流烧录 <font size 5>**Attention!! 下载码流需要先保证驱动安装成功**</font> 1. 打开TD软件，选择 download ![](https://fdvad021asfd8q.oss cn hangzhou.aliyuncs.com/migrate/E203_TD_download.png) 2. 添加 bitstream文件，选择 [LicheeTangNewIoMap_BitStream.bit](https://fdvad021asfd8q.oss cn hangzhou.aliyuncs.com/LicheeTang/LicheeTangNewIoMap_BitStream.bit) 或其他码流文件 ![](https://fdvad021asfd8q.oss cn hangzhou.aliyuncs.com/migrate/E203_TD_add.png) 3. 如果 Mode 为 JTAG，断电后则丢失程序。为了上电自动启动，需要选择 PROGRAM FLASH 。（时间较长） 4. E203源码已开放，如果需要进行IO修改，或者功能修改，请使用源码自行进行修改。可以到 [Github](https://github.com/Lichee Pi/Tang_E203_Mini.git) 下载。 5. FPGA例程已上传，请到 [Tang_FPGA_Examples](https://github.com/Lichee Pi/Tang_FPGA_Examples.git) 下载。"},"/hardware/zh/tang/Tang-primer/get_started/install_Linux.html":{"title":"Linux的开发环境安装","content":"# Linux的开发环境安装 ## 安装TD 想要进行FPGA开发需要安装TD，可以通过[下载站](https://dl.sipeed.com/shareURL/TANG/Premier/IDE)，下载TD安装包和license。 对应应下载的IDE名称为 `TD_5.0.3_28716_NL_Linux.zip` License文件：`Anlogic_20230606.lic` 双击打开第一个文件进行安装，安装结束之后将 Anlogic_20230606.lic 修改成Anlogic.lic放到对应安装目录的TD5.0.27252/license中 下载完程序后，打开终端并 cd 进入TD压缩包所在的目录。 ```bash cd <安装程序存档目录的路径 > ``` 在linux中 /opt 目录是为所有不属于默认安装的软件和附加包保留的。 在这里我们为 TD创建一个安装目录 ```bash sudo mkdir /opt/TD_DECEMBER2018 ``` 将 TD 解压到 /opt/TD_DECEMBER2018 目录中： ```bash sudo tar xvf TD_5.0.3_28716_NL_Linux.zip d /opt/TD_DECEMBER2018/ ``` ## 检查默认linux驱动 将 Tang Primer 连接上电脑，执行lsusb命令然后查看信息。确定 USB VID:PID 为 0547:1002，如下图中的显示 ![](./assets/USB_VID.jpg) ## 新建一个udev文件 新建一个udev文件能够让Tang Primer被插件搜索到， 在终端中执行以下命令以创建新的 udev 规则文件。 ```bash sudo nano /etc/udev/rules.d/91 anlogic jtag.rules ``` 将下面的内容复制到上面新建的文件中。 ``` SUBSYSTEMS \"usb\", ATTRS{idVendor} \"0547\", ATTRS{idProduct} \"1002\", \\ GROUP \"plugdev\", \\ MODE \"0660\" ``` 在终端中执行下面的命令来重启udev服务 ```bash sudo service udev restart ``` ## 检查设备能否被TD检测到 在td所在路径解压目录指定下面命令来打开gui界面 ```bash ./td gui ``` 点击下图中框出来的下载按钮 ![](./assets/td_linux_gui.jpg) 将开发板与电脑连接，点击下载界面的刷新按钮 ![](./assets/refresh.jpg) > 有奇怪的bug，导致JTAG只能在 400kbps 或者更低的速率运行"},"/hardware/zh/tang/Tang-primer/get_started/E203.html":{"title":"搭建蜂鸟开发环境","content":"# 搭建蜂鸟开发环境 Note 现已经做好了 虚拟机镜像 链接：[https://dl.sipeed.com/shareURL/TANG/Primer/vmware](https://dl.sipeed.com/shareURL/TANG/Primer/vmware)，可直接使用 ## 下载交叉编译工具链 百度网盘链接为: [https://pan.baidu.com/s/1eUbBlVc](https://pan.baidu.com/s/1eUbBlVc) 由于这里提供的openocd不支持LicheeTang使用的flash型号，所以进行了一些修改; 请[下载](https://fdvad021asfd8q.oss cn hangzhou.aliyuncs.com/LicheeTang/get_started/openocd) 新的进行替换 ## 配置工作环境 1. 从github下载e200_opensource ```bash git clone https://github.com/SI RISCV/e200_opensource.git ``` 2. 将 sirv e203 lichee.tar.gz 解压至 e200_opensource/sirv e sdk/bsp/env 目录下 <! (https://fdvad021asfd8q.oss cn hangzhou.aliyuncs.com/LicheeTang/get_started/sirv e203 lichee.tar.gz) > 将下载好的交叉工具编译链以及 openocd 解压(记得使用新的openocd替换)，在 e200_opensource/sirv e sdk/work 目录下将其分别软连接到: ```sh . └── build ├── openocd │ └── prefix │ └── bin > /opt/riscv/gnu mcu eclipse/openocd/0.10.0 6 20180112 1448/bin/ └── riscv gnu toolchain └── riscv32 unknown elf └── prefix └── bin > /opt/riscv/gnu mcu eclipse/riscv none gcc/7.2.0 2 20180111 2230/bin/ ``` ## 蜂鸟的调试 我们使用ft2232d与openocd进行蜂鸟的调试，所以需要进行一些配置 将ft2232d插入电脑，执行lsusb，可看到一下信息 ```bash Bus 003 Device 019: ID 0403:6010 Future Technology Devices International, Ltd FT2232C Dual USB UART/FIFO IC ``` 新建 udev rules,使 ft2232d 能够被 plugde group 访问 vim /etc/udev/rules.d/45 ft2232.rules ATTR{idVendor} \"0403\", ATTR{idProduct} \"6010\", MODE \"660\", GROUP \"plugdev\" 查看该设备是否属于 plugdev ls l /dev/ttyUSB1 crw rw 1 root plugdev 188, 1 7月 11 09:13 /dev/ttyUSB1 将你自己的用户添加到 plugdev group 中 whoami sudo usermod –a –G plugdev your user name 确认你自己的用户是否属于 plugdev group groups ## 编译下载demo程序 编译下载demo程序，可参考文件夹下的demo_gpio.tar.gz在e200_opensource/sirv e sdk目录下执行 ```bash make software PROGRAM demo_gpio BOARD sirv e203 lichee #编译 ``` ```bash make upload PROGRAM demo_gpio BOARD sirv e203 lichee #上传 ``` ## 调试 打开两个terminal，一个运行openocd，另外一个运行gdb ```bash make run_openocd PROGRAM demo_gpio BOARD sirv e203 lichee #运行openocd ``` ```bash make run_gdb PROGRAM demo_gpio BOARD sirv e203 lichee #运行gdb ``` `Tip 可能写的不是很清楚，如果有任何疑问欢迎提出，或者参看胡大的《手把手教你设计CPU：RISC V处理器》（已经上市，请在京东、淘宝、当当上搜索 RISC V关键字）`"},"/hardware/zh/tang/Tang-primer/get_started/install_TD_win.html":{"title":"Windows的开发环境安装","content":"# Windows的开发环境安装 > 修改于2022.04.22 ## 安装TD 想要进行FPGA开发需要安装TD，可以通过[下载站](https://dl.sipeed.com/shareURL/TANG)，下载TD安装包和license。 安装包 ：`TD_5.0.4_27252_Win7_64bit_NL.msi` License文件：`Anlogic_20230606.lic` 双击打开第一个文件进行安装，安装结束之后将 Anlogic_20230606.lic 修改成Anlogic.lic放到对应安装目录的TD5.0.27252\\license中 然后可以运行TD软件 ## 安装usb串口 将 Tang Primer 插入您的计算机并打开设备管理器以查看信息。 根据 Windows 版本不同，它可能被命名为 WinUsb Device 或 USB JTAG Cable。 确保 USB VID:PID 为 0547:1002 win7系统没有安装驱动时 ![no_driver](./../../assets/get_started/no_driver.png) win10系统没有安装驱动时 ![no_driver_win10](./../../assets/get_started/no_driver_win10.png) ### win7安装驱动 双击 WinUsb Device 选择更新驱动程序 ![update_drive1](./../../assets/get_started/update_driver1.png) ![update_drive2](./../../assets/get_started/update_driver2.png) 浏览文件夹，选择TD安装目录下的驱动目录。 单击确定开始安装 ![choosefolder](./../../assets/get_started/choosefolder.png) 安装成功，在设备管理器中可以看到 ![installsuccess](./../../assets/get_started/installsuccess.png) ### win10安装驱动 > 在安装驱动程序本身之前，请确保首先禁用驱动程序签名强制，否则 Windows 10 将不允许您安装来自 Anlogic 的未签名驱动程序 双击 WinUsb Device 选择更新驱动程序 ![update_drive1](./../../assets/get_started/update_driver1_win10.png) ![update_drive2](./../../assets/get_started/update_driver2_win10.png) 浏览文件夹，选择TD安装目录下的driver\\win8_10_64目录。 单击确定。 然后单击让我从计算机上的可用驱动程序列表中选择 ![choosefolder](./../../assets/get_started/choosefolder_win10.png) 单击Have Disk...，然后选择您在上一步中选择的目录，然后单击OK ![install_from_disk_win10](./../../assets/get_started/install_from_disk_win10.png) 安装成功，在设备管理器中可以看到 ![installsuccess](./../../assets/get_started/installsuccess.png) ## 验证安装 打开TD，点击下载,如图所示 ![](./../../assets/get_started/87078310026779781.jpg) 将 Tang Primer 插入您的计算机，然后点击下载对话框上的刷新按钮 ![](./../../assets/get_started/1823555291194601.jpg) 出现上图的信息，则表示安装且激活成功"},"/hardware/zh/tang/Tang-primer/e203/display.html":{"title":"蜂鸟驱动屏幕","content":" title: 蜂鸟驱动屏幕 > maxdepth > : 2 > > display/lcd1602 display/oled display/spi\\_tft"},"/hardware/zh/tang/Tang-primer/e203/rv_ip.html":{"title":"蜂鸟添加外设","content":" title: 蜂鸟添加外设 待补充。。。"},"/hardware/zh/tang/Tang-primer/e203/led/led.html":{"title":"RGB LED","content":" title: RGB LED 待补充。。。"},"/hardware/zh/tang/Tang-primer/e203/led/ws2812.html":{"title":"WS2812灯带","content":" title: WS2812灯带 待补充。。。"},"/hardware/zh/tang/Tang-primer/e203/led/pwm_led.html":{"title":"呼吸灯","content":" title: 呼吸灯 待补充。。。"},"/hardware/zh/tang/Tang-primer/e203/led.html":{"title":"蜂鸟点灯","content":" title: 蜂鸟点灯 > maxdepth > : 2 > > led/led led/pwm\\_led led/ws2812"},"/hardware/zh/tang/Tang-primer/e203/ft2232.html":{"title":"FT2232使用简明教程","content":" title: FT2232使用简明教程 待补充。。。"},"/hardware/zh/tang/Tang-primer/e203/sensor.html":{"title":"蜂鸟外挂传感器","content":" title: 蜂鸟外挂传感器 待补充。。。"},"/hardware/zh/tang/Tang-primer/e203/int.html":{"title":"蜂鸟的中断","content":" title: 蜂鸟的中断 待补充。。。"},"/hardware/zh/tang/Tang-primer/e203/display/spi_tft.html":{"title":"SPI\\_MCU彩屏","content":" title: 'SPI\\_MCU彩屏' 待补充。。。"},"/hardware/zh/tang/Tang-primer/e203/display/lcd1602.html":{"title":"1602屏幕","content":" title: 1602屏幕 待补充。。。"},"/hardware/zh/tang/Tang-primer/e203/display/oled.html":{"title":"OLED屏幕","content":" title: OLED屏幕 待补充。。。"},"/hardware/zh/tang/Tang-primer/e203/peripherals.html":{"title":"蜂鸟外设简介","content":" title: 蜂鸟外设简介 待补充。。。"},"/hardware/zh/tang/Tang-primer/fpga/ics/dac908.html":{"title":"FPGA驱动DAC908","content":" title: FPGA驱动DAC908 待补充。。。"},"/hardware/zh/tang/Tang-primer/fpga/ics/codec.html":{"title":"FPGA驱动CODEC","content":" title: FPGA驱动CODEC 待补充。。。"},"/hardware/zh/tang/Tang-primer/fpga/ics/adc9288.html":{"title":"FPGA驱动ADC9288","content":" title: FPGA驱动ADC9288 待补充。。。"},"/hardware/zh/tang/Tang-primer/fpga/ics/usb3300.html":{"title":"FPGA驱动USB3300","content":" title: FPGA驱动USB3300 待补充。。。"},"/hardware/zh/tang/Tang-primer/fpga/sdram.html":{"title":"FPGA驱动SDRAM","content":" title: FPGA驱动SDRAM 待补充。。。"},"/hardware/zh/tang/Tang-primer/fpga/display.html":{"title":"FPGA外接常用显示接口","content":" title: FPGA外接常用显示接口 \\> maxdepth \\> : 2 \\> \\> display/lcd display/vga display/av display/hdmi"},"/hardware/zh/tang/Tang-primer/fpga/opencores.html":{"title":"FPGA 运行其他软核","content":" title: FPGA 运行其他软核 待补充。。。"},"/hardware/zh/tang/Tang-primer/fpga/ics.html":{"title":"FPGA驱动其他IC","content":" title: FPGA驱动其他IC \\> maxdepth \\> : 2 \\> \\> ics/adc9288 ics/dac908 ics/codec ics/usb3300"},"/hardware/zh/tang/Tang-primer/fpga/led.html":{"title":"FPGA点灯","content":" title: FPGA点灯 ## 源码下载 请到 github 下载全部工程，地址为 [https://github.com/Lichee Pi/Tang_FPGA_Examples/](https://github.com/Lichee Pi/Tang_FPGA_Examples/) ## Verilog代码 ```v module led ( input wire CLK_IN, //时钟输入，24MHz input wire RST_N, //复位按键输入，低有效 output wire [2:0]RGB_LED //RGB led输出 ); parameter time1 24’d24_000_000;//晶振为24Mhz，这里表示计数一秒 reg [2:0]rledout; reg [23:0] count; reg [1:0]shift_cnt; initial begin count 24’b0; rledout 3’b1; shift_cnt 2’b0; end always @(posedge CLK_IN)begin if(RST_N 0)begin //复位按键按下就清空计数并清空输出 count < 24’b0; rledout < 3’b1; shift_cnt < 2’b0; end if(count time1) //计数时间到 begin count< 24’d0; //清空计数值 if(shift_cnt 2’b10)begin //移位3次 rledout < 3’b1; shift_cnt < 2’b0; end else begin rledout < {rledout[1:0],1’b0}; //led输出移位 shift_cnt < shift_cnt + 1’b1; end end else count < count + 1’b1; //计数累加 end assign RGB_LED rledout; endmodule ``` 上面的代码输入完且保存后，综合一下，接着自己对照板子原理图进行管脚约束。在生成比特流下载到fpga，可以看到板上的rgb led会移位闪烁。（emmm，闪烁效果太差，如果你有更好的可以发过来。(╯︵╰)"},"/hardware/zh/tang/Tang-primer/fpga/dvp.html":{"title":"FPGA驱动DVP","content":" title: FPGA驱动DVP 待补充。。。"},"/hardware/zh/tang/Tang-primer/fpga/display/vga.html":{"title":"FPGA驱动VGA","content":" title: FPGA驱动VGA 待补充。。。"},"/hardware/zh/tang/Tang-primer/fpga/display/av.html":{"title":"FPGA驱动AV显示器","content":" title: FPGA驱动AV显示器 待补充。。。"},"/hardware/zh/tang/Tang-primer/fpga/display/lcd.html":{"title":"FPGA驱动LCD","content":" title: FPGA驱动LCD 待补充。。。"},"/hardware/zh/tang/Tang-primer/fpga/display/hdmi.html":{"title":"FPGA驱动HDMI","content":" title: FPGA驱动HDMI 待补充。。。"},"/hardware/zh/tang/Tang-primer/index.html":{"title":"荔枝糖 全流程指南","content":"# 荔枝糖 全流程指南 荔枝糖，一款极致打磨的国产开源RISC V开发板。 荔枝糖萌生于国内芯片振荡之潮，历经三个月的生长与蜕变，终于在七月，登上开源的舞台。 荔枝糖不仅担起开源开发者们的期待，更志向于在国内推广RISC V架构相关的开发与教育，向世界介绍中国的一款优秀开发板。 ![](./../assets/material.png) 荔枝糖使用 安路科技(Anlogic Technologies) 的 EG4S20 作为核心单元, **20K逻辑单元(LUT4/LUT5混合架构)，约130KB SRAM，内置32bit位宽 64MBit SDRAM，丰富的LVDS引脚，内置12 bit 1MSPS ADC**，这为荔枝糖提供了无限的可能性： FPC40P座，可接 RGB LCD，VGA转接板，高速DAC模块 FPC24P座，可接DVP摄像头，高速ADC模块 I2C接口的电阻触摸屏控制器，配合RGB LCD使用 3路DCDC电源芯片，稳定高效的电源供应，Bank0 IO电平独立可调 FPGA 配置Flash，8Mbit 用户Flash，nor/nand可选 板载FPGA JTAG下载调试器 RGB LED 相邻插针LVDS等长引出，引出8路GCLK，全引出8路ADC。 双排插针间距900mil， **兼容面包板开发** 半孔引出额外 **40 IO**，整板引出 **130+ IO** 。 ![荔枝糖资源图](./../assets/E203_function.png) ![荔枝糖引脚图(旧板,底面丝印较小版本)](./../assets/E203_pin.png) ![ 荔枝派引脚图(新板,底面丝印较大版本)](./../assets/Lichee tang_NewIoMap.png) 您可能需要这些来进一步了解荔枝糖： EG4S20Datasheet [点我](https://dl.sipeed.com/shareURL/TANG/Primer/HDK/Datasheet/)里面的`EG4S20_DataSheet_V1.4.pdf` 荔枝糖原理图 [点我](https://dl.sipeed.com/shareURL/TANG/Primer/HDK)里面的`LicheeTang_RV(Schematic).pdf` 荔枝糖仍在不断地成长，对于外观、电路设计、文档内容甚至于荔枝糖的发展方向， 我们欢迎您到[荔枝糖 建议与讨论帖](https://bbs.sipeed.com/cate/30/seq/1) 提出您宝贵的建议。 同时欢迎各位加入荔枝派交流群 `834585530` 或者 [荔枝派Telegram电报群](https://t.me/sipeed)与众多开发者、爱好者即时交流。 另外，FPGA开发环境TD (Tang Dynasty) 可在如下网址下载： [https://dl.sipeed.com/shareURL/TANG/Primer/IDE](https://dl.sipeed.com/shareURL/TANG/Primer/IDE)"},"/hardware/zh/tang/Tang-Nano-9K/examples/softcore-1/softcore-1.html":{"title":"移植FatFS，为RISCV添加FAT32文件系统","content":"# 移植FatFS，为RISCV添加FAT32文件系统 > 编辑于2022.05.26 原文链接:https://bbs.sipeed.com/thread/1482 搬运有改动。 首先新建一个项目工程，选型时不要选错型号。 ## Gowin 相关设置 在 IP generator 生成中选择 Gowin_PicoRV32，软核最大可以跑到50MHz，这个频率做一些基本控制是绰绰有余的。 打开IP后，双击要修改的模块进行设置。 此处去掉了 RV32C 和 RV32M 指令集的扩展，关闭了Jtag debug功能。 然后是定制ITCM和DTCM，由于我选择将程序编译后直接放到ITCM中运行（MCU boot and run in ITCM），并且编译后的文件大约需要22KB，所以分给了ITCM 32KB的空间，DTCM保持默认16KB。 外设方面，启用UART来输出打印信息，SPI Master用于与SD卡通信，GPIO用来点灯。我还打开了AHB扩展，并在上面挂载了一片内存用于后续LCD的显存。 还需要调用PLL，为CPU提供50MHz的时钟，SD卡的读写速度也是50MHz，最后绑定好pin脚，生成FPGA的下载文件。 ## GMD 相关的操作 接下去的工作就要转到[GMD](http://www.gowinsemi.com.cn/prodshow.aspx)中了。参考半导体官方文档[IPUG910](http://cdn.gowinsemi.com.cn/IPUG910 1.4_Gowin_PicoRV32_IDE%E8%BD%AF%E4%BB%B6%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C.pdf)进行开发环境搭建和程序编译，外设的驱动编写可以参考[IPUG911](http://cdn.gowinsemi.com.cn/IPUG911 1.3_Gowin_PicoRV32%E8%BD%AF%E4%BB%B6%E7%BC%96%E7%A8%8B%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C.pdf)，最后程序的下载可以参考[IPUG913](http://cdn.gowinsemi.com.cn/IPUG913 1.4_Gowin_PicoRV32%E8%BD%AF%E4%BB%B6%E4%B8%8B%E8%BD%BD%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C.pdf)。 C的开发环境搭建完成后，就开始进行SD卡驱动和fatfs的移植，这里我将SD卡作为只读设备，编写了相应的驱动。 ### SD Command SD卡的通信，主要是通过Matser发送CMD命令进行的，驱动见下面代码。 ```c #define SPI_ID 0 uint8_t sd_sendcmd(uint8_t cmd, uint32_t arg, uint8_t crc) { uint8_t r1, cnt; cnt 0; wbspi_master_select_slave(PICO_WBSPI_MASTER,SPI_ID); wbspi_master_txdata(PICO_WBSPI_MASTER,0xFF); wbspi_master_txdata(PICO_WBSPI_MASTER,(cmd 0x40)); wbspi_master_txdata(PICO_WBSPI_MASTER,arg>>24); wbspi_master_txdata(PICO_WBSPI_MASTER,arg>>16); wbspi_master_txdata(PICO_WBSPI_MASTER,arg>>8); wbspi_master_txdata(PICO_WBSPI_MASTER,arg); wbspi_master_txdata(PICO_WBSPI_MASTER,crc); do{ r1 wbspi_master_txdata(PICO_WBSPI_MASTER,0xFF); cnt++; if(cnt > 50) break; }while(r1 0xFF); return r1; } ``` ### SD Init 基于上面这个函数，就开始编写SD卡初始化函数，初始化的流程为： 1、发送大于74个周期的时钟信号，等待SD卡内部逻辑稳定； 2、发送CMD0，让SD卡进入IDLE状态； 3、发送CMD8，查询卡的型号是不是支持SD 2.0协议； 4、这里只处理支持SD 2.0协议的卡，发送CMD55+ACMD41进行初始化； 5、发送CMD58，查询卡支不支持SDHC； 6、发送CMD9，CMD10，获取SD卡的CID和OCR信息 ```C uint8_t sd_init(void) { uint32_t i; uint8_t r1; uint8_t buff[16]; uint8_t cnt 0; wbspi_master_select_slave(PICO_WBSPI_MASTER,SPI_ID); for(i 0; i<1000; i++); for(i 0; i<10; i++) wbspi_master_txdata(PICO_WBSPI_MASTER,0xFF); r1 sd_sendcmd(0,0,0x95); r1 sd_sendcmd(8,0x1aa,0x87); if(r1 0x01) { buff[0] wbspi_master_txdata(PICO_WBSPI_MASTER,0xFF); buff[1] wbspi_master_txdata(PICO_WBSPI_MASTER,0xFF); buff[2] wbspi_master_txdata(PICO_WBSPI_MASTER,0xFF); buff[3] wbspi_master_txdata(PICO_WBSPI_MASTER,0xFF); do{ r1 sd_sendcmd(55,0,0); if(r1 ! 0x01) return 1; r1 sd_sendcmd(41,0x40000000,1); cnt++; if(cnt>100) return 1; }while(r1! 0); } r1 sd_sendcmd(58,0,0); if(r1 ! 0x00) return 1; buff[0] wbspi_master_txdata(PICO_WBSPI_MASTER,0xFF); buff[1] wbspi_master_txdata(PICO_WBSPI_MASTER,0xFF); buff[2] wbspi_master_txdata(PICO_WBSPI_MASTER,0xFF); buff[3] wbspi_master_txdata(PICO_WBSPI_MASTER,0xFF); wbspi_master_txdata(PICO_WBSPI_MASTER,0xFF); if(buff[0]&0x40) printf(\"sdhc rdy\\r\\n\"); else printf(\"sd2.0 rdy\\r\\n\"); r1 sd_sendcmd(9,0,0xFF); if(r1 ! 0x00) return 1; do{ r1 wbspi_master_txdata(PICO_WBSPI_MASTER,0xFF); }while(r1 ! 0xFE); for(i 0; i<16; i++) { r1 wbspi_master_txdata(PICO_WBSPI_MASTER,0xFF); } r1 sd_sendcmd(10,0,0xFF); if(r1 ! 0x00) return 1; do{ r1 wbspi_master_txdata(PICO_WBSPI_MASTER,0xFF); }while(r1 ! 0xFE); for(i 0; i<16; i++) { r1 wbspi_master_txdata(PICO_WBSPI_MASTER,0xFF); } return 0; } ``` ### SD Read Block 下面是SD卡读单块和多块的驱动。 ```C BYTE SD_ReadSingleBlock(UINT sector, BYTE *buffer) { BYTE r1; WORD i; i 512; r1 sd_sendcmd(17, sector, 1); //发送CMD17 读命令 if(r1 ! 0x00) return r1; do{ r1 wbspi_master_txdata(PICO_WBSPI_MASTER,0xFF); }while(r1 ! 0xFE); while(i! 0) { *buffer wbspi_master_txdata(PICO_WBSPI_MASTER,0xFF); buffer++; i ; } wbspi_master_txdata(PICO_WBSPI_MASTER,0xFF); wbspi_master_txdata(PICO_WBSPI_MASTER,0xFF); return 0; //读取正确，返回0 } BYTE SD_ReadMultiBlock(UINT sector, BYTE *buffer, BYTE count) { BYTE r1; WORD i; r1 sd_sendcmd(18, sector, 1); //读多块命令 if(r1 ! 0x00) return r1; while(count ! 0){ i 512; do{ r1 wbspi_master_txdata(PICO_WBSPI_MASTER,0xFF); }while(r1 ! 0xFE); while(i! 0) { *buffer wbspi_master_txdata(PICO_WBSPI_MASTER,0xFF); buffer++; i ; } buffer+ 512; count ; wbspi_master_txdata(PICO_WBSPI_MASTER,0xFF); } sd_sendcmd(12, 0, 1); //全部传输完成，发送停止命令 wbspi_master_txdata(PICO_WBSPI_MASTER,0xFF); if(count ! 0) return count; //如果没有传完，返回剩余个数 else return 0; } ``` ### FatFs File system SD卡驱动完成后，开始移植FatFs文件系统 源码下载：http://elm chan.org/fsw/ff/archives.html 选择最新的FatFs R0.14b ，并添加到工程。 FFConf.h用于FatFs的定制，这里需要将FF_FS_READONLY的宏改为1，将SD卡作为只读设备。 还需要改写diskio.c文件，适配SD卡。这里只做了最简单的适配，完成了初始化和读，查询状态和获取时间都是空函数。由于宏设置，这两个函数disk_ioctl和disk_write就不管了 ```C #define SD_CARD 0 DSTATUS disk_initialize ( BYTE pdrv /* Physical drive nmuber (0..) */ ) { DRESULT status STA_NOINIT; switch(pdrv) { case SD_CARD://SD卡 status sd_init(); break; default: status STA_NOINIT; } return status; } //获得磁盘状态 DSTATUS disk_status ( BYTE pdrv /* Physical drive nmuber (0..) */ ) { return 0; } //读扇区 //drv:磁盘编号0~9 //*buff:数据接收缓冲首地址 //sector:扇区地址 //count:需要读取的扇区数 DRESULT disk_read ( BYTE pdrv, /* Physical drive nmuber (0..) */ BYTE *buff, /* Data buffer to store read data */ DWORD sector, /* Sector address (LBA) */ UINT count /* Number of sectors to read (1..128) */ ) { DRESULT status RES_PARERR; if (!count)return RES_PARERR; //count不能等于0，否则返回参数错误 switch(pdrv) { case SD_CARD://SD卡 if(count 1) status SD_ReadSingleBlock(sector, buff); else status SD_ReadMultiBlock(sector, buff, count); break; default: status RES_PARERR; } return status; } DWORD get_fattime (void) { return 0; } ``` 最后进行测试，在SD卡的根目录放一个txt文件，然后RV32 CPU通过串口，将文件大小和内容打印出来。 ```C res f_mount(&fs, \"\", 1); res f_open(&file, \"top.txt\", FA_READ); printf(\"\\r\\nfile size:%d\\r\\n\", file.obj.objsize); f_read(&file, fbuff, file.obj.objsize, &br); printf(\"%s\\r\\n\",fbuff); f_close(&file); ```"},"/hardware/zh/tang/Tang-Nano-9K/examples/softcore-1/softcore-2.html":{"title":"使用PicoRV32软核在lcd屏幕上绘制图形","content":"# 使用PicoRV32软核在lcd屏幕上绘制图形 > 编辑于2022.06.22 原文链接:https://bbs.sipeed.com/thread/1483 有改动 ## 摘要 此工程在 LCD 屏幕绘制了两个长方形——一个实心的；另一个空心的。其中空心的边框宽度作为参数可调，并且绘图的颜色还可以通过按钮调整，现已支持红、绿、蓝和白，共四种颜色。 整体的硬件设计基于半导体提供的 PicoRV32 软核IP，在 OPEN AHB INTERFACE 的处，挂载了 128Kbits 的 BSRAM 用作显存。 该 128Kbits 的显存，本质上是一颗双端口的 SRAM ，使得 CPU 和自定义的 LCD IP 共同使用该“显存”。LCD IP 独立于CPU工作，节省 CPU 资源，达到 FPGA 加速的效果。 ## 设计 ### AHB 接口例化 AHB接口用于与CPU交互，LCD接口与LCD IP交互。代码接口如下： ```verilog ahb2bram ahb2bram( .clk_i(clk50), .reset_i(~sys_rstn), .hrdata_o(hrdata), .hresp_o(hresp), .hready_o(hready), .haddr_i(haddr), .hwrite_i(hwrite), .hsize_i(hsize), .hburst_i(hburst), .hwdata_i(hwdata), .hsel_i(hsel), .htrans_i(htrans), .lcd_clk_i(clk10), .lcd_rd_i(lcd_rd), .lcd_addr_i(lcd_addr), .lcd_data_o(lcd_data) ); ``` ### 生成长方形 在这个系统中，CPU主要负责图形的“渲染”，这个在大型系统中常常是GPU来做的。 这里描述有点夸张了，其实所谓的“渲染”就是画个长方形，CPU 根据 C代码中的顶点坐标，把对应的显存地址填入1或者0。所封装的画实心的API如下 ```c void draw_rectangle(uint8_t top_x, uint8_t top_y, uint8_t btm_x, uint8_t btm_y) { uint8_t i,j; uint8_t calc_x; uint8_t calc_y; calc_x top_x/32; calc_y top_y/32; for(i 0; i<Y_MAX; i++) for(j 0; j<X_MAX; j++) { if(j> calc_x && j< calc_y && i> top_y && i< btm_y) PCIO_AHBSRAM >SRAM[i*X_MAX+j] RGB; } } ``` ### 例化 LCD CPU 运行起来后，会根据 C代码 访问 AHB总线，发出读写命令。自定义的 AHB2BRAM 模块，会将总线地址转换成显存地址进行数据读写。将绘制的图形保存在显存中，只要不掉电，就不会丢失。同时，LCD IP 只负责从显存中取数据，按照行场扫描的时序，就可以完完整整的将图形显示在LCD屏幕上了，LCD IP 的接口如下。 ```verilog VGAMod VGAMod ( .nRST(sys_rstn), .PixelClk(clk10), .lcd_rd_o(lcd_rd), .lcd_addr_o(lcd_addr), .lcd_data_i(lcd_data), .LCD_DE(LCD_DE), .LCD_HSYNC(LCD_HSYNC), .LCD_VSYNC(LCD_VSYNC), .LCD_B(LCD_B_t), .LCD_G(LCD_G_t), .LCD_R(LCD_R_t) ); ``` ### 结语 受限于资源，此文实现的系统只有 128Kbits 的显存，而笔者使用的 LCD 的分辨率是480*272，RGB565。如果需要存一幅完整图形需要将显存扩大16倍，似乎超过了Nano 9K板载的这颗FPGA极限。因此，选择折中，不去保存RGB565，而是简单的复制扩展保存的1bit信息到RGB565中，这样颜色深度无法达到65536，只支持红、绿、蓝和白四种颜色。 其实FPGA内封的PSRAM有 64Mbits，足够这块LCD的显存了。以后有机会可以尝试着用这些内存来运行一下 lvgl。 !"},"/hardware/zh/tang/Tang-Nano-9K/examples/spi_lcd/spi_lcd.html":{"title":"Spi lcd","content":" title: Spi lcd keywords: Tang Nano 9K, spi, lcd update: date: 2022 10 25 version: v0.1 author: wonder content: 内容编写 ## 前言 Tang Nano 9K 板卡上有一个 8P 的 spi lcd 连接器，可以用来去驱动配套的 spi lcd 屏幕。 <img src \"./../nano_9k/spi_lcd.jpg\" alt \"spi_lcd\" width 48%> 配套 SPI 屏幕可以在淘宝店询问客服购买：[点我跳转到淘宝页面](https://sipeed.taobao.com/) ## 分析 SPI 屏幕的数据手册在这里：[点我跳转到下载页面](https://dl.sipeed.com/shareURL/TANG/Nano%209K/6_Chip_Manual/CN/LCD_Datasheet) 从数据手册中可以看到以下信息： NO. Item Contents Unit 1 LCD Size 1.14 inch 2 Display Mode Normally black 3 Resolution 135(H)RGB x240(V) pixels 4 Pixel pitch 0.1101(H) x 0.1038(V) mm 5 Active area 14.864(H) x 24.912(V) mm 6 Module size 17.6(H) x 31.0(V) x1.6 (D) mm 7 Pixel arrangement RGB Vertical stripe 8 Interface 4 Line SPI 9 Display Colors 262K colors 10 Drive IC ST7789V3 11 Luminance(cd/m2) 400 (TYP) Cd/m2 12 Viewing Direction All View Best image 13 Backlight 1 White LED 14 Operating Temp. 20℃~ + 70℃ ℃ 15 Storage Temp. 30℃~ + 80℃ ℃ 16 Weight 1.8 g 在里面我们主要需要知道以下信息： 分辨率 (Resolution)：135(H)RGB x240(V) 接口 (Interface)：4 Line SPI 驱动 (Drive IC)：ST7789V3 [点我下载相关数据手册](https://dl.sipeed.com/fileList/MAIX/HDK/Chip_DS/ST7789V3_SPEC_Preliminary_V0.0_200102.pdf) 感谢群友提供的代码，前往 https://github.com/sipeed/TangNano 9K example/tree/main/spi_lcd 查看详情，相关说明会在整理之后展示。 ![spi_lcd](./../nano_9k/spi_lcd.jpg)"},"/hardware/zh/tang/Tang-Nano-9K/examples/spi_lcd.html":{"title":"Spi_lcd","content":"# Spi_lcd 感谢群友提供的代码，前往 https://github.com/sipeed/TangNano 9K example/tree/main/spi_lcd 查看详情，相关说明会在整理之后展示。 ![spi_lcd](./../nano_9k/spi_lcd.jpg)"},"/hardware/zh/tang/Tang-Nano-9K/examples/lcd_constrains.html":{"title":"LCD Pin Constrain content","content":"# LCD Pin Constrain content 直接把下面的内容复制进\".cst\"文件即可 Copt the following content into the \".cst\" file ``` IO_LOC \"LCD_B[4]\" 41; IO_PORT \"LCD_B[4]\" IO_TYPE LVCMOS33; IO_LOC \"LCD_B[3]\" 42; IO_PORT \"LCD_B[3]\" IO_TYPE LVCMOS33; IO_LOC \"LCD_B[2]\" 51; IO_PORT \"LCD_B[2]\" IO_TYPE LVCMOS33; IO_LOC \"LCD_B[1]\" 53; IO_PORT \"LCD_B[1]\" IO_TYPE LVCMOS33; IO_LOC \"LCD_B[0]\" 54; IO_PORT \"LCD_B[0]\" IO_TYPE LVCMOS33; IO_LOC \"LCD_G[5]\" 55; IO_PORT \"LCD_G[5]\" IO_TYPE LVCMOS33; IO_LOC \"LCD_G[4]\" 56; IO_PORT \"LCD_G[4]\" IO_TYPE LVCMOS33; IO_LOC \"LCD_G[3]\" 57; IO_PORT \"LCD_G[3]\" IO_TYPE LVCMOS33; IO_LOC \"LCD_G[2]\" 68; IO_PORT \"LCD_G[2]\" IO_TYPE LVCMOS33; IO_LOC \"LCD_G[1]\" 69; IO_PORT \"LCD_G[1]\" IO_TYPE LVCMOS33; IO_LOC \"LCD_G[0]\" 70; IO_PORT \"LCD_G[0]\" IO_TYPE LVCMOS33; IO_LOC \"LCD_R[4]\" 71; IO_PORT \"LCD_R[4]\" IO_TYPE LVCMOS33; IO_LOC \"LCD_R[3]\" 72; IO_PORT \"LCD_R[3]\" IO_TYPE LVCMOS33; IO_LOC \"LCD_R[2]\" 73; IO_PORT \"LCD_R[2]\" IO_TYPE LVCMOS33; IO_LOC \"LCD_R[1]\" 74; IO_PORT \"LCD_R[1]\" IO_TYPE LVCMOS33; IO_LOC \"LCD_R[0]\" 75; IO_PORT \"LCD_R[0]\" IO_TYPE LVCMOS33; IO_LOC \"LCD_DEN\" 33; IO_PORT \"LCD_DEN\" IO_TYPE LVCMOS33; IO_LOC \"LCD_SYNC\" 34; IO_PORT \"LCD_SYNC\" IO_TYPE LVCMOS33; IO_LOC \"LCD_HYNC\" 40; IO_PORT \"LCD_HYNC\" IO_TYPE LVCMOS33; IO_LOC \"LCD_CLK\" 35; IO_PORT \"LCD_CLK\" IO_TYPE LVCMOS33; IO_LOC \"XTAL_IN\" 52; IO_PORT \"XTAL_IN\" IO_TYPE LVCMOS33 PULL_MODE NONE; IO_LOC \"nRST\" 4; ```"},"/hardware/zh/tang/Tang-Nano-9K/examples/picorv.html":{"title":"Tang Nano 9K picoRV 简单示例","content":" title: Tang Nano 9K picoRV 简单示例 > 编辑于2022年3月28日 ## 前言 在Tang Nano 9K [例程仓库](https://github.com/sipeed/TangNano 9K example/tree/main/picotiny)里面有一个picoRV的例程。 本篇文章仅简单叙述如何使用例程，无其他内容。 ## 相关环境 Python Gowin IDE ## 相关步骤 ### 烧录Bitstream 打开 TangNano 9K example\\picotiny\\project 目录下的 picotiny.gprj 文件 在顶部菜单栏 Project >Configuration >Place&Route >Dual Purpose Pin 里面勾选 Use MSPI as regular IO 在 IDE 的 Process 窗口右键 Place&Route 选择 Clean＆Rerun All 将生成的文件下载到 Nano 9K 的 Embedded Flash 完成上面步骤后我们已经成功将PicoRV固化到FPGA里面了 ### 烧录例程文件 在 TangNano 9K example\\picotiny 目录下执行 ```python python .\\sw\\pico programmer.py .\\example fw flash.v COM13 ``` 上面命令行中最后的 COM13 指的是开发板在系统中的串口编号， 比如在系统中显示为COM14的话就需要将它改成对应的COM14。 成功执行上面命令后会出现 ` Waiting for reset ` 的计时， 这时候按下开发板的S1按键就可以完成烧录。 附带完成的烧录log： ```powershell \\TangNano 9K example\\picotiny> python .\\sw\\pico programmer.py .\\example fw flash.v COM13 Read program with 11760 bytes Waiting for reset ... Total sectors 3 Total pages 46 Flashing 1 / 3 Flashing 2 / 3 Flashing 3 / 3 Flashing completed ``` 然后就可以使用在串口工具来执行我们的代码了，当然也可以用HDMI来显示代码界面 ![](./../nano_9k/picorv.jpg) ## 其他事项 本文仅提供一种运行方法，无其他作用 交叉编译等高阶玩法自己参考项目目录的makefile修改，无其他支持 <p id \"back\"> <a href \"#\" onClick \"javascript :history.back( 1);\">返回上一页(Back)</a> </p>"},"/hardware/zh/tang/Tang-Nano-9K/examples/lushaylabs/10_our_first_cpu/our_first_cpu.html":{"title":"","content":""},"/hardware/zh/tang/Tang-Nano-9K/examples/lushaylabs/2_debugging_uart/debugging_uart.html":{"title":"Tang Nano 9K 调试","content":" title: Tang Nano 9K 调试 keywords: FPGA, Tang, Nano, 9K update: date: 2023 02 14 version: v0.1 author: wonder content: 新建文档 [原文链接](https://learn.lushaylabs.com/tang nano 9k debugging/) > This is the second article in our series on the Tang Nano 9K, the first section on getting your development environment setup can be found [here](./../1_installation_getting_started/installation_getting_started.html). When programming FPGAs or really any embedded system you usually have a lot less visibility into whats going on, in comparison to programming for computers. When everything works its great, but more times then not you won't get your design perfect on the first try and not having this visibility can make it hard to troubleshoot. In this article we will go through some of the different ways to debug an FPGA project as well as cover some of the more common issues, so if you do run into an issue you will know how to overcome it. We will also be building a UART module which will use the on board RV debugger built into the Tang Nano 9K ([🔌🔌](https://item.taobao.com/item.htm?id 666055424174)) to communicate with a computer serially. ## Classifying the Type of Bug To efficiently debug an issue, like in most things, it works best when you use the right tool for the job. Different types of bugs have different tools which can help to find them. From my experience you can usually categorize bugs into three main categories: <ol> <li>Syntax Errors</li> <li>Logic / Implementation Errors</li> <li>Integration Errors.</li> </ol> ### Syntax Errors This is the type of error where you mistyped, forgot to close a block, misused a verilog feature etc... All these kinds of issues are the least severe in my opinion, as they are brought up during the synthesis stage while compiling your design and you will usually get an exact file and line number. So even if the error message is not that clear, you still have the exact location of the problem which makes it easy to fix. We won't go too much into this type of bugs as like I mentioned you will immediately know about this kind of bug during syntheses if not before from the editor itself. ### Logic / Implementation Errors Logic errors are the types of errors where you had a flaw in your original design, maybe you forgot to handle edge cases or had a mistake in your original plan. Implementation errors are the flip side of this, where your design was actually solid, but the code written doesn't actually do what you intended. Both these kinds of issues are a bit harder to catch, since you won't receive any error message. The only indication you will have is that your project doesn't work as intended. In these situations though, we are talking about cases where you understand and know how it is meant to perform. For these cases we can use simulations and visual logic debugging with VCD files to see what our design is doing over time and track down at which stage there is a problem. We will cover both of these method below. ### Integration Errors Integrations errors are errors that occur only when run on the actual FPGA and are usually because of misunderstanding, or not fulling knowing how to interface with another device or a specific protocol. These types of errors are the most difficult to find as they are due to a 3rd party device or from missing information. For example if we were making an FPGA core which reads from a temperature sensor that has an 8 bit temperature value, if we thought the temperature IC returned a 10 bit value and tried to read that we would get incorrect results. This is especially hard to track down, as if you thought a device was 10 bit instead of 8 bit, you would have also made it 10 bit in the simulator in which case it would have passed. To find these kinds of issues you need methods to debug the FPGA while it is running, these methods include making use of the on board LEDs, UART communication during runtime or even logic analyzers / oscilloscopes, we will go over using the on board LEDs to display data as well as sending things from the FPGA to the computer over UART. ## UART In order to use the onboard UART debugger we need to implement our own UART transmitter and receiver modules, which gives us a good test case to go through all the debugging methods listed above. But before we get into the implementation, let's go over the protocol itself so we understand what we are going to be doing. ### The Protocol With UART you send data from one device to another over a single wire. You send 1 start bit of data, then an agreed upon amount of data bits (usually 8) and finally a stop bit. There are some more complex configurations, like multiple stop bits, or adding a parity bit as a checksum. But in our case we will be looking at the simple case of 1 start bit, 8 data bits and a stop bit. The data is transferred least significant bit first. &nbsp; Example sending the byte 01010101 or 85 in decimal: ![uart_2](./assets/uart_2.jpg) There is no clock signal to synchronize both sides like in some other common protocols here both sides need to agree in advance on a frequency or \"baud rate\" which is the amount of bits per second and then each side needs to manage their own clocks to meet the desired frequency. Because there is no common clock, one side cannot react to the \"rising edge\" for example of the other sides clock, and there may be some drift between the two devices not to mention that they might have completely different clock speeds which don't exactly line up with the baud rate. So because of this we want the receiver to be able to run at least 8 16 times faster then the agreed upon baud rate. That way the \"latest\" the receiver would realize the transmission started would be an 1/8th or 1/16th of the bit rate in, and so even if there is a drift due to the different clocks, you should still be able to read all 10 bits of the transmission successfully. The UART on the Tang Nano 9K runs in full duplex mode which means it uses two lines like the one above, allowing for each to device to both send and receive data at the same time. Other than the direction, the protocol is exactly the same for both directions, there is no single side which acts as the controller or schedules when to send or receive they both can decide to send data whenever they want over the appropriate line. ### The Implementation For this project we will need to connect to the onboard debugger's UART pins, which will transfer the UART data we send it to the computer over USB. So lets start with the constraints file. In a new project let's create a file called `tangnano9k.cst` ```v IO_LOC \"clk\" 52; IO_PORT \"clk\" PULL_MODE UP; IO_LOC \"led[0]\" 10; IO_LOC \"led[1]\" 11; IO_LOC \"led[2]\" 13; IO_LOC \"led[3]\" 14; IO_LOC \"led[4]\" 15; IO_LOC \"led[5]\" 16; IO_LOC \"btn1\" 3; IO_LOC \"uart_tx\" 17; IO_PORT \"uart_tx\" IO_TYPE LVCMOS33; IO_LOC \"uart_rx\" 18; IO_PORT \"uart_rx\" IO_TYPE LVCMOS33; ``` The clock and leds are the same as in the previous article's counter example. The btn `pin` is connected to the onboard button so that we can use it for sending data and the `rx` and `tx` pins of the uart are pins 17 and 18 from bank 2 of the FPGA. We will receive data from the computer over pin 17 `rx` and we will send data over pin 18 `tx`. ![uart_pins_1](./assets/uart_pins_1.jpg) You have to follow their path a bit in the schematic, but you can see that these two pins end up going to the BL702 which is the onboard Sipeed debugger. Another thing to notice about the buttons is that it is connected to 1.8V on idle through a 10K pull up, and is pulled low when pressed. So when using it we need to remember it is an active low signal. ![button](./assets/button.jpg) Now that we have the constraints file, lets setup our verilog file `uart.v`: ```v `default_nettype none module uart #( parameter DELAY_FRAMES 234 // 27,000,000 (27Mhz) / 115200 Baud rate ) ( input clk, input uart_rx, output uart_tx, output reg [5:0] led, input btn1 ); localparam HALF_DELAY_WAIT (DELAY_FRAMES / 2); endmodule ``` Here we are declaring a new module which receives the clock pin, uart receive and transmit pins, the leds and the button we configured. The brackets that go before the inputs is an optional section where you can define parameters that can be changed by files that use this module. They are like `localparam`s that we used in the previous article just configurable from the outside. In our case we have 1 parameter of this type called `DELAY_FRAMES` which is the number of clock pulses needed to reach the desired baud rate. In our example we will use one of the standard baud rates of 115200 bits per second, dividing the 27Mhz by this number of bits gives us a number a little higher than 234. So each transmission bit should take a bit over 234 clock pulses. The thing is we don't really want to measure exactly at the bit transition, because like we saw there can be a bit of drift between the clocks, and we are also not exactly counting the correct number of pulses (we would need an extra 0.375 clock pulses for each bit). The safer option is to read the bit directly in what we consider the middle of the bit pulse, that way if we are a bit early or a bit late in terms of clock pulses we will still fall into the correct bit and read the correct value. That is why we have another `localparam` which is simply the full `DELAY_FRAMES` divided by two so we can get to the middle of these pulses. Next we will need some registers: ```v reg [3:0] rxState 0; reg [12:0] rxCounter 0; reg [2:0] rxBitNumber 0; reg [7:0] dataIn 0; reg byteReady 0; ``` The FPGA doesn't do the same thing every clock pulse like in the example of the counter from the previous article. Here we need to remember where we are in the UART cycle and react accordingly, a common way of doing this is with a state machine. That way we can start in an \"idle\" state when we see the start bit we can start receiving data and go to the \"read data\" state and then once we finish the bit we can go to the \"stop bit\" state finally returning back to \"idle\" ready to receive the next communication. The `rxState` register can hold in which state we currently are in. Next we know we need to count clock pulses (as we saw 234 clock pulses is 1 UART bit frame) so we have another register `rxCounter` for counting clock pulses. Next we have `rxBitNumber` which can keep track of how many bits we have read so far, this way we can know when the data is finished and when we will be moving to the stop bit. The next register is an 8 bit register which will store the byte received, and finally we have `byteReady` which is a flag register that will tell us when we have finished reading a byte and the value of `dataIn` is valid to use. Next let's define which states our state machine will have. ```v localparam RX_STATE_IDLE 0; localparam RX_STATE_START_BIT 1; localparam RX_STATE_READ_WAIT 2; localparam RX_STATE_READ 3; localparam RX_STATE_STOP_BIT 5; ``` Like mentioned above, we start in an idle stage, when there is a start bit we need to wait a certain amount of time, then 8 times we can alternate between reading a bit, and waiting for the next bit. Finally we have a state for the stop bit so we can again wait for it to complete and go back to being idle. I will first show the complete implementation and then we can go through each of the states to explain them: ```v always @(posedge clk) begin case (rxState) RX_STATE_IDLE: begin if (uart_rx 0) begin rxState < RX_STATE_START_BIT; rxCounter < 1; rxBitNumber < 0; byteReady < 0; end end RX_STATE_START_BIT: begin if (rxCounter HALF_DELAY_WAIT) begin rxState < RX_STATE_READ_WAIT; rxCounter < 1; end else rxCounter < rxCounter + 1; end RX_STATE_READ_WAIT: begin rxCounter < rxCounter + 1; if ((rxCounter + 1) DELAY_FRAMES) begin rxState < RX_STATE_READ; end end RX_STATE_READ: begin rxCounter < 1; dataIn < {uart_rx, dataIn[7:1]}; rxBitNumber < rxBitNumber + 1; if (rxBitNumber 3'b111) rxState < RX_STATE_STOP_BIT; else rxState < RX_STATE_READ_WAIT; end RX_STATE_STOP_BIT: begin rxCounter < rxCounter + 1; if ((rxCounter + 1) DELAY_FRAMES) begin rxState < RX_STATE_IDLE; rxCounter < 0; byteReady < 1; end end endcase end ``` ### The UART Receiver States The first state is the idle state: ```v RX_STATE_IDLE: begin if (uart_rx 0) begin rxState < RX_STATE_START_BIT; rxCounter < 1; rxBitNumber < 0; byteReady < 0; end end ``` Here we have nothing to do, we are just waiting for the UART `rx` line to be pulled low signifying a start bit. If the line has been pulled low, we set the counter to be equal to 1 to include the current \"clock pulse\" in the UART bit frame and we reinitialize the bitNumber and set the `byteReady` flag back to zero to signify that the `dataIn` register should not be used as we are in the middle of reading data to it. ```v RX_STATE_START_BIT: begin if (rxCounter HALF_DELAY_WAIT) begin rxState < RX_STATE_READ_WAIT; rxCounter < 1; end else rxCounter < rxCounter + 1; end ``` We would like to read the data in the middle of each uart bit, so during the start bit we won't wait a complete bit frame and then read, we will wait a half bit frame and then every 1 uart bit (234 clock pulses) we can read so we will be exactly in the middle. Here we are initializing the counter to 1 since registers take an extra clock pulse to update, so we account for that 1 pulse. ```v RX_STATE_READ_WAIT: begin rxCounter < rxCounter + 1; if ((rxCounter + 1) DELAY_FRAMES) begin rxState < RX_STATE_READ; end end ``` This next stage is merely waiting the 234 clock pulses for the next bit we can read. Since we are already have a half uart bit offset from the previous state we will be in the middle of the signal ready to read after this. Here we are using another method to account for the register delay, we can add 1 when comparing. ```v RX_STATE_READ: begin rxCounter < 1; dataIn < {uart_rx, dataIn[7:1]}; rxBitNumber < rxBitNumber + 1; if (rxBitNumber 3'b111) rxState < RX_STATE_STOP_BIT; else rxState < RX_STATE_READ_WAIT; end ``` In the read state we are clearing the counter to 1, shifting one bit into the dataIn register, incrementing the bitCounter so we can keep track of how many bits we have read so far. If we are already on `rxBitNumber` 7 or 111 in binary we can go to the stop bit and the entire byte has been read, if not we can go back to the read wait state and wait for the next bit. This syntax for bit shifting is actually syntax for concatenating bits. You can use it for example to set a register, the order of the bits is from most significant to least significant. So for example if we do the following: ```v reg [4:0] demo {1'b1,1'b0,2'b110} ``` It would store 10110 in binary or 22 in decimal. In our example we are doing the following: ```v dataIn < {uart_rx, dataIn[7:1]}; ``` Which means the new bit will be placed as the most significant bit, and then we will take the top 7 bits as the first seven bits, essentially moving them all one over, losing the bit at index 0. Internally this creates what is called a shift register since the output of the last bit (bit 7) is connected to the input of bit 6, and bit 6's output is connected to the input of bit 5, etc. Since UART sends the data least significant bit first, we shift the bits in from the most significant bit, so that after shifting 8 times it will end up at the other side and be the least significant bit. ```v RX_STATE_STOP_BIT: begin rxCounter < rxCounter + 1; if ((rxCounter + 1) DELAY_FRAMES) begin rxState < RX_STATE_IDLE; rxCounter < 0; byteReady < 1; end end ``` The final state is the stop bit state and like the read wait we are simply waiting 234 frames after which we are going back to the idle state and setting the `byteReady` flag bit to 1. At this point we should have a working UART receiver, but we wont be able to see that anything is being received. So let's add another `always` block which will react to the data being ready and display the data (or 6 bits at least) on the leds. ```v always @(posedge clk) begin if (byteReady) begin led < ~dataIn[5:0]; end end ``` This block runs in parallel to the UART receiver and will update the LED's register on every clock pulse that the data is ready. We are inverting because the LEDs light up when a bit is set low. ### Testing our Module Now before running this on the FPGA let's look at the first form of debugging which is simulation and visual logic debugging. The way we do this is with Icarus Verilog or iVerilog and VCD files. We already set these up along with a plugin for visual studio code allowing us to view them. To get started we need to create another verilog module known as a test bench which will define the simulation. So create another verilog file called `uart_tb.v` with a new module: ```v module test(); reg clk 0; reg uart_rx 1; wire uart_tx; wire [5:0] led; reg btn 1; uart #(8'd8) u( clk, uart_rx, uart_tx, led, btn ); endmodule ``` This is a new module named test which simply doesn't receive any outside inputs and instead creates all the inputs that the module we want to test requires and creates an instance of that module. So here we are creating a register for the clock the uart rx and tx pins the wires and the button. This isn't always true but as a general rule of thumb I use registers if it is an input into the module to drive the value and if it is an output I use a wire as the module itself will drive the value. You can also see that we are defining an override for the `DELAY_FRAMES` parameter. The `#()` is for the parameters and we don't want to actually need to look at 234 frames of clock pulses in our simulation so I lowered it to 8 clock pulses. Next we need a way to simulate the clock signal. This can be done like follows: ```v always #1 clk ~clk; ``` The `#number` (`#1`) is a special simulation syntax from iverilog that allows us to delay something by a certain number of time frames. By saying each time interval the clock alternates, we are saying the clock cycle is 2 time units (1 high cycle and 1 low cycle is 1 clock cycle). So this loop will wait 1 time unit and toggle the clock register. The next simulation specific feature I want to go over is the `$display` and `$monitor` commands. They are similar to a `printf` or `console.log` where they print out a string optionally injecting variables into it. The difference between display and monitor, is that display will only print the value out once, monitor will print it out, and then reprint it out any time the value changes. So to simulate the UART transmission we can do the following: ```v initial begin $display(\"Starting UART RX\"); $monitor(\"LED Value %b\", led); #10 uart_rx 0; #16 uart_rx 1; #16 uart_rx 0; #16 uart_rx 0; #16 uart_rx 0; #16 uart_rx 0; #16 uart_rx 1; #16 uart_rx 1; #16 uart_rx 0; #16 uart_rx 1; #1000 $finish; end ``` We start by printing a message, then we track the values of the leds and inject their value by using the `%b` which means print the binary representation of this field, we could have also used `%h` for hex representation `%d` for decimal and `%s` for string representation, among others. After that we send the start bit by pulling the line low, then send 8 data bits and finally the stop bit. We delay by 16 time frames or 8 clock cycles as that is what we set `DELAY_FRAMES` to be. `$finish` stops the simulation, so after 1000 more time frames we stop the simulation. For visually debugging the logic we can add another block to dump a VCD file. ```v initial begin $dumpfile(\"uart.vcd\"); $dumpvars(0,test); end ``` `$dumpfile` chooses the name of the file, and `$dumpvars` choosing what to save and how many levels of nested objects to save. By sending 0 as the number of layers it means we want all nested layers (which will include our uart module), and by sending the top module test it means store everything and all child wires / registers. To run this now we need to run in a terminal from the project directory: ```bash iverilog o uart_test.o s test uart.v uart_tb.v vvp uart_test.o ``` The first one generates a simulation based on the verilog files we sent it, the ` s` sets what is the `top` or main module being run and ` o` sets the simulation executables name. Ones finished we can run the simulation with the second line and it will produce the following output: ```bash Starting UART RX VCD info: dumpfile uart.vcd opened for output. LED Value xxxxxx LED Value 011110 ``` We can see it creating the VCD file as well as printed our message and the state of the led register. The initial value is `xxxxxx` because we did not initialize it, and `x` represents an unknown value. Once the full byte has been read in, the register gets updated with the inverted value of the first 6 bits. Simulation wise our program looks good, now let's take a look at the VCD file. Opening it in Visual Studio Code once you have the plugin installed will open up a UI that looks something like the following: ![uart_vcd](./assets/uart_vcd.jpg) By clicking on \"Add Signals\" you can add any of the wires or registers to the UI. In our example let's add the clock, uart_rx wire, rx state and &nbsp;led value. Once added you should have something like the following: ![debug_rx](./assets/debug_rx.jpg) If we zoom in on the start bit and first data bit: ![debug_rx_start](./assets/debug_rx_start.jpeg) We can see the state starts in idle, One clock cycle after we go to the start bit state where we wait the remainder of the first half cycle. Since we defined each uart bit to take 8 clock cycles we wait here for 4 clock cycles and move to the read wait stage. There we wait the full 8 clock cycles and move to read a bit, going back to the read wait stage one clock cycle later. From the simulation it looks like our module is working. But if we had an issue, for example we forgot to clear the counter in the read state. We would see that after the first bit was read we would never leave read wait stage. ![stuck_in_read_wait](./assets/stuck_in_read_wait.jpg) Or if we made the counter too small for example: ```v reg [1:0] rxCounter; ``` which can only store up to the number 3, if we needed it to count to 8 it wouldn't be able to: ![register_too_small](./assets/register_too_small.jpg) In both of these cases taking a look at the `rxCounter` we would see something going on, like here we can see that the register rolls over back to 0 after 3 since there are no more bits and as a result we get back stuck in the start bit state. This is also why you should also test your module with the real values. We changed DELAY_FRAMES to 8 to make it easier to follow step by step. But to make sure we don't have this problem with register sizes we would need to also test with the correct settings. Now to run it on the Tang Nano 9K, lets create a makefile to make it easier: ```makefile BOARD tangnano9k FAMILY GW1N 9C DEVICE GW1NR LV9QN88PC6/I5 all: uart.fs # Synthesis uart.json: uart.v \tyosys p \"read_verilog uart.v; synth_gowin top uart json uart.json\" # Place and Route uart_pnr.json: uart.json \tnextpnr gowin json uart.json freq 27 write uart_pnr.json device ${DEVICE} family ${FAMILY} cst ${BOARD}.cst # Generate Bitstream uart.fs: uart_pnr.json \tgowin_pack d ${FAMILY} o uart.fs uart_pnr.json # Program Board load: uart.fs \topenFPGALoader b ${BOARD} uart.fs f uart_test.o: uart.v uart_tb.v \tiverilog o uart_test.o s test uart.v uart_tb.v test: uart_test.o \tvvp uart_test.o # Cleanup build artifacts clean: \trm uart.vcd uart.fs uart_test.o .PHONY: load clean test .INTERMEDIATE: uart_pnr.json uart.json uart_test.o ``` This is very similar to the previous makefile we made, just with the added target to test using `iverilog` and also a target called `clean` which will delete some of the artifacts. So you can run `make load` to program the Tang Nano and then we should be able to view the data being sent to it over the LEDs. To open a serial terminal we can use tabby. Under the settings, if you go to \"Profiles &amp; Connections\" under the advanced tab and select \"Serial\", we can define the settings for our device: ![navigation](./assets/navigation.jpg) We need to select the serial device since the Tang Nano has two, 1 for JTAG and 1 for UART (which is usually the serial device with the higher number). Inside we need to also set the baud rate which we said is 115200 ![serial_settings](./assets/serial_settings.jpg) I also turned on Local echo so it will also print what we type, under the \"Advanced\" tab here we can see that there is 1 stop bit and 8 data bits. You can save this configuration and then under the profiles tab you can run the profile for the serial device chosen. You should see that you are connected and by pressing keys on the keyboard you should see the LEDs update. ## Transmitting Data Sending data is even more powerful in debugging since we can send things happening at runtime to a serial terminal to gain visibility. For example in our case, you can send back what you think you received over UART, if we saw bits being repeated, or bits missing we could know that the baud rate is too slow or too fast accordingly. Also very handy for dumping memory or sensor values when interfacing with other devices. The transmit side is very similar to the implementation of the receiver we did above, except that we don't want to count from the middle of the pulse, the transmit side has to change the line at the beginning of each bit frame. Let's start by adding some registers for the transmit side: ```v reg [3:0] txState 0; reg [24:0] txCounter 0; reg [7:0] dataOut 0; reg txPinRegister 1; reg [2:0] txBitNumber 0; reg [3:0] txByteCounter 0; assign uart_tx txPinRegister; localparam MEMORY_LENGTH 12; reg [7:0] testMemory [MEMORY_LENGTH 1:0]; ``` Like on the receiver side, we have a register to keep track of the tx state machine, we have a register for counting clock cycles. `dataOut` stores the byte being sent currently and `txPinRegister` is just a register to store the current value that should be attached to the `uart_tx` pin. The last two registers keep track of which bit we are currently sending, and the next is for which byte. In our example we will be sending a message from memory, so we need to keep track of the current byte. The `assign` statement connects the `uart_tx` wire to the register we created and the last two lines define a new \"memory\" where each cell is 8 bits long, and in our example we have 12 total cells. ```v initial begin testMemory[0] \"L\"; testMemory[1] \"u\"; testMemory[2] \"s\"; testMemory[3] \"h\"; testMemory[4] \"a\"; testMemory[5] \"y\"; testMemory[6] \" \"; testMemory[7] \"L\"; testMemory[8] \"a\"; testMemory[9] \"b\"; testMemory[10] \"s\"; testMemory[10] \" \"; end ``` This next code initializes the memory. There are also verilog commands that load in memory from a file, so when working on bigger memory blocks instead of initializing one byte at a time we could read it all from a binary or hex file, we will explore this more in a future article. Next let's define the states of our state machine. We don't have an extra \"wait\" stage here, again because we are not offsetting to the middle of the frame like when reading. We do have an extra stage at the end to debounce the button, since we will be using the button to determine when to send data. ```v localparam TX_STATE_IDLE 0; localparam TX_STATE_START_BIT 1; localparam TX_STATE_WRITE 2; localparam TX_STATE_STOP_BIT 3; localparam TX_STATE_DEBOUNCE 4; ``` ### The Transmit States ```v TX_STATE_IDLE: begin if (btn1 0) begin txState < TX_STATE_START_BIT; txCounter < 0; txByteCounter < 0; end else begin txPinRegister < 1; end end ``` The idle state waits for the button to be pressed (which will make it go low) at which point we will move to the start bit state. If the button is not pressed we set the `uart_tx` to be high as in UART we have a high idle state. ```v TX_STATE_IDLE: begin if (btn1 0) begin txState < TX_STATE_START_BIT; txCounter < 0; txByteCounter < 0; end else begin txPinRegister < 1; end end ``` The start bit is a low signal for `DELAY_FRAMES`, once reached we put the next byte we need to send into `dataOut` and reset the `txBitNumber` back to 0. ```v TX_STATE_WRITE: begin txPinRegister < dataOut[txBitNumber]; if ((txCounter + 1) DELAY_FRAMES) begin if (txBitNumber 3'b111) begin txState < TX_STATE_STOP_BIT; end else begin txState < TX_STATE_WRITE; txBitNumber < txBitNumber + 1; end txCounter < 0; end else txCounter < txCounter + 1; end ``` The write state is very similar, except instead of setting the tx pin to low, we set it to the current bit of the current byte. When the frame is over we check if we are already on the last bit, if so we go to the stop bit state, otherwise we increment the bit number and keep the current state of `TX_STATE_WRITE`. ```v TX_STATE_STOP_BIT: begin txPinRegister < 1; if ((txCounter + 1) DELAY_FRAMES) begin if (txByteCounter MEMORY_LENGTH 1) begin txState < TX_STATE_DEBOUNCE; end else begin txByteCounter < txByteCounter + 1; txState < TX_STATE_START_BIT; end txCounter < 0; end else txCounter < txCounter + 1; end ``` The stop bit is a high output bit, after waiting `DELAY_FRAMES` we check if there are any other bytes to send, if there are, we go back to send another start bit and the cycle will repeat for the next byte. If not we go to the debounce state. ```v TX_STATE_DEBOUNCE: begin if (txCounter 23'b111111111111111111) begin if (btn1 1) txState < TX_STATE_IDLE; end else txCounter < txCounter + 1; end ``` Here we are just waiting a minimum time (about 10 ms) on top of the sending time, and making sure the button is released after this time. This is to ensure that for each button press we only get one transmission event. Press on \"FPGA Toolchain\" > \"Build and Program\" or Run `make load` to reprogram the Tang Nano 9K and reopen the serial terminal. You should see that every time you press the button the FPGA should send the message we stored in memory over UART. <img src \"./assets/uart_transmit.jpg\" alt \"uart_transmit\"> For sending data that isn't ascii, you have a few options, the first being you can setup in tabby to print the data out in hex, and then manually decode it, or you can convert the data on device. So for example you can have another module which takes a number and converts it into text by encoding each digit into ascii. As to not make this article too long, we will cover these conversion methods in another article. ## Interacting Programmatically Serial terminal is great for quickly debugging or viewing data, but sometimes you need some processing on the data on the computer side, or you may just want to use the UART to communicate / control an application on one of the sides. To do this we need to open the serial port programmatically. We will be looking at a simple javascript example using node.js and the serialport library. To install the library run the following from a terminal in your project directory: ```bash npm i serialport ``` This will install the library we can then create a test script to print out the serial devices it sees, so create a file for example called `list devices.js`: ```javascript const {SerialPort} require('serialport'); SerialPort.list().then(console.log); ``` and then you can run it with `node list devices.js` you should see something like the following: ![uart_devices](./assets/uart_devices.jpg) With the `path` for the device we can write a simple program to interact with the tang nano: ```javascript const {SerialPort} require('serialport'); const tangnano new SerialPort({ path: '/dev/tty.usbserial 2101', baudRate: 115200, }); let counter 0; tangnano.on('data', function (data) { console.log('Data In Text:', data.toString()); console.log('Data In Hex:', data.toString('hex')); const binary data.toString().split('').map((byte) > { return byte.charCodeAt(0).toString(2).padStart(8, '0'); }); console.log('Data In Binary: ', binary.join(' ')); console.log(\"\\n\"); counter + 1; tangnano.write(Buffer.from([counter])); }); ``` We start by importing the library, then we initialize our device by sending the correct path and baud rate. Next we initialize a counter variable which we will use to count the number of transmissions. The next block will run every time there is a new message from the tang nano over the serial port. In this example we will simply print out the data in multiple formats as an example, and the final two lines increment the counter and send it to the tang nano. ![uart_program](./assets/uart_program.jpg) Running the script with you should something like the above, also see every time you press the button the LEDs count up in binary since they are connected to the byte being sent over UART and we are sending the counter. To exit the application you can press `ctrl c` which will stop the process to regain control over the terminal. ## Conclusion In this article we created our own UART module and went over some common issues and debugging methods. In the next article we will take a look at using a screen as another method of displaying data or relaying information from the FPGA. For those that made it this far I would like to thank you, and I hope you enjoyed reading. As always the code is available <a href \"https://github.com/lushaylabs/tangnano9k series examples\">here(github)</a>. And if you have any questions or comments feel free to leave them below or contact me on twitter <a href \"https://twitter.com/LushayLabs\">@LushayLabs</a>."},"/hardware/zh/tang/Tang-Nano-9K/examples/lushaylabs/4_creating_a_text_engine/creating_a_text_engine.html":{"title":"Tang Nano 9K SSD1306 OLED 显示字符","content":" title: Tang Nano 9K SSD1306 OLED 显示字符 keywords: FPGA, Tang, Nano, 9K update: date: 2023 03 15 version: v0.1 author: wonder content: 新建文档 [原文链接](https://learn.lushaylabs.com/tang nano 9k creating a text engine/) In the previous article ([here](./../3_oled_101/oled_101.html)) we developed a screen driver core which allows us to render pixels onto an OLED screen. In this article we will be building a text engine on top of our pixel driver to give us an easy abstraction for rendering text to pixels. ## Drawing Text In order to draw text we need two things: 1. a way to map characters to screen pixel positions 2. some conversion between letters and pixels or how the letters look. For mapping characters to the screen we can decide on any arbitrary mapping, our OLED panel is 64 pixels tall and we store data in 8 bit vertical bytes so to make things easy we can say we have 8 rows to work with. Going smaller than this means that a single byte update to the screen may contain multiple rows of text which would complicate the design a bit. Even 8 rows would make the text pretty small, so for our example let's divide the screen into 4 rows of text this would mean that each character could be up to 16 pixels tall. As for the width of each character we have a total of 128 pixels so if we make each character 8 bits wide we can store a maximum of 16 characters per row. ![characters](./assets/characters.jpg) So now with the mapping decided on, if we wanted to put the letter D in the 4th character position on the first row we know the top row of the character is 8px * 4th character maps to pixel columns 31 39 and the bottom row is pixel columns 159 167 (add 128 since we need to go down one full line). Each character will be drawn in two OLED pixel rows where in each row we update 8 of the 16 vertical pixels in a column. We now know which columns to put the letter D in now but what is the actual column of pixels we would like to send to draw the letter D. We need to decide on how the characters look to know how which pixels need to light up. ## Designing the Letters A computer knows how to render letters by using font files. Fonts can either be vector fonts where the contents describe vectors to recreate the letter's shape at any size, or they can be bitmap fonts (pixel fonts) where we store a pixel representation of each character at a specific size / sizes. To keep things simple let's use the bitmap option so we don't have to calculate vectors, also we are designing for a specific OLED panel with a specific resolution so we don't need the scalability. Kind of like in the previous example where we drew an image to the screen by storing its pixels into memory here we need to store the pixels for each character into memory. The difference between the two examples is that over there our memory represented the actual screen and stored each individual pixel exactly where it should show up on the screen, we were storing an image. In the case of our font, we are storing the pixels for each character unconnected to the screen dimensions and positioning, and then the mapping logic we discussed above will be in charge of mapping it to the screen. By having this mapping disconnected we are able to dynamically decide what text to draw to the screen and for example reuse the same letter multiple times. Luckily we don't need to create these fonts ourselves and pixel font tools like <a href \"https://www.pentacom.jp/pentacom/bitfontmaker2/editfont.php?id 4677&amp;ref lushay labs\">bitfontmaker2</a> have galleries of fonts created by talented designers and artists. We will be using the amazing <a href \"https://datagoblin.itch.io/monogram?ref lushay labs\">monogram font</a> which is created by <a href \"https://twitter.com/vmenezio?ref lushay labs\">Vinícius Menézio (Twitter)</a> and made free to use by him. **monogram in bitfontmaker2:** ![bitfontmaker2](./assets/bitfontmaker2.jpg) If you choose another font while following along just make sure it fits into our constrains of 16 px height and 8px width, otherwise you will need to adjust our mapping logic. Exporting a font from bitfontmaker will provide a JSON file where for each ascii code we have an array of numbers. Each number represents a horizontal row of pixels, LSB is the left hand side of the image and starting from the top going down. So for example the bottom of this letter \"A\" from the image above would be 68 since it is 1000100 in binary again where the LSB (right most bit) is the left most pixel. ## Converting the Font We have a font JSON file, but the format is not very convenient for us to use as is. These font files store horizontal rows and we need to send the OLED vertical columns. We can create a small node.js script to remap each horizontal row into 8 vertical columns where we store 2 bytes per column giving us the full 16 pixels. ```javascript const fs require('fs'); const bitmaps fs.readFileSync('./fonts/monogram.json'); const json JSON.parse(bitmaps.toString()); const memory []; for (var i 32; i < 126; i + 1) { const key i.toString() const horizontalBytes json[key]; const verticalBytes []; for (let x 0; x < 8; x + 1) { let b1 0; let b2 0; for (let y 0; y < 8; y + 1) { if (!horizontalBytes) { continue; } const num1 horizontalBytes[y]; const num2 horizontalBytes[y+8] 0; const bit (1 << x); if ((num1 & bit) ! 0) { b1 b1 (1 << y); } if ((num2 & bit) ! 0) { b2 b2 (1 << y); } } memory.push(b1.toString(16).padStart(2, '0')); memory.push(b2.toString(16).padStart(2, '0')); } } fs.writeFileSync('font.hex', memory.join(' ')); ``` We start off by loading the JSON font file and parsing it into a javascript object. We then loop over all the characters codes we want to include, which looking at an ascii table we can see that 32 126 is all the standard visible characters including space. ![ascii_table_orig](./assets/ascii_table_orig.jpg) Inside the outer loop which is iterating over characters, we have a for loop to go over each of the 8 columns, and then a for loop for each column to calculate the two vertical bytes. Inside we focus on a specific bit and go over each horizontal row to build up the vertical column. For example we focus on the 3rd bit in each horizontal row which all together form the vertical bytes for the 3rd column. ![rows_to_columns](./assets/rows_to_columns.jpg) If each of the red boxes is the horizontal rows then the blue box is an example of the top byte for column index 2 and the green box is the second vertical byte for column index 2. After going through all the rows and completing a single column we store the 2 bytes and move onto the next vertical column again going through each of the rows just on the next bit to the right. We already store the bytes in the `memory` array in hex format so the last line simply needs to save it all to a file, in our example called `font.hex`. ## Designing the Text Engine Before we start getting into the actual verilog module, let's go over the general plan for how we can implement this. In the previous article we had a `pixelCounter` register which would go through each of the bytes we needed to update on the screen, and this would act as the address in memory to lookup the relevant byte from our image. There is nothing memory specific though about the implementation. At a high level you can think of it as the screen driver asking for a specific byte by setting the pixel counter (address) and expecting to receive back the byte it needs to send. Memory is one way of mapping an address to a byte, but in our case we will implement a custom module which will take this address and dynamically return a byte, \"dynamically\" creating the image. As we saw in the previous article in order to fully update the screen we need to send it 1024 bytes, which means our pixel counter / address needs to be 10 bits long. For each of the values between 0 1023 we need to know how to decipher: 1. which text row we are on 2. which character in the row 3. which column of the character 4. if we are on the top half of the column or bottom half (again because each vertical column is 16 pixels or 2 bytes). This can be accomplished using our mapping logic and a little understanding of binary. ## Deciphering the Address Before we start splitting characters into rows I think it is more convenient to think of all 4 rows as a single 64 character wide array. So for each OLED pixel address we need to think about which character out of the 64 possible character positions it belongs to. Looking back at the order the OLED pixel counter updates: ![](./assets/byte structure 1.jpg) We can see that we go left to right then drop down to the next row, each two rows is one character we know that the character index has to repeat the last 16 indices twice once for the top row and once for the bottom row. The pattern for character index has to be like the following: ```text 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63 ``` Where each number represents the value for 8 columns. The top row maps to the characters 0 15 then wraps around again to the same numbers to do the bottom row of those characters, then we continue counting the next 16. To accomplish this we need a sub counter for the 8 columns, which once it completes it increments the character index, then after 16 times increments it repeats the same 16 only after which it continues to the next 16. Because all the key numbers are powers of 2 we can simply use the bits of the address to accomplish this. ![address_decoding](./assets/address_decoding.jpg) In binary each bit represents a power of 2, and whenever you have a group of bits that are all 1, and you increment, it overflows to the next bit over and repeats the same cycle over. In our case we want a cycle of 8 for the columns, then for that to repeat in a second cycle of 16, then we need for the entire 16x8 cycle to happen again but without changing the character index, so the next bit after the 16 cannot be connected to character index, and finally we want that hole cycle of 2x16x8 to happen 4 times. So by dividing the bits as per the repeat pattern, we let the natural bit overflow of counting handle everything for us. Just as an example if we take the pixel address of 569 we would get the binary number: 1000111001 splitting it up based on the division above would give us: ```text columnCounter 001 or 1 in decimal characterIndex 100111 or 39 in decimal topRow 0 meaning it is the top row ``` and because there are 16 characters per row we know that character index 39 is the 8th character in the 3rd row. Another way to think of it is that the lower 16 bits of character index are the character number in a row and the top two bits are the row number. ## Implementing the Text Engine Let's start by making some changes to the current screen module to make it receive the data from an outside module instead of from `screenBuffer`. To do this we will output from the module the pixel byte address and we will input the desired pixel data for that address: ```verilog output [9:0] pixelAddress, input [7:0] pixelData ``` For the pixel address we already have the `pixelCounter` variable so we can just connect them: ```verilog assign pixelAddress pixelCounter; ``` And the only other change we need is to update the load data state to take the data from the input parameter instead of from the `screenBuffer`: ```verilog STATE_LOAD_DATA: begin pixelCounter < pixelCounter + 1; cs < 0; dc < 1; bitNumber < 3'd7; state < STATE_SEND; dataToSend < pixelData; end ``` The last line is the new change which sets the `dataToSend` to the data we receive over the new `pixelData` input. Other than that you can delete the two lines we had for the screen buffer: ```verilog reg [7:0] screenBuffer [1023:0]; initial $readmemh(\"image.hex\", screenBuffer); ``` As we no longer need it or the image we were loading. Our screen module is now ready to interface with other modules. So let's get started on the text engine module. Create a new file called `text.v` with the following: ```verilog module textEngine ( input clk, input [9:0] pixelAddress, output [7:0] pixelData ); reg [7:0] fontBuffer [1519:0]; initial $readmemh(\"font.hex\", fontBuffer); endmodule ``` Its inputs are the opposite of what we just defined so that they can connect. Here we are receiving the `pixelAddress` and need to output the data for that pixel. Inside the module we are creating a memory for our font where each index stores a single byte and we have 1520 bytes which is 16 bytes for each of the 95 characters. The next lines loads the `font.hex` file we generated at the beginning into this memory. Next we know how to split up the address from a pixel index to the desired character index column and whether or not we are on the top row: ```verilog wire [5:0] charAddress; wire [2:0] columnAddress; wire topRow; reg [7:0] outputBuffer; ``` We also need a buffer to store the output byte. Connecting these up is simple now that we understand the mapping: ```verilog assign charAddress {pixelAddress[9:8],pixelAddress[6:3]}; assign columnAddress pixelAddress[2:0]; assign topRow !pixelAddress[7]; assign pixelData outputBuffer; ``` The column address is the last 3 bits, the character address is made up of a lower 16 counter and the higher 4 counter for the rows. For the flag which indicates whether we are on the top row or bottom row we can just take a look at bit number 8 where it will be 0 if we are on the top row and 1 if it is the second iteration and we are on the bottom, so we invert it to match the flag name. Last but not least we hookup the `outputBuffer` to the `pixelData` output wires. With all the mapping out of the way let's take a look at how we now convert a letter to pixels. ### Converting a Letter to Pixels Without getting into how we will get the current letter, let's take a look at how we would convert a letter using all the mapping data we just prepared. To get started we can create some more wires to store the current char and the current char we want to display. ```verilog wire [7:0] charOutput, chosenChar; ``` We have two variables for this because our font memory only has values for the character codes 32 126 other character codes would give an undefined behavior. So `charOutput` will be the actual character we want to output, and `chosenChar` will check if it is in range and if not replace the character with a space (character code 32) so it will simply be blank: ```verilog assign chosenChar (charOutput > 32 && charOutput < 126) ? charOutput : 32; ``` If we look back at how we stored our font data, we stored the first column top byte then the first column second byte then the next column top byte and so on. So if we want the letter \"A\" in memory, we know that its ascii code is 65 and our memory starts from ascii code 32 subtracting them gives us the number of characters from the start of memory we need to skip which in this case is 33. We need to multiply this number by 16 as each character is 16 bytes long giving us 528 bytes. Next if we wanted column index 3 we know each column is 2 bytes so we would need to skip another 6 bytes. Lastly once at the column boundary we know the first byte is for the top row and the second byte is for the bottom row of the character, so depending on which we need we optionally skip another byte. In code this looks something like the following: ```verilog ((chosenChar 8'd32) << 4) + (columnAddress << 1) + (topRow ? 0 : 1) ``` We take the character we want to display, subtract 32 to get the offset from start of memory. Multiply by 16 (by shifting left 4 times) to get the start of the character. Add to this the column address multiplied by 2 (again by shifting left by 1) and optionally adding another 1 if we are on the bottom row. This can be used to access the exact byte from the font memory needed: ```verilog always @(posedge clk) begin outputBuffer < fontBuffer[((chosenChar 8'd32) << 4) + (columnAddress << 1) + (topRow ? 0 : 1)]; end ``` With this one line we are mapping the desired character to the exact pixels for the specific column and row. The only thing missing is to know which character to output, but for now if we just add: ```verilog assign charOutput \"A\"; ``` It should simply display the letter A for all character positions. ### Building the project In order to build the project we need another module which will connect our two modules together, let's create a new file called `top.v` which will be our top module: ```verilog module top ( input clk, output ioSclk, output ioSdin, output ioCs, output ioDc, output ioReset ); wire [9:0] pixelAddress; wire [7:0] pixelData; screen scr( clk, ioSclk, ioSdin, ioCs, ioDc, ioReset, pixelAddress, pixelData ); textEngine te( clk, pixelAddress, pixelData ); endmodule ``` As the new top module it needs to receive all the inputs from the constraints file. We then create wires for both the address and data so we can connect them between the two modules. The first module we are defining is an instance of our screen module, and the second is our new text engine. The order doesn't really matter you just need to pass it the parameters in the correct order. By using the same wire variable for both modules it creates the connection between them and allows them to communicate. If using the toolchain manually you can update your `Makefile` to add the new files: ```makefile BOARD tangnano9k FAMILY GW1N 9C DEVICE GW1NR LV9QN88PC6/I5 all: text.fs # Synthesis text.json: top.v text.v screen.v \tyosys p \"read_verilog screen.v text.v top.v; synth_gowin top top json text.json\" # Place and Route text_pnr.json: text.json \tnextpnr gowin json text.json freq 27 write text_pnr.json device ${DEVICE} family ${FAMILY} cst ${BOARD}.cst # Generate Bitstream text.fs: text_pnr.json \tgowin_pack d ${FAMILY} o text.fs text_pnr.json # Program Board load: text.fs \topenFPGALoader b ${BOARD} text.fs f # Generate Simulation text_test.o: text.v text_tb.v top.v screen.v \tiverilog o text_test.o s test text.v text_tb.v top.v screen.v # Run Simulation test: text_test.o \tvvp text_test.o # Generate Font font: font.hex font.hex: \tnode ./scripts/generate_font.js # Cleanup build artifacts clean: \trm text.vcd text.fs text_test.o .PHONY: load clean test .INTERMEDIATE: text_pnr.json text.json text_test.o ``` To make it compile multiple files we basically just need to add the files wherever we had the previous verilog files. So for example when compiling the JSON in the synthesis stage, `read_verilog` used to only receive the `screen.v` file, now it has all three of our verilog files. The rest of the file is as per our standard template just with the added method for generating the font hex file. Running the project now after you generated your `font.hex` file (with `node ./scripts/generate_font.js`) should give you something like the following: ![screen_aaa](./assets/screen_aaa.jpg) ### Displaying Specific Characters We are on the home stretch, we can now display any of the 95 characters, we just need a way to store which character is in each character position. We could do this with a 64 byte memory one byte for each character on the screen, but for cases where you may want multiple modules updating the screen at the same time it is sometimes better to have multiple smaller memories then one big one, allowing different parts of your project to work in parallel. So in our example let's create a module which will represent a single row of text and then we can just instantiate 4 of them to fill up the screen. ```verilog module textRow #( parameter ADDRESS_OFFSET 8'd0 ) ( input clk, input [7:0] readAddress, output [7:0] outByte ); reg [7:0] textBuffer [15:0]; assign outByte textBuffer[(readAddress ADDRESS_OFFSET)]; endmodule ``` So in the same file we can add this module which receives a character address (0 63) and needs to return a byte (representing 1 character) from the 16 bytes in the `textBuffer` for its row. We also have a parameter `ADDRESS_OFFSET` which will allow us to offset the rows by 16 characters. So the first row will output character 0 15 from the buffer for character address 0 15, but the second row needs to output 0 15 while character index will be 16 31 so we will send it 16 as the `ADDRESS_OFFSET` to subtract this difference. The final thing we need here is to initialize the memory. So far we have been loading a file into each of the memories we created, but here we don't have such a file so we need to initialize it manually. ```verilog integer i; initial begin for (i 0; i<15; i i+1) begin textBuffer[i] 48 + ADDRESS_OFFSET + i; end end ``` This will loop through all 16 characters and set an initial value allowing for the toolchain to know what to preprogram into the memory created. We can now go back to our `textEngine` module and add the following instances of our text row: ```verilog wire [7:0] charOutput1, charOutput2, charOutput3, charOutput4; textRow #(6'd0) t1( clk, charAddress, charOutput1 ); textRow #(6'd16) t2( clk, charAddress, charOutput2 ); textRow #(6'd32) t3( clk, charAddress, charOutput3 ); textRow #(6'd48) t4( clk, charAddress, charOutput4 ); ``` We create 4 instances each offset 16 from the previous and we pass each one it's own output line for the character it thinks should be on screen. We can then replace the old assignment to `charOutput` with the following: ```verilog assign charOutput (charAddress[5] && charAddress[4]) ? charOutput4 : ((charAddress[5]) ? charOutput3 : ((charAddress[4]) ? charOutput2 : charOutput1)); ``` Here we are multiplexing the 4 values and only looking at the value from the current row. We have already seen that the top two bits of the character address represent the row number. So if they equal 3 (row index 3 which means both bits are 1) then it is row 4, if the bits are 10 then it is row 3, 01 is row 2 and finally 00 is row 1. Running this now we should see all the rows filled with different characters. ![screen_text](./assets/screen_text.jpg) We can even change the initialization of `textRow` to something specific to better show that each row is handled separately: ```verilog integer i; initial begin for (i 0; i<15; i i+1) begin textBuffer[i] 0; end textBuffer[0] \"L\"; textBuffer[1] \"u\"; textBuffer[2] \"s\"; textBuffer[3] \"h\"; textBuffer[4] \"a\"; textBuffer[5] \"y\"; textBuffer[6] \" \"; textBuffer[7] \"L\"; textBuffer[8] \"a\"; textBuffer[9] \"b\"; textBuffer[10] \"s\"; textBuffer[11] \"!\"; end ``` Running this would give us: ![screen_lushay](./assets/screen_lushay.jpg) ## Conclusion In this article we created a text engine to let us dynamically write strings of text to the screen converting the desired characters to pixels using fonts and mapping the position of each character to the screen pixel positions. With all that said, as dynamic as it converts strings to pixels, the text itself we are displaying is still pretty static. In the next article we will expand on this mini project and go over some methods to dynamically create strings from values and data. Thank you for reading, I hope you enjoyed, if you have any questions or comments feel free to leave a comment below or contact us on twitter <a href \"https://twitter.com/LushayLabs?ref lushay labs\">here</a>. If you would like to purchase any of the components used in this article and support the site you can get them from our store <a href \"https://store.lushaylabs.com/collections/all products?ref lushay labs\">here</a>. And as always all the source code for this entire series can be found on github <a href \"https://github.com/lushaylabs/tangnano9k series examples?ref lushay labs\">here</a>."},"/hardware/zh/tang/Tang-Nano-9K/examples/lushaylabs/6_reading_from_the_external_flash/reading_from_the_external_flash.html":{"title":"","content":""},"/hardware/zh/tang/Tang-Nano-9K/examples/lushaylabs/1_installation_getting_started/installation_getting_started.html":{"title":"Tang Nano 9K 安装上手","content":" title: Tang Nano 9K 安装上手 keywords: FPGA, Tang, Nano, 9K update: date: 2023 02 13 version: v0.1 author: wonder content: 新建文档 原文链接：[https://learn.lushaylabs.com/tang nano series/](https://learn.lushaylabs.com/getting setup with the tang nano 9k/) In this article we will be going over how to get started developing for the Tang Nano FPGA using a fully open source toolchain. We will start with an overview of FPGAs and the toolchain required to develop them, we will then go through setting up your development environment and finish off with a simple example so we can test and verify that everything is working. ## What's an FPGA ? An FPGA is a type of IC that you \"program\" with digital hardware circuits as apposed to microcontrollers or CPUs that you program with software. A CPU has a fixed internal architecture and only understands how to process its own machine codes / assembly language. Developers then compile programming languages into these machine codes and the CPU will run them as it goes through the code. With FPGAs the internal architecture is a blank canvas, you can choose to create a CPU type architecture and design your own assembly language if you like there are even open source architectures like RISC V but you can also decide to custom build your own application specific circuit (ASIC) developing your application in hardware instead of software. A general purpose CPU is convenient in the sense that one design can be used to perform a lot of different tasks its general purpose but the downside is its not very efficient for any specific task. Take for example a single core 2 ghz CPU, even though the clock pulses 2 billion times per second it doesn't mean you can actually do 2 billion things in your application. Each line of code will get converted to many assembly instructions, each of which will be handled serially one at a time and each can take multiple clock cycles. Modern CPUs try to pipeline or parallelize these multiple clock cycles but for the most part you have a lot of overhead. Add on top of that you usually have other things that are running like an operating system which also are scheduled and take clock cycles. On the other hand with FPGAs you are programming your application in hardware, you can react to every clock pulse directly. There is no central processing unit, each part of the application can be handled in parallel, so not only do you actually get the full clock speed, but you get the effect of having as many parallel cores as needed. This also means that with a microcontroller for example, each extra operation that you would like to add to your application will negatively effect all the current operations since they are all fighting for the same resources. In an FPGA unless you specifically want it to block adding new cores / applications to your FPGA has no effect on the existing cores as they are completely separate hardware. So how does it work ? How can an FPGA dynamically reprogram its internal hardware ? At its core an FPGA is made up of lookup tables, flip flops and multiplexers. A lookup table can be thought of as a reconfigurable logic gate, its a prebuilt table where for each set of inputs there is a predefined output. For example a lookup table for an AND gate would look something like this: AND Gate: <table> <tbody> <tr> <th>Input 1</th> <th>Input 2</th> <th>Output</th> </tr> <tr> <td>0</td> <td>0</td> <td>0</td> </tr> <tr> <td>1</td> <td>0</td> <td>0</td> </tr> <tr> <td>0</td> <td>1</td> <td>0</td> </tr> <tr> <td>1</td> <td>1</td> <td>1</td> </tr> </tbody> </table> Usually the lookup tables (LUTs) in an FPGA have more inputs and outputs so they are a bit bigger, but by being able to reprogram these tables you can change the AND gate into an OR gate as follows: OR gate: <table> <tbody><tr> <th>Input 1</th> <th>Input 2</th> <th>Output</th> </tr> <tr> <td>0</td> <td>0</td> <td>0</td> </tr> <tr> <td>1</td> <td>0</td> <td>1</td> </tr> <tr> <td>0</td> <td>1</td> <td>1</td> </tr> <tr> <td>1</td> <td>1</td> <td>1</td> </tr> </tbody> </table> So as you can see in this example by just changing two of the outputs you \"changed\" the internal hardware from an AND gate to an OR gate. Combine these reprogrammable gates with flip flops which allow for storing data and multiplexers which allow for routing connections and you have a method of dynamically \"programming\" the internal electrical circuit. This is a bit of a simplified view, usually FPGAs also come with built in memory/ram, DSPs or even dedicated math functions but at a high level I think the parts that LUTs, flip flops and multiplexers are the core. ## Tang Nano 9K In this series we will be focusing on the Tang Nano 9K FPGA development board (<a href \"https://item.taobao.com/item.htm?id 666055424174\">available in our store</a>) which includes an FPGA from Gowin's LittleBee family the GW1NR 9. This board IMHO currently provides the best bang for your buck both in terms of the FPGA itself number of LUTs / Flip flops / ram and also the development board exposes a good number of IOs and has on board LEDs, buttons and a built in UART debugger and other peripherals. The open source toolchain support is also very good supporting all the features we will be using. Open source toolchain Supported Features by FPGA family： ![supported_features](./assets/supported_features.jpg) For all these reasons, and because of its relatively low price the tang nano 9K has been chosen for this series. ## The Programming Process The process of programming your own core onto an FPGA goes through 3 stages: <ol><li>Synthesis</li><li>Place and Route</li><li>Bitstream Generation</li></ol> ### Synthesis The first step is to take a design written in an HDL (Hardware description language) like Verilog and convert it into primitives which make up the FPGA. In verilog you write your program in terms of modules with registers / connections and logic gates you also have abstractions like conditional statements or math operations. The job of the synthesis tool is to take all this and convert it to primitives like LUTs and flip flops. ### Place and Route Once you have a list of connections and FPGA primitives from the synthesis stage the next step like the name suggests is to map each of the primitives to their physical counterpart. Like to map each of the generated look up tables to one of the physical 8640 internal luts. This step must take into account all the routing requirements when selecting where to place each component, the output of this stage is similar to the output of the synthesis stage, except each of the components are physically mapped. ### Bitstream Generation The third and final step is generating the bits required so that the FPGA itself understands the layout the the place and route stage generated. Each FPGA manufacturer has their own internal format which open source toolchains need to reverse engineer in order to understand the exact format required to program the FPGA. After running these three stages you will have a file which can be programmed onto the FPGA which will reconfigure the internal hardware to match your design ## The Open Source Toolchain The open source toolchain is a collection of open source tools for each of the steps mentioned in the previous section. We have Yosys for synthesis, NextPnR for placing and routing and Apicula which reverse engineered the Gowin architecture and provides the bitstream generation tools. We will also be using openFPGALoader for programming the final bitstream onto the FPGA. We recommend setting up the toolchain with OSS CAD Suite and our VS code extension. OSS CAD Suite is a project maintained by the yosys team which provides pre built binaries for MacOSX, Windows and Linux. Our extensions is a wrapper around these pre built binaries allowing you to visually configure and run the OS toolchain. > If you would prefer to install and use the toolchain manually we have the instructions for that <a href \"https://learn.lushaylabs.com/os toolchain manual installation/\">here</a>. The first step to get this setup is to download and install Visual Studio Code: ### VSCode This is a popular lightweight cross platform editor with many plugins some of which specifically for FPGA development. The editor itself can be downloaded from <a href \"https://code.visualstudio.com/\">here</a>. Once installed, you can open it up and go to the Extensions tab to install plugins. To install our plugin you can search for \"Lushay Code\" or by going to the following <a href \"https://marketplace.visualstudio.com/items?itemName lushay labs.lushay code&amp;ssr false\">link</a>. Besides for that we also recommend these two plugins, although not mandatory we find these useful. 1. <a href \"https://marketplace.visualstudio.com/items?itemName mshr h.VerilogHDL\">Verilog HDL/SystemVerilog </a> provides syntax highlighting support for Verilog 2. <a href \"https://marketplace.visualstudio.com/items?itemName wavetrace.wavetrace\">WaveTrace</a> provides built in waveform viewing which can be used for debugging. With VsCode and the 3 extensions installed the next thing we need is OSS Cad Suite, you can find the latest version download from <a href \"https://github.com/YosysHQ/oss cad suite build/releases\">here</a>. On the release page there are several different versions depending on your OS and CPU architecture. For OS, linux and windows are just called windows and linux, and for MacOSX you need the darwin version. Next you have the architecture, usually either arm or x64, arm is for apple silicon or an arm based linux, x64 is for a standard intel / amd cpus. Download the file for your OS and then extract it somewhere you should now have a folder called `oss cad suite` on your computer. Place this folder wherever you want to keep the toolchain. It is worth noting on windows you don't download a zip but rather a self extracting executable, but it is the same, you just double click it to extract it as a folder called `oss cad suite`. With the folder ready open up VSCode and click on the button on the bottom right hand side called \"FPGA Toolchain\": ![fpga_toolchain_button](./assets/fpga_toolchain_button.jpg) You should receive a popup that says the OSS CAD Suite path is not setup, click on the \"Setup Now\" button and a file browser will appear, you need to select the OSS CAD Suite folder we just extracted you should select the actual folder called `oss cad suite` (the one with the `bin` folder inside). Once selected you have successfully setup the toolchain. ### Ubuntu USB Permission Fix On Ubuntu you will need to give permissions to you user so that we can run openFPGALoader without being root. To do this you need to run the following from a terminal: ```bash curl sSL https://raw.githubusercontent.com/lushaylabs/openfpgaloader ubuntufix/main/setup.sh sh` ``` And then once completed you will need to log out and log back in so that the user permissions take effect and you will need to unplug and replug in the tang nano board. ### Windows USB Driver Fix On windows the default driver does not work with `openFPGALoader` so to get it to work we need to replace the default driver. To do this you need a program called Zadig which can be downloaded <a href \"https://zadig.akeo.ie/\">here</a>. Download the tool and then open it up, once open you need to select \"Options\" &gt; \"List All Devices\" from the top menu to show all connected usb devices. Next in the dropdown you should see two devices: 1. JTAG Debugger (Interface 0) 2. JTAG Debugger (Interface 1) Interface 0 is the JTAG interface `openFPGALoader` needs to program the Tang Nano while Interface 1 is the serial interface used for the UART communication. It is important to leave interface 1 as is and only replace interface 0 here. So select \"JTAG Debugger (Interface 0)\" and underneath you should see it show that it will change the driver to \"WinUSB\" if WinUSB is not selected you can use the up/down arrows to select it. Once selected just the replace driver button and wait a minute or two, once done it should work in openFPGALoader. If you ever want to uninstall this driver and go back to the default driver (for example to use the official gowin IDE) all you have to do is go to \"Device Manager\" select the device called \"JTAG Debugger\" under \"Universal Serial Bus devices\" right click on it and press \"uninstall device\" from the popup also select the checkbox to attempt to remove the driver. Once removed right click on any item in the device manager window and press \"Scan for hardware changes\" this should reconnect the device back with the original driver. ## Other Recommended Software Besides for the toolchain itself there is some other software which can aid in the development of FPGA cores, and will be used throughout this series. ### Node.js During the course of development you may find yourself needing to prepare / convert data or even communicate with the FPGA from your computer. Node.js is just my personal preference and is what I will be using in this series, but any programming language will probably have a way to do the same things if you have a different preference. To install node.js you can either grab the official installer from the <a href \"https://nodejs.org/en/\">node.js site</a> or install using a node version manager like so: **Mac / Ubuntu / Windows WSL** ```bash curl o https://raw.githubusercontent.com/nvm sh/nvm/v0.39.1/install.sh bash nvm install v17.0.1 nvm use v17.0.1 nvm alias default v17.0.1` ``` ### Tabby Tabby is a cross platform terminal which has support for serial terminal which will allow us to communicate over UART with the tangnano9k. Here as well it is a matter of personal preference, I chose to mention tabby since it supports all operating systems and has some extra features like choosing how the data will be read / shown (ascii, hex) and each side can be configured independently. Tabby can be downloaded <a href \"https://tabby.sh/\">here</a> If you only need basic serial support, the Lushay Code extension comes with a basic built in serial console. But I still recommend Tabby since the extra features can be nice. ## Creating a New Project We should now have everything we need to effectively develop an FPGA core. To get started open up your editor (VSCode), from the explorer tab you will have a button to open a folder, click it to choose a new directory that we can use for this project. Once inside you should see your folder in the explorer tab and we can now create some files. Every FPGA project needs at least two files: 1. A file that describes your circuit (in our case a verilog `.v` file) 2. A file that describes the connection between your circuit and your physical board. (in our case a physical constraints `.cst` file) Verilog is an HDL language which is what get's synthesized. Inside the code you will usually want to use specific pins from the actual FPGA, to do this in verilog you create a name for the pin (it can be whatever you want), and then in the `.cst` file you define the mapping of pin name to pin along with other configuration for the pin. So let's start with a simple example which display a binary counter using the on board LEDs. Now onboard we have 6 leds and if each will represent one bit in our counter then it means we can count up from 0 to 63 (binary `111111`). Now our onboard clock frequency is 27 Mhz so counting up every clock pulse would mean the counter would cycle through all the options 428 million times a second, t0o fast to be able to see the counting. So let's say we want it to count once every half a second. Then we would need to wait 13,500,000 clock cycles between incrementing the counter. We can also say that our counting module will require the clock signal on board as input since we will need it to react to clock cycles and we know we want our output to be the status of the 6 leds. So now that we have a general plan, let's create a verilog file called `counter.v` and we can start off with what we know. ```v module top ( input clk, output [5:0] led ); localparam WAIT_TIME 13500000; reg [5:0] ledCounter 0; endmodule ``` This code defines a new module called top with an input called `clk` for the clock signal and 6 outputs called `led`. Again the names here for the inputs and outputs will be mapped to actual pins in the `.cst` file later, so the names can be anything you like. The format for defining an array's size or accessing a group of bits in general is `[MSB:LSB]` which is why 6 bits can be represented as `[5:0]` meaning bit 5 is the most significant bit and bit 0 is the least significant bit, totaling 6 bits. The next line defines a local constant which will be used at compile time, we have already calculated that we will need 13.5 million clock cycles per counter increment in order to reach the desired half second delay. The final line is our actual counter again using the same notation with the `[5:0]` to say it will be a 6 bit wide register. We will also need a counter for the clock cycles. Looking at the binary representation of 13,500,000 we see it needs 24 bits to contain so we can create a counter with the signature `[23:0]` for 24 bits. ```v reg [23:0] clockCounter 0; ``` The next thing we need to do is increment our counters on every clock pulse. This can be done with an `always` block: ```v always @(posedge clk) begin clockCounter < clockCounter + 1; if (clockCounter WAIT_TIME) begin clockCounter < 0; ledCounter < ledCounter + 1; end end ``` The always block starts with it's trigger list or sensitivity list. Essentially what needs to happen for the circuit defined inside to occur. In our case we are saying whenever there is a positive edge on the clock pin (a.k.a clock rise) we want the following to happen. First we will increment the clock counter and then check if we have reached the wait time defined above. If we have reached the wait time then we would like to reset the clock counter to zero and increment the led counter. We don't need to deal with ever resetting the led counter as it has exactly the number of bits as the desired counter so it will automatically roll over back to 0 once it increments 63. It is also worth noting that the `&lt; ` operator is not like a standard assignment operator from most programming languages. This operator sets the value for the input of the flip flop which will only propagate to the output on the next clock signal. This means that even though we increment it on the first line of the block, the value of `clockCounter` will only equal 1 on the next clock pulse, and for the remainder of the current block the value will still be 0. Same thing when we increment the ledCounter, The change will only be seen on the next clock signal. There is a way to immediately assign a value using the blocking ` ` operator instead, but I like to stick only with the non blocking assignment operator `&lt; ` when working with registers, both for simplicity, consistency and I think it is a better practice. The last and final thing to finish our verilog module is to connect the value of our register to the leds. ```v assign led ledCounter; ``` Outside the always block we use the `assign` and ` ` to define the value of wires. Wires (which is the default input/output type) unlike registers don't store values so we need to simply define what they are connected to and they will always equal that value (since they will be physically connected to them). The final code should look like the following: ```v module top ( input clk, output [5:0] led ); localparam WAIT_TIME 13500000; reg [5:0] ledCounter 0; reg [23:0] clockCounter 0; always @(posedge clk) begin clockCounter < clockCounter + 1; if (clockCounter WAIT_TIME) begin clockCounter < 0; ledCounter < ledCounter + 1; end end assign led ledCounter; endmodule ``` The next file we need to create is the `.cst` file where we will need to define the I/Os we used `clk` and `led`. First we will take a look at doing it manually so you can get a sense for how it works under the hood, and then we will take a look at doing it through our VScode extension. To do this manually we need to know some information about the pins. First of all we need to know the pin number. For the GPIO of the board its pretty easy, all the pins are listed in the following image: ![tang_nano_registers](./assets/tang_nano_registers.jpg) So for example the top left pin's number is 38 (IOB31B) and the top right pin (IOR5A) is pin 63, and so on. It's worth noting also that most GPIO are 3.3V but to pay attention that all the BANK3 pins (pin 79 86) are 1.8V pins and should only be used with devices or sources working with 1.8v. But with all that said, in our example we are not using any of the GPIO pins we are using pins of the FPGA which are routed to on board components (the clock and LEDs). Tang Nano 9K Schematic: [Click me](https://dl.sipeed.com/shareURL/TANG/Nano%209K/2_Schematic) Opening up the file we can see a section called \"LED x 6\" defining how the 6 LEDs are connected. ![led_pins](./assets/led_pins.jpg) A side note something thing that can be seen here is that the LEDs are common anode all being supplied power directly from the 1.8 voltage source which means we need to pull our pin down to low (0) in order for the led to light up. But back to what we are looking for. We see the names defined to the connections and then we can see where these references end up on the actual FPGA chip. Above this section we have the FPGA chip itself and we can see they end up as part of bank 3's pins: ![led_pinout](./assets/led_pinout.jpg) More specifically we can see they are pins 10,11,13,14,15,16. Using the same process we can find the clock pin in the xtal (crystal oscillator) section. ![xtal_pinout](./assets/xtal_pinout.jpg) Showing that the pin is pin 52. With that mini investigation complete we would need to create a cst file where we would define the pins like so: ```v IO_LOC \"clk\" 52; IO_PORT \"clk\" PULL_MODE UP; IO_LOC \"led[0]\" 10; IO_LOC \"led[1]\" 11; IO_LOC \"led[2]\" 13; IO_LOC \"led[3]\" 14; IO_LOC \"led[4]\" 15; IO_LOC \"led[5]\" 16; ``` IO_LOC defines a location constraint, meaning we are defining that when placing and routing our design the io called clk must be placed on a specific pin defining its specific location. IO_PORT defines port level constraints like pull ups / pull downs, logic types drive strength etc. Going through our file we define `clk` to be pin 52 with a pull up resistor, and we are defining the 6 bits of our `led` output using the pin numbers we found. It's worth noting we are adding the bit index to them only for convenience so that we can receive them all together instead of 6 separate outputs in verilog. But if we wanted we could have written `IO_LOC \"led1\" 10;` and then in verilog have each LED as a separate output. You can view a little bit more information about this format from the official physical constraints document from Gowin Appendix A. [Gowin Appendix A](http://cdn.gowinsemi.com.cn/UG289.pdf) Or more in depth by searching for the system IO and GPIO specification documents if you would like a more in depth read. To some extent you can also view some of the options in the apicula longvals documentation <a href \"https://github.com/YosysHQ/apicula/blob/master/doc/longval tables.md\">here</a>. ### Constraints with LushayCode With the extension simply create a new file in vscode for example `tangnano9k.cst` and clicking on it you should see something like the following: ![constraints_front](./assets/constraints_front.jpg) Since both the LEDs and the clock are part of the development board they have an included template, so we can simply press \"Add From Template\" and select both the clock and leds. ![selecting_clock](./assets/selecting_clock.jpg) Clicking on \"Add Constraints\" will add them to the current file and you will see them in the table: ![constraints_filled](./assets/constraints_filled.jpg) Just save the file and we are done with the constraints. You can see that the pin numbers are the same as we saw when doing the manual investigation. ## Running the Example Our project is now ready so how do we compile it with the toolchain. To do this you can click again on the \"FPGA Toolchain\" button from our VSCode extension and you should get a dropdown with the different options: ![options_toolchain](./assets/options_toolchain.jpg) Select \"Build and Program\" and if all went well you should now see the tangnano counting up over it's LEDs. ![tangnano_counter](./assets/tangnano_counter.jpg) The only thing is that the counter is inverted. This is due to the fact that the LEDs use a common anode and a value of 0 means to light up not a value of 1. To fix this we can make a small change to our code. To update the verilog code in our example invert the counter so that the leds match the bit status using the `~` operator. The final line of our module should be: ```v assign led ~ledCounter; ``` Re click on \"Build and Program\" from the \"FPGA Toolchain\" button to rebuild and program the FPGA with our fix. ## Conclusion In this article we went through a lot of different topics getting the development environment setup and running a basic example. In the next part of this series we will go more in depth on debugging FPGA projects in order to visually see what's going on internally. All the code from the example is also available on in lushaylabs github repo <a href \"https://github.com/lushaylabs/tangnano9k series examples\">here</a>. And if you have any questions or comments feel free to leave them below or contact me on twitter <a href \"https://twitter.com/LushayLabs\">@LushayLabs</a>."},"/hardware/zh/kvm/NanoKVM/quick_start.html":{"title":"快速上手","content":" title: 快速上手 keywords: NanoKVM, Remote desktop, Lichee, PiKVM, RISCV, tool update: date: 2024 7 4 version: v0.1 author: BuGu content: Release docs update: date: 2024 8 15 version: v0.1 author: BuGu content: Update docs ## 开箱 ![](./../../../assets/NanoKVM/unbox/full_ubox.png) Full版包含 NanoKVM（带外壳，带卡）、KVM B板、USB A to C 线 *2、杜邦线。 ![](./../../../assets/NanoKVM/unbox/lite_ubox.png) Lite版包含 NanoKVM（不带外壳和TF卡） 、散热片。 ## 接口介绍 ![](./../../../assets/NanoKVM/unbox/Interface.png) + **Full 版本可看到三个 USB Type C 接口，名称和功能如下** + HID 接口（也称PC USB），位于 HDMI 接口下方，用于连接主机，模拟键鼠、U盘、RNDIS设备 + AUX 接口，位于 HDMI 接口上方，辅助供电 + KVM B 接口（也称ATX Power），位于网口上方，连接 KVM B 提供电源控制功能 ## 供电 + NanoKVM 支持普通 USB 的 5V 供电，功耗约1W，部分老型号主板可能存在供电电流过小的问题，需要通过 AUX 接口额外供电。 ![](./../../../assets/NanoKVM/unbox/U I W.jpg) + 部分主板 BIOS 可能默认设置为关机 USB 断电，为确保 NanoKVM 常供电，请在 AUX 接口上额外供一路5V电源。 + NanoKVM USB CC 接口下拉5.1K电阻，可使用正规 PD 充电头供电。部分劣质电源未经协商直接输出12V电压，会将NanoKVM直接烧坏。 注：首批内测版 AUX 接口不带 CC 的下拉电阻，无法使用 C C 的 PD 充电头供电，请使用常规 5V USB 电源适配器。 ## 接线 NanoKVM Full版接口示意图如下，Lite版仅包含 USB C、HDMI和网口，可以参考Full版接线。 + 使用一条 USB C to A 数据线连接远程主机和 NanoKVM 的 PC USB 接口（位于 HDMI 接口下方） + 一条HDMI（标准尺寸）连接远程主机和 NanoKVM 的 HDMI 接口 ![](./../../../assets/NanoKVM/unbox/hdmi.png) + 使用网线连接 路由器/交换机 与 NanoKVM + 再使用一条 USB C to A 数据线连接 KVM B 板和 NanoKVM 的 ATX 接口（位于网口上方） 正式版KVM B板自带主板通用的9Pin排母接口，可以直接插在主板上，机箱的开机按键、Power LED 等接口可接到 KVM B 的排针上，参考示意图（此处机箱仅连接开机线）： ![](./../../../assets/NanoKVM/unbox/new ATX B.png) > 注:版本号为30132的KVM B板不能用机箱自带9 Pin排母直接连接板上的排针,需按照上图使用附赠的公对母排线连接 内测版KVM B板与主机9针接口连线如下图，双排排针上下联通，另一排可连接机箱的开机按键、Power LED 等接口 > 注意:早期内测板NanoKVM重启时会短暂拉高RESET控制脚,导致连接的电脑重启,为避免这一问题,请不要连接RESET跳线,后期正式版已修复 ![](./../../../assets/NanoKVM/unbox/old ATX B.png) ![](./../../../assets/NanoKVM/unbox/old ATX B w.png) 注：NanoKVM Cube 不会监控HDD状态 ## 更新 ### 更新镜像 > **Lite 版本需要准备 TF 卡并且烧录镜像后才能开始使用！** Full 版本出厂时已经烧录了镜像，可以跳过此步骤。 镜像会不定期更新。建议更新到最新版本镜像，以获取更好的使用体验。 具体操作方式请参考 [烧录镜像](https://wiki.sipeed.com/hardware/zh/kvm/NanoKVM/system/flashing.html)。 ### 更新应用 新的应用往往带来更多功能或修复某些重要漏洞，建议您将 NanoKVM 应用更新到最新版本，具体操作方式请参考 [更新应用](https://wiki.sipeed.com/hardware/zh/kvm/NanoKVM/system/updating.html)。 2.1.1 及后续版本更新记录：[应用更新记录](https://github.com/sipeed/NanoKVM/blob/main/CHANGELOG.md) ## 基础操作 ### 如何获取IP地址 Full版NanoKVM自带OLED显示屏，联网之后会在显示屏第一行显示IP地址； ![](./../../../assets/NanoKVM/unbox/oled.jpg) Lite版用户请参考[获取IP](https://wiki.sipeed.com/hardware/zh/kvm/NanoKVM/system/updating.html#%E8%8E%B7%E5%8F%96 IP) 注意：1.4.0 版本镜像默认关闭SSH，Lite用户请直接使用 RNDIS IP （10.xxx.xxx.1）登录网页，在设置中即可查看IP ### 查看远程桌面 浏览器直接输入获取的IP，进入登录页面，默认账号密码为admin、admin，登录后强烈建议**先检查更新**（设置 > 检查更新），详细步骤可参考 [更新应用](https://wiki.sipeed.com/hardware/zh/kvm/NanoKVM/system/updating.html)。 Lite版用户，或Full用户重新烧卡登录后页面上无远程画面，请先升级应用后刷新网页，即可开始使用 注：少数版本可能存在无法访问网页/登录后崩溃的情况，请拔出HDMI接口后重新上电，更新为最新的应用后再插入HDMI 注: 建议使用Chrome浏览器，其他浏览器可能出现无法显示画面或无法操作键鼠等兼容性问题 ![](./../../../assets/NanoKVM/unbox/frist_update.png) ### 修改账号密码 **为保障您的信息安全，请在测试功能正常后修改账号密码** ![](./../../../assets/NanoKVM/unbox/unbox_9.png) 注：网页中修改密码后，SSH登录密码将会同步修改（如：网页密码修改为123456, 使用 `ssh root@192.168.xxx.xxx` `123456` 登录） ### ATX电源控制 Full 版套餐内包含了 NanoKVM A/B 板，用于控制和查看主机开关机状态。 + 顶板上的 5V LED（蓝色）指示 NanoKVM 的供电情况； + PWR LED（绿色）为主机的电源指示； + POWER按键作用同主机的电源按键，可以控制主机的开关机； + RESET按键用主机的重启按键，开机状态下按下RESET将强制重启主机 + 网页端也可以查看并控制，参考[用户指南](https://wiki.sipeed.com/hardware/zh/kvm/NanoKVM/user_guide.html)"},"/hardware/zh/kvm/NanoKVM/development.html":{"title":"二次开发","content":" title: 二次开发 keywords: NanoKVM, Remote desktop, Lichee, PiKVM, RISCV, tool update: date: 2024 9 26 version: v0.1 author: BuGu content: Release docs date: 2025 4 10 version: v1.0 author: BuGu content: Update docs NanoKVM除实现KVM功能外还开放了一些数据,用于用户的二次开发,此文档用于描述这些数据的作用,以及开发的注意事项 ## 获取推流相关数据 推流和图像参数位于/kvmapp/kvm文件夹下 + **HDMI 获取的图像原始分辨率** + 图像宽度: /kvmapp/kvm/width + 图像高度: /kvmapp/kvm/height > 示例: 终端查看当前分辨率`echo \"$(cat /kvmapp/kvm/width) * $(cat /kvmapp/kvm/height)\"` + 注: width/height 仅读取,不可写入,kvm_stream 根据该数据实时修改vi参数,自行修改将导致vi子系统无法解析正确图像 + 当两参数中有一个或两个全为0时,表明HDMI线缆拔出 或 HDMI 分辨率正在切换 + width/height 两参数仅在HDMI插入,拔出,或改变分辨率时才能捕获,当 NanoKVM 在开机前插入HDMI线缆,并且HDMI输出非默认1080P分辨率时,vi子系统将无法获取正确的尺寸参数,导致无视频流输出,因此建议用户在第一次开机上电后再插入HDMI,后续每次开机会读取上次关机前保留的HDMI分辨率,故不会受到影响. + **Stream 传输分辨率** + Stream 传输分辨率不同与 HDMI 获取的分辨率,有时为了减小传输数据量,可以设置一个较小的传输分辨率,NanoKVM会相应的对图像缩放后再传输 + 传输分辨率: /kvmapp/kvm/res + 0 : 自动,将跟随 HDMI 原始分辨率 + 480 : 以640*480传输 + 600 : 以800*600传输 + 720 : 以1280*720传输 + 1080: 以1920*1080传输 + 注: 该参数可读可写 > 示例: 终端设置 kvm_stream 以 1280*720 分辨率传输: `echo 720 > /kvmapp/kvm/res` + **Stream 最大传输帧率** + 最大传输帧率: /kvmapp/kvm/fps + 范围: 0 60 + 注: 参数可读可写 > 示例: 终端限制 kvm_stream 最大以 45 fps 传输: `echo 45 > /kvmapp/kvm/fps` + **Stream 当前传输帧率** + 当前传输帧率: /kvmapp/kvm/now_fps + 范围: 0 60 + 注: 参数只读 > 示例: 查看当前stream分辨率: `cat /kvmapp/kvm/now_fps` + **查看硬件版本** + NanoKVM有不同的版本,版本之间硬件有所差异,详情请自行翻阅[原理图](https://cn.dl.sipeed.com/shareURL/KVM/nanoKVM/HDK/02_Schematic),开机脚本将检测硬件差异,并保存在`/etc/kvm/hw`里 + alpha : 早期内测版 NanoKVM Full + beta : 正式版 NanoKVM Full 和 Lite + pcie : NanoKVM PCIe + **network相关配置** + /etc/kvm/server.yaml + 详情参考WiKi >KVM >NanoKVM Cube >网络 + **USB状态获取** + cat /sys/class/udc/4340000.usb/state + configured 已连接 + not attached 未连接 + **HDMI状态获取** + cat /kvmapp/kvm/state + 1：HDMI正常 + 0：HDMI异常 + **ETH状态获取** + cat /sys/class/net/eth0/carrier + 1：网线接入 + 0：网线断开（不准确） + **WiFi存在** + /etc/kvm/wifi_exist 文件存在即为wifi模块存在 + **WiFi状态获取** + cat /kvmapp/kvm/wifi_state + 0：wifi存在但未连接 + 1：wifi已连接 + **打开watchdog（实时）** + touch /etc/kvm/watchdog 打开 + rm /etc/kvm/watchdog 关闭 + **关闭ping功能** + touch /etc/kvm/stop_ping 关闭 + rm /etc/kvm/stop_ping 打开 ## USB HID模拟设备 + 初始化: NanoKVM借助USB Gedget 模拟 USB HID 设备, 在设备开机脚本 `/etc/init.d/S03usbdev` 中完成了键盘,鼠标,触屏的初始化 + 模拟键盘 + 设备: /dev/hidg0 + 报文：8byte： + 格式: 0x000x000xXX0x000x000x000x000x00 + 第四位代表普通按键键值,如 F11: 0x44 + 发送键值后需要及时释放 + 示例: 按下F11按键 ```shell echo ne \\\\x00\\\\x00\\\\x44\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00 > /dev/hidg0 # 按下F11键 echo ne \\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00 > /dev/hidg0 # 释放 ``` + 模拟鼠标 + 设备: /dev/hidg1 + 报文：4byte： + 格式: b8 按键s8 x轴相对位移s8 y轴相对位移s8 滚轮 + 按键 + 左键按下：0x01 + 右键按下：0x12 # 兼容多系统 + 释放：0x00 + 示例: 点按左键 ```shell echo ne \\\\x01\\\\x00\\\\x00\\\\x00 > /dev/hidg1 # 按下左键 echo ne \\\\x00\\\\x00\\\\x00\\\\x00 > /dev/hidg1 # 释放 ``` + 位移 (相对位移) + x/y轴相对位移为带符号数，x正值向右移动，y正值向下移动 + 示例: 右移5格，上移1格 ```shell echo ne \\\\x00\\\\x05\\\\xff\\\\x00 > /dev/hidg1 ``` + 滚轮 + 滚轮为带符号数，正值向下移动 + 示例: 下移1格 ```shell echo ne \\\\x00\\\\x00\\\\x00\\\\x01 > /dev/hidg1 ``` + 模拟触屏 + 设备: /dev/hidg2 + 报文：6byte： + 格式: 按键x轴绝对位置低8位x轴绝对位置高8位y轴绝对位置低8位y轴绝对位置高8位滚轮 + 按键 + 左键按下：0x01 + 右键按下：0x10 + 释放：0x00 + 示例: 点按左键 ```shell echo ne \\\\x01\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00 > /dev/hidg2 # 按下左键 echo ne \\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00 > /dev/hidg2 # 释放 ``` + 位移 (绝对位置) + x/y均为无符号数，(0x0001,0x0001) 代表左上角, (0x7fff,0x7fff) 代表右下角 + 示例: 鼠标移动至屏幕正中间 ```shell echo ne \\\\x00\\\\xff\\\\x3f\\\\xff\\\\x3f\\\\x00 > /dev/hidg2 ``` + 滚轮 + 滚轮为带符号数，正值向下移动 + 示例: 下移1格 ```shell echo ne \\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x01 > /dev/hidg2 ``` ## IO ATX电源控制功能借助IO和外置的KVM B实现，IO和功能对应关系如下 Alpha 版定义（包含早期NanoKVM Cube） 功能 Linux GPIO编号 PWR LED 输入 504 PWR KEY 输出 503 RST KEY 输出 507 Beta 版定义（包含后期NanoKVM Cube和全部的NanoKVM PCIe） 功能 Linux GPIO编号 PWR LED 输入 504 PWR KEY 输出 503 RST KEY 输出 505 + 读取LED状态 (以Beta为例) ```shell cat /sys/class/gpio/gpio504/value # 0 > LED亮 # 1 > LED咩 ``` + 操作电源按钮 (以Beta为例) ```shell # 按下 echo 1 > /sys/class/gpio/gpio503/value # 等待1s sleep 1 # 抬起 echo 0 > /sys/class/gpio/gpio503/value ``` + 操作重启按钮 (以Beta为例) ```shell # 按下 echo 1 > /sys/class/gpio/gpio505/value # 等待1s sleep 1 # 抬起 echo 0 > /sys/class/gpio/gpio505/value ``` + 其他IO：请参考 [LicheeRV Nano GPIO](https://wiki.sipeed.com/hardware/zh/lichee/RV_Nano/5_peripheral.html#LicheeRV Nano%E5%BC%95%E8%84%9A%E5%9B%BE%26amp%3BLinux GPIO%E7%BC%96%E5%8F%B7%EF%BC%9A) 开发 ## 注意事项 + 用户自己构建的程序请不要放在/kvmapp下,每次更新将会重置文件夹内所有内容 + 模拟键鼠操作可能与前端页面操作冲突"},"/hardware/zh/kvm/NanoKVM/user_guide.html":{"title":"用户指南","content":" title: 用户指南 keywords: NanoKVM, Remote desktop, Lichee, PiKVM, RISCV, tool update: date: 2024 7 4 version: v0.1 author: BuGu content: Release docs date: 2024 8 14 version: v1.1 author: BuGu content: Update docs ## OLED界面 ![](./../../../assets/NanoKVM/unbox/oled.jpg) + 显示网线、USB、HDMI 连接状态，连接后图标将反色显示; + IP:连接网线后 NanoKVM 默认自动获取IP，并显示在 OLED 上，若无法Ping通网关，将在IP前显示`!`; + RES: 显示当前传输的分辨率，默认720P + TYPE: 显示传输的方式，支持MJPG 和 H264两种模式 + STREAM: 显示实时传输帧率，系统默认开启了帧差检测（画面静止时停止发送），画面静止时FPS显示为 0 + QUALITY: 显示压缩质量，50 100%，默认为80% + 主界面提供 OLED 休眠功能, 以防止 OLED 烧屏, 短按 BOOT 即可关闭或打开 OLED + `2.1.4`版应用后添加OLED自动休眠功能：在设置中设置休眠时间后，OLED会在设定时间后自动休眠，按下BOOT可以临时唤醒OLED ## 管理页面功能 ![](./../../../assets/NanoKVM/introduce/web_ui.gif) 悬浮栏从左到右依次为：图像设置、屏幕键盘、鼠标样式、镜像挂载、自定义脚本、KVM网页终端、WOL、ATX控制/指示、设置、全屏、隐藏悬浮栏。 ### 分辨率、帧率、图像质量设置 + NanoKVM 支持 1080P、720P、600P、480P 的图像传输，在图像设置 >分辨率中可以选择不同的分辨率。越大的分辨率所占用带宽越大、实时帧率越小。 + 注：此处仅修改图像的传输大小，不会改变 HDMI 输入的图像尺寸，如需修改，请前往主机系统的设置菜单进行设置。 + 帧率设置选项用于修改传输的最大帧率，可以限制网络带宽的占用，但帧率越低，画面越卡，请根据网络情况合理配置。Full版用户在OLED上可看到视频的实时帧率。 + 图像质量选项可以修改画面的压缩比例，当您认为画面较卡，延迟较高时，可以适当调低图像质量。 + 帧差检测 + NanoKVM 默认打开帧差检测功能，即画面静止时停止传输图像，用于节省流量。 + 此功能产生约占用2.5%的CPU占用，从静止到画面变化存在 0.2s 的延迟，点击`显示` >`帧差检测`即可关闭或开启此功能。 ### 虚拟键鼠使用 + NanoKVM 的 USB 接口模拟出了键鼠设备。打开浏览器页面后，系统将自动捕获键鼠输入，并将操作实时同步到 NanoKVM 连接的主机。用户可以选择隐藏鼠标或改变在画面上显示的样式。 + 对于不方便使用键盘的用户，我们提供了屏幕键盘，点击悬浮栏的键盘图标即可唤出屏幕键盘。 ### ISO镜像挂载以及远程装机 + Nano KVM的 USB C 端口除模拟键鼠设备外，还模拟了一个U盘设备，挂载了TF卡内的一部分存储空间，用于装机等需求，该U盘默认格式化为exFAT格式，Full版NanoKVM内置TF卡，模拟出的U盘大小约21G。 + 与普通U盘不同，NanoKVM的虚拟U盘内可同时存放多个镜像，开机之前可以通过 web 页面的选项选择要安装的系统镜像进行挂载。 用户需提前下载待安装的镜像（通常以.iso结尾），将 NanoKVM USB C 插入电脑，将下载好的镜像直接复制到U盘内（可复制多个系统），即可拔出。 按上述步骤连接远程主机与Nano KVM，在浏览器登录系统后，点击光盘图标，选中待安装的系统，即可实现ISO挂载 ![](./../../../assets/NanoKVM/guide/imgsl.png) 接下来开始装机操作，点击`开机（短按）`，迅速按键盘上的F11键（不同主机按键可能不同，请参照主机说明），选择对应的镜像启动并完成装机流程。 ![](./../../../assets/NanoKVM/guide/install.png) 注： + 虚拟U盘功能默认打开，如果不需要可通过点击`设置` >`虚拟U盘`关闭。 + 请先在主机上安全弹出原有的21G虚拟U盘后再挂载镜像,以免数据丢失 + 虚拟U盘也可以当作普通U盘使用，web界面未选中任何镜像时，默认挂载整个21G的虚拟U盘。 + 用户也可使用常规的烧卡方式烧录镜像，不推荐 + 镜像拷入 NanoKVM 的速度受到 USB2.0 传输速度和 SG2002 写卡速度的限制，可能会比较慢，用户可将TF卡取出，插入电脑，[解除隐藏](https://jingyan.baidu.com/article/e4511cf34faece2b845eaf34.html)TF卡的第三个分区，直接将镜像拷入其中。 + 虚拟U盘同时挂载到NanoKVM的 `/data` 目录，用户可在 NanoKVM 终端内直接读写该分区 + 设置中的取消虚拟U盘操作将强制弹出U盘,请先安全弹出U盘后再设置,以免数据丢失 ### 网页终端 + 用户点击悬浮栏的`终端` >`NanoKVM 终端`图标，即可打开网页终端，无需ssh直接访问 NanoKVM 系统 + 当 NanoKVM 断网重连或系统重启后，网页终端界面会提示重新登录，账号`root`，密码`root` ![](./../../../assets/NanoKVM/guide/ssh.png) ### 串口终端 NanoKVM 基于 LicheeRV Nano 构建，RVNano 核心板共有3个串口，UART0默认用于输出系统log，在 NanoKVM Full 版中，引出了 UART1/2，用户可自行拓展功能（第一批内测版仅在外壳处开孔） ![](./../../../assets/NanoKVM/guide/uart_to_3H.jpg) 点击管理页面的`终端`，选择`串口终端`，选择使用的串口，填写波特率，点击开始后即可使用 ![](./../../../assets/NanoKVM/guide/uart1.png) ![](./../../../assets/NanoKVM/guide/uart2.png) 注：串口终端功能使用 WebSSH + picocom 搭建，用法同 picocom ### RNDIS NanoKVM 的 USB 会默认虚拟出 RNDIS USB网卡（从设备），当 NanoKVM 服务异常时可用于系统维护，请参照[这里](https://wiki.sipeed.com/hardware/zh/kvm/NanoKVM/system/updating.html#%E9%80%9A%E8%BF%87 usb rndis %E7%BD%91%E5%8F%A3%E8%8E%B7%E5%8F%96)连接电脑，更多用法请自行探索。 若不使用 RNDIS 功能，可点击`设置` >`RNDIS`关闭。 注: 2.1.5 版本后添加 ncm 方式接，但默认还是 RNDIS ，启用方式：`touch /boot/usb.ncm` 或在 /boot 分区下创建 usb.ncm 空文件 ### ATX电源控制 + 在悬浮栏右侧，有电源和硬盘图标，正常情况下是灰色状态，开机后电源图标变绿。 + 点击电源图标可看到重启键、电源键（长/短按）。 + Full版的ATX控制板受延长线芯数限制，只引出电源、重启按键和电源灯，硬盘灯不亮属正常现象。Lite用户可根据原理图自行扩展。 注： + 正式版 NanoKVM A 硬件保留 WiFi 模块引脚，修改了OLED和部分的ATX引脚，固件会自动检测硬件版本并自适应。 + Lite 版 NanoKVM 不包含 NanoKVM A/B ，固件会直接识别为正式版。 ### 设置 + 切换中英文 + 关于NanoKVM：点击打开Wiki + 检查更新：当有可用更新时，用户可点击更新，约15s左右，网页自动刷新重新登录即可更新完成。 + 2.2.5 应用版本后提供预览更新的功能，打开此选项即可拉取到最新的预览版本。 注意：预览版应用一般包含功能更新、问题修复和性能提升，但仍然有概率会引入新的bug，请谨慎更新。 ### 关于SSH + 2.1.6 版本应用后，SSH支持网页开启和永久关闭，请在 设置 > 设备 > SSH 打开或关闭 + 1.4.0 镜像后，SSH默认关闭 1. 永久关闭：执行`touch /etc/kvm/ssh_stop`即可在NanoKVM下一次开机时开始禁用ssh登录，删除该文件`rm /etc/kvm/ssh_stop`即可解除 2. 临时开启：执行`touch /boot/start_ssh_once`或在 /boot 分区下创建 start_ssh_once 空文件，即可在NanoKVM下一次开机时打开ssh，该文件会自动删除 ### 设置DNS + 如果需要设置DNS列表，请在创建/boot/resolv.conf，这将在启动后强制使用你自己的DNS配置 ### 关于mDNS + mDNS（Multicast DNS）是一种用于在局域网内进行名称解析的协议，使设备能够通过主机名而非 IP 地址相互发现和通信。它允许无需中央 DNS 服务器的情况下，自动发现网络中的服务和设备。 + NanoKVM 使用设备码生成 mDNS主机名，可以尽量保证多设备时主机名不冲突 + NanoKVM 设备名可在设置中修改，重启后即可生效 + mDNS 服务在网络环境复杂时会有较高的CPU占用，影响图像的流畅性，建议不使用时将其关闭：设置 > 设备 > mDNS ### 关于看门狗 + 2.2.2 应用版本后新增看门狗系统，将持续监控server服务的运行，服务异常时将重启系统，默认未开启，可以通过在网页终端执行 `touch /etc/kvm/watchdog` 开启，通过`rm /etc/kvm/watchdog` 关闭 ### 更多功能敬请期待 ## 硬件与结构 ### 拆解 Full 版 NanoKVM 在重新烧卡时需要对外壳拆解，请按下图提示拆开外壳 ![](./../../../assets/NanoKVM/guide/fix1.png) 1. 拆下底部4颗螺丝 2. 借助HDMI和网口将 NanoKVM 推出外壳 3. 取下散热器即可拔出TF卡 ### 内测版和正式版的硬件差别 正式版硬件预留 WiFi 模块相关引脚，修改了 OLED 和 ATX 的引脚分配，如下所示 ![](./../../../assets/NanoKVM/guide/PinDefine.png) 为兼容前后两种硬件，软件上做了自适应设计，内测用户和正式版用户可以放心更新。 ### 重启主机问题 早期内测版 Full NanoKVM 在 reboot 系统时会短暂拉高 RST_SW 引脚，导致连接的主机复位，正式版硬件已修复这个问题。 如果您使用早期内测版 Full NanoKVM 并受次问题的困扰，可以拆机后按上图内测版引脚定义，在 RST_KEY 和 PWR_KEY 上添加1K下拉电阻"},"/hardware/zh/kvm/NanoKVM/faq.html":{"title":"F&Q","content":" title: F&Q keywords: NanoKVM, Remote desktop, Lichee, PiKVM, RISCV, tool ## 异常修复 **以下解决方法都基于最新的应用，如果遇到问题，请先更新应用，若无法在网页端更新，请参照以下步骤完成强制更新：** 1. 参考[这里](https://wiki.sipeed.com/hardware/zh/kvm/NanoKVM/system/updating.html#%E8%8E%B7%E5%8F%96 IP)连接开发板 2. 执行：`python /etc/kvm/update nanokvm.py` > 国外用户可能因为DNS原因下载失败，请在 `/etc/resolv.conf` 添加`nameserver 119.29.29.29`或`nameserver 223.5.5.5`后再试 > 早期版本应用可能不存在该脚本文件，请下载 https://github.com/sipeed/NanoKVM/blob/main/kvmapp/system/update nanokvm.py 解压赋予执行权限后再试 ### 关于密码 1. 更新至 2.1.5 版本应用后，若之前没有设置过网页密码，登录后会提示修改密码，修改密码时，后台的`root`密码也会同步修改成网页密码，若之前已经修改过网页密码，后台`root`密码不会主动修改，请在终端使用`passwd`或网页设置中点击重置密码以修改; 2. 应用版本大于 2.1.5 时，若忘记密码，可以按下机身`BOOT`按键10s以上（NanoKVM Cube的BOOT按键位于USB HID接口右边，PCIe版本BOOT按键可在面板上找到，较老版本的NanoKVM Full可能没有在对应位置开孔，需要拆机操作） 3. 若长按无法重置密码，可能是应用版本小于 2.1.5 ，参考[这里](https://wiki.sipeed.com/hardware/zh/kvm/NanoKVM/system/flashing.html)重新烧录镜像，注意，重烧镜像后会丢失所有配置信息。 ### HID键鼠不工作 1. 使用网页中 \"重置HID\" 功能 2. 部分主机系统对USB键鼠要求较高，需要使用“仅HID”模式，该模式下USB仅模拟键鼠设备，请通过网页鼠标图标中切换该模式 3. 部分主板系统要求HID键鼠设备带有BIOS标识,NanoKVM可在/boot下创建BIOS来启用该功能,执行`touch /boot/BIOS && restart` 4. 检查USB接口是否稳定连接, 可查看 OLED 上 HID 图标是否亮起, 或在网页终端使用 `cat /sys/class/udc/4340000.usb/state`, 如果显示未连接, 则认为 USB 线缆接触不良, 请更换 USB 线缆后再试 ### BIOS 不识别HID键鼠 1. 部分主机系统对USB键鼠要求较高，需要使用“仅HID”模式，该模式下USB仅模拟支持BIOS的键鼠设备，请通过网页鼠标图标中切换该模式 2. 使用网页中 \"重置HID\" 功能 ### 非英文键盘键位错误 + 键盘的键盘布局需要在被控主机系统设置中修改，以Ubuntu+修改法语键盘为例： 设置 >键盘 >输入源 >‘+’ >添加 >搜索\"French\"，添加 ### STA LED 无法正常闪烁 STA灯用于指示NanoKVM的运行状态，正常工作时，STA灯在不规律闪烁，当STA灯出现长亮/长灭或者 规律性间断熄灭时认为NanoKVM出现故障 1. 上电后 STA LED 规律性间断熄灭：系统未检测到TF卡中的系统，请检查TF卡是否正确插入，重新烧录TF镜像 2. STA LED 长时间熄灭：一般在无供电情况下导致，请查看电源状况 > 若仅使用 USB HID 供电，在电脑关机时可能会断开USB电源，请参考相关资料，在BIOS中设置USB常供电，或使用辅助供电。 > 当不慎接入非常规电源后，NanoKVM 可能会烧坏，也会导致 STA LED 熄灭 3. STA LED 长时间亮起，不闪烁：NanoKVM 正式系统和应用一般不会出现该情况，若在NanoKVM系统内配置其他自定义功能，有概率导致系统卡死，STA LED长亮，建议重新烧录镜像 ### 无法获取IP地址 1. Lite用户首先检查有无插卡, Lite 版本默认不带卡出货,需用户自备TF卡,按照[此处](https://wiki.sipeed.com/hardware/zh/kvm/NanoKVM/system/flashing.html)的说明烧卡后重试; 2. 检查网络交换机是否支持100M, 部分新交换机不支持100M的连接, 请更换交换机后重试 3. NanoKVM Cube（包括NanoKVM Full 和 NanoKVM Lite）在接入少数电源/HDMI时会导致无法获取IP，请进行以下确认： > 拔出所有接口，使用充电宝供电，接入网线，查看是否能获取IP > 若可以获取IP，插入HDMI/电脑USB查看IP是否存在 > 若仅充电宝供电时IP存在，插入HDMI/电脑USB后IP消失则确认出现了该问题，请联系客服购买隔离器以解决 ### 登录浏览器界面后，无画面 1. 被控主机可能处于睡眠状态，按下键盘任意按键尝试唤醒 2. 非Chrome浏览器可能存在H264无图像而MJPEG模式正常显示，请使用Chrome浏览器再试 3. PCIe版本可尝试点击`视频`图标下的重置HDMI 4. Cube版本可打开网页后重新拔插HDMI线缆 5. 查看OLED上分辨率/或在网页终端输入`echo \"$(cat /kvmapp/kvm/width) * $(cat /kvmapp/kvm/height)\"`，与被控主机分辨率对比是否相同，如果不同可使用`echo xxx > /kvmapp/kvm/width && echo xxx > /kvmapp/kvm/height` 手动设置分辨率 > 若主机系统为Windows,显示设置中的分辨率很可能与实际分辨率不符,需在高级 >活动信号分辨率中查看 6. 早期内测版 Full NanoKVM 使用普通排线连接 HDMI 采集板，可能因接触不良导致检测不到 HDMI 信号，可按下图所示重新连接排线，或联系客服购买专用排线 ![](./../../../assets/NanoKVM/guide/Old_fix.png) 7. 尝试重启解决：在网页终端中执行`reboot` 8. 若上述方式无法锁定问题，请在网页终端中执行`cat /proc/cvitek/vi_dbg` > 若 `VIDevFPS` 为0，则认为NanoKVM无法获取到HDMI输入，排查以下问题：主机是否输出视频信号、HDMI线缆损坏、Cube是否为早期版本，存在接触不良的情况 > 若 `VIDevFPS` 非0 、`VIFPS` 为0 ，则认为NanoKVM没有正确配置HDMI参数，Cube可以重新插拔HDMI重新自动获取，PCIe可点击`视频`下`重置HDMI`自动获取 > 查看 `VIInImgWidth` 和 `VIInImgHeight`与实际HDMI分辨率是否一致，若不同，则认为NanoKVM没有自动获取到正确的HDMI参数，按照第4点手动配置分辨率参数 ### 主机休眠唤醒后无画面 1. 检查是否使用廉价的DP转HDMI（无源转换头）；这类转换接口没有完善的唤醒机制，无法通知 NanoKVM 画面已经恢复 2. PCIe 版本可以点击重置HDMI按钮来强制重新获取画面 3. Cube/Lite版本缺少重置功能，请更换有源DP转换接头 ### 内网环境下画面延迟异常严重 1. 尝试更换交换机或电源 2. 若无效,请联系售后 ### OLED上正常显示信息，但无法打开网页 1. 请强制更新应用 ### OLED不亮 NanoKVM Full和PCIe版本自带OLED用于显示IP等信息，若OLED无法点亮请按一下步骤排查 1. `2.1.4`版本的应用后添加了OLED休眠功能，按下BOOT按钮可以临时打开OLED 2. 若 STA LED 闪烁异常，请先考虑系统是否正常启动，按上述`STA LED 无法正常闪烁`步骤排查故障 3. 尝试强制更新或重新烧录系统 ### 关于内存 1. NanoKVM 总内存(RAM)空间为256MB, 其中视频图像处理使用一块专用的ion内存区域, 在用户空间查看内存会小于256MB 2. 固件版本号小于 1.3.0 的镜像仅为用户空间保留 128MB 的内存, 1.3.0以及之后的所有镜像, 内存大小扩展到158MB, 有利于Tailscale长时间运行, 请有需要的用户根据[这里](https://wiki.sipeed.com/hardware/zh/kvm/NanoKVM/system/flashing.html)的步骤更新镜像 3. 在设置中启用'内存优化' ### 主机异常重启 + 早期内测版 Full NanoKVM ATX小板连接主机RESET引脚, 重启NanoKVM时主机可能被重启, 请断开RESET跳线或联系客服购买稳定版配件 ### 电流倒灌 + 早期内测版 Full NanoKVM 存在电流倒灌问题: 主机关机且USB无电源输出, 当连接辅助供电电源时电流会倒灌入主机 1. 首先建议设置主机关机后USB保持供电 2. Full版用户: 按下图位置使用电烙铁断开5V电阻或排针短接处, 仅使用辅助供电口供电 ![](./../../../assets/NanoKVM/guide/fix2.png) ### 尝试断电重启解决未知问题 ### 更新过程中如果出现断网等异常情况，可能导致更新失败，请参照以下解决方法： 1. 参考[这里](https://wiki.sipeed.com/hardware/zh/kvm/NanoKVM/system/updating.html#%E8%8E%B7%E5%8F%96 IP)连接开发板 2. 执行 `rm r /kvmapp && cp r /root/old/ / && mv /old/kvmapp && reboot` 恢复上一版本 3. 按最上方的方法进行手动强制更新 4. 重新烧录系统 ### 若上述方法不能解决异常，请在论坛,GitHub或QQ群说明您购买的型号和遇到的问题，我们会耐心解答 + 反馈时，请注明您使用的NanoKVM版本，在什么样的使用环境下（主板型号，系统名称等信息），在什么样的系统配置中（如镜像版本号1.4.0;应用版本号2.2.5;H264;1080P;画质高;帧率30），遇到了什么问题，这样有助于我们复现并解决 + 若出现无图像显示的问题，请在异常时分别执行以下命令，将输出的log粘贴至issue ```shell cat /etc/kvm/hw cat /etc/kvm/hdmi_version cat /etc/kvm/hdmi_mode ``` + 部分问题需要收集运行时的应用log，请按照以下步骤操作： ```shell # 在网页中打开SSH功能（设置 >设备 >SSH） # 使用网页中设置的密码登录ssh，如果没有设置，默认密码为root ssh root@xxx.xxx.xxx.xxx # 修改log等级：/etc/kvm/server.yaml >logger >level：info 修改为 debug vi /etc/kvm/server.yaml # 使用‘i’编辑；使用 ‘Esc’ + :wq 退出 # 重启KVM服务 /etc/init.d/S95nanokvm restart # 复制log ``` ## 反馈方式 * MaixHub 论坛：https://maixhub.com/discussion/nanokvm * GitHub ：https://github.com/sipeed/NanoKVM * QQ 群: 703230713"},"/hardware/zh/kvm/NanoKVM/system/introduction.html":{"title":"系统介绍","content":" title: 系统介绍 keywords: NanoKVM, Remote desktop, Lichee, PiKVM, RISCV, tool update: date: 2024 8 14 version: v0.1 author: BuGu content: Release docs ## 固件（镜像）与应用（APP） NanoKVM 应用运行在修改后的 LicheeRV Nano [固件](https://github.com/sipeed/NanoKVM/releases)上，在网页端 >`设置` >`关于`中可以分别看到镜像和应用的版本号。 + 应用更新包含了KVM的新功能和问题修复，可以在网页直接更新，推送频次较高; + 固件更新则包含较大的系统功能的添加和硬件的适配，需要在github下载镜像并重新烧卡，推送频次较低。 > NanoKVM 镜像在LicheeRV Nano SDK 和 MaixCDK 基础上构建，可以兼容使用 LicheeRV Nano 的资料，反之LicheeRV Nano 或其他 SG2002 产品无法使用KVM软件。如果您想在 NanoKVM 上构建 HDMI 输入相关应用，请与我们联系，以获得技术支持。 ## 开源仓库 + NanoKVM 现已开源前端，后端即将开源（github仓库满2K star） + [NanoKVM 开源仓库](https://github.com/sipeed/NanoKVM) ## 固件版本说明 Full 版 NanoKVM 上包含 KVM A/B 板，早期内测版和正式版存在硬件上的区别 + 1.2.0 及以上的固件同时支持内测版和正式版 + 1.1.0 和 1.0.0 版本固件仅支持内测版的硬件 最新的固件有更多的系统功能，同时保证了对不同硬件的支持，为确保所有功能可用，请尽量烧录最新的固件。 ## 镜像编译 NanoKVM 镜像基于 [LicheeRV Nano SDK](https://github.com/sipeed/LicheeRV Nano Build) ，使用 Buildroot 构建 ## 镜像修改 Todo"},"/hardware/zh/kvm/NanoKVM/system/configuration.html":{"title":"配置文件","content":" title: 配置文件 keywords: NanoKVM, Remote desktop, Lichee, PiKVM, RISCV, tool update: date: 2024 8 13 version: v0.1 author: xwj content: Release docs 配置文件的路径为 `/etc/kvm/server.yaml`。 默认的配置文件内容： ```yaml protocol: http port: http: 80 https: 443 cert: crt: server.crt key: server.key ``` protocol：网络协议，`http` 或 `https` port：服务运行的端口 当 protocol 为 http 时，服务会使用 port.http 端口 当 protocol 为 https 时，服务会使用 port.https 端口 当 protocol 为 https 时，在浏览器中访问时需要加上 `https://` 前缀 (例如：`https://192.168.1.210`） 如果你修改了端口，在浏览器中访问时请加上该端口。例如修改 port.http 为 8080，则在浏览器中的访问地址为 `192.168.1.210:8080` 请勿将端口设置为 0。服务检测到端口为 0 时，会使用默认配置覆盖当前配置文件 cert：服务证书。如果 protocol 设置为 https，则需要配置该参数 crt：证书文件的路径 key：私钥文件的路径 注意，开启 https 后会增加 cpu 占用，可能会导致画面卡顿。"},"/hardware/zh/kvm/NanoKVM/system/flashing.html":{"title":"烧录系统","content":" title: 烧录系统 keywords: NanoKVM, Remote desktop, Lichee, PiKVM, RISCV, tool update: date: 2024 8 13 version: v0.1 author: xwj content: Release docs *NanoKVM Full 版本出厂时已经烧录了镜像，可以选择跳过该步骤。* ## 使用读卡器烧录TF卡 1. 准备 SD 卡： Full 版本自带一张 32G 的 SD 卡，需要拆开外壳将其取出； Lite 版本需要自己准备一张 8G 以上的 SD 卡。 1. 前往 [Github](https://github.com/sipeed/NanoKVM/releases/latest) 下载最新版本镜像。 1. 安装烧录软件，推荐使用 [Etcher](https://etcher.balena.io)。 1. 运行 Etcher： ![run Ethcer](../../../../assets/NanoKVM/flashing/run_etcher.png) 1. 点击 `Flash from file`，选择镜像文件： ![select image](../../../../assets/NanoKVM/flashing/select_image.png) 1. 点击 `Select target`，选择 SD 卡： ![select target](../../../../assets/NanoKVM/flashing/select_target.png) 1. 点击 `Flash!`，开始烧录： ![select target](../../../../assets/NanoKVM/flashing/flashing.png) 1. 等待镜像烧录完成。 ![select target](../../../../assets/NanoKVM/flashing/flashed.png) 恭喜！镜像烧录完成！ 现在，你可以将 SD 卡装到 NanoKVM 上，然后进行下一步的操作了。 ## USB 更新 TF 卡镜像 **注意使用 USB 只能更新系统不能用作第一次烧录。** 请保证 TF 里面已经有系统，并且**系统能正常运行**之后才能用这种方式。 对于 **NanoKVM cube**: 断电，保持 TF 卡插入。 使用牙签或卡针等尖锐物体插入USB C旁的圆形小孔内（此处为reset键）向下按压，保持按压的同时插入 USB 线连接到电脑，等待 U 盘设备出现在电脑上，等待boot盘符出现后即可松开卡针。 ![select target](../../../../assets\\NanoKVM\\flashing\\boot.png) 打开 `Etcher`，选择镜像文件，选择 U 盘设备，点击`Flash`。 ![select image](../../../../assets/NanoKVM/flashing/select_image.png) 等待烧录完成，如果电脑弹出`使用驱动器 G: 中的光盘之前需要将其格式化`这样的字符，**不要**点击格式化磁盘！不然刚烧录好的系统又被格式化了！ 关掉窗口， 右键磁盘，选择弹出 TF 卡即可。 然后断开USB C重新上电，等待系统启动，第一次启动会慢一点，等待一会即可（等待屏幕显示内容，保险起见等待1分钟左右），启动过程中不要断电，防止正在开机处理的文件损坏（解决方法是重新烧录镜像） > 如果发现进不了 U 盘升级模式，可能是系统文件损坏，使用读卡器烧录 TF 卡即可。"},"/hardware/zh/kvm/NanoKVM/system/updating.html":{"title":"更新应用","content":" title: 更新应用 keywords: NanoKVM, Remote desktop, Lichee, PiKVM, RISCV, tool update: date: 2024 8 13 version: v0.1 author: xwj content: Release docs ## 开机 1. 使用网线连接 NanoKVM 的有线网口； 2. 使用标准尺寸的 HDMI 线，连接远程主机和 NanoKVM 的 HDMI 接口； 3. 使用 USB C to A 的数据线，连接远程主机和 NanoKVM 的 PC USB 接口。 接好线之后， NanoKVM 就会自动开机。开机启动需要等待一到两分钟。 ## 获取 IP NanoKVM Full 版本在开机启动后，屏幕上会自动显示 IP，可以跳过此步骤。 NanoKVM Lite 版本可以通过以下方式获取 IP。 ### 在路由器或交换机上查看 NanoKVM 启动后会通过 DHCP 获取 IP。可以在路由器或交换机上找到 NanoKVM 分配的 IP。 ### 通过串口查看 使用串口工具连接 NanoKVM 后获取其 IP。 ### 通过 usb rndis 网口获取 > 如果远程主机是 Windows 系统，请先参考 [usb rndis 网口](https://wiki.sipeed.com/hardware/zh/lichee/RV_Nano/5_peripheral.html#usb rndis 网口) 安装驱动 1. 在远程主机中打开终端软件； 1. 执行 `ifconfig` （在 Windows 系统中是 `ipconfig`）命令； 1. 在显示的网络列表中找到 IPv4 地址为 10 开头的网址，示例如下： ![ipconfig](../../../../assets/NanoKVM/updating/ipconfig.png) 1. 通过 SSH 登录 NanoKVM：`ssh root@10.223.155.1` （注意，不是 10.223.155.100），密码为 `root` ： ![ipconfig](../../../../assets/NanoKVM/updating/ssh.png) 1. 进入 NanoKVM 后，执行 `ifconfig` ，从网络列表中找到 `eth0` 网卡的地址，该地址就是 NanoKVM 的 IP： ![ipconfig](../../../../assets/NanoKVM/updating/ifconfig.png) 1. 获取到 IP 后，接下来就可以通过该 IP 访问 NanoKVM 了。 ## 检查更新 1. 使用任意电脑，连接到与 NanoKVM 相同的网络； 1. 打开浏览器（推荐使用 Chrome），在地址栏中输入刚刚获取到的 IP 并访问； 1. 浏览器会进入一个登录页面，输入默认账号 `admin` 和默认密码 `admin` 进行登录; ![ipconfig](../../../../assets/NanoKVM/updating/login.png) 1. 登录成功后，点击检查更新： ![ipconfig](../../../../assets/NanoKVM/updating/check_for_update.png) 1. 如果有更新，则点击开始更新： ![ipconfig](../../../../assets/NanoKVM/updating/update.png) 1. 等待应用更新完成后，浏览器会自动刷新并重新进入登录页面，再次登录即可。 ## 更新完成 大功告成！ 现在镜像和应用都已经更新到了最新版本。 只要在浏览器中输入 NanoKVM 的 IP 地址，就可开始操控远程主机了。"},"/hardware/zh/kvm/NanoKVM_USB/deployment.html":{"title":"本地部署","content":" title: 本地部署 keywords: NanoKVM, Remote desktop, tool, USB update: date: 2025 01 15 version: v0.1 author: xwj content: Release docs 首先，在 [Releases](https://cdn.sipeed.com/nanokvm/NanoKVM USB.zip) 页面下载 `browser` 版本文件，解压后会得到`NanoKVM USB`文件夹。 ## 本机部署 > 如果只需要通过本机访问（localhost），则可以不使用证书。 这里提供了 Node.js 和 Python 的示例。 ### Node.js 服务 1. 打开终端，进入上一步骤中的 `NanoKVM USB` 目录； 2. 执行 `npm install g http server` 安装 `http server`； 3. 执行 `http server p 8080 a localhost` 启动服务。 ### Python 服务 1. 打开终端，进入上一步骤中的 `NanoKVM USB` 目录； 2. 执行 `python m http.server 8080` 启动服务。 ### 在网页中访问 服务启动后，打开浏览器访问 `http://localhost:8080` 即可。 注意只能使用`http`协议，无法使用`https`协议。 ## 局域网部署 > 如果需要在局域网内访问，则需要使用证书。 这里提供了 Node.js 和 Python 的示例。相较于本地部署，多了一个生成证书的步骤。 ### 生成证书 > 请确保已经安装 `openssl`。 1. 打开终端，进入上一步骤中的 `NanoKVM USB` 目录； 2. 执行 `openssl req newkey rsa:2048 new nodes x509 days 3650 keyout key.pem out cert.pem`； 3. 终端会提示需要输入信息，可以一直按回车键跳过，也可以按自己的需要输入信息。 完成后会在当前目录生成两个文件：`key.pem` 和 `cert.pem`。 ### Node.js 服务 1. 执行 `npm install g http server` 安装 `http server`; 2. 执行 `http server p 8080 S C cert.pem K key.pem` 启动服务。 ### Python 服务 在 `NanoKVM USB` 目录中创建 `server.py` 文件，写入以下代码并保存： ```python import http.server import ssl server_address ('0.0.0.0', 8080) httpd http.server.HTTPServer(server_address, http.server.SimpleHTTPRequestHandler) context ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER) context.load_cert_chain(certfile 'cert.pem', keyfile 'key.pem') httpd.socket context.wrap_socket(httpd.socket, server_side True) print(f\"Serving HTTPS on {server_address[0]}:{server_address[1]}\") httpd.serve_forever() ``` 执行 `python server.py` 运行服务。 ### 在网页中访问 打开浏览器，输入服务地址，比如`https://127.0.0.1:8080`。 如果打开网址后提示`隐私错误`，需要手动点击访问： ![](./../../../assets/NanoKVM/usb/privacy error.png) ## 公网部署 > 如果需要在公网访问，建议使用 `Nginx`。 这里给出一份简单的配置示例，详细的配置方式请参考 `Nginx` 文档。 ```nginx server { listen 80; server_name your_domain.com www.your_domain.com; # 请替换为您的域名 return 301 https://$host$request_uri; } server { listen 443 ssl; server_name your_domain.com www.your_domain.com; # 请替换为您的域名 root /var/www/your_website; # 请替换为 NanoKVM USB 目录路径 index index.html index.htm; ssl_certificate /etc/nginx/ssl/your_domain.crt; # 请替换为您的证书文件路径 ssl_certificate_key /etc/nginx/ssl/your_domain.key; # 请替换为您的私钥文件路径 location / { try_files $uri $uri/ /index.html; } } ```"},"/hardware/zh/kvm/NanoKVM_USB/introduction.html":{"title":"简介","content":" title: 简介 keywords: NanoKVM, Remote desktop, tool, USB update: date: 2024 12 25 version: v0.1 author: xwj content: Release docs ## 简介 ![](./../../../assets/NanoKVM/usb/NanoKVM USB.png) NanoKVM USB是一款便捷的运维/多设备协同工具，它可以无需键鼠设备和显示器，仅使用手边的一台电脑无需下载软件，通过Chrome浏览器即可图形化开始运维工作。 NanoKVM USB 捕捉HDMI图像信号，通过USB3.0传输给HOST主机，与普通USB采集卡不同的是，NanoKVM USB同时捕捉HOST端的键鼠操作，同步给目标主机，无需传统连接屏幕键鼠的方式，就可以完成所有操作。同时支持一路HDMI环出，最高支持4K@30HZ，方便外连大屏。 值得一提的是，NanoKVM USB自带一个USB A端口，支持HOST/TARGET两侧切换，当外接U盘时候可以方便的在两台电脑之间转移数据，此外更多功能请自由探索。 ![](./../../../assets/NanoKVM/usb/wiring.png) ## 使用场景 ![](./../../../assets/NanoKVM/usb/use cases.jpg) ## 接口 ![](./../../../assets/NanoKVM/usb/interface.jpg) ## 参数对比 NanoKVM USB 4K NanoKVM USB Mini KVM HDMI 输入 4K@60fps 4K@30fps 1080P@60fps HDMI 环出 4K@60fps 4K@30fps None USB 采集 4K@60fps 2K@30fps 1080P@60fps USB 接口 USB3.0 USB3.0 USB2.0 USB 切换器 有 有 有 模拟键鼠 支持 支持 支持 剪贴板 支持 支持 支持 软件 无需安装，在 Chrome 中运行 无需安装，在 Chrome 中运行 需要安装 延迟 50 100ms 50 100ms 50 100ms 体积 57x25x23mm 57x25x23mm 61x13.5x53mm 外壳 铝合金 铝合金 铝合金 颜色 黑 黑/蓝/红 黑 价格 ~~$69~~ `$59` `$39.9 / $49.9` `$89 / $109` <div style \"display: flex; padding: 30px 0 20px 0\"> <img src \"./../../../assets/NanoKVM/usb/black.png\" width \"200\" height \"150\" alt \"Image 1\" style \"margin right: 10px;\"> <img src \"./../../../assets/NanoKVM/usb/blue.png\" width \"200\" height \"150\" alt \"Image 1\" style \"margin right: 10px;\"> <img src \"./../../../assets/NanoKVM/usb/red.png\" width \"200\" height \"150\" alt \"Image 1\" style \"margin right: 10px;\"> </div> ## 购买入口 [淘宝官方购买地址](https://item.taobao.com/item.htm?id 898108163819) [速卖通购买地址](https://www.aliexpress.com/item/1005008473747668.html) [预售页面](https://sipeed.com/nanokvm/usb) ## 产品反馈 如果您在使用过程中有任何问题或建议，请通过以下渠道和我们反馈： [Github issues](https://github.com/sipeed/NanoKVM) [MaixHub 论坛](https://maixhub.com/discussion/nanokvm) QQ 交流群: 703230713"},"/hardware/zh/kvm/NanoKVM_USB/quick_start.html":{"title":"快速上手","content":" title: 快速上手 keywords: NanoKVM, Remote desktop, tool, USB update: date: 2024 12 25 version: v0.1 author: xwj content: Release docs ## 接口介绍 ![](./../../../assets/NanoKVM/usb/interface.jpg) ## 接线 使用 USB3.0 或 TypeC 线连接 NanoKVM USB 与 Host 主机。 ![](./../../../assets/NanoKVM/usb/quick_start/wiring1.png) 使用 HDMI 线连接 NanoKVM USB 与 Target 主机。 ![](./../../../assets/NanoKVM/usb/quick_start/wiring2.png) 使用 USB3.0 线连接 NanoKVM USB 与 Target 主机。 ![](./../../../assets/NanoKVM/usb/quick_start/wiring3.png) ## 网页使用教程 ### 打开网页 使用 Chrome 浏览器访问 `https://usbkvm.sipeed.com`。 > 请使用桌面端 Chrome 浏览器，且版本号需要大于 89。 > > 由于使用了 [Web Serial API](https://developer.mozilla.org/en US/docs/Web/API/Serial)，移动端 Chrome 和其它不支持该特性的浏览器均无法使用键鼠。 ### 授权 NanoKVM USB 会模拟成 USB 摄像头，用于传输视频和音频。因此网页首先需要获取摄像头使用权限。 ![](./../../../assets/NanoKVM/usb/quick_start/auth_camera.png) > 如果您拒绝了授权，或者想关闭授权，可以选择重置所有权限。 > > ![](./../../../assets/NanoKVM/usb/quick_start/reset.png) ### 选择 USB 设备 在获取授权后，网页会显示一个选择 USB 设备的弹窗。我们需要在这里选择两个设备： 1. USB 摄像头：用于视频和音频的输入； 2. 串口设备：用于发送键盘和鼠标数据。 #### USB 摄像头 点击下拉框，选择以 `USB Video` 格式命名的摄像头设备。选择设备后网页就会开始显示视频画面。 ![](./../../../assets/NanoKVM/usb/quick_start/usb_video.png) #### 串口设备 > > 如果当前浏览器不支持串口，则不会显现该按钮。此时网页仅有视频传输功能，无法使用键盘和鼠标。 点击选择串口按钮，会弹出所有可用的串口设备列表，从中选择对应的串口设备。 > Windows 为`COMx`格式，macOS为`USB Serial`格式，linux一般为`/dev/ttyUSBx`格式 ![](./../../../assets/NanoKVM/usb/quick_start/usb_serial.png) 设置完成！到这里就可以开始正常使用了。 ### 音频 如果网页没有自动播放声音，则需要用户手动设置。这里以 Mac 控制 Windows 为示例： #### Target 主机 在 Target 主机（Windows）中，选择 NanoKVM 作为**音频输出**设备。 音频设备的名称和是否连接环出设备有关： 如果没有接环出设备，则音频设备名称为 `HDMI TO USB`； 如果连接了环出设备，则音频设备名称为该设备的名称。 ![](./../../../assets/NanoKVM/usb/quick_start/audio_output.jpg) #### Host 主机 在 Host 主机（Mac）中，选择 NanoKVM 作为**音频输入**设备。 音频设备的名称格式一般为 `USB Digital Audio`。 ![](./../../../assets/NanoKVM/usb/quick_start/audio_input.png) ### 鼠标 鼠标默认使用`绝对模式`。在 BIOS 界面或某些系统中，该模式可能无法正常工作，请切换到`相对模式`后使用。 ![](./../../../assets/NanoKVM/usb/quick_start/mouse_mode.png)"},"/hardware/zh/kvm/NanoKVM_USB/faq.html":{"title":"F&Q","content":" title: F&Q keywords: NanoKVM USB, Lichee, PiKVM, RISCV, tool ## 串口/键鼠问题 ### Linux打开网页后无 ttyUSBx 串口设备 + 可能缺少串口驱动导致,请按照以下方法重新安装CH34x驱动: 1. 在WCH官网下载驱动([下载地址](https://www.wch.cn/downloads/CH341SER_LINUX_ZIP.html))，解压后进入driver目录 2. 执行`uname r`查看操作系统发行版本，在([此处](https://elixir.bootlin.com/linux/v6.2/source/drivers/usb/serial/ch341.c))找到对应的版本，将内容复制到`ch341.c`中 3. 执行`make`命令编译驱动 4. 执行`sudo make load`命令安装驱动 5. 替换旧驱动:`cp ch341.ko /lib/modlues/$(uname r)/kernel/drivers/usb/serial/ch341.ko` + 部分linux发行版内置了`brltty`,这是一款盲文阅读工具，但会占用/dev/ttyUSB0串口，导致网页检测不到，在确认不使用`brltty`后建议将其卸载`sudo apt remove brltty` ### Windows 打开网页后无 USB Serial (COMx) 串口设备 + 可能缺少串口驱动导致,请按照以下方法重新安装CH34x驱动: + 在WCH官网下载驱动([下载地址](https://www.wch.cn/downloads/CH341SER_EXE.html))，下载后双击运行安装程序 ### Windows 被控端出现 NanoKVM USB 设备驱动程序未被安装 + 可能是 USB 复合设备未被正确识别导致，请按照以下方法重新安装驱动: + 打开 `设备管理器` → `其他设备` + 找到 `NanoKVM USB` → 右键 `属性` → `驱动程序` → `更新驱动程序` ![](./../../../assets/NanoKVM/usb/windows_usb_1.jpeg) + 选择 `浏览我的电脑以查找驱动程序` → `让我从计算机上的可用驱动程序列表中选取` ![](./../../../assets/NanoKVM/usb/windows_usb_2.jpeg) + 双击 `显示所有设备` ![](./../../../assets/NanoKVM/usb/windows_usb_3.jpeg) + 在 `Standard USB Host Controller` / `标准 USB 主控制器` / `Standard system devices` / `标准系统设备` 中找到 `USB 复合设备 (USB Composite Device)` → 双击安装 ![](./../../../assets/NanoKVM/usb/windows_usb_4.jpeg) ![](./../../../assets/NanoKVM/usb/windows_usb_5.jpeg) > **注意**：不同版本 Windows 驱动位置可能有所差异，请耐心查找。 ### 打开网页后 NanoKVM USB 对应串口设备无法打开 + 可能是部分程序占用该串口，请确认无占用后再试 + Linux可能缺少权限，导致串口无法打开，在终端中执行`sudo chmod 777 /dev/ttyUSB*` + Chrome浏览器可能没有检测到该串口，请刷新网页或重启 Chrome + Chrome权限可能不足，请打开相应权限 ### Mac Mini (Apple Silicon) 上连接设备后找不到串口设备 这通常是因为新款 Mac Mini 后置的雷雳 (Thunderbolt) 接口与前置 USB 接口采用了不同的控制器，导致对部分 USB 设备的兼容性表现不同。后置雷雳接口在兼容传统的 USB 串口设备 (CDC ACM) 时可能会更挑剔，而前置的原生 USB C 接口兼容性通常更好。 建议解决方案： + 更换接口：优先将设备连接到 Mac Mini 的前置 USB C 接口。 + 使用集线器：如果您必须使用后置接口，建议通过一个 USB 集线器 (Hub) 进行连接，通常可以解决识别问题。 ## 视频问题 ### 部分主机BIOS下环出/采集颜色异常 + NanoKVM USB早期固件可能在部分BIOS下环出颜色偏红，采集颜色偏绿，可以通过烧录新固件解决，请先下载烧录软件和固件： [固件下载链接](https://dl.sipeed.com/fileList/KVM/NanoKVM_USB/MS2131_LIB_V2_0_27_Demo_GPIO0_PlugDetect_20251205_replaced_E158EDID.bin)、[烧录软件下载链接](https://dl.sipeed.com/fileList/KVM/NanoKVM_USB/MS_USB3_0_UpgradeTool_V1_3_2.exe) + 烧录步骤： 1. 打开软件，选择下载的固件 2. 将NanoKVM USB Host端的USB C插入电脑 3. 等待软件连接，点击开始烧录，等待完成 > **请勿在烧录过程中拔出NanoKVM USB，有变砖风险** > 烧录软件仅支持Windows > 目前不支持NanoKVM USB(4K)版本的烧录 ### 视频画质差 + 首先检查是否使用了 USB2.0 的线缆/HOST接口，当分辨率较大时 USB2.0 不足以提供充足的传输带宽，会被动降低画质，建议选用 USB3.0的线缆 + 2K分辨率下受限于芯片编码能力，画质会下降，请切换为1080P使用 + 如果 Target 连接的是 Windws主机，请前往系统设置 显示设置 高级显示设置 列出所有模式中更改为 1080P60，并检查`桌面分辨率`和`活动信号分辨率是否一致` ### DP HDMI转接器 + 部分无源DP转HDMI转换器内部电路仅做电平转换，对NanoKVM USB兼容性较差，表现为视频信号从无到有（比如从睡眠唤醒时）NanoKVM USB仍显示然黑屏，需要手动拔插HDMI。 ### 无HDMI环出 + 内测版硬件仅支持HOST侧USB供电，请在使用时保持HOST测供电正常 ### 环出显示屏 + NanoKVM USB在未连接环出显示屏前使用自身的EDID（显示器识别数据），连接环出显示器后切换为环出显示器的EDID。 + 由于EDID中包含显示器厂家以及颜色信息，插入环出显示器前后Target系统设置中可能显示为不同的分辨率列表，USB采集的画面颜色可能在插入前后有所差异 ## 音频问题 ### 音频不连续 + NanoKVM USB 在USB2.0模式下可能会因带宽不够的原因出现音频传输不连续的问题，请尽量使用USB3.0连接NanoKVM USB和Host ## 已知问题 ### 延迟 + ARM 版的 macOS 通过 NanoKVM USB 连接树莓派时延迟会增大，其他组合则不受影响 ## 反馈方式 + 若上述方法不能解决异常，请在论坛,GitHub或QQ群说明您购买的型号和遇到的问题，我们会耐心解答 + [Github issues](https://github.com/sipeed/NanoKVM) + [MaixHub 论坛](https://maixhub.com/discussion/nanokvm) + QQ 交流群: 703230713"},"/hardware/zh/kvm/NanoKVM_PCIe/introduction.html":{"title":"简介","content":" title: 简介 keywords: NanoKVM, Remote desktop, Lichee, PiKVM, RISCV, tool, PCIe update: date: 2024 12 5 version: v0.1 author: BuGu content: Release docs ## 简介 ![](./../../../assets/NanoKVM/introduce/NanoKVM PCIe.png) NanoKVM PCIe 是 NanoKVM 的新形态, 自带 PCIe 挡板, 可以固定在机箱内部, 为台式机用户提供更好的体验。 NanoKVM PCIe 在 NanoKVM Cube的基础上添加可选的 WiFi, PoE功能(选配)；自带 PCIe 插槽,可以从主板 PCIe 插槽取电；此外, 有线连接(ETH)也更加稳定, 符合更专业的需求。 NanoKVM 系列产品包含一个 HDMI 输入接口，可以被电脑识别为显示器，捕捉电脑画面；一个 USB2.0 接口连接电脑主机，可被识别为键盘鼠标触摸板等HID设备，同时使用TF卡多余存储空间，挂载为一个U盘设备；全系标配一个百兆网口，用于视频和控制信号等的网络传输。PCIe版 NanoKVM 标配一个0.49英寸OLED, 实时显示各种状态信息, WiFi配网等各种信息。 > 注：NanoKVM PCIe版仅从PCIe接口取电，无法作为显卡/显示设备直接从PCIe获取图像 为满足用户不同需求，NanoKVM PCIe 提供 WiFi 和 PoE 两个可选配模块, 购买时可自由搭配 ## 使用场景 ![](./../../../assets/NanoKVM/introduce/web_ui.gif) + 服务器管理：用于实时监控服务器，获取服务器运行状态，并对其加以控制； + 远程桌面、开关机：NanoKVM 摆脱主机必须联网和系统软件的限制，作为主机外置硬件，直接提供远程控制的功能； + 远程装机：NanoKVM 模拟 U盘设备，可挂载装机镜像安装系统，也可进入BIOS对电脑设置； + 远程串口：NanoKVM 引出两组串口，可配合IPMI使用，或连接其他开发板使用网页串口终端交互，此外用户可自行拓展更多配件 + 双电脑协同操作 ## 参数 产品 NanoKVM (PCIe) NanoKVM (Full) PiKVM V4 计算单元 SG2002(RISCV) LicheeRV Nano(RISCV) CM4 (ARM) 分辨率 1080P @ 60fps 1080P @ 60fps 1080P @ 60fps 视频编码 MJPEG, H264 MJPEG, H264 MJPEG, H264 视频延迟 90～230ms 90～230ms 100～230ms UEFI/BIOS ✓ ✓ ✓ 模拟USB键鼠 ✓ ✓ ✓ 模拟USB存储 ✓ ✓ ✓ IPMI ✓ ✓ ✓ Wake on LAN ✓ ✓ ✓ Tailscale ✓ ✓ ✓ WebSSH ✓ ✓ ✓ 自定义脚本 ✓ ✓ ETH 100M/10M 100M/10M 1000M/100M/10M PoE 选配 仅外部连接 1000M/100M/10M WiFi 选配 ✓ ATX电源控制 可直连机箱内9Pin电源针脚 USB接口IO控制板 RJ45接口IO控制板 OLED显示 64*32 0.49\" white 128x64 0.96\" white 128x32 0.91\" white 串口终端 2路 2路 Micro SD卡 有，开机即用 有，开机即用 有 功耗 0.2A@5V 0.2A@5V Peak 2.6A@5V 电源输入 多种供电模式 PC USB即可供电 <br> 也支持额外辅助供电 需要DC 5V 3A供电 散热 静音无风扇 静音无风扇 需要风扇主动散热 尺寸 66x57x18mm(不含挡板) 40x36x36mm 120x68x44mm ## NanoKVM PCIe 资料 NanoKVM 与 Sipeed [LicheeRV Nano](https://wiki.sipeed.com/hardware/zh/lichee/RV_Nano/1_intro.html) 使用相同SOC，希望二次开发的小伙伴可在[这里](https://wiki.sipeed.com/hardware/zh/kvm/NanoKVM/development.html)查看更多资料 NanoKVM Cube/PCIe 软件现已完全开源：[KVM应用开源位置](https://github.com/sipeed/NanoKVM)、 [镜像开源位置](https://github.com/sipeed/LicheeRV Nano Build/tree/NanoKVM) > NanoKVM 镜像在LicheeRV Nano SDK 和 MaixCDK 基础上构建，可以兼容使用 LicheeRV Nano 的资料，反之LicheeRV Nano 或其他 SG2002 产品无法使用KVM软件。如果您想在 NanoKVM 上构建 HDMI 输入相关应用，请与我们联系，以获得技术支持。 NanoKVM Cube 和 NanoKVM PCIe 共用同一套镜像和应用, 自动适配不同的硬件版本 + [NanoKVM 镜像下载](https://github.com/sipeed/NanoKVM/releases) ## 购买入口 [淘宝](https://item.taobao.com/item.htm?id 902878081229) [速卖通](https://www.aliexpress.com/item/1005008285472731.html) [预售页面](https://sipeed.com/nanokvm/pcie) ## 产品反馈 如果您在使用过程中有任何问题或建议，请通过以下渠道和我们反馈： + [Github issues](https://github.com/sipeed/NanoKVM) + [MaixHub 论坛](https://maixhub.com/discussion/nanokvm) + QQ 交流群: 703230713"},"/hardware/zh/kvm/NanoKVM_PCIe/quick_start.html":{"title":"快速上手","content":" title: 快速上手 keywords: NanoKVM, Remote desktop, Lichee, PiKVM, RISCV, tool update: date: 2024 12 5 version: v0.1 author: BuGu content: Release docs ## 开箱 ![](./../../../assets/NanoKVM/unbox/PCIe_unbox.jpg) NanoKVM PCIe 包装内包含主机, 半高 PCIe 挡板, 两条 USBA C线缆, 一条 HDMI 线缆, 一根天线, 16P 公对母排线, 4P 母对母排线和一把小螺丝刀 主机上包含杜邦跳线(2+4P), SMA 天线座 注: 上图是 NanoKVM PCIe 带WiFi 带PoE 版本,不带 WiFi 版本会少一根天线, 挡板上少 SMA 天线座 ## 接口介绍 ![](./../../../assets/NanoKVM/unbox/PCIe_new_interface.jpg) 老版本的内测硬件两个USB C口左右相反，参照一下图示，具体以到手后挡板标识为准 ![](./../../../assets/NanoKVM/unbox/PCIe Interface1.png) ![](./../../../assets/NanoKVM/unbox/PCIe Interface2.png) ## 供电 + NanoKVM PCIe 有多种供电选择: USB HID直接供电, USB PWR IN辅助供电, PCIe 插槽取电, PoE 供电(选配) 请任选一种即可, 同时存在多路供电不会干扰 NanoKVM PCIe 的运行,请至少使用一路供电 注: 如果需要USB HID直接供电,则需要在BIOS中设置主板关机 USB 常供电，否则会影响远程开机功能 注: NanoKVM PCIe USB PWR IN CC 接口下拉5.1K电阻，可使用正规 PD 充电头供电。部分劣质PD电源存在烧坏 NanoKVM PCIe 的风险。 ## 安装 1. NanoKVM PCIe 在接线上与 Cube 类似, 请在主机关机且断电的情况下安装 NanoKVM PCIe, 测试功能全部正常后再装入机箱 > ❗请确保装入PCIe卡槽后 NanoKVM PCIe 的按键可以正常按下并抬起，否则可能导致NanoKVM无法启动或功能异常 2. 使用一条 USB C to A 数据线连接远程主机和 NanoKVM 的 USB HID 接口（位于 HDMI 接口下方） 也可以参照下图方式, 直接连接机箱内部的九针USB2.0 ![](./../../../assets/NanoKVM/unbox/PCIe USB.jpg) 连接时务必参照上方示意图和下面的 NanoKVM PCIe 内部接口示意图, 上电前请反复检查, 接错可能会有烧坏 NanoKVM 的风险！部分批次的连接线上的 “HDD LED” 丝印有误，请按照实际情况调整。 ![](./../../../assets/NanoKVM/unbox/PCIe Pin.jpg) 3. 使用附赠的 HDMI 线缆连接远程主机和 NanoKVM 的 HDMI 接口 4. 使用网线连接 路由器/交换机 与 NanoKVM, 如果您在24/12/07后下单的 WiFi 版 NanoKVM PCIe, 此步骤可以省略, 参照WiFi配网环节使用 WiFi 连入. 5. ATX电源控制: 主机电源远程控制的原理是模拟开关按下操作,并读取LED状态同步到网页, 为此, 需要将主板上原本连接机箱开机按键的9针接口断开,接入 NanoKVM PCIe 对应接口, 同时为了机箱按钮仍可操控电源, 需要将机箱上的电源排线也连接到 NanoKCM PCIe上 ![](./../../../assets/NanoKVM/unbox/PCIE ATX.jpg) 接线时,请务必参照上方示意图和 NanoKVM PCIe 内部接口示意图 ![](./../../../assets/NanoKVM/unbox/PCIe Pin.jpg) 注：NanoKVM PCIe 不会监控HDD状态 注：早期部分用户购买的NanoKVM PCIe配套全高PCIe挡板在安装上可能存在过长的问题，请使用较长螺丝固定（注意不要太用力）或购买`外径7mm、内径4.2mm、高度3mm`规格的垫圈。若安装仍然存在困难，请联系淘宝/速卖通客服，或者support@sipeed.com邮箱获取支持 ## WiFi 配网 + 此步骤仅适用于购买了带 WiFi 版本的 NanoKVM PCIe, 其他版本会在 WiFi 图标位置显示 \" \" + 若您不便连接网线,NanoKVM PCIe 提供了 AP 配网功能, 用手机连接 NanoKVM 创建的 AP > 进入网页配置 具体操作流程如下: 1. 上电开机,等待出现主界面UI,当前 WiFi 状态没有亮起, 无 WiFi IP ![](./../../../assets/NanoKVM/unbox/wifi0.jpg) 2. 用包装内附赠的小螺丝刀长按 PCIe 面板上的 BOOT 小孔按键 2s以上 ![](./../../../assets/NanoKVM/unbox/wifi1.jpg) 3. 等待出现 WiFi AP 二维码时, 扫码连接 AP ![](./../../../assets/NanoKVM/unbox/wifi2.jpg) ![](./../../../assets/NanoKVM/unbox/wifi3.jpg) 4. 检测到手机连接成功后, OLED上将出现 Web 二维码, 扫码自动跳转到配置页面 ![](./../../../assets/NanoKVM/unbox/wifi5.jpg) ![](./../../../assets/NanoKVM/unbox/wifi6.jpg) 5. 输入 NanoKVM PCIe 要连接的WiFi 帐号(SSID) 密码(Password), 点击OK, 即可完成配网 ![](./../../../assets/NanoKVM/unbox/wifi8.jpg) ![](./../../../assets/NanoKVM/unbox/wifi9.jpg) 注: + 若无法通过二维码连接AP, 可短按 BOOT 按键, OLED上将出现 AP SSID 和 PASS, 可使用手机系统设置连接 ![](./../../../assets/NanoKVM/unbox/wifi4.jpg) + 若无法通过二维码打开网页, 可短按 BOOT 案件, OLED上将出现 WiFI 配置地址, 手机浏览器输入地址后配置 ![](./../../../assets/NanoKVM/unbox/wifi7.jpg) + 若无法打开配置网页,请关闭移动数据后再试 + 如果 WiFi 帐号或密码设置错误, OLED上会回到步骤3, 请重新连接AP陪网 + 长按 BOOT 会退出 WiFi 配置界面 + 为保证安全,每次配置 WiFi 时, 都会生成一个随机AP密码, 建议按照上述流程完成配置 ## 更新 ### 更新应用 新的应用往往带来更多功能或修复某些重要漏洞，建议您将 NanoKVM 应用更新到最新版本，具体操作方式请参考 [更新应用](https://wiki.sipeed.com/hardware/zh/kvm/NanoKVM/system/updating.html)。 2.1.1 及后续版本更新记录：[应用更新记录](https://github.com/sipeed/NanoKVM/blob/main/CHANGELOG.md) ## 基础操作 ### 如何获取IP地址 Full版NanoKVM自带OLED显示屏，联网之后会在显示屏显示IP地址； WiFi 版本 NanoKVM PCIe ETH 和 WiFi 获取的 IP 将会交替出现, 如图: IP前有'E'的是ETH IP; 有'W'的是 WiFi 获取的IP ![](./../../../assets/NanoKVM/unbox/wifi9.jpg) ### 查看远程桌面 浏览器直接输入获取的IP，进入登录页面，默认账号密码为admin、admin，登录后建议修改密码, 并更新最新的应用 ![](./../../../assets/NanoKVM/unbox/unbox_9.png) 注: 建议使用Chrome浏览器，其他浏览器可能出现无法显示画面或无法操作键鼠等兼容性问题 注：少数版本可能存在无法访问网页/登录后崩溃的情况，请拔出HDMI接口后重新上电，更新为最新的应用后再插入HDMI ### ATX电源控制 如果连接了电源控制接口,可以在网页远程控制电脑启动 + 网页端提供电源灯状态指示, 电源和重启按钮功能, 不能监控到HDD硬盘灯状态"},"/hardware/zh/kvm/NanoKVM_PCIe/user_guide.html":{"title":"用户指南","content":" title: 用户指南 keywords: NanoKVM, Remote desktop, Lichee, PiKVM, RISCV, tool update: date: 2024 12 6 version: v0.1 author: BuGu content: Release docs ## OLED界面 在 NanoKVM PCIe 上, OLED有两种界面: 主界面和WiFi配置界面,通过长按BOOT(2s)切换两个界面 主界面: ![](./../../../assets/NanoKVM/unbox/wifi9.jpg) + 显示网线、USB、HDMI 连接状态，连接后图标将反色显示; + IP: 连接网线后 NanoKVM 默认自动获取IP，并显示在 OLED 上，WiFi版本 IP 将来回切换; + 分辨率: 将显示HDMI物理分辨率,如1920*1080 + FPS: 显示实时传输帧率 + 主界面提供 OLED 休眠功能, 以防止 OLED 烧屏, 短按 BOOT 即可关闭或打开 OLED + `2.1.4`版应用后添加OLED自动休眠功能：在设置中设置休眠时间后，OLED会在设定时间后自动休眠，按下BOOT可以临时唤醒OLED WiFi配置界面(没有选配WiFi的版本无WiFi配置界面) ![](./../../../assets/NanoKVM/unbox/wifi2.jpg) + 根据WiFi配置流程依次显示:WiFi AP 正在创建 >WiFi二维码 >Web二维码 + WiFi连接成功后会自动退出该界面 + 详细WiFi配置流程请参考[配置WiFi](https://wiki.sipeed.com/hardware/zh/kvm/NanoKVM_PCIe/quick_start.html#WiFi 配网) ## 管理页面功能 ![](./../../../assets/NanoKVM/introduce/web_ui.gif) 悬浮栏从左到右依次为：图像设置、屏幕键盘、鼠标样式、镜像挂载、自定义脚本、KVM网页终端、WOL、ATX控制/指示、设置、全屏、隐藏悬浮栏。 ### 分辨率、格式、帧率、图像质量设置 + NanoKVM 支持 1080P、720P、600P、480P 的图像传输，在图像设置 >分辨率中可以选择不同的分辨率。越大的分辨率所占用带宽越大、实时帧率越小, Auto模式下传输分辨率将跟随主机HDMI物理分辨率。 + 注：此处仅修改图像的传输大小，不会改变 HDMI 输入的图像尺寸，如需修改，请前往主机系统的设置菜单进行设置。 + 格式设置: 当前, NanoKVM 支持两种格式: MJPEG和H264 + MJPEG格式传输每一帧图像, 图像质量相对较高, 延迟比较确定, 但流量消耗比较高 + H264格式传输视频流数据, 传输数据体积小, 延迟低,在高画质下比较明显 + 帧率设置选项用于修改传输的最大帧率，可以限制网络带宽的占用，但帧率越低，画面越卡，请根据网络情况合理配置。Full版用户在OLED上可看到视频的实时帧率。 + 图像质量选项可以修改画面的压缩比例，当您认为画面较卡，延迟较高时，可以适当调低图像质量。 + 在MJPEG格式下, 低,中,高,无损,分别代表图像压缩比为: 50%, 60%, 80%, 100% + 在H264格式下, 低,中,高,无损,分别代表传输码率为: 1000Kbps, 2000Kbps, 3000Kbps, 5000Kbps ### 虚拟键鼠使用 + NanoKVM 的 USB 接口模拟出了键鼠设备。打开浏览器页面后，系统将自动捕获键鼠输入，并将操作实时同步到 NanoKVM 连接的主机。用户可以选择隐藏鼠标或改变在画面上显示的样式。 + 对于不方便使用键盘的用户，我们提供了屏幕键盘，点击悬浮栏的键盘图标即可唤出屏幕键盘。 + 少数情况下HID键鼠无法控制主机, 请点击重置HID后再试 + 部分 BIOS 要求鼠标必须使用相对位移模式, 请在网页 >鼠标模式中修改 + 部分 BIOS 要求键鼠必须使用带有BIOS标记的模式,请在网页终端中执行 `touch /boot/BIOS && reboot` ### ISO镜像挂载以及远程装机 + Nano KVM的 USB C 端口除模拟键鼠设备外，还模拟了一个U盘设备，挂载了TF卡内的一部分存储空间，用于装机等需求，该U盘默认格式化为exFAT格式，Full版NanoKVM内置TF卡，模拟出的U盘大小约21G。 + 与普通U盘不同，NanoKVM的虚拟U盘内可同时存放多个镜像，开机之前可以通过 web 页面的选项选择要安装的系统镜像进行挂载。 用户需提前下载待安装的镜像（通常以.iso结尾），将 NanoKVM USB C 插入电脑，将下载好的镜像直接复制到U盘内（可复制多个系统），即可拔出。 按上述步骤连接远程主机与Nano KVM，在浏览器登录系统后，点击光盘图标，选中待安装的系统，即可实现ISO挂载 ![](./../../../assets/NanoKVM/guide/imgsl.png) 接下来开始装机操作，点击`开机（短按）`，迅速按键盘上的F11键（不同主机按键可能不同，请参照主机说明），选择对应的镜像启动并完成装机流程。 ![](./../../../assets/NanoKVM/guide/install.png) 注： + 虚拟U盘功能默认打开，如果不需要可通过点击`设置` >`虚拟U盘`关闭。 + 请先在主机上安全弹出原有的21G虚拟U盘后再挂载镜像,以免数据丢失 + 虚拟U盘也可以当作普通U盘使用，web界面未选中任何镜像时，默认挂载整个21G的虚拟U盘。 + 用户也可使用常规的烧卡方式烧录镜像，不推荐 + 镜像拷入 NanoKVM 的速度受到 USB2.0 传输速度和 SG2002 写卡速度的限制，可能会比较慢，用户可将TF卡取出，插入电脑，[解除隐藏](https://jingyan.baidu.com/article/e4511cf34faece2b845eaf34.html)TF卡的第三个分区，直接将镜像拷入其中。 + 虚拟U盘同时挂载到NanoKVM的 `/data` 目录，用户可在 NanoKVM 终端内直接读写该分区 + 设置中的取消虚拟U盘操作将强制弹出U盘,请先安全弹出U盘后再设置,以免数据丢失 ### 网页终端 + 用户点击悬浮栏的`终端` >`NanoKVM 终端`图标，即可打开网页终端，无需ssh直接访问 NanoKVM 系统 + 当 NanoKVM 断网重连或系统重启后，网页终端界面会提示重新登录，账号`root`，密码`root` ![](./../../../assets/NanoKVM/guide/ssh.png) ### 串口终端 NanoKVM 基于 LicheeRV Nano 构建，RVNano 核心板共有3个串口，UART0默认用于输出系统log，在 NanoKVM Full 版中，引出了 UART1/2，用户可自行拓展功能（第一批内测版仅在外壳处开孔） ![](./../../../assets/NanoKVM/guide/uart_to_3H.jpg) 点击管理页面的`终端`，选择`串口终端`，选择使用的串口，填写波特率，点击开始后即可使用 ![](./../../../assets/NanoKVM/guide/uart1.png) ![](./../../../assets/NanoKVM/guide/uart2.png) 注：串口终端功能使用 WebSSH + picocom 搭建，用法同 picocom ### RNDIS NanoKVM 的 USB 会默认虚拟出 RNDIS USB网卡（从设备），当 NanoKVM 服务异常时可用于系统维护，请参照[这里](https://wiki.sipeed.com/hardware/zh/kvm/NanoKVM/system/updating.html#%E9%80%9A%E8%BF%87 usb rndis %E7%BD%91%E5%8F%A3%E8%8E%B7%E5%8F%96)连接电脑，更多用法请自行探索。 若不使用 RNDIS 功能，可点击`设置` >`RNDIS`关闭。 注: 2.1.5 版本后添加 ncm 方式接，但默认还是 RNDIS ，启用方式：`touch /boot/usb.ncm` 或在 /boot 分区下创建 usb.ncm 空文件 ### ATX电源控制 + 在悬浮栏右侧，有电源和硬盘图标，正常情况下是灰色状态，开机后电源图标变绿。 + 点击电源图标可看到重启键、电源键（长/短按） + Full版的ATX控制板受延长线芯数限制，只引出电源、重启按键和电源灯，硬盘灯不亮属正常现象。 ### 设置 + 切换中英文 + 关于NanoKVM：点击打开Wiki + 检查更新：当有可用更新时，用户可点击更新，约15s左右，网页自动刷新重新登录即可更新完成。 + 2.2.5 应用版本后提供预览更新的功能，打开此选项即可拉取到最新的预览版本。 注意：预览版应用一般包含功能更新、问题修复和性能提升，但仍然有概率会引入新的bug，请谨慎更新。 ### 关于SSH + 2.1.6 版本应用后，SSH支持网页开启和永久关闭，请在 设置 > 设备 > SSH 打开或关闭 + 1.4.0 镜像后，SSH默认关闭 1. 永久关闭：执行`touch /etc/kvm/ssh_stop`即可在NanoKVM下一次开机时开始禁用ssh登录，删除该文件`rm /etc/kvm/ssh_stop`即可解除 2. 临时开启：执行`touch /boot/start_ssh_once`或在 /boot 分区下创建 start_ssh_once 空文件，即可在NanoKVM下一次开机时打开ssh，该文件会自动删除 ### 设置DNS + 如果需要设置DNS列表，请在创建/boot/resolv.conf，这将在启动后强制使用你自己的DNS配置 ### 关于mDNS + mDNS（Multicast DNS）是一种用于在局域网内进行名称解析的协议，使设备能够通过主机名而非 IP 地址相互发现和通信。它允许无需中央 DNS 服务器的情况下，自动发现网络中的服务和设备。 + NanoKVM 使用设备码生成 mDNS主机名，可以尽量保证多设备时主机名不冲突 + NanoKVM 设备名可在设置中修改，重启后即可生效 + mDNS 服务在网络环境复杂时会有较高的CPU占用，影响图像的流畅性，建议不使用时将其关闭：设置 > 设备 > mDNS ### 关于看门狗 + 2.2.2 应用版本后新增看门狗系统，将持续监控server服务的运行，服务异常时将重启系统，默认未开启，可以通过在网页终端执行 `touch /etc/kvm/watchdog` 开启，通过`rm /etc/kvm/watchdog` 关闭 ### 更多功能敬请期待 ## 硬件与结构 NanoKVM PCIe 包含 主板 和 USB接口板 两个部分, 通过2P+4P的排线连接, USB接口板仅将 USB HID 和 USB PWR 接口引出, 当需要 USB HID 接主板内部针脚时,可将4P排线断开 PCIe全高挡板通过两颗螺丝固定在主板上,如需替换半高挡板,请拧下螺丝后替换 受限于PCIe规范中接口的位置, HDMI和下方USB距离较近, 部分HDMI胶壳较厚, 可能会和 USB 接口干涉, 请用包装内附赠的 HDMI 线缆连接"},"/hardware/zh/kvm/index.html":{"title":"KVM series","content":" title: KVM series keywords: NanoKVM, Remote desktop, Lichee, PiKVM, RISCV, tool update: date: 2024 06 21 version: v0.1 author: BuGu content: Create file Lichee NanoKVM is Sipeed KVM tool."},"/hardware/zh/modules_spmod/spmod_eink.html":{"title":"SPMOD - Eink","content":"# SPMOD Eink ## 概述 <img src \"../../assets/spmod/spmod_eink/sp_eink.png\" alt \"XXX\" style \"zoom:40%;\" /> SPMOD_Eink(墨水屏模块)采用 GDEW0154M09 电子墨水屏。 ## SPMOD Eink 介绍 采用 **Sipeed SPMOD** 接口(2.54mm * 8PIN 排针)，统一 MaixPy 开发板接口 通过SP MOD SPI接口与屏幕底板相连 电子墨水屏：GDEW0154M09是一款1.54”，SPI接口控制，拥有24P FPC(0.5mm间距)接口的电子墨水屏。拥有超广可视角。 支持 1 bit 黑/白显示 分辨率：200x200 模块尺寸：35*30*3.8mm ### GDEW0154M09 电子墨水屏介绍 功能特点： 参数 工作电压 2.3V~3.6V 工作电流 1~3mA 工作温度范围 40℃~85℃ 休眠电流 <5uA 屏幕大小 1.54英寸 有效显示区域 27.6mm 分辨率 200*200 色彩 1 bit 黑/白显示 对外接口 24P FPC (0.5mm间距) > 内部集成电路包含门缓冲器、源缓冲器，接口，时序控制逻辑，振荡器，DC DC，SRAM，LUT，VCOM ### SPMOD_Eink 模块引脚定义： 引脚序号 引脚名称 类型 引脚说明 1 GND G 模块电源地 2 CS I SPI片选引脚 3 D/C I 数据/命令输入切换引脚 4 RES I 模块复位引脚，低有效 5 3V3 V 模块电源输入正 6 SCK I SPI串行时钟引脚 7 SI I/O MOSI数据引脚，主机输出从机输入 8 BSY O BUSY状态输出引脚 <img src \"../../assets/spmod/spmod_eink/sp_eink_back.png\" height \"300\" /> 接线方式： MCU:FUN(IO) SP_Eink : : : : GPIOHS(IO_7) RES SPIOHS(IO_15) D/C SPIOHS(IO_20) CS SPI:SCK(IO_21) SCK SPI:MOSI(IO_8) SI GPIOHS(IO_6) BSY 2.3 3.6V 3.3V GND GND <img src \"../../assets/spmod/spmod_eink/connection.png\" height \"250\"> ### 基本指令列表 指令 功能 : : : : 0x10 开始发送黑白图像 0x13 开始发送红白图像 0x12 刷新图像到屏幕 *更多指令信息参考[GDEW0154M09.pdf](https://dl.sipeed.com/shareURL/MAIX/HDK/Spmod_CN/sp_eink)* ## 使用例程 * 流程 1. 初始化配置 2. 创建 Image 并填充 3. 发送图像并刷新 ### C 示例： ```c spi_init(1, SPI_WORK_MODE_0, SPI_FF_STANDARD, DATALENGTH, 0); fpioa_set_function(SPI_Eink_CS_PIN_NUM, FUNC_SPI1_SS0); // SPI_Eink_CS_PIN_NUM: 20; fpioa_set_function(SPI_Eink_SCK_PIN_NUM, FUNC_SPI1_SCLK); // SPI_Eink_SCK_PIN_NUM: 21; fpioa_set_function(SPI_Eink_MOSI_PIN_NUM, FUNC_SPI1_D0); // SPI_Eink_MOSI_PIN_NUM: 8; fpioa_set_function(SPI_Eink_DC_PIN_NUM, FUNC_GPIOHS0 + SPI_Eink_DC_GPIO_NUM); // SPI_Eink_DC_PIN_NUM: 21; fpioa_set_function(SPI_Eink_RST_PIN_NUM, FUNC_GPIOHS0 + SPI_Eink_RST_GPIO_NUM); // SPI_Eink_RST_PIN_NUM: 7; fpioa_set_function(SPI_Eink_BL_PIN_NUM, FUNC_GPIOHS0 + SPI_Eink_BL_GPIO_NUM); // SPI_Eink_BL_PIN_NUM: 6; gpiohs_set_drive_mode(SPI_Eink_DC_GPIO_NUM, GPIO_DM_OUTPUT); gpiohs_set_drive_mode(SPI_Eink_RST_GPIO_NUM, GPIO_DM_OUTPUT); gpiohs_set_pin(SPI_Eink_DC_GPIO_NUM, GPIO_PV_HIGH); gpiohs_set_pin(SPI_Eink_RST_GPIO_NUM, GPIO_PV_HIGH); gpiohs_set_drive_mode(SPI_Eink_BL_PIN_NUM, GPIO_DM_INPUT_PULL_UP); gpiohs_set_pin_edge(SPI_Eink_BL_PIN_NUM, GPIO_PE_BOTH); EPD_DisplayInit(); //EPD init //Paint initialization Paint_NewImage(BlackImage, EPD_WIDTH, EPD_HEIGHT, 270, WHITE); //Set screen size and display orientation Paint_SelectImage(BlackImage); //Set the virtual canvas data storage location Paint_Clear(WHITE); //clear paint Paint_DrawString_EN(0, 0, \"sipeed\", &Font8, WHITE, BLACK); //5*8 Paint_DrawString_EN(0, 10, \"sipeed\", &Font12, WHITE, BLACK); //7*12 Paint_DrawString_EN(0, 25, \"sipeed\", &Font16, WHITE, BLACK); //11*16 Paint_DrawString_EN(0, 45, \"sipeed\", &Font20, WHITE, BLACK); //14*20 Paint_DrawString_EN(0, 80, \"sipeed\", &Font24, WHITE, BLACK); //17*24 EPD_FullDisplay(BlackImage, BlackImage, 0); //display image ``` ### MaixPy 例程： ```python spi1 SPI(SPI.SPI1, mode SPI.MODE_MASTER, baudrate 600 * 1000, polarity 0, phase 0, bits 8, firstbit SPI.MSB, sck 21, mosi 8) fm.register(20, fm.fpioa.GPIOHS20, force True) # SPI_Eink_SS_PIN_NUM: 20; fm.register(15, fm.fpioa.GPIOHS15, force True) # SPI_Eink_DC_PIN_NUM: 15; fm.register(6, fm.fpioa.GPIOHS6, force True) # SPI_Eink_BUSY_PIN_NUM: 6; fm.register(7, fm.fpioa.GPIOHS7, force True) # SPI_Eink_RST_PIN_NUM: 7; cs GPIO(GPIO.GPIOHS20, GPIO.OUT) dc GPIO(GPIO.GPIOHS15, GPIO.OUT) busy GPIO(GPIO.GPIOHS6, GPIO.IN, GPIO.PULL_DOWN) rst GPIO(GPIO.GPIOHS7, GPIO.OUT) epd SPEink(spi1, cs, dc, rst, busy, SPEink_WIDTH, SPEink_HEIGHT, SPEink_ROTATION) epd.init() img image.Image() img img.resize(200, 200) img.draw_line(0, 0, 100, 100) epd.display(img) ``` ### 运行环境 语言 开发板 SDK/固件版本 : : : : : : C MaixCube kendryte standalone sdk v0.5.6 MaixPy MaixCube maixpy v0.5.1 *MaixPy固件建议自行从最新源码编译* ### 运行结果 * C <img src \"../../assets/spmod/spmod_eink/sp_eink_c.png\" height \"250\" /> * MaixPy <img src \"../../assets/spmod/spmod_eink/sp_eink_py.png\" height \"250\" /> ### 移植 修改以下参数即可 * C ```c // board_config.h #define SPI_INDEX 1 #define SPI_SCLK_RATE 600 * 1000 #define SPI_CHIP_SELECT_NSS 0 //SPI_CHIP_SELECT_0 #define SPI_Eink_CS_PIN_NUM 20 #define SPI_Eink_SCK_PIN_NUM 21 #define SPI_Eink_MOSI_PIN_NUM 8 #define SPI_Eink_DC_PIN_NUM 15 #define SPI_Eink_BL_PIN_NUM 6 #define SPI_Eink_RST_PIN_NUM 7 #define SPI_Eink_DC_GPIO_NUM 15 #define SPI_Eink_BL_GPIO_NUM 6 #define SPI_Eink_RST_GPIO_NUM 7 ``` * MaixPy ```python ################### config ################### SPI_Eink_NUM SPI.SPI1 SPI_Eink_DC_PIN_NUM const(15) SPI_Eink_BUSY_PIN_NUM const(6) SPI_Eink_RST_PIN_NUM const(7) SPI_Eink_CS_PIN_NUM const(20) SPI_Eink_SCK_PIN_NUM const(21) SPI_Eink_MOSI_PIN_NUM const(8) SPI_Eink_FREQ_KHZ const(600) ############################################## ``` ## 参考设计 SPMOD_Eink 尺寸图： <img src \"../../assets/spmod/spmod_eink/sipeed_spmod_eink.png\" height \"250\" /> ## 资源链接 资源 官网 www.sipeed.com SIPEED 官方淘宝店 [sipeed.taobao.com](sipeed.taobao.com) Github [https://github.com/sipeed](https://github.com/sipeed) BBS [http://bbs.sipeed.com](http://bbs.sipeed.com) MaixPy 文档官网 [http://maixpy.sipeed.com](http://wiki.sipeed.com/maixpy) Sipeed 模型平台 [https://maixhub.com](https://maixhub.com) SDK 相关信息 [https://dl.sipeed.com/shareURL/MAIX/SDK](https://dl.sipeed.com/shareURL/MAIX/SDK) HDK 相关信息 [https://dl.sipeed.com/shareURL/MAIX/HDK](https://dl.sipeed.com/shareURL/MAIX/HDK) E mail(技术支持和商业合作) [Support@sipeed.com](mailto:support@sipeed.com) telgram link https://t.me/sipeed MaixPy AI QQ 交流群 862340358 "},"/hardware/zh/modules_spmod/spmod_extender.html":{"title":"SPMOD - Extender","content":"# SPMOD Extender ## 概述 ![](../../assets/spmod/spmod_extender/sp_extender.png) SPMOD_Extender(8PIN扩展模块) ## SPMOD Extender 介绍 采用 **Sipeed SPMOD** 接口(2.54mm * 8PIN 排针)，统一 MaixPy 开发板接口 利用SP Extender将SP MOD一分为四，包含三个相连的2线接口（连接至SP MOD的D0和D1）和一个单独的四线接口（连接至SP MOD的D2 D5） 模块尺寸：35.0\\*20.0\\*1.6mm ## 概括 功能特点： 参数 两线SP MOD接口*3 连接至SP MOD的D0和D1，可用作UART (最多连接一个设备)或I2C（最多连接三个设备）或者两个独立的GPIO 四线SP MOD接口 连接至SP MOD的D2 D5，通常用作SPI接口，也可用作四个杜立的GPIO接口 外部供电电压 视连接的模块而定 外部供电电流 视模块工作情况而定，通常小于1000mA 工作温度 40℃ ~ 85℃ ## 参考设计 SPMOD_Extender 尺寸图： <img src \"../../assets/spmod/spmod_extender/sipeed_spmod_extender.png\" height \"250\" /> ## 资源链接 资源 官网 www.sipeed.com SIPEED 官方淘宝店 [sipeed.taobao.com](sipeed.taobao.com) Github [https://github.com/sipeed](https://github.com/sipeed) BBS [http://bbs.sipeed.com](http://bbs.sipeed.com) MaixPy 文档官网 [http://maixpy.sipeed.com](http://wiki.sipeed.com/maixpy) Sipeed 模型平台 [https://maix.sipeed.com](https://maix.sipeed.com) SDK 相关信息 [https://dl.sipeed.com/MAIX/SDK](https://dl.sipeed.com/MAIX/SDK) HDK 相关信息 [https://dl.sipeed.com/MAIX/HDK](https://dl.sipeed.com/MAIX/HDK) E mail(技术支持和商业合作) [Support@sipeed.com](mailto:support@sipeed.com) telgram link https://t.me/sipeed MaixPy AI QQ 交流群（四群） 862340358"},"/hardware/zh/modules_spmod/spmod_tof.html":{"title":"SPMOD - TOF","content":"# SPMOD TOF ## 概述 <img src \"../../assets/spmod/spmod_tof/sp_tof.png\" style \"padding right:100px;\" width \"\" height \"300\" /> SPMOD_TOF(TOF 模块) 采用 VL53L0X 模块。 ## SPMOD TOF 介绍 采用 **Sipeed SPMOD** 接口(2.54mm * 8PIN 排针)，统一 MaixPy 开发板接口 利用SP MOD I2C 和 TOF 模块通讯 ToF模块：VL53L0X模块是一个I2C接口，长距离单点飞行时间测定（ToF）模块，它具有高性能和可靠性 最远测量距离4000mm，最高50Hz的测量刷新率。典型前方测量角度27° 可选配红色激光器瞄准头，通过XSHUT引脚控制激光器开关 模块尺寸：25.0\\*10\\*3.15mm ### VL53L0X 介绍 VL53L0X 功能特性： 测量距离 最大 4000mm(4m) 工作刷新率 50Hz 测量角度（正面） 27° 通信接口 I2C 工作电压 2.6V~3.5V (选用红色激光时： 2.8V~3.3V) 工作状态电流 18mA (选用红色激光时： 20mA) 工作温度 40℃ 80℃ 睡眠状态电流 5uA ### SPMOD_TOF 模块引脚定义： 引脚序号 引脚名称 类型 引脚说明 1 GND G 模块电源地 2 IRQ I 模块中断输入引脚，连接至 VL53L0X 的GPIO1 3 NC NC 悬空引脚，无功能 4 SDA I/O 模块 I2C 串行数据引脚 5 3V3 V 模块电源输入正 6 NC NC 悬空引脚，无功能 7 SHT I 模块休眠&激光头控制引脚 #注释 8 SCL I 模块 I2C 串行时钟引脚 > SHT 低电平时，模块休眠 &激光头关闭 <img src \"../../assets/spmod/spmod_tof/back.png\" height \"300\" /> 接线方式: MCU:FUN(IO) SP_RFID : : : : I2C:SDA(IO_7) SDA NC(IO_15) NC NC(IO_20) IRQ NC(IO_21) NC GPIOHS(IO_8) SHT I2C:SCL(IO_6) SCL 2.8~3.5V 3.3V GND GND <img src \"../../assets/spmod/spmod_tof/connection.png\" height \"250\"> ## 使用例程 * 流程 1. 初始化 2. 校准(可选) 3. 读取距离(多种模式可选) ### C 示例： ```c //set io mux fpioa_set_function(VL53L0X_SCL, FUNC_I2C0_SCLK + VL53L0X_I2C_DEVICE * 2); fpioa_set_function(VL53L0X_SDA, FUNC_I2C0_SDA + VL53L0X_I2C_DEVICE * 2); fpioa_set_function(VL53L0X_SHT, FUNC_GPIOHS0 + VL53L0X_SHT); gpiohs_set_drive_mode(VL53L0X_SHT, GPIO_DM_OUTPUT); //i2c init maix_i2c_init(VL53L0X_I2C_DEVICE, 7, VL53L0X_I2C_FREQ_KHZ * 1000); while (vl53l0x_init(&vl53l0x_dev)) { printf(\"VL53L0X init error!!!\\r\\n\"); msleep(500); } printf(\"VL53L0X init success!\\r\\n\"); // adjusting printf(\"VL53L0X adjusting\\r\\n\"); vl53l0x_calibration_test(&vl53l0x_dev); // get distance printf(\"VL53L0X start work\\r\\n\"); vl53l0x_general_test(&vl53l0x_dev); ``` ### MaixPy 例程： ```python fm.register(VL53L0X_SHT, fm.fpioa.GPIOHS0, force True) XSHUT GPIO(GPIO.GPIOHS0, GPIO.OUT) i2c I2C(VL53L0X_I2C_NUM, freq VL53L0X_FREQ, scl VL53L0X_SCL, sda VL53L0X_SDA) # create obj and read distance \t tof VL53L0X(i2c) \t while True: mm tof.read() utime.sleep_ms(100) print(mm) ``` ### 运行环境 语言 开发板 SDK/固件版本 : : : : C MaixCube kendryte standalone sdk v0.5.6 MaixPy MaixCube maixpy v0.5.1 ### 运行结果 * C <img src \"../../assets/spmod/spmod_tof/log_c.png\" height \"200\" /> * MaixPy [None] ## 移植 修改以下参数即可适配其他 K210 开发板. * C ```c // board_config.h #define VL53L0X_I2C_DEVICE 0 // i2c device number #define VL53L0X_I2C_FREQ_KHZ 100 // i2c frequence #define VL53L0X_SCL 6 // scl #define VL53L0X_SDA 7 // sda #define VL53L0X_SHT 8 // sht ``` * MaixPy ```python ################### config ################### VL53L0X_I2C_NUM const(I2C.I2C0) VL53L0X_FREQ const(100000) VL53L0X_SCL const(6) VL53L0X_SDA const(7) VL53L0X_SHT const(8) ############################################## ``` ## 参考设计 SPMOD_TOF 尺寸图： <img src \"../../assets/spmod/spmod_tof/sipeed_spmod_tof.png\" height \"250\" /> ## 资源链接 资源 官网 www.sipeed.com SIPEED 官方淘宝店 [sipeed.taobao.com](sipeed.taobao.com) Github [https://github.com/sipeed](https://github.com/sipeed) BBS [http://bbs.sipeed.com](http://bbs.sipeed.com) MaixPy 文档官网 [http://maixpy.sipeed.com](http://wiki.sipeed.com/maixpy) Sipeed 模型平台 [https://maix.sipeed.com](https://maix.sipeed.com) SDK 相关信息 [https://dl.sipeed.com/MAIX/SDK](https://dl.sipeed.com/MAIX/SDK) HDK 相关信息 [https://dl.sipeed.com/MAIX/HDK](https://dl.sipeed.com/MAIX/HDK) E mail(技术支持和商业合作) [Support@sipeed.com](mailto:support@sipeed.com) telgram link https://t.me/sipeed MaixPy AI QQ 交流群（四群） 862340358"},"/hardware/zh/modules_spmod/spmod_joystick.html":{"title":"SPMOD - JoyStick","content":"# SPMOD JoyStick ## 概述 <img src \"../../assets/spmod/spmod_joystick/sp_joystick.png\" width \"\" height \"300\" /> SPMOD_JoyStick (JoyStick模块)。 ## SPMOD JoyStick 介绍 采用 **Sipeed SPMOD** 接口(2.54mm * 8PIN 排针)，统一 MaixPy 开发板接口 通过SP MOD SPI接口连接 可通过外部适配器单独连接7.2V~9V DC，为手柄的振动马达供电 内置升压电路，轻松驱动手柄 PSX/PS2兼容 模块尺寸：35.0\\*20.0\\*13.3mm ### SPMOD_JoyStick 模块引脚定义： 引脚序号 引脚名称 类型 引脚说明 1 GND G 模块电源地 2 CS I SPI片选引脚 3 SO I/O MISO数据引脚，手柄信号输出 4 NC NC 悬空引脚，无功能 5 3V3 V 模块电源输入正 6 SCK I SPI串行时钟引脚 7 SI I/O MOSI数据引脚，手柄信号输入 8 ACK O 确认信号输出引脚 <img src \"\" width \"500\" /> ## 使用例程 待更新 ## 参考设计 SPMOD_JoyStick 尺寸图： <img src \"../../assets/spmod/spmod_joystick/sipeed_spmod_joystick.png\" height \"250\" /> ## 资源链接 资源 链接 官网 www.sipeed.com SIPEED 官方淘宝店 [sipeed.taobao.com](sipeed.taobao.com) Github [https://github.com/sipeed](https://github.com/sipeed) BBS [http://bbs.sipeed.com](http://bbs.sipeed.com) MaixPy 文档官网 [http://maixpy.sipeed.com](http://wiki.sipeed.com/maixpy) Sipeed 模型平台 [https://maix.sipeed.com](https://maix.sipeed.com) SDK 相关信息 [https://dl.sipeed.com/MAIX/SDK](https://dl.sipeed.com/MAIX/SDK) HDK 相关信息 [https://dl.sipeed.com/MAIX/HDK](https://dl.sipeed.com/MAIX/HDK) E mail(技术支持和商业合作) [Support@sipeed.com](mailto:support@sipeed.com) telgram link https://t.me/sipeed MaixPy AI QQ 交流群（四群） 862340358"},"/hardware/zh/modules_spmod/spmod_lora.html":{"title":"SPMOD - LoRa","content":"# SPMOD LoRa ## 概述 <img src \"../../assets/spmod/spmod_lora/sp_lora.png\" width \"\" height \"300\" /> SPMOD_LoRa(LoRa 模块)采用 M XL8 模块。 ## SPMOD LoRa 介绍 采用 **Sipeed SPMOD** 接口(2.54mm * 8PIN 排针)，统一 MaixPy 开发板接口 利用 SP MOD SPI 和 LoRa 模块通讯 LoRa 模块：M XL8 SX1276 模块是一个 SPI 接口，内置 LoRaTM 调制解调器和可调功率放大器的 LoRa 模块，它具有高性能和可靠性 370MHz 1200MHz, 最大20dBm (100mW)持续发射功率 模块尺寸：25.0\\*10.0\\*4.3mm ### M XL8 SX1276 LoRa 模块 介绍 功能特点： 参数 工作频段 370MHz 1200Mhz 发射功率 20dBm（最大） 通信接口 SPI 工作电压 1.8V~6.3V 工作温度 40℃ 80℃ 天线 外置天线，IPEX或焊接 接收灵敏度 148dbm RSSI动态范围 127dB 最大链路预算 168dB 收发状态电流 9.9mA 睡眠状态电流 50nA 调制方式 FSK, GFSK, MSK, GMSK, LoRaTM及OOK > 内置LoRaTM调制解调器，内置CRC，继承+12dBm可调PA+LNA ### SPMOD_lora 模块引脚定义： 引脚序号 引脚名称 类型 引脚说明 1 GND G 模块电源地 2 CS I/O SPI片选引脚 3 SO I/O MISO数据引脚，主机输入从机输出 4 RST I 模块复位引脚，低有效 5 3V3 V 模块电源输入正 6 SCK I SPI串行时钟引脚 7 SI I/O MOSI数据引脚，主机输出从机输入 8 IRQ I 连接至模块DIO0，可编程决定功能 <img src \"../../assets/spmod/spmod_lora/back.png\" width \"300\" /> 接线方式: MCU:FUN(IO) SP_LCD : : : : GPIOHS7(IO_7) RST SPI:MISO(IO_15) SO SPI:SS0(IO_20) CS SPI:SCK(IO_21) SCK SPI:MOSI(IO_8) SI GPIOH(IO_6) IRQ 1.8 6.3V 3.3V GND GND <img src \"../../assets/spmod/spmod_lora//connection.png\" height \"250\"> ## 使用例程 * 流程 1. 创建 LoRa 对象并初始化 2. 发送或者接收数据 ### C 示例： ```c fpioa_set_function(SPI_LoRa_SX127X_CS_PIN_NUM, FUNC_SPI1_SS0); // CS: 20 fpioa_set_function(SPI_LoRa_SX127X_SCK_PIN_NUM, FUNC_SPI1_SCLK); // SCLK: 21 fpioa_set_function(SPI_LoRa_SX127X_MOSI_PIN_NUM, FUNC_SPI1_D0); // MOSI: 8 fpioa_set_function(SPI_LoRa_SX127X_MISO_PIN_NUM, FUNC_SPI1_D1); // MISO: 15 fpioa_set_function(SPI_LoRa_SX127X_IRQ_PIN_NUM, FUNC_GPIOHS0 + SPI_LoRa_SX127X_IQR_GPIO_NUM); // IQR: 6 fpioa_set_function(SPI_LoRa_SX127X_RST_PIN_NUM, FUNC_GPIOHS0 + SPI_LoRa_SX127X_RST_GPIO_NUM); // RST: 7 spi_init(SPI_DEVICE_1, SPI_WORK_MODE_0, SPI_FF_STANDARD, DATALENGTH, 0); sx1278_begin(&SX1278, SX1278_433MHZ, SX1278_POWER_17DBM, SX1278_LoRa_SF_8, SX1278_LoRa_BW_20_8KHZ, 10); if (master 1) { printf(\" MASTER \\r\\n\"); ret sx1278_LoRaEntryTx(&SX1278, 16, 2000); } else { printf(\" SALAVE \\r\\n\"); ret sx1278_LoRaEntryRx(&SX1278, 16, 2000); } ``` ### MaixPy 例程： ```python fm.register(20, fm.fpioa.GPIOHS20, force True) # RST fm.register(7, fm.fpioa.GPIOHS7, force True) # CS # set gpiohs work mode to output mode cs GPIO(GPIO.GPIOHS20, GPIO.OUT) rst GPIO(GPIO.GPIOHS7, GPIO.IN) # The other pins are configured at SPI initialization time spi1 SPI(SPI.SPI1, mode SPI.MODE_MASTER, baudrate 100 * 1000, polarity 0, phase 0, bits 8, firstbit SPI.MSB, sck 21, mosi 8, miso 15) lora SX127x(spi spi1, pin_ss cs) lora.init() #######receiver########### receive(lora) ########sender########### # send(lora) ``` ### 运行环境 语言 开发板 SDK/固件版本 : : : : : : C MaixCube kendryte standalone sdk v0.5.6 MaixPy MaixCube maixpy v0.5.1 *MaixPy固件建议自行从最新源码编译* ### 运行结果 * C <center class \"third\"> \t <img src \"../../assets/spmod/spmod_lora/lora_send_log_c.png\" height \"250\"/><img src \"../../assets/spmod/spmod_lora/lora_recv_log_c.png\" height \"250\"/> </center> * MaixPy <center class \"third\"> \t <img src \"../../assets/spmod/spmod_lora/lora_send_log.png\" height \"250\"/><img src \"../../assets/spmod/spmod_lora/lora_recv_log.png\" height \"250\"/> </center> ### 移植 修改以下参数即可适配其他 K210 开发板. * C ```c // board_config.h #define SPI_INDEX 1 #define SPI_SCLK_RATE 600*1000 #define SPI_CHIP_SELECT_NSS 0//SPI_CHIP_SELECT_0 #define SPI_LoRa_SX127X_CS_PIN_NUM 20 #define SPI_LoRa_SX127X_SCK_PIN_NUM 21 #define SPI_LoRa_SX127X_MOSI_PIN_NUM 8 #define SPI_LoRa_SX127X_MISO_PIN_NUM 15 #define SPI_LoRa_SX127X_IRQ_PIN_NUM 6 #define SPI_LoRa_SX127X_RST_PIN_NUM 7 #define SPI_LoRa_SX127X_IQR_GPIO_NUM 6 #define SPI_LoRa_SX127X_RST_GPIO_NUM 7 ``` * MaixPy ```python ################### config ################### LoRa_RST const(20) LoRa_CS const(7) LoRa_SPI_SCK const(21) LoRa_SPI_MOSI const(8) LoRa_SPI_MISO const(15) LoRa_SPI_NUM SPI.SPI1 LoRa_SPI_FREQ_KHZ const(100) ############################################## ``` ## 参考设计 SPMOD_LoRa 尺寸图： <img src \"../../assets/spmod/spmod_lora/sipeed_spmod_lora.png\" height \"250\" /> ## 资源链接 资源 官网 www.sipeed.com SIPEED 官方淘宝店 [sipeed.taobao.com](sipeed.taobao.com) Github [https://github.com/sipeed](https://github.com/sipeed) BBS [http://bbs.sipeed.com](http://bbs.sipeed.com) MaixPy 文档官网 [http://maixpy.sipeed.com](http://wiki.sipeed.com/maixpy) Sipeed 模型平台 [https://maix.sipeed.com](https://maix.sipeed.com) SDK 相关信息 [https://dl.sipeed.com/MAIX/SDK](https://dl.sipeed.com/MAIX/SDK) HDK 相关信息 [https://dl.sipeed.com/MAIX/HDK](https://dl.sipeed.com/MAIX/HDK) E mail(技术支持和商业合作) [Support@sipeed.com](mailto:support@sipeed.com) telgram link https://t.me/sipeed MaixPy AI QQ 交流群（四群） 862340358"},"/hardware/zh/modules_spmod/spmod_weather.html":{"title":"SPMOD - Weather","content":"# SPMOD Weather ## 概述 <img src \"../../assets/spmod/spmod_weather/sp_weather.png\" SPMOD Weather (气象站模块), 集成三轴传感器 QMC7983,与温湿度气压传感器 BME280。 <img src \"../../assets/spmod/spmod_weather/demo.gif\" width \"500\" > ## SPMOD Weather 介绍 特性： 采用 **Sipeed SPMOD** 接口(2*4PIN 2.54mm 排针)，统一 MaixPy 开发板接口 通过SP MOD I2C接口连接 磁性传感器：QMC7983是一个内置灵敏度补偿与NTC的三轴磁性传感器，I2C接口输出（最高频率400KHz），具有出色的动态范围和精度以及超低的功耗 磁感应量程：±30 高斯 温湿度气压传感器：BME280是同时集成了温湿度与气压传感器的数字传感器 模块尺寸：25.0\\*10\\*2.9mm ## 传感器特性： 磁性传感器 QMC7983 工作电压 2.6V~3.6V 工作电流 70uA 休眠电流 <1uA 磁感应量程 ±30 高斯 精度 每 LSB 1mG RMS 噪声 2 mG 对外接口 I2C，默认地址 0x2C,可通过选择电阻调节 温湿度气压传感器 BME280 工作电压 1.71V~3.6V 工作电流 <633uA 休眠电流 <5uA 湿度传感器的关键参数： 响应时间（𝜏63％） 1s 精度公差 ±3％ 相对湿度 磁滞 < 2％ 相对湿度 气压力传感器的关键参数： RMS 噪声 0.2 Pa（等效 到海拔 1.7 厘米） 偏移温度系数 ±1.5 Pa/K（等效温度变化 1°C 时，达到海拔 ±12.6 cm1s） 对外接口 I2C，默认地址 0x76, 可通过选择电阻调节 ### SPMOD_Weather 模块引脚定义： 引脚序号 引脚名称 类型 引脚说明 1 GND G 模块电源地 2 NC NC 悬空引脚，无功能 3 NC NC 悬空引脚，无功能 4 SDA I/O 模块I2C串行数据引脚 5 3V3 V 模块电源输入正 6 NC NC 悬空引脚，无功能 7 NC NC 悬空引脚，无功能 8 SCL I 模块I2C串行时钟引脚 <img src \"../../assets/spmod/spmod_weather/back.png\" width \"300\" /> ## 接线方式 <img src \"../../assets/spmod/spmod_weather/connection.png\" height \"250\"> MCU:FUN(IO) SP_RFID : : : : I2C:SDA(IO_7) SDA NC(IO_15) NC NC(IO_20) IRQ NC(IO_21) NC GPIOHS(IO_8) SHT I2C:SCL(IO_6) SCL 2.8~3.5V 3.3V GND GND ## 使用例程 * 流程 1. 初始化 weather SPWeather(i2c i2c_bus) # create sp_weather while 1: time.sleep_ms(500) print(weather.qmc_read_xyz) # QMC7983 read data print(weather.bme_values) # BME280 read data 2. 校准(可选) 3. 读取距离(多种模式可选) ### C 示例： ```c fpioa_set_function(Weather_SCL, FUNC_I2C0_SCLK + Weather_I2C_DEVICE * 2); // Weather_SCL: 6; fpioa_set_function(Weather_SDA, FUNC_I2C0_SDA + Weather_I2C_DEVICE * 2); // Weather_SDA: 7; maix_i2c_init(Weather_I2C_DEVICE, 7, 400000); // Weather_I2C_DEVICE: 0; rslt qmc_init(); // Magnetic sensor QMC7983 init rslt bme280_init(&dev); // Temperature, humidity and pressure sensors BME280 init stream_sensor_data_normal_mode(&dev); // read and print sensor data ``` ### MaixPy 例程： ```python i2c_bus I2C(I2C.I2C0, freq 100*1000, scl 6, sda 7) # scl: io_6, sda: io_7 weather SPWeather(i2c i2c_bus) # create sp_weather while 1: time.sleep_ms(500) print(weather.qmc_read_xyz) # QMC7983 read data print(weather.bme_values) # BME280 read data ``` ## 运行环境 语言 开发板 SDK/固件版本 : : : : : C MaixCube kendryte standalone sdk v0.5.6 MaixPy MaixCube maixpy v0.5.1 ## 运行结果 * C <img src \"../../assets/spmod/spmod_weather/log_c.png\" height \"200\"> * MaixPy <img src \"../../assets/spmod/spmod_weather/log_py.png\" height \"200\"> ## 参考设计 SPMOD_Weather 尺寸图： <img src \"../../assets/spmod/spmod_weather/sipeed_spmod_weather.png\" height \"250\" /> ## 资源链接 资源 官网 www.sipeed.com SIPEED 官方淘宝店 [sipeed.taobao.com](sipeed.taobao.com) Github [https://github.com/sipeed](https://github.com/sipeed) BBS [http://bbs.sipeed.com](http://bbs.sipeed.com) MaixPy 文档官网 [http://maixpy.sipeed.com](http://wiki.sipeed.com/maixpy) Sipeed 模型平台 [https://maix.sipeed.com](https://maix.sipeed.com) SDK 相关信息 [https://dl.sipeed.com/MAIX/SDK](https://dl.sipeed.com/MAIX/SDK) HDK 相关信息 [https://dl.sipeed.com/MAIX/HDK](https://dl.sipeed.com/MAIX/HDK) E mail(技术支持和商业合作) [Support@sipeed.com](mailto:support@sipeed.com) telgram link https://t.me/sipeed MaixPy AI QQ 交流群（四群） 862340358"},"/hardware/zh/modules_spmod/spmod_grove.html":{"title":"SPMOD - Grove","content":"# SPMOD Grove ## 概述 <img src \"../../assets/spmod/spmod_grove/sp_grove.png\" width \"\" height \"400\" /> SPMOD_Grove(GROVE 模块) ## SPMOD Grove 介绍 采用 **Sipeed SPMOD** 接口(2.54mm * 8PIN 排针)，统一 MaixPy 开发板接口 作为拓展版，提供三个标准的Grove接口。方便您将Grove模块与SP MOD一起使用。 每条数据线均提供外部上拉。 提供高达1000mA的供电能力。 模块尺寸：35.0\\*10.0\\*2.1mm ## 概括 功能特点： 参数 Grove 连接器 (HY 2.0mm 4P连接器)*3 用于连接Grove线缆 排针4*2，间距2.54mm *1 用于和SP MOD接口连接 外部供电电压 视连接的模块而定 外部供电电流 视模块工作情况而定，通常小于1000mA 工作温度 30℃ ~ 85℃ ## 参考设计 SPMOD_Grove 尺寸图： <img src \"../../assets/spmod/spmod_grove/sipeed_spmod_grove.png\" height \"250\" /> ## 资源链接 资源 官网 www.sipeed.com SIPEED 官方淘宝店 [sipeed.taobao.com](sipeed.taobao.com) Github [https://github.com/sipeed](https://github.com/sipeed) BBS [http://bbs.sipeed.com](http://bbs.sipeed.com) MaixPy 文档官网 [http://maixpy.sipeed.com](http://wiki.sipeed.com/maixpy) Sipeed 模型平台 [https://maix.sipeed.com](https://maix.sipeed.com) SDK 相关信息 [https://dl.sipeed.com/MAIX/SDK](https://dl.sipeed.com/MAIX/SDK) HDK 相关信息 [https://dl.sipeed.com/MAIX/HDK](https://dl.sipeed.com/MAIX/HDK) E mail(技术支持和商业合作) [Support@sipeed.com](mailto:support@sipeed.com) telgram link https://t.me/sipeed MaixPy AI QQ 交流群 （四群） 862340358"},"/hardware/zh/modules_spmod/spmod_lcd1.14.html":{"title":"SPMOD - LCD 1.14","content":"# SPMOD LCD 1.14 ## 概述 ![](../../assets/spmod/spmod_lcd1.14/sp_lcd.png) SPMOD_LCD1.14(1.14寸 LCD 屏幕模块)采用 ST7735S TFT LCD屏。 ## SPMOD LCD1.14 介绍 采用 **Sipeed SPMOD** 接口(2.54mm * 8PIN 排针)，统一 MaixPy 开发板接口 采用常见 LCD 驱动 IC ST7735S(4 线 SPI 通讯) 分辨率：240\\*135 模块尺寸：35.0\\*20.0mm ### ST7735S TFT LCD屏 介绍 功能特点： 参数 工作电压 2.5V~4.8V 工作电流 <20mA 工作温度 30℃ ~ 85℃ 休眠电流 <0.1mA 屏幕大小 1.14英寸 有效显示区域 1.7mm * 10.8mm 分辨率 160*80 色彩 132个RGB通道 对外接口 8P FPC (0.5mm间距) > 内部集成电路包含DC / DC转换器、可调VCOM生成器、非易失性（NV）存储器（用于存储初始寄存器设置）、显示时钟的振荡器以及时序控制器 ### SPMOD_LCD1.14 模块引脚定义： 引脚序号 引脚名称 类型 引脚说明 1 GND G 模块电源地 2 CS I SPI片选引脚 3 D/C I 数据/命令输入切换引脚 4 RST I 模块复位引脚，低有效 5 3V3 V 模块电源输入正 6 SCK I SPI串行时钟引脚 7 SI I/O MOSI数据引脚，主机输出从机输入 8 BL I 背光控制引脚，低电平关闭背光 <img src \"../../assets/spmod/spmod_lcd1.14/back.png\" width \"300\" /> 接线方式: MCU:FUN(IO) SP_LCD : : : : GPIOHS7(IO_7) RST GPIOHS15(IO_15) D/C SPI:SS0(IO_20) CS SPI:SCK(IO_21) SCK SPI:MOSI(IO_8) SI GPIOHS6(IO_6) BL 2.5~4.8V 3.3V GND GND <img src \"../../assets/spmod/spmod_lcd1.14//connection.png\" height \"250\"> ## 使用例程 * 流程 1. 初始化配置 2. 创建 Image 并填充 3. 发送图像并刷新 ### C 示例： ```c fpioa_set_function(SPI_IPS_LCD_CS_PIN_NUM, FUNC_SPI1_SS0); // SPI_IPS_LCD_CS_PIN_NUM: 20; fpioa_set_function(SPI_IPS_LCD_SCK_PIN_NUM, FUNC_SPI1_SCLK); // SPI_IPS_LCD_SCK_PIN_NUM: 21; fpioa_set_function(SPI_IPS_LCD_MOSI_PIN_NUM, FUNC_SPI1_D0); // SPI_IPS_LCD_MOSI_PIN_NUM: 8; fpioa_set_function(SPI_IPS_LCD_DC_PIN_NUM, FUNC_GPIOHS0 + SPI_IPS_LCD_DC_GPIO_NUM); // SPI_IPS_LCD_DC_PIN_NUM: 15; SPI_IPS_LCD_DC_GPIO_NUM: 15; fpioa_set_function(SPI_IPS_LCD_RST_PIN_NUM, FUNC_GPIOHS0 + SPI_IPS_LCD_RST_GPIO_NUM); // SPI_IPS_LCD_RST_PIN_NUM: 7; SPI_IPS_LCD_RST_GPIO_NUM: 7; fpioa_set_function(SPI_IPS_LCD_BL_PIN_NUM, FUNC_GPIOHS0 + SPI_IPS_LCD_BL_GPIO_NUM); // SPI_IPS_LCD_BL_PIN_NUM: 6; SPI_IPS_LCD_BL_GPIO_NUM: 6; // set gpiohs work mode to output mode gpiohs_set_drive_mode(SPI_IPS_LCD_DC_GPIO_NUM, GPIO_DM_OUTPUT); gpiohs_set_drive_mode(SPI_IPS_LCD_RST_GPIO_NUM, GPIO_DM_OUTPUT); gpiohs_set_drive_mode(SPI_IPS_LCD_BL_GPIO_NUM, GPIO_DM_OUTPUT); spi_init(1, SPI_WORK_MODE_0, SPI_FF_STANDARD, DATALENGTH, 0); ips_lcd_init(); // init LCD_ShowPicture(0, 0, LCD_W, LCD_H, gImage_nanke); // display ``` ### MaixPy 例程： ```python # 20: SPI_LCD_CS_PIN_NUM; fm.register(SPI_LCD_CS_PIN_NUM, fm.fpioa.GPIOHS20, force True) # 15: SPI_LCD_DC_PIN_NUM; fm.register(SPI_LCD_DC_PIN_NUM, fm.fpioa.GPIOHS15, force True) # 6: SPI_LCD_BUSY_PIN_NUM; fm.register(SPI_LCD_BUSY_PIN_NUM, fm.fpioa.GPIOHS6, force True) # 7: SPI_LCD_RST_PIN_NUM; fm.register(SPI_LCD_RST_PIN_NUM, fm.fpioa.GPIOHS7, force True) # set gpiohs work mode to output mode cs GPIO(GPIO.GPIOHS20, GPIO.OUT) dc GPIO(GPIO.GPIOHS15, GPIO.OUT) busy GPIO(GPIO.GPIOHS6, GPIO.OUT) rst GPIO(GPIO.GPIOHS7, GPIO.OUT) # 21: SPI_LCD_SCK_PIN_NUM; 8: SPI_LCD_MOSI_PIN_NUM; spi1 SPI(SPI_LCD_NUM, mode SPI.MODE_MASTER, baudrate SPI_LCD_FREQ_KHZ * 1000, polarity 0, phase 0, bits 8, firstbit SPI.MSB, sck SPI_LCD_SCK_PIN_NUM, mosi SPI_LCD_MOSI_PIN_NUM) ips SPLCD114(spi1, cs, dc, rst, busy, IPS_WIDTH, IPS_HEIGHT, IPS_MODE) # create an 'image' and fill it img image.Image() img.draw_rectangle(80, 80, 30, 30) # display ips.display(img) ``` ### 运行环境 语言 开发板 SDK/固件版本 : : : : : : C MaixCube kendryte standalone sdk v0.5.6 MaixPy MaixCube maixpy v0.5.1 *MaixPy固件建议自行从最新源码编译* ### 运行结果 * C <img src \"../../assets/spmod/spmod_lcd1.14//sp_lcd1.14_c.png\" height \"250\" /> * MaixPy <img src \"../../assets/spmod/spmod_lcd1.14//sp_lcd1.14_py.png\" alt \"sp_lcd1.14_py\" height \"250\" /> ### 移植 修改以下参数即可适配其他 K210 开发板. * C ```c // board_config.h #define SPI_INDEX 1 #define SPI_SCLK_RATE 600*1000 #define SPI_CHIP_SELECT_NSS 0 // SPI_CHIP_SELECT_0 #define SPI_IPS_LCD_CS_PIN_NUM 20 #define SPI_IPS_LCD_SCK_PIN_NUM 21 #define SPI_IPS_LCD_MOSI_PIN_NUM 8 #define SPI_IPS_LCD_DC_PIN_NUM 15 #define SPI_IPS_LCD_BL_PIN_NUM 6 #define SPI_IPS_LCD_RST_PIN_NUM 7 #define SPI_IPS_LCD_DC_GPIO_NUM 15 #define SPI_IPS_LCD_BL_GPIO_NUM 6 #define SPI_IPS_LCD_RST_GPIO_NUM 7 #define USE_HORIZONTAL 3 // 0/1 is horizontal, and 2/3 is vertical. ``` * Maixpy ```python ################### config ################### SPI_LCD_NUM SPI.SPI1 SPI_LCD_DC_PIN_NUM const(15) SPI_LCD_BUSY_PIN_NUM const(6) SPI_LCD_RST_PIN_NUM const(7) SPI_LCD_CS_PIN_NUM const(20) SPI_LCD_SCK_PIN_NUM const(21) SPI_LCD_MOSI_PIN_NUM const(8) SPI_LCD_FREQ_KHZ const(600) ############################################## ``` ## 参考设计 SPMOD_LCD1.14 尺寸图： <img src \"../../assets/spmod/spmod_lcd1.14/sipeed_spmod_lcd1.14.png\" height \"250\" /> ## 资源链接 资源 官网 www.sipeed.com SIPEED 官方淘宝店 [sipeed.taobao.com](sipeed.taobao.com) Github [https://github.com/sipeed](https://github.com/sipeed) BBS [http://bbs.sipeed.com](http://bbs.sipeed.com) MaixPy 文档官网 [http://maixpy.sipeed.com](http://wiki.sipeed.com/maixpy) Sipeed 模型平台 [https://maixhub.com](https://maixhub.com) SDK 相关信息 [https://dl.sipeed.com/MAIX/SDK](https://dl.sipeed.com/MAIX/SDK) HDK 相关信息 [https://dl.sipeed.com/MAIX/HDK](https://dl.sipeed.com/MAIX/HDK) E mail(技术支持和商业合作) [Support@sipeed.com](mailto:support@sipeed.com) telgram link https://t.me/sipeed MaixPy AI QQ 交流群 862340358 "},"/hardware/zh/modules_spmod/spmod_micarray.html":{"title":"SPMOD - MicArray","content":"# SPMOD MicArray ## 概述 <img src \"../../assets/spmod/spmod_micarray/sp_micarray.png\" width \"\" height \"300\" /> SPMOD_MicArray(麦克风阵列模块)采用 RY3708(DC DC)升压模块 ## SPMOD MicArray 介绍 采用 **Sipeed SPMOD** 接口(2.54mm * 8PIN 排针)，统一 MaixPy 开发板接口 将SP MOD转至FPC，利用FPC与麦克风阵列板相连。 板载3.3V至5V升压DC DC (RY3708)，轻松驱动麦克风阵列。 利用Grove接口控制麦克风阵列板上的LED。 需要配合SIPEED MICARRAY一起使用。 模块尺寸：35.0\\*10.0\\*11.2mm ### BOOST DC DC RY3708 模块 介绍 功能特点： 参数 输出电压 5.1V ±0.2V 外部供电电压 \t3.3V ±0.2V 外部供电电流 视麦克风阵列板的工作情况而定，通常小于500mA 工作温度范围 40℃ ~ 85℃ > 1.2MHz固定开关频率,内部4A开关电流限制,高温自动切断,集成80mΩ内部功率MOSFET ### SPMOD_MicArray 模块引脚定义： 引脚序号 引脚名称 类型 引脚说明 1 GND G 模块电源地 2 D2 I Mic_D0 3 D3 I Mic_D2 4 D0 I Mic_WS 5 3V3 V 模块电源输入正 6 D4 I Mic_D1 7 D5 I Mic_D3 8 D1 I Mic_BCK 9 CK I LED控制串行时钟引脚 (相当于I2C SCL) 10 DA I LED控制串行数据引脚 (相当于I2C SDA) <img src \"\" width \"300\" /> ## 使用例程 ```python from Maix import MIC_ARRAY as mic import lcd lcd.init() mic.init() #mic.init(i2s_d0 23, i2s_d1 22, i2s_d2 21, i2s_d3 20, i2s_ws 19, i2s_sclk 18, sk9822_dat 24, sk9822_clk 25) while True: imga mic.get_map() b mic.get_dir(imga) a mic.set_led(b,(0,0,255)) imgb imga.resize(160,160) imgc imgb.to_rainbow(1) a lcd.display(imgc) mic.deinit() ``` > 需要根据自己接板子上的管脚号来进行修改mic.init()中参数 ## 参考设计 SPMOD_MicArray 尺寸图： <img src \"../../assets/spmod/spmod_micarray/sipeed_spmod_micarray.png\" height \"250\" /> ## 资源链接 资源 官网 www.sipeed.com SIPEED 官方淘宝店 [sipeed.taobao.com](sipeed.taobao.com) Github [https://github.com/sipeed](https://github.com/sipeed) BBS [http://bbs.sipeed.com](http://bbs.sipeed.com) MaixPy 文档官网 [http://maixpy.sipeed.com](http://wiki.sipeed.com/maixpy) Sipeed 模型平台 [https://maix.sipeed.com](https://maix.sipeed.com) SDK 相关信息 [https://dl.sipeed.com/MAIX/SDK](https://dl.sipeed.com/MAIX/SDK) HDK 相关信息 [https://dl.sipeed.com/MAIX/HDK](https://dl.sipeed.com/MAIX/HDK) E mail(技术支持和商业合作) [Support@sipeed.com](mailto:support@sipeed.com) telgram link https://t.me/sipeed MaixPy AI QQ 交流群（四群） 862340358"},"/hardware/zh/modules_spmod/spmod_ethernet.html":{"title":"SPMOD - Ethernet","content":"# SPMOD Ethernet ## 概述 ![](../../assets/spmod/spmod_ethernet/sp_ethernet.png) SPMOD_Ethernet(网络扩展模块)采用 W5500 以太网主控芯片。 ## SPMOD Ethernet 介绍 采用 **Sipeed SPMOD** 接口(2.54mm * 8PIN 排针)，统一 MaixPy 开发板接口 通过SP MOD SPI接口连接 主控芯片：W5500 是一款集成全硬件 TCP/IP 协议栈的嵌入式以太网控制器。 SPI 速率理论上可达80MHz \t集成以太网数据链路层（MAC）和10BaseT/100BaseTX 以太网物理层（PHY），支持自动协商（10/100 Based全双工/半双工） 模块尺寸：35.76\\*19.74\\*8.7mm ### W5500 以太网主控芯片介绍 功能特点： 参数 工作电压 2.97V~3.63V 工作电流 <132mA 工作温度 40℃~85℃ 休眠电流 <15mA SPI 时钟 最高80MHz 全硬件TCP/IP协议栈 支持TCP、UDP、ICMP、IPv4、ARP、IGMP、PPPoE协议 > 支持8路独立硬件 Socket 同时通信 ,通信效率互不影响 ,内部32K字节收发缓存供TCP/IP包处理 ,支持掉电模式、网络唤醒 ,集成 10BaseT / 100Base T 以太网 PHY ,支持自动协商（全/半双工，10M/100M) ,不支持自动极性变换MDIX ### SPMOD_Ethernet 模块引脚定义： 引脚序号 引脚名称 类型 引脚说明 1 GND G 模块电源地 2 CS I SPI片选引脚 3 SO I/0 MISO数据引脚，主机输入从机输出 4 NC NC 悬空引脚，无功能 5 3V3 V 模块电源输入正 6 SCK I SPI串行时钟引脚 7 SI I/0 MOSI数据引脚，主机输出从机输入 8 NC NC 悬空引脚，无功能 <img src \"\" width \"300\" /> ## 使用例程 待更新 ## 参考设计 SPMOD_Ethernet 尺寸图： <img src \"../../assets/spmod/spmod_ethernet/sipeed_spmod_ethernet.png\" height \"250\" /> ## 资源链接 资源 官网 www.sipeed.com SIPEED 官方淘宝店 [sipeed.taobao.com](sipeed.taobao.com) Github [https://github.com/sipeed](https://github.com/sipeed) BBS [http://bbs.sipeed.com](http://bbs.sipeed.com) MaixPy 文档官网 [http://maixpy.sipeed.com](http://wiki.sipeed.com/maixpy) Sipeed 模型平台 [https://maix.sipeed.com](https://maix.sipeed.com) SDK 相关信息 [https://dl.sipeed.com/MAIX/SDK](https://dl.sipeed.com/MAIX/SDK) HDK 相关信息 [https://dl.sipeed.com/MAIX/HDK](https://dl.sipeed.com/MAIX/HDK) E mail(技术支持和商业合作) [Support@sipeed.com](mailto:support@sipeed.com) telgram link https://t.me/sipeed MaixPy AI QQ 交流群（四群） 862340358"},"/hardware/zh/modules_spmod/spmod_template.html":{"title":"SPMOD - XXX","content":"# SPMOD XXX ## 概述 <img src \"../../assets/spmod/sipeed_spmod_xxx.jpg\" alt \"XXX\" style \"zoom:60%;\" /> SPMOD_XX(XX 模块)采用XXX。 ## SPMOD XXX 介绍 采用 **Sipeed SPMOD** 接口(2.54mm * 8PIN 排针)，统一 MaixPy 开发板接口 XXX 模块尺寸：X.XX\\*XX.X\\*XX.Xmm ### XXXX 介绍 XXXXX XXXX XXXX 功能特点： ### SPMOD_XXX 模块引脚定义： 引脚序号 引脚名称 类型 引脚说明 1 GND G XX 2 XXX I XX 3 MISO O XX 4 XXX I XX 5 XXX O XX 6 SCK I XX 7 MOSI I XX 8 VCC G XX ## 使用例程 MaixPy 例程： > NOTE: 待更新 STM32 例程： ## 参考设计 SPMOD_XXX 原理图： ## 资源链接 资源 官网 www.sipeed.com SIPEED 官方淘宝店 [sipeed.taobao.com](sipeed.taobao.com) Github [https://github.com/sipeed](https://github.com/sipeed) BBS [http://bbs.sipeed.com](http://bbs.sipeed.com) MaixPy 文档官网 [http://maixpy.sipeed.com](http://wiki.sipeed.com/maixpy) Sipeed 模型平台 [https://maix.sipeed.com](https://maix.sipeed.com) SDK 相关信息 [https://dl.sipeed.com/MAIX/SDK](https://dl.sipeed.com/MAIX/SDK) HDK 相关信息 [https://dl.sipeed.com/MAIX/HDK](https://dl.sipeed.com/MAIX/HDK) E mail(技术支持和商业合作) [Support@sipeed.com](mailto:support@sipeed.com) telgram link https://t.me/sipeed MaixPy AI QQ 交流群（四群） 862340358"},"/hardware/zh/modules_spmod/spmod_fpc.html":{"title":"SPMOD - FPC","content":"# SPMOD FPC ## 概述 ![](../../assets/spmod/spmod_fpc/sp_fpc.png) SPMOD_FPC(FPC 转接线模块) ## SPMOD FPC 介绍 采用 **Sipeed SPMOD** 接口(2.54mm * 8PIN 排针)，统一 MaixPy 开发板接口 作为延长套件，轻松的将SP MOD接口用FPC延长至另一端。您将有更大的自由连接模块构建系统。 提供一对SP MOD至FPC转换板（一公一母），一条FPC排线, 10P规格。 模块尺寸：15.0\\*10.0\\*3.3mm ## 概括 功能特点： 参数 SP MOD至FPC10转换器器(公母一对)\t 用于将SP MOD接口和FPC的双向转换 FPC排线\t 用于连接两个转换器 外部供电电压 视连接的模块而定 外部供电电流 视模块工作情况而定，通常小于1000mA 工作温度 30℃ ~ 85℃ ## 参考设计 SPMOD_FPC 尺寸图： <img src \"../../assets/spmod/spmod_fpc/sipeed_spmod_fpc.png\" height \"250\" /> ## 资源链接 资源 官网 www.sipeed.com SIPEED 官方淘宝店 [sipeed.taobao.com](sipeed.taobao.com) Github [https://github.com/sipeed](https://github.com/sipeed) BBS [http://bbs.sipeed.com](http://bbs.sipeed.com) MaixPy 文档官网 [http://maixpy.sipeed.com](http://wiki.sipeed.com/maixpy) Sipeed 模型平台 [https://maix.sipeed.com](https://maix.sipeed.com) SDK 相关信息 [https://dl.sipeed.com/MAIX/SDK](https://dl.sipeed.com/MAIX/SDK) HDK 相关信息 [https://dl.sipeed.com/MAIX/HDK](https://dl.sipeed.com/MAIX/HDK) E mail(技术支持和商业合作) [Support@sipeed.com](mailto:support@sipeed.com) telgram link https://t.me/sipeed MaixPy AI QQ 交流群（四群） 862340358"},"/hardware/zh/modules_spmod/spmod_servo.html":{"title":"SPMOD - SERVO","content":"# SPMOD SERVO ## 概述 <img src \"../../assets/spmod/spmod_servo/sp_servo.png\" width \"\" height \"300\" /> SPMOD_SERVO (SERVO模块)。 ## SPMOD SERVO 介绍 采用 **Sipeed SPMOD** 接口(2.54mm * 8PIN 排针)，统一 MaixPy 开发板接口 利用SP MOD控制多达6个独立的PWM 9g舵机 舵机接口采用3P 2.54间距排针 独立的外部5V供电，通过USB Type C或者KF螺钉接线柱，不会从SP MOD取电 板载电源指示灯，通电状态一目了然 模块尺寸：35.0\\*20\\*1.6mm 功能特点： 参数 PWM 9g舵机接口*6 外接4.8 6V电源的情况下，可连接6个PWM 9g舵机并分别控制 外部供电电压 4.8V 6.0V 外部供电电流 视模块工作情况而定，通常小于1500mA 工作温度 40℃ ~ 85℃ ### SPMOD_SERVO 模块引脚定义： <img src \"../../assets/spmod/spmod_servo/sp_servo_pin.png\" width \"500\" /> ## 使用例程 待更新 ## 参考设计 SPMOD_SERVO 尺寸图： <img src \"../../assets/spmod/spmod_servo/sipeed_spmod_servo.png\" height \"250\" /> ## 资源链接 资源 官网 www.sipeed.com SIPEED 官方淘宝店 [sipeed.taobao.com](sipeed.taobao.com) Github [https://github.com/sipeed](https://github.com/sipeed) BBS [http://bbs.sipeed.com](http://bbs.sipeed.com) MaixPy 文档官网 [http://maixpy.sipeed.com](http://wiki.sipeed.com/maixpy) Sipeed 模型平台 [https://maix.sipeed.com](https://maix.sipeed.com) SDK 相关信息 [https://dl.sipeed.com/MAIX/SDK](https://dl.sipeed.com/MAIX/SDK) HDK 相关信息 [https://dl.sipeed.com/MAIX/HDK](https://dl.sipeed.com/MAIX/HDK) E mail(技术支持和商业合作) [Support@sipeed.com](mailto:support@sipeed.com) telgram link https://t.me/sipeed MaixPy AI QQ 交流群（四群） 862340358"},"/hardware/zh/modules_spmod/spmod_psram.html":{"title":"SPMOD - PSRAM","content":"# SPMOD PSRAM ## 概述 <img src \"../../assets/spmod/spmod_psram/sp_psram.png\" width \"\" height \"300\" /> SPMOD_PSRAM(PSRAM模块)采用 IPS6404L SQ 芯片。 ## SPMOD PSRAM 介绍 采用 **Sipeed SPMOD** 接口(2.54mm * 8PIN 排针)，统一 MaixPy 开发板接口 通过SP MOD SPI/QPI接口连接 Pseudo−SRAM芯片：IPS6404L SQ是一个容量为64Mbit，SPI/QPI接口，具有出色的可靠性的和响应时间的伪随机动态存储器芯片。 工作频率：104MHz SPI读取响应时间：30.3ns 模块尺寸：15.0\\*10.0\\*13.3mm ### IPS6404L SQ 迫真静态随机存储器介绍 功能特点： 参数 工作电压 2.7V~3.6V 工作电流 10mA 工作温度 30℃~85℃ 休眠电流 <250μA 工作频率 104Mhz SPI读取响应时间 30.3ns 其他操作响应时间 9.3ns 对外接口 PI/QPI可选，默认SPI ### SPMOD_PSRAM 模块引脚定义： 引脚序号 引脚名称 类型 引脚说明 1 GND G 模块电源地 2 CS I SPI片选引脚 3 D1 I/0 MISO数据引脚，模块数据输出 4 D3 I/O 无功能 (QSPI模式下为IO3) 5 3V3 V 模块电源输入正 6 SCK I SPI串行时钟引脚 7 D0 I/0 MOSI数据引脚，模块数据输入 (QSPI模式下为IO0) 8 D2 I/O 无功能 (QSPI模式下为IO2) <img src \"\" width \"300\" /> ## 使用例程 待更新 ## 参考设计 SPMOD_PSRAM 尺寸图： <img src \"../../assets/spmod/spmod_psram/sipeed_spmod_psram.png\" height \"250\" /> ## 资源链接 资源 官网 www.sipeed.com SIPEED 官方淘宝店 [sipeed.taobao.com](sipeed.taobao.com) Github [https://github.com/sipeed](https://github.com/sipeed) BBS [http://bbs.sipeed.com](http://bbs.sipeed.com) MaixPy 文档官网 [http://maixpy.sipeed.com](http://wiki.sipeed.com/maixpy) Sipeed 模型平台 [https://maix.sipeed.com](https://maix.sipeed.com) SDK 相关信息 [https://dl.sipeed.com/MAIX/SDK](https://dl.sipeed.com/MAIX/SDK) HDK 相关信息 [https://dl.sipeed.com/MAIX/HDK](https://dl.sipeed.com/MAIX/HDK) E mail(技术支持和商业合作) [Support@sipeed.com](mailto:support@sipeed.com) telgram link https://t.me/sipeed MaixPy AI QQ 交流群（四群） 862340358"},"/hardware/zh/modules_spmod/spmod_rfid.html":{"title":"SPMOD - RFID","content":"# SPMOD RFID ## 概述 <img src \"../../assets/spmod/spmod_rfid/sp_rfid.png\" style \"padding right:100px;\" width \"\" height \"300\" /> SPMOD_RFID (NFC 模块)采用复旦微电子 FM17510 高度集成的非接触式（13Mhz）的读写芯片。 ## SPMOD RFID 介绍 采用 **Sipeed SPMOD** 接口(2.54mm * 8PIN 排针)，统一 MaixPy 开发板接口 利用SP MOD SPI和RFID模块通讯 64Byte收发缓冲FIFO RIFC IC 为 FM17510。 模块尺寸：25.0\\*20.1\\*6.2mm ### FM17510 介绍 FM17510 是一款高度集成的工作在 13.56MHz 下的非接触读写器芯片，支持符合 ISO/IEC 14443 TypeA 协议的非接触读写器模式。 同时提供了低功耗的外部卡片侦测功能，方便电池供电、需要低功耗工作、并且需要实时处理任意 时刻会进入射频场的外部卡片的读写器设备。 FM17510 具有低电压、低功耗、 单端驱动等特点。适用于低功耗、低电压、低成本要求的非接触读。 FM1750XX 在软硬件层面上兼容 MFRC552，支持工作模式： FM17510 功能特点： 支持 ISO/IEC 14443 TypeA 读写器模式 读写器模式支持 M1 加密算法 ISO14443 TYPEA 支持通讯速率 106kbps， 212kbps， 424kbps 支持 SPI 串行接口，最高 10Mbps Host 接口独立电源供电，电压范围 2.2~3.6V 工作温度范围 40℃ ~ 85℃ 64Byte 收发缓冲 FIFO 中断输出模式灵活可配 多种低功耗模式 : Soft powerdown模式 , Hard powerdown 模式, Deep powerdown 模式（典型值 1uA） 支持低功耗外部卡片侦测功能 可编程定时器 内置振荡电路外接 27.12MHz 晶振 宽电压工作范围 2.2V~3.6V 内置 CRC 协处理器 可编程 I/O 引脚 ### SPMOD_RFID 模块引脚定义： 引脚序号 引脚名称 类型 引脚说明 Note 1 GND G 模块电源地 2 CS I SPI片选引脚 3 SO I/O MISO数据引脚，主机输入从机输出 4 NPD I 复位/休眠控制引脚 5 3V3 V 模块电源输入正 6 SCK I SPI串行时钟引脚 7 SI I/O MOSI数据引脚，主机输出从机输入 8 IRQ O 模块中断输出引脚 > 当 NPD 引脚为低电平时，模块进入休眠状态；当 NPD 引脚输入一个上升沿时，模块复位。 <img src \"../../assets/spmod/spmod_rfid/back.png\" height \"300\" /> 接线方式: MCU:FUN(IO) SP_RFID : : : : NC(IO_7) NPD SPI:MISO(IO_15) SO SPI:SS0(IO_20) CS SPI:SCK(IO_21) SCK SPI:MOSI(IO_8) SI NC(IO_6) IRQ 2.2~3.6V 3.3V GND GND <img src \"../../assets/spmod/spmod_rfid/connection.png\" height \"250\"> ## 使用例程 * 流程 1. 初始化 2. 扫描并绑定卡片 3. 读写数据 ### C 示例： ```c fpioa_set_function(RFID_CS_PIN, FUNC_GPIOHS0 + RFID_CS_HSNUM); // RFID_CS_PIN: 20; fpioa_set_function(RFID_CK_PIN, FUNC_GPIOHS0 + RFID_CK_HSNUM); // RFID_CK_PIN: 21; fpioa_set_function(RFID_MO_PIN, FUNC_GPIOHS0 + RFID_MO_HSNUM); // RFID_MO_PIN: 8; fpioa_set_function(RFID_MI_PIN, FUNC_GPIOHS0 + RFID_MI_HSNUM); // RFID_MI_PIN: 15; gpiohs_set_drive_mode(spi_io_cfg.hs_cs, GPIO_DM_OUTPUT); gpiohs_set_drive_mode(spi_io_cfg.hs_clk, GPIO_DM_OUTPUT); gpiohs_set_drive_mode(spi_io_cfg.hs_mosi, GPIO_DM_OUTPUT); gpiohs_set_drive_mode(spi_io_cfg.hs_miso, GPIO_DM_INPUT); // detected card PcdRequest(0x52, type) // auth and bind... // read or write 16 bytes data from sector 0x11 PcdWrite(0x11, w_buf) PcdRead(0x11, &r_buf) ``` ### MaixPy 例程： ```python # 20: CS_NUM; fm.register(20, fm.fpioa.GPIOHS20, force True) # set gpiohs work mode to output mode cs GPIO(GPIO.GPIOHS20, GPIO.OUT) # RFID_SCK: 21; RFID_SI:8; RFID_SO: 15; spi1 SPI(SPI.SPI1, mode SPI.MODE_MASTER, baudrate 600 * 1000, polarity 0, phase 0, bits 8, firstbit SPI.MSB, sck 21, mosi 8, miso 15) # Create an object of the class MFRC522 MIFAREReader MFRC522(spi1, cs) # detected and auth, bind... # read or write 16 bytes data from sector 0x11 MIFAREReader.MFRC522_Write(0x11, data) MIFAREReader.MFRC522_Read(0x11) ``` ### 运行环境 语言 开发板 SDK/固件版本 : : : : C MaixCube kendryte standalone sdk v0.5.6 MaixPy MaixCube maixpy v0.5.1 ### 运行结果 * C <img src \"../../assets/spmod/spmod_rfid/c_log.png\" height \"200\" /> * MaixPy <img src \"../../assets/spmod/spmod_rfid/maixpy_log.png\" height \"200\" /> ### 移植 修改以下参数即可适配其他 K210 开发板. * C ```c // board_config.h #define RFID_CS_PIN (20) #define RFID_CK_PIN (21) #define RFID_MO_PIN (8) #define RFID_MI_PIN (15) #define RFID_CS_HSNUM (20) #define RFID_CK_HSNUM (21) #define RFID_MO_HSNUM (8) #define RFID_MI_HSNUM (15) ``` * MaixPy ```python ################### config ################### CS_NUM const(20) SPI_FREQ_KHZ const(600) SPI_SCK const(21) SPI_MOSI const(8) SPI_MISO const(15) ############################################# ``` ## 参考设计 SPMOD_RFID 尺寸图： <img src \"../../assets/spmod/spmod_rfid/sipeed_spmod_rfid.png\" height \"250\" /> ## 资源链接 资源 官网 www.sipeed.com SIPEED 官方淘宝店 [sipeed.taobao.com](sipeed.taobao.com) Github [https://github.com/sipeed](https://github.com/sipeed) BBS [http://bbs.sipeed.com](http://bbs.sipeed.com) MaixPy 文档官网 [http://maixpy.sipeed.com](http://wiki.sipeed.com/maixpy) Sipeed 模型平台 [https://maix.sipeed.com](https://maix.sipeed.com) SDK 相关信息 [https://dl.sipeed.com/MAIX/SDK](https://dl.sipeed.com/MAIX/SDK) HDK 相关信息 [https://dl.sipeed.com/MAIX/HDK](https://dl.sipeed.com/MAIX/HDK) E mail(技术支持和商业合作) [Support@sipeed.com](mailto:support@sipeed.com) telgram link https://t.me/sipeed MaixPy AI QQ 交流群（四群） 862340358"},"/hardware/zh/modules_spmod/spmod_bt.html":{"title":"SPMOD - BT","content":"# SPMOD BT ## 概述 ![](./../../assets/spmod/spmod_bt/sp_bt.png) SPMOD BT(蓝牙 模块)采用 YDJ 23。 ## SPMOD BT 介绍 采用 **Sipeed SPMOD** 接口(2.54mm * 8PIN 排针)，统一 MaixPy 开发板接口 利用 SP MOD UART 和蓝牙模块通讯 JDY 23蓝牙模块：支持BLE 5.0（兼容 BLE4.0、BLE4.2）。具有UART接口。模块支持AT指令控制。具备超低功耗特性和高可靠性 板载两个状态指示LED，模块状态一目了然 模块尺寸：25.6\\*20.2\\*3.2mm ### JDY 23 蓝牙介绍： 功能特点： 参数 工作频段： 2.4G 发射功率： 4db（最大） 通信接口： UART 工作电压： 1.8V~3.6V 工作温度： 40℃ 80℃ 天线： 板载PCB天线 接收灵敏度： 97dbm 主从支持： 从机 蓝牙版本： BLE 5.0（兼容 BLE4.0、BLE4.2） 唤醒状态电流： 800uA（广播模式） 浅睡状态电流： <50uA (广播模式) 深度睡眠电流： 9uA （无广播） 默认串口波特率： 9600 ### SPMOD_BT 模块引脚定义： 引脚序号 引脚名称 类型 引脚说明 1 GND G 模块电源地 2 AWK I/O 模块休眠唤醒引脚，低有效 3 STA I/O 蓝牙连接状态连接，连接成功时输出高电平 4 RX I 模块UART数据接受引脚，连接上位机TX 5 3V3 V 模块电源输入正 6 NC 悬空引脚，无功能 7 RST I/O 模块复位引脚，低电平有效 8 TX O 模块UART数据发送引脚，连接上位机的RX <img src \"../../assets/spmod/spmod_bt/back.jpg\" height \"250\" /> 接线方式： MCU:FUN(IO) SP_BT : : : : UART:TX(IO_7) RX USRT:RX(IO_6) TX 1.8 3.3V 3.3V GND GND <img src \"../../assets/spmod/spmod_bt/connection.png\" height \"250\"> ### 主要 AT 指令列表： 指令 描述 AT+POWR 显示模块发送功率 AT+RST\t 软复位 AT+MAC\t 显示MAC 地址 AT+NAME 显示广播名 AT+HOSTEN 从模式或 IBEACON 工作模式 AT+IBUUID IBEACON 的 UUID AT+DISC 指令断开连接 AT+SLEEP 睡眠 AT+MTU 设置模块发送的发包数长 *更多AT指令请参考[JDY 23 V2.1.pdf](https://cn.dl.sipeed.com/shareURL/MAIX/HDK/sp_mod/sp_bt)* ## 使用例程 * 流程 1. 发送 AT 指令 2. 接收数据 3. 判断是否设置成功 ### C 示例： ```c // set uart rx/tx func to io_6/7 fpioa_set_function(6, FUNC_UART1_RX + UART_NUM * 2); fpioa_set_function(7, FUNC_UART1_TX + UART_NUM * 2); uart_init(UART_DEVICE_1); uart_configure(UART_DEVICE_1, 9600, 8, UART_STOP_1, UART_PARITY_NONE); //change the name of sp_bt module to MAIXCUBE uart_send_data(UART_NUM, \"AT+NAMEMAIXCUBE\\r\\n\", strlen(\"AT+NAMEMAIXCUBE\\r\\n\")); //send AT order msleep(100); ret uart_receive_data(UART_NUM, rcv_buf, sizeof(rcv_buf)); //receive response if(ret ! 0 && strstr(rcv_buf, \"OK\")) { printk(LOG_COLOR_W \"set name success!\\r\\n\"); } // get the name of sp_bt module uart_send_data(UART_NUM, \"AT+NAME\\r\\n\", strlen(\"AT+NAME\\r\\n\")); //send AT order msleep(100); ret uart_receive_data(UART_NUM, rcv_buf, sizeof(rcv_buf)); //receive response if(ret ! 0 && strstr(rcv_buf, \"NAME\")) { printk(LOG_COLOR_W \"get name success!\\r\\n\"); } ``` ### MaixPy 例程： ```python # set uart rx/tx func to io_6/7 fm.register(6,fm.fpioa.UART1_RX) fm.register(7,fm.fpioa.UART1_TX) uart UART(UART.UART1,9600,8,1,0,timeout 1000, read_buf_len 4096) #change the name of sp_bt module to MAIXCUBE uart.write(\"AT+NAMEMAIXCUBE\\r\\n\") #send AT order time.sleep_ms(100) read_data uart.read() #receive response if read_data: read_str read_data.decode('utf 8') count read_str.count(\"OK\") if count ! 0: uart.write(\"set name success\\r\\n\") # get the name of sp_bt module uart.write(\"AT+NAME\\r\\n\") #send AT order time.sleep_ms(100) read_data uart.read() #receive response if read_data: read_str read_data.decode('utf 8') count read_str.count(\"NAME\") if count ! 0: uart.write(\"get name success\\r\\n\") ``` *注意发送AT指令后一定要加上\\r\\n* ### 运行结果: 使用[BLE Utility](../../tools/bledebugger.apk)连接设备后进行收发测试结果如下: <center class \"third\"> <img src \"../../assets/spmod/spmod_bt/res.png\" height \"250\"/><img src \"../../assets/spmod/spmod_bt/res1.png\" height \"250\"/> </center> ### 运行环境: 语言 开发板 SDK/固件版本 : : : : : C MaixCube kendryte standalone sdk v0.5.6 MaixPy MaixCube maixpy v0.5.1 ## 参考设计 SPMOD_BLE 尺寸图： <img src \"../../assets/spmod/spmod_bt/sipeed_spmod_bt.png\" height \"250\" /> ## 资源链接 资源 官网 www.sipeed.com SIPEED 官方淘宝店 [sipeed.taobao.com](sipeed.taobao.com) Github [https://github.com/sipeed](https://github.com/sipeed) BBS [http://bbs.sipeed.com](http://bbs.sipeed.com) MaixPy 文档官网 [http://maixpy.sipeed.com](http://wiki.sipeed.com/maixpy) Sipeed 模型平台 [https://maix.sipeed.com](https://maix.sipeed.com) SDK 相关信息 [https://dl.sipeed.com/shareURL/MAIX/SDK](https://dl.sipeed.com/shareURL/MAIX/SDK) HDK 相关信息 [https://dl.sipeed.com/shareURL/MAIX/HDK](https://dl.sipeed.com/shareURL/MAIX/HDK) E mail(技术支持和商业合作) [Support@sipeed.com](mailto:support@sipeed.com) telgram link https://t.me/sipeed MaixPy AI QQ 交流群（四群） 862340358"},"/hardware/zh/maixIV/m4cdock/FAQ.html":{"title":"Maix-IV 系列 常见问题（FAQ）","content":" title: Maix IV 系列 常见问题（FAQ） ## Q：如何确认自己系统使用的 SDK 的版本号？ A：使用命令 `cat /proc/ax_proc/version`，参考结果如下： ```bash root@ax650:~# cat /proc/ax_proc/version Ax_Version V1.45.0_P39_20240830020829 ``` ## Q：更新到 1.45.0_P39 版本，根文件系统大小不到 5G，如何扩容？ A：扩容前： ```bash root@ax650:~# df h Filesystem Size Used Avail Use% Mounted on /dev/root 4.9G 4.3G 336M 93% / ``` 扩容后： ```bash root@ax650:~# df h Filesystem Size Used Avail Use% Mounted on /dev/root 15G 4.3G 9.6G 31% / ``` 操作步骤：首先明确当前是 TFCard 启动还是 eMMC 启动，可通过命令 `grep oP 'root \\K\\S+' /proc/cmdline` 获取得到结果如下： ```bash root@ax650:~# grep oP 'root \\K\\S+' /proc/cmdline /dev/mmcblk1p2 # TFCard 启动 # /dev/mmcblk0p2 # 或 eMMC 启动 ``` 可得知当前文件系统位于 `/dev/mmcblk0` 或 `/dev/mmcblk1`，用于替换下面的 `/dev/mmcblkX` 后执行命令： ```bash parted /dev/mmcblkX resizepart 2 100% resize2fs /dev/mmcblkXp2 fsck y /dev/mmcblkXp2 sync ``` ## Q：更新到 1.45 版本，根文件系统大小仅剩 8G，如何扩容？ A：首次烧录会出现该现象，实际EMMC该分区大小已预先设置最大可用，请运行以下命令更新文件系统元数据。之后应为28G：**！切记！**执行完`sync`再断电或重启设备否则会造成不开机。 ```bash resize2fs /dev/mmcblk0p10 fsck y /dev/mmcblk0p10 sync root@maixbox:~# df h Filesystem Size Used Avail Use% Mounted on /dev/root 28G 6.0G 21G 23% / ``` ## Q：MAC物理地址重复，导致同一局域网下无法正常连接网络，如何解决？ A：可通过进入`uboot`命令行模式设置环境变量`ethaddr`和`eth1addr`并保存，可永久修改对应网卡的mac地址： ```bash # 例如 setenv ethaddr d0:00:00:00:00:01 setenv eth1addr d0:00:00:00:00:02 saveenv ```"},"/hardware/zh/maixIV/m4cdock/quick-start.html":{"title":"","content":"## 系统开机与登录 注意：要求必须通过 12V DC 进行供电，否则仅通过 USB 会出现供电不足进而导致系统不稳定 ### 开机前准备 开机前硬件准备： 1. 12V DC 供电电源 2. HDMI 线缆和显示器 3. Type C 线缆（可选：串口调试和登录） 4. RJ45 网络线缆（可选：连接网络及 SSH 登录） 首次使用请根据您手上版本确认以下状态符合，否则系统无法正常使用 外壳上开关处于已打开状态（有外壳版本） Button 丝印处保持跳线帽短接（裸板版本） ![top](../assets/top.png) ### 正常开机 通过 HDMI1 连接显示器并接入 12V DC 供电，等待片刻约 20 多秒后显示器屏幕将会如下显示 LightDM 登录界面，表示系统启动成功。 ![desktop](../assets/desktop.jpg) 板载 USB A 口连接鼠标、键盘，方便后续系统操作和输入。登录界面等待输入用户名和密码，默认都为 root，确认登录即可进入 Debian 桌面系统。 ### 串口和SSH登录（进阶） 板载 USB Type C 接口为默认调试串口，波特率相关配置为 **115200 8n1**。 用户可通过串口工具打开该串口，以查看内核调试信息，也可在此处通过用户名和密码直接登录系统终端进行命令操作。 由于 Debian 镜像在制作过程中为了控制大小方便版本分发，因此常用的板级软件开发工具并未预装，建议第一次使用的用户在通过调试串口登录之后，执行以下操作 通过网线连接以太网 执行以下命令，安装后续章节 DEMO 板上编译必备软件开发工具(`ifconfig`、`gcc/g++`、`cmake`、`libopencv`......) ``` apt update apt install build essential apt install libopencv dev apt install cmake ``` 注意：本系统仅内置 root 超级用户，且考虑到安全性并未开启超级用户 SSH 密码登录。 若用户需要使用 SSH 登录 root 用户，推荐使用密钥登录，可以免输密码不仅方便快捷且安全。 所需操作如下：通过串口或桌面登录系统后，手动粘贴个人公钥保存到`/root/.ssh/authorized_keys`文件内，该文件不存在可手动创建。更详细过程可搜索 SSH 密钥登录或直接查看该[教程](https://www.runoob.com/w3cnote/set ssh login key.html)。 ## 交互式图像分割和修复（Segment and Inpaint Anything） 交互式图像分割和修复，基于QT的GUI交互界面，实现了交互式点选、框选的实时分割和进一步可选修复，具体效果预览和操作流程如下。 ![samqt](../assets/samqt.jpg) 原始代码由爱芯官方开源于 GITHUB：[SAM ONNX AX650 CPP](https://github.com/AXERA TECH/SAM ONNX AX650 CPP) 可下载官方预编译版本或按仓库内文档自行编译进行体验，下图是移除照片某球员的效果展示。 <div><table><tr> <td><img src \"../assets/sam_example_before.png\" alt sam_example_before border 0></td> <td><img src \"../assets/sam_example_after.png\" alt sam_example_after border 0></td> </tr></table></div> 以下是实机操作画面。 <div><table><tr> <td><img src \"../assets/sam_raw.jpg\" alt sam_raw border 0></td> <td><img src \"../assets/sam_sam.jpg\" alt sam_sam border 0></td> <td><img src \"../assets/sam_inpaint.jpg\" alt sam_inpaint border 0></td> </tr><tr> <td>RAW</td> <td>SAM</td> <td>Inpaint</td> </tr></table></div> ## 交互式以文搜图（CLIP） 交互式以文搜图示例，基于QT的GUI交互解码，采用 OpenAI 在 2021 年开源的 Zero Shot 视觉分类模型 CLIP(Contrastive Language–Image Pre training) 通过文本输入快速检索出相关图片并显示，支持中文、英文两种文本语言输入。 原始代码由爱芯官方开源于 GITHUB：[CLIP ONNX AX650 CPP](https://github.com/AXERA TECH/CLIP ONNX AX650 CPP) [DEMO VIDEO](https://github.com/sipeed/sipeed_wiki/assets/13964381/df4cec7f 29af 465f bfad e54312274437) 准备 QT 运行环境 ``` apt update apt install cmake qt6 base dev ``` 下载预编译好的可执行文件、模型文件、测试图片、测试文本 [Baidu Pan](https://pan.baidu.com/s/17M5ugUyuf9mbi1cHLGJHXg) 将下载获得的 *CLIP.zip* 在 `/root/Desktop/` 路径下解压得到以下内容 ``` root@maixbox:~/Desktop/CLIP# tree L 1 . ├── CLIPQT ├── cn_vocab.txt ├── coco_1000 ├── libonnxruntime.so ├── libonnxruntime.so.1.16.0 ├── onnx_models ├── run_en.sh ├── run_zh.sh └── vocab.txt ``` 使用 HDMI 基于 HDMI1 接口链接显示器并登录进入桌面, 打开控制终端运行 `run_zh.sh` ![b38722991915fa54f17df18ca1f1447](https://github.com/AXERA TECH/CLIP ONNX AX650 CPP/assets/13964381/8fa2c4b8 b061 413e b72d 298bb4a445aa) CLIP DEMO 正常运行 ![34c8b68b1a8721d4ebff3b4b7184733](https://github.com/AXERA TECH/CLIP ONNX AX650 CPP/assets/13964381/7d0b9740 3598 492c ad42 2de23e7764e2) ## **运行下列 DEMO 提前须知** 默认是 HDMI1 是桌面，而以下的 DEMO 需要使用 HDMI0 输出画面，受限于显示驱动，它们之间存在冲突，即不能同时显示。 因此，若想运行后续 DEMO ，则要先杀掉 fb_vo 这个进程，`ps auxgrep fb_vo`找到进程号后`kill 9 实际pid`杀掉即可，此时 HDMI1 的桌面将停止刷新（停止下列 Demo 后，执行 `/root/runVoHook.sh`即可恢复桌面使用）。 然后，在通过 ssh 或者串口的命令行里面执行对应的 run.sh，这时候接到 HDMI0 的显示器就会正常出显示画面了 ## 32路AI BOX（人车检测） BoxDemo 是本机搭载的 BOX 产品类的演示应用程序，包括从 ××H264/H.265×× 视频解码，经 AI 全结构化检测，最后经 HDMI 显示的 PIPE 流程。 `/opt/bin/BoxDemo/run.sh`为启动脚本。需要连接 HDMI0 到显示器，默认数据流是视频文件输入 经AI运算和视频处理后输出到 HDMI0 单显 32 路（6x6 布局，最后4路为无信号窗口）。支持双屏 HDMI (支持同显和异显)，此时实际测量整机功耗为不到 7W。 该应用原理为输入 32 路视频复制为共 64 通道，其中32通道为 472 x 264 分辨率输出 HDMI 缩放拼接供显示，剩余32通道为 1024 x 576 分辨率同步输入加载所选模型的 NPU 进行 AI 分析并将结果按需反馈到前 32 路对应视频流。目前仅使用了 3.6T（三分之一性能）算力轻松覆盖使用， 帧率15到20，瓶颈在于 CPU 的前后处理任务。另可额外再开启编码功能用于本地存储或网络推流。 如需要修改输入为 RTSP 流，请手动修改`/opt/bin/BoxDemo/box.conf`文件中`streamxx`行为有效 RTSP 地址。 如需要双屏显示，请手动修改`/opt/bin/BoxDemo/box.conf`文件中DISP1值为1，代表额外输出到 HDMI1。 视频流示意图如下： ![aibox_pipeline](../assets/aibox_pipeline.png) ![aibox_example32ch](../assets/aibox_example32ch.png) ## DINO v2 单目深度估计（Depth Estimation） DINO v2 单目深度估计，仅使用单颗彩色摄像头，使用 Facebook 的 DINO v2 大模型提取多维度视觉特征，并搭配下游模型进行估算场景相对深度 ![pipeline_bin](../assets/pipeline_bin.png) ```bash cd ~/ax pipeline/bin ./sample_multi_demux_ivps_npu_multi_rtsp_hdmi_vo \\ p ./config/dinov2_depth.json \\ f ~/boxvideos/13.mp4 ``` 注：可指定其它 H.264 编码的视频文件或者 RTSP 流。 基于 Facebook 开源大模型 DINOv2 的深度估计移植效果预览。 <div><table><tr> <td><img src \"../assets/dinov2 1.png\" alt dinov2 1></td> <td><img src \"../assets/dinov2 2.png\" alt dinov2 2></td> </tr></table></div> ![dinov2 3](../assets/dinov2 3.png) ## YOLOv5 行人检测追踪（Pedestrian Detection，Person re identification） ```bash cd ~/ax pipeline/bin ./sample_multi_demux_ivps_npu_multi_rtsp_hdmi_vo \\ p ./config/yolov5_seg.json \\ f ~/boxvideos/25.mp4 ``` ![yolov5_seg](../assets/yolov5_seg.png)"},"/hardware/zh/maixIV/m4cdock/intro.html":{"title":"","content":"## 产品概述 **置顶淘宝链接：[立即购买](https://item.taobao.com/item.htm?spm 1619a.1.0.0.3f0865abb4Wq5c&id 744014549573&ns 1&abbucket 18#detail)** M4C Dock 是 Sipeed 公司推出的端侧混合精度高算力边缘计算盒子，搭载爱芯元智第三代高能效比智能视觉芯片 AX650N，内置 AI 算力 72TOPS@INT4 或 18TOPS@INT8，可运行当前热门大模型。 内置ISP支持 8K@30fps，另有爱芯独家 AI ISP，可实现微光夜视。同时含有 H.264 和 H.265 编解码器，支持单路最大 8K@60fps 解码，8K@30ps 编码，实测可稳定 32 路 1080P@30fps 解码，16 路 1080P@30fps 编码。 接口方面，AX650N 支持 64bit LPDDR4x，多路MIPI 输入，千兆 Ethernet、USB3.0 以及 HDMI 2.0b 输出。解码内置高算力和超强编解码能力，满足行业对高性能边缘智能计算的需求。 本款NPU性能强大，在仅使用单核心时，常用开源 AI 模型表现如下：yolov5s 在 640x640 分辨率图片输入下可达130帧（7.66ms）。mobilenetv2 在 224x224 分辨率图片输入下超达1798帧（0.556ms）。 通过内置多种深度学习算法，实现视觉结构化、行为分析、状态检测等应用，高效率支持 Transformer 模型和视觉大模型。提供丰富的开发文档，方便用户进行二次开发。 ## 功能参数 设备 详细描述 CPU 8x A55@1.7Ghz，集成 FPU，支持 NEON 加速 NPU 72 TOPS@INT4 或 18 TOPS@INT8，支持 INT4/INT8/INT16/FP16/FP32 输入，支持 TopN(N< 32) ISP 最大支持 8192x4320@30fps，最大分辨率: 16384x16384， 支持 AI ISP（微光夜视） CODEC 支持 H.264/H.265 编解码，单路最大 8K@60fps 解码和 8K@30ps 编码 DSP 双核800Mhz RAM 8G 64bit LPDDR4x，系统内核和 AI CMM 使用占比可调 ROM 32G eMMC 5.1，系统盘 SSD/HDD 3x SATA 3.0 6Gb/s，可接 SSD/HDD，一路位于 M.2 接口，两路标准 SATA 接口 视频输出 2x HDMI 2.0a，最大分辨率：4K@60fps 摄像头输入 2x 4Lane MIPI CSI 摄像头，最大支持 3.5Gbps 网络 2x 1Gbps 千兆以太网，实测达944Mbps PCIE扩展 1x 1Lane PCIE2.0 5Gbps，位于 MINI PCIE 接口 USB扩展 1x USB3.2 Gen1 SS 5Gbps + 3x USB2.0 HS 480Mbps（蓝色远离网口的一个为OTG烧录端口） 外部连接 1x RS485 + 1x RS232 ## 资源汇总 ### 硬件相关资料汇总 AX650N 芯片规格书：https://dl.sipeed.com/shareURL/MaixIV/M4N Dock ### 软件开发资料汇总 软件开发文档：https://dl.sipeed.com/shareURL/MaixIV/M4N Dock 软件开发SDK：https://github.com/AXERA TECH/ax650n_bsp_sdk ### AI 开发资料汇总 AI工具链（模型转换、仿真、部署，ONNX） Pulsar2 由爱芯元智自主研发的 ALL IN ONE 新一代神经网络编译器 使用文档：https://pulsar2 docs.readthedocs.io/zh_CN/latest/pulsar2/introduction.html 下载地址：https://huggingface.co/AXERA TECH/Pulsar2/tree/main 模型算子支持列表：https://pulsar2 docs.readthedocs.io/zh_CN/latest/appendix/op_support_list.html 爱芯 Samples 例程：https://github.com/AXERA TECH/ax samples 已转换模型：https://dl.sipeed.com/shareURL/MaixIV/M4N Dock ## 技术支持 若有特定业务开发需求需要应用层开发文档，或在系统层对内核和根文件系统有特定需求或需要定制开发，请发邮件到support@sipeed.com尝试获取支持。"},"/hardware/zh/maixIV/m4c/system-update.html":{"title":"","content":"本指南详细介绍了 M4C Dock 开发板的两种系统烧录方法：通过 TFCard 启动和烧录 eMMC，以及通过 AXDL 工具烧录。请根据您的需求选择合适的方法。 ## 镜像文件说明 *该页面介绍的烧录方法所使用的镜像包因体积过大，且下载站带宽有限故仅存储在百度企业网盘同级目录下，入口链接可见于[下载站页面顶端区域](https://dl.sipeed.com/)。* 镜像类型 启动特点 文件名 获取方法 TFCard&eMMC Image `烧录 eMMC 上电自启` 或 `烧录 TFCard 手动启动` `sdcard.img` 下载路径：MaixIV/M4N Dock/09_Image/TFCard&eMMC Images AXSDK AXP `烧录 eMMC 上电自启` `xxx.axp` 下载路径：MaixIV/M4N Dock/09_Image/ubuntu 若下载的镜像文件是 `.xz` 结尾，请先进行解压操作。Linux 用户可使用 xz 工具，Windows 用户可使用 7 zip 等工具。 ![](../assets/baidupan dl.png) ## 通过 TFCard 启动和烧录 eMMC ### 启动 Live 系统（需手动按键操作） #### 第一步：准备 TFCard 并烧录镜像 准备一张至少 8GB 的 TFCard，使用任意读卡器工具或电脑自带的卡槽进行读写。 注意：按以下操作，TFCard 内容将会全部丢失，如有重要数据请提前备份。 操作系统 烧录方法 Linux `sudo dd if sdcard.img of /dev/sdX bs 4M conv fsync status progress` Windows 使用 `Win32DiskImager` 或 `Rufus` 或 `balenaEtcher` 进行烧录 附 Linux 例子： ```bash # 使用读卡器挂载了 TFCard 为 /dev/sdb 设备 % sudo dd if sdcard.img of /dev/sdb bs 4G conv sparse,fsync status progress 0+3 records in 0+3 records out 5754429440 bytes (5.8 GB, 5.4 GiB) copied, 89.2665 s, 64.5 MB/s ``` #### 第二步：使用烧录有镜像的 TFCard 启动 Live 系统 **TFCard 启动方法** 底板 设备树 TF 卡槽位置 `BOOT` 按键位置 Dock `dtbs/m4nbox.dtb` 尾部左上方，Type C 座子的对角线位置 Type C 座子旁边 BOOT 丝印处 Hat `dtbs/m4nhat.dtb` USB3 母座和缺口之间，位于背面 HDMI 座子旁边 BOOT0 丝印处 Cluster `dtbs/m4ncluster.dtb` M.2 座子下方 Type C 座子旁边 BOOT 丝印处 1. 挂载 TFCard 并修改 FAT32 分区 config.txt 文件中 `dtb_img_name dtbs/m4nbox.dtb` 为对应底板的值。 2. 将 TFCard 插入 TF 卡槽内。 3. 按住 `BOOT` 按键不放，复位：1.重新上电 或 2.保持上电点按（按下再松开） `RST` 按键。 3.1. 如有外壳遮蔽（如 M4C Dock），需要移除前面板，可拧下 3 颗螺丝然后旋转打开。 执行完以上操作， Live 系统应已启动，可通过串口0看到系统启动的打印信息。 **该 Live 系统功能完全，可直接上手体验使用。如需要上电自启进入系统而不需要额外的按键操作的话，请固化镜像到 eMMC，具体操作烦请续看下节。** ### 在 Live 系统内烧录 eMMC（上电自动启动） 板载 eMMC 的设备名将保持为 `/dev/mmcblk0`，相对的 TFCard 的设备名则为 `/dev/mmcblk1`，请注意区分。 现提供两个方法，都可以完成烧录镜像到板载 eMMC 的操作。可自行选择： #### 方法一：直接安装 Live 系统 1. 按上节说明成功进入 Live 系统，接着打开终端执行后续操作。 2. 使用 `dd` 将 TFCard 内的 Live 系统直接还原到 eMMC 中，具体命令如下： ```sh dd if /dev/mmcblk1 of /dev/mmcblk0 bs 3M count 1 conv fsync sync # 确保分区表生效 dd if /dev/mmcblk1p1 of /dev/mmcblk0p1 bs 64M conv fsync dd if /dev/mmcblk1p2 of /dev/mmcblk0p2 bs 1G conv sparse,fsync status progress fsck y /dev/mmcblk0p2 sync ``` 3. 等待上述指令执行完后，即可取出 TFCard。后续可直接上电或点按 `RST`，之后应能正常启动进入 eMMC 系统。 #### 方法二：Live 系统内烧录镜像 要求：能够访问和读写已烧录 Live 系统的 TFCard 格式为 `ext4` 的第二分区，如不清楚相关知识点，那么该方法暂时不适用，请采用更通用的方法一。 1. 拷贝镜像文件 `sdcard.img` 到第二分区（Live系统根目录）任意地方。 2. 参考 TFCard 烧录 Live 系统镜像，执行以下命令： ```sh dd if /path/to/sdcard.img of /dev/mmcblk0 bs 1G conv sparse,fsync status progress ``` 3. 等待上述指令执行完后，即可取出 TFCard，后续可直接上电或点按 `RST` 正常启动 eMMC 内系统。 ## 通过 AXDL 烧录 烧录文件名格式为 `xxx.axp`。 具体操作方法见首页资源汇总软件开发文档压缩包内`AXDL 工具使用指南.pdf`。 **提示：官方 EVB 板上 Download 按键对应各底板的 BOOT 按键操作** AXDL软件（仅 Windows 可用）位于下载站`PC_Software`目录下。 **注意：M4N Dock 的 USB 烧录口是位于靠近 `HDMI` 接口的以太网座子最下面贴近板子的那一个 `USB A` 口。请准备`A to A`的数据线，或者电脑有 `Type C` 口也可以直接使用 `A to C` 的数据线。其余底板都是 Type C** **注意：烧写时不要连接 `12V` 电源，仅使用 USB 烧写线供电即可，否则有烧毁 `PC` 的 `USB接口` 的风险**"},"/hardware/zh/maixIV/m4c/FAQ.html":{"title":"","content":"## ssh 远程登录 root 用户，密码输入正确却登录不成功，要如何使能 root 用户密码登录 SSH？ 默认密码：root *考虑到安全性，使用的默认策略，root 用户只能通过密钥进行远程登录，可以免输密码不仅方便快捷且安全。其所需操作如下：通过串口或桌面登录系统后，手动粘贴个人公钥保存到`/root/.ssh/authorized_keys`文件内，该文件不存在可手动创建。更详细过程可搜索 SSH 密钥登录或直接查看该[教程](https://www.runoob.com/w3cnote/set ssh login key.html)。* 若执意要通过密码登录，可如下操作： ```bash # 登录进入串口终端，执行一遍下方命令 # 启用 root 用户远程密码登录 echo \"PermitRootLogin yes\" > /etc/ssh/sshd_config.d/allow root.conf systemctl restart sshd ``` 开发结束后，避免 root 用户密码意外泄漏导致的各种风险，最好关闭 root 用户远程密码登录，执行下列操作： ```bash # 登录进入任意终端，执行一遍下方命令 # 关闭 root 用户远程密码登录 rm /etc/ssh/sshd_config.d/allow root.conf systemctl restart sshd ``` ## Q: 使用 TFCard&eMMC 镜像，根文件系统默认分区太小，如何扩容 eMMC 或者 TFCard？ ```bash # 登录进入任意终端，执行一遍下方命令 # 替换下面的 mmcblkX 为 mmcblk0（eMMC）或 mmcblk1（TFCard）。 # /dev/mmcblkXp2 为第二分区，也是根文件系统分区。 parted /dev/mmcblkX resizepart 2 100% resize2fs /dev/mmcblkXp2 fsck y /dev/mmcblkXp2 sync ``` ## Q: 有些大语言模型需要执行 tokenizer 相关 python 脚本，执行报错 ModuleNotFoundError，如何解决？ ```bash # 避免污染系统 python 库，新建虚拟环境 apt install python3 venv python3 m venv venv llm # 激活该虚拟环境 source venv llm/bin/activate # 安装缺失的 python 模块，国内可使用清华镜像源加速 pip install transformers jinja2 i https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple # 安装完毕，可继续执行脚本 ``` 记得每次要执行相关 python 脚本前，要先激活已安装的虚拟环境： ```bash # 激活该虚拟环境 source venv llm/bin/activate ``` ## Q: 类似 GPIO2_A27 已在设备树被配置成了 I2C3_SCL，那在不使用 I2C3 的时候如何控制 GPIO2_A27 呢？（pinctrl） ```bash cd /sys/kernel/debug/pinctrl/4250200.pinctrl grep \"GPIO2_A27\" pinmux functions # output # function 447: GPIO2_A27, groups [ I2C3_SCL ] grep \"I2C3_SCL\" pinmux pins # output # pin 87 (I2C3_SCL): device 2024000.i2c function i2c3_scl group I2C3_SCL echo 2024000.i2c > /sys/bus/platform/drivers/i2c_designware/unbind grep \"I2C3_SCL\" pinmux pins # output # pin 87 (I2C3_SCL): UNCLAIMED # echo \"<group name function name>\" > pinmux select echo \"I2C3_SCL GPIO2_A27\" > pinmux select gpioset gpiochip2 27 0 gpioset gpiochip2 27 1 ``` ## Q：MAC 物理地址每次重启随机生成，导致 ip 地址不稳定，请问如何解决？ A：sdcard 20250627.img.xz 开始，第一分区（FAT32）根目录下会有 `config.txt` 文件，内为 uboot 的环境变量配置。添加环境变量 `ethaddr` 和 `eth1addr` 即可持久化修改对应网卡的mac地址： ``` ethaddr d0:00:00:00:00:01 eth1addr d0:00:00:00:00:02 ``` ![](../assets/m4c/set macaddress.png)"},"/hardware/zh/maixIV/m4c/axmodel-deploy.html":{"title":"M4C 部署 AI 模型","content":"# M4C 部署 AI 模型 title: 外设使用 keywords: Linux, Lichee, TH1520, SBC, RISCV, Peripheral update: date: 2023 11 24 version: v1.0 author: dragonforward content: 加入了YOLOv8和YOLOv5部署 ## 部署大语言、多模态模型 从下列网站获取模型和运行时。 部署方法可见每个仓库的 README.md。 爱芯官方：https://huggingface.co/AXERA TECH 国内镜像站：https://hf mirror.com/AXERA TECH 模型 链接 链接（国内镜像站） Qwen3:0.6b [Qwen3 0.6B Int8](https://huggingface.co/AXERA TECH/Qwen3 0.6B) [Qwen3 0.6B Int8](https://hf mirror.com/AXERA TECH/Qwen3 0.6B) DeepSeek R1:1.5b [DeepSeek R1 Distill Qwen 1.5B](https://huggingface.co/AXERA TECH/DeepSeek R1 Distill Qwen 1.5B) [DeepSeek R1 Distill Qwen 1.5B](https://hf mirror.com/AXERA TECH/DeepSeek R1 Distill Qwen 1.5B) Qwen2.5:1.5b [Qwen2.5 1.5B Instruct GPTQ Int8](https://huggingface.co/AXERA TECH/Qwen2.5 1.5B Instruct GPTQ Int8) [Qwen2.5 1.5B Instruct GPTQ Int8](https://hf mirror.com/AXERA TECH/Qwen2.5 1.5B Instruct GPTQ Int8) SD1.5 [lcm lora sdv1 5](https://huggingface.co/AXERA TECH/lcm lora sdv1 5) [lcm lora sdv1 5](https://hf mirror.com/AXERA TECH/lcm lora sdv1 5) InternVL2.5:1b [InternVL2_5 1B Int8](https://huggingface.co/AXERA TECH/InternVL2_5 1B) [InternVL2_5 1B Int8](https://hf mirror.com/AXERA TECH/InternVL2_5 1B) **请注意：以上模型都需要基于 `SDK 1.45.0` （含）以后版本编译打包出来的镜像才可运行大模型。请及时更新系统，我们提供的 TFCard&eMMC 镜像是符合条件的，且预留了 6GB 内存供模型加载运行使用，可以运行 7b 参数的 int4 大模型。** *快速体验 qwen3 0.6b：* ```bash # 可切换成其它大模型仓库的链接 git clone https://hf mirror.com/AXERA TECH/Qwen3 0.6B cd Qwen3 0.6B # 若执行报错 ModuleNotFoundError，查阅 FAQ 相关细节 python3 qwen3_tokenizer_uid.py # 切换成对应的执行脚本，和恢复必要程序的执行权限 chmod +x main_ax650 sh run_qwen3_0.6b_int8_ctx_ax650.sh ``` ## 部署yolov5s 自定义模型 > 本博客将向你展示零基础一步步的部署好自己的yolov5s模型（博主展示的是安全帽模型），利用yolov5 官方的代码工具导出onnx模型，并通过onnxsim自带的工具精简网络结构，导出子图，为了Pulsar2 工具进行处理模型做准备。 ### 获得自定义训练得到的yolov5s onnx模型 #### 准备自定义数据集（博主用的是VOC数据集） `数据集目录结构`如下： ``` └─VOC2028:\t\t自定义数据集 ├─Annotations\t存放的是数据集标签文件，xml格式 ├─ImageSets\t\t数据集的划分文件 │ └─Main ├─JPEGImages\t存放的是数据集图片 ``` `分割数据集` 在split_train_val.py文件路径下执行`python3 split_train_val.py`会得到一下目录结构： ``` └─VOC2028:\t\t自定义数据集 ├─Annotations\t存放的是数据集标签文件，xml格式 ├─ImageSets\t\t数据集的划分文件 │ └─Main test.txt └─test.txt └─train.txt └─val.txt ├─JPEGImages\t存放的是数据集图片 ├─split_train_val.py\t分割数据集的py文件 ``` `split_train_val.py文件代码如下`： ``` # * coding: utf 8 * \"\"\" Author:dragonforward 简介：分训练集、验证集和测试集，按照 8：1：1 的比例来分，训练集8，验证集1，测试集1 \"\"\" import os import random import argparse parser argparse.ArgumentParser() # xml文件的地址，根据自己的数据进行修改 xml一般存放在Annotations下 parser.add_argument(' xml_path', default 'Annotations/', type str, help 'input xml label path') # 数据集的划分，地址选择自己数据下的ImageSets/Main parser.add_argument(' txt_path', default 'ImageSets/Main/', type str, help 'output txt label path') opt parser.parse_args() train_percent 0.8 # 训练集所占比例 val_percent 0.1 # 验证集所占比例 test_persent 0.1 # 测试集所占比例 xmlfilepath opt.xml_path txtsavepath opt.txt_path total_xml os.listdir(xmlfilepath) if not os.path.exists(txtsavepath): os.makedirs(txtsavepath) num len(total_xml) list list(range(num)) t_train int(num * train_percent) t_val int(num * val_percent) train random.sample(list, t_train) num1 len(train) for i in range(num1): list.remove(train[i]) val_test [i for i in list if not i in train] val random.sample(val_test, t_val) num2 len(val) for i in range(num2): list.remove(val[i]) file_train open(txtsavepath + '/train.txt', 'w') file_val open(txtsavepath + '/val.txt', 'w') file_test open(txtsavepath + '/test.txt', 'w') for i in train: name total_xml[i][: 4] + '\\n' file_train.write(name) for i in val: name total_xml[i][: 4] + '\\n' file_val.write(name) for i in list: name total_xml[i][: 4] + '\\n' file_test.write(name) file_train.close() file_val.close() file_test.close() ``` `voc转label得到label文件` 目录结构如下： ``` └─VOC2028:\t\t自定义数据集 ├─Annotations\t存放的是数据集标签文件，xml格式 ├─ImageSets\t\t数据集的划分文件 │ └─Main ├─JPEGImages\t存放的是数据集图片 └─labels\t\tyolov5将此文件夹当作训练的标注文件夹 └─voc_label.py ``` `voc_label.py文件代码如下`： ``` # * coding: utf 8 * import xml.etree.ElementTree as ET import os sets ['train', 'val', 'test'] # 如果你的Main文件夹没有test.txt，就删掉'test' classes [\"hat\", \"people\"] # 改成自己的类别，VOC数据集有以下20类别 # classes [\"brickwork\", \"coil\",\"rebar\"] # 改成自己的类别，VOC数据集有以下20类别 # classes [\"aeroplane\", 'bicycle', 'bird', 'boat', 'bottle', 'bus', 'car', 'cat', 'chair', 'cow', 'diningtable', 'dog', # 'horse', 'motorbike', 'person', 'pottedplant', 'sheep', 'sofa', 'train', 'tvmonitor'] # class names # abs_path os.getcwd() /root/yolov5/data/voc_label.py abs_path '/root/yolov5/data/' def convert(size, box): dw 1. / (size[0]) dh 1. / (size[1]) x (box[0] + box[1]) / 2.0 1 y (box[2] + box[3]) / 2.0 1 w box[1] box[0] h box[3] box[2] x x * dw w w * dw y y * dh h h * dh return x, y, w, h def convert_annotation(image_id): in_file open(abs_path + '/VOC2028/Annotations/%s.xml' % (image_id), encoding 'UTF 8') out_file open(abs_path + '/VOC2028/labels/%s.txt' % (image_id), 'w') tree ET.parse(in_file) root tree.getroot() size root.find('size') w int(size.find('width').text) h int(size.find('height').text) for obj in root.iter('object'): difficult obj.find('difficult').text # difficult obj.find('Difficult').text cls obj.find('name').text if cls not in classes or int(difficult) 1: continue cls_id classes.index(cls) xmlbox obj.find('bndbox') b (float(xmlbox.find('xmin').text), float(xmlbox.find('xmax').text), float(xmlbox.find('ymin').text), float(xmlbox.find('ymax').text)) b1, b2, b3, b4 b # 标注越界修正 if b2 > w: b2 w if b4 > h: b4 h b (b1, b2, b3, b4) bb convert((w, h), b) out_file.write(str(cls_id) + \" \" + \" \".join([str(a) for a in bb]) + '\\n') for image_set in sets: if not os.path.exists(abs_path + '/VOC2028/labels/'): os.makedirs(abs_path + '/VOC2028/labels/') image_ids open(abs_path + '/VOC2028/ImageSets/Main/%s.txt' % (image_set)).read().strip().split() list_file open(abs_path + '/VOC2028/%s.txt' % (image_set), 'w') for image_id in image_ids: list_file.write(abs_path + '/VOC2028/JPEGImages/%s.jpg\\n' % (image_id)) # 要么自己补全路径，只写一半可能会报错 convert_annotation(image_id) list_file.close() ``` ![picture 1](../assets/al1.png) #### 训练模型 配置环境 ``` git clone https://github.com/ultralytics/yolov5 cd yolov5 pip install r requirements.txt pip install onnx ``` 下载预训练权重（博主尝试了v7.0的和v6.0的pt都可以） ``` https://github.com/ultralytics/yolov5/releases/download/v7.0/yolov5s.pt ``` ![picture 2](../assets/al2.png) 训练（博主使用的是学校的集群进行训练） ``` python3 train.py weights weights/yolov5s.pt cfg models/yolov5s.yaml data data/safthat.yaml epochs 150 batch size 16 multi scale device 0 ``` ![picture 3](../assets/al3.png) ``` python3 detect.py source /root/yolov5/data/images/000000.jpg weights /root/yolov5/runs/train/exp13/weights/best.pt conf thres 0.25 ``` ![picture 4](../assets/al4.png) 导出onnx模型，并通过onnxsim自带的工具精简网络结构，导出子图 ``` python3 export.py weights yolov5s_hat.pt include onnx pip install onnx simplifier python3 m onnxsim yolov5s_hat.onnx yolov5s_hat_sub.onnx ``` ![picture 5](../assets/al5.png) 模型查看通过网址输入netron.app查看三个输出： ![picture 6](../assets/al6.png) 查看官方给的yolov5s.json文件： ``` { \"model_type\": \"ONNX\", \"npu_mode\": \"NPU1\", \"quant\": { \"input_configs\": [ { \"tensor_name\": \"images\", \"calibration_dataset\": \"./dataset/calibration_dataset.tar.gz\", \"calibration_size\": 4, \"calibration_mean\": [0, 0, 0], \"calibration_std\": [255.0, 255.0, 255.0] } ], \"calibration_method\": \"MinMax\", \"precision_analysis\": false }, \"input_processors\": [ { \"tensor_name\": \"images\", \"tensor_format\": \"BGR\", \"src_format\": \"BGR\", \"src_dtype\": \"U8\", \"src_layout\": \"NHWC\" } ], \"output_processors\": [ { \"tensor_name\": \"326\", \"dst_perm\": [0, 2, 3, 1] }, { \"tensor_name\": \"370\", \"dst_perm\": [0, 2, 3, 1] }, { \"tensor_name\": \"414\", \"dst_perm\": [0, 2, 3, 1] } ], \"compiler\": { \"check\": 0 } } ``` output_processors给的326，370，414 根据[秋水大佬博客](https://zhuanlan.zhihu.com/p/569083585)的导出子图文件修改得到适应pulsar2工具的onnx文件： ``` import onnx input_path \"yolov5s_hat sim.onnx\" output_path \"yolov5s_hat_sub.onnx\" input_names [\"images\"] output_names [\"326\",\"370\",\"414\"] onnx.utils.extract_model(input_path, output_path, input_names, output_names) ``` 问题记录： （1）导出子图很关键 &ensp; &ensp;由于之前对深度学习知识了解很少，才知道子图，如果执行使用yolov5s_hat_sub.onnx，在Pulsar2工具中进行量化的话，会生成axmodel但是是无法执行了，通过`o0圏圏蟲0o`大佬给的模型对比网络结构和秋水大佬的ax620a部署yolov5博客才明白自己问题出现在哪里 如果你没处理导出子图得到的图会是这样： ![picture 7](../assets/al7.png) 正确量化后的yolov5s图： 官方的yolov5s模型： ![picture 8](../assets/al8.png) 博主的正确的axmodel： ![picture 9](../assets/al9.png) 其中数字不同255和21的原因（秋水大佬博客有讲）： 该数字为（模型训练的类别+5）*3，博主类别为2类，所以就是21 ### 模型转化（关键） #### 安装docker环境（已安装过的可以跳过） ``` 安装docker依赖的基础软件 sudo apt get update sudo apt get install apt transport https ca certificates curl gnupg agent software properties common 添加官方来源 curl fsSL https://download.docker.com/linux/ubuntu/gpg sudo apt key add sudo add apt repository \"deb [arch amd64] https://download.docker.com/linux/ubuntu $(lsb_release cs) stable\" 安装 docker sudo apt get update sudo apt get install docker ce docker ce cli containerd.io ``` #### pulsar2工具模型转化以及仿真运行 下载pulsar2工具（博主使用的是1.9） [谷歌网盘链接：](https://drive.google.com/file/d/1 NW7ExBXj5 nTha40iwYshjNJb74Zfer/view?usp drive_link) [quick_start_example 文件夹](https://github.com/AXERA TECH/pulsar2 docs/releases/download/v1.9/quick_start_example.zip) 其中文件如下： ``` config dataset model output pulsar2 run helper ``` ./dataset/calibration_data.tar：添加了数据集的四张照片 config文件： ``` { \"model_type\": \"ONNX\", \"npu_mode\": \"NPU1\", \"quant\": { \"input_configs\": [ { \"tensor_name\": \"images\", \"calibration_dataset\": \"./dataset/calibration_data.tar\", \"calibration_size\": 4, \"calibration_mean\": [0, 0, 0], \"calibration_std\": [255.0, 255.0, 255.0] } ], \"calibration_method\": \"MinMax\", \"precision_analysis\": false }, \"input_processors\": [ { \"tensor_name\": \"images\", \"tensor_format\": \"BGR\", \"src_format\": \"BGR\", \"src_dtype\": \"U8\", \"src_layout\": \"NHWC\" } ], \"output_processors\": [ { \"tensor_name\": \"326\", \"dst_perm\": [0, 2, 3, 1] }, { \"tensor_name\": \"370\", \"dst_perm\": [0, 2, 3, 1] }, { \"tensor_name\": \"414\", \"dst_perm\": [0, 2, 3, 1] } ], \"compiler\": { \"check\": 0 } } ``` ``` （博主是直接就是root用户，如果不是root用户记得加sudo） root@LAPTOP U638FQQS:~# docker load i ax_pulsar2_1.9_enc.tar.gz root@LAPTOP U638FQQS:~# docker images a REPOSITORY TAG IMAGE ID CREATED SIZE hhb4tools/rv_debian_build 1.3 08f478d17c34 7 weeks ago 2.16GB pulsar2 1.9_enc 641ba18a8da3 2 months ago 3.46GB hhb4tools/hhb 2.4.5 58df969ae05a 3 months ago 8.16GB hhb4tools/rv_ub20_build 1.4 a65456ded4f0 6 months ago 5.11GB hhb4tools/march user static 1.0 d9efab34da5e 7 months ago 301MB riscv64/ubuntu 22.04 8b55084b9c02 11 months ago 61.6MB riscv64/ubuntu 21.04 d0b60ed75c22 21 months ago 60.3MB root@LAPTOP U638FQQS:~#docker run it net host rm v $PWD:/data pulsar2:1.9_enc root@1657ec5355e2:/data# pulsar2 version version: 1.9 commit: c62d0b64 root@1657ec5355e2:/data# ``` 1. 编译执行 以 yolov5s_hat_sub.onnx 为例, 执行如下 pulsar2 build 命令编译生成 compiled.axmodel: ``` pulsar2 build input model/yolov5s_hat_sub.onnx output_dir output config config/yolov5s_config.json ``` 博主输出信息： ``` root@1657ec5355e2:/data# pulsar2 build input model/yolov5s_hat_sub.onnx output_dir output config config/yolov5s_config.json 2023 11 16 17:49:21.238 WARNING yamain.command.build:fill_default:320 ignore images csc config because of src_format is AutoColorSpace or src_format and tensor_format are the same Building onnx ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 100% 0:00:00 2023 11 16 17:49:22.486 INFO yamain.command.build:build:444 save optimized onnx to [output/frontend/optimized.onnx] 2023 11 16 17:49:22.489 INFO yamain.common.util:extract_archive:21 extract [dataset/calibration_data.tar] to [output/quant/dataset/images]... Quant Config Table ┏━━━━━━━━┳━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━┓ ┃ Input ┃ Shape ┃ Dataset Directory ┃ Data Format ┃ Tensor Format ┃ Mean ┃ Std ┃ ┡━━━━━━━━╇━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━┩ │ images │ [1, 3, 640, 640] │ images │ Image │ BGR │ [0.0, 0.0, 0.0] │ [255.0, 255.0, 255.0] │ └────────┴──────────────────┴───────────────────┴─────────────┴───────────────┴─────────────────┴───────────────────────┘ Transformer optimize level: 0 4 File(s) Loaded. [17:49:24] AX LSTM Operation Format Pass Running ... Finished. [17:49:24] AX Set MixPrecision Pass Running ... Finished. [17:49:24] AX Refine Operation Config Pass Running ... Finished. [17:49:24] AX Reset Mul Config Pass Running ... Finished. [17:49:24] AX Tanh Operation Format Pass Running ... Finished. [17:49:24] AX Confused Op Refine Pass Running ... Finished. [17:49:24] AX Quantization Fusion Pass Running ... Finished. [17:49:24] AX Quantization Simplify Pass Running ... Finished. [17:49:24] AX Parameter Quantization Pass Running ... Finished. Calibration Progress(Phase 1): 100%███████████████████████████████████████████████████████████████████████████████ 4/4 [00:01<00:00, 2.16it/s] Finished. [17:49:26] AX Passive Parameter Quantization Running ... Finished. [17:49:26] AX Parameter Baking Pass Running ... Finished. [17:49:26] AX Refine Int Parameter Pass Running ... Finished. [17:49:26] AX Refine Weight Parameter Pass Running ... Finished. Network Snapshot Num of Op: [142] Num of Quantized Op: [142] Num of Variable: [267] Num of Quantized Var: [267] Quantization Snapshot Num of Quant Config: [430] BAKED: [60] OVERLAPPED: [168] ACTIVATED: [138] SOI: [4] PASSIVE_BAKED: [60] Network Quantization Finished. quant.axmodel export success: output/quant/quant_axmodel.onnx >export input/output data to folder: output/quant/debug/test_data_set_0 Building native ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 100% 0:00:00 2023 11 16 17:49:28.704 WARNING yamain.command.load_model:pre_process:454 preprocess tensor [images] 2023 11 16 17:49:28.704 INFO yamain.command.load_model:pre_process:456 tensor: images, (1, 640, 640, 3), U8 2023 11 16 17:49:28.705 INFO yamain.command.load_model:pre_process:456 op: op:pre_dequant_1, AxDequantizeLinear, {'const_inputs': {'x_zeropoint': array(0, dtype int32), 'x_scale': array(1., dtype float32)}, 'output_dtype': <class 'numpy.float32'>, 'quant_method': 0} 2023 11 16 17:49:28.705 INFO yamain.command.load_model:pre_process:456 tensor: tensor:pre_norm_1, (1, 640, 640, 3), FP32 2023 11 16 17:49:28.705 INFO yamain.command.load_model:pre_process:456 op: op:pre_norm_1, AxNormalize, {'dim': 3, 'mean': [0.0, 0.0, 0.0], 'std': [255.0, 255.0, 255.0]} 2023 11 16 17:49:28.705 INFO yamain.command.load_model:pre_process:456 tensor: tensor:pre_transpose_1, (1, 640, 640, 3), FP32 2023 11 16 17:49:28.705 INFO yamain.command.load_model:pre_process:456 op: op:pre_transpose_1, AxTranspose, {'perm': [0, 3, 1, 2]} 2023 11 16 17:49:28.705 WARNING yamain.command.load_model:post_process:475 postprocess tensor [326] 2023 11 16 17:49:28.705 INFO yamain.command.load_model:handle_postprocess:473 op: op:post_transpose_1, AxTranspose 2023 11 16 17:49:28.705 WARNING yamain.command.load_model:post_process:475 postprocess tensor [370] 2023 11 16 17:49:28.706 INFO yamain.command.load_model:handle_postprocess:473 op: op:post_transpose_2, AxTranspose 2023 11 16 17:49:28.706 WARNING yamain.command.load_model:post_process:475 postprocess tensor [414] 2023 11 16 17:49:28.706 INFO yamain.command.load_model:handle_postprocess:473 op: op:post_transpose_3, AxTranspose tiling op... ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 241/241 0:00:00 new_ddr_tensor [] <frozen backend.ax650npu.oprimpl.normalize>:186: RuntimeWarning: divide by zero encountered in divide <frozen backend.ax650npu.oprimpl.normalize>:187: RuntimeWarning: invalid value encountered in divide build op... ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 1177/1177 0:00:04 add ddr swap... ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 1141/1141 0:00:00 calc input dependencies... ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 1437/1437 0:00:00 calc output dependencies... ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 1437/1437 0:00:00 assign eu heuristic ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 1437/1437 0:00:00 assign eu onepass ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 1437/1437 0:00:00 assign eu greedy ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 1437/1437 0:00:00 2023 11 16 17:49:34.720 INFO yasched.test_onepass:results2model:2004 max_cycle 4,846,471 2023 11 16 17:49:35.349 INFO yamain.command.build:compile_npu_subgraph:1076 QuantAxModel macs: 7,881,318,400 2023 11 16 17:49:35.352 INFO yamain.command.build:compile_npu_subgraph:1084 use random data as gt input: images, uint8, (1, 640, 640, 3) 2023 11 16 17:49:38.687 INFO yamain.command.build:compile_ptq_model:1003 fuse 1 subgraph(s) root@1657ec5355e2:/data# ``` 2. 模型仿真运行 ``` cp output/compiled.axmodel pulsar2 run helper/models/yolov5s_hat.axmodel 输入数据准备 python3 cli_detection.py pre_processing image_path sim_images/000032.jpg axmodel_path models/yolov5s_hat.axmodel intermediate_path sim_inputs/0 输出信息： root@1657ec5355e2:/data/pulsar2 run helper# python3 cli_detection.py pre_processing image_path sim_images/000032.jpg axmodel_path models/yolov5s_hat.axmodel intermediate_path sim_inputs/0 [I] Write [images] to 'sim_inputs/0/images.bin' successfully. 仿真模型推理 pulsar2 run model models/yolov5s_hat.axmodel input_dir sim_inputs output_dir sim_outputs list list.txt 输出信息： root@1657ec5355e2:/data/pulsar2 run helper# pulsar2 run model models/yolov5s_hat.axmodel input_dir sim_inputs output_dir sim_outputs list list.txt Building native ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 100% 0:00:00 >>> [0] start write [326] to [sim_outputs/0/326.bin] successfully write [370] to [sim_outputs/0/370.bin] successfully write [414] to [sim_outputs/0/414.bin] successfully >>> [0] finish 输出数据处理（记得指定图片路径） python3 cli_detection.py post_processing image_path sim_images/000032.jpg axmodel_path models/yolov5s_hat.axmodel intermediate_path sim_outputs/0 输出信息： root@1657ec5355e2:/data/pulsar2 run helper# python3 cli_detection.py post_processing image_path sim_images/000032.jpg axmodel_path models/yolov5s_hat.axmodel intermediate_path sim_outputs/0 [I] Number of detected objects: 7 [I] 0: 94.59%, [972, 224, 1089, 345] [I] 0: 94.56%, [886, 222, 970, 327] [I] 0: 94.12%, [1141, 145, 1262, 281] [I] 0: 93.96%, [487, 249, 571, 370] [I] 0: 93.94%, [331, 201, 430, 341] [I] 0: 93.27%, [186, 192, 302, 351] [I] 0: 62.17%, [607, 233, 692, 338] root@1657ec5355e2:/data/pulsar2 run helper# ``` 具体工具文档如下： [pulsar2工具文档](https://pulsar2 docs.readthedocs.io/zh cn/latest/user_guides_quick) ### 开发板运行 开发板镜像为1.27版本，采用本地编译 下载源码： ``` git clone https://github.com/AXERA TECH/ax samples.git ``` 修改ax_yolov5s_steps.cc文件中： ``` 修改classname标签 const char* CLASS_NAMES[] { \"person\", \"hat\"}; generate_proposals_yolov5函数指定classnum数量为2 for (uint32_t i 0; i < io_info >nOutputSize; ++i) { auto& output io_data >pOutputs[i]; auto& info io_info >pOutputs[i]; auto ptr (float*)output.pVirAddr; int32_t stride (1 << i) * 8; detection::generate_proposals_yolov5(stride, ptr, PROB_THRESHOLD, proposals, input_w, input_h, ANCHORS, prob_threshold_u_sigmoid,2); } ``` 修改的原因是它默认为80，不然会报错下面信息： ``` root@maixbox:/home/ax samples/build/install/ax650# ./ax_yolov5s m yolov5s_hat.axmodel i 000032.jpg model file : yolov5s_hat.axmodel image file : 000032.jpg img_h, img_w : 640 640 WARN,Func(__is_valid_file),NOT find file '/etc/ax_syslog.conf' ERROR,Func(__syslog_parma_cfg_get), NOT find '/etc/ax_syslog.conf' Engine creating handle is done. Engine creating context is done. Engine get io info is done. Engine alloc io is done. Engine push input is done. Segmentation fault ``` ![picture 10](../assets/al10.png) ``` cd ax samples mkdir build && cd build cmake DBSP_MSP_DIR /soc/ DAXERA_TARGET_CHIP ax650 .. make j6 make install ``` 编译完成后，生成的可执行示例存放在 `ax samples/build/install/ax650/` 路径下： ```bash ax samples/build$ tree install install └── ax650 ├── ax_classification ├── ax_detr ├── ax_dinov2 ├── ax_glpdepth ├── ax_hrnet ├── ax_imgproc ├── ax_pfld ├── ax_pp_humanseg ├── ax_pp_liteseg_stdc2_cityscapes ├── ax_pp_ocr_rec ├── ax_pp_person_attribute ├── ax_pp_vehicle_attribute ├── ax_ppyoloe ├── ax_ppyoloe_obj365 ├── ax_realesrgan ├── ax_rtmdet ├── ax_scrfd ├── ax_segformer ├── ax_simcc_pose ├── ax_yolo_nas ├── ax_yolov5_face ├── ax_yolov5s ├── ax_yolov5s_seg ├── ax_yolov6 ├── ax_yolov7 ├── ax_yolov7_tiny_face ├── ax_yolov8 ├── ax_yolov8_pose └── ax_yolox ``` 讲axmodel模型放在可执行文件下和测试图片： ``` root@maixbox:/home/ax samples/build/install/ax650# ./ax_yolov5s m yolov5s_hat.axmodel i 000032.jpg model file : yolov5s_hat.axmodel image file : 000032.jpg img_h, img_w : 640 640 WARN,Func(__is_valid_file),NOT find file '/etc/ax_syslog.conf' ERROR,Func(__syslog_parma_cfg_get), NOT find '/etc/ax_syslog.conf' Engine creating handle is done. Engine creating context is done. Engine get io info is done. Engine alloc io is done. Engine push input is done. post process cost time:0.42 ms Repeat 1 times, avg time 6.15 ms, max_time 6.15 ms, min_time 6.15 ms detection num: 7 0: 95%, [ 981, 221, 1080, 342], person 0: 95%, [ 332, 201, 431, 341], person 0: 95%, [ 886, 222, 970, 327], person 0: 94%, [1141, 140, 1262, 290], person 0: 94%, [ 187, 197, 300, 347], person 0: 94%, [ 487, 252, 571, 373], person 0: 91%, [ 605, 232, 689, 337], person ``` ![picture 11](../assets/al11.png) ### 感谢 感谢`o0圏圏蟲0o`,`无事闲来`，`梦醒时分`，`N/A`，`秋水`等大佬的帮助 ## 部署yolov8s 自定义模型 > 本博客将向你展示零基础一步步的部署好自己的yolov8s模型（博主展示的是自己训练的手写数字识别模型），本博客教你从训练模型到转化成利于Pulsar2 工具量化部署到开发板上 ### 训练自己的YOLOv8s模型 #### 准备自定义数据集 数据集结构可以不像下面一样，这个只是记录当前测试适合的数据集目录结构，常见结构也有VOC结构，所以看个人喜好 `数据集目录结构`如下： ``` └─yolov8s_datasets:\t\t自定义数据集 ├─test\t │ └─images 图片文件 │ └─label 标签文件 ├─train\t\t │ └─images 图片文件 │ └─label 标签文件 ├─valid\t │ └─images 图片文件 │ └─label 标签文件 ├─data.yaml 路径和类别 ``` 本博客的data.yaml内容如下： ``` train: ../train/images val: ../valid/images test: ../test/images nc: 10 names: ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'] ``` ![picture 12](../assets/yolov8s1.png) #### YOLOv8训练环境搭建 配置环境 [YOLOv8官方配置环境](https://docs.ultralytics.com/quickstart/#install ultralytics) ``` # Clone the ultralytics repository git clone https://github.com/ultralytics/ultralytics # Navigate to the cloned directory cd ultralytics # Install the package in editable mode for development pip install e . ``` 下载预训练权重 ``` https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8s.pt ``` ![picture 13](../assets/yolov8s2.png) 测试环境 model路径可以指定绝对路径，source也可以指定图片的绝对路径 ``` yolo predict model yolov8n.pt source 'https://ultralytics.com/images/bus.jpg' ``` ![picture 14](../assets/yolov8s3.png) #### 训练自己的YOLOv8s模型 训练模型（官方有两种方式一种是使用CLI命令，另一种是使用PYTHON命令） 我比较喜欢训练用PYTHON命令，测试用CLI命令吗，看个人喜好 [YOLOv8官方PYTHON的用法](https://docs.ultralytics.com/usage/python/) [YOLOv8官方CLI的用法](https://docs.ultralytics.com/usage/cli/) ``` cd ultralytics touch my_train.py 将下面内容填写到py文件 from ultralytics import YOLO model YOLO('/root/ultralytics/yolov8s.pt') results model.train(data '/root/data1/wxw/yolov8s_datasets/data.yaml',epochs 80,amp False,batch 16,val True,device 0) 在此路径下执行python3 my_train.py ``` ![picture 15](../assets/yolov8s4.png) 测试模型 ``` yolo predict model /root/ultralytics/runs/detect/train17/weights/best.pt source '/root/ultralytics/ultralytics/assets/www.png' imgsz 640 ``` ![picture 16](../assets/yolov8s5.png) ### 模型部署和实机测试 #### 前期准备 导出适宜pular2的onnx模型 （1）导出onnx模型（记得加上opset 11） ``` yolo task detect mode export model /root/ultralytics/runs/detect/train17/weights/best.pt format onnx opset 11 ``` （2）onnx模型onnxsim化 ``` python3 m onnxsim best.onnx yolov8s_number_sim.onnx ``` 终端输出信息： ``` Simplifying... Finish! Here is the difference: ┏━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━┓ ┃ ┃ Original Model ┃ Simplified Model ┃ ┡━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━┩ │ Add │ 9 │ 8 │ │ Concat │ 24 │ 19 │ │ Constant │ 153 │ 139 │ │ Conv │ 64 │ 64 │ │ Div │ 2 │ 1 │ │ Gather │ 4 │ 0 │ │ MaxPool │ 3 │ 3 │ │ Mul │ 60 │ 58 │ │ Reshape │ 5 │ 5 │ │ Resize │ 2 │ 2 │ │ Shape │ 4 │ 0 │ │ Sigmoid │ 58 │ 58 │ │ Slice │ 2 │ 2 │ │ Softmax │ 1 │ 1 │ │ Split │ 9 │ 9 │ │ Sub │ 2 │ 2 │ │ Transpose │ 2 │ 2 │ │ Unsqueeze │ 7 │ 0 │ │ Model Size │ 42.6MiB │ 42.6MiB │ └────────────┴────────────────┴──────────────────┘ ``` （3）获得onnxsim化模型的sub ``` touch zhuanhuan.py 把下面内容加入进去，记得路径替换为自己模型 import onnx input_path \"/root/ultralytics/runs/detect/train17/weights/yolov8s_number_sim.onnx\" output_path \"yolov8s_number_sim_sub.onnx\" input_names [\"images\"] output_names [\"400\",\"433\"] onnx.utils.extract_model(input_path, output_path, input_names, output_names) ``` 得到模型如下图： ![picture 17](../assets/yolov8s6.png) 为模型量化部署的data [quick_start_example 文件夹](https://github.com/AXERA TECH/pulsar2 docs/releases/download/v1.9/quick_start_example.zip) ``` └─data:\t\t ├─config\t │ └─yolov8s_config_b1.json ├─dataset\t\t │ └─calibration_data.tar 四张数据集照片 ├─model\t │ └─yolov8s_number_sim_sub.onnx ├─pulsar2 run helper ``` 其中yolov8s_config_b1.json文件配置如下： ``` { \"model_type\": \"ONNX\", \"npu_mode\": \"NPU1\", \"quant\": { \"input_configs\": [ { \"tensor_name\": \"images\", \"calibration_dataset\": \"./dataset/calibration_data.tar\", \"calibration_size\": 4, \"calibration_mean\": [0, 0, 0], \"calibration_std\": [255.0, 255.0, 255.0] } ], \"calibration_method\": \"MinMax\", \"precision_analysis\": true, \"precision_analysis_method\":\"EndToEnd\" }, \"input_processors\": [ { \"tensor_name\": \"images\", \"tensor_format\": \"BGR\", \"src_format\": \"BGR\", \"src_dtype\": \"U8\", \"src_layout\": \"NHWC\" } ], \"output_processors\": [ { \"tensor_name\": \"400\", \"dst_perm\": [0, 1, 3, 2] }, { \"tensor_name\": \"433\", \"dst_perm\": [0, 2, 1] } ], \"compiler\": { \"check\": 0 } } ``` #### axmodel模型获取 进入docker环境（怎么搭建可以查看yolov5的自定义模型），将data文件拷贝到其中 执行下面命令： ``` cd data/ pulsar2 build input model/yolov8s_number_sim_sub.onnx output_dir output config config/yolov8s_config_b1.json ``` 终端输出信息： ``` root@1657ec5355e2:/data# pulsar2 build input model/yolov8s_number_sim_sub.onnx output_dir output config config/yolov8s_config_b1.json 2023 11 24 17:00:31.661 WARNING yamain.command.build:fill_default:320 ignore images csc config because of src_format is AutoColorSpace or src_format and tensor_format are the same Building onnx ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 100% 0:00:00 2023 11 24 17:00:33.226 INFO yamain.command.build:build:444 save optimized onnx to [output/frontend/optimized.onnx] 2023 11 24 17:00:33.229 INFO yamain.common.util:extract_archive:21 extract [dataset/calibration_data.tar] to [output/quant/dataset/images]... Quant Config Table ┏━━━━━━━━┳━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━┓ ┃ Input ┃ Shape ┃ Dataset Directory ┃ Data Format ┃ Tensor Format ┃ Mean ┃ Std ┃ ┡━━━━━━━━╇━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━┩ │ images │ [1, 3, 640, 640] │ images │ Image │ BGR │ [0.0, 0.0, 0.0] │ [255.0, 255.0, 255.0] │ └────────┴──────────────────┴───────────────────┴─────────────┴───────────────┴─────────────────┴───────────────────────┘ Transformer optimize level: 0 4 File(s) Loaded. [17:00:35] AX LSTM Operation Format Pass Running ... Finished. [17:00:35] AX Set MixPrecision Pass Running ... Finished. [17:00:35] AX Refine Operation Config Pass Running ... Finished. [17:00:35] AX Reset Mul Config Pass Running ... Finished. [17:00:35] AX Tanh Operation Format Pass Running ... Finished. [17:00:35] AX Confused Op Refine Pass Running ... Finished. [17:00:35] AX Quantization Fusion Pass Running ... Finished. [17:00:35] AX Quantization Simplify Pass Running ... Finished. [17:00:35] AX Parameter Quantization Pass Running ... Finished. Calibration Progress(Phase 1): 100%██████████████████████████████████████████████████████████████████████ 4/4 [00:02<00:00, 1.54it/s] Finished. [17:00:38] AX Passive Parameter Quantization Running ... Finished. [17:00:38] AX Parameter Baking Pass Running ... Finished. [17:00:38] AX Refine Int Parameter Pass Running ... Finished. [17:00:39] AX Refine Weight Parameter Pass Running ... Finished. Network Snapshot Num of Op: [166] Num of Quantized Op: [166] Num of Variable: [320] Num of Quantized Var: [320] Quantization Snapshot Num of Quant Config: [521] BAKED: [64] OVERLAPPED: [230] ACTIVATED: [147] SOI: [17] PASSIVE_BAKED: [63] Network Quantization Finished. quant.axmodel export success: output/quant/quant_axmodel.onnx >export per layer debug_data(float data) to folder: output/quant/debug/float Writing npy... ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 100% 0:00:00 >export input/output data to folder: output/quant/debug/test_data_set_0 Building native ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 100% 0:00:00 Quant Precision Table【EndToEnd Reference】 ┏━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━┳━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━┓ ┃ Operator ┃ Type ┃ Output Tensor ┃ Data Type ┃ Shape ┃ Cosin Distance ┃ ┡━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━╇━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━┩ │ Conv_0 │ AxQuantizedConv │ 128 │ FP32 │ (1, 32, 320, 320) │ 0.997423529624939 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ op_29:onnx.Silu │ AxQuantizedSilu │ 130 │ FP32 │ (1, 32, 320, 320) │ 0.9927281141281128 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Conv_3 │ AxQuantizedConv │ 131 │ FP32 │ (1, 64, 160, 160) │ 0.9920939207077026 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ op_43:onnx.Silu │ AxQuantizedSilu │ 133 │ FP32 │ (1, 64, 160, 160) │ 0.9900780916213989 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Conv_6 │ AxQuantizedConv │ 134 │ FP32 │ (1, 64, 160, 160) │ 0.9906365275382996 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ op_52:onnx.Silu │ AxQuantizedSilu │ 136 │ FP32 │ (1, 64, 160, 160) │ 0.9852141737937927 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Split_9 │ AxSplit │ 137 │ FP32 │ (1, 32, 160, 160) │ 0.9803164601325989 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Split_9 │ AxSplit │ 138 │ FP32 │ (1, 32, 160, 160) │ 0.9905278086662292 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Conv_10 │ AxQuantizedConv │ 139 │ FP32 │ (1, 32, 160, 160) │ 0.9823276996612549 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ op_5:onnx.Silu │ AxQuantizedSilu │ 141 │ FP32 │ (1, 32, 160, 160) │ 0.9837850332260132 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Conv_13 │ AxQuantizedConv │ 142 │ FP32 │ (1, 32, 160, 160) │ 0.9893827438354492 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ op_14:onnx.Silu │ AxQuantizedSilu │ 144 │ FP32 │ (1, 32, 160, 160) │ 0.9909690022468567 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Add_16 │ AxQuantizedAdd │ 145 │ FP32 │ (1, 32, 160, 160) │ 0.9938862919807434 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Concat_17 │ AxQuantizedConcat │ 146 │ FP32 │ (1, 96, 160, 160) │ 0.9908509254455566 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Conv_18 │ AxQuantizedConv │ 147 │ FP32 │ (1, 64, 160, 160) │ 0.9462912082672119 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ op_30:onnx.Silu │ AxQuantizedSilu │ 149 │ FP32 │ (1, 64, 160, 160) │ 0.950251042842865 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Conv_21 │ AxQuantizedConv │ 150 │ FP32 │ (1, 128, 80, 80) │ 0.9519447684288025 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ op_35:onnx.Silu │ AxQuantizedSilu │ 152 │ FP32 │ (1, 128, 80, 80) │ 0.9611063003540039 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Conv_24 │ AxQuantizedConv │ 153 │ FP32 │ (1, 128, 80, 80) │ 0.95732182264328 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ op_36:onnx.Silu │ AxQuantizedSilu │ 155 │ FP32 │ (1, 128, 80, 80) │ 0.9646297097206116 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Split_27 │ AxSplit │ 156 │ FP32 │ (1, 64, 80, 80) │ 0.9520685076713562 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Split_27 │ AxSplit │ 157 │ FP32 │ (1, 64, 80, 80) │ 0.9791563153266907 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Conv_28 │ AxQuantizedConv │ 158 │ FP32 │ (1, 64, 80, 80) │ 0.9838675260543823 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ op_37:onnx.Silu │ AxQuantizedSilu │ 160 │ FP32 │ (1, 64, 80, 80) │ 0.9839531183242798 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Conv_31 │ AxQuantizedConv │ 161 │ FP32 │ (1, 64, 80, 80) │ 0.9883632063865662 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ op_38:onnx.Silu │ AxQuantizedSilu │ 163 │ FP32 │ (1, 64, 80, 80) │ 0.9865988492965698 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Add_34 │ AxQuantizedAdd │ 164 │ FP32 │ (1, 64, 80, 80) │ 0.985512375831604 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Conv_35 │ AxQuantizedConv │ 165 │ FP32 │ (1, 64, 80, 80) │ 0.9902355074882507 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ op_39:onnx.Silu │ AxQuantizedSilu │ 167 │ FP32 │ (1, 64, 80, 80) │ 0.9860387444496155 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Conv_38 │ AxQuantizedConv │ 168 │ FP32 │ (1, 64, 80, 80) │ 0.9821805953979492 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ op_40:onnx.Silu │ AxQuantizedSilu │ 170 │ FP32 │ (1, 64, 80, 80) │ 0.9860064387321472 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Add_41 │ AxQuantizedAdd │ 171 │ FP32 │ (1, 64, 80, 80) │ 0.9900265336036682 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Concat_42 │ AxQuantizedConcat │ 172 │ FP32 │ (1, 256, 80, 80) │ 0.982897937297821 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Conv_43 │ AxQuantizedConv │ 173 │ FP32 │ (1, 128, 80, 80) │ 0.9762859344482422 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ op_41:onnx.Silu │ AxQuantizedSilu │ 175 │ FP32 │ (1, 128, 80, 80) │ 0.973669707775116 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Conv_46 │ AxQuantizedConv │ 176 │ FP32 │ (1, 256, 40, 40) │ 0.9805741906166077 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ op_42:onnx.Silu │ AxQuantizedSilu │ 178 │ FP32 │ (1, 256, 40, 40) │ 0.9669018983840942 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Conv_49 │ AxQuantizedConv │ 179 │ FP32 │ (1, 256, 40, 40) │ 0.974116325378418 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ op_44:onnx.Silu │ AxQuantizedSilu │ 181 │ FP32 │ (1, 256, 40, 40) │ 0.9633337259292603 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Split_52 │ AxSplit │ 182 │ FP32 │ (1, 128, 40, 40) │ 0.9472137689590454 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Split_52 │ AxSplit │ 183 │ FP32 │ (1, 128, 40, 40) │ 0.985866904258728 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Conv_53 │ AxQuantizedConv │ 184 │ FP32 │ (1, 128, 40, 40) │ 0.9925387501716614 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ op_45:onnx.Silu │ AxQuantizedSilu │ 186 │ FP32 │ (1, 128, 40, 40) │ 0.9885753989219666 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Conv_56 │ AxQuantizedConv │ 187 │ FP32 │ (1, 128, 40, 40) │ 0.9947008490562439 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ op_46:onnx.Silu │ AxQuantizedSilu │ 189 │ FP32 │ (1, 128, 40, 40) │ 0.9901566505432129 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Add_59 │ AxQuantizedAdd │ 190 │ FP32 │ (1, 128, 40, 40) │ 0.988625705242157 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Conv_60 │ AxQuantizedConv │ 191 │ FP32 │ (1, 128, 40, 40) │ 0.9962781667709351 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ op_47:onnx.Silu │ AxQuantizedSilu │ 193 │ FP32 │ (1, 128, 40, 40) │ 0.9916768670082092 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Conv_63 │ AxQuantizedConv │ 194 │ FP32 │ (1, 128, 40, 40) │ 0.9938035607337952 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ op_48:onnx.Silu │ AxQuantizedSilu │ 196 │ FP32 │ (1, 128, 40, 40) │ 0.9931269288063049 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Add_66 │ AxQuantizedAdd │ 197 │ FP32 │ (1, 128, 40, 40) │ 0.9921359419822693 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Concat_67 │ AxQuantizedConcat │ 198 │ FP32 │ (1, 512, 40, 40) │ 0.9850411415100098 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Conv_68 │ AxQuantizedConv │ 199 │ FP32 │ (1, 256, 40, 40) │ 0.993002712726593 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ op_49:onnx.Silu │ AxQuantizedSilu │ 201 │ FP32 │ (1, 256, 40, 40) │ 0.9870186448097229 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Conv_71 │ AxQuantizedConv │ 202 │ FP32 │ (1, 512, 20, 20) │ 0.9940688610076904 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ op_50:onnx.Silu │ AxQuantizedSilu │ 204 │ FP32 │ (1, 512, 20, 20) │ 0.9908106923103333 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Conv_74 │ AxQuantizedConv │ 205 │ FP32 │ (1, 512, 20, 20) │ 0.9955147504806519 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ op_51:onnx.Silu │ AxQuantizedSilu │ 207 │ FP32 │ (1, 512, 20, 20) │ 0.993266224861145 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Split_77 │ AxSplit │ 208 │ FP32 │ (1, 256, 20, 20) │ 0.9926754832267761 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Split_77 │ AxSplit │ 209 │ FP32 │ (1, 256, 20, 20) │ 0.9949012398719788 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Conv_78 │ AxQuantizedConv │ 210 │ FP32 │ (1, 256, 20, 20) │ 0.9967618584632874 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ op_53:onnx.Silu │ AxQuantizedSilu │ 212 │ FP32 │ (1, 256, 20, 20) │ 0.9936745166778564 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Conv_81 │ AxQuantizedConv │ 213 │ FP32 │ (1, 256, 20, 20) │ 0.9948074221611023 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ op_54:onnx.Silu │ AxQuantizedSilu │ 215 │ FP32 │ (1, 256, 20, 20) │ 0.9930222630500793 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Add_84 │ AxQuantizedAdd │ 216 │ FP32 │ (1, 256, 20, 20) │ 0.9927186965942383 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Concat_85 │ AxQuantizedConcat │ 217 │ FP32 │ (1, 768, 20, 20) │ 0.9923632144927979 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Conv_86 │ AxQuantizedConv │ 218 │ FP32 │ (1, 512, 20, 20) │ 0.9958001971244812 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ op_55:onnx.Silu │ AxQuantizedSilu │ 220 │ FP32 │ (1, 512, 20, 20) │ 0.9927506446838379 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Conv_89 │ AxQuantizedConv │ 221 │ FP32 │ (1, 256, 20, 20) │ 0.9961010217666626 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ op_56:onnx.Silu │ AxQuantizedSilu │ 223 │ FP32 │ (1, 256, 20, 20) │ 0.9958807229995728 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ MaxPool_92 │ AxMaxPool │ 224 │ FP32 │ (1, 256, 20, 20) │ 0.9983914494514465 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ MaxPool_93 │ AxMaxPool │ 225 │ FP32 │ (1, 256, 20, 20) │ 0.9990320801734924 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ MaxPool_94 │ AxMaxPool │ 226 │ FP32 │ (1, 256, 20, 20) │ 0.9992600679397583 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Concat_95 │ AxConcat │ 227 │ FP32 │ (1, 1024, 20, 20) │ 0.9989012479782104 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Conv_96 │ AxQuantizedConv │ 228 │ FP32 │ (1, 512, 20, 20) │ 0.9985116720199585 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ op_57:onnx.Silu │ AxQuantizedSilu │ 230 │ FP32 │ (1, 512, 20, 20) │ 0.9942172169685364 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Resize_100 │ AxResize │ 235 │ FP32 │ (1, 512, 40, 40) │ 0.9942169189453125 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Concat_101 │ AxQuantizedConcat │ 236 │ FP32 │ (1, 768, 40, 40) │ 0.990614652633667 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Conv_102 │ AxQuantizedConv │ 237 │ FP32 │ (1, 256, 40, 40) │ 0.9945578575134277 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ op_1:onnx.Silu │ AxQuantizedSilu │ 239 │ FP32 │ (1, 256, 40, 40) │ 0.9886558055877686 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Split_105 │ AxSplit │ 240 │ FP32 │ (1, 128, 40, 40) │ 0.9857398867607117 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Split_105 │ AxSplit │ 241 │ FP32 │ (1, 128, 40, 40) │ 0.9915053248405457 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Conv_106 │ AxQuantizedConv │ 242 │ FP32 │ (1, 128, 40, 40) │ 0.994576096534729 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ op_2:onnx.Silu │ AxQuantizedSilu │ 244 │ FP32 │ (1, 128, 40, 40) │ 0.9875540137290955 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Conv_109 │ AxQuantizedConv │ 245 │ FP32 │ (1, 128, 40, 40) │ 0.9929768443107605 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ op_3:onnx.Silu │ AxQuantizedSilu │ 247 │ FP32 │ (1, 128, 40, 40) │ 0.9889622330665588 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Concat_112 │ AxQuantizedConcat │ 248 │ FP32 │ (1, 384, 40, 40) │ 0.9886360764503479 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Conv_113 │ AxQuantizedConv │ 249 │ FP32 │ (1, 256, 40, 40) │ 0.9926217198371887 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ op_4:onnx.Silu │ AxQuantizedSilu │ 251 │ FP32 │ (1, 256, 40, 40) │ 0.9852688312530518 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Resize_117 │ AxResize │ 256 │ FP32 │ (1, 256, 80, 80) │ 0.9852687120437622 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Concat_118 │ AxQuantizedConcat │ 257 │ FP32 │ (1, 384, 80, 80) │ 0.9802942872047424 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Conv_119 │ AxQuantizedConv │ 258 │ FP32 │ (1, 128, 80, 80) │ 0.9910836815834045 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ op_6:onnx.Silu │ AxQuantizedSilu │ 260 │ FP32 │ (1, 128, 80, 80) │ 0.9910115599632263 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Split_122 │ AxSplit │ 261 │ FP32 │ (1, 64, 80, 80) │ 0.9845921397209167 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Split_122 │ AxSplit │ 262 │ FP32 │ (1, 64, 80, 80) │ 0.9941115975379944 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Conv_123 │ AxQuantizedConv │ 263 │ FP32 │ (1, 64, 80, 80) │ 0.991513192653656 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ op_7:onnx.Silu │ AxQuantizedSilu │ 265 │ FP32 │ (1, 64, 80, 80) │ 0.9923253059387207 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Conv_126 │ AxQuantizedConv │ 266 │ FP32 │ (1, 64, 80, 80) │ 0.9854940176010132 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ op_8:onnx.Silu │ AxQuantizedSilu │ 268 │ FP32 │ (1, 64, 80, 80) │ 0.9859618544578552 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Concat_129 │ AxQuantizedConcat │ 269 │ FP32 │ (1, 192, 80, 80) │ 0.9889001250267029 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Conv_130 │ AxQuantizedConv │ 270 │ FP32 │ (1, 128, 80, 80) │ 0.9906606078147888 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ op_9:onnx.Silu │ AxQuantizedSilu │ 272 │ FP32 │ (1, 128, 80, 80) │ 0.9892817139625549 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Conv_133 │ AxQuantizedConv │ 273 │ FP32 │ (1, 128, 40, 40) │ 0.9838826656341553 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Conv_172 │ AxQuantizedConv │ 314 │ FP32 │ (1, 64, 80, 80) │ 0.9849876165390015 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Conv_179 │ AxQuantizedConv │ 321 │ FP32 │ (1, 128, 80, 80) │ 0.9861446022987366 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ op_10:onnx.Silu │ AxQuantizedSilu │ 275 │ FP32 │ (1, 128, 40, 40) │ 0.977114737033844 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ op_21:onnx.Silu │ AxQuantizedSilu │ 316 │ FP32 │ (1, 64, 80, 80) │ 0.9862261414527893 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ op_23:onnx.Silu │ AxQuantizedSilu │ 323 │ FP32 │ (1, 128, 80, 80) │ 0.9812053442001343 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Concat_136 │ AxQuantizedConcat │ 276 │ FP32 │ (1, 384, 40, 40) │ 0.9808831214904785 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Conv_175 │ AxQuantizedConv │ 317 │ FP32 │ (1, 64, 80, 80) │ 0.9858677387237549 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Conv_182 │ AxQuantizedConv │ 324 │ FP32 │ (1, 128, 80, 80) │ 0.9869458079338074 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Conv_137 │ AxQuantizedConv │ 277 │ FP32 │ (1, 256, 40, 40) │ 0.9876588582992554 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ op_22:onnx.Silu │ AxQuantizedSilu │ 319 │ FP32 │ (1, 64, 80, 80) │ 0.9876548647880554 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ op_24:onnx.Silu │ AxQuantizedSilu │ 326 │ FP32 │ (1, 128, 80, 80) │ 0.9867691397666931 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ op_11:onnx.Silu │ AxQuantizedSilu │ 279 │ FP32 │ (1, 256, 40, 40) │ 0.9794371724128723 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Conv_178 │ AxQuantizedConv │ 320 │ FP32 │ (1, 64, 80, 80) │ 0.9962972402572632 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Conv_185 │ AxQuantizedConv │ 327 │ FP32 │ (1, 10, 80, 80) │ 0.999699056148529 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Split_140 │ AxSplit │ 280 │ FP32 │ (1, 128, 40, 40) │ 0.9779428839683533 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Split_140 │ AxSplit │ 281 │ FP32 │ (1, 128, 40, 40) │ 0.9810059666633606 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Concat_186 │ AxQuantizedConcat │ 328 │ FP32 │ (1, 74, 80, 80) │ 0.9990708827972412 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Conv_141 │ AxQuantizedConv │ 282 │ FP32 │ (1, 128, 40, 40) │ 0.9924895763397217 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ op_12:onnx.Silu │ AxQuantizedSilu │ 284 │ FP32 │ (1, 128, 40, 40) │ 0.9863465428352356 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Conv_144 │ AxQuantizedConv │ 285 │ FP32 │ (1, 128, 40, 40) │ 0.9836944341659546 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ op_13:onnx.Silu │ AxQuantizedSilu │ 287 │ FP32 │ (1, 128, 40, 40) │ 0.979435384273529 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Concat_147 │ AxQuantizedConcat │ 288 │ FP32 │ (1, 384, 40, 40) │ 0.9788963198661804 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Reshape_219 │ AxReshape │ 365 │ FP32 │ (1, 74, 6400) │ 0.9990708827972412 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Conv_148 │ AxQuantizedConv │ 289 │ FP32 │ (1, 256, 40, 40) │ 0.988214910030365 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ op_15:onnx.Silu │ AxQuantizedSilu │ 291 │ FP32 │ (1, 256, 40, 40) │ 0.9796479940414429 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Conv_187 │ AxQuantizedConv │ 329 │ FP32 │ (1, 64, 40, 40) │ 0.9869023561477661 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ op_25:onnx.Silu │ AxQuantizedSilu │ 331 │ FP32 │ (1, 64, 40, 40) │ 0.9856531620025635 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Conv_190 │ AxQuantizedConv │ 332 │ FP32 │ (1, 64, 40, 40) │ 0.9895309209823608 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ op_26:onnx.Silu │ AxQuantizedSilu │ 334 │ FP32 │ (1, 64, 40, 40) │ 0.9907711148262024 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Conv_193 │ AxQuantizedConv │ 335 │ FP32 │ (1, 64, 40, 40) │ 0.9972687363624573 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Conv_194 │ AxQuantizedConv │ 336 │ FP32 │ (1, 128, 40, 40) │ 0.9887939691543579 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ op_27:onnx.Silu │ AxQuantizedSilu │ 338 │ FP32 │ (1, 128, 40, 40) │ 0.9862679839134216 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Conv_197 │ AxQuantizedConv │ 339 │ FP32 │ (1, 128, 40, 40) │ 0.9903503060340881 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ op_28:onnx.Silu │ AxQuantizedSilu │ 341 │ FP32 │ (1, 128, 40, 40) │ 0.9908957481384277 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Conv_200 │ AxQuantizedConv │ 342 │ FP32 │ (1, 10, 40, 40) │ 0.9996321201324463 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Concat_201 │ AxQuantizedConcat │ 343 │ FP32 │ (1, 74, 40, 40) │ 0.9989909529685974 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Reshape_222 │ AxReshape │ 372 │ FP32 │ (1, 74, 1600) │ 0.9989909529685974 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Conv_151 │ AxQuantizedConv │ 292 │ FP32 │ (1, 256, 20, 20) │ 0.9880331158638 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ op_16:onnx.Silu │ AxQuantizedSilu │ 294 │ FP32 │ (1, 256, 20, 20) │ 0.9844340682029724 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Concat_154 │ AxQuantizedConcat │ 295 │ FP32 │ (1, 768, 20, 20) │ 0.988816499710083 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Conv_155 │ AxQuantizedConv │ 296 │ FP32 │ (1, 512, 20, 20) │ 0.9941884875297546 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ op_17:onnx.Silu │ AxQuantizedSilu │ 298 │ FP32 │ (1, 512, 20, 20) │ 0.9871212244033813 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Split_158 │ AxSplit │ 299 │ FP32 │ (1, 256, 20, 20) │ 0.9856522679328918 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Split_158 │ AxSplit │ 300 │ FP32 │ (1, 256, 20, 20) │ 0.9890781044960022 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Conv_159 │ AxQuantizedConv │ 301 │ FP32 │ (1, 256, 20, 20) │ 0.9955114722251892 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ op_18:onnx.Silu │ AxQuantizedSilu │ 303 │ FP32 │ (1, 256, 20, 20) │ 0.9916191101074219 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Conv_162 │ AxQuantizedConv │ 304 │ FP32 │ (1, 256, 20, 20) │ 0.9965550899505615 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ op_19:onnx.Silu │ AxQuantizedSilu │ 306 │ FP32 │ (1, 256, 20, 20) │ 0.9942261576652527 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Concat_165 │ AxQuantizedConcat │ 307 │ FP32 │ (1, 768, 20, 20) │ 0.9901660084724426 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Conv_166 │ AxQuantizedConv │ 308 │ FP32 │ (1, 512, 20, 20) │ 0.9945989847183228 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ op_20:onnx.Silu │ AxQuantizedSilu │ 310 │ FP32 │ (1, 512, 20, 20) │ 0.9887732863426208 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Conv_202 │ AxQuantizedConv │ 344 │ FP32 │ (1, 64, 20, 20) │ 0.996159553527832 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ op_31:onnx.Silu │ AxQuantizedSilu │ 346 │ FP32 │ (1, 64, 20, 20) │ 0.9934245944023132 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Conv_205 │ AxQuantizedConv │ 347 │ FP32 │ (1, 64, 20, 20) │ 0.9966049194335938 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ op_32:onnx.Silu │ AxQuantizedSilu │ 349 │ FP32 │ (1, 64, 20, 20) │ 0.9963405132293701 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Conv_208 │ AxQuantizedConv │ 350 │ FP32 │ (1, 64, 20, 20) │ 0.9985672235488892 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Conv_209 │ AxQuantizedConv │ 351 │ FP32 │ (1, 128, 20, 20) │ 0.9967932105064392 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ op_33:onnx.Silu │ AxQuantizedSilu │ 353 │ FP32 │ (1, 128, 20, 20) │ 0.9959353804588318 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Conv_212 │ AxQuantizedConv │ 354 │ FP32 │ (1, 128, 20, 20) │ 0.9973016381263733 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ op_34:onnx.Silu │ AxQuantizedSilu │ 356 │ FP32 │ (1, 128, 20, 20) │ 0.9974710941314697 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Conv_215 │ AxQuantizedConv │ 357 │ FP32 │ (1, 10, 20, 20) │ 0.9998636245727539 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Concat_216 │ AxQuantizedConcat │ 358 │ FP32 │ (1, 74, 20, 20) │ 0.9993820786476135 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Reshape_225 │ AxReshape │ 379 │ FP32 │ (1, 74, 400) │ 0.9993820786476135 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Concat_226 │ AxQuantizedConcat │ 380 │ FP32 │ (1, 74, 8400) │ 0.9990093111991882 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Split_227 │ AxSplit │ 381 │ FP32 │ (1, 64, 8400) │ 0.9962611198425293 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Split_227 │ AxSplit │ 382 │ FP32 │ (1, 10, 8400) │ 0.9996734857559204 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Reshape_237 │ AxReshape │ 396 │ FP32 │ (1, 4, 16, 8400) │ 0.9962611198425293 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Sigmoid_270 │ AxQuantizedSigmoid │ 433 │ FP32 │ (1, 10, 8400) │ 0.9993797540664673 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Transpose_238 │ AxTranspose │ 397 │ FP32 │ (1, 8400, 4, 16) │ 0.9962610602378845 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Softmax_239 │ AxQuantizedSoftmax │ 398 │ FP32 │ (1, 8400, 4, 16) │ 0.9862769246101379 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Transpose_240 │ AxTranspose │ 399 │ FP32 │ (1, 16, 4, 8400) │ 0.9862770438194275 │ ├─────────────────┼────────────────────┼───────────────┼───────────┼───────────────────┼────────────────────┤ │ Conv_241 │ AxQuantizedConv │ 400 │ FP32 │ (1, 1, 4, 8400) │ 0.9961861371994019 │ └─────────────────┴────────────────────┴───────────────┴───────────┴───────────────────┴────────────────────┘ Building native ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 100% 0:00:00 2023 11 24 17:00:43.829 WARNING yamain.command.load_model:pre_process:454 preprocess tensor [images] 2023 11 24 17:00:43.830 INFO yamain.command.load_model:pre_process:456 tensor: images, (1, 640, 640, 3), U8 2023 11 24 17:00:43.830 INFO yamain.command.load_model:pre_process:456 op: op:pre_dequant_1, AxDequantizeLinear, {'const_inputs': {'x_zeropoint': array(0, dtype int32), 'x_scale': array(1., dtype float32)}, 'output_dtype': <class 'numpy.float32'>, 'quant_method': 0} 2023 11 24 17:00:43.830 INFO yamain.command.load_model:pre_process:456 tensor: tensor:pre_norm_1, (1, 640, 640, 3), FP32 2023 11 24 17:00:43.830 INFO yamain.command.load_model:pre_process:456 op: op:pre_norm_1, AxNormalize, {'dim': 3, 'mean': [0.0, 0.0, 0.0], 'std': [255.0, 255.0, 255.0]} 2023 11 24 17:00:43.830 INFO yamain.command.load_model:pre_process:456 tensor: tensor:pre_transpose_1, (1, 640, 640, 3), FP32 2023 11 24 17:00:43.830 INFO yamain.command.load_model:pre_process:456 op: op:pre_transpose_1, AxTranspose, {'perm': [0, 3, 1, 2]} 2023 11 24 17:00:43.831 WARNING yamain.command.load_model:post_process:475 postprocess tensor [400] 2023 11 24 17:00:43.831 INFO yamain.command.load_model:handle_postprocess:473 op: op:post_transpose_1, AxTranspose 2023 11 24 17:00:43.831 WARNING yamain.command.load_model:post_process:475 postprocess tensor [433] 2023 11 24 17:00:43.831 INFO yamain.command.load_model:handle_postprocess:473 op: op:post_transpose_2, AxTranspose tiling op... ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 303/303 0:00:00 new_ddr_tensor [] <frozen backend.ax650npu.oprimpl.normalize>:186: RuntimeWarning: divide by zero encountered in divide <frozen backend.ax650npu.oprimpl.normalize>:187: RuntimeWarning: invalid value encountered in divide build op... ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 1254/1254 0:00:06 add ddr swap... ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 2269/2269 0:00:00 calc input dependencies... ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 2659/2659 0:00:00 calc output dependencies... ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 2659/2659 0:00:00 assign eu heuristic ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 2659/2659 0:00:00 assign eu onepass ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 2659/2659 0:00:00 assign eu greedy ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 2659/2659 0:00:00 2023 11 24 17:00:52.838 INFO yasched.test_onepass:results2model:2004 max_cycle 8,507,216 2023 11 24 17:00:53.860 INFO yamain.command.build:compile_npu_subgraph:1076 QuantAxModel macs: 14,226,048,000 2023 11 24 17:00:53.862 INFO yamain.command.build:compile_npu_subgraph:1084 use random data as gt input: images, uint8, (1, 640, 640, 3) 2023 11 24 17:00:58.726 INFO yamain.command.build:compile_ptq_model:1003 fuse 1 subgraph(s) root@1657ec5355e2:/data# ls config dataset model output pulsar2 run helper root@1657ec5355e2:/data# cp r output /mnt/ ``` axmodel转化成功后可以在后缀加上.onnx，如下： ![picture 12](../assets/yolov8s7.png) #### 部署到开发板 开发板镜像为1.27版本，采用本地编译 下载源码： ``` git clone https://github.com/AXERA TECH/ax samples.git ``` 修改ax_yolov8s_steps.cc文件中： ``` 修改classname标签和类别数量 const char* CLASS_NAMES[] { \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"}; int NUM_CLASS 10; ``` ``` cd ax samples mkdir build && cd build cmake DBSP_MSP_DIR /soc/ DAXERA_TARGET_CHIP ax650 .. make j6 make install ``` 编译完成后，生成的可执行示例存放在 `ax samples/build/install/ax650/` 路径下： ```bash ax samples/build$ tree install install └── ax650 ├── ax_classification ├── ax_detr ├── ax_dinov2 ├── ax_glpdepth ├── ax_hrnet ├── ax_imgproc ├── ax_pfld ├── ax_pp_humanseg ├── ax_pp_liteseg_stdc2_cityscapes ├── ax_pp_ocr_rec ├── ax_pp_person_attribute ├── ax_pp_vehicle_attribute ├── ax_ppyoloe ├── ax_ppyoloe_obj365 ├── ax_realesrgan ├── ax_rtmdet ├── ax_scrfd ├── ax_segformer ├── ax_simcc_pose ├── ax_yolo_nas ├── ax_yolov5_face ├── ax_yolov5s ├── ax_yolov5s_seg ├── ax_yolov6 ├── ax_yolov7 ├── ax_yolov7_tiny_face ├── ax_yolov8 ├── ax_yolov8_pose └── ax_yolox ``` 将axmodel模型放在可执行文件下和测试图片： ``` root@maixbox:/home/ax samples/build/install/ax650# ./ax_yolov8 m yolov8snumber.axmodel i 1.jpg model file : yolov8snumber.axmodel image file : 1.jpg img_h, img_w : 640 640 WARN,Func(__is_valid_file),NOT find file '/etc/ax_syslog.conf' ERROR,Func(__syslog_parma_cfg_get), NOT find '/etc/ax_syslog.conf' Engine creating handle is done. Engine creating context is done. Engine get io info is done. Engine alloc io is done. Engine push input is done. post process cost time:0.49 ms Repeat 1 times, avg time 10.92 ms, max_time 10.92 ms, min_time 10.92 ms detection num: 4 2: 94%, [ 275, 38, 362, 168], 2 3: 94%, [ 58, 47, 145, 175], 3 1: 92%, [ 75, 250, 140, 378], 1 1: 90%, [ 288, 249, 336, 378], 1 ``` ![picture 12](../assets/yolov8s8.png)"},"/hardware/zh/maixIV/m4chat/quick-start.html":{"title":"","content":"## 系统烧录 详情见 [系统烧录指南](../m4c/system update.html)，请优先考虑 TFCard&eMMC 镜像（Debian 12 系统）。 以下基于该镜像展开介绍，若使用自行编译的镜像，请多加注意细节对比。 ## 系统启动 ### 开机前准备 1. 5V USB 供电电源 2. mini HDMI 线缆和显示器 3. USB 串口工具如 [SLogic Combo8](../../logic_analyzer/combo8/index.html)（可选项，用于串口调试和登录） ### 正常开机 1. 登录界面 通过 mini HDMI 连接显示器并接入供电，此时核心板应亮起蓝灯，Hat 底板亮起白灯，表明供电正常。如果 eMMC 为默认供树莓派启动的从机镜像，请注意烧录独立新镜像到 TF 卡并插入 M4C Hat。再保持 `BOOT0` 键按下时点按 `RST`，等待片刻约 20 多秒后显示器屏幕将会如下显示 LightDM 登录界面，表示系统启动成功。 2. 系统桌面 板载 USB A 口连接鼠标、键盘，方便后续系统操作和输入。登录界面等待输入用户名和密码，默认都为 root，确认登录即可进入 XFCE4 桌面系统。 <div style \"display: flex; flex wrap: wrap; gap: 10px; width: 100%;\"> <img src \"../assets/m4chat/DSC07545.JPG\" style \"width: calc(50% 5px);\"> <img src \"../assets/m4chat/DSC07546.JPG\" style \"width: calc(50% 5px);\"> </div> ### 串口和SSH登录（进阶） 板载 USB Type C 接口为默认调试串口，波特率相关配置为 **115200 8n1**。 用户可通过串口工具打开该串口，以查看内核调试信息，也可在此处通过用户名和密码直接登录系统终端进行命令操作。 若需通过 SSH 登录，可通过 USB有线/无线网卡 扩展网络链接。 注意：本系统仅内置 root 超级用户，且考虑到安全性并未开启超级用户 SSH 密码登录。 若临时有该需求请参阅[这里](../m4c/FAQ.html)。 ## LLM ### DeepSeek R1 & QWen3 左侧：[DeepSeek R1 1.5B](https://huggingface.co/AXERA TECH/DeepSeek R1 Distill Qwen 1.5B) 右侧：[QWen3 0.6B](https://huggingface.co/AXERA TECH/Qwen3 0.6B) 部署参考[此处](../m4c/axmodel deploy.html#部署大语言、多模态模型) ![DSr1 1.5B and QWen 0.6B](../assets/m4chat/DSr1 1.5B and QWen 0.6B.jpg) ## VLM ### internVL3 ![internVL3 demo](../assets/m4chat/internVL3 demo.jpg) 操作过程如下视频： <video controls autoplay src \"../assets/m4chat/m4nhat run llm internVL 2025 07 07.mp4\" type \"video/mp4\"> Your browser does not support video playback. </video> ## DepthAnything v2 下载[axcl npu python 库](https://github.com/AXERA TECH/pyaxengine/releases)后，`pip install axengine x.y.z py3 none any.whl` 进行安装。 ```bash source ../venv llm/bin/activate python python/infer.py img examples/demo02.jpg model depth_anything_v2_vits_ax650.axmodel ``` ![DepthAnything v2 before](../assets/m4chat/DSC07539.JPG) ![DepthAnything v2 after](../assets/m4chat/DSC07540.JPG) ![depthanything output](../assets/m4chat/depthanything output.png) ## 交互式图像分割和修复（Segment and Inpaint Anything） 交互式图像分割和修复，基于QT的GUI交互界面，实现了交互式点选、框选的实时分割和进一步可选修复，具体效果预览和操作流程如下。 ![samqt](../assets/samqt.jpg) 原始代码由爱芯官方开源于 GITHUB：[SAM ONNX AX650 CPP](https://github.com/AXERA TECH/SAM ONNX AX650 CPP) 可下载官方预编译版本或按仓库内文档自行编译进行体验，下图是移除照片某球员的效果展示。 <div><table><tr> <td><img src \"../assets/sam_example_before.png\" alt sam_example_before border 0></td> <td><img src \"../assets/sam_example_after.png\" alt sam_example_after border 0></td> </tr></table></div> 以下是实机操作画面。 <div><table><tr> <td><img src \"../assets/sam_raw.jpg\" alt sam_raw border 0></td> <td><img src \"../assets/sam_sam.jpg\" alt sam_sam border 0></td> <td><img src \"../assets/sam_inpaint.jpg\" alt sam_inpaint border 0></td> </tr><tr> <td>RAW</td> <td>SAM</td> <td>Inpaint</td> </tr></table></div> ## 交互式以文搜图（CLIP） 交互式以文搜图示例，基于QT的GUI交互解码，采用 OpenAI 在 2021 年开源的 Zero Shot 视觉分类模型 CLIP(Contrastive Language–Image Pre training) 通过文本输入快速检索出相关图片并显示，支持中文、英文两种文本语言输入。 原始代码由爱芯官方开源于 GITHUB：[CLIP ONNX AX650 CPP](https://github.com/AXERA TECH/CLIP ONNX AX650 CPP) [DEMO VIDEO](https://github.com/sipeed/sipeed_wiki/assets/13964381/df4cec7f 29af 465f bfad e54312274437) 准备 QT 运行环境 ``` apt update apt install cmake qt6 base dev ``` 下载预编译好的可执行文件、模型文件、测试图片、测试文本 [Baidu Pan](https://pan.baidu.com/s/17M5ugUyuf9mbi1cHLGJHXg) 将下载获得的 *CLIP.zip* 在 `/root/Desktop/` 路径下解压得到以下内容 ``` root@m4nhat 7190c7:~/Desktop/CLIP# tree L 1 . ├── CLIPQT ├── cn_vocab.txt ├── coco_1000 ├── libonnxruntime.so ├── libonnxruntime.so.1.16.0 ├── onnx_models ├── run_en.sh ├── run_zh.sh └── vocab.txt ``` 使用 HDMI 基于 HDMI1 接口链接显示器并登录进入桌面, 打开控制终端运行 `run_zh.sh` ![b38722991915fa54f17df18ca1f1447](https://github.com/AXERA TECH/CLIP ONNX AX650 CPP/assets/13964381/8fa2c4b8 b061 413e b72d 298bb4a445aa) CLIP DEMO 正常运行 ![34c8b68b1a8721d4ebff3b4b7184733](https://github.com/AXERA TECH/CLIP ONNX AX650 CPP/assets/13964381/7d0b9740 3598 492c ad42 2de23e7764e2)"},"/hardware/zh/maixIV/m4chat/intro.html":{"title":"","content":"## 简介 M4C Hat 是 Sipeed 公司推出的高集成度 AI 计算模组，采用爱芯元智 AX650N/C 芯片的紧凑型解决方案。作为嵌入式设备扩展模块，在提供 72TOPS@INT4(18TOPS@INT8) 算力的同时，保留与 M4C Dock 同源的 8K 编解码能力，专为空间受限的边缘计算场景设计。 本模组支持主流树莓派系列开发板即插即用，并支持 Transformer 架构加速。通过板载 0.8mm 4Pin USB 和 Type A USB SS 5Gbps 接口，可快速扩展摄像头、存储等外设，是智能摄像头、工业质检等轻量级AI应用的理想选择。PCIE2.0 扩展接口完美适配树莓派5，支持构建多模态边缘计算节点，支持 QWen 2.5、QWen 3、DeepSeek、InternVL2.5 等大模型的量化部署。 ## 图片展示 <div style \"display: flex; flex wrap: wrap; gap: 10px; width: 100%;\"> <img src \"../assets/m4chat/DSC07555.JPG\" style \"width: calc(50% 5px);\"> <img src \"../assets/m4chat/DSC07569.JPG\" style \"width: calc(50% 5px);\"> <img src \"../assets/m4chat/DSC07556.JPG\" style \"width: calc(50% 5px);\"> <img src \"../assets/m4chat/neofetch.jpg\" style \"width: calc(50% 5px);\"> </div> ## 接口标注 ![接口标注](../assets/m4chat/IAD.png) ## 功能参数 设备 详细描述 CPU 8x A55@1.7Ghz，集成 FPU，支持 NEON 加速 NPU 72 TOPS@INT4 或 18 TOPS@INT8，支持INT4/INT8/INT16/FP16/FP32 输入，支持 TopN(N< 32) CODEC 支持 H.264/H.265 编解码，单路最大 8K@60fps 解码和 8K@30ps 编码 DSP 双核800Mhz RAM 8G 64bit LPDDR4x，系统内核和 AI CMM 使用占比可调，默认 2+6 配置 ROM 32G eMMC 5.1，系统盘 视频输出 1x HDMI 2.0a，最大分辨率：4K@60fps 摄像头输入 1x 0.8mm 4p 外接 USB 摄像头 PCIE扩展 1x 16p fpc 1Lane PCIE2.0 5Gbps，兼容树莓派5 USB扩展 1x Type A USB SS 5Gbps + 1x Type C USB HS 480Mbps 外部连接 1x 1.25mm 2p 外接扬声器 + 1x 1.25mm 2p 外接风扇 + 1x 10p fpc 外接 SPI 屏幕 + 1x 6p fpc 外接 I2C 触摸 ![](../assets/m4c/benchmark.png) ![](../assets/m4c/normalized_benchmark.png) Models RK3588@6T Maix4@18T Hailo8 26T Hailo8 13T Inceptionv1 43 2494 928 519 MobileNetv2 960 5073 2433 1738 SqueezeNet11 694 5961 ResNet18 543 2254 ResNet50 294 1045 1368 503 SwinT 21 401 ViT B/16 18 207 107 40 YOLOv5s 48 384 364 168 YOLOv5n 78 743 YOLOv6s 80 321 YOLOv6n 212 743 YOLOv8s 39 279 YOLOv8n 73 710 YOLOxs 34 304 YOLO11s 30 313 Models Item Maix4@18T RK3588@6T SmolVLM 256M Image Encoder 512*512 105ms 842ms TTFT 57ms 87ms Decode 80 tokens/s 77 tokens/s StableDiffusion 1.5(512*512) U Net 0.43 s/it 5.65 s/it VAE Decoder 0.91 s 11.13 s Qwen2.5 VL 3B Image Encoder 448*448 780 ms TTFT 320 tokens 2857 ms Decode 6.2 tokens/s Image Encoder 392*392 2930 ms TTFT 196 tokens 1262 ms Decode 8.6 tokens/s ## 资源汇总 ### 硬件相关资料汇总 AX650N 芯片规格书：https://dl.sipeed.com/shareURL/MaixIV/M4N Dock ### 软件开发资料汇总 软件开发文档：https://dl.sipeed.com/shareURL/MaixIV/M4N Dock 软件开发SDK：https://www.ebaina.com/down/240000038900 ### AI 开发资料汇总 大模型和AXCL：https://axcl docs.readthedocs.io 树莓派5 AXCL专项：https://axcl pi5 examples cn.readthedocs.io 模型仓库：https://huggingface.co/AXERA TECH AI工具链（模型转换、仿真、部署，ONNX） Pulsar2 由爱芯元智自主研发的 ALL IN ONE 新一代神经网络编译器 使用文档：https://pulsar2 docs.readthedocs.io/zh_CN/latest/pulsar2/introduction.html 下载地址：https://huggingface.co/AXERA TECH/Pulsar2/tree/main 模型算子支持列表：https://pulsar2 docs.readthedocs.io/zh_CN/latest/appendix/op_support_list_ax650.html Samples 源码：https://github.com/AXERA TECH/ax samples LLM 源码：https://github.com/AXERA TECH/ax llm ## 技术支持 若有特定业务开发需求需要应用层开发文档，或在系统层对内核和根文件系统有特定需求或需要定制开发，请发邮件到support@sipeed.com尝试获取支持。"},"/hardware/zh/maixIV/m4chat/pcie-slaveboard.html":{"title":"","content":"<script src \"https://cdn.jsdelivr.net/npm/chart.js\"></script> # 树莓派5 PCIe 加速指南 ## 结果演示 树莓派 5 以下前置准备工作完成后，演示运行[大模型 DeepSeek R1:1.5B](https://huggingface.co/AXERA TECH/DeepSeek R1 Distill Qwen 1.5B GPTQ Int4) (Int4 参数量化)，性能达 13.69 tokens/s（较小参数量模型性能受限于 PCIe 链接，对比单板直接运行结果 19 tokens/s 差距会稍大），对比树莓派 5 仅 6.12 tokens/s。见以下视频： <video controls autoplay src \"../assets/m4chat/PCIe/axcl run llm on raspi5 2025 08 19 3xspeedup.mp4\" type \"video/mp4\"> Your browser does not support video playback. </video> ## 前置准备 Maix4 Hat sdcard 20250818.img.zst or newer ### 安装 <div style \"display: flex; justify content: space between;\"> <img src \"../assets/m4chat/DSC07559.JPG\" style \"width: 48%;\"> <img src \"../assets/m4chat/DSC07561.JPG\" style \"width: 48%;\"> </div> ![](../assets/m4chat/DSC07569.JPG) ### Maix4 HAT 烧录从机系统 1.使用 fpc 排线连接 Maix4 HAT 和 树莓派 5 的 PCIe 座子，并确认固定完毕。 2.上电树莓派给 Maix4 HAT 供电。 3.参考 [System Flashing Guide](../m4c/system update.html#启动 Live 系统（需手动按键操作）) 进入 TFCard Live 系统。 4.执行 `dd if /boot/spl_AX650_card_signed.bin of /dev/mmcblk0 conv fsync` 烧录从机系统以支持通过 PCIe 启动: ```bash root@m4chat 08080a:~# dd if /boot/spl_AX650_card_signed.bin of /dev/mmcblk0 conv fsync 512+0 records in 512+0 records out 262144 bytes (262 kB, 256 KiB) copied, 0.0165514 s, 15.8 MB/s ``` 5.启用树莓派的 PCIex1 端口: 执行 `sudo raspi config` 并进入 `6 Advanced Options > A8 PCIe Speed`，选择 `Yes` 以使能 PCIex1 gen3。 5.1.或检查 `/boot/firmware/config.txt` 中的内容（文件末尾）是否包含以下字段： ```bash [all] dtparam pciex1_gen 3 ``` 实际上这个 `config.txt` 文件所在 SD 卡的 boot 分区为 FAT32 格式，因此可被广大操作系统识别和读写。可在树莓派关机后取出，并通过读卡器插在 PC 上直接修改。 > 注意：刚烧录树莓派镜像的新卡不存在这个 /boot/firmware 目录，此时需要插入树莓派完整启动一次才会生成上文所描述的结构。 6.重启树莓派，使用 lspci 命令检查加速卡是否正确被识别： ```bash # 应能看到以下输出 sipeed@rpi sipeed:~ $ lspci 0001:00:00.0 PCI bridge: Broadcom Inc. and subsidiaries BCM2712 PCIe Bridge (rev 21) 0001:01:00.0 Multimedia video controller: Axera Semiconductor Co., Ltd Device 0650 (rev01) 0002:00:00.0 PCI bridge: Broadcom Inc. and subsidiaries BCM2712 PCIe Bridge (rev 21) 0002:01:00.0 Ethernet controller: Raspberry Pi Ltd RP1 PCIe 2.0 South Bridge ``` 其中前两行信息则表示树莓派的 PCIe 初始化成功，并识别挂载了 `Multimedia video controller: Axera Semiconductor Co., Ltd Device 0650 (rev01)`。 ### Raspi 5 安装 AXCL 软件包 PCIe 可以正常识别到 Maix4 HAT 后，还需要继续安装 AXCL 软件包以提供支持，才能通过 Maix4 HAT 加速运行模型。 该软件包 `axcl_host_aarch64_V3.6.2_20250603154858_NO4873.deb` 可于下载站单独下载到树莓派开发板上，或直接使用下面的AIDemos.tar.zst。 然后运行安装命令： ```bash sudo apt install axcl_host_aarch64_V3.6.2_20250603154858_NO4873.deb # 如果遇到问题:例如可以识别 PCIe，但 axcl smi 不能显示任何设备，请执行以下命令重新安装 sudo apt install reinstall axcl_host_aarch64_V3.6.2_20250603154858_NO4873.deb ``` 安装成功后，断电重启树莓派。 此时运行 `axcl smi` 显示内容如下，即代表安装成功： ```bash sipeed@rpi sipeed:~$ axcl smi + + AXCL SMI V3.6.2_20250603154858 Driver V3.6.2_20250603154858 + + + + Card Name Firmware Bus Id Memory Usage Fan Temp Pwr:Usage/Cap CPU NPU CMM Usage + + 0 AX650N V3.6.2 0001:01:00.0 148 MiB / 945 MiB 55C / 0% 0% 18 MiB / 7040 MiB + + + + + + Processes: Card PID Process Name NPU Memory Usage ``` ## 模型演示 于网盘下载 [AIDemos.tar.zst](https://mega.nz/folder/NxxEzRAB#e sA_IK0K5JqQM6FnCH6_Q) 并解压缩即可复现体验下列已部署模型。 国内用户可于下载站百度网盘加速下载。 ### 准备: 准备 Python 环境并安装 axengine 包。 ```bash cd /path/to/AIDemos/extra python m venv venv llm source venv llm/bin/activate pip install r requirements.txt pip install axengine 0.1.3 py3 none any.whl ``` 结果: ```bash sipeed@rpi sipeed:~/Downloads/AIDemos/extra $ ls lh total 44M rw r r 1 sipeed sipeed 44M Aug 14 09:04 axcl_host_aarch64_V3.6.2_20250603154858_NO4873.deb rw r r 1 sipeed sipeed 19K Aug 14 09:46 axengine 0.1.3 py3 none any.whl rw r r 1 sipeed sipeed 1.3K Aug 18 08:50 requirements.txt drwxr xr x 6 sipeed sipeed 4.0K Aug 18 03:24 venv llm ``` ### YOLO11 参考: https://huggingface.co/AXERA TECH/YOLO11 准备: ```bash source ../extra/venv llm/bin/activate ``` 示例: ```bash sipeed@rpi sipeed:~/Downloads/AIDemos/YOLO11 $ ls axcl_yolo11 ax_yolo11\tfootball.jpg ssd_horse.jpg yolo11s.axmodel yolo11x.axmodel sipeed@rpi sipeed:~/Downloads/AIDemos/YOLO11 $ ./axcl_yolo11 m yolo11s.axmodel i football.jpg model file : yolo11s.axmodel image file : football.jpg img_h, img_w : 640 640 axclrtEngineCreateContextt is done. axclrtEngineGetIOInfo is done. grpid: 0 input size: 1 name: images 1 x 640 x 640 x 3 output size: 3 name: /model.23/Concat_output_0 1 x 80 x 80 x 144 name: /model.23/Concat_1_output_0 1 x 40 x 40 x 144 name: /model.23/Concat_2_output_0 1 x 20 x 20 x 144 Engine push input is done. post process cost time:0.90 ms Repeat 1 times, avg time 3.34 ms, max_time 3.34 ms, min_time 3.34 ms detection num: 7 0: 95%, [ 759, 213, 1126, 1152], person 0: 94%, [ 0, 359, 315, 1107], person 0: 94%, [1350, 344, 1629, 1036], person 0: 89%, [ 490, 480, 658, 996], person 32: 73%, [ 771, 888, 830, 939], sports ball 32: 67%, [1231, 876, 1280, 924], sports ball 0: 62%, [ 0, 565, 86, 995], person ``` <div style \"display: flex; justify content: space between;\"> <img src \"../assets/m4chat/PCIe/football.jpg\" style \"width: 48%;\"> <img src \"../assets/m4chat/PCIe/yolo11_out.jpg\" style \"width: 48%;\"> </div> <div style \"width: 80%; margin: 0 auto;\"> <canvas id \"YOLOv11BarChart\"></canvas> <script> var ctx document.getElementById('YOLOv11BarChart').getContext('2d'); var YOLOv11BarChart new Chart(ctx, { type: 'bar', data: { labels: ['YOLOv11s', 'YOLOv11x'], // Now the models are the labels datasets: [ { label: 'Maix4 HAT 24T(PCIe mode)', data: [298, 40.48], backgroundColor: 'rgba(255, 99, 132, 0.2)', borderColor: 'rgba(255, 99, 132, 1)', borderWidth: 1 }, { label: 'Jetson Orin Nano Super 67T', data: [196.85, 50.25], backgroundColor: 'rgba(54, 162, 235, 0.2)', borderColor: 'rgba(54, 162, 235, 1)', borderWidth: 1 }, { label: 'Hailo8 26T', data: [147, 0], backgroundColor: 'rgba(255, 206, 86, 0.2)', // Gold borderColor: 'rgba(255, 206, 86, 1)', borderWidth: 1 } ] }, options: { responsive: true, plugins: { title: { display: true, text: 'YOLOv11 Performance Benchmark(fps)', // Chart title added here font: { size: 20 } }, legend: { position: 'top', }, tooltip: { callbacks: { label: function(tooltipItem) { return tooltipItem.dataset.label + ': ' + tooltipItem.raw + ' fps'; } } } }, scales: { y: { beginAtZero: true } } } }); </script> </div> 相关数据来源: [Ultralytics](https://docs.ultralytics.com/zh/guides/nvidia jetson/#nvidia jetson orin nano super developer kit_1), [RK3588](https://github.com/yuunnn w/rknn cpp yolo?tab readme ov file#report inference results and speed) ### DeepSeek R1 Distill Qwen 1.5B GPTQ Int4 参考: https://huggingface.co/AXERA TECH/DeepSeek R1 Distill Qwen 1.5B GPTQ Int4 用法: ```bash ./run_from_pi.sh ``` 示例: ```bash sipeed@rpi sipeed:~/Downloads/AIDemos/DeepSeek R1 Distill Qwen 1.5B GPTQ Int4 $ ./run_from_pi.sh Main script running (PID: 9852), subprocess PID: 9856 build time: Feb 13 2025 15:44:57 [I][ Init][ 111]: LLM init start bos_id: 151646, eos_id: 151643 100% ████████████████████████████████ 31 / 31 [17.22s<17.22s, 1.80 count/s] init post axmodel okremain_cmm( 1 MB) [I][ Init][ 226]: max_token_len : 1023 [I][ Init][ 231]: kv_cache_size : 256, kv_cache_num: 1023 [I][ load_config][ 282]: load config: { \"enable_repetition_penalty\": false, \"enable_temperature\": true, \"enable_top_k_sampling\": true, \"enable_top_p_sampling\": false, \"penalty_window\": 20, \"repetition_penalty\": 1.2, \"temperature\": 0.9, \"top_k\": 10, \"top_p\": 0.8 } [I][ Init][ 288]: LLM init ok Type \"q\" to exit, Ctrl+c to stop current running >> what can you do? <think> </think> I'm DeepSeek R1, an AI assistant created exclusively by DeepSeek. My purpose is to help you generate helpful responses. I don't have personal experiences or emotions, so I don't have feelings, but I'm focused on providing accurate and useful information. For more information, please visit DeepSeek's official website. [N][ Run][ 610]: hit eos,avg 13.69 token/s >> ``` <div style \"width: 80%; margin: 0 auto;\"> <canvas id \"DeepSeekR1BarChart\"></canvas> <script> var ctx document.getElementById('DeepSeekR1BarChart').getContext('2d'); var DeepSeekR1BarChart new Chart(ctx, { type: 'bar', data: { labels: ['DSR1:1.5B', 'DSR1:7B'], // Models as labels datasets: [ { label: 'Maix4 HAT 24T(PCIe mode)', data: [13.69, 4.64], backgroundColor: 'rgba(255, 99, 132, 0.2)', borderColor: 'rgba(255, 99, 132, 1)', borderWidth: 1 }, { label: 'RPI5', data: [6.12, 1.43], backgroundColor: 'rgba(54, 162, 235, 0.2)', borderColor: 'rgba(54, 162, 235, 1)', borderWidth: 1 } ] }, options: { responsive: true, plugins: { title: { display: true, text: 'DeepSeek R1 Performance Benchmark(higher is better)', // Chart title added here font: { size: 20 } }, legend: { position: 'top', }, tooltip: { callbacks: { label: function(tooltipItem) { return tooltipItem.dataset.label + ': ' + tooltipItem.raw + ' token/s'; } } } }, scales: { y: { beginAtZero: true } } } }); </script> </div> 相关数据来源: [deepseek r1 on RPI5](https://dev.to/jeremycmorgan/running deepseek r1 locally on a raspberry pi 1gh8) ### InternVL2_5 1B 参考: https://huggingface.co/AXERA TECH/InternVL2_5 1B 用法: ```bash ./run_from_pi.sh ``` 示例: ```bash sipeed@rpi sipeed:~/Downloads/AIDemos/InternVL2_5 1B $ ./run_from_pi.sh Main script running (PID: 10379), subprocess PID: 10383 [I][ Init][ 128]: LLM init start [I][ Init][ 321]: connect http://127.0.0.1:49152 ok bos_id: 1, eos_id: 151645 7% ███ 2 / 27 [0.70s<9.41s, 2.87 count/s] embed_selector init ok [I][ run][ 30]: AXCLWorker start with devid 0 100% ████████████████████████████████ 27 / 27 [18.42s<18.42s, 1.47 count/s] init post axmodel ok,remain_cmm(6433 MB)6574 MB) [I][ Init][ 225]: image_encoder_height : 448, image_encoder_width: 448 [I][ Init][ 227]: max_token_len : 1023 [I][ Init][ 230]: kv_cache_size : 128, kv_cache_num: 1023 [I][ Init][ 238]: prefill_token_num : 320 [I][ Init][ 240]: prefill_max_token_num : 320 ________________________ ID remain cmm(MB) 0 6066 ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯ [I][ load_config][ 282]: load config: { \"enable_repetition_penalty\": false, \"enable_temperature\": true, \"enable_top_k_sampling\": true, \"enable_top_p_sampling\": false, \"penalty_window\": 20, \"repetition_penalty\": 1.2, \"temperature\": 0.9, \"top_k\": 10, \"top_p\": 0.8 } [I][ Init][ 337]: LLM init ok Type \"q\" to exit, Ctrl+c to stop current running prompt >> describe the picture in English image >> ssd_car.jpg [I][ Encode][ 393]: image encode time : 362.10 ms, size : 229376 [I][ Encode][ 453]: offset : 42 out_embed.size() : 276864 [I][ Run][ 481]: input token num : 309, prefill_split_num : 1 [I][ Run][ 604]: ttft: 510.61 ms The image shows a classic red double decker bus parked on the side of a city street. The bus is adorned with advertisements, one of which reads, \"THINGS GET MORE EXCITING WHEN YOU SAY YES,\" along with a website, \"VMGIVING.COM.\" The bus number on it is 16. In the foreground, a woman is standing with a cheerful expression. She is wearing a black coat, a scarf, and jeans and appears to be smiling at the camera. In front of her, there is a streetcar, also red, passing by. The street is marked with a bicycle lane, indicated by a dashed white line on the road. In the background, several multi story buildings, likely commercial establishments, are visible. The setting appears to be a bustling urban area, with a mix of historical and modern architecture, suggesting a city center. [N][ Run][ 756]: hit eos,avg 18.73 token/s prompt >> ``` ![ssd_car.jpg](../assets/m4chat/PCIe/ssd_car.jpg) ### lcm lora sdv1 5 参考: https://huggingface.co/AXERA TECH/lcm lora sdv1 5 准备: ```bash source ../extra/venv llm/bin/activate ``` 用法: ```bash python run_txt2img_axe_infer_once.py prompt 'two beautiful girl' # or python run_txt2img_axe_infer_loop.py # wait it be ready and then type prompt and press Enter # or python run_img2img_axe_infer.py prompt \"8k, cute\" init_image txt2img_output_axe.png ``` 示例: ```bash (venv llm) sipeed@rpi sipeed:~/Downloads/AIDemos/lcm lora sdv1 5 $ python run_txt2img_axe_infer_once.py prompt 'two beautiful girl' [INFO] Available providers: ['AXCLRTExecutionProvider'] prompt: two beautiful girl text_tokenizer: ./models/tokenizer text_encoder: ./models/text_encoder unet_model: ./models/unet.axmodel vae_decoder_model: ./models/vae_decoder.axmodel time_input: ./models/time_input_txt2img.npy save_dir: ./txt2img_output_axe.png [INFO] Using provider: AXCLRTExecutionProvider [INFO] SOC Name: AX650N [INFO] VNPU type: VNPUType.DISABLED [INFO] Compiler version: 3.4 9215b7e5 text encoder take 4936.9ms [INFO] Using provider: AXCLRTExecutionProvider [INFO] SOC Name: AX650N [INFO] VNPU type: VNPUType.DISABLED [INFO] Compiler version: 3.3 972f38ca [INFO] Using provider: AXCLRTExecutionProvider [INFO] SOC Name: AX650N [INFO] VNPU type: VNPUType.DISABLED [INFO] Compiler version: 3.3 972f38ca load models take 25627.9ms unet once take 433.6ms unet once take 433.4ms unet once take 433.5ms unet once take 433.5ms unet loop take 1736.7ms vae inference take 914.8ms save image take 206.9ms (venv llm) sipeed@rpi sipeed:~/Downloads/AIDemos/lcm lora sdv1 5 $ python run_img2img_axe_infer.py prompt \"8k, cute\" init_image txt2img_output_axe.png [INFO] Available providers: ['AXCLRTExecutionProvider'] prompt: 8k, cute text_tokenizer: ./models/tokenizer text_encoder: ./models/text_encoder unet_model: ./models/unet.axmodel vae_encoder_model: ./models/vae_encoder.axmodel vae_decoder_model: ./models/vae_decoder.axmodel init image: txt2img_output_axe.png time_input: ./models/time_input_img2img.npy save_dir: ./img2img_output_axe.png [INFO] Using provider: AXCLRTExecutionProvider [INFO] SOC Name: AX650N [INFO] VNPU type: VNPUType.DISABLED [INFO] Compiler version: 3.4 9215b7e5 text encoder take 2954.0ms [INFO] Using provider: AXCLRTExecutionProvider [INFO] SOC Name: AX650N [INFO] VNPU type: VNPUType.DISABLED [INFO] Compiler version: 3.3 dirty 2ecead35 dirty [INFO] Using provider: AXCLRTExecutionProvider [INFO] SOC Name: AX650N [INFO] VNPU type: VNPUType.DISABLED [INFO] Compiler version: 3.3 972f38ca [INFO] Using provider: AXCLRTExecutionProvider [INFO] SOC Name: AX650N [INFO] VNPU type: VNPUType.DISABLED [INFO] Compiler version: 3.3 972f38ca load models take 15804.3ms vae encoder inference take 459.1ms unet once take 433.6ms unet once take 433.3ms unet loop take 868.3ms vae decoder inference take 913.7ms grid image saved in ./lcm_lora_sdv1 5_imgGrid_output.png save image take 445.9ms ``` ![img2img_output_axe](../assets/m4chat/PCIe/img2img_output_axe.png) <div style \"width: 80%; margin: 0 auto;\"> <canvas id \"SDV1_5BarChart\"></canvas> <script> var ctx document.getElementById('SDV1_5BarChart').getContext('2d'); var SDV1_5BarChart new Chart(ctx, { type: 'bar', data: { labels: ['U Net (it/min)', 'VAE Decoder (frame/min)'], // Models as labels datasets: [ { label: 'Maix4 HAT 24T(PCIe mode)', data: [139.53, 65.93], backgroundColor: 'rgba(255, 99, 132, 0.2)', borderColor: 'rgba(255, 99, 132, 1)', borderWidth: 1 }, { label: 'RK3588', data: [10.62, 5.39], backgroundColor: 'rgba(54, 162, 235, 0.2)', borderColor: 'rgba(54, 162, 235, 1)', borderWidth: 1 } ] }, options: { responsive: true, plugins: { title: { display: true, text: 'Stable Diffusion 1.5 (512x512) Performance Benchmark (lower is better)', // Chart title added here font: { size: 20 } }, legend: { position: 'top', }, tooltip: { callbacks: { label: function(tooltipItem) { return tooltipItem.dataset.label + ': ' + tooltipItem.raw; } } } }, scales: { y: { beginAtZero: true } } } }); </script> </div> 相关数据来源: [RK3588](https://huggingface.co/happyme531/Stable Diffusion 1.5 LCM ONNX RKNN2) ### Depth Anything V2 参考: https://huggingface.co/AXERA TECH/Depth Anything V2 准备: ```bash source ../extra/venv llm/bin/activate ``` 用法: ```bash python infer.py model depth_anything_v2_vits.axmodel img examples/demo01.jpg # or python infer_onnx.py model depth_anything_v2_vits.onnx img examples/demo02.jpg ``` ![depth_ouput_ax1](../assets/m4chat/PCIe/depth_ouput_ax1.png) ![depth_ouput_ax2](../assets/m4chat/PCIe/depth_ouput_ax2.png) <div style \"width: 80%; margin: 0 auto;\"> <canvas id \"Depth_Anything_V2BarChart\"></canvas> <script> var ctx document.getElementById('Depth_Anything_V2BarChart').getContext('2d'); var Depth_Anything_V2BarChart new Chart(ctx, { type: 'bar', data: { labels: ['Depth Anything V2 (fps)'], // Models as labels datasets: [ { label: 'Maix4 HAT 24T(PCIe mode)', data: [24.39], backgroundColor: 'rgba(255, 99, 132, 0.2)', borderColor: 'rgba(255, 99, 132, 1)', borderWidth: 1 }, { label: 'Jetson Orin', data: [10.2], backgroundColor: 'rgba(54, 162, 235, 0.2)', borderColor: 'rgba(54, 162, 235, 1)', borderWidth: 1 } ] }, options: { responsive: true, plugins: { title: { display: true, text: 'Depth Anything V2 (518x518) Performance Benchmark (fps)', // Chart title added here font: { size: 20 } }, legend: { position: 'top', }, tooltip: { callbacks: { label: function(tooltipItem) { return tooltipItem.dataset.label + ': ' + tooltipItem.raw + ' fps'; } } } }, scales: { y: { beginAtZero: true } } } }); </script> </div> 相关数据来源: [Jetson Orin](https://github.com/IRCVLab/Depth Anything for Jetson Orin) ### clip 参考: https://huggingface.co/AXERA TECH/clip https://github.com/AXERA TECH/clip.axera 准备: ```bash source ../extra/venv llm/bin/activate ``` 示例: ```bash (venv llm) sipeed@rpi sipeed:~/Downloads/AIDemos/clip $ ls clip_vit_l14_336px_image_encoder_all_u16_fc_u8.axmodel\tclip_vit_l14_336px_text_encoder_u16.axmodel images infer.py Tokenizer.py vocab.txt (venv llm) sipeed@rpi sipeed:~/Downloads/AIDemos/clip $ python infer.py [INFO] Available providers: ['AXCLRTExecutionProvider'] [INFO] Using provider: AXCLRTExecutionProvider [INFO] SOC Name: AX650N [INFO] VNPU type: VNPUType.DISABLED [INFO] Compiler version: 4.0 685bfee4 input.1 [1, 3, 336, 336] float32 4002 [1, 768] float32 [INFO] Using provider: AXCLRTExecutionProvider [INFO] SOC Name: AX650N [INFO] VNPU type: VNPUType.DISABLED [INFO] Compiler version: 4.0 685bfee4 texts [1, 77] int32 text_features [1, 768] float32 (14, 768) (11, 768) logits_per_image cat dog husky airplane car cityscape fire person eagle bike pineapple bike2.jpg 0.00 0.02 0.01 0.00 0.46 0.00 0.01 0.29 0.0 0.21 0.00 eagle.jpg 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 1.0 0.00 0.00 mv2seg.png 0.00 0.00 0.00 0.00 0.98 0.00 0.00 0.01 0.0 0.00 0.00 husky.jpeg 0.00 0.00 1.00 0.00 0.00 0.00 0.00 0.00 0.0 0.00 0.00 fire.png 0.00 0.00 0.00 0.00 0.00 0.00 1.00 0.00 0.0 0.00 0.00 dog.jpg 0.00 0.12 0.04 0.00 0.04 0.00 0.00 0.00 0.0 0.80 0.00 cat.jpg 0.91 0.03 0.01 0.00 0.01 0.00 0.01 0.00 0.0 0.01 0.03 big dog.jpg 0.00 0.15 0.07 0.00 0.56 0.00 0.03 0.09 0.0 0.01 0.08 pineapple.jpg 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.0 0.00 1.00 bike.jpg 0.00 0.00 0.01 0.00 0.01 0.00 0.00 0.05 0.0 0.92 0.00 cityscape.png 0.00 0.00 0.00 0.00 0.19 0.24 0.50 0.00 0.0 0.00 0.05 air.jpg 0.00 0.00 0.00 0.94 0.04 0.00 0.01 0.00 0.0 0.01 0.00 dog chai.jpeg 0.00 0.23 0.04 0.00 0.57 0.00 0.06 0.07 0.0 0.01 0.02 grace_hopper.jpg 0.02 0.07 0.00 0.00 0.55 0.00 0.28 0.07 0.0 0.00 0.00 logits_per_text bike2.jpg eagle.jpg mv2seg.png husky.jpeg fire.png dog.jpg cat.jpg big dog.jpg pineapple.jpg bike.jpg cityscape.png air.jpg dog chai.jpeg grace_hopper.jpg cat 0.00 0.01 0.00 0.00 0.00 0.00 0.92 0.01 0.0 0.00 0.00 0.00 0.04 0.02 dog 0.00 0.02 0.00 0.01 0.00 0.40 0.01 0.14 0.0 0.00 0.00 0.00 0.41 0.01 husky 0.00 0.00 0.00 1.00 0.00 0.00 0.00 0.00 0.0 0.00 0.00 0.00 0.00 0.00 airplane 0.00 0.07 0.00 0.00 0.00 0.00 0.00 0.01 0.0 0.00 0.00 0.91 0.01 0.00 car 0.03 0.01 0.29 0.00 0.00 0.05 0.00 0.19 0.0 0.00 0.01 0.01 0.38 0.03 cityscape 0.00 0.01 0.05 0.00 0.00 0.00 0.00 0.05 0.0 0.09 0.64 0.00 0.16 0.00 fire 0.00 0.01 0.00 0.00 0.94 0.00 0.00 0.01 0.0 0.00 0.01 0.00 0.02 0.01 person 0.15 0.04 0.01 0.00 0.00 0.03 0.00 0.22 0.0 0.17 0.00 0.00 0.33 0.03 eagle 0.00 1.00 0.00 0.00 0.00 0.00 0.00 0.00 0.0 0.00 0.00 0.00 0.00 0.00 bike 0.01 0.00 0.00 0.00 0.00 0.69 0.00 0.00 0.0 0.29 0.00 0.00 0.00 0.00 pineapple 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 1.0 0.00 0.00 0.00 0.00 0.00 ``` ### Whisper 参考: https://huggingface.co/AXERA TECH/Whisper 准备: ```bash source ../extra/venv llm/bin/activate ``` 用法: ```bash python whisper_onnx.py model_path ./models onnx/base/ t base wav ./demo.wav python whisper.py model_path ./models/small/ t small wav ./demo.wav # or ./whisper_axcl_aarch64 e ./models/small/small encoder.axmodel m ./models/small/small decoder main.axmodel l ./models/small/small decoder loop.axmodel p ./models/small/small positional_embedding.bin t ./models/small/small tokens.txt w ./demo.wav ``` 示例: ```bash (venv llm) sipeed@rpi sipeed:~/Downloads/AIDemos/Whisper $ ./whisper_axcl_aarch64 e ./models/small/small encoder.axmodel m ./models/small/small decoder main.axmodel l ./models/small/small decoder loop.axmodel p ./models/small/small positional_embedding.bin t ./models/small/small tokens.txt w ./RP1intro.wav language en encoder: ./models/small/small encoder.axmodel decoder_main: ./models/small/small decoder main.axmodel decoder_loop: ./models/small/small decoder loop.axmodel wav_file: ./RP1intro.wav language: en Load encoder take 2442.17 ms Load decoder_main take 4068.22 ms Load decoder_loop take 3837.32 ms Read positional_embedding Encoder run take 190.63 ms First token: 41154 \t take 51.20ms Next Token: 17741 \t take 30.39 ms Next Token: 1025 \t take 30.33 ms Next Token: 307 \t take 30.36 ms Next Token: 3094 \t take 30.25 ms Next Token: 1228 \t take 30.30 ms Next Token: 264 \t take 30.26 ms Next Token: 497 \t take 30.30 ms Next Token: 48 \t take 30.30 ms Next Token: 16 \t take 30.36 ms Next Token: 39839 \t take 30.21 ms Next Token: 1969 \t take 30.29 ms Next Token: 11 \t take 30.34 ms Next Token: 257 \t take 30.30 ms Next Token: 7372 \t take 30.22 ms Next Token: 19273 \t take 30.29 ms Next Token: 22848 \t take 30.20 ms Next Token: 4761 \t take 30.13 ms Next Token: 294 \t take 30.31 ms Next Token: 1782 \t take 30.33 ms Next Token: 295 \t take 30.32 ms Next Token: 41154 \t take 30.29 ms Next Token: 17741 \t take 30.33 ms Next Token: 13 \t take 30.28 ms Next Token: 50257 \t take 30.31 ms All Token: take 778.48ms, 32.11 token/s All take 1010.35ms Result: Raspberry Pi 5 is built using the RQ1 IO control, a package containing silicon designed in house of Raspberry Pi. ``` ### MeloTTS 参考: https://huggingface.co/AXERA TECH/MeloTTS 准备: ```bash source ../extra/venv llm/bin/activate cp R nltk_data ~/ ``` 用法: ```bash (venv llm) sipeed@rpi sipeed:~/Downloads/AIDemos/MeloTTS/python $ cd python (venv llm) sipeed@rpi sipeed:~/Downloads/AIDemos/MeloTTS/python $ python melotts.py h [INFO] Available providers: ['AXCLRTExecutionProvider'] usage: melotts [ h] [ sentence SENTENCE] [ wav WAV] [ encoder ENCODER] [ decoder DECODER] [ dec_len DEC_LEN] [ sample_rate SAMPLE_RATE] [ speed SPEED] [ language {ZH,ZH_MIX_EN,JP,EN,KR,ES,SP,FR}] Run TTS on input sentence options: h, help show this help message and exit sentence SENTENCE, s SENTENCE wav WAV, w WAV encoder ENCODER, e ENCODER decoder DECODER, d DECODER dec_len DEC_LEN sample_rate SAMPLE_RATE, sr SAMPLE_RATE speed SPEED language {ZH,ZH_MIX_EN,JP,EN,KR,ES,SP,FR}, l {ZH,ZH_MIX_EN,JP,EN,KR,ES,SP,FR} ``` 示例: ```bash (venv llm) sipeed@rpi sipeed:~/Downloads/AIDemos/MeloTTS/python $ python melotts.py s \"Dig the well before you are thirsty.\" l EN [INFO] Available providers: ['AXCLRTExecutionProvider'] sentence: Dig the well before you are thirsty. sample_rate: 44100 encoder: ../encoder onnx/encoder en.onnx decoder: ../decoder ax650/decoder en.axmodel language: EN > Text split to sentences. Dig the well before you are thirsty. > split_sentences_into_pieces take 0.7653236389160156ms [INFO] Using provider: AXCLRTExecutionProvider [INFO] SOC Name: AX650N [INFO] VNPU type: VNPUType.DISABLED [INFO] Compiler version: 3.3 3251425d load models take 1990.5009269714355ms Sentence[0]: Dig the well before you are thirsty. Load language module take 11539.379358291626ms encoder run take 30.54ms Decode slice[0]: decoder run take 99.54ms Decode slice[1]: decoder run take 92.79ms Decode slice[2]: decoder run take 92.74ms Save to output.wav ``` ## AXCL 推理性能 测试一下 `axcl_run_model` （与原生系统内 ax_run_model 同样使用方法），推理 yolov5s 的性能与 Maix4 原生系统上的数据极度接近。（使用的板卡文件系统自带 yolov5s 模型为单核模型,\"type: 1 Core\", 实际满核性能为 x3） ```bash sipeed@rpi sipeed:~/Downloads/AIDemos/models $ axcl_run_model m yolov5s.axmodel Run AxModel: model: yolov5s.axmodel type: 1 Core vnpu: Disable warmup: 1 repeat: 1 batch: { auto: 1 } axclrt ver: 1.0.0 pulsar2 ver: 1.2 patch2 7e6b2b5f tool ver: 0.0.1 cmm size: 12730188 Bytes min 7.837 ms max 7.837 ms avg 7.837 ms ``` 其余常用模型的性能实测数据如下表： Model Input Size Batch 1 (IPS) Batch 8 (IPS) Inceptionv1 224 1073 2494 Inceptionv3 224 478 702 MobileNetv1 224 1508 4854 MobileNetv2 224 1366 5073 ResNet18 224 1066 2254 ResNet50 224 576 1045 SqueezeNet11 224 1560 5961 Swin T 224 342 507 ViT B/16 224 162 207 YOLOv5s 640 326 394 YOLOv6s 640 282 322 YOLOv8s 640 248 279 YOLOv9s 640 237 YOLOv10s 640 298 YOLOv11n 640 860 YOLOv11s 640 305 YOLOv11m 640 114 YOLOv11l 640 87 YOLOv11x 640 41 ## 已知问题 ### 不断电重启树莓派会导致 Maix4 HAT 无法再次挂载 > 注意： > 目前有一已知问题，因为当前板卡不能满足树莓派的启动过程中关于 pciex1 的复位时序，所以只有断电后再冷启动才能成功挂载 Maix4 HAT。而在挂载成功后若是保持不断电来重启树莓派，会导致下一次树莓派无法挂载 Maix4 HAT。因此每次都需要断电后再冷启动树莓派。 若是直接重启了树莓派，树莓派串口应会打印如下启动日志。其中第 18 行显示 `1000110000.pcie: link down`，表示 pcie 建立链接失败，显然此时未能成功挂载 Maix4 HAT。 ```bash 7.11 fs_open: 'armstub8 2712.bin' 7.15 Loading 'kernel_2712.img' to 0x00000000 offset 0x200000 7.33 Read kernel_2712.img bytes 9727677 hnd 0x3c43 9.93 PCI1 reset 9.03 PCI2 reset 9.13 set_reboot_order 0 9.13 set_reboot_arg1 0 9.14 USB OTG disconnect 9.56 MESS:00:00:09.256590:0: Starting OS 9256 ms 9.62 MESS:00:00:09.262115:0: 00000040: > 00000480 9.63 MESS:00:00:09.263966:0: 00000030: > 00100080 9.68 MESS:00:00:09.268679:0: 00000034: > 00100080 9.73 MESS:00:00:09.273392:0: 00000038: > 00100080 9.78 MESS:00:00:09.278105:0: 0000003c: > 00100080 NOTICE: BL31: v2.6(release):v2.6 240 gfc45bc492 NOTICE: BL31: Built : 12:55:13, Dec 4 2024 [ 0.695249] brcm pcie 1000110000.pcie: link down Debian GNU/Linux 12 rpi sipeed ttyAMA10 My IP address is 192.168.10.176 fdae:b0ae:ebf1:0:b270:135e:b646:70c3 rpi sipeed login: ``` > 当然现有一更简便方法。我们把树莓派的一个 GPIO 连到了 Maix4 HAT 的复位引脚上，因此若需要保持不断电也能重启树莓派并能成功挂载。需要在每次重启前先执行命令 `gpioset gpiochip0 28 0` Maix4 HAT 进入复位状态，再正常执行树莓派重启命令即可再次正常挂载。 ## AXCL 更多资料 **其余详细信息可查看 [axcl官方文档](https://axcl docs.readthedocs.io)。** **另有 [树莓派5 AXCL专项页面](https://axcl pi5 examples cn.readthedocs.io)。** 可于 [文中](../m4c/axmodel deploy.html) 介绍到的大模型仓库下载各种已被支持的大模型，并在树莓派上部署运行。"},"/hardware/zh/logic_analyzer/slogic16u3/User_Guide.html":{"title":"Slogic16U3 用户指南","content":"# Slogic16U3 用户指南 👷‍♂️ 本指南正在积极撰写中 — 感谢您的耐心！ ## 修订历史 日期 版本 作者 描述 2024 09 23 v0.1 Sipeed 团队 初始草稿 ## 目录 1. [概述](#概述) 2. [规格](#规格) 3. [硬件连接](#硬件连接) 4. [软件安装](#软件安装) 5. [软件使用](#软件使用) 6. [从源码构建软件](#从源码构建软件) 7. [固件更新](#固件更新) 8. [常见问题](#常见问题) ## 概述 Slogic16U3 是一款用于数字信号调试与分析的高性能逻辑分析仪。 <div style \"display: flex; flex wrap: wrap; gap: 10px; width: 100%;\"> <img src \"../../../en/logic_analyzer/slogic16u3/assets/DCIM/DSC07963.JPG\" style \"width: 100%;\"> <img src \"../../../en/logic_analyzer/slogic16u3/assets/DCIM/DSC07962.JPG\" style \"width: calc(50% 5px);\"> <img src \"../../../en/logic_analyzer/slogic16u3/assets/DCIM/DSC07961.JPG\" style \"width: calc(50% 5px);\"> </div> ## 规格 **通道数:** 16 **最大采样率:** 典型 800 MHz @ 4CH **存储深度:** 无限 **接口:** USB 3.2 Gen1 (5 Gbps) **供电:** USB 供电 (5V 900mA) **尺寸:** 150 × 100 × 30 mm ## 快速开始 参见[基础使用](basic_operation.html) ## 硬件配置 USB接口：**USB C 3.2 Gen1** 信号输入：2x12P排母，16 ch Data + 2 ch VCC + 2 ch reserved **指示灯:** 多色（见[基础使用](basic_operation.md#指示灯颜色与功能)） **附件:** 标准 ***2x6P*** **公对母杜邦线** x2，或 ***2x4P*** **同轴线模组** x2 逻辑分析仪测试夹 x16 0.5m **A+C to C** USB3 数据线 x1 不锈钢取卡针 x1 说明卡片 x1 拉链收纳包 x1 ## 软件 ### 支持的操作系统与测试平台 操作系统 / 平台 支持 示例平台 Windows (x86_64) 是 Ultra 5 125H Linux (x86_64) 是 Core i5+ 8225U Linux (aarch64) 是 RPI5 macOS (aarch64) 是 Apple Silicon M4 ### 支持的协议 支持多种协议，包括： AC '97、I²C、SPI、UART、CAN、JTAG、1 Wire、PWM、USB 等等。 *最新支持协议请参考软件内的解码器选择面板。* ### 安装 #### Windows 解压便携版并双击 `pulseview.exe` 启动。 ![](../../../en/logic_analyzer/slogic16u3/assets/Screenshots/Screenshot_2025 09 08_11 11 10.png) 若需启用调试模式，在终端运行： ```cmd pulseview debug.exe l5 ``` ![](../../../en/logic_analyzer/slogic16u3/assets/Screenshots/Screenshot_2025 09 23_11 09 53.png) #### Linux ```bash chmod +x Pulseview.appimage ./Pulseview.appimage # ./Pulseview.appimage l5 # 启用调试模式 ``` ![](../../../en/logic_analyzer/slogic16u3/assets/Screenshots/Screenshot_2025 09 08_11 24 12.png) ![](../../../en/logic_analyzer/slogic16u3/assets/Screenshots/Screenshot_2025 09 08_11 33 45.png) #### macOS 下载并打开 `Pulseview.dmg` 安装。 ![](../../../en/logic_analyzer/slogic16u3/assets/Screenshots/Screenshot_2025 09 18_11 11 57.png) ![](../../../en/logic_analyzer/slogic16u3/assets/Screenshots/Screenshot_2025 09 18_11 15 40.png) **相关链接：** 淘宝、AliExpress、MaixHub 邮箱: support@sipeed.com ## 软件使用 界面和工作流程与 DSView 类似。 配置通道、采样率、采样点/时间和其他参数后进行采集。 使用软件触发、采集、浏览、测量、协议解码与文件管理。 ### 更改采样深度 采样深度决定每次采集的数据点数量。 可在主控面板中设置采样深度，通常以数据点数表示。 更高的采样深度能够捕获更长或更详细的信号，但需要更多内存并可能增加传输时间。 如果只需捕获短事件，可减小采样深度以加快操作。 在开始采集前调整采样深度以满足分析需求。 **如果磁盘空间充足，采样深度可以视为无限；数据可以直接流式写入存储。** ![unlimited sample depth](../../../en/logic_analyzer/slogic16u3/assets/Screenshots/Screenshot_2025 09 25_16 53 25.png) ### 更改采样率 **最大采样率：** 800 MHz（受激活通道数影响） **16 通道：** 最高 200 MHz **8 通道：** 最高 400 MHz **4 通道：** 最高 800 MHz 在主控面板中设置采样率。 若无法使用更高速率，请禁用未使用的通道。 ![200MHz max on 16ch](../../../en/logic_analyzer/slogic16u3/assets/Screenshots/Screenshot_2025 09 25_14 30 46.png) ![400MHz max on 8ch](../../../en/logic_analyzer/slogic16u3/assets/Screenshots/Screenshot_2025 09 25_14 31 04.png) ![800MHz max on 4ch](../../../en/logic_analyzer/slogic16u3/assets/Screenshots/Screenshot_2025 09 25_14 31 20.png) ### 选择激活通道 可在 **16**, **8**, 或 **4** 通道配置间切换。 在配置区域启用/禁用通道。 减少激活通道数可提高最大采样率。 ![entry of channel selection](../../../en/logic_analyzer/slogic16u3/assets/Screenshots/Screenshot_2025 09 25_14 34 42.png) ![Channel count(pulseview modified)](../../../en/logic_analyzer/slogic16u3/assets/Screenshots/Screenshot_2025 09 25_14 35 03.png) ![Buffer size(default)](../../../en/logic_analyzer/slogic16u3/assets/Screenshots/Screenshot_2025 09 25_14 42 35.png) ### 调整电压阈值 阈值可在 **0.1V 到 6.0V** 之间以 **0.1V 步进** 设置。 在通道/设备配置面板中调整。 按照逻辑电平选择阈值（例如 3.3V CMOS 约设为 1.0V）。 在采集前应用更改。 ![entry of volt threshold selection](../../../en/logic_analyzer/slogic16u3/assets/Screenshots/Screenshot_2025 09 25_14 34 42.png) ![6V max](../../../en/logic_analyzer/slogic16u3/assets/Screenshots/Screenshot_2025 09 25_14 45 40.png) 提示：对于 3.3V CMOS/TTL，阈值可设为约 1.0V（大约 3.3V 的 30%）。 ### 边沿触发 配置边沿触发以在特定信号跳变时开始采集。 在触发面板中选择通道和触发类型（上升沿、下降沿或双边沿）。 ![](../../../en/logic_analyzer/slogic16u3/assets/Screenshots/Screenshot_2025 09 25_15 05 54.png) ![](../../../en/logic_analyzer/slogic16u3/assets/Screenshots/Screenshot_2025 09 25_15 06 48.png) ## 从源码构建软件 软件为开源。 [Sipeed 的 libsigrok GitHub 仓库](https://github.com/sipeed/libsigrok/tree/slogic dev) **推荐：** 使用 [sigrok util](https://github.com/sigrokproject/sigrok util) 的构建脚本，获得跨平台的简单体验。 **步骤：** 1. 克隆 sigrok util 并按照其 README 安装依赖。 2. 编辑构建脚本以使用 Sipeed 的 libsigrok fork： ```bash $GIT_CLONE https://github.com/sipeed/libsigrok b slogic dev ``` 3. （可选）添加选项以加速构建并减小体积： ``` disable all drivers enable sipeed slogic analyzer disable bindings enable cxx ``` 4. 运行适合目标平台的构建脚本（例如 `./sigrok cross linux`、`./sigrok cross mingw`、`./sigrok cross macosx`）。 更多高级或手动构建请参考 upstream sigrok 与 PulseView 文档。 ## 固件更新 固件更新通过 Python / PyQt GUI 工具提供。 [固件更新工具仓库](https://github.com/sipeed/slogic16u3 tools) **更新步骤：** 1. 克隆或下载仓库： ```bash git clone https://github.com/sipeed/slogic16u3 tools.git ``` 2. 安装依赖并设置环境： ```bash source .venv/bin/activate ``` 3. 进入 `pt` 目录： ```bash cd pt ``` 4. 运行 GUI 工具： ```bash python src/gui.py ``` 5. 按下设备上的 **mode** 按钮。GUI 应显示 \"SLogic16U3 OTA\"。 6. 在 GUI 中选择固件文件。 7. 点击 **OTA** 开始更新。 8. 等待完成并按界面指引操作。 > **注意：** 将很快发布该更新工具的二进制版本。 ![](../../../en/logic_analyzer/slogic16u3/assets/Screenshots/Screenshot_2025 09 25_15 34 06.png) ## 常见问题 ### 在 Linux 中为什么找不到 SLogic16U3 设备？ 普通用户默认无法访问 USB 设备。 使用 sudo 运行 Pulseview： ```bash sudo ./Pulseview.appimage ``` 或者设置 udev 规则（见下文）。 ### 如何为 Linux 设置 udev 规则？ 创建新的 udev 规则文件： ```bash sudo tee /etc/udev/rules.d/60 sipeed.rules <<EOF SUBSYSTEM! \"usbusb_device\", GOTO \"sipeed_rules_end\" ACTION! \"add\", GOTO \"sipeed_rules_end\" ATTRS{idVendor} \"359f\", MODE \"0666\", GROUP \"plug_dev\", TAG+ \"uaccess\" ENV{ID_MM_DEVICE_IGNORE} \"1\" LABEL \"sipeed_rules_end\" EOF ``` 重新加载 udev 规则并触发： ```bash sudo udevadm control reload sudo udevadm trigger ``` 拔掉并重新连接设备。 现在可以以普通用户身份运行 Pulseview。 ### 为什么不能使用更高采样率？只显示 200M。 最大采样率取决于激活通道数量和 USB 带宽。 Slogic16U3 的 USB 3.0 提供约 ~400MB/s 带宽。 要使用更高速率（400M/800M），请禁用未使用的通道。"},"/hardware/zh/logic_analyzer/slogic16u3/FAQ.html":{"title":"常见问题","content":"# 常见问题 ## 为什么找不到 SLogic16U3 设备？ ![No SLogic Device](../../../en/logic_analyzer/slogic16u3/assets/Screenshots/Screenshot_2025 09 26_11 40 49.png) 最常见的原因是 PulseView 在连接 SLogic16U3 之前就已启动。如果软件在启动时找不到设备，它可能不会自动再次探测设备。 解决办法： 1. 要自动检测，请先连接 SLogic16U3，然后再启动 PulseView。软件在启动时应能自动检测到设备。 2. 如果你是在启动软件后才插入设备，请在插入设备后手动打开“连接到设备”（或“设备设置”）对话框： 打开 “Connect to Device”。 选择适用于 SLogic16U3 的驱动/后端。 点击 “Scan” 来发现已连接的设备。 从列表中选择 SLogic 设备并点击 “OK”。 UI 会返回到捕获/主页面，设备将可用。 ![SLogic Found](../../../en/logic_analyzer/slogic16u3/assets/Screenshots/Screenshot_2025 09 26_11 41 22.png) 另外，在 Linux 上普通用户默认无法访问 USB 设备，因为权限受限。 ![Nothing Found](../../../en/logic_analyzer/slogic16u3/assets/Screenshots/Screenshot_2025 09 26_11 41 03.png) 可选两种方法之一： 使用 root 权限运行 PulseView（快速测试）: ```bash sudo ./Pulseview.appimage ``` 设置 udev 规则以便普通用户可以访问设备（推荐）。关于 udev 规则和安装步骤，请参见下文“如何为 Linux 设置 udev 规则？”部分。 ## 如何为 Linux 设置 udev 规则？ 创建一个新的 udev 规则文件： ```bash sudo tee /etc/udev/rules.d/60 sipeed.rules <<EOF SUBSYSTEM! \"usbusb_device\", GOTO \"sipeed_rules_end\" ACTION! \"add\", GOTO \"sipeed_rules_end\" ATTRS{idVendor} \"359f\", MODE \"0666\", GROUP \"plugdev\", TAG+ \"uaccess\" ENV{ID_MM_DEVICE_IGNORE} \"1\" LABEL \"sipeed_rules_end\" EOF ``` Arch 系统用户请使用 `GROUP \"uucp\"` 做替代。 重新加载 udev 规则并触发： ```bash sudo udevadm control reload sudo udevadm trigger ``` 拔掉并重新连接设备。 现在你可以以普通用户身份运行 PulseView。 ## 为什么无法使用更高的采样率？只显示 200M。 最大采样率取决于活动通道数和 USB 带宽。 SLogic16U3 的 USB 3.0 提供大约 ~400MB/s 的带宽。 要使用更高的采样率（例如 400M/800M），请禁用未使用的通道。 ## 装置锁定在DFU模式，无法切换至SLogic模式 这通常意味着SLogic固件损坏，可能是由于OTA失败导致。 解决方法：重新OTA正确的固件。 ## 无法切换至DFU模式，提示\"unknown usb device\" 这意味着USB枚举失败，可能是由于USB线缆过长/质量不好导致。 解决方法：尝试使用更短/质量好的USB线缆重试。"},"/hardware/zh/logic_analyzer/slogic16u3/Introduction.html":{"title":"简介","content":"# 简介 ## 简介 SLogic16U3 是新一代 USB3 逻辑分析仪。它在紧凑的 40×40×10 mm 超小尺寸外壳中通过 5Gbps USB3 接口实现高采样率： 800M@4CH, 400M@8CH, 200M@16CH. 支持0 ~ 10V信号输入，可配置0~6V的电压触发阈值 和 软件触发，且仅需￥369起！ ![SLogic16U3 产品](../../../en/logic_analyzer/slogic16u3/assets/DCIM/SLogic16U3.png) ## 特点与规格 属性 SLogic Combo8 SLogic16U3 SLogic32U3 型号 SLogic Combo8 SLogic16U3 SLogic32U3 USB 类型 USB2.0 USB3.0 USB3.2 Gen2 最大采样率 80M 800M 1500M 最大通道数 8 16 32 最大带宽 0.3Gbps 3.2Gbps 6.4Gbps Typical Comb. (stream, unlimited) 80M@4CH, 40M@8CH 800M@4CH, 400M@8CH, 200M@16CH 1500M@4CH, 800M@8CH, 400M@16CH, 200M@32CH 兼容 Sigrok Y Y Y 可调阈值 N Y Y 外壳材质 塑料 铝合金 铝合金 额外特性 DAP Link, CK Link, 4 UART Extend ADC > Oscilloscope 尺寸 20x40x10mm 40x40x10mm 50x50x10mm 价格 ￥69 ￥369 ~￥999 ## 产品图 尺寸：40x40x10mm 视图：顶/前/后 <div style \"display: flex; flex wrap: wrap; gap: 10px; width: 100%;\"> <img src \"../../../en/logic_analyzer/slogic16u3/assets/DCIM/DSC07962.png\" style \"width: 32%;\"> <img src \"../../../en/logic_analyzer/slogic16u3/assets/DCIM/DSC07963.png\" style \"width: 32%;\"> <img src \"../../../en/logic_analyzer/slogic16u3/assets/DCIM/DSC07961.png\" style \"width: 32%;\"> <img src \"../../../en/logic_analyzer/slogic16u3/assets/DCIM/20250927 155815.png\" style \"width: 32%;\"> <img src \"../../../en/logic_analyzer/slogic16u3/assets/DCIM/20250927 155818.png\" style \"width: 32%;\"> <img src \"../../../en/logic_analyzer/slogic16u3/assets/DCIM/20250927 155808.png\" style \"width: 32%;\"> </div> ## 软件安装 ### 支持的操作系统 ![](../../../en/logic_analyzer/slogic16u3/assets/Screenshots/supported platforms.png) Windows 10/11 (x86_64) 原生exe程序受限于windows USB驱动问题，目前仅能达到390+MB/s, 无法跑满400MB/s的目标带宽，只能降速到400M@4CH,200M@8CH,100M@16CH的指标 如果你使用windows电脑，且想跑满400MB/s的带宽，可安装linux虚拟机实现满速采集 <details class \"indent\"> <summary><b>另 Linux 虚拟机可满速运行</b></summary> <img src \"../../../en/logic_analyzer/slogic16u3/assets/Screenshots/Screenshot_2025 09 27_11 05 12.png\"> </details> Linux (x86_64) **必须：额外配置解决权限问题：**[如何为 Linux 设置 udev 规则？](./FAQ.html#如何为 Linux 设置 udev 规则？) macOS (Apple Silicon M4) ### 下载 软件下载: https://dl.sipeed.com/shareURL/SLogic 源代码（slogic dev 分支）: https://github.com/sipeed/libsigrok/tree/slogic dev #### Windows 解压便携版压缩包并双击 `pulseview.exe` 启动。 若需启用调试模式，在终端运行： ```cmd pulseview debug.exe l5 ``` ![](../../../en/logic_analyzer/slogic16u3/assets/Screenshots/Screenshot_2025 09 23_11 09 53.png) #### Linux ```bash chmod +x Pulseview.appimage ./Pulseview.appimage # ./Pulseview.appimage l5 # 启用调试模式 ``` ![](../../../en/logic_analyzer/slogic16u3/assets/Screenshots/Screenshot_2025 09 26_19 12 07.png) #### macOS 下载并打开 `Pulseview.dmg` 即可直接运行。 ![](../../../en/logic_analyzer/slogic16u3/assets/Screenshots/Screenshot_2025 09 18_11 11 57.png) ## 相关链接 购买（淘宝）：https://item.taobao.com/item.htm?id 994512536278 购买（AliExpress）：https://www.aliexpress.com/item/1005010321792670.html MaixHub: [maixhub.com](https://maixhub.com/discussion/slogic) 支持邮箱：support@sipeed.com GitHub（libsigrok slogic dev）：https://github.com/sipeed/libsigrok/tree/slogic dev Sipeed GitHub: https://github.com/sipeed GitHub（SLogic16U3 Tools）：https://github.com/sipeed/slogic16u3 tools 社区（Discord）：[discord.gg/V4sAZ9XWpN](https://discord.gg/V4sAZ9XWpN)"},"/hardware/zh/logic_analyzer/slogic16u3/Hardware_Specification.html":{"title":"硬件操作","content":" title: 硬件操作 keywords: LogicAnalyzer, SLogic, basic usage, hardware update: date: 2025 09 25 version: v0.1 author: Serika content: Release docs 此章节介绍 **SLogic16 U3** 硬件相关的使用与操作。 ## 硬件概览 ### 配件一览 ![unboxing_0](./assets/DCIM/unboxing_0.png) 一套完整的硬件包括 **SLoigc16 U3 主机** 和 **包装内附件**，如下所示： <!DOCTYPE html> <html lang \"zh CN\"> <head> <meta charset \"UTF 8\"> <title>CSS Indentation</title> <style> .indent { margin left: 0ch; /* wideof 0 characters */ } </style> </head> <body> <details class \"indent\"> <summary><font color \"#4F84FF\"><b>SLoigc16 U3 主机</b> x1 </font></summary> <img src \"./assets/DCIM/15k_la_photo.png\"> </details> </body> </html> **包装内附件:** （注：杜邦线和同轴线为二选一） <!DOCTYPE html> <html lang \"zh CN\"> <head> <meta charset \"UTF 8\"> <title>CSS Indentation</title> <style> .indent { margin left: 0ch; /* wideof 0 characters */ } </style> </head> <body> <details class \"indent\"> <summary><font color \"#4F84FF\"><b>2x6P 公对母杜邦线</b> x2 </font></summary> <img src \"./assets/DCIM/normal_cable.jpg\"> </details> </body> </html> <!DOCTYPE html> <html lang \"zh CN\"> <head> <meta charset \"UTF 8\"> <title>CSS Indentation</title> <style> .indent { margin left: 0ch; /* wideof 0 characters */ } </style> </head> <body> <details class \"indent\"> <summary><font color \"#4F84FF\"><b>2x4P 同轴线模组</b> x2 </font></summary> <img src \"./assets/DCIM/coaxial_cable.jpg\"> </details> </body> </html> <!DOCTYPE html> <html lang \"zh CN\"> <head> <meta charset \"UTF 8\"> <title>CSS Indentation</title> <style> .indent { margin left: 0ch; /* wideof 0 characters */ } </style> </head> <body> <details class \"indent\"> <summary><font color \"#4F84FF\"><b>逻辑分析仪测试夹</b> x16 </font></summary> <img src \"./assets/DCIM/testing_hook.jpg\"> </details> </body> </html> <!DOCTYPE html> <html lang \"zh CN\"> <head> <meta charset \"UTF 8\"> <title>CSS Indentation</title> <style> .indent { margin left: 0ch; /* wideof 0 characters */ } </style> </head> <body> <details class \"indent\"> <summary><font color \"#4F84FF\"><b>0.5m A+C to C USB3 数据线</b> x1 </font></summary> <img src \"./assets/DCIM/usb3_cable.jpg\"> </details> </body> </html> <!DOCTYPE html> <html lang \"zh CN\"> <head> <meta charset \"UTF 8\"> <title>CSS Indentation</title> <style> .indent { margin left: 0ch; /* wideof 0 characters */ } </style> </head> <body> <details class \"indent\"> <summary><font color \"#4F84FF\"><b>不锈钢SIM卡针</b> x1 </font></summary> <img src \"./assets/DCIM/small_pin.jpg\"> </details> </body> </html> <!DOCTYPE html> <html lang \"zh CN\"> <head> <meta charset \"UTF 8\"> <title>CSS Indentation</title> <style> .indent { margin left: 0ch; /* wideof 0 characters */ } </style> </head> <body> <details class \"indent\"> <summary><font color \"#4F84FF\"><b>说明卡片</b> x1 </font></summary> <img src \"./assets/DCIM/readme_card.jpg\"> </details> </body> </html> <!DOCTYPE html> <html lang \"zh CN\"> <head> <meta charset \"UTF 8\"> <title>CSS Indentation</title> <style> .indent { margin left: 0ch; /* wideof 0 characters */ } </style> </head> <body> <details class \"indent\"> <summary><font color \"#4F84FF\"><b>拉链收纳包</b> x1 </font></summary> <img src \"./assets/DCIM/storage_bag.jpg\"> </details> </body> </html> > 各批次配件的外观可能存在细微差异，最终样式请以实物为准。 ### 连接方式 <!DOCTYPE html> <html lang \"zh CN\"> <head> <meta charset \"UTF 8\"> <title>CSS Indentation</title> <style> .indent { margin left: 0ch; /* wideof 0 characters */ } </style> </head> <body> <details class \"indent\"> <summary><font color \"#4F84FF\">点击此处查看SLoigc16 U3的硬件连接示意图 </font></summary> <img src \"./assets/MISC/la_topview.jpg\"> </details> <br> </body> </html> **同轴线子板**/**杜邦线组** 都具有方向性，其插入方向见上图，线上的三角标记 **▴** 对准外壳上的三角标记 **▾** 为正。 **同轴线** 的远端有 **2** 个接线端子。其中白色的端子和信号源连接，黑色的端子和GND连接。 **杜邦线** 每组只有 **2** 个单独的GND，在其连接线上的三角标记 **▴** 和外壳对准插入时，黑色的线束就是GND，红色为VCC。 #### 逻辑分析仪背面 ![slogic16_u3_rear](./assets/MISC/la_rearview.jpg) 逻辑分析仪的背面是 **2x12P** 排母，其间距是2.54mm。排母的引脚定义见上图（逻辑分析仪后视图）。 其中数字编号 **0 15** 为采样通道的编号，对应上位机中的通道编号，共计16通道。 **G** 代表 **GND**，使用时请连接被采样装置和逻辑分析仪的GND，共计4通道。 **VCC** 代表电源输出，其输出能力为 **3.3V @500mA**，共计2通道（2通道共享电流输出能力）。 **CK** 代表预留的采样时钟输入/触发输出通道，其功能暂未实现，共计2通道。 #### 逻辑分析仪正面 ![slogic16_u3_rear](./assets/MISC/la_frontview.jpg) 上图为逻辑分析仪正视图，从左至右依次为： **USB C** 接口标准是3.2 Gen1 (5Gbps)，使用逻辑分析仪功能需要使用有对应能力（USB3.0）的线缆。 **MODE** 小孔中有一个隐藏式按键，可以用SIM卡针捅入后按下，其功能详见[MODE按键](#MODE按键)章节描述。 **ACT** 是 **状态指示灯**，具体状态见下方[ACT指示灯](#ACT指示灯)章节描述。 ### 开始使用 首先，连接 **PC USB3** → **USB A/C to USB C** → **SLogic** → **杜邦线**/**同轴线子板** <!DOCTYPE html> <html lang \"zh CN\"> <head> <meta charset \"UTF 8\"> <title>CSS Indentation</title> <style> .indent { margin left: 0ch; /* wideof 0 characters */ } </style> </head> <body> <details class \"indent\"> <summary><font color \"#4F84FF\">点击此处查看SLoigc16 U3的硬件连接图 </font></summary> <img src \"./assets/DCIM/SLogic16U3.jpg\"> </details> <br> </body> </html> > 目前SLogic16仅有 **USB3** 模式支持，使用附赠的 **USB A/C to USB C** 线缆即可兼容。 将目标设备的待测信号点通过**杜邦线**/**同轴线**连接至 **SLogic** 任意空闲CH数字端口，并确保待测设备的GND与SLogic的GND相连接。 > 注意，在信号源奈奎斯特频率大于或等于 50 MHz 的情况下，推荐使用同轴线进行采样，以获得更佳的稳定性。 可以根据实际情况决定是否使用 **逻辑分析仪测试夹** 连接至待测信号点。 > 为了提升采样稳定性，SLogic 的 GND 线应尽量靠近待测点，即便仅缩短 **1 mm** 也可能带来改善。在使用同轴线采样时，建议您在连接每个采样信号 **CH** 的同时，也连接对应的 **GND**。 最后启动 [**plusview**](./Software_User_Guide) 开始采集操作。 关于软件的安装和相关操作，可以参考[这里](./Introduction#软件安装)。 ## ACT指示灯 **ACT指示灯** 位于逻辑分析仪正面，靠近机身外侧。 ![slogic16_u3_rear](./assets/MISC/la_frontview_act.jpg) ### 颜色&功能 指示灯是一颗3色RGB，每一种颜色代表一种状态，不同状态组合指示当前设备状态 **颜色** <span style \"color:blue\">蓝灯</span> <span style \"color:green\">绿灯</span> <span style \"color:red\">红灯</span> **功能** 电源 USB LINK 指示 运行状态指示 下表是不同颜色对应的正常运行时候的装置状态 **状态** **颜色** <b>备注</b> **正常连接** <span style \"color:cyan\">青色</span> <span style \"color:blue\">蓝</span> + <span style \"color:green\">绿</span> **数据传输** <span style \"color:cyan\">青色</span> + <span style \"color:red\">红色快闪</span> <span style \"color:blue\">蓝</span> + <span style \"color:green\">绿</span> + <span style \"color:red\">红快闪</span> **DFU模式** <span style \"color:cyan\">青色</span> + <span style \"color:red\">红色慢闪</span> <span style \"color:blue\">蓝</span> + <span style \"color:green\">绿</span> + <span style \"color:red\">红慢闪</span> 下表的指示灯颜色对应的装置的异常状态 **状态** **颜色** **备注** **USB连接失败** <span style \"color:blue\">蓝</span> <span style \"color:blue\">只亮蓝灯</span> **Flash加载异常** <span style \"color:red\">红</span> <span style \"color:red\">只亮红灯</span> 除表中已列举的状态外，其余状态（如只亮绿灯/三灯常亮）皆属于未定义的状态 如果出现未定义的状态，请尝试重新拔插USB。若无法解决则应高度怀疑硬件损坏。 > ⚠注意：任何时候<span style \"color:green\">绿灯</span>如果熄灭都意味着USB连接出现问题，请尝试重新连接以解决问题。此时<span style \"color:red\">红灯</span>的状态没有意义。 ### 异常状态 **检查清单**：<span style \"color:blue\"><b>只亮蓝灯</b></span> 使用的USB线缆不支持**USB3**（常见于手机充电线） PC的USB接口不支持**USB3** 连接到了Desktop PC 机箱的前面板的USB 连接到了不兼容的**USB hub**（请尽量保证SLogic直连PC USB） 连接到了供电能力不足的**USB端口** 连接线太长（请尽量使用1m以内的连接线） **检查清单**：<span style \"color:red\"><b>只亮红灯</b></span> 使用的USB线缆质量太差，线上压降过大 PC的USB接口故障：可能由于保险丝老化导致供电能力不足 SLogic硬件损坏，请保持装置断电并联络售后 ## MODE按键 **MODE按键** 位于逻辑分析仪正面，在 **USB C 连接器** 和 **ACT指示灯** 之间。这是一个隐藏式按键，需要使用SIM卡针品插入外壳才能按动。 ![slogic16_u3_rear](./assets/MISC/la_frontview_mode.jpg) 装置上电后默认功能是 **逻辑分析仪**，正常情况下[ACT指示灯](#ACT指示灯)显示青色。 同时出现一个新的 **USB3** 装置：**SLogic16 U3**（逻辑分析仪） <! ![slogic16_u3](./assets/slogic_u3.png) > **按下MODE按键**切换功能，切换成功后可以看到**指示灯变化：** 红灯慢闪。 同时出现一个新的 **USB2** 装置：**SLogic DFU** （升级模式） > **SLogic** 模式使用 **USB3** 模式，而 **DFU** 模式使用 **USB2** 模式。 <! ![slogic16_u2](./assets/slogic_u2.png) > 再次按下 **MODE** 则切换回 **SLogic16 U3**，重复按下 **MODE** 再进入**SLogic DFU**，如此往复循环在两个模式中来回切换。 > Windows环境打开设备管理器或使用 *USB treeview*，Linux/macOS环境使用 *lsusb* 命令，可以找到 \"*SLogic16 U3/SLogic DFU*\" 装置 ## 更新固件 首先，[进入DFU MODE](#MODE按键)：上电后按下 **MODE按键**，等待<span style \"color:red\">红灯慢闪</span> 。 确认\"*SLogic DFU*\" 设备出现后，使用 **DFU工具** 进行更新。 > Windows环境打开设备管理器或使用 *USB treeview*，Linux/macOS环境使用 *lsusb* 命令，可以找到 \"*SLogic DFU*\" 装置 > 理论上，OTA操作只会更新SLogic固件，无法影响 **DFU** 功能。因此即使OTA失败也不要紧，装置会锁定在 **DFU** 模式，直到SLogic固件更新成功。 固件更新通过 命令行 工具提供。 [固件更新工具仓库](https://github.com/sipeed/slogic16u3 tools/tree/main/ota/src/dist) [最新固件下载地址](https://dl.sipeed.com/shareURL/SLogic/SLogic16U3/4_Firmware) ### **更新步骤：** 1. 下载更新工具。 2. 按下设备上的 **mode** 按钮。内核日志(Linux)或设备管理器(Win)应显示名为 \"SLogic DFU\" 的新设备。 3. 下载固件文件。 4. 打开命令行输入 `spi_flash_xxx 固件路径` 开始更新。 5. 等待完成并查看更新结果。 ![](../../../en/logic_analyzer/slogic16u3/assets/Screenshots/Screenshot_2025 12 25_16 28.png) ![](../../../en/logic_analyzer/slogic16u3/assets/Screenshots/Screenshot_2025 12 25_16 18.png) ## 安全 & 注意事項 **SLogic** 的 ***VCC*** 是电源输出，两个 ***VCC*** 端口共享同一路电源。电源供电能力为：***3.3V @ 500mA MAX*** **切勿** 将 **SLogic** 的 ***VCC*** 直接和 ***GND*** 短接，以免发生短路过流 **SLogic** 具备过流保护设计。但为了确保使用安全，我们仍建议您尽量避免发生短路情况，因为主机侧 **USB** 端口的过流保护能力可能存在差异 当 **SLogic** 与市电供电的计算机配合使用时，其接地端会与计算机接地端相连。此时，为了保护设备与主机安全，请仅将探头接地端连接到等电位的接地点，**切勿**连接至热地或电位不一致的点"},"/hardware/zh/logic_analyzer/slogic16u3/Software_User_Guide.html":{"title":"SLogic16U3 — 软件使用指南","content":"# SLogic16U3 — 软件使用指南 本指南说明如何在捕获应用中使用 SLogic16U3。覆盖设备连接与检测、跨平台的用户界面、基础与高级采样设置、捕获流程、浏览与测量工具、协议解码以及文件操作。 ## 连接 SLogic 最佳做法：在主机上将 SLogic16U3 连接到 USB 3.0 接口，然后再启动捕获应用，这样软件可以在启动时自动检测到设备。 如果应用已在运行： 将 SLogic 插入 USB 3.0 主机端口（避免使用无电源的集线器）。 打开应用菜单，选择 “Connect to Device” 端选择对话框。 选择 SLogic 驱动/后端。 点击 “Scan” 或 “Refresh”。 从发现的设备列表中选择 SLogic 设备，点击 “OK”。 故障排查清单： 尝试更换 USB 数据线或使用不同的主机端口。 确认设备电源/LED 指示正常。 拔插设备后重新打开连接对话框或重启应用。 在 Linux 上检查权限（可用 sudo 进行快速测试或安装 udev 规则；参见 FAQ）。 参见: [Why can't I find the SLogic16U3 device?](./FAQ.html#为什么找不到 SLogic16U3 设备？) ![](../../../en/logic_analyzer/slogic16u3/assets/Screenshots/SLogic_Connect_1.png) ## 用户界面 ### Windows 菜单、对话框和文件对话框遵循 Windows 约定。 ![](../../../en/logic_analyzer/slogic16u3/assets/Screenshots/Screenshot_2025 09 23_11 09 53.png) ### Linux 布局与其他平台相似。 注意：普通 Linux 用户可能没有访问 USB 设备的权限。快速测试可使用 sudo 运行应用；日常使用请安装 udev 规则（参见 FAQ）。 在终端运行 `AppImage l5` 可以在故障排查时显示有用日志。 ![](../../../en/logic_analyzer/slogic16u3/assets/Screenshots/Screenshot_2025 09 26_16 25 08.png) ### macOS 菜单位于系统菜单栏；对话框与 macOS UI 约定集成。 如果 macOS 阻止访问，请打开 系统偏好设置 → 安全性与隐私 并为应用授予权限。 优先使用主板直连端口或有电源的 USB3 集线器。 ![](../../../en/logic_analyzer/slogic16u3/assets/Screenshots/Flameshot_2025 09 26_16 13 57.png) ## 基本采样模式与配置 在采集之前，配置以下核心设置： 通道使能：仅启用所需通道以减少带宽占用并提高采样率余量。 电压阈值：根据被测设备（DUT）的逻辑电平设置。 采样率：选择预设；允许的采样率取决于启用通道数和 USB 带宽。 采样深度 / 捕获长度：选择捕获样点数。 ### 配置（混合设置） 推荐的快速工作流程： 1. 启用所需通道（按需 16/8/4）。 2. 在支持时设置电压阈值。 3. 选择与启用通道兼容的采样率预设。 4. 选择采样深度。 5. 配置触发或直接开始采集。 提示： 减少启用通道可提高可达采样率。 对于长时间捕获，保存/导出前请确认磁盘空间。 ![](../../../en/logic_analyzer/slogic16u3/assets/Screenshots/Flameshot_2025 09 26_14 49 26.png) ### 电压阈值 选择与 DUT 匹配的阈值： 例如 ~1.6 V 适用于很多低电压系统（如 3.3 V 或 5 V 逻辑）。 最高可达 6.0 V 用于更高电压信号——先确认硬件限制。 不确定时，先用万用表或示波器测量信号再连接。 ![](../../../en/logic_analyzer/slogic16u3/assets/Screenshots/Flameshot_2025 09 26_15 43 37.png) ![](../../../en/logic_analyzer/slogic16u3/assets/Screenshots/Flameshot_2025 09 26_15 41 50.png) ### 通道 / 采样率预设 随着启用通道增多，可用采样率会减少（受 USB 吞吐量限制）。 使用预设列表在标准模式间切换（16ch / 8ch / 4ch）。 需要更高时间分辨率时，减少活动通道并提高采样率。 ![](../../../en/logic_analyzer/slogic16u3/assets/Screenshots/Flameshot_2025 09 26_15 25 09.png) ![](../../../en/logic_analyzer/slogic16u3/assets/Screenshots/Flameshot_2025 09 26_15 26 59.png) ![](../../../en/logic_analyzer/slogic16u3/assets/Screenshots/Flameshot_2025 09 26_15 27 57.png) ### 采样深度 / 捕获长度 选择采样深度（点数）或捕获时间。采样率 × 深度决定内存和存储使用。 ![](../../../en/logic_analyzer/slogic16u3/assets/Screenshots/Flameshot_2025 09 26_15 34 23.png) ## 高级：触发配置 通常支持的触发类型包括： 单通道的边沿触发（上升/下降）。 电平触发（信号在阈值上/下保持一段时间）。 跨多个通道的组合触发。 设置基本边沿触发的方法： 1. 打开触发设置。 2. 选择通道并选择 Rising（上升）或 Falling（下降）等。 3. 如需复合触发，可添加额外通道条件。 ![](../../../en/logic_analyzer/slogic16u3/assets/Screenshots/Screenshot_2025 09 26_15 56 13.png) ![](../../../en/logic_analyzer/slogic16u3/assets/Screenshots/Screenshot_2025 09 26_15 59 12.png) ![](../../../en/logic_analyzer/slogic16u3/assets/Screenshots/Screenshot_2025 09 26_16 01 52.png) ## 捕获流程 ### 典型步骤 1. 连接设备并确认检测到。 2. 配置通道、电压阈值和采样率。 3. 设置采样深度和触发模式。 4. 启动捕获并等待完成。 5. 检查波形并使用解码器或测量工具。 捕获模式： 连续/流式：持续捕获直到停止；注意数据大小和内存管理。 如遇样点丢失： 降低采样率或减少启用通道。 使用专用 USB 3.0 端口并选用高质量 USB 数据线。 ![](../../../en/logic_analyzer/slogic16u3/assets/Screenshots/Screenshot_2025 09 26_15 52 49.png) ![](../../../en/logic_analyzer/slogic16u3/assets/Screenshots/Screenshot_2025 09 26_15 52 58.png) ### 使用触发时 在开始捕获前配置触发条件以确保事件被捕获到缓冲区中。 ![](../../../en/logic_analyzer/slogic16u3/assets/Screenshots/Screenshot_2025 09 26_15 59 12.png) ![](../../../en/logic_analyzer/slogic16u3/assets/Screenshots/Screenshot_2025 09 26_15 57 08.png) ## 浏览与标尺测量 导航与控制： 缩放：鼠标滚轮或上下按钮。 前后平移：拖动或按住 Shift + 滚动 或按住 Shift + 上下按钮。 垂直平移：按住 Ctrl + 滚动 或按住 Ctrl + 上下按钮。 ![](../../../en/logic_analyzer/slogic16u3/assets/Screenshots/Screenshot_2025 09 26_16 48 45.png) ![](../../../en/logic_analyzer/slogic16u3/assets/Screenshots/Screenshot_2025 09 26_16 48 50.png) ![](../../../en/logic_analyzer/slogic16u3/assets/Screenshots/Screenshot_2025 09 26_16 49 42.png) ![](../../../en/logic_analyzer/slogic16u3/assets/Screenshots/Screenshot_2025 09 26_16 49 18.png) 标尺： 添加时间标尺以测量间隔。放置两个标尺可计算时间差。 使用标尺测量来计算波特率、脉宽或事件间隔。 按住 Shift + 拖动以创建测量标尺。 ![](../../../en/logic_analyzer/slogic16u3/assets/Screenshots/Screenshot_2025 09 26_16 42 44.png) ## 协议解码 要解码总线： 1. 打开 Decoder 窗格。 2. 选择协议（I2C、SPI、UART、CAN、SDIO 等）。 3. 配置引脚、字节序（LSB/MSB）、时钟极性/相位及波特率/时钟速率。 4. 启用解码器；解码后的帧会标注在波形上并可点击查看详情。 ![](../../../en/logic_analyzer/slogic16u3/assets/Screenshots/Screenshot_2025 09 26_16 47 45.png) 提示： 正确映射探针引脚到逻辑信号（MOSI/MISO/SCLK/CS、TX/RX）。 对于高速总线提高采样率以确保正确解码。 禁用未使用的解码器以减少 CPU 与 UI 负载。 ### UART 示例（4M） ![](../../../en/logic_analyzer/slogic16u3/assets/Screenshots/Screenshot_2025 09 26_16 15 28.png) ![](../../../en/logic_analyzer/slogic16u3/assets/Screenshots/Screenshot_2025 09 26_16 16 09.png) ![](../../../en/logic_analyzer/slogic16u3/assets/Screenshots/Screenshot_2025 09 26_14 12 44.png) ![](../../../en/logic_analyzer/slogic16u3/assets/Screenshots/Screenshot_2025 09 26_14 13 24.png) ![](../../../en/logic_analyzer/slogic16u3/assets/Screenshots/Screenshot_2025 09 26_14 14 04.png) ### SDIO / SDCard 示例 ![](../../../en/logic_analyzer/slogic16u3/assets/Screenshots/Screenshot_2025 09 26_16 17 19.png) ![](../../../en/logic_analyzer/slogic16u3/assets/Screenshots/Screenshot_2025 09 26_16 17 57.png) ![](../../../en/logic_analyzer/slogic16u3/assets/Screenshots/Screenshot_2025 09 26_11 08 53.png) ![](../../../en/logic_analyzer/slogic16u3/assets/Screenshots/Screenshot_2025 09 26_11 10 26.png) ## 文件操作（保存 / 加载） 保存会话：存储捕获的样本、通道配置、触发设置和解码器状态。使用会话可保存工作以便以后分析。 加载会话：恢复已保存的捕获和 UI 状态。 ![](../../../en/logic_analyzer/slogic16u3/assets/Screenshots/Flameshot_2025 09 26_16 22 26.png) ![](../../../en/logic_analyzer/slogic16u3/assets/Screenshots/Flameshot_2025 09 26_16 23 19.png) <! End of Software User Guide >"},"/hardware/zh/logic_analyzer/combo8/use_cklink_function.html":{"title":"作为CKLink使用","content":" title: 作为CKLink使用 keywords: LogicAnalyzer, debugger, link, RISCV, tool update: date: 2023 07 23 version: v0.1 author: lxo content: Release docs SLogic Combo 8 具备高速CK Link功能，且速率远超CK Link Lite，接近CK Link Pro，是调试RISC V芯片的好工具。在此模式下还同时具备一路高速串口（20Mbps）功能。 准备开始使用CK LINK！ ## 开启CKLink功能 按下切换按键，将指示灯切换为黄色 ![slogic_led_yellow](./assets/use_cklink_function/slogic_led_yellow.png) > 验证CKLink功能是否开启的方法: > Windows环境打开设备管理器，Linux环境使用lsusb命令，可以找到\"CKLink HS\"设备 ## 开始使用 ### 引脚连接 > CKLink和DAPLink线序相似，所以放到了一张图里，请忽略掉“DAP” ![daplink_cklink_line_order](./assets/use_daplink_function/daplink_cklink_line_order.png) CKLink模式下可以同时支持一路CKLink和一路UART 上图左侧的引脚（TXD、RXD）可以作为串口使用（注：DTR、RTS 保留未使用） 上图右侧的引脚（TCK、TDI、TDO、TMS）作为CKLink调试使用 ### 使用方法 在Windows、Linux系统可以直接参考[使用 CDK + Sipeed RV Debugger Plus 编译调试](https://bouffalolab.gitee.io/bl_mcu_sdk/get_started/cdk_rv_debugger_plus.html#cdk sipeed rv debugger plus)和[T HEAD Debug Server 用户手册](https://occ.t head.cn/document?temp introduction 2&slug t head debug server user manual)，用法完全一样 #### 使用CDK进行调试 点击工具栏上方的`Start/Stop Debugger`按钮，进入debug界面，如下图所示 ![](./assets/use_cklink_function/cklink_cdk_debug.png) _Debug HellowWorld!_ 在`debug`界面下，你可以在左侧的`Register`窗口中查看CPU的内部寄存器数据。同时，在右侧的`Peripherals`外设面板中，你可以浏览相应外设寄存器数据。你可以通过顶部菜单栏的`Peripherals >System Viewer`来选择所需的外设。此外，在界面上方的工具栏中，你会找到相关的调试按钮，它们可以用于设置断点、单步调试、逐条指令执行以及全速运行等操作。当然，所有这些操作都有相应的快捷键和快速设置方式。如需详细信息，请参考CDK帮助文档，这里就不再详细展开介绍。 点击单步运行按钮，运行代码，即可看到指示光标移动到下一句代码，同时可以看到串口面板中显示输出的 Hello World！ #### 使用T HEAD Debug Server进行调试 > 请[参考](../../maix/m1s/other/start.html)M1s DOCK 上手**第十节 使用JTAG调试**的内容。"},"/hardware/zh/logic_analyzer/combo8/use_logic_function.html":{"title":"作为逻辑分析仪使用","content":" title: 作为逻辑分析仪使用 keywords: LogicAnalyzer, debugger, link, RISCV, tool update: date: 2023 07 23 version: v0.1 author: lxo content: Release docs ## 开启逻辑分析仪功能 按下按键将指示灯切换为蓝色。如下图所示： ![slogic_led_blue](./assets/use_logic_function/slogic_led_blue.png) > 验证逻辑分析仪功能是否开启: > Windows环境打开设备管理器，Linux环境使用lsusb命令，可以找到\"USB TO LA\"设备 ## 开始使用 > 注意： > 1. Linux环境下SLogic Combo 8最大传输带宽320Mb/s，典型配置80M@4CH 40M@8CH。 > 2. Windows环境下SLogic Combo 8最大传输带宽160Mb/s，典型配置80M@2CH 40M@4CH。 > 3. 如果上位机启动过程中，设备出现断连的情况，需要重新扫描并连接设备 ### 快速使用 #### 引脚连接 ![slogic_line_order](./assets/use_logic_function/slogic_line_order.png) 上图为SLogic 8个通道的线序图，将目标设备的待测信号点连接至SLogic任意空闲CH端口，并确保待测设备的GND与SLogic的GND相连接。 > 注意SLogic的GND线需要离待测点的位置越近越好，哪怕更近1cm也可能会增加采样质量 #### 下载和运行上位机 [点击这里下载上位机](https://dl.sipeed.com/shareURL/SLogic/SLogic_combo_8/4_application/PulseView) [点击这里下载新的上位机(同时支持SLogic Combo8 & SLogic16U3, Win/Mac/Linux)](https://dl.sipeed.com/shareURL/SLogic) 上位机软件用于观察和分析数字信号。Windows用户请下载exe后缀的文件，Linux用户请下载AppImage后缀的文件，建议下载日期最新的版本。 > 当软件名为`PulseView xxxx 230811 xxx.AppImage`时，日期则是2023年08月11日。其他软件的日期命名规则类似。 **Linux环境：** 1. 下载完成后，进入软件所在目录，使用快捷键`CTRL+ALT+T`打开终端，使用以下命令为软件赋予执行权限并以管理员身份运行： ```bash chmod +x PulseView x86_64 032323 1101.AppImage sudo ./PulseView x86_64 032323 1101.AppImage ``` **Windows环境：** 1. 下载完成后，点击exe文件并开始安装，根据安装引导一直点击next即可安装完成。 2. 安装完成后，在快捷菜单界面可以找到上位机图标，双击运行 > 注：在Linux环境最大可支持80M@4通道、40M@8通道采样；由于Windows环境下USB传输不稳定的限制，在Windows上最大只能支持到80M@2通道、40M@4通道采样。 **MacOS环境** PulseView SLogic 250910 aarch64.dmg #### 扫描SLogic并连接 首次启动时会自动连接，也可以选择手动连接SLogic **手动连接步骤** 1. 点击\"Scan for devices xxx\"扫描设备 2. 选择\"SIPEED USB TO LA xxx\"并点击OK连接设备 ![image 20230912140845449](./assets/use_logic_function/set_connect_cfg_of_pulseview.png) #### 准备采样 1. 设置PulseView的通道数、采样点数和采样率 下图设置通道数为**8**，采样点数为**1M samples**,采样率为**10Mhz**。此时的**采样时间**为1M / 10Mhz 0.1s ![equ_selec_complete_of_pulseview](./assets/use_logic_function/equ_selec_complete_of_pulseview.png) #### 开始采样 1. 点击Run启动采集，并获得采样结果 ![waveform_fast_of_pulseview](./assets/use_logic_function/waveform_fast_of_pulseview.png) > 若在采样过程中未使用D7通道，可能会观察到该通道的电平反转现象，该现象为正常情况不影响正常使用 #### 分析采样结果 1. 打开协议选择栏 ![image 20230912150905946](./assets/use_logic_function/open_ptl_field.png) 2. 选择需要分析的协议 ![image 20230912153947189](./assets/use_logic_function/select_the_target_protocol.png) 3. 配置协议的参数 ![image 20230912152007703](./assets/use_logic_function/config_param_of_protocol.png) 4. 观察分析结果 ![image 20230912152105530](./assets/use_logic_function/observe_the_analysis_res.png) 根据分析结果然后开始调试吧~ ### 详细配置 #### 采样参数 采样参数包括有采样样本数量、采样频率和采样时间 1. 采集样本数量：样本数量根据需求选择合适数值即可 2. 采样频率：根据被测信号频率选择，**推荐选择大于10倍被测信号频率**(可参考奈奎斯特定理) 3. 采样时间：采样时间根据采集**样本数量**以及**采样频率**进行计算，计算公式为：</br>**时间（秒） 样本数 / 采样率**</br>例如1M samples，1Mhz时，采样时间为1s ![set_total_sampling_time_of_pulseview](./assets/use_logic_function/set_total_sampling_time_of_pulseview.png) > 设置完成采集样本数量、采样频率后，将鼠标至于采集样本数量选择框上，会显示当前参数的采样时间 #### 通道参数 点击通道的标签来设置通道参数，通道参数包括有标签名、标签颜色、通道波形显示窗口宽度和信号触发方式 1. 标签名：可根据采样信号意义设置，便于多信号采样分辨信号 2. 标签颜色：根据个人喜好设置，便于多信号采样分辨不同信号 3. 通道波形显示窗口宽度：根据信号幅值设置，单位为像素，信号幅值变化大时，可提高该参数便于观察信号幅值变化 4. **信号触发方式**：具有**直接采样**、**高电平触发**、**低电平触发**、**下降沿触发**、**上升沿触发**以及**边沿触发** (采集信号之前，可能存在许多无效信号，根据信号的规律来设置触发方式可以有效地过滤掉无效信号，从而提高采样效率和准确性。) ![set_channel_cfg_of_pulseview](./assets/use_logic_function/set_channel_cfg_of_pulseview.png) ### 调试波形 #### 视图操作 通过操作视图，可以更详细的观察波形 ![tag_of_pulseview](./assets/use_logic_function/tag_of_pulseview.png) **波形缩放**：鼠标滚轮（中键）向上滚动放大波形、向下滚动缩小波形 **拖动波形**：鼠标左键按住可以左右上下拖动波形显示区 **区域放大**：鼠标双击某区域可放大该区域波形 **通道滚动**：“波形显示区”使用 Ctrl+鼠标滚轮（中键）可以快速上下滚动通道 **时间测量**：您可以通过，在所需的位置右键点击鼠标点击\"创建标记点（Create Marker Here）\"来标记位置，当您重复标记其他位置时，软件会自动计算并在时间轴上显示两个标记点之间的时间长度 **调整通道顺序**：鼠标拖动通道标签即可拖动通道至指定位置 #### 协议解码 在抓取所需的数据后，为了便于对数据进行分析，可以使用协议解码功能对数据进行解码，以下为一些常见协议的解码过程。 ##### UART协议数据解码 1. 将串口的TX引脚到D0通道 2. 点击顶部工具栏**黄蓝波形图标**，搜索UART，双击选择串行接口类UART ![uart_select](./assets/use_logic_function/logic_uart_select.png) 3. 点击波形显示窗口新增的UART通道的**协议标签**。 设置TX对应通道，数据格式，信号波特率以及字节序 ![uart_set](./assets/use_logic_function/logic_uart_set.png) 4. 抓取数据，解析结果如下： 示例为UART的TX脚发送数据 “Hello SLogic！” （数据格式为ascii，波特率115200，小端字节序) ![uart_tx](./assets/use_logic_function/logic_uart_tx.jpg) ##### I2C协议数据解码 1. 将I2C的SCL引脚连接到D0通道，SDA引脚连接到D1通道 2. 点击顶部工具栏**黄蓝波形图标**，搜索I2C，双击选择第一项 ![i2c_select](./assets/use_logic_function/logic_i2c_select.png) 3. 点击波形显示窗口新增的I2C通道的**协议标签**。 点击新增的I2C**协议标签**，设置的SCL、SDA所在通道 ![i2c_set](./assets/use_logic_function/logic_i2c_set.png) 4. 抓取数据，解析结果如下： 示例为I2C发送0x68 ![i2c_value](./assets/use_logic_function/logic_i2c_0x68_write.jpg) ##### SPI协议数据解码 1. 将SPI的MISO、MOSI、CLK、CS引脚依次连接至D0、D1、D2、D3通道 2. 点击顶部工具栏**黄蓝波形图标**，搜索SPI，双击选择串行接口类SPI ![spi_select](./assets/use_logic_function/logic_spi_select.png) 3. 点击波形显示窗口新增的SPI通道的**协议标签**。 设置CLK、MISO、MOSI、CS对应通道，片选信号有效电平 ![spi_set](./assets/use_logic_function/logic_spi_set.png) 4. 抓取数据，测试结果如下： 示例为SPI发送0x00~0X09(时钟10Mhz，片选低电平有效) ![spi_10mhz](./assets/use_logic_function/logic_spi_10mhz.jpg) 示例为SPI发送0x00~0X09(时钟26Mhz，片选低电平有效) ![spi_26mhz](./assets/use_logic_function/logic_spi_26mhz.jpg) ### 注意事项 逻辑分析仪连接被测系统时，需要注意以下事项： 1. 逻辑分析仪与电脑是共地的，如果待测设备是强电系统，务必使用\"USB隔离器\"来进行隔离措施。否则，很可能会造成逻辑分析仪或电脑损坏的风险 2. GND 通道与被测系统的 GND 必须可靠连接，尽可能的短 3. 信号通道必须可靠连接至被测系统的待测信号位置，不可随意“嫁接”，导致干扰的引入 4. 如果不注意接线方式，很可能会引入很多毛刺，导致软件无法分析数据"},"/hardware/zh/logic_analyzer/combo8/use_fouruart_function.html":{"title":"作为串口模块使用","content":" title: 作为串口模块使用 keywords: LogicAnalyzer, debugger, link, RISCV, tool update: date: 2023 07 23 version: v0.1 author: lxo content: Release docs SLogic Combo 8 具备4路独立高速串口功能，前两路基于UART可同时达到20Mbps的超高速波特率，后两路通过IO模拟最高可达1Mbps。非常适合批量烧录，生产测试等场景。 ## 开启串口模块功能 按下切换按键，将指示灯切换为红色 ![slogic_led_red](./assets/use_fouruart_function/slogic_led_red.png) > 验证SLogic功能是否开启的方法: > Windows环境打开设备管理器，Linux环境使用lsusb命令，可以找到\"UARTx4 HS\"设备。 ## 开始使用 ### 引脚连接 ![fouruart_line_order](./assets/use_fouruart_function/fouruart_line_order.png) SLogic Combo 8总共有4个串口，UART0和UART1最高支持20M波特率，UART3和UART4最高支持1M波特率。 注意： 1. 保证模块与目标设备共地，防止出现乱码等情况。 2. Windows平台的设备号可能是乱序的，需要手动尝试来找到对应的串口 ### Linux 注意：Linux由于系统原因，当设备拥有大于一个的ttyACM后，Linux会认为其为调制解调器，会临时占用发送AT指令。此时无法打开串口，会报资源占用设备忙碌，属正常现象，稍等片刻即可恢复正常。要解决该问题，可以添加udev规则来规避该问题,参考以下指令： ```shell sudo touch /etc/udev/rules.d/49 sipeed.rules sudo echo \"ATTRS{idVendor} \\\"359f\\\", ATTRS{idProduct} \\\"3101\\\", ENV{ID_MM_DEVICE_IGNORE} \\\"1\\\"\" > /etc/udev/rules.d/49 sipeed.rules sudo udevadm control reload ``` #### 数据收发 Linux可使用picocom或minicom作为串口收发工具，安装指令为： ```Bash sudo apt install picocom sudo apt install minicom ``` 以minicom为例，使用`CTRL+ALT+T`打开Linux终端，输入安装指令，将会提示输入该Linux系统管理员用户密码，输入密码后回车，静待软件包安装完成 ![](./assets/use_fouruart_function/minicom_install_uart.png) 完成安装后，使用UART0与测试设备进行通信，于终端输入命令： ```Bash sudo minicom b 2000000 D /dev/ttyACM0 ``` b参数指定所需的波特率，与测试设备UART串口设置波特率相同即可 D参数指定监听的端口号 ![](./assets/use_fouruart_function/minicom_uart.png) 命令输入后即与测试设备进行通信，收到信息将于终端进行打印；以及向测试设备发送数据。 #### 串口回传测试： ![](./assets/use_fouruart_function/uart_line_uart.jpg) (上：串口模块接线图) 回传测试结果： ![](./assets/use_fouruart_function/minicom_test_uart.png) ### Windows 在Windows系统中，您可以使用SSCOM、MobaXterm等串口助手作为串口收发工具。以下以**SSCOM**为例，演示如何使用SSCOM进行串口通信测试 1. 首先，下载SSCOM，该软件为开源软件，请自行百度下载 2. 下载完成后，解压并启动串口助手。您将看到如下界面： ![SSCOM界面](./assets/use_fouruart_function/sscom_gui.png) 3. 将模块连接到PC上。然后在Windows设备管理器中（快捷键`Win + X + M`）查看是否成功连接，以及获取串口号信息 ![设备管理器](./assets/use_fouruart_function/sscom_device_manage.png) 由于Windows系统的特性，串口号可能会是乱序的。因此，您可以按照以下步骤测试对应的串口号： 连接模块的TX*和RX*引脚（*为0 3） 设置波特率，通常使用115200 开启串口 逐个尝试不同的端口号设备，点击“发送”按钮，检查是否收到数据，以确认每个端口对应的串口号 ![确认串口号](./assets/use_fouruart_function/sscom_determine_port.png) 4. 确认了每个串口的端口号后，您可以在数据输入窗口中输入需要发送的数据。同时，接收到的数据也会显示在窗口中 #### 收发测试 使用SLogic 4xUART模块进行串口通信测试，前两路虚拟串口最高速率可达20Mbps。以下以使用SSCOM测试性能为例 ##### 测试 1Mbps（256kbps，512kbps） 1. 连接TX2和RX3 2. 启动两个SSCOM实例，分别连接到两个串口 3. 将波特率设置为1000000，然后开启串口 4. 创建一个256KB的文本文件，其中的内容为重复的常见字符 5. 使用SSCOM的文件发送功能，选择刚创建的文本文件并发送 6. 另一个SSCOM实例将接收数据并检查接收到的文件内容 以下是1Mbps测试的结果，检查文件大小以及数据内容确认1Mbps时，收发256kb数据测试成功 ![1Mbps测试（256KB）](./assets/use_fouruart_function/uart_sscom_1mbps_256kb.png) 将文本文件的数据增大至512KB，并重复测试，确认1Mbps时，收发512kb数据测试成功 ![](./assets/use_fouruart_function/uart_sscom_1mbps_512kb.png) ##### 测试 20Mbps（256kbps） 1. 连接TX0和RX1 2. 启动两个SSCOM实例，分别连接到两个串口 3. 将波特率设置为20000000，然后开启串口 4. 创建一个256KB的文本文件，其中的内容为重复的常见字符 5. 使用SSCOM的文件发送功能，选择刚创建的文本文件并发送 6. 另一个SSCOM实例将接收数据并检查接收到的文件内容 以下是测试结果截图，可以通过检查文件大小和数据内容来确认测试是否成功 ![20Mbps测试](./assets/use_fouruart_function/uart_sscom_20mbps_256kb.png)"},"/hardware/zh/logic_analyzer/combo8/use_daplink_function.html":{"title":"作为DAPLink使用","content":" title: 作为DAPLink使用 keywords: LogicAnalyzer, debugger, link, RISCV, tool update: date: 2023 07 23 version: v0.1 author: lxo content: Release docs SLogic Combo 8 具备高速DAP Link功能，适用于各种常规芯片，尤其是在Windows下使用IDE调试的STM32等芯片 ## 开启DAPLink功能 按下切换按键，将指示灯切换为绿色 ![slogic_led_green](./assets/use_daplink_function/slogic_led_green.png) > 验证DAPLink功能是否开启的方法: > Windows环境打开设备管理器，Linux环境使用lsusb命令，可以找到\"RV CMSIS DAP\"设备 ## 开始使用 以STM32F103C8T6芯片在Windows MDK IDE为例介绍具体使用步骤：连接，下载、调试固件，演示使用的MDK版本为当前最新版（V5.38） ### 引脚连接 > CKLink和DAPLink线序相似，所以放到了一张图里，请忽略掉“CK” ![daplink_cklink_line_order](./assets/use_daplink_function/daplink_cklink_line_order.png) DAPLink模式下可以同时支持一路DAPLink和一路UART 上图左侧的引脚（TXD、RXD）可以作为串口使用（注：DTR、RTS 保留未使用） 上图右侧的引脚（TCK(SWCLK)、TDI、TDO、TMS(SWDIO)）作为DAPLink调试使用 ### 使用MDK连接DAPLink 1. 设置Reset Options为SYSRESETREQ 2. 在CMSIS DAP中找到并寻找RV CMSIS DAP设备（图中 Port 默认为 SW 两线调试，可选 JTAG 4 线调试） SW 两线调试只需要连接 TCK(SWCLK)及 TMS(SWDIO) 即可。 ![cfg_dap_debugger_of_mdk](./assets/use_daplink_function/cfg_dap_debugger_of_mdk.png) ### 使用MDK下载固件 ![download_fw_in_mdk](./assets/use_daplink_function/download_fw_in_mdk.png) ### 使用MDK调试固件 ![start_debugger_in_mdk](./assets/use_daplink_function/start_debugger_in_mdk.png) ### MDK使用视频 <p align \"center\"> <video src \"./assets/use_daplink_function/slogic_daplink_keil_usage.mp4\" width \"100%\" controls \"controls\" autoplay \"autoplay\" x5 playsinline \"\" \t\tplaysinline \t\twebkit playsinline \"true\" \t\tposter \"./assets/use_daplink_function/start_debugger_in_mdk.png\" \t\tpreload \"auto\" > </video> </p> ### 使用openocd连接 先前有用户[反映](https://maixhub.com/discussion/100020)clion无法使用Slogic进行调试，深入确认后发现是openocd的版本问题。 xpack 版本 openocd 下载链接为https://xpack.github.io/dev tools/openocd/releases 下载的是 v0.12.0 2 版本运行截图 ![](./assets/use_daplink_function/xpack_openocd.png) 来自https://gnutoolchains.com/arm eabi/openocd 下载的`20231002`版本会出现无法发现Slogic的问题，报错截图如下 ![](./assets/use_daplink_function/gnu_openocd.png) ![](./assets/use_daplink_function/dap_clion_not_found.jpg) 感谢群友`dragonforward`的文档贡献"},"/hardware/zh/logic_analyzer/combo8/basic_operation.html":{"title":"基础操作","content":" title: 基础操作 keywords: LogicAnalyzer, debugger, link, RISCV, tool update: date: 2023 07 23 version: v0.1 author: lxo content: Release docs SLogic Combo 8共有4个功能（SLogic、CKLink Debugger、DAP Link Debugger、USB2UART）。这篇文档用来指导如何选择功能。 ## 按键功能 上电后，**按下按键**切换功能，切换成功后可以看到**指示灯变化**。 ![slogic_btn](./assets/basic_operation/slogic_btn.png) （上：红框是切换按键的位置） > 注意：切换功能时，切换间隔不要小于100ms，否则可能导致模块进入boot模式，现象会看到灯不再变化。如果遇到了该情况，尝试重新上电即可~ ## 指示灯颜色与功能 每种功能对应一种颜色，通过指示灯的颜色来判断当前启用的功能 功能 Slogic DAPLink USB2UART CKLink 指示灯颜色 蓝色 绿色 红色 黄色 （上：指示灯颜色/功能对应表） ## 面板信息 通过面板信息可以查阅当前的功能和对应线序： 左侧是**CKLink（黄色）**和**DAPLink（绿色）**线序，它们线序相似所以放到了一起。 中间是**UART（红色）**线序。 右侧是**SLogic（蓝色）**线序。 ![slogic_panel](./assets/basic_operation/slogic_panel.png) （上：颜色/功能/线序对应图） 举个例子： 1. 如果要使用SLogic功能，那么需要按下按键将指示灯切换为蓝色，就可以切换到SLogic功能，通过面板的蓝色字体下对应的线序找到SLogic的引脚线序。 2. 如果要使用UART功能，那么需要按下按键将指示灯切换为红色，就可以切换到UART功能，通过面板的红色字体下对应的线序找到UART的引脚线序。 好的，现在你已经可以切换到你需要的功能了，进入下一步使用吧~"},"/hardware/zh/logic_analyzer/combo8/faq.html":{"title":"常见问题(FAQ)","content":" title: 常见问题(FAQ) keywords: LogicAnalyzer, debugger, link, RISCV, tool update: date: 2023 09 12 version: v0.1 author: lxo content: Release docs 以下按照Q&A的形式列举了一些常见的问题，使用过程遇到任何问题时请在下文中尝试寻找解决方法，如果上述记录并没有解决你的问题，可以尝试在[社区](https://maixhub.com/discussion)中反馈该问题，合理的问题会有技术人员或其他开发者为您解答。 ## 综合问题 ### 使用逻辑分析仪/DAPLink/CKLink/串口模块时有部分功能异常 **A:**请优先在Q&A中尝试找到并解决你的问题，如果仍有问题，则点击[这里](./update_firmware.html)更新固件后再尝试 ### 按下按键后，指示灯没有变化？ **A:**检查是否按下的频率太快，按下按键的间隔不要小于100ms，否则可能导致模块进入boot模式，现象会看到灯不再变化。如果遇到了该情况，尝试重新上电即可恢复 ## 逻辑分析仪 ### 点击run后弹窗提示\"device closed but should be open\" ![image 20230816113213933](./assets/use_logic_function/tips_capture_failed.png) **A:**这可能是接触不稳定导致设备断连了，尝试重新插拔设备后再重新连接即可 ### 使用8通道采集时发现D7通道在悬空时也会出现波形 **A:**这是一个待解决的问题，但这个问题不会影响采集波形，给D7通道接入外部信号后仍然可以正常采集波形。如果不需要这个通道时也可以隐藏这个通道，很抱歉给您带来了困扰。 ### 波形采集时，波形显示窗口中的波形和实际的波形不一致 **A:**请确保将逻辑分析仪的GND线连接到了目标设备的GND，并且确保GND线离待测点的位置越近越好。要知道即使是1cm的距离，中间也可能有很多元器件会干扰信号，所以哪怕是更近1cm也有可能让信号质量更好。 ### 逻辑分析仪无法长时间采样 **A:**有多种情况影响无法长时间采样： **情况1：**采样点数和采样率设置不正确导致采样时间很小，采样时间(单位:s) 采样点数/采样率，请确保采样点数和采样率设置正确。 **情况2：**PC性能的影响。由于PulseView需要使用大量的USB带宽，但是如果此时PC本身性能不足，也会导致采样时间变短。 **情况3：**PC内存的影响。如果一切都正常，那么检查一下是否是采样点数设置太大，导致内存不足以保存采样数据 ## DAPLink ### MDK找不到DAPLink设备 **A:**有可能是MDK版本过低的原因，低版本的MDK可能无法识别DAPLink（本文测试使用的MDK版本是V5.38）。如果MDK版本低导致无法识别DAPLink，但是不想升级版本，可以参考[这里](https://developer.arm.com/documentation/ka003663/latest/)的方法来更新CMSIS DAP的调试驱动 ### DAPLink模式的串口功能无法正常使用，出现回显的情况 **A:**请在更新固件章节中将固件更新到最新版本后再尝试 ### DAPLink在烧录固件时报错`Connection refused due to device mismatch!` ![image 20230816113213933](./assets/use_daplink_function/err_device_mismatch.jpg) **A:**可能是实际芯片型号与芯片包不匹配导致。例如MDK使用`STM32F103`的配置，但实际芯片是`CS32F103`，由于`STM32F103`的IDCODE是**0x1B10417**，`CS32F103`的IDCODE是**0x2BA01477**，由此发生设备不匹配导致拒绝连接。解决方法是找到并安装实际芯片的软件包，软件包数量较多，下载方法请自行查找。 ### DAPLink在Clion/openocd报错`Unable to find a matching CMSIS DAP device` **A:** 可能是默认使用的openocd版本不支持，请使用xpack版本的openocd，下载链接见https://xpack.github.io/dev tools/openocd/releases/ ## CKLink None ## 串口模块 ### 串口终端无法打开串口 **A:**尝试一下其他的串口助手，Windows上可以尝试使用XCOM，Linux上可以尝试使用Minicom"},"/hardware/zh/logic_analyzer/combo8/update_firmware.html":{"title":"更新固件","content":" title: 更新固件 keywords: LogicAnalyzer, debugger, link, tool update: date: 2023 09 01 version: v0.1 author: lxo content: Release docs 以下是SLogic Combo 8 更新固件的步骤 ## 下载烧录工具和固件 烧录工具：[点击下载](https://dl.sipeed.com/shareURL/SLogic/SLogic_combo_8/4_application/Tools) 固件：[点击下载](https://dl.sipeed.com/shareURL/SLogic/SLogic_combo_8/4_application/Firmware) 烧录工具和固件选择最新版本即可，下载完成后自行解压 > 注：当固件名为`slogic_combo8_pack_202308171404.bin`时，日期为2023年08月17日。其他固件的日期命名规则类似。 ## 配置烧录工具 1. 启动烧录工具 解压后，烧录工具的根目录下提供了不同系统环境的执行文件。 Windows用户：双击`BLDevCube.exe`启动 Linux用户：双击`BLDevCube ubuntu`启动。注意Linux环境需要添加可执行权限`sudo chmod +x BLDevCube ubuntu` 2. 选择芯片 启动后，选择 **BL616/618** 并点击Finish ![chip_selection](./assets/download_firmware/chip_selection.png) 3. 使能Single Download Options，并添加下载好的固件 ![config_download_firmware](./assets/download_firmware/config_download_firmware.png) ## 配置设备 让SLogic Combo 8进入烧录模式 ![enter_the_burn_mode](./assets/download_firmware/enter_the_burn_mode.png) 操作步骤： 1. 长按按键不松开 2. 重新上电 3. 观察LED灯不亮，则操作成功 ## 烧录固件 配置串口号和波特率，并点击`Create & Download`即可下载 ![download_firmware](./assets/download_firmware/download_firmware.png) 下载完成后，进度条显示绿框说明下载成功，更新固件完成"},"/hardware/zh/logic_analyzer/combo8/index.html":{"title":"SLogic Combo 8","content":" title: SLogic Combo 8 keywords: LogicAnalyzer, debugger, link, RISCV, tool update: date: 2023 07 23 version: v0.1 author: lxo content: Release docs ## 简介 SLogic Combo 8是一款兼有逻辑分析仪、CKLink Debugger、DAP Link Debugger、USB2UART功能的开发工具，使用时可以通过按键任意切换功能。 ![slogic_combo8_main](./assets/readme/slogic_combo8_main.png) ## 功能参数 ### SLogic功能参数 逻辑分析仪 **SLogic Combo 8** 最大通道数 8CH 最高采样率 80M 传输带宽 320Mb/s 采样模式 Stream 典型配置 80M@4CH 40M@8CH 信号输入范围 0～3.6V 高低电平门限 VIH>2V VIL<0.8V 注：Windows环境下SLogic Combo 8最大传输带宽160Mb/s，典型配置80M@2CH 40M@4CH ### CKLink功能参数 CKLink SLogic Combo 8 JTAG时钟速率 16M 典型dump速度 1200KB/s 调试串口 最高20Mbps ### DAPLink功能参数 DAPLink SLogic Combo 8 调试串口 最高20Mbps 典型烧录速度 110KB/s ### UART功能参数 高速四串口 **SLogic Combo 8** 最高波特率 2x20Mbps+2x1Mbps 总带宽 42Mbps ## 开始使用 点击下方链接进入对应章节： [基础操作](./basic_operation.html) [作为逻辑分析仪使用](./use_logic_function.html) [作为CKLink使用](./use_cklink_function.html) [作为DAPLink使用](./use_daplink_function.html) [作为串口模块使用](./use_fouruart_function.html) [更新固件](./update_firmware.html) ## 其他链接 [淘宝](https://item.taobao.com/item.htm?spm a21n57.1.0.0.14dd523cuZ61oI&id 737788586308&ns 1&abbucket 5#detail) [Sipeed 下载站](https://dl.sipeed.com/shareURL/SLogic/SLogic_combo_8/4_application/Firmware) [交流论坛](maixhub.com/discussion) 联系邮箱：support@sipeed.com"},"/hardware/zh/logic_analyzer/index.html":{"title":"SLogic series","content":" title: SLogic series keywords: LogicAnalyzer, debugger, link, RISCV, tool update: date: 2023 03 09 version: v0.1 author: wonder content: Create file SLogic is Sipeed Logic Analyzer."},"/hardware/zh/maixII/index.html":{"title":"Maix-II 系列硬件产品","content":"Maix II 系列硬件产品 ## Maix II 简介 继经典的 K210 Maix I 系列 AIOT 板卡之后，Sipeed 继续推出多款可运行完整 Linux 系统的边缘计算板卡，将以 MAIX II，MAIX III 按照性能依次命名。 MAIX II 系列包含多款硬件产品，目前有: * **Maix II Dock**： **本系列推荐产品**, 芯片为全志 V831, 高性价比能跑 Linux 的SOC，同时支持硬件 AI 加速（0.2Tops 算力），目前软件支持最容易入门，提供 C SDK 和 Python SDK， 以及在线模型训练服务([MaixHub](https://maixhub.com)) * **MaixSense**： 芯片为全志R329，也有提供硬件 AI 加速，0.25Tops 算力。 * **Maix II S**：芯片为全志 V833，V831 升级版， 主要用于商业定制用途，个人用户慎重选择。 ## MaixII Dock 芯片为全志 V831, 单核 Cortex A7 800MHz， 64MiB 片内 DDR2 内存， 高性价比能跑 Linux 的SOC，同时支持硬件 AI 加速（0.2Tops 算力），可以当成普通 Linux SOC 使用， 也可以用于边缘 AI 应用。 **本系列推荐产品**, 最具性价比， 目前软件支持最容易入门， 支持 C 语言开发，提供 C SDK([libmaix](http://github.com/sipeed/libmaix))； 同时提供 [MaixPy3](/maixpy3) 支持，使用 Python 语言即可开发，可以直接使用大量 Python 库，并且配套 jupyter IDE， 同时 [MaixHub](https://maixhub.com) 完全支持此设备 * 产品功能速览 <p align \"center\"> <iframe src \"//player.bilibili.com/player.html?aid 298543445&bvid BV1sF411u7xb&cid 586467021&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\"> </iframe> </p> * 实拍图： ![m2dock](../../assets/maixII/m2dock.jpg) * 购买链接: [sipeed.taobao.com](https://item.taobao.com/item.htm?ft t&id 635874427363) * 详情： [MaixII Dock](./M2/resources.html) ## MaixSense 芯片为全志 R329，双核 A53@1.5GHz，片内 256MiB DDR3 内存，双核 HiFi4@400MHz 也有提供硬件 AI 加速，0.25Tops 算力， 更加擅长音频领域， 支持 armbian 系统。 官方开放资料很多，目前比较适合动手能力比较强的开发者。 ![](./M2A/assets/M2A 1.gif) * 购买链接: [sipeed.taobao.com](https://sipeed.taobao.com) * 详情： [MaixSense](./M2A/maixsense.html) ## MaixII S 可以理解成 V831 的性能升级版， V831 上的程序可以直接在 V833 上运行，此开发板仅支持商业用户，个人用户建议选择 Maix II Dock 开发板 <img style \"max height: 300px\" src \"./M2S/assets/M2s_Dock.jpg\" alt “M2s_Dock”/> * 详情： [MaixII S](./M2S/V833.html)"},"/hardware/zh/maixII/M2A/config_system.html":{"title":"配置系统","content":"# 配置系统 Lichee MaixSense 的引脚图如下: <img src \"./assets/R329 pin.png\" alt \"pinmap\" width 60%> ## 连接串口 连接串口是为了使电脑与板子能够进行通信。 相关操作： 使用 Type C 线将电脑与上图所标注处的 `USB转系统串口` 相连即可，然后根据电脑系统执行不同的下方操作 ### Linux & macOS Linux 不需要装驱动，系统自带了，使用 `ls /dev/ttyUSB*` 命令即可看到设备号 ### Windows Lichee MaixSense 使用了 CH340 作为串口芯片。Windows 用户需要安装 CH340 的驱动。 Windows 下载 [ch340 ch341 driver](https://api.dl.sipeed.com/shareURL/MAIX/tools/ch340_ch341_driver) 安装即可，然后可以在设备管理器中看到串口设备和端口号。 ## Tina 系统配置 一般建议使用 armbian 系统，对于 Tina 系统用户需要有一定的使用基础才能够使用。 Lichee MaixSense 的 Tina 系统配置和 [M2dock](./../M2/usage.html) 基本相同，这里不另作赘述。 <! 可以将板子上的摄像头拆下来后再将电脑与该接口相连然后使用 [adb](https://developer.android.google.cn/studio/releases/platform tools?hl zh cn) 工具来操作板子，此操作仅限 Tina 系统。因为不推荐小白使用 Tina 系统，所以此处不再细说 > ## armbian 系统配置 根据本文开头描述来将电脑与板子连接且安装 [CH340 驱动](https://dl.sipeed.com/fileList/MAIX/tools/ch340_ch341_driver/CH341SER.EXE) 后，可以在串口软件比如 Xshell 或者 [Mobaxterm](./../M2/tools/mobaxterm.html)中，设置波特率 (baudrate) 为115200，选择板子的串口，连接上板子。 由于所提供的下载镜像分为内置 MaixPy3 的镜像和无 MaixPy3 的镜像，所以下面分为两种来说明相关操作。 ### 默认含有 MaixPy3 的镜像 用户名和密码均为 `root` ，登陆进去即可。输入的时候要是输错了就是直接按回车重来吧，最好输入时无更改。 成功登录的 log 参考如下： ```bash Armbian 21.08.0 trunk Bullseye ttyS0 maixsense login: root Password: __ __ _ ____ \\/ __ _(_)_ __/ ___ ___ _ __ ___ ___ \\/ / _` \\ \\/ /\\___ \\ / _ \\ '_ \\/ __/ _ \\ (_ > < ___) __/ \\__ \\ __/ _ _\\__,__/_/\\_\\____/ \\____ ____/\\___ Welcome to Armbian 21.08.0 trunk Bullseye with bleeding edge Linux 5.14.0 rc7 sun50iw11 No end user support: built from trunk & unsupported (bullseye) userspace! System load: 133% Up time: 0 min Memory usage: 53% of 231M Zram usage: 23% of 115M IP: 192.168.0.251 CPU temp: 50°C Usage of /: 77% of 2.9G [ 0 security updates available, 66 updates total: apt upgrade ] Last check: 2022 08 31 01:45 [ General system configuration (beta): armbian config ] Last login: Tue Aug 30 10:34:06 UTC 2022 on ttyS0 root@maixsense: ``` ### 不含 MaixPy3 的镜像 首次使用需要设置密码，第一次使用没有设置密码的话只能重新烧录重新获取设置密码的机会。 密码过短或者过于简单的话会被要求重新设置。 ```bash New to Armbian? Documentation: https://docs.armbian.com Support: https://forum.armbian.com New root password: ********** Repeat password: ********** ``` 设置完密码后需要自行设置默认 shell,一般选择 bash ```bash Choose default system command shell: 1) bash 2) zsh Shell: BASH ``` 然后会要求新建一个用户，自定义用户名和登录密码即可。 ```bash Creating a new user account. Press <Ctrl C> to abort Please provide a username (eg. your forename): ll Create password: ********* Repeat password: ********* ``` 新建用户后默认给新建的用户授予了 root 权限，以后可以直接使用新建的用户来操作板子。 我们可以用 `passwd` 命令来删除或者修改密码。 例如我们可以使用 `passwd d root` 来删除我们开始所创建的 root 用户的密码，也可以使用 `passwd root` 命令来重新设置 root 用户的密码 下面是部分 `passwd` 命令例子 log ```bash root@maixsense:~# passwd root New password: Retype new password: passwd: password updated successfully ``` 下面是部分示例~ ![2021080511 46 52](./assets/2021080511 46 52.gif)"},"/hardware/zh/maixII/M2A/maixsense.html":{"title":"MaixSense 简介","content":"# MaixSense 简介 这个板子和之前的 Maix I 系列不同，它的主控不但带有 AI 加速功能，还支持运行 armbian 系统。 ## M2A 板卡 M2A 板卡以全志 R329 为核心主控，还集成电源芯片、FEL烧录按键、wifi模组、存储焊盘和 RMGII 接口等组件。 ![M2A](./assets/M2A.jpg) ### R329 芯片 R329 芯片是由全志科技所设计双核 Cortex A53 64 位处理器 ，配备有双 HIFI4 DSP 可用于音频后处理和预处理，以及 Arm 中国以极低的功耗却可达到 0.256 TOPS 算力的 AIPU（人工智能处理单元），能够用来硬件加速神经网络，对摄像头获取到的 720p 分辨率的图像进行相应的处理。 ![R329框架](./assets/R329_1.png) 条目 参数 CPU Dual core ARM Cortex™ A53@1.5GHz<br>32KB L1 I cache + 32KB L1 D cache per core<br>256KB L2 cache DSP Dual core HiFi4@400MHz<br> 32KB L1 I cache + 32KB L1 D cache per core<br> 2MB SRAM NPU 搭载周易™Z1 AIPU，最大支持0.25TOPS@600MHz 内存 内置 DDR3 256MB 储存 支持 SPI Nand/Nor/eMMC 音频 5路ADC，2路DAC<br>3个 I2S/PCM 控制器 以太网 10/100/1000 Mbps USB OTG \\* 1<br>Host \\* 1 SDIO SDIO 3.0 * 2 I2S I2S*3(I2S0, I2S1, S I2S0) SPI SPI*2(SPI0, SPI1) TWI TWI*3(TWI0, TWI1, S TWI0) GPADC 4 ch SCR SCR*1 PWM PWM*15(PWM[8:0], S PWM[5:0]) ## MaixSense开发板介绍 MaixSense 开发板可能是市面上最小的 Linux 卡片电脑。本套件包含一个搭载全志 R329 的高度集成 SOM 核心板，以及一个多功能 IO 扩展底板，可以运行 Linux 系统, 并具备出色的扩展功能。您可以将它用于搭建个人服务器、开发智能语音助手、设计机器人等场景。它通过内置的周易 AIPU 处理器同时支持智能语音和视频图像处理，开发者可以直接在开发板上跑通 CV , NLP 等 AI 模型。 **Tina Linux**：全志科技基于 Linux 内核开发的针对智能硬件类产品的嵌入式软件系统。Tina Linux基于 openwrt 14.07 版本的软件开发包,包含了Linux系统开发用到的内核源码、驱动、工具、系统中间件与应用程序包。可以从 [https://github.com/sipeed/r329 linux 4.9](https://github.com/sipeed/r329 linux 4.9) 获取到 Tina sdk。 但是 MaixSense 不只是可以运行 Tina ，还可以运行 **armbian**，这是一个真正**完整**的 linux 系统，armbian 是基于 debian/ubuntu 进行开发的。 名称 armbian Tina 简介 专门用于`ARM`开发板的`Debian` 全志深度修改OpenWRT1404的系统 特点 主线化Linux，功能丰富 厂商深度修改，软硬件契合度高 适用人群 极客，嵌入式入门玩家等 深度开发，需要自行定制等开发人员 ## MaixSense外观预览 <div align \"center\"> <img src \"./assets/M2A 1.gif\" alt \"Maixsense outlook\" > </div> ## MaixSense 基本参数 <table role \"table\" class \"center_table\"> <thead> <tr> <th colspan \"2\">MaixSense基本参数</th> </tr> </thead> <tbody> <tr> <td>处理器 CPU</td> <td>双核 ARM CortexTM A53™ </td> </tr> <tr> <td>AIPU(NPU)</td> <td>搭载周易TZ1AIPU，最大支持0.25TOPS@600MHz</td> </tr> <tr> <td>DRAM</td> <td>SIP 256MB DDR3</td> </tr> <tr> <td>存储</td> <td>可使用核心板搭载的 SPINAND (默认空贴)存储<br>可使用底板搭载的SD卡座</td> </tr> <tr> <td>视频编码器</td> <td>H264/5 &JPEG,最大720p@30fps</td> </tr> <tr> <td>摄像头</td> <td>出厂默认OV9732，最高支持720P@30fps HD<br>采用USB C连接器,支持正反插(可分别用作前后摄)</td> </tr> <tr> <td>麦克风</td> <td>两个模拟MEMS麦克风，平均灵敏度91dB SPL@1kHz</td> </tr> <tr> <td>屏幕</td> <td>1.5寸SPI总线屏幕,屏幕接口采用0.5mm 12P FPC，分辨率240*240</td> </tr> <tr> <td>按键</td> <td>1个复位按键和4个用户按键(ADC按键)，1个下载按键(FEL)</td> </tr> <tr> <td>以太网接口</td> <td>在核心板以24P 0.5mm间距FPC的形式引出，用于连接相应PHY</td> </tr> <tr> <td>IO引出</td> <td>3*10P 2.54mm 焊盘<br>1个4PMx1.25插座(引出2*GPIO和5V/GND)<br>具体可看下方引脚图</td> </tr> </tbody> </table> ## 引脚图参考 ![R329 pin](./assets/R329 pin.png) 摄像头接口图： ![camera_pin_order](./assets/camera_pin_order.png) ## 相关资料 [MaixSense 硬件资料](https://dl.sipeed.com/shareURL/MaixII/MaixII A) [极数社区 R329 上手帖](https://aijishu.com/a/1060000000221780) [极数社区 R329 芯片FAQ](https://aijishu.com/a/1060000000291439) [极数社区矽速科技](https://aijishu.com/blog/xisukeji)（很多资料） ## 产品技术支持 M2A 开发板可以在多种场景实现客户不同方面的需要，在 AIoT 上已经广泛的使用，品质和性能在行业内已经有非常好的口碑，专业的技术团队为广大客户解决硬件设计和软件功能上的各种各样问题。专业技术支持和更详细资料请联系商务<support@sipeed.com>。"},"/hardware/zh/maixII/M2A/R329.html":{"title":"芯片介绍","content":"# 芯片介绍 ## R329 全志 R329 双核 Cortex A53 处理器的 64 位，配备双 HIFI4 DSP 用于音频后处理和预处理，以及 Arm 中国的 AIPU（人工智能处理单元）以极低的功耗提供高达 0.256 TOPS。可以对神经网络进行硬件加速，驱动 720p 的摄像头。 ![R329框架](./assets/R329_1.png) 项目 参数 CPU Dual core ARM Cortex™ A53@1.5GHz<br>32KB L1 I cache + 32KB L1 D cache per core<br>256KB L2 cache DSP Dual core HiFi4@400MHz<br> 32KB L1 I cache + 32KB L1 D cache per core<br> 2MB SRAM NPU 搭载周易™Z1 AIPU，最大支持0.25TOPS@600MHz 内存<br>Memory 内置 DDR3 128MB<br> 支持 SPI Nand/Nor/eMMC Audio Supports 5 audio ADC and 2 audio DAC<br>Supports 5 analog audio inputs and 2 analog audio output<br>Up to 3 I2S/PCM controllers for Bluetooth and external audio codec<br>Integrated digital microphone, supports maximum 8 digital microphones Enthernet 10/100/1000 Mbps USB OTG \\* 1<br>Host \\* 1 SDIO SDIO 3.0 * 2 I2S I2S*3(I2S0, I2S1, S I2S0) SPI SPI*2(SPI0, SPI1) TWI TWI*3(TWI0, TWI1, S TWI0) GPADC 4 ch SCR SCR*1 PWM PWM*15(PWM[8:0], S PWM[5:0])"},"/hardware/zh/maixII/M2A/Usages-copy.html":{"title":"Armbian 配置及使用","content":"# Armbian 配置及使用 ## 配置网络 我们使用 `nmtui` 命令来配置 wifi ![202108051626](./assets/202108051626.gif) ## 新建用户 一般来说不使用root来登录linux系统，因为这样很容易把系统玩崩了。 因此新建一个用户来避免一直使用root账户来进行操作。 ```bash adduser xxx # 添加用户名为 xxx 的用户 # ... # 省略一些 log New password: # 新建用户密码 Retype new password: # 重新输入密码 # ... # 省略一些 log Enter the new value, or press ENTER for the default # 添加信息，或者直接按 ENTER 选择默认信息 # ... # 按五次 enter 选择默认即可 Is the information correct? [Y/n] y # 输入 y 完成创建 ``` 到这里我们就已经成功创建名称为 xxx 的用户了 ### 授予管理员权限 有时候用户需要使用到管理员权限，下面内容就是授予用户管理员权限 ```bash sudo nano /etc/sudoers # 修改 /etc/sudoers 文件。编辑器个人喜好 ``` 在文件里找到下面的内容 ```vim # User privilege specification root ALL (ALL:ALL) ALL ``` 在里面添加上 ```vim # User privilege specification root ALL (ALL:ALL) ALL xxx ALL (ALL:ALL) ALL ``` 接着保存后退出即可。 ## 使用SSH连接 想要使用 ssh 来连接板子的话需要板子里面存在的用户名称和密码。 默认的 root 用户没有密码， 所以想用 root 账户的话需要自己使用passwd命令自己添加密码； 使用串口连接板子后执行 ifconfig 来或许板子的 IP 地址。 接着就可以使用 ssh 来连接板子了。 用户也可以尝试使用 MobaXterm 这个软件来方便电脑与板子传输文件 ## MaixPy3 IDE 连接 只能通过远程连接来用 MaixPy3 IDE 连接 MaixSense ，使用有线连接会连接不上。 每个人的网络环境都存在差异，都可能存在连接不上的情况。 ### 准备 烧录好带有 MaixPy3 的 Armbian 系统 连接网络进行 MaixPy3更新，确保 MaixPy3 的版本大于 0.3.4。 运行 `ifconfig` 获取开发板的 IP 地址 ### 连接 在MaixSense上运行 `python3 c \"import maix.mjpg;maix.mjpg.start()\"` 启动板子上的远程 RPyc 服务 在电脑 IDE 中新建代码区，运行下面的代码来连接开发板 ```python $connect(\"192.168.43.44\") # 此处填入开发板的 IP 地址 import platform print(platform.uname()) ``` 运行输出结果如下： ![MaixPy3 IDE](./assets/MaixPy3 IDE.jpg) ## 设置时区 命令行中输入`armbian config`，选中Personal，再选择Timezone > Asia >Shanghai设置上海时间（Debian中没有北京时间），按住TAB键切换到ok，保存即可。\t\t ![202108062005](./assets/202108062005.gif) ## 设置中文显示 命令行中输入`armbian config`，选中Personal > Locales > 下滑到最下面，空格选中zh.GBK和zh.UTF 8,，然后勾选zh_CN.UTF8设置为系统默认语言，按住TAB键切换到ok，保存，exit退出，下载中文字体，`apt get install fonts wqy zenhei`，重启后系统环境就变成中文的了。 ![202108062054](./assets/202108062054.gif) ## 配置蓝牙 打开`armbian config`，选中Network，选择BTinstall安装蓝牙支持包。 ![202108071034](./assets/202108071034.gif) 可以使用Xftp传输，安装完毕后断电重启即可。 然后就可以使用Bluetoothctl配置蓝牙。 常用命令： ```bash devices \t\t列出活动的蓝牙设备 paired devices \t\t列出已配对蓝牙设备 pairable <on/off> \t\t是否允许配对 discoverable <on/off> 是否允许被发现 discoverable timeout [value]设置暴露时间 pair [dev] 配对设备 trust [dev] 信任设备 untrust [dev] 取消设备信任 remove <dev> 移除设备 connect <dev> 连接设备 disconnect [dev] 断开设备连接 quit 退出 help \t\t\t\t查看帮助 ``` ### 连接蓝牙设备 使用`bluetoothctl`连接蓝牙设备。 ```bash scan on #扫描设备 scan off #停止扫描 trust XX:XX:XX:XX # 信任设备 pair XX:XX:XX:XX #配对设备 connect XX:XX:XX:XX #连接设备 ``` ![202108071610](./assets/202108071610.gif) ### 设置蓝牙音频输入/输出 启用蓝牙音频前，需要先安装`pulseaudio`即及蓝牙组件 ```bash sudo apt install pulseaudio sudo apt install pulseaudio module bluetooth ``` 然后使用pactl查看是否有蓝牙输出设备 ```bash pactl list short sinks ``` 切换音频输出到蓝牙 ```bash pactl set default sink <dev> ``` log如下： ```bash maixsense:~:# apt install pulseaudio maixsense:~:# apt install pulseaudio module bluetooth maixsense:~:# pactl list short sinks 0\talsa_output.platform 7032000.codec.stereo fallback\tmodule alsa card.c\ts16le 2ch 44100Hz\tSUSPENDED 2\tbluez_sink.00_26_04_00_73_B1.a2dp_sink\tmodule bluez5 device.c\ts16le 2ch 44100Hz\tSUSPENDED maixsense:~:# pactl set default sink 2 ``` ![202108071726](./assets/202108071726.gif) 然后就可以播放音频到蓝牙设备，或者通过蓝牙连接手机当作蓝牙音箱使用。 ## 配置音量 `alsamixer` ![202108071440](./assets/202108071440.gif) 常用命令 ``` Help xxEsc 离开 ▒x xxF1 ? H 帮助 ▒x xxF2 / 系统信息 ▒x xxF3 回放控制 ▒x xxF4 捕获控制 ▒x xxF5 所有控制 ▒x xxTab 切换显示模式 ▒x xxF6 S 选择声卡 ▒x xxL 刷新屏幕 ▒x xxLeft 移动到上一个的控制 ▒x xxRight 移动到下一个的控制 ▒x xxUp/Down 改变音量 ▒x xx+ 改变音量 ▒x xxPage Up/Dn 大幅改变音量 ▒x xxEnd 设置音量为0 ▒x xx0 9 从0到9依次设置音量 ▒x xxQ W E 增加 左/全部/右声道音量 ▒x xxZ X C 减少 左/全部/右声道音量 ▒x xxB 左右声道平衡 ▒x xxM 切换静音 ▒x x< > 切换左/右静音 ▒x xxSpace 切换捕获 ▒x xx; ' 切换左/右捕获 ▒x ``` 如果需要控制蓝牙设备音量，需要使用`pactl` ，并且`pcatl`也支持控制声卡，所以推荐使用此app控制音量。 ```bash ##查看输入/输出设备索引 pactl list short sources/sinks ##设置输入/输出音量 pactl set source/sink volume index volume pactl set default source/sink ##设置默认输入/输出 ``` 示例，设置蓝牙耳机为输出设备，音量为10%,然后增加20%，最后减少30% ```bash maixsense:~:# pactl list short sinks 0\talsa_output.platform 7032000.codec.stereo fallback\tmodule alsa card.c\ts16le 2ch 44100Hz\tSUSPENDED 2\tbluez_sink.00_26_04_00_73_B1.a2dp_sink\tmodule bluez5 device.c\ts16le 2ch 44100Hz\tRUNNING ##蓝牙设备一般为bluez_sink maixsense:~:# pactl set default sink 2 maixsense:~:# pactl set sink volume 2 10% maixsense:~:# pactl set sink volume 2 +8192 maixsense:~:# pactl set sink volume 2 0x3000 ##可选 百分比，十进制数，十六进制数控制，效果相同，并且可以超过100% ``` ## 媒体播放 媒体播放常用mplayer 下载mplayer > sudo apt install mplayer 然后执行 `sudo mplayer badapple_240p.mp4 vo fbdev2` 来播放视频 或者`sudo mplayer G.E.M.邓紫棋\\ \\ 光年之外.flac` 播放音频 在后面加上`< /dev/null > /dev/null 2>1 &`以便在后台播放 ```bash mplayer /root/badapple_240p.mp4 vo fbdev2 < /dev/null > /dev/null 2>1 & ``` ![202108091128](./assets/202108091128.gif) ## 编写c代码 ```bash vim helloworld.c #使用 vim 创建一个文件并打开 i #在vim中这个指令的意思是输入，之后就可以敲代码了 ``` 可以将下面的代码输入到刚刚新创建的文件中 ```c #include <stdio.h> int main() { printf(\"Hello, world\\n\"); return 0; } ``` 输完上面的代码后需要按下 esc 键来退出编辑模式 就这再输入 `:wq` 来保存文件且退出vim ```bash gcc hello.c o hello.o #编译C文件 ./hello.o #运行编译出来的C文件 ``` ![202108091201](./assets/202108091201.gif) ## 编写python代码 详细解释看上面的C代码样例 ```bash vim helloworld.py i print(\"hello world!\\n\") esc :wq python3 helloworld.py ``` ![202108091339](./assets/202108091339.gif) ## 使用python点亮第一个灯 安装GPIO的python支持库 ```bash pip install gpiod ``` 把led正极插入PH5,负极插入GND 编写代码 ``` bash vim led.py ``` 复制代码进去 ```python import time import gpiod as gpio PH_BASE (8 1)*32 # \"PH\" gpiochip1 gpio.chip(\"gpiochip1\") led gpiochip1.get_line((PH_BASE + 5)) # \"PH5\" config gpio.line_request() config.request_type gpio.line_request.DIRECTION_OUTPUT led.request(config) while led: led.set_value(0) time.sleep(1) print(\"led on\") led.set_value(1) time.sleep(1) print(\"led off\") ``` 执行代码 ```bash python3 led.py ``` 效果如下： ![202108091956](./assets/202108091956.gif) ## 运行神经网络实例 获取1000类物体分类模型 下载站链接[zhouyi_test.tar.xz](https://dl.sipeed.com/shareURL/MaixII/MaixII A/example),使用任意方式上传到板子中 ```bash tar Jxvf zhouyi_test.tar.xz #解压压缩包 cd zhouyi_test #打开解压后的文件目录 chmod 777 run.sh #授予执行权限 ./run.sh #执行1000类物体分类 ``` ## 设置开机启动 启用开机自启动脚本 ```bash vim /lib/systemd/system/rc local.service ``` 在最后面添加 ```bash [Install] WantedBy multi user.target Alias rc.local.service ``` 编辑自启动脚本 ```bash vim /etc/rc.local ``` 在`exit 0`前面添加需要启动的服务 然后重启即可 注意，此脚本会在用户登录前执行，执行日志如下 ```bash [ OK ] Finished Permit User Sessions. [ 38.569457] rc.local[1322]: hello world! ``` ## 更多的使用方法 请到[MaixPy3](/soft/maixpy3/zh/readme.md)和[极术社区](https://aijishu.com/a/1060000000221780)中自行查看"},"/hardware/zh/maixII/M2A/Hardware_test.html":{"title":"硬件测试","content":"# 硬件测试 ## 测试屏幕 可以使用`echo \"hello sipeed\" > /dev/tty0` 重定向信息到屏幕上。 <img src \"./assets/image 20210805150728052.png\" alt \"image 20210805150728052\" style \"zoom:50%;\" /> ## 测试摄像头 armbian 内置了 ffmpeg ，可以快速捕捉 sensor 数据并输出到屏幕上 使用如下命令快速捕捉 sensor 并输出到屏幕上 ffmpeg i /dev/video0 vframes 1 s 240*240 pix_fmt rgb565le vf transpose 2,transpose 2 f fbdev /dev/fb0 ![image 20210805165654537](./assets/image 20210805165654537.png) ## 测试网络 使用 `nmtui` 指令可以进入可视化的配网界面， 选择 Activate a connection ， 选择对应的 WIFI名称 ，输入连接密码，确认即可。 ![202108051626](./assets/202108051626.gif) 设置完毕后使用 ifconfig 查看本机操作，然后就可以使用 ssh 等操作了。 ![image 20210805162936212](./assets/image 20210805162936212.png) 也可以使用apt下载各种应用 ```bash sudo apt install neofetch armbian config ``` ![image 20210805165620823](./assets/image 20210805165620823.png) 如果遇到终端显示错位，还需要`sudo apt get install xterm`安装下xterm，然后`resize`即可。 ![202108061015](./assets/202108061015.gif) ## 测试AIPU 获取1000类物体分类模型 下载站链接[zhouyi_test.tar.xz](https://dl.sipeed.com/shareURL/MaixII/MaixII A/example),使用任意方式上传到板子中 ```bash tar Jxvf zhouyi_test.tar.xz #解压压缩包 cd zhouyi_test #打开解压后的文件目录 chmod 777 run.sh #授予执行权限 ./run.sh #执行1000类物体分类 ``` 识别出鼠标 <img src \"./assets/recognize_mouse.jpg\" alt \"识别鼠标\" style \"zoom:65%;\"> <br> 对于linux命令行，使用`Ctrl + C`来退出当前程序。"},"/hardware/zh/maixII/M2A/flash_system.html":{"title":"系统烧录","content":"# 系统烧录 ## 系统简介 Lichee MaixSense（以下简称R329）提供了以下两种系统镜像 名称 armbian Tina : : : 简介 专门用于ARM开发板的轻量级 Debian 全志魔改OpenWRT1404的系统 特点 主线化Linux，功能丰富 厂商魔改，比较精简 适用人群 极客，嵌入式入门玩家等 深度开发，需要自行定制等开发人员 > ！！！一定要严格按照步骤操作！！！armbian系统请使用大于 4G 的 TF/SD 卡进行烧录，Tina系统请使用大于 1G 的 TF/SD 卡进行烧录, 质量较差的启动卡会有糟糕的实际使用体验 对于 R329 芯片， 建议使用 Etcher 软件来烧录镜像。 ## 获取镜像 ### armbian 系统镜像 armbian 镜像获取： > 链接：[百度网盘](https://pan.baidu.com/s/1p4cCSFLIPVOnVXB_TT546g) 提取码：`r329` 其中以 maixpy3 开头命名的镜像文件的是已经装载了 MaixPy3 库和相关驱动的镜像包。 armbian 镜像所打包的方法为 [dd](https://baike.baidu.com/item/DD/2654972); 可以选用适合当前系统的 [Etcher](https://www.balena.io/etcher/ \"Etcher\") 软件来烧录。 ### Tina 系统镜像 Tina 系统需要自己进行编译，具体编译方式参考 [https://github.com/sipeed/R329 Tina jishu](https://github.com/sipeed/R329 Tina jishu) ## 烧录镜像 ### armbian 镜像烧录 #### 资源获取 下载[Etcher](https://www.balena.io/etcher/ \"Etcher\") #### 烧录步骤 首先解压所下载的镜像压缩包，得到 `.img` 镜像文件，打开 [Etcher](https://www.balena.io/etcher/ \"Etcher\") 软件，点击 `Flash from file` ,选中解压出来的 `.img ` 文件镜像，然后点击 `Select target` 选中sd卡，最后点击 `Flash` 进行烧录，等待完成即可。 下面只是用原始的 armbian 作为展示，有需求的话可也已选择下载带有 MaixPy3 的镜像文件。 ![burn](./assets/95133.gif) 最终下载结束后的效果会和下图一样，显示 `Flash Complete!`： ![下载结束](./assets/finish_flash.png) 如果烧录失败了，请手动格式化一下 sd 卡。Windows 和 MacOS 可以使用 [SD Card Formatter](https://www.sdcard.org/downloads/formatter/eula_windows/SDCardFormatterv5_WinEN.zip)来格式化 sd 卡，Linux 系统可以使用 [Gparted](https://gparted.org/)来格式化。 ### Tina 镜像烧录 Tina 系统的烧录方式和 MaixII Dock 通用，可参考[MaixII M2dock 烧录系统 Sipeed Wiki](./../M2/flash.html)，这里不多做介绍"},"/hardware/zh/maixII/M2A/ssh.html":{"title":"如何使用SSH","content":"# 如何使用SSH > 编辑于2022.04.29 这里讲一下怎么使用ssh，和一些常碰到的问题。 ## 简介 SSH 是较可靠，专为远程登录会话和其他网络服务提供安全性的协议。 通常我们用这个来远程登陆别的linux设备。 ## 用法 ### 目标设备进行的操作 #### 目标设备安装ssh 一般来说大多数设备都已经内置了ssh，但是对于需要的话一般可以用下面命令安装ssh. ```bash sudo apt install ssh y ``` #### 开启端口 修改 /etc/ssh/sshd_config 里面的 #22 为 22 . 一般来说这样就没啥问题了，有其他的问题的话先重启试试（解决99%的问题）。剩下1%的问题网上搜搜 ### 主机端操作"},"/hardware/zh/maixII/M2A/Usages.html":{"title":"基本使用","content":"# 基本使用 进行完前面的 [配置系统](./config_system.html) 后，我们已经成功登录到板子然后可以使用命令行来操作板子了。 ## 扩容系统 使用不含有 MaxiPy3 的系统镜像启动后会会自动扩容，可以跳过 `扩容系统` 这一步。 使用内置 MaxiPy3 的镜像系统不会自动扩充系统容量到最大值，因此需要执行一下 `/usr/lib/armbian/armbian resize filesystem start` 命令来扩容一下系统大小，会花费一下时间；执行时不要强行退出，执行完毕后会自动退回到终端 ## 连接网络 这里我们使用 `nmtui` 命令来配置 wifi ![202108051626](./assets/202108051626.gif) <details> <summary><font color \"#4F84FF\">点开查看图文版操作</font></summary> <p>命令行中输入 nmtui 来打开可视化 wifi 连接界面</p> <img src \"./assets/wifi/nmtui.png\" alt \"nmtui\"> <img src \"./assets/wifi/active_wifi.png\" alt \"active_wifi\"> <p>如上图所示我们选择 Activate a connection 来设置连接</p> <p>先择目标 wifi </p> <img src \"./assets/wifi/choose_wifi.png\" alt \"choose_wifi\"> <img src \"./assets/wifi/input_password_1.png\" alt \"input_password_1\"> <p>输入正确的密码</p> <img src \"./assets/wifi/input_password_2.png\" alt \"input_password_2\"> <p>会显示 connecting</p> <img src \"./assets/wifi/connect_wifi.png\" alt \"connect_wifi\"> <p>成功后会发现右边的 active 变成了 Deactive，到此基本说明已经连上了 wifi</p> <p>连接失败的话重新输入正确的 wifi 密码再尝试连接</p> <img src \"./assets/wifi/succeed_connecting.png\" alt \"succeed_connecting\"> <p>然后我们重新退出回命令行终端</p> <img src \"./assets/wifi/quit_connecting.png\" alt \"quit_connecting\"> <img src \"./assets/wifi/quit_nmtui.png\" alt \"quit_nmtui\"> <img src \"./assets/wifi/back_terminal.png\" alt \"back_terminal\"> <p>可以使用 ifconfig 命令来查看板子的 IP</p> <img src \"./assets/wifi/ifconfig.png\" alt \"ifconfig\"> <img src \"./assets/wifi/see_ip.png\" alt \"see_ip\"> <p>到这里看到了 IP 就说明已经连接上了(上图中的红框位置)</p> </details> ## 新建用户 一般来说不建议使用 root 来登录 linux 系统，因为这样很容易把系统玩崩了。 我们来新建一个用户来进行日常使用。这里我们使用 `adduser` 这个命令来添加用户。 添加用户名为 `xxx` 的用户 ```bash adduser xxx ``` 一些 log 显示完后会让我们设置密码： ```bash New password: Retype new password: ``` 成功设置密码后所显示的 log 会包括下面的内容。 ```bash passwd: password updated successfully ``` 接下来所有的都使用默认的即可（全部都 回车 确定就行） ```bash Enter the new value, or press ENTER for the default Full Name []: Room Number []: Work Phone []: Home Phone []: Other []: Is the information correct? [Y/n] ``` 到这里我们就已经成功创建名称为 xxx 的用户了。 使用命令 login 来登录刚刚新建的用户: ```bash login xxx ``` 想要退出登录的话使用命令 `logout` 就可以 ```bash logout ``` ### 授予管理员权限 有时候新建的用户需要使用到管理员权限来执行一些操作，下面内容就是授予用户管理员权限。 这里我们编辑 `/etc` 目录下的 `sudoers` 文件就可以修改相关权限。 ```bash sudo nano /etc/sudoers ``` 在文件里找到下面的内容 ```vim # User privilege specification root ALL (ALL:ALL) ALL ``` 在里面添加上 `xxx ALL (ALL:ALL) ALL`（其中xxx是你之前添加的用户名） ```vim # User privilege specification root ALL (ALL:ALL) ALL xxx ALL (ALL:ALL) ALL ``` 接着保存后退出即可。 ## 安装应用 这里我们使用安装 `armbian config` 为例。直接执行下面的命令即可 ```bash sudo apt install armbian config y ``` 上面的命令的意思是使用 root 权限来运行 apt 应用的 install 命令来安装 armbian config 且后面所有需要选择的内容均为 yes 选项 ## 设置时区 命令行中输入 `armbian config`，选中 Personal，再选择 Timezone > Asia >Shanghai 设置上海时间（Debian中没有北京时间），按住 TAB 键切换到 ok 后，保存即可。 在 `armbian config` 设置界面中一直按键盘上的 `Esc` 键也能有退出的效果。 ![202108062005](./assets/202108062005.gif) ## 设置中文显示 命令行中输入`armbian config`，选中Personal > Locales，下滑到最下面（可以试着使用键盘上的 `PageDown` 按键加快下滑），使用键盘空格键来选中 zh.GBK 和 zh.UTF 8 ，回车确认后再选择 zh_CN.UTF8 为系统默认语言，然后多次按下 `Esc` 键来退回到命令行终端界面。<! 执行命令 `sudo apt install fonts wqy zenhei` 来下载中文字体， > 然后使用 `reboot` 命令来重启后系统后就会发现命令行终端有中文显示了。 ![202108062054](./assets/202108062054.gif) ## 配置蓝牙 打开 `armbian config`，选中 Network，选择 BTinstall 安装蓝牙支持包。 ![202108071034](./assets/202108071034.gif) 然后就可以使用 Bluetoothctl 配置蓝牙。 <html> <details> <summary><font color \"#4F84FF\">点开查看常用命令</font></summary> <pre class \"line numbers language bash\"> devices 列出活动的蓝牙设备 paired devices 列出已配对蓝牙设备 pairable &lt;on/off&gt; 是否允许配对 discoverable &lt;on/off&gt; 是否允许被发现 discoverable timeout [value]设置暴露时间 pair [dev] 配对设备 trust [dev] 信任设备 untrust [dev] 取消设备信任 remove &lt;dev&gt; 移除设备 connect &lt;dev&gt; 连接设备 disconnect [dev] 断开设备连接 quit 退出 help 查看帮助 </pre> </details> </html> ### 连接蓝牙设备 使用 `bluetoothctl` 连接蓝牙设备。 ```bash scan on #扫描设备 scan off #停止扫描 trust XX:XX:XX:XX #信任设备 pair XX:XX:XX:XX #配对设备 connect XX:XX:XX:XX #连接设备 ``` ![202108071610](./assets/202108071610.gif) ### 设置蓝牙音频输入/输出 启用蓝牙音频前，需要先安装 `pulseaudio` 和蓝牙组件 ```bash sudo apt install pulseaudio sudo apt install pulseaudio module bluetooth ``` 然后使用 pactl 命令查看是否有蓝牙输出设备 ```bash pactl list short sinks ``` 切换音频输出到蓝牙，下面的 `<dev>` 在此处应该为 `2` ```bash pactl set default sink <dev> ``` log 如下： ```bash maixsense:~:# apt install pulseaudio maixsense:~:# apt install pulseaudio module bluetooth maixsense:~:# pactl list short sinks 0\talsa_output.platform 7032000.codec.stereo fallback\tmodule alsa card.c\ts16le 2ch 44100Hz\tSUSPENDED 2\tbluez_sink.00_26_04_00_73_B1.a2dp_sink\tmodule bluez5 device.c\ts16le 2ch 44100Hz\tSUSPENDED maixsense:~:# pactl set default sink 2 ``` ![202108071726](./assets/202108071726.gif) 然后就可以播放音频到蓝牙设备，或者通过蓝牙连接手机当作蓝牙音箱使用。 ## 配置音量 这里使用 `alsamixer` 这个应用来改变音量 ![202108071440](./assets/202108071440.gif) <html> <details> <summary><font color \"#4F84FF\">点开查看常用命令</font></summary> <pre> Help xxEsc 离开 ▒x xxF1 ? H 帮助 ▒x xxF2 / 系统信息 ▒x xxF3 回放控制 ▒x xxF4 捕获控制 ▒x xxF5 所有控制 ▒x xxTab 切换显示模式 ▒x xxF6 S 选择声卡 ▒x xxL 刷新屏幕 ▒x xxLeft 移动到上一个的控制 ▒x xxRight 移动到下一个的控制 ▒x xxUp/Down 改变音量 ▒x xx+ 改变音量 ▒x xxPage Up/Dn 大幅改变音量 ▒x xxEnd 设置音量为0 ▒x xx0 9 从0到9依次设置音量 ▒x xxQ W E 增加 左/全部/右声道音量 ▒x xxZ X C 减少 左/全部/右声道音量 ▒x xxB 左右声道平衡 ▒x xxM 切换静音 ▒x x< > 切换左/右静音 ▒x xxSpace 切换捕获 ▒x xx; ' 切换左/右捕获 ▒x </pre> </details> </html> 如果需要控制蓝牙设备音量，需要使用 `pactl` 。 因为 `pcatl` 也支持控制声卡，所以建议使用这个应用来控制音量。 ```bash ##查看输入/输出设备索引 pactl list short sources/sinks ##设置输入/输出音量 pactl set source/sink volume index volume pactl set default source/sink ##设置默认输入/输出 ``` 示例，设置蓝牙耳机为输出设备，音量为10%,然后增加20%，最后减少30% ```bash maixsense:~:# pactl list short sinks 0\talsa_output.platform 7032000.codec.stereo fallback\tmodule alsa card.c\ts16le 2ch 44100Hz\tSUSPENDED 2\tbluez_sink.00_26_04_00_73_B1.a2dp_sink\tmodule bluez5 device.c\ts16le 2ch 44100Hz\tRUNNING ##蓝牙设备一般为bluez_sink maixsense:~:# pactl set default sink 2 maixsense:~:# pactl set sink volume 2 10% maixsense:~:# pactl set sink volume 2 +8192 maixsense:~:# pactl set sink volume 2 0x3000 ##可选 百分比，十进制数，十六进制数控制，效果相同，并且可以超过100% ``` ## 媒体播放 媒体播放常用 mplayer 这个应用。 下载 mplayer ```bash sudo apt install mplayer y ``` 安装后我们需要把想要播放的文件传到板子上。 文件可以在[下载站](https://dl.sipeed.com/shareURL/MaixII/MaixII Dock/example)获取到下面的示例文件 这里可以用 [mobaxterm](../M2/tools/mobaxterm.html) 软件来使用无线网络把文件传输到板子上。 然后执行 `sudo mplayer badapple_240_60fps.mp4 vo fbdev2` 来播放视频或者 `sudo mplayer Short.mp3` 播放音频 ```bash mplayer badapple_240_60fps.mp4 vo fbdev2 ``` 想要退出的话使用键盘上的 `Ctrl+C` 组合键来退出。 也在在命令行后面加上`< /dev/null > /dev/null 2>1 &`以便在后台播放 ```bash mplayer badapple_240_60fps.mp4 vo fbdev2 < /dev/null > /dev/null 2>1 & ``` 上面的指令是在后台播放的。想要停止的话可以先使用 `fg` 命令来切换到任务，再使用 `Ctrl+C` 来终止程序 ![202108091128](./assets/202108091128.gif) 如果没播放成功的话，尝试增加设备音量（前文提过alsamixer）或者确认一下文件路径是否正确 ## 编写c代码 一般命令行都是用 vim 来作为编辑器。有兴趣的可以额外学习一下这款强大的编辑器 如果提示没有安装 vim 的话，可以使用命令 `sudo apt install vim y` 来安装 vim。 然后我们使用 vim 来新建一个名为 `helloworld.c` 的源文件 ```bash vim helloworld.c ``` vim 有命令模式（Command mode） ， 输入模式（Insert mode） 和 底线命令模式（Last line mode）。 新建文件后默认的模式为 命令模式，此时我们按下键盘上的 `i` 键可进入输入模式。 将下面的代码正常输入到文件内容中。 ```c #include <stdio.h> int main() { printf(\"Hello, world\\n\"); return 0; } ``` 然后使用键盘上的 esc 键来退出输入模式到命令模式， 然后使用 `:` 来进入底线命令模式，接着输入 `wq` 来保存文件且退出到命令行 然后接可以在命令行中使用 gcc 来编译我们的代码了。 如果没有 gcc 的话使用 apt 命令来安装一下。 有关 gcc 的详细说明请自行搜索。 ```bash gcc hello.c o hello.o ``` 结束编译后直接运行即可 ```bash ./hello.o ``` ![202108091201](./assets/202108091201.gif) ## 编写python代码 详细解释看上面的C代码样例 ```bash vim helloworld.py #新建一个python文件并且用vim打开 i print(\"hello world!\\n\") esc :wq python3 helloworld.py ``` ![202108091339](./assets/202108091339.gif) ## 使用 python 点亮第一个灯 首先安装 GPIO 的 python 支持库 ```bash pip install gpiod ``` 把 led 正极插入 PH5,负极插入 GND 创建 `led.py` 文件 ``` bash vim led.py ``` 将下面代码输入到所创建的文件中 ```python import time import gpiod as gpio PH_BASE (8 1)*32 # \"PH\" gpiochip1 gpio.chip(\"gpiochip1\") led gpiochip1.get_line((PH_BASE + 5)) # \"PH5\" config gpio.line_request() config.request_type gpio.line_request.DIRECTION_OUTPUT led.request(config) while led: led.set_value(0) time.sleep(1) print(\"led on\") led.set_value(1) time.sleep(1) print(\"led off\") ``` 保存退出到命令行终端后执行代码 ```bash python3 led.py ``` 效果如下： ![202108091956](./assets/202108091956.gif) ## 设置开机启动 需要会一些脚本语言。 首先启用开机自启动脚本，这里我们来编辑相关文件就可以修改相关设置。 ```bash vim /lib/systemd/system/rc local.service ``` 在最后面添加 ```bash [Install] WantedBy multi user.target Alias rc.local.service ``` 这样就成功启用了开机自启动脚本 接下来我们只需要把想要开机运行的内容添加到 rc.local 文件就可以了 编辑自启动脚本 ```bash vim /etc/rc.local ``` 在`exit 0`前面添加需要启动的服务 ```bash echo \"hello world!\" ``` 然后重启即可。 例如进行上面的修改后，此脚本会在用户登录前执行，执行示例日志如下 ```bash [ OK ] Finished Permit User Sessions. [ 38.569457] rc.local[1322]: hello world! ``` 要注意的是在开机脚本里面最好不要循环占用串口，这会导致我们无法再通过串口来操作板子。 ## 更多的使用方法 请到[MaixPy3](/soft/maixpy3/zh/readme.md)和[极术社区](https://aijishu.com/a/1060000000221780)中自行查看"},"/hardware/zh/maixII/M2S/V833.html":{"title":"M2S核心介绍","content":"# M2S核心介绍 ## V833 Chip V833智能视觉AI专用处理器是基于存算紧耦AI引擎的视频识别处理器，采用业界优秀的半导体工艺，创新突破了存算紧耦架构、神经网络权重量化技术、人脸检测技术和人脸图像质量评估技术、图像畸变矫正技术、图像防抖技术和可变帧率的编码技术等关键技术，有效地解决了神经网络计算复杂度高、网络性能差、人脸检测效率低和准确度不高、广角和鱼眼镜头的图像畸变、智能识别/安防产品功耗高等问题，综合技术水平达国内优秀水平，是一款能耗低、运算效率高、检测效率高、图像效果佳的人工智能视频识别处理器。 > 取至<http://www.elecfans.com/d/1557234.html> ![](./assets/V833.png) ## 参数 项目 参数 CPU 单核Cortex A7@1.2GHz Video encoder H.264, up to 5M@20fps<br>H.265, up to 5M@30fps <br>JPEG, up to 1080p@60fps NPU 0.4T EISE Up to 1080p@60fps SDRAM DDR2/DDR3/DDR3L SMHC SMHC x3 (SDcO, SDC1, SDC2) SPI SPI x3 (SPIO with 2 CS, SPIO supportsquad output/quad input SPl mode) LCD Parallel RGB, Serial RGB, i8080 DSPO BT1120,BT656 l2S l2S x2 (12S0,I2S1) Parallel CSI Support Ethernet 10/100/1000 Mbit/s Ethernet port with RGMll and RMll interfaces TWI TWI x5 (TWIO,TWI1,TWI2,TWI3,s_TwWIO) RSB support GPADC 2 ch Audio codec Output : LINEOUTP/N<br>Input: MICIN1P/N, LINEINL MIPI CSI 4 lane, up to 8M@30fps MIPI DSI Support Package LFBGA273 "},"/hardware/zh/maixII/M2S/reources.html":{"title":"M2S介绍","content":"# M2S介绍 MaixII S是基于 V833 芯片设计的一款【板卡】+【底板】的开发板产品。 ## 板卡 ![](./assets/M2s_Dock.jpg) > 资料[下载](https://dl.sipeed.com/shareURL/MaixII/MaixII A) ### 参数 项目 参数 CPU 全志 V833 Arm Cortex A7 1.2Ghz 主频 NPU 0.4TOPS 算力 内存 标配单片 16bit 128MB DDR3（可选最大 16bit 512MB DDR3） 存储核心板板载 128MB SD NAND（可选 512MB 和 4GB）底板板载 TF 卡座子，可扩展存储 摄像头接口MIPI：标配 200W 像素可见光摄像头(可选配宽动态摄像头)，76 度视场角<br>DVP：标配 30W 像素红外摄像头 补光灯接口 板载 2 个 DC DC 恒流降压驱动电路+2 个 2P 1.25mm 卧贴母座 <br>（每路最大驱动能力达到 5V 0.5A） 显示屏幕接口 MIPI：默认引出 4 lane MIPI 接口，已适配 5 寸和 7 寸屏 触摸屏接口 6P 0.5mm FPC 座子：可以连接电容触摸屏或者电阻触摸屏，目前已适配 GT911 音频接口 板载 3W 单声道音频功放，有 2P 1.25mm 卧贴母座可以连接喇叭 <br>板载驻极体麦克风电路，有 2P 1.25mm 卧贴母座可以连接麦克风 以太网 板载百兆 PHY 和百兆网口变压器，有 6P 1.25mm 卧贴母座可以连接以太网口 继电器 板载继电器，触电切换能力 2A 30VDC RTC 实时时钟 板载专用 RTC 芯片+1220 纽扣电池座子 按键 • 复位按键<br>• FEL 按键（进入下载模式）<br>• 2 个用户可编程按键（可以用作防拆报警键等自定义功能） 扩展接口 <br>• 4P 座子：1 组 UART、1 组 485、1 组 USB、1 组 IIC<br>• 9P 座子：2 个供电引脚+2 个继电器引脚+1 个按键的 2 引脚+2 个信号引脚<br>• 9P 座子：7 个信号引脚（可以复用为 1 组 SPI 总线+多个 CS 脚）+2 个电源引脚<br>• 9P 座子：6 个信号引脚+3 个电源引脚 ## 产品技术支持 M2S开发板可以在多种场景实现客户不同方面的需要，在AIoT上已经广泛的使用，品质和性能在行业内已经有非常好的口碑，专业的技术团队为广大客户解决硬件设计和软件功能上的各种各样问题。专业技术支持和更详细资料请联系商务<support@sipeed.com>。"},"/hardware/zh/maixII/M2/introduce.html":{"title":"芯片平台介绍","content":" title: 芯片平台介绍 keywords: MaixII, MaixPy3, Python, Python3, M2dock desc: maixpy 芯片平台介绍 V831 芯片介绍 从 2019 年至今的时间，可以开始看到几个相机 SoC 与一个内置的转专业或 SIMD 指令加快人脸检测、物体检测等等，从低分辨率 Kendryte K210 处理器 2.5 k Ingenic T31 MIPS 视频处理器，甚至 4k 能力 iCatch V37 相机 SoC 。 Allwinner 过去推出了几个摄像头处理器(V3， V316， S3…)，但没有一个包含 NPU (又名 AI 加速器)。现在这已经改变了，Allwinner V831 Cortex A7 全高清摄像头 SoC 还包括一个小的 200 GOPS NPU 。 > 取自 [allwinner v831 ai full hd camera soc powers sochip v831 development board](https://www.cnx software.com/2020/04/28/allwinner v831 ai full hd camera soc powers sochip v831 development board/) ## v831 Chip ![V831_struct.png](./asserts/V831_struct.png) ## 参数表 项目 参数 备注 CPU 最高 800Mhz Video encoder H.264, up to 1080p@30fps</br>H265, up to 1080p@30fps</br>JPEG, up to 1080p@30fps NPU 0.2T EISE Up to 1080p@30fps SDRAM SIP 64MB DDR2 SIP封装（System In a Package系统级封装） SMHC SMHC x2 (SDC0, SDC1) 主机控制器（SMHC）接口；物理层规范V2.0，SDIO卡规范V2.0 SPI SPI x2 (SPI0, SPI1) LCD Serial RGB, i8080 DSPO BT656 I2S I2S x1 (I2S0) Parallel CSI No support Ethernet 10/100 Mbit/s Ethernet port with RMII TWI TWI x4 (TWI0, TWI1, TWI2, TWI3) RSB No support GPADC 1 ch Audio codec Output: LINEOUTP</br>Input: MICIN1P/N MIPI CSI 2 lane, up to 1080p@60fps MIPI DSI No support Package QFN88 [V833／V831 Datasheet V1.0.pdf](https://linux sunxi.org/images/b/b9/V833%EF%BC%8FV831_Datasheet_V1.0.pdf) ## 产品技术支持 M2dock开发板可以在多种场景实现客户不同方面的需要，在AIoT上已经广泛的使用，品质和性能在行业内已经有非常好的口碑，专业的技术团队为广大客户解决硬件设计和软件功能上的各种各样问题。专业技术支持和更详细资料请联系商务。"},"/hardware/zh/maixII/M2/flash.html":{"title":"MaixII-Dock 烧录系统","content":" title: MaixII Dock 烧录系统 keywords: MaixII, MaixPy3, Python, Python3, M2dock desc: maixpy MaixII M2dock 烧录系统 update: date: 2021.03.20 author: dls content: 新建文档，开始编写内容 date: 2021.12.8 author: Rui & 点灯鼠 content: 整理并更新烧录方式 date: 2022.3.8 author: Rui content: 修改烧录的注意事项 date: 2023.7.31 author: Neucrack content: 精简描述， 解决修复 livesuit 无法使用的问题 > 注意事项！ > 烧录会清空 TF 卡中所有数据，有重要数据请提前备份 > 部分 AMD 平台的电脑存在无法烧录的情况 > 少部分 TF 卡可能无法烧录镜像，建议用户购买官方的镜像 TF 卡 ## 烧录系统简介 因为 MAIX II 的芯片是 V831，需要运行一个操作系统（Linux），软件都是在这个操作系统的基础上运行的。 所以我们需要学会如何烧录系统（/升级系统），方便更新系统和出现问题时重刷系统。 ## 获取系统镜像文件 从[下载站](https://dl.sipeed.com/shareURL/MaixII/MaixII Dock/SDK/release)获取最新的 V831 系统镜像,得到一个压缩包，解压之后就得到一个 .img 文件，这个就是系统镜像文件 > 如果下载站下载的很慢，建议使用百度网盘进行下载，下载站的下载带宽有限。链接：[点我](https://pan.baidu.com/s/1vCExI3_48Q90JrxO70JdiQ) ### 系统镜像文件命名说明 比如 `v831 m2dock maixhub 0.5.1 20220701.zip`和 ` v831 m2dock maixpy3 0.5.1 20220701.zip`： 名称 含义 maixhub 0.5.1(推荐) 此镜像是内置了 [MaixPy3](https://wiki.sipeed.com/maixpy3)`0.5.1`的版本，且内置 [maixhub app](https://maixhub.com/app/1) maixpy3 0.5.1 此镜像是内置了 [MaixPy3](https://wiki.sipeed.com/maixpy3)`0.5.1`的版本，但其中 **无** 内置 [maixhub app](https://maixhub.com/app/1) > 注意点： > * 上述镜像均为开源版，如果需要从 Flash 启动而不是从 TF 卡启动的镜像，请联系 support@sipeed.com 获取商业支持。 > * 内置 maixhub app 的镜像就是没有内置 maixhub app 版本在 `/root/app` 放置了 [maixhub app](https://maixhub.com/app/1) ## Windows 上使用 PhoenixCard 烧录镜像 PhoenixCard 是用来烧录全志科技芯片的工具，前者通过 USB 烧录到板载的 flash，后者用于烧录镜像到 TF 卡中。 PhoenixSuit 和 PhoenixCard 是常用来烧录全志科技芯片的两种工具，前者通过 USB 烧录到板载的 flash，后者用于烧录镜像到 TF 卡中。 零售开源版的 M2 模组上没有焊接 Flash，因此需要使用 TF 卡来作为启动介质，需要用 PhoenixCard 烧录镜像到 TF 卡中来启动 ### 准备工作 1. 烧录工具 [PhoenixCard](https://dl.sipeed.com/shareURL/MaixII/MaixII Dock/SDK/tools) 2. 系统 [镜像](https://dl.sipeed.com/shareURL/MaixII/MaixII Dock/SDK/release) 3. 内存卡格式化工具 [SD Card Formatter](https://www.sdcard.org/downloads/formatter/eula_windows/SDCardFormatterv5_WinEN.zip) ### 系统烧录 1. 将内存卡通过读卡器接到电脑的 USB 口，如果弹出格式化通知的话，点击取消即可 ![windows_format_tf](./asserts/windows_format_tf.png) 2. 打开 SD Card Formatter 软件，对内存卡进行格式化。Refresh（刷新）后点击Format（格式化），注意不要格式化错了分区。 ![image 20210802102810041](./../../../assets/maixII/V831/image 20210802102810041.png) 3. 打开PhoenixCard 选择 `启动卡` 选项 选择正确的盘符 点击 `烧卡` 根据状态栏的颜色可以判断烧录结果：红色的话说明烧录失败了，建议使用[SD card Formatter](https://www.sdcard.org/downloads/formatter/eula_windows/SDCardFormatterv5_WinEN.zip)格式化后再重新烧录一次；绿色表示则一切正常。 ![image 20210802104155132](./../../../assets/maixII/V831/image 20210802104155132.png) ## Linux(Ubuntu) 使用 Livesuit 烧录 ### 安装烧录工具 Livesuit > **每次更新系统 linux kernel 之后需要重新安装软件** 1. 安装依赖 dkms ```shell sudo apt install dkms ``` 1. 安装 libpng1.2（一定要使用这个版本） ```shell wget http://archive.ubuntu.com/ubuntu/pool/main/libp/libpng/libpng_1.2.54.orig.tar.xz tar xvf libpng_1.2.54.orig.tar.xz ``` ```shell cd libpng 1.2.54 ./autogen.sh ./configure make j8 sudo make install ``` 更新链接库: ```shell sudo ldconfig ``` 1. 安装 **livesuit** ```shell git clone https://github.com/linux sunxi/sunxi livesuite.git cd sunxi livesuite cd awusb sudo dkms install . ``` > **问题1**： 报错`make[2]: *** 没有规则可制作目标“arch/x86/entry/syscalls/syscall_32.tbl”，由“arch/x86/include/generated/uapi/asm/unistd_32.h” 需求。 停止。`的话， > 参考[issue](https://github.com/linux sunxi/sunxi livesuite/issues/17)修改Makefile的 `SUBDIR`字符为`M`就可以编译通过的到`ko`文件。 > > **问题2**： 遇到`module: x86/modules: Skipping invalid relocation target, existing value is nonzero for type 1, loc 0000000094ea3f48, val ffffffffc2034d37` > ``` > sudo apt update && sudo apt upgrade > sudo apt remove purge linux headers * # 可以具体一个一个移除 > sudo apt autoremove && sudo apt autoclean > sudo apt install linux headers `uname r` > ``` 保证`sudo dkms install .`成功执行 ``` cd .. chmod +x LiveSuit.sh sudo ./LiveSuit.sh ``` **注意一定要加 sudo** ### 使用 Livesuit 烧录 `sudo livesuit` 打开烧录工具，并点击“固件”选择镜像文件 ![](./asserts/flash_15.png) 不插入 SD 卡，将 V831 USB OTG 接口连接到 PC, 提示是否格式化分区，这时候插入 SD 卡，之后点击 `YES` ![](./asserts/flash_17.png) 等待烧录完成，提示“固件升级成功”，即可断开 USB ，至此固件烧录完毕 ![](./asserts/flash_19.png) ![](./asserts/flash_21.png) ## 其它 ### 烧录系统到 flash 中 [烧录方式](./no_sd_flash.html) ### 无读卡器烧录方式 [烧录方式](./PhoenixSuit.html) ### 使用 dd 烧录 官方没有做 MaixII Dock 的 dd 镜像相关支持，可以自己烧录到 TF 卡后，用读卡器在电脑上自行制作。 > 这里有个不算完美方法的[参考](https://www.cnblogs.com/USTHzhanglu/p/15431249.html)。"},"/hardware/zh/maixII/M2/usage.html":{"title":"Maix-II Dock 基础使用","content":" title: Maix II Dock 基础使用 ## 连接电脑 <img src \"./asserts/m2dock.jpg\" height 350> 如图，有两个 Type C 口，一个 `USB UART`，一个 `USB OTG`。 两者都可以给板子 5V 供电。 `USB UART` 是 板子的系统交互串口转 USB，连接此接口可以通过电脑的串口终端工具和开发板交互。 `USB OTG` 是 `USB` 从机接口，连接此接口可以通过电脑的 `adb` 工具和开发板交互。 在前面文档中已经烧录了系统，现在只需要讲电脑与板子`USB OTG`口连接起来即可，等待开机，等一会儿，电脑会出现一个 `U盘`。 > 如果开发板屏幕已经有画面了，但是电脑没有弹出 U盘，可以在电脑`设备管理器`中卸载`Android Device` > `Android ADB Interface`，注意勾选`删除此设备的驱动软件`。 > 如果还没出现则拔掉开发板重新插上尝试，一般都是 `ADB` 驱动问题。 > ![](/news/MaixPy3/v831_usage/assest/adb.jpg) > ![](/news/MaixPy3/v831_usage/assest/delete.jpg) 在 U盘 里面我们可以看到一个 `app` 文件夹，默认是[MaixHub APP](https://maixhub.com/app/1) 应用，上电会自动执行`app`目录下的`main.py`或者`main.sh`文件，可以在此目录下替换自己的应用。 > 在给开发板断电前，一定要记得**弹出 U盘**，否则会损坏开发板文件系统导致文件系统只读（只读后可以通过烧录系统来恢复）。 ## 在 Linux shell 执行命令 保证前面 U盘 会出现的情况下，我们可以通过 ADB 来和开发板进行交互。 ADB 程序在 windows 下需要手动安装， Linux 或者 MacOS，一般直接内置 adb 命令。 Windows 安装 ADB 有两种方法： 1. 直接下载 [ADB driver](https://adbdriver.com/downloads/) 安装（不需要使用 Python 开发可以用这种方式）。 2. 直接安装 [MaixPy3 IDE](https://dl.sipeed.com/shareURL/MaixII/MaixPy3 IDE)([百度网盘连接](https://pan.baidu.com/s/1d5zbIDSOBUvIta_rRhLx_A)) 会同时自动安装 adb 驱动。 然后键盘`Win+R`输入 `cmd`进入终端，输入`adb shell`即可进入开发板的 shell 环境。 然后我们就可以执行`Linux`命令了，比如`ls`查看目录下文件，`cd /root`进入到`/root`目录，执行`Python`文件用`python3 main.py`等。 比如我看看`/root`目录下有什么文件： ```bash root@sipeed:/# ls /root app ``` 可以看到和 U盘一样的 `app` 文件夹。 > 更多 Linux 常用命令可自行学习，注意 这里的 Linux 实际上是一个定制版本的 OpenWrt 系统，叫作 Tina Linux，所以有些命令和 PC 的 Linux 可能会有写差异。 ## 通过串口与 shell 交互 除了通过 ADB 交互，开发板的另一个串口也可以用来交互。 * 板子 USB UART 口连接电脑 * 使用串口终端软件，比如 putty 或者 mobaxterm， 具体教程查看【<a href 'https://wiki.sipeed.com/hardware/zh/maixII/M2/tools/mobaxterm.html' target _blank>如何使用 mobaxterm</a>】 ![mobaxterm_connect](./asserts/usage/mobaxterm_connect.png) ## Python 开发 ### Hello world 通过上面的终端交互的方法： ``` cd /root vim hello.py ``` 然后输入`i`进入编辑模式，输入下面的代码： ```python print(\"Hello world\") ``` 然后按`ESC`退出编辑模式，输入`:wq`保存并退出。 然后执行`python3 hello.py`即可看到输出`Hello world`。 ### MaixPy3 开发 MaixPy3 提供了大量的易用 API，这里可以先测试一下摄像头和屏幕： 基于上面的 hello world 代码，我们创建一个`camera_show.py`： ```python from maix import camera, display while 1: img camera.capture() display.show(img) ``` 在执行代码之前，确保屏幕和摄像头没有程序在使用，比如默认的`MaixHub APP`，可以操作按钮选择`退出`功能来退出`MaixHub APP`。 然后在终端执行`python3 camera_show.py` 就可以在屏幕看到摄像头的画面了。 更多使用方法参考 [MaixPy3 文档](/maixpy3) ## M2Dock 联网 M2Dock 带有 2.4G 无线模组，可以用来连接 2.4G 频段的无线网络。 **推荐**：可以用 [MaixHub APP](https://maixhub.com/app/1) 扫码连接。 也可以通过以下方式在命令行连接。 v0.5.4 版本系统镜像和之前的镜像联网方法未兼容，根据烧录的镜像版本选择对应的联网方法： * v0.5.4 .. details::, 点击展开 在 0.5.4 的镜像中，移除了之前编辑配置文件然后再连接网络的方法，改为用命令行来连接无线网络。 可以看到板子中内置了许多 wifi 相关的命令（按 TAB 补全剩余命令，没有就自己手动敲完整） ![wifi_test_command_list](./asserts/usage/wifi_test_command_list.jpg) 这里只使用 `wifi_connect_ap_test` 命令来连接无线网络，在使用之前可以先直接执行 `wifi_scan_results_test` 命令来扫描周围网络，确定板子可以识别到目标无线网络。 使用下面的命令来连接名称为 `Sipeed_Guest`， 且密码为 `qwert123` 的无线网络。 ```bash wifi_connect_ap_test Sipeed_Guest qwert123 ``` ![wifi_test_connect_wireless](./asserts/usage/wifi_test_connect_wireless.jpg) 在连接的信息中可以看到 `192.168.3.158` 这串数字，这是板子在当前网络环境中的 IP 地址。 执行 `ifconfig` 命令可以看到 wlan0 的 IP 地址为 `192.168.3.158`，与连接 WiFi 时候的信息一样。 ![wifi_test_ifconfig](./asserts/usage/wifi_test_ifconfig.jpg) * v0.5.4 前 .. details::, 点击展开 开发板上的 OTG 接口与电脑连接之后，就会在资源管理器中得到一个 U 盘 设备。通过编辑器打开里面名为 `wpa_supplicant.conf` 文件 ![wap_conf_png](./asserts/usage/wap_conf.png) 可以看到里面有 `yourWIFIname` 和 `yourWIFIpassword` 两项，将他们更改成你想要连接的无线网络和对应的无线网络密码并保存后，使用电脑系统自带的弹出 U 盘操作方式来移除 U 盘，这样可以避免损坏 U 盘的文件系统。接着在 m2dock 命令行终端执行 `reboot` 命令来重启板卡，开机后就自动连接 WiFi 了。 ![wap_conf_gif](./asserts/usage/wap_conf.gif) ## Opkg 软件包管理器 在命令行可以通过包管理器命令安装新的软件。 Opkg 是一个轻量快速的套件管理系统，类似 Ubuntu 下面的 apt 工具， 目前已成为 Opensource 界嵌入式系统标准。常用于 路由、 交换机等 嵌入式设备中，用来管理软件包的安装升级与下载。 ### 相关常用命令 opkg update 更新可以获取的软件包列表 opkg upgrade 对已经安装的软件包升级 opkg list 获取软件列表 opkg install 安装指定的软件包 opkg remove 卸载已经安装的指定的软件包 例如： ```bash root@sipeed:/# opkg list MaixPy3 0.2.5 1 alsa lib 1.1.4.1 1 busybox 1.27.2 3 busybox init base files 167 1612350358 ca certificates 20160104 curl 7.54.1 1 dropbear 2015.71 2 e2fsprogs 1.42.12 1 eyesee mpp external 1.0 1 eyesee mpp middleware 1.0 1 eyesee mpp system 1.0 1 ``` ## Python 包管理器 [pip](https://pypi.org/project/pip/) 是 Python 包管理工具，该工具提供了对 Python 软件包的查找、下载、安装、卸载的功能。 ### pip换源 对于国内可能只接访问 pypi.org 速度比较慢，用国内的镜像源可以加速 pip 安装。 ### 临时使用 ```python pip install i https://pypi.tuna.tsinghua.edu.cn/simple package name ``` package name 更换成你想要安装的包名 ### 设为默认 升级 pip 到最新的版本 (> 10.0.0) 后进行配置： ```python pip install i https://pypi.tuna.tsinghua.edu.cn/simple pip U ``` 设置清华镜像源为默认： ```python pip config set global.index url https://pypi.tuna.tsinghua.edu.cn/simple ```"},"/hardware/zh/maixII/M2/tools/mobaxterm.html":{"title":"如何使用 mobaxterm","content":" title: 如何使用 mobaxterm keywords: Jupyter, MaixPy3, Python, Python3 desc: maixpy 如何使用 mobaxterm ## mobaxterm 是什么？ 这是在 Windows 下使用的全能终端管理软件，对开发与运维人员必备，可以在 [mobaxterm.mobatek.net/download](https://mobaxterm.mobatek.net/download.html) 获取免费版本使用，在国内网站上有中文版。 ![](https://mobaxterm.mobatek.net/img/moba/features/feature terminal.png) 主要通过它提供的下列功能： serial 通过串口连接 Linux 系统的终端 ssh 远程登录 Linux 系统的终端 ftp 远程访问文件服务上的资源 ## 连接 串口(Serial) 开源硬件产品大多都会预留串口（Serial）用作 Linux 系统的终端交互接口，下面介绍串口【session】的创建。 ![](./asserts/mobaxterm serial 4.png) 在「session setting」 对话框里选择【serial】，再选好串口号及波特率，点击【OK】就完成连接了。 ![](./asserts/mobaxterm serial 5.png) 同样【session】会保存在左侧的【session】标签页里，方便下次连接。 ## 连接 SSH 除了有线串口的方式，还可以通过无线访问 SSH 登录 Linux 系统。 在板子终端输入 `hostname I` 查看自己 ip 地址 (先连上网)，然后输入自己用户名和密码。 ```bash root@maixsense:~# hostname I 192.168.0.197 ``` 然后我们就可以来新建SSH会话然后远程登录到板子了 新建SSH会话 ![](./asserts/mobaxterm_ssh.jpg) 登录到板子终端 ![](./asserts/mobaxterm_ssh_login.png) > 输入密码的时候是看不到的（没有输入显示），在输入结束之后，按回车即可 就可以看到 Linux 的登录会话终端了。 传输文件的时候可以直接把文件拖入或者拉出下图的左红框中。 ![](./asserts/mobaxterm_ssh_view.jpg) ## 连接 FTP 与 SSH 同理。 ![](./asserts/mobaxterm_ftp.png) 进入后就可以看到文件夹了。 ![](./asserts/mobaxterm_ftp.jpg) 可以拖拽文件上传和下载。 ![](./asserts/mobaxterm_ftp_ud.png) <a href \"#\" onClick \"javascript :history.back( 1);\">返回上一页(Back)</a>"},"/hardware/zh/maixII/M2/tools/vscode.html":{"title":"如何使用 vscode","content":" title: 如何使用 vscode keywords: vscode, MaixPy3, Python, Python3 desc: maixpy 如何使用 vscode ## 前言 它是微软出品的一款可扩展的轻量级开源编辑器，并且支持全平台系统。这些特性使得 VSCode 颇受欢迎，这也使其成为了一个很棒的 Python 开发平台。 关于如何安装和使用它的教程已经数不胜数，这里只推荐[【用 VSCode 愉快地写 Python 代码】](https://zhuanlan.zhihu.com/p/66157046)。 ## 为什么要使用它？ 除了专业 Python 代码开发环境，它还支持打开 jupyter notebook 文档运行代码。 与浏览器运行的 jupyter notebook 一样，执行 Python 代码的时候要选择对应的执行核心，如 [ipython/ipykernel](https://github.com/ipython/ipykernel) 或者 [rpyc_ikernel](https://github.com/sipeed/rpyc_ikernel) 的核心。 下面就来说说如何使用它。 ### 创建 notebook 文档 ![](https://tukuimg.bdstatic.com/scrop/abb1e4146fb8679109fa99aa0b03f59f.gif) ### 运行 Python 代码 ![](https://tukuimg.bdstatic.com/scrop/a1e2381bfac1a332a323774ee1b49c9f.gif) ### 运行后预览图表 ![](https://tukuimg.bdstatic.com/scrop/9c5bf21507c776f98d55bcfc0e51c5ff.gif) ## 你可以学到什么？ 在 VS Code 中使用 Jupyter 笔记本时需要进行的基本操作。如果您使用 VS Code 来满足其他开发需求，那么在 VS Code 中尝试使用 Jupyter Notebook 是非常方便的，这样您就可以只使用一个 IDE。特别是其代码自动补齐的功能可以让你的开发更快捷。 > 需要注意的是，截止 2021年3月3日 在 VSCODE 里的 jupyter notebook 文档进行中断存在一些问题，并不是很流畅，如果出现了运行无响应的问题可以重新打开文档解决问题。"},"/hardware/zh/maixII/M2/tools/adb.html":{"title":"adb 操作介绍","content":"# adb 操作介绍 ADB.exe 在 MaixPy3 IDE 中的 maixpy3_examples 和 PhoenixSuit 文件夹下 ## 链接开发板 将开发板上的 OTG 接口接上电脑， 然后再命令行中输入 adb shell，会自动进入到开发板的 linux 系统中 ```shell BusyBox v1.27.2 () built in shell (ash) run profile file __ ___ _ __ _ / / /__ _(_)_ __ / / (_)__ __ ____ __ / /_/ / _ `/ /\\ \\ / / /__/ / _ \\/ // /\\ \\ / /_/ /_/\\_,_/_//_\\_\\ /____/_/_//_/\\_,_//_\\_\\ root@sipeed:/# ``` 这时可以开始使用 MaixPy3 进行开发了"},"/hardware/zh/maixII/M2/tools/pyqt_rtsp.html":{"title":"如何使用 pyqt_rtsp","content":" title: 如何使用 pyqt_rtsp keywords: pyqt_rtsp, MaixPy3, Python, Python3 desc: maixpy 如何使用 pyqt_rtsp > 这是一个图传客户端工具，脱离 jupyter 的编程环境，使用的时候只需要在电脑上安装好就可以链接到硬件中获取图传信息。 ![](./asserts/pyqt_rtsp.png) 这个工具是通过 Python 实现的 rtsp + rtp 流媒体服务，支持文件、图像、显示器、摄像头的图像传输，适用于支持 Python3 的系统。 ## 安装方法 首先知道它是一个 C/S 结构图传客户端，你需要在某个硬件上安装 maixpy3 和启动服务，与之对应的客户端访问该硬件获取它的流媒体，这个硬件可以是你的嵌入式 linux 设备，也可以是你的 linux 计算机。 ### 服务端配置过程 在 linux 设备上安装 maixpy3 执行 maixpy3_rpycs 即可启动作为服务端。 ```bash (venv) $ pip3 install maixpy3 (venv) $ maixpy3_rpycs ``` ### 客户端配置过程 接着要在其他电脑上通过 Python 安装 [rtsp_pyqt](https://github.com/sipeed/MaixPy3/tree/main/examples/rtsp_pyqt) 客户端工具。 ```bash (venv) $ pip3 install r requirements.txt (venv) $ python3 mainLogic.py ``` ### 使用方法 运行后可见下图，然后输入 IP （如：192.168.0.127）进行链接： ![](./asserts/pyqt_rtsp_login.png) 按下【setup】链接到目标设备自动获取摄像头流，支持播放、暂停等操作，拍照和录像自动保存到目录下的文件夹。 ## 多余的讯息 > 如 IP 可以这样获取，我只是想炫耀一下我的拼装技术，逃~ ![](./asserts/rtsp_get_ip.jpg)"},"/hardware/zh/maixII/M2/PhoenixSuit.html":{"title":"MaixII M2dock 烧录系统","content":" title: MaixII M2dock 烧录系统 keywords: MaixII, MaixPy3, Python, Python3, M2dock desc: maixpy MaixII M2dock 烧录系统 > ！！！一定要严格按照步骤操作！！！请使用大于 1G 的 TF/SD 卡进行烧录，开源版本要求使用 TF/SD 卡来启动系统。 V831 为全志的 SOC， 所以 Windwos 使用 **PhoenixSuit**, Linux 上使用 **Livesuit** 烧录镜像文件。 从下载站获取最新的 V831 系统镜像 [SDK_MaixII/release](http://dl.sipeed.com/shareURL/MAIX/SDK_MaixII/release) ，找不到就搜索 V831 获取最新的镜像。 解压 V831 镜像压缩包，得到一个 xxxx.img 文件。 从网上获取 PhoenixSuit(Windows) 烧录工具。 [baidu PhoenixSuit](https://www.baidu.com/s?wd PhoenixSuit) [bing PhoenixSuit](https://www.bing.com/search?q PhoenixSuit&FORM BESBTB&mkt zh CN) [github PhoenixSuit](https://github.com/colorfulshark/PhoenixSuit) [lo4d PhoenixSuit](https://phoenixsuit.en.lo4d.com/windows) ## Windows 上使用 PhoenixSuit 烧录 解压 PhoenixSuit(Windows) 工具压缩包，不插入 SD 卡，将 V831 USB OTG 接口连接到 PC，打开设备管理器，安装驱动文件 ![](./asserts/flash_01.png) ![](./asserts/flash_03.png) 打开烧录软件, 并浏览打开镜像文件 ![](./asserts/flash_05.png) 重新插拔板子（上电不插入 SD 卡），软件提示是否要清空烧录，提示是否需要升级，点击 `YES` ![](./asserts/flash_07.png) 插入 sd 卡，提示是否强制格式化，再次点击 `YES`开始烧录（大约 40S） ![](./asserts/flash_09.png) 可能需要等待几秒才会更新状态，然后等待提示“固件升级成功”，即可断开 USB ，至此固件烧录完毕 ![](./asserts/flash_11.png) ![](./asserts/flash_13.png)"},"/hardware/zh/maixII/M2/other.html":{"title":"其他事项","content":" title: 其他事项 keywords: MaixII, MaixPy3, Python, Python3, M2dock desc: maixpy 其他事项 > 编辑于 2022年8月23日 这里讲述 V831 开发板的一些额外使用事项和相关解决方法 以下替换设备相关操作完成后，名称为 `maixhub` 的镜像里的 app 应用不再可用 ## 测试屏幕方法 请测试前观察系统上电后屏幕是否会闪烁一次；这表示屏幕已经通电、驱动起来，并对其复位（RST）后产生的。 在 Linux Shell 运行 `cat /dev/urandom > /dev/fb0` 就会输入随机数据到 fb0 产生雪花屏了，这表示屏幕显示是正常的。 <center><img src \"./asserts/lcd_test.jpg\" width \"400\"></center> <details> <summary>帧缓冲相关知识</summary> 帧缓冲（framebuffer）是 Linux 为显示设备提供的一个接口，把显存抽象后的一种设备。 它允许上层应用程序在图形模式下直接对显示缓冲区进行 读写操作。framebuffer 是 LCD 对应的一种 HAL（硬件抽象层），提供抽象的，统一的接口操作，用户不必关心硬件层是怎么实施的。这些都是由 Framebuffer 设备驱动来完成的。帧缓冲设备对应的设备文件为 /dev/fb*，如果系统有多个显示卡，Linux下还可支持多个帧缓冲设备，最多可达 32 个，分别为 /dev/fb0 到 /dev/fb31，而 /dev/fb 则为当前缺省的帧缓冲设备，通常指向 /dev/fb0，在嵌入式系统中支持一个显示设备就够了。帧缓冲设备为标准字 符设备，主设备号为 29 ，次设备号则从 0 到 31 。分别对应 /dev/fb0 /dev/fb31 。 </details> ## 切换屏幕 目前开发板支持的屏幕有 1.3寸、2.4寸、2.8寸 的 IPS 屏，且只是支持在[我们淘宝](https://sipeed.taobao.com/)上售卖的显示屏；对于别的屏幕有需求的，可以走商务通道进行定制。 ### 准备 需要切换的屏幕与对应的转接板 开发板 最新[系统镜像](./flash.html) ### 屏幕连接 开发板可以直接与 1.3寸 屏幕连接，但是与 2.4寸 或 2.8寸 屏幕连接的话需要使用转接板 转接板上的接口一个 1 的标识符，是来确保不被反插的。屏幕排线上的 1 要和转接板、开发板的上 1 相位置对应。 屏幕标识的 1 如下所示 <html> <img src \"./asserts/other/1.3.png\" width 45%> <img src \"./asserts/other/2.4.jpg\" width 45%> </html> 转接板上面的 1 如下所示 <img src \"./asserts/other/change.jpg\" width 600> 板子上的 1 如下所示 <img src \"./asserts/other/V831.jpg\" width 600> 具体接线参考下面两张图 <html> <img src \"./asserts/other/not connected.jpg\" width 45%> <img src \"./asserts/other/connected.jpg\" width 45%> </html> ### 切换设备树 update_dtb 程序是给 Allwinner tina linux 专门写的应用。 编译好的设备树文件，可以在[下载站](https://dl.sipeed.com/shareURL/MaixII/MaixII Dock/SDK/Toolchain)中进行下载 该设备树文件是通过内核编译出来的，不推荐个人用户自行编译。设备树文件命名规则如下： 文件名字 可用屏幕 可用摄像头 : : : : : : sipeed_2.8_240x320_vs3205.dtb 2.8寸 vs3205 sipeed_2.8_240x320_sp2305.dtb 2.8寸 sp2305 sipeed_2.4_240x320_vs3205.dtb 2.4寸 vs3205 sipeed_2.4_240x320_sp2305.dtb 2.4寸 sp2305 sipeed_1.3_240x240_vs3205.dtb 1.3寸 vs3205 sipeed_1.3_240x240_sp2305.dtb 1.3寸 sp2305 sipeed_1.3_240x240_ov2685.dtb 1.3寸 ov2685 将设备树文件存放到开发板中在电脑中显示的虚拟U盘中。 接着在 adb 终端里面执行下面命令 ```bash sync #刷新一下文件 update_dtb /dev/mmcblk0 /root/sipeed_240x240_vs3205.dtb reboot #重启设备来更新配置 ``` 即可切换设备树。 如果发现屏幕显示效果不对 说明选错了对应的设备树文件。重新换成正确的设备树即可 这里贴一张正常显示的图样 ![show](./asserts/show.jpg) ## 更换摄像头 目前 MaixII Dock 开发板目前支持的摄像头有 sp2305、vs3205、ov2685（只支持在官方店上再售卖的摄像头，有别的摄像头需求可以进行商务定制），摄像头之间的切换同样时需要更换设备树文件，更换方式上面的更换屏幕一样的。 ### 准备 需要切换的摄像头模块 开发板 最新的[系统镜像](./flash.html) 编译好的设备树文件，可以在[下载站](https://dl.sipeed.com/shareURL/MaixII/MaixII Dock/SDK/Toolchain)中进行下载 ### 连接摄像头 > **注意的是要摄像头的接法，不要把摄像头给接反了，摄像头的底板上有一个白点，开发板卡上也有一个白点，这两个白点要在同一边。如果接反了，摄像头烧毁了请自行再买一个吧** <html> <div class \"imbox\"> <img src \"./asserts/other/camera_outlook_1.jpg\" width 350 alt \"camera top\"> <img src \"./asserts/other/camera_outlook_2.jpg\" width 350 alt \"camera bottom\"> </div> </html> ### 切换设备树 > update_dtb 程序是给 Allwinner tina linux 专门写的小工具。 将设备树文件存放到开发板中在电脑中显示的虚拟U盘中。 接着在 adb 终端里面执行下面命令 ```bash sync #刷新一下文件 update_dtb /dev/mmcblk0 /root/sipeed_240x240_vs3205.dtb reboot #重启设备来更新配置 ``` 即可切换设备树，该设备树文件是通过内核编译出来的，不推荐个人用户自行编译 文件名字 可用屏幕 可用摄像头 : : : : : : sipeed_2.8_240x320_vs3205.dtb 2.8寸 vs3205 sipeed_2.8_240x320_sp2305.dtb 2.8寸 sp2305 sipeed_2.4_240x320_vs3205.dtb 2.4寸 vs3205 sipeed_2.4_240x320_sp2305.dtb 2.4寸 sp2305 sipeed_1.3_240x240_vs3205.dtb 1.3寸 vs3205 sipeed_1.3_240x240_sp2305.dtb 1.3寸 sp2305 sipeed_1.3_240x240_ov2685.dtb 1.3寸 ov2685 ## 编译链 在[下载站](https://dl.sipeed.com/shareURL/MaixII/MaixII Dock/SDK/Toolchain)里有一个名为 `toolchain sunxi musl pack 2021 01 09.tar.xz` 的文件，这是在 Linux 系统下为 V831 所使用的编译链。 有需求的可以自行尝试，但是对于 V831 还是推荐使用 MaixPy3 和 MaixHub。 ## 怎么样使用 USB 摄像头 M2Dock 有两个 TypeC 接口。其中一个标识有 UART，作为板子与电脑进行串口通信的接口。另一个口有 OTG 标识，默认是作为 USB 从机来使用的，比如我们能够在电脑上使用 `adb` 来操作 M2Dock 就是因为这个接口默认是从机模式。 需要注意的是 M2Dock 系统默认将 OTG 标识设置为 adb 设备，可以在 PC 端通过 `adb` 命令来操作板子，也可以通过使得电脑上的 jypyter 通过 `adb forward` 功能在板子上运行 python 代码。 想要连接摄像头，需要手动更改这个端口为主机模式。从板子上的 USB UART 来操作板子，并执行下面的命令就可以将 OTG 口作为主机模式使用。 要注意的是之子那个下面的命令后，板子上将与电脑通过 USB OTG 口进行通信。 ```bash echo \"usb_host\" > /sys/devices/platform/soc/usbc0/otg_role ``` 接着就能向通常的 linux 系统一样操作 /dev 目录下的摄像头了。 ## 如何将 USB OTG 口作为从机 M2Dock 默认的 OTG 口就是 USB 从机设备了，要是有因为其他原因需要重新设置成从机设备的话，在 M2Dock 上执行下面的命令就可以了。 ```bash echo \"usb_device\" > /sys/devices/platform/soc/usbc0/otg_role ```"},"/hardware/zh/maixII/M2/resources.html":{"title":"Maix-II-Dock(M2dock) 介绍","content":" title: Maix II Dock(M2dock) 介绍 keywords: MaixII, MaixPy3, Python, Python3, M2dock desc: 板级资源介绍 <div style \"font size: 1.2em;border: 2px solid green; border color:#c33d45;padding:1em; text align:center; background: #c33d45; color: white\"> <div> <div style \"height:0.4em\"></div> <span>全新硬件产品 MaixCAM，性能大升级，请看:</span> <a target \"_blank\" style \"color: #ffe0e0\" href \"https://wiki.sipeed.com/maixcam\"> https://wiki.sipeed.com/maixcam </a> </div> <div style \"padding: 1em 0 0 0\"> <a style \"color: white; font size: 0.9em; border radius: 0.3em; padding: 0.5em; background color: #a80202\" href \"https://item.taobao.com/item.htm?id 784724795837\">淘宝</a> <a style \"color: white; font size: 0.9em; border radius: 0.3em; padding: 0.5em; background color: #a80202\" href \"https://www.aliexpress.com/store/911876460\">速卖通</a> </div> </div> **Maix II V831 系列会被逐渐淘汰，如果你正准备购买 v831, 请立刻选择 MaixCAM;** **也欢迎 v831 用户升级到 MaixCAM** <br> <br> <br> <br> Maix II Dock 是一块精致小巧的 `AI` + `IOT` + `音视频处理` 开发板， 支持常规 Linux 开发的同时， 有特有的 **AI 硬件加速** 特性，配合 Sipeed 提供的易用的软件生态，快速让你的边缘 AI 应用落地。 Maix II Dock 已经集成了大量开箱即用的功能，比如 `AI 图像和物体识别`，`AI 语音识别`，`AI 人脸识别`，`AI 车牌识别`，`小车巡线`， 传统`OpenCV`支持，`常用硬件外设库`等等。 下面是部分功能展示视频： <p align \"center\"> <iframe src \"//player.bilibili.com/player.html?aid 298543445&bvid BV1sF411u7xb&cid 586467021&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\"> </iframe> </p> 常见应用场景：`STEM 和大学教育`, `工业流水线工具`，`智能家居`，`智能机器人`，`智能监控场景`等等。 **硬件**上， 基于全志 V831 芯片， 以【核心板】+【底板】的形式组成开发板，可以直接使用开发板，也可以只使用核心板根据需求自行设计底板，方便快速完成开发。 **软件**上， 除了可以直接使用全志提供的资料进行开发（部分可能需要找全志获取）外，Sipeed 提供了非常方便的 Python SDK（[MaixPy3](/maixpy3)）以及 C SDK （[libmaix](https://github.com/sipeed/libmaix)）。 **平台**上，提供在线模型训练服务（[MaixHub](https://maixhub.com)），方便刚入门也能无门槛快速训练 AI 模型。 **购买**：[sipeed.taobao.com](https://item.taobao.com/item.htm?id 635874427363) ## M2 核心板 22mm x 24.5mm 的尺寸，使用金手指引出引脚，体积小巧又方便开发。 <img style \"max height: 260px\" src \"./asserts/maix_v831.jpg\" alt \"core_board\"/> > 核心板硬件资料下载 [Sipeed_Maix_II_3101](https://api.dl.sipeed.com/shareURL/MaixII/MaixII Dock/HDK/Sipeed_MaixII_V831/Sipeed_Maix_II_3101) ### V831 芯片介绍 全志 V831, 单核 Cortex A7 800MHz， 64MiB 片内 DDR2 内存， 高性价比能跑 Linux 的SOC，同时支持硬件 AI 加速（0.2Tops 算力）(yolov2 45 ms ~ 60 ms)，可以当成普通 Linux SOC 使用， 也可以用于边缘 AI 应用， 更详细的参数请看手册和下文。 芯片手册： [V833／V831 Datasheet V1.0.pdf](https://linux sunxi.org/images/b/b9/V833%EF%BC%8FV831_Datasheet_V1.0.pdf) 内部结构图： <img style \"max height: 400px\" src \"./asserts/V831_struct.png\" alt \"V831 struct\"/> ### M2核心板参数 与 Maix I 对比 项目 Maix I (K210) Maix II (V831) 主控芯片<br> CPU 400~600Mhz 800~1000Mhz 视频编码器 <br>Video encoder None H.264, up to 1080p@30fps<br>H265, up to 1080p@30fps<br>JPEG, up to 1080p@30fps AI加速器<br>NPU 0.23TOPS（官方宣称 1TOPS 计算方法不同）<br>support Conv+BN+ACT+POOL 0.2TOPS<br>support Conv,Inner_Product,Pool,Eltwise,ACT,BN,Split,Concat 内存<br>Memory 8MB SRAM SIP 64MB DDR2 存储<br>Storage 16MB SPI Nor Flash 可选的16M flash(默认空贴) 摄像头<br>Camera DVP, 最高输入30W像素 2lane MIPI, 最高支持1080P@60fps 显示<br>Display 8bit MCU LCD 8bit MCU LCD, 配转接板可接最大10寸RGB LCD SDIO None SMHC x2 (SDC0, SDC1) SPI SPIx3 SPI x2 (SPI0, SPI1) I2C I2C x3 I2C x4 (TWI0, TWI1, TWI2, TWI3) I2S 8bit I2S I2S x1 (I2S0) Ethernet None 10/100 Mbit/s Ethernet port with RMII interface ADC None 1 ch 6bit LRADC for key Audio None LINEOUTP + MICIN1P/N 开发软件 Maixpy/C MaixPy3/C/linux ## 底板 一般情况下可以认为底板屏幕为正面，带摄像头为背面。 ![m2dock](./../../../assets/maixII/m2dock.jpg) > 底板硬件资料下载 [点我跳转](https://api.dl.sipeed.com/shareURL/MaixII/MaixII Dock/HDK/Sipeed_MaixII_Dock_V831) > 感谢热心网友分享的 [ M2 模块底板母座 PCB 封装](https://bbs.elecfans.com/jishu_2036119_1_1.html) ### 底板硬件参数 ![Pin](./asserts/M2Dock_pin.jpg) 标号 Maix II 部件 功能 备注 1 M.2 B KEY 母座*1 用于连接 V831 核心版 出厂已连接 2 核心板M2 铜柱螺母*1 用于配合 M2 螺丝固定 V831 核心板 出厂已固定 3 电源指示 LED 灯*1 用于指示底板是否正常通电 4 状态指示 LED灯*1 用户可编程LED灯，一般用于状态指示 5 CPU 复位键*1 按下可重启 V831 芯片 6 用户按键*2 可以控制两路 IO 电平，自定义功能 7 Wi Fi 模块*1 型号 RTL8189FTV，用于给模组提供 Wi Fi 功能 SDIO 接口 8 BTB 摄像头接口*1 用于连接 BTB 摄像头模块 出厂已连接 9 摄像头 M2 铜柱螺母*2 用于固定 BTB 摄像头 出厂已固定 10 FHD 摄像头*1 默认SP2305 Sensor BTB形式，1080P 默认含6mm焦距M12镜头，用户可选配其他焦距镜头 11 USB 转 UART 芯片*1 提供串口通信功能 出厂已烧录固件 12 Type C 接口(USB OTG) *1 用于 V831 的 USB OTG功能 可用于模组供电 13 Type C 接口(UART) *1 用于对V831通常的串口调试 可用于模组供电 14 三轴加速度传感器*1 I2C接口，可提供3轴的加速度数据 15 microSD 卡槽*1 用于外接 microSD卡 模组的系统默认从SD卡引导 16 LCD 接口*1 FPC0.5mm 24Pin，MCU 接口 17 IPS 高清屏幕\\*1 1.3寸IPS屏幕，分辨率240\\*240 出厂已连接 18 IPEX Wi Fi天线座 IPEX(一代) Wi Fi天线 19 外拓排母 引出 V831 的 通用IO口，可用于连接外设 20 扬声器接口*1 MX1.25 2P接口（间距1.25mm） 21 扬声器*1 8Ω1W 1609复合铝膜扬声器 出厂已连接 22 麦克风*1 模拟驻极体麦克风 ## 资源汇总 硬件: [MaixII 硬件资料库](https://api.dl.sipeed.com/shareURL/MaixII/MaixII Dock/HDK) 软件： * Python SDK： [MaixPy3 软件文档](/maixpy3) （Python 语法，有大量易用 API，适合上手开发） * C SDK: [libmiax](https://github.com/sipeed/libmaix) （适合高级开发者，另外要使用 OpenCV 也推荐使用此 SDK， Python 版本的 OpenCV 占用内存比较大，可能会导致内存不足） * MaixHub 模型平台（AI 模型下载、在线训练、项目分享）： [MaixHub](https://maixhub.com) * 全志 tina V83x SDK： [Tina Linux/tina V83x](https://github.com/Tina Linux/tina V83x) * 工具链： [dl.sipeed.com](https://dl.sipeed.com/shareURL/MaixII/MaixII Dock/SDK/Toolchain) 或者 [github](https://github.com/sipeed/libmaix/releases/download/v0.1.0/toolchain sunxi musl pack 2021 01 09.tar.xz) ## Maix II Dock 上手开发路线指南 * **烧录系统镜像**： 因为需要使用 Linux 系统（tina linux）， 所以需要先学习烧录系统镜像，就类似学会电脑重装系统一样，这样在遇到问题就可以重来，在左侧目录找到“烧录系统”文章查看 <! 这里不给烧录系统的链接，让用户学会查看左边目录 > * **基本 Linux 操作**： 学会基础的 Linux 操作，比如如何打开终端，基础的终端命令，以及如何传输文件到开发板等，比如 串口使用， adb 使用等等基础操作 * **选择开发语言**： * 如果你熟悉 C 有一定的开发经验，可以选择使用[libmaix](https://github.com/sipeed/libmaix)，按照其 `REAME.md` 文档搭建开发环境 * 如果你希望快速上手，并使用 Python 语言开发， 请使用[MaixPy3](/maixpy3)，仔细阅读其文档即可 * **平台和分享**：如果需要使用 AI 功能，可以搭配 [MaixHub](https://maixhub.com) 在线训练平台使用，平台提供了 AI 模型或者项目分享功能，节约大家不少时间。"},"/hardware/zh/maixII/M2/opencv.html":{"title":"Maix-II DOCK 使用 OpenCV","content":" title: Maix II DOCK 使用 OpenCV update: date: 2023.08.02 author: neucrack content: 新建文档，添加 C/C++ 和 Python 使用 OpenCV 方法 有两种使用方式，C/C++ 或者 Python 语言使用 ## Maix II Dock C/C++ 使用 OpenCV 使用 [libmaix + opencv](https://github.com/sipeed/libmaix/tree/release/examples/camera_opencv)。 这里写好了 opencv 的最小例程，根据你的情况开发即可。 > OpenCV 开发的好处是需要啥都能搜到例子，另外还能用 MaixPy3 用的一些接口，比如 find_blobs 寻找色块，在[这里](https://github.com/sipeed/MaixPy3/blob/c6b5c419a9c547f1f42c686020eb0e4cdb3f93cf/ext_modules/_maix_image/py_maix_image.cpp#L105)查找你要的 API， 然后根据指向的函数，比如`.def(\"binary\", &maix_image::_binary,`指向[_binary](https://github.com/sipeed/MaixPy3/blob/c6b5c419a9c547f1f42c686020eb0e4cdb3f93cf/ext_modules/_maix_image/_maix_image.cpp#L926)函数，照着这个函数写就好了！是不是自由度巨大，不用受限于 MaixPy3 的 API 更新啦 > > libmaix + opencv 为 m2dock 编译指导：请参考 [libmaix 的 readme 文档](https://github.com/sipeed/libmaix/blob/release/README.md) 修改例程中的 OpenCV 操作即可，例程是一个边缘检测： ```c++ void opencv_ops(cv::Mat &rgb) { cv::Mat gray; cv::cvtColor(rgb, gray, cv::COLOR_RGB2GRAY); cv::Canny(gray, gray, 100, 255, 3, false); cv::cvtColor(gray, rgb, cv::COLOR_GRAY2RGB); } ``` ## Python 使用 OpenCV Maix II Dock 使用 OpenCV 参考[给 M2Dock 安装 Python Opencv](https://wiki.sipeed.com/news/others/v831_opencv/v831_opencv.html) 这篇文章给 M2Dock 安装 Python Opencv 包，然后在 Python 代码里面`import cv2`就可以开始使用啦！ 不过由于 Maix II Dock 内存资源有限，同时使用模型的话可能内存会比较紧张，根据自己的需求使用就好，如果内存不足，则建议使用 C/C++ 开发。"},"/hardware/zh/maixII/M2/faq.html":{"title":"Maix-II DOCK 常见问题指南","content":" title: Maix II DOCK 常见问题指南 >这里记录 Maix II DOCK 相关的 A&Q 常见问题。 ## 没有弹出 U 盘或者 adb 提示 device not found ![adb_error](./asserts/faq/adb_error.jpg) 出现这种问题的情况有如下可能： 1. 所使用的 TypeC 线只有供电功能，没有数据传输功能 2. 使用的是 C2C 数据线 3. 板子不是通过 OTG 口与电脑连接 4. U 盘没出现，需要手动卸载 ADB 驱动 5. 板子 LINUX 系统没启动，比如没有插入烧录过系统的 TF 卡 ## 虚拟 U 盘文件复制失败，看不到文件 ### 从电脑复制到 U 盘 这种情况可能是文件较大没能完整传输所导致的，需要在传输结束后先在电脑上移除虚拟 U 盘，然后在板子执行 `reboot` 命令或者按下 `RST` 键重启板子来加载文件系统。 ### 在 U 盘创建文件 只用板子命令行终端在 `/root/` 下创建文件够不会同步在 U 盘里显示，这时需要重启一下就能在 U 盘里看到通过板子终端在 `/root/` 所创建的文件了。 ## 镜像卡插上后不显示 U 盘无反应，屏幕也不亮。 1. 确保镜像卡正常且烧录成功 2. 确保上电的就是 OTG 口，并且 M2DOCK 的电源灯正常工作。 3. 确保已安装好 MaixPy3 以及附带的驱动并删除驱动。 4. 更换线材重试，更换电脑 USB 口重试，仍然加载不出来，更换电脑确认。 5. 以上操作后还是不行请再次使用 SD Card Formatter 重新格式化 SD 卡 再次烧录上电或联系淘宝客服。 ## 本地 pip 安装失败 M2DOCK 不能本地编译以及本地 pip安装，只能搭配 Maixpy3 使用。 ## 使用屏幕时呈花屏状态 1. 排线是否插稳，查看是否线序被破坏，接触不良导致的。 2. fb 缓冲区是否异常导致的 3. 尝试重启板卡看看是否还会花屏 4. 硬件问题 ## 如何更换屏幕及摄像头的设备树 目前开发板支持的屏幕有 1.3寸、2.4寸、2.8寸 的 IPS 屏，且只是支持在我们淘宝上售卖的显示屏；对于别的屏幕有需求的，可以走商务通道进行定制。 如何进行屏幕的切换及更新设备树：[点击查看](https://wiki.sipeed.com/hardware/zh/maixII/M2/other.html#%E5%88%87%E6%8D%A2%E5%B1%8F%E5%B9%95) 目前 MaixII Dock 开发板目前支持的摄像头有 sp2305、vs3205、ov2685（只支持在官方店上再售卖的摄像头，有别的摄像头需求可以进行商务定制），摄像头之间的切换同样时需要更换设备树文件，更换方式上面的更换屏幕一样的。 如何进行摄像头以及设备树的切换：[点击查看](https://wiki.sipeed.com/hardware/zh/maixII/M2/other.html#%E6%9B%B4%E6%8D%A2%E6%91%84%E5%83%8F%E5%A4%B4) ## 脱机运行 对于 M2Dock，前面说过开机启动代码顺序是 `/root/app/main.py > /root/main.py` ，所以在保存的时候自己注意下保存位置。 ## 文件系统只读 使用开发板虚拟的 U 盘时在断电前一定要记得弹出 U 盘，否则可能引起文件系统损坏，导致文件系统只读。 最简单粗暴的方法时重烧系统镜像。"},"/hardware/zh/maixII/M2/no_sd_flash.html":{"title":"无 SD 卡系统烧录方式","content":"# 无 SD 卡系统烧录方式 **目前没有在V831上进行过flash系统烧录，V833可以使用一下方式进行烧录，镜像需要发送邮件获取** 如需烧录到V831上，需要自行设计底板，引出fel烧录按键 ## 获取烧录工具 从网上获取 PhoenixSuit(Windows) 烧录工具。 [baidu PhoenixSuit](https://www.baidu.com/s?wd PhoenixSuit) [bing PhoenixSuit](https://www.bing.com/search?q PhoenixSuit&FORM BESBTB&mkt zh CN) [github PhoenixSuit](https://github.com/colorfulshark/PhoenixSuit) [lo4d PhoenixSuit](https://phoenixsuit.en.lo4d.com/windows) ## Windows 上使用 PhoenixSuit 烧录 获取系统镜像（.img） 和烧录工具（.exe） 。解压到你知道的地方。 ![](./../img/no_sd_flash.png) 解压后打开 PhoenixSuit_V1.10 烧录工具 PhoenixSuit.exe 选择烧录的 .img 镜像。 ![](./../img/no_sd_flash_1.png) 这时候开始插入硬件， 同时按下硬件的两个按键， 其中一个是 fel 烧录模式的触发， 要注意接线头是否联通。 （若是裸板如右图所示先按 FEL 后按 RST 复位） ![](./../img/no_sd_flash_2.png) 按住后， 此时插入电脑的 USB 口， 相当于上电（RST 复位） 进入烧录模式， 务必注意先按键再通电， 之后需要安装相应的 USB 驱动。 > 如果该电脑插入后设备管理器显示驱动未安装， 请手动指向 PhoenixSuit_V1.10 / Drivers 的驱动文件夹完成安装， 安装完成如下显示 Android ADB Interface ， 如果实在搞不定就使用市面上常见的驱动安装软件（如驱动精灵） 帮助安装。 ![](./../img/no_sd_flash_3.png) 这时候 PhoenixSuit 软件会提示是否格式化更新， 一直选是即可， 不成功可以重试或检测接线是否牢固。 ![](./../img/no_sd_flash_4.png) 进度状态如下， 直到成功。 ![](./../img/no_sd_flash_5.png) <a href \"#\" onClick \"javascript :history.back( 1);\">返回上一页(Back)</a>"},"/hardware/zh/maixII/M2/maixhub_train.html":{"title":"体验在 MaixHub 训练自己的 AI 检测模型，并快速部署到 Maix-II-Dock","content":" title: 体验在 MaixHub 训练自己的 AI 检测模型，并快速部署到 Maix II Dock keywords: MaixII, m2dock, maixhub update: date: 2023.7.31 author: Neucrack version: v1.0 content: 添加文档 你没看错，接触这款开发板的第一件事情，竟然是可以直接训练 AI 模型！ 在进行写代码开发前，让我们一起来**零代码**体验一下训练一个自己的物体检测 AI 模型，并且快速部署到 Maix II Dock。 ## AI 物体检测模型简介 **目标**： 顾名思义，就是用 AI 来检测物体，比如检测人脸、玩具、卡片、车辆、水果等等。 开发板（设备）通过摄像头拍摄到画面（图片），然后通过 AI 模型来检测画面中的物体，包括坐标、大小、物体名称，然后将检测结果显示在屏幕上。 **原理**： 利用了一个叫作 YOLOv2 的物体检测模型和方法，具体怎么做到的这里先不管，后期再学习，先把它当成一个黑盒，输入图片，输出检测结果。 而 MAIX II 拥有硬件神经网络加速单元，可以非常快速地运行这个模型，可以实时检测画面中的物体。 ## MaixHub 简介 MaixHub 是由 Sipeed 推出的 AI 平台和分享社区，可以在线训练 AI 模型，不需要开发基础，也不需要昂贵的机器，并且可以免费使用，非常适合 AI 初学者体验学习，也适合简单场景应用快速落地。 同时也是开发者分享社区，可以在上面找到很多大家分享的模型，以及开发经验等等。 ## 准备工作 * 确保开发板连接好了 WiFi 天线，因为需要连接互联网。 * 准备好一个能够连接互联网的 WiFi 环境，比如路由器，手机热点等。 * 确保在上一篇文档[烧录系统](./flash.html)中已经烧录了**最新**的文件名带有`maixhub`字样的镜像，这样上电启动后会自动进入 MaixHub APP 界面，如下： ![maixhub app](./asserts/maixhub_app_start.png) > 另外你也可以手动[下载最新的 MaixHub APP](https://maixhub.com/app/1) 手动更新，方法见链接里面的文档说明。 然后可以看到界面可以切换功能，可以先切换语言选择中文，然后有其它功能比如**WiFi**、**采集图片**、**部署模型**等等。 * 进入 WiFi 界面，根据提示在浏览器打开 [maixhub.com/wifi](https://maixhub.com/wifi)，填写 WiFi 的 SSID 和密码生成二维码，然后开发板扫描二维码连接 WiFi。 ## 如何在 MaixHub 训练自己的 AI 模型及部署到 Maix II Dock * 访问[MaixHub](https://maixhub.com/)， 注册登录账号。 * 成功登录后，首页有**AI知识** 和 **视频教程**，可以观看并学习使用。 这里写一下主要的步骤，大家可以看 MaixHub 的教程以及自行举一反三摸索。 * 创建在线训练项目，选择**图像检测**。 * 创建数据集，选择开发板（设备）的**采集图片**功能上传图片，尽量多采集图片，尽量多覆盖使用场景。 * 标注数据集。 * 创建训练任务，等待云端训练完成。 * 开发板（设备）打开**部署模型**功能，扫码部署模型。 * 摄像头对着被检测的物体，查看检测效果。 ## 将识别结果通过串口发送到单片机 下载模型，里面有`main.py`程序，里面有串口发送结果的代码，通过引脚`G6`（`TX`）发送数据，波特率为`115200`。 将所有文件放再在 U盘`app/`目录下替换原有文件（没有`app`目录则手动新建一个），重启开发板即可自动运行。"},"/hardware/zh/maixIII/index.html":{"title":"","content":" "},"/hardware/zh/maixIII/ax-pi/faq_axpi.html":{"title":"Maix-III 系列 AXera-Pi 常见问题（FAQ）","content":" title: Maix III 系列 AXera Pi 常见问题（FAQ） ## Q：供电不足怎么办？ A：可以把两根 usb 口接上来供电，板子至少要 USB3.0 1A 的电流才能启动喔！（拉黑 USB2.0 500ma） ## Q：被产品电了怎么办？ A：最近冬天静电来了，产品要注意接地喔。 ## Q：如何更换 os04a10 摄像头？ A：**一改参数，二改代码，以下述改动为例**： 类似 sample_vin_vo 这类命令改 ` c 0` 就可以启用 os04a10 摄像头，对应 ` c 2` 就是默认提供的 gc4653 摄像头。 如果是类似 [IPCDemo](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/basic_usage.html#IPCDemo) 的话更改相对应后缀 gc4653 为 `gc4653_config.json`、os04a10 为 `os04a10_config.json`。 ![ipc_demo_json](./../../../en/maixIII/ax pi/assets/flash_system/ipc_demo_json.jpg) 像[RSTP](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/basic_usage.html#rtsp) 这种脚本运行的示例，可以通过编辑里面的摄像头注释来改变摄像头配置。 ![rtsp_stream_shell](./../../../en/maixIII/ax pi/assets/flash_system/rtsp_stream_shell.jpg) 可以编辑 C 代码里设置默认摄像头的代码 `COMMON_SYS_CASE_E eSysCase SYS_CASE_SINGLE_GC4653;` 来切换摄像头，详细可看[components/libmaix/lib/arch/axpi/libmaix_cam/libmaix_cam.cpp#L93](https://github.com/sipeed/libmaix/blob/release/components/libmaix/lib/arch/axpi/libmaix_cam/libmaix_cam.cpp#L93) <div> <img src \"./../../../en/maixIII/ax pi/assets/qa/qa_switcg_os04a10_1.jpg\" alt \"qa_switcg_os04a10_1\" width \"45%\"> <img src \"./../../../en/maixIII/ax pi/assets/qa/qa_switcg_os04a10_2.jpg\" alt \"qa_switcg_os04a10_2\" width \"45%\"> </div> ## Q：运行摄像头有关程序时报错 i2c_read: Failed to read reg: Remote I/O error.!？ A：摄像头接线是否正确、检查摄像头配置是否与型号相匹配、参数是否修改、启动命令行输入是否出错、以及摄像头是否启动；如果以上都是正确的话，摄像头依旧报错就是硬件问题了。 ## Q：如何更换其他屏幕？ A：目前默认只提供 5 寸屏幕，支持其他屏幕需要自行修改驱动代码和设备树，以及对应的应用层显示代码。 ## Q：运行 xxxx menuconfig 时遇到报错 locale.Error: unsupported locale setting !? A：可以使用 `sudo localedef i en_US f UTF 8 en_US.UTF 8` 恢复一下配置即可。 ## Q：运行 IPC ODM 命令时报错 VCEncInit:ERROR codecFormat NOT support by HW !? A：试着按复位键或者是插拔重启设备即可。 ## Q：运行程序后屏幕显示花屏？ ![faq_display](./../assets/faq_display.jpg) A：查看摄像头型号参数是否配置正确。 ## Q：运行命令后报错：Bus Error！？ ![faq_bus](./../assets/faq_bus.jpg) A：这种情况是 SD 卡质量问题导致掉卡，也就是镜像卡里面的程序崩掉了无法读取到。 更换质量好一点的 SD 卡或官方购买镜像卡，可参照 `SD` 卡测试选购合适的卡[点击前往查看](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/flash_system.html#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9 SD %E5%8D%A1%EF%BC%9F)。 ## Q：使用 `ifconfig a` 查看后没有 eth0 ip 地址？ A：没有联网的话会直接看不到 ip 地址，查看下网线是否有接入、是否接稳了。 或使用 `dhclient eth0` 手动启动或参考文档[传送门](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/basic_usage.html#%E6%9C%89%E7%BA%BF%E4%BB%A5%E5%A4%AA%E7%BD%91%EF%BC%88eth0%EF%BC%89%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95)重新配置 ip 获取地址。 ## Q：运行 uvc 命令后一直报错读取不到设备？ A：这种情况一般会少数出现在 Windows 环境上，查看设备管理器是不是有什么显示异常驱动，卸载后即可使用。 ## Q：运行 uvc 命令后出现卡住现象？ A：重启即可 ## Q：使用 ssh 登陆后断开报错：packet_write_wait: Connection to 10.xxx.xxx.xxx port 22: Broken pipe！ A: 运行一下`python3 c \"import os, binascii; os.system('sed i \\'/iface eth0 inet dhcp/ahwaddress ether {}\\' /etc/network/interfaces'.format(binascii.hexlify(bytes.fromhex(open('/proc/ax_proc/uid').read().split('0x')[1][: 5]),':').decode('iso8859 1'))) if os.system('grep \\'hwaddress ether\\' /etc/network/interfaces q') ! 0 else exit();\"` 后重启即可。 ## Q：硬件物料更改说明、没有 wlan0 、屏幕烧屏、摄像头倒过来怎么解决？ {#version} > **新旧版底板区别** > 1. 在新底板上我们标注了设备号：`v3768`，用户也可以根据版本号来确认版本的不同。 2. 底板摄像头 FPC 连接座更换，主要就是固定方向改变，但是接线方向未变。 3. WiFi 模块更换：`旧 RTL8723BS` > `新 RTL8189FTV`。 **如果遇到 wlan0 不显示的话请参考以下解决方法：** 1. 根据下图确定 WiFi 模块的版本来替换 `/boot` 目录下的相对应的驱动，更新内核驱动可以用 `cp /boot/kernel.img.rtl8723bs /boot/kernel.img` 更新后请重启板卡。 2. 可能是运输导致核心板与底板衔接松了，重新插拔装紧核心板即可。 3. 尝试以上方法后仍不显示 wlan0 的话，重新烧录镜像（未知系统问题、极少见）。 ![faq_borad](./../assets/faq_board.jpg) > **新旧版摄像头区别** 新版摄像头线序方向发生了变化，可点击[接线示例](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/flash_system.html#%E5%A6%82%E4%BD%95%E8%BF%9E%E6%8E%A5%E5%A4%96%E8%AE%BE%E5%92%8C%E9%85%8D%E4%BB%B6%EF%BC%9F)参考并进行接线防止接反导致烧坏排线或板卡。 ![faq_sensor](./../assets/faq_sensor.jpg) **如出现摄像头、屏幕画面反了倒过来了可参考以下解决方法：** `V3751` 版本的摄像头批次导致的问题，物理旋转即可解决。 ![faq_video_a](./../assets/faq_video_a.jpg) 有装配亚克力外壳的 AXera Pi 可参考以下图例旋转安装： <html> <img src \"./../assets/faq_video_b.jpg\" width 48%> <img src \"./../assets/faq_video_c.jpg\" width 48%> </html> > **新旧版屏幕区别** 新旧板的屏幕所使用的设备树（驱动）不同。 ![faq_newdisplay](./../assets/fqa_newdisplay.jpg) **屏幕上电后出现残影、锯齿、烧屏或下图画面请参考以下解决方法：** <html> <img src \"./../assets/faq_sawtooth.jpg\" width 48%> <img src \"./../assets/faq_dth.jpg\" width 48%> </html> 新旧版的屏幕设备树不同，根据上图日期区分并替换 `/boot` 目录下对应的 `dtb` 设备树驱动即可，请及时更换否则会导致烧屏，使用 `cp /boot/dtb.img.lcd20220830 /boot/dtb.img` 进行设备树替换后重启。 ## Q：运行 opencv 相关后报错：can't open camera by index. A：查询一下摄像头设备号是否与代码内调用设备号的一致。 ## Q：烧录后启动失败显示 XERA UBOOT > A：进入 uboot 模式了输入 boot 后即可启动。 ![faq_boot](./../assets/faq_boot.jpg) ## Q：芯片为什么显示 1G 内存以及用户为什么只能用 1.3g 内存 ![faq_mem](./../assets/faq_mem.png) 第一个是 uboot 显示 bug 我们贴的都是 2GB 内存. 第二个是 系统上显示的内存为什么不是刚好 2GB，这里根据原厂芯片方案可知官方设计的 1G 内存分配方案为 256M + 768M CMM. ![faq_ddr](./../assets/faq_ddr.png) ![faq_uboot](./../assets/faq_dram.png) 而我们贴的是 2GB 内存采用的是 512M CMM 的内存方案，其余的内存 2048M 512M 1536M 为用户空间内存，再除去 256M kernel 内存后剩下 1536M 256M 约等于 1.3G 供用户使用 什么是 CMM 内存，简单理解就是一段独立于 linux 系统之外的大段线性物理内存，一般是分给 NPU ISP GPU 用的线性物理空间，这意味着加载模型不需要消耗 1.22G 用户空间内存，消耗的是 CMM 内存，如推理、编码、ISP处理都不会吃用户空间内存。 现在带 NPU ISP GPU 的芯片都会有类似的设计或概念，可以从芯片手册或驱动代码中得知。 如爱芯的 `/soc/scripts/auto_load_all_drv.sh` 存放有 `insmod /soc/ko/ax_cmm.ko cmmpool anonymous,0,0x60000000,512M` 这个字段。 ![cmm_memory_size_script](./../../../en/maixIII/ax pi/assets/qa/cmm_memory_size_script.png) 以及系统启动配置： `/* bootargs for SD */#define BOOTAGRS_SD \"mem 1536M initcall_debug 0 loglevel 0 ax_boot_delay 0 vmalloc 768M console ttyS0,115200n8 earlyprintk dw_uart, init /sbin/init noinitrd root /dev/mmcblk2p2 rw rootdelay 3 rootfstype ext4\"` ![bootargs_command](./../../../en/maixIII/ax pi/assets/qa/bootargs_command.png)"},"/hardware/zh/maixIII/ax-pi/basic_usage.html":{"title":"Maix-III AXera-Pi 系统基础使用","content":" title: Maix III AXera Pi 系统基础使用 基于上文的上手指引后，本文介绍使用 Maix III AXera Pi 开发板的 Linux debian11 系统基础使用方法。 ## 系统登录 ### 登录工具 这里介绍相关使用的终端登录工具，分别是：`MobaXterm`、`electerm`、`vscode remote`。 **MobaXterm 介绍** MobaXterm 是在 Windows 下使用的全能终端管理软件，而 Linux 系统可以使用 ssh 远程被操作，使用 MobaXterm 进行 ssh 登陆板子直接编辑板内的代码或执行命令，也能方便的拖拽文件上传或下载到电脑里，类似的工具还有 vscode remote 远程登录 linux 服务器。 ![mobaxterm_ssh](./../assets/ssh.jpg) 下载链接：[点击跳转](https://mobaxterm.mobatek.net/download.html) 分别付费与免费双版本，下载免费版本即可。 使用教程：[如何使用 MobaXterm](https://wiki.sipeed.com/hardware/zh/maixII/M2/tools/mobaxterm.html?highlight ssh) **electerm 介绍（推荐）** electerm 是一个基于 `electron/ssh2/node pty/xterm/antd/useProxy` 等开源组件开发，支持跨平台的 `Terminal/SSH/SFTP` 客户端工具，同时支持 `Linux、MacOS、Windows` 等多种操作系统，它既可以作为终端工具来使用，还能传输文件并自带中文界面，更加满足用户日常对终端的需求。 ![electerm](./../assets/electerm.jpg) 下载链接：[点击跳转](https://electerm.html5beta.com/) 根据操作系统来下载相对应的版本即可。 **vscode remote 介绍** vscode remote 是 vscode 的一个插件，可以直接连接到远程的 linux 服务器，然后在本地编辑代码，同步到远程服务器上编译运行，这里以一台 Windows 10 的桌面计算机系统为例，只要能安装 vscode 编辑器软件计算机都行。 ![vscode](./../assets/vscode.jpg) 下载连接：[点击跳转](https://code.visualstudio.com/) 连接教程：[如何使用 vscode remote 连接板子](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/dev_prepare.html?highlight ssh#vscode remote) ### 登录方式 Maix III AXera Pi 开发板的 Linux debian11 系统默认使用 root 用户登录。 用户名为 `root`，密码为 `root`，目前板子接入电脑端上电启动后支持以下登录 Linux 系统方式。 #### 有线 串口 serial 登陆 > 使用串口 serial 登陆前需安装 tty 转 USB 串口驱动 **Linux**：系统本身自带无需再装驱动，使用 `ls /dev/ttyUSB*` 即可看到设备号。 **Windows**：直接[点击下载 CH340 驱动](https://api.dl.sipeed.com/fileList/MAIX/tools/ch340_ch341_driver/CH341SER.EXE)安装，安装后可在`设备管理器`查看串口设备。 .. details::点此展开查看 CH340 驱动安装 先打开设备管理器查看是否有 **CH340** 驱动，如无驱动的话请点击上方链接进行下载。 ![usb serial](./../assets/usb serial.jpg) 下载完成后，右键点击文件，选择**以管理员身份运行(A)**即会自动安装。 ![install serial](../assets/install serial.jpg) 安装完成，可在设备管理器端口处查看设备。 >[有些同学会遇到 Ubuntu22.04 CH340系列串口驱动（没有ttyUSB）问题，点此查看解决方案。](https://blog.csdn.net/qq_27865227/article/details/125538516) .. details::点此展开查看 USB UART 接口示意图 ![uart](./../assets/uart.jpg) 使用 usb 3.0 线连接板子上的 USB UART 接入电脑端，使用前请安装上文的驱动，再使用 MobaXterm 即可连接，默认串口配置为 115200、8N1（波特率115200，8位数据，无奇偶校验，1位停止位）。 **serial 登陆教程**：[点击查看](https://wiki.sipeed.com/hardware/zh/maixII/M2/tools/mobaxterm.html?highlight ssh#%E8%BF%9E%E6%8E%A5 %E4%B8%B2%E5%8F%A3%28Serial%29) 成功连接后会打印大量调试信息，会弹出登陆账号信息，输入用户名及密码即可登陆。 ![serial](./../assets/serial.jpg) > 串口通常只提供给专业的驱动开发工程师调试用，会打印大量的调试信息，如感到不适请使用 **ssh** 登陆。 #### 基于 ip + ssh 登录 > 登录前需安装 **rndis usb** 网卡驱动 一般情况下 rndis usb 网卡驱动在 Linux 下可不用安装，在 Windows 下需要按下图手动安装系统自带驱动，而 macos 需要编译安装驱动（horndis），Windows 还需要配置一下网络优先级，勾选微软 rndis 驱动后设置网络跃点数调整优先级。 **Windows 配置网络优先级**：[设置网络跃点数调整优先级](https://jingyan.baidu.com/article/358570f6bc5cfdce4724fca2.html) 这里举例如何在 Win10 安装系统自带的 rndis 驱动，在 Linux 上免驱动自动识别 rndis 驱动，MacOS 安装可以参考这篇 [【AXPI】如何在 M1/M2 Mac上使用 Rndis](https://zhuanlan.zhihu.com/p/593627641) 。 .. details::点此展开查看 Win10 驱动安装过程 打开设备管理器找到其他设备，选中 rndis 选择更新驱动程序，在如何搜索设备软件窗口中，选择**浏览计算机查找驱动程序软件（R）**。 ![rndis_1](./../assets/rndis_1.jpg) 再选择**从计算机的设备驱动程序列表中选择（L）**在硬件设备列表中往下拉，找到**网络适配器**，选中**下一步**。 ![rndis_2](./../assets/rndis_2.jpg) 在厂商列表中选择 **Microsoft**，右侧列表中选择 **USB RNDIS Adapter**。 ![rndis_3](./../assets/rndis_3.jpg) 点击下一步等待安装即可。 .. details::点此展开查看 USB OTG 接口示意图 ![otg](./../assets/otg.jpg) 系统默认开启了 usb rndis 虚拟以太网，用户可通过板载 USB OTG 口连接 usb0 网卡的 IP `192.168.233.1` 进行 ssh 登录操作。使用 ssh 登录前需要先登陆板子通过 `ifconfig a` 命令得到板子 IP 后再使用 IP 进行 ssh 登录上 Linux 系统，下图的 IP 地址（除 `127.0.0.1` 外）都能登陆板子。 ![ifconfig](./../assets/ifconfig.jpg) **ssh 连接教程**：[点击跳转](https://wiki.sipeed.com/hardware/zh/maixII/M2/tools/mobaxterm.html?highlight ssh#%E8%BF%9E%E6%8E%A5 SSH) 按教程示例新建 ssh 会话，双击会话后会有提醒输入账号及密码，输入后按回车即可连接。 ![ssh](./../assets/ssh.jpg) ### 登录后 登录后，可以使用 `ls` 命令查看当前目录下的文件，使用 `cd` 命令切换目录，使用 `pwd` 命令查看当前目录。 ## 网络配置 ### 网络操作基础 **使用 ping baidu.com 测试网络** ![baidu](./../assets/baidu.jpg) **使用 ifconfig a 查看所有网卡情况** Maix III AXera Pi 开发板的 Linux 系统默认使用 DHCP 协议获取 IP 地址，可以使用命令行 `ifconfig a` 查看当前网络配置，板子根据下述会配置四种网卡类型。 ```bash root@AXERA:~# cat /etc/network/interfaces # interfaces(5) file used by ifup(8) and ifdown(8) # Include files from /etc/network/interfaces.d: source /etc/network/interfaces.d/* auto lo iface lo inet loopback # auto eth0 allow hotplug eth0 iface eth0 inet dhcp # auto usb0 allow hotplug usb0 iface usb0 inet static address 192.168.233.1 netmask 255.255.255.0 # allow hotplug wlan0 # wpa ssid \"dalaoshu\" # wpa psk \"junhuanchen\" auto wlan0 iface wlan0 inet manual wpa conf /boot/wpa_supplicant.conf iface wlan0 inet dhcp ``` 可以使用命令行 `ifconfig a` 查看所有网卡信息。 ```bash root@AXERA:~# ifconfig a eth0: flags 4163<UP,BROADCAST,RUNNING,MULTICAST> mtu 1500 inet 192.168.0.77 netmask 255.255.255.0 broadcast 192.168.0.255 ether 1e:09:dc:e9:1c:29 txqueuelen 1000 (Ethernet) RX packets 301 bytes 41433 (40.4 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 31 bytes 2970 (2.9 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 device interrupt 56 lo: flags 73<UP,LOOPBACK,RUNNING> mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 loop txqueuelen 1000 (Local Loopback) RX packets 16 bytes 1064 (1.0 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 16 bytes 1064 (1.0 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 usb0: flags 4163<UP,BROADCAST,RUNNING,MULTICAST> mtu 1500 inet 192.168.233.1 netmask 255.255.255.0 broadcast 192.168.233.255 ether 02:da:9b:e4:a8:7f txqueuelen 1000 (Ethernet) RX packets 121 bytes 15220 (14.8 KiB) RX errors 0 dropped 15 overruns 0 frame 0 TX packets 35 bytes 7258 (7.0 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 wlan0: flags 4163<UP,BROADCAST,RUNNING,MULTICAST> mtu 1500 inet 192.168.0.112 netmask 255.255.255.0 broadcast 192.168.0.255 ether 0c:cf:89:32:c5:c0 txqueuelen 1000 (Ethernet) RX packets 950 bytes 154305 (150.6 KiB) RX errors 0 dropped 950 overruns 0 frame 0 TX packets 5 bytes 1398 (1.3 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 ``` **使用 dhclient 触发 DHCP 获取 ip** >这里以有线网卡（eth0）为例，decliient 还支持无线 WIFI（wlan0）. 使用上方 `ifconfig a` 命令后，如果 eth0 的地址获取失败可使用 `dhclient eth0` 触发 DHCP 获取 IP。 ```bash root@AXERA:~# dhclient eth0 & [1]+ Done dhclient eth0 root@AXERA:~# ifconfig eth0 wlan0: flags 4163<UP,BROADCAST,RUNNING,MULTICAST> mtu 1500 inet 192.168.0.136 netmask 255.255.255.0 broadcast 192.168.0.255 ether 0c:cf:89:32:c5:dc txqueuelen 1000 (Ethernet) RX packets 1284 bytes 157505 (153.8 KiB) RX errors 0 dropped 1274 overruns 0 frame 0 TX packets 205 bytes 20798 (20.3 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 ``` ### USB RNDIS（usb0）配置方法 可使用静态 IP 地址 `192.168.233.1` 这里已配置好 dhcp 服务了，从而避免用户需手动设置 IP 地址的操作。 > 使用 usb0 前需要安装 rndis 驱动，可点击[驱动安装过程](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/basic_usage.html#%E5%9F%BA%E4%BA%8E ip %2B ssh %E7%99%BB%E5%BD%95)前往安装。 在 Windows 系统下如果遇到多个网卡时，发现 USB 网卡优于局域网导致内网网站访问很慢甚至失败，此时就需要通过 Win10 设置跃点数来调整网络优先级的连接顺序，去修改优先级改善访问慢的状态，数值越大优先级越低（比如设置 1000），从而把 USB 网卡优先级调至最低，可点击前往[配置网络优先级](https://jingyan.baidu.com/article/358570f6bc5cfdce4724fca2.html). **查看 usb0 网卡是否存在** 可通过 `ifconfig usb0` 命令查看 usb0 网卡或尝试 `ping 192.168.233.1` 是否能通。 ```bash root@AXERA:~# ifconfig usb0 usb0: flags 4099<UP,BROADCAST,MULTICAST> mtu 1500 inet 192.168.233.1 netmask 255.255.255.0 broadcast 192.168.233.255 ether 16:37:cd:c6:f2:ae txqueuelen 1000 (Ethernet) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 ``` **在 ping 通后 192.168.233.1 即可通过 usb 线登陆到板子** USB 网卡会自动 DHCP 配置，直接连接 192.168.233.1 即可，连接方式可参考示意图。 ![ssh usb](./../assets/ssh usb.jpg) ### 有线以太网（eth0）配置方法 **查看 eth0 网卡是否存在** 可使用 `dhclient eth0 &` 手动启动 DHCP 客户端获取 IP 地址，得到 ip 后使用 `ifconfig eth0` 命令查看当前网络配置。默认支持千兆网络，只需要开机前将网线插上去，在启动过程中就会自动配置并联网，可以通过 `apt update` 测试软件源更新。 ```bash root@AXERA:~# ifconfig eth0: flags 4163<UP,BROADCAST,RUNNING,MULTICAST> mtu 1500 inet 192.168.0.77 netmask 255.255.255.0 broadcast 192.168.0.255 ether 1e:09:dc:e9:1c:29 txqueuelen 1000 (Ethernet) RX packets 301 bytes 41433 (40.4 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 31 bytes 2970 (2.9 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 device interrupt 56 ``` **关于 eth0 地址相同的问题** 执行下述代码就会从 `/proc/ax_proc/uid` 读取 chip_id 写到 `/etc/network/interfaces` 的 eth0 配置里，该命令多次执行不受影响。 ``` python3 c \"import os, binascii; os.system('sed i \\'/iface eth0 inet dhcp/ahwaddress ether {}\\' /etc/network/interfaces'.format(binascii.hexlify(bytes.fromhex(open('/proc/ax_proc/uid').read().split('0x')[1][: 5]),':').decode('iso8859 1'))) if os.system('grep \\'hwaddress ether\\' /etc/network/interfaces q') ! 0 else exit();\" ``` **一些问题排除方法，如没有 ip 如何配置** 登录后无法获取以太网地址的话，可用上文命令启动 DHCP 客户端获取 IP 地址。 或者是使用 `ifdown eth0` 关闭网卡后再使用 `ifup eth0 force` 启动手动配置 IP。 .. details::点此展开查看配置示例 ![eth0 config](./../assets/eth0 config.jpg) ### 无线 WIFI （wlan0）配置方法 >**20230103** 后镜像更新以及不同硬件（rtl8189fs）WiFi 模组，相关的 `WiFi` 配置全部采用 `nmtui` 图形化或命令行进行联网。相关的硬件版本区分或出现 `wlan0` 不显示的情况都请移步[ Maix III 系列 AXera Pi 常见问题（FAQ）](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/faq_axpi.html)查看。 **查看 WIFI 网卡是否存在** **wlan0**：无线网卡，使用 DHCP 协议获取 IP 地址，可使用命令 `ifconfig wlan0` 查看当前网络配置。 #### 使用命令行联网 >注意：新镜像（**20230103**）已提前配置好 `nmtui connect` 直接可以根据下文进行联网。 >旧镜像使用前需先配置 `nmtui connect` 才可使用，可点击前往[ 启动 nmtui connect 图形化联网 ](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/basic_usage.html#配置 nmtui connect 使用图形化联网)查看。 以下联网命令行已提前放置在开机脚本 `/boot/rc.local` 里，用户可参考示例修改命令行的 `账户 & 密码` 并在终端运行联网即可，系统会自动保存连接过的 WiFi 账户以及密码。 ```bash nmcli device wifi connect Sipeed_Guest password qwert123 # 示例 nmcli device wifi connect AXera Pi password 11111111 # 改动 WiFi 账户以及 pssword 密码 ``` .. details::点击查看修改示例图 ![nmtui_adb](./../assets/nmtui_adb.png) #### 使用 nmtui connect 图形化联网 终端输入 `nmtui connect` 打开可视化联网页面。页面会显示扫描到的 WiFi 信息，使用键盘的 **上下左右** 键选择要连接的 WiFi 按下 **回车** 键，页面提示输入 WiFi 密码，输完后选择 `OK` 并按 **回车** 键则会弹出页面，选择 `Quit` 按 **回车** 键退出，页面会显示 * 标变动代表联网完成。 <html> <img src \"./../assets/nmtui_one.png\" width 45%> <img src \"./../assets/nmtui_two.png\" width 45%> </html> #### nmtui connect 图形化联网详解 系统已预置 NetworkManager 在 `nano /etc/NetworkManager/NetworkManager.conf` 里的 `managed false` 修改成 `managed true` 和注释掉 `/etc/network/interfaces` 里的有关于 `wlan0` 的配置（可以打开 `allow hotplug wlan0` ）后「拔线断电重启」即可使用 `nmtui connect` 进行联网，但原来的 `wpa_supplicant.conf` 里的配置会失效。 ``` root@AXERA:~# cat /etc/network/interfaces # interfaces(5) file used by ifup(8) and ifdown(8) # Include files from /etc/network/interfaces.d: source /etc/network/interfaces.d/* auto lo iface lo inet loopback # auto eth0 allow hotplug eth0 iface eth0 inet dhcp # auto usb0 allow hotplug usb0 iface usb0 inet static address 192.168.233.1 netmask 255.255.255.0 allow hotplug wlan0 # wpa ssid \"2.4G\" # wpa psk \"1qaz2wsx\" # auto wlan0 # iface wlan0 inet manual # wpa conf /boot/wpa_supplicant.conf # iface wlan0 inet dhcp ``` > [配置 NetworkManager 参考](https://support.huaweicloud.com/bestpractice ims/ims_bp_0026.html#section1) & [linux系统中使用nmtui命令配置网络参数（图形用户界面）](https://www.cnblogs.com/liujiaxin2018/p/13910144.html) 这样你就可以使用 `nmcli pretty device wifi list` 进行 Wi Fi 的扫描了。 ``` root@AXERA:~# nmcli pretty device wifi list Wi Fi scan list (wlan0) IN USE BSSID SSID MODE CHAN RATE SIGNAL> > CC:81:DA:5B:10:98 2.4G Infra 7 270 Mbit/s 92 > 22:59:57:DD:90:63 田震天啊天震田 Infra 1 270 Mbit/s 65 > C4:70:AB:3B:5A:EF 201 Infra 1 130 Mbit/s 65 > 6A:70:AB:3B:5A:EC Infra 1 130 Mbit/s 65 > 48:A0:F8:22:BB:2D ChinaNet KQXN Infra 3 130 Mbit/s 65 > 10:C1:72:2F:AD:FC ChinaNet kWCT Infra 11 130 Mbit/s 64 > B0:DF:C1:76:C5:21 Infra 2 195 Mbit/s 62 > 66:9A:08:0C:57:D4 aWiFi 204 Infra 3 270 Mbit/s 62 > 1C:60:DE:96:19:16 26JK Infra 6 270 Mbit/s 60 > 1C:60:DE:78:D8:D2 EDwinLam. Infra 1 270 Mbit/s 59 > 64:64:4A:28:14:3F Xiaomi_143E Infra 2 130 Mbit/s 59 > 08:40:F3:27:63:70 大王 Infra 5 270 Mbit/s 59 > 14:A3:2F:62:80:F4 HUAWEI 211 Infra 6 270 Mbit/s 59 > E4:0E:EE:DA:96:A4 w168 Infra 6 270 Mbit/s 59 > 66:9A:08:0C:2D:34 aWiFi 305 Infra 6 270 Mbit/s 59 > 00:E0:4C:2B:2F:F3 UU加速盒 2FF2 Infra 11 270 Mbit/s 59 > 74:50:4E:8D:51:69 Infra 5 270 Mbit/s 57 > 76:50:4E:1D:51:69 207 Infra 5 130 Mbit/s 57 > lines 1 23 ``` #### 如何打开 WIFI AP 热点模式（需替换 rtl8189fs wifi 模组） 基于 nmtui 联网成功后改用 nmcli 命令。 `nmcli device wifi hotspot ifname wlan0 con name MyHostspot ssid MyHostspotSSID password 12345678` 即可创建 MyHostspotSSID 的 ap 热点。 ![nmcli_ssid](./../assets/nmcli_ssid.png) > 目前 rtl8723bs WIFI 能打开，但连上会重启板子，网卡驱动问题暂时不修，更换成 rtl8189fs 即可正常使用。 #### 如何修改连接的 WIFI 账号密码（已过时） 默认 WIFI 账号密码配置存放在 `/boot/wpa_supplicant.conf` 里，测试过并支持 Android 手机开放的 WPA PSK2 热点，配置修改后会在重启后生效（**建议用 nmtui connect 进行配置连接**)。 ```bash root@AXERA:~# cat /boot/wpa_supplicant.conf ctrl_interface DIR /var/run/wpa_supplicant GROUP netdev update_config 1 network { ssid \"Sipeed_Guest\" key_mgmt WPA PSK psk \"qwert123\" } ``` #### 如何扫描 WIFI 热点（已过时） 这需要了解 iwconfig 和 iwlist 命令去管理 WIFI 网卡，例如 WIFI 扫描方法 `iwlist wlan0 scanning`，由于 iwconfig 只支持无密码和 WEP 认证的热点，所以现已不使用这个命令，仅供简单的查询热点或测试 WIFI 的好与坏。 ``` root@AXERA:~# iwlist wlan0 scanning wlan0 Scan completed : Cell 01 Address: 58:41:20:05:07:96 ESSID:\"Sipeed_Guest\" Protocol:IEEE 802.11bgn Mode:Master Frequency:2.412 GHz (Channel 1) Encryption key:on Bit Rates:300 Mb/s Extra:wpa_ie dd160050f20101000050f20401000050f20401000050f202 IE: WPA Version 1 Group Cipher : CCMP Pairwise Ciphers (1) : CCMP Authentication Suites (1) : PSK Extra:rsn_ie 30140100000fac040100000fac040100000fac020000 IE: IEEE 802.11i/WPA2 Version 1 Group Cipher : CCMP Pairwise Ciphers (1) : CCMP Authentication Suites (1) : PSK Quality 100/100 Signal level 100/100 Extra:fm 0003 Cell 02 Address: 0C:3A:FA:0E:81:7F ESSID:\"\" Protocol:IEEE 802.11bgn Mode:Master Frequency:2.412 GHz (Channel 1) Encryption key:off Bit Rates:144 Mb/s Quality 100/100 Signal level 88/100 Extra:fm 0001 Cell 03 Address: 64:64:4A:88:7F:06 ESSID:\"Reachintelligent\" Protocol:IEEE 802.11bgn Mode:Master Frequency:2.412 GHz (Channel 1) Encryption key:on Bit Rates:144 Mb/s Extra:rsn_ie 30140100000fac040100000fac040100000fac020c00 IE: IEEE 802.11i/WPA2 Version 1 Group Cipher : CCMP Pairwise Ciphers (1) : CCMP Authentication Suites (1) : PSK IE: Unknown: DD7B0050F204104A0001101044000102103B00010310470010876543219ABCDEF0123464644A887F04102100067869616F6D69102300045241373210240004303030321042000531323334351054000800060050F20400011011000C5869616F4D69526F75746572100800020000103C0001031049000600372A000120 Quality 100/100 Signal level 100/100 Extra:fm 0003 ``` > 目前所有的网络配置都会在重启后自动生效，如果想要自己手工控制网卡的开关，请了解一下 ifup 或 ifdown 命令的用法，类似 ifup eth0 启动 eth0 网卡，ifdown eth0 force 强制关闭 eth0 网卡等。 ## 系统配置 ### 系统时间 Maix III AXera Pi 开发板的 Linux 系统默认使用 NTP 协议获取系统时间，可以使用 `date` 命令查看当前系统时间。 > 如果联网了会自动使用 `ntp debian` 同步时间，没有同步则说明没有网络，没有同步 `apt update` 更新软件也会失败。 ### 安装软件 Maix III AXera Pi 开发板的 Linux 系统可以通过 `apt` 更新软件。 比如安装 gcc gdb ffmpeg 等常用 Linux 软件，只需要使用下述命令即可，其他软件安装也同理。 ```bash sudo apt update sudo apt install gcc gdb ffmpeg ``` .. details::点此展开查看示例图 ![apt](./../assets/apt.jpg) > 由于 Linux 系统直接断电可能会导致文件系统损坏，如果可以的话建议按下述命令去进行开关机，可以避免一些由于直接断电系统损坏导致的奇怪问题出现。 ### 重启系统 Maix III AXera Pi 开发板的 Linux 系统可以通过 `reboot` 命令重启，重启命令如下： ```bash reboot ``` ### 关闭系统 Maix III AXera Pi 开发板的 Linux 系统可以通过 `poweroff` 命令关闭，关闭命令如下： ```bash poweroff ``` ### 磁盘扩容 基于一些用户可能有扩容分区的需求，因此在这里添加在 AXera Pi 上给板子扩容或者是建立新分区的内容。 操作方法 首先需要烧录完上方的 debian11 的镜像系统后，再使用 AXera Pi 登陆上 Linux 系统来进行磁盘扩容分区。 >[点击查看 AXera Pi 登陆方式](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/basic_usage.html#%E7%B3%BB%E7%BB%9F%E7%99%BB%E5%BD%95) 成功登陆到 AXera Pi 上后，用户可以先使用 `lsblk` 命令来查看设备当前的存储情况。接着使用 `cfdisk /dev/mmcblk2` 来进行磁盘分区扩容的操作。（`mmcblk2` 是我们进行操作的区域名称也称设备名） .. details::点击查看配置示意图 ![cfdisk](./../assets/cfdisk mmcblk2.jpg) 运行命令后终端会弹出下图操作界面，由 `Free space` 可见存储空间还余 `4.3G`，用户可使用键盘上的方向键移动选择我们要扩容的分区 `/dev/mmcblk2p2` 。 .. details::点击查看配置示意图 ![rizese mmcblk2](./../assets/rizese mmcblk2.png) 选择上图的 `Resize` 按下**回车键**对当前分区进行缩容或扩容，界面会跳出提示用户修改新的分区大小。 .. details::点击查看配置示意图 ![new resize](./../assets/new resize.png) 修改后敲**回车键**确定，终端界面会回到原页面。这时我们已经完成对分区扩容的修改了，还需要把改动的部分写入磁盘。在页面选择 `Write` 并敲**回车键**后输入 `yes` 确定将改动分区表写入磁盘中，再敲**回车键**即可。 .. details::点击查看配置示意图 ![write disk](./../assets/write disk.png) 操作后会返回原界面，选择 `Quit` 退出即可。 .. details::点击查看配置示意图 ![quit](./../assets/quit.jpg) 接下来使用命令行 `df h` 查询磁盘使用空间的情况，终端会显示用户没改动之前的使用情况，需要我们使用命令 `resize2fs /dev/mmcblk2p2` 来调整文件系统的大小实现对 `mmcblk2` 分区的扩容，再使用 `df h` 查询就可以看到磁盘改动后的情况。 .. details::点击查看配置示意图 ![df mmcblk2](./../assets/df mmcblk2.jpg) > **注意**：如果调整完文件系统的大小后使用 `df h` 查询磁盘信息依旧是改动前的信息，可使用 `reboot` 重启设备后在查询。 ### 开机启动脚本 系统已经内置好 `/boot/rc.local` 的开机启动脚本，用户可参照以下示例进行修改。 开机启动脚本是在 / 根目录下运行的，举例来说，如果想要开机启动 `/home/run.sh` 脚本。 1. 用绝对路径挂后台运行程序 `/home/run.sh & ` 才可以确保开机后进入 shell 命令终端。 2. 【推荐】用相对路径挂后台运行程序 `cd /home && ./run.sh &` 注意此时 pwd 和绝对路径是不一样。 请先验证好可以在 / 根目录下启动后再放入以下的开机脚本中，不会就抄以下脚本的例子。 ```bash root@AXERA:~# cat /boot/rc.local #!/bin/sh # this file is called by /etc/rc.local at boot. # systemctl stop usb gadget@g0 # mkdir p /mnt/udisk && mount /dev/sda1 /mnt/udisk # python3 /mnt/udisk/alltest.py # this control lcd backlight(50 ~ 1000) echo 0 > /sys/class/pwm/pwmchip0/export echo 1000 > /sys/class/pwm/pwmchip0/pwm0/period echo 500 > /sys/class/pwm/pwmchip0/pwm0/duty_cycle echo 1 > /sys/class/pwm/pwmchip0/pwm0/enable # wifi connect ssid Sipeed_Guest pasw qwert123 nmcli device wifi connect Sipeed_Guest password qwert123 if [ f \"/root/boot\" ]; then cd /root/ && chmod 777 * && ./boot & elif [ d \"/root/app\" ]; then cd /root/app && chmod 777 * if [ f \"./main\" ]; then ./main & elif [ f \"./main.bin\" ]; then ./main.bin & elif [ f \"./main.py\" ]; then python3 ./main.py & fi else aplay /home/res/boot.wav >/dev/null 2>&1 & /opt/bin/sample_vo_fb v dsi0@480x854@60 m 0 >/dev/null 2>&1 & sleep 0.8 && /home/fbv 1.0b/fbv /home/res/2_480x854.jpeg && killall sample_vo_fb & python3 c \"import os, binascii; os.system('sed i \\'/iface eth0 inet dhcp/ahwaddress ether {}\\' /etc/network/interfaces'.format(binascii.hexlify(bytes.fromhex(open('/proc/ax_proc/uid').read().split('0x')[1][: 5]),':').decode('iso8859 1'))) if os.system('grep \\'hwaddress ether\\' /etc/network/interfaces q') ! 0 else exit();\" & fi exit 0 ``` .. details::点此展开查看示例图 ![start](./../assets/start.jpg) 下面是启动日志（截取）： ![m3axpi_debian_boot_log_screenshot](./../../../en/maixiii/ax pi/assets/flash_system/m3axpi_debian_boot_log_screenshot.png) 1. 虽然上面显示 `DRAM: 1 GiB`，但是在系统中弄可以查到实际的存储是 `2 GiB`. 2. 因物料更换屏幕现有不同的版本，需区别版本以及使用屏幕时出现锯齿等画面请移步到[ Maix III 系列 AXera Pi 常见问题(FAQ) ](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/faq_axpi.html#Q：硬件物料更改说明、没有 wlan0 、屏幕烧屏、摄像头倒过来怎么解决？)查询。 ### 更新内核与驱动 在 SD 卡的第一分区会挂载到系统根目录下的 /boot 系统启动相关的文件，替换它后重启（reboot）即可完成更新。 boot.bin 芯片 spl 初始化程序 uboot.bin uboot 启动引导程序 kernel.img linux 内核 dtb.img linux 设备树 例如： 更新设备树可以用 `cp /boot/dtb.img.lcd20221025 /boot/dtb.img` 更新内核驱动可以用 `cp /boot/kernel.img.rtl8723bs /boot/kernel.img` 最后 reboot 即可生效。 ## 如何传输文件 > 如果在使用 AXera Pi 途中出现从设备到电脑端文件互传的需求，可根据以下的方式进行传输： ### 使用读卡器物理拷贝文件 **物理传输**：由于 Linux 系统采用 `ext4` 分区在 Windows / Mac 默认系统下无法进行查看，用户需额外安装增强工具才能读取到具体的分区。而 Linux 系统可直接看到卡里的分区和内容，也可以选择把读卡器接到安卓设备通过 **OTG** 转接头实现文件拷贝。 [如何在 Windows 下访问 ext4 格式的硬盘？](https://zhuanlan.zhihu.com/p/448535639) [[macOS] 在 macOS 上挂载 Linux 的 ext/ext3/ext4 文件系统](https://blog.twofei.com/773/) ### 板子与电脑的文件互传 > 基于让用户的使用更加快速便捷，还可以选择直接在板子上与电脑端通过工具实现文件互传。 **使用 SSH 远程管理工具进行文件传输：** 使用前需要使用 `ifconfig` 查询板子的 IP 地址做登录备用，可点击前往[系统登录](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/basic_usage.html#%E5%9F%BA%E4%BA%8E ip %2B ssh %E7%99%BB%E5%BD%95)查看。在 Windows 上有众多远程管理 Linux 服务器的工具都提供了文件传输的功能，这里推荐免费绿色的 **Mobaxterm** 工具。 [如何使用 MobaXterm](https://wiki.sipeed.com/hardware/zh/maixII/M2/tools/mobaxterm.html) [利用 MobaXterm 实现 Linux 和 Windows 之间传输文件](https://jingyan.baidu.com/article/9f63fb91e2bc6688400f0e93.html) [用 MobaXterm 在 Linux 和 Windows 之间上传/下载文件](https://blog.csdn.net/unforgettable2010/article/details/123930796) > 如果想了解更多的工具可点击[【推荐7款超级好用的终端工具 —— SSH+FTP】](https://zhuanlan.zhihu.com/p/301653835)查看，而其他系统都提供了好用的命令行终端，支持 SSH 、scp 等命令直接执行。 **使用 scp 命令复制文件：** 和 cp 复制文件等命令一样，它就是 `ssh + cp scp` 这个意思。 [Linux 操作系统 scp 命令使用方法](https://cloud.tencent.com/developer/article/1876623) **使用有线串口互传文件：** 使用前根据串口 serial 登录接线配置参数连上板子，安装 `apt get install lrzsz` 工具后可参考以下文章。 [有线串口 serial 登录](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/basic_usage.html#%E6%9C%89%E7%BA%BF %E4%B8%B2%E5%8F%A3 serial %E7%99%BB%E9%99%86) 使用命令行工具 `minicom D /dev/ttyUSB0 b 115200` 可以查看[ Ubuntu 中使用 minicom 玩转文件的上传与下载](https://blog.csdn.net/wanyeye/article/details/42002377)。 使用 MobaXterm 可以点击 [MobaXterm 使用 rz/sz 传送文件](https://blog.csdn.net/qq_28837389/article/details/120073720)查看。 ## 验证系统外设 ### 系统预置的资源 Maix III AXera Pi 开发板的 Linux 系统预置了一些资源，可以通过 `ls /opt` 命令来查看。 ```bash root@AXERA:~# ls /opt bin include lib scripts share ``` 还有一些在 `home` 目录下： ```bash root@AXERA:~# tree L 1 /home ├── ax samples # npu ai sdk ├── examples # 一些开箱示例 ├── fbv 1.0b # fbv 图片查看器 ├── images # 一些测试图片 ├── libmaix # simple pipeline sdk ├── models # 内置的 AI 模型 ├── res # 一些图像字体资源 ├── systemd usb gadget # 配置 usb 服务 ├── usb uvc gadget # 配置 uvc 服务 └── ustreamer # mjpeg 图传 ``` 板子已经预置了 `gcc g++ gdb libopencv ffmpeg` 等工具，可直接在板上编译运行程序。 可参考下方使用方法： ```bash cd /home/libmaix/examples/axpi/ python3 project.py build fbon ./dist/start_app.sh ``` .. details::点击查看示例效果 使用命令行后会打印大量数据信息并启动摄像头及屏幕。 ![libmaix](./../assets/libmaix.jpg) 而 axsample 已经预编译好了，相关 joint 模型已内置在 `/home/models/` 下便于用户查询。 ```bash /home/ax samples/build/install/bin/ax_yolov5s m /home/models/yolov5s.joint i /home/images/cat.jpg r 10 fbon fbv yolov5s_out.jpg ``` .. details::点击查看效果 输入上方命令后屏幕会显示 yolovs_out.jpg 图像 ![cat](./../assets/cat.jpg) 可以在联网后直接 `git pull` 更新仓库的提交记录，如果不能访问 github 的话就设置一下 `git remote` 从 gitee 拉取代码吧。 > **注意**：使用 xxxx menuconfig 报错请移步[Maix III 系列 AXera Pi 常见问题（FAQ）](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/faq_axpi.html) ### 排针引脚图 ![layout_axpi](./../assets/layout_axpi_1.png) ### RTC 使用 `ls /sys/class/rtc` 查询会出现 /dev/rtc0 和 /dev/rtc1，分别是外部电池以及芯片内部的 rtc 时钟。 **查看时间** ```bash cat /sys/class/rtc/rtc0/time && cat /sys/class/rtc/rtc0/date cat /sys/class/rtc/rtc1/time && cat /sys/class/rtc/rtc1/date ``` ```bash root@AXERA:~# cat /sys/class/rtc/rtc0/time && cat /sys/class/rtc/rtc0/date 08:13:30 2022 08 19 ``` **设置时间** 使用 `hwclock w f /dev/rtc0` 或 `hwclock w f /dev/rtc1` 写入。 只有这个方法可以写进去，确认 RTC 是否写入成功，只需要断电后重启的时间不为 1970 就行。 ### CPU & RAM 默认 800MHz 可以调到 1ghz. ```bash root@AXERA:~# ax_lookat 0x01900000 s 33 0x1900000:00000033 root@AXERA:~# ax_clk AX620A: DDR: 3733 MHz CPU: 800 MHz BUS of VPU: 624 MHz BUS of NPU: 624 MHz BUS of ISP: 624 MHz BUS of CPU: 624 MHz NPU OTHER: 800 MHz NPU GLB: 24 MHz NPU FAB: 800 MHz NPU CORE1: 800 MHz NPU CORE0: 800 MHz ISP: 533 MHz MM: 594 MHz VPU: 624 MHz root@AXERA:~# ax_lookat 0x01900000 s 35 0x1900000:00000035 root@AXERA:~# ax_clk AX620A: DDR: 3733 MHz CPU: 1000 MHz BUS of VPU: 624 MHz BUS of NPU: 624 MHz BUS of ISP: 624 MHz BUS of CPU: 624 MHz NPU OTHER: 800 MHz NPU GLB: 24 MHz NPU FAB: 800 MHz NPU CORE1: 800 MHz NPU CORE0: 800 MHz ISP: 533 MHz MM: 594 MHz VPU: 624 MHz root@AXERA:~# ``` 目前硬件内存虽然是 2g 但在系统上只能看到 745M ，不用担心，这是目前的分配内存过于保守导致的，后续更新内核调整一下 NPU 和 CMM 的内存分配的。**(注：内核已更新，用户空间恢复 1.22G)** ### VIDEO （这是出厂测试硬件用的测试程序，请不要使用它！！因为它画面显示是不正常的！！！） >**注意**：VIDEO 的以下命令只用于测试摄像头硬件是否有成像能用的作用，正常效果角度请点击应用传送门查看！！ >内置开箱应用传送门：[点击前往](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/basic_usage.html#%E5%86%85%E7%BD%AE%E5%BC%80%E7%AE%B1%E5%BA%94%E7%94%A8) 目前系统的摄像头驱动不经过 v4l2 驱动框架，所以必须通过代码配置的方式进行启用，相关摄像头驱动都是在应用层上完成的， gc4653 （基础版）（使用 c 2) os04a10（夜视版）（使用 c 0) ```bash sample_vin_vo c 2 e 1 s 0 v dsi0@480x854@60 ``` .. details::运行上方命令后可看到画面（示例效果） ![video](./../assets/video.jpg) >默认使用的是 gc4653 ，使用 os04a10 请移步[Maix III 系列 AXera Pi 常见问题(FAQ)](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/faq_axpi.html)查询。 ### DISPLAY > 因物料更换屏幕现有不同的版本，需区别版本以及使用屏幕时出现锯齿等画面请移步到[ Maix III 系列 AXera Pi 常见问题(FAQ) ](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/faq_axpi.html#Q：硬件物料更改说明、没有 wlan0 、屏幕烧屏、摄像头倒过来怎么解决？)查询。 目前想要使用 libdrm 需要搭配代码使用，请参考 sdk 的源码实现，因为目前系统还未移植好 gpu 驱动所以无法使用 modetest 进行测试，但可以参考下面进行测试。 测试屏幕是否能用, 可以直接运行命令 `sample_vo v dsi0@480x854@60 m 0` 命令屏幕会显示出彩色条纹。但使用前务必调用 `fboff` 关闭 fb 设备。 目前系统默认使用的是最简单的 framebuffer 显示驱动（/dev/fb0），在系统里内置了 `fbon / fboff / fbv xxx.jpg` 三个命令负责管理 fb 设备的启用和显示。 #### 显示一张图片 ```bash fbon fbv /home/res/logo.png fboff ``` ![fbv_logo](./../assets/fbv_logo.jpg) #### 播放视频 播放视频可以使用 ffmpeg 的命令，但请注意 ffmpeg 播放视频前需要将视频顺时针旋转 90°，将 RGB 视频变成 BGR 格式以及分辨率 resize 改成 480*854。如果出现视频播放速度太快的现象就需要使用 `ffmpeg i /home/kun_1_output.mp4 vf \"setpts 2*PTS\" test3.mp4` 重新生成一个慢速的视频文件，再次播放即可。 ```bash fbon ffmpeg i /home/test3.mp4 pix_fmt rgba f fbdev /dev/fb0 fboff ``` 在 python 中可以使用 `os.system()` 将上面的命令包裹起来，直接在代码里面运行。 ```python import os os.system(\"fbon\") os.system(\"fbv /home/res/logo.png\") os.system(\"fboff\") os.system(\"fbon\") os.system(\"ffmpeg i /home/test3.mp4 pix_fmt rgba f fbdev /dev/fb0\") os.system(\"fboff\") ``` ### NPU 测试 NPU 的示例程序在 `/home/ax samples/build/install` 目录下，已经预编译好了，直接就可以调用并显示运行结果。 ```bash fbon /home/ax samples/build/install/bin/ax_yolov5s m /home/models/yolov5s.joint i /home/images/cat.jpg r 10 fbv yolov5s_out.jpg ``` .. details::点击查看效果 ![cat](./../assets/cat.jpg) ### AUDIO 和桌面系统保持一致，直接可用 alsa utils 进行测试。 **测试脚本**：`speaker test t sine f 440 c1` **录制音频**：`arecord test.wav c 2 f cd d 2` **播放音频**：`aplay test.wav` 录音回放的 `python3` 代码如下： ```python import pyaudio try: chunk 1024 # Each chunk will consist of 1024 samples sample_format pyaudio.paInt16 # 16 bits per sample channels 2 # Number of audio channels fs 44100 # Record at 44100 samples per second time_in_seconds 30 p pyaudio.PyAudio() stream p.open(format sample_format, channels channels, rate fs, frames_per_buffer chunk, input True, output True) # Store data in chunks for 3 seconds for i in range(0, int(fs / chunk * time_in_seconds)): data stream.read(chunk) stream.write(data) finally: # Stop and close the Stream and PyAudio stream.stop_stream() stream.close() p.terminate() ``` 可以在 alsamixer 配置你的设备，如果不了解的话建议不要修改。 ![alsamixer](./../assets/alsamixer.jpg) ### USB >**注意**：由于芯片只有一个完整功能的 usb2.0，同一时刻下只有一个使用方向如 OTG 从机或 HOST 主机。 #### 如何配置 USB OTG 虚拟网卡 RNDIS usb0 有线 ssh 登录 默认就会启动配置 `systemctl enable usb gadget@g0`，启动用 `systemctl start usb gadget@g0`，停止开机启动用 `systemctl disable usb gadget@g0`，停止服务用`systemctl stop usb gadget@g0`。 此时使用命令 `sshpass p root ssh root@192.168.233.1` 即可连接，账号及密码都是 root 。 ![ssh usb](./../assets/ssh usb.jpg) #### 如何配置 USB OTG 虚拟串口 /dev/ttyGS0 并转发登录接口 停止 usb gadget@g0 后使用 `systemctl start usb gadget@g1` 即可看到，然后使用 `systemctl start getty@ttyGS0` 即可转发串口终端到 usb 的虚拟串口上。 ![usb_tty](./../assets/usb_tty.jpg) #### 如何使用 USB HOST 读取一个 256M 的 SD 卡 先关了 otg 的 rndis 后再 lsusb 就可以看到了。 >我们在 debian 系统上配置了 usb gadget@g1 和 usb gadget@g0 两个服务。 ```bash root@AXERA:~# systemctl stop usb gadget@g0 root@AXERA:~# lsusb Bus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub Bus 001 Device 002: ID 067b:2731 Prolific Technology, Inc. USB SD Card Reader Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub root@AXERA:~# fdisk l Disk /dev/mmcblk2: 58.94 GiB, 63281561600 bytes, 123596800 sectors Units: sectors of 1 * 512 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disklabel type: dos Disk identifier: 0x32eb5429 Device Boot Start End Sectors Size Id Type /dev/mmcblk2p1 * 2048 264191 262144 128M c W95 FAT32 (LBA) /dev/mmcblk2p2 264192 123596799 123332608 58.8G 83 Linux Disk /dev/sda: 240 MiB, 251658240 bytes, 491520 sectors Disk model: SD Card Reader Units: sectors of 1 * 512 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disklabel type: dos Disk identifier: 0x0607cfd2 Device Boot Start End Sectors Size Id Type /dev/sda1 * 240 490239 490000 239.3M e W95 FAT16 (LBA) root@AXERA:~# mkdir /mnt/sdcard && mount /dev/sda1 /mnt/sdcard ``` 一步到位挂载 U 盘第一分区的命令 `systemctl stop usb gadget@g0 && lsusb && mkdir p /mnt/udisk && mount /dev/sda1 /mnt/udisk` #### 如何配置 USB OTG 虚拟一个 USB 摄像头 **usb uvc gadget**：[usb uvc gadget](https://github.com/junhuanchen/usb uvc gadget) **更多详情请移步内置应用查看**：[应用传送门](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/basic_usage.html#UVC %E8%99%9A%E6%8B%9F USB %E6%91%84%E5%83%8F%E5%A4%B4) #### 如何配置 USB HOST 读取一个 USB 摄像头 >适配 usb 摄像头前我们需要给板子接上以太网 `eth0`，使用 `ifconfig` 查询以太网的 `IP` 方便我们使用。 >如果获取不到以太网的 `IP` 地址，请移步右侧进行重新启动/配置[点击前往相关](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/basic_usage.html#%E6%9C%89%E7%BA%BF%E4%BB%A5%E5%A4%AA%E7%BD%91%EF%BC%88eth0%EF%BC%89%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95)。 **Ustreamer**：[点击查看相关仓库](https://github.com/pikvm/ustreamer) 运行下方的命令行，终端会弹出调试信息无明显报错后，打开任意浏览器输入我们刚获取的以太网 `IP` 地址，进入 `ustreamer` 使用体验拍照及录像功能。 ```bash /home/ustreamer/ustreamer device /dev/video0 host 0.0.0.0 port 80 ``` ![ustreamer_adb](./../assets/ustreamer_adb.png) `snapshot` 为拍照功能，`stream` 为视频功能。 ![ustreamer](./../assets/ustreamer.png) .. details::点击查看效果图 ![ustreamer_snapshot](./../assets/ustreamer_snapshot.jpg) **使用 Opencv 读取 USB 摄像头** 可在终端进入 `python3` 模式运行以下代码即可使用 USB 摄像头进行拍照。 ```python import os import cv2 video cv2.VideoCapture(0) for i in range(30): ret, frame video.read() if ret: cv2.imwrite(\"/tmp/capture.jpg\", frame) os.system(\"fbon && fbv /tmp/capture.jpg\") ``` .. details::点击查看终端运行图以及效果图 ![opencv](./../assets/opencv.jpg) ![opencv_cream](./../assets/opencv_cream.jpg) >运行出现报错请移步[Maix III 系列 AXera Pi 常见问题(FAQ)](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/faq_axpi.html)进行查询。 ### GPIO #### 进入休眠模式：通过按 awake 键唤醒 使用下文命令可进入休眠模式，但需注意（部分因 WiFi 模块旧 `RTL8723bs` 版本）的问题会导致命令报错（可进行多次尝试）进入休眠后终端会掉线，通过 `awake` 键可重新唤醒。 ``` echo mem > /sys/power/state ``` #### 读取 KEY 按键输入：GPIO2 21 ```bash echo 85 > /sys/class/gpio/export echo in > /sys/class/gpio/gpio85/direction cat /sys/class/gpio/gpio85/value ``` #### 点亮 LED 灯 GPIO2 A4 A5 68 69 ```bash echo 68 > /sys/class/gpio/export echo out > /sys/class/gpio/gpio68/direction echo 1 > /sys/class/gpio/gpio68/value sleep 1 echo 0 > /sys/class/gpio/gpio68/value sleep 1 echo 1 > /sys/class/gpio/gpio68/value ``` > 计算规则 GPIO2 A4 32 * 2 + 4 68 对于爱芯的芯片，GPIO0 和 GPIO2 对应 A 和 C ，此处 A4 并不代表 GPIO2 只是序号。 也就是 GPIO2 A4 在标准设备中的定义为 GPIO C(2) 4(A4) 同理 GPIOA0 对应 GPIO0A4。 以后主流会统一到 PA0 或 PC4 这类定义，方便不同芯片共同定义。 使用 Python 控制排针上的 GPIO 方法举例，可见排针上的 BOT_GPIO_0 7 对应 GPIO2_A16_m GPIO2_A23_m 喔。 ![io_pin_map](./../assets/io_pin_map.png) 可见排针的 PA0 3 与上图的关系。 ![gpio_axpi](./../assets/gpio_axpi.png) 先在 python3 中加载简易封装 gpio 类，使用的是 linux 的 libgpiod 的 python 版本。 ```python try: from gpiod import chip, line, line_request config None # rpi is default value A 0 def gpio(gpio_line 0, gpio_bank \"a\", gpio_chip 0, line_mode line_request.DIRECTION_OUTPUT): global config if config ! None and gpio_line in config: gpio_bank, gpio_chip config[gpio_line] l, c [32 * (ord(gpio_bank.lower()[0]) ord('a')) + gpio_line, chip(\"gpiochip%d\" % gpio_chip)] tmp c.get_line(l) cfg line_request() # led.active_state line.ACTIVE_LOW cfg.request_type line_mode # line.DIRECTION_INPUT tmp.request(cfg) tmp.source \"GPIO chip %s bank %s line %d\" % (gpio_chip, gpio_bank, gpio_line) return tmp def load(cfg None): global config config cfg except ModuleNotFoundError as e: pass ``` GPIO 输入测试： ```python led0 gpio(16, gpio_chip 2, line_mode line_request.DIRECTION_INPUT) led1 gpio(17, gpio_chip 2, line_mode line_request.DIRECTION_INPUT) led2 gpio(18, gpio_chip 2, line_mode line_request.DIRECTION_INPUT) led3 gpio(19, gpio_chip 2, line_mode line_request.DIRECTION_INPUT) def test(): import time print(led0.get_value()) print(led1.get_value()) print(led2.get_value()) print(led3.get_value()) time.sleep(1) print(time.asctime()) while True: test() ``` GPIO 输出测试： ```python led0 gpio(16, gpio_chip 2, line_mode line_request.DIRECTION_OUTPUT) led1 gpio(17, gpio_chip 2, line_mode line_request.DIRECTION_OUTPUT) led2 gpio(18, gpio_chip 2, line_mode line_request.DIRECTION_OUTPUT) led3 gpio(19, gpio_chip 2, line_mode line_request.DIRECTION_OUTPUT) def test(): import time time.sleep(1) led0.set_value(1) led1.set_value(1) led2.set_value(1) led3.set_value(1) time.sleep(1) led0.set_value(0) led1.set_value(0) led2.set_value(0) led3.set_value(0) print(time.asctime()) while True: test() ``` [可参考的 gpio.h/gpio.c 代码](https://www.cnblogs.com/juwan/p/16917802.html#linux spiv) ### UART > 关闭 ttyS0 交互在开机后用 `systemctl stop serial getty@ttyS0.service` 串口就不会再出现交互了，但彻底禁用遇到点问题，重启后会恢复，待研究。 系统输出默认是 **ttyS0** ，排针上的是 **ttyS1** ，而虚拟串口是 **ttyGS0**。 ![uart_tty](./../assets/uart_tty.jpg) 可用 `python3 pyserial` 库来测试功能的好与坏，但是需要注意排针丝印可能不准确。 如果出现串口的 tx 和 rx 没有数据的话可以反接一下，以及确保是共地的。 ```python import serial ser serial.Serial('/dev/ttyS1', 115200, timeout 1) ser.write(b'hello world\\n') ser.close() ``` [可参考的 uart.h/uart.c 代码](https://www.cnblogs.com/juwan/p/16917802.html#linux uart ttysx) ### PWM 以配置一个 pwm0 修改屏幕背光为例，需更新到 **20221201** 后的镜像。 **例**：`echo 204 > /sys/class/pwm/pwmchip0/pwm0/duty_cycle` 运行后屏幕亮度只有十分之一. ```bash echo 0 > /sys/class/pwm/pwmchip0/export echo 4167 > /sys/class/pwm/pwmchip0/pwm0/period echo 204 > /sys/class/pwm/pwmchip0/pwm0/duty_cycle echo 2084 > /sys/class/pwm/pwmchip0/pwm0/duty_cycle echo 1 > /sys/class/pwm/pwmchip0/pwm0/enable ``` PWM 使用参考：[点击查看](https://wiki.sipeed.com/soft/maixpy3/zh/usage/hardware/PWM.html#%E5%BC%80%E5%A7%8B) ### I2C > m3axpi 的排针上的 I2C 是 /dev/i2c 7 对应 `i2cdetect y r 7` 喔， 0 1 2 是摄像头的， 8 是系统的 usb rtc 的， 9 做预留。 使用 i2c tools 工具包，可使用 i2cdetect y 0 来查看 i2c 总线上的设备。 如果出现 i2c 设备扫不到的情况需要接一下上拉电阻。 ```bash root@AXERA:~# i2cdetect y r 0 0 1 2 3 4 5 6 7 8 9 a b c d e f 00: 10: 20: 21 30: 36 40: 50: 60: 70: root@AXERA:~# ``` 这里 **0x21** 和 **0x36** 就代表的板子在 cam0 这个排线上的 /dev/i2c 0 设备存在某个摄像头的 i2c 设备，而读写可用 i2cget 和 i2cset 命令，与其他芯片皆为同理。 ### SPI 可参考右边同理事例：[为 AW V831 配置 spidev 模块，使用 py spidev 进行用户层的 SPI 通信。](https://www.cnblogs.com/juwan/p/14341406.html) ``` root@AXERA:~# ./spidev_test D /dev/spidev1.0 v spi mode: 0x0 bits per word: 8 max speed: 500000 Hz (500 KHz) TX FF FF FF FF FF FF 40 00 00 00 00 95 FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF F0 0D ......@....�..................�. RX FF FF FF FF FF FF 40 00 00 00 00 95 FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF F0 0D ......@....�..................�. root@AXERA:~# ./spidev_test D /dev/spidev1.0 v spi mode: 0x0 bits per word: 8 max speed: 500000 Hz (500 KHz) TX FF FF FF FF FF FF 40 00 00 00 00 95 FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF F0 0D ......@....�..................�. RX FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF ................................ root@AXERA:~# ./spidev_test D /dev/spidev1.0 v spi mode: 0x0 bits per word: 8 max speed: 500000 Hz (500 KHz) TX FF FF FF FF FF FF 40 00 00 00 00 95 FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF F0 0D ......@....�..................�. RX FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF ................................ ``` ### CHIP ID 获取芯片唯一的 id 码。 ``` cat /proc/ax_proc/uid ``` ### ADC（暂未支持） .. details::点击查看 硬件上支持，但软件上目前还没写调试工具配合。 可参考外围开发手册，这需要专用的代码控制，目前还没有全部补充完。 1. 设置 THM 寄存器 2. 中间需要 delay 一段时间，否则读取出来的值，可能不对. 3. 0x2000028 寄存器读取出来的值 DATA 4. DAT 和 voltage 的对应关系，voltage DATA / 1024 * VREF(1.8V) 5. 如果读取 chan1/2/3/4，需要读取 0x200002c，0x2000030，0x2000034，0x2000038 使能 ADC 通道 devmem 0x2000020 32 0x1000 //chan0 devmem 0x2000020 32 0x800 //chan1 devmem 0x2000020 32 0x400 //chan2 devmem 0x2000020 32 0x200 //chan3 devmem 0x2000020 32 0x100 //chan4 devmem 0x200002c devmem 0x2000030 devmem 0x2000034 devmem 0x2000038 ### 出厂测试脚本 .. details::点击可查看产品出厂测试时用的 Python 测试脚本 ```python test_flag False try: from gpiod import chip, line, line_request config None # rpi is default value A 0 def gpio(gpio_line 0, gpio_bank \"a\", gpio_chip 0, line_mode line_request.DIRECTION_OUTPUT): global config if config ! None and gpio_line in config: gpio_bank, gpio_chip config[gpio_line] l, c [32 * (ord(gpio_bank.lower()[0]) ord('a')) + gpio_line, chip(\"gpiochip%d\" % gpio_chip)] tmp c.get_line(l) cfg line_request() # led.active_state line.ACTIVE_LOW cfg.request_type line_mode # line.DIRECTION_INPUT tmp.request(cfg) tmp.source \"GPIO chip %s bank %s line %d\" % (gpio_chip, gpio_bank, gpio_line) return tmp def load(cfg None): global config config cfg except ModuleNotFoundError as e: pass key gpio(21, gpio_chip 2, line_mode line_request.DIRECTION_INPUT) led0 gpio(4, gpio_chip 2, line_mode line_request.DIRECTION_OUTPUT) led1 gpio(5, gpio_chip 2, line_mode line_request.DIRECTION_OUTPUT) import time import ifcfg import os def check_ifconfig(): result [] for name, interface in ifcfg.interfaces().items(): if name in ['eth0', 'wlan0'] and interface['inet']: result.append(name) return result try: if (0 key.get_value()): os.system(\"export LD_LIBRARY_PATH /opt/lib:LD_LIBRARY_PATH && /opt/bin/sample_vin_vo c 2 e 1 s 0 v dsi0@480x854@60 &\") led1.set_value(1) while True: led0.set_value(1) time.sleep(0.2) led0.set_value(0) time.sleep(0.2) tmp check_ifconfig() if len(tmp) > 1: led0.set_value(0) led1.set_value(0) test_flag True break while (0 key.get_value()): time.sleep(0.2) os.system(\"aplay /home/res/boot.wav\") led0.set_value(1) led1.set_value(1) import pyaudio chunk 1024 # Each chunk will consist of 1024 samples sample_format pyaudio.paInt16 # 16 bits per sample channels 2 # Number of audio channels fs 44100 # Record at 44100 samples per second p pyaudio.PyAudio() stream p.open(format sample_format, channels channels, rate fs, frames_per_buffer chunk, input True, output True) while (1 key.get_value()): data stream.read(chunk, exception_on_overflow False) stream.write(data) while (0 key.get_value()): time.sleep(0.2) os.system('killall sample_vin_vo') os.system('killall sample_vin_vo') # Stop and close the Stream and PyAudio stream.stop_stream() stream.close() p.terminate() except Exception as e: print(e) finally: if test_flag: led0.set_value(0) led1.set_value(0) ''' import pyaudio try: chunk 1024 # Each chunk will consist of 1024 samples sample_format pyaudio.paInt16 # 16 bits per sample channels 2 # Number of audio channels fs 44100 # Record at 44100 samples per second time_in_seconds 300 p pyaudio.PyAudio() stream p.open(format sample_format, channels channels, rate fs, frames_per_buffer chunk, input True, output True) for i in range(0, int(fs / chunk * time_in_seconds)): data stream.read(chunk) stream.write(data) finally: # Stop and close the Stream and PyAudio stream.stop_stream() stream.close() p.terminate() ''' ``` ## 内置开箱应用 ### IPCDemo 这是一个典型的 IPC 演示程序，对应的功能模块有： ISP：负责从 Sensor 获取图像 RAW 数据并转为 YUV，最终分 3 路通道输出以上信息。 IVPS：图像视频处理模块。实现对视频图形进行一分多、Resize、Crop、旋转等功能。 VENC / JENC：视频/JPEG 编码输出。 Detect：支持人脸或结构化检测。 Web 显示：实现 H264 流的 Web 传输和提供 Web 方式查看实时视频。 RTSP 推流：实现 H264 流的 RTSP 封装以及传输。 录像 TF 卡存储：封装 H264 流为 MP4 格式文件并保存至 TF 卡或者 FLASH 空间。 <p align \"center\"> <iframe src \"//player.bilibili.com/player.html?aid 260625114&bvid BV1me411T7g8&cid 837160730&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\" style \"max width:640px; max height:480px;\"> </iframe> </p> <p align \"center\"> <iframe src \"//player.bilibili.com/player.html?aid 688159412&bvid BV1p24y1d7Te&cid 837167669&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\" style \"max width:640px; max height:480px;\"> </iframe> </p> #### 使用方法 >**注意**：启动命令默认的镜头型号为 **gc4653** ，因不同的摄像头配置文件不一致，使用别的型号时需点击右侧[更换摄像头](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/faq_axpi.html#Q%EF%BC%9A%E5%A6%82%E4%BD%95%E6%9B%B4%E6%8D%A2 os04a10 %E6%91%84%E5%83%8F%E5%A4%B4%EF%BC%9F)进行修改。 在终端运行下面的命令即可启动网页，服务默认绑定到 0.0.0.0 地址，直接在浏览器输入 usb0 的 IP 即可访问，使用板子上其他 IP 也可以访问页面（例如：`192.168.233.1:8080`）. ```bash /opt/bin/IPCDemo/run.sh /opt/bin/IPCDemo/config/gc4653_config.json ``` .. details::点击查看 输入启动命令后，终端会打印大量调试信息。 ![ipc](./../assets/ipc.jpg) 访问页面后会弹出登录页面，点击登录后页面会弹出下图画面。 ![ipc admin](./../assets/ipc admin.jpg) #### 如何抓拍？如何录制？ 浏览器抓拍录制（web） **抓拍图像** 网页经过上文的启动后显示画面，右下角有抓拍和录制的功能图标。 用户可点击摄像头图标进行抓拍喜欢的场景，抓拍的照片会在页面自动弹出进行下载方便用户查看存储。 ![ipc web](./../assets/ipc web.jpg) **录制视频** 点击右下角的录制图标，即可进入本地录制视频（mp4）模式，再次点击图标即录制完成结束。 ![ipc mp4](./../assets/ipc mp4.jpg) 用户可在配置页面的`录像回放`选项预览视频进行下载到本地或删除的操作。 ![ipc config](./../assets/ipc config.jpg) >**注意**： >版本为 **20221017** 的镜像后默认打开了录制保存到`/opt/mp4`的目录下。 >视频录制要储存到文件系统后才能打开，某种意义上用户也可以挂载网络路径来当监控录像使用。 #### 人脸检测 >IPCDemo 除了上文的基础功能还有进阶的 AI 功能应用，例如**：人脸检测、车牌识别**。 使用前先进行相机结构化配置再进行人脸检测，具体配置参考以下示例。 .. details::点击查看配置流程 接入页面后选择**配置**在**智能配置**里再进行**结构化配置**，用户可根据自己的需要进行勾选即可。 ![ipc video](./../assets/ipc video.jpg) 配置完成后回到预览页面即可进行人脸及人形识别，IPC 会自动框出识别人脸并且截取人脸的图片，可在预览页面下方点击截取图样放大查看附带信息。 左侧：人脸检测 右侧：人形检测 <html> <img src \"./../assets/ipc model.jpg\" width 45%> <img src \"./../assets/ipc person.jpg\" width 45%> </html> #### 车牌识别 使用前先进行**结构化配置**勾选车牌所需的检测画框即可。 .. details::点击查看 IPC 配置流程 接入页面后选择**配置**在**智能配置**里再进行**结构化配置**，用户可根据自己的需要进行勾选即可。 ![ipc video](./../assets/ipc video.jpg) 设置完成即可回到预览页面进行车牌识别，IPC 会自动框出识别到得车牌及读取车牌数字信息，用户在页面下方点击图片可查看截取到的车牌图片及信息。 ![ipc car](./../assets/ipc car.jpg) <! <p align \"center\"> <iframe src \"//player.bilibili.com/player.html?aid 773227207&bvid BV1B14y1Y7A4&cid 837154353&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\" style \"max width:640px; max height:480px;\"> </iframe> </p> > ### RTSP 推流 >**RTSP**：也称实时流传输协议，该协议定义了一对多应用程序如何有效地通过 IP 网络传送多媒体数据。 使用 RTSP 传送数据前，我们需要先认识工具 `VLC Media Player`。 **VLC Media Player**：[点击下载](https://www.videolan.org/vlc/) .. details::点此展开查看 VLC Media Player 介绍 VLC Media Player（VLC 多媒体播放器），是一款可播放大多数格式，而无需安装编解码器包的媒体播放器，以及支持多平台使用、支持 DVD 影音光盘，VCD 影音光盘及各类流式协议。 ![vl yolov5s](./../assets/vlc yolov5s.jpg) 运行下文命令后终端会弹出调试信息，打开 `VLC Media Player` 进行配置网络串流后即可看到画面效果。 ```bash /home/examples/vin_ivps_joint_venc_rtsp_vo_onvif_mp4v2/run.sh ``` .. details::点击查看终端运行图 ![vlr run](./../assets/vlc run.jpg) .. details::点此展开查看 VLC Media Player 配置步骤 打开后在上方选择**媒体**后选择**打开网络串流**进到配置画面。 ![vlc](./../assets/vlc.jpg) 在网络页面输入**网络 URL ：`rtsp://192.168.233.1:8554/axstream0`**， 勾选下方更多选项进行调整缓存后点击下方播放即可。 ![vlc urt](./../assets/vlc urt.jpg) 双屏效果如下： <html> <img src \"./../assets/rtsp display.jpg\" width 48%> <img src \"./../assets/rtsp axpi.jpg\" width 48%> </html> <p align \"center\"> <iframe src \"//player.bilibili.com/player.html?aid 731837313&bvid BV1XD4y1r7eP&cid 866903759&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\"> </iframe> </p> >**注意**：默认摄像头为 gc4653 型号不同请移步[Maix III 系列 AXera Pi 常见问题(FAQ)](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/faq_axpi.html)更换参数。 #### ffplay RTSP 拉流工具除了 `VCL` 还可以直接使用 `ffplay`。 **ffplay** :[点击下载](https://dl.sipeed.com/shareURL/MaixIII/AXera/09_Software_tool) ```bash sudo apt install ffmpeg ffplay rtsp://192.168.233.1:8554/axstream0 fflags nobuffer ``` ### ONVIF ODM 拉流 >版本为 **20221111** 后的镜像系统内置了按键录像 mp4 和支持更换 yolov5s 人脸/物体检测模型以及对软件 ODM（ONVIF）进行支持。 在进行体验之前，我们先来认识即将使用的软件：`ONVIF Device Manager` **ONVIF Device Manager**：[点击下载](https://sourceforge.net/projects/onvifdm/) .. details::点击查看 ONVIF ODM 软件介绍 ONVIF 协议作为全球性的网络视频监控开放接口标准，推进了网络视频在安防市场的应用，特别是促进了高清网络摄像头的普及和运用。 越来越多的前端 IPC 厂家和后端 NVR 及存储提供商加入进来。而 ONVIF Device Manager 是 ONVIF 官方基于协议提供的免费第三方的 ONVIF 协议测试工具，与上文的 VLC 相比性能不同，但 ODM 的内容形式更加多样丰富。 ![odm](./../assets/odm.jpg) 运行下文命令，设备屏幕会跳出 yolov5s 模型运行画面，接着我们来配置 `ODM` 实现 PC 端显示。 ```bash /home/examples/vin_ivps_joint_venc_rtsp_vo_onvif_mp4v2/run.sh ``` .. details::点击设备运行效果图 ![odm mipi](./../assets/odm mipi.jpg) 打开下载好的 `ODM` 软件点击左侧白框的 `Refresh` 按键扫描设备，扫描成功会显示 `IP Camera` 方框点击后选择下方的 `Live video` 即可在 PC 端看到画面。 ![odm config](./../assets/odm config.jpg) 还可通过下方命令去查看文件配置： ```bash cd /home/examples/vin_ivps_joint_venc_rtsp_vo_onvif_mp4v2/ ls l ``` >**注意**：ODM 受网络影响较大，如果有卡顿现象把网络更换成以太网即可。 >默认摄像头为 gc4653 如型号不同请移步[Maix III 系列 AXera Pi 常见问题(FAQ)](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/faq_axpi.html)更换参数。 **更换模型** >**20221116** 后更新的镜像已在 `run.sh` 内置了不同摄像头参数的源码。 >**20221111** 镜像内置 yolov5s 的人脸/物体检测模型，可使用以下命令更改运行脚本内容更换模型。 ``` bash nano /home/examples/vin_ivps_joint_venc_rtsp_vo_onvif_mp4v2/run.sh ``` .. details::点击查看修改操作示例 运行后会显示 `run.sh` 的编辑页面，对当前启动的模型进行注释或调用其他模型即可， 按 **ctrl+X** 键后会提示是否保存修改内容。 ![model save](./../assets/model save.jpg) 根据提示按下 **Y** 键保存，界面会显示修改内容写入的文件名按**回车**键确定， 再次运行 `run.sh` 脚本即可看到模型更换成功。 ![model file](./../assets/model file.jpg) 除了直接在板端修改 `run.sh` 脚本，还可以通过 `MdbaXterm` 软件使用 ssh 登录查看 `/home/examples/vin_ivps_joint_venc_rtsp_vo_onvif_mp4v2/` 目录下的`run.sh` 直接进行修改保存。 **按键录制 MP4** 运行 `run.sh` 期间可按下板载的按键 `user` 进行录制视频，按下后 **LED0** 会亮起代表开始录制 MP4， .. details::点击查看按键示意图 ![odm mp4](./../assets/odm mp4.jpg) 终端界面会显示下图 `delete file`，再次按下按键板卡会停止录制而 LED0 会灭掉， ![odm adb](./../assets/odm adb.png) 录制完成的 MP4 文件可在 **`home/examples/`** 目录下查看。 ![mp4 file](./../assets/mp4 file.png) ### PP Humanseg 人体分割 >版本为 **20221116** 后的系统镜像内置了 `pp_human` 人体分割应用，并且内置了不同摄像头的参数命令在目录下的启动脚本 `run.sh` 里，用户使用只需要修改注释相应命令行即可使用。 运行下方的命令后终端会输出调试信息，设备屏幕会显示运行画面。 ```bash /home/examples/vin_ivps_joint_vo_pp_human_seg/run.sh ``` <! ![pp_human](./../assets/pp_human.jpg) > <p align \"center\"> <iframe src \"//player.bilibili.com/player.html?aid 902571856&bvid BV1iP4y1y75t&cid 889419118&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\"> </iframe> </p> 使用下方命令进入图形化页面，对 `run.sh` 里不同摄像头参数的源码进行调用或注释。 ```bash nano /home/examples/vin_ivps_joint_vo_pp_human_seg/run.sh ``` .. details::点击查看图形化页面 修改后按 **ctrl+x** 退出键会提示是否保存页面，后续按终端提示操作即可。 ![pp_human_adb](./../assets/pp_humana_adb.png) ### UVC 虚拟 USB 摄像头 **usb uvc gadget**：[点击查看相关仓库](https://github.com/junhuanchen/usb uvc gadget) >版本为 **20221123** 的镜像系统内置了 uvc vo 应用，并且还可以在手机端软件使用。 >目前应用还处于不稳定的状态，第一次启动程序会改变 usb otg rndis 转成 usb otg uvc 模式导致设备重启，重启再运行即可，画面绿屏是启动脚本里摄像头配置不对。 使用前准备两条 USB type_c 的数据线以及一条双 type_c 口的数据线。 把设备的 **UART** 及 **OTG** 口用 `USB type c` 线全部接入 `PC` 端，再运行下方命令终端会弹出无报错调试信息。 ```bash /home/examples/vin_ivps_joint_venc_uvc_vo/run.sh ``` .. details::点击查看终端示例图 ![uvc_adb](./../assets/uvc_adb.png) 打开 `PC` 端自带相机应用即可在设备屏幕以及 `PC` 端观察到模型检测画面。 ![uvc_vo](./../assets/uvc_vo.jpg) 可以使用以下的命令行更换尾缀 `start` 开启、`stop` 停止、`restore` 重启来对 `uvc` 程序进行操作。 ```bash /home/usb uvc gadget/uvc gadget.sh #start/stop/restore ``` **手机端虚拟摄像头** UVC 也能在安卓手机端的 `app` 上当虚拟摄像头使用，使用前在软件商店下载好 **USB 摄像头专业版** 软件。 .. details::USB 摄像头专业版软件介绍 USB 摄像头是一款支持 USB 摄像头、适配采集卡等设备通过 OTG 连接手机并驱动设备展示画面。 ![uvc_usb](./../assets/uvc_usb.jpg) 把双头 `type c` 线的分别接上手机端以及设备的 OTG 口，运行上方命令后会自动连接。 ![uvc_phone](./../assets/uvc_phone.jpg) >**注意**：如果需要完全脱离电脑端用手机端供电的话，需要把 uvc 程序写入开机脚本即可。 ### Python API 编程 除了在板端上使用命令行去直接运行程序，还可以使用 Python 来编程直接运行调用 AI 模型和各种库。 **传送门**：[试试 Python 编程](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/python_api.html) <p align \"center\"> <iframe src \"//player.bilibili.com/player.html?aid 518756219&bvid BV1Ug411n7DC&cid 923425798&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\"> </iframe> </p> ### 姿态关键点检测（人体/手势/动物） >镜像已内置了 `人体\\手势\\动物` 等模型及调用命令行在 `/home/run.sh` 目录下，用户可直接修改进行调用。 #### AX POSE PPL 人体姿态关键点 **终端使用命令行调用模型** 用户先修改内置在 `/home/run.sh` 的启动脚本，再运行 `run.sh` 脚本命令调用模型。 **如何修改 `run.sh` 脚本，以人体关键点 `ax_poes` 为例。** ![ax_poes_sh](./../assets/ax_poes_sh.jpg) 使用下文命令进入后找到自己需要调用的模型及命令，使用方向键移动取消注释更换 ` c 2` 不同摄像头参数，然后按 `ctrl+x` 键退出会提示保存，按提示操作即修改完成。 ```bash nano /home/run.sh ``` **修改后在终端输入 `/home/run.sh` 命令运行程序，即可体验人体关键点。** <p align \"center\"> <iframe src \"//player.bilibili.com/player.html?aid 647932316&bvid BV1Pe4y1W7n6&cid 901750338&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\"> </iframe> </p> **前往[试试 Python 编程](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/python_api.html#%E4%BD%BF%E7%94%A8 Python %E8%B0%83%E7%94%A8 ax poes ppl %E6%A8%A1%E5%9E%8B)查看如何使用 `Python` 调用模型示例。** **如何调用运行 `run.sh` 里的更多预置模型。** 我们在 `run.sh` 里预置了调用多种模型的命令行以及相应的摄像头参数。 具体使用可参考上文 `nano /home/run.sh` 进入可视化编辑页面修改，运行启动脚本即可使用。 ```bash sample_vin_ivps_joint_vo sample_vin_ivps_joint_venc_rtsp_vo ``` ```bash yolov5_seg.json yolov7.json yolox.json yolov5s_face.json pp_human_seg.json ax_pose.json hrnet_animal_pose.json hand_pose.json ``` #### HandPose 手势姿态关键点 如上文的 `人体姿态关键点` 修改为示例，直接在 `run.sh` 脚本进行修改（图标注为需取消注释的命令）并运行 `run.sh` 即可体验模型，运行效果可看最下文的视频。 ![hand_run](./../assets/hand_run.jpg) #### HRNet_animal 动物姿态关键点 如上文的 `人体姿态关键点` 修改为示例，直接在 `run.sh` 脚本进行修改（图标注为需取消注释的命令）并运行 `run.sh` 即可体验模型，运行效果可看最下文的视频。 ![animal](./../assets/animal.jpg) <p align \"center\"> <iframe src \"//player.bilibili.com/player.html?aid 903331499&bvid BV1DP4y197hF&cid 909711786&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\"> </iframe> </p> ### LVGL7 UI > 在 **20221125** 后更新的镜像系统里，我们内置了 lvgl7 UI 应用。 **运行应用前请先准备材料：**USB type c 线/USB type c 转换头/无线鼠标。 使用 USB type c 数据线两端分别接入设备的 **UART** 口与电脑端 **USB** 口，再使用转换头的 **USB** 端接入鼠标的 USB 接收器，另一端接入设备 **OTG** 口。 运行下方命令后终端会弹出无报错的启动信息后，屏幕会显示画面用户即可体验 lvgl 应用了。 ``` cd /home ./bin/sample_vin_ivps_joint_vo_lvgl c 0 ``` .. details::点击查看终端示例图 ![lvgi_adb](./../assets/lvgl_adb.png) <p align \"center\"> <iframe src \"//player.bilibili.com/player.html?aid 690497396&bvid BV1n24y1C7DN&cid 901748014&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\"> </iframe> </p> **如何调用运行 `/home/bin` 目录下更多内置应用** 以下应用是内置在 `home/bin` 目录下的，用户可使用 `ls /home/bin` 查询并参考示例调用其余应用。 ```bash root@AXERA:~# ls /home/bin sample_h264_ivps_joint_vo sample_v4l2_user_ivps_joint_vo sample_vin_ivps_joint_vo sample_vin_joint sample_rtsp_ivps_joint sample_vin_ivps_joint_venc_rtsp sample_vin_ivps_joint_vo_h265 sample_rtsp_ivps_joint_rtsp_vo sample_vin_ivps_joint_venc_rtsp_vo sample_vin_ivps_joint_vo_lvgl ``` 例：调用 `sample_vin_ivps_joint_vo_h265` 运行命令如下方示例，` c 2` 为摄像头参数。 ```bash /home/bin/sample_vin_ivps_joint_vo_h265 c 2 ``` .. details::点击查看终端示例图 ![sample](./../assets/sample.jpg) ### 车牌识别（可输出效果） 系统镜像是没有内置任何关于车牌识别的调用命令的，所以我们需要在 `/home/run.sh` 内写入或改动模型名称，再运行车牌识别的应用。 **在 `/home/run.sh` 内写入相关调用命令** 用户先使用 `nano /home/run.sh` 进入编辑页面，再复制下文命令在 `run.sh` 内粘贴并退出保存，然后编辑页面关闭后运行 `/home/run.sh` 体验车牌识别应用。 ``` ./bin/sample_vin_ivps_joint_vo p ./config/license_plate_recognition.json c 2 ``` ![car](./../assets/car.jpg) **在 `/home/run.sh` 内修改其他命令的模型名称** 依旧是先用 `nano /home/run.sh` 进入编辑页面，然后就是将原有的调用的模型名称换成车牌识别的名称（修改完退出并保存）最后运行 `/home/run.sh` 体验车牌识别应用。 ``` license_plate_recognition.json ``` <iframe src \"//player.bilibili.com/player.html?aid 401504443&bvid BV1wd4y1f7g1&cid 1141368672&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\"> </iframe> ### sherpa ncnn 中英文语音识别 >版本为 `20230214` 后的镜像内置了 sherpa ncnn 中英文语音识别应用，`20230223` 模型进行了升级效果更加灵敏，用户可手动升级即可。如出现运行后无反应请先测试 [`AUDIO`](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/basic_usage.html#AUDIO) 基本的录音回放是否可用。 先运行命令先进入到 `/home/sherpa ncnn m3axpi` 的目录下，再运行中英文的启动命令体验语音识别应用。 ```bash cd /home/sherpa ncnn m3axpi ``` 中文语音识别 ```bash ./sherpa ncnn alsa \\ ./sherpa ncnn streaming zipformer zh 14M 2023 02 23/tokens.txt \\ ./sherpa ncnn streaming zipformer zh 14M 2023 02 23/encoder_jit_trace pnnx.ncnn.param \\ ./sherpa ncnn streaming zipformer zh 14M 2023 02 23/encoder_jit_trace pnnx.ncnn.bin \\ ./sherpa ncnn streaming zipformer zh 14M 2023 02 23/decoder_jit_trace pnnx.ncnn.param \\ ./sherpa ncnn streaming zipformer zh 14M 2023 02 23/decoder_jit_trace pnnx.ncnn.bin \\ ./sherpa ncnn streaming zipformer zh 14M 2023 02 23/joiner_jit_trace pnnx.ncnn.param \\ ./sherpa ncnn streaming zipformer zh 14M 2023 02 23/joiner_jit_trace pnnx.ncnn.bin \\ \"hw:0,0\" \\ 4 \\ greedy_search ``` 英文语音识别 ```bash ./sherpa ncnn alsa \\ ./sherpa ncnn conv emformer transducer small 2023 01 09/tokens.txt \\ ./sherpa ncnn conv emformer transducer small 2023 01 09/encoder_jit_trace pnnx.ncnn.int8.param \\ ./sherpa ncnn conv emformer transducer small 2023 01 09/encoder_jit_trace pnnx.ncnn.int8.bin \\ ./sherpa ncnn conv emformer transducer small 2023 01 09/decoder_jit_trace pnnx.ncnn.param \\ ./sherpa ncnn conv emformer transducer small 2023 01 09/decoder_jit_trace pnnx.ncnn.bin \\ ./sherpa ncnn conv emformer transducer small 2023 01 09/joiner_jit_trace pnnx.ncnn.int8.param \\ ./sherpa ncnn conv emformer transducer small 2023 01 09/joiner_jit_trace pnnx.ncnn.int8.bin \\ \"hw:0,0\" \\ 2 \\ greedy_search ``` 运行命令后可对着 AXera Pi 板卡**（麦克风靠近卡槽区域）**说话或播放声音，板卡会自动识别并把结果打印到终端，如下图使用中文运行效果示例。 ![sherpa](./../assets/sherpa.png) **如何升级语音识别模型** > 镜像版本日期为 `20230313` 的已内置好升级版的中文语音识别模型，用户不需要自行下载模型包更新。 使用 `git bash` 用下文命令行把更新的模型包下载到本地备用。 ```bash git lfs install git clone https://huggingface.co/marcoyang/sherpa ncnn streaming zipformer zh 14M 2023 02 23 ``` ![bash_sherpa](./../assets/bash_sherpa.png) 更新包拷贝完成后需放置到 AXera Pi 板卡上的 `/home/sherpa ncnn m3axpi` 相对应目录下，具体的文件传输方法可参考[【文件传输】](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/basic_usage.html#%E5%A6%82%E4%BD%95%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6)进行板卡与电脑互传。 ## 商业应用方案 ### SENSOR 支持双摄方案 > （20230529 GC4653 软件上还不行，图中测试可用的是 os04a10） > （20230412 暂时废弃，目前 GC4653 双摄在软件上调不出来，折衷方案可以用 USB 摄像头过度，只验证过 OS04A10 双摄） 目前 AXera Pi 板卡物理上理论支持 GC4653 及 OS04A10 实现双摄方案，而 GC4653 软件上还不行，图中测试可用的是 OS04A10. OS04A10 在硬件上不支持使用双摄 2 * 4lane，软件上支持但硬件不支持，属于设计意外。 ![os04a10](./../assets/os04a10.jpg) 使用双摄方案需替换相关的设备树文件，此处设备树只是配置 I2C 设备与摄像头型号无关。 详情资料可参考：[资料包。](https://dl.sipeed.com/shareURL/MaixIII/AXera/11_patch/dual_gc4653_patch) ```bash juwan@juwan n85 dls:~/Downloads/m3axpi_dual_gc4653_notes$ tree . . ├── 0001 support dual gc4653 camera.patch // 给软件 sample_vin 的示例补丁，用于说明如何在应用层添加双摄支持。 ├── dtb.img.lcd20221025.dual.gc4653 // 需要更新设备树，主要原因是第二个摄像头的 i2c 设备结点不对需要启用和修改，注 emmc 方案没有这个问题 ├── res.jpg // 用于给硬件接线排查 接线是否正常，正常的情况是怎样的，配合 sample_vin_ c_3 测试确认。 ├── run.png // 接线图 同上 └── sample_vin_ c_3 // 测试程序 同上 0 directories, 5 files ``` 基于此，就可以实现双摄支持了！ ### EMMC 量产相关方案 目前已经支持 M3AXPI EMMC 量产的相关方案实现。 **相关资料例程**：[[m3axpi]关于爱芯 ax620a 方案如何采用 EMMC 商业化量产成品这件事](https://www.cnblogs.com/juwan/p/17266132.html) ![emmc](./../assets/emmc.jpg)"},"/hardware/zh/maixIII/ax-pi/dev_prepare.html":{"title":"Maix-III AXera-Pi 开发板 SDK 使用介绍","content":" title: Maix III AXera Pi 开发板 SDK 使用介绍 > 本文假定你是一名不了解 linux 系统的开发方式的开发者，但知道 gcc 和 make 命令使用的相关专业工程师，如果你不了解 gcc 编译程序，可以先学习[Linux中gcc/g++ gdb make/Make 的基本使用和理解](https://blog.csdn.net/m0_46606290/article/details/123083945) 。 ## 准备工作 欲善其事，必先利其器。在开始开发之前，需要准备好开发板、开发环境、开发工具等。 根据前面的章节，你掌握了开发板的 烧录系统 和 登录系统 等一系列 Linux 基础操作，这可以帮助你在开发过程中排查设备问题或调试驱动代码。 但接下来要开发程序就需要准备好开发环境和开发工具了，以下是给从来没接触过嵌入式 linux 系统开发的同学了解的内容，如软件工程的同学。 首先认识一下什么是交叉编译，通常来说，编译程序有交叉编译和本地编译两种情况，本地编译就是在本机上使用 gcc 进行编译运行程序（例如在 Visual Studio 上编译运行 hello world ），而交叉编译就是本机没有编译环境，需要在另一台机器上完成编译再送进来运行（例如在 Android Studio 上编译 apk 送到手机里安装程序运行）。 > 交叉编译是指在一种计算机架构上编译出另一种计算机架构的可执行程序。交叉编译的目的是为了在一种计算机架构上运行另一种计算机架构的程序。例如，可以在 x86 架构的计算机上编译出 ARM 架构的可执行程序，或者在 ARM 架构的计算机上编译出 x86 架构的可执行程序。交叉编译的目的是为了在一种计算机架构上运行另一种计算机架构的程序。例如，可以在 x86 架构的计算机上编译出 ARM 架构的可执行程序，或者在 ARM 架构的计算机上编译出 x86 架构的可执行程序。 两者的区别在于编译一些复杂大型软件，本机性能太弱内存又少，导致编译出来的时间太长，所以需要交叉编译来完成，比如 ax sample 在本机完整编译需要十几分钟，而在一台高性能的桌面计算机上只需要数十秒即可。 所以从开发的角度来说，本机编译只是为了快速应用查看效果，真正得开发起来还是得交叉编译，就像原厂提供的 bsp sdk 一样，在计算机上完成编译后，再送进板子中运行。 ## 板子与电脑的文件互传 在编译程序之前，你需要了解一些拷贝文件到板子或电脑的方法，免得交叉编译完程序不知道怎么传文件进去板子里运行。 ssh 相关的远程工具需要，你知道板子的 IP 地址，可以从 ifconfig 得知。 serial 相关的有线串口工具，需要你接好线配置好参数连上板子。 如何登录板子均可以从前文【系统使用手册】中得知。 ### 使用 ssh 远程管理工具 在 windows 上有许多远程管理 linux 服务器的工具都提供了文件传输的功能，这里只推荐免费绿色好用的 mobaxterm 工具。 [利用MobaXterm实现linux和windows之间传输文件](https://jingyan.baidu.com/article/9f63fb91e2bc6688400f0e93.html) [用MobaXterm 在linux和windows之间上传/下载文件](https://blog.csdn.net/unforgettable2010/article/details/123930796) > [如何使用 mobaxterm](https://wiki.sipeed.com/hardware/zh/maixII/M2/tools/mobaxterm.html) 想了解更多可以看 [推荐7款超级好用的终端工具 —— SSH+FTP](https://zhuanlan.zhihu.com/p/301653835) ，而其他系统都提供了好用的命令行终端，支持 ssh 、 scp 等命令直接执行。 ### 使用 scp 命令复制文件 和 cp 复制文件等命令一样，它就是 ssh + cp scp 这个意思。 [linux操作系统scp命令使用方法](https://cloud.tencent.com/developer/article/1876623) ### 使用读卡器物理拷贝文件 由于 linux 系统采用 ext4 分区在 Windows / Mac 默认系统上看不到，需要额外安装增强工具才能读取到具体的分区。 [如何在 Windows 下访问 ext4 格式的硬盘？](https://zhuanlan.zhihu.com/p/448535639) [[macOS] 在 macOS 上挂载 Linux 的 ext/ext3/ext4 文件系统](https://blog.twofei.com/773/) Linux 系统可以直接看到卡里的分区和内容，实在不行也可以把读卡器接到安卓设备通过 otg 转接头实现文件拷贝。 ### 使用有线串口互传文件 接好串口连上设备，安装 `apt get install lrzsz` 工具后参考以下文章： 使用 命令行工具 `minicom D /dev/ttyUSB0 b 115200` 可以看[ubuntu中使用 minicom 玩转文件的上传与下载](https://blog.csdn.net/wanyeye/article/details/42002377)。 使用 mobaxterm 可以看 [MobaXterm 使用 rz/sz 传送文件](https://blog.csdn.net/qq_28837389/article/details/120073720) 其他的可以自行百度。 ## 本机编译可直接运行程序 这里把 m3axpi 板子当作一台本地的微型 linux 服务器的角色来看待，使用 vscode remote 或 mobaxterm 这类远程开发工具连接到板子里，这样就可以得到一个和在 linux 服务器一样的本地开发环境，可以在本地编辑代码后直接编译运行程序。 ### vscode remote vscode remote 是 vscode 的一个插件，可以直接连接到远程的 linux 服务器，然后在本地编辑代码，同步到远程服务器上编译运行，这里以一台 ubuntu20.04 的桌面计算机系统为例，只要能安装 vscode 编辑器软件计算机都行，这里只是为了示意如何连接到板子里。 安装插件： ```bash sudo apt install code code install extension ms vscode remote.remote ssh ``` <! [附图] > 连接到板子： ```bash ssh root@192.168.233.1 ``` <! [附图] > 不想输入密码可以用 sshpass 命令省略。 ```bash sshpass p root ssh root@192.168.233.1 ``` 接着就可以在 vscode 里编译运行 linux 系统的程序了，幸运的是在 debian 系统上可以直接通过 apt 得到本机的编译工具链，而不用交叉编译就可以直接编译运行程序，这些都已经提前准备好了，对用户来说可以节省不少搭建内部开发环境的时间。 所以可以直接在板子里编译运行 libmaix 项目： ```bash cd /home/libmaix/examples/axpi/ python3 project.py build fbon ./dist/start_app.sh ``` > 按 ctrl + c 中断停止程序直到退出。 <! 附图： > ### mobaxterm 在 Windows 上可以用 mobaxterm 这样的工具连接到板子进行 linux 服务器管理，但编译还是需要在 linux 系统上进行。 ![mobaxterm_ssh](./../assets/ssh.jpg) ## 交叉编译上传程序再运行 在这之前需要有本地编译的认知，然后发现本地内存和性能不能满足自身开发需求的时候，就要准备交叉编译程序了，此时程序是在另一台更强的 x86 linux 系统上完成的，并且编译出来的程序需要拷贝到板子里运行。 > **[20221010 现提供一种借助 docker qemu arm 虚拟机来实现在 x86 机器上实现本地编译 arm 程序的方法，这种方法既提高了编译效率又不用配环境的方法值得一试！](https://www.cnblogs.com/juwan/p/16769237.html)** 首先得有一台 linux 系统，如 ubuntu20.04 这样的桌面计算机，接着和上面一样，也可以在这台计算机上安装 vscode remote 或 idea clion 这类开发工具直接连接到板子里，这可以方便你编辑代码或传输文件。 想要在 x86 的机器上编译出 arm 架构的程序，想要先配置专用的交叉编译工具链，例如这里使用的是 arm linux gnueabihf 这个工具链，这个编译链可以直接通过 apt 安装。 `sudo apt install gcc arm linux gnueabihf` 安装完成后，可以在 /usr/bin 目录下找到 `arm linux gnueabihf gcc` 这个交叉编译工具，这个工具可以用来编译 linux 系统的程序。 ```bash juwan@juwan n85 dls:~$ /usr/bin/arm linux gnueabihf gcc v Using built in specs. COLLECT_GCC arm linux gnueabihf gcc COLLECT_LTO_WRAPPER /usr/lib/gcc cross/arm linux gnueabihf/9/lto wrapper Target: arm linux gnueabihf Configured with: ../src/configure v with pkgversion 'Ubuntu 9.4.0 1ubuntu1~20.04.1' with bugurl file:///usr/share/doc/gcc 9/README.Bugs enable languages c,ada,c++,go,d,fortran,objc,obj c++,gm2 prefix /usr with gcc major version only program suffix 9 enable shared enable linker build id libexecdir /usr/lib without included gettext enable threads posix libdir /usr/lib enable nls with sysroot / enable clocale gnu enable libstdcxx debug enable libstdcxx time yes with default libstdcxx abi new enable gnu unique object disable libitm disable libquadmath disable libquadmath support enable plugin enable default pie with system zlib without target system zlib enable libpth m2 enable multiarch enable multilib disable sjlj exceptions with arch armv7 a with fpu vfpv3 d16 with float hard with mode thumb disable werror enable multilib enable checking release build x86_64 linux gnu host x86_64 linux gnu target arm linux gnueabihf program prefix arm linux gnueabihf includedir /usr/arm linux gnueabihf/include Thread model: posix gcc version 9.4.0 (Ubuntu 9.4.0 1ubuntu1~20.04.1) ``` 本地与交叉编译唯一不同的地方就是需要把将编译出来的程序，上传到板子运行，而不能直接运行程序。 以 libmaix 这个项目为例：在 x86 的机器上编译时需要修改本机的交叉编译链，如：python3 project.py board axpi toolchain /usr/bin toolchain prefix arm linux gnueabihf config 之中的编译链可能会发生改变，这里需要根据你的实际情况进行修改，比如本机环境下可能有多个编译链，但一般来说是不需要修改的。 除了修改交叉编译链，如果出现编译失败，还需要修改编译配置中所需要的依赖文件或头文件的路径： ``` list(APPEND ADD_INCLUDE \"lib/arch/axpi/joint\" \"lib/arch/axpi/opt/include\" \"lib/arch/axpi/opt/include/opencv4\" ) \"/lib/aarch64 linux gnu/libm.so\" \"/lib/aarch64 linux gnu/libpthread.so\" \"/lib/aarch64 linux gnu/libopencv_videoio.so\" \"/lib/aarch64 linux gnu/libopencv_highgui.so\" \"/lib/aarch64 linux gnu/libopencv_imgcodecs.so\" \"/lib/aarch64 linux gnu/libopencv_imgproc.so\" \"/lib/aarch64 linux gnu/libopencv_core.so\" \"/lib/aarch64 linux gnu/libopencv_freetype.so\" ``` 当换了编译链后也要修改到其他路径下的链接库： ``` list(APPEND ADD_INCLUDE \"lib/arch/axpi/joint\" \"/opt/include\" \"/usr//local/include/opencv4\" ) \"/lib/arm linux gnueabihf/libm.so\" \"/lib/arm linux gnueabihf/libpthread.so\" \"/lib/arm linux gnueabihf/libopencv_videoio.so\" \"/lib/arm linux gnueabihf/libopencv_highgui.so\" \"/lib/arm linux gnueabihf/libopencv_imgcodecs.so\" \"/lib/arm linux gnueabihf/libopencv_imgproc.so\" \"/lib/arm linux gnueabihf/libopencv_core.so\" \"/lib/arm linux gnueabihf/libopencv_freetype.so\" ``` 简而言之，更换了桌面系统和编译链，那源码中对应的一些依赖文件肯定也会发生改变，这需要看所用的 sdk 是如何解决这个问题的，通常来说只需要换交叉编译链和修改链接目录即可。 上文介绍了如何在 linux 系统上编译运行 libmaix 项目，以及如何在 linux 系统上交叉编译 libmaix 项目，希望对大家有所帮助，只要掌握了如何管理开发环境和如何编译运行 linux 的程序，接下来就可以基于我们提供的 sdk 开发属于自己的项目了。 在这里「大佬鼠」推荐自己的开发流程和方法，最开始就是先在板子上本地编译测试现有的代码和功能，然后根据 [[maixpy3 axpi] 编辑发布 debian 镜像与在 PC 上交叉编译程序 ](https://www.cnblogs.com/juwan/p/16769237.html) 来安装 docker arm 虚拟机。 接着，将之前烧录到板子里的根文件系统（.img）通过 losetup + mount + chroot 挂载（.img）出来，这时候你就会得到和板子一样的 arm 虚拟机环境，就可以直接本地编译啦！不过，这个方法需要学习 docker 的安装喔，包括后面的模型开发也上会用到 docker 的。 > 如果你不嫌麻烦的话，可以选择配置交叉编译链、板子依赖的头文件、第三方链接库后才能进行程序的编译，但这个 docker arm 虚拟机的方法是最省事的，甚至还可以通过读卡器（或网络）挂载板子里的根文件系统进行编译。 * [什么是交叉编译？](https://cn.bing.com/search?q %E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%EF%BC%9F) * [超详细解答vscode如何远程连接Linux以及可能会出现的一些问题](https://blog.csdn.net/cxn15335120506/article/details/123238233) * [vscode remote](https://code.visualstudio.com/docs/remote/remote overview) * [ssh scp 是什么？](https://cn.bing.com/search?q ssh+scp+%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F) * [libmaix](https://github.com/sipeed/libmaix) * [mobaxterm](https://mobaxterm.mobatek.net) * [arm linux gnueabihf gcc](https://packages.ubuntu.com/focal/gcc arm linux gnueabihf) ## 获取 SDK 源码 前文介绍了基础的开发环境搭建和使用方法，你应该了解什么是本地编译和交叉编译，下面开始介绍如何使用这些 sdk 源码开发程序。 [libmaix](https://github.com/sipeed/libmaix) 由 sipeed 提供在 linux 平台统一的嵌入式开发环境，主要有摄像头、屏幕、视觉、图像处理、NPU pipiline 相关的实机部署例程，适合刚入门嵌入式 linux 开发的同学使用。 [ax sample](https://github.com/AXERA TECH/ax samples) 由爱芯提供 AI 模型的开发与评估验证，提供给有经验的 AI 开发者使用，不涉及任何硬件外设有关的内容。 [axpi_bsp_sdk](https://github.com/sipeed/axpi_bsp_sdk) 芯片商用时所用的 bsp 开发包，这里主要提供的是芯片的原始开发资料，如 uboot 、 linux 、 msp 、msp 等工程代码，这个部分是逐步开源的，你可以从这里得到商业评估用的代码，例如 ipcdemo 这样的程序，但这些代码会很复杂且高耦合，适合有经验的同行出于商业落地的目的使用。 [ax pipeline](https://github.com/AXERA TECH/ax pipeline) 基于 axpi_bsp_sdk 制作的 AI 部署高性能仓库，在这里主要用于该项目基于 AXera Pi 展示 ISP、图像处理、NPU、编码、显示 等功能模块软件调用方法，方便社区开发者进行快速评估和二次开发自己的多媒体应用。 ### libmaix 这是一个适用于 sipeed 所用 linux 芯片开发的 C/C++ 基础开发框架，使用 cmake 构建，提供了许多开箱参考的案例，还有一些第三方库代码的链接，如 opencv openmv 这些视觉库的链接。 SDK 源码在 [libmaix](https://github.com/sipeed/libmaix)， 需要使用 git 命令下载： ```bash git clone https://github.com/sipeed/libmaix.git recursive ``` >! 注意这里` recursive` 参数是必须的，用来下载仓库里面的子模块，如果没有这个参数，代码会不完整，导致编译出错。 > 中国国内可能下载速度较慢，可以多取消重试几次，可能会遇到速度快的节点，当然最好还是通过设置代理来加速下载。 另外， AI 模型及例程在 [MaixHub 模型库](https://maixhub.com/model/zoo) 可以找到， 以及 [AXERA TECH/ax samples](https://github.com/AXERA TECH/ax samples) 仓库。 ## 编译 SDK 源码 回顾一下前文的内容，编译有两种方式： * 直接在开发板上编译：编译速度较慢，但是不需要额外的环境配置。 * 在 PC 上编译，然后拷贝可执行文件到开发板，也就是交叉编译： 编译速度更快，但是需要额外的环境配置。 ### [libmaix](https://github.com/sipeed/libmaix) > /home/ 目录已预置，可以 git pull 联网拉取更新。 对于 `libmaix`， 按照其`README.md` 文件描述的方法编译即可， 不过需要在`menuconfig`命令中选择 `AXera Pi` 作为编译目标。 这里简要介绍一下编译过程（libmaix 目前还未稳定，未来可能会有大的更新），实际以[libmaix 仓库](https://github.com/sipeed/libmaix)代码和说明为准。 * 先安装依赖 ``` apt install build essential cmake python3 sshpass git ``` > sshpass 也可以不安装， build essential, cmake, git, python3 必须安装 * 克隆仓库到本地或者开发板 ``` git clone https://github.com/sipeed/libmaix recursive ``` >! 注意 ` recursive` 参数是必须的，用以克隆子模块，否则会缺代码。 这里以在开发板上编译为例： ```bash cd /home/libmaix # git clone https://github.com/sipeed/libmaix recursive cd examples/axpi python3 project.py distclean # python3 project.py menuconfig # 可以配置相关参数 python3 project.py build # 如果增加文件了，需要 python3 project.py rebuild 命令 ./dist/start_app.sh # 运行示例程序 ``` ### [ax samples](https://github.com/AXERA TECH/ax samples) > /home/ 目录已预置，可以 git pull 联网拉取更新。 [ax samples](https://github.com/AXERA TECH/ax samples) 是爱芯官方提供的例程，包含了一些 AI 模型和运行代码，编译完能直接在开发板上运行，只不过输入是图片，不是摄像头。 进入开发板终端，执行以下代码： ```bash cd /home/ax samples # git clone https://github.com/AXERA TECH/ax samples.git mkdir build cd build cmake .. make install ``` 然后就能在`ax samples/build/install/bin/`目录下找到编译好的可执行文件。 ### [axpi_bsp_sdk](https://github.com/sipeed/axpi_bsp_sdk) 回到芯片原厂开发的环境，这需要有经验的嵌入式 Linux 开发者来操作，直接看 readme 进行操作，文档在 docs 目录下。 #### What is this? this is a ax620 linux bsp sdk form AX620_R1.22.2801_Sipeed. currently it is application layer open source. ```bash juwan@juwan n85 dls:~/GIT_AX620_SDK_V0.31.0_P23/sipeed/axpi_bsp_sdk$ tree L 1 . ├── app ├── build ├── msp ├── readme.md ├── rootfs └── third party 5 directories, 1 file ``` #### ready arm gcc ```bash git clone https://github.com/sipeed/axpi_bsp_sdk.git cd axpi_bsp_sdk wget http://releases.linaro.org/components/toolchain/binaries/latest 7/arm linux gnueabihf/gcc linaro 7.5.0 2019.12 x86_64_arm linux gnueabihf.tar.xz sudo tar xvf gcc linaro 7.5.0 2019.12 x86_64_arm linux gnueabihf.tar.xz C /opt/ ``` #### how to compile bsp msp sample ```bash cd msp/sample/ export PATH \"/opt/gcc linaro 7.5.0 2019.12 x86_64_arm linux gnueabihf/bin/:$PATH\" && make p AX620_demo all install ``` third party libs ```bash cd third party export PATH \"/opt/gcc linaro 7.5.0 2019.12 x86_64_arm linux gnueabihf/bin/:$PATH\" && make p AX620_demo all install ``` bsp app ipcdemo ```bash cd app/ export PATH \"/opt/gcc linaro 7.5.0 2019.12 x86_64_arm linux gnueabihf/bin/:$PATH\" && make p AX620_demo all install ``` bsp msp component lib, such as `cd app/msp/component/common && make xxxx`. ``` juwan@juwan n85 dls:~/GIT_AX620_SDK_V0.31.0_P23/sipeed/axpi_bsp_sdk/msp/component$ tree L 1 . ├── axsyslog ├── common └── thermal 4 directories, 0 files ``` #### run your program on pc ``` sshpass p root scp ./vo_fb/sample_vo_fb root@192.168.233.1:/opt/bin/sample_vo_fb ``` on board ``` chmod 777 /opt/bin/sample_vo_fb /opt/bin/sample_vo_fb v dsi0@480x854@60 m 0 & fbv /home/examples/480x360.jpg killall sample_vo_fb ``` ## 组合 SDK 和 AI 模型例程 比如我们要跑一个视觉 AI 模型，需要用到摄像头，屏幕，还有 AI 模型，你需要借助以下仓库代码完成这个目标。 ### 借助 libmaix 实现（开发难度最小，适合验证） 基于 libmaix 的 axpi 项目进行开源快速验证效果，代码简单易懂，基于在线服务完成模型部署，只用于新手上路，与 ax sample 的模型一起被支持。 [axpi](https://github.com/sipeed/libmaix/tree/release/examples/axpi) [axpi_classification_cam](https://github.com/sipeed/libmaix/tree/release/examples/axpi_classification_cam) [axpi_yolov5_cam](https://github.com/sipeed/libmaix/tree/release/examples/axpi_yolov5_cam) > 20221113 目前仓库只保证用户初次上手时能够不报错的安全调用 AI 模型，不代表芯片的最好效果。 ### 借助 ax pipeline 实现（开发难度适中，适合优化） 到了这里要有基本的芯片 bsp sdk 开发的基础（axpi_bsp_sdk），这部分会略显专业一些，这个仓库目前追求最高性能的效果。 [准备编译环境](https://github.com/AXERA TECH/ax pipeline/blob/main/docs/compile.md) [如何更换自己训练的 yolov5 模型？](https://github.com/AXERA TECH/ax pipeline/blob/main/docs/how_to_deploy_custom_yolov5_model.md) [如何部署自己的其他模型](https://github.com/AXERA TECH/ax pipeline/blob/main/docs/how_to_deploy_custom_model.md) ### 借助 ipcdemo 实现（开发难度最大，适合落地） 基于 axpi_bsp_sdk 的 ipcdemo 商用视频推流应用，由于源码过于复杂，需要有上述基础才能介入。 [axpi_bsp_sdk/app/IPCDemo](https://github.com/sipeed/axpi_bsp_sdk/tree/main/app/IPCDemo)"},"/hardware/zh/maixIII/ax-pi/axpi.html":{"title":"MAIX-III AXera-Pi 是什么？","content":" title: MAIX III AXera Pi 是什么？ keywords: MAIX III, AXera Pi, Maix3, Sipeed, ax620a, axera, sipeed, AI, model, maixhub > 如果你想分享这款 AI 开发板给其他同学了解，请使用唯一的传送门「[ wiki.sipeed.com/m3axpi ](http://wiki.sipeed.com/m3axpi) 」。 ![maixiii_axpi](./../../../../../static/home/maixiii_axpi.jpg) > [>>> 想要购买请点此直达淘宝商品链接 <<<](https://item.taobao.com/item.htm?id 682169792430) 2021 年的时候，国内各大芯片原厂纷纷亮出了自己的 Linux 边缘 AI 芯片。 但在 AI 开发板的市场中，前有树莓派（Raspberry Pi），后有英伟达（Jetson Nano）等国外老牌选手强力围剿国内 Linux AI 开发板，在这之前国产的同类产品无论是价格还是体验，都被打的丢盔弃甲。 如今在千元内的选手有晶晨 A311D 、地平线 X3 、瑞芯微 RV1126、堪智 K510、全志 V85X 、晶视 CR182x 等等国产芯片，看上去感觉有很多选择？ 但是，它们要么资料太少（资料封闭）、能效比低、价格太贵、生态贫瘠、开发困难、视觉效果太差存在各种各样的问题。 真的很难有一款边缘 AI 板子可以满足开发者的要求！！！ 但现在！这些问题可能不再是问题了！ 是时候请出我们新一轮的参赛选手了！ 练习时长两年半（不是），一颗 3.6TOPs@INT8 大算力低功耗超强夜景的芯片总算是来到了 MAIX III Linux AI 系列！ <p align \"center\"> <img src \"https://axera tech.com/upload/8f/091a2540e7cdc5c7f62df022f80220.jpg\" alt \"img\" style \"zoom: 50%;\" /> </p> 没错，它就是来自「[爱芯元智](https://axera tech.com/)」的 [AX620A](https://axera tech.com/product/T7297367876123493768)，这是一款高算力，高能效比，低功耗的 AI SoC 芯片，芯片集成了四核 Cortex A7 @ 1Ghz CPU，带有浮点运算单元，支持 NEON，拥有 3.6TOPs@INT8 的高算力 NPU，支持 4K@30fps 的 ISP，以及支持 H.264、H.265 编码的 VPU，AX620A 还支持 32bit LPDDR4x，支持 EMMC v5.1 / SPI Flash，最多支持 6 路 MIPI 输入，同时最多支持 4 路工作，支持多路子码流，支持 1 路千兆 Ethernet，支持 1 路 USB2.0，支持 2 路 MIPI DSI/CSI 输出。拥有大算力和优异画质处理能力的 AX620A 可以实现更多的 AI 功能，带来最优的 AI 体验！（来自官方） ## 产品介绍 它其实早在九月初就参展了 2022 年世界人工智能大会了～（当时它长这样） <p align \"center\"> <img src \"./../assets/waic axpi.jpg\" style \"zoom: 70%;\" /> </p> 最后总算是在 20221001 的时候推出了这款搭载 AX620A 的开发板，正式名为：**MAIX III AXera Pi**，在以下内容中简称 **m3axpi** 喔！ <p align \"center\"> <video src \"../assets/axpi_boom.mp4\" width \"100%\" controls \"controls\" autoplay \"autoplay\" x5 playsinline \"\" \t\tplaysinline \t\twebkit playsinline \"true\" \t\tposter \"../assets/maix iii small.jpg\" \t\tpreload \"auto\" > </video> </p> 那么，它都带来了哪些内容呢？ 资料太少？文档教你从开箱到开发，从嵌入式 Linux 开发到 AI 模型开发指南一应俱全！ 能效比差？四核 A7 靠一条 USB3.0 就可以带起来！和你的外接电源、散热器说拜拜吧！！ 开发困难？支持 debian11 系统内置 SDK 直接板上编译！白嫖在线 AI 模型训练直到部署！！！ 没有生态？ SIPEED 拥有关于 LINUX、RISCV、AIOT、FPGA、MCU 等嵌入式领域的内容！！！！ 摄像效果太差？芯片主打 AI ISP 夜视增强！由原厂亲手为你调试白天到夜间的超强影像！！！！！ 价格太贵？从核心+底板+屏幕+摄像头+卡+外壳支架全套总共人民币 **579** ！（咆哮！！！！！！） 说这么多没用的，还是赶紧把东西掏出来，让大家瞧瞧都有些什么吧！ ## 微光影像效果 ### 夜景增强效果 <p align \"center\"> <iframe src \"//player.bilibili.com/player.html?aid 561523949&bvid BV1Ee4y1v7iF&cid 860676576&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\" style \"max width:640px; max height:480px;\"> </iframe> </p> ### 展会暗室现场 <p align \"center\"> <iframe src \"//player.bilibili.com/player.html?aid 430541632&bvid BV1iG41137tx&cid 831645988&page 1&t 83.6\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\" style \"max width:640px; max height:480px;\"> </iframe> </p> ### AI 应用实拍 <p align \"center\"> <iframe src \"//player.bilibili.com/player.html?aid 773227207&bvid BV1B14y1Y7A4&cid 837154353&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\" style \"max width:640px; max height:480px;\"> </iframe> </p> ## 多元 AI 生态 ### 大算力超多算子！ [点此 >>> 「查看 AX620A 算子支持列表」 <<< 喔！](https://pulsar docs.readthedocs.io/zh_CN/latest/appendix/op_support_list.html) 下表统计一下目前（20221012）千元内在售的 AI 主板（仅单主板，全套太贵）的 NPU 算力性能从高到低的排行（商品价格会受市场波动影响，若发现表格数据过于离谱请指正）。 芯片 产品 价格 CPU RAM NPU 晶晨 A311D Khadas VIM3 ¥850.00 四核 ARM Cortex A73@2.2GHz <br> 双核 ARM Cortex A53@1.8GHz 2GB 5TOPs 地平线 X3 旭日派 ¥499.00 四核 ARM Cortex A53@1.2GHz 2GB 5TOPs 爱芯元智 AX620A MAIX III AXera Pi ¥399.00 四核 ARM Cortex A7@1.0GHz 2GB 3.6TOPs 堪智 K510 K510 CRB KIT Lite ¥699.00 双核 RISCV 64 位 800Mhz 512MB 3TOPs 瑞芯微 RV1126 EASY EAI Nano ¥328.00 四核 ARM Cortex A7@1.5GHz 1GB 2TOPs 全志 V85X 全志 V853 单主板 ¥973.00 单核 ARM Cortex A7@1.2GHz 512MB 1TOPs ### 大量现成的模型！ 没有拿到板子之前，你可以到 [MaixHub 模型库](https://maixhub.com/model/zoo) 找到你需要的模型，可以在过滤选项中选择 `AX Pi` 来查找能在 `AXera Pi` 上运行的模型。 ![models](./../assets/models.jpg) 还可以在 [AXERA TECH/ax samples](https://github.com/AXERA TECH/ax samples) 仓库也可以找到模型，板子系统里也预置了模型资源，后续模型更新会在这里[「ax models」](https://github.com/AXERA TECH/ax models)，而 [ AX Samples 将不断更新最流行的、实用的、有趣的示例代码](https://github.com/AXERA TECH/ax samples/tree/main/examples#examples)，目前比较典型的模型支持： 物体分类: MobileNet, Resnet 物体检测: YOLO v3~v8 分割: Face_Parsing, [PP HumanSeg](https://github.com/AXERA TECH/ax samples/blob/main/examples/ax620/README.md#PP HumanSeg) 3D单目车辆检测： [Monodlex](https://github.com/AXERA TECH/ax samples/blob/main/examples/ax620/README.md#Monodlex) 人体关键点：[HRNet](https://github.com/AXERA TECH/ax samples/blob/main/examples/ax620/README.md#HRNet)，[AX POSE PPL](https://github.com/AXERA TECH/ax samples/blob/main/examples/ax620/README.md#AX POSE PPL)， [HandPose](https://github.com/AXERA TECH/ax samples/blob/main/examples/ax620/README.md#HandPose) 语义分割: [PP Seg](https://github.com/AXERA TECH/ax samples/blob/main/examples/ax620/README.md#MobileSeg) 传统 CV 操作: CropResize 加速 ### 在线训练模型吧！ 支持 零代码，免费云端服务器的 [MaixHub](https://wiki.sipeed.com/news/maixhub/new_maixhub.html)在线训练，小白也能定制自己的 AI 模型！ ### 移植自己的模型 想要在板子上移植你的模型请看[「部署模型到 Maix III AXera Pi 开发板」](/ai/zh/deploy/ax pi.html) ### 分享有趣的模型！ * 社区可以找到大家分享的模型，方便快速验证想法。 * 在线训练的模型，或者移植的自己的模型，均可以分享到 [MaixHub 模型库](https://maixhub.com/model/zoo) ，大家一起交流学习成长！（请开始你的表演吧） ## 活跃的社区资源 产品相关的专栏内容有（官方维护）： [MAIX III AXera Pi 系列文章（1）：新一代 3.6T 视觉 AI 板卡面世](https://aijishu.com/a/1060000000374898) [MAIX III AXera Pi 系列文章（2）：丰富多采的 AI 应用](https://aijishu.com/a/1060000000374900) [MAIX III AXera Pi 系列文章（3）：Debian 系统 & 开箱案例](https://aijishu.com/a/1060000000374902) [MAIX III AXera Pi 系列文章：开箱之硬件初体验](https://aijishu.com/a/1060000000378968) [MAIX III AXera Pi 系列文章：上手之丝滑玩转 AI 板卡【一】](https://aijishu.com/a/1060000000380513) [MAIX III AXera Pi 系列文章：上手之丝滑玩转 AI 板卡【二】](https://aijishu.com/a/1060000000383970) [YOLOv8 目标检测：训练自定义数据集并部署到爱芯派（一）](https://aijishu.com/a/1060000000395215) [YOLOv8 目标检测：训练自定义数据集并部署到爱芯派（二）](https://aijishu.com/a/1060000000395812) [MMPose：在爱芯派上玩转你的关键点检测](https://aijishu.com/a/1060000000396746) [MOT：如何在爱芯派上实现多目标跟踪的神奇效果！](https://aijishu.com/a/1060000000399566) [MMPoes（衍生章）：如何在爱芯派上实现跌倒检测并预警](https://aijishu.com/a/1060000000401084) [OCR：如何利用爱芯派实现图像文字识别](https://aijishu.com/a/1060000000403913) 以下是由社区开发者贡献的内容，欢迎你也来贡献喔！！！（直接丢群里都可以喔！） [爱芯派 AI微光全彩夜视 开箱体验](https://zhuanlan.zhihu.com/p/571233089) [爱芯 AX620A NPU 初体验](https://neucrack.com/p/440) [MMYOLO 检测算法部署在 AX620A 记录](https://zhuanlan.zhihu.com/p/614698969?utm_campaign &utm_medium social&utm_oi 815507548294770688&utm_psn 1620047438693208065&utm_source qq) [部署你的yolov8来识别杠精（bushi）](https://www.yuque.com/prophetmu/chenmumu/pd3sdkb8z4vvvgai) [[m3axpi] YOLOv5 训练到部署全流程（最新）](https://github.com/Abandon ht/m3axpi_model/blob/main/yolov5/README_zh CN.md) [[m3axpi] YOLOv8 训练到部署全流程（最新）](https://github.com/Abandon ht/m3axpi_model/blob/main/yolov8/README_zh CN.md) [爱芯元智AX620A部署yolov5 6.0模型实录（已过时）](https://zhuanlan.zhihu.com/p/569083585) [ubuntu22.04搭建AX620A官方例程开发环境](https://blog.csdn.net/flamebox/article/details/127103964) [AX620A运行yolov5s自训练模型全过程记录（windows）](https://blog.csdn.net/flamebox/article/details/127249243) [MAIX III AXera Pi爱芯派从零入门开发【1】开箱试玩](https://www.bilibili.com/video/BV1LP4y1274d/?spm_id_from 333.999.0.0) [MAIX III AXera Pi爱芯派从零入门开发【2】开发部署](https://www.bilibili.com/video/BV1Ne4y117U9/?spm_id_from 333.999.0.0) [MAIX III AXera Pi爱芯派从零入门开发【3】模型转换及部署](https://www.bilibili.com/video/BV1jg411z7C8/?spm_id_from 333.999.0.0) [MAIX III AXera Pi爱芯派从零入门开发【4】视频推理及推流](https://www.bilibili.com/video/BV14D4y147Ed/?spm_id_from 333.999.0.0) [小手智联老徐 —— AI 边缘计算平台 爱芯元智 AX620A 爱芯派开箱](https://blog.csdn.net/weixin_43978579/article/details/127966677) [HonestQiao —— 矽速 MAIX III AXera Pi 开箱](https://bbs.elecfans.com/m/jishu_2314161_1_1.html) [一款国产「3.6TOPS@INT8」视觉 AI 开发板](https://mp.weixin.qq.com/s/3bxFxO0Q0UmpzSM3_K794g) [国产AI开发板测评 MAIX III AXera Pi 上手 YOLOv5s 实时目标检测](https://mp.weixin.qq.com/s/lqxL DmhBa K9gu3uEyebQ) [【AXPI】如何在 M1/M2 Mac上使用 Rndis](https://zhuanlan.zhihu.com/p/593627641) 产品相关的新闻内容有： [AI ISP 的黎明——大话成像](https://axera tech.com/tech/T7297054127901756535) [2022世界人工智能大会启动:爱芯元智发布AI ISP“爱芯智眸®”_中华网](https://tech.china.com/article/20220901/092022_1134965.html) [爱芯元智AX620A与百度飞桨完成 I 级兼容性测试 开源生态建设更进一步](https://mp.weixin.qq.com/s/k6G1pE 31VXlrBA3F6_Liw) [AI 视觉新势力×微光全彩“黑”科技](https://mp.weixin.qq.com/s/JIvVprWlQPvE7bTxozAG_Q) [爱芯派™AXera Pi™亮相ICCAD 爱芯元智开源生态建设加速](https://mp.weixin.qq.com/s/_nZLfEjxOb4QLpGWgaLVWQ) [新一代 Kaldi 嵌入式端实时语音识别](https://mp.weixin.qq.com/s/r4nGu04o1sjdFZt_vYbUAA) > 截止更新时间：20221205 <p align \"center\"> <img src \"./../assets/demo_one.jpg\" style \"zoom: 100%;\"> <img src \"./../assets/demo_two.jpg\" style \"zoom: 100%;\"> </p> ## 硬件参数 <p align \"center\"> <img src \"./../assets/waiguan1.jpg\" style \"zoom: 51%;\" /> <img src \"./../assets/maix iii small.jpg\" style \"zoom: 80%;\" /> <img src \"./../assets/waiguan2.jpg\" style \"zoom: 45%;\" /> </p> ### 硬件标注图 <p align \"center\"> <img src \"./../assets/layout_axpi_2.png\" alt \"layout_axpi_2\" width \"45%\"> <img src \"./../assets/layout_axpi_1.png\" alt \"layout_axpi_1\" width \"45%\"> </p> ### 核心板参数 项目 参数 CPU 四核 Cortex A7, 支持 NEON 和 FPU NPU 14.4Tops@int4，3.6Tops@int8 ISP 4K@30fps 编解码格式 H.264, H.265 视频编码 4K@30fps 视频解码 1080P@60fps Ethernet 支持双路RGMII / RMII 接口模式的以太网 显示输出 MIPI DSI 4 Lane，最高支持4K@30FPS DRAM 2GB LPDDR4X 3733Mhz 存储 可选16GB EMMC（默认是 TF 卡启动） IO 引出 DDR4 SODIMM 260P 金手指全 IO 引出 ### 底板参数 项目 参数 摄像头输入 （默认单摄）最高支持 3 摄:1个MIPI4 LANE+2个MIPI2 LANE 屏幕输出 支持最高 4 LANE MIPI DSI 屏幕 SD 插槽 默认从 SD 卡启动 录音输入 板载两个 MEMS MIC 支持双麦降噪 音频输出 3.5MM耳机接口 支持立体声输入和 MIC 输入 网络接口 支持 千兆以太网（ETH） 和 2.4GHZ WI FI 板载天线 USB 接口 1xUSB2.0HS 支持 OTG 或 HOST 功能，1xUSB UART 系统串口 其他资源 1x用户按键，3x系统按键，1xRTC时钟，2xLED 对外接口 引出CJTAG，可自行连接相应调试器，引出2x12排针，4个M2.5螺丝定位孔 ### 摄像头一览 低配 gc4653 400w 基础体验版本。 <p align \"center\"> <img src \"./../assets/ax620a_gc.jpg\" style \"zoom: 100%;\" /> </p> 高配 os04a10 400w 夜景增强版本。 <p align \"center\"> <img src \"./../assets/ax620a_os.jpg\" style \"zoom: 100%;\" /> </p> > [更换摄像头常见问题](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/faq_axpi.html) ## 硬件资源 [硬件资源汇总链接](https://dl.sipeed.com/shareURL/MaixIII/AXera) [产品规格书](https://dl.sipeed.com/shareURL/MaixIII/AXera/01_Specification) [原理图](https://dl.sipeed.com/shareURL/MaixIII/AXera/02_Schematic) [点位图](https://dl.sipeed.com/shareURL/MaixIII/AXera/03_Bit_number_map) [模型文件](https://dl.sipeed.com/shareURL/MaixIII/AXera/05_3D_file) [尺寸图](https://dl.sipeed.com/shareURL/MaixIII/AXera/04_Dimensional_drawing) [GC4653 摄像头参考使用手册](https://dl.sipeed.com/shareURL/MaixIII/AXera/07_Chip_manual) ## 软件开发 ### 超高性价比与能效比 别搞那些虚的。来点实际点的，以下是目前（20221014）市场上销量排行的典型 AI 开发产品，**商品价格会随时变动，有疑问可查询或指出并纠正**。（已除去低成本 38 板摄像头和芯片原厂超昂贵开发板） AI 开发板 全家桶套餐的主要内容 大致价格（20221013） 英伟达JETSON NANO开发板 4GB 主板、铝合金外壳（带风扇）、5V4A 电源、双频无线网卡、64G U盘、IMX279 摄像头、HDMI 线 + 网线、7 寸触摸屏+支架、 ¥2129.00 Raspberry Pi 树莓派4B 4GB 主板、七寸触摸屏+支架、64G U盘、散热片、HDMI 线 + 网线、5V3A 电源、亚克力外壳（带风扇）、500w USB 摄像头、入门指导手册 ¥1439.00 Khadas vim3物联网a311d（目前线上销量不高，但很典型） VIM3（4GB+32G）开发板、外壳、散热器、风扇、30W 电源、HDMI 线 ¥1399.00 迅为RK3568开发板瑞芯微 商业级2G+16G、7寸MIPI屏、OV5695摄像头、（没有配电源） ¥1380.00 EASY EAI Nano AI开发板 瑞芯微RV1126 1GB 单主板、200w双目摄像头（gc2xxx）、5寸ips屏、天线、喇叭、铜柱、2A电源 ¥799.00 亚博智能 旭日X3派开发板 2GB 主板、古月居课程、WIFI 天线、铝合金外壳、gc4663 摄像头、32G U盘、5V3A 开关电源、HDMI 线 ¥769.00 Sipeed M3AXPI Linux AI 微光夜视 爱芯派 2GB 单主板、400w gc4653 摄像头、5寸ips屏、外壳、数据线、32G TF 卡、在线模型训练服务、活力四射的开源社区 ¥579.00 想想某些产品为什么卖这么贵，销量还这么好？凭什么？ 这些产品除了本身的质量要过硬，功能要够强，还要凭借自身的社区生态、软件支持、丰富资料、开源代码、用户口碑等等特色，来支撑产品高性价比的形象。 > 笔者在这里认为所谓的性价比不是一昧地追求产品的最低价，而是在同类产品市场的主流价格区间内，选出社区用户群体可以接受的价格，然后在这个定位里去尽力做出效果最好的产品。 从这些典型的产品中可以看出 m3axpi 套餐是没有配「散热片和风扇还有外接电源」的，这也是它的另一个特色「高能效比」。 是的，这个产品不需要散热器/风扇，也不需要外接 2A 电源就可以启动系统，更不需要找 hdmi 线和显示器。 来一个实际测量的温度和功耗，注意要使用 USB3.0 的口来供电喔。 <p align \"center\"> <img src \"./../assets/temp_test_axpi.jpg\" style \"zoom: 100%;\" /> </p> > 从实测结果上来看，这个功耗和温度控制得挺好，用 USB3.0 5V@1A 承载了底板、核心板、WIFI、以太网、摄像头、5寸屏的工作。 ### 基于 debian 系统开发 提供 debian11 Linux 系统，支持 SD 卡启动 DD 烧录系统，方便用户开箱上手，同时支持 Python API 编程开发 AI 应用。 1. 烧录方法：[WIKI AXera Pi 烧录系统](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/flash_system.html#%E8%8E%B7%E5%8F%96%E9%95%9C%E5%83%8F) 2. 上手指南：[WIKI AXera Pi 上手必看](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/flash_system.html) 2. Python 编程：[ax_pipeline_api ](https://github.com/junhuanchen/ax_pipeline_api) （由社区大佬鼠贡献） 3. 开发笔记：[[maixpy3 axpi] 关于爱芯 ax620a 移植 debian11 系统这件事](https://www.cnblogs.com/juwan/p/16751348.html) 4. 开发笔记：[[maixpy3 axpi] 编辑发布 debian 镜像与在 PC 上交叉编译程序 ](https://www.cnblogs.com/juwan/p/16769237.html) ### 开放 BSP SDK 源码 提供各类开发源码，提供 API 开发文档，SDK 开发方法等说明，细节可以从[准备 C/C++ 编程](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/dev_prepare.html#%E8%8E%B7%E5%8F%96 SDK %E6%BA%90%E7%A0%81) 得知。 #### [ax sample](https://github.com/AXERA TECH/ax samples) 由爱芯提供典型 AI 模型的开发与评估验证，提供给有经验的 AI 开发者使用或只想蹭模型的同学，不涉及任何硬件外设有关的内容。 1. [示例项目 examples](https://github.com/AXERA TECH/ax samples/tree/main/examples) 2. [物体检测 PP YOLOv3](https://github.com/AXERA TECH/ax samples/blob/main/examples/ax620/README.md#yolov3paddle) 3. [人体分割 PP HumanSeg](https://github.com/AXERA TECH/ax samples/blob/main/examples/ax620/README.md#MobileSeg) 4. [语义分割 PP Seg](https://github.com/AXERA TECH/ax samples/blob/main/examples/ax620/README.md#PP HumanSeg) #### [libmaix](https://github.com/sipeed/libmaix) 由 SIPEED 提供在嵌入式平台统一的嵌入式开发环境，主要有摄像头、屏幕、视觉、图像处理、部署 Pipeline 相关的实机例程，适合刚入门嵌入式 linux 开发的同学使用。 1. [测试一下屏幕显示](https://github.com/sipeed/libmaix/tree/release/examples/display) 2. [把摄像头显示到屏幕](https://github.com/sipeed/libmaix/tree/release/examples/axpi) 3. [摄像头+yolov5 模型+屏幕](https://github.com/sipeed/libmaix/tree/release/examples/axpi_yolov5_cam) #### [axpi_bsp_sdk](https://github.com/sipeed/axpi_bsp_sdk) 芯片商用时所用的 bsp 开发包，这里主要提供的是芯片的原始开发资料，如 uboot、linux、msp 、sample、rtsp、ipcdemo 等工程代码，这个部分是逐步开源的，你可以从这里得到商业评估用的代码，例如 ipcdemo 这样的程序，但这些代码会很复杂且高耦合，适合有经验的同行出于商业落地的目的使用。 1. 开发文档 [docs](https://github.com/sipeed/axpi_bsp_sdk/tree/main/msp/sample/vo_fb) 2. 框架应用 [ipcdmeo](https://github.com/sipeed/axpi_bsp_sdk/tree/main/app/IPCDemo) 3. 外设验证 [sample](https://github.com/sipeed/axpi_bsp_sdk/tree/main/msp/sample) #### [ax pipeline](https://github.com/AXERA TECH/ax pipeline) AX Pipeline 由爱芯主导开发。该项目基于 AXera Pi 展示 ISP、图像处理、NPU、编码、显示 等功能模块软件调用方法，方便社区开发者进行快速评估和二次开发自己的多媒体应用。 1. [快速编译](https://github.com/AXERA TECH/ax pipeline/blob/main/docs/compile.md) 基于 cmake 实现简单的跨平台编译。 2. [如何更换自己训练的 yolov5 模型](https://github.com/AXERA TECH/ax pipeline/blob/main/docs/how_to_deploy_custom_yolov5_model.md) 3. [如何部署自己的其他模型](https://github.com/AXERA TECH/ax pipeline/blob/main/docs/how_to_deploy_custom_model.md) 4. [如何调整图像方向](https://github.com/AXERA TECH/ax pipeline/blob/main/docs/how_to_adjust_image_orientation.md) 5. [ModelZoo](https://github.com/AXERA TECH/ax pipeline/blob/main/docs/modelzoo.md) 一些支持或将支持的模型和一些模型的说明。 ## 常见问题（FAQ） AI 服务 http://maixhub.com 在线文档 http://wiki.sipeed.com 交流社区 http://bbs.sipeed.com 开源组织 http://github.com/sipeed AXERA 技术交流群：（ 139953715 ）专供 AI ISP 技术交流 荔枝 MaixPy3 AI 交流群：（ 756313869 ）给产品开箱小白答疑 Q & A 请到 [Maix III 系列 AXera Pi 常见问题(FAQ)](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/faq_axpi.html) 了解喔。"},"/hardware/zh/maixIII/ax-pi/flash_system.html":{"title":"AXera-Pi 上手指南","content":" title: AXera Pi 上手指南 tags: AXera Pi, 烧录系统, 上手指南 keywords: AXera Pi，烧录, 上手 desc: AXera Pi 产品上手指南 update: date: 2022 11 25 version: v0.4 author: lyx content: 增加上手使用说明 ## 上手指南 为了让小伙伴们轻松、快速、平稳地把产品用起来，我们准备了新手初学者上手指南： ### Linux 系统简介 **AXera Pi 默认板卡没有存储介质，因此需要准备一张系统卡来启动设备。** 目前 AXera Pi 提供的是 Debian11 Bullseye 镜像，[Ubuntu 源自 Debian，这意味着 Ubuntu 使用与 Debian 相同的 apt 打包系统，并共享来自 Debian 存储库的大量软件包和库，利用 Debian 基础设施作为基础。 大多数“派生” Linux 发行版，它们使用相同的包管理系统并与基于的发行版共享软件包。](https://zhuanlan.zhihu.com/p/426219868) > ![debian_logo](./../assets/debian_logo.jpg) > [选择 Debian 的理由](https://www.debian.org/intro/why_debian) [官方淘宝店](https://sipeed.taobao.com/) 可以购买预烧录系统镜像的 SD 卡，否则就需要自己进行以下的操作来准备 SD 镜像卡。 ### 选择 SD 卡 > 已在官方购买镜像卡的同学跳过这一步骤，直接在设备插入 TF 卡[ 点击查看 ](#%E5%90%AF%E5%8A%A8 Linux %E7%B3%BB%E7%BB%9F)启动 Linux 系统。 为了方便用户有更多的选择，我们对部分 SD 卡在 AXera Pi 板子上进行了读写测速。 ![sd](./../assets/flash_system/sd.jpg) > 因为部分 SD 卡是后面陆续才进行测试，没有一一单独拍照但可以根据型号辨认。 序号 型号 <p style \"white space:nowrap\">写入速度（写入量 160MB）</p> <p style \"white space:nowrap\">读取速度（读取量 160MB） </p> 1. Netac 朗科 A2 P500 超高速 64GB 存储卡 2.04697 s, 80.0 MB/s 1.8759 s, 87.3 MB/s 2. 三星 microSDXC UHS I 128G 存储卡（蓝卡） 2.53387 s, 64.7 MB/s 1.99882 s, 82.0 MB/s 3. EAGET TF 卡（T1 系列）64G 存储卡 6.56955 s, 24.9 MB/s 7.13792 s, 23.0 MB/s 4. 京东 高性能 microSDXC UHS I 128G 存储卡 2.28133 s, 71.8 MB/s 1.92001 s, 85.3 MB/s 5. KIOXIA microSDXC UHS I 32G 存储卡 6.71284 s, 24.4 MB/s 2.36794 s, 69.2 MB/s 6. Netac 朗科 A1 32GB 存储卡 4.31411 s, 38.0 MB/s 2.00759 s, 81.6 MB/s 7. BanQ JOY card 白金 64G 存储卡 9.08105 s, 18.0 MB/s 9.02843 s, 18.1 MB/s 8. 海康威视 HS TF P2 64G 存储卡 2.28079 s, 71.8 MB/s 1.87698 s, 87.3 MB/s 下面为没有拍照但是测速过的卡： 序号 型号 <p style \"white space:nowrap\">写入速度（写入量 160MB）</p> <p style \"white space:nowrap\">读取速度（读取量 160MB） </p> 1. 雷克沙（Lexar）64GB TF（MicroSD）存储卡 C10 U3 V30 A2 2.59644 s, 63.1 MB/s 1.9106 s, 85.8 MB/s 2. 雷克沙（Lexar）128GB TF（MicroSD）存储卡 C10 U3 V30 6.73793 s, 24.3 MB/s 6.94079 s, 23.6 MB/s ### 烧录 Linux 系统 ![axpi flash](./../assets/axpi flash.png) 因为开发板上的 EMMC 仅默认预留焊盘，所以需要从 TF 卡启动 Linux Debian 系统。 #### 如何获取镜像？ 因为镜像文件比较大，因此仅提供百度云下载链接。 前往百度云[点击进入下载页面](https://pan.baidu.com/s/1 UtDoAVP6spwqjHP2wneJA)，输入提取码 `sdls` 即可下载文件，镜像包与校验文件都已经放在里面了。 ![debian](./../assets/debian.jpg) 其中拓展名为 `img.xz` 的是压缩文件，我们就是需要烧录这个文件，拓展名是 `img.xz.md5sum` 的是校验文件，可以用来校压缩文件的完整性。 镜像压缩文件命名的组成为：`镜像提供方` _ `适用芯片` _ `Linux 发行版` _ `镜像时间` + `img.xz` 校验文件需要在 Linux 环境中使用，windows10 及以上的用户可以使用 wsl 来提供 Linux 环境 使用命令为在镜像文件和校验文件共同存在的目录使用 `md5sum c *.md5sum*`，就可以来查看完整性了。 校验成功 校验失败 ![md5sum_success](./../assets/flash_system/md5sum_success.jpg) ![md5sum_failed](./../assets/flash_system/md5sum_failed.jpg) 可以看到校验失败的话会消失 FAILED。当然通常不需要进行校验，这里只是给有需要的人提前预留一下。 #### 如何烧录镜像？ **烧录前我们需要进行以下准备：** 一张容量大于 8G 的 SD 卡；建议购买官方镜像卡，不然可能会因为 SD 卡质量差而带来糟糕的体验 一个读卡器：建议使用支持 USB3.0 的读卡器，不然会因为读卡器的速度过低会使烧录时间过长 [Etcher](https://www.balena.io/etcher/)软件：根据自身电脑下载对应版本的软件即可 **镜像系统烧录方法：** 首先运行 [Etcher](https://www.balena.io/etcher/ \"Etcher\") 软件，点击 `Flash from file` 选中已经下载好的 `img.xz` 文件镜像，然后点击 `Select target` 选中 SD 卡，最后点击 `Flash` 进行烧录等待完成即可。 **烧录镜像文件到 SD 卡：** ![burn_image_by_etcher](./../../../assets/maixIII/ax pi/burn_image_by_etcher.gif) 烧录中 烧录完成 ![axera_burning_image](./../../../assets/maixIII/ax pi/axera_burning_image.png) ![finish_flash](./../../maixII/M2A/assets/finish_flash.png) 需要注意的是在烧录完成后显示的应该是 `Flash Complete!`，并且显示的是 `Successful` 。 进行完上述操作后，电脑可能会提示需要格式化 U 盘，这个时候我们直接忽略这个提示（因为在 Etcher 软件里面已经烧录完成且 `Successful` 了），将内存卡取下，准备安装到板子上准备使用。 #### 烧录问题 ##### 1. 使用 Etcher 选择镜像的后出现错误 可以重新运行 Etcher 来解决该软件由于缓存等问题而造成的加载错误 ##### 2. 结束烧录后提示的是 Failed 重新一次烧录内存卡镜像 ##### 3. 格式化后内存卡可用容量很小 这种情况使用对于 Windows 和 MacOS 可以使用 [SD Card Formatter](https://www.sdcard.org/downloads/formatter/eula_windows/SDCardFormatterv5_WinEN.zip)来格式化 SD 卡，Linux 系统可以使用系统的 disk 工具或 [Gparted](https://gparted.org/)来格式化。 ### 启动 Linux 系统 完成上面的烧录镜像卡后，接着接可以组装板子了。 ![axpi connect](./../assets/axpi connect.png) #### 如何连接外设和配件？ > 购买全功能套餐的同学们可以跳过此装配步骤。 **接线前我们需要进行准备工作：** 一块 AXera Pi 开发板 一个 USB3.0 （或者两个 USB2.0）的电脑接口来连接板子 一张已经烧录适用于 m3axpi 的系统镜像的 SD 卡 GC4653 Sensor 普通版摄像头 或者 OS04a10 Sensor 夜视版摄像头 配套的 5 寸 MIPI 屏 ![axpi config](./../assets/axpi config.jpg) **可参考以下示例避免误接：** 将屏幕**（排线反面朝上）**接入底板背面 LCD 接口，组装好后翻正板子在右侧的卡槽处插入烧录好的镜像卡。 <html> <img src \"./../assets/mipi.jpg\" width 48%> <img src \"./../assets/sensor.jpg\" width 48%> </html> **摄像头接线认准以下注意点：** >因物料更换摄像头现有两种版本，`V3753` 版本的摄像头接线座子以及线序进行了更改，**如若接反后上电的话底板的 LED 灯会不亮，接反时间久会导致烧坏板卡或摄像头，请根据以下注意点正确接入摄像头。** 进行接线前确保摄像头底部的小人与板子丝印同向再进行接线，如下图所示。 ![sensor_oldnew](./../assets/sensor_oldnew.jpg) 接线时确保底板接口座子与摄像头座子的线序 **`1`** 在同一侧，认准排线正面蓝色线序接入即可。 <html> <img src \"./../assets/senror_v3751.jpg\" width 48%> <img src \"./../assets/sensor_v3753.jpg\" width 48%> </html> #### 如何启动 AXera Pi ？ >因物料更换屏幕现有不同的版本，需区别版本以及使用屏幕时出现锯齿等画面请移步到[ Maix III 系列 AXera Pi 常见问题(FAQ) ](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/faq_axpi.html#Q：硬件物料更改说明、没有 wlan0 、屏幕烧屏、摄像头倒过来怎么解决？)查询。 如果 PC 支持 USB3.0 * 用 type c 接入 `USB UART`，串口方式登录开发板 * 或者接 `USB OTG`， ssh 方式登录开发板 如果 PC 只支持 USB2.0 * 需要两个 USB2.0 端口、两根 type c，同时连接 `USB UART` 和 `USB OTG` ，否则电流不足无法开机 ![start](./../assets/start.jpg) > 在 **20221013** 后设备通电开机会从耳机播放音乐和点亮出厂的 5 寸屏幕，并在串口输出如下的 debian11 系统启动日志（截取部分日志如下）.[有些同学会遇到 Ubuntu22.04 CH340 系列串口驱动（没有 ttyUSB）问题，点此查看解决方案](https://blog.csdn.net/qq_27865227/article/details/125538516)。 ![m3axpi_debian_boot_log_screenshot](./../../../en/maixIII/ax pi/assets/flash_system/m3axpi_debian_boot_log_screenshot.png) ### 登录到板子里 > 当 **AXera Pi** 出现上述 logo 画面后代表开机成功，这时我们把板子当做一台 Linux 服务器来对待。 ![axpi login](./../assets/axpi login.png) 通过**「系统登录方式」**快速帮助用户了解如何登录到设备里的 Linux 系统，用户可以选择 `USB UART 串口` 或 `USB OTG SSH` 登录，可点击[**「系统使用手册 登录方式」**](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/basic_usage.html#%E7%B3%BB%E7%BB%9F%E7%99%BB%E5%BD%95)前往查看，以下文 USB OTG 口的 usb0 网卡（192.168.233.1）作为 ssh 登录的 ip 进入板子为例。 ```bash juwan@juwan n85 dls:$ sshpass p root ssh root@192.168.233.1 Linux AXERA 4.19.125 #53 SMP PREEMPT Tue Sep 13 13:16:27 HKT 2022 armv7l The programs included with the Debian GNU/Linux system are free software; the exact distribution terms for each program are described in the individual files in /usr/share/doc/*/copyright. Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent permitted by applicable law. Last login: Wed Oct 12 16:43:43 2022 from 192.168.233.10 root@AXERA:~# screenfetch _,met$$$$$gg. root@AXERA ,g$$$$$$$$$$$$$$$P. OS: Debian ,g$$P\"\" \"\"\"Y$$.\". Kernel: armv7l Linux 4.19.125 ,$$P' `$$$. Uptime: 2d 3h 5m ',$$P ,ggs. `$$b: Packages: 785 `d$$' ,$P\"' . $$$ Shell: bash 5.1.4 $$P d$' , $$P Disk: 2.6G / 3.6G (77%) $$: $$. ,d$$' CPU: ARMv7 rev 5 (v7l) @ 4x 1.248GHz $$\\; Y$b._ _,d$P' RAM: 88MiB / 744MiB Y$$. `.`\"Y$$$$P\"' `$$b \" .__ `Y$$ `Y$$. `$$b. `Y$$b. `\"Y$b._ `\"\"\"\" root@AXERA:~# ax_clk AX620A: DDR: 3733 MHz CPU: 800 MHz BUS of VPU: 624 MHz BUS of NPU: 624 MHz BUS of ISP: 624 MHz BUS of CPU: 624 MHz NPU OTHER: 800 MHz NPU GLB: 24 MHz NPU FAB: 800 MHz NPU CORE1: 800 MHz NPU CORE0: 800 MHz ISP: 533 MHz MM: 594 MHz VPU: 624 MHz root@AXERA:~# ``` <! 由上文我们可以知道板子的基础信息，在 **20221202** 后更新的镜像包里已经开放了 1.22G 的用户空间。 > <! 我们可以跟着指南往下看学会把板子用起来！ > <! 我们可以知道板子的基础信息，目前默认是用 800Mhz 来跑，而且内存分配较保守能留给用户的空间内存不到 1GB，但不用担心，板子贴得内存最小都得是 2G 的，所以之后会通过更新内核开放更多内存给用户空间。 > ### 学会使用板子 ![axpi ai](./../assets/axpi ai.png) 由于默认没有配置桌面环境（只显示 logo），所以我们需要将 **AXera Pi** 连接一台电脑，通过终端管理软件（shell）与它进行命令行交互，这些可以在[「系统使用手册 验证外设」](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/basic_usage.html#%E9%AA%8C%E8%AF%81%E7%B3%BB%E7%BB%9F%E5%A4%96%E8%AE%BE)学会板上所有验证过的系统调频、外设、驱动、应用等资源的用法，像一些 Linux 操作基础、如何控制 I2C / UART / SPI 这些硬件设备的操作，还可以在[「系统使用手册 内置 AI 应用」](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/basic_usage.html#%E9%AA%8C%E8%AF%81%E7%B3%BB%E7%BB%9F%E5%A4%96%E8%AE%BE)里调用内置的开箱 AI 应用及例程，快去用起来吧！ ![serial](./../assets/serial.jpg) ### 试试 Python 编程（适用初学者） 基于这篇上手指引的一路走下来的学习，相信小伙伴们也基本对 **AXera Pi** 基础使用以及验证外设有一定的掌握了，那我们就踏入编程的世界，一起来试试 Python 编程吧！ [试试 Python 编程](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/python_api.html) 我们内置了以 `jupyter notebook/ax pipline api/pinpong` 等 Python 包，你可以在**「试试 Python 编程」**里获得如何在 **AXera Pi** 上进入 Python 模式启动 `jupyter notebook` 并使用运行 AI 模型。 ![python_jy](./../assets/python_jy.jpg) 以及如何连接 **Arduino UNO** 以及 **Microbit** 进行 Python 编程的效果如下图。 <html> <img src \"./../assets/arduino.jpg\" width 48%> <img src \"./../assets/microbit.jpg\" width 48%> </html> ### 准备 C/C++ 编程（适用开发者） 能走到这里就说明板子已经用起来了，那就来开发吧！在这之前需要**「准备 C/C++ 编程」**了解如何拷贝文件到板子里，如何搭建本地编译或交叉编译，然后学习到如何基于现有的代码进行开发。 [准备 C/C++ 编程](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/dev_prepare.html) 快速了解现在提供哪些开源代码仓库以及用法，这些开源仓库会持续更新和开放的。 ![axpi_sdk.jpg](./../assets/axpi_sdk.jpg) ### 训练模型部署 初学者训练模型可以从 [AI 开发指南](https://wiki.sipeed.com/ai/zh/deploy/ax pi.html) 学习如何训练一个最简单的模型到量化转换部署测试。 更专业更深入的调优需要了解 [Pulsar](https://pulsar docs.readthedocs.io/) ，这是由**「爱芯元智」**自主研发的 all in one 神经网络编译器，充分发挥片上异构计算单元(CPU+NPU)算力， Pulsar 工具链核心功能是将 .onnx 模型编译成芯片能解析并运行的 （.joint） 模型。 目前有以下几种部署方式（Pipeline）推荐： **libmaix**：并不在意程序的性能和效率，用最快的方式把摄像头图像输入 AI 模型后输出识别结果绘制到显示到屏幕上验证一下识别效果。 **ax pipeline**：没有多余的封装，直接操作芯片核心资源 vin \\ ivps \\ npu \\ vo 等硬解设备进行部署开发，可以使模型部署达到一个非常好的效果。 **IPCDemo**：以效果最好、性能最好、占用最少、稳定可靠、功能最多、确保最终能部署到用户的现场不出问题的框架代码来开发 AI 程序。 #### libmaix 部署 在板子上编译这个示例代码 [axpi_classification_cam](https://github.com/sipeed/libmaix/tree/release/examples/axpi_classification_cam)，然后放入模型运行后即可看到效果，截止 **20221013** 前代码还没有优化所以性能不高只够看个结果，想要效果和性能可以看 **ax pipeline** 部署。 <p align \"center\"> <img src \"./../assets/mobilenet_axpi.jpg\" alt \"img\" style \"zoom: 100%;\" /> </p> 即可验证效果：[详细可从 maixhub 上获取](https://maixhub.com/model/zoo/89)。 #### ax pipeline 部署 以上的部署方式都出于快速验证或应用落地的角度进行的，还有一套基于 **bsp sdk** 的 [ax pipeline](https://github.com/AXERA TECH/ax pipeline) 部署方式，它面向既了解 AI 又知道芯片底层 Linux 开发方法的同学，目前内置应用中提供了板子的 **rtsp** 和屏幕双推流 **yolov5** 实时识别以及新增 **yolov5s seg** 实例分割的程序就是来自于它。 ![rtsp display](./../assets/rtsp display.jpg) #### IPCDemo 部署 这是一个典型的 IPC 演示程序，源码在这里 [axpi_bsp_sdk IPCDemo](https://github.com/sipeed/axpi_bsp_sdk/tree/main/app/IPCDemo) ，其中 IPCDemo 的功能模块有： ISP：负责从 Sensor 获取图像 RAW 数据并转为 YUV，最终分 3 路通道输出以上信息。 IVPS：图像视频处理模块。实现对视频图形进行一分多、Resize、Crop、旋转等功能。 VENC / JENC：视频/JPEG 编码输出。 Detect：支持人脸或结构化检测。 Web 显示：实现 H264 流的 Web 传输和提供 Web 方式查看实时视频。 RTSP 推流：实现 H264 流的 RTSP 封装以及传输。 录像 TF 卡存储：封装 H264 流为 MP4 格式文件并保存至 TF 卡或者 FLASH 空间。 以下视频中的 IPCDemo 程序使用方法请点击<a href \"https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/basic_usage.html#%E5%86%85%E7%BD%AE%E5%BC%80%E7%AE%B1%E5%BA%94%E7%94%A8\" target \"blank\">内置开箱应用</a>查看。 <p align \"center\"> <iframe src \"//player.bilibili.com/player.html?aid 260625114&bvid BV1me411T7g8&cid 837160730&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\" style \"max width:640px; max height:480px;\"> </iframe> </p>"},"/hardware/zh/maixIII/ax-pi/sdk_usage.html":{"title":"Maix-III 系列 AXera-Pi 开发板 SDK 使用介绍","content":" title: Maix III 系列 AXera Pi 开发板 SDK 使用介绍 ## 获取 SDK 源码 上一篇介绍了基础的开发环境搭建和使用方法，你应该了解什么是本地编译和交叉编译，这一篇介绍如何使用这些 sdk 源码开发程序。 [libmaix](https://github.com/sipeed/libmaix) 由 sipeed 提供在 linux 平台统一的嵌入式开发环境，主要有摄像头、屏幕、视觉、图像处理、NPU pipiline 相关的实机部署例程，适合刚入门嵌入式 linux 开发的同学使用。 [ax sample](https://github.com/AXERA TECH/ax samples) 由爱芯提供 AI 模型的开发与评估验证，提供给有经验的 AI 开发者使用，不涉及任何硬件外设有关的内容。 [axpi_bsp_sdk](https://github.com/sipeed/axpi_bsp_sdk) 芯片商用时所用的 bsp 开发包，这里主要提供的是芯片的原始开发资料，如 uboot 、 linux 、 msp 、msp 等工程代码，这个部分是逐步开源的，你可以从这里得到商业评估用的代码，例如 ipcdemo 这样的程序，但这些代码会很复杂且高耦合，适合有经验的同行出于商业落地的目的使用。 [ax pipeline](https://github.com/AXERA TECH/ax pipeline) 基于 axpi_bsp_sdk 制作的 AI 部署高性能仓库，在这里主要用于该项目基于 AXera Pi 展示 ISP、图像处理、NPU、编码、显示 等功能模块软件调用方法，方便社区开发者进行快速评估和二次开发自己的多媒体应用。 ### libmaix 这是一个适用于 sipeed 所用 linux 芯片开发的 C/C++ 基础开发框架，使用 cmake 构建，提供了许多开箱参考的案例，还有一些第三方库代码的链接，如 opencv openmv 这些视觉库的链接。 SDK 源码在 [libmaix](https://github.com/sipeed/libmaix)， 需要使用 git 命令下载： ```bash git clone https://github.com/sipeed/libmaix.git recursive ``` >! 注意这里` recursive` 参数是必须的，用来下载仓库里面的子模块，如果没有这个参数，代码会不完整，导致编译出错 > 中国国内可能下载速度较慢，可以多取消重试几次，可能会遇到速度快的节点，当然最好还是通过设置代理来加速下载。 另外， AI 模型及例程在 [MaixHub 模型库](https://maixhub.com/model/zoo) 可以找到， 以及 [AXERA TECH/ax samples](https://github.com/AXERA TECH/ax samples) 仓库。 ## 编译 SDK 源码 回顾一下前文的内容，编译有两种方式： * 直接在开发板上编译：编译速度较慢，但是不需要额外的环境配置。 * 在 PC 上编译，然后拷贝可执行文件到开发板，也就是交叉编译： 编译速度更快，但是需要额外的环境配置。 ### [libmaix](https://github.com/sipeed/libmaix) > /home/ 目录已预置，可以 git pull 联网拉取更新。 对于 `libmaix`， 按照其`README.md` 文件描述的方法编译即可， 不过需要在`menuconfig`命令中选择 `AXera Pi` 作为编译目标。 这里简要介绍一下编译过程（libmaix 目前还未稳定，未来可能会有大的更新），实际以[libmaix 仓库](https://github.com/sipeed/libmaix)代码和说明为准。 * 先安装依赖 ``` apt install build essential cmake python3 sshpass git ``` > sshpass 也可以不安装， build essential, cmake, git, python3 必须安装 * 克隆仓库到本地或者开发板 ``` git clone https://github.com/sipeed/libmaix recursive ``` >! 注意 ` recursive` 参数是必须的，用以克隆子模块，否则会缺代码 这里以在开发板上编译为例： ```bash cd /home/libmaix # git clone https://github.com/sipeed/libmaix recursive cd examples/axpi python3 project.py distclean # python3 project.py menuconfig # 可以配置相关参数 python3 project.py build # 如果增加文件了，需要 python3 project.py rebuild 命令 ./dist/start_app.sh # 运行示例程序 ``` ### [ax samples](https://github.com/AXERA TECH/ax samples) > /home/ 目录已预置，可以 git pull 联网拉取更新。 [ax samples](https://github.com/AXERA TECH/ax samples) 是爱芯官方提供的例程，包含了一些 AI 模型和运行代码，编译完能直接在开发板上运行，只不过输入是图片，不是摄像头。 进入开发板终端，执行以下代码： ```bash cd /home/ax samples # git clone https://github.com/AXERA TECH/ax samples.git mkdir build cd build cmake .. make install ``` 然后就能在`ax samples/build/install/bin/`目录下找到编译好的可执行文件。 ### [axpi_bsp_sdk](https://github.com/sipeed/axpi_bsp_sdk) 回到芯片原厂开发的环境，这需要有经验的嵌入式 Linux 开发者来操作，直接看 readme 进行操作，文档在 docs 目录下。 #### What is this? this is a ax620 linux bsp sdk form AX620_R1.22.2801_Sipeed. currently it is application layer open source. ```bash juwan@juwan n85 dls:~/GIT_AX620_SDK_V0.31.0_P23/sipeed/axpi_bsp_sdk$ tree L 1 . ├── app ├── build ├── msp ├── readme.md ├── rootfs └── third party 5 directories, 1 file ``` #### ready arm gcc ```bash git clone https://github.com/sipeed/axpi_bsp_sdk.git cd axpi_bsp_sdk wget http://releases.linaro.org/components/toolchain/binaries/latest 7/arm linux gnueabihf/gcc linaro 7.5.0 2019.12 x86_64_arm linux gnueabihf.tar.xz sudo tar xvf gcc linaro 7.5.0 2019.12 x86_64_arm linux gnueabihf.tar.xz C /opt/ ``` #### how to compile bsp msp sample ```bash cd msp/sample/ export PATH \"/opt/gcc linaro 7.5.0 2019.12 x86_64_arm linux gnueabihf/bin/:$PATH\" && make p AX620_demo all install ``` third party libs ```bash cd third party export PATH \"/opt/gcc linaro 7.5.0 2019.12 x86_64_arm linux gnueabihf/bin/:$PATH\" && make p AX620_demo all install ``` bsp app ipcdemo ```bash cd app/ export PATH \"/opt/gcc linaro 7.5.0 2019.12 x86_64_arm linux gnueabihf/bin/:$PATH\" && make p AX620_demo all install ``` bsp msp component lib, such as `cd app/msp/component/common && make xxxx`. ``` juwan@juwan n85 dls:~/GIT_AX620_SDK_V0.31.0_P23/sipeed/axpi_bsp_sdk/msp/component$ tree L 1 . ├── axsyslog ├── common └── thermal 4 directories, 0 files ``` #### run your program on pc ``` sshpass p root scp ./vo_fb/sample_vo_fb root@192.168.233.1:/opt/bin/sample_vo_fb ``` on board ``` chmod 777 /opt/bin/sample_vo_fb /opt/bin/sample_vo_fb v dsi0@480x854@60 m 0 & fbv /home/examples/480x360.jpg killall sample_vo_fb ``` ## 组合 SDK 和 AI 模型例程 比如我们要跑一个视觉 AI 模型，需要用到摄像头，屏幕，还有 AI 模型，你需要借助以下仓库代码完成这个目标。 ### 借助 libmaix 实现（开发难度最小，适合验证） 基于 libmaix 的 axpi 项目进行开源快速验证效果，代码简单易懂，基于在线服务完成模型部署，只用于新手上路，与 ax sample 的模型一起被支持。 [axpi](https://github.com/sipeed/libmaix/tree/release/examples/axpi) [axpi_classification_cam](https://github.com/sipeed/libmaix/tree/release/examples/axpi_classification_cam) [axpi_yolov5_cam](https://github.com/sipeed/libmaix/tree/release/examples/axpi_yolov5_cam) > 20221113 目前仓库只保证用户初次上手时能够不报错的安全调用 AI 模型，不代表芯片的最好效果。 ### 借助 ax pipeline 实现（开发难度适中，适合优化） 到了这里要有基本的芯片 bsp sdk 开发的基础（axpi_bsp_sdk），这部分会略显专业一些，这个仓库目前追求最高性能的效果。 [准备编译环境](https://github.com/AXERA TECH/ax pipeline/blob/main/docs/compile.md) [如何更换自己训练的 yolov5 模型？](https://github.com/AXERA TECH/ax pipeline/blob/main/docs/how_to_deploy_custom_yolov5_model.md) [如何部署自己的其他模型](https://github.com/AXERA TECH/ax pipeline/blob/main/docs/how_to_deploy_custom_model.md) ### 借助 ipcdemo 实现（开发难度最大，适合落地） 基于 axpi_bsp_sdk 的 ipcdemo 商用视频推流应用，由于源码过于复杂，需要有上述基础才能介入。 [axpi_bsp_sdk/app/IPCDemo](https://github.com/sipeed/axpi_bsp_sdk/tree/main/app/IPCDemo)"},"/hardware/zh/maixIII/ax-pi/python_api.html":{"title":"Maix-III AXera-Pi 试试 Python 编程","content":"时间负责人更新内容: :: :: :2022.12.02lyx初次编写文档2022.12.15lyx增加内容2023.01.04lyx增加人脸/车牌识别、Yolov6等新模型2023.01.29lyx补充细节说明2023.02.23lyx增加YOLOV8、YOLOV8 SEG、ax_bvc_det（人车非检测）、crowdcount（人流量统计）等模型基于前文的[产品上手指南](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/flash_system.html)以及[系统使用手册](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/basic_usage.html)后，本文章会介绍如何在MAIX IIIAXera Pi板卡上体验Python编程！##前言从MIAX IMCU、MAIX IISOC、再到MAIX IIILinux系列，SIPEED一直在致力于让更多的人轻松快捷的把板卡使用起来，所以衍生了各种各样的上手指南文档，板卡也在增加着更多形式的编程体验，Linux基础差不熟悉？C++有难度？调用AI模型困难？没有关系，那就由这篇适合初学者的Python编程文档来帮助你快速把AXera Pi板卡用起来并调用AI模型应用。在进入到使用Python编程之前，我们需要先认识要使用的语言以及工具，一起往下看吧。在AXera Pi板卡内置了`Python3、JupyterNotebook、Pinpong、Pillow`等包让用户更便捷的进行使用Python编程，本篇文档以在`JupyterNotebook`网页上进行Python编程为示例阐述。###什么是Python**Python**是一种广泛使用的解释型、高级和通用的编程语言。它支持多种编程范型包括函数式、指令式、反射式、结构化和面向对象编程，还拥有动态类型系统和垃圾回收功能，能够自动管理内存使用，并且其本身拥有一个巨大而广泛的标准库。![api_python_logo 3.jpg](attachment:api_python_logo 3.jpg) **Python与C++相比有什么区别？**从上文得知Python是一种解释型语言，用户不需要编译以扩展名为`.py`的代码可直接传递给解释器生成输出。而C++是编译型语言，编译器需要把源代码生成目标代码再执行生成输出。对于初学者来说Python更易于学习并且语法简单、可读性更强。而C++在系统编程及性能上更优胜，但语法复杂编写起来对初学者有一定的挑战难度。 **Python基础及入门学习**在使用JupyterNotebook进行Python编程之前，同学们需要掌握一定的Python语言的基础才能接着往下走，可根据下列提供的传送门进行学习。[什么是Python?](https://wiki.sipeed.com/soft/maixpy3/zh/origin/python.html?highlight python)[国内Python基础教程](https://wiki.sipeed.com/soft/maixpy3/zh/origin/video.html)**以下的文章适合有一定Python基础想深入的同学们：**[大佬鼠の嵌入式Python入门教程[1]](https://wiki.sipeed.com/soft/maixpy3/zh/origin/hello_world.html)[大佬鼠の嵌入式Python入门教程[2]](https://wiki.sipeed.com/soft/maixpy3/zh/origin/loop_python.html)###什么是JupyterNotebook它是同时兼具Python3、Markdown及Terminal的环境并基于网页用于交互计算的应用程序。其可应用于开发、文档编写、运行代码和展示结果，以网页的形式打开并可直接编写及运行代码，运行结果也会直接显示在代码框下层。如在过程中需要编写说明文档，可在同页面中编写便于及时的解释和说明。![api_jupyter.jpg](attachment:api_jupyter.jpg)##启动网页>如果你浏览完上面的段落后到达这里，相信你已经掌握如何在AXera Pi进行烧录并登录系统以及基础的Linux操作了，并对我们即将用到的Python语言以及工具`JupyterNotebook`有了一定的认识，那就接着往下学习如何启动网页进行Python编程吧！> [产品上手指南](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/flash_system.html)> [系统使用手册](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/basic_usage.html)使用前准备一台AXera Pi设备并把它接入电脑端通电，参考[系统使用手册](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/basic_usage.html#%E7%B3%BB%E7%BB%9F%E7%99%BB%E5%BD%95)登录到板卡的Linuxdebian11系统，登录后使用`ifconfig a`命令查看板卡的IP地址方便后续使用。查询完输入`jupyternotebook`命令启动它，终端会返回一系列服务器的信息。![api_adb.jpg](attachment:api_adb.jpg)上图可以看到终端返回服务器信息，打开任意浏览器输入板卡IP地址后缀加上`:8888`即可直接访问网页端**（但请注意：lo:127.0.0.1此IP是不可用于访问）**网页端会提醒输入密码`root`后访问。![api_root.png](attachment:api_root.png)>**注意**：使用JupyterNotebook时终端需保持连接状态，否则会与本地服务器的连接断开而无法操作。输入后会跳转到`Files`的页面，点击右侧的`New`可选择符合需求的编辑环境。![api_python3.jpg](attachment:api_python3.jpg)```txtPython3：默认的python3kernelTextFile：新建一个文本文件Folder：新建一个文件夹Terminal：在浏览器中新建一个用户终端，类似于shell/adb终端.```##基础用法这里介绍每个方框称为单元格，单元框左侧会有**蓝色（命令模式）**或**绿色（编辑模式）**两种颜色。**`蓝色单元格`(命令模式)**![green.jpg](attachment:green.jpg)**`绿色单元格`(编辑模式)**![blue.jpg](attachment:blue.jpg)通用用法： **Shift+Enter：**运行单元格，且以命令模式切换到下一个单元格 **Ctrl+Enter：**运行单元格，且进入命令模式编辑模式中： **Esc**：进入命令模式命令模式中： **h：**打开帮助 **Enter：**进入编辑模式 **x：**剪切单元格 **c：**复制单元格 **v：**粘贴单元格 **dd：**删除整个单元格 **ii：**终止运行 **a：**向光标所在单元格上方添加单元格 **b：**向下添加 **m：**使得单元格变成markdown状态##运行代码>本篇文章所有的示例代码都是摄像头GC4653为例，如有OS04A10型号请前往[Maix III系列AXera Pi常见问题（FAQ）](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/faq_axpi.html)修改。用户选择`Python3`环境即可进入编辑页面，在网页上运行Python代码有以下三种示例供大家参考，代码运行后编辑框下会打印输出结果参数，用户则可以从板卡设备屏幕观察到运行实时效果。 **使用`!+cmd`运行内置的脚本或命令行，或是直接在框内编辑`Python`代码并点击运行，这里以运行`NPU`应用为例。**!lshome/imagesair.jpg carvana02.jpg\t face5.jpg\t o2_resize.jpg ssd_car.jpg\r aoa 2.jpeg carvana03.jpg\t grace_hopper.jpg pineapple.jpg ssd_dog.jpg\r aoa.jpeg carvana04.jpg\t mobileface01.jpg pose 1.jpeg\t ssd_horse.jpg\r bike.jpg cat.jpg\t\t mobileface02.jpg pose 2.jpeg\r bike2.jpg cityscape.png\t mtcnn_face4.jpg pose 3.jpeg\r cable.jpg dog.jpg\t\t mtcnn_face6.jpg pose.jpg\r carvana01.jpg efficientdet.png mv2seg.png\t selfie.jpg!/home/ax samples/build/install/bin/ax_yolov5s m/home/models/yolov5s.joint i/home/images/cat.jpg r10 model file : /home/models/yolov5s.joint image file : /home/images/cat.jpg img_h, img_w : 640 640 [AX_SYS_LOG] AX_SYS_Log2ConsoleThread_Start Run Joint Runtime version: 0.5.10 [INFO]: Virtual npu mode is 1_1 Tools version: d696ee2f run over: output len 3 Create handle took 487.99 ms (neu 22.29 ms, axe 0.00 ms, overhead 465.70 ms) Repeat 10 times, avg time 22.57 ms, max_time 22.88 ms, min_time 22.46 ms detection num: 1 15: 89%, [ 167, 28, 356, 353], cat [AX_SYS_LOG] Waiting thread(2867848448) to exit [AX_SYS_LOG] AX_Log2ConsoleRoutine terminated!!! exit[AX_SYS_LOG] join thread(2867848448) ret:0fromIPython.displayimportImageImage(\"yolov5s_out.jpg\") **也可以使用`%run`跑模块文件或`.py`文件，这里以运行`hello.py`为例。**%runhello.pyhello world！##启动终端>上文演示了如何实现Python编程，而**JupyterNotebook**还能开启终端并与`Python3`同时运行。回到`homepage`后点击右侧的`New`后选择`Terminal`新建终端进行操作。用户可以在`Files`页面直接查看内置目录的文件夹，或者是使用终端用`ls`查看目录，用`cd`进入目录。![api_wed%20.jpg](attachment:api_wed%20.jpg)##编写文档>用户可在**JupyterNotebook**里使用`Markdowm`语法编写文档提升代码的易读性以及条理性。点击编辑框把模式从代码更换成`Markdown`，在命令模式下可使用`M`键变成`Markdown`状态。![api_markdown 2.jpg](attachment:api_markdown 2.jpg)##传输文件>除了运行代码以及编写文档等还可以进行文件的传输，让用户使用更加便捷。 **如何导入电脑端的文件，以下面两种方式为例：**点击主页右侧`New`新建`TextFile：文本文件`或`Folder：文件夹或文件`，手动复制粘贴内容导入文件。![api_python3.png](attachment:api_python3.png)或者是直接从网页端导入文件，点击右侧的`Upload`直接在任意目录下导入需要的文件即可。![api_upload.jpg](attachment:api_upload.jpg) **如何导出我们在网页端编写的文件，以下面为例：**在网页端编写的的内容都可以以文档的形似输出，默认保存的是以后缀名为`.ipynb`的`json`格式，保存不同格式请点击`File` \\>`Downloadas` \\>`选择你需要的格式即可`，网页会自动下载到本地。![api_file 2.jpg](attachment:api_file 2.jpg)##ax pipeline api>基于`20230214`后更新的镜像包，`ax pipeline api`版本升级到1.0.9支持Python获取摄像头图像及推理结果一起显示到屏幕上或保存。[**ax pipeline api：**](https://github.com/junhuanchen/ax pipeline api)此项目基于[ax pipeline](https://github.com/AXERA TECH/ax pipeline)实现了`pybind11`和`ctypes`的PythonAPI，用户可使用Python调用内置的多种AI模型以及通用的Python库pinpong、opencv、numpy、pillow等，让AXera Pi用起来更简单！ **`ctypes`和`pybind11`两者区别？**`ctypes`是最早适配的，相较于新的`pybind11`来说支持的接口更多稳定性更好，而新的`pybind11`则是输出效果更直观（可显示到屏幕/网页上）代码更任意理解，但两者因板卡外设有限不可混用。 **使用前先安装获取`ax pipeline api`包**因`ax pipeline api`更新升级较频繁，用户在使用Python编程前可先在终端使用下方命令行更新包，确保自己使用是最新版本的即可。!pip3installax pipeline api URequirement already satisfied: ax pipeline api in /usr/local/lib/python3.9/dist packages (1.0.7) Collecting ax pipeline api Using cached ax pipeline api 1.0.7.tar.gz (15.5 MB) Using cached ax pipeline api 1.0.6.tar.gz (19.5 MB)>如果出现更新失败，可替换清华源` ihttps://pypi.tuna.tsinghua.edu.cn/simple`加速一下。##Yolov5/Yolov8目标检测（ctypes）把`ax pipeline api`包升级好后，接下来我们先体验更稳定的**ctypes**的`Yolov5/8`模型实现目标检测！importtimefromaximportpipelinepipeline.load(['libsample_vin_ivps_joint_vo_sipy.so',' p','/home/config/yolov5s.json',' c','2',])whilepipeline.work():time.sleep(0.001)tmp pipeline.result()iftmpandtmp['nObjSize']:foriintmp['mObjects']:x,y,w,h i['bbox']['x'],i['bbox']['y'],i['bbox']['w'],i['bbox']['h']objname,objprob i['objname'],i['prob']print(objname,objprob,x,y,w,h)#iftmp['nObjSize']>10:#tryexit#pipeline.drop()b'bottle' 0.5032062530517578 0.11116950958967209 0.40303218364715576 0.21706661581993103 0.5804097652435303 b'bottle' 0.7368168830871582 0.11036165803670883 0.4033470153808594 0.2250344455242157 0.5822746157646179 b'bottle' 0.7751374244689941 0.11194521933794022 0.3943900167942047 0.21920150518417358 0.5996366739273071 b'bottle' 0.7996727228164673 0.1136007010936737 0.4050813317298889 0.21979697048664093 0.579041600227356 b'bottle' 0.7779128551483154 0.11486124992370605 0.4005553424358368 0.21681155264377594 0.5885791778564453 b'bottle' 0.7506007552146912 0.11348568648099899 0.4008048176765442 0.2208258956670761 0.5853195190429688 b'bottle' 0.7448824644088745 0.11283267289400101 0.40612301230430603 0.22086872160434723 0.5755194425582886importtimefromaximportpipelinepipeline.load(['libsample_vin_ivps_joint_vo_sipy.so',' p','/home/config/yolov8.json',' c','2',])whilepipeline.work():time.sleep(0.001)tmp pipeline.result()iftmpandtmp['nObjSize']:foriintmp['mObjects']:x,y,w,h i['bbox']['x'],i['bbox']['y'],i['bbox']['w'],i['bbox']['h']objname,objprob i['objname'],i['prob']print(objname,objprob,x,y,w,h)#iftmp['nObjSize']>10:#tryexit#pipeline.drop()b'toilet' 0.4541160762310028 0.602770209312439 0.9111631512641907 0.16810722649097443 0.08513855934143066 b'toilet' 0.6902503967285156 0.606963574886322 0.9117961525917053 0.16024480760097504 0.08727789670228958 b'toilet' 0.6852353811264038 0.6020327210426331 0.9118891358375549 0.16942621767520905 0.08718493580818176 b'toilet' 0.7014157176017761 0.6041151881217957 0.9120386242866516 0.16582755744457245 0.0863698348402977 b'cup' 0.46080872416496277 0.6049922108650208 0.9143685698509216 0.1643451750278473 0.08425315469503403从上面跑的yolov8模型示例来看，运行时编辑框下会输出检测结果的相关参数，而实际画面可在板卡屏幕查看。我们也可以从上面的代码中替换不同功能的`.so`库或不同效果的`AI`模型来实现更多的AI应用。>更换`.so`库以及`AI`模型请参考以下示例进行修改，这篇文档只挑选部分经典模型作为示例，大家可以举一反三进行更换功能库以及模型，更多详细信息前往[ax pipeline api](https://github.com/junhuanchen/ax pipeline api)查看。全文示例使用`GC4653`摄像头不同型号请前往[Maix III系列AXera Pi常见问题（FAQ）](https://wiki.sipeed.com/hardware/zh/maixIII/ax pi/faq_axpi.html)修改。 以下是内置的libxxx*.so库总览：**可通过替换不同的`libxxx*.so`来体验不同的功能。**```bashlibsample_h264_ivps_joint_vo_sipy.so#inputh264videotoivpsjointoutputscreenvolibsample_v4l2_user_ivps_joint_vo_sipy.so#inputv4l2/dev/videoXtoivpsjointoutputscreenvolibsample_rtsp_ivps_joint_rtsp_vo_sipy.so#inputvideofromrtsptoivpsjointoutputrtspandscreenvolibsample_vin_ivps_joint_vo_sipy.so#inputmipisensortoivpsjointoutputscreenvolibsample_vin_ivps_joint_venc_rtsp_sipy.so#inputmipisensortoivpsjointoutputrtsplibsample_vin_ivps_joint_venc_rtsp_vo_sipy.so#inputmipisensortoivpsjointoutputrtspandscreenvolibsample_vin_ivps_joint_vo_h265_sipy.so#inputmipisensortoivpsjointoutputscreenvoandsaveh265videofilelibsample_multi_rtsp_ivps_joint_multi_rtsp_sipy.so#inputmultirtspvideotoivpsjointoutputmultirtspvideolibsample_rtsp_ivps_joint_rtsp_sipy.so#inputvideofromrtsptoivpsjointoutputrtsplibsample_rtsp_ivps_joint_rtsp_vo_sipy.so#inputvideofromrtsptoivpsjointoutputrtspandscreenvolibsample_rtsp_ivps_joint_vo_sipy.so#inputvideofromrtsptoivpsjointoutputscreenvo```**更换`libxxx*.so`可参考以下示例：**```bashpipeline.load(['libsample_vin_ivps_joint_venc_rtsp_vo_sipy.so',' p','/home/config/yolov5s.json',' c','2',])``` 以下是内置的多种AI模型总览：**AI模型被内置在`/home/config`的目录下，可通过更换模型来实现不同的AI应用。**```bashax_bvc_det.jsonhrnet_pose_yolov8.jsonyolov5s_face_recognition.jsonax_person_det.jsonlicense_plate_recognition.jsonyolov5s_license_plate.jsonax_pose.jsonnanodet.jsonyolov6.jsonax_pose_yolov5s.jsonpalm_hand_detection.jsonyolov7.jsonax_pose_yolov8.jsonpp_human_seg.jsonyolov7_face.jsoncrowdcount.jsonscrfd.jsonyolov7_palm_hand.jsonhand_pose.jsonyolo_fastbody.jsonyolov8.jsonhand_pose_yolov7_palm.jsonyolopv2.jsonyolov8_seg.jsonhrnet_animal_pose.jsonyolov5_seg.jsonyolox.jsonhrnet_pose.jsonyolov5s.jsonhrnet_pose_ax_det.jsonyolov5s_face.json```**更换AI模型可参考以下示例：**```bashpipeline.load(['libsample_vin_ivps_joint_vo_sipy.so',' p','/home/config/yolov5s_face.json',' c','2',])```##Yolov8 seg实例分割importtimefromaximportpipelinepipeline.load(['libsample_vin_ivps_joint_vo_sipy.so',' p','/home/config/yolov8_seg.json',' c','2',])whilepipeline.work():time.sleep(0.001)tmp pipeline.result()iftmpandtmp['nObjSize']:foriintmp['mObjects']:print(i)#iftmp['nObjSize']>10:#tryexit#pipeline.drop(){'label': 39, 'prob': 0.41857901215553284, 'objname': b'bottle', 'bbox': {'x': 0.02848125249147415, 'y': 0.03796946257352829, 'w': 0.03146517649292946, 'h': 0.15615946054458618}, 'bHasMask': 1, 'mYolov5Mask': {'w': 6, 'h': 15, 'data': b'\\x00\\x00\\xff\\xff\\xff\\x00\\x00\\xff\\xff\\xff\\xff\\x00\\x00\\xff\\xff\\xff\\xff\\x00\\x00\\xff\\xff\\xff\\xff\\x00\\x00\\xff\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\xff\\xff\\x00\\x00\\xff\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\xff\\x00\\x00\\xff\\xff\\xff\\xff\\x00\\x00\\xff\\xff\\xff\\xff\\x00\\x00'}} {'label': 39, 'prob': 0.4118087887763977, 'objname': b'bottle', 'bbox': {'x': 0.028065890073776245, 'y': 0.03647643327713013, 'w': 0.0326821468770504, 'h': 0.15858806669712067}, 'bHasMask': 1, 'mYolov5Mask': {'w': 6, 'h': 15, 'data': b'\\x00\\x00\\xff\\xff\\xff\\x00\\x00\\xff\\xff\\xff\\xff\\x00\\x00\\xff\\xff\\xff\\xff\\x00\\x00\\xff\\xff\\xff\\xff\\x00\\x00\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\xff\\x00\\x00\\xff\\xff\\xff\\xff\\x00\\x00\\xff\\xff\\xff\\xff\\x00\\x00\\xff\\xff\\xff\\xff\\x00\\x00'}}##读取USB摄像头进行检测使用前先准备`USB摄像头`以及`USBtype c转接头`备用，把`USB摄像头`接入`USBtype c转接头`，再把转接头的type c端接入板卡设备的`OTG`口。接线完毕后运行下文代码即可支持USB摄像头输入进行检测，运行效果会输出到设备屏幕。importtimefromaximportpipelinepipeline.load(['libsample_v4l2_user_ivps_joint_vo_sipy.so',' p','/home/config/yolov8.json'])whilepipeline.work():time.sleep(0.001)tmp pipeline.result()##车牌识别（输出运行效果）importtimefromaximportpipelinepipeline.load(['libsample_vin_ivps_joint_vo_sipy.so',' p','/home/config/license_plate_recognition.json',' c','2',])whilepipeline.work():time.sleep(0.001)tmp pipeline.result()iftmpandtmp['nObjSize']:foriintmp['mObjects']:print(i)#iftmp['nObjSize']>10:#tryexit#pipeline.drop(){'label': 0, 'prob': 0.350676953792572, 'objname': b'anhuiCLJ3', 'bbox': {'x': 0.2686941921710968, 'y': 0.17339776456356049, 'w': 0.4595341384410858, 'h': 0.3150448203086853}, 'bHasBoxVertices': 1, 'bbox_vertices': [{'x': 0.2912384867668152, 'y': 0.17690573632717133}, {'x': 0.7315817475318909, 'y': 0.22101126611232758}, {'x': 0.708527147769928, 'y': 0.47905251383781433}, {'x': 0.2720993161201477, 'y': 0.44149187207221985}], 'nLandmark': 4, 'landmark': [{'x': 0.2720993161201477, 'y': 0.44149187207221985}, {'x': 0.708527147769928, 'y': 0.47905251383781433}, {'x': 0.7315817475318909, 'y': 0.22101126611232758}, {'x': 0.2912384867668152, 'y': 0.17690573632717133}]} {'label': 0, 'prob': 0.2783961892127991, 'objname': b'anhuiTLJ0', 'bbox': {'x': 0.23988564312458038, 'y': 0.38015124201774597, 'w': 0.46291205286979675, 'h': 0.31740766763687134}, 'bHasBoxVertices': 1, 'bbox_vertices': [{'x': 0.26884639263153076, 'y': 0.38855984807014465}, {'x': 0.7055302858352661, 'y': 0.4226400554180145}, {'x': 0.6729471683502197, 'y': 0.6891617774963379}, {'x': 0.24066202342510223, 'y': 0.658175528049469}], 'nLandmark': 4, 'landmark': [{'x': 0.24066202342510223, 'y': 0.658175528049469}, {'x': 0.6729471683502197, 'y': 0.6891617774963379}, {'x': 0.7055302858352661, 'y': 0.4226400554180145}, {'x': 0.26884639263153076, 'y': 0.38855984807014465}]}##人脸识别importtimefromaximportpipelinepipeline.load(['libsample_vin_ivps_joint_vo_sipy.so',' p','/home/config/yolov5s_face_recognition.json',' c','2',])whilepipeline.work():time.sleep(0.001)tmp pipeline.result()iftmpandtmp['nObjSize']:foriintmp['mObjects']:print(i)#iftmp['nObjSize']>10:#tryexit#pipeline.drop(){'label': 0, 'prob': 0.5212324261665344, 'objname': b'unknown', 'bbox': {'x': 0.6881264448165894, 'y': 0.5129707455635071, 'w': 0.05985317379236221, 'h': 0.12323958426713943}, 'bHasBoxVertices': 1, 'bbox_vertices': [{'x': 0.0, 'y': 0.0}, {'x': 0.0, 'y': 0.0}, {'x': 0.0, 'y': 0.0}, {'x': 0.0, 'y': 0.0}], 'nLandmark': 5, 'landmark': [{'x': 0.7027329802513123, 'y': 0.5531390309333801}, {'x': 0.7250422835350037, 'y': 0.5570502281188965}, {'x': 0.7070087194442749, 'y': 0.57811439037323}, {'x': 0.7003915905952454, 'y': 0.6006622314453125}, {'x': 0.7167162299156189, 'y': 0.6037786602973938}]}##ax_bvc_det人车非机动车检测importtimefromaximportpipelinepipeline.load(['libsample_vin_ivps_joint_vo_sipy.so',' p','/home/config/ax_bvc_det.json',' c','2',])whilepipeline.work():time.sleep(0.001)tmp pipeline.result()iftmpandtmp['nObjSize']:foriintmp['mObjects']:x,y,w,h i['bbox']['x'],i['bbox']['y'],i['bbox']['w'],i['bbox']['h']objname,objprob i['objname'],i['prob']print(objname,objprob,x,y,w,h)#iftmp['nObjSize']>10:#tryexit#pipeline.drop()b'vehicle' 0.9299032092094421 0.3565574288368225 0.44399410486221313 0.23071418702602386 0.2580929398536682 b'vehicle' 0.9225113391876221 0.357175350189209 0.44230249524116516 0.23054184019565582 0.2606807053089142 b'vehicle' 0.9186123609542847 0.3581112325191498 0.44336238503456116 0.22992925345897675 0.26163965463638306 b'vehicle' 0.5208129286766052 0.3618425130844116 0.4461480975151062 0.23065532743930817 0.2652992308139801 b'vehicle' 0.7194858193397522 0.3608142137527466 0.45302334427833557 0.23270295560359955 0.2703518867492676 b'vehicle' 0.8540934324264526 0.3617907166481018 0.4548843204975128 0.23152287304401398 0.27814221382141113 b'vehicle' 0.7356315851211548 0.31006965041160583 0.45962005853652954 0.23436705768108368 0.26961490511894226##crowdcount人流量检测importtimefromaximportpipelinepipeline.load(['libsample_vin_ivps_joint_vo_sipy.so',' p','',' c','2',])whilepipeline.work():time.sleep(0.001)tmp pipeline.result()iftmpandtmp['nObjSize']:foriintmp['mObjects']:print(i)#iftmp['nObjSize']>10:#tryexit#pipeline.drop()##姿态关键点系列（人体/手/动物）姿态关键点系列包含人体姿态、手势姿态以及动物姿态的检测，出于方便大家的使用都罗列出来了。###ax pose ppl人体姿态检测关键点对应的人体部位如下：0：鼻子、1：左眼、2：右眼、3：左耳、4：右耳、5：左肩、6：右肩、7：左肘、8：右肘、9:左腕、10：右腕、11：左胯、12：右胯、13：左膝、14:右膝、15：左踝、16：右踝importtimefromaximportpipelinepipeline.load(['libsample_vin_ivps_joint_vo_sipy.so',' p','/home/config/ax_pose.json',' c','2',])whilepipeline.work():time.sleep(0.001)tmp pipeline.result()iftmpandtmp['nObjSize']:foriintmp['mObjects']:print(i)#iftmp['nObjSize']>10:#tryexit#pipeline.drop(){'label': 0, 'prob': 0.41659796237945557, 'objname': b'person', 'bbox': {'x': 0.01200273260474205, 'y': 0.0, 'w': 0.9315435290336609, 'h': 0.9421796798706055}, 'bHasBoxVertices': 0, 'bHasLandmark': 17, 'landmark': [{'x': 0.6708333492279053, 'y': 0.23333333432674408}, {'x': 0.6427083611488342, 'y': 0.16851851344108582}, {'x': 0.6520833373069763, 'y': 0.14629629254341125}, {'x': 0.7322916388511658, 'y': 0.5055555701255798}, {'x': 0.7614583373069763, 'y': 0.06481481343507767}, {'x': 0.7541666626930237, 'y': 0.09444444626569748}, {'x': 0.7541666626930237, 'y': 0.1518518477678299}, {'x': 0.7124999761581421, 'y': 0.15925925970077515}, {'x': 0.5041666626930237, 'y': 0.08703703433275223}, {'x': 0.6739583611488342, 'y': 0.07407407462596893}, {'x': 0.690625011920929, 'y': 0.6814814805984497}, {'x': 0.7833333611488342, 'y': 0.25}, {'x': 0.7614583373069763, 'y': 0.25}, {'x': 0.35104167461395264, 'y': 0.6074073910713196}, {'x': 0.3489583432674408, 'y': 0.5777778029441833}, {'x': 0.0572916679084301, 'y': 0.5185185074806213}, {'x': 0.0677083358168602, 'y': 0.5185185074806213}]}###HandPose手势姿态检测importtimefromaximportpipelinepipeline.load(['libsample_vin_ivps_joint_vo_sipy.so',' p','/home/config/hand_pose.json',' c','2',])whilepipeline.work():time.sleep(0.001)tmp pipeline.result()iftmpandtmp['nObjSize']:foriintmp['mObjects']:x,y,w,h i['bbox']['x'],i['bbox']['y'],i['bbox']['w'],i['bbox']['h']objname,objprob i['objname'],i['prob']print(objname,objprob,x,y,w,h)#iftmp['nObjSize']>10:#tryexit#pipeline.drop(){'label': 0, 'prob': 0.948456346988678, 'objname': b'hand', 'bbox': {'x': 0.26589435338974, 'y': 0.26926565170288086, 'w': 0.46994149684906006, 'h': 0.4706382751464844}, 'bHasBoxVertices': 1, 'bbox_vertices': [{'x': 1.4048067331314087, 'y': 0.42393070459365845}, {'x': 1.2827746868133545, 'y': 1.74061918258667}, {'x': 0.06521528959274292, 'y': 1.5236728191375732}, {'x': 0.18724757432937622, 'y': 0.6408770084381104}], 'bHasLandmark': 21, 'landmark': [{'x': 0.3895833194255829, 'y': 0.6722221970558167}, {'x': 0.4635416567325592, 'y': 0.5925925970077515}, {'x': 0.5979166626930237, 'y': 0.4888888895511627}, {'x': 0.6979166865348816, 'y': 0.4148148000240326}, {'x': 0.7562500238418579, 'y': 0.442592591047287}, {'x': 0.7541666626930237, 'y': 0.5388888716697693}, {'x': 0.8166666626930237, 'y': 0.4314814805984497}, {'x': 0.7927083373069763, 'y': 0.3314814865589142}, {'x': 0.768750011920929, 'y': 0.25925925374031067}, {'x': 0.746874988079071, 'y': 0.5981481671333313}, {'x': 0.778124988079071, 'y': 0.43703705072402954}, {'x': 0.7260416746139526, 'y': 0.3203703761100769}, {'x': 0.706250011920929, 'y': 0.27222222089767456}, {'x': 0.703125, 'y': 0.6499999761581421}, {'x': 0.7291666865348816, 'y': 0.4611110985279083}, {'x': 0.6666666865348816, 'y': 0.3722222149372101}, {'x': 0.628125011920929, 'y': 0.3351851999759674}, {'x': 0.6416666507720947, 'y': 0.6981481313705444}, {'x': 0.6864583492279053, 'y': 0.5814814567565918}, {'x': 0.6625000238418579, 'y': 0.5092592835426331}, {'x': 0.6447916626930237, 'y': 0.4592592716217041}]}###animal pose动物姿态检测importtimefromaximportpipelinepipeline.load(['libsample_vin_ivps_joint_vo_sipy.so',' p','/home/config/hrnet_animal_pose.json',' c','2',])whilepipeline.work():time.sleep(0.001)tmp pipeline.result()iftmpandtmp['nObjSize']:foriintmp['mObjects']:x,y,w,h i['bbox']['x'],i['bbox']['y'],i['bbox']['w'],i['bbox']['h']objname,objprob i['objname'],i['prob']print(objname,objprob,x,y,w,h)#iftmp['nObjSize']>10:#tryexit#pipeline.drop()b'cat' 0.4067786633968353 0.5895833373069763 0.0833333358168602 0.25 0.5703703761100769 b'cat' 0.47085827589035034 0.5666666626930237 0.09444444626569748 0.2708333432674408 0.5740740895271301 b'cat' 0.5028171539306641 0.5239583253860474 0.09814814478158951 0.32083332538604736 0.5888888835906982 b'cat' 0.4983457326889038 0.5302083492279053 0.1111111119389534 0.31041666865348816 0.5777778029441833 b'dog' 0.807929515838623 0.0833333358168602 0.1259259283542633 0.26875001192092896 0.5370370149612427 b'dog' 0.6479188799858093 0.15729166567325592 0.8425925970077515 0.12291666865348816 0.1518518477678299##PillowYolov5s目标检测importtimefromaximportpipelinefromPILimportImage,ImageDraw#readysipeedlogocanvaslcd_width,lcd_height 854,480img Image.new('RGBA',(lcd_width,lcd_height),(255,0,0,200))ui ImageDraw.ImageDraw(img)ui.rectangle((20,20,lcd_width 20,lcd_height 20),fill (0,0,0,0),outline (0,0,255,100),width 20)logo Image.open(\"/home/res/logo.png\")img.paste(logo,box (lcd_width logo.size[0],lcd_height logo.size[1]),mask None)defrgba2argb(rgba):r,g,b,a rgba.split()returnImage.merge(\"RGBA\",(a,b,g,r))canvas_argb rgba2argb(img)pipeline.load(['libsample_vin_ivps_joint_vo_sipy.so',' p','/home/config/yolov5s.json',#' p','/home/config/yolov8.json',' c','2',])whilepipeline.work():time.sleep(0.001)argb canvas_argb.copy()tmp pipeline.result()iftmpandtmp['nObjSize']:ui ImageDraw.ImageDraw(argb)foriintmp['mObjects']:x i['bbox']['x']*lcd_widthy i['bbox']['y']*lcd_heightw i['bbox']['w']*lcd_widthh i['bbox']['h']*lcd_heightobjlabel i['label']objprob i['prob']ui.rectangle((x,y,x+w,y+h),fill (100,0,0,255),outline (255,0,0,255))ui.text((x,y),str(objlabel))ui.text((x,y+20),str(objprob))pipeline.config(\"display\",(lcd_width,lcd_height,\"ARGB\",argb.tobytes()))print_data 2 False##PillowYolov8目标检测（pybind11）体验完`ctypes`来试试新的API`pybind11`跑Yolov8目标检测吧！新的`pybind11`支持把获取摄像头图像以及推理结果一起显示到屏幕（网页）或者是保存下来，但目前还处于不稳定状态，使用时出现不稳定闪烁或者是报错请重启内核即可。importm3axpi#m3axpi.camera(SysCase 0)#switchos04a10#m3axpi.camera(SysCase 2)#defaultgc4653m3axpi.load(\"/home/config/yolov8.json\")fromPILimportImage,ImageDraw,ImageFontlcd_width,lcd_height,lcd_channel 854,480,4fnt ImageFont.truetype(\"/home/res/sans.ttf\",20)img Image.new('RGBA',(lcd_width,lcd_height),(255,0,0,200))ui ImageDraw.ImageDraw(img)ui.rectangle((20,20,lcd_width 20,lcd_height 20),fill (0,0,0,0),outline (0,0,255,100),width 20)logo Image.open(\"/home/res/logo.png\")img.paste(logo,box (lcd_width logo.size[0],lcd_height logo.size[1]),mask None)whileTrue:rgba img.copy()tmp m3axpi.capture()rgb Image.frombuffer(\"RGB\",(tmp[1],tmp[0]),tmp[3])rgba.paste(rgb,box (0,0),mask None)##camera320x180paste854x480res m3axpi.forward()if'nObjSize'inres:ui ImageDraw.ImageDraw(rgba)ui.text((0,0),\"fps:%02d\"%(res['niFps']),font fnt)forobjinres['mObjects']:x,y,w,h int(obj['bbox'][0]*lcd_width),int(obj['bbox'][1]*lcd_height),int(obj['bbox'][2]*lcd_width),int(obj['bbox'][3]*lcd_height)ui.rectangle((x,y,x+w,y+h),fill (255,0,0,100),outline (255,0,0,255))ui.text((x,y),\"%s:%02d\"%(obj['objname'],obj['prob']*100),font fnt)rgba.paste(logo,box (x+w logo.size[1],y+h logo.size[1]),mask None)m3axpi.display([lcd_height,lcd_width,lcd_channel,rgba.tobytes()])#display(rgba)#显示到网页##调用Pillow进行图像处理并显示>**Pillow（PIL）**是Python常用的图像处理库，而Pillow是PIL支，提供了广泛的文件格式支持，强大的图像处理能力，主要包括图像储存、图像显示、格式转换以及基本的图像处理操作等。**使用以下的例子来说明如何使用PythonPillow:**!lshome/imagesair.jpg carvana02.jpg\t face5.jpg\t mv2seg.png\t selfie.jpg\r aoa 2.jpeg carvana03.jpg\t faces\t\t o2_resize.jpg ssd_car.jpg\r aoa.jpeg carvana04.jpg\t grace_hopper.jpg pineapple.jpg ssd_dog.jpg\r bike.jpg cat.jpg\t\t mobileface01.jpg pose 1.jpeg\t ssd_horse.jpg\r bike2.jpg cityscape.png\t mobileface02.jpg pose 2.jpeg\r cable.jpg dog.jpg\t\t mtcnn_face4.jpg pose 3.jpeg\r carvana01.jpg efficientdet.png mtcnn_face6.jpg pose.jpgfromPILimportImage,ImageDrawpil_im Image.open('home/images/bike2.jpg','r')draw ImageDraw.Draw(pil_im)draw.arc((0,0,400,400),start 0,end 300,fill 'red',width 3)draw.rectangle((20,20,200,100),fill (100,20,60),outline \"#FF0000\",width 3)pil_im.show()#display(pil_im) **关于Pillow更多的使用资料请[点击](https://www.itcodar.com/python/how to show pil image in ipython notebook.html)查看。**##调用Numpy进行数组计算>**NumPy**（NumericalPython）是Python语言的一个扩展程序库，支持大量的维度数组与矩阵运算，此外也是针对数组运算提供大量的数学函数库。**使用以下的例子来说明如何调用Numpy：**importnumpyasnp#int8,int16,int32,int64四种数据类型可以使用字符串'i1','i2','i4','i8'代替dt np.dtype('i4')print(dt)int32 **关于Numpy的更多资料例程请[点击](https://www.runoob.com/numpy/numpy tutorial.html)查看。**##播放音视频 [如何使用Python播放音视频](https://wiki.sipeed.com/soft/maixpy3/zh/usage/Audio/play_mp4.html)##发起Http请求或MQTT通信 [如何发起Http请求或MQTT通信](https://wiki.sipeed.com/soft/maixpy3/zh/usage/net.html)##使用PinPong库控制Microbit>PinPong库是一套控制开源硬件主控板的Python库，基于Firmata协议并兼容MicroPython语法。**使用前请先准备材料并按步骤接线，使用Microusb数据线连接Microbit，然后把另一端接入转接头的USB口，再把转接头的Type c口接入设备的OTG口，使用Type c数据线连接设备的UART口及PC端通电。** 一个Type cUSB转接头 一台Microbit以及Microusb数据线 一台AXera Pi设备以及Type c数据线可直接在`Python3`环境运行下方代码即可连接microbit掌控版并会看到`helloworld`亮灯效果。importtimefrompinpong.boardimportBoard,Pinfrompinpong.extension.microbitimport*Board(\"microbit\",\"/dev/ttyACM0\").begin()display.show(Image.HEART)whileTrue:display.scroll(\"helloworld\")__________________________________________ ____ _ ____ / __ \\(_)___ / __ \\____ ____ ____ _ / /_/ / / __ \\/ /_/ / __ \\/ __ \\/ __ `/ / ____/ / / / / ____/ /_/ / / / / /_/ / /_/ /_/_/ /_/_/ \\____/_/ /_/\\__, / v0.4.9 Designed by DFRobot /____/ __________________________________________ [01] Python3.9.2 Linux 4.19.125 armv7l with glibc2.31 Board: MICROBIT selected > board: MICROBIT serial: /dev/ttyACM0 [10] Opening /dev/ttyACM0 [32] Firmata ID: 2.7 [22] Arduino compatible device found and connected to /dev/ttyACM0 [40] Retrieving analog map... [42] Auto discovery complete. Found 26 Digital Pins and 6 Analog Pins All right. PinPong go... **点击[Microbit传送门](https://pinpong.readthedocs.io/zh_CN/latest/2.pinpong%E7%A4%BA%E4%BE%8B/index1.html)查看更多的相关例程资料。**##使用PinPong库控制ArduinoUNO**使用前请先准备材料按步骤接线，先用Type B数据线连接ArduinoUNO，接着把另一端接入转接头的USB口，再把转接头的Type c口接入设备板载的OTG口，使用Type c数据线连接设备板载的UART口及电脑端进行上电操作。** 一个Type cUSB转接头 一台ArduinoUNO以及Type b数据线 一台AXera Pi设备以及Type c数据线直接在编辑框运行以下代码控制ArduinoUNO板点亮外接的**LED**灯以及板载也会亮起。importtimefrompinpong.boardimportBoard,PinBoard(\"uno\",\"/dev/ttyUSB0\").begin()led Pin(Pin.D13,Pin.OUT)#引脚初始化为电平输出whileTrue:led.value(1)#输出高电平print(\"1\")#终端打印信息time.sleep(1)#等待1秒保持状态led.value(0)#输出低电平print(\"0\")#终端打印信息time.sleep(1)#等待1秒保持状态__________________________________________ ____ _ ____ / __ \\(_)___ / __ \\____ ____ ____ _ / /_/ / / __ \\/ /_/ / __ \\/ __ \\/ __ `/ / ____/ / / / / ____/ /_/ / / / / /_/ / /_/ /_/_/ /_/_/ \\____/_/ /_/\\__, / v0.4.9 Designed by DFRobot /____/ __________________________________________ [01] Python3.9.2 Linux 4.19.125 armv7l with glibc2.31 Board: UNO selected > board: UNO serial: /dev/ttyUSB0 [10] Opening /dev/ttyUSB0 [32] Firmata ID: 2.7 [22] Arduino compatible device found and connected to /dev/ttyUSB0 [40] Retrieving analog map... [42] Auto discovery complete. Found 20 Digital Pins and 6 Analog Pins All right. PinPong go... 1 0 1 0 1 user quit process![uno 3.jpg](attachment:uno 3.jpg) **点击[ArduinoUNO传送门](https://pinpong.readthedocs.io/zh_CN/latest/2.pinpong%E7%A4%BA%E4%BE%8B/index1.html)查看更多的相关例程资料。**"},"/hardware/zh/modules/Gamepad.html":{"title":"Sipeed Gamepad","content":"# Sipeed Gamepad ## 概述 ![](./../../assets/spmod/spmod_amigo_hendle/Gamepad141.jpg) 采用主控芯片： GD32F150G 通信接口：IIC（8P座子或者Grove 4P 2.0mm座子） 板载10个按键（每个按键都连接到独立的GPIO） 板载指示灯 ## 硬件参数 项目 参数 MCU GD32F150G（Arm Cortex M3） 主频 72Mhz 存储 64KB Flash, 8KB SRAM 按键 10个按键（每个按键都连接到独立的GPIO） 下载接口 SWD下载 晶振 24MHz无源晶振 LED 板载1个电源指示灯和2个LED USB接口 板载1个USB TYPE C 母座（连接到MCU的USB） ![](./../../assets/spmod/spmod_amigo_hendle/amigo_handle_5.png) ## 手柄接口 ![](./../../assets/spmod/spmod_amigo_hendle/amigo_handle_3.jpg) ![](./../../assets/spmod/spmod_amigo_hendle/amigo_handle_4.jpg) 引脚序号 引脚名称 类型 引脚说明 1 GND G 模块电源地 2 NC NC 悬空引脚，无功能 3 NC NC 悬空引脚，无功能 4 SDA I/O 模块I2C串行数据引脚 5 3V3 V 模块电源输入正 6 NC NC 悬空引脚，无功能 7 NC NC 悬空引脚，无功能 8 SCL I 模块I2C串行时钟引脚 链接方式 单手柄： ![](./../../assets/spmod/spmod_amigo_hendle/Gamepad.143.jpg) 双手柄： ![等待完善](./../../assets/spmod/spmod_amigo_hendle/amigo_handle_6.png) ## 软件描述 项目 参数 开发环境 Maixpy IDE、 PlatformIO IDE 开发语言 C语言、 python 通讯协议 IIC > GD32F150G源码和例程 [https://github.com/sipeed/GD32F150 I2C Handle](https://github.com/sipeed/GD32F150 I2C Handle) ### 手柄测试 单手手柄输入测试 ```python from machine import I2C import nes, lcd from sound import CubeAudio import sys, time from fpioa_manager import fm from Maix import FPIOA, GPIO # B A SEL START UP DOWN LEFT RIGHT X Y # 1 2 4 8 16 32 64 128 254 253 i2c I2C(I2C.I2C2, freq 400*1000, sda 27, scl 24) lcd.init(freq 15000000) lcd.register(0x36, 0x20 state 0 import time i 0 while True: dev i2c1.scan() print(dev) dev i2c2.scan() print(dev) time.sleep(0.5) try: #i2c.writeto(0x4A, b'0') tmp (i2c1.readfrom(0x4A, 2)) print('{} {}'.format(int(tmp[0]), int(tmp[1]))) except Exception as e: print(e) ``` 双手柄输入测试 ```python from machine import I2C import nes, lcd from sound import CubeAudio import sys, time from fpioa_manager import fm from Maix import FPIOA, GPIO # B A SEL START UP DOWN LEFT RIGHT X Y # 1 2 4 8 16 32 64 128 254 253 i2c I2C(I2C.I2C2, freq 400*1000, sda 27, scl 24) lcd.init(freq 15000000) lcd.register(0x36, 0x20 state 0 import time i 0 while True: dev i2c1.scan() print(dev) dev i2c2.scan() print(dev) time.sleep(0.5) try: #i2c.writeto(0x4A, b'0') tmp (i2c1.readfrom(0x4A, 2)) print('{} {}'.format(int(tmp[0]), int(tmp[1]))) except Exception as e: print(e) try: #i2c.writeto(0x42, b'0') tmp (i2c2.readfrom(0x42, 2)) print('{} {}'.format(int(tmp[0]), int(tmp[1]))) except Exception as e: print(e) ``` 测试代码输出 ```python 0 252 #没有输出 1 252 #按下 B 键 2 252 #按下 A 键 4 252 #按下 SEL 键 8 252 #按下 START 键 16 252 #按下 UP 键 32 252 #按下 DOWN 键 64 252 #按下 LEFT 键 128 252 #按下 RIGHT 键 0 254 #按下 X 键 0 253 #按下 Y 键 ``` ### 游戏测试 [MaixPy NES](/soft/maixpy/zh/api_reference/media/nes.md) ## 资料下载 [Gamepad](https://dl.sipeed.com/shareURL/MAIX/HDK/Sipeed Gamepad)"},"/hardware/zh/modules/micarray.html":{"title":"MicArray 麦克风阵列","content":"# MicArray 麦克风阵列 ## 产品介绍 <img src \"./../../assets/spmod/spmod_micarray/spmod_micarray.png\" width 55%> 麦克风阵列模块是 Sipeed 基于 MSM261S4030H0 数字麦克风芯片设计的，模块声音识别灵敏度、信噪比高，由沿板的六个麦克风和一个中心的麦克风组成，阵列板上的 12 颗 LED 可以用来可视化识别声源方位，基于 `GCC PHAT` 算法实现声源定位、语音识别、波束成形等需求场合。 >购买链接： > [淘宝](https://item.taobao.com/item.htm?id 591820993474) > [Aliexpress](https://www.aliexpress.com/item/1005002687541143.html) ## 相关参数资料 ### 数据手册 [点我下载 MSM261S4030H0 数据手册](https://dl.sipeed.com/fileList/MAIX/HDK/Chip_DS/%E9%BA%A6%E5%85%8B_MSM261S4030H0(%E4%BD%BF%E7%94%A8%E7%9A%84).pdf) [点我下载 SK9822 数据手册](https://dl.sipeed.com/fileList/MAIX/HDK/Chip_DS/sk9822_micarray_led.PDF) ### 硬件资料 [点我前往硬件资料合集](https://dl.sipeed.com/shareURL/MAIX/HDK/Sipeed R6+1_MicArray) [点我下载产品规格书](https://dl.sipeed.com/fileList/MAIX/HDK/Sipeed R6+1_MicArray/Specifications/Sipeed%20R6+1%20%E9%BA%A6%E5%85%8B%E9%A3%8E%E9%98%B5%E5%88%97%20%E8%A7%84%E6%A0%BC%E4%B9%A6%20V1.0.pdf) [点我下载产品原理图](https://dl.sipeed.com/fileList/MAIX/HDK/Sipeed R6+1_MicArray/Sipeed R6+1_MicArray_11.16/Sipeed R6+1_MicArray_11.16(Schematic).pdf) [点我下载点位图](https://dl.sipeed.com/fileList/MAIX/HDK/Sipeed R6+1_MicArray/Sipeed R6+1_MicArray_11.16/Sipeed R6+1_MicArray_11.16(Assembly%20drawing).pdf) ### 相关参数 功能特点 参数 声压级 140 dB SPL 灵敏度 26(dB,dBFS @1kHz 1Pa) 信噪比 57 dB (20kHz bandwidth,A weighted) <br>THD<1% (100dB SPL @1kHz S Nom,Rload>2k ) 时钟频率 1.0 4.0Mhz(正常模式) <br>150 800khz(低功耗模式) MEMS 麦克风 7 个 MSM261S4030H0 组成阵列 连接器 支持 2*5P 2.54mm 端子和 10P 0.5mm FPC 连接器 灯光 12 个 SK9822 LED 组成一个环形 LED 阵列 多个 LED 通过双信号线级联 / 8 Bit（256 级）可调颜色 / 5 Bit（32 级）亮度调节 尺寸 78.1*88.8mm ## 使用方法 在进行上手使用麦克风阵列前，我们需要先完成一些准备工作。 ### 准备工作 **烧录固件** 前往 [下载站](https://dl.sipeed.com/shareURL/MAIX/MaixPy/release/master) 下载固件，下载 [固件说明](https://wiki.sipeed.com/soft/maixpy/zh/get_started/upgrade_maixpy_firmware.html#%E5%9B%BA%E4%BB%B6%E5%91%BD%E5%90%8D%E8%AF%B4%E6%98%8E) 里面的默认固件即可使用。 **掌握 K210 系列开发板的基础使用（使用开发板为前提）** 前往 [K210 上手（避坑）指南](https://wiki.sipeed.com/news/MaixPy/K210_usage.html) 学习相关基础使用，下一步操作开始默认会运行代码会使用开发板。 ### 模块引脚定义 因麦克风阵列需与开发板进行搭配才能使用，连接方式有两种（**2.54mm 杜邦线及 10P 0.5mm FPC 排线**） 如适配板卡上无 FPC 排线接口需使用杜邦线进行连接，需使用下列引脚的定义信息。 引脚序号 引脚名称 类型 引脚说明 1 VIN VCC 模块电源输入正 2 GND GND 模块电源地 3 MIC_D0 I/O 0 号麦克风和1号麦克风的 I²S 接口的串行数据输出 4 MIC_D1 I/O 2 号麦克风和3号麦克风的 I²S 接口的串行数据输出 5 MIC_D2 I/O 4 号麦克风和5号麦克风的 I²S 接口的串行数据输出 6 MIC_D3 I/O 中心麦克风的 I²S 接口的串行数据输出 7 MIC_WS I/O I²S 接口的串行数据字选择 8 MIC_CK I/O I²S 接口的串行数据时钟 9 LED_CK I/O LED 的串行数据时钟 10 LED_DA I/O LED 的的串行数据输出 <img src \"./../../assets/spmod/spmod_micarray/MicArray.png\" width 55%> ### 接线参考 >文档以杜邦线接法为示例，接线前参照自己所用板卡原理图，确定自己选择的引脚没有被其他外设使用。 >**（比如不应该与 LCD 引脚或者摄像头的引脚等外设引脚复用）** 麦克风阵列 开发板上的对应管脚 代码中所对应的参数 VIN 3.3v/5v —— GND GND —— LED_CK I/O 口 sk9822_clk LED_DA I/O 口 sk9822_dat MIC_D0 I/O 口 i2s_d0 MIC_D1 I/O 口 i2s_d1 MIC_D2 I/O 口 i2s_d2 MIC_D3 I/O 口 i2s_d3 MIC_WS I/O 口 i2s_ws MIC_CK I/O 口 i2s_sclk **注意**：因为 K210 的 FPIOA 的特性, 支持每个外设随意映射到任意引脚；所以将上面的表格中的 `I/O 口` 与（自行使用）开发板上带有数字标识的引脚连起来即可，类似于标有 GND 这种特殊标识（参考板子原理图）的就不算所谓的数字标识引脚，连接完后可以查看（例程代码下方）关于代码中引脚的说明。 ### Micropython 代码 > 以下是声源定位实现的代码，运行即可在开发板上体验声源定位的效果。 ```python from Maix import MIC_ARRAY as mic import lcd lcd.init() mic.init()#默认配置 #mic.init(i2s_d0 23, i2s_d1 22, i2s_d2 21, i2s_d3 20, i2s_ws 19, i2s_sclk 18, sk9822_dat 24, sk9822_clk 25)#可自定义配置 IO while True: imga mic.get_map() # 获取声音源分布图像 b mic.get_dir(imga) # 计算、获取声源方向 a mic.set_led(b,(0,0,255))# 配置 RGB LED 颜色值 imgb imga.resize(160,160) imgc imgb.to_rainbow(1) # 将图像转换为彩虹图像 a lcd.display(imgc) mic.deinit() ``` **注意**：请自行根据自己的连接的引脚号，对应着修改 `mic.init(i2s_d0 23, i2s_d1 22, i2s_d2 21, i2s_d3 20, i2s_ws 19, i2s_sclk 18, sk9822_dat 24, sk9822_clk 25)` 里面的参数（**示例：将麦克风阵列上的 `MIC_D0` 与 K210 板子上标号为 25 的引脚相连，那么代码中的相关参数需要修改为 `i2s_d0 25`**）其他引脚同理修改，因用户自行配置的不同无固定杜邦线连接说明，个人自行修改引脚参数，并且不要忘记删掉 `mic.init(...)` 前面的注释（删掉`#`就行）。 ### C 语言代码 #### SK9822 驱动代码 仅供参考用，来源：[github](https://github.com/sipeed/MaixPy v1blob/master/components/kendryte_sdk/src/sipeed_sk9822.c) ;需要分析代码的话建议复制代码到电脑本地编辑器中查看。 <details> <summary>sipeed_sk9822.c</summary> <pre class \"language none line numbers language c\"><code class \"language c\">#include \"sipeed_sk9822.h\" #define LED_NUM 12 #define SK9822_DAT_SET() \\ { \\ gpiohs >output_val.bits.b27 1; \\ } #define SK9822_DAT_CLR() \\ { \\ gpiohs >output_val.bits.b27 0; \\ } #define SK9822_CLK_SET() \\ { \\ gpiohs >output_val.bits.b28 1; \\ } #define SK9822_CLK_CLR() \\ { \\ gpiohs >output_val.bits.b28 0; \\ } static void sk9822_init(void) { gpiohs_set_drive_mode(SK9822_DAT_GPIONUM, GPIO_DM_OUTPUT); gpiohs_set_drive_mode(SK9822_CLK_GPIONUM, GPIO_DM_OUTPUT); gpiohs_set_pin(SK9822_DAT_GPIONUM, 0); gpiohs_set_pin(SK9822_CLK_GPIONUM, 0); } void sk9822_send_data(uint32_t data) { for (uint32_t mask 0x80000000; mask > 0; mask >> 1) { SK9822_CLK_CLR(); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); // usleep(1); if (data & mask) { SK9822_DAT_SET(); } else { SK9822_DAT_CLR(); } SK9822_CLK_SET(); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); asm volatile(\"nop\"); // usleep(2); } } //32bit 0 void sk9822_start_frame(void) { sk9822_send_data(0); } //32bit 1 void sk9822_stop_frame(void) { sk9822_send_data(0xffffffff); } //1 1 1 1 gray b g r void sk9822_data_one_led(uint8_t gray, uint8_t r, uint8_t g, uint8_t b) { uint32_t tosend; gray & 0x1f; //for make sure no error data in tosend ((0xe0 gray) << 24) (b << 16) (g << 8) r; sk9822_send_data(tosend); } uint32_t sk9822_gen_data_one_led(uint8_t gray, uint8_t r, uint8_t g, uint8_t b) { uint32_t tosend; gray & 0x1f; //for make sure no error data in tosend ((0xe0 gray) << 24) (b << 16) (g << 8) r; return tosend; } //first color1, then msleep interval, then color2, last msleep interval void sk9822_flash(uint32_t color1, uint32_t color2, uint32_t interval) { uint8_t index; color1 0xe0000000; color2 0xe0000000; sk9822_start_frame(); for (index 0; index < LED_NUM; index++) { sk9822_send_data(color1); } sk9822_stop_frame(); msleep(interval); sk9822_start_frame(); for (index 0; index < LED_NUM; index++) { sk9822_send_data(color2); } sk9822_stop_frame(); msleep(interval); } static void arraymove(uint32_t array[], uint8_t len) { uint8_t index; uint32_t tmp; tmp array[0]; for (index 0; index < len 1; index++) { array[index] array[index + 1]; } array[len 1] tmp; } //呼吸 //跑马灯 //方位 void sk9822_horse_race(uint8_t r, uint8_t g, uint8_t b, uint32_t interval, uint8_t times) { uint32_t led_frame[LED_NUM] {0}; uint8_t i, index; for (index 0; index < 12; index++) { led_frame[index] 0xff000000; } for (index 0; index < 6; index++) { // led_frame[index] sk9822_gen_data_one_led((0xe0(index*4)),r 40*index,g 30*index,b 20*index); led_frame[index] sk9822_gen_data_one_led((0xe0 (32 index * 4)), r, g, b); } for (index 0; index < times; index++) { while (1) { sk9822_start_frame(); for (i 0; i < 12; i++) { sk9822_send_data(led_frame[i]); } sk9822_stop_frame(); arraymove(led_frame, LED_NUM); msleep(interval); } } } void sk9822_breath(uint8_t r, uint8_t g, uint8_t b, uint32_t interval) { uint8_t index, cnt, dir; uint32_t color sk9822_gen_data_one_led(0xff, r, g, b); cnt 0; dir 1; while (1) { if (cnt > 30) { dir !dir; cnt 0; } cnt++; color sk9822_gen_data_one_led((0xe0 (dir ? cnt : 31 cnt)), r, g, b); sk9822_start_frame(); for (index 0; index < LED_NUM; index++) { sk9822_send_data(color); } sk9822_stop_frame(); msleep(interval); } } void sipeed_init_mic_array_led(void) { sk9822_init(); //flash 3 times sk9822_flash(0xffeec900, 0xffff0000, 200); sk9822_flash(0xffeec900, 0xff00ff00, 200); sk9822_flash(0xffeec900, 0xff0000ff, 200); } // void sipeed_calc_voice_strength(uint8_t voice_data[]) // { // uint32_t tmp_sum[12] {0}; // uint32_t led_color[12]; // uint8_t i, index, tmp; // for (index 0; index < 12; index++) // { // tmp_sum[index] 0; // for (i 0; i < voice_strength_len[index]; i++) // { // tmp_sum[index] + voice_data[voice_strength[index][i]]; // } // tmp (uint8_t)tmp_sum[index] / voice_strength_len[index]; // led_brightness[index] tmp > 15 ? 15 : tmp; // } // sk9822_start_frame(); // for (index 0; index < 12; index++) // { // led_color[index] (led_brightness[index] / 2) > 1 ? (((0xe0 (led_brightness[index] * 2)) << 24) 0xcd3333) : 0xe0000000; // sk9822_send_data(led_color[index]); // } // sk9822_stop_frame(); // } </code> </pre> </details> #### Micarray 代码 仅供参考用，来源：[github](https://github.com/sipeed/MaixPy v1blob/master/components/micropython/port/src/Maix/Maix_mic_array.c)；需要分析代码的话建议复制代码到电脑本地编辑器中查看。 ## 更多拓展用法 >这里收集了社区小伙伴们贡献的关于麦克风阵列更多的拓展用法，供大家进行参考实现。 ### 如何获取数据格式 麦克风阵列与 K210 是通过 I2S 协议进行通信的，可通过麦克风的通信协议手册查询接收的数据格式。 ### 如何获取声音的强度及角度 [点灯鼠教程](https://bbs.sipeed.com/thread/68) [Github 原文教程](https://github.com/USTHzhanglu/Maixpy/tree/master/code/script/mic) ### 声源定位 [K210——声源定位、声音识别](https://qichenxi.blog.csdn.net/article/details/126022738?spm 1001.2101.3001.6661.1&utm_medium distribute.pc_relevant_t0.none task blog 2%7Edefault%7ECTRLIST%7ERate 1 126022738 blog 129727127.235%5Ev33%5Epc_relevant_default_base3&depth_1 utm_source distribute.pc_relevant_t0.none task blog 2%7Edefault%7ECTRLIST%7ERate 1 126022738 blog 129727127.235%5Ev33%5Epc_relevant_default_base3&utm_relevant_index 1) [2022 年电赛 E 题声源定位跟踪系统](https://blog.csdn.net/qq_53357019/article/details/126982978) ## 常见问题 ### 出现报错信息 ![报错信息](./../../assets/spmod/spmod_micarray/spmod_micarray_err.png) 更换其他IO管脚即可"},"/hardware/zh/modules/micarray_usbboard_bl616.html":{"title":"麦克风阵列 UAC 驱动板 MA-USB8（使用指南）","content":"# 麦克风阵列 UAC 驱动板 MA USB8（使用指南） ## 产品概览 ![](../../assets/modules/micarray_usbboard_bl616/product front.png) MA USB8 是一块为麦克风阵列提供 USB 音频与串口数据接口的驱动板，主要用于把麦克风阵列采集到的音频（通过 UAC2.0 8通道）和声场成像/声源定位热力图（通过 CDC ACM / UART 帧）输出到上位机或 MCU。常见应用场景有语音采集/降噪/波束指向与声场可视化等。 UAC2.0（USB Audio Class）: 8 通道，PCM s16_le，48 kHz CDC ACM（USB 虚拟串口）: 16×16 原始格式声场热力图（Hotmap Frame）串行输出 UART: 通过 UART (2,000,000 bps) 输出 16×16 原始/HEX+彩色格式声场热力图（适合 MCU 场景） > 本文是 MA USB8 的使用指南，覆盖从接线、验证设备、音频录制、波束成形到如何读取/解析声场热力图与常见故障排查。 ## 快速上手 ### 硬件接线与基础准备 1. 准备 5V/USB2.0 数据线。 2. 将 MA USB8 通过 USB 连接 PC（或杜邦线连接到 MCU 主板）。 3. 选择一种模式： 首选：USB（UAC2.0 音频 + CDC ACM 串口）—— 在 PC 上同时获取多通道音频与声场帧。 备用：UART / USB2TTL（2,000,000 bit baudrate）—— 在 MCU/嵌入式场景下只获取（HEX/伪彩）声场帧。 建议在 PC 主机上安装 [Audacity](https://www.audacityteam.org/download/) 常用音频处理软件。 继续前请检查： 确认 USB 数据线连接牢靠、设备上电（LED 是否闪烁），并使用 PC 的设备管理/终端确认出现 `/dev/ttyACM0` 或 Windows 下出现 `MA USB8` 设备。 如果在 Windows 下使用 [Audacity](https://www.audacityteam.org/download/) 录音，请先打开设备管理或 [Audacity](https://www.audacityteam.org/download/) 的设置确认 MA USB8 可见。 ### 验证设备（Linux） 插入设备后运行： 查 USB 复合设备： dmesg tail # 看到 /dev/ttyACM0 和 `SipeedUSB MicArray`。 lsusb # 查看设备 id，便于 udev 规则或故障排查 音频设备： arecord l # 列出可用录音设备（应该看到 8 通道 UAC 设备） pactl list short sources # Pulseaudio 环境下查看来源 ![](../../assets/modules/micarray_usbboard_bl616/dmesg.png) ![](../../assets/modules/micarray_usbboard_bl616/lsusb.png) ### 验证设备（Windows） 在设备管理器中可看到：音频接口 MicArray (UAC2.0) 和虚拟串口 USB串行设备 (CDC ACM)；如需 8 通道录制，请在录音软件（如 Audacity）中选择正确设备并设置为 8 通道采样。详细可见下节介绍。 ![](../../assets/modules/micarray_usbboard_bl616/devmgmt.png) ### 录音：录制 8 通道音频（UAC2.0） 下面给出 Linux CLI 与 Audacity 的常见步骤。 #### Linux（命令行，arecord 示例） 1. 确认设备 `arecord l`。记下 card:id，例如 hw:1,0。 2. 使用 arecord 录制： ```bash arecord D hw:1,0 f S16_LE c 8 r 48000 t wav d 10 test_8ch.wav ``` 这条命令录制 10s 的 8 通道 WAV（PCM S16_LE，48kHz）。 3. （可选）使用 sox 提取指定通道（如 CH6）进行回放或分析： ```bash sudo apt install sox sox test_8ch.wav ch6.wav remix 7 # sox 的通道编号从 1 开始，7 表示第 7 个通道 (0 based >1 based 转换) aplay ch6.wav ``` > 注意：硬件编号与频道索引关系与系统环境有关，录制或回放时请根据 `arecord l`/`aplay l` 输出确认硬件编号。 #### Audacity（GUI） 1. 打开 Audacity > 编辑 > 首选项 > 设备，选择 MA USB8 采集设备。 2. 在录音通道处选择 8×通道。 3. 开始录制，你会看到多通道波形，停止后可以选择某一路音轨听/导出。 ![](../../assets/modules/micarray_usbboard_bl616/audacity linux sine1k.png) **Windows 需要使用 WASAPI 才会出现 8 声道的选择** <div style \"display: flex; justify content: space between;\"> <img src \"../../assets/modules/micarray_usbboard_bl616/audacity windows wasapi step 1.png\" style \"width: 48%;\"> <img src \"../../assets/modules/micarray_usbboard_bl616/audacity windows wasapi step 2.png\" style \"width: 48%;\"> </div> ## 波束成形（Beamforming）示例 MA USB8 支持 12 方向的波束成形（0..B），每步为 30°。 示例：要把波束指向 CH0（0°）并在输出通道 CH6 获取波束合成后的音频： 1. 打开串口（ttyACM0）： ```bash minicom D /dev/ttyACM0 H ``` 2. 在 minicom 中直接输入 `0`（字符）设置波束为方向 0°。 3. 在音频软件（[Audacity](https://www.audacityteam.org/download/) / arecord）监听或录制 CH6：CH6 会包含指向 CH0 的波束合成音频（例如输入 0 对应角度 0°）。 备注：输入 0..9, A, B 分别对应 0°,30°,…,330° 的 12 个方向；默认值 0。 ![](../../assets/modules/micarray_usbboard_bl616/sine500hz@ch0_and_sine1000hz@ch3_with_beamforming@ch0.png) ## 读取并解析声场热力图（CDC ACM / UART） 驱动板通过 CDC ACM（/dev/ttyACM0）或 UART（2,000,000 bps）发送热力图帧。帧格式上方已给出。下面给出串口读取/解析的示例： ### 通过 minicom / picocom 观察（快速） CDC ACM Raw（minicom）: `minicom D /dev/ttyACM0 H`（` H` 使显示十六进制/无回显，视 minicom 版本而定） UART（picocom）: `picocom b 2000000 /dev/ttyUSB0` （仅物理串口 UART 支持 十六进制/颜色映射视图） 按 `F` 切换为十六进制视图 (HEX)，然后按下 `C` （大写）切换为十六进制+颜色映射视图 (HEX CMAP)。 ![](../../assets/modules/micarray_usbboard_bl616/minicom_acm&picocom_uart combine.png) <div style \"display: flex; justify content: space between;\"> <img src \"../../assets/modules/micarray_usbboard_bl616/picocom_uart hex.png\" style \"width: 45%;\"> <img src \"../../assets/modules/micarray_usbboard_bl616/picocom_uart hex cmap.png\" style \"width: 45%;\"> </div> （开发者参考：hexdump 检查方法与数据格式说明请参见本文末的 “开发者参考” 部分。） ### MCU 解析串口数据帧 如果要在 MCU 端解析这个帧，原则相同：丢弃 16 字节头并把后 256 字节按行/列解析。 ## 常用串口命令 (用户速查) 下面摘录最常用且对普通用户最有用的串口命令，便于现场调试： 设置波束方向（0..9, A, B）：向串口直接输入字符（例如 `0`、`3`、`A`）来设置波束方向。 打开/关闭 LED 指示灯：输入 `e` / `E` （小写关，大写开）。 切换 UART 热力图打印：输入 `f` / `F`（切换 16×16 ASCII 打印）。 更多详细指令及行为参见本文末的“开发者参考”中的完整指令表。 ### 示例：设置并验证波束方向 1. 在串口中输入 `3`（示例）设置方向为 90°（3×30 90）。 2. 在 Audacity 中监听 CH6：你应该在 CH6 听到来自目标方向的声音被增强，或在系统中录制 CH6 再回放分析。 ## 常见问题与故障排查 Windows 上如果仅能看到 2 通道，可能是 Windows USB 音频驱动/软件对 USB 多通道的限制；需要使用 `WASAPI`。 Linux 权限问题：无法访问 `/dev/ttyACM0` 或 `/dev/ttyUSB0` 可通过添加 udev 规则或将当前用户加入 `plugdev` 组来解决： `sudo usermod a G plugdev $USER` 然后重新登录。 创建 udev 规则（示例，替换 vendor/product id）： ```bash # /etc/udev/rules.d/99 ma usb8.rules SUBSYSTEM \"tty\", ATTRS{idVendor} \"359F\", MODE \"0666\", GROUP \"plugdev\" ``` CDC ACM/ttyACM0 不输出热力图：请确认设备同时处于 CDC ACM/UAC 模式（并不是只用作 UAC 音频），尝试断开其他使用该串口的软件后再打开。 UART 串口乱码或无法显示：请确认波特率为 `2000000 bps`，且使用 `picocom b 2000000`、`minicom b 2000000` 等工具；在 Windows 下需要安装正确的 USB 串口驱动（CH340/CH341/CH552 等）。 ## 固件升级 下载 [固件](../../assets/modules/micarray_usbboard_bl616/firmware/MA USB8 251201.bin) 并参考 [固件刷写教程](../logic_analyzer/combo8/update_firmware.html#Burn firmware) 进行升级。 ## 开发者参考（协议、代码示例、完整指令表） 以下内容针对需要二次开发或深入调试的用户；普通用户可以忽略其中的协议细节。 ![](../../assets/modules/micarray_usbboard_bl616/picocom_uart raw errcode.png) ### Hotmap Frame 格式（开发者视角） frame bytes value head 16 16 × 0xFF data 16 × 16 每点 1 字节 (0 255)，按行优先 (HxW) 说明：总长度为 16 + 256 272 字节；head 用于对齐与帧头检测，payload 为 256 字节，每个字节表示该网格点的强度（0 最小，255 最大）。 ![](../../assets/modules/micarray_usbboard_bl616/minicom_acm raw.png) ![](../../assets/modules/micarray_usbboard_bl616/minicom_uart raw.png) ### 完整指令表（开发者） 指令 输入(小/大写: 关/开) 默认值 作用 输入源 设置 UAC CH6 波束成型方向角度 0,1,..9,A,B 0 将波束指向以 30° 步进的方向（实际角度 输入 × 30）；CH6 会输出合成后的音频 任意（串口/CDC） 修改声源定位激活阈值(t,T) t, T 650 t: 50, T: +50, 阈值可调范围: 0~2000 任意（串口/CDC） UART 声源定位图伪彩映射开关 (c/C) c, C c 打开/关闭热力图伪彩（color map），需要先开启 16×16 打印 仅 UART UART 打印内部调试信息 (d/D) d, D d 启用/禁用调试信息输出 仅 UART LED 指示灯开关 (e/E) e, E E 启用/禁用 LED 实时指示显示 任意 UART 16×16 打印开关 (f/F) f, F f 切换 UART 打印 16×16 声场矩阵 (ASCII) 仅 UART 恢复默认设置 (R) R 恢复驱动板所有默认设置 任意 ### udev 与权限建议 若运行 Linux 且经常使用串口，建议为设备创建 udev 规则来简化权限管理： ```bash # /etc/udev/rules.d/99 ma usb8.rules SUBSYSTEM \"tty\", ATTRS{idVendor} \"XXXX\", ATTRS{idProduct} \"YYYY\", MODE \"0666\", GROUP \"plugdev\" ``` 替换 `XXXX` / `YYYY` 为 `lsusb` 显示的设备 Vendor/Product id。 ### 串口/USB 注意事项 CDC ACM（/dev/ttyACM0）在 Linux 下通常为内核 cdc_acm 驱动映射；若发现与 UAC 音频冲突，请先确认没有其他程序占用端口。 UART/TTY（/dev/ttyUSB0）一般由 USB转串口芯片（CH34x、CH340、CH552）驱动映射。"},"/hardware/zh/modules/debugger_and_uart.html":{"title":"施工中","content":" title: 施工中 Sipeed RV Debugger Lite JTAG /串口调试 Sipeed RV debugger plus JTAG+UART Sipeed USB JTAG/TTL Sipeed 双串口转USB模块"},"/hardware/zh/modules/camera_summary.html":{"title":"施工中","content":" title: 施工中 GC0328 双摄像头模块(GC0328) OV7740 OV2640 OV2640 M12 双摄像头模块(OV2640)"}}