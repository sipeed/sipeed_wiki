{"/soft/maixpy/zh/course/image/image_draw_font/image_draw_font.html":{"title":"如何显示中文","content":" title: 如何显示中文 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy 如何显示中文 MaixPy 支持加载 Unicode 字库，Unicode（ 统一码、万国码、单一码）是计算机科学领域里的一项业界标准。 有如下语种支持： * A 大写拉丁字母\"A\" A * ß 小写拉丁字母\"Sharp S\" ß * þ 小写拉丁字母\"Thorn\" þ （小字库不支持） * Δ 大写希腊字母\"Delta\" Δ * Й 大写斯拉夫字母\"Short I\" Й * ק 希伯来字母\"Qof\" ק * م 阿拉伯字母 \"Meem\" م * ๗ 泰文数字 7 ๗ * ቐ 埃塞俄比亚音节文字\"Qha\" ቐ * あ 日语平假名 \"A\" あ * ア 日语片假名 \"A\" ア * 叶 简体汉字 \"叶\" 叶 * 轉 繁体汉字 \"轉\" 轉 * 엽 韩国音节文字 \" Yeob\" 엽 该功能接口均使用 `image.Image()` 对象完成，MaixPy 固件请使用最新版本 2020年9月2日。 ## 字模接口 使用 draw_font 打印字模字符串，类似 `img.draw_font(10, 20, 8, 8, b'/x20/xFC/xFC/x2C/xAC/x4C/x4D/xA3')`。 ```python import lcd, image lcd.init() img image.Image() tmp b'/x20/xFC/xFC/x2C/xAC/x4C/x4D/xA3' img.draw_font(10, 20, 8, 8, tmp, scale 1, color (255, 255, 255)) lcd.display(img) ``` 范例参考 [image_draw_font.py](https://gitee.com/Sipeed/maixpy_scripts/tree/master/multimedia/gui/image/demo_draw_font/image_draw_font.py) 。 ## 字库接口 请先使用 font_load / font_free 加载或释放字库，这将提升 draw_string 的功能，支持从 `xx.Dzk` 文件 与 Flash 地址加载，这之后后 draw_string 将通过字库打印字符串，目前只支持 `ASCII` / `UTF 8` 编码 。 > 附带字库文件 [0xA00000_font_uincode_16_16_tblr.Dzk](https://gitee.com/Sipeed/maixpy_scripts/tree/master/multimedia/gui/image/demo_draw_font/tools/0xA00000_font_uincode_16_16_tblr.Dzk) ```python import lcd, image lcd.init() img image.Image() # image.font_load(image.UTF8, 16, 16, 0xA00000) image.font_load(image.UTF8, 16, 16, '/sd/0xA00000_font_uincode_16_16_tblr.Dzk') img.draw_string(20, 90, b'こんにちは、世界', x_spacing 2, mono_space 1) image.font_free() lcd.display(img) ``` 范例参考 [image_draw_string.py](https://gitee.com/Sipeed/maixpy_scripts/tree/master/multimedia/gui/image/demo_draw_font/image_draw_string.py) 。 ## 显示效果 ![view_image_font](./view_image_font.jpg) ## 字库工具 我们将使用根目录下的 [FontGenerator.zip](https://gitee.com/Sipeed/maixpy_scripts/tree/master/multimedia/gui/image/demo_draw_font/tools/FontGenerator.zip) 导出字体对应的字库，请看下图完成导出操作。 1. 选择字库编码类型为 Unicode 编码，这将支持绝大多数国家的语言。 ![image 20200902180913322](./image 20200902180913322.png) 2. 选择扫描模式，为 5 横向、先上下后左右的字模的扫描打印方向。 ![image 20200902181130459](./image 20200902181130459.png) 3. 如下图配置所需要的字体样式后创建字库。 ![image 20200902181311553](./image 20200902181311553.png) 4. 保存成 DZK 格式即可，字模数据访问方法如图文字说明 ![image 20200902181442677](./image 20200902181442677.png) ## 字模工具 > 警告：不推荐使用字模工具，不了解的人请不要使用。 使用目录下的 [Pc2Lcd2002.zip](https://gitee.com/Sipeed/maixpy_scripts/tree/master/multimedia/gui/image/demo_draw_font/tools/Pc2Lcd2002.zip) 获取字模的字符串。 1. 确认软件为字符模式。 ![image 20200902175614964](./image 20200902175614964.png) 2. 设置如图即可导出想要的字符串。 ​\t![image 20200902180153452](./image 20200902180153452.png) 3. 填入文字后点击生成字模。 ![image 20200902175948599](./image 20200902175948599.png) 4. 提取字模字符串即可使用。 ![image 20200902180505263](./image 20200902180505263.png) ``` 这(0) 是(1) 测(2) 试(3) /x00/x20/x10/x17/x00/x02/xF1/x10/x10/x10/x11/x12/x14/x28/x47/x00/x80/x40/x40/xFC/x10/x10/x20/xA0/x40/xA0/x10/x08/x08/x00/xFE/x00这0 /x1F/x10/x10/x1F/x10/x10/x1F/x00/xFF/x01/x11/x11/x11/x29/x45/x83/xF0/x10/x10/xF0/x10/x10/xF0/x00/xFE/x00/x00/xF8/x00/x00/x00/xFE是1 /x00/x27/x14/x14/x85/x45/x45/x15/x15/x25/xE5/x21/x22/x22/x24/x08/x04/xC4/x44/x54/x54/x54/x54/x54/x54/x54/x54/x04/x84/x44/x14/x08测2 /x00/x20/x10/x10/x07/x00/xF0/x17/x11/x11/x11/x15/x19/x17/x02/x00/x28/x24/x24/x20/xFE/x20/x20/xE0/x20/x10/x10/x10/xCA/x0A/x06/x02试3 ``` > 可以使用图形模式绘制自己喜欢的字模图形，支持 32 * 32 的图形。 > > ![image 20200902181645277](./image 20200902181645277.png)"},"/soft/maixpy/zh/course/image/basic_operation.html":{"title":"图像的基本运算","content":" title: 图像的基本运算 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy 图像的基本运算 ## 坐标 ### 获取/设置像素点 我们可以通过 image.get_pixel(x, y) 方法来获取一个像素点的值。 image.get_pixel(x, y) 对于灰度图: 返回(x,y)坐标的灰度值. 对于彩色图: 返回(x,y)坐标的(r,g,b)的tuple. 同样，我们可以通过 image.set_pixel(x, y, pixel) 方法，来设置一个像素点的值。 image.set_pixel(x, y, pixel) 对于灰度图: 设置(x,y)坐标的灰度值。 对于彩色图: 设置(x,y)坐标的(r,g,b)的值。 举例： ```python img sensor.snapshot() img.get_pixel(10,10) img.set_pixcel(10,10,(255,0,0))#设置坐标(10,10)的像素点为红色(255,0,0) ``` ### 获取图像的宽度和高度 image.width() 返回图像的宽度(像素) image.height() 返回图像的高度(像素) image.format() 灰度图会返回 sensor.GRAYSCALE，彩色图会返回 sensor.RGB565。 image.size() 返回图像的大小(byte) ### 图像的运算 image.invert() 取反，对于二值化的图像，0(黑)变成1(白)，1(白)变成0(黑)。 注： 图像可以是另一个image对象，或者是从 (bmp/pgm/ppm)文件读入的image对象。 两个图像都必须是相同的尺寸和类型（灰度图/彩色图）。 image.nand(image) 与另一个图片进行与非（NAND）运算。 image.nor(image) 与另一个图片进行或非（NOR）运算。 image.xor(image) 与另一个图片进行异或（XOR）运算。 image.xnor(image) 与另一个图片进行异或非（XNOR）运算。 image.difference(image) 从这张图片减去另一个图片。比如，对于每个通道的每个像素点，取相减绝对值操作。这个函数，经常用来做移动检测。"},"/soft/maixpy/zh/course/image/find_qrcodes.html":{"title":"MaixPy 查找二维码","content":" title: MaixPy 查找二维码 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy MaixPy 查找二维码 从图片中识别二维码，常见的二维码为 QR Code，QR 全称 Quick Response，它比传统的条形码(Bar Code)能存更多的信息，也能表示更多的数据类型. ## 使用方法 image 模块中已经实现有查找二维码方法，需要使用非 minimum 固件版本，需要准备一个二维码，可以用[草料二维码](https://cli.im/)生成你想要的内容. * 从摄像头获取图片，将摄像头对准二维码 ```python import image, sensor img sensor.snapshot() ``` * 从图片中查找所有二维码对象(image.qrcode)列表 ```python res img.find_qrcodes() ``` * 操作二维码对象 例如打印信息 ```python print(res[0].payload()) ``` 详细 API 介绍请查看[API Image](../../api_reference/machine_vision/image/image.html). ## 例程 识别二维码，如果识别不到二维码，请尝试更改 `sensor.vflip()` 函数参数。 ```python import sensor import image import lcd import time clock time.clock() lcd.init() sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.set_vflip(0) sensor.run(1) sensor.skip_frames(30) while True: clock.tick() img sensor.snapshot() res img.find_qrcodes() fps clock.fps() if len(res) > 0: img.draw_string(2, 2, res[0].payload(), color (0,128,0), scale 2) print(res[0].payload()) lcd.display(img) ```"},"/soft/maixpy/zh/course/image/adaptive-histogram-equalization.html":{"title":null,"content":" title: keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy ```python # 自适应直方图均衡例子 # # 此示例展示了如何使用自适应直方图均衡来改善图像中的对比度。 #自适应直方图均衡将图像分割成区域，然后均衡这些区域中的直方图， #以改善图像对比度与全局直方图均衡化。 #此外，您可以指定剪辑限制以防止对比度变得狂野。 import sensor, image, time sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QQVGA) sensor.skip_frames(time 2000) clock time.clock() while(True): clock.tick() # clip_limit <0为您提供正常的自适应直方图均衡，这可能会导致大量的对比噪音... # clip_limit 1 什么都不做。为获得最佳效果，请略高于1，如下所示。 # 越高，越接近标准自适应直方图均衡，并产生巨大的对比度波动。 img sensor.snapshot().histeq(adaptive True, clip_limit 3) print(clock.fps()) ```"},"/soft/maixpy/zh/course/image/sensor.html":{"title":"Sensor 感光元件","content":" title: Sensor 感光元件 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy Sensor 感光元件 sensor模块,用于设置感光元件的参数。 使用例程: 实时预览摄像头 ```python import sensor #引入感光元件的模块 sensor.reset()#初始化感光元件 sensor.set_pixformat(sensor.RGB565)#设置为彩色 sensor.set_framesize(sensor.QVGA)#设置图像的大小 sensor.skip_frames()#跳过n张照片，在更改设置后，跳过一些帧，等待感光元件变稳定。 while(True): img sensor.snapshot()#拍摄一张照片，img为一个image对象 ``` 初始化 ```python sensor.reset()# 初始化感光元件 #设置彩色／黑白 sensor.set_pixformat()# 设置像素模式。 sensor.GRAYSCALE# 灰度，每个像素8bit。 sensor.RGB565# 彩色，每个像素16bit。 ``` 设置图像大小 sensor.QQCIF# 88x72 sensor.QCIF# 176x144 sensor.CIF# 352x288 sensor.QQSIF# 88x60 sensor.QSIF# 176x120 sensor.SIF# 352x240 sensor.QQQQVGA# 40x30 sensor.QQQVGA# 80x60 sensor.QQVGA# 160x120 sensor.QVGA# 320x240 sensor.VGA# 640x480 ```python sensor.set_framesize()# 设置图像的大小 ``` 跳过一些帧 sensor.skip_frames(n 10) 跳过 n 张照片，在更改设置后，跳过一些帧，等待感光元件变稳定。 获取一张图像 sensor.snapshot() 拍摄一张照片，返回一个 image 对象。 自动增益／白平衡／曝光 sensor.set_auto_gain() 自动增益开启(True)或者关闭(False)。 在使用颜色追踪时，需要关闭自动增益。 sensor.set_auto_whitebal() 自动白平衡开启(True)或者关闭(False)。 在使用颜色追踪时，需要关闭自动白平衡。 sensor.set_auto_exposure(enable[\\, exposure_us]) enable 打开(True)或关闭(False)自动曝光。默认打开。 如果 enable 为 False， 则可以用 exposure_us 设置一个固定的曝光时间(以微秒为单位)。 设置窗口 ROI ```python sensor.set_windowing(roi) ``` ROI：Region Of Interest，图像处理中的术语”感兴趣区“。就是在从需要处理的图像中提取出的要处理的区域。 ```python sensor.set_framesize(sensor.VGA) # 高分辨率 sensor.set_windowing((240, 240)) #取中间的 240*240 区域 ``` roi 的格式是(x, y, w, h)。 设置翻转 ```python #水平方向翻转 sensor.set_hmirror(True) # 垂直方向翻转 sensor.set_vflip(True) ```"},"/soft/maixpy/zh/course/image/kernel-filter.html":{"title":"核滤波","content":" title: 核滤波 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy 核滤波 ![image 20200812191240724](kernel filter.assets/image 20200812191240724.png) 例程 ```python # 核滤波 # # 这个例子展示了核滤波。 import sensor, image, time sensor.reset() # 初始化sensor #设置图像色彩格式，有RGB565色彩图和GRAYSCALE灰度图两种 sensor.set_pixformat(sensor.GRAYSCALE) # or sensor.RGB565 #设置图像像素大小 sensor.set_framesize(sensor.QVGA) # or sensor.QQVGA (or others) sensor.skip_frames(time 2000) # 让新的设置生效 clock time.clock() # 跟踪FPS帧率 kernel_size 1 # 3x3 1, 5x5 2, 7x7 3, etc. kernel [ 2, 1, 0, \\ 1, 1, 1, \\ 0, 1, 2] while(True): clock.tick() # 追踪两个 snapshots() 之间经过的毫秒数. img sensor.snapshot() # 拍一张照片，返回图像 # Run the kernel on every pixel of the image. # 在图像的每个像素上运行核 img.morph(kernel_size, kernel) print(clock.fps()) # 注意: 当连接电脑后，帧率会变成一半的速度。当不连接电脑，帧率会增加。 ```"},"/soft/maixpy/zh/course/index.html":{"title":"MaixPy 手把手教程说明","content":" title: MaixPy 手把手教程说明 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy MaixPy 手把手教程说明 看本教程之前， 请**务必先看左侧目录【入门必看指南】** 教程是在认为已经完全掌握了前面的 入门 部分的内容的基础上写的 本教程主要分模块地介绍 MaixPy 包含的功能的使用方法， 在看教程时，可能需要配合 API 文档 和 例程仓库[MaixPy_scripts](https://github.com/sipeed/MaixPy v1_scripts) 一同学习"},"/soft/maixpy/zh/dnn/index.html":{"title":"深度学习及 KPU 基础知识","content":" title: 深度学习及 KPU 基础知识 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy 深度学习及 KPU 基础知识 ## 阅读完本章文档可以了解什么？ 1. 了解深度学习一些基础内容 2. 了解 K210 内部 KPU 的特性 3. 了解 KPU 使用过程中可能会遇到的问题，以及问题的解决方法 ## 概述 在本章中，将会为大家介绍深度学习和 K210 内部 KPU 的一些基础知识，以及大家在这部分容易遇到的问题。深度学习及其所涵盖的应用实例是一个非常庞大的领域，没有人能够用一篇文档就把它说得很清楚。希望这篇文档能够让大家对深度学习有一定的了解，产生超出本文档说明外的问题时，能够通过搜索引擎查询等手段解决问题。 ## 关于深度学习 在介绍深度学习前，我们先来介绍神经网络。 ​\t什么是神经网络呢？是一种模仿动物神经网络行为特征，进行分布式并行信息处理的算法数学模型。 下面，让我们举个简单例子来说明它干了什么。 其实从某种程度来上说，我们在上小学时，就已经开始运用神经网络的相关思想来解决实际问题了。此时的你，可能满脸问号QAQ。不怕，且听我一一道来。现在，假设有一个方程 `y kx + b` 。相信这个方程你一定见过无数次。其实我们可以把这个方程当作神经网络的\"模型\"，未知数\"k\"当作神经网络的权重，\"b\"当作神经网络的偏置。此时我们要训练这个神经网络模型，其实训练的过程，就是在数据集上求解全局最优权重和偏置的过程。此时，假设这个方程满足\"x 1,y 2\",\"x 2,y 4\"。这个满足条件便是上文说到的数据集，通过在人脑中，对这个网络的训练，我们可以得知整个网络的最优权重为2，最优偏置为0。此时，便完成了神经网络的训练。 不过值得提出的是，训练的最终目的，永远都是预测。古往今来，那么多神经网络消耗大量算力资源去寻找合适权重和偏置。都是为了能够寻找一个输入数据与输出数据之间的对应关系。一个优秀的神经网络，它的输入数据应该是随机的，不确定的(没有在数据集中被训练过的)。而输出数据则是准确的，可靠的。回到上文，我们训练了神经网络\"y 2x + 0\"，此时数据集拥有的数据x为\"1\"和\"2\"。此时为了评估模型性能，我们输入非数据集数据\"3\"，此时，通过神经网络前向传播，得到了输出值\"6\"。至此，完成了神经网络模型的预测。 上文用了非常简单的demo来为大家阐述神经网络究竟在干啥，下面让我们一起看看真正的神经网络模型长啥样。 ![全连接神经网络模型](https://i.loli.net/2020/06/30/PVxMcSde8YJ4Q9b.jpg) 上图为大家展示了一个比较常见的全连接神经网络模型(Fully connected neural network)。对比这个网络结构与之前的\"y 2x + 0\"网络，我们可以发现如下不同: 1. 输入数据个数不确定(可以有n个输入) 2. 输出数据个数不确定(可以有n个输出) 3. 参数个数不确定(图中可以有n个全连接层，每个层所包含神经元可以有n个，从而导致参数个数为n) 模型的构造过程可以看作是参数个数的确定过程(当网络层结构确定后，参数个数也确定了)，模型的训练过程可以看作是在数据集上全局最优参数的确定过程。模型的预测过程可以看作是输入数据*参数 预测结果的过程。(*代表进行某种运算) 在对神经网络有了一定的了解后，接下来将会介绍深度学习。大家可以把深度学习当做是一种改良版的神经网络算法。它与其他几个名词之间的关系为:机器学习是人工智能的一个子集，深度学习和神经网络又是机器学习的一个子集。 神经网络和深度学习之间的区别，以及深度学习的优点等内容，由于篇幅有限，不能在此一一介绍，大家感兴趣的话，可以通过搜索引擎进行查询。 ## 关于 KPU K210 SOC 内部搭载一颗 KPU(Neural Network Processor), KPU 即通用的神经网络处理器，它可以在低功耗的情况下实现卷积神经网络计算，时时获取被检测目标的大小、坐标和种类，对人脸或者物体进行检测和分类。 K210 搭载的 KPU 具备以下几个特点： 1. 支持主流训练框架按照特定限制规则训练出来的定点化模型 2. 对网络层数无直接限制，支持每层卷积神经网络参数单独配置，包括输入输出通道数目、输入输 出行宽列高 3. 支持两种卷积内核 1x1 和 3x3 4. 支持任意形式的激活函数 5. 实时工作时最大支持神经网络参数大小为 5.5MiB 到 5.9MiB 6. 非实时工作时最大支持网络参数大小为（Flash 容量 软件体积） KPU 的内部结构如下图所示。 ![K210 KPU结构](https://i.loli.net/2020/06/30/Q9tPOjyMWFiTwxA.png) Maixpy下 KPU 相关 API 及 Demo 可以点击[此处](https://maixpy.sipeed.com/zh/libs/Maix/kpu.html?h kpu)查看。 ## KPU使用过程中的常见问题 ### 1. KPU能够加载多大的模型？ 当k210运行 c 代码时，能够加载 6MB左右的模型。 当运行maixpy(mini)时，能够加载3MB左右的模型。 当运行maixpy(完整版)时，能够加载2MB左右的模型。 ### 2. 什么模型能被KPU加载运行？ 被nncase转换后的kmodel能够被kpu加载运行。 nncase使用说明点击[此处](https://github.com/kendryte/nncase/blob/master/docs/USAGE_ZH.md) nncase tflite ops支持点击[此处](https://github.com/kendryte/nncase/blob/master/docs/tflite_ops.md) nncase 常见问题点击[此处](https://github.com/kendryte/nncase/blob/master/docs/FAQ_ZH.md) ### 3. KPU能通过哪些方式加载模型？ 1. 加载TF卡中的模型 ```python kpu.load(\"/sd/test.kmodel\") ``` 2. 加载Flash中的模型 ```python kpu.load(offset) ``` 此处的offset为模型在flash中的偏移地址，模型可以通过k flash烧入k210内部flash中 ### 4. 报错\"memory overflow\"怎么办？ 出现这个问题，一般是由于模型过大引起的。可以依次尝试如下解决方案: 1. 更换maixpy mini版本固件 2. 进行模型剪枝优化 3. 放弃在maixpy固件下开发，而采用勘智的C SDK进行开发。 ### 5. 报错\"load error,only support kmodel v3/v4\"怎么办？ 出现这个问题可以尝试如下解决方案: 1. 如果为flash中加载模型，请确保flash offset填写正确，并保证和maixpy固件没有冲突。 2. 如果是采用nncase 0.2.0进行转换的kmodel V4，请尝试采用nncase 0.1.0进行转换，从而生成kmodel V3。（截至2020/06/30，maixpy对kmodel v4的加载bug还未修复） ### 6. 我想实现不同模型的选择加载(例如按下按钮运行目标分类，再次按下按钮则运行目标检测)，应该怎么写程序？ 因为flash有限，固建议将所有k210模型放到TF卡内进行加载。因为内部RAM有限，所以当需要切换不同模型进行`kpu.load(k210model)`前，请先执行`kpu.deinit(k210model)`对SRAM中的模型进行释放。否则将会报错\"memory overflow\"。"},"/soft/maixpy/zh/dnn/ml_mnist.html":{"title":"mnist 手写数字识别","content":" title: mnist 手写数字识别 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy mnist 手写数字识别 ```python import sensor,lcd,image import KPU as kpu lcd.init() sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.set_windowing((224, 224)) #set to 224x224 input sensor.set_hmirror(0) #flip camera task kpu.load(0x200000) #load model from flash address 0x200000 sensor.run(1) img_lcd image.Image() while True: img sensor.snapshot() #lcd.display(img,oft (0,0)) #display large picture img1 img.to_grayscale(1) #convert to gray img2 img1.resize(28,28) #resize to mnist input 28x28 a img2.invert() #invert picture as mnist need a img2.strech_char(1) #preprocessing pictures, eliminate dark corner img2x2 img2.resize(28*2,28*2) #scale to display a img_lcd.draw_image(img2x2,0,0)#display small 28x28 picture a img2.pix_to_ai(); #generate data for ai #watch conv0 a kpu.set_layers(task, 1) fmap kpu.forward(task,img2) #run neural network model for i in range(0,16): tmp kpu.fmap(fmap,i) tmpx2 tmp.resize(14*2,14*2) #scale to display a img_lcd.draw_image(tmpx2,(i%8)*14*2,28*2+14*2*int(i/8)) #watch conv1 a kpu.set_layers(task, 2) fmap kpu.forward(task,img2) #run neural network model for i in range(0,32): tmp kpu.fmap(fmap,i) tmpx2 tmp.resize(7*2,7*2) #scale to display a img_lcd.draw_image(tmpx2,(i%16)*7*2,28*2+14*2*2+7*2*int(i/16)) #watch conv2 a kpu.set_layers(task, 8) fmap kpu.forward(task,img2) #run neural network model for i in range(0,10): tmp kpu.fmap(fmap,i) tmpx2 tmp.resize(4*2,4*2) #scale to display a img_lcd.draw_image(tmpx2,i*4*2,28*2+14*2*2+7*2*2) #watch softmax a kpu.set_layers(task, 11) fmap kpu.forward(task,img2) plist fmap[:] for i in range(0,10): cc int(plist[i]*256) a img_lcd.draw_rectangle(i*16, 28*2+14*2*2+7*2*2+4*2+10, 16, 16, color (cc, cc, cc), thickness 1, fill True) a img_lcd.draw_string(i*16+5, 28*2+14*2*2+7*2*2+4*2+10+16, str(i), color (255, 255, 255), scale 2, mono_space False) #show result lcd.display(img_lcd,oft (0,0)) ```"},"/soft/maixpy/zh/share/my_share/index.html":{"title":"MaixPy 经验分享 —— XXX","content":" title: MaixPy 经验分享 —— XXX keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy MaixPy 经验分享 —— XXX 本目录下主要用于大家分享自己的经验，或者教程，也可以在作者允许转载的情况下搬运，并著名出处。 ## 要参与分享，你需要提前掌握的知识 * git 和 github 的使用 * github PR（pull request）的使用 在入门教程里面有简要的介绍， 详细的使用方法请自行学习 如果你没有信心掌握这些技能， 你可以到提交[issue](https://github.com/sipeed/MaixPy_DOC/issues) 来说明问题或者贡献经验等，我们帮助你进行添加 ## 如何添加 ### 克隆文档到本地 ``` git clone https://github.com/sipeed/MaixPy_DOC cd MaixPy_DOC ``` ### 新建目录 需要新建一个目录专门用于写分享的文章， 在`MaixPy_DOC/zh/share/my_share/`目录下建立一个文件夹， 文件夹名只能用小写英文和下划线，可以用你的英文名字命名，比如`tom`或者`lihua`, 以下用`MaixPy_DOC/zh/share/my_share/tom`举例 当然，如果你写的是英文文档，需要放到`MaixPy_DOC/en/share/my_share/tom`文件夹下 在这个文件夹内建立一个文件，命名为`readme.md`, 然后在里面使用`markdown`语法编写分享， 建立`MaixPy_DOC/zh/share/my_share/tom/assets`目录，用来存放图片， 文档里面引用图片使用相对路径，比如放了一张图片路径是`MaixPy_DOC/zh/share/my_share/tom/assets/cover.jpg`，则在`MaixPy_DOC/zh/share/my_share/tom/readme.md`中引用图片使用如下语法 ``` ![封面](./assets/cover.jpg) ``` 注意， 不要往文件夹内放大文件， 图片也不要用太大的，否则会导致文档仓库巨大无比 ### 编写文档 为了文档看起来格式正确，更易于阅读， 编写文档**必须**遵循语法和格式要求： **看 [文档规范](../../contribute/doc_convention.html)** **文档模板**, 按照模板写文章， 可以根据自己的情况修改 ``` 作者 联系方式 个人主页 XXX XXXX@XXX.com [github/sipeed](http://github.com/sipeed) ## 简介： 描述下本次分享的背景，最终实现的效果展示等，可以使用图片或者 GIF 或者视频进行展示，但是不要放太大的图片到`assets`文件夹，不然用户因为网速问题很久都无法加载出来，就失去了意义了 ## 准备: ### 预备知识 ### 需要准备的软硬件环境 #### 硬件 图文描述使用到的开发板， 外设模块等 #### 软件 图文描述使用到的软件工具，MaixPy 版本 如果使用到第三方软件工具，可以附加相关名称或下载链接 ## 过程，具体标题自定义 ## 过程， 具体标题自定义 ## 结果 建议添加图片展示实际运行效果 ## 总结 对本次分享进行总结 ## 问题和反馈 可以提供反馈方式 ## 参考 在这里以列表的方式注明文章中引用的文章和源码 * 引用文章1: https://www.sipeed.com ``` ### 添加这篇分享到文档左边的目录栏 打开`MaixPy_DOC/zh/SUMMARY.md`, 在末尾添加自己的分享，比如 ``` ## 社区 & 分享 [精选教程](./share/recommend_articles.html) [开源项目](./share/open_projects.html) 大家的经验分享 * [参与经验分享/分享模板](./share/my_share/index.html) * [jerry 的模型训练教程](./share/my_share/jerry/index.html) ``` 添加自己的卡后效果是： ``` ## 社区 & 分享 [精选教程](./share/recommend_articles.html) [开源项目](./share/open_projects.html) 大家的经验分享 * [参与经验分享/分享模板](./share/my_share/index.html) * [模型训练教程 jerry](./share/my_share/jerry/index.html) * [如何设计一个自己的模型 tom](./share/my_share/tom/index.html) ``` 注意是**\\***号前面是两个空格，不是`tab` ### 提交 编写完后提交修改，然后在 github 上提交 PR， PR 通过后官方文档页面就会有这篇文章了"},"/soft/maixpy/zh/share/recommend_articles.html":{"title":"MaixPy 精选文章","content":" title: MaixPy 精选文章 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy MaixPy 精选文章 从社区**精选**的文章，收集一些不错的文章到这里，方便大家学习交流。 另外，如果你有经验想要分享，也欢迎参与， 写好文章后，提交 [issue](https://github.com/sipeed/MaixPy_DOC/issues) 请求添加 要求： * 与 MaixPy 相关 * 文章目录层次结构清晰 * 文章逻辑清晰，需要写明分享的简介、效果、操作过程、总结，图文并茂 你也可以按照[参与经验分享/分享模板](../share/my_share/index.html)直接在文档中添加经验分享，如果写得不错，也会被收录到本页面 文章链接全部收录进以下帖子以方便更新： [【精选文章导航】](https://bbs.sipeed.com/thread/492)"},"/soft/maixpy/zh/share/open_projects.html":{"title":"MaixPy 相关开源项目精选","content":" title: MaixPy 相关开源项目精选 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy MaixPy 相关开源项目精选 这里收集了一些比较不错的 MaixPy 相关的开源项目分享，欢迎 star 如果你也有不错的 MaixPy 相关的开源项目， 欢迎提交 [issue](https://github.com/sipeed/MaixPy_DOC/issues) 请求添加， 要求： * 与 MaixPy 相关 * 项目有完整清晰的`README`，包括简介，效果，代码，使用方法等 ## 应用 项目主页 简介 作者 [LZBUAV/K210_Python](https://github.com/LZBUAV/K210_Python) Kendryte K210 AI芯片应用程序的集合，其中包括面部检测，颜色检测，目标检测和分类，QR码和Apriltag码检测以及与ArduPilot飞行软件的通信 [LZBUAV](https://github.com/LZBUAV) [BBS](https://cn.bbs.sipeed.com/d/490 maixpy maixpy explorer aiot) MaixPy + 腾讯云Explorer+小程序 快速打造一个 AIOT应用 [neucrack](https://github.com/neutree) ## 模型训练 项目主页 简介 作者 [sipeed/maix_train](https://github.com/sipeed/maix_train) 分类和检测模型训练项目 [Sipeed](https://github.com/sipeed/maix_train/graphs/contributors) [lemariva/MaixPy_YoloV2](https://github.com/lemariva/MaixPy_YoloV2) 使用 Mobilenet+YOLOv2 在 Sipeed Maix Dock 开发板上进行物体检测, 更多说明看[博客](https://lemariva.com/blog/2020/01/maixpy object detector mobilenet and yolov2 sipeed maix dock) [lemariva](https://github.com/lemariva) [zhen8838/K210_Yolo_framework](https://github.com/zhen8838/K210_Yolo_framework) k210 上的 yolo v3 模型训练框架 [zhen8838](https://github.com/zhen8838) [TonyZ1Min/yolo for k210](https://github.com/TonyZ1Min/yolo for k210) 在 windows 训练 YOLO 物体检测模型 [TonyZ1Min](https://github.com/TonyZ1Min) ## UI & System 项目主页 简介 作者 [eggfly/M5StickVComputer](https://github.com/eggfly/M5StickVComputer) 运行在`M5StickV`上的纯 Python 应用框架 [eggfly](https://github.com/eggfly) "},"/soft/maixpy/zh/firmware/compile.html":{"title":"源码编译","content":" title: 源码编译 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy 源码编译 预编译的固件可能不满足特定的使用场景， 如果需要修改配置，请配置并编译需要的固件 ## 本机环境编译 编译方法请参考 源码下的编译说明 [build.md](https://github.com/sipeed/MaixPy v1/blob/master/build.md) 在 `python project.py menuconfig` 命令部分可以 勾选 或者 去掉 功能和模块 ## 使用 docker 环境编译 docker 可以简化开发环境安装 > 如果你没用过 docker， 关于 docker 的知识请自行学习， > 在没学习过的情况下你可以认为它和虚拟机类似，即已经为你准备好了带编译环境的虚拟机，直接下载运行就可以用来编译源码了 docker 镜像已经打包好了环境，直接拉取镜像并且运行即可开始编译， 参考 [使用 Docker 编译源码](https://github.com/sipeed/MaixPy v1tree/master/tools/docker)"},"/soft/maixpy/zh/firmware/online_compile.html":{"title":"固件在线编译","content":" title: 固件在线编译 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy 固件在线编译 ~在线编译不需要搭建编译环境，只需要选择需要的模块点击编译，编译过程会在云端完成，固件会以邮件的方式发送~ ~~访问 [MaixHub](https://www.maixhub.com/onlinecompiler) 进行固件定制~~ 在线编译不再支持， 需要定制固件请参考[源码编译](./compile.html)"},"/soft/maixpy/zh/firmware/why_customize_firware.html":{"title":"为何需要固件定制","content":" title: 为何需要固件定制 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy 为何需要固件定制 主要是为了节省内存。 芯片的内存是`6MiB`通用内存+`2MiB` AI 专用内存，相比普通单片机来说确实非常大，如果不用 AI 功能，整个`8MiB`内存我们都可以使用， 但是因为很多时候我们需要运行模型，一个模型可能达到`3MiB`甚至更大，而固件也是需要占用内存的， 所以为了能运行更大的模型，我们需要妥协裁剪一些不必要的功能。 在前面更新固件的章节介绍了与编译了许多固件版本， 有`minimum`的， `with_v4_support`的，也有`with_ide_support`的， 还有`with_lvgl`的， 这些固件可能用在不同的场合。比如： * 裁剪 IDE 代码, 如果不需要连接 MaixPy IDE， 可以裁剪 IDE 部分以节省内存。 * 裁剪 OpenMV 功能，固件兼容了 OpenMV 的部分功能，如果使用模型，这些功能可能不需要，就可以裁剪掉。 * 裁剪多线程支持，若不需要多线程支持，即可裁剪该部分得到更多内存空间。 所以，如果你在使用某个功能时， 发现提示`ImportError: no module named 'XXX'`，可能是你使用了不包含这个功能的固件，比如`minimum`固件不包含 IDE 和 `image.find_blobs`功能， 如果烧录了这个固件， 再去连接 `IDE` 就会长时间连接不上， 使用`image.find_blobs`这个函数也会提示找不到函数定义。"},"/soft/maixpy/zh/modules/grove/grove_rgb_led_ring.html":{"title":"Grove - RGB LED Ring(LED 灯条)","content":" title: Grove RGB LED Ring(LED 灯条) keywords: maixpy, k210, AIOT, 边缘计算, RGB LED Ring desc: maixpy Grove RGB LED Ring(LED 灯条) <div class \"grove_pic\"> <img src \"../../../assets/hardware/module_grove/grove_led_ring.jpg\"> </div> Grove RGB LED 环采用3535尺寸的 LED，LED 内嵌有嵌入式微控制器。每个 WS2813 驱动芯片均可寻址并且位于 LED 内部。每个 LED 都有恒定电流驱动，因此即使电压变化，颜色也将非常一致。 ## 参数 项目 \t值 : : 功率 3.3V/5V 静态电流 0.7mA/LED RGB通道恒流 16mA/LED 刷新频率 2Hz 重置时间 >280μs 工作温度 25～85℃ 贮存温度 40～105℃ ## 使用方法 MaixPy 已经在 modules 模块中实现有 WS2812 驱动。 * 创建 ws2812 对象，只需要单根信号线即可 ```python from modules import ws2812 led_io, led_num 24, 24 ws ws2812(led_io, led_num) ``` * 设置某个灯的颜色并显示 ```python for i in range(led_num): ws.set_led(i, (0, 0, 0)) ws.display() ``` ## 例程 [Grove RGB LED Ring 例程](https://github.com/sipeed/MaixPy v1_scripts/blob/master/modules/grove/ws2812/ws2812.py) ## 更多 * API 手册: [modules.ws2812](../../api_reference/extend/ws2812.html) * 模块详情: [Seeed Grove LED_ring](https://wiki.seeedstudio.com/Grove LED_ring/)"},"/soft/maixpy/zh/modules/grove/grove_chainable_rgb_led.html":{"title":"Grove - Chainable RGB LED(可链接 LED 灯)","content":" title: Grove Chainable RGB LED(可链接 LED 灯) keywords: maixpy, k210, AIOT, 边缘计算, RGB LED desc: maixpy Grove Chainable RGB LED(可链接 LED 灯) <div class \"grove_pic\"> <img src \"../../../assets/hardware/module_grove/grove_rgb_led.jpg\"> </div> Grove Chainable RGB LED 使用2线传输（数据和时钟）与 MCU 通信。 这种2线传输可用于级联多个模块。 内置 clock regeneration 可延长传输距离。 该Grove模块适用于任何基于彩色LED的项目。 ## 参数 项目值 : : 工作电压5V 工作电流20mA 通信协议串行 ## 使用方法 * 导入例程仓库中的 RGB_LED 类并创建一个 RGB_LED 对象 ```python from RGB_LED import RGB_LED led RGB_LED(clk_pin, data_pin, led_num, clk_gpiohs_num, data_gpiohs_num, True) ``` * 设置某个灯的颜色， 颜色值为 rgb 格式 ```python for i in range(led_num): led.set_RGB(i, r, g, b) ``` ## 例程 [Grove Chainable RGB LED 例程](https://github.com/sipeed/MaixPy v1_scripts/tree/master/modules/grove/chainable_RGB_LED) ## 更多 模块详情: [Seeed Grove Chainable RGB LED](https://wiki.seeedstudio.com/Grove Chainable_RGB_LED/)"},"/soft/maixpy/zh/modules/grove/grove_ultrasonic_ranger.html":{"title":"Grove - Ultrasonic Ranger(超声波测距)","content":" title: Grove Ultrasonic Ranger(超声波测距) keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy Grove Ultrasonic Ranger(超声波测距) <div class \"grove_pic\"> <img src \"../../../assets/hardware/module_grove/ultrasonic.jpg\"> </div> Grove Ultrasonic Ranger 是一个非接触式测距模块，工作频率为 40KHz。Grove_Ultrasonic_Ranger 的触发和回波信号共享1个 SIG 引脚。 ## 参数 项目 值 工作电压 \t 3.2〜5.2V 工作电流 \t 8ma 超声波频率 \t40kHz 测量范围 \t 2 350cm 解析度 \t 1cm 输出量 \t PWM 尺寸 \t 50mm x 25mm x 16mm 重量 \t 13g 测量角度 \t 15° 工作温度 \t 10〜60°C 触发信号 \t 10uS TTL 回声信号 \t TTL ## 使用方法 MaixPy 已经在 modules 模块中实现有 ultrasonic 驱动。 * 导入 ultrasonic 类并创建对象 ```python from modules import ultrasonic device ultrasonic(fm.fpioa.GPIOHS0) ``` * 获取当前测量距离(cm) ```python distance device.measure(unit ultrasonic.UNIT_CM, timeout 3000000) ``` ## 例程 [Grove Ultrasonic Ranger 例程](https://github.com/sipeed/MaixPy v1_scripts/tree/master/modules/grove/ultrasonic) ## 更多 * API 手册: [modules.ultrasonic](../../api_reference/extend/ultrasonic.html) * 模块详情: [Seeed Grove Ultrasonic_Ranger](https://wiki.seeedstudio.com/Grove Ultrasonic_Ranger/)"},"/soft/maixpy/zh/modules/grove/index.html":{"title":"Grove","content":" title: Grove keywords: maixpy, k210, AIOT, 边缘计算, Grove介绍 desc: maixpy Grove 采用 Grove 标准接口的模块，Grove 为 Seeed 团队使用的统一接口系统，目前以支持大量模块。 ## Grove 接口 Grove 接口的线缆有 4 种颜色，用户可以根据颜色快速区别 ![](../../../assets/hardware/module_grove/grove_interface.jpg) pin 颜色 描述 pin 1 黄色 (例如，I2C Grove Connectors上的SCL) pin 2 白色 (例如，I2C Grove Connectors上的SDA) pin 3 红色 VCC (所有的Grove接口红色都是VCC) pin 4 黑色 GND (所有的Grove接口黑色都是GND) Grove模块主要有 4 种接口: 1. Grove Digital 数字接口:<br/> Grove 数字接口由 Grove 插头的四条标准线组成.<br/> 两条信号线通常称为 D0 和 D1 .<br/> 大多数模块只使用D0，但有些(像LED Bar Grove显示屏)使用两者.通常核心板会将板卡上的第一个Grove连接头称为D0，第二个称为D1.第一个接头会连接到主控芯片的DO/D1管脚，第二个连接头会连接到主控芯片的D1/D2引脚，后面的连接头以此类推. pin Function Note pin1 Dn 第一个数字输入 — pin2 Dn+1 第二个数字输入 — pin3 VCC 供电引脚 5V/3.3V — pin4 GND 地 — 2. Grove UART :<br/> The Grove UART 是特殊的一种数字输入输出接口.<br/> 它使用引脚 1 和引脚 2 进行串行输入和发送. <br/> 引脚1是 RX 线(用于接收数据，因此是输入)， 其中引脚 2 是 TX 线(用于向 Grove 模块传输数据). pin Function Note pin1 RX 串行接收 pin2 TX 串行发送 pin3 VCC 供电引脚 5V/3.3V pin4 GND 地 3. Grove I2C:<br/> 有许多类型的I2C Grove 传感器可用.<br/>MaixCube 上的 Grove 只支持 3.3V 传感器 Grove I2C 连接器具有标准布局.引脚 1 是SCL信号，引脚 2 是SDA信号 pin Function Note pin1 SCL I2C 时钟 pin2 SDA I2C 数据 pin3 VCC 供电引脚，5V/3.3V pin4 GND 地 详情请参考：[Grove_System](https://wiki.seeedstudio.com/cn/Grove_System/) ## 外设模块 以下外设均采用 Grove 接口 * [Ultrasonic Ranger 测距](./grove_ultrasonic_ranger.html) * [Chainable RGB LED 灯](./grove_chainable_rgb_led.html) * [RGB LED Ring 灯条](./grove_rgb_led_ring.html)"},"/soft/maixpy/zh/modules/on_chip/pwm.html":{"title":"PWM 的使用","content":" title: PWM 的使用 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy PWM 的使用 关于 PWM 详细介绍请参考[PWM API 文档](../../api_reference/machine/pwm.html). ## 使用方法 * 从 machine 导入 PWM, Timer 模块 ```python from machine import Timer,PWM ``` * 创建 Timer 和 PWM ```python tim Timer(Timer.TIMER0, Timer.CHANNEL0, mode Timer.MODE_PWM) ch PWM(tim, freq 500000, duty 50, pin boad_info.LED_G) ``` * 改变占空比, 设置的 pin 脚将输出不同占空比的波形 ```python ch.duty(duty) ``` ## 示例 控制 LED_G 灯亮度 > `board_info` 与板卡相关，不同板卡配置不同，使用前需要[手动配置](../../api_reference/builtin_py/board_info.html)。 ```python from machine import Timer,PWM import time from board import board_info from fpioa_manager import fm tim Timer(Timer.TIMER0, Timer.CHANNEL0, mode Timer.MODE_PWM) ch PWM(tim, freq 500000, duty 50, pin board_info.LED_G) duty 0 dir True while True: if dir: duty + 10 else: duty 10 if duty>100: duty 100 dir False elif duty<0: duty 0 dir True time.sleep(0.05) ch.duty(duty) ```"},"/soft/maixpy/zh/modules/on_chip/i2c.html":{"title":"I2C 的使用","content":" title: I2C 的使用 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy I2C 的使用 关于 I2C 详细介绍请参考[I2C API 文档](../../api_reference/machine/i2c.html). ## 使用方法 ### 主机模式 * 创建 I2C(软件模拟或硬件) 对象 ```python from machine import I2C from fpioa_manager import fm # i2c I2C(I2C.I2C0, freq 100000, scl 28, sda 29) # hardware i2c i2c I2C(I2C.I2C4, freq 100000, scl 28, sda 29,gscl fm.fpioa.GPIOHS3,gsda fm.fpioa.GPIOHS2) # software i2c ``` * 扫描从机, 返回所有从机地址 ```python devices i2c.scan() ``` * 对从机读写数据 ```python for device in devices: i2c.writeto(device, b'123') i2c.readfrom(device, 3) ``` ### 从机模式 * 创建从机回调函数 ```python count 0 def on_receive(data): print(\"on_receive:\",data) def on_transmit(): count count+1 print(\"on_transmit, send:\",count) return count def on_event(event): print(\"on_event:\",event) ``` * 创建 I2C 对象 ```python from machine import I2C i2c I2C(I2C.I2C0, mode I2C.MODE_SLAVE, scl 28, sda 29, addr 0x24, addr_size 7, on_receive on_receive, on_transmit on_transmit, on_event on_event) ``` ## 示例 * 读取所有从机地址并分别收发数据 ```python from machine import I2C i2c I2C(I2C.I2C0, freq 100000, scl 28, sda 29) # software i2c devices i2c.scan() print(devices) for device in devices: i2c.writeto(device, b'123') i2c.readfrom(device, 3) ``` * 从机模式示例 ```python from machine import I2C count 0 def on_receive(data): print(\"on_receive:\",data) def on_transmit(): count count+1 print(\"on_transmit, send:\",count) return count def on_event(event): print(\"on_event:\",event) i2c I2C(I2C.I2C0, mode I2C.MODE_SLAVE, scl 28, sda 29, addr 0x24, addr_size 7, on_receive on_receive, on_transmit on_transmit, on_event on_event) ```"},"/soft/maixpy/zh/modules/on_chip/timer.html":{"title":"Timer（定时器） 的使用","content":" title: Timer（定时器） 的使用 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy Timer（定时器） 的使用 关于 Timer 详细介绍请参考[Timer API 文档](../../api_reference/machine/timer.html). ## 使用方法 * 从 machine 导入 Timer 模块 ```python from machine import Timer ``` * 创建 Timer 对象 ```python def on_timer(timer): print(\"time up:\",timer) print(\"param:\",timer.callback_arg()) tim Timer(Timer.TIMER0, Timer.CHANNEL0, mode Timer.MODE_PERIODIC, period 1, unit Timer.UNIT_S, callback on_timer, arg on_timer, start False, priority 1, div 0) ``` * 启动定时器, 此时定时器将定时执行回调函数 ```python tim.start() ``` * 停止定时器 ```python tim.stop() ``` ## 示例 定时执行回调函数 ```python from machine import Timer def on_timer(timer): print(\"time up:\",timer) print(\"param:\",timer.callback_arg()) tim Timer(Timer.TIMER0, Timer.CHANNEL0, mode Timer.MODE_PERIODIC, period 1, unit Timer.UNIT_S, callback on_timer, arg on_timer, start False, priority 1, div 0) print(\"period:\",tim.period()) tim.start() time.sleep(5) tim.stop() time.sleep(5) tim.restart() time.sleep(5) tim.stop() del tim ```"},"/soft/maixpy/zh/modules/on_chip/i2s.html":{"title":"I2S（集成电路内置音频总线）的使用","content":" title: I2S（集成电路内置音频总线）的使用 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy I2S（集成电路内置音频总线）的使用 关于 I2S 音频总线详细介绍请参考[I2S API 文档](./../../api_reference/Maix/i2s.html). ## 使用方法 * 从 Maix 导入 I2S 模块 ```python from Maix import I2S ``` * 创建 I2S 对象 ```python i2s_dev I2S(device_num) ``` * 配置参数 ```python i2s_dev.channel_config(rx.CHANNEL_0, rx.RECEIVER, align_mode I2S.STANDARD_MODE) i2s_dev.set_sample_rate(sample_rate) ``` * 读取或播放数据 ```python i2s_dev.record(256)#sampling points number must be smaller than 256 ``` ## 例程 采集数据并直接播放 ```python from Maix import I2S import time from fpioa_manager import * fm.register(20,fm.fpioa.I2S0_IN_D0)#GO fm.register(19,fm.fpioa.I2S0_WS) fm.register(18,fm.fpioa.I2S0_SCLK) fm.register(34,fm.fpioa.I2S2_OUT_D1) fm.register(35,fm.fpioa.I2S2_SCLK) fm.register(33,fm.fpioa.I2S2_WS) sample_rate 44*1000 rx I2S(I2S.DEVICE_0) rx.channel_config(rx.CHANNEL_0, rx.RECEIVER, align_mode I2S.STANDARD_MODE) rx.set_sample_rate(sample_rate) tx I2S(I2S.DEVICE_2) tx.channel_config(tx.CHANNEL_1, tx.TRANSMITTER, align_mode I2S.RIGHT_JUSTIFYING_MODE) tx.set_sample_rate(sample_rate) while True: audio rx.record(256)#sampling points number must be smaller than 256 tx.play(audio) ```"},"/soft/maixpy/zh/modules/on_chip/uart.html":{"title":"UART 的使用","content":" title: UART 的使用 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy UART 的使用 关于 UART 详细介绍请参考[UART API 文档](./../../api_reference/machine/uart.html). ## 使用方法 * 从 machine 导入 UART 模块 ```python from machine import UART ``` * 配置使用到的 pin 脚为 UART 功能 ```python fm.register(10, fm.fpioa.UART1_TX, force True) fm.register(11, fm.fpioa.UART1_RX, force True) ``` * 创建 UART 对象 ```python uart UART(UART.UART1, 115200, 8, 1, 0, timeout 1000, read_buf_len 4096) ``` * 读写数据 ```python uart.write(b'hello world') read_data uart.read() ``` ## 示例 将串口接收到的数据发送回去 ```python from machine import UART from board import board_info from fpioa_manager import fm # maixduino board_info PIN10/PIN11/PIN12/PIN13 or other hardware IO 12/11/10/3 fm.register(board_info.PIN10, fm.fpioa.UART1_TX, force True) fm.register(board_info.PIN11, fm.fpioa.UART1_RX, force True) fm.register(board_info.PIN12, fm.fpioa.UART2_TX, force True) fm.register(board_info.PIN13, fm.fpioa.UART2_RX, force True) uart_A UART(UART.UART1, 115200, 8, 0, 0, timeout 1000, read_buf_len 4096) uart_B UART(UART.UART2, 115200, 8, 0, 0, timeout 1000, read_buf_len 4096) write_str 'hello world' for i in range(20): uart_A.write(write_str) if uart_A.any(): read_data uart_B.read() if read_data: read_str read_data.decode('utf 8') print(\"string \", read_str) if read_str write_str: print(\"baudrate:115200 bits:8 parity:0 stop:0 check Successfully\") uart_A.deinit() uart_B.deinit() del uart_A del uart_B ```"},"/soft/maixpy/zh/modules/on_chip/spi.html":{"title":"SPI 的使用","content":" title: SPI 的使用 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy SPI 的使用 关于 SPI 详细介绍请参考[SPI API 文档](../../api_reference/machine/spi.html). ## 使用方法 ### 主机模式 * 从 machine 导入 SPI 模块 ```python from machine import SPI ``` * 配置使用到的 pin 脚为片选 GPIO 功能和 SPI 功能. ```python fm.register(25,fm.fpioa.GPIOHS10, force True)#cs cs GPIO(GPIO.GPIOHS10, GPIO.OUT) fm.register(28,fm.fpioa.SPI1_D0, force True)#mosi fm.register(26,fm.fpioa.SPI1_D1, force True)#miso fm.register(27,fm.fpioa.SPI1_SCLK, force True)#sclk ``` * 创建 SPI 对象 ```python spi1 SPI(SPI.SPI1, mode SPI.MODE_MASTER, baudrate 10000000, polarity 0, phase 0, bits 8, firstbit SPI.MSB) ``` * 使用片选 GPIO 选中从机, 通过 SPI 读写数据 ```python cs.value(0) spi1.write_readinto(w, r) cs.value(1) ``` ### 从机模式 K210 SPI 从机模式只支持三线通信，因此 MaixPy 中并没有实现该模式，需要从机模式可参考[SPI_SLAVE 裸机实现](https://github.com/kendryte/kendryte standalone demo/tree/develop/spi_slave)。 ## 示例 * 选中片选 GPIO 对应从机并收发数据 ```python from machine import SPI from fpioa_manager import fm from Maix import GPIO fm.register(25,fm.fpioa.GPIOHS10, force True)#cs cs GPIO(GPIO.GPIOHS10, GPIO.OUT) fm.register(28,fm.fpioa.SPI1_D0, force True)#mosi fm.register(26,fm.fpioa.SPI1_D1, force True)#miso fm.register(27,fm.fpioa.SPI1_SCLK, force True)#sclk spi1 SPI(SPI.SPI1, mode SPI.MODE_MASTER, baudrate 10000000, polarity 0, phase 0, bits 8, firstbit SPI.MSB) w b'\\xFF' r bytearray(1) cs.value(0) print(spi1.write_readinto(w, r)) cs.value(1) ```"},"/soft/maixpy/zh/modules/on_chip/gpio.html":{"title":"GPIO 的使用","content":" title: GPIO 的使用 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy GPIO 的使用 关于 GPIO 详细介绍请参考[GPIO API 文档](../../api_reference//Maix/gpio.html). ## 使用方法 * 将某 IO 注册为 GPIO 功能 ```python from Maix import GPIO from fpioa_manager import fm fm.register(io_number,fm.fpioa.GPIO0) ``` * 设置 GPIO 为输入或输出模式 ```python gpio GPIO(GPIO.GPIO0,GPIO.OUT) ``` * 读取或设置 GPIO 电平 ```python gpio.value() ``` ## 示例 > `board_info` 与板卡相关，不同板卡配置不同，使用前需要[手动配置](../../api_reference/builtin_py/board_info.html)。 点亮 LED ```python import utime from Maix import GPIO from board import board_info from fpioa_manager import fm fm.register(board_info.LED_R,fm.fpioa.GPIO0) led_r GPIO(GPIO.GPIO0,GPIO.OUT) utime.sleep_ms(500) led_r.value(0) fm.unregister(board_info.LED_R) ```"},"/soft/maixpy/zh/modules/on_chip/wdt.html":{"title":"WDT（看门狗） 的使用","content":" title: WDT（看门狗） 的使用 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy WDT（看门狗） 的使用 关于 WDT 详细介绍请参考[WDT API 文档](./../../api_reference/machine/wdt.html). ## 使用方法 看门狗主要用于保护系统正常运行，作用原理为，看门狗启动后，程序中必须定时执行一个喂狗的操作，当系统受到干扰不能正常运行时，喂狗操作也不能定时执行，此时看门狗将产生内部复位，使系统重新开始工作。 * 从 machine 导入 WDT 模块 ```python from machine import WDT ``` * 定义回调函数，创建 WDT 对象 ```python def on_wdt(self): print(self.context(), self) #self.feed() ## release WDT #self.stop() # test callback wdt wdt1 WDT(id 1, timeout 4000, callback on_wdt, context {}) ``` * 喂狗 ```python wdt1.feed() ``` *可以在回调函数中执行喂狗操作* * 关闭看门狗 ```python wdt1.stop() ``` ## 示例 1. 喂一次狗后关闭 2. 不喂狗使得系统复位 ```python import time from machine import WDT # ''' # test default wdt wdt0 WDT(id 0, timeout 3000) print('into', wdt0) time.sleep(2) print(time.ticks_ms()) # 1.test wdt feed wdt0.feed() time.sleep(2) print(time.ticks_ms()) # 2.test wdt stop wdt0.stop() print('stop', wdt0) # 3.wait wdt work #while True: #print('idle', time.ticks_ms()) #time.sleep(1) # ''' # ''' def on_wdt(self): print(self.context(), self) #self.feed() ## release WDT #self.stop() # test callback wdt wdt1 WDT(id 1, timeout 4000, callback on_wdt, context {}) print('into', wdt1) time.sleep(2) print(time.ticks_ms()) # 1.test wdt feed wdt1.feed() time.sleep(2) print(time.ticks_ms()) # 2.test wdt stop wdt1.stop() print('stop', wdt1) # 3.wait wdt work #while True: #print('idle', time.ticks_ms()) #time.sleep(1) # ''' #''' ## test default and callback wdt def on_wdt(self): print(self.context(), self) #self.feed() ## release WDT #self.stop() wdt0 WDT(id 0, timeout 3000, callback on_wdt, context []) wdt1 WDT(id 1, timeout 4000, callback on_wdt, context {}) ## 3.wait wdt work while True: #wdt0.feed() print('idle', time.ticks_ms()) time.sleep(1) #''' '''output into [MAIXPY]WDT:(800cc560; id 0, timeout 3000, callback 800abcf8, context 800abcf8) 550247 552247 stop [MAIXPY]WDT:(800cc560; id 0, timeout 3000, callback 800abcf8, context 800abcf8) into [MAIXPY]WDT:(800cc5e0; id 1, timeout 4000, callback 800cc5a0, context 800cc5c0) 554261 556261 stop [MAIXPY]WDT:(800cc5e0; id 1, timeout 4000, callback 800cc5a0, context 800cc5c0) idle 556268 idle 557269 idle 558269 [] [MAIXPY]WDT:(800cc680; id 0, timeout 3000, callback 800cc620, context 800cc640) idle 559275 {} [MAIXPY]WDT:(800cce40; id 1, timeout 4000, callback 800cc620, context 800cc6c0) idle 560282 idle 561283 [MAIXPY] Pll0:freq:806000000 [MAIXPY] Pll1:freq:398666666 [MAIXPY] Pll2:freq:45066666 [MAIXPY] cpu:freq:403000000 [MAIXPY] kpu:freq:398666666 [MAIXPY] Flash:0xef:0x17 [MaixPy] gc heap 0x800c9850 0x80149850(524288) [MaixPy] init end __ __ _____ __ __ _____ __ __ \\/ /\\ _ _ \\ \\ / / __ \\ \\ \\ / / \\ / / \\ \\ V / __) \\ \\_/ / \\/ / /\\ \\ > < ___/ \\ / / ____ \\ _ _ / . \\ _ _ /_/ \\_\\ _____ /_/ \\_\\ _ _ Official Site : https://www.sipeed.com Wiki : https://maixpy.sipeed.com MicroPython v0.5.1 174 gf18990aa3 dirty on 2021 01 11; Sipeed_M1 with kendryte k210 Type \"help()\" for more information. ''' ```"},"/soft/maixpy/zh/modules/others/servo.html":{"title":"舵机","content":" title: 舵机 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy 舵机 ## 警告！请外接电源，不要用电脑供电给舵机，烧了自理。 ## 使用方法 舵机需要使用 PWM 输出不同占空比来控制其旋转角度, 首先需要准备舵机 * 导入 PWM 模块，创建 PWM 对象，PWM 输出引脚接到舵机信号输入 ```python from machine import Timer,PWM tim Timer(Timer.TIMER0, Timer.CHANNEL0, mode Timer.MODE_PWM) S1 PWM(tim, freq 50, duty 0, pin 17) ``` * 输出不同占空比波形来控制舵机 ```python S1.duty((angle+90)/180*10+2.5) ``` PWM 控制 API 参考: [PWM API](../../api_reference/machine/pwm.html) ## 例程 * 控制舵机旋转不同角度: [Servo](https://github.com/sipeed/MaixPy v1_scripts/blob/79a5485ec983e67bb8861305a52418b29e0dc205/modules/others/Servo/Servo.py) * 舵机云台: [gimbal](https://github.com/sipeed/MaixPy v1_scripts/tree/master/application/gimbal)"},"/soft/maixpy/zh/modules/others/onewire.html":{"title":"onewire（单总线）的使用","content":" title: onewire（单总线）的使用 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy onewire（单总线）的使用 # 使用方法 * 从 modules 导入 onewire 模块 ```python from modules import onewire ``` * 创建 onewire 对象 ```python fm.register(14, fm.fpioa.GPIOHS2, force True) bus onewire(fm.fpioa.GPIOHS2) ``` * 搜索，读写数据等操作 ## 例程： ds18b20 温度读取：[onwire_ds18b20](https://github.com/sipeed/MaixPy v1_scripts/blob/80f4eb71d3481b6f119f25f39f7c9b37404b99ce/hardware/demo_onewire_ds18x20.py)"},"/soft/maixpy/zh/modules/others/index.html":{"title":"其他模块","content":" title: 其他模块 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy 其他模块 * [双目摄像头](./binocular_camera.html) * [esp32 ADC模数转换](./esp32_read_adc.html) * [HTPA 红外测温](./htpa.html) * [串口红外镜头](./mlx90640.html) * [舵机](./servo.html)"},"/soft/maixpy/zh/modules/others/mlx90640.html":{"title":"MLX90640 串口红外镜头模块","content":" title: MLX90640 串口红外镜头模块 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy MLX90640 串口红外镜头模块 <img src \"./../../../assets/hardware/other/mlx90640_hot_map3.jpg\"> <img src \"../../../assets/hardware/other/k210_mlx90640_hot_map2.jpg\"> 可用于无接触测温。 ## 参数 * 分辨率：32x24 * 测量范围： 40°C~300°C * 温度分辨率：0.1°C * 测量精度：±2°C * 重复精度：±2°C * 响应频率：8HZ * 工作电压：3.3~5V * 工作电流：42mA * 工作温度： 40°C~85°C * 尺寸：17.27mmx33mm ## 使用方法 该模块使用串口或 I2C 进行通信，确认接线正确后，从串口即可读取到测量数据。 ## 例程 * 在 LCD 显示红外热成像图片：[demo mlx90640](https://github.com/sipeed/MaixPy v1_scripts/tree/master/modules/others/mlx90640) ## 更多 * 模块详情：[Far infrared thermal sensor array (32x24 RES)](https://www.melexis.com/en/product/MLX90640/Far Infrared Thermal Sensor Array) * 详细教程：[mlx90640](https://neucrack.com/p/189)"},"/soft/maixpy/zh/modules/others/htpa.html":{"title":"HTPA 热红外测温模组","content":" title: HTPA 热红外测温模组 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy HTPA 热红外测温模组 <img src \"./../../../assets/hardware/other/htpa32x32.png\"> <img src \"../../../assets/hardware/other/htpat_scale_240x240.png\"> 可用于无接触测温。 ## 参数 * 电源电压(DC)：3.3V * 电流消耗：5.5(±1.0)mA * 时钟频率(传感器)：5(±3)MHz * 环境温度范围： 20 ~ 85℃ * 对象温度范围： 20 ~ >1000°C * 帧率(全帧)：2 ~ 27hz * 帧率(四分之一帧)：8 ~ 110hz * 噪声等效温差(最佳光学)：140mK@1Hz * 通信方式：I2C ## 使用方法 MaixPy 已经在 modules 中实现了 htpa（需要在固件编译时该模块使能才可用）。 * 导入并创建 htpa ```python from machine import I2C from modules import htpa dev htpa(i2c I2C.I2C0, scl_pin 7, sda_pin 6, i2c_freq 1000000) ``` * 获取检测范围内所有点的温度 ```python temperature dev.temperature() ``` API 详情参考[modules.htpa](../../api_reference/extend/htpa.html) ## 例程 * 在 LCD 绘制温度分布图：[htpa demo](https://github.com/sipeed/MaixPy v1_scripts/blob/79a5485ec983e67bb8861305a52418b29e0dc205/modules/others/heimann_HTPA_32x32/HTPA_32x32_demo.py) ## 更多 * 模块资料：[32x32 Thermopile Array](https://www.heimannsensor.com/32x32) * 详细教程: [热红外 heimann (海曼) HTPA 32x32d](https://neucrack.com/p/199)"},"/soft/maixpy/zh/modules/others/esp32_read_adc.html":{"title":null,"content":" title: keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy ## 如何使用 ESP32 获取 ADC 模拟量 由于 K210 没有 ADC 读取模拟量的功能，所以该功能只能从 ESP32 、ESP82XX 等硬件上获取，ADC 最基础的用途就是实现一个可触摸的按键触点。 ### ESP32 示例代码 ```python # Uasge see readme.md # from network_esp32 import wifi import time, network from Maix import GPIO from fpioa_manager import fm class wifi(): # IO map for ESP32 on Maixduino fm.register(25,fm.fpioa.GPIOHS10)#cs fm.register(8,fm.fpioa.GPIOHS11)#rst fm.register(9,fm.fpioa.GPIOHS12)#rdy print(\"Use Hareware SPI for other maixduino\") fm.register(28,fm.fpioa.SPI1_D0, force True)#mosi fm.register(26,fm.fpioa.SPI1_D1, force True)#miso fm.register(27,fm.fpioa.SPI1_SCLK, force True)#sclk nic network.ESP32_SPI(cs fm.fpioa.GPIOHS10, rst fm.fpioa.GPIOHS11, rdy fm.fpioa.GPIOHS12, spi 1) print(\"ESP32_SPI firmware version:\", wifi.nic.version()) # get ADC0 ADC1 ADC2 adc wifi.nic.adc((0,1,2)) print(adc) while True: try: # get ADC0~5 adc wifi.nic.adc() except Exception as e: print(e) continue for v in adc: print(\"%04d\" %(v), end \" \") print(' : adc') ''' MicroPython v0.5.1 136 g039f72b6c dirty on 2020 11 18; Sipeed_M1 with kendryte k210 Type \"help()\" for more information. >>> raw REPL; CTRL B to exit >OK (2370, 3102, 3071) 2017 2753 0977 2709 0963 0855 : adc 0617 0757 0150 0095 0133 0153 : adc 1319 1478 0955 0939 0698 0619 : adc 2403 3231 3299 3298 1483 0779 : adc 1119 1815 1274 1315 0230 0255 : adc 0951 0951 0295 0283 0319 0399 : adc 2175 2769 2576 2579 1487 1104 : adc 1995 2846 2647 2699 0839 0441 : adc ''' ``` ### OSError: Get version fail 重试就行，通常是 esp32 还未初始化成功。 ```shell Traceback (most recent call last): File \"<stdin>\", line 15, in <module> File \"<stdin>\", line 24, in wifi OSError: Get version fail > ``` ### ESP82XX 实现思路 > 文档对该部分内容不做解释。 通过 AT+SYSADC 查询 ADC 值，在乐鑫的 ESP82XX AT 固件中默认为GPIO12 引脚。 直接读取值即可使用。"},"/soft/maixpy/zh/modules/others/binocular_camera.html":{"title":"双目摄像头","content":" title: 双目摄像头 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy 双目摄像头 ![](../../../assets/hardware/module/camera_binocular.png) ## 使用方法 需要准备一个双目摄像头 * 导入并初始化双目摄像头 ```python import sensor sensor.binocular_reset() sensor.shutdown(False) sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.shutdown(True) sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) ``` * 打开摄像头并捕捉图像 ```python sensor.shutdown(True) img sensor.snapshot() ``` API 详情请参考: [Sensor API](../../api_reference/machine_vision/sensor.html) ## 例程 捕捉图像并显示在 LCD 上 [demo_binocular](https://github.com/sipeed/MaixPy v1_scripts/blob/5a03ab549d06cd713f2c0d19f0c18fbd24c69025/hardware/demo_binocular.py)"},"/soft/maixpy/zh/modules/sp_mod/sp_lcd1.14.html":{"title":"SP_LCD1.14 的使用","content":" title: SP_LCD1.14 的使用 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy SP_LCD1.14 的使用 <img src \"../../../assets/hardware/module_spmod/sp_lcd1.14.png\"/> SP_LCD 拥有一块1.14’寸 LCD， 8P FPC(0.5mm 间距)接口的 TFT 液晶屏，180°可视角. ## 参数 * 屏幕大小: 1.14 英寸 * 分辨率: 240*135 * 色彩: 132 个 RGB 通道 * 通信接口: SPI * 有效显示区域:21.7mm * 10.8mm * 工作电压: 2.5V~4.8V * 工作温度: 30°C~85°C 模块详细信息请参考[LCD1.14 规格书与数据手册](https://api.dl.sipeed.com/fileList/MAIX/HDK/Spmod_EN/SP LCD1.14%20Datasheet%20V1.0.pdf) ## 使用方法 1. 准备: 已烧录最新固件的开发板, sp_lcd114 模块. 2. 运行: 连接模块, 修改[示例代码](https://github.com/sipeed/MaixPy v1_scripts/tree/master/modules/spmod/sp_lcd114)中 config 包围的配置, 运行后模块将显示图片. 程序如下: ```python # init ips SPLCD114(spi1, cs, dc, rst, busy, IPS_WIDTH, IPS_HEIGHT, IPS_MODE) # create an 'image' and fill it img image.Image() img.draw_rectangle(80, 80, 30, 30) # display ips.display(img) ``` 主要步骤为: * 初始化(参数从左到右为: SPI 对象, 片选脚, 复位脚, 忙标志脚, 屏幕宽, 屏幕高度, 屏幕方向). * 创建 Image. * 调用 display 显示图片(传入参数为 Image 对象)."},"/soft/maixpy/zh/modules/sp_mod/sp_rfid.html":{"title":"SP_RFID 的使用","content":" title: SP_RFID 的使用 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy SP_RFID 的使用 <img src \"../../../assets/hardware/module_spmod/sp_rfid.png\"/> 该模块所采用的 FM17510 是一款高度集成的工作在 13.56MHz 下的非接触读写器芯片. 支持符合 ISO/IEC 14443 TypeA 协议的非接触读写器模式, 并且程序与 MFRC522 兼容. ## 参数 * 支持 ISO/IEC 14443 TypeA 读写器模式 * 读写器模式支持 M1 加密算法 * ISO14443 TYPEA 支持通讯速率 106kbps,212kbps,424kbps * 支持 SPI 串行接口,最高 10Mbps * 电压范围 2.2V~3.6V * 64Byte 收发缓冲 FIFO * 多种低功耗模式:Soft powerdown 模式 Hard powerdown 模式 * 内置 CRC 协处理器 * 支持低功耗外部卡片侦测功能 * 工作电压: 2.2V~3.6V * 工作温度: 40°C~85°C 模块详细信息请参考[RFID 规格书与数据手册](https://api.dl.sipeed.com/fileList/MAIX/HDK/Spmod_EN/SP RFID%20Datasheet%20V1.0.pdf) ## 使用方法 1. 准备: 已烧录最新固件的开发板, sp_rfid 模块, M1 卡片. 2. 运行: 连接模块, 修改[示例代码](https://github.com/sipeed/MaixPy v1_scripts/tree/master/modules/spmod/sp_rfid)中 config 包围的配置, 运行后将卡片靠近模块天线, 可看到终端打印的读卡信息. 程序如下: ```python # Init module MIFAREReader MFRC522(spi1, cs) # Scan for cards (status, ataq) MIFAREReader.MFRC522_Request(MIFAREReader.PICC_REQALL) # Get uid (status, uid) MIFAREReader.MFRC522_Anticoll() if status MIFAREReader.MI_OK: # Bind card by uid MIFAREReader.MFRC522_SelectTag(uid) # Authenticate block 0x11 by key status MIFAREReader.MFRC522_Auth(MIFAREReader.PICC_AUTHENT1A, 0x11, key, uid) if status MIFAREReader.MI_OK: # Write 16 bytes from block 0x11 MIFAREReader.MFRC522_Write(0x11, data) # Read 16 bytes from block 0x11 MIFAREReader.MFRC522_Read(0x11) '''output >>> [Warning] function is used by fm.fpioa.GPIOHS20(pin:36) Welcome to the MFRC522 data read/write example Card detected type: 0x400 Card read UID: 110,159,46,15 Size: 8 Sector 11 will now be filled with 1~16: 4 backdata &0x0F 0x0A 10 Data written start to read Sector 18 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15] Card detected type: 0x400 Card read UID: 110,159,46,15 Size: 8 Sector 11 will now be filled with 1~16: 4 backdata &0x0F 0x0A 10 Error while writing Data written ''' ``` 主要分为几步: * 创建 MFRC522 对象(参数为: SPI 对象, 片选脚). * 扫描卡片并获取到 ATQA(即卡片类型码), ATQA 对应卡片类型如下: ATQA Type : : : 0x4400 Mifare_UltraLight 0x0400 Mifare_One(M1 S50) 0x0200 Mifare_One(M1 S70) 0x0800 Mifare_Pro(X) 0x4403 Mifare_DESFire * 获取卡片 UID * 通过 UID 绑定卡片(防碰撞, 确保所选卡能正确执行交易, 不受现场另一张卡的影响) * 对卡片中某一扇区进行身份验证(M1(S50)默认密码为16个0xff) * 读/写卡片信息(以一个块(16字节)为基本读写单位)"},"/soft/maixpy/zh/modules/sp_mod/sp_tof.html":{"title":"SP_TOF 的使用","content":" title: SP_TOF 的使用 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy SP_TOF 的使用 <img src \"../../../assets/hardware/module_spmod/sp_tof.png\"/> SP_TOF 所采用的 VL53L0X 是新一代飞行时间(ToF)激光测距模块, 无论目标反射率如何, 都能提供精确的距离测量, 搭配的红色激光瞄头辅助观察测距点. ## 参数 * 测量距离: 最大 2000mm(较暗环境), 1000mm(明亮环境) * 工作刷新率: 50Hz * 测量角度: 27°(正面) * 通信接口: I2C * 工作电压: 2.6V~3.5V * 工作温度: 40°C~80°C 模块详细信息请参考[TOF 规格书与数据手册](https://api.dl.sipeed.com/fileList/MAIX/HDK/Spmod_EN/SP ToF(1P)%20Datasheet%20V1.0.pdf) ## 使用方法 1. 准备: 已烧录最新固件的开发板, sp_tof 模块. 2. 运行: 连接模块, 修改[示例代码](https://github.com/sipeed/MaixPy v1_scripts/tree/master/modules/spmod/sp_tof)中 config 包围的配置, 运行后将激光瞄头对准测量点, 可看到终端打印的距离信息. 程序如下: ```python # create obj and read distance tof VL53L0X(i2c) while True: mm tof.read() utime.sleep_ms(100) print(mm) '''output >>> [41] 536mm 538mm 533mm 535mm 529mm 532mm ''' ``` 主要步骤为: * 创建 TOF 对象(参数为: I2C 对象). * 读取距离, 若读取距离为 8190, 则说明已经超出量程."},"/soft/maixpy/zh/modules/sp_mod/sp_ethernet.html":{"title":"SP_Ethernet 的使用","content":" title: SP_Ethernet 的使用 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy SP_Ethernet 的使用 <img src \"../../../assets/hardware/module_spmod/sp_ethernet.png\"> 该模块采用 W5500作为主控芯片，这是一款集成全硬件 TCP/IP 协议栈的嵌入式以太网控制器。 ## 参数 * 工作电压：2.6V~3.6V * 工作电流：<132mA * 休眠电流：<15mA * 通讯接口：SPI * 工作温度范围： 40℃ ~ 85℃ 模块详细信息请参考[Ethernet 规格书](https://api.dl.sipeed.com/fileList/MAIX/HDK/Spmod_EN/SP Ethernet%20Datasheet%20V1.0.pdf) ## 使用方法 1. 准备: 已烧录最新固件的开发板, sp_ethernet 模块， 网线。 2. 运行: 连接模块, 修改[示例代码](https://github.com/sipeed/MaixPy v1_scripts/tree/master/modules/spmod/sp_ethernet)中 config 包围的配置, 运行后模块将打印通信数据。 程序如下： ```python spi1 SPI(4, mode SPI.MODE_MASTER, baudrate 600 * 1000, polarity 0, phase 0, bits 8, firstbit SPI.MSB, sck WIZNET5K_SPI_SCK, mosi WIZNET5K_SPI_MOSI, miso WIZNET5K_SPI_MISO) # create wiznet5k nic nic network.WIZNET5K(spi spi1, cs WIZNET5K_SPI_CS) print(\"Static IP: \", nic.ifconfig()) ``` * 创建 SPI 并使用 SPI 创建 WIZNET5K 有线网卡 * 打印当前 IP 信息 相关 API 参考: [wiznet5k API](../../api_reference/machine/network.html#wiznet5k)"},"/soft/maixpy/zh/modules/sp_mod/sp_bt.html":{"title":"SP_BT 的使用","content":" title: SP_BT 的使用 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy SP_BT 的使用 <img src \"../../../assets/hardware/module_spmod/sp_bt.png\"/> SP_BT 是一款蓝牙串口透传模块， 具备超低功率特性和高可靠性， 使用 AT 指令进行控制， 蓝牙版本为 BLE 5.0(兼容BLE4.0, BLE4.2), 默认串口波特率为9600. ## 参数 * 接收灵敏度: 97dm * 发射功率: 4db(最大) * 通信接口: UART * 天线: 板载天线 * 主从支持: 从机 * 工作频段: 2.4G * 工作温度: 40°C~85°C * 工作电压: 1.8V~3.6V 模块详细信息请参考[BT 规格书与数据手册](https://api.dl.sipeed.com/fileList/MAIX/HDK/Spmod_EN/SP BT%20Datasheet%20V1.0.pdf) ## 使用说明 1. 准备: 已烧录最新固件的开发板, sp_bt 模块, 蓝牙调试助手. 2. 运行: 连接模块, 修改[示例代码](https://github.com/sipeed/MaixPy v1_scripts/tree/master/modules/spmod/sp_bt)中 config 包围的配置, 运行后使用蓝牙调试助手连接并发送数据, 即可在终端查看收发信息. 程序如下: ```python # set uart rx/tx func to io_6/7 fm.register(TX, fm.fpioa.UART1_TX) fm.register(RX, fm.fpioa.UART1_RX) # init uart uart UART(UART.UART1, 9600, 8, 1, 0, timeout 1000, read_buf_len 4096) set_name(uart, name) print(\"wait data: \") while True: read_data uart.read() if read_data: print(\"recv:\", read_data) uart.write(read_data) # send data back print(\"wait data: \") ``` 主要步骤为: * 初始化串口(波特率为模块默认波特率9600) * 设置模块广播名 * 等待连接, 接收数据打印后发送回去 ## 连接过程 * 模块初始化后处于未连接状态(指示灯: ACT 闪烁, STA 常灭). * 蓝牙调试助手连接后模块变为已连接(指示灯: ACT 常亮, STA 常亮). * 连接后蓝牙调试助手会显示的服务如下图: <img src \"../../../assets/hardware/module_spmod/sp_bt_screenshot.png\" alt \"bt_server\"/> 上图中可以看到有一个 UUID 为 ffe0 的服务有两个特征, 打开透传(ffe1)的 Write, Notify, 便可以开始发送/接收数据."},"/soft/maixpy/zh/modules/sp_mod/index.html":{"title":"SP-MOD","content":" title: SP MOD keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy SP MOD ## SP MOD 接口 SP MOD 即为 sipeed module, simplify PMOD, super module，Sipeed 官方主推使用，8P 2.54mm 2x4 双排排母，支持通讯协议如下： ![](./../../../assets/hardware/module_spmod/sp_mod.svg) ## 外设模块 以下模块均采用 SP MOD 标准接口的模块。 * [SP_BT 蓝牙透传](./sp_bt.html) * [SP_LoRa 无线通信](./sp_lora.html) * [SP_RFID 射频识别](./sp_rfid.html) * [SP_TOF 测距](./sp_tof.html) * [SP_Eink 电子墨水屏](./sp_eink.html) * [SP_LCD1.14 IPS屏](./sp_lcd1.14.html) * [SP_Weather 气象传感](./sp_weather.html) * [SP_Ethernet 有线网口](./sp_ethernet.html)"},"/soft/maixpy/zh/modules/sp_mod/sp_weather.html":{"title":"SP_WEATHER 的使用","content":" title: SP_WEATHER 的使用 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy SP_WEATHER 的使用 <img src \"../../../assets/hardware/module_spmod/sp_weather.png\"/> SP_Weather 气象模块拥有两颗传感器, 磁性传感器 QMC7983, 这是一个内置灵敏度补偿与 NTC 的三轴磁性传感器, 具有出色的动态范围和精度以及超低的功耗. 温湿度气压传感器 BME280, 能够同时测量温湿度以及气压. ## 参数 ### 磁性传感器 QMC7983 * 磁感应量程: ±30 高斯 * 精度: 每 LSB 1mG * RMS 噪声: 2mG * 对外接口: I2C, 默认地址 0x2C,可通过选择电阻调节 * 工作电压: 2.6V~3.6V * 工作温度: 30°C ~ 85°C ### 温湿度气压传感器 BME280 * 温度传感器的关键参数 * 测量范围: 40°C~85 * 精度: 范围(°C)误差值(°C) : :: : 25±0.5 0~65±1.0 20~0±1.25 40~ 20±1.5 * 湿度传感器的关键参数 * 响应时间(τ63%): 1 s * 精度公差: ±3% 相对湿度 * 磁滞: ±1% 相对湿度 * 气压传感器的关键参数 * RMS 噪声: 0.2Pa(相当于 1.7cm) * 偏移温度系数: ±1.5 Pa/K(相当于 1℃ 温度变化时为 ±12.6cm) * 对外接口: I2C,默认地址 0x76,可通过选择电阻调节 * 工作电压: 1.71V~3.6V * 工作温度: 30°C ~ 85°C 模块详细信息请参考[气象模块规格书与数据手册](https://api.dl.sipeed.com/fileList/MAIX/HDK/Spmod_EN/SP WEATHER%20Datasheet%20V1.0.pdf) ## 使用方法 1. 准备: 已烧录最新固件的开发板, sp_weather 模块. 2. 运行: 连接模块, 修改[示例代码](https://github.com/sipeed/MaixPy v1_scripts/tree/master/modules/spmod/sp_weather)中 config 包围的配置, 运行后可看到终端打印的磁性传感器和气压温湿度传感器数据 输出结果如下: ```python '''output >>> I2C devices:[44, 118] 0x32 6 (228, 123, 156) ('31.0C', '1017.75hPa', '34.32%') (235, 130, 185) ('30.75C', '1017.74hPa', '34.31%') (235, 130, 161) ('30.7C', '1017.82hPa', '34.32%') ''' ``` 主要步骤为: * 创建 SPWEATHE(参数为: I2C 对象). * 读取磁力传感器数据和温湿度数据.(读取到的数据均为元组)"},"/soft/maixpy/zh/modules/sp_mod/sp_eink.html":{"title":"SP_EINK 的使用","content":" title: SP_EINK 的使用 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy SP_EINK 的使用 <img src \"../../../assets/hardware/module_spmod/sp_eink.png\"/> SP_EINK 模块所采用的 GDEW0154M09 是一款 1.54”, 拥有 24P FPC(0.5mm 间距)接口的电子墨水屏. ## 参数 * 屏幕大小: 1.54 英寸 * 有效显示区域: 27.6mm * 27.6mm * 色彩: 黑/白/红显示 * 通信接口: SPI * 工作温度: 40°C~85°C * 工作电压: 2.3V~3.6V 模块详细信息请参考[EINK 规格书与数据手册](https://api.dl.sipeed.com/fileList/MAIX/HDK/Spmod_EN/SP EINK%20Datasheet%20V1.0.pdf) ## 使用方法 1. 准备: 已烧录最新固件的开发板, sp_eink 模块. 2. 运行: 连接模块, 修改[示例代码](https://github.com/sipeed/MaixPy v1_scripts/tree/master/modules/spmod/sp_eink)中 config 包围的配置, 运行后模块将显示图片. 程序如下: ```python # init epd SPEINK(spi1, cs, dc, rst, busy, EPD_WIDTH, EPD_HEIGHT) epd.init() # create red image img_r image.Image() img_r img_r.resize(EPD_WIDTH, EPD_HEIGHT) img_r.draw_line(0, 0, 100, 100) # create black/white image img_bw image.Image() img_bw img_bw.resize(EPD_WIDTH, EPD_HEIGHT) img_bw.draw_line(100, 50, 200, 100) # display epd.display(img_r, img_bw) # sleep mode epd.sleep() ``` 主要步骤如下: * 创建 SPEINK 对象(参数为: SPI 对象, 片选脚, 复位脚, 忙标志脚, 横向分辨率, 纵向分辨率, 屏幕旋转角度(0, 90, 180, 270)), 初始化. * 创建红色和黑色图像, 设置为屏幕大小并填充图像. * 调用 display(参数依次为: 红色图像, 黑色图像), 此时屏幕将会闪烁并显示图像. * 进入睡眠状态."},"/soft/maixpy/zh/modules/sp_mod/README_copy.html":{"title":"SP-MOD","content":" title: SP MOD keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy SP MOD ## SP MOD 接口 SP MOD 即为 sipeed module, simplify PMOD, super module，Sipeed 官方主推使用，8P 2.54mm 2x4 双排排母，支持通讯协议如下： ![](./../../../assets/hardware/module_spmod/sp_mod.svg) ## 外设模块 以下模块均采用 SP MOD 标准接口的模块。 * [SP_BT 蓝牙透传](./sp_bt.html) * [SP_LoRa 无线通信](./sp_lora.html) * [SP_RFID 射频识别](./sp_rfid.html) * [SP_TOF 测距](./sp_tof.html) * [SP_Eink 电子墨水屏](./sp_eink.html) * [SP_LCD1.14 IPS屏](./sp_lcd1.14.html) * [SP_Weather 气象传感](./sp_weather.html) * [SP_Ethernet 有线网口](./sp_ethernet.html)"},"/soft/maixpy/zh/modules/sp_mod/sp_lora.html":{"title":"SP_LORA 的使用","content":" title: SP_LORA 的使用 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy SP_LORA 的使用 <img src \"../../../assets/hardware/module_spmod/sp_lora.png\"/> SP_LoRa 模块使用 M XL8 模组, 其内置 LoRaTM 调制解调器和可调功率放大器的 LoRa 模块, 具有高性能和高可靠性. ## 参数 * 工作频段: 370MHz~1200Mhz * 发射功率: 20dBm(最大) * 通信接口: SPI * 天线: 外置天线,IPEX 或焊接 * 接收灵敏度: 148dbm * RSSI 动态范围: 127dB * 工作电压: 1.8V~6.3V * 工作温度: 40°C~80°C 模块详细信息请参考[LoRa 规格书与数据手册](https://api.dl.sipeed.com/fileList/MAIX/HDK/Spmod_EN/SP LoRa%20Datasheet%20V1.0.pdf) ## 使用方法 1. 准备: 两块已烧录最新固件的开发板, 两个 sp_lora 模块. 2. 运行: 连接模块, 修改[示例代码](https://github.com/sipeed/MaixPy v1_scripts/tree/master/modules/spmod/sp_lora)中 config 包围的配置, 两块开发板分别运行发送和接收函数, 即可在终端查看收发信息. 程序如下: ```python # init lora SX127x(spi spi1, pin_ss cs) # lora reset rst.value(0) time.sleep_ms(10) rst.value(1) time.sleep_ms(100) lora.init() ####### receiver ########### receive(lora) ######## sender ########### # send(lora) '''output mpfs [/flash]> runfile lora_send.py transfer 6400 of 14576 transfer 12800 of 14576 transfer 14576 of 14576 [Warning] function is used by fm.fpioa.GPIOHS7(pin:23) LoRa Sender Sending packet: Hello(0) mpfs [/sd]> runfile lora_recv.py transfer 6400 of 14576 transfer 12800 of 14576 transfer 14576 of 14576 [Warning] function us used by fm.fpioa.GPIOHS7(pin:23) LoRa Receiver [Memory free: 470080 allocated: 48064] *** Received message *** Hello(0) with RSSI: <bound_method 800d19e0 <SX127x object at 800f5700>.<function packetRssi at 0x800d3180>> ''' ``` 这里使用的调试运行工具为 mpfshell 方便同时打开两个终端运行脚本. 主要步骤为: * 创建 LoRa 对象(参数为: SPI 对象, 片选脚) * 复位(将复位引脚拉低有拉高), 初始化. * 开始发送或接收."},"/soft/maixpy/zh/api_reference/extend/touchscreen.html":{"title":"touchscreen（触摸屏幕）","content":" title: touchscreen（触摸屏幕） keywords: maixpy, k210, AIOT, 边缘计算, 深度学习, 人工智能 desc: maixpy touchscreen（触摸屏幕） `touchscreen` 模块包含了基本的读取触摸屏幕操作 目前支持的触摸屏幕： * ns2009（默认） 如果需要修改驱动型号，需要重新编译 `MaixPy` 源码修改预编译支持的型号 ## 全局函数 ### init(i2c None, cal None) 初始化触摸屏 > API 在后面可能会有所改动（主要是针对多种驱动对参数的改动） #### 参数 * `i2c`： 目前支持的是 `I2C` 通信的触摸屏， 传入`I2C`实例对象， 后期这个参数可能会被重命名或者取消 * `cal`： 校准数据， 是一个 `7` 个整型值的元组， 可以通过 `touchscreen.calibrate()` 函数得到 ### calibrate() 校准屏幕，使屏幕显示和触摸屏像素能够对应 #### 返回值 返回一个 `7` 个整型值的元组， 可以保存到文件系统或者`flash`，在初始化的时候传入，这样就不用每次都校准了 ### read() 读取当前屏幕的状态以及按下的点的坐标值 #### 返回值 一个由 `3` 个整型值组成的元组 `(status, x, y)`， 注意这个值会一直保持上一个状态 * `status`： 状态， 取值有 `touchscreen.STATUS_PRESS`， `touchscreen.STATUS_MOVE`， `touchscreen.STATUS_RELEASE` * `x`： `x` 轴坐标 * `y`： `y` 轴坐标 ## 常量 ### touchscreen.STATUS_PRESS 屏幕被按下， `read()` 函数返回的元组的第一个值 ### touchscreen.STATUS_MOVE 屏幕被按住并移动，即按住移动， `read()` 函数返回的元组的第一个值 ### touchscreen.STATUS_RELEASE 屏幕不再被按住，即没有点击， `read()` 函数返回的元组的第一个值 ## 例程 ## 例程 1 ： 图画板 黑底白画笔画图板， 使用`boot` 按键可以清除内容 > 取消 `ts.calibrate()` 的注释可以在开始运行触摸屏校准程序 > `board_info` 与板卡相关，不同板卡配置不同，使用前需要[手动配置](../builtin_py/board_info.html)。 ```python import touchscreen as ts from machine import I2C import lcd, image from board import board_info from fpioa_manager import * board_info board_info() fm.register(board_info.BOOT_KEY, fm.fpioa.GPIO1) btn_clear GPIO(GPIO.GPIO1, GPIO.IN) lcd.init() i2c I2C(I2C.I2C0, freq 400000, scl 30, sda 31) ts.init(i2c) #ts.calibrate() lcd.clear() img image.Image() status_last ts.STATUS_IDLE x_last 0 y_last 0 draw False while True: (status,x,y) ts.read() print(status, x, y) if draw: img.draw_line((x_last, y_last, x, y)) if status_last! status: if (status ts.STATUS_PRESS or status ts.STATUS_MOVE): draw True else: draw False status_last status lcd.display(img) x_last x y_last y if btn_clear.value() 0: img.clear() ts.__del__() ```"},"/soft/maixpy/zh/develop_kit_board/maix_go.html":{"title":"Maix Go","content":" title: Maix Go keywords: maixpy, k210, AIOT, 边缘计算, Maix Go desc: maixpy Maix Go ## 外观及功能介绍 ### 外观一览 ![Maix Go](../../assets/hardware/maix_go/Go.png) ### 板载功能 项目 说明 CPU： 双核 64bit RISC V / 400MHz* (双精度FPU集成) 内存： 8MiB 64bit 片上 SRAM 存储： 16MiB Flash, 支持 micro SDXC 拓展存储 (最大128GB) 屏幕： 2.4 寸 TFT, 电容触摸屏幕分辨率：320\\*240 摄像头(套餐)： 200W 像素(实际使用 30W)，0V2640 型号 M12 摄像头 TF 卡槽： 多媒体资源扩展，支持大容量储存 ## 资料下载 Sipeed Maix Go 资料下载：[Sipeed Maix Go](https://dl.sipeed.com/shareURL/MAIX/HDK/Sipeed Maix GO)"},"/soft/maixpy/zh/develop_kit_board/maix_bit.html":{"title":"Maix Bit","content":" title: Maix Bit keywords: maixpy, k210, AIOT, 边缘计算, Maix Bit desc: maixpy Maix Bit ## 外观及功能介绍 ### 外观一览 ![Maix Bit](../../assets/hardware/maix_bit/maix_bit.png) ### 板载功能 项目 说明 CPU： 双核 64bit RISC V / 400MHz (双精度FPU集成) 内存： 8MiB 64bit 片上 SRAM 存储： 16MiB Flash, 支持 micro SDXC 拓展存储 (最大128GB) 屏幕(套餐)： 2.4 寸 TFT, 屏幕分辨率：320\\*240 摄像头(套餐)： 200W 像素(实际使用 30W)，0V2640 型号 M12 摄像头 TF 卡槽： 多媒体资源扩展，支持大容量储存 ### 引脚资源 ![](./../../assets/hardware/maix_bit/maixbit_pin_maps.svg) ## 资料下载 Sipeed Maix Bit 资料[下载](https://dl.sipeed.com/shareURL/MAIX/HDK/Sipeed Maix Bit/Maix Bit_V2.0_with_MEMS_microphone) Sipeed Maix Bit 规格书[下载](https://dl.sipeed.com/fileList/MAIX/HDK/Sipeed Maix Bit/Specifications/Sipeed%20Maix Bit%20%E8%A7%84%E6%A0%BC%E4%B9%A6%20V2.0.pdf) Sipeed Maix Bit 原理图[下载](https://dl.sipeed.com/fileList/MAIX/HDK/Sipeed Maix Bit/Maix Bit_V2.0_with_MEMS_microphone/Maix Bit_V2.0_Schematic.pdf)"},"/soft/maixpy/zh/develop_kit_board/maix_cube.html":{"title":"MaixCube","content":" title: MaixCube keywords: maixpy, k210, AIOT, 边缘计算, MaixCube desc: maixpy MaixCube ## 概述 SIPEED **MaixCube** 可开发编程学习套件, MaixCube 在硬件上集成 30W 摄像头、可扩展 TF 卡槽、用户按键、IPS 1.3 寸显示屏、200mAh 锂电池、扬声器,麦克风、SPMOD,GROVE 扩展接口等。 软件上 MaixCube 默认搭载 MaixPy, 用户可以非常轻松的使用 MicroPython 语法快速上手 AI IoT 开发，开发人脸识别，物体识别等 AI 应用，同时还预留开发调试接口，也能将其作为一款功能强大的 AI 学习开发板。 ## 外观及功能介绍 ### 外观一览 ![Maix Cube](../../assets/hardware/maix_cube/maixcube_product_appearance.png) ### 板载功能 项目 说明 CPU： 双核 64bit RISC V / 400MHz (双精度FPU集成) 内存： 8MiB 64bit 片上 SRAM 存储： 16MiB Flash, 支持 micro SDXC 拓展存储 (最大128GB) 屏幕： 1.3 寸 **IPS** 屏幕：分辨率 **240*240** 摄像头： 搭载 **0V7740** **30W** 像素 **Sensor** 按键： 复位按键，电源按键（短按开机，长按 *8S* 关机），三向按键 USB： Type C 接口，正反盲插 音频： 支持音频录制，播放，驱动 IC（ES8374） 板载传感器： 三轴加速度传感器（MSA301） 灯： 板载两颗 RGB LED，一颗闪光灯 TF 卡槽： 多媒体资源扩展，支持大容量储存 电源管理： AXP173 控制单元，200mAh 锂电池，支持用户充放电控制 ### 引脚资源 ![Maix Cube](../../assets/hardware/maix_cube/maixcube_resources.png) ### 板载扩展接口 Maix Cube 对用户开放了两种高度扩展的接口：一个 [SP MOD](../modules/sp_mod/index.html) 与 一个 [Grove](./../modules/grove/index.html) 接口，用户可以很方便的进行 DIY ### 板载 I2C 设备 MaixCube 板载 I2C 传感器/IC IC 设备 id I2C 地址(7位地址) MaixPy 读取地址 示例代码 ES8374 0x08 0x10 D(16) [code](https://github.com/sipeed/MaixPy v1_scripts/blob/79a5485ec983e67bb8861305a52418b29e0dc205/modules/others/es8374/es8374.py) MSA301 0x13 0x26 D(38) [code](https://github.com/sipeed/MaixPy v1_scripts/blob/7fea2359a7f0c05f586be915aa8e6112262e0caa/multimedia/gui/maixui/msa301.py) AXP173 0x68 0x34 D(52) [code](https://github.com/sipeed/MaixPy v1_scripts/blob/7fea2359a7f0c05f586be915aa8e6112262e0caa/multimedia/gui/maixui/pmu_axp173.py) ## 上手把玩 由于 MaixCube 出厂自带 GUI 演示界面和示例程序，所以在拿到板子时可以先上手把玩下预设程序， 在之后那么我们就开始以 MaixCube 上手，借助 MaixPy 入门 AIoT. 而在开发之前我们需要了解并准备相关工具，以减少我们后边因为准备不足而走的坑路 上手步骤: 1. 下载需要的驱动，软件 2. 开发板连接电脑，并安装 USB 驱动 3. 更新最新固件 4. 下载并打开最新的 MaixPy IDE 5. MaixPy IDE 连接开发板 运行 MaixPy 示例程序 ### 软硬件准备 硬件准备: **电脑**一台 **MaixCube** 开发板 **可靠**的 USB Type C 数据线一条：注意一定要**可靠**的数据线 软件准备: USB 驱动：[点我](https://dl.sipeed.com/shareURL/MAIX/tools/driver) Kflash_gui：[https://dl.sipeed.com/shareURL/MAIX/tools/kflash_gui](https://dl.sipeed.com/shareURL/MAIX/tools/kflash_gui) MaixPy IDE ：[https://dl.sipeed.com/shareURL/MAIX/MaixPy/ide/_/v0.2.5](https://dl.sipeed.com/shareURL/MAIX/MaixPy/ide/_/v0.2.5) 例程程序库：[https://github.com/sipeed/MaixPy v1_scripts](https://github.com/sipeed/MaixPy v1_scripts) ### 安装驱动 我们在拿到 Maix Cube 并连接到电脑的时候，可以打开设备管理器查看串口驱动是否已经安装，打开设备管理器的方法有: 此电脑(右键) > 属性 > 设备管理器 开始菜单(右键) > 设备管理器 控制面板 > (搜索)设备管理器 <img src \"../../assetcs/../assets/get_started/win_device_1.png\" height \"400\"> 1. 当我们的系统是 Win10 系统，系统则会帮我们自动安装驱动，而如果是旧版 Win7，win8 系统我们就需要自己手动安装: ![](../../assetcs/../assets/get_started/win_device_2.png) 1. 打开上一节的的链接下载驱动 ![](../../assetcs/../assets/get_started/win_device_3.png) 1. 点击安装 ![](../../assets/get_started/drives.gif) 1. 安装完成之后，可以在设备管理器看到已经识别到两个串口设备了 ![](../../assetcs/../assets/get_started/win_device_4.png) ### 更新固件到最新版 用户拿到开发板之后，板载的固件默认或许已经不是最新版的，那么在使用过程中会存在或多或少的 bug， 我们这时候就需要更新固件版本到最新版本 更新方法查看：[更新固件](../get_started/upgrade_maixpy_firmware.html) ### 运行第一个程序 `Hello World` LCD 实时预览 Camera（使用 MaixPy IDE 连接时型号选择 Maixduino 即可） ```python import sensor, image, time, lcd sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.skip_frames(time 2000) sensor.set_hmirror(1) sensor.set_vflip(1) clock time.clock() lcd.init(type 2) lcd.rotation(2) while(True): clock.tick() img sensor.snapshot() print(clock.fps()) img.draw_string(60, lcd.height() 120, \"fps:\"+str(clock.fps()), lcd.GREEN, scale 2) lcd.display(img) ``` ## 资料下载 Sipeed Maix Cube 资料下载：[Sipeed Maix Cube](https://dl.sipeed.com/shareURL/MAIX/HDK/Sipeed Maix Cube) Sipeed Maix Cube 规格书下载：[Sipeed Maix Cube](https://dl.sipeed.com/shareURL/MAIX/HDK/Sipeed Maix Cube/ProductSpecification/Sipeed%20Maix%20Cube%20Datasheet%20V1.0.pdf) Sipeed Maix Cube 原理图下载：[Sipeed Maix Cube](https://dl.sipeed.com/shareURL/MAIX/HDK/Sipeed Maix Cube/Maix Cube 2757/Maix Cube 2757%28Schematic%29.pdf)"},"/soft/maixpy/zh/develop_kit_board/grove_ai_hat.html":{"title":"Grove AI HAT","content":" title: Grove AI HAT keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy Grove AI HAT ## 外观及功能介绍 ### 外观一览 ![Grove AI HAT](../../assets/hardware/grove_ai_hat/grove_ai_hat1.png) ### 板载功能 项目 说明 CPU： 双核 64bit RISC V / 400MHz (双精度FPU集成) 内存： 8MiB 64bit 片上 SRAM 存储： 16MiB Flash 屏幕（套餐）： 2.4 寸 TFT, 电容触摸屏幕分辨率：320\\*240 摄像头（套餐）： 搭载 **OV7740** 或 **OV5642** **30W** 像素 **Sensor** 按键： 复位按键，电源按键（短按开机，长按 *8S* 关机） USB： Type C 接口，正反盲插 板载传感器： 三轴加速度传感器（ADXL345BCCZ RL），ADC（ADS1115IDGS） ### 硬件板载扩展接口 该开发版对用户开放了四个 [Grove](https://cn.maixpy.sipeed.com/zh/modules/grove/) 接口,用户可以很方便的进行 DIY。 ### 板载 I2C 设备 传感器 功能 I2C 地址(7位地址) SCL SDA 示例代码 ADS1115 ADC 0x48 IO23 IO24 [script](https://github.com/sipeed/MaixPy v1_scripts/tree/master/modules/others/ads1115) ADXL345 三轴加速度计 0x53 IO23 IO24 [script](https://github.com/sipeed/MaixPy v1_scripts/tree/master/modules/others/adxl345) ## 资源下载 [原理图](http://dl.sipeed.com/fileList/MAIX/HDK/Sipeed Grove_AI_HAT/Grove_AI_HAT_for_Edge_Computing_v1.0_SCH_190514.pdf)"},"/soft/maixpy/zh/develop_kit_board/core_k210.html":{"title":"K210 模块核心板","content":" title: K210 模块核心板 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy K210 模块核心板 ![K210](./../../assets/hardware/k210/k210 front background.jpg) Kendryte K210 是集成机器视觉与机器听觉能力的系统级芯片 (SoC) .使用台积电 (TSMC) 超低功耗的 28 纳米先进制程,具有双核 64 位处理器,拥有较好的功耗性能,稳定性与可靠性. 该方案力求零门槛开发,可在最短时效部署于用户的产品中,赋予产品人工智能. Kendryte K210 定位于 AI 与 IoT 市场的 SoC ,同时是使用非常方便的 MCU . Kendryte 中文含义为**勘智**,而勘智取自勘物探智.这颗芯片主要应用领域为物联网领域,在物联网领域进行开发,因此为勘物;这颗芯片主要提供的是人工智能解决方案,在人工智能领域探索,因此为探智. 具备机器视觉能力 具备机器听觉能力 更好的低功耗视觉处理速度与准确率 具备卷积人工神经网络硬件加速器 KPU ,可高性能进行卷积人工神经网络运算 TSMC 28nm 先进制程,温度范围 40°C 到 125°C ,稳定可靠 支持固件加密,难以使用普通方法破解 独特的可编程 IO 阵列,使产品设计更加灵活 低电压,与相同处理能力的系统相比具有更低功耗 3.3V/1.8V 双电压支持,无需电平转换,节约成本 1. AI 解决方案 ## 1.1. 机器视觉 Kendryte K210 具备机器视觉能力,是零门槛机器视觉嵌入式解决方案.它可以在低功耗情况下进行卷积神经网络计算. 该芯片可以实现以下机器视觉能力: 基于卷积神经网络的一般目标检测 基于卷积神经网络的图像分类任务 人脸检测和人脸识别 实时获取被检测目标的大小与坐标 实时获取被检测目标的种类 1.2. 机器听觉 Kendryte K210 具备机器听觉能力.芯片上自带高性能麦克风阵列音频处理器,可以进行实时声源定向与波束形成. 该芯片可以实现以下机器听觉能力: 声源定向 声场成像 波束形成 语音唤醒 语音识别 1.3. 视觉 / 听觉混合解决方案 Kendryte K210 可结合机器视觉和机器听觉能力,提供更强大的功能.一方面,在应用中既可以通过声源定位和声场成像辅助机器视觉对目标的跟踪,又可以通过一般目标检测获得目标的方位后辅助机器听觉对该方位进行波束形成.另一方面,可以通过摄像头传来的图像获得人的方向后,使得麦克风阵列通过波束形成指向该人.同时也可以根据麦克风阵列确定一个说话人的方向,转动摄像头指向该人. 2. 资料下载 Kendryte 官网下载页面 其中必看的有 datasheet Kendryte Github"},"/soft/maixpy/zh/develop_kit_board/maix_duino.html":{"title":"MaixDuino","content":" title: MaixDuino keywords: maixpy, k210, AIOT, 边缘计算, MaixDuino desc: maixpy MaixDuino ## 概述 SIPEED MaixDuino 是基于我们 M1 模块(主控:Kendryte K210)开发的一款外形兼容 Arduino 的开发板 <br/>MaixDuino 集成摄像头、TF卡槽、用户按键、TFT显示屏、MaixDuino 扩展接口等, 用户可使用 MaixDuino 轻松搭建一款人脸识别门禁系统, 同时还预留开发调试接口, 也能将其作为一款功能强大的 AI 学习开发板. ## 外观及功能介绍 ### 外观一览 ![MaixDuino](../../assets/hardware/maix_duino/maixduino_4.png) ### 板载功能 项目 说明 CPU： 双核 64bit RISC V / 400MHz* (双精度FPU集成) 内存： 8MiB 64bit 片上 SRAM 存储： 16MiB Flash, 支持 micro SDXC 拓展存储 (最大128GB) 屏幕（套餐）： 2.4 寸 TFT, 屏幕分辨率：320\\*240 摄像头（套餐）： 30W 像素 GC0328 摄像头 DVP： 标准 Camera DVP 24PIN 接口 电源+USB： USB Type C 接口 ESP32： ESP32 SPI 连接(ESP32 支持 WIFI 与 蓝牙)，PAM8403A DAC： I2C DAC TF 卡槽： 多媒体资源扩展，支持大容量储存 ### 引脚资源 ![MaixDuino](../../assets/hardware/maix_duino/sipeed_maixduin_pins.png) ## 资料下载 Sipeed Maix Duino 资料下载：[Sipeed Maix Duino](https://dl.sipeed.com/shareURL/MAIX/HDK/Sipeed Maixduino/) Sipeed Maix Duino 规格书下载：[Sipeed Maix Duino](https://dl.sipeed.com/shareURL/MAIX/HDK/Sipeed Maixduino/Specifications) Sipeed Maix Duino 原理图下载：[Sipeed Maix Duino][Sipeed Maix Duino] [Sipeed Maix Duino]: https://dl.sipeed.com/fileList/MAIX/HDK/Sipeed Maixduino/Maixduino_2832/Maixduino_2832(Schematic).pdf"},"/soft/maixpy/zh/develop_kit_board/get_hardware.html":{"title":"如何选购开发板","content":" title: 如何选购开发板 keywords: maixpy, k210, AIOT, 边缘计算, Maix开发板 desc: maixpy 如何选购开发板 要开始使用 MaixPy, 必须需要一款 K210 开发板, 可以从 Sipeed 官方淘宝店获得心仪的硬件： [Sipeed 官方淘宝店](https://sipeed.taobao.com/) ## 需要的硬件 ### 一款开发板 由于 MaixPy 早期产品线比较多，具体开发板及参数列表如下，用户可以根据自己的动手能力和需求选购对应开发板 > MaixPy 系类开发板板载的 ROM 均为 16MB SPI FLASH, RAM: 6MB(通用) + 2MB(KPU 专用) <table border \"2\"> <tr> <th colspan 3>MaixPy 系列开发板</th> </tr> <tr> <td>描述</td> <td>实物图</td> <td>说明</td> </tr> <td>Maix Amigo</td> <td> <img src \"../../assets/hardware/maix_amigo/sipeed_maix_amigo_400x400.jpg\" height \"200\"> </p><a href \"https://sipeed.taobao.com/\">点击购买 Maix Amigo</a> </td> <td>3.5寸 大屏幕， 预留三个 Grove 接口，三个 SPMOD 接口(其中一个为游戏手柄接口)</td> <tr> <td>Maix Cube</td> <td> <img src \"../../assets/hardware/maix_cube/sipeed_maix_cube_400x400.jpg\" height \"200\"> </p><a href \"https://sipeed.taobao.com/\">点击购买 Maix Cube</a> </td> <td>迷你开发板，引出 Grove/Spmod 接口</td> </tr> <tr> <td>Maix Dock(M1W)</td> <td> <img src \"../../assets/hardware/maix_dock/sipeed_maix_dock_m1w.jpg\" height \"200\"> </p><a href \"https://sipeed.taobao.com/\">点击购买 Maix Dock(M1W)</a> </td> <td>全引脚引出，采用 M1W 模块 (内部集成 ESP8285)</td> </tr> <tr> <td>Maix Dock(M1)</td> <td> <img src \"../../assets/hardware/maix_dock/sipeed_maix_dock_m1.jpg\" height \"200\"> </p><a href \"https://sipeed.taobao.com/\">点击购买 Maix Dock(M1)</a> </td> <td>全引脚引出，采用 M1 模块 </td> </tr> <tr> <td>Maix Bit</td> <td> <img src \"../../assets/hardware/maix_bit/sipeed_maix_bit_400x400.jpg\" height \"200\"> </p><a href \"https://sipeed.taobao.com/\">点击购买 Maix Bit</a> </td> <td>全引脚引出，2x20pin，最小系统板</td> </tr> <tr> <td>Maix Duino</td> <td> <img src \"../../assets/hardware/maix_duino/sipeed_maix_duino_400x400.jpg\" height \"200\"> </p><a href \"https://sipeed.taobao.com/\">点击购买 Maix Duino</a> </td> <td>兼容 Arduino，支持 ESP32 WIFI，支持 ESP32 5个 ADC 通道的读取</td> </tr> <tr> <td>Grove AI HAT</td> <td> <img src \"../../assets/hardware/grove_ai_hat/grove_ai_hat.jpg\" height \"200\"></br> </p><a href \"https://sipeed.taobao.com/\">点击购买 Grove AI HAT</a> </td> <td>板载加速度计和高精度 ADC, 引出多个 Grove/Spmod 接口, 可用作树莓派配件</td> </tr> <tr> <td>Maix GO</td> <td> <img src \"../../assets/hardware/maix_go/sipeed_maix_go_400x400.jpg\" height \"200\"> </p><a href \"https://sipeed.taobao.com/\">点击购买 Maix GO</a> </td> <td>售罄</td> </tr> <tr> <td>Maix Nano</td> <td> <img src \"../../assets/hardware/m1n/sipeed_maix_m1n_400x400.jpg\" height \"200\"></br> <img src \"../../assets/hardware/m1n/sipeed_maix_nano_400x400.jpg\" height \"200\"> </p><a href \"https://sipeed.taobao.com/\">点击购买 Maix Nano</a> </td> <td>核心开发板</td> </tr> </table> ### USB Type C 连接线 <img src \"../../assets/hardware/other/usb_type_c.png\" height \"300\" alt \"type_c\"> 选用 Type C 是因为它支持正反插，对开发十分友好 从淘宝官方购买可以询问是否附送，目前大部分安卓机也在使用 Type C 连接线 > **USB 数据线注意点：** 由于市面上的 USB 线质量良莠不齐，采用的线材（主要是线芯材质）不同，好一点的数据线采用 镀锡铜、铜丝、铜箔丝、裸铜等,线阻小,数据线两端压降小，而差一点的有铜包钢，铜包铁,线阻大,数据线两端压降大，造成实际供给开发板的电压，电流过小，使开发板处于非正常工作状态；所以建议选用质量可靠的数据线（一般手机附送的数据线质量都是比较可靠的） ### 屏幕 **屏幕强烈建议购买!** 从淘宝官方购买可以询问是否包含, 推荐用户购买带 LCD 的板子或者套餐,方便后续运行程序时结果的直观展示, 板型 屏幕驱动 IC 支持分辨率 备注 Maix Cube(IPS) ST7789 240\\*240 Maix Amigo ILI9486 320\\*480 Maix Amigo(IPS 版) ILI9486 320\\*480 Maix Nano(不带屏幕) Maix Dock ST7789 320\\*240 Maix Bit ST7789 320\\*240 Maix Dock ST7789 320\\*240 Maix Go ST7789 320\\*240 Grove AI HAT ST7789 320\\*240 ### 摄像头 在售的有：OV2640（常规，M12）、OV7740、GC0328； 由于 K210 DVP 接口支持的分辨率为 VGA（640*480 30W）， 所以实际使用选取 30W 像素的摄像头即可。 截至 MaixPy 固件版本: `MaixPy 0.6.2_54` ,支持的摄像头型号如下表 型号 设备 id 像素 说明 备注 OV2640 0x2642 200W 支持度较好 OV7740 0x7742 30W 支持度较好 OV3660 0x3660 300W 兼容运行 GC0328 0x9d 30W 支持度较好 GC2145 0x2145 200W 兼容运行 MT9D111 0x1519 200W 可以运行，支持不完整 OV5640 0x5640 500W 支持度较好 OV5642 0x5642 500w 支持度较好 截止至固件版本 `MaixPy 0.6.2_54` 相关摄像头测试情况如下: 硬件型号 测试通过的单目或双目摄像头 M1/M1W 模组系列（Maixduino、Dock、Go） OV2640、GC0328、OV7740、GC2145、OV5640、OV5642 M1n 模组系列（Nano、Cube） OV2640、GC0328、OV7740、GC2145、OV5640、OV5642 MaixBit OV2640、GC0328、OV7740、GC2145、OV5640、OV5642 Maix Amigo OV7740（后摄）、GC0328（前摄） 目前摄像头的颜色模式 YUV422 RGB565 & YUV422 OV2640 OV5640 OV7740 GC2145 GC0328 OV5642 从淘宝官方购买可以询问型号, OV7740 帧率相对高一点; OV2640 比较古老, 画质稍不如 GC0328 > 注：很多用户一上来就问哪款支持的帧率最高，其实帧率除了硬件上会有差异，而且在你使用的程序，由于程序的处理流程不同，帧率也是会有差异的，所以这里无法标注（以免误导用户）具体最高帧率。目前来说别的摄像头是没有对应的驱动程序，需要的可以自己进行编写。 ### Micro SD 卡 (TF 卡) (可选) 不使用 Micro SD 卡也是可以操作文件的, 在内部 Flash 上已经保留一部分来作为文件系统了, 只是 Flash 速度很慢！ 为了方便图片文件快速操作, 可以选择购买一张 `Micro SD` 卡, 　 MaixPy　内置了 SPI SD卡协议驱动, 购买时尽量选择速度快协议新的 Micro SD 卡, 比如 SD 2代协议, Class10 的内存卡 因为 K210 没有 SDIO 硬件外设, 所以使用了 SPI 来与 SD 卡通信, 当然, 市面上的 SD 卡品质参差不齐, SPI 模式不一定都能兼容, 尽量买正规的卡, 实在有需求请自行定制驱动～～ 比如：下图左边两张卡 MaixPy 的驱动不支持, 中间和右边的都支持, 但是中间的 class10 卡速度最快(最高测过 128GB可用) > 另外测试过网上购买的几张闪迪、金士顿、三星的卡, 其中发现有一张三星的卡无法使用 ![TF SDCard](../../assets/hardware/other/tf_sdcard.png) [**Sipeed 官方店 SD 卡购买链接**](https://item.taobao.com/item.htm?spm a1z10.5 c.w4002 21231188711.12.5a7f7379ZEhEdC&id 587713418483)，该卡 SPI 协议只支持 V1 版本， 所以读取速率较低，建议购买其他支持 SPI V2 协议的 SD 卡，淘宝店开发板套餐中可以单选 SD 卡。 ### ST Link (用来给开发板 Maix Go 上的 STM32 更新固件) (可选) 如果购买的是 `Maix Go`, 上面集成了一颗 `STM32` 芯片, 用来模拟 `USB转串口` 工具, 以及模拟 `JTAG`, 如果想后期自行更新其固件, 建议购买一个 `ST Link` 备用; 如果不需要`JTAG` 功能可以不用购买 ### JTAG 调试器 (可选) **注意：** **!!! 烧录过 key_gen.bin 之后将永久禁用 K210 的 JTAG 调试功能** `K210` 这款芯片支持 `JTAG` 调试, 如果需要调试功能, 需要使用 `JTAG` 调试器, 请在 `Sipeed` 官方淘宝店咨询购买。 如果是 `Maix Go` 开发板, 可以不用另外购买 `JTAG` 调试器, `Maix Go` 开发板上面集成了一个 `STM32`芯片, 可以模拟 `JTAG`(`STM32` 使用 `CMSIS DAP` 或者 `open ec` 固件), `open ec` 固件目前还不支持, 后续会支持, 请以 `open ec` github 项目主页说明为准"},"/soft/maixpy/zh/develop_kit_board/maix_nano.html":{"title":"Maix Nano","content":" title: Maix Nano keywords: maixpy, k210, AIOT, 边缘计算, Maix Nano desc: maixpy Maix Nano ## 外观及功能介绍 ### 外观一览 ![Maix Nano](../../assets/hardware/m1n/sipeed_maix_nano.png) ### 板载功能 项目 说明 CPU： 双核 64bit RISC V / 400MHz* (双精度FPU集成) 内存： 8MiB 64bit 片上 SRAM 存储： 16MiB Flash, 支持 micro SDXC 拓展存储 (最大128GB) 屏幕： 无屏幕 摄像头（套餐）： 30W 像素 GC0328 摄像头 ### 硬件板载扩展接口 Maix Nano 预留了一个 [SP_MOD](../modules/sp_mod/index.html) 接口 ## 资料下载 * M1n 资料下载：[dl.sipeed.com](https://dl.sipeed.com/shareURL/MAIX/HDK/Sipeed M1n) * M1n 原理图下载：[Sipeed M1n Datasheet V1.0.pdf](https://dl.sipeed.com/fileList/MAIX/HDK/Sipeed M1n/Sipeed%20M1n%20Datasheet%20V1.0.pdf)"},"/soft/maixpy/zh/develop_kit_board/maix_amigo.html":{"title":"MaixAmigo","content":" title: MaixAmigo keywords: maixpy, k210, AIOT, 边缘计算, MaixAmigo desc: maixpy MaixAmigo ## 概述 SIPEED **MaixAmigo** 可开发编程学习套件, MaixAmigo 在硬件上集成前后各 30W 像素摄像头、可扩展 TF 卡槽、用户按键、3.5‘TFT 寸显示屏、520mAh 锂电池、扬声器,麦克风、SPMOD,GROVE 扩展接口等。 软件上 MaixAmigo 默认搭载 MaixPy, 用户可以非常轻松的使用 MicroPython 语法快速进行人脸识别、物体分类等多种 AIoT 开发，同时还预留开发调试接口，也能将其作为一款功能强大的 AI 学习开发板。 ## 外观及功能介绍 ### 外观一览 ![MaixAmigo](../../assets/hardware/maix_amigo/maix_amigo_0.png) ### 板载功能 项目 说明 CPU： 双核 64bit RISC V / 400MHz* (双精度FPU集成) 内存： 8MiB 64bit 片上 SRAM 存储： 16MiB Flash, 支持 micro SDXC 拓展存储 (最大128GB) 屏幕： 3.5寸 TFT 显示屏, 分辨率：320\\*480, 支持电容触摸(FT6X36) 摄像头： OV7740 (后摄)与GC0328(前摄) 各 30W 像素(最大分辨率 VGA:640\\*480) 灯： 三颗单色 LED 灯，一颗闪光灯 电池： 板载可充电锂聚合物电池 (容量520mAh ) 板载扬声器与麦克风 集成单音频控制器 ES8374 1W 8Ω 扬声器 板载接口： USB C \\*2 (K210 调试供电接口+兼容 STM32 核心板 USB 接口) 板载传感器: MSA301 三轴加速度传感器 TF 卡槽： 多媒体资源扩展，支持大容量储存 电池: 520mAh 锂电池 ### 引脚资源 ![MaixAmigo](../../assets/hardware/maix_amigo/sipeed_maix_amigo_vi.jpg) ### 硬件板载扩展接口 MaixAmigo 对用户开放了两种高度扩展的接口：三个 [SP MOD](./../modules/sp_mod/index.html) 与 三个 [Grove](./../modules/grove/index.html) 接口,用户可以很方便的进行 DIY。 ### 板载 I2C 设备 MaixAmigo 板载 I2C 传感器/IC IC 设备 id I2C 地址(7位地址) MaixPy 读取地址 示例代码 ES8374（音频解码芯片） 0x08 0x10 D(16) [code](https://github.com/sipeed/MaixPy v1_scripts/blob/79a5485ec983e67bb8861305a52418b29e0dc205/modules/others/es8374/es8374.py) MSA301（三轴加速计） 0x13 0x26 D(38) [code](https://github.com/sipeed/MaixPy v1_scripts/blob/7fea2359a7f0c05f586be915aa8e6112262e0caa/multimedia/gui/maixui/msa301.py) AXP173（电源管理芯片） 0x68 0x34 D(52) [code](https://github.com/sipeed/MaixPy v1_scripts/blob/7fea2359a7f0c05f586be915aa8e6112262e0caa/multimedia/gui/maixui/pmu_axp173.py) ## 上手把玩 MaixAmigo 同样使用 MaixPy 入门 AIoT ，由于硬件特殊性，请在[配置 amigo 硬件](https://github.com/sipeed/MaixPy v1_scripts/blob/master/board/config_maix_amigo.py) 后再使用 MaixPy （如果不配置会导致摄像头拍摄的照片有噪点）。 而在开发之前我们需要了解并准备相关工具，以减少我们后边因为准备不足而走的坑路 上手步骤: 1. 下载需要的驱动，软件 2. 开发板连接电脑，并安装 USB 驱动 3. 更新最新固件 4. 下载并打开最新的 MaixPy IDE 5. MaixPy IDE 连接开发板 运行 MaixPy 示例程序 ### 软硬件准备 硬件准备: **电脑**一台 **MaixAmigo** 开发板 **可靠**的 USB Type C 数据线一条：注意一定要**可靠**的数据线 软件准备: USB 驱动：[点我](https://dl.sipeed.com/shareURL/MAIX/tools/driver) Kflash_gui：[https://dl.sipeed.com/shareURL/MAIX/tools/kflash_gui](https://dl.sipeed.com/shareURL/MAIX/tools/kflash_gui) MaixPy IDE ：[https://dl.sipeed.com/shareURL/MAIX/MaixPy/ide/_/v0.2.5](https://dl.sipeed.com/shareURL/MAIX/MaixPy/ide/_/v0.2.5) 例程程序库：[https://github.com/sipeed/MaixPy v1_scripts](https://github.com/sipeed/MaixPy v1_scripts) ### 安装驱动 我们在拿到 Maix Amigo 并连接到电脑的时候，可以打开设备管理器查看串口驱动是否已经安装，打开设备管理器的方法有: 此电脑(右键) > 属性 > 设备管理器 开始菜单(右键) > 设备管理器 控制面板 > (搜索)设备管理器 <img src \"../../assets/get_started/win_device_1.png\" height \"400\"> 1. 当我们的系统是 Win10 系统，系统则会帮我们自动安装驱动，而如果是旧版 Win7，win8 系统我们就需要自己手动安装: ![](../../assets/get_started/win_device_2.png) 1. 打开上一节的的链接下载驱动 ![](../../assets/get_started/win_device_3.png) 1. 点击安装 ![](../../assets/get_started/drives.gif) 1. 安装完成之后，可以在设备管理器看到已经识别到两个串口设备了 ![](../../assets/get_started/win_device_4.png) ### 更新固件到最新版 用户拿到开发板之后，板载的固件默认或许已经不是最新版的，那么在使用过程中会存在或多或少的 bug， 我们这时候就需要更新固件版本到最新版本 更新方法查看：[更新固件](../get_started/upgrade_maixpy_firmware.html) **若使用 amigo 开发板，请烧录大于或等于 v0.6.2_12 版本的专用 amigo 固件（例如：maixpy_v0.6.2_12_gf18990aa3_amigo_tft(ips)_xxxx.bin），它与标准 maixpy 固件的差异在于其内置了 amigo 硬件的配置（config.json），并且屏幕类型分为 ips 和 tft ，烧录任意屏幕类型固件都是可以启动的，但不同屏幕的显示会不正常（正常的是红色的 maixpy 欢迎页），所以根据实际情况都可以烧录一遍确认。** ### 运行第一个程序 `Hello World` LCD 实时预览 Camera（使用 MaixPy IDE 连接时型号选择 Maixduino 即可） ```python # * coding：UTF 8 * import sensor, image, time, lcd from fpioa_manager import fm # lcd.init(freq 20000000) while True: try: sensor.reset(choice 1) sensor.set_pixformat(sensor.YUV422) sensor.set_framesize(sensor.QVGA) sensor.skip_frames(time 2000) for i in range(100): img sensor.snapshot() lcd.display(img) except Exception as e: print(e) try: sensor.reset(choice 2) sensor.set_pixformat(sensor.YUV422) sensor.set_framesize(sensor.QVGA) sensor.skip_frames(time 2000) for i in range(100): img sensor.snapshot().rotation_corr(z_rotation +90) lcd.display(img) except Exception as e: print(e) ``` ## 资料下载 Maix Amigo 资料下载：[Sipeed Amigo](https://dl.sipeed.com/shareURL/MAIX/HDK/Sipeed Amigo) Maix Amigo 规格书下载：[Sipeed Amigo](https://dl.sipeed.com/shareURL/MAIX/HDK/Sipeed Amigo/ProductSpecification) Maix Amigo IPS 版本 原理图下载：[Maix_Amigo_2970(Schematic).pdf][Maix_Amigo_2970(Schematic).pdf] Maix Amigo TFT 版本 原理图下载：[Maix_Amigo_2960(Schematic).pdf][Maix_Amigo_2960(Schematic).pdf] [Maix_Amigo_2970(Schematic).pdf]: https://dl.sipeed.com/fileList/MAIX/HDK/Sipeed Amigo/2970/Maix_Amigo_2970(Schematic).pdf [Maix_Amigo_2960(Schematic).pdf]: https://dl.sipeed.com/fileList/MAIX/HDK/Sipeed Amigo/2960/Maix_Amigo_2960(Schematic).pdf"},"/soft/maixpy/zh/develop_kit_board/develop_kit_board.html":{"title":"MaixPy 系列开发板","content":" title: MaixPy 系列开发板 keywords: maixpy, k210, AIOT, 边缘计算, Maix开发板 desc: maixpy MaixPy 系列开发板 ## MaixPy 开发板 目前 MaixPy 系类开发板有一下这几款型号: Maix Go Maix Dock Maix Duino Maix Bit Maix Cube Maix Amigo ## 差异对比 型号 USB IC 核心模块 备注 Maix Go <img src \"../../assets/dk_board/maix_go/Go.jpg\" width \"260\"> Maix Go STM32 M1W Maix Dock <img src \"../../assets/dk_board/maix_dock/Dan_Dock.png\" width \"260\"> CH340 M1/M1W Maix Duino <img src \"../../assets/dk_board/maix_duino/maixduino_0.png\" width \"260\"> CH552 M1 Maix Bit <img src \"../../assets/dk_board/maix_bit/BiT.png\" width \"260\"> CH552/CH340 Maix Cube <img src \"../../assets/dk_board/maix_cube/maixcube_2020 06 13_06 31 29.png\" width \"260\"> GD32/CH552 M1n Maix Amigo <img src \"\" width \"260\"> GD32 M1n "},"/soft/maixpy/zh/develop_kit_board/core_module.html":{"title":"Sipeed M1/M1W (Lichee Dan)","content":" title: Sipeed M1/M1W (Lichee Dan) keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy Sipeed M1/M1W (Lichee Dan) 1. M1/M1W ![M1/M1W](./../../assets/hardware/m1_m1w/M1_Dan.png) ![M1/M1W](./../../assets/hardware/m1_m1w/M1_pin.png) M1: K210全引脚引出, 芯片内置 8M SRAM, 模块内置 16M Flash M1W 是带 WiFi(esp8285) 版本 模组 WIFI FLASH SRAM 说明 M1 无 16MiB 8MiB M1W ES8285 16MiB 8MiB M1n 无 16MiB 8MiB 1. M1n ![M1n](./../../assets/hardware/m1n/M1n.png) M1n 核心模块采用了 M.2 的金手指接口，并板载了24Pin 的 FPC 底座, 相对于 M1/M1W 可以让用户很方便的将 K210 快速集成到自己的创意或者商业产品中. 1. 资料下载 芯片 K210 Datasheet: Kendryte 官网 M1n 资料下载: [dl.sipeed.com](https://dl.sipeed.com/shareURL/MAIX/HDK/Sipeed M1n) M1n 原理图下载：[Sipeed M1n Datasheet V1.0.pdf](https://dl.sipeed.com/fileList/MAIX/HDK/Sipeed M1n/Sipeed%20M1n%20Datasheet%20V1.0.pdf)"},"/soft/maixpy/zh/develop_kit_board/module_microphone.html":{"title":"Sipeed Microphone","content":" title: Sipeed Microphone keywords: maixpy, k210, AIOT, 边缘计算, Sipeed Microphone desc: maixpy Sipeed Microphone <table border \"2\"> <tr> <th colspan 3>Sipeed 麦克风模块</th> </tr> <tr> <td>描述</td> <td>实物图</td> <td>说明</td> </tr> <td> 单麦克风模块 </td> <td> <img src \"../../assets/hardware/module/microphone_taobao_400x400.jpg\" height \"200\"> </p> <a href \"https://sipeed.taobao.com/\">点击购买 麦克风模块</a> </td> <td> 1.麦克风 IC: MSM261S4030H0</p> 2.接口：6P 2.54mm 排线接口</p> 3.供电电压：3.3V@5mA</p> 4.模块尺寸：15.2mm*9.1mm</p> 4.工作温度: 30℃~80℃</p> <tr> <tr> <td> 单麦克风模块 </td> <td> <img src \"../../assets/hardware/module/mic_array_taobao.jpg\" height \"200\"> </p> <a href \"https://sipeed.taobao.com/\">点击购买 麦克风模块</a> </td> <td> 1.麦克风 IC: 7 个 MSM261S4030H0</p> 2.接口：10Pfpc / 10 pin 2.54mm 排线接口</p> 3.供电电压：5V@mA</p> 4.模块尺寸：15.2mm*9.1mm</p> 4.工作温度: 30℃~80℃</p> </tr> </table> ## Sipeed Mic Array Mic Array 麦克风阵列，截止 MaixPy 版本 `MicroPython v0.5.0 218 g8053a70`, 麦克风阵列硬件上的 pin io 支持自定义配置。 更详细的信息建议前往: [这里](https://wiki.sipeed.com/hardware/zh/modules/micarray.html?highlight %E9%BA%A6%E5%85%8B%E9%A3%8E) 查看 No. MaixGo(默认配置 IO) 说明 MIC_D0 23 MIC_D1 22 MIC_D2 21 MIC_D3 20 MIC_WS 19 MIC_SCLK 18 LED_DAT 24 SK9822 DAT LED_CLK 25 SK9822 CLK ### 例程 声源定位 ```python from Maix import MIC_ARRAY as mic import lcd lcd.init() mic.init()#默认配置 # mic.init(i2s_d0 23, i2s_d1 22, i2s_d2 21, i2s_d3 20, i2s_ws 19, i2s_sclk 18, sk9822_dat 24, sk9822_clk 25)#可自定义配置 IO while True: imga mic.get_map() # 获取声音源分布图像 b mic.get_dir(imga) # 计算、获取声源方向 a mic.set_led(b,(0,0,255))# 配置 RGB LED 颜色值 imgb imga.resize(160,160) imgc imgb.to_rainbow(1) # 将图像转换为彩虹图像 a lcd.display(imgc) mic.deinit() ``` 效果： <iframe width \"600\" height \"350\" src \"//player.bilibili.com/player.html?aid 37058760&cid 65120313&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\"> </iframe>"},"/soft/maixpy/zh/develop_kit_board/maix_dock.html":{"title":"Maix Dock","content":" title: Maix Dock keywords: maixpy, k210, AIOT, 边缘计算, Maix Dock desc: maixpy Maix Dock ## 外观及功能介绍 ### 外观一览 MaixDock(M1W) ![MaixDock(M1W)](../../assets/hardware/maix_dock/sipeed_maix_dock_m1w.jpg) MaixDock(M1) ![MaixDock(M1)](../../assets/hardware/maix_dock/sipeed_maix_dock_m1.jpg) ### 板载功能 项目 说明 CPU： 双核 64bit RISC V / 400MHz* (双精度FPU集成) 内存： 8MiB 64bit 片上 SRAM 存储： 16MiB Flash, 支持 micro SDXC 拓展存储 (最大128GB) 屏幕（套餐）： 2.4 寸 TFT, 屏幕分辨率：320\\*240 摄像头（套餐）： 30W 像素 GC0328 摄像头 WIFI： MaixDock(M1W) 采用 M1W（内部集成 ESP8285 WIFI SOC）； MaixDock(M1) 内部无 WIFI 功能 TF 卡槽： 多媒体资源扩展，支持大容量储存 ### 引脚资源 ![](../../assets/hardware/maix_dock/maixdock_pin_maps.svg) ## 资料下载 Sipeed Maix Dock 资料下载：[Sipeed Maix Dock](https://dl.sipeed.com/shareURL/MAIX/HDK/Sipeed Maix Dock) Sipeed Maix Dock 规格书下载：[Sipeed Maix Dock](https://dl.sipeed.com/shareURL/MAIX/HDK/Sipeed Maix Dock/Specifications) Sipeed Maix Dock 原理图下载：[Sipeed Maix Dock](https://dl.sipeed.com/fileList/MAIX/HDK/Sipeed Maix Dock/Maix Dock_11.27/Maix Dock_11.27 schematic.pdf) ## 相关问题 Maix Dock 不能使用 MobaXterm 或其他 不支持手动串口流控制的软件 来进行串口通信。 为了不浪费时间，建议使用 MaixPy 来进行通信。 可以在 MaixPy 顶部菜单栏 工具 >打开终端 >新终端 >连接到串口 >选择正确的串口 >115200波特率 来新建一个终端 ![sipeed_maix_dock_terminal](../../assets/hardware/maix_dock/sipeed_maix_dock_terminal.png)"},"/soft/maixpy/zh/maixpy_history.html":{"title":"MaixPy 发展历程","content":" title: MaixPy 发展历程 keywords: maixpy, k210, AIOT, 边缘计算, 人工智能, 深度学习 desc: maixpy MaixPy 发展历程 写下本篇发展历程， 希望让后来的开发者们了解到 MaixPy 都经历了什么，以及一些重大的改变的原因是什么，以及在何时取得了重大的进步等 代码提交历史可以在 [historic](https://github.com/sipeed/MaixPy v1commits/historic) 和 [master](https://github.com/sipeed/MaixPy v1commits/master) 分支看到 ## 2018 年 9 月 MaixPy 项目启动，契机是 K210 芯片流片完成。 于是大家想着做一套让更多人在嵌入式使用的 AI 开发的易使用的软件套件， 因为 Micropython 的易用性，而且 k210 有 6+2MiB 内存，主频 400MHz，完全能够驾驭 Micropython， 故选择了 Micropython 作为编程语法 基于开发板 Maix dock， 这时取名为 荔枝丹， QQ 群名也叫荔枝丹炼丹群 [xiaohui](https://github.com/xiaoxiaohuixxh) 和 [wipping](https://github.com/wipping) 开始尝试对 Micropython 移植 ## 2018 年 12 月 k210 SDK 从 freertos 换成了 standalone SDK, 并且着手片上外设驱动适配 [neucrack](https://github.com/neutree) ，[xel](https://github.com/xelll) 和 [zepan](https://github.com/Zepan) 加入项目组 ## 2019 年 2 月 发布第一版固件 [v0.1.1 beta](https://github.com/sipeed/MaixPy v1releases/tag/v0.1.1), 支持了基本的外设， 继承了 openmv 的 image sensor lcd API，适配了一些开源的工具比如 upyloader，armpy等, 编写文档 并发布在 maixpy.sipeed.com 另外这时也有了 Maix bit 和 Maix Go 两块新开发板 xiaohui 退出项目组 ## 2019 年 3 月 发布第二版固件 [v0.2.4](https://github.com/sipeed/MaixPy v1releases/tag/v0.2.4), 增加了 jpeg， wav， kpu， nes， avi， lvgl 等支持 ## 2019 年 4 月 适配了 OpenMV IDE 也就是 MaixPy IDE， 在原来软件的基础上只将 USB 通信改成了 k210 支持的 串口通信， 其它功能没有变化 预编译固件开始区分功能分成多个固件， 主要考虑到运行模型内存不足的问题 wipping 退出项目组， zepan 和 xel 专注到其它项目组 ## 2019 年 6 月 重构了项目结构， 之前是直接在 micropython 的目录结构中添加代码， 在 port 目录中添加代码， 但是这会有一个问题， 就是更新 micropython 程序变得比较麻烦， 需要将 micropython 和 MaixPy 增加的代码分开， 而且旧的代码结构太混乱， Makefile 写得也不是很好，构建缓慢。 所以有了现在的目录结构， 使用了 cmake + kconfig 对工程进行构建， 同时将各个组件模块化， 并且可以选择是否编译进固件， 编译框架在[这里](https://github.com/Neutree/c_cpp_project_framework)。 但是仍有遗留问题， 目录下面有一些遗留代码没有完全接偶。 ## 2019 年 7 月 增加 M5Stick V 开发板的支持， 由 [Martin Han](https://github.com/MarsTechHAN) 维护 ## 2019 年 12 月 [Maixhub](https://www.maixhub.com) 上线， 用于在线模型训练，只需要上传数据集无须编写代码 硬件更新： 上线 M1N 模块， 金手指模块 ## 2020 年 4 月 [糖老鸭](https://github.com/QinYUN575) 加入项目组 ## 2020 年 5 月 [大佬鼠](https://github.com/junhuanchen) 加入项目组 ## 2020 年 6 月 硬件更新： 上线 Maix Cube 开发板 ## 2020 年 7 月 为不同板子增加板级配置文件， 放在文件系统中， 开机读取， 主要是由于 Cube 和 Amigo 增加了电源芯片， 在开机时为了能正常使用必须先设置电源芯片 硬件更新： 上线 Maix Amigo 开发板， 增加了外壳 ## 2020 年 11 月 重新梳理文档， 更完美的文档和社区 ## 2021 年 1 月 稳定 MaixPy 各项功能，补充缺失的文档，迎接 MaixPy3 项目的到来。 ## 2022 年 6 月 全新 [Maixhub](maix.sipeed.com) 上线，更好的体验 ## 2024 年 4 月 全新的 [MaixPy v4](https://wiki.sipeed.com/maixpy/) 更新，不再使用 MicroPython，转而使用标准 CPython3，适配性能更强大的 [MaixCAM](https://wiki.sipeed.com/maixcam) 硬件设备。 为了区分 MicroPython 版本的 MaixPy， 将其名称改为 MaixPy v1，并且暂停维护，等到未来如果有必要再考虑更新，新版的 MaixPy v4 采用 MaixPy 名称。"},"/soft/maixpy/zh/get_started/install_driver/dock.html":{"title":"Maix Dock USB 驱动安装","content":" title: Maix Dock USB 驱动安装 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy Maix Dock USB 驱动安装 ## Linux Linux 不需要装驱动，系统自带了，使用 `ls /dev/ttyUSB*` 即可看到设备号 ## Windows `Maix Dock` 使用了 `CH340` 作为驱动芯片。`Windows` 用户需要安装 `CH340` 的驱动。 Windows 下载 [ch340 ch341 driver](https://api.dl.sipeed.com/fileList/MAIX/tools/ch340_ch341_driver/CH341SER.EXE) 安装即可，然后可以在 `设备管理器` 中看到串口设备"},"/soft/maixpy/zh/get_started/install_driver/cube.html":{"title":"Maixpy Cube USB 驱动安装","content":" title: Maixpy Cube USB 驱动安装 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy USB 驱动安装 ## Linux Linux 不需要装驱动，系统自带了，使用 `ls /dev/ttyUSB*` 即可看到设备号 ## Windows `Windows` 用户需要安装 特定的驱动。 USB 驱动: [点我](https://dl.sipeed.com/shareURL/MAIX/tools/driver) 我们在拿到 MaixPy 开发板并连接到电脑的时候, 可以打开设备管理器查看串口驱动是否已经安装,打开设备管理器的方法有: 此电脑(右键) > 属性 > 设备管理器 开始菜单(右键) > 设备管理器 控制面板 > (搜索)设备管理器 <img src \"../../../assets/get_started/win_device_1.png\" height \"400\"> 1. 当我们的系统是 Windows 10 系统,系统则会帮我们自动安装驱动，而如果是旧版 Win7，win8 系统，我们就需要自己手动安装 USB 驱动: ![](../../../assets/get_started/win_device_2.png) 2. 打开上一节的的链接下载驱动 ![](../../../assets/get_started/win_device_3.png) 3. 点击安装 ![](../../../assets/get_started/drives.gif) 4. 安装完成之后,可以在设备管理器看到已经识别到两个串口设备了(其中只有一个串口可用) ![](../../../assets/get_started/win_device_4.png)"},"/soft/maixpy/zh/get_started/install_driver/go.html":{"title":"Maix Go USB 驱动安装","content":" title: Maix Go USB 驱动安装 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy Maix Go USB 驱动安装 这款 `STM32` 芯片的固件出厂默认采用 [open ec](https://github.com/sipeed/open ec) 的固件， 如果没问题，则会出现一个或者两个串口， 比如 `Linux` 下出现两个串口 `/dev/ttyUSB0` 和 `/dev/ttyUSB1`， 下载和访问串口时请使用 `/dev/ttyUSB1`。 Windows 也类似。 如果需要重新烧录这个固件，可以从 [github](https://github.com/sipeed/open ec/releases) 或者 [官网下载 open ec 固件](https://dl.sipeed.com/shareURL/MAIX/tools/open ec/flash zero.bin)， 然后使用 `ST LINK` 连接板子上引出的 `STM32` 的 `SW` 引脚（`GND`, `SWDIO`, `SWCLK`）进行烧录。（目前版本的 `Go` 板子上的 `STM32` 不支持串口烧录，只能使用 `ST LINK` 进行烧录， 有需要请自行购买，或者使用一款板子用 `IO` 模拟也可以（比如树莓派） ） 除了 `open ec` 还有 `CMSIS DAP` 固件， 相比 `open ec` 可以模拟 `JTAG` 来对板子进行调试， `open ec` 目前还未支持模拟 `JTAG`， 可以 [从官网下载固件](http://dl.sipeed.com/shareURL/MAIX/tools/cmsis dap/)， 使用 `ST LINK` 对其进行烧录， 在 `Linux` 下会出现 `/dev/ttyACM0` 设备 > ST LINK 对 `STM32` 的烧录方法资料很全，请自行搜索 **请注意对 STM32 更新固件和更新 MaixPy 固件是不一样的， 一般情况不需要更新 STM32的固件， 默认的即够用了， STM32 只是一个 USB转串口的工具而已！！！勿混淆。。。** ## Linux Linux 不需要装驱动，系统自带了，使用 `ls /dev/ttyUSB*` 即可看到设备号 ## Windows 开发板使用了一颗 `STM32` 来实现模拟串口以及 `JTAG` 功能， `Windows` 需要安装 特定的驱动。 USB 驱动: [点我](https://dl.sipeed.com/shareURL/MAIX/tools/driver) 我们在拿到 MaixPy 开发板并连接到电脑的时候, 可以打开设备管理器查看串口驱动是否已经安装,打开设备管理器的方法有: 此电脑(右键) > 属性 > 设备管理器 开始菜单(右键) > 设备管理器 控制面板 > (搜索)设备管理器 <img src \"../../../assets/get_started/win_device_1.png\" height \"400\"> 1. 当我们的系统是 Windows 10 系统,系统则会帮我们自动安装驱动，而如果是旧版 Win7，win8 系统，我们就需要自己手动安装 USB 驱动: ![](../../../assets/get_started/win_device_2.png) 2. 打开上一节的的链接下载驱动 ![](../../../assets/get_started/win_device_3.png) 3. 点击安装 ![](../../../assets/get_started/drives.gif) 4. 安装完成之后,可以在设备管理器看到已经识别到两个串口设备了(其中只有一个串口可用) ![](../../../assets/get_started/win_device_4.png)"},"/soft/maixpy/zh/get_started/install_driver/duino.html":{"title":"Maix Duino USB 驱动安装","content":" title: Maix Duino USB 驱动安装 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy Maix Duino USB 驱动安装 ## Linux Linux 不需要装驱动，系统自带了，使用 `ls /dev/ttyUSB*` 即可看到设备号 ## Windows 开发板使用了 `CH552` 芯片来实现 `USB` 转串口功能，没有 `JTAG` 模拟功能，`Windows` 需要安装 特定的驱动。 USB 驱动: [点我](https://dl.sipeed.com/shareURL/MAIX/tools/driver) 我们在拿到 MaixPy 开发板并连接到电脑的时候, 可以打开设备管理器查看串口驱动是否已经安装,打开设备管理器的方法有: 此电脑(右键) > 属性 > 设备管理器 开始菜单(右键) > 设备管理器 控制面板 > (搜索)设备管理器 <img src \"../../../assets/get_started/win_device_1.png\" height \"400\"> 1. 当我们的系统是 Windows 10 系统,系统则会帮我们自动安装驱动，而如果是旧版 Win7，win8 系统，我们就需要自己手动安装 USB 驱动: ![](../../../assets/get_started/win_device_2.png) 2. 打开上一节的的链接下载驱动 ![](../../../assets/get_started/win_device_3.png) 3. 点击安装 ![](../../../assets/get_started/drives.gif) 4. 安装完成之后,可以在设备管理器看到已经识别到两个串口设备了(其中只有一个串口可用) ![](../../../assets/get_started/win_device_4.png)"},"/soft/maixpy/zh/get_started/install_driver/ai_hat.html":{"title":"Grove AI HAT USB 驱动安装","content":" title: Grove AI HAT USB 驱动安装 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy 驱动安装 ## Linux Linux 不需要装驱动，系统自带了，使用 `ls /dev/ttyUSB*` 即可看到设备号 ## Windows `Windows` 用户需要安装 特定的驱动。 USB 驱动: [点我](https://dl.sipeed.com/shareURL/MAIX/tools/driver) 我们在拿到 MaixPy 开发板并连接到电脑的时候, 可以打开设备管理器查看串口驱动是否已经安装,打开设备管理器的方法有: 此电脑(右键) > 属性 > 设备管理器 开始菜单(右键) > 设备管理器 控制面板 > (搜索)设备管理器 <img src \"../../../assets/get_started/win_device_1.png\" height \"400\"> 1. 当我们的系统是 Windows 10 系统,系统则会帮我们自动安装驱动，而如果是旧版 Win7，win8 系统，我们就需要自己手动安装 USB 驱动: ![](../../../assets/get_started/win_device_2.png) 2. 打开上一节的的链接下载驱动 ![](../../../assets/get_started/win_device_3.png) 3. 点击安装 ![](../../../assets/get_started/drives.gif) 4. 安装完成之后,可以在设备管理器看到已经识别到两个串口设备了(其中只有一个串口可用) ![](../../../assets/get_started/win_device_4.png)"},"/soft/maixpy/zh/get_started/install_driver/nano.html":{"title":"Maix Nano USB 驱动安装","content":" title: Maix Nano USB 驱动安装 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy Maix Nano USB 驱动安装 ## Linux Linux 不需要装驱动，系统自带了，使用 `ls /dev/ttyUSB*` 即可看到设备号 ## Windows 开发板使用了 `CH552` 芯片来实现 `USB` 转串口功能，`Windows` 用户需要安装 特定的驱动。 USB 驱动: [点我](https://dl.sipeed.com/shareURL/MAIX/tools/driver) 我们在拿到 MaixPy 开发板并连接到电脑的时候, 可以打开设备管理器查看串口驱动是否已经安装,打开设备管理器的方法有: 此电脑(右键) > 属性 > 设备管理器 开始菜单(右键) > 设备管理器 控制面板 > (搜索)设备管理器 <img src \"../../../assets/get_started/win_device_1.png\" height \"400\"> 1. 当我们的系统是 Windows 10 系统,系统则会帮我们自动安装驱动，而如果是旧版 Win7，win8 系统，我们就需要自己手动安装 USB 驱动: ![](../../../assets/get_started/win_device_2.png) 2. 打开上一节的的链接下载驱动 ![](../../../assets/get_started/win_device_3.png) 3. 点击安装 ![](../../../assets/get_started/drives.gif) 4. 安装完成之后,可以在设备管理器看到已经识别到两个串口设备了(其中只有一个串口可用) ![](../../../assets/get_started/win_device_4.png)"},"/soft/maixpy/zh/get_started/install_driver/bit.html":{"title":"Maix Bit USB 驱动安装","content":" title: Maix Bit USB 驱动安装 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy Maix Bit USB 驱动安装 ## Linux Linux 不需要装驱动，系统自带了，使用 `ls /dev/ttyUSB*` 即可看到设备号 ## Windows 开发板分为新旧两版，需要分别安装不同的驱动 ### `Maix Bit`（旧版） Windows 下载 [ch340 ch341 driver](https://api.dl.sipeed.com/fileList/MAIX/tools/ch340_ch341_driver/CH341SER.EXE) 安装即可，然后可以在 `设备管理器` 中看到串口设备 ### `Maix Bit` 新版带麦克风版本（使用`CH552`） 开发板 开发板使用了 `CH552` 芯片来实现 `USB` 转串口功能，没有 `JTAG` 模拟功能，`Windows` 需要安装 特定的驱动， USB 驱动: [点我](https://dl.sipeed.com/shareURL/MAIX/tools/driver) 我们在拿到 MaixPy 开发板并连接到电脑的时候, 可以打开设备管理器查看串口驱动是否已经安装,打开设备管理器的方法有: 此电脑(右键) > 属性 > 设备管理器 开始菜单(右键) > 设备管理器 控制面板 > (搜索)设备管理器 <img src \"../../../assets/get_started/win_device_1.png\" height \"400\"> 1. 当我们的系统是 Windows 10 系统,系统则会帮我们自动安装驱动，而如果是旧版 Win7，win8 系统，我们就需要自己手动安装 USB 驱动: ![](../../../assets/get_started/win_device_2.png) 2. 打开上一节的的链接下载驱动 ![](../../../assets/get_started/win_device_3.png) 3. 点击安装 ![](../../../assets/get_started/drives.gif) 4. 安装完成之后,可以在设备管理器看到已经识别到两个串口设备了(其中只有一个串口可用) ![](../../../assets/get_started/win_device_4.png)"},"/soft/maixpy/zh/get_started/install_driver/amigo.html":{"title":"Maixpy Amigo USB 驱动安装","content":" title: Maixpy Amigo USB 驱动安装 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy USB 驱动安装 ## Linux Linux 不需要装驱动，系统自带了，使用 `ls /dev/ttyUSB*` 即可看到设备号 ## Windows `Windows` 用户需要安装 特定的驱动。 USB 驱动: [点我](https://dl.sipeed.com/shareURL/MAIX/tools/driver) 我们在拿到 MaixPy 开发板并连接到电脑的时候, 可以打开设备管理器查看串口驱动是否已经安装,打开设备管理器的方法有: 此电脑(右键) > 属性 > 设备管理器 开始菜单(右键) > 设备管理器 控制面板 > (搜索)设备管理器 <img src \"../../../assets/get_started/win_device_1.png\" height \"400\"> 1. 当我们的系统是 Windows 10 系统,系统则会帮我们自动安装驱动，而如果是旧版 Win7，win8 系统，我们就需要自己手动安装 USB 驱动: ![](../../../assets/get_started/win_device_2.png) 2. 打开上一节的的链接下载驱动 ![](../../../assets/get_started/win_device_3.png) 3. 点击安装 ![](../../../assets/get_started/drives.gif) 4. 安装完成之后,可以在设备管理器看到已经识别到两个串口设备了(其中只有一个串口可用) ![](../../../assets/get_started/win_device_4.png)"},"/soft/maixpy/zh/get_started/get_started_fs.html":{"title":"存储系统介绍","content":" title: 存储系统介绍 keywords: maixpy, k210, AIOT, 边缘计算, maixpy入门 desc: maixpy 存储系统介绍 MaixPy 存储系统大致如下图所示： ![](../../assets/get_started/memory.png) 由上图可知，MaixPy 中的存储介质主要由 `Flash`，`SD` 卡组成，分为三块区域，分别是 MaixPy.bin 固件区，xxx.kmodel 模型区，文件系统区：Flash 上为 [`spiffs`](https://github.com/pellepl/spiffs)（SPI Flash File System），SD 卡为 Fatfs（FAT file system）。 ## MaixPy.bin 固件区 用来存储 MaixPy.bin 固件，起始于 0x000000，因为 K210 会从 0x000000 地址开始运行程序。 ## xxx.kmodel 模型区 通常起始于 0x300000，模型文件之所以不烧录在 `Flash` 的文件系统（文件系统会后续解释）中，原因有下： 1. `Flash` 中文件系统拥有的内存并不够大，不足以放入大模型，更大的模型可以放入 `SD` 卡中。 2. 直接读取模型文件比经过文件系统读取速率更快。 该区域没有文件系统管理，需要根据烧录时的起始地址操作文件，例如当模型烧录在 0x500000 时的读取方法： ```python KpuTask kpu.load(0x500000) ``` ## 文件系统区 通常从 0xD00000 开始，该区域交由文件系统管理，我们预留了 `Flash` 末尾的 `3MiB` 空间，交由 [`spiffs`](https://github.com/pellepl/spiffs) 管理， 另外也支持 `FAT32`（Fatfs） 的 `SD` 卡。这些文件系统提供接口使我们通过 **文件名** 便可对文件进行读写操作，而不必像模型区那样使用 **文件起始地址** 操作。同时还能帮助我们有效管理存储介质，例如磨损均衡（Flash 是有磨损寿命的，相关知识请自行搜索）可以充分发挥 Flash 的寿命。 ### MaixPy 文件系统的使用 由于 `Flash` 和 `SD` 卡的文件系统各不相同，接口不一致，使得操作不同文件系统需要调用不同接口，此时 MaixPy 中的虚拟文件系统（VFS）正是用于解决该问题，`VFS` 可以挂载多个不同类型文件系统，并为用户操作这些文件系统提供统一接口，用户使用这些接口时可以忽略不同文件系统之间的差异。这些接口在 `os` 模块中实现，使用示例如下： ```python import uos print(\"files:\", uos.listdir(\"/flash\")) with open(\"/flash/test.txt\", \"w\") as f: f.write(\"hello text\") print(\"files:\", uos.listdir(\"/flash\")) with open(\"/flash/test.txt\", \"r\") as f: content f.read() print(\"read:\", content) ``` 以上示例中，`spiffs` 文件系统开机被自动挂载到 `/flash` 目录，用户只需要在使用 `os` 的接口时传入 `\"/flash\"` 目录名作为参数便可访问该文件系统。 解读： * 导入 `uos` 模块 * 列出 `/flash` 目录下所有文件 * 向 `/flash` 目录写入一个名为 `test.txt` 的文件，内容为 `hello text`, * 列出 `/flash` 目录下所有文件，会发现 `test.txt` 的存在 * 读取文件内容到 `content` 变量 * 打印 `content` 变量， 输出 `hello text`，也就是刚刚写入文件的内容 * 这个内容在开发板断电之后再上电，仍然能读到正确的内容（Flash 断电后不会丢失内容） 当然也支持 SD 卡， 如果你需要使用， SD 卡需要满足以下几点： * 支持 `SPI` 模式, 市面上大多数正版卡都支持 * 分区为 `MBR （msdos）` * 格式化为 `FAT32` * 大小测试过最大 **`1TB`** 可用 断电插入 `SD` 后， 上电，`SD` 卡会被挂载在 `/sd`，如果有多个分区，第二个分区名是`/sd2` 注意`/`（根目录）不能写入数据，只能往`/flash`或者`/sd`写入数据 开机如果有`SD`卡， 会自动将当前目录切换到`/sd`， 如果没有，则会自动切换到`/flash`"},"/soft/maixpy/zh/get_started/knowledge_prepare.html":{"title":"必备基础知识","content":" title: 必备基础知识 keywords: maixpy, k210, AIOT, 边缘计算, maixpy入门, 人工智能 desc: maixpy 必备基础知识 要开始使用 `MaixPy`， 我们建议至少有以下基础知识（如果没有，需要先学习）： * 有足够的耐心和细心， 能够静下心来专研技术、仔细查看文档、专心写代码 * 有 `Python` 或者 `Micropython` 基础， 会使用 `Python` 基础语法。 * 如果不会 `Python`语法， 但是有其它编程语言基础，请用百度搜一下 `Python 教程` 学习基础语法部分即可； * 如果不会任何一门编程语言， 那本文档看起来会很吃力， 请先学习 `Python` 基础语法和使用 * 至少有一种单片机开发基础，能看懂基本的电路图， 目前本文档还没有针对零基础的人群的教程 > 需要有单片机开发经验的原因是本文档目前还没有对一些基本的术语进行教学，比如 `UART` 是什么？ `I2S` 是什么？而且在未来也多半不会对这些基础知识进行详细地阐述 （但是实际上， 如果你善于使用搜索工具进行学习， 就算不懂也可以学习到） * 了解 Micropython 是什么， 这里查看： [MicroPython 语言介绍](http://docs.micropython.org/en/latest/reference/index.html) * 大致上了解 Micropython 与 Python 的不同， 可以在这里：[MicroPython 与 CPython（Python3） 的不同之处](http://docs.micropython.org/en/latest/genrst/index.html) 查看 如果上述的几点有一点不满足， 那么建议先补足所缺， 否则学习和开发的过程将会异常艰辛！！！！"},"/soft/maixpy/zh/get_started/env_maixpyide.html":{"title":"MaixPy IDE 安装与使用","content":" title: MaixPy IDE 安装与使用 keywords: maixpy, k210, AIOT, 边缘计算, maixpy入门 desc: maixpy MaixPy IDE 安装与使用 ![maixpy_ide_start](../../assets/maixpy/maixpy_ide_start.png) ## 关于 MaixPy IDE ![MaixPy IDE](../../assets/maixpy/maixpy_ide.png) 首先需要弄清： **MaixPy** 使用 `Micropython` 脚本语法，所以不像 `C` 语言 一样需要编译，其实不用 `IDE` 也能愉快使用： 使用串口终端工具，前面已经安装了 使用 `IDE` 则会方便在电脑上实时编辑脚本并上传到开发板以及直接在开发板上执行脚本，以及在电脑上实时查看摄像头图像、保存文件到开发板等 当然， 使用 `IDE` 因为压缩、传输需要耗费一部分资源，所以性能会有所降低，而且如果MaixPy宕机也没有串口终端好发现问题 ## MaixPy 固件 要使用 `MaixPy IDE` , 固件必须是 `v0.3.1` 版本以上, 否则MaixPyIDE 上会连接不上， 使用前尽量检查固件版本和 IDE 版本，都更新到最新版以保障能正常使用 ## 下载安装包 [dl.sipeed.com](http://dl.sipeed.com/MAIX/MaixPy/ide/) 文件列表等说明 请看 最新版本文件夹下的 `readme.txt` 文件， 如果下载速度慢请使用 cdn 链接下载 ## 安装 #### 如果是安装程序(**推荐**，简单方便) `Windows`直接双击`exe`文件运行安装程序; `Linux`命令行给运行权限然后执行 ``` chmod +x maixpy ide linux x86_64 0.2.2.run ./maixpy ide linux x86_64 0.2.2.run ``` #### 如果是压缩包(`7z`) 则解压到文件夹 > 如果系统不支持 `7z`， 则需要 [下载 `7z`解压缩工具](https://www.7 zip.org/)，然后用 `7z` 在`Linux`下也可以双击压缩包进行解压！ 如果需要使用终端解压， 可以参考以下命令： ```bash sudo apt install p7zip full 7z x maixpy ide linux x86_64 0.2.2 installer archive.7z r omaixpy ide # ` o` 后面直接跟解压缩的路径, 中间没有空格. ``` * 解压后, 执行 * 如果是 `Windows`： 直接双击`maixpyide`来执行，可以右键固定到开始页面或者固定到任务栏方便后面使用 * `Linux`： 执行 ``` chmod +x setup.sh ./setup.sh ./bin/maipyide.sh ``` ## 测试运行 打开 MaixPy IDE, 上方工具栏里面选择开发板的型号。**amigo，cube 开发板请选择 Maixduino 进行连接**。 `Tool > Select Board` (工具 >选择开发板) 点击 `connect` 连接 `MaixPy IDE` ![connect icon.png](../../assets/maixpy/maixpy_connect_icon.png) 连接成功之后，链接按钮会由绿变红． ![connect success.png](../../assets/maixpy/maixpy_connect success.png) 连接按钮下方是运行按钮，会执行当前编辑区的`py`文件． ![helloworld run.png](../../assets/maixpy/maixpy_helloworld.png) 再次点击运行按钮(红色), 停止运行当前代码． ## 上传文件 在 **Tool/工具** 菜单中可以选择发送文件 ## 注意 * 点击连接后，不用和终端工具同时使用，否则会出现串口占用无法打开 * 如果一直无法成功连接成功， 检查： * 请检查是否开发板型号选择错误； * 观察开发板屏幕是否有变化，如果没有反应可能是串口选择错误； * 尝试升级到最新的 [master 分支固件](http://cn.dl.sipeed.com/MAIX/MaixPy/release/master)， 以及最新的 MaixPy IDE 软件 * 运行代码后获取不到图像 * 请换个USB口，比较老旧的电脑会出现这个问题 ## 根据错误提示寻找原因 程序运行出错时会弹框提示错误，但是错误信息不一定完整，请**在终端输出里面查找更详细的错误信息** 如有必要，请断开 IDE， 仅使用串口终端运行程序（也许你需要先把程序保存到文件，然后运行文件）查看打印以排错 如果提交问题（bbs、群、github issue等），为了使问题快速得到解决，请务必带上上面所述完整信息"},"/soft/maixpy/zh/get_started/upgrade_esp32_firmware.html":{"title":"更新板载 ESP32 固件","content":" title: 更新板载 ESP32 固件 keywords: maixpy, k210, AIOT, 边缘计算, ESP32, 人工智能 desc: maixpy 更新板载 ESP32 固件 ## 简介： MaixPy 系列的开发板中 MaixDuino 板载了一块 ESP32 WIFI SOC，一般情况下不推荐更新板载的 ESP32 模块。 但是但我们发现使用过程中存在 bug 并修复了之后我们就需要更新修复的固件。 ## 更新 ESP32 固件步骤 ### 准备 硬件: MaixDuino, USB Type C 数据线 软件: ESPFLASH ESP32 固件更新工具：ESP32 **flash_download_tools** 下载链接：[**flash_download_tools**](https://www.espressif.com/zh hans/support/download/other tools) ESP32 MaixDuino 固件： 下载链接：[**flash_download_tools**](https://cn.dl.sipeed.com/MAIX/factory_firmware/) 下载烧录固件前先擦除一遍原有固件！！！！ ### 更新流程： 1. 下载 **flash_download_tools**， ![flash_download_tools](../../assets/hardware/module_esp32/image 20200504164050916.png) ![flash_download_tools](../../assets/hardware/module_esp32/image 20200504164221705.png) 2. 下载 **MaixDuino ESP32 固件** ![update esp32](../../assets/hardware/module_esp32/image 20200504164245329.png) 3. 连接 MaixDuino, 选择 ESP32 串口(一般都是串口号比较大的) 4. 设置下载选项: 1. 如图配置相应选项, 注意**波特率一定要设置为 115200** ![b6474ddd5340cc9b7cf6006f75974a7b.png](../../assets/hardware/module_esp32/image 20200504164320888.png) ![acf618a24b4cb8c5f8c2e98acc6cf11b.png](../../assets/hardware/module_esp32/image 20200504164450650.png) 5. 点击 **Start** 更新固件，并等待完成更新 6. 验证更新是否完成 1. 使用 XCOM, 打开 ESP32 串口，点击 RST 复位 ESP32，如图即刷入成功 ![96e955badd7450e7b5ba58230ae12c48.png](../../assets/hardware/module_esp32/image 20200504164747839.png)"},"/soft/maixpy/zh/get_started/get_started_upload_script.html":{"title":"上传脚本&模块到开发板","content":" title: 上传脚本&模块到开发板 keywords: maixpy, k210, AIOT, 边缘计算, maixpy入门, 人工智能 desc: maixpy 上传脚本&模块到开发板 前面我们接触到了直接执行 `pye(\"filename.py\")` 命令可以打开一个编辑器，可以直接编辑文件系统中的文件 但是慢慢我们会发现，这样的方法只适合用来改少量的代码，当代码量庞大或者我们需要高亮支持时，它就不适用了，我们需要在电脑上写完代码，然后上传到板子的文件系统里面 目前有以下几种方法： ### 使用 MaixPy IDE 上传脚本到开发板 打开 `MaixPy IDE`， 连接开发板 编辑文件，然后在顶端`Tool`（工具）菜单中，点击`将打开的文件保存为 boot.py` 来将代码保存到开发板的`boot.py`文件，中，下次开发板开机上电会自动执行这个文件 当然也可以使用顶端`Tool`(工具)菜单中的`发送文件`功能来发送文件，会保存到开发板并且文件名和电脑上的文件名相同，（除了脚本也可以上传其它文件，不要太大） ![](../../assets/maixpy/maixpy_ide_tools.png) ## 使用图形工具 uPyLoader 上传、运行脚本 [uPyLoader](https://github.com/BetaRavener/uPyLoader) 是一款开源软件，使用它可以方便地连接 MaixPy 并且上传、下载、执行文件，同时监控输出等等功能，功能比较完善 下载可执行文件:[release](https://github.com/BetaRavener/uPyLoader/releases) ![uPyLoader](../../assets/other/uPyLoader.png) 选择串口并点击 `Connect` 按钮来连接板子 第一次运行该软件需要初始化， 点击 `File >Init transfer files` 来完成初始化，这会在板子里创建两个文件，分别是 `__upload.py` 和 `__download.py`。 左边选中需要上传的文件，点击 `Transfer` 即可上传到板子的文件系统。 右边是板子里面的文件， 点击 `List files` 可以刷新文件列表， 选中 文件名， 点击 `Execute` 即可执行该脚本文件 点击上面的 `View > terminal ` 可以打开终端 用来查看运行时的输出或者发送命令 ## 使用命令行工具 [mpfshell lite](https://github.com/junhuanchen/mpfshell lite) 是一个简单易用的命令行上传、下载、执行文件 的工具， 而且开源 注意这个工具是运行在电脑端的，而不是运行在板子上的 使用 `mpfs help` 来查看帮助信息 使用 `mpfs put file_in_PC.py` 命令还可以不上传脚本到板子而是直接在板子上运行该脚本 除此之外还有 ampy rshell 这些。 ## SD（TF） 直接运行 拷贝到 SD 卡后， 在终端中执行 `import 文件名` 或者`exec()`来运行脚本 ## SD 卡自动拷贝到 Flash 文件系统 为了方便将 SD 卡的内容拷贝到 Flash 文件系统， 只需要将要拷贝到 Flash 文件系统的文件重命名为`cover.boot.py` 或者`cover.main.py`, 然后放到`SD`卡根目录， 开发板断电插入`SD`卡，然后开发板上电， 程序就会自动将这两个文件拷贝到`/flash/boot.py`或者`/flash/main.py`，这样就算后面取出了`SD`卡，程序已经在 `/flash/boot.py`或者`/flash/main.py`了"},"/soft/maixpy/zh/get_started/knowledge_git_github.html":{"title":"git 和 github 介绍","content":" title: git 和 github 介绍 keywords: maixpy, k210, AIOT, 边缘计算, maixpy入门, 人工智能 desc: maixpy git 和 github 介绍 因为在学习 MaixPy 的过程中， 有很多地方用到 git 和 github， 所以这里简单解释一下它们是什么，以及区别是什么。 ## 什么是 git git 是一款 代码托管 **软件**， 用来管理代码的版本。 比如： 我今天改了代码， 然后明天也改了代码， 以后我都能看到这两次改动历史， 以及改了什么内容，可以精确到哪一行，方便后面找问题; 或者我发现第二次提交的代码出现了问题， 我需要回到第一次提交后的版本， 都可以用这个工具实现; 另外方便多个人修改同一份代码，能管理大家提交的代码，不容易出现混乱。 再也不用拷贝无数个文件夹来备份修改了！ git 会在目录下创建一个`.git`隐藏文件夹， 所有更改记录保存在这里面，不能删除这个文件夹。 但是需要注意的是， 现在的 git 主要用来管理文本文件， 不适用拿来管理二进制文件，比如图片 PDF等等， 会让文件夹占用的空间变得很大。 具体的教程，可以看 [这里](https://git scm.com/), 中文教程可以看 [这里](https://www.liaoxuefeng.com/wiki/896043488029600/896067008724000) ## 什么是 github [github](http://github.com/) 是一个 分享代码 的 **网站**。 可以在这个网站上注册， 然后建立仓库（repository），往这个仓库里面放代码公开分享，让更多地人来使用， 甚至一起修改，一起优化代码， 这就是**开源**。 每个仓库都是可以单独地使用 `git` 这个软件来管理的， 大家在自己的电脑上修改代码， 然后使用`git`提交， 然后使用`git`推送到`github`这个网站， 大家就可以看到新的内容了。 MaixPy 的源码的地址是： [https://github.com/sipeed/maixpy](https://github.com/sipeed/maixpy) , 也就是一个 `git 仓库`。 github 的[帮助](https://docs.github.com/en/free pro team@latest/github), 中文 [帮助](https://docs.github.com/cn/free pro team@latest/github) 另外，国内也有几家不过的类似`github`的网站， 比如[gitee](https://gitee.com/) ## git 和 github 的区别 一个是一个软件， 一个是一个网站。 只不过这个网站用到了 git 这个技术来管理仓库。 ## 为什么我无法访问 github， 或者访问速度很慢 github 是国外的网站， 因为距离远，线路问题导致某些运营商的某些线路可能访问慢甚至无法访问， 比如 github 用来存放源文件的域名 `https://raw.githubusercontent.com/` 可能无法访问 解决方法： * 换个线路， 也就是换个网络， 比如你用电信网， 可以换移动或者联通试试， 换手机流量，或者换个地方等方法 * 使用 VPN 类软件，这里不教，请注意合法使用 ## 什么是 star 在 github 上， 每个公开的仓库大家都可以去点赞收藏，也就是 star，在 github 右上角 ⭐ 形状的按钮 ![star ](../../assets/other/github_star.jpg) 如果你觉得项目不错，请给个 star，这样会鼓励开发者花更多时间维护仓库，同时也告诉第一次来的访问者这是个不错的项目，值得关注。 star 后， 可以在个人资料里面找到自己的 star 仓库，方便下一次找到 说到这里，大家觉得 [MaixPy](https://github.com/sipeed/maixpy) 不错的话，可以 star 一个哦～ ## 什么是 Master 分支 在每个仓库中， 可以存在很多个分支，不同分支可以有不同的代码，而且不同的分支之间还可以互相合并，方便保存代码的不同版本，以及方便团队合作， master 分支就是指主分支，也就是最重要的分支，通常仓库默认展示的就是 master 分支。 ## 什么是提交 提交，英文叫`commit`， 就是每次更改仓库的代码， 都提交一次，就会被记录到提交历史记录里面，后面随时都可以看这次提交了什么内容，也可以将代码回滚到这次提交 每个提交都有一个独立的`commit ID`， 比如`d28cb7ac7db5ad61c0738df95d733717deefda1d`， 简写成`d28cb7a` ## 什么是子模块 子模块， 英文叫`submodule`， 就是在仓库中可以引用其它仓库，相当于是一个软链接， 不需要在仓库放实际的代码， 只需要放一个链接即可。 这样的好处是多个仓库可以分开管理， 比如`仓库1`引用了`仓库2`作为子模块， 如果`仓库2`代码更新了， `仓库1`可以选择继续使用旧版的`仓库2`的代码， 也可以选择使用`仓库2`最新的代码，只是更新一下子模块链接 比如`MaixPy`用了`kendryte standalone sdk`作为子模块,看[这里](https://github.com/sipeed/MaixPy v1tree/master/components/kendryte_sdk) ![submodule](../../assets/get_started/github_submodule.jpg) 可以看到这里文件夹的图标不太一样，它只是一个链接，点击就会跳到相应的仓库而不是直接打开文件夹 所以 **MaixPy 使用了子模块** ## 什么是克隆 在`github`上面的仓库，如果需要下载到本地来， 就需要使用克隆， 使用 ``` git clone 地址 ``` 就可以吧仓库克隆到本地了， 克隆的本地的仓库名副其实就是 github 上面的一份克隆， 完全一样，也保留了历史记录等 当然也可以不用克隆，网页有点击下载的按钮，但是下载的缺陷就是不会包含提交代码的历史记录，根据自己的情况选择 需要注意的是， 在克隆包含有子模块的仓库时， 因为克隆默认只会将子模块的链接克隆下来， 子模块的代码没有克隆到本地， 你需要这样克隆 ``` git clone 地址 recursive ``` 或者 ``` git clone 地址 project_name cd project_name git submodule update init recursive ``` 比如: ``` git clone https://github.com/sipeed/MaixPy recursive ``` ## 什么是 issue 也就是问题的意思， 在github 上， 每个仓库有一个专门用来提问的地方， 比如 [MaixPy的issue](https://github.com/sipeed/MaixPy v1issues) 大家在这里提问， 类似论坛一样， 都会被记录下来，方便后面的人查阅 ## 什么是 fork 在 github 上， 仓库页面右上角有一个 fork 按钮 ![](../../assets/other/github_star.jpg) 点击可以将仓库 fork 到自己的仓库，就相当于是一份拷贝，叫 fork 的原因是你在 fork 成自己的仓库后，可以对自己这个仓库进行随意修改，算是原来被 fork 仓库的一个发展分支，源自它但是可以不与它相同 ## 什么是 PR 即 github 上的 pull request 功能， 就是参与一个仓库的代码更新， 就是先 fork 成自己的仓库，然后修改，修改后提交合并到被 fork 的源仓库， 具体方法可自行学习"},"/soft/maixpy/zh/get_started/knowledge_audio.html":{"title":"音频处理背景知识","content":" title: 音频处理背景知识 keywords: maixpy, k210, AIOT, 边缘计算, maixpy入门, 人工智能 desc: maixpy 音频处理背景知识 ## 什么是声音（音频） > 人是理性的，而世界是感性的。 什么是音频，音频即振动。 光粒子的振动形成光波，即光; 而普遍物体的振动形成声波，即声音 ## 音频编码基础知识 声道数（通道数） 即声音通道的数目，在对声音的记录时，同时记录不同空间位置的音频，即录制多通道音频； 而常见的音频文件有单声道与立体声之分，即单声道记录单一位置的音频，而立体声有左右声道等记录不同空间位置的音频，并可以通过不同的扬声器播放不同通道的音频，从而还原不同空间位置的音频，使人耳通过音频感受不同空间位置（更具有空间感）。 采样位数 即采样值或取样值（就是将采样样本幅度量化）。它是用来衡量声音波动变化的一个参数，也可以说是声卡的分辨率。它的数值越大，分辨率也就越高，所发出声音的能力越强。 在计算机中采样位数一般有 8 位和 16 位之分，但有一点请大家注意，8 位不是说把纵坐标分成8份，而是分成 2 的 8 次方即 256 份； 同理 16 位是把纵坐标分成2 的 16 次方 65536 份。 采样频率 即取样频率，指每秒钟取得声音样本的次数。采样频率越高，声音的质量也就越好，声音的还原也就越真实，但同时它占的资源比较多。由于人耳的分辨率很有限，太高的频率并不能分辨出来。在 16 位声卡中有 22KHz、44KHz 等几级，其中 22KHz 相当于普通 FM 广播的音质，44KHz 已相当于 CD 音质了，目前的常用采样频率都不超过 48KHz。 ## 音频编码处理之 PCM PCM 介绍 目前我们在计算机上进行音频播放都需要依赖于音频文件，音频文件的生成过程是将声音信息采样、量化和编码产生的数字信号的过程，人耳所能听到的声音，最低的频率是从 20Hz 起一直到最高频率 20Khz，因此音频文件格式的最大带宽是 20Kzh。根据奈奎斯特的理论，只有采样频率高于声音信号最高频率的两倍时，才能把数字信号表示的声音还原成为原来的声音，所以音频文件的采样率一般在 40~50KHZ，比如最常见的 CD 音质采样率 44.1KHZ。 对声音进行采样、量化过程被称为脉冲编码调制（Pulse Code Modulation），简称PCM，而由上文采样频率，采样位数，声道数三个概念可以由下面公式得出在计算机中 PCM 文件所占用的存储空间大小： PCM 音频数据大小 (采样频率 * 采样位数 * 声道 * 时间)//8 (单位：Bytes)。 由于 PCM 数据是最原始的音频数据，对于采样的数据完全无损，所以 PCM 数据虽然音质优秀但体积对于计算机的存储还是过于庞大；为了解决这个问题先后诞生了一系列的音频格式，这些音频格式运用不同的方法对音频数据进行压缩，其中有无损压缩（ALAC、APE、FLAC）和有损压缩（MP3、AAC、OGG、WMA）两种。 ## WAV Waveform Audio File Format（WAVE，又或者是因为扩展名而被大众所知的WAV），是微软与 IBM 公司所开发在个人电脑存储音频流的编码格式，在 Windows 平台的应用软件受到广泛的支持，地位上类似于麦金塔电脑里的 AIFF。 此格式属于资源交换档案格式(RIFF)的应用之一，通常会将采用脉冲编码调制的音频资存储在区块中。也是其音乐发烧友中常用的指定规格之一。由于此音频格式未经过压缩，所以在音质方面不会出现失真的情况，但档案的体积因而在众多音频格式中较为大。 所有的 WAV 都有一个文件头，这个文件头音频流的编码参数。WAV 对音频流的编码没有硬性规定，除了 PCM 之外，还有几乎所有支持 ACM 规范的编码都可以为 WAV 的音频流进行编码。WAV 也可以使用多种音频编码来压缩其音频流，不过我们常见的都是音频流被 PCM 编码处理的WAV，但这不表示WAV 只能使用 PCM 编码，MP3 编码同样也可以运用在 WAV 中，和 AVI 一样，只要安装好了相应的 Decode，就可以欣赏这些 WAV了。 在 Windows 平台下，基于 PCM 编码的 WAV 是被支持得最好的音频格式，所有音频软件都能完美支持，由于本身可以达到较高的音质的要求，因此，WAV 也是音乐编辑创作的首选格式，适合保存音乐素材。因此，基于 PCM 编码的 WAV 被作为了一种中介的格式，常常使用在其他编码的相互转换之中，例如 MP3 转换成 WMA。 **而在 MaixPy 中，aduio 模块支持播放的 WAV 文件格式为 PCM_s16le (signed 16 bits little endian, 有符号 16 位小端)**"},"/soft/maixpy/zh/get_started/get_started_boot.html":{"title":"开机自启动脚本","content":" title: 开机自启动脚本 keywords: maixpy, k210, AIOT, 边缘计算, maixpy入门 desc: maixpy 开机自启动脚本 系统会在 `/flash` 或者 `/sd`(优先) 目录创建 `boot.py` 文件和`main.py`， 开机会自动先执行`boot.py`，然后执行`main.py`（如果检测到SD卡则执行SD卡里的）， 编辑这两个脚本的内容即可实现开机自启，如果在 `boot.py` 里面写死循环（While True）程序，将会导致 `main.py` 不能运行（先调用 `boot.py` 后调用 `main.py`），重新发送不带死循环的 `boot.py` 即可解决。 boot.py 主要用于配置硬件，只配置一次即可。 main.py 可以用于主要的运行的程序。 对应的具体执行的[代码在此](https://github.com/sipeed/MaixPy v1/blob/972059491227ece63fbfc2cd0e78fe13ee78427d/components/micropython/port/src/maixpy_main.c#L586 L595)，有疑问就直接看源码。 注意: * Micro SD 卡应该被格式化为 FAT(FAT32) 文件系统 * FAT 格式的储存卡会被挂载到 `/sd`, 内部 Flash 中的 SPIFFS 会被挂载到`/flash`"},"/soft/maixpy/zh/get_started/get_started_led_blink.html":{"title":"点亮 LED","content":" title: 点亮 LED keywords: maixpy, k210, AIOT, 边缘计算, maixpy入门 desc: maixpy 点亮 LED 点灯程序作为学习所有开发板的第一个程序，就像学所有编程语言都是先学 hello world 一样，具有着神圣的意义 ## 电路 众所周知， 点亮一个 LED 需要一个电源， 一个电阻， 一个 LED 灯泡， 在 Maix Dock 开发板上， 有三个 LED， 线路如下： ![](../../assets/hardware/maix_dock/LED_sch.png) 比如我们希望红灯点亮， 即 `LED_R` 连接的这个 LED， 图中可以看到 LED 的正极已经连接了 3.3V 电源， 所以我们只要让 LED_R 为低电平 LED 即可点亮。 > 注意， 这里 `LED_R` 是给这个引脚取的一个别名， 实际上是连接到芯片的一个引脚，比如 `Pin13`或者说`IO13` ## 外设到引脚的映射： FPIOA(现场可编程 IO 阵列， Field Programmable Input and Output Array) 可能你曾经用过一些单片机，在手册上都规定了引脚和片上外设功能（就是芯片内部集成的外设，比如 `GPIO`、`I2C`、`SPI` 等）的绑定，或者重映射。比如规定了 `I2C` 只能用 `Pin9` 和 `Pin10`，启动了重映射功能后，只能用`Pin11`和`Pin12` 但是 MaixPy 所使用的硬件 K210 的片上外设对应的引脚（硬件引脚）是可以**任意映射**的，相比之下 K210 硬件设计和软件设计的自由度更大。 比如 `I2C` 可以使用 `Pin11` 和 `Pin12`，也可以改成其它任意引脚 > 注意要区分 `GPIO` 和 `IO`的区别， `IO`也可以叫`Pin` 也就是引脚，是芯片引出来的硬件引脚， 而`GPIO`是一种外设，可以控制这些`Pin/IO` 的外设 因为有了这个强大的映射功能， 所以在使用引脚时，需要增加一步映射的步骤： ```python from fpioa_manager import fm # 导入库 fm.register(28, fm.fpioa.GPIO0) ``` 这里我们将引脚 `28` 映射为了 `GPIO0` 的功能, 执行了这句命令后，引脚`28`和`GPIO0`就映射（绑定）好了，要取消映射（解绑），则需要调用`fm.unregister`函数，具体看`API`文档，这里不介绍 另外，`Pin` 和 外设只能**唯一**对应， 不能一对多，需要对同一个外设或者引脚重复映射，否则程序可能产生难以发现的错误（`BUG`） ## 代码 我们控制 LED 需要使用到 GPIO > `board_info` 与板卡相关，不同板卡配置不同，使用前需要[手动配置](./../api_reference/builtin_py/board_info.html)。 程序如下： ```python from fpioa_manager import fm from Maix import GPIO io_led_red 13 fm.register(io_led_red, fm.fpioa.GPIO0) led_r GPIO(GPIO.GPIO0, GPIO.OUT) led_r.value(0) ``` 按照前面运行代码的方法在终端里面运行代码， 会发现 LED 灯被点亮了！ 接下来我们分析代码： * 从 `fpioa_manager` 包导入`fm` 对象，主要用于引脚和外设的映射 * 从包 `Maix` 导入了 `GPIO` 这个类， GPIO 外设相关操作 * 定义一个变量`io_led_red`，值为`13`，即`Pin13/IO13`, 具体 LED 的引脚连接到了芯片的哪个引脚，请在前面的开发板介绍中看原理图 * 使用`fm`(fpioa manager 的缩写)这个内置的对象来注册芯片的外设和引脚的对应关系，　这里　`fm.fpioa.GPIO0` 是　K210 的一个 GPIO 外设（`注意区分 GPIO（外设） 和引脚（实实在在的硬件引脚）的区别` ）， 所以把 `fm.fpioa.GPIO0` 注册到了 引脚 `IO13`； * 然后定义一个 `GPIO` 对象`led_r`， 具体参数看 `GPIO` API 文档， 在左边侧边栏查找。 * 使用 `led_r.value(1)` 或者 `led_r.value(0)` 来设置高低电平即可, 因为这里设置了低电平， 根据上面的原理图可知低电平导通，LED 灯亮 到这里已经可以点灯了， 现在可以自己尝试用 `for` 循环来实现 `LED` 闪烁或者流水灯～做出不同的变换效果"},"/soft/maixpy/zh/get_started/board_info.html":{"title":"Board","content":" title: Board keywords: maixpy, k210, AIOT, 边缘计算, maixpy入门 desc: maixpy Board > **本文档在 MaixPy 0.5.1 128 版本测试通过。** 这是一个 MaixPy 板级配置模块，它可以在用户层统一 Python 代码，从而屏蔽许多硬件的引脚差异。 效果如下： ```python from Maix import GPIO from fpioa_manager import fm from board import board_info print(board_info.LED_R) fm.register(board_info.LED_R, fm.fpioa.GPIO0, force True) led_r GPIO(GPIO.GPIO0, GPIO.OUT) led_r.value(0) ``` 而这份代码同时支持 MaixPy 所有硬件运行，并且打印的 board_info.LED_R 都不尽相同，通过它保证示例代码的一致性。 ## board 的配置方法 将以下链接对应的 python 代码复制出来（如 config_maix_bit.py），放到 IDE 编辑框中运行，即可完成对『你的硬件』配置项（config.json）的导入，它会在 flash 上存储该配置文件。 选择自己对应的开发板类型 1. Maix Bit [config_maix_bit.py](https://github.com/sipeed/MaixPy v1_scripts/tree/master/board/config_maix_bit.py) 2. Maix Dock [config_maix_dock.py](https://github.com/sipeed/MaixPy v1_scripts/tree/master/board/config_maix_dock.py) 3. Maix Go [config_maix_go.py](https://github.com/sipeed/MaixPy v1_scripts/tree/master/board/config_maix_go.py) 4. Maix Duino [config_maix_duino.py](https://github.com/sipeed/MaixPy v1_scripts/tree/master/board/config_maix_duino.py) 5. Maix Cube [config_maix_cube.py](https://github.com/sipeed/MaixPy v1_scripts/tree/master/board/config_maix_cube.py) 6. Maix Amigo [config_maix_amigo.py](https://github.com/sipeed/MaixPy v1_scripts/tree/master/board/config_maix_amigo.py) 7. Maix Nano > 这个没有硬件外设.....所以不要问为什么没有它的配置代码了。 运行配置代码后会自动重启，此时代码中才可以调用 board_info.BOOT_KEY , 实际上 board_info.BOOT_KEY 就是指 IO 16 ，对应的定义在 config.json 中可以得知，如果不存在的资源将会报错，如没有 LED 定义的硬件，运行 LED 点亮的时候就会报错。 ```python from board import board_info # see board/readme.md to config your sipeed's hardware. print(board_info.BOOT_KEY, board_info.BOOT_KEY 16) ``` ## 创建你的专属硬件 你可以借助该接口代码适配你的硬件，配置方法参考 [MaixPy_scripts/board](https://github.com/sipeed/MaixPy v1_scripts/tree/master/board) 里面有供你参考的配置文件。 ## board 的使用方法 导入配置： ```python from board import board_info board_info.load({ 'PIN10': 10, 'BOOT_KEY': 16, 'WIFI_TX': 6, 'WIFI_RX': 7, 'WIFI_EN': 8, }) print('PIN10:', board_info.PIN10) print('BOOT_KEY:', board_info.BOOT_KEY) print('WIFI_TX:', board_info.WIFI_TX) print('WIFI_RX:', board_info.WIFI_RX) print('WIFI_EN:', board_info.WIFI_EN) ``` 调用结果： ```shell PIN10: 10 BOOT_KEY: 16 WIFI_TX: 6 WIFI_RX: 7 WIFI_EN: 8 ``` > 就这样。"},"/soft/maixpy/zh/get_started/maixpy_get_started_video.html":{"title":"MaixPy 视频入门教程","content":" title: MaixPy 视频入门教程 keywords: maixpy, k210, AIOT, 边缘计算, maixpy入门, 人工智能 desc: maixpy MaixPy 视频入门教程 视频简单介绍了基本的上手过程，事实上文档上会更加详细， 视频只是提供一个比较直观的入门参考，对部分人群来说看视频入门会更加容易， 另外，本视频内的文档版本是最初的版本，新文档目录结构有了适当的调整，请大家举一反三： <iframe width \"800\" height \"600\" src \"//player.bilibili.com/player.html?aid 52613549&cid 92076022&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\"> </iframe> 建议进入[Bilibili](https://www.bilibili.com/video/av52613549?zw)登录看高清版本哦， 如果觉得节奏太慢可以右键调速～"},"/soft/maixpy/zh/get_started/upgrade_stm32_firmwave.html":{"title":"MaixGo 更新板载 STM32 调试器固件","content":" title: MaixGo 更新板载 STM32 调试器固件 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy MaixGo 更新板载 STM32 调试器固件 MaixGo 开发板板载了一块基于 STM32 的调试器"},"/soft/maixpy/zh/get_started/knowledge_image.html":{"title":"图像处理背景知识","content":" title: 图像处理背景知识 keywords: maixpy, k210, AIOT, 边缘计算, maixpy入门, 人工智能 desc: maixpy 图像处理背景知识 ## 什么是摄像头？ 我们都见过各种摄像头，比如 <img src \"../../assets/other/camera_mi.png\" height \"200\"> <img src \"../../assets/hardware/module/camera.png\" height \"200\"> 那么什么是摄像头，说到底，就是一个将光学信号转变成电信号的一个装置。在计算机视觉中，最简单的相机模型是`小孔成像模型`： ![](../../assets/other/Pinhole camera.svg) 小孔模型是一种理想相机模型，没有考虑实际相机中存在的场曲、畸变等问题。但是在实际使用时，这些问题可以通过在标定的过程中引入`畸变参数`解决，所以小孔模型仍然是目前最广泛使用的相机模型。 图像透过镜头，照在一个感光芯片上，感光芯片可以把光照的波长和强度等信息转成计算机(数字电路)可以识别的数字信号，`感光元件`是长这样的： ![camera sensor](../../assets/other/sensor.png) (中间的方形元件就是感光元件) ## 什么是像素和分辨率？ 感光元件是有很多个感光点构成的，比如有 `640` x `480` 个点，每个点就是一个像素，把每个点的像素收集整理起来，就是一副图片，那么这张图片的分辨率就是 640x480： ## 什么是帧率 帧率(FPS)就是每秒钟处理的图片数量，如果超过20帧，人眼就基本分辨不出卡顿。当然，如果用在机器上，帧率越高越好。 ## 什么是颜色 物理上，颜色就是不同波长的电磁波。 ![sRGB rendering of the spectrum of visible light](../../assets/other/1920px Linear_visible_spectrum.svg.png) 颜色频率 波长 紫色668–789 THz380–450 nm 蓝色631–668 THz450–475 nm 青色606–630 THz476–495 nm 绿色526–606 THz495–570 nm 黄色508–526 THz570–590 nm 橙色484–508 THz590–620 nm 红色400–484 THz620–750 nm 但是，根据人眼的视觉效果，可以通过 RGB，CMYK，HSB，LAB 色域，来将可见光的颜色描述出来。 ## RGB 三原色 三原色的原理不是物理原因，而是由于人的生理原因造成的。人的眼睛内有几种辨别颜色的锥形感光细胞，分别对黄绿色、绿色和蓝紫色(或称紫罗兰色)的光最敏感(波长分别为564、534和420纳米)。 所以 RGB 经常用于显示器上，用来显示图片。 LAB 亮度 对比度 Lab颜色空间中，L亮度；a的正数代表红色，负端代表绿色；b的正数代表黄色，负端代表兰色。不像RGB色彩空间，Lab颜色被设计来接近人类视觉。 因此L分量可以调整亮度对，修改a和b分量的输出色阶来做精确的颜色平衡。 注意：在MaixPy的查找色块的算法中，运用的就是这个LAB模式！ 光源的选择 如果你的机器是在工业上，或者24小时长时间运行的设备，保持一个稳定的光源是至关重要的，尤其在颜色算法中。亮度一变，整个颜色的值会变化的很大！ ## 镜头的焦距 因为图像是通过镜头的光学折射，照到感光元件上的。那么镜头就决定了，整个画面的大小和远近。一个最重要的参数就是焦距。 ![focal_distance](../../assets/other/focal_distance.jpg) **镜头焦距**：是指镜头光学后主点到焦点的距离，是镜头的重要性能指标。镜头焦距的长短决定着拍摄的成像大小，视场角大小，景深大小和画面的透视强弱。当对同一距离远的同一个被摄目标拍摄时，镜头焦距长的所成的象大，镜头焦距短的所成的象小。注意焦距越长，视角越小。 还有一点是镜头的畸变，因为光学原理，在感光芯片上不同的位置，与镜头的距离不同的，简单说就是近大远小，所以在边缘会出现鱼眼效果(桶型畸变)。为了解决这个问题，可以在代码中使用算法来矫正畸变，注：MaixPy中使用image.lens_corr(1.8)来矫正2.8mm焦距的镜头。也可以直接使用无畸变镜头。无畸变镜头加入了额外的矫正透镜部分，价格自然会高不少。 ## 镜头的滤片 在镜头上，通常会有一个滤片。 ![camera sensor](../../assets/other/sensor_1.png) 这个滤片是做什么的呢？ 我们知道，不同颜色的光，是波长不一样。在正常环境中，除了可见光，还有很多红外光，在夜视中，用的就是红外光。 但是，在正常颜色应用中，是不需要红外光的，因为红外光也会使感光元件受到反应，就使得整个画面泛白。所以我们在镜头上放一个只能通过波长 650nm 以内的滤光片，将红外光进行过滤。"},"/soft/maixpy/zh/get_started/get_started_edit_file.html":{"title":"编辑并执行文件","content":" title: 编辑并执行文件 keywords: maixpy, k210, AIOT, 边缘计算, maixpy入门 desc: maixpy 编辑并执行文件 ## MaixPy 内置了文件系统 前面说了， `MaixPy` 支持 `Flash` 使用的 `SPIFFS`（目前不支持创建目录）, 默认分配了 `3MB` 给 `SPIFF`（从`flash` `0xD00000`地址开始 `3M`）, 开机自动挂载到 `/flash` 目录下 也支持 `FAT32` 格式`MBR`分区的 `Micro SD （TF）`卡 ,开机自动挂在到 `/sd` 目录下 需要注意的是, 根目录只是用来挂载 Flash 或者 SD 卡, 具体的文件在 `/flash` 或者 `/sd` 目录下 ## 为什么需要编辑并执行文件 在前面的实验中,我们直接在终端里面敲代码来一句一句执行,这样也简单方便,我们输入命令后会立即执行并及时得到返回的结果,这种交互方式称为 **`REPL（Read Eval Print Loop：交互式解释器）`**, 这种方式的好处就是简单方便,使用起来和 Linux 终端十分相似,只是使用的语法换成了 MaixPy(Micropython)的语法。 但是在实际运行的时候，我们希望代码保存在文件系统， 需要运行是直接运行文件，这样我们不用每次都敲代码,减少了很多麻烦 ## 编辑并保存文件 ### 方法一： 使用内置编辑器 [Micropython Editor(pye)](https://github.com/robert hh/Micropython Editor) 在 MaixPy 中, 我们内置了一款编开源编辑器 [Micropython Editor(pye)](https://github.com/robert hh/Micropython Editor) 使用 `os.listdir()` 可以查看当前目录下的文件, 使用 `pye(\"hello.py\")` 可以创建文件并进入编辑模式, 快捷键等使用说明可以在[这里查看](https://github.com/robert hh/Micropython Editor/blob/master/Pyboard%20Editor.pdf) 比如我们写入代码 ```python print(\"hello maixpy\") ``` 然后按 `Ctrl+S` 按 `Enter` 键保存, 按 `Ctrl+Q` 退出编辑 **注意**： 使用这款编辑器对使用的串口工具有一定要求, 必须将 `BackSpace` 按键设置为 `DEL` 功能, 否则按 `BackSpace` 调用的是 `Ctrl+H` 一样的功能（即字符替换）。 Linux 下推荐使用 `minicom`, 需要使用 `sudo minicom s` 来设置,参考[前面的教程](env_serial_tools.html) Windows 下也一样, 根据自己使用的工具上网搜设置方法, 比如 `xshell` 搜 `xshell如何设置backspace为del` 得到结果： `文件` > `属性` > `终端` > `键盘`, 把 delete 和 backspace 序列改为 ASCII 127 即可. ### 方法二： 使用 MaixPy IDE 打开 `MaixPy IDE`, 连接开发板 编辑文件,然后在顶端`Tool`（工具）菜单中, 使用顶端`Tool`(工具)菜单中的`发送文件`功能来发送文件,会保存到开发板并且文件名和电脑上的文件名相同 当然也可以点击`将打开的文件保存为 boot.py` 来将代码保存到开发板的`boot.py`文件,中,下次开发板开机上电会自动执行这个文件 ![](../../assets/maixpy/maixpy_ide_tools.png) ### 方法三： 使用工具 [uPyLoader](https://github.com/BetaRavener/uPyLoader) 读取到 PC（电脑)上编辑后再保存到开发板 下载可执行文件:[release](https://github.com/BetaRavener/uPyLoader/releases) ![uPyLoader](../../assets/other/uPyLoader.png) 选择串口并点击 `Connect` 按钮来连接板子 第一次运行该软件需要初始化, 点击 `File >Init transfer files` 来完成初始化,这会在板子里创建两个文件,分别是 `__upload.py` 和 `__download.py`。 然后双击文件名即可打开文件并编辑,编辑完成后点击 `save` 来保存到开发板即可 ### 方法四： 使用工具 [rshell](https://github.com/dhylands/rshell) 读取到 PC（电脑)上编辑后再保存到开发板 按照 `rshell` [项目主页](https://github.com/dhylands/rshell)的说明安装好 `rshell` ```shell sudo apt get install python3 pip sudo pip3 install rshell rshell p /dev/ttyUSB1 # 这里根据实际情况选择串口 ``` 编辑文件 ```python ls /flash edit /flash/boot.py # 编辑器使用方法和 vim 一样 ``` ## 执行文件 使用 `os.chdir()` 切换当前目录到文件的目录,比如 `os.chdir(\"/flash\")` ### 方法一： `import` 然后执行 `import hello` 即可看到输出 `hello maixpy` 使用此方法简单易用,但是需要注意的是, 目前 `import` 只能使用一次, 如果第二次 `import`, 则文件不会再执行, 如果需要多次执行,建议使用下面的方法 而且 `import` 也不会执行`if __name__ \"__main__\":`条件下的代码，需要注意 ### 方法二： `exec()` 使用 `exec()` 函数来执行 ```python with open(\"hello.py\") as f: exec(f.read()) ``` ### 方法三： 使用 **MaixPy IDE** 来执行 打开文件, 然后点击执行按钮来执行，**注意**：这样执行代码和 `REPL`执行代码类似，只是将程序发送到开发板，并没有保存到文件系统，是一次性执行的 ![](../../assets/maixpy/maixpy_connect success.png) ### 方法四： 使用 uPyLoader 来执行 连接好后选中文件, 点击 `excute` 按钮来执行文件 ### 方法五： 使用 ampy 来直接运行电脑上的文件 [ampy](https://github.com/pycampers/ampy) 执行命令 `ampy run file_in_PC.py` 来执行位于电脑上的文件（文件不会保存到开发板） ## MaixPy 支持挂载文件系统到电脑么 不支持， 因为使用的芯片 k210 没有 USB 功能， 无法模拟 U 盘设备，所以不能像 Microbit 和 STM32 的 Micropython 一样虚拟一个 U 盘"},"/soft/maixpy/zh/get_started/mpfshell-lite/English.html":{"title":"&emsp;&emsp;&emsp;&emsp;A Shell Type Micropython File Explorer⛺","content":"# &emsp;&emsp;&emsp;&emsp;A Shell Type Micropython File Explorer⛺ [中文文档](index.html) [![MIT](https://img.shields.io/badge/license MIT blue.svg)](./LICENSE) [![PyPI version](https://badge.fury.io/py/mpfshell lite.svg)](https://badge.fury.io/py/mpfshell lite) The lite version of this mpfshell is an aggressive development version. The stable version is available at [mpfshell](https://github.com/wendlers/mpfshell). ## Features: 1. Compact, full featured MicroPython management tools, such as: put\\get\\cat\\rm\\execfile and so on. 2. Fixed the problem of massive use of Windows, such as path, garbled code, etc., but some problems are still being solved in succession. 3. Green single file under Windows, out of the box, or using Python for cross platform operation. ## System requirements Python 3.5.4 + requirements.txt ## Uasge ### 1. into [releases](https://github.com/junhuanchen/mpfshell lite/releases) download mpfs.exe. Find the version of the system you are using and download it. ![](readme/00.png) ### 2. Install using PIP Using the Python PIP tool to download and install, in the console input ` pip insrall mpfshell lite`, then enter `mpfs` can run. ```shell pip install mpfshell lite mpfs ``` ![](readme/01.png) ## Connect your hardware Connect to your hardware and the port number of the current hardware will appear. ``` looking for all port... serial name : USB SERIAL CH340 (COM5) : COM5 input ' open COM5 ' and enter connect your board. ``` Enter 'open COM5' as shown in the figure to connect. ![](readme/05.png) You can see ` Connected to esp32 ` already Connected. ## Run micropython code. ### 1.Run the code directly ``` mpfs [/]> view looking for all port... serial name : USB SERIAL CH340 (COM5) : COM5 current open_args ser:COM5 mpfs [/]> open COM5 Connected to esp32 mpfs [/]> exec print('hello world!') hello world! mpfs [/]> ``` ![](readme/07.png) ### 2.Run the code file Prepare a Python code file (.py) on your desktop ```python print('hello world!') ``` ![](readme/09.png) use the exe version ![](readme/11.png) Put exe with .py and follow these commands. ``` looking for all port... serial name : USB SERIAL CH340 (COM5) : COM5 input ' open COM5 ' and enter connect your board. ** Micropython File Shell v0.9.1, sw@kaltpost.de & juwan@banana pi.com ** Running on Python 3.5 using PySerial 3.3 mpfs [/]> open com5 Connected to esp32 mpfs [/]> runfile ts.py hello world! Connected to esp32 mpfs [/]> ``` ![](readme/13.png) use the PIP version In CMD console mode, you need to use the following command to locate the folder path (LCD) and then run the file (runfile). You can use the LCD location to run a file path, such as `lcd C:/Users/Juwan/Desktop` (note that is `/` is not `\\`, this let a person tired) ``` mpfs [/]> open com5 Connected to esp32 mpfs [/]> lcd Desktop mpfs [/]> lls Local files: <dir> blog desktop.ini editor.exe mpfs 0.9.1.exe ts.py mpfs [/]> runfile ts.py hello world! Connected to esp32 mpfs [/]> ``` ![](readme/15.png) ## Use help In the program, you can also get the details of the corresponding command description or parameters by using the help + command. ![](readme/17.png) For example: `help cd`， returns the `cd <TARGET DIR> ​ Change current remote directory to given target.`。 You can see that it is used to change the current file directory starting point in the target board, equivalent to setting the default path of the folder in the board. ## Common mistakes If there is a dead loop without any delay in the connection process, it will affect the success of the software connection board, especially the dead loop of main.py without delay, which will lead to the failure to connect to the hardware after power on. You can reset the connection rm main.py, which needs to be noted. ## Dissection tool ### 0. Supported version of the system system type system version running condition notes Windows win7 win10 normal native CMD does not support TAB Linux luubuntu normal native Shell supports TAB Mac Darwin normal is consistent with Unix ### 1. Important functional operations operation method different system tools support run effect notes Enter something and complete it with the TAB key Only the shell, repl, powershell support. If you want to type \"import\", you only need to input \"i\" and then press the TAB key to complete it automatically. For example, in Linux, you can input \"ttyUSB0\" and only need \"i + TAB\". It can only input completion history. Left copy selection, right paste selection Windows only system support. Open the CMD console program attributes in the quick edit function, can let the program supports the mouse to click suspended after some drag copying the text content. Are generally choose a line. Up, down, left and right buttons and backspace all supports. You can modify what you've typed. Fixes were made for Windows ### 2. All of the use of the command Command the braces for short, easy to use. command type USES method to run the result note open (o) opens the current device. Format: a serial port cable ` open com3 `, wireless ` ws: 192.168.10.114, 1234 ` connection after a successful return to ` Connected to esp32 ` control board before, need to open the connection first. The parentheses are shorthand. close closes the current device. quit (q) enters exit the program EOF enters exit the program cat (c) Enter the file name, such as `cat boot.py` Prints out the contents of the specified file on the board for quick viewing. put Push files from the current directory to the board, for example `put boot.py` Failure returns an error message get Gets the files in the current directory of the board, for example `get boot.py` Boot.py is added to the directory where the program is running (lpwd) mput Opposite to put mget Opposite to put repl (e) Enter python's repl control interface You can execute python code directly. exec (e) input Python Code, for example `exec print('hello')` Returns the run result of print('hello') Only one line of python code can be executed. execfile (ef) Python files that exist in the execution board, for example `execfile main.py` Execute the effect of main.py lexecfile (lef) A python file that exists under the execution program, for example `lexecfile main.py` Execute the effect of main.py Unlike runfile will enter repl mode, so support input() operations. runfile (rf) It combines the put and execfile commands cd input Specify the directory in the board, for example `cd /` 或 `cd D:/Users` Modify the program to access the board of the directory To ` / ` separate Linux path. md input Directory name Create a new directory on the board lcd input Specifies the current directory in the program, for example `cd /` Modify the directory in which the program accesses the board To ` / ` separate Linux path. pwd input`pwd` Returns the directory on the current board lpwd input `lpwd` Returns the directory in which the current program resides mpyc input Python files in the current directory, for example `mpyc main.py` Pyc python code static compilation code processing, generate main.pyc need to have mpy cross command in the system mrm Enter the specified directory or file name `rm Directory or file name` Removes the directory or file name from the system rm Enter the specified directory or file name `rm Directory or file name` Removes the directory or file name from the board ls input` ls /` View all files in the board's current directory lls input `lls /` View all files in the program's current directory view input `view` View the possible serial ports on the machine, and the current open configuration help View the help command, for example : `help lls` # pyinstaller 1. create mpfs.exe pyinstaller F mpfs i logo.ico # uplaod pypi ```shell python setup.py sdist build ``` ```shell # pip install twine twine upload dist/* verbose ```"},"/soft/maixpy/zh/get_started/mpfshell-lite/mpfshell-lite-help.html":{"title":"Document","content":"# Document ### Mpfshell 使用手册 由于本章涉及的内容不适合图示说明，所以均已表格或文字说明。 在 python3.5 以上使用命令 `pip install mpfshell lite` 即可安装，接着输入 `mpfshell lite` 即可打开运行。 ##### 0. 了解不同的支持版本 系统类型 系统版本 运行情况 注意事项 Windows WIN7 WIN10 正常 原生 CMD 不支持 TAB Linux Lubuntu Ubuntu 正常 原生 Shell 支持 TAB Mac Darwin 正常 与 Unix 均一致 ##### 1. 了解重要的功能操作 操作方法 不同系统工具支持情况 运行效果 注意事项 输入一些内容后通过 TAB 键补全 仅 shell、repl、powershell 支持。 如果想要打 import 只需要 输入 i 后在按下 TAB 键就可以自动补全了，比如 linux 下，输入 ttyUSB0，只需要 i + TAB 键就可以了。 前提是，该命令被系统提前输入过，否则它没办法补全，它只能补全历史输入的信息。 左键复制选取，右键粘贴选取 仅 Windows的系统支持。 开启 **CMD控制台** 程序的属性里的 **快速编辑** 功能，可以让程序支持鼠标 点击暂停程序后点左键拖动复制文本内容。 如果选取的是多行代码或命令，不代表可以直接使用，所以一般都是选取一行的。 上下左右按键及退格 均支持 上下按键可以切换读取历史输入过的命令，左右方向键以及程序退格操作可以对自己输入过的内容进行修改。 仅针对windows做了修复。 ##### 2. 了解所有功能的命令 命令类型 使用方法 运行结果 注意事项 open(o) 打开当前设备。格式有：有线串口 `open com3`，无线有 `ws:192.168.10.114,1234` 连接成功后返回 `Connected to esp32` 控制板子前，需要先打开连接。括号为简写。 close 关闭当前设备。 quit 输入 退出程序 EOF 输入 退出程序 无 cat 输入 文件名，例如 `cat boot.py` 将板子的指定文件打印出来快速查看。 无 put 把当前目录下的文件推送到板子，例如`put boot.py` 无 失败会返回错误信息 get 获取板子当前目录下的文件，例如`get boot.py` 在程序运行的目录下多了一个 boot.py 文件 mput 与 put 相对，以板子为主，对程序的目录操作。 mget 与 get 相对，以板子为主，对程序的目录操作。 repl(e) 进入 python 的 repl 控制接口 可以直接执行python代码。 exec (e) 输入 Python 代码，例如`exec print('hello')` 返回print('hello')的运行结果 hello 只能执行一行 python 代码。括号为简写。 execfile(ef) 执行板子中存在的python文件，例如`execfile main.py` 执行 main.py 的效果 括号为简写。 lexecfile(ef) 执行程序下存在的python文件，例如`lexecfile main.py` 执行 main.py 的效果 括号为简写，与 runfile 不同的是会进入repl模式，所以支持input操作。 runfile(rf) 结合了 put 和 execfile 命令 括号为简写。 cd 输入 指定板子里的目录，例如 `cd /` 修改程序访问板子的所处目录 以 `/` 开头的linux路径，尽量不要改变路径，除非你十分清楚自己在做什么。 md 输入 目录名称 在板子上新建一个目录 无 lcd 输入 指定现在程序里的目录，例如 `cd /` 修改程序访问板子的所处目录 以 `/` 开头的linux路径，尽量不要改变路径，除非你十分清楚自己在做什么。 pwd 输入`pwd` 返回当前板子所处的目录 无 lpwd 输入 `lpwd` 返回当前程序所处的目录 无 mpyc 输入 当前目录下的 python 文件，例如 `mpyc main.py` 把 python 代码 pyc 化静态编译代码处理，生成 main.pyc mrm 输入程序当前的 `rm 目录或文件名` 移除该目录或文件名 rm 输入板子当前的 `rm 目录或文件名` 移除该目录或文件名 ls 输入` ls /` 查看 板子 当前目录下的所有文件 lls 输入 `lls /` 查看 程序 当前目录下的所有文件 view 输入 `view` 查看 本机 可能的串口，和当前的 open 配置 help 查看命令的帮助，详细看本节结尾。 在程序中，你也可以通过 help + 命令 的方式获取对应的命令说明或参数等细节。 例如：`help cd`， 返回的是 `cd <TARGET DIR> ​ Change current remote directory to given target.`。 可以得知 它是用来改变 目标板子里的当前文件目录起点，相当于设置板子的文件夹默认路径在什么位置。 提示：连接板子的时候，要特别注意死循环，如果在连接过程中板子存在没有任何延时的死循环，则会影响软件连接板子的成功率，尤其是没有延时的 mian.py 死循环，这会导致上电后将无法连接无线模式，这点需要注意，不过，有线串口的连接不成功则会进行板子的复位。"},"/soft/maixpy/zh/get_started/mpfshell-lite/mpfshell-lite.html":{"title":"&emsp;&emsp;&emsp;一款 Shell 型 MicroPython 文件资源管理器⛺","content":"# &emsp;&emsp;&emsp;一款 Shell 型 MicroPython 文件资源管理器⛺ [English Docs](English.html) [![MIT](https://img.shields.io/badge/license MIT blue.svg)](./LICENSE) [![PyPI version](https://badge.fury.io/py/mpfshell lite.svg)](https://badge.fury.io/py/mpfshell lite) 这个 mpfshell 的 lite 版是开发十分激进的版本，稳定版请参见 [mpfshell](https://github.com/wendlers/mpfshell) 。 ## 特点： 1. 体积迷你，功能齐全的 MicroPython 管理工具，如：put\\get\\cat\\rm\\execfile 等等。 2. 修复 Windows 大量使用问题，路径、乱码等等，但还是存在一些问题在陆续解决。 3. Windows 下绿色单文件，开箱即用，也可使用 Python 跨平台运行。 ## 系统要求 Python 3.5.4 + requirements.txt ## 使用方法 ### 1. 到 [releases](https://github.com/junhuanchen/mpfshell lite/releases) 下载 mpfs.exe。 寻找你所用的系统版本并下载，如果下载很慢，可以用[微云地址](https://share.weiyun.com/5qIHqWY)，下载后双击运行它。 ![](readme/00.png) ### 2. 使用 PIP 安装 使用 Python 的 PIP 工具下载并安装，在控制台中输入`pip install mpfshell lite`，然后输入 `mpfs` 即可运行。 ```shell pip install mpfshell lite mpfs ``` ![](readme/01.png) ## 连接你的硬件 连接你的硬件，此时会出现当前硬件的端口号。 ``` unix looking for all port... serial name : USB SERIAL CH340 (COM5) : COM5 input ' open COM5 ' and enter connect your board. ``` 输入如图的 'open COM5' 即可连接。 ![](readme/05.png) 可以看到 `Connected to esp32` 已经连接了。 ### 进入 REPL 模式 ``` unix mpfs [/]> open looking for all port... Connected to esp32 mpfs [/]> repl > *** Exit REPL with Ctrl+Q *** MicroPython v1.10 220 ged36cfd56 dirty on 2019 05 28; ESP32 module with ESP32 Type \"help()\" for more information. >>> ``` ![](readme/06.png) ## 运行 micropython 代码。 ### 1.直接运行代码 ``` unix mpfs [/]> view looking for all port... serial name : USB SERIAL CH340 (COM5) : COM5 current open_args ser:COM5 mpfs [/]> open COM5 Connected to esp32 mpfs [/]> exec print('hello world!') hello world! mpfs [/]> ``` ![](readme/07.png) ### 2.运行代码文件 在 桌面 准备一个 Python 代码文件（.py） ```python print('hello world!') ``` ![](readme/09.png) 使用 exe 版本 ![](readme/11.png) 将 exe 与 .py 放在一起，按以下命令操作。 ``` unix looking for all port... serial name : USB SERIAL CH340 (COM5) : COM5 input ' open COM5 ' and enter connect your board. ** Micropython File Shell v0.9.1, sw@kaltpost.de & juwan@banana pi.com ** Running on Python 3.5 using PySerial 3.3 mpfs [/]> open com5 Connected to esp32 mpfs [/]> runfile ts.py hello world! Connected to esp32 mpfs [/]> ``` ![](readme/13.png) 使用 PIP 版本 在 CMD 的控制台模式下，需要使用以下命令，先定位文件夹路径（lcd），再运行文件（runfile）。 可以使用 lcd 定位到运行文件的路径下，如 `lcd C:/Users/Juwan/Desktop` （注意是 / 不是 \\，这让人很烦） ``` unix mpfs [/]> open com5 Connected to esp32 mpfs [/]> lcd Desktop mpfs [/]> lls Local files: <dir> blog desktop.ini editor.exe mpfs 0.9.1.exe ts.py mpfs [/]> runfile ts.py hello world! Connected to esp32 mpfs [/]> ``` ![](readme/15.png) ## 使用帮助 在程序中，你也可以通过 help + 命令 的方式获取对应的命令说明或参数等细节。 ![](readme/17.png) 例如：`help cd`， 返回的是 `cd <TARGET DIR> ​ Change current remote directory to given target.`。 可以得知 它是用来改变 目标板子里的当前文件目录起点，相当于设置板子的文件夹默认路径在什么位置。 ## 常见错误 连接硬件的时候，要特别注意死循环，如果在连接过程中板子存在没有任何延时的死循环，则会影响软件连接板子的成功率，尤其是没有延时的 main.py 死循环，这会导致上电后将无法连接硬件，你可以在复位连接后 rm main.py，这点需要注意，不过，有线串口的连接不成功则会进行板子的复位（ Mac 例外）。 ## 详解工具 ### 0. 支持的系统版本 系统类型 系统版本 运行情况 注意事项 Windows WIN7 WIN10 正常 原生 CMD 不支持 TAB Linux Lubuntu Ubuntu 正常 原生 Shell 支持 TAB Mac Darwin 正常 与 Unix 均一致 ### 1. 重要的功能操作 操作方法 不同系统工具支持情况 运行效果 注意事项 输入一些内容后通过 TAB 键补全 仅 shell、repl、powershell 支持。 如果想要打 import 只需要 输入 i 后在按下 TAB 键就可以自动补全了，比如 linux 下，输入 ttyUSB0，只需要 i + TAB 键就可以了。 前提是，该命令被系统提前输入过，否则它没办法补全，它只能补全历史输入的信息。 左键复制选取，右键粘贴选取 仅 Windows的系统支持。 开启 **CMD控制台** 程序的属性里的 **快速编辑** 功能，可以让程序支持鼠标 点击暂停程序后点左键拖动复制文本内容。 如果选取的是多行代码或命令，不代表可以直接使用，所以一般都是选取一行的。 上下左右按键及退格 均支持 上下按键可以切换读取历史输入过的命令，左右方向键以及程序退格操作可以对自己输入过的内容进行修改。 仅针对windows做了修复。 ### 2. 所有命令的用法 命令中的括号为简写，方便使用。 命令类型 使用方法 运行结果 注意事项 open (o) 打开当前设备。格式有：有线串口 `open com3`，无线有 `ws:192.168.10.114,1234` 连接成功后返回 `Connected to esp32` 控制板子前，需要先打开连接。括号为简写。 close 关闭当前设备。 quit (q) 输入 退出程序 EOF 输入 退出程序 无 cat (c) 输入 文件名，例如 `cat boot.py` 将板子的指定文件内容打印出来，以便快速查看。 无 put 把当前目录下的文件推送到板子，例如`put boot.py` 无 失败会返回错误信息 get 获取板子当前目录下的文件，例如`get boot.py` 在程序运行的目录（lpwd）下多了一个 boot.py 文件 mput 与 put 相对，以板子为主，对程序的目录操作。 mget 与 get 相对，以板子为主，对程序的目录操作。 repl (e) 进入 python 的 repl 控制接口 可以直接执行python代码。 exec (e) 输入 Python 代码，例如`exec print('hello')` 返回print('hello')的运行结果 hello 只能执行一行 python 代码。括号为简写。 execfile (ef) 执行板子中存在的python文件，例如`execfile main.py` 执行 main.py 的效果 括号为简写。 lexecfile (lef) 执行程序下存在的python文件，例如`lexecfile main.py` 执行 main.py 的效果 括号为简写，与 runfile 不同的是会进入repl模式，所以支持input操作。 runfile (rf) 结合了 put 和 execfile 命令 括号为简写。 cd 输入 指定板子里的目录，例如 `cd /` 或 `cd D:/Users` 修改程序访问板子的所处目录 以 `/` 分隔的linux路径。 md 输入 目录名称 在板子上新建一个目录 无 lcd 输入 指定现在程序里的目录，例如 `cd /` 修改程序访问板子的所处目录 以 `/` 分隔的linux路径。 pwd 输入`pwd` 返回当前板子所处的目录 无 lpwd 输入 `lpwd` 返回当前程序所处的目录 无 mpyc 输入 当前目录下的 python 文件，例如 `mpyc main.py` 把 python 代码 pyc 化静态编译代码处理，生成 main.pyc 需要系统里有 mpy cross 命令 mrm 输入指定的目录或文件名 `rm 目录或文件名` 移除系统里的该目录或文件名 rm 输入指定的目录或文件名 `rm 目录或文件名` 移除板子里的该目录或文件名 ls 输入` ls /` 查看 板子 当前目录下的所有文件 lls 输入 `lls /` 查看 程序 当前目录下的所有文件 view 输入 `view` 查看 本机 可能的串口，和当前的 open 配置 help 查看命令的帮助，例如：`help lls` # pyinstaller 1. create mpfs.exe pyinstaller F mpfs i logo.ico # uplaod pypi ```shell python setup.py sdist build ``` ```shell # pip install twine twine upload dist/* verbose ```"},"/soft/maixpy/zh/get_started/knowledge_micropython.html":{"title":"MicroPython 背景知识","content":" title: MicroPython 背景知识 keywords: maixpy, k210, AIOT, 边缘计算, maixpy入门, 人工智能 desc: maixpy MicroPython 背景知识 由于 **MaixPy** 是基于 **MicroPython** 之上进行开发构建的, 提供给用户最终的接口是 **Micropython** ，所以在使用 MaixPy 开发之初我们需要熟悉下 `MicroPython` 的基础知识与语法 ## 关于 MicroPython: MicroPython 是编程语言 Python3 的精简高效实现，语法和 Python3 保持一致，但只实现了 Python 标准库的一小部分，并且经过优化，可以在 MCU ， WIFI SOC 上等资源受限的环境中使用，所以我们在使用 MicroPython 需要了解其语法。 如果之前有 **C/C++/Java** (或任何其他语言)的编程经验，推荐 [《廖雪峰的 Python 教程》](https://www.liaoxuefeng.com/wiki/1016959663602400) 如果之前没有任何编程经验，推荐 [《笨方法学 Python》](https://wizardforcel.gitbooks.io/lpthw/content/) ## REPL 和 串口 首先，断开开发板与 MaixPy IDE 的连接，否则串口会冲突！ 打开 MaixPy IDE 中的终端窗口 print('The quick brown fox', 'jumps over', 'the lazy dog') 输出: ``` The quick brown fox jumps over the lazy dog ``` print() 会依次打印每个字符串，遇到逗号“,”会输出一个空格，因此，输出的字符串是这样拼起来的： > The quick brown fox jumps over the lazy dog print() 也可以打印整数，或者计算结果： ```python print(300) 300 print(100 + 200) 300 ``` 因此, 我们可以把计算100 + 200的结果打印得更漂亮一点: ```python print('100 + 200 ', 100 + 200) 100 + 200 300 ``` 注意, 对于 100 + 200, Python 解释器自动计算出结果 300，但是 '100 + 200 ' 是字符串而非数学公式，Python 把它视为字符串。 ## MicroPython 基本语法 ### 变量 在 Python 中，等号 ` ` 是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，例如： ```python a 123 # a是整数 print(a) a 'ABC' # a变为字符串 print(a) ``` 这种变量本身类型不固定的语言称之为**动态语言**，与之对应的是 **静态语言**。 静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如 Java 是静态语言，赋值语句如下(// 表示注释)： ```java int a 123; // a是整数类型变量 a \"ABC\";// 错误:不能把字符串赋给整型变量 ``` 和静态语言相比，动态语言更灵活，就是这个原因。 ### list 列表 Python 内置的一种数据类型是**列表**：**list**.<br/> **list** 是一种有序的集合, 可以随时添加和删除其中的元素. 比如, 列出班里所有同学的名字, 就可以用一个 **list** 表示: ```python classmates ['Michael', 'Bob', 'Tracy'] classmates ['Michael', 'Bob', 'Tracy'] ``` 变量 classmates 就是一个 `list`.<br/> 用 `len()` 函数可以获得 list 元素的个数: ```python len(classmates) 3 ``` 用索引来访问 list 中每一个位置的元素, 索引是从 0 开始的: ```python classmates[0] 'Michael' classmates[1] 'Bob' classmates[2] 'Tracy' classmates[3] Traceback (most recent call last): File \"<stdin>\", line 1, in <module> IndexError: list index out of range ``` 当索引超出了范围时，Python 会报一个 IndexError 错误，所以，要确保索引不要越界，记得最后一个元素的索引是 len(classmates) 1。 如果要取最后一个元素，除了计算索引位置外，还可以用 1 做索引，直接获取最后一个元素： ```python classmates[ 1] 'Tracy' ``` 以此类推，可以获取倒数第2个、倒数第3个： ```python classmates[ 2] 'Bob' classmates[ 3] 'Michael' classmates[ 4] Traceback (most recent call last): File \"<stdin>\", line 1, in <module> IndexError: list index out of range ``` 当然，倒数第 4 个就越界了。 list 是一个**可变**的**有序表**，所以可以往 list 中追加元素到末尾： ```python classmates.append('Adam') classmates ['Michael', 'Bob', 'Tracy', 'Adam'] ``` 也可以把元素插入到指定的位置，比如索引号为1的位置： ```python classmates.insert(1, 'Jack') classmates ['Michael', 'Jack', 'Bob', 'Tracy', 'Adam'] ``` 要删除 list 末尾的元素, 用 pop() 方法： ```python classmates.pop() 'Adam' classmates ['Michael', 'Jack', 'Bob', 'Tracy'] ``` 要把某个元素替换成别的元素, 可以直接赋值给对应的索引位置: ```python classmates[1] 'Sarah' classmates ['Michael', 'Sarah', 'Tracy'] ``` list 里面的元素的数据类型也可以不同, 比如: ```python L ['Apple', 123, True] ``` 如果一个 list 中一个元素也没有，就是一个空的 list，它的长度为 0： ```python L [] len(L) 0 ``` ### tuple 元组 另一种有序列表叫元组: **tuple**.<br/> tuple 和 list 非常类似，但是 `tuple` 一旦初始化就不能修改，比如同样是列出同学的名字： ```python classmates ('Michael', 'Bob', 'Tracy') ``` 现在，classmates 这个 **tuple** 不能变了，它也没有 append(), insert() 这样的方法.其他获取元素的方法和 list 是一样的, 你可以正常地使用 classmates[0], classmates[ 1], 但不能赋值成另外的元素. 不可变的 tuple 有什么意义？因为 tuple 不可变, 所以代码更安全。 如果可能，能用 tuple 代替 list 就尽量用 tuple。 tuple 的陷阱:当你定义一个 tuple 时, 在定义的时候, tuple 的元素就必须被确定下来, 比如: ```python t (1, 2) t (1, 2) ``` 但是, 要定义一个 只有1个元素的 tuple, 如果你这么定义: ```python t (1) t 1 ``` 但此时,定义的不是 tuple, t 是整型变量, 变量 t 的值为1! <br/> 这是因为括号()既可以表示tuple, 又可以表示数学公式中的小括号, 这就产生了歧义, 因此, Python规定, 这种情况下, 按小括号进行计算, 计算结果自然是1. 所以, 只有 1 个元素的 **tuple** 定义时必须加一个逗号`,`, 来消除歧义: ```python t (1,) t (1,) ``` Python在显示只有 1 个元素的 tuple 时, 也会加一个逗号`,`, 以免你误解成数学计算意义上的括号. ### 条件判断 if 语句的完整形式是: ``` if <条件判断1>: <执行1> elif <条件判断2>: <执行2> elif <条件判断3>: <执行3> else: <执行4> ``` 比如: ```python age 20 if age > 6: print('teenager') elif age > 18: print('adult') else: print('kid') ``` ### 循环 Python 的循环有两种, 一种是 `for...in` 循环, 依次把 list 或 tuple 中的每个元素迭代出来, 看例子: ```python names ['Michael', 'Bob', 'Tracy'] for name in names: print(name) ``` 执行这段代码, 会依次打印 names 的每一个元素: ```python Michael Bob Tracy ``` 所以 `for x in ...` 循环就是把每个元素代入变量x, 然后执行缩进块的语句. 如果要计算 1 100 的整数之和, 从 1 写到 100 有点困难, 幸好 Python提供一个 range() 函数, 可以生成一个整数序列, 再通过 list() 函数可以转换为 list.<br/> 比如 range(5) 生成的序列是从 0 开始小于 5 的整数: ```python list(range(5)) [0, 1, 2, 3, 4] ``` range(101) 就可以生成 0 100 的整数序列, 计算如下: ```python sum 0 for x in range(101): sum sum + x print(sum) ``` 第二种循环是 `while 循环`, 比如我们要计算 100 以内所有奇数之和, 可以用 while 循环实现: ```python sum 0 n 99 while n > 0: sum sum + n n n 2 print(sum) ``` ### 数据类型转换 Python 内置的常用函数还包括数据类型转换函数, 比如 int() 函数可以把其他数据类型转换为整数: ```python >>> int('123') 123 >>> int(12.34) 12 >>> float('12.34') 12.34 >>> str(1.23) '1.23' >>> str(100) '100' >>> bool(1) True from machine import GPIO ``` ### 函数 在 Python 中, 定义一个函数要使用 `def` 语句, 依次写出函数名、括号、括号中的参数和冒号`:`, 然后在缩进块中编写函数体, 函数的返回值用 `return` 语句返回. 我们先写一个计算 x2 的函数: ```python def power(x): return x * x ``` 对于 power(x) 函数, 参数 x 就是一个位置参数. 当我们调用 power 函数时, 必须传入有且仅有的一个参数x: ```python power(5) 25 power(15) 225 ``` 现在, 如果我们要计算 x3 怎么办?可以再定义一个 power3 函数, 但是如果要计算x4、x5……怎么办?我们不可能定义无限多个函数. 你也许想到了, 可以把 power(x) 修改为 power(x, n), 用来计算 xn , 说干就干: ```python def power(x, n): s 1 while n > 0: n n 1 s s * x return s ``` 对于这个修改后的power(x, n)函数, 可以计算任意n次方: ```python power(5, 2) 25 power(5, 3) 125 ``` 修改后的 power(x, n) 函数有两个参数: x 和 n, 这两个参数都是位置参数, 调用函数时, 传入的两个值按照位置顺序依次赋给参数x和n. ### 切片 取一个 `list` 或 `tuple` 的部分元素是非常常见的操作.比如, 一个list 如下: ```python L ['Michael', 'Sarah', 'Tracy', 'Bob', 'Jack'] ``` 取前3个元素, 用一行代码就可以完成切片: ```python L[0:3] ['Michael', 'Sarah', 'Tracy'] ``` L[0:3] 表示, 从索引 0 开始取, 直到索引 3 为止, 但不包括索引3.即索引0, 1, 2, 正好是3个元素. 如果第一个索引是0, 还可以省略: ```python L[:3] ['Michael', 'Sarah', 'Tracy'] ``` 也可以从索引1开始, 取出2个元素出来: ```python L[1:3] ['Sarah', 'Tracy'] ``` `tuple` 也是一种 list, 唯一区别是 `tuple` 不可变.因此, `tuple` 也可以用切片操作, 只是操作的结果仍是 `tuple`: ```python (0, 1, 2, 3, 4, 5)[:3] (0, 1, 2) ``` `字符串` 'xxx' 也可以看成是一种 `list`, 每个元素就是一个字符.因此, 字符串也可以用切片操作, 只是操作结果仍是字符串: ```python 'ABCDEFG'[:3] 'ABC' ``` ### 对象 Python 是**面向对象**编程的, 比如一个 LED 灯 ```python from pyb import LED red_led LED(1) red_led.on() ``` LED 是一个**类**, red_led 就是一个**对象**, 可以对这个对象进行操作, 比如点亮 on, 关掉 off, 查看 value. ### 模块 ### 什么是模块? 随着代码的增多，在一个文件里的代码会越来越长，越来越难看懂。 为了编写可维护的代码，我们把很多函数分组，放到不同的文件里。在Python 中，一个 `.py` 文件就称之为一个**模块(Module)**. 模块有什么好处? 复用代码方便！如果我写了一个模块，你也写了一个模块，我们就有了两个模块。我们把这些模块都组织起来，大家就可以少写很多代码了！ #### 如何使用模块? ```python import time time.sleep_ms(500) ``` `import time` 就是引入 `time` 这个模块。通过 `import` 语句，就可以引入模块。 ### 更多 更多 MicroPython 基础语法教程请自行搜索。"},"/soft/maixpy/zh/get_started/upgrade_esp8285_firmware.html":{"title":"更新板载 ESP8285 固件","content":" title: 更新板载 ESP8285 固件 keywords: maixpy, k210, AIOT, ESP8285, 边缘计算 desc: maixpy 更新板载 ESP8285 固件 ## 简介： 目前 MaixPy 系列采用 M1W 模块的作为核心模块的开发板有: MaixDock(M1W)， MaixGo 通常情况下我们不需要更新模块内部 WIFI SOC ESP8285 的固件，但是如果使用过程中存在 bug，以及有新版本的固件发布时我们就可以更新固件 > MaixDock、MaixGo 使用的 M1W 模块中的 ESP8285 默认烧录的是 AT 固件 ## 验证 ESP8285 是否能够正常工作 MaixPy 验证 ESP8285 是否正常工作例程 > [查看文本末尾例程](#maixpy 例程测试) 外接 USB 转串口模块测试 使用 USB 转串口模块，按照下表连接之后上电 M1W USB 模块 说明 M1W GND GND 共地 K210 (IO6)/ESP8285 TX RX K210 (IO7)/ESP8285 RX TX k210 RST(上电之前接地，全过程拉低 RST) GND 上电之后板子会在串口输出(这里使用 XCOM, 波特率 115200) 来验证 ESP8285 是否正常启动 ![image 20200805175207487](../../assets/hardware/module_esp8285/image 20200805175207487.png) ## AT 指令集 ESP8285 和 ESP8266 为同一系列产品，使用同一套 AT 指令集 ESP8285/ESP8266/ESP32 最新 AT指令集 https://github.com/espressif/esp at/blob/v2.0.0.0_esp8266/docs/ESP_AT_Commands_Set.md ## 更新 ESP8285 固件步骤 在烧录 ESP8285 固件之前，先了解下 ESP8285 烧录原理: ### ESP8285 固件烧录原理 ESP8285 在上电时，会判断 boot stapping 管脚的状态，并决定启动(boot)模式, 如: > ets\tJan\t\t8\t2013,rst\tcause:1,\tboot\tmode:(3,2) 其中打印的 boot mode 的第一位数字（3）代表当前的 boot 模式。 Boot 模式由 strapping 管脚的 3 位值 [GPIO15， GPIO0， GPIO2] 共同决定。如下表所 示： Strapping 管脚的 3 位值/[GPIO15， GPIO0， GPIO2] Boot 模式 7 / [1， 1， 1] SDIO HighSpeed V2 IO 6 / [1， 1， 0] SDIO LowSpeed V1 IO 5 / [1， 0， 1] SDIO HighSpeed V1 IO 4 / [1， 0， 0] SDIO LowSpeed V2 IO 3 / [0， 1， 1] Flash Boot 2 / [0， 1， 0] Jump Boot 1 / [0， 0， 1] UART Boot 0 / [0， 0， 0] Remapping ESP8285 进入不同模式的 IO 电平请看如下表： 模式 CH_PD(EN) RST GPIO15 GPIO0 GPIO2 TXD0 : : : : : : UART 下载模式 高 高 低 低 高 高 Flash 运行模式 高 高 低 高 高 高 Chip 测试模式 低 即 ESP8285 进入 UART 下载模式，启动信息 mode 第一位应该为 mode:(1, X)，如下： > ets\tJan\t\t8\t2013,rst\tcause:1,\tboot\tmode:(1,1) 而以 MaixDock 为例，可以看到 MaixDock 原理图如下： ![](../../assets/hardware/maix_dock/sipeed_maix_dock_sch.png) ![](../../assets/hardware/maix_dock/sipeed_maix_dock_sch_wifi.png) ### 准备 > 这里以 MaixDock(M1W), Windows 10 系统为例 硬件: MaixDock, USB Type C 数据线 软件: ESP 固件更新工具：ESP8285 **flash_download_tools** 乐鑫官网下载链接：[**flash_download_tools**](https://www.espressif.com/zh hans/support/download/other tools) ESP8285 AT 固件： 乐鑫官方下载链接: [espressif_esp8266 at](https://www.espressif.com/zh hans/support/download/at?keys &field_type_tid%5B%5D 14) ![](../../assets/hardware/module_esp8285/image 20210105192007.png) ### Windows 使用 flash_download_tools 更新 ES8285（这里以 MaixDock 为例）： 1. 按照下面配置，连接 MaixDock, 将 USB 转串口模块和ESP8285连接，连接方式前面已经介绍 上电前 需要将 GPIO0 拉低，即将天线旁左上角的触点接地，进入 UART 下载模式。 ![](../../assets/hardware/maix_dock/maix_dock_2.jpg) 1. 打开 **flash_download_tools** 2. 下载 **MaixDock ESP8285 固件** ![](../../assets/hardware/module_esp8285/flash_download_tool.png) 3. 选择 ESP8285 串口(一般都是串口号比较大的) 4. 设置下载选项: 如图配置相应选项, 注意**波特率一定要设置为 115200** ![](../../assets/hardware/module_esp8285/flash_download_tool_ESP8285.png) 5. 点击 **Start** 更新固件，并等待完成更新 6. 验证更新是否完成 使用 XCOM 波特率 115200, 打开 ESP8285 串口，输出 `AT\\r\\n`,如图提示 `OK` 即刷入成功 ![esp8285_at.png](../../assets/hardware/maix_dock/esp8285_at.png) ### LINUX 使用 esp_tool 更新 ES8285（这里以 MaixDock 为例）： 1. 按照下面配置，连接 MaixDock, ![](../../assets/hardware/maix_dock/maixdock_pin_maps.svg) 2. 安装 esptool ```shell pip3 install esptool ``` 3. 下载 **MaixDock ESP8285 固件** ```shell ls /dev/ttyUSB* # 查看 USB 串口 esptool port /dev/ttyUSB0 write_flash 0x0 ESP8285 AT V1.7.4_8Mbit_40Mhz.bin # 烧录固件 ``` 4. 验证更新是否完成 使用串口工具， 波特率 115200, 打开 ESP8285 串口，输出 `AT\\r\\n`,如图提示 `OK` 即刷入成功 ![esp8285_at.png](../../assets/hardware/maix_dock/esp8285_at.png) ### MaixPy 例程测试： ```python import network, time from machine import UART from Maix import GPIO from fpioa_manager import fm # En SEP8285 rst #fm.register(8, fm.fpioa.GPIOHS0, force True) #wifi_en GPIO(GPIO.GPIOHS0, GPIO.OUT) #wifi_en.value(1) # En SEP8285 rst fm.register(0, fm.fpioa.GPIOHS0, force True) wifi_io15 GPIO(GPIO.GPIOHS0, GPIO.OUT) wifi_io15.value(0) fm.register(8, fm.fpioa.GPIOHS1, force True) wifi_en GPIO(GPIO.GPIOHS1, GPIO.OUT) wifi_en.value(1) # for new MaixGO board, if not, remove it #fm.register(0, fm.fpioa.GPIOHS1, force True) #wifi_io15_en GPIO(GPIO.GPIOHS1, GPIO.OUT) #wifi_io15_en.value(0) fm.register(6, fm.fpioa.UART2_RX, force True) fm.register(7, fm.fpioa.UART2_TX, force True) uart UART(UART.UART2,115200,timeout 1000, read_buf_len 4096) def wifi_enable(en): global wifi_en wifi_en.value(en) def wifi_deal_ap_info(info): res [] for ap_str in info: ap_str ap_str.split(\",\") info_one [] for node in ap_str: if node.startswith('\"'): info_one.append(node[1: 1]) else: info_one.append(int(node)) res.append(info_one) return res #wifi_enable(0) time.sleep(2) nic network.ESP8285(uart) ap_info nic.scan() ap_info wifi_deal_ap_info(ap_info) ap_info.sort(key lambda x:x[2], reverse True) # sort by rssi for ap in ap_info: print(\"SSID:{:^20}, RSSI:{:>5} , MAC:{:^20}\".format(ap[1], ap[2], ap[3]) ) ```"},"/soft/maixpy/zh/get_started/uart.html":{"title":"什么是串口","content":"# 什么是串口 ## 串口 COM口( cluster communication port )即串行通讯端口，简称串口。微机上的串口通常是9针，也有25针的接口，最大速率115200bps。 ![uart](./../../assets/get_started/uart.jpg) 1. 通常用于连接鼠标（串口）及通讯设备（如连接外置式调制解调器进行数据通讯或一些工厂的数控机接口）等。 1. 一般主板外部只有一个串口，机箱后面和并口一起的那个九孔输出端（梯形），就是COM1口，COM2口一般要从主板上插针引出。并口是最长的那个梯形口； 1. 目前主流的主板一般都只带1个串口，甚至不带，慢慢会被USB 取代。 ## USB 串口 USB，是英文Universal Serial Bus（通用串行总线）的缩写，是一个外部总线标准，用于规范电脑与外部设备的连接和通讯。是应用在PC领域的接口技术。 ![](./../../assets/get_started/usb_uart.png) USB 串口的特点 1. 可以热插拔。就是用户在使用外接设备时，不需要关机再开机等动作，而是在电脑工作时，直接将 USB 插上使用。 1. 携带方便。USB 设备大多以“小、轻、薄”见长，对用户来说，随身携带大量数据时，很方便。当然USB硬盘是首要之选了。 1. 标准统一。大家常见的是 IDE 接口的硬盘，串口的鼠标键盘，并口的打印机扫描仪，可是有了USB之后，这些应用外设统统可以用同样的标准与个人电脑连接，这时就有了 USB 硬盘、USB 鼠标、USB 打印机等等。 1. 可以连接多个设备。USB 在个人电脑上往往具有多个接口，可以同时连接几个设备，如果接上一个有四个端口的USB HUB时，就可以再连上；四个USB设备，以此类推，尽可以连下去，将你家的设备都同时连在一台个人电脑上而不会有任何问题(注：最高可连接至127个设备)。 传送速度 1. USB 1.0是在1996年出现的，速度只有1.5Mb/s(位每秒)； 1998年升级为USB 1.1，速度也大大提升到12Mb/s ； 1. USB2.0规范是由USB1.1规范演变而来的。它的传输速率达到了480Mbps，折算为MB为60MB/s，足以满足大多数外设的速率要求。 1. USB 3.0的理论速度为5.0Gb/s，其实只能达到理论值的5成，那也是接近于USB 2.0的10倍了。 1. USB 3.1，传输速度为10Gbit/s，三段式电压5V/12V/20V，最大供电100W ，新型Type C插型不再分正反。 ## 串口和 USB 串口的区别 ![](./../../assets/get_started/usb_vs_uart.png)"},"/soft/maixpy/zh/get_started/upgrade_maixpy_firmware.html":{"title":"更新 MaixPy 固件","content":" title: 更新 MaixPy 固件 keywords: maixpy, k210, AIOT, 边缘计算, maix固件 desc: maixpy 更新 MaixPy 固件 ## 准备 硬件: USB Type C 数据线 MaixPy 开发板 PC(电脑) 软件: MaixPy 开发板 USB 驱动程序 kflash_gui ## 确认驱动已经正确安装 按照前面的说明安装好驱动，并且在电脑中能看到串口设备, `Linux` 和 `Mac OS` 执行 `ls /dev/` 即可看到设备号，比如名字是`ttyUSB0`和`ttyUSB1`; `Windows`在设备管理器中查看 ## 获得升级工具 * 下载 <a href \"https://github.com/sipeed/kflash_gui/releases\" target \"_break\">kflash_gui</a>, 会得到一个压缩包 > kflash_gui 是跨平台的，可以在多个系统下工作（包括 Windows、Linux、MacOS、甚至树莓派） > 使用勘智（Kendryte）的`Windows`版本可能部分开发版无法下载成功，请使用 `kflash_gui` 这个软件来下载 * 解压到一个文件夹，双击 `kflash_gui.exe`(/`kflsh_gui`) 即可运行, `Windows`下建议右键`固定到开始页面` 或者`固定到任务栏`, `Linux` 下可以自己新建一个<a href \"https://github.com/sipeed/kflash_gui/blob/master/kflash_gui.desktop\" target \"_break\">kflash_gui.desktop</a>, 修改文件地址, 使用管理员身份复制到`/usr/share/application`目录，然后在系统菜单界面就可以看到`kflash_gui`这款应用了 * 另外也可以使用命令行版本下载 ```shell pip3 install kflash kflash help kflash p /dev/ttyUSB0 b 1500000 B goE maixpy.bin ``` ## 获得固件 * 发布版本的固件从 <a href \"https://github.com/sipeed/MaixPy v1releases\" target \"_break\">github</a> 页面下载 * 在Sipeed官方下载站获取：<a href \"http://dl.sipeed.com/MAIX/MaixPy/release/master/\" target \"_break\">下载站</a> 固件为 `.bin` 结尾或者 `.kfpkg` 的文件 >`.kfpkg`其实就是多个`.bin`文件的打包版本, 可以使用`kflash_gui`打包或者<a href \"http://blog.sipeed.com/p/390.html\" target \"_break\" >[手动打包](http://blog.sipeed.com/p/390.html)</a> ![MaixPy Firmware Type](../../assets/maixpy/firmware_type.png) ## 固件命名说明 文件名 说明 备注 `maixpy_vx.y.z_x_xxx*.bin` 默认版本的 MaixPy 固件，包含了大多数功能, 支持连接 `MaixPy IDE`, `maixpy_vx.y.z_x_xxx*_m5stickv.bin` 针对 M5Stickv 定制的固件, 支持连接 `MaixPy IDE` — `maixpy_vx.y.z_x_xxx*_with_lvgl.bin` MaixPy 固件, 支持连接 `MaixPy IDE`, 带 LVGL 版本.(LVGL是嵌入式 GUI 框架, 写界面的时候需要用到) — `maixpy_vx.y.z_x_xxx*_minimum.bin` MaixPy 固件最小集合，不支持 `MaixPy IDE`, 不包含`OpenMV`的相关算法和各种外设模块 — `maixpy_vx.y.z_x_xxx*_minimum_with_ide_support.bin` MaixPy 固件最小集合, 支持连接 `MaixPy IDE`, 不包含`OpenMV`的相关算法和各种外设模块 运行各种模型，建议使用这个 `elf_maixpy_vx.y.z_x_xxx*.7z` elf 文件，普通用户不用关心，用于死机调试 — `face_model_at_0x300000.kfpkg` 人脸模型，放置在地址位 0x300000, 可以和`.bin`分开多次下载，不冲突 — 出厂的固件是不一样的，不同的开发板，固件不一样，所以出现无法链接ide和屏幕白屏的时候，需要替换固件 ## 下载固件到开发板 * 打开 `kflash_gui` 应用 * 然后选择固件、设置选项, 点击下载即可, 更多特性介绍、使用说明见 <a herf \"https://github.com/sipeed/kflash_gui\">kflash_gui 项目主页</a> 使用时注意串口不能被其它软件占用，选择正确的开发板和串口号，可以适当降低波特率和使用低速模式来提高下载成功率 ![](../../assets/kflash_gui/kflash_gui_download.png) > 对于最早期的 `Maix Go`, 如果确认选项是对的，仍然无法下载, 可以尝试将三相拨轮按键拨向 `Down` 的位置并保持再下载 ### Sipeed RV JATG 调试器 <a href \"https://github.com/sipeed/kflash_gui\">Sipeed USB JTAG/TTL RISC V调试器 STLINK V2 STM8/STM32模拟器</a> **烧录常见问题FAQ** 如果在使用 `kflash_gui` 烧录出现以下等问题 ![Upgrade Error](../../assets/kflash_gui/kflash_gui_upgrade_error.png) 可以按照以下顺序进行排查 * 检查`PC`是否有权限打开端口，对于 `win10`，需要以管理员身份运行 `kflash_gui` 。 * 检查端口是否选择正确（如果出现两个设备端口，通常选择端口号小的那一个）。 * 检查端口是否被其他应用占用（如`Maixpy IDE`，`putty`等），应当关闭其他程序占用。 * 检查设备是否选择正确，对于 `Maix Bit2.0`（包括M1n模块），应该选择 `Maix Bit ( with Mic )`。 > 补充说明：对于Maix Bit 2.0两个串口端口的问题 > > * 只有其中一个串口端口有效，用于串口通信与ISP下载程序。 > * Maix Bit与PC采用串口通信，通过CH552T芯片实现USB虚拟串口功能，而该芯片可以虚拟出两个串口，在Maix Bit（M1n模块底板）中，我们只用到了一个串口，不过有些k210产品两个串口都使用了。 ## 最新标准固件下载 2021/6/18更新：[标准固件下载](https://dl.sipeed.com/fileList/MAIX/MaixPy/release/master/maixpy_v0.6.2_54_g897214100/maixpy_v0.6.2_54_g897214100.bin) ## 固件更新信息 日期 版本号 备注 2021/7/27 固件版本 0.6.2_57 加入了安装教程视频中的测试模式，可以开机检测sd卡是否挂载 "},"/soft/maixpy/zh/get_started/env_install_driver.html":{"title":"安装 USB 驱动","content":" title: 安装 USB 驱动 keywords: maixpy, k210, AIOT, 边缘计算, maixpy入门 desc: maixpy 安装 USB 驱动 正式使用 MaixPy 之前，我们需要先安装好串口驱动，才可进行下一步的开发与使用；因为板子是通过 USB 转串口设备与电脑连接（K210 没有 USB 硬件支持功能）。 根据板子的 USB 转串口芯片型号装驱动。 > 在 `Linux` 或者 `Mac` 下操作串口， 如果不想每次都使用 `sudo` 命令， 执行 `sudo usermod a G dialout $(whoami)` 将自己添加到 `dialout` 用户组即可，可能需要注销或者重启才能生效 现有开发板板载的 USB 转串口 IC 说明 开发板型号 USB 转串口 IC 说明 安装教程 Maix Go STM32 STM32 USB 驱动 [Go](./install_driver/go.html) Maix Dock CH340 [Dock](./install_driver/dock.html) Maix Duino CH552 CH552 USB 驱动 [Duino](./install_driver/duino.html) Maix Bit CH552(新版)/CH340(旧版) CH552 USB 驱动 [Bit](./install_driver/bit.html) Maix Cube GD32(新版)/CH552(旧版) CH552 USB 驱动 [Cube](./install_driver/cube.html) Maix Amigo GD32 GD32 USB 驱动 [Amigo](./install_driver/amigo.html) Maix Nano CH552 CH552 USB 驱动 [Nano](./install_driver/nano.html) Grove AI HAT GD32 GD32 USB 驱动 [Grove AI HAT](./install_driver/ai_hat.html) > 使用 CH340 IC 的板子直接装 CH340 的驱动即可，其他的板子需要安装特定的 USB 驱动 ## 关于 USB 串口的疑难杂症排查 如果没有看到串口，请按如下顺序排查硬件问题。 插入电脑，是否存在叮咚一声，如插入 U 盘时USB 驱动加载的声音，没有表示硬件上的串口芯片出问题了。 更换线材重试，更换电脑 USB 口重试，仍然加载不出来，更换电脑确认。 如果没有办法烧录固件，请按如下顺序排查硬件问题。 使用串口工具查看硬件当中是否存在 maixpy 固件 设置 115200 波特率连接串口，按复位键（RST）接收到芯片的数据，不管是什么都表示串口芯片工作正常，如果没有则表示硬件异常。 基于上述再进行烧录固件，烧录前，按硬件的 BOOT 键后按复位，再松开 BOOT 键，此时烧录正常进行，如果没有则表示 Flash 受损，可以尝试烧录到 SRAM ，如果烧录失败，则表示串口芯片异常。 如果到这里了，还是不能解决问题，则硬件确实存在缺陷 ### K210 的烧写机制介绍 我们常把这个称为一键下载电路，表示能够轻松的通过控制 串口的 RST 和 DTR 的完成对 BOOT 和 RST 引脚的控制进入烧录模式，如上描述的期望硬件电路自动完成最初由人按下 BOOT 后按 RST 的操作，这与硬件实现强相关，基于此，再进行 TX 和 RX 的数据传输，所以实际上我们需要用到 UART 串口的功能引脚。 在 Kflash 中分多种版型多种烧写方式的触发，我们可以简单分为几类，低速的 115200 和 高速的 1500000 波特率，以这两类波特率所匹配的烧录方式为差异点，如果发现下载过程中失败，可以适当的降低波特率，这是由于串口芯片工作不稳定导致，而工具中对版型选择只是会影响第一段烧录模式的触发，而在这之后的烧写固件中就会采取配置的波特率进行烧写，通常不超过与flash的通信烧录速度，常见于 50~60 KB/S。 如果发现无论如何更换烧录模式都无法进入，要么是烧录版型不匹配，要么是串口芯片的 DTR RST 引脚出了问题（物理上的）。"},"/soft/maixpy/zh/get_started/env_serial_tools.html":{"title":"串口连接","content":" title: 串口连接 keywords: maixpy, k210, AIOT, 边缘计算, maixpy入门 desc: maixpy 使用串口工具 ## 连接硬件 连接 Type C 线， 一端电脑一端开发板 查看设备是否已经正确识别： 在 Linux 下可以通过 `ls /dev/ttyUSB*` 或者 `ls /dev/ttyACM*` 来查看， 如果没有可以 `ls /dev` 来找找，具体的设备名跟串口芯片和驱动有关. 也可以用`sudo dmesg`来看是否有设备挂载记录 在 Windows 下可以打开设备管理器来查看 如果没有发现设备， 需要确认有没有装驱动以及接触是否良好 ## 使用串口工具 ### Windows Windows 常用的串口终端软件有 [mobaxterm](https://mobaxterm.mobatek.net/)，[xshell](https://xshell.en.softonic.com/)，[mpfshell lite](./mpfshell lite/mpfshell lite.html) 等工具 #### Mobaxterm [MobaXterm](https://mobaxterm.mobatek.net/) 是 Windows 下一款非常好用的多功能终端软件（当然也包括串口终端） ![Mobaxterm](../../assets/get_started/mobaxterm_serail_port.png) ![Mobaxterm](../../assets/get_started/mobaxterm.png) #### mpfshell lite [mpfshell lite](./mpfshell lite/mpfshell lite.html)是一款体积迷你，功能齐全的 MicroPython 管理工具，可以对flash、sd卡的文件进行管理，也可以进行micropython的编写。 #### MaixPy IDE终端工具 打开 MaixPy IDE，在 IDE 没有连接板子的时候选择通过串口终端进入开发板 ![](./../../assets/get_started/IDE_1.png) ![](./../../assets/get_started/IDE_2.png) ![](./../../assets/get_started/IDE_3.png) ![](./../../assets/get_started/IDE_4.png) ![](./../../assets/get_started/IDE_5.png) ### Linux 使用 python 中的 pyserial 进行开发板的连接 安装 pyserial sudo python3 m pip install pyserial 连接开发板 sudo python3 m serial.tools.miniterm raw dtr 0 rts 0 /dev/ttyUSB0 115200 ![](../../assets/get_started/linux python.png) 复位开发板 通过按两次键盘上的，CTRL+T 和 CTRL+R，可实现复位 退出串口 按键盘上的 CTRL + ] > 可以通过运行 `sudo usermod a G dialout $(whoami)` ，添加用户的使用权限，然后重启系统，后面使用 pyserial 打开串口就可以不使用 sudo 权限了"},"/soft/maixpy/zh/get_started/get_started_power_on.html":{"title":"MaixPy 开发板上电","content":" title: MaixPy 开发板上电 keywords: maixpy, k210, AIOT, 边缘计算, maixpy入门, 人工智能 desc: maixpy MaixPy 开发板上电 当我们拿到 MaixPy 开发板之后 ## 检查硬件 检查硬件是否有损坏， 以及摄像头和屏幕是否接好，排线千万不要接反了。 ## 连接硬件 连接 Type C 线， 一端电脑一端开发板 查看设备是否已经正确识别： 在 Windows 下可以打开设备管理器来查看 在 Linux 下可以通过 `ls /dev/ttyUSB*` 或者 `ls /dev/ttyACM*` 来查看， 如果没有可以 `ls /dev` 来找找，具体的设备名跟串口芯片和驱动有关 如果没有发现设备， 需要确认有没有装驱动以及接触是否良好 上电后， 如果是新出厂的开发板， 可能会显示红色背景，前景是简单的 MaixPy 介绍，包括官网地址，画面是静止的，需要通过接下来的编程让它改变。 ![](./../../assets/maixpy/welcome_maixpy.png) 对于 maixbit 板子，我们准备了组装视频 <iframe src \"//player.bilibili.com/player.html?aid 860412959&bvid BV1dG4y1R7Ap&cid 900550125&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\"> </iframe> ## 检查固件版本 使用**串口终端**打开串口，然后复位，看输出的版本信息，与[github](https://github.com/sipeed/MaixPy v1releases) 或者 [master 分支](http://dl.sipeed.com/MAIX/MaixPy/release/master/) 的固件版本对比，根据当前版本情况考虑升级到最新版本 比如： ```python [MaixPy] init end __ __ _____ __ __ _____ __ __ \\/ /\\ _ _ \\ \\ / / __ \\ \\ \\ / / \\ / / \\ \\ V / __) \\ \\_/ / \\/ / /\\ \\ > < ___/ \\ / / ____ \\ _ _ / . \\ _ _ /_/ \\_\\ _____ /_/ \\_\\ _ _ Official Site : https://www.sipeed.com Wiki : https://maixpy.sipeed.com MicroPython v0.5.0 12 g284ce83 on 2019 12 31; Sipeed_M1 with kendryte k210 Type \"help()\" for more information. ``` **查看版本号：** 这里版本是 `v0.5.0 12 g284ce83`， 也可以使用下面的代码查看版本 > **注：** 固件可以从下载站 [dl.sipeed.com](http://dl.sipeed.com/MAIX/MaixPy/release/master/) 中获取 ```python import sys print(sys.implementation.version) ``` 如果你在开发过程中遇到了问题， 也可以先尝试更新固件到最新版本 ## 执行代码 * 打开串口终端后，按开发板的复位按钮就可以看到打印的开机信息了，会输出 ```shell >>> ``` 即在等待我们输入代码，如果没有这个符号，可能是有开机自动运行的程序正在运行，可以按`Ctrl+C`来取消正在运行的程序 * 然后输入程序执行 ```python >>> print(\"hello world\") hello world >>> ``` ## 粘贴执行多行代码 当我们有多行代码是从其它地方复制过来的，比如 ```python import os f os.listdir() print(f) ``` * 先复制好代码 * 串口终端按 `Ctrl+E` * 粘贴代码 * 按 `Ctrl+D`（注意如果之前没有按 `Ctrl+E` 则是软件复位命令，MaixPy 会软复位），然后就可以看到所有代码执行了 ```python >>> ['boot.py','main.py', 'freq.conf'] >>> ``` > 如果数据量比较大，串口可能丢失数据，会导致提示语法错误，可以多试几次"},"/soft/maixpy/zh/get_started/get_started_cam_lcd.html":{"title":"第一个程序: 使用屏幕和摄像头","content":" title: \"第一个程序: 使用屏幕和摄像头\" keywords: maixpy, k210, AIOT, 边缘计算, maixpy入门 desc: \"maixpy 第一个程序: 使用屏幕和摄像头\" 开发板有配套的摄像头和屏幕，请在上电前检查硬件连接是否正确（**按照排线标有的一号引脚对齐**） 然后上电，打开串口终端， 按键盘`Ctrl+E`,然后粘贴以下代码： ```python import sensor, lcd sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) sensor.skip_frames() lcd.init(freq 15000000) while(True): lcd.display(sensor.snapshot()) ``` 按键盘`Ctrl+D`来开始运行代码 会发现屏幕被点亮了，而且显示出了摄像头拍到的画面 如果显示`reset fail`， 则是摄像头没有连接好，或者摄像头已经损坏，或者检查是不是使用了不支持的摄像头 上面的程序都可以在 API 手册中查到含义， 在左边目录中可以找到， 也可以使用左上角的搜索框进行搜索。 现在解释上面的程序： * `import sensor, lcd`: 首先导入内置的`sensor`（摄像头）库和`lcd`（屏幕）库 * `sensor.reset()`: 初始化摄像头，这里失败需要检查硬件 * `sensor.set_pixformat(sensor.RGB565)`: 设置摄像头为`RGB565`格式，默认都是用`RGB565`即可 * `sensor.set_framesize(sensor.QVGA)`: 分辨率为`QVGA`，即`320x240` * `sensor.run(1)`: 开始运行，在现在的版本中也可以不调用，在上面设置完成后，摄像头会自动开始运行 * `sensor.skip_frames()`: 摄像头刚启动时，图像质量还没稳定，所以跳过一些图像 * `lcd.init(freq 15000000)`: 初始化 LCD， 这里传了一个参数叫`freq`即频率， 是指定驱动 LCD 的时钟频率，这里是`15MHz`，可以根据硬件性能调整 * `while(True)`: 这是一个循环，循环里面的代码会被不停地运行 * `sensor.snapshot()`:从摄像头取一帧图像数据，返回值是一张图像的对象 * `lcd.display()`： 显示图像到 LCD * `lcd.display(sensor.snapshot())`: 这里就是先执行括号里的获取图像，返回值直接作为参数给 LCD 进行显示"},"/soft/maixpy/zh/contribute/app_doc_template.html":{"title":"MaixPy_DOC 实例教程模板","content":" title: MaixPy_DOC 实例教程模板 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy MaixPy_DOC 实例教程模板 本文说明文档贡献者在撰写教程中遵循的规范，以及注意事项，请各位贡献者根据本文撰写文档； 如果对模板格式，内容存在疑惑请到本项目仓库 [MaixPy_DOC](https://github.com/sipeed/MaixPy_DOC) 提交 `ISSUE`。 🙇‍ 感谢各位贡献者的热心支持！ 关于文档编写工具 > 文档使用 `MarkDown` 语法撰写, 整体文档项目使用 `gitbook` 构建；这里推荐使用 `Typora` 及 `VS Code` 搭配 `MarkDown` 插件作为文本编辑器 关于文档图文内容存放 > 实例教程文档请存放到路径 `./MaixPy_DOC/zh(这里区分中英文，中文：zh，英文：en)/application/xxx(具体分类，分类建议请看后续描述)/xxx（具体的例程名称，建议使用英文命名）`.md > 文档中引用到的图片建议使用相对链接，并将图片文件存放与文档同目录下的 `[文件名].assets` 文件夹中； 关于文档分类建立存放路径 > 与硬件外设强相关的建议命名（存放路径）为：`` > 与 image 强相关的建议命名（存放路径）为：`image` > 与 KPU 强相关的建议命名（存放路径）为：`KPU` > 较为综合的例程的建议命名（存放路径）为：`demo` > 以下内容为文档模板内容： # MaixPy 实例教程 —— XXX ## 一、概述： > 1. 描述下该例程实现的效果 > > 2. 简要说明操作步骤 > ## 二、准备: > 说明需要准备的软硬件环境 预备知识 硬件 > 图文描述使用到的开发板&&外设模块等 软件 > 图文描述使用到的软件工具，MaixPy 版本 > 如果使用到第三方软件工具，可以附加相关名称或下载链接 ### 具体操作步骤 ### 程序代码 ```python xxxxx ``` ### 效果 > 建议添加图片展示实际运行效果 ## 问题和反馈(Question && Feedback) 贡献者说明： > 这里给贡献者提供引流入口 作者： 联系方式(Email)： 博客："},"/soft/maixpy/zh/contribute/doc_convention.html":{"title":"文档贡献规范","content":" title: 文档贡献规范 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy 文档贡献规范 有几种情况你可能需要看本文档： * 发现文档有误或者有内容需要补充，并且会自己想参与修改 * 提交 教程/经验/开源项目分享 等等 为了让文档看起来风格统一， 内容不重复不出错， 编写需要遵循同一个规范，请各位贡献者**务必**根据本文撰写文档； 如果对模板格式，内容存在疑惑请到本项目仓库 [MaixPy_DOC](https://github.com/sipeed/MaixPy_DOC) 提交 `ISSUE`。 🙇‍ 感谢各位贡献者的热心支持！ ## 要参与贡献，你需要提前掌握的知识 * git 和 github 的使用 * github PR（pull request）的使用 在入门教程里面有简要的介绍， 详细的使用方法请自行学习 如果你没有信心掌握这些技能， 你可以到提交[issue](https://github.com/sipeed/MaixPy_DOC/issues) 来说明问题或者贡献经验等，我们帮助你进行添加 ## 文档系统简介 文档使用 gitbook 进行构建， 并使用简单高效的 Markdown 编写内容, 这里推荐使用 `Typora` 或者 `VS Code` 搭配 `MarkDown Preview Enhanced` 插件作为文档编辑器 文档源码托管在 [github](https://github.com/sipeed/sipeed_wiki/tree/main/docs/soft/maixpy) 本地预览方法见 文档源码的 [README.md](https://github.com/sipeed/sipeed_wiki/README.md) 文档有两种语言， 中文和英文，分别放在`zh`和`en`文件夹中， 其中的`SUMMARY.md`是文档左边的目录项，其它`md`文件时具体的文档文件，根目录下的`assets`目录放两种语言公用的图片资源文件 ## Markdown 语法 Markdown 的基础语法如果没接触过， 请花半个小时进行学习， 推荐github的教程： [github Markdown 教程](https://guides.github.com/features/mastering markdown/) 在本文中， 以下几点我们需要注意： ### 标题类的语法标记必须使用空格隔开，大标题与正文之间需要一个空行，比如： ```markdown ## 这是二级标题 * 这是列表项1 * 这是列表项2 ``` 而如下所示的则不是正确的，可能会导致解析器出现解析错误格式错乱等 ```markdown ##这是二级标题 *这是列表项1 *这是列表项2 ``` ### 所有页面只有一个一级标题 由于需要自动生成目录，主要是为了保证自动生成的目录正确。 每个页面这样写 ``` ( 至少需要一个以上的空行，建议2行 ) ## 二级标题1 ( 这里不能使用一级标题，及不能用一个#号。 也不需要写序号，会自动生成序号) ( 空一行 ) 正文 ( 至少空一行) ### 三级标题 ( 类似二级标题, 也不需要写需要，会自动生成) 正文 ## 二级标题2 正文 ``` ### 标题编号 所有标题**不需要**写编号， **会自动生成**比如 ``` ## 标题一 ### 子标题1 ## 标题二 ``` 最终效果： ``` 1. 标题一 1.1 子标题1 2. 标题二 ``` 如果手动写了最终显示就会重复， 所以需要注意！ ### 链接 由于页面众多，而且需要链接图片等资源，在写链接时，均使用相对路径， 比如目录结构如下 ``` assets/ (放公用的资源文件) pic000.png en/ get_started/ assets/ (放get_started目录下md文件公用的资源文件) pic.png get_hardware.md how_to_read.md zh/ ``` 如果在`get_hardware.md`中贴图片，将图片放进`assets`文件夹后，使用如下代码引用图片 ``` ![pic](assets/pic.png) ![pic](../../assets/pic000.png) ``` ### 中英文混写 在写中文文档时，在中文中夹杂英文尽量用空格隔开，标点符号尽量使用全角符号， 主要是为了显眼，让文档更优雅。 比如： ```markdown 在 Micropython 中， 我们常常使用 `deinit` 来表示析构函数，而不是像 STM32 一样来表示设置默认值 ``` 在 Micropython 中， 我们常常使用 `deinit` 来表示析构函数，而不是像 STM32 一样来表示设置默认值 ```markdown 在 Micropython 中， 我们常常使用 deinit 来表示析构函数，而不是像 STM32 一样来表示设置默认值 ``` 在 Micropython 中， 我们常常使用 deinit 来表示析构函数，而不是像 STM32 一样来表示设置默认值 ## 目录 * 多种语言分别放在不同的目录，`en`和`zh`目录 * 生成的文档目录在对应语言的文件夹 `SUMMARY.md` 中编辑 * 源文档的文件夹尽量一个功能模块对应一个文件夹，资源文件（图片）放置到对应 md 文档根目录下的 `assets` 文件夹目录下，这样方便中英文文档都引用同样的图片，而且生成的 URL 相同，同时增删修改时更方便。 * 同时，为了中英文文档都能使用，图片里面尽量不要标注中文或英文，可以标注标号，然后文档用标号阐述， 针对特定语言的图片放到当前路径下的 `assets` 目录： ``` assets/ (放公用的资源文件， 中英文都能引用) en/ get_started/ assets/ (放get_started目录下md文件的资源文件， 只给英文使用) get_hardware.md how_to_read.md zh/ ``` ## 文件名 * 文件名除了 `README.md` 特殊，其它文件名使用 小写+下划线 的命名方式，比如 `get_hardware.md` ## 中英文（多语言）的页面文件目录结构和文件名相同 由于最后生成的页面中有多语言切换选项，点击切换后会直接访问对应语言的相同路径，所以中英文的目录结构和文件名必须相同。 比如英文正在访问 `en/get_started/how_to_read.md`，点击语言切换的按钮后，会自动访问 `zh/get_started/how_to_read.md`，如果这个文件不存在就会报`404`错误！ ## 目录和链接 尽量引导阅读者使用目录，文内跳转链接慎用，如果链接跳得比较乱，会导致文档看起来比较乱，阅读会比较困难。 ## 模块文档内容 * 文件头部包含模块的介绍，资源介绍，使用注意点， 例程 * 需要分点说明构造函数、函数、常量等 * **说明不能偷懒只简单将函数名称翻译一遍，需要详细说明函数的功能、参数的取值范围以及注意点** ## 多版本管理 文档除了做了中英文（多语言）支持（不是自动翻译，需要手动修改）， 也做了多版本管理。 每个版本是一个分支， 对分支名字有要求， 分别为： * `master` 分支为主分支 * `dev`分支为开发分支 * 其它的发布的历史版本均以小写 `v` 开头，比如创建一个分支叫 `v1.2` 创建好新的分支后，需要在每个语言版本的目录下 `book.json`中修改版本链接，不然读者找不到入口 可以在新建的分支下本地预览（预览方法见根目录 `README.md`），注意这时候预览的页面就是当前分支的内容，如果要本地预览其它分支内容，需要先切换到其它分之后再预览即可。 确认无误修改完成后推送分支到远程（github），自动构建系统会自动构建并发布到 pages 分支，等构建完毕访问网址即可看到效果。"},"/soft/maixpy/zh/contribute/code_convention.html":{"title":"MaixPy 编程规范","content":" title: MaixPy 编程规范 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy MaixPy 编程规范 这是一份 **MaixPy** 开发人员的开发指引。**MaixPy** 做为一份开源软件，它需要由不同的人采用合作的方式完成，这份文档是开发人员的一个指引。 **MaixPy** 的开发人员请遵守这样的编程风格。同时对于使用 MaixPy 的用户，也可通过这份文档了解 MaixPy 代码内部一些约定从而比较容易的把握到 MaixPy 的实现方式。 ## 规范原则 [x] 朴实，避免晦涩语法 [x] 严谨，逻辑反复思考 [x] 简约，命名简洁、代码精炼 [x] 性能，通过算法、编译器、硬件进行优化 ## 目录结构 && 文件名称 目录结构 整个工程按照功能模块划分子目录，每个子目录再划分头文件和源文件目录，以便架构清晰、易懂。 目录名称如果无特殊的需求，请使用全小写的形式；目录名称应能够反应部分的意思，components 目录下能够反映组件的意义。 文件结构 文件名称如果无特殊的需求(如果是引用其他地方，可以保留相应的名称)，请使用全小写的形式。另外为了避免文件名重名的问题，一些地方请尽量不要使用通用化、使用频率高的名称。 ## 头文件定义 C语言头文件为了避免多次重复包含，需要定义一个符号。这个符号的定义形式请采用如下 的风格： ```c #ifndef __FILE_H__ #define __FILE_H__ /* header file content */ #endif ``` 即定义的符号两侧采用 \"__\" 以避免重名，另外也可以根据文件名中是否包含多个词语而 采用 \"_\" 连接起来。 ## 文件头注释 在每个源文件文件头上，应该包括相应的版权信息，Change Log 记录： ```c /** * File : maixpy_main.h * This file is part of MaixPy * Copyright 2019 Sipeed Co.,Ltd. MaixPy Development Team * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE 2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ ``` 例如采用如上的形式。 ## 结构体定义 结构体名称请使用小写英文名的形式，单词与单词之间采用 \"_\" 连接，例如： ```c struct lcd_config { int width; int height; }; ``` 其中，\"{\"，\"}\" 独立占用一行，后面的成员定义使用缩进的方式定义。 结构体等的类型定义请以结构体名称加上 \"_t\" 的形式作为名称，例如： ```c typedef struct lcd_config lcd_config_t; ``` ## 宏定义 在 MaixPy 中，请使用大写英文名称作为宏定义，单词之间使用 \"_\" 连接，例如： ```c #define MAIXPY_TRUE 1 ``` ## 函数名称、声明 函数名称请使用小写英文的形式，单词之间使用 \"_\" 连接。提供给上层应用使用的 API 接口，必须在相应的头文件中声明；如果函数入口参数是空，必须使用 void 作为入口参 数，例如： ```c maixpy_err_t lcd_init(void); ``` ## 注释编写 请使用英文做为注释，使用中文注释将意味着在编写代码时需要来回不停的切换中英文输入法从而打断编写代码的思路。并且使用英文注释也能够比较好的与中国以外的技术者进行交流。 源代码的注释不应该过多，更多的说明应该是代码做了什么，仅当个别关键点才需要一些相应提示性的注释以解释一段复杂的算法它是如何工作的。对语句的注释只能写在它的上方或右方，其他位置都是非法的。 ## 缩进及分行 缩进请采用 4 个空格的方式。如果没有什么特殊意义，请在 \"{\" 后进行分行，并在下一行都采用缩进的方式，例如： ```c if (condition) { /* others */ } ``` 唯一的例外是 switch 语句，switch case 语句采用 case 语句与 switch 对齐的方式， 例如： ```c switch (value) { case value1: break; case value2: break; defalut: break; } ``` case 语句与前面的 switch 语句对齐，后续的语句则采用缩进的方式。 分行上，如果没有什么特殊考虑，请**不要在代码中连续使用两个以上的空行**。 ## 大括号与空格 从代码阅读角度，建议每个大括号单独占用一行，而不是跟在语句的后面，例如： ```c if (condition) { /* others */ } ``` 匹配的大括号单独占用一行，代码阅读起来就会有相应的层次而不会容易出现混淆的情况。 空格建议在非函数方式的括号调用前留一个空格以和前面的进行区分，例如： ```c if (x < y) { /* others */ } for (index 0; index < MAX_NUMBER; index ++) { /* others */ } ``` 建议在括号前留出一个空格(涉及的包括 if、for、while、switch 语句)，而运算表达式中，运算符与字符串间留一个空格。另外，不要在括号的表达式两侧留空格，例如： ```c if ( x < y ) { /* other */ } ``` 这样括号内两侧的空格是不允许的。 ## log 信息 在 MaixPy 中，普遍使用的 log 方式是 printk, 而面向 py 终端的是使用 mp_print, 而在我们对 MaixPy 功能增减之后建议将不需要的 printk 删除或者注释掉 但是**注意**，最终提交的代码里面不能有`printk`和`printf`函数， 只能在调试时使用！！！否则会导致 IDE 使用时断开连接 日志输出应该被设计成正常情况下是关闭状态(例如通过一个变量或宏就能够开启)，并且 当真正输出日志时，日志是易懂易定位问题的方式。\"天书式\"的日志系统是糟糕的，不合理的。 ## 函数 在内核编程中，函数应该尽量精简，仅完成相对独立的简单功能。函数的实现不应该太长，函数实现太长，应该反思能够如何修改(或拆分)使得函数更为精简、易懂。 ## 用 astyle 自动格式化代码 参数： style allman indent spaces 4 indent preproc block pad oper pad header unpad paren suffix none align pointer name lineend linux convert tabs verbose ## 规范参考 AliOS Things [《AliOS Things Coding Style Guide》](https://github.com/alibaba/AliOS Things/wiki/AliOS Things Coding Style Guide) RT Thread [《RT Thread 编程风格》](https://github.com/RT Thread/rt thread/blob/master/documentation/coding_style_cn.md)"},"/soft/maixpy/zh/thanks.html":{"title":"致谢","content":" title: 致谢 keywords: maixpy, k210, AIOT, 边缘计算, 人工智能, 深度学习 desc: maixpy 致谢 * [MaixPy 源码贡献者](https://github.com/sipeed/MaixPy v1graphs/contributors) * [MaixPy_scripts 示例代码贡献者](https://github.com/sipeed/MaixPy v1_scripts/graphs/contributors) * [Maixduino 源码贡献者](https://github.com/sipeed/Maixduino/graphs/contributors) * [MaixPy_DOC 文档贡献者](https://github.com/sipeed/MaixPy_DOC/graphs/contributors)"},"/soft/maixpy/zh/how_to_read.html":{"title":"如何正确 阅读 本文","content":" title: 如何正确 阅读 本文 keywords: maixpy, k210, AIOT, 边缘计算, 人工智能, 深度学习 desc: maixpy 如何正确 阅读 本文 **注意： 目前唯一文档官网： [wiki.sipeed.com/maixpy3](https://wiki.sipeed.com/maixpy)** ## 首先请仔细阅读一遍左边侧边栏的目录结构看一看文档有那些内容 * **简介**： `MaixPy` 的简介，作品展示，以及发展历史等 * **入门指南**： 使用 `MaixPy` 的入门教程，包括基础知识，一定要看， 才能避免遇到很多问题，会给后面开发节省很多时间 * **更多功能应用**： 这里是一步一步地教各种功能的使用， 对于刚上手不知道该做什么的同学们很有用， 仔细读哦 * **API 手册**： 各个功能模块的 API 手册， 方便编程时查阅 * **标准库**： `micropython` 的标准库， 很多 API 兼容 `python3` 的 API * **machine**： 机器相关， 重启控制，机器 UID， 以及各种外设控制 * **Maix**: 一些特殊的模块， 比如 FPIOA， KPU， FFT等 * **内置类**：内置的用 `mpy` （micropython 的缩写）编写的类， 可以在源码项目中找到 * **机器视觉**: 一些机器视觉相关的模块， image sensor lcd 大致上兼容 OpenMV 的 API， 但是后期不会实时跟着 OpenMV 更新 * **附加外设模块**： 一些外设模块的使用， 比如触摸屏， 超声波， LED 灯等 * **内置应用**： 内置的应用， 比如 NES 游戏机（FC 红白机，也就是小时候的小霸王游戏机），pye（内置的文档编辑器） * **常见问题 FAQ**： 大家经常问的问题汇总 * **进阶**： 一些进阶的玩法， 以及如何参与 [`文档的修改`](./contribute/doc_convention.html) 和 [`源码的修改`](./contribute/code_convention.html)，或者 `例程` 的贡献 * **社区 & 分享**： 收集一些来自社区的好的教程、作品、开源项目等， 大家也可以按照贡献说明来共享自己的作品或者教程 ## 重要必读部分 <code><strong><font size 4>简介</font></strong></code> 和 <code><strong><font size 4>入门指南</font></strong></code>，一定要完整看完， 遇到问题也一定要先看 <code><strong><font size 4>常见问题</font></strong></code> ## 开始学习 * 刚接触，可以根据左边侧边栏的目录从上到下一页一页仔细看，跟着做即可， 入门一定不要跳过！！！ * 学会如何更新固件，如何写代码，其中学会使用串口终端也十分重要，不建议过分依赖 IDE， 特别是在程序死掉的时候， 用终端可能会获得更多报错信息，更有利于解决问题，在遇到问题在社区提问时，也尽量给出终端运行的完整信息 * 每个模块/库文档里面的结尾都附有简单例程， 或者到这里: [MaixPy_script](https://github.com/sipeed/MaixPy v1_scripts) 查找需要的示例， 可以尝试运行看效果 ## 学会搜索 * 关于模块的接口及参数，在使用时根据自己的需求进行查阅，<code><strong><font size 4>页面顶部右上角有搜索框</font></strong></code>，可以好好利用，同时也可以使用浏览器的页面搜索功能，即按键盘<kbd> Ctrl+F </kbd>，然后输入要搜索的内容后按确认键 * 如果有找不到的内容也请不要着急， 可以上 github 的 [issue](https://github.com/sipeed/MaixPy v1issues) 页面找一找（搜一搜）是不是有人提过了，没有的话可以新建 issue， 或者到 [论坛](https://bbs.sipeed.com) 搜索问题，没有再向大家求助， 或者联系技术支持。 ## MaixPy 常见问题 * 常见问题请见[常见问题](./others/maixpy_faq.html) ## 其它教程 * 除了文档，还可以浏览[BBS](https://bbs.sipeed.com)用户写的教程， 或者百度搜索， 以及各个开发者的博客，都会有很多开发教程开发日记等， 都可以参考 ## 提问技巧 在各种地方提问， 不管是 github 还是 QQ 群，还是论坛， 还是邮件， 提问要尽量提供完整的问题复现步骤，把你所经过的使用过程， 问题是怎么产生的， 现象是什么样的， 一定要完整地说明， 不要怕文字多，要站在解决问题的人的角度想问题，提的问题开发者能解决吗？ 方便开发者百忙之中测试问题并解决！ 更加具体的请看下一节 [如何优雅提问](./how_to_ask.html)"},"/soft/maixpy/zh/index.html":{"title":"MaixPy-v1 文档简介","content":" title: MaixPy v1 文档简介 keywords: maixpy, k210, AIOT, 边缘计算, 人工智能, 深度学习 desc: maixpy MaixPy v1 文档简介 <div style \"font size: 1.2em;border: 2px solid green; border color:#c33d45;padding:1em; text align:center; background: #c33d45; color: white\"> <div> <span>新版 MaixPy (v4) 已经上线， 完整 Python3 支持，功能更强大， 请看:</span> <a target \"_blank\" style \"color: #ffe0e0\" href \"https://wiki.sipeed.com/maixpy\"> wiki.sipeed.com/maixpy </a> <br> <div style \"height:0.4em\"></div> <span>全新硬件产品 MaixCAM，性能大升级，请看:</span> <a target \"_blank\" style \"color: #ffe0e0\" href \"https://wiki.sipeed.com/maixcam\"> https://wiki.sipeed.com/maixcam </a> </div> <div style \"padding: 1em 0 0 0\"> <a style \"color: white; font size: 0.9em; border radius: 0.3em; padding: 0.5em; background color: #a80202\" href \"https://item.taobao.com/item.htm?id 784724795837\">淘宝</a> <a style \"color: white; font size: 0.9em; border radius: 0.3em; padding: 0.5em; background color: #a80202\" href \"https://www.aliexpress.us/item/1005006912917562.html\">速卖通</a> </div> </div> **Maix I K210 系列正在被逐渐淘汰，如果你正准备购买 K210, 请立刻选择 MaixCAM;** **也欢迎 K210 用户升级到 MaixCAM** **本文档中（https://wiki.sipeed.com/soft/maixpy/zh/ 路径下）的所有 MaixPy 均代指 MaixPy v1** <br> <br> <br> <br> <br> <div class \"title_pic\"> <div class \"logo_maixpy\"> <img src \"../assets/maixpy/maixpy.png\" alt \"maixpy ​​logo\"> </div> <span class \"logo_sipeed\"> <img src \"../assets/sipeed/sipeed_logo_4.svg\" alt \"sipeed logo\"> </span> <span class \"logo_mpy\"> <img src \"../assets/maixpy/micropython.png\" alt \"micropython logo\"> </span> </br> </div> ## 关于 MaixPy v1 [**MaixPy v1**](https://wiki.sipeed.com/soft/maixpy/zh/index.html)（后文直接用 MaixPy 代之，注意与 MaixPy v4 区分） 是将 [Micropython](http://micropython.org/) 移植到 [K210](https://canaan creative.com/product/kendryteai)（一款 64 位双核带硬件 FPU、卷积加速器、FFT、Sha256 的 RISC V CPU ） 的一个项目； [**MaixPy**](https://wiki.sipeed.com/soft/maixpy/zh/index.html) 不但支持 MCU 常规操作， 还集成了硬件加速的 `AI` 机器视觉和麦克风阵列相关的算法。相应的高达 `1TOPS` 算力核心模块却不到`￥50`， 凭借着快速开发和较低成本与其较小的体积很适合 `AIOT` 领域智能应用 > MicroPython 是基于 Python3 的语法做的一款解析器，包含了 Python3 的大多数基础语法， 主要运行在性能和内存有限的嵌入式芯片上。（注意 Micropython 不包含 Python3 的所有语法） **MaixPy** 让我们在 K210 上编程更加简单快捷， 我们也将源代码开源在 github [点我跳转](https://github.com/sipeed/MaixPy) 上 使用 MaixPy 可以做很多有趣的事情， 具体可以 [看这里](./what_maix_do.html) ## 简洁的代码实例 比如我们需要扫描 **I2C** 总线上的设备，不需要复杂的开发环境和工程，只需要通过串口发送如下代码即可实现： ```python from machine import I2C # 导入内置库 i2c I2C(I2C.I2C0, freq 100000, scl 28, sda 29) # 定义一个I2C对象， 使用I2C0, 频率100kHz，SCL引脚是IO28, SDA 引脚是IO29 devices i2c.scan() # 调用函数扫描设备 print(devices) # 打印设备 ``` 同样，我们需要实现一个**呼吸灯**，只需要如下代码： > `board_info` 与板卡相关，不同板卡配置不同，使用前需要[手动配置](./api_reference/builtin_py/board_info.html)。 ```python from machine import Timer,PWM from board import board_info import time tim Timer(Timer.TIMER0, Timer.CHANNEL0, mode Timer.MODE_PWM) ch PWM(tim, freq 500000, duty 50, pin board_info.LED_G) duty 0 dir True while True: if dir: duty + 10 else: duty 10 if duty>100: duty 100 dir False elif duty<0: duty 0 dir True time.sleep(0.05) ch.duty(duty) ``` **实时拍照**： ```python import sensor import image import lcd lcd.init() sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) while True: img sensor.snapshot() lcd.display(img) ``` **AI 物体检测**: ```python import KPU as kpu import sensor sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.set_windowing((224, 224)) model kpu.load(\"/sd/mobilenet.kmodel\") # load model while(True): img sensor.snapshot() # take picture by camera out kpu.forward(task, img)[:] # inference, get one hot output print(max(out)) # print max probability object ID ``` please read doc before run it! ## 这篇文档的内容 所有关于 MaixPy 的内容， 包括： * 如何选择并得到一款合适自己的模块或者开发板 * 如何开始上手使用 * 库和接口（API）文档查询 * 详细的一步一步手把手教程 * 来自社区的分享（教程或开源项目） **为了在学习过程中避免遇到难以解决的问题，请务必按照左边目录结构从上到下阅读，特别是写在前面的章节，不要跳过** ## 可以运行MaixPy的开发板 首先我们需要选择一款适合自己的开发板，各个型号的 MaixPy 型号请点击：[开发板与配件选购指南](./develop_kit_board/get_hardware.html)，同时目录下也有对应开发板的硬件参数和资料 要获得这些板子，可以访问Sipeed（矽速）官网[www.sipeed.com](https://www.sipeed.com/)，或者[官方淘宝店](https://sipeed.taobao.com/) ## MaixPy 源码 `MaixPy` 源码是指 运行在 `K210` 上的 `Micropython` 语法解析器， 使用 `C语言` 编写， 源码托管在 [github](https://github.com/sipeed/MaixPy), 如果只是想使用 MaixPy，不需要了解源码， 但是也欢迎给 `MaixPy` 项目一个 `star` ; 如果想参与开发 MaixPy 的内置功能，可以下载进行开发，欢迎大家提交 `PR` 本项目主要由 &copy;<a href \"https://www.sipeed.com\" style \"color: #f14c42\">Sipeed</a> Co.,Ltd. 维护， 并接受来自开源社区的贡献， 具体贡献这见[贡献者列表](https://github.com/sipeed/MaixPy v1graphs/contributors) ## 反馈 关于本文档或者功能或者源码方面的问题，也欢迎提交issue: * [反馈](https://github.com/sipeed/MaixPy v1issues) ## 交流 有问题尽量到上面的反馈地址提交`issue`，方便留下记录，其他人也可以查阅，提交前搜索一下是否有人提过相同问题 也可以去[论坛](bbs.sipeed.com)发帖交流，方便按他人查询类似问题。 以下交流方式提供辅助： <table role \"table\"> <thead> <tr> <th>交流方式</th> <th>地址</th> </tr> </thead> <tbody> <tr> <td>issue</td> <td><a href \"https://github.com/sipeed/MaixPy v1issues\">https://github.com/sipeed/MaixPy v1issues</a></td> </tr> <tr> <td>BBS</td> <td><a href \"https://bbs.sipeed.com\" rel \"nofollow\">https://bbs.sipeed.com</a></td> </tr> <tr> <td>MaixPy AI QQ 交流群</td> <td>862340358</td> </tr> <tr> <td>MaixPy AI QQ 交流群(六群)</td> <td>636551897</td> </tr> <tr> <td>telgram</td> <td><a href \"https://t.me/sipeed\" rel \"nofollow\">https://t.me/sipeed</a></td> </tr> <tr> <td>E mail(商业合作)</td> <td><a target \"_blank\" rel \"noopener noreferrer\" href \"./../assets/sipeed/support_email.jpg\"><img src \"./../assets/sipeed/support_email.jpg\" alt \"email\" style \"max width:100%;\"></a></td> </tr> </tbody> </table> <table role \"table\" class \"center_table\"> <thead> <tr> <th>网站导航</th> <th>地址</th> </tr> </thead> <tbody> <tr> <td><strong>MaixPy</strong> 唯一官方文档官网</td> <td><span class \"limit_width\">中文站: </span><span class \"\"><a href \"https://wiki.sipeed.com/soft/maixpy/zh/\" rel \"nofollow\"><strong>wiki.sipeed.com</strong></a></span></td> </tr> <tr> <td><strong>MaixPy</strong> 例程仓库</td> <td><span class \"limit_width\">github：</span> <span class \"\"><a href \"https://github.com/sipeed/MaixPy v1_scripts\"><strong>github/maixpy_script</strong></a></span> <br><span class \"limit_width\">国内：</span><span class \"\"><a href \"https://gitee.com/Sipeed/maixpy_scripts\" rel \"nofollow\"><strong>gitee/maixpy_scripts</strong></a></span></td> </tr> <tr> <td>MaixPy 源码</td> <td><span class \"limit_width\"></span><span class \"\"><a href \"https://github.com/sipeed/MaixPy\"><strong>github: MaixPy</strong></a></span></td> </tr> <tr> <td>开发板资料下载</td> <td><span class \"limit_width\"></span><span class \"\"><a href \"http://dl.sipeed.com/MAIX/HDK\" rel \"nofollow\"><strong>dl.sipeed.com</strong></a></span></td> </tr> <tr> <td>Sipeed WIKI</td> <td><span class \"limit_width\"></span><span class \"\"><a href \"https://wiki.sipeed.com\" rel \"nofollow\"><strong>wiki.sipeed.com</strong></a></span></td> </tr> </tbody> </table> "},"/soft/maixpy/zh/SUMMARY.html":{"title":"Summary","content":" title: Summary keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy Summary * [简介](./index.html) * [MaixPy 能做哪些事](./what_maix_do.html) * [MaixPy 发展历程](./maixpy_history.html) * [致谢](./thanks.html) ## 入门必看指南 * [如何正确阅读本文 (重要！！！)](./how_to_read.html) * [如何优雅提问 (重要！！！)](./how_to_ask.html) * 开发板和配件选购指南 [开发板选购指南(对比)](./develop_kit_board/get_hardware.html) 开发板介绍 [Maix Dock](./develop_kit_board/maix_dock.html) [Maix Bit](./develop_kit_board/maix_bit.html) [Maix Amigo](./develop_kit_board/maix_amigo.html) [Maix Duino](./develop_kit_board/maix_duino.html) [Maix Cube](./develop_kit_board/maix_cube.html) [Maix Go](./develop_kit_board/maix_go.html) [Maix Nano](./develop_kit_board/maix_nano.html) 外设模组（配件） [SP MOD](./modules/sp_mod/index.html) [Grove](./modules/grove/index.html) [其它](./modules/others/index.html) * 基础知识 [MaixPy 语法基础知识](./get_started/knowledge_micropython.html) [git 和 github](./get_started/knowledge_git_github.html) [MaixPy 图像基础知识](./get_started/knowledge_image.html) [MaixPy 音频基础知识](./get_started/knowledge_audio.html) * 开发环境准备 [安装驱动](./get_started/env_install_driver.html) [Maix Dock](./get_started/install_driver/dock.html) [Maix Bit](./get_started/install_driver/bit.html) [Maix Amigo](./get_started/install_driver/amigo.html) [Maix Cube](./get_started/install_driver/cube.html) [Maix Go](./get_started/install_driver/go.html) [Maix Nano](./get_started/install_driver/nano.html) [更新 MaixPy 固件](./get_started/upgrade_maixpy_firmware.html) [使用串口终端工具](./get_started/env_serial_tools.html) [MaixPy IDE 使用说明](./get_started/env_maixpyide.html) 更新 WIFI 模块固件 [更新板载 ESP32 固件](./get_started/upgrade_esp32_firmware.html) [更新板载 ESP8285 固件](./get_started/upgrade_esp8285_firmware.html) * 上手 [上电](./get_started/get_started_power_on.html) [第一个程序: 使用屏幕和摄像头](./get_started/get_started_cam_lcd.html) [第二个程序: 点亮 LED](./get_started/get_started_led_blink.html) [存储系统介绍](./get_started/get_started_fs.html) [编辑并运行脚本](./get_started/get_started_edit_file.html) [上传脚本到开发板](./get_started/get_started_upload_script.html) [开机自动运行脚本](./get_started/get_started_boot.html) [开发板配置文件](./api_reference/builtin_py/board_info.html) [上手视频教程](./get_started/maixpy_get_started_video.html) * 固件定制 [为什么需要定制固件](./firmware/why_customize_firware.html) [在线编译](./firmware/online_compile.html) [源码编译](./firmware/compile.html) ## MaixPy 手把手教程 * [教程说明](./course/index.html) * 基本图像处理 * 图像获取和显示 * [图像获取](./course/image/basic/get_images.html) * [图像显示](./course/image/basic/display_images.html) * [MaixPy 图像及常用操作](./course/image/basic/vary.html) * [基本画图、写字](./course/image/basic/draw.html) * [硬件加速的图像处理](./course/image/basic/acc_image_deal.html) * MaixPy AI * [深度神经网络基础知识](./course/ai/basic/dnn_basic.html) * [MaixPy AI 硬件加速基础知识](./course/ai/basic/maixpy_hardware_ai_basic.html) * 图像处理 * [人脸检测](./course/ai/image/face_detect.html) * [1000 种物体分类](./course/ai/image/1000_type_classifier.html) * [人脸识别](./course/ai/image/face_recognization.html) * [自学习分类](./course/ai/image/self_learn_classifier.html) * 音频处理 * [语音识别](./course/speech/recognizer_cnn.html) * 模型训练 * 训练自己的分类和检测模型 * [MaixHub 云端训练](./course/ai/train/maixhub.html) * [本地训练](./course/ai/train/local.html) * 传统算法 * 图像处理 [寻找色块](./course/image/find_color_blob.html) [二维码识别](./course/image/find_qrcodes.html) * 音频处理 [FFT](./course/speech/fft.html) [FFT 瀑布图](./course/speech/fft_waterfall.html) [关键词识别](./course/speech/recognizer_mfcc.html) * 外设 * 片上外设 [I2C](./modules/on_chip/i2c.html) [PWM](./modules/on_chip/pwm.html) [SPI](./modules/on_chip/spi.html) [Timer](./modules/on_chip/timer.html) [UART](./modules/on_chip/uart.html) [I2S](./modules/on_chip/i2s.html) [WDT](./modules/on_chip/wdt.html) * [SP MOD](./modules/sp_mod/index.html) [BT 蓝牙透传](./modules/sp_mod/sp_bt.html) [LoRa 无线通信](./modules/sp_mod/sp_lora.html) [RFID 射频识别](./modules/sp_mod/sp_rfid.html) [TOF 测距](./modules/sp_mod/sp_tof.html) [Eink 电子墨水屏](./modules/sp_mod/sp_eink.html) [Lcd1.14 IPS屏](./modules/sp_mod/sp_lcd1.14.html) [Weather 气象模块](./modules/sp_mod/sp_weather.html) [Ethernet 有线网口](./modules/sp_mod/sp_ethernet.html) * [Grove](./modules/grove/index.html) [Ultrasonic Ranger 测距](./modules/grove/grove_ultrasonic_ranger.html) [Chainable RGB LED 灯](./modules/grove/grove_chainable_rgb_led.html) [RGB LED Ring 灯条](./modules/grove/grove_rgb_led_ring.html) * 更多外设 [Sipeed 麦克风阵列](./develop_kit_board/module_microphone.html) [双摄模块](./modules/others/binocular_camera.html) [MLX90640 串口红外镜头](./modules/others/mlx90640.html) [HTPA 红外镜头](./modules/others/htpa.html) [舵机](./modules/others/servo.html) [ESP32 ADC](./modules/others/esp32_read_adc.html) [onwire 单总线](./modules/others/onewire.html) * 更多功能 * 系统 [主频、复位等](./course/others/system.html) [内存配置与查看](./course/others/mem.html) * GUI [中文等多国语言支持](./course/image/image_draw_font/image_draw_font.html) [Maix UI](./course/others/maixui.html) [Lvgl](./course/others/lvgl.html) [编辑器 pye](./course/others/pye.html) * 网络 [配置 network 网卡](./course/network/network_config.html) [使用 socket 通信](./course/network/socket_usage.html) * 多媒体 [audio](./course/media/audio.html) [video](./course/media/video.html) * 游戏 [NES 游戏机](./api_reference/media/nes.html) ## API手册 * [标准库](./api_reference/standard/index.html) [cmath](./api_reference/standard/cmath.html) [gc](./api_reference/standard/gc.html) [math](./api_reference/standard/math.html) [sys](./api_reference/standard/sys.html) [ubinascii](./api_reference/standard/ubinascii.html) [ucollections](./api_reference/standard/ucollections.html) [uctypes](./api_reference/standard/uctypes.html) [uerrno](./api_reference/standard/uerrno.html) [uhashlib](./api_reference/standard/uhashlib.html) [uheapq](./api_reference/standard/uheapq.html) [ujson](./api_reference/standard/ujson.html) [uos](./api_reference/standard/uos.html) [ure](./api_reference/standard/ure.html) [usocket](./api_reference/standard/usocket.html) [ustruct](./api_reference/standard/ustruct.html) [utime](./api_reference/standard/utime.html) [uzlib](./api_reference/standard/uzlib.html) * [machine](./api_reference/machine/index.html) [I2C](./api_reference/machine/i2c.html) [PWM](./api_reference/machine/pwm.html) [SPI](./api_reference/machine/spi.html) [Timer](./api_reference/machine/timer.html) [UART](./api_reference/machine/uart.html) [network](./api_reference/machine/network.html) [WDT](api_reference/machine/wdt.html) * [Maix](./api_reference/Maix/index.html) [FPIOA](./api_reference/Maix/fpioa.html) [GPIO](./api_reference/Maix/gpio.html) [KPU](./api_reference/Maix/kpu.html) [FFT](./api_reference/Maix/fft.html) [I2S](./api_reference/Maix/i2s.html) [freq](./api_reference/Maix/freq.html) [utils](./api_reference/Maix/utils.html) * [helper](./api_reference/builtin_py/index.html) [fpioa_manager](./api_reference/builtin_py/fm.html) [board_info](./api_reference/builtin_py/board_info.html) [Micropython Editor](./api_reference/application/pye.html) * [media](./api_reference/machine_vision/index.html) [lcd](./api_reference/machine_vision/lcd.html) [sensor](./api_reference/machine_vision/sensor.html) [image](api_reference/machine_vision/image/image.html) [video](./api_reference/media/video.html) [audio](./api_reference/media/audio.html) [nes](./api_reference/media/nes.html) [lvgl](./course/others/lvgl.html) [isolated_word](./api_reference/machine_vision/isolated_word.html) [maix_asr](./api_reference/machine_vision/maix_asr.html) * [extend](./api_reference/extend/index.html) [touchscreen](./api_reference/extend/touchscreen.html) [modules.ultrasonic](./api_reference/extend/ultrasonic.html) [modules.ws2812](./api_reference/extend/ws2812.html) [modules.htpa](./api_reference/extend/htpa.html) [modules.onewire](./api_reference/extend/onewire.html) ## 常见问题 FAQ * [MaixPy 常见问题 FAQ](./others/maixpy_faq.html) * [MaixHub 平台 FAQ](./others/maixhub_faq.html) ## 进阶 * 进阶开发 [源码目录结构](./course/advance/project_framework.html) [如何编译 MaixPy 工程](course/advance/compile.html) [如何用 C 添加一个 MaixPy 模块](./course/advance/add_c_module.html) [打包文件系统](./course/advance/pack_fs.html) * 参与贡献 [参与文档编写（规范）](./contribute/doc_convention.html) [代码编写规范](./contribute/code_convention.html) ## 社区 & 分享 [精选文章](./share/recommend_articles.html) [开源项目](./share/open_projects.html) 大家的经验分享 * [参与经验分享/分享模板](./share/my_share/index.html)"},"/soft/maixpy/zh/how_to_ask.html":{"title":"如何优雅地提问","content":" title: 如何优雅地提问 keywords: maixpy, k210, AIOT, 边缘计算, 人工智能, 深度学习 desc: maixpy 如何优雅地提问 ## 在各个地方提问时， 大家会发现有几个现象： * 提问题后没人回答 * 提的问题过了很久才有人回答 * 对方老是嫌弃自己太菜 ## 问问题前，确认自己已经学习了 入门指南 本文档的 **入门指南** 章节， 是使用 `MaixPy` 的基础中的基础， 不管你是否有过开发经验，是大佬还是小白， 请务必从前到后完整阅读并操作一遍。 很多问题会在这个过程中解决， 切忌一开始就到 QQ群、论坛 、issue， 或者邮件随便提问， 很多在文档中一开始就说明了的问题可能不会得到社区的及时的回答， 节省大家的时间，也为了更好的社区环境，大家共同更好地成长，请互相理解 ## 提问时，尽量做到以下几点，会大大提高问题被快速解决的几率： ### 缕清问题， 弄清楚到底发生了什么，以及我做了什么，包括： * 我想实现什么效果，什么功能？ * 为了实现这个效果，我是怎么做的， 详细的过程是什么？ * 实施的过程中， 什么错误发生了， 现象是什么（比如报错了， 报了什么错，**完整**的错误内容是什么？） * 我是否认真看了报错的信息， 报错信息中是否有提示了错误的原因和解决的方法？ * 根据这些报错信息， 仔细思考， 是否能解决问题？ * 搜索 文档、 issue， 以及用搜索引擎能不能搜索到问题的解决方法 ### 如果问题自己实在不能解决， 需要请教于人， 需要考虑： * 请教谁，在哪里请教， 谁会更有几率回答我的问题？以及实时性如何？ * 我应该给他提供什么数据和现象他才能愿意快速帮我解决问题？ * 提供我的目的 （方便让回答者知道你在做什么事情） * 提供完整的实施过程， 以及过程中出现的现象 （方便回答者跟着你的流程去做一遍， 即问题复现） * 给出错误的地方， 指明哪里出现的现象或结果和自己预期的不一样！ （让回答者知道，哪里没达到预期） * 提供出现的错误信息， 需要完整， 尽可能更多地截图， 更多的日志，千万别小气地截一张小图，或者之给出日志的一部分（ 因为回答者可能很久没做这件事情了，忘记了一些细节，需要靠截图和完整日志来快速回忆起来; 而且根据详细的日志可以快速定位到问题处在哪里） * 怎么提问态度显得比较诚恳，就算我再小白，大家也愿意回答 ### 提问模板 提问尽量做到提问优雅，不需要添加多余的语气词，抱怨的词汇，斟酌每一个词和标点符号，站在回答人的角度思考问题，如何让回答的人快速帮助自己解决问题， 字数太少描述不清楚， 字数太多则让人没有耐心 #### 标题 无论在哪里提问（包括`QQ群`）， 给自己的问题拟定一个`30`个字左右标题， 阐明问题的中心思想，包括： * 问题类别， 是问题请教，还是 BUG提交，还是经验分享等等。让大家在满是文字的屏幕上可以立马定位到你想做什么 * 一句话阐明问题的中心你思想，比如 `运行摄像头示例程序，报错 reset fail， 可能是硬件问题` 所以综合后标题可以是这样： * `【MaixPy 提问】 运行摄像头示例程序，报错 reset fail， 可能是硬件问题吗` 这样的标题一定**不能**出现: * `啊啊啊啊啊为什么我的板子又不行了` * `为什么我的代码不能运行了` * `为什么我的屏幕黑屏了` * `【MaixPy 提问】 收到了开发板，开发板屏幕是红的，一行小字，为什么呢？` * `我运行xxx程序，出了问题` 可以这样问： * `【MaixPy 提问】 我的板子在我接反电源后，现在板子无法启动，怎么判断板子哪里烧毁了，如果可以，怎么救活呢` * `【MaixPy BUG】 pix_to_ai 没有对最后一个像素进行转换` #### 内容 首先站在回答者的角度， 如果被问问题: * 首先要知道对方要做什么，实现什么目标 * 为了实现这个目标，他是参考了哪里的步骤做的 * 实际上采用了哪些具体的步骤，然后在那一步出现了问题， 方便我照着他的步骤去尝试复现一下现象。如果这个问题看起来不好解决，又没有复现的步骤，那可能要花很多时间去复现，先放一放先解决其它问题吧 * 具体出现的问题是什么，如果他只说出了问题，我怎么知道他出了什么问题，也许是身体不适？所以这很重要，需要让他说明出问题时的现象，并指明与预期有什么不同，不然我还得去猜去对比和预期有什么不同，解决问题的时长又增加了 * 出问题了，我可能需要他的日志文件，方便我根据日志去看源码等进行分析，不然可能会很难解决问题，那这个问题可以放到后面慢慢看吧 综上， 可以这么提问： * 详细阐明自己的目标，想做什么事情， 现象应该是什么样的 * 我有没有参考哪里的文档、代码或者教学 * 如何复现错误：具体怎么做的， 每一个步骤写详细，直到问题出现 * 详细阐述错误出现时的现象，以及和期望的相比哪里不一样，需要证明问题确实出现了 * 附带日志文件，以及截图，甚至是视频，日志和截图一定要完整，不要只截取一小部分，回答者可能会从你的完整日志和截图中发现一些你没注意到的问题，这很重要！ * 另外，粘贴代码注意格式，别粘贴后显示很乱，无法入目，尽量能复制后 直接能运行 * 最后，对解答问题的社区朋友们表达感谢"},"/soft/maixpy/zh/what_maix_do.html":{"title":"MaixPy 能做哪些事","content":" title: MaixPy 能做哪些事 keywords: maixpy, k210, AIOT, 边缘计算, 人工智能, 深度学习 desc: maixpy MaixPy 能做哪些事 以下展示的功能为 K210 目前能实现的功能，部分功能为开源开发者们自行开发的成果，并不是官方能提供以下所有功能对应的源码和模型！！！ ## 人脸检测 <iframe style src \"//player.bilibili.com/player.html?aid 48648880&cid 85194253&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\"> </iframe> ## MobileNet 物体识别 <iframe src \"//player.bilibili.com/player.html?aid 46664014&cid 81743560&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\"> </iframe> ## tiny yolov2 20分类 <iframe src \"//player.bilibili.com/player.html?aid 50442796&cid 88307224&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\"> </iframe> ## 人脸识别 <iframe src \"//player.bilibili.com/player.html?aid 77466790&amp;cid 132521878&amp;page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\"> </iframe> ## 情绪识别 <iframe src \"//player.bilibili.com/player.html?aid 627513525&bvid BV1Jt4y1i755&cid 247518143&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\"> </iframe> ## 识别颜色值、找形状、找直线、面部识别等 <iframe src \"//player.bilibili.com/player.html?aid 48652548&cid 85200171&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\"> </iframe> 视频来自 [Hardware.ai](https://www.youtube.com/channel/UCCBSoR9ZO0Uj7W6jH9Y317g) ## MNIST 手写数字识别 <iframe src \"//player.bilibili.com/player.html?aid 46663492&cid 81742916&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\"> </iframe> ## 车牌识别 <iframe src \"//player.bilibili.com/player.html?aid 628060482&bvid BV1it4y1Y7zc&cid 263532620&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\"> </iframe> ## 分拣系统 <iframe src \"//player.bilibili.com/player.html?aid 927463889&bvid BV1pT4y1w7Aq&cid 246175512&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\"> </iframe> ## Feature map 显示 <iframe src \"//player.bilibili.com/player.html?aid 44971536&cid 78764427&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\"> </iframe> ## 视频播放和录制 <iframe src \"//player.bilibili.com/player.html?aid 44971751&cid 78764762&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\"> </iframe> ## NES 游戏模拟器 （FC 红白机） <iframe src \"//player.bilibili.com/player.html?aid 48653991&cid 85202525&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\"> </iframe> ## GBA 游戏模拟器 <iframe src \"//player.bilibili.com/player.html?aid 48654358&cid 85203041&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\"> </iframe> [源码](https://github.com/44670/mgba k210) ## 游戏 Quake I <iframe src \"//player.bilibili.com/player.html?aid 48656943&cid 85206864&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\"> </iframe> [源码](https://github.com/elect gombe/quake k210) ## MMD 3D 实时渲染 <iframe src \"//player.bilibili.com/player.html?aid 48656998&cid 85206967&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\"> </iframe> [源码](https://github.com/elect gombe/k210_mmd) ## GUI 界面 littlevGL <iframe src \"//player.bilibili.com/player.html?aid 48653253&cid 85201363&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\"> </iframe> ## 云台脸部跟踪 <iframe src \"//player.bilibili.com/player.html?aid 36466137&cid 64024878&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\"> </iframe> ## 麦克风阵列 <iframe src \"//player.bilibili.com/player.html?aid 37058760&cid 65120313&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\"> </iframe> ## FFT 频谱图 <iframe src \"//player.bilibili.com/player.html?aid 44617696&cid 78104545&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\"> </iframe>"},"/soft/maixpy/zh/others/maixpy_faq.html":{"title":"MaixPy 常见问题","content":" title: MaixPy 常见问题 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy MaixPy 常见问题 ## MaixPy 与 C 开发有什么异同，我该怎么选择 MaixPy 是基于 Micropython 的脚本语言， 不需要编译，在运行时解析，编写起来更简单方便，只是运行时时实性不如 C 语言。 所以如果是快速验证、新手、只会 python、头发少等都可以用 MaixPy; 追求极限性能效率或者熟悉 C ，以及对 MaixPy 的长期运行的稳定性不太有信心的都可以使用 C 语言开发 ## MaixPy 软件包失败现象 1. 卸载干净之前下的软件安装包，重新下载并换磁盘安装。 2. 卸载软件，删除释放的文件，清理注册表后，重装即可 <img src \"\" alt \"maixpy\"> ## MaixPy IDE 无法成功连接开发板 **现象:** ​\t开发板到手之后，一直无法连接 MaixPy IDE * 检查固件是否支持 IDE， 早期的固件以及名字带`minimum`的固件都不支持 * 检查串口是否被占用（其它软件也打开了串口） * 点击连接后，不用和终端工具同时使用，否则会出现串口占用无法打开 * 如果一直无法成功连接成功， 检查： * 请检查是否开发板型号选择错误； * 观察开发板屏幕是否有变化，如果没有反应可能是串口选择错误； * 尝试升级到最新的 [master 分支固件](http://cn.dl.sipeed.com/MAIX/MaixPy/release/master)， 以及最新的 MaixPy IDE 软件 > MaixPy 版本号低于 0.5.0_v0 不支持连接 MaixPy IDE ## Micro SD 卡读取不到 Micro SD 读取不到现象及解决方法: 1. 确认 SD 能否在电脑上正常使用，如果不能即 SD 已损坏， 2. 电脑能够正常使用，读取 SD，但 MaixPy 开发板无法使用： SD 卡未格式化为 MBR 分区 FAT32 格式 3. 电脑能够正常使用 SD 卡，也确认 SD 卡的磁盘格式为 FAT32，但 MaixPy 开发板依旧无法使用： 可能存在的原因：部分 SD 出厂时，sd 中没有磁盘分区表，或者磁盘分区表类型不是 MBR 解决的方法：使用第三方磁盘管理软件，将 sd 分区表类型转换为 MBR, 并且将 sd 格式格式化为 FAT32 > 这里使用 **Diskgenius** 来转换磁盘分区表格式 ![Diskgenius](../../assets/other/diskgenius.png) ![GPT 类型转 MBR](../../assets/other/diskgenius_sd_gpt_to_mbr.png) ![MBR 类型](../../assets/other/diskgenius_sd.png) 3. SD 卡不支持 SPI 协议 目前硬件只能支持 SPI 协议读取， 尽量购买正规的卡 比如：下图左边两张卡 MaixPy 的驱动不支持， 中间和右边的都支持， 但是中间的 class10 卡速度最快（最高测过 128GB可用） > 另外测试过网上购买的几张闪迪、金士顿、三星的卡，其中发现有一张三星的卡无法使用 ![](../../assets/hardware/other/tf_sdcard.png) ## SD 卡支持多大容量 最大测试过 **1TB** 可以使用 ## 使用 SD 加载文件、模型不成功 现象：我们在使用过程中可能遇到加载模型提示错误， 可能存在的问题原因: sd 不兼容，挂载不成功 验证 sd 卡是否挂载方法: ```python import os print(os.listdir(\"/\")) >>['flash'] # 没有挂载 SD 卡 >>['flash', 'sd'] # 挂载 SD 卡成功 ``` ## 为什么连接了 IDE 帧率降低了很多 K210 没有 USB 外设， 因此只能使用串口与 IDE 通信， 速度不如 USB 设备快，因此会影响帧率， 可以关闭 IDE 的摄像头预览 ## 为什么 IDE 上预览的摄像头图像很模糊 K210 没有 USB 外设， 因此只能使用串口与 IDE 通信， 速度不如 USB 设备快， 因此对图片进行了压缩，如果需要看清晰的图像请在开发板的屏幕上看，或者保存成图片传到电脑查看 所以 IDE 的图像预览功能主要是给教学和演示使用， 平时建议使用屏幕， 可以使用以下代码来设置预览图质量 ```python sensor.set_jb_quality(95) ``` 这样就将预览图的质量设置为了 `95%`， 但是帧率会有明显降低 ## 怎么提高摄像头帧率 * 换更好的摄像头，比如 `ov7740` 帧率会比 `ov2640` 高一点。 但前提是摄像头电路必须与开发板的电路兼容 * 增加摄像头时钟频率(`sensor.reset(freq )`)，但是注意不要太高，太高会让画面变差 * 可以自己编译源码，打开摄像头双缓冲选项（默认打开），并且 `sensor.reset(dual_buff True)`，帧率会有所增加，但是相应地，耗费的内存也会增加（大约为 384KiB ） ## IDE 帧缓冲区成像方向不正确，LCD 显示方向不正确 由于 MaixPy 支持的硬件型号较多，在使用 MaixPy IDE 或者 LCD 显示的时候会出现显示的方向不正确,那么这时候我们就需要对图像进行旋转了; 在修正显示方向之前,我们需要确认是 Sensor 方向旋转(MaixPy IDE 右上角的图像即为 Sensor 直接输出的图像)了，还是 LCD 方向旋转了 修正方法: sensor 方向修正： ```python # 设置摄像头水平镜像 # `enable`: 1 表示开启水平镜像 0 表示关闭水平镜像 sensor.set_hmirror(enable) # 设置摄像头垂直镜像 # `enable`: 1 表示开启垂直镜像 0 表示关闭垂直镜像 sensor.set_vflip(enable) ``` lcd 方向修正： ```python # 设置 `LCD` 屏幕方向 # 参数: `dir`: 取值范围 [0,3]， 从`0`到`3`依次顺时针旋转 # 返回值: 当前方向，取值[0,3] lcd.rotation(dir) # 设置 `LCD` 是否镜面显示 # 参数: `invert`： 是否镜面显示， `True` 或者 `False` # 返回值: 当前设置，是否镜面显示，返回`True`或者`False` lcd.mirror(invert) ``` ## 烧录 MaixPy 之后， K210 无法启动 现象：我们在使用过程中可能遇到烧录 MaixPy 之后，MaixPy 出现无法启动(表象为 无法点亮屏幕，白屏 等)， 问题原因: 出现这种现象很大一部分是内部文件系统中的配置文件读取出错，或者我们设置的系统配置值(如 gc heap 值过大)出错导致系统无法启动。 解决方法：擦除文件系统(擦除全部 flash) 使用 kflash_gui 右上角选择`擦除`功能，然后加载`MaixPy 文件系统`模板，地址变成`0xD00000`, 长度变为`3MiB` 或者直接烧录擦除固件: 点击下载 [K210 chip_erase.kfpkg](https://dl.sipeed.com/fileList/MAIX/MaixPy/release/Erase_all/K210 chip_erase.kfpkg) 擦除后再重新烧录一次目标固件即可 ## 使用 JTAG 调试器一直无法接连 K210 现象：使用裸机开发 K210, JTAG 调试器一直无法接连 K210 可能的原因： 1. OpenOCD 调试环境搭建有问题（细节这里不说明） 2. 烧录过 key_gen.bin 之后，将永久禁用 K210 的 JTAG 调试功能 ## 下载，保存脚本到 MaixPy 内部flash 之后，板子无法更新固件，无法启动运行脚本 可能现象：下载，保存脚本到 MaixPy 内部flash 之后，板子无法更新固件，板子无法启动 1. 程序中拉高了 GPIO16, 造成了自动下载点电路无法拉低 GPIO16,使 K210 进入 ISP 模式，手动拉低 16 号管脚即可 ## kflash 无法烧录/更新 MaixPy 固件 kflash_gui 配置选项 开发板型号 开发板型号选错 烧录空间(SRAM/Flash) 烧录空间选错 波特率&下载速度模式 下载波特率过高 ## 出现 type object 'board_info' has no attribute 'XX' 请看[开发板配置文件](./../get_started/board_info.html),对开发板进行重新配置 ## TF卡格式没有问题，但是无法读取TF卡，挂载失败 请使用 ```python from machine import SDCard SDCard.remount() ``` 进行重新挂载 使用 ```python def sd_check(): import os try: os.listdir(\"/sd/.\") except Exception as e: return False return True print(sd_check()) ``` 进行检测是否挂载成功 ## ValueError:[MAIXPY]kpu: load error:2002, ERR_KMODEL_VERSION: onlysupport kmodel V3/V4 now 1、更新固件，更新固件，更新到最新版本支持v3/v4的MaixPy固件，具体更新方法看前面的文档 2、检查存放模型的位置是否与读取的位置是否一致，如果将模型放到sd上，然后读取的位置为flash的0x300000时就会出现这样的错误 3、如果是使用以 smodel 为后缀模型，必需使用自己开发板上的机器码 (从 MaixHub) 来获取模型。 ## 在 MaixPyIDE 上运行 boot.py 文件时，卡死，没有显示，没有报错 如果你的模型是烧录到flash上，你需要在串口终端上运行boot.py里面的代码，输出一段红色的报错信息为`Out of memory`，这时你需要将模型放到sd上，然后再进行读取（一定要可以挂载的sd卡，否则都是白干） ## 运行模型的时候报 ValueError: [MAIXPY]kpu: load error:2006, ERR. NO_ MEM: memory not enough 同上 Out of memory ，请使用更小的固件获得更多的运行内存，标准固件大于 2m 剩余 1m 多，同理选用 600kb 可以获得 3m 多的运行内存，查看剩余运行内存看 [demo_view_mem.py](https://github.com/sipeed/MaixPy v1_scripts/blob/master/basic/demo_view_mem.py)。 这是内存不足了，不是 flash 或者是 sd 内存不够，是运行内存不够了。解决办法： 1. 这时需要跟换 mini 固件得以解决，如果还是不行，那就要减少训练的时候使用的数据集 2. 或者通过查看【[内存管理](./../course/others/mem.html)】这篇教程进行对内存和 GC 进行调整 ## OSEerror: [Errno 2] ENOENT/OSError:[Error 5] EIO 所需要读取的文件不存在对应的路径上，如果这个文件是在sd卡上的话，建议查看sd卡是否挂载了 使用一下代码判断内存是否挂载上，如果挂载不上会放回False，可能是卡不兼容，或者是卡没有格式化好，如果不是在官方店买的卡，不能保证能用(`官方卡出现不能使用的及时与客服反馈`) ```python def sd_check(): import os try: os.listdir(\"/sd/.\") except Exception as e: return False return True print(sd_check()) ``` 可以使用下面代码进行重新挂载 ```python from machine import SDCard SDCard.remount() ``` ## 串口终端打不开板子，但是ide可以运行 1、检查串口是不是被ide占用了，因为串口只能用一个软件进行打开。 2、使用 ide 中软件菜单的串口终端打开 ## ValueError: [MAIXPY]kpu: load error:2005,ERR_READ_FILE: read file failed 读取文件失败（read file failed） 重新获取模型，重新烧录模型，重新导入模型。 检查文件是不是损坏了，用校验工具对比一下。 检查sd卡上的模型模型和代码中的名字与路径是不是一样的。 检查模型下载地址是不是和程序一样。 ## 烧录了 key_gen.bin 之后的操作 烧录 key_gen.bin 之后，通过串口软件来连接开发板，然后按下 reset 按键，重启开发板，可以看到机器码打印到串口的接收区中。也可以通过 MaixPy IDE 中的 [串口终端](/soft/maixpy/zh/get_started/env_serial_tools.html#MaixPy IDE终端工具)来连接开发板查看机器码。 获取到机器码之后，需要重新烧录需要使用的固件才能运行对应的代码。否则是连 IDE 都无法连接的 ## 摄像头拍摄的模糊 使用 OV5642 摄像头拍摄出来的画面模糊，可以通过扭动摄像头来进行调整焦距。如果使用其他的摄像头拍摄的模糊也是同理，但有些摄像头特性就是如此，只能通过更改摄像头来进行修改 ## 烧录模型或者固件，出现花屏、屏幕颜色不对、屏幕颜色单一 这时需要使用 kflash 来对 flash 整片擦除，然后重新烧录 固件 和 模型。 烧录模型到 flsah 的时候一定要注意烧录的位置，是否正确（数清楚对应 0 的个数）。 比如常见的白色花屏以及黄屏就是固件烧错，需要擦除重烧标准固件就正常了，主要因为屏幕配置不同导致的。 比如绿屏可能是摄像头损坏了输出了绿色图像。 比如红屏是正常的，但需要用户下载程序。 蓝屏的话需要完全擦除片内 flash 后再重新烧录。 ![yellow_lcd](./../../../../../news/MaixPy/mixly_application/accets/k210_usage/yellow_lcd.png) ## TypeError: Can't convert to type 错误 Maixpy ide 挂着运行时内存不足，就会出现的常见错误，解决方法，换成菜单的打开终端运行，或让内存有一定预留就不会出现了。 ## kpu:check img format err! 注意看终端输出提示，特别强调！！！ 灰色字体的错误 kpu img w 320, h 240 but model w 224, h 224 意思是说，这个模型的要求是 224 224 ，但输入的是 320 240 。 所以要改图片为 224 224 输入，如果是 128 128 同理修改图片尺寸！！！！！ 要么使用 sensor.set_windowing 改变摄像头输入大小，要么对 图像 img.resize 改变图像大小。 ## ValueError input not support 检查一下 Python 代码出错行，排查 ValueError 错误，一般发生在输入的类型不与目标函数所需的类型一致导致的错误，可能是内存不足导致对象为 None 也可能是类被回收了。 ## OSError reset failed 这种情况表示板卡对摄像头初始化失败了，可以看到 `sensor.reset()` 是有初始化摄像头的功能的。 ![os_error](./assets/maixpy_faq/os_error.png) 1. 摄像头接线错误，板卡不能正常对摄像头进行初始化操作。 2. 摄像头损坏，板卡无法对摄像头初始化。 建议使用 Sipeed 所提供的摄像头，用户自行配备的可能因为线序不符或者摄像头驱动不支持等原因而不能用。 ## 后缀名为 kmodel 和 smodel 的模型文件有什么区别？ 后缀名为 kmodel 的模型文件是用来阐述这个模型的形状结构和参数。 而 smodel 模型需要用到机器码；机器码是一机一码的一种加密方式，用于模型文件的加密。如果使用别的机器码去加密或者下载其他以 smodel 为文件后缀的模型文件，开发板是无法使用这些模型文件的!! ## MemoryError: Out of normal MicroPython Heap Memory 前往 ： [https://neucrack.com/p/325](https://neucrack.com/p/325#%E5%86%85%E5%AD%98%E4%B8%8D%E5%A4%9F%20%EF%BC%88MemoryError:%20Out%20of%20normal%20MicroPython%20Heap%20Memory!%EF%BC%89) 查阅相关解决方法 ## 如何同时运行多个模型 其实也不是同时运行，而是分时运行。 如果有足够内存，就一次性把几个模型加载到内存， 然后分别分时运行推理。 如果内存不足，加载第一个模型，运行后注销（使用 `kpu.deinit`），再加载运行第二个模型部分或全部模型。使用 `load_flash` 的方式加载模型，实时从 flash 读取内容。 ## 如何加载大模型 由于 K210 的 RAM 的运行限制，当需要加载大模型文件时，可以通过直接 Flash 中动态加载并运行。 具体用法前往 github: 使用说明:[点我github](https://github.com/sipeed/MaixPy v1_scripts/blob/master/machine_vision/load_big_model/README_ZH.md) 具体仓库:[点我github](https://github.com/sipeed/MaixPy v1_scripts/tree/master/machine_vision/load_big_model) ## could not open port 'COMxx':Permission 错误 这种情况是因为串口被占用了，自己将使用过串口的程序关闭掉就行。实在不会解决的话重启电脑也能达到关闭所有使用串口程序的效果。 ## Maix Dock 串口不能用 Maix Dock 不能使用 MobaXterm 或其他 不支持手动串口流控制的软件 来进行串口通信。 为了节省时间，建议使用 MaixPy IDE 来进行通信。 可以在 MaixPy IDE 顶部菜单栏 工具 >打开终端 >新终端 >连接到串口 >选择正确的串口 >115200波特率 来新建一个终端，在这里面使用串口。 ![sipeed_maix_dock_terminal](./../../assets/hardware/maix_dock/sipeed_maix_dock_terminal.png) ## 烧录固件途中出现握手失败等报错信息 ![kflash_gui](./../../../../../news/MaixPy/mixly_application/accets/k210_usage/kflash_gui.jpg) 一般出现这个问题，先从以下几个方面判断问题（因使用环境不同造就的设备握手失败） 1. 设备管理器没有 `COM` 端口，重新安装串口驱动或者更换 USB 线材再次尝试。 2. 设备管理器出现 `COM` 端口，但是串口被其它软件占用了，重新插拔一次 USB 即可。 3. 更新烧录软件到最新版本：[点我](https://dl.sipeed.com/shareURL/MAIX/tools/kflash_gui)。 4. 烧录前依次按住 BOOT 和 RST 按键，然后按顺序松开 RST 按键和 BOOT 按键，使芯片进行烧录模式。 5. 尝试过以上的方法都不行的话请更换电脑设备尝试，可能由于 USB HUB 或者 USB 线缆等外部因素导致的。 ## 摄像头出现黑斑现象 ![sensor_error](./../../../../../news/MaixPy/mixly_application/accets/k210_usage/sensor_error.png) 显示黑斑，但是有正常画面。说明摄像头内片不干净，拆开摄像头后小心擦拭下。 ## 运行摄像头程序显示：RuntimeError：Sensor timeout! 摄像头连接超时，更换摄像头。 ## 烧录固件后画面反色 擦除、烧录固件，使用代码反色屏幕：[点我查看](https://wiki.sipeed.com/soft/maixpy/zh/course/image/basic/display_images.html?highlight %E5%8F%8D%E8%89%B2)。 ## 孤词语句模块进入录音状态后显示：Idle 2 阅读 [录入词汇模板](https://wiki.sipeed.com/soft/maixpy/zh/course/speech/recognizer_mfcc.html#%E5%BD%95%E5%85%A5%E8%AF%8D%E6%B1%87%E6%A8%A1%E6%9D%BF) 和 [isolated_word API](https://wiki.sipeed.com/soft/maixpy/zh/api_reference/machine_vision/isolated_word.html)来了解更多 ## K210 是否支持 TensorFlow .h5/.tflite 格式模型 K210 支持 TensorFlow .h5/.tflite 格式模型，但使用的时候用 nncase 工具转化成 `.kmodel` 格式才可进行使用。相关文档链接：[MaixPy AI 硬件加速基本知识](https://wiki.sipeed.com/soft/maixpy/zh/course/ai/basic/maixpy_hardware_ai_basic.html#%E6%A8%A1%E5%9E%8B%E8%BD%AC%E6%8D%A2) ## 当操作失误需判断 K210 主控芯片是否短路 使用万用表查看芯片的 `1.8/3.3` 是否有电压，下图红框都是输出点。 ![board_voltage_checkpoint](./assets/maixpy_faq/board_voltage_checkpoint.jpg) ## 使用 k210 曝光过重过低如何解决 只有 K210 配套的 OV2640 摄像头支持曝光调节，阅读 [sensor 感光元件曝光控制](https://wiki.sipeed.com/news/MaixPy/sensor.html) 了解更多 ## K210 是否支持 U 盘挂载到电脑 K210 不支持 USB 设备，芯片没有 USB 功能，无法模拟 U 盘设备，不支持挂载文件系统到电脑。 不要再问为什么没有 U 盘或者是显示 SD 卡了！那示例设备不是 K210 。 ## K210 上电后电脑弹出 USB 集线有电涌 这是板卡短路了，导致 usb 电流过大电脑提示保护。 ## MaixHub 训练的模型，放到开发板运行时一直显示 Loading model... 可能是烧录了内存占用比较大的固件，可以先换成 minimum 版本的固件试试，可以再可以尝试普通固件 ## OSError: [Errno 5] EIO 1. 检查 I2C 设备的地址是否正确，应该是 0x20 而不是 20。 2. 检查 I2C 写入数据的格式是否正确，应该使用 `b'\\x03'` 和 `b'\\x80'` 而不是 `b'x3'` 和 `b'x80'`。 3. 检查 I2C 写入命令是否正确，如果您想要设置 PCA9534 的输入/输出模式，应该使用 `i2c.writeto_mem (0x20,0x3,b'\\x80')` 而不是 `i2c.writeto (0x20, 2, b'x80')`。 4. 检查 I2C 连接线是否牢固，是否有松动或断裂的情况。 5. 检查 I2C 设备是否有损坏或过热的情况。 6. 在 I2C 初始化和使用之间添加一些延时，以确保 I2C 端口已经激活。 ## AttributeError: 'Image' object has no attribute 'find_blobs' 请参考烧录和升级固件文档，烧录带 openmv 全功能的固件，即全功能固件， minimum 版本的固件是没有这个函数的，同理，其它 openmv 的函数也如此。 如果觉得全功能固件占用内存太大，也可以自己编译裁减固件大小"},"/soft/maixpy/zh/others/open_projects.html":{"title":"与 MaixPy 相关的开源项目","content":" title: 与 MaixPy 相关的开源项目 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy 与 MaixPy 相关的开源项目 如果你有什么跟 MaixPy 相关的开源项目， 欢迎通过邮件(support@sipeed.com)或者 [issues](https://github.com/sipeed/MaixPy_DOC/issues/new) 告诉我们，或者直接修改文档提交 PR 非常期待大家的好玩有趣或者实用的作品哦～～～"},"/soft/maixpy/zh/course/ai/basic/maixpy_hardware_ai_basic.html":{"title":"MaixPy AI 硬件加速基本知识","content":" title: MaixPy AI 硬件加速基本知识 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy MaixPy AI 硬件加速基本知识 ## 模型使用和硬件加速原理 前面我们知道了模型是一组数据结构以及很多参数， 最终以一个文件比如 `kmodel` 格式的文件的形式存在。 而这个模型要能在 MaixPy 的程序里面被使用， 首先需要程序能够理解 `kmodel` 这个文件的格式， 并且支持模型里面的算法，这样才能按照模型的描述将输入经过一些裂计算过程后得到输出。 所以，重点就是支持模型里面的算法，称 **算子**， 理论上，我们可以用软件去实现这些算子， 就可以成功运行模型了， 而执行软件的物理器件是 `CPU` ， 神经网络模型的计算量很大，加上我们输入的是图片，图片本身的数据量就挺庞大， 就算是 `K210` `400MHz` 的主频， 也无法满足流畅的推算模型。 所以， 要么升级 `CPU`，但是成本太高， 要么做一个专用的硬件， 让这个硬件专门去特定的算法，因为不像 `CPU` 一样要做通用计算， 所以速度会非常快，在电脑上， 我们通常使用专用的图像加速卡即 `GPU` 来加速图形计算， 在 `K210` 上，这个专门的硬件叫做 `KPU` (Kendryte Proccess Unit)，第一个单词是公司名， 其实和其它芯片的 `NPU` (神经网络处理单元 Neural network Processing Unit) 做的事情是一样的。 在 MaixPy 里面，已经集成了推导模型的代码，同时使用了 `KPU` 进行计算加速，使用时无需编写很多代码，只需要调用几个函数即可快速运行模型 ## 关于 KPU 虽然 KPU 是能够加速模型运算了， 但是由于成本、时间、功耗、体积、发热、应用领域定位等各种因素，它的能力并不能像专业领域的强力 `NPU` 一样，包含了每一种算子，它只能处理一部分。 KPU 实现了 卷积、批归一化、激活、池化 这 4 种基础操作的硬件加速， 但是它们不能分开单独使用，是一体的加速模块。 所以， 在 KPU 上面推理模型， 以下要求（如果不需要训练和设计模型，暂时不需要仔细了解）： 1. 内存限制 K210 有 6MB 通用 RAM 和 2MB KPU 专用 RAM。模型的输入和输出特征图存储在 2MB KPU RAM 中。权重和其他参数存储在 6MB 通用 RAM 中。 2. 哪些算子可以被 KPU 完全加速？ 下面的约束需要全部满足。 * 特征图尺寸：输入特征图小于等于 320x240 (宽x高) 同时输出特征图大于等于 4x4 (宽x高)，通道数在 1 到 1024。 * Same 对称 paddings (TensorFlow 在 stride 2 同时尺寸为偶数时使用非对称 paddings)。 * 普通 Conv2D 和 DepthwiseConv2D，卷积核为 1x1 或 3x3，stride 为 1 或 2。 * 最大池化 MaxPool (2x2 或 4x4) 和 平均池化 AveragePool (2x2 或 4x4)。 * 任意逐元素激活函数 (ReLU, ReLU6, LeakyRelu, Sigmoid...), KPU 不支持 PReLU。 3. 哪些算子可以被 KPU 部分加速？ * 非对称 paddings 或 valid paddings 卷积， nncase 会在其前后添加必要的 Pad 和 Crop（可理解为 边框 与 裁切）。 * 普通 Conv2D 和 DepthwiseConv2D，卷积核为 1x1 或 3x3，但 stride 不是 1 或 2。 nncase 会把它分解为 KPUConv2D 和一个 StridedSlice (可能还需要 Pad)。 * MatMul 算子， nncase 会把它替换为一个 Pad(到 4x4)+ KPUConv2D(1x1 卷积和) + Crop(到 1x1)。 * TransposeConv2D 算子， nncase 会把它替换为一个 SpaceToBatch + KPUConv2D + BatchToSpace。 > 以上说明来自[这里](https://github.com/kendryte/nncase/blob/master/docs/FAQ_ZH.md) ## 模型转换 前面说到， 模型其实就是一组数据结构和参数数据，不同的软件只能识别特定格式的模型， KPU 只认`.kmodel`格式的模型， 一般用电脑训练的模型则不是， 比如 `tensorflow` 是 `.h5` 格式或者 `.tflite` 格式， 要给 `KPU` 使用， 必须经过变成 `kmodel` 格式， 可以使用 [nncase](https://github.com/kendryte/nncase) 这个工具来达到模型转换的目的 如果你需要转换模型， 具体使用方法请自行查看这个仓库里面的介绍 ## kmodel V3 模型 和 V4 模型 由于代码更新， 在过程中产生了两个大版本， `V3` 和 `V4`， 其中 `V3` 模型是指用 [nncase v0.1.0 RC5](https://github.com/kendryte/nncase/releases/tag/v0.1.0 rc5) 转换出来的模型； `V4`模型指用 [nncase v0.2.0](https://github.com/kendryte/nncase/releases/tag/v0.2.0 beta4) 转换出来的模型 两者有一定的不同，所以现在两者共存， `V3` 代码量更少，占用内存小，效率也高，但是支持的算子少； `V4` 支持的算子更多，但是都是软件实现的，没有硬件加速，内存使用更多，所以各有所长。 MaixPy 的固件也可以选择是否支持 `V4`。 ## MaixPy 中使用模型 kmodel 1. 加载 SD 卡 （TF 卡）中的模型 将模型放到 SD 卡， 然后加载 ```python import KPU as kpu m kpu.load(\"/sd/test.kmodel\") ``` 2. 加载 Flash 中的模型 将模型下载到 Flash， 然后加载 ```python import KPU as kpu model_addr_in_flash 0x300000 m kpu.load(model_addr_in_flash) ``` 此处的 `model_addr_in_flash` 为模型在 Flash 中的偏移地址，模型可以通过 kflash.py 或者 kflash_gui 烧录到 Flash 对应的地址中 3. 准备输入 一般情况下，我们会使用图像作为输入： 直接使用摄像头采集的数据作为输入： ```python img sensor.snapshot() ``` 这里 `img` 就可以直接作为输入， 这里需要 **注意**： `snapshot()` 函数采集到图片后，会将图片数据放到两个地方 (1) `RGB565` 内存块， 图像以 `RGB565` 的形式存放在一块内存中，方便图像处理的函数使用，注意在内存中的排序是 `[像素1 RGB, 像素2 RGB...]` (2) `RGB888` 内存块， 图像以 `R8G8B8` 的形式存放在另一块内存中，注意在内存中的排序是 `[所有像素 R, 所有像素 G， 所有像素 B]`， 我们也称之为 `AI` 内存 **其中，实际上作为 KPU 输入的数据是 `RGB888` 区域**， 这个在前面的文档 [MaixPy 图像及常用操作](./../../../course/image/basic/vary.html) 章节中有仔细讲解过 从文件读取，或者将修改过的摄像头图像作为输入： 直接从摄像头采集的图像会自动填充 `RGB888` 区域，但是我们使用图像处理函数比如 `image.resize()` 时，只会修改 `RGB565`，没有修改 `RGB888`，因为同时修改两处内存需要耗费大量时间，而 `KPU` 的输入又是 `RGB888` 内存块， 所以在需要进行 `KPU` 运算时， 需要同步（刷新）一下 `RGB888` 内存块， 使用 `img.pix_to_ai()` 来进行同步，否则先前的修改将不会在 `KPU` 上生效。 比如： ```python img image.Image(\"/sd/test.jpg\") # 从 sd 卡读取 test.jpg 作为输入 img.pix_to_ai() # 同步 `RGB888` 内存块 ``` ```python img sensor.snapshot() # 获取摄像头采集的数据 img img.resize(240, 240) # 使用图像处理函数处理原图像 img.pix_to_ai() # 同步 `RGB888` 内存块 ``` 4. 前向运行模型 前向运行模型，也就是按照 输入到输出 的方向走一遍模型计算， 通过输入得出输出的值： ```python feature_map kpu.forward(m, img) ``` 这里得到了 `feature_map`， 是一个特征图， 比如我们前面将的 `小球` 和 `玩具` 的分类，输出特征图是两个节点， 每个节点表示了是对应物体的概率，我们将特征图转换为 `list` 对象： ```python p_list feature_map[:] print(p_list) ``` 就可以得到类似 `[0.9, 0.1]` 这样的置信度结果了 ## KPU使用过程中的常见问题 ### KPU能够加载多大的模型？ C 语言代码运行模型： 当 K210 运行 C 代码时，能够加载 < 6MB 左右的模型， 具体要看 C 代码的内容。 MaixPy 运行模型： * 当运行 MaixPy (minimum版本) 时，能够加载 4MB 左右的模型。 如果不使用摄像头和 LCD， 最大可以加载 5MB 左右的模型（因为摄像头和 LCD 的缓冲区占用了很多内存，但实际应用也没多大意义了） * 当运行 MaixPy (完整版) 时，能够加载 2MB 左右的模型 * 另外也支持实时从 `Flash` 加载模型， 理论上只要单层使用内存不超过 2MB， 整体模型可以无限大，只不过要牺牲一点运算速度。 使用方法看[这里](https://github.com/sipeed/MaixPy v1_scripts/tree/master/machine_vision/load_big_model)。 如果对原理和实现感兴趣，可以看[这里](https://neucrack.com/p/313) ### 报错\"memory overflow\"怎么办？ 出现这个问题，根据前面讲到过的 [`系统内存管理`](../../others/mem.html) 可知，一般有两个可能性： 1. 报错的地方跟系统堆无关系， 可能是 `GC` 内存不够导致，可以适当增加 `GC` 的总内存大小 2. 由于模型过大引起的。可以依次尝试如下解决方案： 1. 更换 MaixPy mini 版本固件 2. 进行模型剪枝优化 3. 使用 `kpu.load_flash` 接口运行时实时加载模型，只是执行效率降低一点 4. 如果内存不足，且 `kpu.load_flash` 性能无法满足， 那么你可能需要使用 [C SDK](https://github.com/kendryte/kendryte standalone sdk) 进行开发。 ### 报错\"load error,only support kmodel v3/v4\"怎么办？ 出现这个问题可以尝试如下解决方案: 1. 如果为加载 Flash 中的模型，请确保 `flash offset` 填写正确，并保证和 MaixPy 固件的地址没有冲突（模型在 Flash 中的地址太靠前，然后往 Flash 烧录入固件时， 固件大小超过了模型所在的起始地址， 导致模型被破坏） 2. 如果是采用 `nncase 0.2.0` 进行转换的 `kmodel V4`，请尝试采用 `nncase 0.1.0` 进行转换，从而生成 `kmodel V3` ### 我想实现不同模型的选择加载(例如按下按钮运行目标分类，再次按下按钮则运行目标检测)，应该怎么写程序？ 因为内部 RAM 有限，所以当需要切换不同模型进行 `kpu.load(address)` 前，请先执行 `kpu.deinit(k210model)` 释放之前模型占用的内存，然后再加载新的模型。 也就是分时复用内存"},"/soft/maixpy/zh/course/ai/basic/dnn_basic.html":{"title":"深度神经网络（DNN）基础知识","content":" title: 深度神经网络（DNN）基础知识 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy 深度神经网络（DNN）基础知识 这里介绍使用 MaixPy AI 相关功能需要了解的知识，让你能够理解后面的内容， 不在本篇中深入介绍。 ## 如何解决一个问题 引出机器解决问题 一个问题， 通常分为 **输入** 和 **输出（结果）** 比如： 坐标系中的一条直线如下， 上面的数据点值是已知的: ![y kx+b](../../../../assets/dnn/ykxb.jpg) 现在提问，假如数据点规律不变， 输入一个 x 坐标 20, y 的值是多少？ 按照大家的知识，都知道这是一个一元一次方程(`y kx + b`能解决的， 带入两个点的值，算出方程为`y 3x + 10`, 那么当 `x 20`, `y` 的值为`70`， 于是输入是`20`, 输出是`70`。 这里就是 输入(`20`) + 算法（一元一次方程） 输出（`70`）， 这就是我们在解决一个问题时的基本方法， 所以关键就是找到这个符合这条线段上数据点规律的一个算法。 人类很强大，会从这些数据中归纳总结学习，最终得到了这个算法（方程），然后其他的人直接使用这个算法就可以快速用于解决同类问题，那么，有没有一种方法， 让机器自动去寻找这个算法呢？ ## 如何让机器总结出算法 要让机器自动总结出算法，即机器学习（ML，Machine Learning）， 我们先看看，人类是如何得到这个算法（方程）的。 * 步骤1： 首先，有大量数据点，然后人类根据这些数据点发现了直线都符合`y kx + b`这个适应所有直线的算法, 但是发现，这里面有两个未知数`k`和`b`, 这就是适应任何直线的参数 * 步骤2： 然后具体的是什么样的直线，因为方程有两个未知数，即参数，将实际的两个数据点带入这个方程，得到了`k 3`和`b 10` * 步骤3： 然后我们用在步骤2中没有用到的在线上的数据点，去试试这个算法（方程）是否正确，最终发现都验证正确 * 步骤4： 然后要通过`x`的值知道其它的点的`y`的值，只需要代入`y 3x + 10` 即可 那么，机器学习是不是也可以利用这个步骤来做呢？ * 我们认为地设计一个算法结构， 加入我们碰巧直接设计成了`y kx + b`， 我们给具体的直线留下了两个参数，我们暂且称呼这个结构叫 **模型结构**，因为有未知参数，我们称之为未训练的模型结构。其中`x`称为**输入**, `y`称为**输出** * 现在，我们将我们这条直线的的几个点代入到这个方程， 我们称这个过程为 **训练**，得到`y 3x + 10` 这个算法， 已经没有未知参数了， 我们现在称它为**模型** 或者 训练好的模型，其中`k b`是模型内的参数，`y kx + b`是这个模型的结构。 而带入训练的数据点，就叫做**训练数据**，它们的统称就叫**训练数据集** * 然后，我们使用几个在 训练 过程中没有用到的在线段上的数据点作为输入，代入这个模型进行运算，得到结果，比如 `x 10`, 得到`y 40`, 然后对比输出值是否与预期相符，这里我们发现`x 10, y 40` 确实是在图中这条直线上的， 并且训练时没有使用这个点，说明我们得到的模型在此次核验中通过，这个过程叫 **验证**， `x 10, y 40` 这个数据叫验证数据。 如果我们用多组数据去验证这个模型， 这些数据的统称就叫**验证数据集** * 现在， 我们获得了一个**模型**，并且用**验证数据集**对这个模型进行了验证，貌似也是很准确了，那我们就可以假设这个模型基本满足了我们以后有一个`x`， 要求着图中线上任意一点的`y`值，都可以输入`x`给出这条直线上对应点的`y`坐标。 这个过程我们其实是在**使用模型**了，这个过程称之为**推理** 其实这就算是机器学习了， 我们人类需要的事就是设计`y kx + b`这个结构，以及给出**训练数据集**和**验证数据集**，经过**训练**和**验证**得到一个我们认为可用的模型，然后使用`输入 + 模型`就可以得到认为的正确`输出（结果）`了。 ## 什么是深度神经网络？ 深度神经网络（DNN）是机器学习（ML）领域中的一种技术。 前面说了一个比较简单的例子， 根据一条直线数据来预测直线上的任何一个点， `y kx + b`这个结构是人为设计的， 很简单，当用于复杂的数据，发现它就不适用了，比如“这张图片里面是球还是玩具” ![小球](../../../../assets/dnn/ball.jpg) ![玩具](../../../../assets/dnn/toy.jpg) 前面为了模型能够存下一条直线的信息， 用了结构`y kx + b`，直线的特征都存在模型里面了。 现在用来存一张图的特征，光是`y kx + b`这个线性结构， 以及`k 和 b`两个参数显然无法满足了， 需要设计一个更好的结构， 这时 **神经网络** 就出现了， 一种网状结构，能更好地记住图片的特征信息， 而这个网状结构又是多层的，也就是有深度的，所以称之为深度神经网络（DNN， deep neural network）， 所以说 DNN 是一种网络结构，是为了实现机器学习的一种手段。 每一层由多个节点组成， 如下图， 一个 DNN 包含了 **输入层**， **隐藏层**， **输出层**， 这里隐藏层由三层组成（`A[1], A[2], A[3]`层），但是统称隐藏层： ![深度神经网络](../../../../assets/dnn/dnn.jpg) **输入层**： 图中就是一个深度神经网络结构， `x` 是输入， 比如`x`这里可以是图片, 输入有多个节点，每个节点可以是一个像素点值， 这里输入层画了 7 个节点， 假如我们有一张图片是 `10 x 10`的分辨率，则输入层共需要 `100` 个节点。 这里输入层是一个一维结构，实际情况可能有多维结构， 比如输入如果是一张灰度图片，分辨率`3x3`，这其实是一个二维结构，即两行两列的矩阵（关于矩阵的概念请自行学习，或者暂且理解成二维数组），比如： ``` [[109 138 110] [220 37 166] [32 243 67] ] ``` 每个像素点的值取值范围∈[0, 255]，然后我们将其平铺后变成共 9 个数据的一维数组给输入层 ``` [109 138 110 220 37 166 32 243 67] ``` > 另外， 一般也会将输入层的值归一化到范围`[0, 1]` 如果是一张彩色图片，那就是三维，即`高、宽、颜色通道`，颜色通道比如`RGB`三个颜色通道，即，输入有形状（包含了维度和每个维度的数据数量），比如上面的一维输入形状为`(9)`，其它图像通常以`(高，宽，通道数)`来表示形状，比如`(10, 10, 3)`表示分辨率`10 x 10`， 并且有三个颜色通道， 比如`RGB`。 这里为了入门好理解，原理只介绍一维的情况 **输出层**： `y` 是输出，这里输出有两个值，你可以理解成就是 MaixPy 的两个浮点值的 `list` `[Y1, Y2]`， `Y1`是`是小球的概率`，值∈[0, 1], `Y2`是`是玩具的概率`。 所以最终我们使用这个模型， 就是给它一张图片， 机器按照这个模型规定的结构和算法进行计算后得到一个 `list`， 我们根据这个输出的值就知道图中是什么东西了。 **隐藏层**: 连接输入层和输出层的隐藏层，以及中间的连接，负责了将输入数据推算成合理的输出值。 ## 中间休息，总结 到现在为止， 你知道， **模型**是什么：就是一组数据结构，保存了一个网络的形状，以及里面的参数， 通常，这个模型的数据可以被保存成文件，比如`.h5 .tflite .kmodel`等文件，都是用来阐述这个模型的形状结构和参数，只不过是不同软件使用。 人们只需要设计模型结构以及参数，用来解决一类问题，比如常见的物体分类， 比如就是上面说的区分一张图里面是小球还是玩具。 这个模型里面有很多参数，具体在需要识别物体的时候，使用已知分类的数据集让机器自动训练得出一套合适的模型参数。 然后我们就可以输入数据，让通过模型推理出来输入的数据时什么类别了。 所以， 如果我们不需要训练模型，直接使用别人训练好的模型，只需要： * 确认需求，找到现成的模型，因为模型已经是训练好的了，输入和输出的形状的含义都已经定了 * 确认模型的输入形状，比如模型输入分辨率`10x10`的彩图，则使用时需要将符合要求的图片传个输入层 * 确认输出层的含义，比如前面说的识别小球和玩具，最后输出是分别代表是该物体的概率的 list， 比如 `[0.9, 0.1]`, 第一个值代表是小球的概率，那我们就知道这张图里有 90% 的概率是小球， 只有 10% 的概率是玩具 * 将模型放到推理程序进行运行。 具体用什么程序先不着急，会在下一章介绍 到这里，应该大致上明白了以下东西： * 什么是机器学习 * 什么是深度神经网络（简单概念） * 模型是什么 * 什么是输入层，输出层，在上面举例的分类应用中分别表示什么含义，层形状是什么样的 * 到此为止，我可能还不知道什么是模型训练 * 如果我需要一个模型，我知道如何确认需求 所以，**如果你只希望能够使用模型，不需要训练，到此即可**， 也不需要知道模型有些什么具体的东西，你就把它当成一个**黑盒工具箱**使用即可。 如果想要更深的了解，请继续看下面的内容。 ## 继续：深度神经网络（续 既然设计了多层设计，那我们继续深入： **数据流** ， **权重**， **偏置**: 在模型进行推理时，数据从输入层流动到输出层，就是这些网状箭头的方向（第三节网状图），每个箭头前一层到后一层的计算可以用一个熟悉的公式:`y wx + b`, 称`w`为**权重**(weight), `b`为**偏置**（bias）, 注意是每个箭头都有一个单独的`w, b`, 也就是说后一层节点的值等于前一层节点经过这个公式计算过后的值， 后一层的节点有多个前一层节点指向，那就等于所有前一层节点的值经过这个公式计算后的值的和。 就这样经历了无数次运算后，结果终于在输出层以一个值的形式出现了，整个推理也就完成了 **激活函数**： 上面的模型虽然可以通过输入得到结果，但是会发现，所有层计算都是线性函数，那么不管有多少层，整体其实还是一个线性函数，即`y0 w1x + b1` + `y w2y0 + b2` > `y w2(w1x + b1) + b2` > `y w2w1x + w2b1 + b2`, 其实还是一个线性函数，那么多层的意义就没有了，于是我们需要在中间加入非线性函数，让网络内部更加复杂一点， 于是就在每个节点上做手脚， 在每个节点输出数据前，先对其用一个非线性函数运算，比如`sigmod`或者`relu`函数，别听到名字害怕，其实很简单，看下图, 总之就是 x 和 y 不成线性关系： ![sigmod](../../../../assets/dnn/sigmod.jpg) ![relu](../../../../assets/dnn/relu.jpg) 即到现在为止， 除了输入层，所有节点输出的值都需要经过`Sigmod(∑(Wn * x + Bn))`, 输出一个浮点数值 **softmax**: 输出层在最后输出的时候，因为前面的运算，值的范围不是很统一，虽然我们可以通过比大小，值最大的即认为是答案，但是为了统一而且可以直观地知道每个类别的可能性（另外也为了训练的准确性，这里不讲），正如前面讲到，我们最后输出的一个类别的概率，取值范围∈[0, 1]， 且所有输出的值和为`1`，所以在输出层后面对输出层的所有值进行处理，公式为 ![softmax](../../../../assets/dnn/softmax.jpg) 到此，从输入到输出的推理过程就结束了 ## 深度神经网络训练 前面简单介绍了深度神经网络的结构组成， 以及从输入层到输出层的正向过程，在我们使用模型时，就是这个正向过程。 那么，模型定好了，里面的参数（比如`w,b`）都是随机的值，怎么让它自动训练得到模型中参数的值呢？ 在前面我们讲到， 使用一些我们已知结果的数据输入，来得到参数，同样地，这里我们也输入已知结果的数据，得到第一次的输出结果 **判定输出正确性(accuracy)（或者说误差/loss）** 和 **损失函数**： 在输出层得出结果，比如得到了`[0.6, 0.4]` 代表是小球的概率`0.6`, 是玩具的概率`0.4`, 但是因为是已知答案的数据， 实际正确答案是`[1.0, 0.0]`, 这明显不符合要求。 所以我们得出正确答案和推算的答案的误差为： `[0.4, 0.4]`, 但是发现一个问题就是这个误差值的范围不太好看，要是误差的取值范围∈`[0, ∞]` 就好了。 在高中数学中有个函数`y log10(x)`, 坐标图如下： ![log10](../../../../assets/dnn/log10x.jpg) 发现`x`取值∈`[0, 1]`时， ` y`的取值刚好∈`[0, ∞]`， 而我们的输出结果也刚好∈`[0, 1]`！ 所以，我们直接这样计算误差： `error log10(输出)`， 也就是输出越接近`1`，误差就越接近 `0`，这种方法称之为`交叉熵损失（CEE, Cross Entropy Error)`， 除了这种方法还有其它的比如均方误差（MSE，Mean Squared Error）等 至此，我们知道了现在结果和实际结果的误差 **误差的反向传播** 和 **参数优化（权重更新）**： 因为模型的参数还不符合我们的预期， 那我们需要对参数进行修正，我们使用反向传播的方式。 前面我们得出了误差， 因为参数不够正确， 我们用这个误差去修改模型中的参数，来达到微调模型内参数的效果。 就好像你在开一个水龙头， 水大了（即误差大了），就把开关拧紧一点，小了就拧松一点，对其做调整。 就像我们正向推算一样，这次换成了反向，从后往前，可以得到在每个节点处的误差值，然后再根据一定的学习率去更新模型内参数。这里暂时就不仔细展开讲了。 总之，经过一轮反向的调整参数之后，得到了新的模型 **衡量模型好坏：训练集误差和验证集误差**： 我们使用训练数据集里面的数据反复去进行正向推理得出误差，然后反向调整这个过程，在使用完训练数据集后，可能会得到误差比较小，但是这只能说明这个模型对这批数据来说比较准确，换一些新的数据可能就不准确了，所以我们要用一些训练集里没有的数据去**验证**模型的效果： 我们使用 **验证数据集** 去正向推算，得到误差，因为验证数据集没有参与训练，也就是说现在模型的参数和验证数据集没有任何关系，我们用这个得到的误差来恒定这个模型的好坏，误差越小则认为效果越好 **多次迭代**： 如果将所有数据集训练完了，发现误差依然很大，那么可以用多次训练的方法来继续训练，即**多次迭代**，每次迭代完成后都用 验证数据集 去验证效果如何， 如果训练集的误差和验证集的误差都足够小，我们就可以暂且认为模型已经有不错的效果了。 **测试集**： 这时，我们就可以用又一批新的数据去测试我们的模型效果如何，因为这是全新的数据，没有参与到训练也没参与到验证（即确定什么时候停止训练），理论上更有公信力。如果测试误差较小，那么训练就算成功了 **优化训练**： 如果最终效果不太好， 有很多地方可以调整， 比如 * 训练迭代的次数，并不是越多越好，过多的在一批数据集上训练可能导致模型只对这批数据有效，泛化能力不够， 也就是**过度拟合** * 每次训练的学习率也可以调整 * 检查数据集，是否有一些影响分类的数据存在 * 优化网络结构，不管是输入输出还是内部结构和参数，根据不同的数据和任务可以有更优的设计，也叫**特征工程** ## 说在最后 到这里，应该大致上明白了以下东西： * 什么是机器学习 * 什么是深度神经网络 * 模型是什么 * 什么是输入层，输出层，在上面举例的分类应用中分别表示什么含义，层形状是什么样的 * 什么是训练，有什么作用 * 数据训练集，验证集，测试集分别是什么，用在什么地方，需要注意什么 * 衡量模型好坏的标准是什么 如果还不明白的，可以再仔细理解一遍，或者查阅相关资料，如果你发现有更好的阐述方法，欢迎按照左边目录的文档贡献方法参与贡献 ## 修改记录 日期 作者 备注 2020.11.17 [neucrack](https://neucrack.com) 初始版本，根据 MaixPy 的需要介绍深度神经网络基本概念，初稿 "},"/soft/maixpy/zh/course/ai/train/maixhub.html":{"title":"Maixhub 模型训练","content":" title: Maixhub 模型训练 keywords: 模型训练, 在线训练, AI模型, 模型库 desc: MaixHub 模型训练 目前 MaixHub 新版网站已上线，点此前往 [maixhub.com](http://maixhub.com) ，除了支持 k210 nncase 模型训练，更支持了更多平台和开发板，比如手机、电脑、V831、单片机等等。 并且大大改进了训练流程，支持在线标注，一键上传数据支持，更多训练参数可手动调整，以及一键部署到设备等功能，快来体验吧！ MaixHub 提供模型训练功能和模型分享功能， 只需要准备好需要训练的数据集， 不需要搭建训练环境和代码， 上传训练数据即可快速训练出模型，方便快速制作你的 AI 应用，或者入门学习 AI 训练的流程和原理。 另外你也可以在 MaixHub 模型库下载你喜欢的模型，甚至上传分享你自己制作的模型，不管是在 MaixHub 训练的，还是自己写代码训练的各种有意思的模型！"},"/soft/maixpy/zh/course/ai/train/local.html":{"title":"本地模型训练 for Linux","content":" title: 本地模型训练 for Linux keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy 本地模型训练 > 没有任何的开发基础请慎重使用，出现问题请自行解决！ windows10上使用本地训练教程看[这里](https://bbs.sipeed.com/thread/932) 本地模型训练使用 [sipeed/maix_train](https://github.com/sipeed/maix_train) 这份代码进行， 使用了 Tensorflow 作为训练框架 以下所有的训练使用的代码都是在linux下进行使用的，不是在windows下使用的！ 主要支持： * 物体分类模型（使用 Mobilenet V1）： 只识别图片中的物体是什么 * 物体检测模型（使用 YOLO V2）： 找到图片中认识的图体，并同时找到其坐标和大小 ## 系统环境 首先，需要一台有 Linux 系统的电脑 如果你的主力系统是 Windows， 你可以用以下系统环境： * 使用虚拟机, `virtual box` 或者 `vmware` 都可以， 系统推荐安装`Ubuntu20.04` * 或者安装双系统，安装方法请自行搜索学习，或者看[这个双系统安装教程](https://neucrack.com/p/330) 你可能想着在 `Windows` 下面进行开发， 但是这里强烈建议使用`Linux`而不是`Windows`： * 首先，大多数模型训练框架都是首先支持 `Linux`， 在`Linux`下面开发的难度会比`Windows`下开发更加容易 * 作为一个开发者， 学会使用`Linux`是基础技能，当然，除非你是`Windows`狂热粉， 那我相信你一定有把其它系统的软件移植到`Windows`的能力 * 对于windows环境的配置存在许多奇奇怪怪的现象，会出现无法使用GPU进行训练，只能使用CPU训练 ## 软件安装 训练可以使用 CPU 进行训练，但是速度比较慢， 如果使用专用的显卡（GPU）进行加速，速度会快非常多，个人一般使用`Nvidia`的显卡， 比如`RTX 3090`， 当然，使用普通的`GTX 1060 6G内存`版本就可以愉快使用了 初次接触，建议先使用 CPU 进行训练，环境安装会简单很多很多， 以下只讲 CPU 训练的方法， GPU 请自行学习 > GPU 使用可以参考 Tensorflow 官方 [GPU 使用教程](https://tensorflow.google.cn/install/gpu)， 如果你显卡驱动遇到了问题，可以参考[这里](https://neucrack.com/p/252)， 另外如果你用 [docker 安装](https://tensorflow.google.cn/install/docker)遇到了问题， 也可以看[这里](https://neucrack.com/p/116) 接下来的使用方法摘抄于仓库的 [README](https://github.com/sipeed/maix_train/blob/master/README.md), 如果有出入， 以仓库的`README`为准，注意分辨 * 将训练代码克隆到本地 ``` git clone https://github.com/sipeed/maix_train recursive ``` * 安装依赖 ``` cd maix_train pip3 install r requirements.txt ``` 中国用户可以使用阿里云或者清华的源， 下载速度更快 ``` pip3 install r requirements.txt i https://mirrors.aliyun.com/pypi/simple/ ``` * 下载 [nncase v0.1.0 rc5](https://github.com/kendryte/nncase/releases/tag/v0.1.0 rc5) 并解压到 `maix_train/tools/ncc/ncc_v0.1`, 保证可执行文件的路径是 `maix_train/tools/ncc/ncc_v0.1/ncc` * 配置工程 先初始化工程 ``` python3 train.py init ``` 然后根据你的硬件情况，编辑`maix_train/instance/config.py`配置 ## 准备数据集 准备数据集， 图片大小为 `224x224`， 格式可以参考`maix_train/datasets`下的数据集示例 ## 训练分类模型 ``` python3 train.py t classifier z datasets/test_classifier_datasets.zip train ``` 或者解压数据集到文件夹，指定数据集文件夹 ``` python3 train.py t classifier d datasets/test_classifier_datasets train ``` ## 训练目标检测模型 ``` python3 train.py t detector z datasets/test_detector_xml_format.zip train ``` ## 使用模型 和使用`Maixhub`训练的模型一样， 在`out`文件夹会生成一个`zip`文件，里面包含了结果，把**所有**文件拷贝到`SD`卡根目录，然后开发板上电运行即可"},"/soft/maixpy/zh/course/ai/train/local_windows_1.html":{"title":"本地训练 for windows","content":"# 本地训练 for windows > 没有任何的开发基础请慎重使用，出现问题请自行解决！ 这个教程有手就行，不需要虚拟机，请严格按照教程的步骤一步步来。 tensorflow gpu 2.3.0版本对于cuda版本有点严格，之前的教程出现了问题了，可以运行分类训练，但是对于检测训练可以训练，但是不能进行模型输出。现在已经解决了，cuda版本必须是10.1版本，cudnn是 10.1 V7.**版本，不然是不能使用GPU进行训练。 ## 安装python3.8 推荐安装python3.8，由于python3.9有一些不知名问题导致了环境可能会配置失败 [点击下载安装python3.8](https://www.python.org/ftp/python/3.8.10/python 3.8.10 amd64.exe)，双击打开python3.8安装包 安装之后的python，按win+r，输入cmd打开命令行，然后输入python+回车，出现下图则表示python安装成功 ![3.png](https://bbs.sipeed.com/storage/attachments/2021/07/21/VIkEq8iIkf0ae6WJRB7xVOatpIcNBBBjHVLu0DPX_thumb.png \"1456\") ## 安装pip 在python环境下安装各种包是可以通过使用pip来进行安装的，具体的安装方式[这里](https://www.cnblogs.com/littlehb/p/8886409.html) 可以通过 `pip list`来查看python上安装了的包 ## CUDA和CUDNN环境配置 对于模型的训练，可以使用CPU或者是GPU进行训练，本教程是针对GPU训练的环境配置的。 不同版本的CUDA有所对应不同的显卡驱动版本要求，可以参考[这里](https://docs.nvidia.com/cuda/cuda toolkit release notes/index.html)下载对应的显卡驱动版本 推荐使用CUDA10.1版本 > 必须是英伟达的显卡，如果是AMD的显卡或者电脑上没有英伟达的显卡，可以跳过这一步 ### 安装显卡驱动 点击[这里](https://www.nvidia.cn/Download/index.aspx?lang cn),选择你对应的显卡型号，下载对应的显卡驱动，然后打开文件夹，进行显卡驱动的安装。 可以通过右键的VNIDIA控制面版查看当前系统的显卡驱动版本 ### 安装CUDA 打开cuda10.1下载的[链接](https://developer.nvidia.com/cuda 10.1 download archive base)，选择对应的系统版本和下载方式 ![111.png](https://bbs.sipeed.com/storage/attachments/2021/07/21/qCvepuVTJVbL8DgDkHzD9b4L7GLXPBHcqXVX4YLR_thumb.png \"1457\") 点击Download进行下载，这个网页可能打开的比较慢，可以通过科学上网来打开。下载好的安装包，直接打开，然后一直点下一步就好了。 ### 安装CUDNN 对于CUDNN下载，这个可以自行百度，由于这个网页没有科学上网的情况下打开是比较慢的。 点击[这里](https://developer.nvidia.com/rdp/cudnn archive)进入到cudnn的下载官网，选择cudnn v7.6.5.32 for cuda 10.1的版本进行下载， ![2.png](https://bbs.sipeed.com/storage/attachments/2021/07/21/y7bzFvQanbwKTjypKgeMmJ1WWnjrn5KF0VVwBAZv_thumb.png \"1458\") 下载之后会得到一个cudnn 10.1 windows10 x64 v7.6.5.32.zip的压缩包，将其解压。解压的得到的文件三个文件![文件](https://bbs.sipeed.com/storage/attachments/2021/08/02/6s0BxoZQX1Bhii36KnKQccwxXot5XDIgI6xgoLyw_thumb.png \"1608\")，都复制到 **C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.1**文件下面。 这时CUDA的环境已经配置好了 ## tensorflow安装 对于tensorflow的安装，这是也是有要求的，需要安装tensorflow gpu 2.3.0版 win+r，输入cmd，打开命令行 在命令行中输入 pip install tensorflow gpu 2.3.0 如果使用这命令的时候提示 **'pip'不是内部或外部命令，也不是可运行的程序或批处理文件**，这说明了你电脑上没有安装pip，为什么不好好看我前面的写的安装pip？？？？？？？ 如果下载的很慢，请输入 pip install tensorflow gpu 2.3.0 i https://pypi.mirrors.ustc.edu.cn/simple 然后等待安装成功即可 ## MaixHub本地训练 配置了那么久的环境了，终于到最后一步了，[下载本地训练代码](https://github.com/sipeed/maix_train) 进入连接之后，可以通过git命令进行下载，或者是点击Download ZIP进行下载压缩包 ![3.png](https://bbs.sipeed.com/storage/attachments/2021/07/21/bGnesxEq2b4YxRIsyFZobK36kpk9Ip3GVoQohgd5_thumb.png \"1459\") 将压缩包解压，任何位置都都可以，只要你记得解压到哪里了。然后下载 [ncc win7 x86_64](https://github.com/kendryte/nncase/releases/tag/v0.1.0 rc5) 并解压，就会得到一个叫ncc win7 x86_64的文件夹，将这个文件夹名字修改为ncc_v0.1。 再将这个文件夹的复制到maix_train/tools/ncc文件夹下面。（如果没有ncc这个文件夹就创建一个，路径一定要对的上） ![maix_train_windows](./../../../../assets/get_started/maix_train_windows.gif) 不会科学上网的同学可能会下载很慢，我已经下载好，上传到[gitee](https://gitee.com/Rui_worker/maix_train)上了(里面也有ncc的文件了)。"},"/soft/maixpy/zh/course/ai/train/local_windows_2.html":{"title":"本地训练使用教程","content":"# 本地训练使用教程 > 没有任何的开发基础请慎重使用，出现问题请自行解决！ 配置好本地训练的环境之后，就可以开始进行本地训练了，如果没有配置好的，请看上一篇[教程](https://bbs.sipeed.com/thread/932) ## 安装依赖 打开解压后得到的文件夹，打开里面的 requirements.txt 文件，将里面的 tensorflow> 2.3.1 删除，保存关闭。 ![4.png](https://bbs.sipeed.com/storage/attachments/2021/07/21/2AZNFAWTnje3DQSuBplNRmJv3FXJO8rkAATuJdjf_thumb.png \"1460\") 在文件夹的这里输入cmd, 回车，进入命令行界面 ![5.png](https://bbs.sipeed.com/storage/attachments/2021/07/21/hkzdghzlqlnZBTbcES61V7p15EnCKnYJNpPZ8tgJ_thumb.png \"1463\") 输入 pip install r requirements.txt 如果下载速度很慢的话，可以使用中科大源来进行下载 pip install r requirements.txt i https://mirrors.aliyun.com/pypi/simple/ 等待全部包的安装结束就可以了 ## 数据集的制作 对于数据集的制作，请严格按照 Maixhub 上的数据集[制作要求](https://www.maixhub.com/ModelTrainingHelp_zh.html)来进行。如果是分类训练可以不用进行压缩，但是要按压缩包的文件层级要求来将文件放到文件夹中 注意：对于压缩包中的文件夹名字和层级数一定要和要求中的一摸一样！一摸一样！不然会出现数据集读取不到等的一些奇奇怪怪的错误，导致训练不能开始。 ## 开始训练 先进行初始化 python train.py init 开始训练之前，我们需要将自己本地训练的参数进行修改，在instance/config.py中进行修改对应的参数，否则就会出现错误，再进行训练 将数据集放到本地训练源码中的datasets文件夹中，然后在有train.py文件层级上启动命令行界面，和安装依赖的时的启动方法一样。 > 小白不知道怎么改的可以不用去修改 ![5.png](https://bbs.sipeed.com/storage/attachments/2021/07/21/CkW1EwXQiKCLsouz5mPJzhVK6S6zn1vcxH1ZcQTA_thumb.png \"1461\") 分类训练输入 python train.py t classifier z datasets/test_classifier_datasets.zip train 如果是没有压缩的文件夹，则输入 python train.py t classifier d datasets/test_classifier_datasets train > 这里输入的命令中，在datasets/后面加的是你自己的所制作的数据集名字，不要上来就直接将复制命令运行。 目标检测输入 python train.py t detector z datasets/test_detector_xml_format.zip train > 这里输入的命令中，在datasets/后面加的是你自己的所制作的数据集名字，不要上来就直接将复制命令运行。 训练完之后就会得到一个out的文件夹，里面的文件就是训练之后得到的模型 ## 常见问题 ### 训练过程中判断是否使用 GPU 1. 启动训练的查看是否出现答应出这些信息，并都是和下图框出来的一样的 ![6.png](./../../../../assets/AI/GPU.png) 如果没有，则说明你的前面的cuda和cudnn环境没有安装好，请将所有关于英伟达的软件驱动进行卸载，是卸载！！！不是将文件删除。然后再重新进行cuda和cudnn的环境配置。 2. 在任务管理器中查看，GPU 的显存有没有被使用到，而不是看显卡的利用率 3. 训练刚开始出现的 no GPU，will use CPU 只是一个提示信息而已，并不是没有使用到 ### 训练中出现Internal: no kernel image is available for execution on the device 环境需要重新安装，tensorflow安装版本没有对上 ### 出现failed: TrainFailReason.ERROR_PARAM, datasets not valid: datasets format error: datasets error, not support format, please check 这种就是没有严格的安装数据集要求来进行制作，检查你的文件夹名字，就可以解决的了，特别是images这个文件夹，容易少了个s ## 出现报错之后，先自己将报错信息进行查看，看不懂可以翻译，不要报错了就直接问，自己都先排查一次"},"/soft/maixpy/zh/course/ai/image/1000_type_classifier.html":{"title":"1000 种物体分类模型","content":" title: 1000 种物体分类模型 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy 1000 种物体分类模型 可以识别 1000 种物体 ## 使用方法 * 使用`minimum` 版本固件 * [下载模型文件](https://dl.sipeed.com/fileList/MAIX/MaixPy/model/mobilenet_0x300000.kfpkg) * 使用 `kflash_gui` 烧录模型文件到 `Flash`, 这个模型文件回自动烧录到地址0x300000上，不需要手动选择地址 * 保存文件[labels.txt](https://github.com/sipeed/MaixPy v1_scripts/tree/master/machine_vision/mobilenet_1000_class/labels.txt) ([备用链接](https://en.bbs.sipeed.com/uploads/default/original/1X/d41ad9dfbe01f228abe726986fbf1baf4e288f2e.zip)) 到文件系统，具体方法见入门教程（发挥你的聪明才智）（参考答案：因为内容太多，如果使用 REPL 直接复制粘贴可能数据会出错， 所以要使用 工具传输。最简单的是放到 SD 卡； 如果要放到 `/flash`，minimum 可能不支持 IDE， 可以使用`upyloader`发送文件） * 因为这个模型有`4.2MiB`，比较大，所以使用了`minimum`的固件，同时保证`GC`使用的内存不要太大，可以通过以下方式设置小一点,把内存留给模型使用 ```python from Maix import utils import machine utils.gc_heap_size(256*1024) machine.reset() ``` * 导入模型 ```python import KPU as kpu task kpu.load(0x300000) ``` * 读入 labels ```python f open('/sd/labels.txt','r') labels f.readlines() f.close() ``` * 初始化摄像头, LCD 可以根据自己的硬件安装情况设置摄像头是否镜像，以及 LCD 是否旋转等 略，请参考前面的教程 * 识别物体 ```python fmap kpu.forward(task, img) plist fmap[:] pmax max(plist) max_index plist.index(pmax) ``` 这里把运行的结果转换成了一个`list`对象， 然后找到了最大值的下标， 通过这个下标我们就知道标签名是什么了（`labels[max_index]`） * 显示结果 ```python img img.draw_string(0, 0, \"%.2f : %s\" %(pmax, labels[max_index].strip()), color (255, 0, 0)) lcd.display(img, oft (0,0)) print(fps) ``` 完整例程看 [maixpy_scripts](https://github.com/sipeed/MaixPy v1_scripts/tree/master/machine_vision/mobilenet_1000_class)"},"/soft/maixpy/zh/course/ai/image/face_detect.html":{"title":"人脸检测","content":" title: 人脸检测 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy 人脸检测 在一张图片中找出人脸， 并且框出人脸，即知道脸的位置和大小 使用了`YOLO V2`模型对人脸进行检测 ## 使用方法： * 下载模型： 到[这里](https://dl.sipeed.com/MAIX/MaixPy/model) 下载 `face_model_at_0x300000.kfpkg` 这个模型文件 * 用 kflash_gui 下载模型到 Flash， 或者放到 SD 卡中 * 加载模型 ```python task kpu.load(0x300000) # task kpu.load(\"/sd/face.kmodel\") anchor (1.889, 2.5245, 2.9465, 3.94056, 3.99987, 5.3658, 5.155437, 6.92275, 6.718375, 9.01025) kpu.init_yolo2(task, 0.5, 0.3, 5, anchor) ``` 因为使用了`YOLO V2`这个模型， 它有专用的函数接口， 使用`init_yolo2`来初始化模型 参数分别为： * `kpu_net`: kpu 网络对象, 即加载的模型对象, `KPU.load()`的返回值 * `threshold`: 概率阈值， 只有是这个物体的概率大于这个值才会输出结果， 取值范围：[0, 1] * `nms_value`: box_iou 门限, 为了防止同一个物体被框出多个框，当在同一个物体上框出了两个框，这两个框的交叉区域占两个框总占用面积的比例 如果小于这个值时， 就取其中概率最大的一个框 * `anchor_num`: anchor 的锚点数， 这里固定为 `len(anchors)//2` * `anchor`: 锚点参数与模型参数一致，同一个模型这个参数是固定的，和模型绑定的（训练模型时即确定了）， 不能改成其它值。 然后输入图片数据，运行模型 ```python code kpu.run_yolo2(task, img) ``` 得到结果， 完整例程看[这里](https://github.com/sipeed/MaixPy v1_scripts/blob/master/machine_vision/face_find/demo_find_face.py) API 文档看 [Maix.KPU](./../../../api_reference/Maix/kpu.html)"},"/soft/maixpy/zh/course/ai/image/face_recognization.html":{"title":"人脸识别","content":" title: 人脸识别 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy 人脸识别 除了检测到人脸的位置以外， 还可以识别到这个人是谁（需要先对准人按按钮学习） 效果视频： [youtube](https://www.youtube.com/embed/hS_mcGptXeo) 或者 [bilibili](https://www.bilibili.com/video/BV1bJ411Q7L6) <iframe src \"https://player.bilibili.com/player.html?aid 77466790&bvid BV1bJ411Q7L6&cid 132521878&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\" width 500 height 400> </iframe> ## 使用方法 * 从 [MaixHub](https://www.maixhub.com) 按照说明下载模型， 获得模型`smodel`, 就是 加密版本的`kmodel` * 按照入门教程的方法下载模型到开发板 * 运行脚本 [script](https://github.com/sipeed/MaixPy v1_scripts/blob/master/machine_vision/face_recognization/demo_face_recognization.py) ## 程序理解 总共用了三个模型， 分别是： * 人脸检测模型， 这和前面的人脸检测使用的是同一个模型， 即找到人脸 * 人脸关键点检测模型，从前面找到的人脸中找到人脸的 眼睛 鼻子 和 嘴巴 的位置 * 人脸特征提取模型， 从一张人脸图片中得出一个特征值 步骤如下： * 检测到人脸 * 裁出人脸，找到人脸的眼睛鼻子嘴巴， 这里裁成了`128x128`的图 * 把人脸图中的脸旋转到标准位置 * 用特征提取模型提取出人脸的特征值 有了前面的基础， 这里的程序就能看懂了，也就不再进行详细的阐述了，只不过是从之前的使用一个模型，变成了按照顺序分别使用三个模型，再加上一点简单的图像裁减和旋转处理，都是调用`API`，仔细看一遍代码就知道具体的细节是如何实现的了"},"/soft/maixpy/zh/course/ai/image/self_learn_classifier.html":{"title":"自学习分类器（self learning classifier）","content":" title: 自学习分类器（self learning classifier） keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy 自学习分类器（self learning classifier） 无需单独训练， 直接在开发板上对物体特征进行学习，然后直接使用 演示视频： [youtube](https://www.youtube.com/watch?v aLW1YQrT 2A) 或者 [bilibili](https://www.bilibili.com/video/BV1Ck4y1d7tx) ## 使用方法 * [在这里](https://dl.sipeed.com/shareURL/MAIX/MaixPy/release/master) 下载版本 > v0.5.0 33 的固件 * [下载 kmodel](https://maixhub.com/model/zoo/61) * 使用 [kflash_gui](https://github.com/sipeed/kflash_gui) 下载固件和模型 * 运行 [示例脚本](https://github.com/sipeed/MaixPy v1_scripts/blob/master/machine_vision/self_learning_classifier/self_learning_classifier.py) > 如果使用 lite 版本的 kmodel, 应该在创建 classifier 的时候传入 `fea_len` 参数为`512`，使用另外一个大一点的（1.8MiB）模型的时候则不需要这个参数: ```python classifier kpu.classifier(model, class_num, sample_num, fea_len 512) ``` 然后运行启动后开始学习物体 * 按开发板上的 `boot 按钮` 来捕获 3 个类别 `手机`, `小车`, `键盘`， 每个类别只需要捕获一次 * 然后捕获 15 张图， 对顺序没有要求， 比如捕获 5 张 `手机`, 5 张 `小车` ， 5 张 `键盘` 的图片 * 然后它会自动学习这 15 张图的特征 * 最后识别到的图像类别会展示在左上角 ## 保存/加载学习好的特征 * 使用 `classifier.save(path)` 来保存学习好的特征到`path`文件 * 使用 `KPU.classifier.load()` 来加载特征, 参考 [self_learning_classifier_load.py](https://github.com/sipeed/MaixPy v1_scripts/blob/master/machine_vision/self_learning_classifier/self_learning_classifier_load.py) 文件"},"/soft/maixpy/zh/course/speech/fft_waterfall.html":{"title":"FFT 瀑布图(雨图)","content":" title: FFT 瀑布图(雨图) keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy FFT 瀑布图(雨图) FFT 瀑布图即为数据随时间变化的频率分布图，下面将介绍如何使用 MaixPy 绘制瀑布图。 ## 绘制方法 * 准备时域信号（例如音频数据） ```python rx I2S(I2S.DEVICE_0) rx.channel_config(rx.CHANNEL_0, rx.RECEIVER, align_mode I2S.STANDARD_MODE) rx.set_sample_rate(sample_rate) audio rx.record(sample_points) ``` * 进行FFT运算（将数据进行 FFT 运算并获取其频率分布情况） ```python fft_points 512 fft_res FFT.run(audio.to_bytes(),fft_points) fft_amp FFT.amplitude(fft_res) ``` * 绘制在 image （由于 FFT 结果的对称性，只需要绘制其中一部分即可） ```python hist_x_num 128 img image.Image(size (128,128)) for i in range(hist_x_num): img[i] fft_amp[i] ``` *详细API参考[I2S API](../../api_reference/Maix/i2s.html), [FFT API](../../api_reference/Maix/fft.html)* ## 例程 > 以下例程在固件v0.5.1 MaixDock 测试通过 实时采集音频数据并绘制为 FFT 瀑布图 [demo_fft_waterfall.py](https://github.com/sipeed/MaixPy v1_scripts/blob/master/hardware/demo_fft_waterfall.py) 效果： ![](../../../assets/course/fft_waterfall.gif)"},"/soft/maixpy/zh/course/speech/recognizer_mfcc.html":{"title":"isolated word","content":" title: isolated word keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy isolated word > **本文档在 MaixPy 0.5.1_128 minimum_speech_with_ide_support 固件测试通过，使用前请确保硬件录音功能可用。** 这是一个孤立词识别的算法模块,用户通过录音生成词汇模板加载到模块中，再通过它识别到用户加载的词汇模板，并返回匹配的可能性，实现请参考[基于STM32的孤立词语音识别](https://gk969.com/stm32 speech recognition/)。 孤立词识别 按照语音发音方式来分，有孤立词识别、连接词识别、连续语音识别 3 种；所谓孤立词识别（Isolated Word Recognition）是指在发待识别音时，每次只含词汇表中的一个词条。 词汇模板 我们将一段用人声说出的词汇录音下来，通过算法制作成可识别的模板，称为词汇模板。 模板匹配 假设算法模块加载了词汇模板，我们通过录音输入数据给算法模块后，它会进行内部匹配得到最有可能的识别结果。 > 本模块具体识别流程是：预滤波、ADC、分帧、端点检测、预加重、加窗、特征提取、特征匹配。端点检测(VAD)采用短时幅度和短时过零率相结合。检测出有效语音后，根据人耳听觉感知特性，计算每帧语音的Mel频率倒谱系数(MFCC)。然后采用动态时间弯折(DTW)算法与特征模板相匹配，最终输出识别结果。 ## 如何使用？ 目前硬件支持程度：Maix BIT / DOCK / DUINO / GO 。 > 截至 20201123 由于 Cube & Amigo 经过 ES8374 后，麦克风底噪过大会被判断为噪音环境，还需要修复。 ### 开箱即用示例代码 使用 maixduino / maixbit 的测试用例 [isolated_word.py](https://github.com/sipeed/MaixPy v1_scripts/blob/master/multimedia/speech_recognizer/isolated_word.py)，使用方法请阅读代码，请注意硬件的 麦克风 配置 和 声道 配置。 Maix DOCK 可直接使用的示例代码[demo_isolated_word_on_maixdock.py](https://github.com/sipeed/MaixPy v1_scripts/blob/master/multimedia/speech_recognizer/demo_isolated_word_on_maixdock.py)，按屏幕提示说话即可，具体看[测试录像](https://www.bilibili.com/video/BV1oz4y1C7yE?from search&seid 17464946072274851468)。 ### 模块调用流程 为了能够更好地使用本模块，请了解使用流程。 #### 准备 I2S 录音模块 配置一个 I2S.DEVICE_0 设备，并设置 CHANNEL_0 通道到录音输入。 ```python from Maix import GPIO, I2S from fpioa_manager import fm fm.register(20,fm.fpioa.I2S0_IN_D0, force True) fm.register(18,fm.fpioa.I2S0_SCLK, force True) # dock 32 fm.register(19,fm.fpioa.I2S0_WS, force True) # dock 30 rx I2S(I2S.DEVICE_0) rx.channel_config(rx.CHANNEL_0, rx.RECEIVER, align_mode I2S.STANDARD_MODE) rx.set_sample_rate(16000) print(rx) ``` 运行结果： ```shell [MAIXPY]i2s0:(sampling rate 16003, sampling points 1024) [MAIXPY]channle0:(resolution 2, cycles 2, align_mode 1, mode 1) [MAIXPY]channle1:(resolution 0, cycles 0, align_mode 0, mode 0) [MAIXPY]channle2:(resolution 0, cycles 0, align_mode 0, mode 0) [MAIXPY]channle3:(resolution 0, cycles 0, align_mode 0, mode 0) ``` #### 创建 孤立词 模块 isolated_word 初始化的参数如下： [dmac] 录音所使用的 DMA 通道，默认使用【通道 2】。 [i2s] 录音设备，默认使用 I2S.DEVICE_0 。 [size] 词汇模板容量，表示可以加载的模板总数，默认为 10 个。 [shift] 声道选择，Maix 系列的硬件录音设备通常为单声道输入，设置 0 为左声道，所以 1 为右声道。 ```python from speech_recognizer import isolated_word # default: maix dock / maix duino set shift 0 sr isolated_word(dmac 2, i2s I2S.DEVICE_0, size 10, shift 0) # maix bit set shift 1 print(sr.size()) print(sr) ## threshold sr.set_threshold(0, 0, 10000) ``` 运行结果如下： ```shell 10 [MAIXPY] isolated_word:(80212a60) mfcc_dats 8023a060 size 10 i2s_device_number_t 0 dmac_channel_number_t 2 ``` #### 录入词汇模板 调用如下代码： 如果周围环境很嘈杂，它就会反复输出 2 (isolated_word.Ready) 到 3 (isolated_word.MaybeNoise) ，需要处于安静环境下才能录入词汇模板 如果状态为 isolated_word.Speak 则表示你可以说话了 如果运行 sr.record(0) 它状态变成了 isolated_word.Done 则表示录入完成，并保存到编号 0 的模板。 你可以通过 sr.state() 可以查看当前模块的状态 ```python ## record and get & set while True: time.sleep_ms(100) print(sr.state()) if sr.Done sr.record(0): data sr.get(0) print(data) break if sr.Speak sr.state(): print('speak A') #sr.set(1, data) ``` 同理，如果你要录入第二个【词汇模板】，只需要改变录入的位置，如改成 sr.record(1)（计算机存储数组从 0 开始计数）。 #### 识别词汇模板 假设你已经录入了【词汇模板】则调用如下代码，它会持续识别当前的声音开始匹配录入的【词汇模板】，也就是所谓的孤立词语音识别。 ```python print('recognizer') while True: time.sleep_ms(200) #print(sr.state()) #print(sr.dtw(data)) if sr.Done sr.recognize(): res sr.result() print(res) ``` 最终呈现的效果就是打印出最优匹配的【词汇模板】编号以及相关数据，具体请查看 result 函数用法，可以根据实际情况来判断本次识别是否合理，如匹配的帧长/匹配度是否符合预期，过大或过小都是不合理的。"},"/soft/maixpy/zh/course/speech/fft.html":{"title":"FFT 信号处理","content":" title: FFT 信号处理 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy FFT 信号处理 FFT 即快速傅里叶变换（Fast Fourier Transform），将时域信号转化为频域信号，应用范围非常广，例如消除音频图像噪声。 ## 使用方法 k210 带有硬件 FFT 模块，支持 64 点、 128 点、 256 点以及 512 点的 FFT。 * 导入 FFT 模块 ```python import FFT ``` * 输入时域数据（例如音频数据）并进行 FFT 运算 ```python res FFT.run(data, points, shift) ``` 相关 API 解释请参考[FFT API](../../api_reference/Maix/fft.html) ## 例程 采集声音并进行 FFT 运算，将运算后的数据在屏幕上显示为柱状图: [demo_fft_spectrum](https://github.com/sipeed/MaixPy v1_scripts/blob/master/hardware/demo_fft_spectrum.py) 效果： <iframe width \"600\" height \"350\" src \"//player.bilibili.com/player.html?aid 44617696&cid 78104545&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\"> </iframe>"},"/soft/maixpy/zh/course/speech/recognizer_cnn.html":{"title":"maix asr（自动语音识别）","content":" title: maix asr（自动语音识别） keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy maix asr（自动语音识别） > **本文档在 MaixPy 0.5.1_128 minimum_speech_with_ide_support 固件测试通过，使用前请确保录音功能/调用模型可用。** 这是一个基于声学模型的语音识别模块，用户设置拼音组成的词汇加载到模块中，就可以开始录音识别用户输入的词汇，并返回可能匹配的词汇列表。 > 2021年02月01日最近收到一些反馈，确认有个别同学在 IDE 的下运行不出结果，这时请切换到菜单》终端中运行才可以看到结果。 ## 使用方法 **警告** 不会【使用录音】和【调用模型】的同学，请先去学习前置技能再来使用本篇文档。 烧录声学模型 > TODO 之后存放到下载站统一链接。 从这里获取声学模型[maix_asr_2900k_0x500000](https://github.com/sipeed/MaixPy v1_scripts/blob/master/multimedia/speech_recognizer/maix_asr_2900k_0x500000.kmodel), 烧录到 0x500000 地址即可。 > 没有烧模型就加载模块会 core dump ，不要跑来问怎么报错了。 创建录音设备 本模块支持所有 Maix 系列硬件使用，我们只需要配置一个 I2S.DEVICE_0 设备，并设置 CHANNEL_0 通道到录音输入就可以了，如果是 Cube 和 amigo 则需要先配置具体的音频解码芯片，再打开 I2C 录音设备。 ```python from Maix import GPIO, I2S from fpioa_manager import fm fm.register(20,fm.fpioa.I2S0_IN_D0, force True) fm.register(18,fm.fpioa.I2S0_SCLK, force True) # dock 32 fm.register(19,fm.fpioa.I2S0_WS, force True) # dock 30 rx I2S(I2S.DEVICE_0) rx.channel_config(rx.CHANNEL_0, rx.RECEIVER, align_mode I2S.STANDARD_MODE) rx.set_sample_rate(16000) print(rx) ``` 创建 maix_asr 的辅助类，可以跳过不看。 ```python from speech_recognizer import asr class maix_asr(asr): asr_vocab [\"lv\", \"shi\", \"yang\", \"chun\", \"yan\", \"jing\", \"da\", \"kuai\", \"wen\", \"zhang\", \"de\", \"di\", \"se\", \"si\", \"yue\", \"lin\", \"luan\", \"geng\", \"xian\", \"huo\", \"xiu\", \"mei\", \"yi\", \"ang\", \"ran\", \"ta\", \"jin\", \"ping\", \"yao\", \"bu\", \"li\", \"liang\", \"zai\", \"yong\", \"dao\", \"shang\", \"xia\", \"fan\", \"teng\", \"dong\", \"she\", \"xing\", \"zhuang\", \"ru\", \"hai\", \"tun\", \"zhi\", \"tou\", \"you\", \"ling\", \"pao\", \"hao\", \"le\", \"zha\", \"zen\", \"me\", \"zheng\", \"cai\", \"ya\", \"shu\", \"tuo\", \"qu\", \"fu\", \"guang\", \"bang\", \"zi\", \"chong\", \"shui\", \"cuan\", \"ke\", \"shei\", \"wan\", \"hou\", \"zhao\", \"jian\", \"zuo\", \"cu\", \"hei\", \"yu\", \"ce\", \"ming\", \"dui\", \"cheng\", \"men\", \"wo\", \"bei\", \"dai\", \"zhe\", \"hu\", \"jiao\", \"pang\", \"ji\", \"lao\", \"nong\", \"kang\", \"yuan\", \"chao\", \"hui\", \"xiang\", \"bing\", \"qi\", \"chang\", \"nian\", \"jia\", \"tu\", \"bi\", \"pin\", \"xi\", \"zou\", \"chu\", \"cun\", \"wang\", \"na\", \"ge\", \"an\", \"ning\", \"tian\", \"xiao\", \"zhong\", \"shen\", \"nan\", \"er\", \"ri\", \"zhu\", \"xin\", \"wai\", \"luo\", \"gang\", \"qing\", \"xun\", \"te\", \"cong\", \"gan\", \"lai\", \"he\", \"dan\", \"wei\", \"die\", \"kai\", \"ci\", \"gu\", \"neng\", \"ba\", \"bao\", \"xue\", \"shuai\", \"dou\", \"cao\", \"mao\", \"bo\", \"zhou\", \"lie\", \"qie\", \"ju\", \"chuan\", \"guo\", \"lan\", \"ni\", \"tang\", \"ban\", \"su\", \"quan\", \"huan\", \"ying\", \"a\", \"min\", \"meng\", \"wu\", \"tai\", \"hua\", \"xie\", \"pai\", \"huang\", \"gua\", \"jiang\", \"pian\", \"ma\", \"jie\", \"wa\", \"san\", \"ka\", \"zong\", \"nv\", \"gao\", \"ye\", \"biao\", \"bie\", \"zui\", \"ren\", \"jun\", \"duo\", \"ze\", \"tan\", \"mu\", \"gui\", \"qiu\", \"bai\", \"sang\", \"jiu\", \"yin\", \"huai\", \"rang\", \"zan\", \"shuo\", \"sha\", \"ben\", \"yun\", \"la\", \"cuo\", \"hang\", \"ha\", \"tuan\", \"gong\", \"shan\", \"ai\", \"kou\", \"zhen\", \"qiong\", \"ding\", \"dang\", \"que\", \"weng\", \"qian\", \"feng\", \"jue\", \"zhuan\", \"ceng\", \"zu\", \"bian\", \"nei\", \"sheng\", \"chan\", \"zao\", \"fang\", \"qin\", \"e\", \"lian\", \"fa\", \"lu\", \"sun\", \"xu\", \"deng\", \"guan\", \"shou\", \"mo\", \"zhan\", \"po\", \"pi\", \"gun\", \"shuang\", \"qiang\", \"kao\", \"hong\", \"kan\", \"dian\", \"kong\", \"pei\", \"tong\", \"ting\", \"zang\", \"kuang\", \"reng\", \"ti\", \"pan\", \"heng\", \"chi\", \"lun\", \"kun\", \"han\", \"lei\", \"zuan\", \"man\", \"sen\", \"duan\", \"leng\", \"sui\", \"gai\", \"ga\", \"fou\", \"kuo\", \"ou\", \"suo\", \"sou\", \"nu\", \"du\", \"mian\", \"chou\", \"hen\", \"kua\", \"shao\", \"rou\", \"xuan\", \"can\", \"sai\", \"dun\", \"niao\", \"chui\", \"chen\", \"hun\", \"peng\", \"fen\", \"cang\", \"gen\", \"shua\", \"chuo\", \"shun\", \"cha\", \"gou\", \"mai\", \"liu\", \"diao\", \"tao\", \"niu\", \"mi\", \"chai\", \"long\", \"guai\", \"xiong\", \"mou\", \"rong\", \"ku\", \"song\", \"che\", \"sao\", \"piao\", \"pu\", \"tui\", \"lang\", \"chuang\", \"keng\", \"liao\", \"miao\", \"zhui\", \"nai\", \"lou\", \"bin\", \"juan\", \"zhua\", \"run\", \"zeng\", \"ao\", \"re\", \"pa\", \"qun\", \"lia\", \"cou\", \"tie\", \"zhai\", \"kuan\", \"kui\", \"cui\", \"mie\", \"fei\", \"tiao\", \"nuo\", \"gei\", \"ca\", \"zhun\", \"nie\", \"mang\", \"zhuo\", \"pen\", \"zun\", \"niang\", \"suan\", \"nao\", \"ruan\", \"qiao\", \"fo\", \"rui\", \"rao\", \"ruo\", \"zei\", \"en\", \"za\", \"diu\", \"nve\", \"sa\", \"nin\", \"shai\", \"nen\", \"ken\", \"chuai\", \"shuan\", \"beng\", \"ne\", \"lve\", \"qia\", \"jiong\", \"pie\", \"seng\", \"nuan\", \"nang\", \"miu\", \"pou\", \"cen\", \"dia\", \"o\", \"zhuai\", \"yo\", \"dei\", \"n\", \"ei\", \"nou\", \"bia\", \"eng\", \"den\", \"_\"] def get_asr_list(string 'xiao ai fas tong xue'): return [__class__.asr_vocab.index(t) for t in string.split(' ') if t in __class__.asr_vocab] def get_asr_string(listobj [117, 214, 257, 144]): return ' '.join([__class__.asr_vocab[t] for t in listobj if t < len(__class__.asr_vocab)]) def unit_test(): print(__class__.get_asr_list('xiao ai')) print(__class__.get_asr_string(__class__.get_asr_list('xiao ai fas tong xue'))) def config(self, sets): self.set([(sets[key], __class__.get_asr_list(key)) for key in sets]) def recognize(self): res self.result() # print(tmp) if res ! None: sets {} for tmp in res: sets[__class__.get_asr_string(tmp[1])] tmp[0] #print(tmp[0], get_asr_string(tmp[1])) return sets return None from machine import Timer def on_timer(timer): #print(\"time up:\",timer) #print(\"param:\",timer.callback_arg()) timer.callback_arg().state() try: # default: maix dock / maix duino set shift 0 t maix_asr(0x500000, I2S.DEVICE_0, 3, shift 0) # maix bit set shift 1 tim Timer(Timer.TIMER0, Timer.CHANNEL0, mode Timer.MODE_PERIODIC, period 64, callback on_timer, arg t) tim.start() #for i in range(50): #time.sleep_ms(100) #t.stop() #for i in range(50): #time.sleep_ms(100) #t.run() t.config({ 'xiao ai ya' : 0.3, 'hao de ya' : 0.2, 'ni hao ya' : 0.3, }) print(t.get()) while True: #time.sleep(1) tmp t.recognize() # print(tmp) if tmp ! None: print(tmp) except Exception as e: print(e) finally: tim.stop() t.__del__() del t ``` 对麦克风说话 我们可以看到代码中定义了以下词汇： ```python t.config({ 'xiao ai' : 0.3, 'hao de' : 0.2, 'ni hao' : 0.3, }) print(t.get()) ``` 也就是你对着麦克风在 6 秒内，说【你 好】、【好 的】、【小 爱】就可以完成识别了，配置项为两个字段，第一个字段长度不超过六组拼音，第二个字段表示识别的最低门限（匹配的阈值），高于该值就打印，低于该值就丢弃。 最开始测试的时候，说话可以大声一点，具体效果看[演示视频](https://www.bilibili.com/video/BV1C5411L7JC/), 完整示例: [test_maix_asr.py](https://github.com/sipeed/MaixPy v1_scripts/blob/master/multimedia/speech_recognizer/test_maix_asr.py)"},"/soft/maixpy/zh/course/media/video.html":{"title":"video（视频） 的使用","content":" title: video（视频） 的使用 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy video（视频） 的使用 详细 API 参考：[video API](./../../api_reference/media/video.html) ## 使用方法 > MaixAmigo, MaixCube在使用音频前需要[初始化 ES8374 音频解码芯片](https://github.com/sipeed/MaixPy v1_scripts/blob/master/modules/others/es8374/es8374.py) * 创建 video 对象，设置音量 ```python import video v video.open(\"/sd/badapple.avi\") v.volume(50) ``` * 初始化 lcd，用于播放画面 ```python import lcd lcd.init() ``` * 创建 I2S，用于处理音频对象 ```python from Maix import GPIO, I2S i2s I2S(I2S.DEVICE_0) i2s.channel_config(i2s.CHANNEL_1, I2S.TRANSMITTER, resolution I2S.RESOLUTION_16_BIT, cycles I2S.SCLK_CYCLES_32, align_mode I2S.RIGHT_JUSTIFYING_MODE) fm.register(34, fm.fpioa.I2S0_OUT_D1, force True) fm.register(35, fm.fpioa.I2S0_SCLK, force True) fm.register(33, fm.fpioa.I2S0_WS, force True) ``` * 播放视频 ```python while True: if v.play() 0: print(\"play end\") break ``` * 回收对象 ```python v.__del__() ``` ## 例程 > 测试用例中 avi 文件地址：[badapple.avi](https://api.dl.sipeed.com/shareURL/MAIX/MaixPy/assets) * 播放 avi 文件：[video_play](https://github.com/sipeed/MaixPy v1_scripts/blob/master/multimedia/video/demo_video_play.py) * 使用摄像头录制视频为 avi 文件并保存：[record_video](https://github.com/sipeed/MaixPy v1_scripts/blob/master/multimedia/video/demo_video_record.py) * 顺序捕获 avi 视频每个画面并显示：[video_capture](https://github.com/sipeed/MaixPy v1_scripts/blob/master/multimedia/video/demo_video_capture.py) * amigo 播放 avi 文件：[amigo_play_video](https://github.com/sipeed/MaixPy v1_scripts/blob/master/multimedia/video/amigo_play_video.py)"},"/soft/maixpy/zh/course/media/audio.html":{"title":"audio（音频） 的使用","content":" title: audio（音频） 的使用 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy audio（音频） 的使用 详细 API 参考：[audio API](./../../api_reference/media/audio.html) ## 使用方法 > MaixAmigo, MaixCube 在使用音频前需要[初始化 ES8374 音频解码芯片](https://github.com/sipeed/MaixPy v1_scripts/blob/master/modules/others/es8374/es8374.py) * 创建 audio 对象 ```python import audio player audio.Audio(path \"/sd/6.wav\") ``` * 创建 I2S 对象（用于处理音频对象） ```python from Maix import I2S # init i2s(i2s0) wav_dev I2S(I2S.DEVICE_0) # config i2s according to audio info wav_dev.channel_config(wav_dev.CHANNEL_1, I2S.TRANSMITTER,resolution I2S.RESOLUTION_16_BIT ,cycles I2S.SCLK_CYCLES_32, align_mode I2S.RIGHT_JUSTIFYING_MODE) ``` * 获取 audio 对象信息并关联 I2S 对象 ```python # read audio info wav_info player.play_process(wav_dev) print(\"wav file head information: \", wav_info) ``` * 根据 audio 信息配置 I2S 对象 ```python sample_rate wav_info[1] wav_dev.set_sample_rate(sample_rate) ``` * 使用已关联的 I2S 对象播放音频 ```python # loop to play audio while True: ret player.play() if ret None: print(\"format error\") break elif ret 0: print(\"end\") break ``` * 结束播放 ```python player.finish() ``` ## 例程 > 测试音频地址：[6.wav](https://github.com/sipeed/MaixPy v1_scripts/blob/master/multimedia/audio/6.wav) * 播放 wav 文件：[play_wav](https://github.com/sipeed/MaixPy v1_scripts/blob/master/multimedia/audio/play_wav.py) * 录制音频为 wav 文件并保存：[record_wav](https://github.com/sipeed/MaixPy v1_scripts/blob/master/multimedia/audio/record_wav.py)"},"/soft/maixpy/zh/course/network/network_config.html":{"title":"如何给 MaixPy 连接网络","content":" title: 如何给 MaixPy 连接网络 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy 如何给 MaixPy 连接网络 > 大佬鼠 2020 11 26 编辑 既然叫 AIOT 自然不能少了联网， MaixPy 现在支持 W5X00 / EPS32 / ESPAT 等联网的方法，如下所示。 ESP32 需要搭配[专用的 SPI 固件](https://github.com/sipeed/Maixduino_esp32_fimware)，支持 TCP / UDP 客户端。 ESPAT 配合乐鑫[AT 固件（esp at）](https://github.com/espressif/esp at)，只支持 TCP 客户端。 W5X00 接上网线就可以配置+使用了，支持 TCP / UDP 客户端。 在使用 Socket 之前，请先把网络连接好，有线的需要解析 DNS 和 IP 地址、网关，无线的需要填 WIFI 的账号（SSID）和密码，千万不要问出“发现 Bug 了！！！怎么访问不了百度（我没有联网）”的问题。 ## 计算机网络基础 > 不会这些基础，你也用不起来。 在应用 MaixPy 网络功能建议知道以下关键词： network 和 socket 是什么？ TCP \\ UDP 是什么？ HTTP \\ HTTPS \\ MQTT \\ FTP 又是什么？ 从实用主义的角度讲解，在 maixpy (micropython) 中，关于网络的内容分为最基础的以下两层接口。 ### network 负责管理网卡的接口，网卡是将网络数据协议从硬件发出的一类硬件接口，属于硬件范畴。 举例来说： 通常 WIFI 网卡主要职能就是连接无线路由器，帮助用户连接互联网，而有线网卡则是借由网线帮助用户连接互联网，它们会在这一层完成网关配置、DNS 解析、Ping 请求等操作，若是作为服务端还会完成无线配网、域名解析等功能。 ### socket 与网卡不同的地方在于 socket 只负责应用层的数据协议的传输，通常由最底层的 PCB 连接块封装成现在常见的 socket 套接字接口模块，它主要提供 TCP/IP 与 UDP 的连接传输方法，用户可以基于该接口进行网络编程。 #### TCP 和 UDP 是什么？ 在 socket 的基础上，我们分为 TCP 和 UDP 两个典型传输接口，主要强调的是两个应用之间通信是否保持连接，如果不保持连接，则使用 UDP 连接方式，需要与服务器保持长连接则使用 TCP 连接方式，注意 UDP 和 TCP 端口是彼此独立的存在，不需要混为一谈。 > TCP 拥有流式长连接重传机制，通过内部几类计时器和数据拥堵窗口可以一定程度上保证用户数据不会丢失，但存在超时等待的情况。 > UDP 则不需要连接，直接讲数据以广播的形式向上层交换机、路由器之间传输，所以 UDP 包具有一定的穿透性，可以在上级网络中不经过配置向外穿透数据包（实际情况会被改变）。 #### HTTP \\ HTTPS \\ MQTT \\ FTP 是什么？ 而基于此可以拓展出运行在 80 端口的 HTTP 协议，在 443 端口传输的 HTTP 等通信协议，在 21 端口的 FTP 文件传输协议，基于此的还有 MQTT 和 WebSocket 等应用传输协议，但它们都是基于原始 socket 接口完成的功能，不同的只是封装的应用协议。 ### 如何联网？ 请根据自己的网络情况选择对应的联网脚本，可以直接运行，也可以将其作为类库上传到硬件中，方便后续的 socket 开发，可以使用类似如下的脚本完成网络的配置，这在示例代码中可以得知具体用法。 一般验证用法： ```python import network_esp32 print(network_esp32) print(dir(network_esp32)) from network_esp32 import wifi print(wifi) '''ouput >>> <module 'network_esp32' from 'network_esp32.py'> ['__class__', '__name__', '__file__', 'GPIO', 'network', 'time', 'board_info', 'fm', 'wifi'] <class 'wifi'> MicroPython v0.5.1 140 g7bf6445e7 dirty on 2020 11 26; Sipeed_M1 with kendryte k210 Type \"help()\" for more information. >>> ''' ``` 真实环境用法： ```python SSID \"Sipeed_2.4G\" PASW \"xxxxxxxx\" def enable_esp32(): from network_esp32 import wifi if wifi.isconnected() False: for i in range(5): try: # Running within 3 seconds of power up can cause an SD load error # wifi.reset(is_hard False) wifi.reset(is_hard True) print('try AT connect wifi...') wifi.connect(SSID, PASW) if wifi.isconnected(): break except Exception as e: print(e) print('network state:', wifi.isconnected(), wifi.ifconfig()) enable_esp32() def enable_espat(): from network_espat import wifi if wifi.isconnected() False: for i in range(5): try: wifi.reset() print('try AT connect wifi...') wifi.connect(SSID, PASW) if wifi.isconnected(): break except Exception as e: print(e) print('network state:', wifi.isconnected(), wifi.ifconfig()) #enable_espat() ``` #### Maixduino + ESP32 使用 Maixduino 的 esp32 联网，上传该类库 [network_esp32.py](https://github.com/sipeed/MaixPy v1_scripts/blob/master/network/network_esp32.py) 即可。 ```python # This file is part of MaixPY # Copyright (c) sipeed.com # # Licensed under the MIT license: # http://www.opensource.org/licenses/mit license.php # import time, network from Maix import GPIO from fpioa_manager import fm class wifi(): nic None def reset(force False, reply 5, is_hard True): if force False and __class__.isconnected(): return True try: # IO map for ESP32 on Maixduino fm.register(25,fm.fpioa.GPIOHS10)#cs fm.register(8,fm.fpioa.GPIOHS11)#rst fm.register(9,fm.fpioa.GPIOHS12)#rdy if is_hard: print(\"Use Hareware SPI for other maixduino\") fm.register(28,fm.fpioa.SPI1_D0, force True)#mosi fm.register(26,fm.fpioa.SPI1_D1, force True)#miso fm.register(27,fm.fpioa.SPI1_SCLK, force True)#sclk __class__.nic network.ESP32_SPI(cs fm.fpioa.GPIOHS10, rst fm.fpioa.GPIOHS11, rdy fm.fpioa.GPIOHS12, spi 1) print(\"ESP32_SPI firmware version:\", __class__.nic.version()) else: # Running within 3 seconds of power up can cause an SD load error print(\"Use Software SPI for other hardware\") fm.register(28,fm.fpioa.GPIOHS13, force True)#mosi fm.register(26,fm.fpioa.GPIOHS14, force True)#miso fm.register(27,fm.fpioa.GPIOHS15, force True)#sclk __class__.nic network.ESP32_SPI(cs fm.fpioa.GPIOHS10,rst fm.fpioa.GPIOHS11,rdy fm.fpioa.GPIOHS12, mosi fm.fpioa.GPIOHS13,miso fm.fpioa.GPIOHS14,sclk fm.fpioa.GPIOHS15) print(\"ESP32_SPI firmware version:\", __class__.nic.version()) # time.sleep_ms(500) # wait at ready to connect except Exception as e: print(e) return False return True def connect(ssid \"wifi_name\", pasw \"pass_word\"): if __class__.nic ! None: return __class__.nic.connect(ssid, pasw) def ifconfig(): # should check ip ! 0.0.0.0 if __class__.nic ! None: return __class__.nic.ifconfig() def isconnected(): if __class__.nic ! None: return __class__.nic.isconnected() return False if __name__ \"__main__\": # It is recommended to callas a class library (upload network_espat.py) # from network_esp32 import wifi SSID \"Sipeed_2.4G\" PASW \"xxxxxxxx\" def check_wifi_net(reply 5): if wifi.isconnected() ! True: for i in range(reply): try: wifi.reset(is_hard True) print('try AT connect wifi...') wifi.connect(SSID, PASW) if wifi.isconnected(): break except Exception as e: print(e) return wifi.isconnected() if wifi.isconnected() False: check_wifi_net() print('network state:', wifi.isconnected(), wifi.ifconfig()) # The network is no longer configured repeatedly import socket sock socket.socket() # your send or recv # see other demo_socket_tcp.py / udp / http / mqtt sock.close() '''ouput MicroPython v0.5.1 136 g039f72b6c dirty on 2020 11 18; Sipeed_M1 with kendryte k210 Type \"help()\" for more information. >>> >>> >>> raw REPL; CTRL B to exit >OK Use Hareware SPI for other maixduino [esp32_spi] use hard spi(1) hard spi esp32 set hard spi clk:9159090 Get version fail try AT connect wifi... Use Hareware SPI for other maixduino [Warning] function is used by unknown(pin:10) [Warning] function is used by unknown(pin:6) [Warning] function is used by unknown(pin:11) [esp32_spi] use hard spi(1) hard spi esp32 set hard spi clk:9159090 ESP32_SPI firmware version: 1.4.0 try AT connect wifi... network state: True ('192.168.0.180', '255.255.255.0', '192.168.0.1') > MicroPython v0.5.1 136 g039f72b6c dirty on 2020 11 18; Sipeed_M1 with kendryte k210 Type \"help()\" for more information. >>> >>> >>> raw REPL; CTRL B to exit >OK network state: True ('192.168.0.180', '255.255.255.0', '192.168.0.1') > MicroPython v0.5.1 136 g039f72b6c dirty on 2020 11 18; Sipeed_M1 with kendryte k210 Type \"help()\" for more information. >>> ''' ``` #### ESP82XX 的 AT 固件 使用 ESP8266/85 的 AT 固件联网，上传该类库 [network_espat.py](https://github.com/sipeed/MaixPy v1_scripts/blob/master/network/network_espat.py) 即可 > `board_info` 与板卡相关，不同板卡配置不同，使用前需要[手动配置](../../api_reference/builtin_py/board_info.html)。 ```python # This file is part of MaixPY # Copyright (c) sipeed.com # # Licensed under the MIT license: # http://www.opensource.org/licenses/mit license.php # import time, network from Maix import GPIO from machine import UART from fpioa_manager import fm from board import board_info class wifi(): __is_m1w__ True uart None eb None nic None def init(): if __class__.__is_m1w__: fm.register(0, fm.fpioa.GPIOHS1, force True) M1wPower GPIO(GPIO.GPIOHS1, GPIO.OUT) M1wPower.value(0) # b'\\r\\n ets Jan 8 2013,rst cause:1, boot mode:(7,6)\\r\\n\\r\\nwaiting for host\\r\\n' fm.register(board_info.WIFI_EN, fm.fpioa.GPIOHS0) # board_info.WIFI_EN IO 8 __class__.en GPIO(GPIO.GPIOHS0,GPIO.OUT) fm.register(board_info.WIFI_RX,fm.fpioa.UART2_TX) # board_info.WIFI_RX IO 7 fm.register(board_info.WIFI_TX,fm.fpioa.UART2_RX) # board_info.WIFI_TX IO 6 __class__.uart UART(UART.UART2, 115200, timeout 1000, read_buf_len 8192) def enable(en): __class__.en.value(en) def _at_cmd(cmd \"AT\\r\\n\", resp \"OK\\r\\n\", timeout 20): __class__.uart.write(cmd) # \"AT+GMR\\r\\n\" time.sleep_ms(timeout) tmp __class__.uart.read() # print(tmp) if tmp and tmp.endswith(resp): return True return False def at_cmd(cmd \"AT\\r\\n\", timeout 20): __class__.uart.write(cmd) # \"AT+GMR\\r\\n\" time.sleep_ms(timeout) tmp __class__.uart.read() return tmp def reset(force False, reply 5): if force False and __class__.isconnected(): return True __class__.init() for i in range(reply): print('reset...') __class__.enable(False) time.sleep_ms(50) __class__.enable(True) time.sleep_ms(500) # at start > 500ms if __class__._at_cmd(timeout 500): break __class__._at_cmd() __class__._at_cmd('AT+UART_CUR 921600,8,1,0,0\\r\\n', \"OK\\r\\n\") __class__.uart UART(UART.UART2, 921600, timeout 1000, read_buf_len 10240) # important! baudrate too low or read_buf_len too small will loose data #print(__class__._at_cmd()) try: __class__.nic network.ESP8285(__class__.uart) time.sleep_ms(500) # wait at ready to connect except Exception as e: print(e) return False return True def connect(ssid \"wifi_name\", pasw \"pass_word\"): if __class__.nic ! None: return __class__.nic.connect(ssid, pasw) def ifconfig(): # should check ip ! 0.0.0.0 if __class__.nic ! None: return __class__.nic.ifconfig() def isconnected(): if __class__.nic ! None: return __class__.nic.isconnected() return False if __name__ \"__main__\": # It is recommended to callas a class library (upload network_espat.py) # from network_espat import wifi SSID \"Sipeed_2.4G\" PASW \"xxxxxxxx\" def check_wifi_net(reply 5): if wifi.isconnected() ! True: for i in range(reply): try: wifi.reset() print('try AT connect wifi...', wifi._at_cmd()) wifi.connect(SSID, PASW) if wifi.isconnected(): break except Exception as e: print(e) return wifi.isconnected() if wifi.isconnected() False: check_wifi_net() print('network state:', wifi.isconnected(), wifi.ifconfig()) # The network is no longer configured repeatedly import socket sock socket.socket() # your send or recv # see other demo_socket_tcp.py / udp / http / mqtt sock.close() '''ouput >>> raw REPL; CTRL B to exit >OK [Warning] function is used by fm.fpioa.GPIOHS1(pin:17) [Warning] function is used by fm.fpioa.GPIOHS0(pin:16) reset... try AT connect wifi... True could not connect to ssid Sipeed_2.4G reset... try AT connect wifi... True network state: True ('192.168.0.165', '255.255.255.0', '192.168.0.1', '0', '0', 'b0:b9:8a:5b:be:7f', 'Sipeed_2.4G') > MicroPython v0.5.1 136 g039f72b6c dirty on 2020 11 18; Sipeed_M1 with kendryte k210 Type \"help()\" for more information. >>> >>> >>> raw REPL; CTRL B to exit >OK network state: True ('192.168.0.165', '255.255.255.0', '192.168.0.1', '0', '0', 'b0:b9:8a:5b:be:7f', 'Sipeed_2.4G') > ''' ``` #### Spmod 的 WIZNET5K 使用 Spmod 的 WIZNET5K 网卡联网，运行此类中的代码 [network_wiznet5k.py](https://github.com/sipeed/MaixPy v1_scripts/blob/master/network/network_wiznet5k.py) 即可，可以直接获取对应的 IP 信息 WIZNET5K 为有线网卡模块, 使用时只需要将网线插好即可, 使用 SPI 协议, 在完整固件中默认使能了此模块, 最小固件中没有. ```python spi1 SPI(4, mode SPI.MODE_MASTER, baudrate 600 * 1000, polarity 0, phase 0, bits 8, firstbit SPI.MSB, sck WIZNET5K_SPI_SCK, mosi WIZNET5K_SPI_MOSI, miso WIZNET5K_SPI_MISO) nic network.WIZNET5K(spi spi1, cs WIZNET5K_SPI_CS) print(\"Static IP: \", nic.ifconfig()) #dhcp 动态获取 IP, 因为上面已经设置了静态 IP , 这一步可跳过, 要注意的是如果使用 DHCP, 必须像下面代码一样使用死循环, 否则将获取不成功 while True: if(nic.dhclient()): print(\"DHCP IP:\", nic.ifconfig() ) break; '''output >>> Static IP: ('192.168.0.117', '255.255.255.0', '192.168.0.1', '8.8.8.8') init dhcp DHCP IP: ('192.168.0.165', '255.255.255.0', '192.168.0.1', '8.8.8.8') ''' ``` ### 联网表现 请在确认了联网，得到了 IP 地址才开始使用 socket 网络编程喔，就如下获得了 IP 地址。 ```shell network state: True ('192.168.0.165', '255.255.255.0', '192.168.0.1', '0', '0', 'b0:b9:8a:5b:be:7f', 'Sipeed_2.4G') ```"},"/soft/maixpy/zh/course/network/socket_usage.html":{"title":"如何使用 Socket 网络编程","content":" title: 如何使用 Socket 网络编程 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy 如何使用 Socket 网络编程 > 大佬鼠 2020 11 26 编辑，截止目前 MaixPy 的 socket 模块还未能实现 listen / bind / accept 等接口。 ## 如何使用 TCP 和 UDP 客户端连接服务器 假设已知 [如何给 MaixPy 连接网络](./network_config.html) 的基础内容，直接运行示例代码。 * 警告：不准问：“没联网为什么不能访问网络的问题！” 请确认 地址 和 端口后再使用以下客户端代码。 ### 准备客户端代码 有如下几类典型客户端代码： TCP 客户端 [demo_socket_tcp_client.py](https://github.com/sipeed/MaixPy v1_scripts/blob/master/network/demo_socket_tcp_client.py) UDP 客户端 [demo_socket_udp_client.py](https://github.com/sipeed/MaixPy v1_scripts/blob/master/network/demo_socket_udp_client.py) TCP 图传 客户端 [demo_socket_pic_client.py](https://github.com/sipeed/MaixPy v1_scripts/blob/master/network/demo_socket_pic_client.py) ### 准备调试工具（服务端代码） 常见于网络调试助手，或者自己在电脑上运行提供的 Python3 服务端脚本。 TCP 服务端 [demo_socket_tcp_server.py](https://github.com/sipeed/MaixPy v1_scripts/blob/master/network/demo_socket_tcp_server.py) UDP 服务端 [demo_socket_udp_server.py](https://github.com/sipeed/MaixPy v1_scripts/blob/master/network/demo_socket_udp_server.py) TCP 图传 服务端 [demo_socket_pic_server.py](https://github.com/sipeed/MaixPy v1_scripts/blob/master/network/demo_socket_pic_server.py) 先起一个已知 IP 地址和端口的网络服务，等待 MaixPy 作为客户端发送数据过来服务器。 ### 典型客户端代码举例 TCP ```python import socket ADDR (\"192.168.0.107\", 60000) sock socket.socket() sock.connect(ADDR) sock.settimeout(1) while 1: sock.send(\"hello\\n\") #data sock.recv(10) # old maxipy have bug (recv timeout no return last data) #print(data) # fix try: data b\"\" while True: tmp sock.recv(1) print(tmp) if len(tmp) 0: raise Exception('timeout or disconnected') data + tmp except Exception as e: print(\"rcv:\", len(data), data) #time.sleep(2) sock.close() ``` UDP ```python import socket ADDR (\"192.168.0.107\", 60000) sock socket.socket(socket.AF_INET, socket.SOCK_DGRAM) sock.settimeout(1) while 1: try: sock.sendto(\"hello\\n\", ADDR) data, addr sock.recvfrom(1024) except Exception as e: print(\"receive error:\", e) continue print(\"addr:\", addr, \"data:\", data) time.sleep(2) sock.close() ''' >>> raw REPL; CTRL B to exit >OK network state: True ('192.168.0.186', '255.255.255.0', '192.168.0.1') addr: ('192.168.0.107', 60000) data: b'HELLO\\n' addr: ('192.168.0.107', 60000) data: b'HELLO\\n' addr: ('192.168.0.107', 60000) data: b'HELLO\\n' ''' ``` ### 其他网络功能 以下为特殊功能代码。 #### esp32 的 ping [demo_esp32_ping.py](https://github.com/sipeed/MaixPy v1_scripts/blob/master/network/demo_esp32_ping.py) ```shell ESP32_SPI firmware version: 1.4.0 try AT connect wifi... network state: True ('192.168.0.180', '255.255.255.0', '192.168.0.1') ping baidu.com: 40 ms > MicroPython v0.5.1 136 g039f72b6c dirty on 2020 11 18; Sipeed_M1 with kendryte k210 Type \"help()\" for more information. >>> ``` #### esp32 的 ADC [demo_esp32_read_adc.py](https://github.com/sipeed/MaixPy v1_scripts/blob/master/network/demo_esp32_read_adc.py) ```shell MicroPython v0.5.1 136 g039f72b6c dirty on 2020 11 18; Sipeed_M1 with kendryte k210 Type \"help()\" for more information. >>> raw REPL; CTRL B to exit >OK (2370, 3102, 3071) 2017 2753 0977 2709 0963 0855 : adc 0617 0757 0150 0095 0133 0153 : adc 1319 1478 0955 0939 0698 0619 : adc 2403 3231 3299 3298 1483 0779 : adc 1119 1815 1274 1315 0230 0255 : adc 0951 0951 0295 0283 0319 0399 : adc 2175 2769 2576 2579 1487 1104 : adc 1995 2846 2647 2699 0839 0441 : adc ``` > 其实 espAT 也是这样获取 ADC 的，但只能在指定的引脚上。 #### HTTP 的支持 [demo_http_get_jpg.py](https://github.com/sipeed/MaixPy v1_scripts/blob/master/network/demo_http_get_jpg.py) #### https 的支持 该功能默认是不被编译的，但所以提供的是 HTTP 的使用方法，而 HTTP 和 HTTPS 只是路径 url 的区别，注意这个 https 的 IP 解析依赖于网卡固件，并不在 K210 上完成。 [demo_socket_https.py](https://github.com/sipeed/MaixPy v1_scripts/blob/master/network/demo_socket_https.py) #### esp32、82XX 的 scan WIFI AP 热点 [demo_esp32_ap_scan.py](https://github.com/sipeed/MaixPy v1_scripts/blob/master/network/demo_esp32_ap_scan.py) [demo_espat_ap_scan.py](https://github.com/sipeed/MaixPy v1_scripts/blob/master/network/demo_espat_ap_scan.py) ```python ''' >>> raw REPL; CTRL B to exit >OK SSID: Sipeed_2.4G , ENC:WPA/WPA2 PSK , RSSI: 57 SSID: ChinaNet Ffdj , ENC:WPA/WPA2 PSK , RSSI: 58 SSID: wea_615 , ENC:WPA/WPA2 PSK , RSSI: 67 SSID: ChinaNet PnAN , ENC:WPA/WPA2 PSK , RSSI: 70 SSID: wea_613 , ENC:WPA/WPA2 PSK , RSSI: 73 SSID: ChinaNet TnSG , ENC:WPA/WPA2 PSK , RSSI: 82 SSID: chipshine_GUEST , ENC:WPA/WPA2 PSK , RSSI: 83 SSID: ASUS , ENC:WPA/WPA2 PSK , RSSI: 86 SSID: gta888 , ENC:WPA/WPA2 PSK , RSSI: 87 SSID: huahua , ENC:WPA/WPA2 PSK , RSSI: 88 > MicroPython v0.5.1 136 g039f72b6c dirty on 2020 11 18; Sipeed_M1 with kendryte k210 Type \"help()\" for more information. >>> ''' ``` #### mqtt 支持 这个是来自于 micropython 的官方仓库提供的代码，如果是商业用途，请将 socket 配置为非阻塞且添加 MQTT 保活的协议。 [demo_socket_mqtt.py](https://github.com/sipeed/MaixPy v1_scripts/blob/master/network/demo_socket_mqtt.py) #### 更新 ESP82XX 的 AT 固件 > 这是给 AT 固件提供的功能，懂的自然懂。 [demo_espat_ap_test.py](https://github.com/sipeed/MaixPy v1_scripts/blob/master/network/demo_espat_ap_test.py) [espat_upgrade.py](https://github.com/sipeed/MaixPy v1_scripts/blob/master/network/espat_upgrade.py)"},"/soft/maixpy/zh/course/advance/project_framework.html":{"title":"代码框架结构","content":" title: 代码框架结构 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy 代码框架结构 ## 目录简介 目录 子目录 子目录2 子目录3 内容梗概 assets 资源文件 projects 工程文件， 每个文件夹一个工程 tools 工具 components┐ 组件 └ boards 板级代码 └ drivers 驱动 └ micropython ┐ micropython 相关代码 └ core micropython 源码 └ port┐ maixpy 自定义部分源码 └ builtin_py maixpy 默认内置类 └ include 移植部分头文件 └ src 功能模块源码 └ spiffs SPIFFS 文件系统 └ utils 工具类（函数） > 现在的代码因为历史遗留原因在 `components/micropython/port/src` 目录下代码结构不是很好，以后的代码尽量按照现在的框架做到层次分明 ## 添加代码 工程使用 `CMake` 进行组织， 并且工程支持多个可配置选项（`Kconfig`） * 如果不添加文件夹和配置项，可以在现有的文件夹内添加文件编译即可 * 如果需要添加模块，可以修改 `CMakeLists.txt` 来添加内容， 可以参考内容更少的[c_cpp_project_framework](https://github.com/Neutree/c_cpp_project_framework) * 如果需要添加配置项， 可以通过修改 `Kconfig` 文件来达到目的，所有配置项在编译时会生成宏定义添加到`global_config.h`(生成的文件)中去， 而且在 `CmakeLists.txt` 文件中都可以使用该宏定义。 > 比如在 Kconfig 中定义 `config BOARD_M5STICK`, 在 CMakeLists.txt 中可以通过判断CONFIG_BOARD_M5STICK 是否为真来决定是否编译特定的代码。 编译时就可以通过`python3 project.py menuconfig`来选择是否勾选了"},"/soft/maixpy/zh/course/advance/compile.html":{"title":"如何编译","content":" title: 如何编译 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy 如何编译 本文是为了帮助一些想要成为开发者的用户而写的开源项目の开发文档。 ## 获取 maixpy 开源项目 请准备 linux 系统环境（在 Windows 上使用 WSL 也可以），挂上 XXX 代理，输入 `git clone https://github.com/sipeed/MaixPy` 拉取 MaixPy 仓库代码和子模块，确保拿到后阅读目录下的 [build.md](https://github.com/sipeed/MaixPy v1/blob/master/build.md) 文档。 > 没有代理的同学可以用 github 镜像站列表（`https://github.com/rc1844/fastgithub`）加速拉取 maixpy 仓库，请不要用 gitee 拉取 maixpy 仓库，会掉子模块仓库的。 ``` juwan@juwan N85 N870HL:~$ git clone https://gitclone.com/github.com/sipeed/MaixPy 正克隆到 'MaixPy'... remote: 对象计数中: 77517, 完成. remote: 压缩对象中: 100% (20929/20929), 完成. remote: Total 77517 (delta 56791), reused 76050 (delta 55761) 接收对象中: 100% (77517/77517), 53.62 MiB 972.00 KiB/s, 完成. 处理 delta 中: 100% (56791/56791), 完成. juwan@juwan N85 N870HL:~$ cd MaixPy/ juwan@juwan N85 N870HL:~/MaixPy$ git submodule update recursive init 子模组 'components/kendryte_sdk/kendryte standalone sdk'（https://github.com/sipeed/kendryte standalone sdk）已对路径 'components/kendryte_sdk/kendryte standalone sdk' 注册 子模组 'components/micropython/core'（https://github.com/micropython/micropython.git）已对路径 'components/micropython/core' 注册 子模组 'components/micropython/port/src/lvgl/lv_bindings'（https://github.com/littlevgl/lv_binding_micropython.git）已对路径 'components/micropython/port/src/lvgl/lv_bindings' 注册 子模组 'components/micropython/port/src/ulab/micropython ulab'（https://github.com/Neutree/micropython ulab.git）已对路径 'components/micropython/port/src/ulab/micropython ulab' 注册 子模组 'components/spiffs/core'（https://github.com/pellepl/spiffs.git）已对路径 'components/spiffs/core' 注册 子模组 'tools/flash/kflash_py'（https://github.com/sipeed/kflash.py.git）已对路径 'tools/flash/kflash_py' 注册 子模组 'tools/kconfig/Kconfiglib'（https://github.com/ulfalizer/Kconfiglib.git）已对路径 'tools/kconfig/Kconfiglib' 注册 子模组 'tools/spiffs/mkspiffs'（https://github.com/igrr/mkspiffs.git）已对路径 'tools/spiffs/mkspiffs' 注册 正克隆到 '/home/juwan/MaixPy/components/kendryte_sdk/kendryte standalone sdk'... 正克隆到 '/home/juwan/MaixPy/components/micropython/core'... ``` 注意，这之后拉取子仓库是没有加速的，会从 github 试图拉取，你也可以用同样的方法单独拉取子模块位置（在 `.gitmodules` 中定义），本篇文档是无法帮你解决网络问题的。 > 如果 https://gitclone.com 挂了，就自己想办法找其他线路吧。 如何确认最终子模块是否拉取完整，可以输入 `git submodule status`，不完整请不要进行编译，必出错误。 ```shell juwan@juwan N85 N870HL:~/Desktop/maixpy$ git submodule status 7fdb511fe61026eec5874885de5981c4f60f664d components/kendryte_sdk/kendryte standalone sdk (v0.5.2 181 g7fdb511) ced340d739e84737dd5c8e6b4ab9af2ea44e29e7 components/micropython/core (v1.11 64 gced340d73) ddf09164ee1711a61169030a7ee8bf370ee5743f components/micropython/port/src/lvgl/lv_bindings (remotes/origin/dev 6.0 32 gddf0916) c315a571df49a19b843f7dffc300c21ccb7d4edd components/micropython/port/src/ulab/micropython ulab (0.24 27 gc315a57) ec68ba8208d7550860e4e78299d58a529b88bf85 components/spiffs/core (0.2 234 gec68ba8) 1ef6f4c0b2cb8b1872b6ffe9337f4e02d5487fa6 tools/flash/kflash_py (v1.0 79 g1ef6f4c) 53c72959ac4d71f99913e4b0eea99261a6585430 tools/kconfig/Kconfiglib (v12.12.1 14 g53c7295) 983970e40ff381d95d68a9bddff70c4d9921021b tools/spiffs/mkspiffs (0.2.3 6 g983970e) ``` ### 编译 maixpy 开源项目 > 这节内容假设你没有任何搭建交叉编译链的经验。 首先按 [build.md](https://github.com/sipeed/MaixPy v1/blob/master/build.md) 顺序执行各种操作即可，如果你不会英文你可以开翻译机。 步骤说明如下： 给 linux 环境安装必须的编译工具和 Python 模块，确保 cmake / make / python3 可用。 设置 toolchain 工具链到系统 `/opt/kendryte toolchain/` 目录下，方便 SDK 寻找编译工具，确保存在 /opt/kendryte toolchain/bin/riscv64 unknown elf gcc 编译工具。 进入到 MaixPy 的具体硬件项目下 `cd projects/maixpy_k210` 然后输入 `python3 project.py build` 开始编译。 整个编译步骤就这样结束了， 编译成功后你就会在 `projects/maixpy_k210` 目录下得到一个 build 文件夹，里面有如下文件： maixpy.bin 将要被烧录到 0x000000 地址的 K210 固件。 maixpy.txt 当前固件对应的反编译代码内容，辅助你排查 core dump 的指针地址的信息。 其他文件是编译过程中产生的 .a 和 .o 中间编译文件，可忽略。 ### 烧录 maixpy 固件到你的硬件 现在你拿到了 maixpy.bin 固件，插入硬件，然后使用 `python3 project.py B goE p /dev/ttyUSB1 b 1500000 flash` 烧录硬件，以 ` B` 参数为例。 ```shell juwan@juwan N85 N870HL:~/Desktop/maixpy/projects/maixpy_k210$ python3 project.py h SDK_PATH:/home/juwan/Desktop/maixpy maixpy usage: project.py [ h] [ p PORT] [ b BAUDRATE] [ t] [ n] [ s] [ B {dan,bit,bit_mic,goE,goD,maixduino,kd233,auto}] [ S] [ toolchain PATH] [ toolchain prefix PREFIX] [ config_file PATH] [ verbose] {config,build,rebuild,menuconfig,clean,distclean,clean_conf,flash} build tool, e.g. `python project.py build` ``` 其中 ` B goE` 是选择版型，可选的项有 `dan,bit,bit_mic,goE,goD,maixduino,kd233,auto` 表示烧录方式，这个和具体硬件有很大关系。 bit 通常对应使用 CH340 的芯片。 maixduino 通常对应使用 CH552 的芯片。 具体你可以多种试试，还可以选择烧录频率 115200 、1500000 的 BAUDRATE 选择，当然，无论是哪种配置，只要能烧录进去就行，更多的使用方法你需要查看 h 的帮助说明。 常见的烧录过程如下： ```shell ➜ maixpy_k210_minimum git:(master) ✗ sudo kflash b 1500000 p /dev/ttyUSB0 build/maixpy.bin [sudo] fqr 的密码： [INFO] COM Port Selected Manually: /dev/ttyUSB0 [INFO] Default baudrate is 115200 , later it may be changed to the value you set. [INFO] Trying to Enter the ISP Mode... ._ [INFO] Automatically detected goE/kd233 [INFO] Greeting Message Detected, Start Downloading ISP Downloading ISP: 100.0% 10kiB/s [INFO] Booting From 0x80000000 [INFO] Wait For 0.1 second for ISP to Boot [INFO] Boot to Flashmode Successfully [INFO] Selected Baudrate: 1500000 [INFO] Baudrate changed, greeting with ISP again ... [INFO] Boot to Flashmode Successfully [INFO] Selected Flash: On Board [INFO] Initialization flash Successfully Programming BIN: 100.0% 47kiB/s [INFO] Rebooting... ``` ### 命令行连接硬件 & 运行代码 到这一步基本都会使用了吧。 这里推荐一下开发时的一些 linux 或 micropython 的快速操作，首先可以使用 minicom 或 picocom 串口工具进入 MicroPython 终端（在烧录命令后加上 ` && picocom /dev/ttyUSB0 b 115200` 就可以了），接着进入到 micropython 可以按下 Ctrl + E 进入粘贴模式，然后粘贴代码后输入 Ctrl + D 结束输入运行代码。 ```python >>> hello world! >>> ``` 这样你就完成了快速的验证和开发，但如果你是要调试某一段功能代码，你可以通过 [mpfshell lite](https://github.com/junhuanchen/mpfshell lite) 直接命令行上传代码，复位就运行，然后报错和调试。 > 底层开发动态语言经常这样操作，所以要感谢所有做解释器接口的开发者做了大量的接口验证。 ## MaixPy 项目应用说明 假设已经知道如何使用 MaixPy 工程进行开发、编译、烧录，接下来将深入介绍一些工具的用法，这里面只交待一些常见用法，并不会展开细节说明。 ### 介绍 cmake 的工程编译方法 cmake 是通过 CMakeLists.txt 编写代码和规则后编译生成 Makefile 的工具，用法和细节自行百度，这里有一个结构简单的 cmake 工程[Get_static_library_by_cmake](https://github.com/junhuanchen/Get_static_library_by_cmake.git)供你运行和参考学习。 在没有 cmake 之前，都是使用 makefile 的方式进行工程管理，直到今天 micropython 官方也依然是使用双层 Makefile + inclue(makefile) 的工程管理多版型硬件的方法。 但 MaixPy 只把 micropython 当做一个依赖库包加入到自己的环境当中，所以实际上 MaixPy 的软件架构设计是围绕着 K210 软件组件的形式进行构建的。 因此可以来到 maixpy 文件夹里存在一个 hello_world 的工程，让看看它是怎么构成的。 hello_world build compile main CMakeLists.txt config_defaults.mk project.py MaixPy 项目已经准备了一个模板提供给你进行 K210 的项目构建，这里忽略项目构建的过程，重点关注需要可以编译链接的工程配置部分，也就是 main 下的 CMakeLists.txt ，它的内容如下。 ```cmake ############### Add include ################### # list(APPEND ADD_INCLUDE \"include\" # ) # list(APPEND ADD_PRIVATE_INCLUDE \"\") ############################################### ############ Add source files ################# list(APPEND ADD_SRCS \"src/main.cpp\" ) # aux_source_directory(src ADD_SRCS) # list(REMOVE_ITEM COMPONENT_SRCS \"src/test2.c\") ############################################### ###### Add required/dependent components ###### list(APPEND ADD_REQUIREMENTS kendryte_sdk) ############################################### ############ Add static libs ################## # list(APPEND ADD_STATIC_LIB \"lib/libtest.a\") ############################################### register_component() ``` 可以看到 `ADD_SRCS` 链接了一个 `src/main.cpp` 代码文件作为程序入口。 通过 `ADD_REQUIREMENTS` 就可以加载其他地方的模块进来，例如 `list(APPEND ADD_REQUIREMENTS kendryte_sdk)` 则请求了 `kendryte_sdk` 这个 SDK 包。 如果想要链接自己的 nncase 库呢？其他库代码呢？ 可以直接则改为绝对路径下的 `LINK_DIRECTORIES(/home/juwan/maixpy/projects/maixpy_old/main/src/nncase)` 的代码就可以了，这样做的前提是这个库是由 cmake 工程的方式提供的。 > 这里示范了如何在编译调用自己的 nncase 库，结合这些关键讯息再去阅读工程，应该就可以较为轻松的用起来了吧。 ### 如何打包 micropython spiffs 文件系统分享出来 如果你深入使用了 MaixPy 进行开发，你会发现 MaixUI 提供了一种文件系统文件（img），当你刷入这个 UI 系统一样的 img ，你就会在烧录后直接进入 UI 界面。 需要知道 MicroPython 是从 0x0 开始的程序，在程序中会通过 spiffs 在 Flash 的 [0xD00000, (0xD00000 + 0x300000)) 区间构建 VFS （虚拟文件系统），是由 maixpy/projects/maixpy_xxxxx/config_defaults.mk 中定义得到的。 ```makefile CONFIG_SPIFFS_SIZE 0x300000 CONFIG_SPIFFS_START_ADDR 0xD00000 ``` > 这里只讨论工具的使用，而不对其实现做详解。 而 [spiffs](https://github.com/pellepl/spiffs) 是不支持目录结构的，那么我们会发现 ui 的 img 在 flash 里的文件名称会存在 `lib/core.py` 这样的名称，而正常情况下我们是不可能将这个文件创建起来的，所以要通过工具将其打包。 在 tools/spiffs/mkspiffs 目录下有 gen_spiffs_image.py 脚本完成这个打包镜像的功能，用法请看 tools/spiffs/README.md 说明。 在 spiffs 目录下准备一个 fs 文件夹，包含你要打包的代码或资源文件内容。 执行 `python gen_spiffs_image.py ../../projects/maixpy_k210/config_defaults.mk` 即可得到 maixpy_spiffs.img 二进制文件。 将上述得到的 img 烧入到 0xD00000 就恢复 micropython 的文件系统里的内容。 如果你做了一些小系统，用这样的方式发布，用户拿到你提供的 img 文件，烧入就可以立刻得到和你一样的环境啦，这其实和基于 Linux 系统发布某系统镜像的结构是一样的。 现在，你学会了吗？ ### MaixPy 的持续集成服务（Travis CI） Travis CI 提供的是持续集成服务（Continuous Integration，简称 CI）。它绑定 Github 上面的项目，只要有新的代码，就会自动抓取。然后，提供一个运行环境，执行测试，完成构建，还能部署到服务器。 提及一下 MaixPy 是有借助 travis + tools/release.sh 完成项目的编译后，将编译目录上传到了发布服务器上从而完成了每日构建，这常见于各类包的自动化构建与编译，感兴趣不妨自己亲手试试。 > [持续集成服务 Travis CI 教程](http://www.ruanyifeng.com/blog/2017/12/travis_ci_tutorial.html) ### 如何更好的阅读开源项目源代码 说到这里，以个人的角度来看，基于阅读代码这种基本功要求之外，想要更好的阅读源代码，对于不同的项目有不同的组织架构，任何一位刚进入这个行业的初学者，可以用亲身经历的项目作为切入点，逐渐从项目架构、源码、编译、测试、发布软件等方面建立起完整的软件工程意识，围绕此进行知识的深入学习也是一种不错的手段，希望你能通过这篇文章建立起完整的软件工程体系吧。 ## 最后的参考资料 bing.com + keyword + yourself"},"/soft/maixpy/zh/course/advance/add_c_module.html":{"title":"如何用 C 添加一个 MaixPy 模块","content":" title: 如何用 C 添加一个 MaixPy 模块 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy 如何用 C 添加一个 MaixPy 模块 ## 预备知识 在 `python` 中万物皆对象 需要先知道 module，type， function， class 分别是什么，有什么关系和区别 * module（模块） 在`MaixPy`中，把每个类别的功能放到一个 模块 中， 比如内置的 `uos`,`usys`,`machine`， 另外我们自己新建的文件， 比如`test.py` 也可以是一个模块， 我们使用模块都这样使用： ```python import uos import machine import test ``` > 在 C 源码中就是 `mp_type_module` * type（类型） 用来表示一个基本的类型， 它可以包含一些方法或者变量 > 在 C 源码中就是 `mp_type_type` * class（类） 一个 class 其实就是一个 `type`，比如 ```python class A:pass print(type(A)) ``` 会输出 ``` <class 'type'> ``` 当对`A`进行了实例化 ``` class A:pass a A() print(type(a)) ``` 会输出 ``` <class 'A'> ``` 表示`a`是`A`的一个实例（对象） > 在 C 中定义一个类其实就是定义一个 `mp_type_type` ## 在 C 中添加模块 我们的目标是实现在`MaixPy`层面可以使用以下代码： ```python import my_lib print(my_lib.__name__) my_lib.hello() ``` ### 在`components/port/src`目录下新建一个文件夹比如取名`my_lib` ### 然后在`my_lib`文件夹下新建`my_lib.c`文件 ### 编辑`my_lib.c`添加代码 #### 定义一个模块： ```c #include \"obj.h\" const mp_obj_module_t my_lib_module { .base { &mp_type_module }, .globals (mp_obj_dict_t*)&mp_module_my_lib_globals_dict, }; ``` 这里`my_lib_module`是定义的`my_lib`模块对象, `mp_type_module`表明是一个模块， `mp_module_my_lib_globals_dict`是模块的全局变量和函数，是一个`dict`对象，有我们自己定义， 现在还没定义 #### 定义模块的全局变量 ```c STATIC mp_obj_t hello() { mp_printf(&mp_plat_print, \"hello from my_lib\"); return mp_const_none; } MP_DEFINE_CONST_FUN_OBJ_0(my_lib_func_hello_obj, my_lib_func_hello); STATIC const mp_map_elem_t my_lib_globals_table[] { { MP_OBJ_NEW_QSTR(MP_QSTR___name__), MP_OBJ_NEW_QSTR(MP_QSTR_my_lib) }, { MP_OBJ_NEW_QSTR(MP_QSTR_hello), (mp_obj_t)&my_lib_func_hello_obj }, }; STATIC MP_DEFINE_CONST_DICT ( mp_module_my_lib_globals_dict, my_lib_globals_table ); ``` 这里定义了一组键值对数组，键值对数值, `mp_map_elem_t`的定义如下： ```c typedef struct _mp_map_elem_t { mp_obj_t key; mp_obj_t value; } mp_map_elem_t; ``` * 第一个值是`key`，类型是`str`对象， 即在`MaixPy`层面使用`my_lib.key`来调用。这里用了`MP_OBJ_NEW_QSTR(MP_QSTR___name__)`生成了一个值为`__name__`的`str`对象，你可能有疑问`__name__`这个`c`变量定义在哪里，这是在编译阶段使用工具自动生成`c`变量，总之记住这样可以写可以生成一个常量`str`对象保存在固件里就好了 * 第二个值是数值，类型是一个对象，可以是`str/function/int/float/tuple/list/dict`等， 方式如下： * `str`: 这里同样是定义了一个`str`类型的值为`my_lib`,即在`MaixPy`层面使用`my_lib.__name__`得到结果`my_lib`。 * `其它常量对象`： 可以使用`mp_obj_new_xxx`,比如`int`变量`mp_obj_new_int(10)`， 函数在`obj.h`中搜索 * `函数`： 这里的`key``hello`对应的值为为`(mp_obj_t)&my_lib_func_hello_obj`，是一个函数对象，注意不是`C`函数，前面说了`python`中一切皆对象， 这里也是使用了一个函数对象，然后去地址强制转换成 `mp_obj_t`。这个函数对象使用了`MP_DEFINE_CONST_FUN_OBJ_0`宏定义将`my_lib_func_hello`这个`C`函数定义为`my_lib_func_hello_obj`这个对象，注意`hello`函数需要返回一个值`mp_const_none`,注意不能返回`NULL`， 因为`NULL`不是一个(`MaixPy`)对象， 这个返回值也就是`MaixPy`层面调用`hello()`函数时的返回值 > 除了`MP_DEFINE_CONST_FUN_OBJ_0`即没有参数之外，还有`1/2/3/n`个参数，以及带关键字参数，这些请翻阅源码举一反三学习 然后使用`MP_DEFINE_CONST_DICT`宏定义将`my_lib_globals_table`这个键值对变成`MaixPy`层面能理解的`dict`对象（`mp_map_elem_t`只是`C`层面能理解）`mp_module_my_lib_globals_dict`, 这个对象也被上一步中定义模块的时候使用 到此一个模块就定义完成了， 在 `MaixPy`层面，理论上可以使用如下语句进行使用了 ```python import my_lib print(my_lib.__name__) my_lib.hello() ``` 但是我们还没编译 #### 将模块添加到固件， 并进行编译 * 在`my_lib.c`文件末尾添加: ```c MP_REGISTER_MODULE(MP_QSTR_my_lib, my_lib_module, MODULE_MY_LIB_ENABLED); ``` 这行代码注册这个模块，但是是否编译进固件取决与`MODULE_MY_LIB_ENABLED`这个宏定义在`mpconfigport.h`中是否定义为`1` * 所以我们打开`mpconfigport.h`文件，在里面添加 ```c #define MODULE_MY_LIB_ENABLED (1) ``` * 打开`components/micropython/CMakeLists.txt`编辑 找到文件中有`############## Add source files ###############` 的地方， 在后面添加 ```cmake append_srcs_dir(MPY_PORT_SRCS \"port/src/my_lib\") ``` 到此，项目才会将`my_lib`这个文件夹编译到固件 然后`python project.py rebuild`编译固件即可，因为新增了文件，一定要用`rebuild`命令而不是`build`，注意编译提示，如果有报错，注意修改 ## 在模块中添加一个 type 前面定义了一个`my_lib`模块，现在我们希望在`my_lib`中定义一个类，叫`A`，如下 ```python import my_lib a my_lib.A() print(a.add(1, 2)) ``` 这里只讲大致上的思路，然后提供样例，聪明的你一下就能理解了 * 定义一个`mp_obj_type_t` 对象，正如前面定义`mp_obj_module_t`一样 * 同样的，给这个类对象一个`dict`对象，作为这个类的成员，成员可以是常量或者函数甚至是另一个`type`对象 * 将这个类对象注册到前面的`my_lib`模块 定义`mp_obj_type_t`对象和成员定义可以参考`port/src/standard_lib/machine/machine_i2c.c`中的实现 > 定义`mp_obj_type_t`时有一个`make_new`成员，这个函数是用来新建对象时会被调用的函数，比如`a my_lib.A(); a.add(1,2)` > 如果不新建对象，直接调用类方法或变量，这个函数不会被调用`A.var_a` 比如我们定义了一个`const mp_obj_type_t my_lib_A_type ... ` 然后在`my_lib/my_lib.c`中 `my_lib_globals_table`中添加这个对象，并将其映射到`key` `A`即可 ```c { MP_ROM_QSTR(MP_QSTR_A), MP_ROM_PTR(&my_lib_A_type) }, ``` ## 使用 C 语言编写固件时需要注意 * `mp_printf` vs `printk` vs `printf`： 因为`IDE`使用了串口通信协议，所以在`C`层面不要直接使用`printk`或者`printf`函数打印消息，**必须**使用`mp_printf`函数来打印，不然会导致 `IDE` 运行时收到不理解的数据而断开连接！！ 当然平时调试可以使用`printk`，因为这个函数不会触发系统中断，可以在中断函数里面调用，但是仅限调试时使用， 实际提交代码时一定要删除掉！！"},"/soft/maixpy/zh/course/advance/pack_fs.html":{"title":"打包文件系统","content":" title: 打包文件系统 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy 打包文件系统 将 PC 上的若干个文件打包成一个 SPIFFS 文件系统镜像，使用 kflash 烧录到 flash 特定的地址， 这些文件就能直接在开发板上(MaixPy)读取到了 详情请看使用说明： [pack SPIFFS for MaixPy](https://github.com/sipeed/MaixPy v1tree/master/tools/spiffs) 操作示例 GIF： ![pack fs](https://cdn.sipeed.com/pack_spiffs_ops.gif) GIF 备用链接： [pack_spiffs_ops.gif](../../../assets/course/advance/pack_spiffs_ops.gif)"},"/soft/maixpy/zh/course/others/pye.html":{"title":"pye (Micropython Editor)","content":" title: pye (Micropython Editor) keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy pye (Micropython Editor) 在 MaixPy 中, 我们内置了一款编开源编辑器 [Micropython Editor(pye)](https://github.com/robert hh/Micropython Editor) > 注意在`minimum`版本的固件中不包含此功能 使用 `os.listdir()` 可以查看当前目录下的文件, 使用 `pye(\"hello.py\")` 可以创建文件并进入编辑模式, 快捷键等使用说明可以在[这里查看](https://github.com/robert hh/Micropython Editor/blob/master/Pyboard%20Editor.pdf) 比如我们写入代码 ```python print(\"hello maixpy\") ``` 然后按 `Ctrl+S` 按 `Enter` 键保存, 按 `Ctrl+Q` 退出编辑 **注意**： 使用这款编辑器对使用的串口工具有一定要求, 必须将 `BackSpace` 按键设置为 `DEL` 功能, 否则按 `BackSpace` 调用的是 `Ctrl+H` 一样的功能（即字符替换）。 Linux 下推荐使用 `minicom`, 需要使用 `sudo minicom s` 来设置,参考[前面的教程](./../../get_started/env_serial_tools.html) Windows 下也一样, 根据自己使用的工具上网搜设置方法, 比如 `xshell` 搜 `xshell如何设置backspace为del` 得到结果： `文件` > `属性` > `终端` > `键盘`, 把 delete 和 backspace 序列改为 ASCII 127 即可."},"/soft/maixpy/zh/course/others/maixui.html":{"title":"MaixUI 基础使用指导","content":" title: MaixUI 基础使用指导 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy MaixUI 基础使用指导 如何正确的食用 MaixUI 项目？ ## 为什么要开发它？它的意义和存在价值是什么？ 在任何芯片下永远存在对 UI 框架的基本需求，但由于 K210 无法在支持 Ai 功能的情况下继续使用 LVGL 环境，导致 UI 失去了本来存在的意义。 也就是在不能用 QT 也不能用 LVGL 的时候，又希望能够使用 Python 编写 UI 应用，所以才诞生了基于 image 的 MaixUI UI 框架。 ## 对 MaixUI 的要求 在最新 MaixPy 固件的基础上 2020年10月7日 满足如下要求。 确保 MicroPython 的 GC 内存在任何时候都是使用可回收可控的。 确保 UI 组件代码独立，不包含在固件，可被调试修改。 确保系统稳定性，保证代码和硬件资源均可重入，不会出现 core dump 现象。 运行可重入，也就运行动态代码展示 UI 样式，类似 HTML5 / CSS 的设计。 Python 的异常捕获实时反馈到屏幕上，快速定位出错行。 UI 相关的绘制函数可被多处装饰使用，也可独立运行。 框架提供的所有 MicroPython 硬件驱动均可独立运行相应的单元测试。 框架运行时允许动态加载外部符合结构的 UI 应用，可以从 storage 或 network 上获取用户自定义应用。 所以在最基础的示例中，它将严格控制内存占用控制在 512k ~ 1M ，并将绘图性能保持 15 ~ 24fps 之间。 ## 如何食用？ 来，我们从最简单的入口代码开始说起，完整的代码在这里 [app_main.py](https://github.com/sipeed/MaixUI/blob/master/app/app_main.py) 。 ```python # This file is part of MaixUI # Copyright (c) sipeed.com # # Licensed under the MIT license: # http://www.opensource.org/licenses/mit license.php # import time, gc, math, sys try: from core import agent, system from dialog import draw_dialog_alpha from ui_canvas import ui, print_mem_free from ui_container import container from wdt import protect from creater import get_time_curve except ImportError as e: sys.print_exception(e) from lib.core import agent, system from lib.dialog import draw_dialog_alpha from ui.ui_canvas import ui, print_mem_free from ui.ui_container import container from driver.wdt import protect from lib.creater import get_time_curve ``` 分别是运行它所需要 import 的依赖代码，有如下依赖： from core import agent, system 提供一个 agent 软定时器和一个全局实例 system 软定时器对象。 from dialog import draw_dialog_alpha 提供了一个圆角边框 MessageBox 控件的绘图操作。 from ui_canvas import ui, print_mem_free 提供了一个 UI 画布的基础接口，通过它来管理全局的统一绘图操作。 from ui_container import container 提供了一种运行 UI 应用的容器模块，可以通过它切换不同的 UI 应用。 from wdt import protect 看门狗，保证系统在出现 core dump 后能够重启恢复过来。 from creater import get_time_curve 一种基于时间或计数器的曲线生成函数，用来维持非线性动画效果。 这两段代码是用来 import 加载到不同区域（在 Flash/SD 的根目录或文件夹下）的代码，所以你知道怎么 import 代码了就行。 可以使用 MaixPy IDE 发送文件，也可以使用 [mpfshell lite](https://github.com/junhuanchen/mpfshell lite) put 文件到硬件的 flash 或 sd 中。 可以使用 SD 读卡器，把整个 maixui 仓库下的文件夹放到 SD 卡中启动即可。 ### 定义 UI 应用 接着介绍一种典型的基础应用的案例，准备如下代码（class launcher 静态类）。 ```python class launcher: def load(): __class__.ctrl agent() __class__.ctrl.event(20, __class__.draw) def free(): __class__.ctrl None @ui.warp_template(ui.blank_draw) @ui.warp_template(ui.grey_draw) @ui.warp_template(ui.bg_in_draw) @ui.warp_template(ui.anime_in_draw) @ui.warp_template(ui.help_in_draw) #@ui.warp_template(taskbar.time_draw) #@ui.warp_template(taskbar.mem_draw) #@catch # need sipeed_button def draw(): height 100 + int(get_time_curve(3, 250) * 60) pos draw_dialog_alpha(ui.canvas, 20, height, 200, 20, 10, color (255, 0, 0), alpha 200) ui.canvas.draw_string(pos[0] + 10, pos[1] + 10, \"Welcome to MaixUI\", scale 2, color (0,0,0)) ui.display() def event(): __class__.ctrl.cycle() ``` 在这里， __class__ 类似于 实例类 中的 this 指针，可以通过它访问当前类的全局变量。 该静态类拥有有 load / free / event 三个生命周期函数用以提供给 UI 容器维持该 UI 应用的持续运行。 load 只会执行一次，用于 UI 应用的初始化。 free 只会执行一次，用于 UI 应用的释放。 event 将会提供给 UI 容器循环执行其中的操作。 UI 容器指的是 [ui/ui_container.py](https://github.com/sipeed/MaixUI/tree/master/ui/ui_container.py) 。 当然你也可以不通过 UI 容器来维持运行。 可以看到该 UI 应用在 load 的时候定义了 agent 软定时器和设置了绘图函数的期望执行周期为 20ms ，设置再小也不会低于真实运行的周期。 ```python __class__.ctrl agent() __class__.ctrl.event(20, __class__.draw) ``` 然后在 event 函数中维持 软定时器 ctrl 拥有的分时事件（非阻塞 no block），因此基于此设计你可以制作很多个不同定时的分时任务。 ```python __class__.ctrl.cycle() ``` 它可以周期执行，也可以用完删除，就如下示范。 ```python self.ctrl agent() # loop self.ctrl.event(5, self.draw) # once def into_launcher(self): container.reload(launcher) self.remove(into_launcher) self.ctrl.event(2000, into_launcher) ``` 接着我们看到具体的 UI 绘图事件，不同于按键/触摸等硬件驱动事件，但无论是哪类事件，我们都期望它能够尽快结束，交出运行核心。 ```python @ui.warp_template(ui.blank_draw) @ui.warp_template(ui.grey_draw) @ui.warp_template(ui.bg_in_draw) @ui.warp_template(ui.anime_in_draw) @ui.warp_template(ui.help_in_draw) #@ui.warp_template(taskbar.time_draw) #@ui.warp_template(taskbar.mem_draw) #@catch # need sipeed_button def draw(): height 100 + int(get_time_curve(3, 250) * 60) pos draw_dialog_alpha(ui.canvas, 20, height, 200, 20, 10, color (255, 0, 0), alpha 200) ui.canvas.draw_string(pos[0] + 10, pos[1] + 10, \"Welcome to MaixUI\", scale 2, color (0,0,0)) ui.display() ``` 在这里，我们有一个最基础的 draw() 绘图函数，也为它装饰了 5 个基础函数，事实上装饰只是好看，它实际上等效于如下代码，所以是否使用取决于你的喜好。 ```python def draw(): ui.blank_draw() # 准备一个空白的 image 画布对象 ui.grey_draw() # 给 画布 画上灰色 ui.bg_in_draw() # 给 画布 画上内置的 背景图 一个 sipeed 的 logo 。 ui.anime_in_draw() # 给 画布 加载四周水波动画效果 ui.help_in_draw() # 给 画布 画上 内置的 帮助说明。 height 100 + int(get_time_curve(3, 250) * 60) # 获取基于时间的正弦曲线值 # 在指定位置画出 圆角边框的 MessageBox 的效果，并获取边框的 左上角起点 。 pos draw_dialog_alpha(ui.canvas, 20, height, 200, 20, 10, color (255, 0, 0), alpha 200) # 在指定位置打印 \"Welcome to MaixUI\" 字符串。 ui.canvas.draw_string(pos[0] + 10, pos[1] + 10, \"Welcome to MaixUI\", scale 2, color (0,0,0)) # 把当前的画布显示到屏幕上，多次执行也不影响，执行后会释放当前画布对象。 ui.display() ``` 接入其他按键/触摸/摄像头的事件亦如此，可以在此查看 UI 绘图的具体实现 [ui/ui_canvas.py](https://github.com/sipeed/MaixUI/tree/master/ui/ui_canvas.py)。 ### 运行 UI 框架 在真正进入上述的业务逻辑之前，我们需要把 UI 框架跑起来，因此我们需要一个入口函数，如 `if __name__ \"__main__\":` 中的代码。 ```python if __name__ \"__main__\": container.reload(launcher) while True: container.forever() ``` 讲解一下，我们看到使用 UI 容器 （container.reload(launcher)） 加载一个名为 launcher 的 UI 应用即可运行，可以在此查看 UI 容器的具体实现 [ui/ui_container.py](https://github.com/sipeed/MaixUI/tree/master/ui/ui_container.py)。 但仅仅这样写是不够稳定的，所以我们可以通过两个 while True 保持程序永远不会退出（除非系统 core dump 崩溃）。 并通过 last 与 当前 tick_ms 做差得到当前的 fps 值，建议非调试场合建议关闭 print 这个函数，它非常耗时（ms 级）。 ```python while True: while True: last time.ticks_ms() 1 while True: try: #time.sleep(0.1) print(1000 // (time.ticks_ms() last), 'fps') last time.ticks_ms() except Exception as e: gc.collect() print(e) finally: try: ui.display() except: pass ``` 然后我们加强一下环境的稳定性，加入看门狗的维持（protect.keep()）和 GC 内存回收（gc.collect()），还有维持一个全局的软定时器（system.parallel_cycle()），用作全局的定时器线程。 ```python if __name__ \"__main__\": container.reload(launcher) while True: while True: last time.ticks_ms() 1 while True: try: #time.sleep(0.1) print(1000 // (time.ticks_ms() last), 'fps') last time.ticks_ms() gc.collect() container.forever() system.parallel_cycle() protect.keep() #gc.collect() #print_mem_free() except KeyboardInterrupt: protect.stop() raise KeyboardInterrupt #except Exception as e: #gc.collect() #print(e) finally: try: ui.display() except: pass ``` 你可以通过 time.sleep(0.1) 来降低 UI 容器的执行速率来观察 UI 的变化状态是否符合预期，有时候高于 15 fps 的变化人眼感知不到，就可以减少不必要的绘图过程，压缩绘图过程提高性能。 你可以通过 except Exception as e: 来保证任何异常都不会导致 UI 框架的崩溃，但调试的时候可以把这个注释，来捕获可能出现的异常。 > 默认情况下程序超过 10 秒没有执行 protect.keep() 重置看门狗，则系统自动重启，这从 import wdt 驱动的时候就开始计时了，详细可以看 [driver/wdt.py](https://github.com/sipeed/MaixUI/tree/master/driver/wdt.py) 驱动。 最后再加入捕获 KeyboardInterrupt 异常事件来保证程序可以在 IDE 或 Ctrl + C 输入后，停下来并被重新运行，并停下看门狗事件（protect.stop()），同时还要在 finally 中试图执行 ui.display() 防止绘图事件中存在异常导致没有释放画布，保证 image 画布对象永远都能在循环的最后被释放。 ```python try: protect.keep() except KeyboardInterrupt: protect.stop() raise KeyboardInterrupt except Exception as e: gc.collect() print(e) finally: try: ui.display() except: pass ``` 以上就是 MaixUI 框架最基础的示范，虽然 MaixUI 只会提供 Cube 和 Amigo 的应用案例，但只要基于 MaixPy 均可使用，或者说，支持 image 接口对象的 MicroPython 环境均可使用。 希望我们未来能会同步到 CPython 共用的，也就是可以在 CPython 上进行 UI 样式的开发同步到 MicroPython 环境中，这会高效率的完成开发的，但性能也不能落下。 ### 最后 本文档介绍如何运行最基础的示例，如果想看更多示例，可以参考 [app_cube.py](https://github.com/sipeed/MaixUI/tree/master/app/app_cube.py) & [app_amigo.py](https://github.com/sipeed/MaixUI/tree/master/app/app_amigo.py) 两个案例。 > 截至目前 2020年10月7日 已经完成 MaixPy 的常见功能使用的 App 案例，不过这需要你亲自烧写一下体验看看了 XD ， 说明里只有一点简单的交互与动画展示。 目前 app_main.py 运行效果如下： ![](./image/app_main.gif)"},"/soft/maixpy/zh/course/others/system.html":{"title":"系统控制","content":" title: 系统控制 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy 系统控制 ## 复位（reset） ```python import machine machine.reset() ``` ## 主频（cpu） 可以设置 CPU 和 KPU 的主频， 具体参考[Maix.freq](./../../api_reference/Maix/freq.html)模块 ```python from Maix import freq freq.set(cpu 400, kpu 400) ```"},"/soft/maixpy/zh/course/others/mem.html":{"title":"内存管理","content":" title: 内存管理 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy 内存管理 在 MaixPy 中， 目前使用了两种内存管理， 一种是 GC（垃圾回收）， 另一种是系统堆内存， 两者同时存在。 比如：芯片有 6MiB 内存，加入固件使用了前面的 2MiB， 还剩 4MiB， 默认 `GC`使用 512KiB， 剩下的给系统堆内存管理。 * 在`mpy`层面写的代码， 变量都是存在`GC`管理的内存块中，比如定义一个变量`a [1,2,3,4]`, 如果`GC'`内存不足了， 会自动触发`gc.collect()`函数的执行， `GC`会自动把没有在使用了的变量给销毁，留出来空间给新的变量使用。 > `GC`使用`标记 清除`的方式进行内存回收，有兴趣可以看[这里](https://neucrack.com/p/46) * 因为`GC`要扫描内存， 如果除了程序占用的内存，剩下的都给`GC`，那每次扫描需要耗费大量时间，所以分成了两种内存。 堆内存由 `C`层面的代码控制，主要用于图片内存， AI内存， LCD 内存， 以及模型加载到内存等 `GC` 内存的总大小是可以设置的， 所以，根据具体的使用情况可以适当修改`GC`内存大小， 比如： * 为了加载更大的模型，可以把 `GC`内存设置小一点 * 如果分配新的变量提示内存不足， 可以适当将`GC`内存设置大一点即可 * 如果都不够了， 就要考虑缩减固件大小，或者优化代码了 设置`GC`内存大小示例： ```python from Maix import utils import machine print(utils.gc_heap_size()) utils.gc_heap_size(1024*1024) # 1MiB machine.reset() ``` 注意修改后需要重启生效 查看内存分配情况： ```python import gc print(gc.mem_free() / 1024) # stack mem import Maix print(Maix.utils.heap_free() / 1024) # heap mem ''' >>> raw REPL; CTRL B to exit >OK 352.0937 4640.0 > MicroPython v0.5.1 136 g039f72b6c dirty on 2020 11 18; Sipeed_M1 with kendryte k210 Type \"help()\" for more information. >>> ''' ```"},"/soft/maixpy/zh/course/others/lvgl.html":{"title":"lvgl","content":" title: lvgl keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy LittlevGL **现在已经不推荐使用该模块，请使用者具备足够的开发水平，不接收有关于 LVGL 与 AI 功能共用的问题，谢谢配合（2020年12月11日大佬鼠宣）** 请使用带有 LVGL 字样的 bin 固件进行操作。 参考官方文档： [lvgl blog page](https://lvgl.io/developers) ## 例程 参考 [github 的 MaixPy_Scripts](https://github.com/sipeed/MaixPy v1_scripts/tree/master/multimedia/gui/lvgl)"},"/soft/maixpy/zh/course/maixpy/demo_find_green_blob.html":{"title":"MaixPy 查找色块","content":" title: MaixPy 查找色块 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy MaixPy 查找色块 ## MaixPy 查找色块 ```python import sensor import image import lcd import time lcd.init(freq 15000000) sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) green_threshold (0, 80, 70, 10, 0, 30) while True: img sensor.snapshot() blobs img.find_blobs([green_threshold]) if blobs: for b in blobs: tmp img.draw_rectangle(b[0:4]) tmp img.draw_cross(b[5], b[6]) c img.get_pixel(b[5], b[6]) lcd.display(img) ```"},"/soft/maixpy/zh/course/image/image_counting-cells.html":{"title":"MaixPy 实现细胞计数","content":" title: MaixPy 实现细胞计数 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy MaixPy 实现细胞计数 > counting cells 实现细胞计数步骤: 原图——灰度图——腐蚀膨胀——二值化阈值——滤波操作 计数 ```python ```"},"/soft/maixpy/zh/course/image/find_color_blob.html":{"title":"MaixPy 查找色块","content":" title: MaixPy 查找色块 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy MaixPy 查找色块 找出图片中指定颜色所有色块 ## 使用方法 MaixPy 已经在 image 模块中实现有查找色块方法，需要使用非 minimum 固件版本。 * 从摄像头获取图片 ```python import image, sensor img sensor.snapshot() ``` * 从图片中查找所有色块对象(image.blob)列表, 传入的颜色阈值参数按照 LAB 格式(l_lo，l_hi，a_lo，a_hi，b_lo，b_hi) ```python green_threshold (0, 80, 70, 10, 0, 30) blobs img.find_blobs([green_threshold]) ``` * 操作色块对象 根据自己的需求操作色块对象, 例如将色块对象在图像中用矩形框标识出来 ```python tmp img.draw_rectangle(b[0:4]) ``` 详细 API 介绍请查看[API Image](../../api_reference/machine_vision/image/image.html). ## 例程 找绿色色块 ```python import sensor import image import lcd import time lcd.init() sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) green_threshold (0, 80, 70, 10, 0, 30) while True: img sensor.snapshot() blobs img.find_blobs([green_threshold]) if blobs: for b in blobs: tmp img.draw_rectangle(b[0:4]) tmp img.draw_cross(b[5], b[6]) c img.get_pixel(b[5], b[6]) lcd.display(img) ```"},"/soft/maixpy/zh/course/image/basic/get_images.html":{"title":"获得图像","content":" title: 获得图像 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy 获得图像 可以从摄像头获得图像，也可以从文件系统读取图片文件， 也可以从网络获取图片 ## 从摄像头获取 这部分已经在前面的教程有提过 ``` python import sensor, lcd sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) sensor.skip_frames() img sensor.snapshot() print(img) ``` * `import sensor`: 首先导入内置的`sensor`（摄像头）库 * `sensor.reset()`: 初始化摄像头，这里失败需要检查硬件 * `sensor.set_pixformat(sensor.RGB565)`: 设置摄像头为`RGB565`格式，默认都是用`RGB565`即可 * `sensor.set_framesize(sensor.QVGA)`: 分辨率为`QVGA`，即`320x240` * `sensor.run(1)`: 开始运行，在现在的版本中也可以不调用，在上面设置完成后，摄像头会自动开始运行 * `sensor.skip_frames()`: 摄像头刚启动时，图像质量还没稳定，所以跳过一些图像 * `sensor.snapshot()`:从摄像头取一帧图像数据，返回值是一张图像的对象 除了以上的函数， 你可能还需要设置图像为镜像（`hmirror`)，比如前置摄像头； 或者上下翻转(`vflip`)， 以及白平衡等等， 具体看 [sensor 模块的 API 手册](./../../../api_reference/machine_vision/sensor.html) ## 从文件读取 ```python import image img image.Image(\"/sd/test.jpg\") print(img) ``` 当然你也可以把图片保存到文件系统` ```python img.save(\"/sd/test2.jpg\", quality 95) ``` ## 从内存读取（或者网络读取） 可以先将文件读取到内存， 具体是从哪里读取的看你的应用了， 比如网络，或者串口 SPI 等等， 构造一个 `bytes`对象 ```python import image jpeg_buff b'\\xFF' # jpeg buffer img image.Image(jpeg_buff, from_bytes True) print(img) ``` ## 直接创建一个空白图像 ```python import image img image.Image(size (320, 240)) ``` 这张图片是全黑的空白图像"},"/soft/maixpy/zh/course/image/basic/vary.html":{"title":"基本图像变换 和 常用操作","content":" title: 基本图像变换 和 常用操作 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy 基本图像变换 和 常用操作 这里简单介绍一些经常用到的图像的基本变换操作 旋转： ```python img.rotation_corr() ``` 改变图像尺寸： ```python img.resize() ``` 更多的图像变换请看[image API](./../../../api_reference/machine_vision/image/image.html) ## 图像缓冲区介绍 MaixPy 为图像设计了两个缓冲区， * 一个是`RGB565`缓冲区，顾名思义， 是以`RGB565`的格式存放这图片的信息的一块内存。注意在内存中的排序是`[像素1 RGB, 像素2 RGB...]` * 另一个是`RGB888`缓冲区，顾名思义， 是以`RGB88`的格式存放这图片的信息的一块内存。注意在内存中的排序是`[所有像素 R, 所有像素 G， 所有像素 B]`, 我们也称之为`AI`内存 这里使用两个内存块主要的原因是底层代码所有图片操作以及`LCD`显示均是基于`RGB565`， 但是`KPU`又需要`RGB888`的输入。 ``` + + + + camera(sensor)+ + + + + v + + v + img.pix_to_ai() RGB565 + >+ RGB888 + + + + + + ^ v + + + + + + image ops KPU + + + + ``` 只有摄像头采集图片时，硬件会自动放一份数据到`RGB888`内存区域， 其它的都不会自动填充`RGB888`内存块， 软件操作只会对`RGB565`内存进行操作，不会自动更新`RGB888`，（因为更新需要消耗时间） 这很值得注意， 这意味着，每次我们用更改了`RGB565`内存块，比如执行了`img img.resize((224, 224))`，如果希望`KPU`使用更改过后的图片， 需要执行`img.pix_to_ai()`来将`RGB565`的图像手动更新到`RGB888`的区域，然后才可以调用`kpu`相关的函数进行模型推理！ 同样反方向更新也提供 API： `img.ai_to_pix()`， 这会将`RGB888`区域的数据更新到`RGB565`区域 ## resize 修改分辨率 ```python import image img image.Image(size (100, 100)) img2 img.resize(50, 50) print(img) print(img2) ``` ## 获取和修改像素值 ```python import image img image.Image(size (10, 10)) print(\"pixel 0:\", img[0], img.get_pixel(0, 0)) img[0] (255, 0, 0) img img.set_pixel(1, 0, (255, 255, 10)) print(\"after pixel 0 change:\", img[0], img[1]) ``` 这里设置的第二个像素点`B`为`10`， 实际发现读出来是`8`， 这是正常现象，因为前面说了，在内存中储存是用了`RGB565`进行储存，所以会有误差 ## 复制图像 ```python import image img image.Image(size (10, 10)) img2 img.copy() img2[0] (255, 0, 0) print(img[0], img2[0]) ``` ## 剪裁图像 同样使用`copy`函数 ```python import image img image.Image(size (10, 10)) img2 img.copy(roi (0, 0, 5, 5)) img2[0] (255, 0, 0) print(img) print(img2) print(img[0], img2[0]) ``` ## 转换成 bytes 对象 转换成 `RGB565` 字符串 ```python import image img image.Image(size (10, 10)) img[0] (255, 0, 0) img_bytes img.to_bytes() print(\"bytes length: %d bytes[0]: %x%x\" %(len(img_bytes), img_bytes[0], img_bytes[1])) ``` 这里输出的值为`RGB565`格式，以两个字节表示一个像素点储存 另外， 也可以先将图片压缩为 `JPEG` 格式，然后再转换成`bytes` ```python import image img image.Image(size (10, 10)) img img.compressed(quality 20) jpeg_bytes img.to_bytes() print(\"bytes length: %d bytes[0]: %x%x\" %(len(jpeg_bytes), jpeg_bytes[0], jpeg_bytes[1])) ``` 这里使用`compressed`函数不会修改原图， 使用`compress()`函数则会修改原图， 但是压缩后的大小如果比原图占用的空间还大，就会失败 ## 转换为灰度图像 ```python img img.to_grayscale(copy False) ``` 这里 `copy` 参数的意思就是是否要重新申请一片内存， 不修改原图的意思 ## 转换为 RGB565 彩图 转换为 彩图， 注意只是格式成为了彩图， 画面并不是彩图， 如果需要将灰度图转换为彩图，使用`img.to_rainbow()` ```python img img.to_rgb565(copy True) ``` 这里 `copy` 参数的意思就是是否要重新申请一片内存， 不修改原图的意思 如果原图是灰度图， 必须是`True` ## 转换为彩图 ```python img img.to_rainbow(copy True) ``` 这里 `copy` 参数的意思就是是否要重新申请一片内存， 不修改原图的意思 如果原图是灰度图， 必须是`True` ## 保存到文件系统 ```python img.save(\"/sd/test.jpg\", quality 95) img.save(\"/sd/test.bmp\") ``` ## 旋转 ```python img.rotation_corr([x_rotation 0.0[, y_rotation 0.0[, z_rotation 0.0[, x_translation 0.0[, y_translation 0.0[, zoom 1.0]]]]]]) ``` 中括号为可选参数，即沿着哪个轴旋转一定的角度， 如果`minimum`版本的固件里面没有这个函数， 可以用完全版本的固件"},"/soft/maixpy/zh/course/image/basic/acc_image_deal.html":{"title":"硬件加速的图像处理","content":" title: 硬件加速的图像处理 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy 硬件加速的图像处理 使用硬件替换某些软件部分， 可以让计算更加快速，已经做了加速优化的方法如下： 如下代码， 分别对图像进行了`边缘查找`，`锐化`，`浮雕化`， 利用了卷积计算快速得到结果。 ```python import sensor import image import lcd import time lcd.init(freq 15000000) sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) origin (0,0,0, 0,1,0, 0,0,0) edge ( 1, 1, 1, 1,8, 1, 1, 1, 1) sharp ( 1, 1, 1, 1,9, 1, 1, 1, 1) relievo (2,0,0,0, 1,0,0,0, 1) tim time.time() while True: img sensor.snapshot() img.conv3(edge) lcd.display(img) if time.time() tim >10: break tim time.time() while True: img sensor.snapshot() img.conv3(sharp) lcd.display(img) if time.time() tim >10: break tim time.time() while True: img sensor.snapshot() img.conv3(relievo) lcd.display(img) if time.time() tim >10: break lcd.clear() ```"},"/soft/maixpy/zh/course/image/basic/display_images.html":{"title":"显示图片","content":" title: 显示图片 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy 显示图片 显示图片很简单， 直接使用 `lcd` 模块，调用函数进行显示即可， 如下： ```python import lcd, image lcd.init() img image.Image(\"/sd/test.jpg\") lcd.display(img) ``` 但是不同的屏幕初始化序列可能不一样， 在`lcd.init`的时候有很多可选参数， 具体看 API 文档的描述，常见的如下 对于 IPS 屏幕，需要反色： ```python lcd.init(type 2) ``` 对于屏幕体质不是很好， 需要降低频率，或者体质很好需要超频： ```python lcd.init(freq 15000000) ``` 另外， 也可是设置屏幕的旋转方向： ```python lcd.rotation(2) ``` 参数是`0～3`, 分别代表顺时针旋转 `0度` `90度` `180度` `270度` 更多方法， 请参考 [lcd 文档](./../../../api_reference/machine_vision/lcd.html)"},"/soft/maixpy/zh/course/image/basic/draw.html":{"title":"画图 写字","content":" title: 画图 写字 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy 画图 写字 有两种方式，推荐第二种 ## 第一种， 使用`lcd`模块直接在屏幕上画 ```python import image, lcd lcd.init() lcd.draw_string(0, 0, \"hello\") ``` 更多的函数和参数，参见[lcd API 手册](./../../../api_reference/machine_vision/lcd.html) ## 第二种， 使用`image` 模块在内存中画，画完后使用`lcd.display`函数将整张图片展示到屏幕 ```python import image, lcd lcd.init() img image.Image(size (320, 240)) img.draw_string(0,0, \"hello\") lcd.display(img) ``` 更多的函数和参数，可以看 [image API 手册](./../../../api_reference/machine_vision/image/image.html) , 在页面搜索`image.draw` 可以找到所有画图函数 需要中文（多国语言）支持请看 [如何显示中文](./../../../course/image/image_draw_font/image_draw_font.html) ,或搜索 “字库” 。"},"/soft/maixpy/zh/api_reference/machine/pwm.html":{"title":"machine.PWM","content":" title: machine.PWM keywords: maixpy, k210, AIOT, 边缘计算, 深度学习, 人工智能 desc: maixpy machine.PWM PWM： 脉宽调制模块， 硬件支持的PWM， 可以指定任意引脚（0到47引脚） 每个 PWM 依赖于一个定时器， 即当定时器与 PWM 功能绑定后， 不能作为普通定时器使用了。 因为有 3 个定时器， 每个定时器有 4 个通道， 即最大可以同时产生 12 路 PWM 波形 ## 构造函数 ```python pwm machine.PWM(tim, freq, duty, pin, enable True) ``` 通过指定的参数新建一个 PWM 对象 ### 参数 * `tim`: 每个PWM依赖一个定时器来产生波形， 所以这里需要传一个定时器对象，这个定时器对象必须初始化时必须指定定时器 ID 和通道号 * `freq`： PWM 波形频率 * `duty`： PWM 占空比， 指高电平占整个周期的百分比，取值：[0,100] * `[pin]`： PWM 输出引脚。 可以不设置，而是使用 [fm](../builtin_py/fm.html) 统一管理引脚映射。 * `enable`： 是否立即开始产生波形，默认位`True`，及对象生成后立即开始在指定的引脚上产生 PWM 波形 ## 方法 ### init 类似构造函数 ```python pwm.init(tim, freq, duty, pin, enable True) ``` #### 参数 与构造函数相同 #### 返回值 无 ### freq 获取或者设置 PWM 频率 ```python pwm.freq(freq) ``` #### 参数 * `freq`： PWM 频率， 可选参数， 如果不传参数则步设置只返回当前频率值 #### 返回值 当前设置的实际的 PWM 频率 ### duty 获取或者设置 PWM 占空比 ```python pwm.duty(duty) ``` #### 参数 * `duty`： PWM 占空比 可选， 如果不传参数则步设置只返回当前占空比值 #### 返回值 当前设置的 PWM 占空比值 ### enable 使能 PWM 输出， 使指定的引脚上立即产生波形 ```python pwm.enable() ``` #### 参数 无 #### 返回值 无 ### disable 失能 PWM 输出， 指定的引脚不再产生波形 ```python pwm.disable() ``` #### 参数 无 #### 返回值 无 ### deinit/\\__del\\__ 注销 PWM 硬件，释放占用的资源，关闭 PWM 时钟 ```python pwm.deinit() ``` #### 参数 无 #### 返回值 无 #### 例子 ```python pwm.deinit() ``` 或者 ```python del pwm ``` ## 常量 无 ## 例程 ### 例程 1 （呼吸灯） > `board_info` 与板卡相关，不同板卡配置不同，使用前需要[手动配置](../builtin_py/board_info.html)。 ```python from machine import Timer,PWM import time from board import board_info tim Timer(Timer.TIMER0, Timer.CHANNEL0, mode Timer.MODE_PWM) ch PWM(tim, freq 500000, duty 50, pin board_info.LED_G) duty 0 dir True while True: if dir: duty + 10 else: duty 10 if duty>100: duty 100 dir False elif duty<0: duty 0 dir True time.sleep(0.05) ch.duty(duty) ``` ### 例程 2 > `board_info` 与板卡相关，不同板卡配置不同，使用前需要[手动配置](../builtin_py/board_info.html)。 ```python import time import machine from board import board_info tim machine.Timer(machine.Timer.TIMER0, machine.Timer.CHANNEL0, mode machine.Timer.MODE_PWM) ch0 machine.PWM(tim, freq 3000000, duty 20, pin board_info.LED_G, enable False) ch0.enable() time.sleep(3) ch0.freq(2000000) print(\"freq:\",ch0.freq()) ch0.duty(60) time.sleep(3) ch0.disable() ```"},"/soft/maixpy/zh/api_reference/machine/i2c.html":{"title":"machine.I2C","content":" title: machine.I2C keywords: maixpy, k210, AIOT, 边缘计算, 深度学习, 人工智能 desc: maixpy machine.I2C I2C 总线协议，简单地使用两条线（SCL，SDA）可以控制多个从机（主机模式）。 * 支持主机模式和从机模式 * 7 位/10 位寻址模式 * 标准模式 < 100Kb/s * 快速模式 < 400Kb/s * 超快速模式 < 1000Kb/s * 高速模式 3.4Mb/s ## 构造函数 ```python class machine.I2C(id, mode I2C.MODE_MASTER, scl None, sda None, gscl None, gsda None, freq 400000, timeout 1000, addr 0, addr_size 7, on_recieve None, on_transmit None, on_event None) ``` 通过指定的参数新建一个 I2C 对象 ### 参数 * `id`： I2C ID, [0~2] \\(I2C.I2C0~I2C.I2C2\\) [3~5] \\(I2C.I2C3~I2C.I2C5, I2C_SOFT\\) 是软模拟 I2C 的编号 * `mode`： 模式， 主机(`I2C.MODE_MASTER`)和从机（`I2C.MODE_SLAVE`)模式 * `scl`： SCL 引脚，直接传引脚编号即可，取值范围： [0,47]。 可以不设置，而是使用 [fm](../builtin_py/fm.html) 统一管理引脚映射。 * `sda`： SDA 引脚，直接传引脚编号即可，取值范围： [0,47]。 可以不设置，而是使用 [fm](../builtin_py/fm.html) 统一管理引脚映射。 * `gscl`: SCL 对应的 GPIOHS，使用软件模拟 I2C 时才需要传入，默认与 `scl` 相同。 * `gsda`: SDA 对应的 GPIOHS，使用软件模拟 I2C 时才需要传入，默认与 `sda` 相同 。 * `freq`： I2C通信频率， 支持标准100Kb/s, 快速400Kb/s， 以及更高速率（硬件支持超快速模式1000Kb/s，以及高速模式3.4Mb/s） * `timeout`： 超时时间，目前这个参数保留，设置无效 * `addr`： 从机地址，如果是主机模式不用设置， 从机模式则代表从机（本机）地址 * `addr_size`： 地址长度， 支持 7 位寻址和 10 位寻址， 取值`7`或者`10` * `on_recieve`： 从机模式的接收回调函数 * `on_transmit`： 从机模式的发送回调函数 * `on_event`： 从机模式的事件函数（开始事件和结束事件） ## 方法 ### init 类似构造函数 ```python i2c I2C.init(id, mode Timer.MODE_MASTER, scl, sda, gscl, gsda, freq 400000, timeout 1000, addr 0, addr_size 7, on_recieve None, on_transmit None, on_event None) ``` #### 参数 与构造函数相同 #### 返回值 无 ### scan 扫描I2C总线上的从机 ```python i2c.scan() ``` #### 参数 无 #### 返回值 list 对象， 包含了所有扫描到的从机地址 ### readfrom 从总线读取数据 ```python i2c.readfrom(addr, len, stop True) ``` #### 参数 * `addr`: 从机地址 * `len`： 数据长度 * `stop`： 是否产生停止信号，保留，目前只能使用默认值Ture #### 返回值 读取到的数据，`bytes` 类型 ### readfrom_into 读取数据并放到制定变量中 ```python i2c.readfrom_into(addr, buf, stop True) ``` #### 参数 * `addr`: 从机地址 * `buf`： `bytearray`类型， 定义了长度，读取到的数据存放在此 * `stop`： 是否产生停止信号，保留，目前只能使用默认值Ture #### 返回值 无 ### writeto 发送数据到从机 ```python i2c.writeto(addr, buf, stop True) ``` #### 参数 * `addr`: 从机地址 * `buf`： 需要发送的数据 * `stop`： 是否产生停止信号，保留，目前只能使用默认值Ture #### 返回值 成功发送的字节数 ### readfrom_mem 读取从机寄存器 ```python i2c.readfrom_mem(addr, memaddr, nbytes, mem_size 8) ``` #### 参数 * `addr`: 从机地址 * `memaddr`： 从机寄存器地址 * `nbytes`： 需要读取的长度 * `mem_size`： 寄存器宽度， 默认为8位 #### 返回值 返回`bytes`类型的读取到的数据 ### readfrom_mem_into 读取从机寄存器值到指定变量中 ```python i2c.readfrom_mem_into(addr, memaddr, buf, mem_size 8) ``` #### 参数 * `addr`: 从机地址 * `memaddr`： 从机寄存器地址 * `buf`： `bytearray`类型， 定义了长度，读取到的数据存放在此 * `mem_size`： 寄存器宽度， 默认为8位 #### 返回值 无 ### writeto_mem 写数据到从机寄存器 ```python i2c.writeto_mem(addr, memaddr, buf, mem_size 8) ``` #### 参数 * `addr`: 从机地址 * `memaddr`： 从机寄存器地址 * `buf`： 需要写的数据 * `mem_size`： 寄存器宽度， 默认为8位 #### 返回值 无 ### deinit/\\__del\\__ 注销I2C硬件，释放占用的资源，关闭I2C时钟 ```python i2c.deinit() ``` #### 参数 无 #### 返回值 无 #### 例子 ```python i2c.deinit() ``` 或者 ```python del i2c ``` ## 常量 * `I2C0`: I2C 0 * `I2C1`: I2C 1 * `I2C2`: I2C 2 * `MODE_MASTER`: 作为主机模式 * `MODE_SLAVE`: 作为从机模式 * `I2C_EV_START`: 事件类型，开始信号 * `I2C_EV_RESTART`: 事件类型，重新开始信号 * `I2C_EV_STOP`: 事件类型，结束信号 ## 例程 ### 例程 1： 扫描从机设备 ```python from machine import I2C i2c I2C(I2C.I2C0, freq 100000, scl 28, sda 29) devices i2c.scan() print(devices) ``` ### 例程 2： 读写 ```python import time from machine import I2C i2c I2C(I2C.I2C0, freq 100000, scl 28, sda 29) i2c.writeto(0x24,b'123') i2c.readfrom(0x24,5) ``` ### 例程 3： 从机模式 ```python from machine import I2C count 0 def on_receive(data): print(\"on_receive:\",data) def on_transmit(): count count+1 print(\"on_transmit, send:\",count) return count def on_event(event): print(\"on_event:\",event) i2c I2C(I2C.I2C0, mode I2C.MODE_SLAVE, scl 28, sda 29, addr 0x24, addr_size 7, on_receive on_receive, on_transmit on_transmit, on_event on_event) ``` ### 例程 4： OLED(ssd1306 128x64) ```python import time from machine import I2C SSD1306_CMD 0 SSD1306_DATA 1 SSD1306_ADDR 0x3c def oled_init(i2c): i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xAE, mem_size 8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x20, mem_size 8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x10, mem_size 8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xb0, mem_size 8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xc8, mem_size 8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x00, mem_size 8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x10, mem_size 8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x40, mem_size 8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x81, mem_size 8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xff, mem_size 8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xa1, mem_size 8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xa6, mem_size 8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xa8, mem_size 8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x3F, mem_size 8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xa4, mem_size 8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xd3, mem_size 8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x00, mem_size 8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xd5, mem_size 8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xf0, mem_size 8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xd9, mem_size 8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x22, mem_size 8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xda, mem_size 8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x12, mem_size 8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xdb, mem_size 8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x20, mem_size 8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x8d, mem_size 8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x14, mem_size 8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xaf, mem_size 8) def oled_on(i2c): i2c.writeto_mem(SSD1306_ADDR, 0x00, 0X8D, mem_size 8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0X14, mem_size 8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0XAF, mem_size 8) def oled_off(i2c): i2c.writeto_mem(SSD1306_ADDR, 0x00, 0X8D, mem_size 8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0X10, mem_size 8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0XAE, mem_size 8) def oled_fill(i2c, data): for i in range(0,8): i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xb0+i, mem_size 8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x10, mem_size 8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x01, mem_size 8) for j in range(0,128): i2c.writeto_mem(SSD1306_ADDR, 0x40, data, mem_size 8) i2c I2C(I2C.I2C0, mode I2C.MODE_MASTER, freq 400000, scl 28, sda 29, addr_size 7) time.sleep(1) oled_init(i2c) oled_fill(i2c, 0xff) ```"},"/soft/maixpy/zh/api_reference/machine/machine.html":{"title":"machine","content":" title: machine keywords: maixpy, k210, AIOT, 边缘计算, 深度学习, 人工智能 desc: maixpy machine ## unique_id"},"/soft/maixpy/zh/api_reference/machine/timer.html":{"title":"machine.Timer","content":" title: machine.Timer keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy machine.Timer 硬件定时器，可以用来定时触发任务或者处理任务，设定时间到了后可以触发中断（调用回调函数），精度比软件定时器高。 需要注意的是，定时器在不同的硬件中可能会有不同的表现。MicroPython 的 Timer 类定义了在给定时间段内（或在一段延迟后执行一次回调）执行回调的基本操作，并允许特定的硬件上定义更多的非标准行为（因此不能移植到其他板）。 共有 3 个定时器， 每个定时器有 4 个通道可以使用 ## 构造函数 ```python tim machine.Timer(id, channel, mode Timer.MODE_ONE_SHOT, period 1000, unit Timer.UNIT_MS, callback None, arg None, start True, priority 1, div 0) ``` 通过指定的参数新建一个 Timer 对象 ### 参数 * `id`: Timer ID, [0~2] \\(Timer.TIMER0~TIMER2\\) * `channel`: Timer 通道, [Timer.CHANNEL0~Timer.CHANNEL3] * `mode`: Timer 模式, `MODE_ONE_SHOT` 或者 `MODE_PERIODIC` 或者 `MODE_PWM` * `period`: Timer 周期, 在启动定时器后 `period` 时间， 回调函数将会被调用，(0,~) * `unit`: 设置周期的单位，默认位毫秒（`ms`），`Timer.UNIT_S` 或者 `Timer.UNIT_MS` 或者 `Timer.UNIT_US` 或者`Timer.UNIT_NS` * `callback`: 定时器回调函数， 定义了两个参数， 一个是定时器对象`Timer`， 第二个是在定义对象是希望传的参数`arg`，更多请看`arg`参数解释 > 注意：回调函数是在中断中调用的，所以在回调函数中请不要占用太长时间以及做动态分配开关中断等动作 * `arg`: 希望传给回调函数的参数，作为回调函数的第二个参数 * `start`: 是否在对象构建成功后立即开始定时器， `True`：立即开始， `False`:不立即开启，需要调用`start()`函数来启动定时器 * `priority`: 硬件定时器中断优先级， 与特定的CPU相关， 在K210中，取值范围是[1,7]， 值越小优先级越高 * `div`: 硬件定时器分频器，取值范围[0,255]， 默认为0， clk_timer（定时器时钟频率） clk_pll0（锁相环0频率）/2^(div+1) > clk_timer*period(unit:s) 应该 < 2^32 并且 > 1 ## 方法 ### init 类似构造函数 ```python tim.init(id, channel, mode Timer.MODE_ONE_SHOT, period 1000, unit Timer.UNIT_MS, callback None, arg None, start True, priority 1, div 0) ``` #### 参数 类似构造函数 #### 返回值 无 ### callback_arg 获取设置的传给回调函数的参数，只能是 `Timer` 对象调用， 类 `Timer` 不能调用 ### callback 获取或者设置回调函数 ```python tim.callback(callback) ``` #### 参数 * `callback`： 设置的回调函数，可选参数， 如果不传参数，则只返回先有的回调函数 #### 返回值 当前的回调函数 #### 例子 ```python def on_timer(timer): print(\"time up:\",timer) print(\"param:\",timer.callback_arg()) tim.callback(on_timer) print(on_timer, tim.callback()) ``` ### period 获取或者设置定时周期 ```python tim.period(period) ``` #### 参数 * `period`： 可选参数，配置周期， 如果不传参数， 则只返回当前周期值 #### 返回值 当前周期值 #### 例子 ```python tim.period(2000) print( tim.period() ) ``` ### start 启动定时器 ```python tim.start() ``` #### 参数 无 #### 返回值 无 #### 例子 ```python tim.start() ``` ### stop 停止定时器 ```python tim.stop() ``` #### 参数 无 #### 返回值 无 ### restart 重新开启定时器 ```python tim.restart() ``` #### 参数 无 #### 返回值 无 ### deinit/\\__del\\__ 注销定时器，并且注销硬件的占用，关闭硬件的时钟 ```python tim.deinit() ``` #### 参数 无 #### 返回值 无 #### 例子 ```python tim.deinit() ``` 或者 ```python del tim ``` ## 常量 * `TIMER0`: Timer0 id * `TIMER1`: Timer1 id * `TIMER2`: Timer2 id * `CHANNEL0`: Timer 通道 0 * `CHANNEL1`: Timer 通道 1 * `CHANNEL2`: Timer 通道 2 * `CHANNEL3`: Timer 通道 3 * `MODE_ONE_SHOT`: Timer 只运行一次（回调一次） * `MODE_PERIODIC`: Timer 始终运行（连续回调） * `MODE_PWM`: 定时器不用来回调函数，用以产生PWM * `UNIT_S`: 单位秒 (s) * `UNIT_MS`: 单位毫秒 (ms) * `UNIT_US`: 单位微秒 (us) * `UNIT_NS`: 单位纳秒 (ns) ## 例程 ### 例程 1 定时3秒后打印信息 ```python from machine import Timer def on_timer(timer): print(\"time up:\",timer) print(\"param:\",timer.callback_arg()) tim Timer(Timer.TIMER0, Timer.CHANNEL0, mode Timer.MODE_ONE_SHOT, period 3000, callback on_timer, arg on_timer) print(\"period:\",tim.period()) ``` ### 例程 2 每隔 1 秒打印消息， 停止 5 秒后再重启， 5 秒后关闭并注销定时器 ```python import time from machine import Timer def on_timer(timer): print(\"time up:\",timer) print(\"param:\",timer.callback_arg()) tim Timer(Timer.TIMER0, Timer.CHANNEL0, mode Timer.MODE_PERIODIC, period 1, unit Timer.UNIT_S, callback on_timer, arg on_timer, start False, priority 1, div 0) print(\"period:\",tim.period()) tim.start() time.sleep(5) tim.stop() time.sleep(5) tim.restart() time.sleep(5) tim.stop() del tim ```"},"/soft/maixpy/zh/api_reference/machine/network.html":{"title":"network","content":" title: network keywords: maixpy, k210, AIOT, 边缘计算, 深度学习, 人工智能 desc: maixpy network 该模块用于初始化各种网卡驱动，网卡具有连接路由，断开路由，查看网卡连接信息，检查是否连接等功能。 使用`WiFi`请确保已经接上了天线 **esp8285** 在部分开发板上带了 一个 使用`AT`方式交互的网卡模块，比如`esp8285`，与`k210`通过串口连接 引脚`8`是使能脚，可以创建一个`GPIO`对象来控制它的高低电平来实现使能和失能，也可以用它复位（先低后高），复位后需要等待一小段时间才能操作，可以查看例程[network_espat.py](https://github.com/sipeed/MaixPy v1_scripts/blob/79a5485ec983e67bb8861305a52418b29e0dc205/network/network_espat.py) **esp32** 目前在`MaixDuino`开发板中有一个 `esp32` 模块通过 `spi` 与`k210`相连，同时也有单独的`TF`插卡式模块 ## network.ESP8285(uart) 构造一个`ESP8285`网卡对象，使用该方法需要传入一个`uart`对象，在`MaixPy`目前支持的`dock`和`GO`上，是使用AT指令模块作为`WiFi`。所以该`uart`对象是与`AT`模块通信的对象，可以查看`uart`模块例程 调用此方法会初始化`ESP8285`， 如果失败会抛出异常 ### 参数 * `uart`: 与AT模块通信的UART对象 ### 返回值 * `ESP8285`: 网卡对象 ## ESP8285 ### connect(ssid, key) 连接热点（AP/路由器） #### 参数 * `ssid`: 热点的`SSID` * `key`: 热点的密码 #### 返回值 无， 如果发生错误会抛出异常 ### 2.2. ifconfig() 查看wifi连接信息，目前network不支持设置网卡配置 ``` nic.ifconfig() ``` #### 参数 无 #### 返回值 `tuple` 类型， 元素都是字符串：`(ip, netmask, gateway, dns_server, dhcp_server, mac, ssid)`， 如果没有查询到或者无效，值为`\"0\"` ### isconnected() 查看wifi是否连接 ``` nic.isconnected() ``` #### 参数 无 #### 返回值 `True`: 已经连接 `False`: 断开连接 ### disconnect() 断开 wifi 连接 #### 参数 无 #### 返回值 无 ### scan() 扫描周围的热点信息 #### 参数 无 #### 返回值 一个 `list`对象， 每个元素包含了一个字符串， 字符串来自`AT`模块的响应，内容和`esp8285`的`AT指令文档`所描述的相同，如下： `ecn, ssid, rssi,mac, channel, freq\toffset, freq cali, pairwise_cipher, group_cipher, bgn, wps` * `ecn`：加密⽅式 * 0：OPEN * 1：WEP * 2：WPA_PSK * 3：WPA2_PSK * 4：WPA_WPA2_PSK * 5：WPA2_Enterprise（⽬前 AT 不⽀持连接这种加密 AP） * `ssid`：字符串参数，AP 的 SSID * `rssi`：信号强度 * `mac`：字符串参数，AP 的 MAC 地址 * `channel`：信道号 * `freq offset`：AP 频偏，单位：kHz。此数值除以 2.4，可得到 ppm 值 * `freq\tcali`：频偏校准值 * `pairwise_cipher`: * 0：CIPHER_NONE * 1：CIPHER_WEP40 * 2：CIPHER_WEP104 * 3：CIPHER_TKIP * 4：CIPHER_CCMP * 5：CIPHER_TKIP_CCMP * 6：CIPHER_UNKNOWN * `group_cipher`: 定义与 `pairwise_cipher` 相同 * `bgn`: bit0 代表 b 模式; bit1 代表 g 模式; bit2 代表 n 模式 若对应 bit 为 1，表示该模式使能；若对应 bit 为 0，则该模式未使能。 * `wps`：0，WPS 未使能；1，WPS 使能 比如： ``` info_strs ['4,\"ChinaNet lot0\", 79,\"c8:50:e9:e8:21:3e\",1, 42,0,4,3,7,1', '4,\"TOPSTEP2G4\", 7 0,\"f8:e7:1e:0d:0d:f8\",1, 57,0,4,4,7,0'] ``` 这看起来可能会比较奇怪，因为每个AP的信息都是一串字符，信息里面还有整型和字符串，字符串用双引号括起来的，所以拿到这个字符串后需要再次处理后再使用，比如： ```python def wifi_deal_ap_info(info): res [] for ap_str in info: ap_str ap_str.split(\",\") info_one [] for node in ap_str: if node.startswith('\"'): info_one.append(node[1: 1]) else: info_one.append(int(node)) res.append(info_one) return res info_strs ['4,\"ChinaNet lot0\", 79,\"c8:50:e9:e8:21:3e\",1, 42,0,4,3,7,1', '4,\"TOPSTEP2G4\", 70,\"f8:e7:1e:0d:0d:f8\",1, 57,0,4,4,7,0'] info wifi_deal_ap_info(info_strs) print(info) ``` 输出是： ``` [[4, 'ChinaNet lot0', 79, 'c8:50:e9:e8:21:3e', 1, 42, 0, 4, 3, 7, 1], [4, 'TOPSTEP2G4', 70, 'f8:e7:1e:0d:0d:f8', 1, 57, 0, 4, 4, 7, 0]] ``` 然后比如我们需要获得所有`AP`的`SSID`只需要使用 ``` for ap_info in info: print(ap_info[1]) ``` ### enable_ap(ssid, key, chl 5, ecn 3) * **警告：截止 2020年11月26日前， MaixPy 的 socket 还未实现 listen / bind / accpet 等函数操作。** 打开热点 #### 参数 * `ssid`: SSID * `key`： 密码 * `chl`： WiFi信号的通道号 * `ecn`： 加密方法， 有`OPEN``WPA2_PSK`等，参考本页`ESP8285`的常量部分， 默认值是`3`， 也就是`ESP8285.WPA2_PSK`，比如 ```python nic network.ESP8285(uart) nic.enable_ap(\"maixpy\", \"12345678\", 5, nic.OPEN) ``` 或者 ``` nic.enable_ap(\"maixpy\", \"12345678\", 5, network.ESP8285.OPEN) ``` ### disable_ap() 关闭热点 ### 常量 #### OPEN 热点的加密方式为不需要密码 #### WPA_PSK 热点的加密方式为 `WPA_PSK` #### WPA2_PSK 热点的加密方式为 `WPA2_PSK` #### WPA_WPA2_PSK 热点的加密方式为 `WPA_WPA2_PSK` ## 例程 参考[network目录下的例程](https://github.com/sipeed/MaixPy v1_scripts/tree/master/network) ## network.ESP32_SPI(cs,rst,rdy,mosi,miso,sclk) 构造一个`ESP32_SPI`网卡对象，需要传入对应的`GPIOHS FUNC` 如果传入参数数量不对，会返回错误 **注意** 想要在 maixduino 上 SPI 和 SD 不冲突，需要设置 ESP32_SPI 为硬件 SPI 配置。 ### 参数 * 对应引脚功能的 `fpioa_func` ### 返回值 * `ESP32_SPI` 网卡对象 ## ESP32_SPI ### adc 读取`esp32`模块的`adc`值 #### 参数 无 #### 返回值 `tunple`，5个通道的`adc`值<br>顺序是`\"PIN36\", \"PIN39\", \"PIN34\", \"PIN35\", \"PIN32\"` #### 例程 [demo_esp32_read_adc.py](https://github.com/sipeed/MaixPy v1_scripts/blob/master/network/demo_esp32_read_adc.py) ## network.WIZNET5K(spi, cs) 构造一个`WIZNET5K`网卡对象，使用该方法需要传入一个`spi`对象， 一个`cs` pin 脚. 调用此方法会初始化`WIZNET5K`， 如果失败会抛出异常 ### 参数 * `spi`: 负责与 WIZNET5K 模块通信 * `cs`: spi 通信片选脚 ### 返回值 * `WIZNET5K`: 网卡对象 ## WIZNET5K ### dhclient DHCP 动态获取 IP ``` nic.dhclient() ``` #### 参数 无 #### 返回值 * `True`: 获取成功 * `False`: 获取失败 ### ifconfig ``` nic.ifconfig() ``` #### 参数 * 不传参: 查询网卡信息 * 传入`(ip, netmask, gateway, dns_server)`字符串元组: 配置网卡, `ip` ip 地址, `netmask`子网掩码, `gateway`网关 IP 地址, `dns_server` DNS 服务 IP 地址. #### 返回值 * 不传参: 返回`tuple`，元素都是字符串, `(ip, netmask, gateway, dns_server)`， 如果没有查询到或者无效，值为`\"0\"` * 传参: 返回`None` ### isconnected 查看网络是否连接 ``` nic.isconnected() ``` #### 参数 无 #### 返回值 * `True`: 已经连接 * `False`: 断开连接 #### 例程 [network_wiznet5k.py](https://github.com/sipeed/MaixPy v1_scripts/blob/master/network/network_wiznet5k.py)"},"/soft/maixpy/zh/api_reference/machine/index.html":{"title":"machine","content":" title: machine keywords: maixpy, k210, AIOT, 边缘计算, 深度学习, 人工智能 desc: maixpy machine machine 库主要包含了与硬件相关的各种接口，如下： * [I2C](./i2c.html) * [SPI](./spi.html) * [Timer](./timer.html) * [PWM](./pwm.html) * [UART](./uart.html) ## 方法 machine.unique_id() 获取唯一 ID ### 返回值 32 字节的唯一ID ## 方法 machine.reset() 重启"},"/soft/maixpy/zh/api_reference/machine/uart.html":{"title":"machine.UART","content":" title: machine.UART keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy machine.UART uart 模块主要用于驱动开发板上的异步串口，可以自由对 uart 进行配置。k210 一共有3个 uart，每个 uart 可以进行自由的引脚映射。 ## 构造 ### 引脚映射 在使用 uart 前，我们需要使用 fm 来对芯片引脚进行映射和管理。如下所示，将 PIN10 设置为 uart2 的发送引脚，PIN11 设置为 uart2 的接收引脚 ``` fm.register(board_info.PIN10,fm.fpioa.UART2_TX) fm.register(board_info.PIN11,fm.fpioa.UART2_RX) ``` ### 构造函数 ``` uart machine.UART(uart,baudrate,bits,parity,stop,timeout, read_buf_len) ``` 通过指定的参数新建一个 UART 对象 #### 参数 * `uart` UART 号，使用指定的 UART，可以通过 `machine.UART.` 按tab键来补全 * `baudrate`: UART 波特率 * `bits`: UART 数据宽度，支持 `5/6/7/8` (默认的 REPL 使用的串口（UARTHS）只支持 8 位模式)， 默认 `8` * `parity`: 奇偶校验位，支持 `None`, `machine.UART.PARITY_ODD`, `machine.UART.PARITY_EVEN` （默认的 REPL 使用的串口（UARTHS）只支持 None）， 默认 `None` * `stop`: 停止位， 支持 `1`， `1.5`, `2`， 默认 `1` * `timeout`: 串口接收超时时间 * `read_buf_len`： 串口接收缓冲，串口通过中断来接收数据，如果缓冲满了，将自动停止数据接收 #### 返回值 * UART对象 ## 方法 ### init 用于初始化 uart，一般在构造对象时已经初始化，这里用在重新初始化 uart ``` uart.init(baudrate,bits,parity,stop,timeout, read_buf_len) ``` #### 参数 同构造函数，但不需要第一个UART号 #### 返回值 无 ### read 用于读取串口缓冲中的数据 ``` uart.read(num) ``` #### 参数 * `num`: 读取字节的数量，一般填入缓冲大小，如果缓冲中数据的数量没有 `num` 大，那么将只返回缓冲中剩余的数据 #### 返回值 * `bytes`类型的数据 ### readline 用于读取串口缓冲数据的一行 ``` uart.readline(num) ``` * `num`: 读取行的数量 #### 返回值 *`bytes`类型的数据 ### write 用于使用串口发送数据 ``` uart.write(buf) ``` #### 参数 * `buf`: 需要发送到数据 #### 返回值 * 写入的数据量 ### deinit 注销 UART 硬件，释放占用的资源 ``` uart.deinit() ``` #### 参数 无 #### 返回值 无 ### repl_uart() 获取用于 REPL 的串口对象 #### 返回值 用于 REPL 的串口对象， 默认初始化位 `115200 8 N 1` ## 例程 ### 例程 1 在运行例程之前，请确认 `PIN4` 已经连接到 `PIN10`， `PIN3` 已经连接到 `PIN11` 运行程序后，可以在终端看到 `baudrate:115200 bits:8 parity:0 stop:0 check Successfully` 的打印信息 > 以下例程对于Bit开发是不能直接进行使用，需要修改对应可用的PIN脚，可自行尝试 ```python from machine import UART from board import board_info from fpioa_manager import fm # maixduino board_info PIN10/PIN11/PIN12/PIN13 or other hardware IO 10/11/4/3 fm.register(board_info.PIN10, fm.fpioa.UART1_TX, force True) fm.register(board_info.PIN11, fm.fpioa.UART1_RX, force True) fm.register(board_info.PIN3, fm.fpioa.UART2_TX, force True) fm.register(board_info.PIN4, fm.fpioa.UART2_RX, force True) uart_A UART(UART.UART1, 115200, 8, 0, 0, timeout 1000, read_buf_len 4096) uart_B UART(UART.UART2, 115200, 8, 0, 0, timeout 1000, read_buf_len 4096) write_str 'hello world' for i in range(20): uart_A.write(write_str) read_data uart_B.read() if read_data: read_str read_data.decode('utf 8') print(\"string \", read_str) if read_str write_str: print(\"baudrate:115200 bits:8 parity:0 stop:0 check Successfully\") uart_A.deinit() uart_B.deinit() del uart_A del uart_B ``` ### 例程 2 AT模块串口 > 以下例程对于Bit开发是不能直接进行使用，需要修改对应可用的PIN脚，可自行尝试 ```python fm.register(board_info.WIFI_RX,fm.fpioa.UART2_TX) fm.register(board_info.WIFI_TX,fm.fpioa.UART2_RX) uart machine.UART(machine.UART.UART2,115200,timeout 1000, read_buf_len 4096) ``` ### 例程 3 修改 REPL 串口波特率 > 以下例程对于Bit开发是不能直接进行使用，需要修改对应可用的PIN脚，可自行尝试 ```python from machine import UART repl UART.repl_uart() repl.init(1500000, 8, None, 1, read_buf_len 2048) ``` ### 例程 3 修改 REPL 串口 > 以下例程对于Bit开发是不能直接进行使用，需要修改对应可用的PIN脚，可自行尝试 ```python from machine import UART fm.register(board_info.PIN15,fm.fpioa.UART1_TX) fm.register(board_info.PIN17,fm.fpioa.UART1_RX) uart machine.UART(UART.UART1, 115200) UART.set_repl_uart(uart) ```"},"/soft/maixpy/zh/api_reference/machine/spi.html":{"title":"machine.SPI","content":" title: machine.SPI keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy machine.SPI SPI（Serial Peripheral Interface） 是一个同步串行协议，由主机和从机组成。 标准4线模式由 SCK（SCLK）， CS（片选）， MOSI， MISO 4条线连接主从机 在 K210 上， SPI 有一下特征： * 共有 4 个 SPI 设备， 其中 SPI0 、SPI1、 SPI3 只能工作在主机模式下， SPI2 只能工作在从机模式时下， 在 MaixPy 上， SPI3 已经用来连接了 SPI Flash 作为保留硬件资源。 * 支持 1/2/4/8 线全双工模式， 在 MaixPy 中， 目前只支持标准（摩托罗拉）4线全双工模式（即 SCK， MOSI， MISO， CS 四个引脚） * 最高传输速率 45M：1/2主频，约 200Mbps * 支持 DMA * 4个可配置任意引脚的硬件片选 ## 构造函数 ```python spi machine.SPI(id, mode SPI.MODE_MASTER, baudrate 500000, polarity 0, phase 0, bits 8, firstbit SPI.MSB, sck, mosi, miso, cs0, cs1, cs2, cs3) ``` 通过指定的参数新建一个 SPI 对象 ### 参数 * `id`： SPI ID， 取值范围[0,4]， 目前只支持 0 和 1 、4 ， 并且只能是主机模式， 2 只能作为从机，目前未实现， 3 保留, 4 使用软模拟 SPI（.SPI_SOFT） * `mode`： SPI 模式， `MODE_MASTER` 或者`MODE_MASTER_2`或者`MODE_MASTER_4`或者`MODE_MASTER_8`或者`MODE_SLAVE`， 目前只支持`MODE_MASTER` * `baudrate`： SPI 波特率（频率） * `polarity`： 极性， 取值为 0 或 1， 表示 SPI 在空闲时的极性， 0 代表低电平， 1 代表高电平 * `phase`： 相， 取值位 0 或 1， 表示在时钟的第一个还是第二个跳变沿采集数据， 0 表示第一个， 1 表示第二个 * `bits`： 数据宽度， 默认值为8， 取值范围[4,32] * `firstbit`： 指定传输采用 MSB 还是 LSB 顺序传输， 默认 `SPI.MSB` * `sck`: SCK（时钟）引脚， 可直接传引脚数值，取值范围：[0,47]。 可以不设置，而是使用 [fm](../builtin_py/fm.html) 统一管理引脚映射。 * `mosi`: MOSI（主机输出） 引脚， 可直接传引脚数值，取值范围：[0,47]。 可以不设置，而是使用 [fm](../builtin_py/fm.html) 统一管理引脚映射。 * `miso`: MISO（主机输入） 引脚， 可直接传引脚数值，取值范围：[0,47]。 可以不设置，而是使用 [fm](../builtin_py/fm.html) 统一管理引脚映射。 * `cs0`: CS0（片选） 引脚， 可直接传引脚数值，取值范围：[0,47]。 可以不设置，而是使用 [fm](../builtin_py/fm.html) 统一管理引脚映射。 * `cs1`: CS1（片选） 引脚， 可直接传引脚数值，取值范围：[0,47]。 可以不设置，而是使用 [fm](../builtin_py/fm.html) 统一管理引脚映射。 * `cs2`: CS2（片选） 引脚， 可直接传引脚数值，取值范围：[0,47]。 可以不设置，而是使用 [fm](../builtin_py/fm.html) 统一管理引脚映射。 * `cs3`: CS3（片选） 引脚， 可直接传引脚数值，取值范围：[0,47]。 可以不设置，而是使用 [fm](../builtin_py/fm.html) 统一管理引脚映射。 * `d0~d7`： 数据引脚， 在非标准4线模式中使用，目前保留。 可以不设置，而是使用 [fm](../builtin_py/fm.html) 统一管理引脚映射。 ## 方法 ### init 类似构造函数 ```python spi.init(id, mode SPI.MODE_MASTER, baudrate 500000, polarity 0, phase 0, bits 8, firstbit SPI.MSB, sck, mosi, miso, cs0) ``` #### 参数 与构造函数相同 #### 返回值 无 ### read 读取数据 ```python spi.read(nbytes, write 0x00, cs SPI.CS0) ``` #### 参数 * `nbytes`： 需要读取的长度 * `cs`： 选择片选引脚， 在初始化时已经为`cs0`~`cs3`设置了引脚，这里只需要选择`SPI.CS0`~`SPI.CS3`即可，默认为`SPI.CS0` * `write`： 因为是全双工，设置在读取时`MOSI`引脚的值，默认为`0x00`，即始终为低电平 #### 返回值 `bytes`类型的数据 ### readinto 读取数据，并放到指定变量中 ```python spi.readinto(buf, write 0x00, cs SPI.CS0) ``` #### 参数 * `buf`： `bytearray` 类型， 定义了长度，读取完成后数据保存在此 * `cs`： 选择片选引脚， 在初始化时已经为`cs0`~`cs3`设置了引脚，这里只需要选择`SPI.CS0`~`SPI.CS3`即可，默认为`SPI.CS0` * `write`： 因为是全双工，设置在读取时`MOSI`引脚的值，默认为`0x00`，即始终为低电平 #### 返回值 无 ### write 发送数据 ```python spi.write(buf, cs SPI.CS0) ``` #### 参数 * `buf`： `bytearray` 类型， 定义了数据及长度 * `cs`： 选择片选引脚， 在初始化时已经为`cs0`~`cs3`设置了引脚，这里只需要选择`SPI.CS0`~`SPI.CS3`即可，默认为`SPI.CS0` #### 返回值 无 ### write_readinto 发送数据，同时读取数据到变量，即全双工 ```python spi.write(write_buf, read_buf, cs SPI.CS0) ``` #### 参数 * `write_buf`： `bytearray` 类型， 定义了需要发送的数据及长度 * `read_buf`： `bytearray` 类型， 定义了接收数据存放的位置 * `cs`： 选择片选引脚， 在初始化时已经为`cs0`~`cs3`设置了引脚，这里只需要选择`SPI.CS0`~`SPI.CS3`即可，默认为`SPI.CS0` #### 返回值 无 ### deinit/\\__del\\__ 注销 SPI，释放硬件，关闭 SPI 时钟 ```python spi.deinit() ``` #### 参数 无 #### 返回值 无 #### 例子 ```python spi.deinit() ``` 或者 ``` del spi ``` ## 常量 * `SPI0`: SPI 0 * `SPI1`: SPI 1 * `SPI2`: SPI 2 * `MODE_MASTER`: 作为主机模式 * `MODE_MASTER_2`: 作为主机模式 * `MODE_MASTER_4`: 作为主机模式 * `MODE_MASTER_8`: 作为主机模式 * `MODE_SLAVE`: 作为从机模式 * `MSB`： MSB， 即先发送高位或高字节 * `LSB`： LSB， 即先发送低位或者低字节 * `CS0`： 片选0 * `CS1`： 片选1 * `CS2`： 片选2 * `CS3`： 片选3 ## 例程 ### 例程 1： 基本读写 ```python from machine import SPI spi SPI(SPI.SPI1, mode SPI.MODE_MASTER, baudrate 10000000, polarity 0, phase 0, bits 8, firstbit SPI.MSB, sck 28, mosi 29, miso 30, cs0 27) w b'1234' r bytearray(4) spi.write(w) spi.write(w, cs SPI.CS0) spi.write_readinto(w, r) spi.read(5, write 0x00) spi.readinto(r, write 0x00) ```"},"/soft/maixpy/zh/api_reference/machine/wdt.html":{"title":"machine.WDT","content":" title: machine.WDT keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy machine.WDT MaixPy 的 WDT 看门狗模块，用于在应用程序崩溃且最终进入不可恢复状态时重启系统。一旦开始，当硬件运行期间没有定期进行喂狗（feed）就会在超时后自动复位。 ## 构造函数 ```python from machine import WDT wdt0 WDT(id 1, timeout 4000, callback on_wdt, context {}) ``` 通过指定的参数新建一个 WDT 对象 ### 参数 * `id`: 这个看门狗对象必须初始化时必须指定 ID （0 ~ 2） 用于区分使用的看门狗。 * `timeout`： 看门狗超时时间，单位为毫秒（ms）。 * `callback`: （可选）可以在超时后执行的回调函数。 * `context`： （可选）为回调函数传递的参数。 ## 方法 ### feed “喂养”看门狗，以防止其重置系统。该应用应将该调用用于合适位置，并确保只在验证一切正常运行后才“喂养”看门狗。 ```python wdt0.feed() ``` #### 参数 无 #### 返回值 无 ### stop 停止当前看门狗对象 ```python wdt0.stop() ``` #### 参数 无 #### 返回值 无 ## 例程 ### 例程 1 （基础使用） 喂一次狗后便不再喂狗使得系统复位 ```python import time from machine import WDT # ''' # test default wdt wdt0 WDT(id 0, timeout 3000) print('into', wdt0) time.sleep(2) print(time.ticks_ms()) # 1.test wdt feed wdt0.feed() time.sleep(2) print(time.ticks_ms()) # 2.test wdt stop # wdt0.stop() ``` ### 例程 2 （进阶使用） 在回调函数中喂狗，系统正常运行 ```python import time from machine import WDT def on_wdt(self): print(self.context(), self) self.feed() ## release WDT #self.stop() # test callback wdt wdt1 WDT(id 1, timeout 4000, callback on_wdt, context {}) print('into', wdt1) time.sleep(2) print(time.ticks_ms()) # 1.test wdt feed wdt1.feed() time.sleep(2) print(time.ticks_ms()) # 2.test wdt stop # wdt1.stop() # print('stop', wdt1) # 3.wait wdt work while True: print('idle', time.ticks_ms()) time.sleep(1) ```"},"/soft/maixpy/zh/api_reference/builtin_py/pye.html":{"title":"Micropython Editor","content":" title: Micropython Editor keywords: maixpy, k210, AIOT, 边缘计算, 深度学习, 人工智能 desc: maixpy Micropython Editor MaixPy 固件中集成了文件编辑器 —— [`pye`](https://github.com/robert hh/Micropython Editor), 用户可以直接通过串口终端修改板子里面的文件 使用方法： ```python from pye_mp import pye pye(\"/sd/boot.py\") ```"},"/soft/maixpy/zh/api_reference/builtin_py/board_info.html":{"title":"Board","content":" title: Board keywords: maixpy, k210, AIOT, 边缘计算, 深度学习, 人工智能 desc: maixpy Board > **本文档在 MaixPy 0.5.1 128 版本测试通过。** 这是一个 MaixPy 板级配置模块，它可以在用户层统一 Python 代码，从而屏蔽许多硬件的引脚差异。 效果如下： ```python from Maix import GPIO from fpioa_manager import fm from board import board_info print(board_info.LED_R) fm.register(board_info.LED_R, fm.fpioa.GPIO0, force True) led_r GPIO(GPIO.GPIO0, GPIO.OUT) led_r.value(0) ``` 而这份代码同时支持 MaixPy 所有硬件运行，并且打印的 board_info.LED_R 都不尽相同，通过它保证示例代码的一致性。 ### board 的配置方法 将以下链接对应的 python 代码复制出来（如 config_maix_bit.py），放到 IDE 编辑框中运行，即可完成对『你的硬件』配置项（config.json）的导入，它会在 flash 上存储该配置文件。 运行配置代码后会自动重启，此时代码中才可以调用 board_info.BOOT_KEY , 实际上 board_info.BOOT_KEY 就是指 IO 16 ，对应的定义在 config.json 中可以得知，如果不存在的资源将会报错，如没有 LED 定义的硬件，运行 LED 点亮的时候就会报错。 ```python from board import board_info # see board/readme.md to config your sipeed's hardware. print(board_info.BOOT_KEY, board_info.BOOT_KEY 16) ``` ### Maix Bit [config_maix_bit.py](https://github.com/sipeed/MaixPy v1_scripts/tree/master/board/config_maix_bit.py) ### Maix Dock [config_maix_dock.py](https://github.com/sipeed/MaixPy v1_scripts/tree/master/board/config_maix_dock.py) ### Maix Go [config_maix_go.py](https://github.com/sipeed/MaixPy v1_scripts/tree/master/board/config_maix_go.py) ### Maix Duino [config_maix_duino.py](https://github.com/sipeed/MaixPy v1_scripts/tree/master/board/config_maix_duino.py) ### Maix Cube [config_maix_cube.py](https://github.com/sipeed/MaixPy v1_scripts/tree/master/board/config_maix_cube.py) ### Maix Amigo [config_maix_amigo.py](https://github.com/sipeed/MaixPy v1_scripts/tree/master/board/config_maix_amigo.py) ### Maix Nano > 这个没有硬件外设.....所以不要问为什么没有它的配置代码了。 ### 创建你的专属硬件 你可以借助该接口代码适配你的硬件，配置方法参考 [MaixPy_scripts/board](https://github.com/sipeed/MaixPy v1_scripts/tree/master/board) 里面有供你参考的配置文件。 ### board 的使用方法 导入配置： ```python from board import board_info board_info.load({ 'PIN10': 10, 'BOOT_KEY': 16, 'WIFI_TX': 6, 'WIFI_RX': 7, 'WIFI_EN': 8, }) print('PIN10:', board_info.PIN10) print('BOOT_KEY:', board_info.BOOT_KEY) print('WIFI_TX:', board_info.WIFI_TX) print('WIFI_RX:', board_info.WIFI_RX) print('WIFI_EN:', board_info.WIFI_EN) ``` 调用结果： ```shell PIN10: 10 BOOT_KEY: 16 WIFI_TX: 6 WIFI_RX: 7 WIFI_EN: 8 ``` > 就这样。"},"/soft/maixpy/zh/api_reference/builtin_py/index.html":{"title":"内置类（builtin_py）","content":" title: 内置类（builtin_py） keywords: maixpy, k210, AIOT, 边缘计算, 深度学习, 人工智能 desc: maixpy 内置类（builtin_py） `内置类` 库（builtin_py）是对 MaixPy 底层的类进行封装的用户层接口，方便用户使用 MaixPy 它包括以下： * [fpioa_manager](./fm.html) * [board_info](./board_info.html) * [pye](./pye.html) > `board_info` 与板卡相关，不同板卡配置不同，使用前需要[手动配置](../builtin_py/board_info.html)。 ```python from board import board_info from fpioa_manager import fm ```"},"/soft/maixpy/zh/api_reference/builtin_py/fm.html":{"title":"fpioa_manager","content":" title: fpioa_manager keywords: maixpy, k210, AIOT, 边缘计算, 深度学习, 人工智能 desc: maixpy fpioa_manager > **本文档在 MaixPy 0.5.1 128 版本测试通过。** fpioa_manager：简称`fm`，该模块用于注册芯片内部功能和引脚，帮助用户管理内部功能和引脚映射关系的功能模块。 ## 如何理解【引脚]映射[内部功能]？ K210 芯片上的 外部引脚 和 内部功能 是彼此独立的，引脚是指从芯片上引出的许多金属触点，也就是我们俗称的功能引脚，它可以是 GPIO / PWM / ADC / I2C 等内部功能引脚，传统的认知是引脚对应的内部功能是不可改变的，但可以复用的，而 K210 是可以通过映射来改变引脚功能的，看如下示意图理解具体的映射功能。 首先可以将 I2C 的 SCL/SDA 映射（MAP）到 IO6/IO7 引脚，从而在此引脚上进行 I2C 的读写操作。 ``` + + + + < + < + I2C IO6 + + + + < + < + UART IO7 + + + + < + SPI IO8 + + + + < + I2S IO9 + + + + ``` 接着还可以将 SPI 的 SCLK/MOSI/MISO/CS 映射（MAP）到 IO6/IO7/IO8/IO9 引脚，也就可以在此引脚上进行 SPI 的读写操作。 ``` + + + + < < < I2C IO6 + + + + < < + UART IO7 + + + + + SPI < < + + IO8 + + < < + I2S IO9 + + + + ``` ## 使用方法 调用 register 函数将 pin 引脚与具体的硬件功能(GPIO/I2C/UART/I2S/SPI)绑定起来，在不使用的时候调用 unregister 释放引脚所绑定的硬件功能（或称 **function** ），这不同于传统单片机的理解， K210 可以将一定范围内的引脚映射到具体的硬件功能。 如下代码所示： ```python from fpioa_manager import fm fm.register(11, fm.fpioa.GPIO0, force True) fm.register(12, fm.fpioa.GPIOHS0, force True) fm.register(13, fm.fpioa.UART2_TX) fm.register(14, fm.fpioa.UART2_RX) # other code fm.unregister(11) fm.unregister(12) fm.unregister(13) fm.unregister(14) ``` **注意事项**: 以下 GPIOHS 已经在 MaixPy 中默认使用，程序中如非必要请不要使用。 GPIOHS 功能 描述 GPIOHS31 LCD_DC LCD 控制信号引脚 GPIOHS30 LCD_RST LCD 复位芯片脚 GPIOHS29 SD_CS SD 卡 SPI 片选 GPIOHS28 MIC_LED_CLK SK9822_DAT GPIOHS27 MIC_LED_DATA SK9822_CLK 另外以下引脚已经在 MaxiPy 开机启动时注册，请注意。 ### SD卡 * `功能`：SPI1_SCLK/SPI1_D0/SPI1_D1/GPIOHS29/SPI0_SS1 * `引脚`：PIN25/PIN26/PIN27/PIN28/PIN29 ### LCD * `功能`：SPI0_SS3/SPI0_SCLK/GPIOHS30/GPIOHS31 * `引脚`：PIN36/PIN37/PIN38/PIN39 ### sensor * `功能`：SCCB_SDA/SCCB_SCLK/CMOS_RST/CMOS_VSYNC/CMOS_PWDN/CMOS_HREF/CMOS_XCLK/CMOS_PCLK * `引脚`：PIN40/PIN41/PIN42/PIN43/PIN44/PIN45/PIN46/PIN47 ### REPL * `功能`：UARTHS_RX/UARTHS_TX * `引脚`：PIN4/PIN5 ## class `fm` ### register(pin, func, force True) * `pin`: 功能映射引脚 * `function` : 芯片功能 * `force`: 强制分配，如果为`True`，则可以多次对同一个引脚注册;`False`则不允许同一引脚多次注册。默认为`True`是为了方便`IDE`多次运行程序使用 设置引脚（pin）对应的外设功能（func），默认启用强制绑定参数（force True），它将强制更换指定的引脚功能，如果发现存在上一个绑定的引脚，则会发出一个警告，但不影响代码继续执行。 如果设置 force False ，则会在 register 发现硬件功能已经被使用了，此时就会弹出异常，方便深度开发的时候不清楚 GPIO/HS 的分配情况，常见于运行某个代码的按键在访问某些功能的时候不能使用了的场合。 #### 使用方法 ```python from fpioa_manager import fm fm.register(16, fm.fpioa.GPIO2) fm.register(13, fm.fpioa.GPIO2) fm.register(12, fm.fpioa.GPIO2, force False) ``` 可见提示了 fm.fpioa.GPIO2(pin:16) 和 fm.fpioa.GPIO2(pin:13) 的占用情况。 ```shell [Warning] function is used by fm.fpioa.GPIO2(pin:16) Traceback (most recent call last): File \"<stdin>\", line 5, in <module> File \"fpioa_manager.py\", line 20, in register Exception: [Warning] function is used by fm.fpioa.GPIO2(pin:13) ``` ### unregister(pin) 释放引脚（pin）上的硬件功能（GPIO/I2C/SPI/I2S/UART）。 ### get_pin_by_function(pin) 获取引脚（pin）上绑定的硬件功能。 ### get_gpio_used() 获取所有 gpio 的使用情况，它只查询 GPIOHS / GPIO 的引脚分配情况, None 表示该硬件功能未被使用。 #### 使用方法 ```python from fpioa_manager import fm for item in fm.get_gpio_used(): print(item) ``` > 注意：每个引脚都会有默认状态 ```shell ('fm.fpioa.GPIOHS0', 16) ('fm.fpioa.GPIOHS1', 17) ('fm.fpioa.GPIOHS2', 18) ('fm.fpioa.GPIOHS3', 19) ('fm.fpioa.GPIOHS4', 37) ('fm.fpioa.GPIOHS5', 38) ('fm.fpioa.GPIOHS6', 22) ('fm.fpioa.GPIOHS7', 23) ('fm.fpioa.GPIOHS8', 24) ('fm.fpioa.GPIOHS9', 25) ('fm.fpioa.GPIOHS10', None) ('fm.fpioa.GPIOHS11', 27) ('fm.fpioa.GPIOHS12', 28) ('fm.fpioa.GPIOHS13', 29) ('fm.fpioa.GPIOHS14', 30) ('fm.fpioa.GPIOHS15', 31) ('fm.fpioa.GPIOHS16', 32) ('fm.fpioa.GPIOHS17', 33) ('fm.fpioa.GPIOHS18', 34) ('fm.fpioa.GPIOHS19', 35) ('fm.fpioa.GPIOHS20', None) ('fm.fpioa.GPIOHS21', None) ('fm.fpioa.GPIOHS22', None) ('fm.fpioa.GPIOHS23', None) ('fm.fpioa.GPIOHS24', 40) ('fm.fpioa.GPIOHS25', 41) ('fm.fpioa.GPIOHS26', 42) ('fm.fpioa.GPIOHS27', 43) ('fm.fpioa.GPIOHS28', 44) ('fm.fpioa.GPIOHS29', 26) ('fm.fpioa.GPIOHS30', 46) ('fm.fpioa.GPIOHS31', 47) ('fm.fpioa.GPIO0', 8) ('fm.fpioa.GPIO1', 9) ('fm.fpioa.GPIO2', None) ('fm.fpioa.GPIO3', None) ('fm.fpioa.GPIO4', 12) ('fm.fpioa.GPIO5', 13) ('fm.fpioa.GPIO6', 14) ('fm.fpioa.GPIO7', 15) ``` ### help() 调用它会打印出如下『附录： 外设表』帮助说明。 详细看 [FPIOA](../Maix/fpioa.html) 。"},"/soft/maixpy/zh/api_reference/media/video.html":{"title":"video（视频）","content":" title: video（视频） keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy video（视频） 支持播放和录制 `avi` 视频，需要烧录 [标准固件](https://dl.sipeed.com/shareURL/MAIX/MaixPy/release/master/maixpy_v0.6.2_41_g02d12688e) ，才能使用 ## 全局函数 ### open(path, record False, interval 100000, quality 50, width 320, height 240, audio False, sample_rate 44100, channels 1) 打开一个文件来播放或者录制 #### 参数 * `path`： 文件路径， 比如 `/sd/badapple.avi` * `record`： 是否进行录制， 如果选择 `Ture`， 则会进行录制视频，否则是播放视频。 默认 `False` * `interval`： 录制的帧间隔， 单位是微秒， fps 1000000/interval， 默认 `100000`， 即每秒`10`帧 * `quality`： `jpeg` 压缩质量（`%`）， 默认`50` * `width`： 录制屏幕宽度， 默认 `320` * `height`： 录制屏幕高度， 默认 `240` * `audio`： 是否录制音频， 默认 `False` * `sample_rate`： 录制音频采样率， 默认 `44100` (`44.1k`) * `channels`： 录制音频声道数， 默认 `1`， 即单声道 #### 返回值 返回一个对象， 根据不同格式返回的对象不同。 目前只支持 `avi` 格式， 返回 由 `avi` 类创建的对象 ## 类 `avi` 由 `video.open()` 函数返回 ### play() 播放视频， 每调用一次解析一次数据（音频或者视频） #### 返回值 * `0`： 播放结束 * `1`： 正在播放 * `2`： 暂停（保留） * `3`： 当前解码的帧是视频帧 * `4`： 当前解码的帧是音频帧 ### capture(img) 捕获视频画面帧（顺序捕获） #### 参数 * `img`: image 对象, 用来存放捕获到的画面 #### 返回值 * `0`： 已经达到视频末尾 * `3`： 成功捕获到视频画面帧 ### volume(volume) 设置音量 #### 参数 * `volume`： 音量值， 取值范围：[0,100] #### 返回值 设置的音量值， 取值范围 [0,100] ### record() 录制视频和音频， 每调用一次录制一帧，函数内部会限制速度，如果没有到录制设置的间隔，在到达设定的间隔之前会阻塞 #### 返回值 录制的视频的当前帧的长度 ## 例程 ### 例程 1： 播放 `avi` 视频 首先保证视频是 `320x240` 大小， 视频压缩格式为 `mjpeg`， 音频压缩格式位 `PCM`， 还需要接入扬声器和LCD。 可以在这里下载测试可以用的视频： [badapple.avi](http://api.dl.sipeed.com/shareURL/MAIX/MaixPy/assets) ```python from Maix import GPIO, I2S from fpioa_manager import fm import lcd import video import time lcd.init() # AUDIO_PA_EN_PIN None # Bit Dock and old MaixGo AUDIO_PA_EN_PIN 32 # Maix Go(version 2.20) # AUDIO_PA_EN_PIN 2 # Maixduino # init i2s(i2s0) i2s I2S(I2S.DEVICE_0) # config i2s according to audio info i2s.channel_config(i2s.CHANNEL_1, I2S.TRANSMITTER, resolution I2S.RESOLUTION_16_BIT, cycles I2S.SCLK_CYCLES_32, align_mode I2S.RIGHT_JUSTIFYING_MODE) # open audio PA if AUDIO_PA_EN_PIN: fm.register(AUDIO_PA_EN_PIN, fm.fpioa.GPIO1, force True) wifi_en GPIO(GPIO.GPIO1, GPIO.OUT) wifi_en.value(1) fm.register(34, fm.fpioa.I2S0_OUT_D1, force True) fm.register(35, fm.fpioa.I2S0_SCLK, force True) fm.register(33, fm.fpioa.I2S0_WS, force True) v video.open(\"/sd/badapple_320_240_15fps.avi\") print(v) v.volume(50) while True: if v.play() 0: print(\"play end\") break v.__del__() ``` 默认使用了 `I2S0` 来播放音频， 所以需要设置 `I2S0` 对应的引脚， 关闭WiFi是因为`Dock`板WiFi对音质的干扰 ### 例程2： 录制 `avi` 视频 ```python import sensor, image, lcd, time lcd.init(freq 15000000) sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.set_hmirror(1) sensor.set_vflip(1) sensor.run(1) sensor.skip_frames(30) import video v video.open(\"/sd/capture.avi\", audio False, record 1, interval 200000, quality 50) tim time.ticks_ms() for i in range(50): tim time.ticks_ms() img sensor.snapshot() lcd.display(img) img_len v.record(img) # print(\"record\",time.ticks_ms() tim) print(\"record_finish\") v.record_finish() v.__del__() # play your record v video.open(\"/sd/capture.avi\") print(v) v.volume(50) while True: if v.play() 0: print(\"play end\") break print(\"play finish\") v.__del__() lcd.clear() ``` 可以取消打印屏蔽来看实际的录制间隔有没有达到设置的帧间隔（比如这里设置的`200000us`） 实际打印应该是 `200ms`， 如果实际帧间隔大于设置的值，则说明实际性能没有达到设置的要求，需要调大设置的帧间隔即减小帧率。 另外去掉显示和打印也可以一定程度上增加帧率。 ### 例程3: 顺序 `avi` 捕获视频帧并显示 ```python import lcd import video import image lcd.init() v video.open(\"/sd/badapple_320_240_15fps.avi\") print(v) img image.Image() while True: status v.capture(img) if status ! 0: lcd.display(img) else: print(\"end\") break; v.__del__() ```"},"/soft/maixpy/zh/api_reference/media/nes.html":{"title":"NES 游戏模拟器","content":" title: NES 游戏模拟器 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy NES 游戏模拟器 经典的 FC 红白机 游戏模拟器， 带我们回到小时候吧～～ **警告，该模块只在标准固件（> 2m）中被编译包含，其他固件不带有，如有需求，请重新编译固件。** ## 函数 ### init(rc_type nes.KEYBOARD, cs, mosi, miso, clk, repeat 16, vol 5) 初始化 `NES` 模拟器 #### 参数 * `tc_type`： 遥控器类型， 键盘（`nes.KEYBOARD`）（注意是串口与电脑通信，而不是直接接USB键盘到开发板）或者手柄（`nes.JOYSTICK`）。 > 建议使用`PS2`手柄，体验会更好， 键盘通过串口工具输入可能不能同时按多个按键，当然也可以通过自己在PC写一个脚本来转发键值就能解决（去[这里](https://github.com/sipeed/MaixPy v1_scripts/tree/master/multimedia/nes)找找？） * `cs`： 如果使用 `SPI` 接口的 `PS2` 手柄， 传入 `cs` 外设编号（注意不是引脚号，需要先映射引脚） * `mosi`： 如果使用 `SPI` 接口的 `PS2` 手柄， 传入 `mosi` 外设编号（注意不是引脚号，需要先映射引脚） * `miso`： 如果使用 `SPI` 接口的 `PS2` 手柄， 传入 `miso` 外设编号（注意不是引脚号，需要先映射引脚） * `clk`： 如果使用 `SPI` 接口的 `PS2` 手柄， 传入 `clk` 外设编号（注意不是引脚号，需要先映射引脚） * `repeat`： 这个参数只对使用键盘（/串口）时， 指按键的重复率 * `vol`： 初始化时的音量， 后面可以通过按键调整 ### 基础示例 运行 `NES` 游戏 `ROM` #### 参数 * `nes`： 游戏 `ROM` 路径， 比如 `/sd/mario.nes` ```python try: nes.init(nes.INPUT) nes.load(\"/sd/mario.nes\") while True: nes.loop() finally: nes.free() ``` ## 快捷键 ### 代码输入 * `nes.input` ： `(①号机手柄, ②号机手柄, 菜单功能)` ### 键盘（/串口） * `移动` ： `W A S D` * `A` ： `J` * `B` ： `K` * `start` ： `M` 或者 `Enter` * `option`： `N` 或者 `\\` * `退出` ： `ESC` * `音量 ` ： ` ` * `音量 +` ： ` ` * `运行速度 ` ： `R` * `运行速度 +` ： `F` ### 手柄 * `移动` ： 方向键 `< ` `^` `V` ` >` * `A` ： `□` * `B` ： `×` * `start` ： `START` * `select`： `SELECT` * `退出` ： 暂无 * `音量 ` ： `R2` * `音量 +` ： `R1` * `运行速度 ` ： `L1` * `运行速度 +` ： `L2` ## 例程 > \"mario.nes\" 游戏文件请自行搜索下载 ### Gamepad测试 以下为双手柄输入测试代码，具体的接线和测试方式请看[Gamgpad测试](/hardware/zh/modules/amigo_handle.html#手柄测试) ```python from machine import I2C import nes, lcd from sound import CubeAudio import sys, time from fpioa_manager import fm from Maix import FPIOA, GPIO # B A SEL START UP DOWN LEFT RIGHT X Y # 1 2 4 8 16 32 64 128 254 253 i2c I2C(I2C.I2C2, freq 400*1000, sda 27, scl 24) lcd.init(freq 15000000) lcd.register(0x36, 0x20 state 0 import time i 0 while True: dev i2c1.scan() print(dev) dev i2c2.scan() print(dev) time.sleep(0.5) try: #i2c.writeto(0x4A, b'0') tmp (i2c1.readfrom(0x4A, 2)) print('{} {}'.format(int(tmp[0]), int(tmp[1]))) except Exception as e: print(e) try: #i2c.writeto(0x42, b'0') tmp (i2c2.readfrom(0x42, 2)) print('{} {}'.format(int(tmp[0]), int(tmp[1]))) except Exception as e: print(e) ``` ### 键盘（串口） ```python import nes, lcd lcd.init(freq 15000000) nes.init(nes.KEYBOARD) nes.load(\"/sd/mario.nes\") while True: nes.loop() ``` ### PS2 手柄 ```python import nes, lcd from fpioa_manager import fm fm.register(19, fm.fpioa.GPIOHS19) fm.register(18, fm.fpioa.GPIOHS18) fm.register(23, fm.fpioa.GPIOHS23) fm.register(21, fm.fpioa.GPIOHS21) lcd.init(freq 15000000) nes.init(nes.JOYSTICK, cs fm.fpioa.GPIOHS19, clk fm.fpioa.GPIOHS18, mosi fm.fpioa.GPIOHS23, miso fm.fpioa.GPIOHS21) nes.load(\"/sd/mario.nes\") while True: nes.loop() ``` ### 双手柄玩游戏(Amigo) ```python from machine import I2C import nes, lcd from sound import CubeAudio import sys, time from fpioa_manager import fm from Maix import FPIOA, GPIO import time i2c I2C(I2C.I2C3, freq 400*1000, sda 27, scl 24) CubeAudio.init(i2c) tmp CubeAudio.check() print(tmp) CubeAudio.ready(volume 100) fm.fpioa.set_function(13,fm.fpioa.I2S0_MCLK) fm.fpioa.set_function(21,fm.fpioa.I2S0_SCLK) fm.fpioa.set_function(18,fm.fpioa.I2S0_WS) fm.fpioa.set_function(35,fm.fpioa.I2S0_IN_D0) fm.fpioa.set_function(34,fm.fpioa.I2S0_OUT_D2) i2c1 I2C(I2C.I2C1, freq 400*1000, sda 9, scl 7) #P1手柄I2C设置 i2c I2C(I2C.I2C2, freq 400*1000, sda 27, scl 24) #P2手柄I2C设置 lcd.init(freq 15000000) lcd.register(0x36, 0x20) # amigo state 0 try: nes.init(nes.INPUT) nes.load(\"mario.nes\") #游戏文件名 nes.load(\"/sd/mario.nes\") #读取sd卡游戏文件 for i in range(20000): nes.loop() for i in range(500): nes.loop() nes.input(8, 0, 0) nes.loop() nes.input(0, 0, 0) nes.loop() while True: #这是P1手柄输入 try: left (i2c1.readfrom(0x4A, 1)) except Exception as e: print(e) nes.loop() #这是P2手柄输入 try: right (i2c.readfrom(0x42, 1)) except Exception as e: print(e) #nes.input(right[0], 0, 0) #单个手柄输入 nes.input(right[0], left[0], 0) #双手柄输入 for i in range(100): nes.loop() nes.loop() finally: nes.free() ```"},"/soft/maixpy/zh/api_reference/media/audio.html":{"title":"audio（音频）","content":" title: audio（音频） keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy audio（音频） 抽象的音频对象，该对象可以被当做参数传入也可以直接使用其方法来播放音频 ## 模块函数 ### 构造函数 构造 `Audio` 对象 ```python audio.Audio(array None, path None, points 1024) ``` #### 参数 该接口能传入一个参数，每个参数会决定不同的音频类型 * `array`: `bytearray`类型的数据，可以将该数据转换为音频对象， 默认 `None` * `path`: 打开的音频文件路径，目前仅支持 `wav` 格式， 默认 `None`, **注意**需要标明关键字`path`，`audio.Audio(\"/sd/1.wav\")`这样是错的！！ `audio.Audio(path \"/sd/1.wav\")` 才是正确的 * `points`: 开辟有 points 个采样点数的音频缓冲，一个采样点大小为 32bit。为0的情况下将不开辟缓冲, 默认 `1024` #### 返回值 返回一个 `Audio` 对象 ### to_bytes: bytes转换函数 将音频对象中的音频数据转换为 `bytearray` 类型的对象 ``` audio_data test_audio.to_bytes() ``` #### 参数 无 #### 返回值 返回的音频数据 `bytearray` 对象 ### play_process: 播放预处理函数 用于预处理音频对象，在播放之前需要对音频文件进行解析，所以需要预处理。这里需要传入一个播放用的 I2S 设备 ``` wav_info test_audio.play_process(i2s_dev) ``` #### 参数 * `i2s_dev`: 用于播放的i2s设备 #### 返回值 该 wav 文件的头部信息 ,`list`类型，分别是`numchannels`（声道数）, `samplerate`（采样率）, `byterate`（每秒数据字节数 samplerate * numchannels * bitspersample / 8）, `blockalign`（每个采样所需的字节数 numchannels * bitspersample / 8）, `bitspersample`（每个采样存储的bit数，8：8bit，16：16bit，32：32bit）, `datasize`（音频数据长度） ### play: 播放函数 读取音频文件并且解析播放，一般配合循环来使用 #### 参数 无 #### 返回值 * `None`： 格式不支持播放 * `0`： 播放结束 * `1`： 正在播放 ### finish： 音频后处理函数 完成音频播放，该函数必须在播放完毕后调用，回收底层分配的资源 #### 参数 无 #### 返回值 无 ## 例程 播放 `wav` 音频 ```python from fpioa_manager import * from Maix import I2S, GPIO import audio # disable wifi fm.register(8, fm.fpioa.GPIO0) wifi_en GPIO(GPIO.GPIO0,GPIO.OUT) wifi_en.value(0) # register i2s(i2s0) pin fm.register(34,fm.fpioa.I2S0_OUT_D1) fm.register(35,fm.fpioa.I2S0_SCLK) fm.register(33,fm.fpioa.I2S0_WS) # init i2s(i2s0) wav_dev I2S(I2S.DEVICE_0) # init audio player audio.Audio(path \"/sd/6.wav\") player.volume(40) # read audio info wav_info player.play_process(wav_dev) print(\"wav file head information: \", wav_info) # config i2s according to audio info wav_dev.channel_config(wav_dev.CHANNEL_1, I2S.TRANSMITTER,resolution I2S.RESOLUTION_16_BIT ,cycles I2S.SCLK_CYCLES_32, align_mode I2S.RIGHT_JUSTIFYING_MODE) wav_dev.set_sample_rate(wav_info[1]) # loop to play audio while True: ret player.play() if ret None: print(\"format error\") break elif ret 0: print(\"end\") break player.finish() ```"},"/soft/maixpy/zh/api_reference/machine_vision/lcd.html":{"title":"lcd（屏幕显示）","content":" title: lcd（屏幕显示） keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy lcd（屏幕显示） ## 函数 ### lcd.init(type 1, freq 15000000, color lcd.BLACK, invert 0, lcd_type 0) 初始化 `LCD` 屏幕显示 #### 参数 * `type`： 设备的类型（保留给未来使用）: * `0`: None * `1`: lcd shield（默认值） * `2`: Maix Cube * `5`: sipeed rgb 屏转接板 > type 是键值参数，必须在函数调用中通过写入 type 来显式地调用 * `freq`： `LCD` （实际上指 `SPI` 的通讯速率） 的频率 * `color`： `LCD` 初始化的颜色， 可以是 16 位的 `RGB565` 颜色值，比如 `0xFFFF`； 或者 `RGB888` 元组， 比如 `(236, 36, 36)`， 默认 `lcd.BLACK` * `invert`: `LCD` 反色显示 * `lcd_type`: lcd 类型： * `0`: 默认类型 * `1`: LCD_TYPE_ILI9486 * `2`: LCD_TYPE_ILI9481 * `3`: LCD_TYPE_5P0_7P0，5 寸或 7 寸 分辨率为 800 * 480 的 lcd （需要搭配 sipeed 转接板） * `4`: LCD_TYPE_5P0_IPS，5 寸 分辨率为 854*489 的 IPS lcd （需要搭配 sipeed 转接板） * `5`: LCD_TYPE_480_272_4P3，4.3 寸分辨率为 480*272 的 lcd （需要搭 sipeed 配转接板） > MaixCube 和 MaixAmigo 使用 LCD 之前需要配置电源芯片，否则会出现花屏现象，这一步 MaixPy 固件会自动配置，无需手动操作，用户只需要了解即可 ### lcd.deinit() 注销 `LCD` 驱动，释放I/O引脚 ### lcd.width() 返回 `LCD` 的宽度（水平分辨率） ### lcd.height() 返回 `LCD` 的高度（垂直分辨率）。 ### lcd.type() 返回 `LCD` 的类型（保留给未来使用）： 0: None 1: lcd Shield ### lcd.freq(freq) 设置或者获取 `LCD` （SPI） 的频率 #### Paremeters * `freq`: LCD (SPI) 的频率 #### Return LCD 的频率 ### lcd.set_backlight(state) 设置 `LCD` 的背光状态， 关闭背光会大大降低lcd扩展板的能耗 > 未实现 #### 参数 * `state`： 背光亮度， 取值 [0,100] ### lcd.get_backlight() 返回背光状态 #### 返回值 背光亮度， 取值 [0,100] ### lcd.display(image, roi Auto, oft (x, y)) 在液晶屏上显示一张 `image`（GRAYSCALE或RGB565）。 roi 是一个感兴趣区域的矩形元组(x, y, w, h)。若未指定，即为图像矩形 若 roi 宽度小于lcd宽度，则用垂直的黑色边框使 roi 居于屏幕中心（即用黑色填充未占用区域）。 若 roi 宽度大于lcd宽度，则 roi 居于屏幕中心，且不匹配像素不会显示（即液晶屏以窗口形态显示 roi 的中心）。 若 roi 高度小于lcd高度，则用垂直的黑色边框使 roi 居于屏幕中心（即用黑色填充未占用区域）。 若 roi 高度大于lcd高度，则 roi 居于屏幕中心，且不匹配像素不会显示（即液晶屏以窗口形态显示 roi 的中心）。 > roi 是键值参数，必须在函数调用中通过写入 roi 来显式地调用。 * `oft`: 设置偏移坐标，设置了这个坐标就不会自动填充周围了 ### lcd.clear() 将液晶屏清空为黑色或者指定的颜色。 #### 参数 * `color`： `LCD` 初始化的颜色， 可以是 16 位的 `RGB565` 颜色值，比如 `0xFFFF`； 或者 `RGB888` 元组， 比如 `(236, 36, 36)` ### lcd.direction(dir) 在 `v0.3.1` 之后已经被舍弃， 请使用`lcd.rotation` 和 `lcd.invert`代替， 如非必要请勿使用， 接口仍会被保留用于调试使用 设置屏幕方向， 以及是否镜像等 #### 参数 * `dir`： 正常情况下推荐 `lcd.YX_LRUD` 和 `lcd.YX_RLDU`， 另外还有其它值，交换 `XY` 或者 `LR` 或者 `DU`即可 ### lcd.rotation(dir) 设置 `LCD` 屏幕方向 #### 参数 * `dir`: 取值范围 [0,3]， 从`0`到`3`依次顺时针旋转 #### 返回值 当前方向，取值[0,3] ### lcd.mirror(invert) 设置 `LCD` 是否镜面显示 #### 参数 * `invert`： 是否镜面显示， `True` 或者 `False` #### 返回值 当前设置，是否镜面显示，返回`True`或者`False` ### lcd.bgr_to_rgb(enable) 设置是否启动 bgr 色彩显示 #### 参数 * `enable`：是否启用 bgr 显示，`True` 或者 `False` ### lcd.fill_rectangle(x, y, w, h, color) 填充`LCD` 指定区域 #### 参数 * `x`: 起始坐标`x` * `x`: 起始坐标`y` * `w`: 填充宽度 * `h`: 填充高度 * `color`: 填充颜色， 可以是元组，比如`(255, 255, 255)`，或者`RGB565``uint16`值， 比如红色`0x00F8` ## 例程 ### 例程 1： 显示英文 ```python import lcd lcd.init() lcd.draw_string(100, 100, \"hello maixpy\", lcd.RED, lcd.BLACK) ``` ### 例程 2： 显示图片 ```python import lcd import image lcd.init() img image.Image(\"/sd/pic.bmp\")#320*240 lcd.display(img) ``` ### 例程 3： 利用显示图片的方式显示英文 ```python import lcd import image img image.Image() img.draw_string(60, 100, \"hello maixpy\", scale 2) lcd.display(img) ``` ### 例程 4： 实时显示摄像头捕捉到的图像 ```python import sensor, lcd sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) sensor.skip_frames() lcd.init() while(True): lcd.display(sensor.snapshot()) ```"},"/soft/maixpy/zh/api_reference/machine_vision/isolated_word.html":{"title":"isolated_word（孤立词 MFCC 模块）","content":" title: isolated_word（孤立词 MFCC 模块） keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy isolated_word（孤立词 MFCC 模块） ## 类 （class） ### isolated_word isolated_word 构造参数如下： `dmac`: 录音所使用的 DMA 通道，默认使用【通道 2】。 `i2s`: 录音设备，默认使用 I2S.DEVICE_0 。 `size`: 词汇模板容量，表示可以加载的模板总数，默认为 10 个。 `shift`: 声道选择，Maix 系列的硬件录音设备通常为单声道输入，设置 0 为左声道，所以 1 为右声道。 ```python from speech_recognizer import isolated_word sr isolated_word(dmac 2, i2s I2S.DEVICE_0, size 10, shift 0) ``` ## 方法 （function） ### size 返回当前词汇模板总量。 ```python from speech_recognizer import isolated_word sr isolated_word() sr.size() ``` ### set_threshold 设置孤立词模块的工作参数。 参数①： 噪声阈值，用于短时过零率计算 参数②： 短时过零率阈值，超过此阈值，视为进入过渡段。 参数③： 短时累加和阈值，超过此阈值，视为进入过渡段。 ```python from speech_recognizer import isolated_word sr isolated_word() sr.set_threshold(0, 0, 10000) ``` ### record 录入【词汇模板】。 参数①： 将录入的模板保存到指定的索引位置。 ```python from speech_recognizer import isolated_word sr isolated_word() while True： if sr.Done sr.record(0): pass ``` ### state 可以返回如下工作状态。 功能 描述 Init 模块已经初始化。 Idle 模块正在空转，没有工作。 Ready 模块录音处理中。 MaybeNoise 模块判断是否为噪音环境。 Speak 模块等待人声录入。 Restrain 模块录入数据不合法，退回 Speak 状态。 Done 模块语音识别成功，可通过 result 获取结果。 ### recognize 识别【词汇模板】。 ```python from speech_recognizer import isolated_word sr isolated_word() while True： if sr.Done sr.recognize(): print(sr.result()) ``` ### result 获取【词汇模板】,返回 （匹配的模板编号、匹配的dtw值、当前的帧长、匹配的帧长） 数组。 ```python from speech_recognizer import isolated_word sr isolated_word() print(sr.result()) ``` ### get 获取【词汇模板】,返回 （数据帧长， 数据帧） 数组。 #### 返回值 * `frm_len`:数据帧长 * `frm_data`:数据帧 ```python from speech_recognizer import isolated_word sr isolated_word() print(sr.get(0)) ``` ### set 加载【词汇模板】到模块中。 ```python from speech_recognizer import isolated_word sr isolated_word() print(sr.set(1, sr.get(0))) ``` ### run 运行孤立词模块（录音）。 ```python from speech_recognizer import isolated_word sr isolated_word() sr.run() ``` ### reset 重置孤立词模块。 ```python from speech_recognizer import isolated_word sr isolated_word() sr.reset() ``` ### dtw 返回 动态时间弯折(DTW)算法 计算最优匹配值，该值越小就越好。 #### 返回值 * `dis`:累计匹配距离（int） ```python from speech_recognizer import isolated_word sr isolated_word() print(sr.dtw(sr.get(0))) ``` ### __del__ 释放孤立词模块，可以主动调用，也可以被 gc.collect() 自动回收。 ```python from speech_recognizer import isolated_word sr isolated_word() sr.__del__() del sr ```"},"/soft/maixpy/zh/api_reference/machine_vision/index.html":{"title":"机器视觉/听觉","content":" title: 机器视觉/听觉 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy 机器视觉/听觉 主要包含了了与图像、显示、语音相关的类，包括： * [lcd](./lcd.html) * [sensor](./sensor.html) * [image](./image/image.html) * [video](./../media/video.html) * [isolated_word](./isolated_word.html) * [maix_asr](./maix_asr.html)"},"/soft/maixpy/zh/api_reference/machine_vision/maix_asr.html":{"title":"maix_asr（语音识别模块）","content":" title: maix_asr（语音识别模块） keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy maix_asr（语音识别模块） ## class（类） ### maix_asr maix_asr 构造参数如下： `address` 烧写声学模型的 Flash 地址。 `i2s` 录音设备，默认使用 I2S.DEVICE_0 。 `dmac` 录音所使用的 DMA 通道，默认使用 `通道 3`。 `shift` 声道选择，Maix 系列的硬件录音设备通常为单声道输入，设置 0 为左声道，所以 1 为右声道。 ```python from speech_recognizer import asr class maix_asr(asr): def config(self, sets): pass t maix_asr(0x500000, I2S.DEVICE_0, 3, shift 0) ``` 该 maix_asr 模块由继承内部 asr 模块而来的拓展配置接口辅助类，实现如下： ```python from speech_recognizer import asr class maix_asr(asr): asr_vocab [\"lv\", \"shi\", \"yang\", \"chun\", \"yan\", \"jing\", \"da\", \"kuai\", \"wen\", \"zhang\", \"de\", \"di\", \"se\", \"si\", \"yue\", \"lin\", \"luan\", \"geng\", \"xian\", \"huo\", \"xiu\", \"mei\", \"yi\", \"ang\", \"ran\", \"ta\", \"jin\", \"ping\", \"yao\", \"bu\", \"li\", \"liang\", \"zai\", \"yong\", \"dao\", \"shang\", \"xia\", \"fan\", \"teng\", \"dong\", \"she\", \"xing\", \"zhuang\", \"ru\", \"hai\", \"tun\", \"zhi\", \"tou\", \"you\", \"ling\", \"pao\", \"hao\", \"le\", \"zha\", \"zen\", \"me\", \"zheng\", \"cai\", \"ya\", \"shu\", \"tuo\", \"qu\", \"fu\", \"guang\", \"bang\", \"zi\", \"chong\", \"shui\", \"cuan\", \"ke\", \"shei\", \"wan\", \"hou\", \"zhao\", \"jian\", \"zuo\", \"cu\", \"hei\", \"yu\", \"ce\", \"ming\", \"dui\", \"cheng\", \"men\", \"wo\", \"bei\", \"dai\", \"zhe\", \"hu\", \"jiao\", \"pang\", \"ji\", \"lao\", \"nong\", \"kang\", \"yuan\", \"chao\", \"hui\", \"xiang\", \"bing\", \"qi\", \"chang\", \"nian\", \"jia\", \"tu\", \"bi\", \"pin\", \"xi\", \"zou\", \"chu\", \"cun\", \"wang\", \"na\", \"ge\", \"an\", \"ning\", \"tian\", \"xiao\", \"zhong\", \"shen\", \"nan\", \"er\", \"ri\", \"zhu\", \"xin\", \"wai\", \"luo\", \"gang\", \"qing\", \"xun\", \"te\", \"cong\", \"gan\", \"lai\", \"he\", \"dan\", \"wei\", \"die\", \"kai\", \"ci\", \"gu\", \"neng\", \"ba\", \"bao\", \"xue\", \"shuai\", \"dou\", \"cao\", \"mao\", \"bo\", \"zhou\", \"lie\", \"qie\", \"ju\", \"chuan\", \"guo\", \"lan\", \"ni\", \"tang\", \"ban\", \"su\", \"quan\", \"huan\", \"ying\", \"a\", \"min\", \"meng\", \"wu\", \"tai\", \"hua\", \"xie\", \"pai\", \"huang\", \"gua\", \"jiang\", \"pian\", \"ma\", \"jie\", \"wa\", \"san\", \"ka\", \"zong\", \"nv\", \"gao\", \"ye\", \"biao\", \"bie\", \"zui\", \"ren\", \"jun\", \"duo\", \"ze\", \"tan\", \"mu\", \"gui\", \"qiu\", \"bai\", \"sang\", \"jiu\", \"yin\", \"huai\", \"rang\", \"zan\", \"shuo\", \"sha\", \"ben\", \"yun\", \"la\", \"cuo\", \"hang\", \"ha\", \"tuan\", \"gong\", \"shan\", \"ai\", \"kou\", \"zhen\", \"qiong\", \"ding\", \"dang\", \"que\", \"weng\", \"qian\", \"feng\", \"jue\", \"zhuan\", \"ceng\", \"zu\", \"bian\", \"nei\", \"sheng\", \"chan\", \"zao\", \"fang\", \"qin\", \"e\", \"lian\", \"fa\", \"lu\", \"sun\", \"xu\", \"deng\", \"guan\", \"shou\", \"mo\", \"zhan\", \"po\", \"pi\", \"gun\", \"shuang\", \"qiang\", \"kao\", \"hong\", \"kan\", \"dian\", \"kong\", \"pei\", \"tong\", \"ting\", \"zang\", \"kuang\", \"reng\", \"ti\", \"pan\", \"heng\", \"chi\", \"lun\", \"kun\", \"han\", \"lei\", \"zuan\", \"man\", \"sen\", \"duan\", \"leng\", \"sui\", \"gai\", \"ga\", \"fou\", \"kuo\", \"ou\", \"suo\", \"sou\", \"nu\", \"du\", \"mian\", \"chou\", \"hen\", \"kua\", \"shao\", \"rou\", \"xuan\", \"can\", \"sai\", \"dun\", \"niao\", \"chui\", \"chen\", \"hun\", \"peng\", \"fen\", \"cang\", \"gen\", \"shua\", \"chuo\", \"shun\", \"cha\", \"gou\", \"mai\", \"liu\", \"diao\", \"tao\", \"niu\", \"mi\", \"chai\", \"long\", \"guai\", \"xiong\", \"mou\", \"rong\", \"ku\", \"song\", \"che\", \"sao\", \"piao\", \"pu\", \"tui\", \"lang\", \"chuang\", \"keng\", \"liao\", \"miao\", \"zhui\", \"nai\", \"lou\", \"bin\", \"juan\", \"zhua\", \"run\", \"zeng\", \"ao\", \"re\", \"pa\", \"qun\", \"lia\", \"cou\", \"tie\", \"zhai\", \"kuan\", \"kui\", \"cui\", \"mie\", \"fei\", \"tiao\", \"nuo\", \"gei\", \"ca\", \"zhun\", \"nie\", \"mang\", \"zhuo\", \"pen\", \"zun\", \"niang\", \"suan\", \"nao\", \"ruan\", \"qiao\", \"fo\", \"rui\", \"rao\", \"ruo\", \"zei\", \"en\", \"za\", \"diu\", \"nve\", \"sa\", \"nin\", \"shai\", \"nen\", \"ken\", \"chuai\", \"shuan\", \"beng\", \"ne\", \"lve\", \"qia\", \"jiong\", \"pie\", \"seng\", \"nuan\", \"nang\", \"miu\", \"pou\", \"cen\", \"dia\", \"o\", \"zhuai\", \"yo\", \"dei\", \"n\", \"ei\", \"nou\", \"bia\", \"eng\", \"den\", \"_\"] def get_asr_list(string 'xiao ai fas tong xue'): return [__class__.asr_vocab.index(t) for t in string.split(' ') if t in __class__.asr_vocab] def get_asr_string(listobj [117, 214, 257, 144]): return ' '.join([__class__.asr_vocab[t] for t in listobj if t < len(__class__.asr_vocab)]) def unit_test(): print(__class__.get_asr_list('xiao ai')) print(__class__.get_asr_string(__class__.get_asr_list('xiao ai fas tong xue'))) def config(self, sets): self.set([(sets[key], __class__.get_asr_list(key)) for key in sets]) def recognize(self): res self.result() # print(tmp) if res ! None: sets {} for tmp in res: sets[__class__.get_asr_string(tmp[1])] tmp[0] #print(tmp[0], get_asr_string(tmp[1])) return sets return None ``` ### function（方法） #### config 可以配置语音识别的所需要的词汇列表，最大不超过 6 个音符，超了会忽略，参数为 `'xiao ai ya' : 0.3` 对应的 中文拼音字符串 和 匹配的最低概率（门限），且注意它不区分音调，所以 `你 好 鸭` 和 `尼 浩 雅` 没有区别，所以设计的时候要注意词汇的语调是否会形成新词。 用例如下： ```python t.config({ 'xiao ai ya' : 0.3, 'hao de ya' : 0.2, 'ni hao ya' : 0.3, }) ``` #### recognize 将会识别 config 函数中所配置的词汇。 用例如下： ```python tmp t.recognize() # print(tmp) if tmp ! None: print(tmp) ``` 返回结果： ```python { 'xiao ai ya' : 0.9, 'xiao ai' : 0.2, } ``` 跟 config 时的参数一样，只是作为返回值给出，可以见到此处出现 `小 爱 鸭` 和 `小 爱` 两个匹配结果。 #### state 期望保持在 100ms 内能够执行 asr 模块，它会返回当前模块状态，可以忽略返回结果，用法如下： ```python from machine import Timer def on_timer(timer): #print(\"time up:\",timer) #print(\"param:\",timer.callback_arg()) timer.callback_arg().state() # default: maix dock / maix duino set shift 0 t maix_asr(0x500000, I2S.DEVICE_0, 3, shift 0) # maix bit set shift 1 tim Timer(Timer.TIMER0, Timer.CHANNEL0, mode Timer.MODE_PERIODIC, period 64, callback on_timer, arg t) tim.start() ``` 可见 on_timer 会在 64 ms 的周期内执行 timer.callback_arg().state() 函数，其中 timer.callback_arg() 为 maix_asr 类的实例。 #### run 控制模块运行（录音）。 #### stop 控制模块停止（录音）。 #### __del__ 主动调用可释放模块，可被 gc.collect() 主动回收。"},"/soft/maixpy/zh/api_reference/machine_vision/image/image.html":{"title":"image（机器视觉）","content":" title: image（机器视觉） keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy image（机器视觉） 移植于 `openmv`， 与 `openmv` 功能相同 ## 例程 ### 例程 1： 找绿色 ```python import sensor import image import lcd import time lcd.init() sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) green_threshold (0, 80, 70, 10, 0, 30) while True: \timg sensor.snapshot() \tblobs img.find_blobs([green_threshold]) \tif blobs: \t\tfor b in blobs: \t\t\ttmp img.draw_rectangle(b[0:4]) \t\t\ttmp img.draw_cross(b[5], b[6]) \t\t\tc img.get_pixel(b[5], b[6]) \tlcd.display(img) ``` ### 例程 2： 显示 fps ```python import sensor import image import lcd import time clock time.clock() lcd.init() sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) sensor.skip_frames(30) while True: clock.tick() img sensor.snapshot() fps clock.fps() img.draw_string(2,2, (\"%2.1ffps\" %(fps)), color (0,128,0), scale 2) lcd.display(img) ``` ### 例程 3： 扫描二维码 ```python import sensor import image import lcd import time clock time.clock() lcd.init() sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.set_vflip(1) sensor.run(1) sensor.skip_frames(30) while True: clock.tick() img sensor.snapshot() res img.find_qrcodes() fps clock.fps() if len(res) > 0: img.draw_string(2,2, res[0].payload(), color (0,128,0), scale 2) print(res[0].payload()) lcd.display(img) ``` > 如果使用了镜头，画面会有扭曲，需要矫正画面 > 使用 `lens_corr` 函数来矫正， 比如 `2.8`mm， `img.lens_corr(1.8)` > 无法识别二维码的时候需要用sensor.set_hmirror(1)来调整摄像头的镜像画面 ### 例程4 寻找矩阵 ```python # Find Rects Example # # 这个例子展示了如何使用april标签代码中的四元检测代码在图像中找到矩形。 四元检测算法以非常稳健的方式检测矩形，并且比基于Hough变换的方法好得多。 例如，即使镜头失真导致这些矩形看起来弯曲，它仍然可以检测到矩形。 圆角矩形是没有问题的！ # (但是，这个代码也会检测小半径的圆)... import sensor, image, time sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QQVGA) sensor.skip_frames(time 2000) sensor.set_vflip(1) clock time.clock() while(True): clock.tick() img sensor.snapshot() # 下面的`threshold`应设置为足够高的值，以滤除在图像中检测到的具有 # 低边缘幅度的噪声矩形。最适用与背景形成鲜明对比的矩形。 for r in img.find_rects(threshold 10000): img.draw_rectangle(r.rect(), color (255, 0, 0)) for p in r.corners(): img.draw_circle(p[0], p[1], 5, color (0, 255, 0)) print(r) print(\"FPS %f\" % clock.fps()) ``` ### 例程5 寻找Apriltag ```python # AprilTags 示例 # # 此示例显示了OpenMV Cam在OpenMV Cam M7上检测April标签的强大功能。 # OpenMV2 M4版本无法检测April标签。 import sensor, image, time, math sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QQVGA) # 如果分辨率更大，我们的内存会耗尽... sensor.skip_frames(time 2000) sensor.set_auto_gain(False) # 必须关闭此功能，以防止图像冲洗… sensor.set_auto_whitebal(False) # 必须关闭此功能，以防止图像冲洗… clock time.clock() # 注意！与find_qrcodes不同，find_apriltags方法不需要对图像进行镜头校正 # apriltag代码最多支持可以同时处理6种tag家族。 # 返回的tag标记对象，将有其tag标记家族及其在tag标记家族内的id。 tag_families 0 tag_families image.TAG16H5 # 注释掉，禁用这个家族 tag_families image.TAG25H7 # 注释掉，禁用这个家族 tag_families image.TAG25H9 # 注释掉，禁用这个家族 tag_families image.TAG36H10 # 注释掉，禁用这个家族 tag_families image.TAG36H11 # 注释掉以禁用这个家族(默认家族) tag_families image.ARTOOLKIT # 注释掉，禁用这个家族 #标签系列有什么区别？ 那么，例如，TAG16H5家族实际上是一个4x4的方形标签。 #所以，这意味着可以看到比6x6的TAG36H11标签更长的距离。 #然而，较低的H值（H5对H11），意味着4x4标签的假阳性率远高于6x6标签。 #所以，除非你有理由使用其他标签系列，否则使用默认族TAG36H11。 def family_name(tag): if(tag.family() image.TAG16H5): return \"TAG16H5\" if(tag.family() image.TAG25H7): return \"TAG25H7\" if(tag.family() image.TAG25H9): return \"TAG25H9\" if(tag.family() image.TAG36H10): return \"TAG36H10\" if(tag.family() image.TAG36H11): return \"TAG36H11\" if(tag.family() image.ARTOOLKIT): return \"ARTOOLKIT\" while(True): clock.tick() img sensor.snapshot() for tag in img.find_apriltags(families tag_families): # 如果没有给出家族，默认TAG36H11。 img.draw_rectangle(tag.rect(), color (255, 0, 0)) img.draw_cross(tag.cx(), tag.cy(), color (0, 255, 0)) print_args (family_name(tag), tag.id(), (180 * tag.rotation()) / math.pi) print(\"Tag Family %s, Tag ID %d, rotation %f (degrees)\" % print_args) print(clock.fps()) ``` ## 函数 函数还可以在本页按 `Ctrl+F` 使用浏览器的搜索功能搜 `image.` 来标记函数 ### image.rgb_to_lab(rgb_tuple) 返回RGB888格式的元组 rgb_tuple (r, g, b)对应的LAB格式的元组(l, a, b)。 > RGB888是指红、绿、蓝各8位（0 255）。在LAB中，L的取值范围为0 100，a/b 的取值范围为 128到127。 ### image.lab_to_rgb(lab_tuple) 返回LAB格式的元组 lab_tuple (l, a, b)对应的RGB888格式的元组(r, g, b)。 > RGB888是指红、绿、蓝各8位（0 255）。在LAB中，L的取值范围为0 100，a/b 的取值范围为 128到127。 ### image.rgb_to_grayscale(rgb_tuple) 返回RGB888格式的元组 rgb_tuple (r, g, b)对应的灰度值。 > RGB888是指红、绿、蓝各8位（0 255）。灰度值取值于0 255。 ### image.grayscale_to_rgb(g_value) 返回灰度值 g_value 对应的RGB888格式的元组(r, g, b)。 > RGB888是指红、绿、蓝各8位（0 255）。灰度值取值于0 255。 ### image.load_decriptor(path) 从磁盘上加载一个描述符对象(descriptor object). path 是描述符文件保存的路径。 ### image.save_descriptor(path, descriptor) 保存描述符对象 descriptor 到磁盘。 path 是描述符文件保存的路径。 ### image.match_descriptor(descritor0, descriptor1[, threshold 70[, filter_outliers False]]) 对于LBP描述符来说，这个函数返回的是一个体现两个描述符之间区别的整数。这一距离测度尤为必要。这个距离是对相似度的一个度量。这个测度值越接近0，LBPF特征点匹配得就越好。 对于ORB描述符来说，这个函数返回的是kptmatch对象。见上。 threshold 是用来为ORB键点过滤不明确匹配服务的。 一个较低的 threshold 值将紧扣关键点匹配算法。 threshold 值位于0 100 (int)。默认值为70。 filter_outliers 是用来为ORB键点过滤异常值服务的。 特征点允许用户提高 threshold 值。默认设置为False。 ## HaarCascade 类 – 特征描述符 Haar Cascade特征描述符用于 `image.find_features()` 方法。它没有供用户调用的方法。 ### 构造函数 class image.HaarCascade(path[, stages Auto]) 从一个Haar Cascade二进制文件\b（适合OpenMV Cam\b的格式）加载一个Haar Cascade。 如果您传递“frontalface”字符串 而非一条路径，这个构造函数将会把一个内置的正脸Haar Cascade载入内存。 此外，您也可以通过“eye”来把Haar Cascade载入内存。 最后，这个方法会返回载入的Haar Cascade对象，用来使用 image.find_features() 。 stages 默认值为Haar Cascade中的阶段数。然而，您可以指定一个较低的数值来加速运行特征检测器，当然这会带来较高的误报率。 > 您可以制作自己的Haar Cascades 来配合您的OpenMV Cam 使用。 首先，使用谷歌搜索“<thing> Haar Cascade”，检测是否有人已经为您想要检测的对象制作了OpenCV Haar Cascade。 如果没有，那您需要自己动手制作（工作量巨大）。 关于如何制作自己的Haar Cascade，见此 关于如何把OpenCV Haar Cascades转化成您的OpenMV Cam可以读取的模式， 见此script 问：Haar Cascade 是什么？ 答：Haar Cascade是一系列用来确定一个对象是否存在于图像中的对比检查。 这一系列的对比检查分成了多个阶段，后一阶段的运行以先前阶段的完成为前提。 对比检查并不复杂，不过是像检查图像的中心垂直是否比边缘更轻微之类的过程。 大范围的检查在前期阶段首先进行，在后期进行更多更小的区域检查。 问：Haar Cascades 是如何制作而成的？ 答：Haar Cascades通过标有正负的图像对发生器算法进行训练。 比如，用数百张含有猫（已被标记为内含猫）的图片和数百张不含有猫形物的图片（已作出不同标记）来训练这个生成算法。 \b\b这个生成算法\b最后会产生一个用来检测猫的Haar Cascades。 ## Similarity 类 – 相似度对象 相似度对象由 `image.get_similarity` 返回. ### 构造函数 class image.similarity 请调用 image.get_similarity() 函数来创建此对象。 #### 方法 ##### similarity.mean() 返回8x8像素块结构相似性差异的均值。范围[ 1/+1]，其中 1完全不同，+1完全相同。 您也可以通过索引 [0] 取得这个值。 ##### similarity.stdev() 返回8x8像素块结构相似性差异的标准偏差。 您也可以通过索引 [1] 取得这个值。 ##### similarity.min() 返回8x8像素块结构相似性差异的最小值。其中 1完全不同，+1完全相同。 您也可以通过索引 [2] 取得这个值。 > 通过查看此值，您可以快速确定两个图像之间的任何8x8像素块是否差别很大，即远远低于+1。 ##### similarity.max() 返回8x8像素块结构相似性差异的最小值。其中 1完全不同，+1完全相同。 您也可以通过索引 [3] 取得这个值。 > 通过查看此值，您可以快速确定两个图像之间的任何8x8像素块是否都相同。即比 1大很多。 ## Histogram 类 – 直方图对象 直方图对象是由 `image.get_histogram` 返回。 灰度直方图有一个包含多个二进制的通道。 所有二进制都进行标准化，使其总和为1。 RGB565有三个包含多个二进制的通道。所有二进制都进行标准化，使其总和为1。 ### 构造函数 class image.histogram 请调用 `image.get_histogram()` 函数来创建此对象。 ### 方法 #### histogram.bins() 返回灰度直方图的浮点数列表。 您也可以通过索引 [0] 取得这个值。 #### histogram.l_bins() 返回RGB565直方图LAB的L通道的浮点数列表。 您也可以通过索引 [0] 取得这个值。 #### histogram.a_bins() 返回RGB565直方图LAB的A通道的浮点数列表。 您也可以通过索引 [1] 取得这个值。 #### histogram.b_bins() 返回RGB565直方图LAB的B通道的浮点数列表。 您也可以通过索引 [2] 取得这个值。 #### histogram.get_percentile(percentile) 计算直方图频道的CDF，返回一个传递 percentile (0.0 1.0) (浮点数)中的直方图的值。 因此，若您传入0.1，该方法会告知您，当累加入累加器时，哪一个二进制会使累加器跨过0.1。 在没有异常效用破坏您的自适应色跟踪结果时，这对于确定颜色分布的最小值(0.1)和max(0.9)甚是有效。 #### histogram.get_threhsold() 使用Otsu’s 方法计算最佳阈值，将直方图分的每个通道为两半。 该方法返回一个 image.threshold 对象。 这个方法对确定最佳的 image.binary() 阈值特别有用。 #### histogram.get_statistics() 计算直方图中每个颜色通道的平均值、中值、众值、标准差、最小值、最大值、下四分值和上四分值， 并返回一个statistics对象。 您也可以使用 histogram.statistics() 和 histogram.get_stats() 作为这个方法的别名。 ## Percentile 类 – 百分比\b值对象 百分比值对象由 `histogram.get_percentile` 返回。 灰度百分比值有一个通道。不使用 l_* 、 a_* 或 b_* 方法。 RGB565百分比值有三个通道。使用 l_* 、 a_* 和 b_* 方法。 ### 构造函数 class image.percentile 请调用 histogram.get_percentile() 函数来创建此对象。 ### 方法 #### percentile.value() 返回灰度百分比值（取值区间为0 255）。 您也可以通过索引 [0] 取得这个值。 #### percentile.l_value() 返回RGB565 LAB 的L通道的百分比值（取值区间为0 100）。 您也可以通过索引 [0] 取得这个值。 #### percentile.a_value() 返回RGB565 LAB 的A通道的百分比值（取值区间为 128 127）。 您也可以通过索引 [1] 取得这个值。 #### percentile.b_value() 返回RGB565 LAB 的B通道的百分比值（取值区间为 128 127）。 您也可以通过索引 [2] 取得这个值。 ## Threhsold 类 – 阈值对象 阈值对象由 histogram.get_threshold 返回。 灰度图像有一个通道。没有 l_*, a_*, 和 b_* 方法. RGB565 阈值有三个通道。使用 l_*, a_*, 和 b_* 方法。 ### 构造函数 class image.threshold 请调用 histogram.get_threshold() 函数来创建此对象。 #### 方法 #### threhsold.value() 返回灰度图的阈值 (between 0 and 255)。 您也可以通过索引 [0] 取得这个值。 #### threhsold.l_value() 返回RGB565图LAB中的L阈值 (between 0 and 100). 您也可以通过索引 [0] 取得这个值。 #### threhsold.a_value() 返回RGB565图LAB中的A阈值 (between 128 and 127). 您也可以通过索引 [1] 取得这个值。 #### threhsold.b_value() 返回RGB565图LAB中的B阈值 (between 128 and 127). 您也可以通过索引 [2] 取得这个值。 ## class Statistics – 统计数据对象 统计数据对象是由 histogram.get_statistics 或 image.get_statistics 返回的。 灰度统计数据有一个通道，使用非 l_* 、 a_* 或 b_* 方法。 RGB565百分比值有三个通道。使用 l_* 、 a_* 和 b_* 方法。 ### 构造函数 class image.statistics 请调用 histogram.get_statistics() 或 image.get_statistics() 函数来创建此对象。 ### 方法 #### statistics.mean() 返回灰度均值(0 255) (int)。 您也可以通过索引 [0] 取得这个值。 #### statistics.median() 返回灰度中值(0 255) (int)。 您也可以通过索引 [1] 取得这个值。 #### statistics.mode() 返回灰度众值(0 255) (int)。 您也可以通过索引 [2] 取得这个值。 #### statistics.stdev() 返回灰度标准差(0 255) (int)。 您也可以通过索引 [3] 取得这个值。 #### statistics.min() 返回灰度最小值(0 255) (int)。 您也可以通过索引 [4] 取得这个值。 #### statistics.max() 返回灰度最大值(0 255) (int)。 您也可以通过索引 [5] 取得这个值。 #### statistics.lq() 返回灰度下四分值(0 255) (int)。 您也可以通过索引 [6] 取得这个值。 #### statistics.uq() 返回灰度上四分值(0 255) (int)。 您也可以通过索引 [7] 取得这个值。 #### statistics.l_mean() 返回RGB5656 LAB 中L的均值(0 255) (int)。 您也可以通过索引 [0] 取得这个值。 #### statistics.l_median() 返回RGB5656 LAB 中L的中值(0 255) (int)。 您也可以通过索引 [1] 取得这个值。 #### statistics.l_mode() 返回RGB5656 LAB 中L的众值(0 255) (int)。 您也可以通过索引 [2] 取得这个值。 #### statistics.l_stdev() 返回RGB5656 LAB 中L的标准偏差值(0 255) (int)。 您也可以通过索引 [3] 取得这个值。 #### statistics.l_min() 返回RGB5656 LAB 中L的最小值(0 255) (int)。 您也可以通过索引 [4] 取得这个值。 #### statistics.l_max() 返回RGB5656 LAB 中L的最大值(0 255) (int)。 您也可以通过索引 [5] 取得这个值。 #### statistics.l_lq() 返回RGB5656 LAB 中L的下四分值(0 255) (int)。 您也可以通过索引 [6] 取得这个值。 #### statistics.l_uq() 返回RGB5656 LAB 中L的上四分值(0 255) (int)。 您也可以通过索引 [7] 取得这个值。 #### statistics.a_mean() 返回RGB5656 LAB 中A的均值(0 255) (int)。 您也可以通过索引 [8] 取得这个值。 #### statistics.a_median() 返回RGB5656 LAB 中A的中值(0 255) (int)。 您也可以通过索引 [9] 取得这个值。 #### statistics.a_mode() 返回RGB5656 LAB 中A的众值(0 255) (int)。 您也可以通过索引 [10] 取得这个值。 #### statistics.a_stdev() 返回RGB5656 LAB 中A的标准偏差值(0 255) (int)。 您也可以通过索引 [11] 取得这个值。 #### statistics.a_min() 返回RGB5656 LAB 中A的最小值(0 255) (int)。 您也可以通过索引 [12] 取得这个值。 #### statistics.a_max() 返回RGB5656 LAB 中A的最大值(0 255) (int)。 您也可以通过索引 [13] 取得这个值。 #### statistics.a_lq() 返回RGB5656 LAB 中A的下四分值(0 255) (int)。 您也可以通过索引 [14] 取得这个值。 #### statistics.a_uq() 返回RGB5656 LAB 中A的上四分值(0 255) (int)。 您也可以通过索引 [15] 取得这个值。 #### statistics.b_mean() 返回RGB5656 LAB 中B的均值(0 255) (int)。 您也可以通过索引 [16] 取得这个值。 #### statistics.b_median() 返回RGB5656 LAB 中B的中值(0 255) (int)。 您也可以通过索引 [17] 取得这个值。 #### statistics.b_mode() 返回RGB5656 LAB 中B的众值(0 255) (int)。 您也可以通过索引 [18] 取得这个值。 #### statistics.b_stdev() 返回RGB5656 LAB 中B的标准差值(0 255) (int)。 您也可以通过索引 [19] 取得这个值。 #### statistics.b_min() 返回RGB5656 LAB 中B的最小值(0 255) (int)。 您也可以通过索引 [20] 取得这个值。 #### statistics.b_max() 返回RGB5656 LAB 中B的最大值(0 255) (int)。 您也可以通过索引 [21] 取得这个值。 #### statistics.b_lq() 返回RGB5656 LAB 中B的下四分值(0 255) (int)。 您也可以通过索引 [22] 取得这个值。 #### statistics.b_uq() 返回RGB5656 LAB 中B的上四分值(0 255) (int)。 您也可以通过索引 [23] 取得这个值。 ## Blob 类 – 色块对象 色块对象是由 `image.find_blobs` 返回的。 ### 构造函数 class image.blob 请调用 image.find_blobs() 函数来创建此对象。 ### 方法 #### blob.rect() 返回一个矩形元组(x, y, w, h) ，用于如色块边界框的 image.draw_rectangle 等 其他的 image 方法。 #### blob.x() 返回色块的边界框的x坐标(int)。 您也可以通过索引 [0] 取得这个值。 #### blob.y() 返回色块的边界框的y坐标(int)。 您也可以通过索引 [1] 取得这个值。 #### blob.w() 返回色块的边界框的w坐标(int)。 您也可以通过索引 [2] 取得这个值。 #### blob.h() 返回色块的边界框的h坐标(int)。 您也可以通过索引 [3] 取得这个值。 #### blob.pixels() 返回从属于色块(int)一部分的像素数量。 您也可以通过索引 [4] 取得这个值。 #### blob.cx() 返回色块(int)的中心x位置。 您也可以通过索引 [5] 取得这个值。 #### blob.cy() 返回色块(int)的中心x位置。 您也可以通过索引 [6] 取得这个值。 #### blob.rotation() 返回色块的旋转（单位：弧度）。如果色块类似铅笔或钢笔，那么这个值就是介于0 180之间的唯一值。 如果这个色块圆的，那么这个值就没有效用。如果这个色块完全不具有对称性，您只能由此得到0 360度的旋转。 您也可以通过索引 [7] 取得这个值。 #### blob.code() 返回一个16位的二进制数字，其中为每个颜色阈值设置一个位，这是色块的一部分。 例如，如果您通过 image.find_blobs 来寻找三个颜色阈值，这个色块可以设置为0/1/2位。 注意：除非以 merge True 调用 image.find_blobs ，否则每个色块只能设置一位。 那么颜色阈值不同的多个色块就可以合并在一起了。 您也可以用这个方法以及多个阈值来实现颜色代码跟踪。 您也可以通过索引 [8] 取得这个值。 #### blob.count() 返回合并为这一色块的多个色块的数量。只有您以 merge True 调用 image.find_blobs 时，这个数字才不是1。 您也可以通过索引 [9] 取得这个值。 #### blob.area() 返回色块周围的边框面积(w * h) #### blob.density() 返回这个色块的密度比。这是在色块边界框区域内的像素点的数量。 总的来说，较低的密度比意味着这个对象的锁定得不是很好。 ## Line类 – 直线对象 直线对象是由 `image.find_lines` , `image.find_line_segments` 或 `image.get_regression` 返回的。 ### 构造函数 class image.line 请调用 image.find_lines(), image.find_line_segments(), 或 image.get_regression() 函数来创建此对象。 ### 方法 #### line.line() 返回一个直线元组(x1, y1, x2, y2) ，用于如 image.draw_line 等其他的 image 方法。 #### line.x1() 返回直线的p1顶点 x坐标分量。 您也可以通过索引 [0] 取得这个值。 #### line.y1() 返回直线的p1 y分量。 您也可以通过索引 [1] 取得这个值。 #### line.x2() 返回直线的p2 x分量。 您也可以通过索引 [2] 取得这个值。 #### line.y2() 返回直线的p2 y分量。 您也可以通过索引 [3] 取得这个值。 #### line.length() 返回直线长度即 sqrt(((x2 x1)^2) + ((y2 y1)^2). 您也可以通过索引 [4] 取得这个值。 #### line.magnitude() 返回霍夫变换后的直线的长度。 您也可以通过索引 [5] 取得这个值。 #### line.theta() 返回霍夫变换后的直线的角度（0 179度）。 您也可以通过索引 [7] 取得这个值。 #### line.rho() 返回霍夫变换后的直线p值。 您也可以通过索引 [8] 取得这个值。 ## Circle类 –圆形对象 圆形对象是由 `image.find_circles` 返回的。 ### 构造函数 class image.circle 请调用 image.find_circles() 函数来创建此对象。 ### 方法 #### circle.x() 返回圆的x位置。 您也可以通过索引 [0] 取得这个值。 #### circle.y() 返回圆的y位置。 您也可以通过索引 [1] 取得这个值。 #### circle.r() 返回圆的半径。 您也可以通过索引 [2] 取得这个值。 #### circle.magnitude() 返回圆的大小。 您也可以通过索引 [3] 取得这个值。 ## Rect类 – 矩形对象 矩形对象是由 `image.find_rects` 返回的。 ### 构造函数 class image.rect 请调用 image.find_rects() 函数来创建此对象。 ### 方法 #### rect.corners() 返回一个由矩形对象的四个角组成的四个元组(x,y)的列表。四个角通常是按照从左上角开始沿顺时针顺序返回的。 #### rect.rect() 返回一个矩形元组(x, y, w, h)，用于如 矩形的边界框的 image.draw_rectangle 等其他的 image 方法。 #### rect.x() 返回矩形的左上角的x位置。 您也可以通过索引 [0] 取得这个值。 #### rect.y() 返回矩形的左上角的y位置。 您也可以通过索引 [1] 取得这个值。 #### rect.w() 返回矩形的宽度。 您也可以通过索引 [2] 取得这个值。 #### rect.h() 返回矩形的高度。 您也可以通过索引 [3] 取得这个值。 #### rect.magnitude() 返回矩形的大小。 您也可以通过索引 [4] 取得这个值。 ## QRCode类 – 二维码对象 二维码对象是由 `image.find_qrcodes` 返回的。 ### 构造函数 class image.qrcode 请调用 image.find_qrcodes() 函数来创建此对象。 ### 方法 #### qrcode.corners() 返回一个由该对象的四个角组成的四个元组(x,y)的列表。四个角通常是按照从左上角开始沿顺时针顺序返回的。 #### qrcode.rect() 返回一个矩形元组(x, y, w, h)，用于如二维码的边界框的 image.draw_rectangle 等其他的 image 方法。 #### qrcode.x() 返回二维码的边界框的x坐标(int)。 您也可以通过索引 [0] 取得这个值。 #### qrcode.y() 返回二维码的边界框的y坐标(int)。 您也可以通过索引 [1] 取得这个值。 #### qrcode.w() 返回二维码的边界框的w坐标(int)。 您也可以通过索引 [2] 取得这个值。 #### qrcode.h() 返回二维码的边界框的h坐标(int)。 您也可以通过索引 [3] 取得这个值。 #### qrcode.payload() 返回二维码有效载荷的字符串，例如URL 。 您也可以通过索引 [4] 取得这个值。 #### qrcode.version() 返回二维码的版本号(int)。 您也可以通过索引 [5] 取得这个值。 #### qrcode.ecc_level() 返回二维码的ECC水平(int)。 您也可以通过索引 [6] 取得这个值。 #### qrcode.mask() 返回二维码的掩码(int)。 您也可以通过索引 [7] 取得这个值。 #### qrcode.data_type() 返回二维码的数据类型。 您也可以通过索引 [8] 取得这个值。 #### qrcode.eci() 返回二维码的ECI。ECI储存了QR码中存储数据字节的编码。若您想要处理包含超过标准ASCII文本的二维码，您需要查看这一数值。 您也可以通过索引 [9] 取得这个值。 #### qrcode.is_numeric() 若二维码的数据类型为数字式，则返回True。 #### qrcode.is_alphanumeric() 若二维码的数据类型为文字数字式，则返回True。 #### qrcode.is_binary() 若二维码的数据类型为二进制式，则返回True。如果您认真处理所有类型的文本，则需要检查eci是否为True，以确定数据的文本编码。通常它只是标准的ASCII，但是它也可能是有两个字节字符的UTF8。 #### qrcode.is_kanji() 若二维码的数据类型为日本汉字，则返回True。设置为True后，您就需要自行解码字符串，因为日本汉字符号每个字符是10位，而MicroPython不支持解析这类文本。 ## AprilTag类 – AprilTag对象 AprilTag对象是由 `image.find_apriltags` 返回的。 ### 构造函数 class image.apriltag 请调用 image.find_apriltags() 函数来创建此对象。 ### 方法 #### apriltag.corners() 返回一个由该对象的四个角组成的四个元组(x,y)的列表。四个角通常是按照从左上角开始沿顺时针顺序返回的。 #### apriltag.rect() 返回一个矩形元组(x, y, w, h)，用于如AprilTag边界框的 image.draw_rectangle 等其他的 image 方法。 #### apriltag.x() 返回AprilTag边界框的x坐标(int)。 您也可以通过索引 [0] 取得这个值。 #### apriltag.y() 返回AprilTag边界框的y坐标(int)。 您也可以通过索引 [1] 取得这个值。 #### apriltag.w() 返回AprilTag边界框的w坐标(int)。 您也可以通过索引 [2] 取得这个值。 #### apriltag.h() 返回AprilTag边界框的h坐标(int)。 您也可以通过索引 [3] 取得这个值。 #### apriltag.id() 返回AprilTag的数字ID。 TAG16H5 > 0 to 29 TAG25H7 > 0 to 241 TAG25H9 > 0 to 34 TAG36H10 > 0 to 2319 TAG36H11 > 0 to 586 ARTOOLKIT > 0 to 511 您也可以通过索引 [4] 取得这个值。 #### apriltag.family() 返回AprilTag的数字家庭。 image.TAG16H5 image.TAG25H7 image.TAG25H9 image.TAG36H10 image.TAG36H11 image.ARTOOLKIT 您也可以通过索引 [5] 取得这个值。 #### apriltag.cx() 返回AprilTag的中心x位置(int)。 您也可以通过索引 [6] 取得这个值。 #### apriltag.cy() 返回AprilTag的中心y位置(int)。 您也可以通过索引 [7] 取得这个值。 #### apriltag.rotation() 返回以弧度计的AprilTag的旋度(int)。 您也可以通过索引 [8] 取得这个值。 #### apriltag.decision_margin() 返回AprilTag匹配的色饱和度（取值0.0 1.0），其中1.0为最佳。 您也可以通过索引 [9] 取得这个值。 #### apriltag.hamming() 返回AprilTag的可接受的数位误差数值。 TAG16H5 > 最多可接受0位错误 TAG25H7 > 最多可接受1位错误 TAG25H9 > 最多可接受3位错误 TAG36H10 > 最多可接受3位错误 TAG36H11 > 最多可接受4位错误 ARTOOLKIT > 最多可接受0位错误 您也可以通过索引 [10] 取得这个值。 #### apriltag.goodness() 返回AprilTag图像的色饱和度（取值0.0 1.0），其中1.0为最佳。 > 目前这一数值通常是0.0。未来我们可以启用一个称为“标签细化”的功能，以实现对更小的AprilTag的检测。然而，现在这个功能将帧速率降低到1 FPS以下。 您也可以通过索引 [11] 取得这个值。 #### apriltag.x_translation() 返回距离摄像机x方向的变换，距离的单位未知。 这个方法对于确定远离摄像机的AprilTag的位置很有用。但是，AprilTag的大小以及您使用的镜头等因素都会影响X单元归属的确定。为使用方便，我们推荐您使用查找表将该方法的输出转换为对您的应用程序有用的信息。 注意：此处的方向为从左至右。 您也可以通过索引 [12] 取得这个值。 #### apriltag.y_translation() 返回距离摄像机y方向的变换，距离的单位未知。 这个方法对于确定远离摄像机的AprilTag的位置很有用。但是，AprilTag的大小以及您使用的镜头等因素都会影响Y单元归属的确定。为使用方便，我们推荐您使用查找表将该方法的输出转换为对您的应用程序有用的信息。 注意：此处的方向为从上至下。 您也可以通过索引 [13] 取得这个值。 #### apriltag.z_translation() 返回距离摄像机z方向的变换，距离的单位未知。 T这个方法对于确定远离摄像机的AprilTag的位置很有用。但是，AprilTag的大小以及您使用的镜头等因素都会影响Z单元归属的确定。为使用方便，我们推荐您使用查找表将该方法的输出转换为对您的应用程序有用的信息。 注意：此处的方向为从前至后。 您也可以通过索引 [14] 取得这个值。 #### apriltag.x_rotation() 返回以弧度计的AprilTag在X平面上的旋度。例：目视AprilTag，从左至右移动摄像头。 您也可以通过索引 [15] 取得这个值。 #### apriltag.y_rotation() 返回以弧度计的AprilTag在Y平面上的旋度。例：目视AprilTag，从上至下移动摄像头。 您也可以通过索引 [16] 取得这个值。 #### apriltag.z_rotation() 返回以弧度计的AprilTag在Z平面上的旋度。例：目视AprilTag，旋转摄像头。 注意：这只是 apriltag.rotation() 的重命名版本。 您也可以通过索引 [17] 取得这个值。 ## DataMatrix类 – 数据矩阵对象 数据矩阵对象是由 `image.find_datamatrices` 返回的。 ## 构造函数 class image.datamatrix 请调用 image.find_datamatrices() 函数来创建此对象。 ### 方法 #### datamatrix.corners() 返回一个由该对象的四个角组成的四个元组(x,y)的列表。四个角通常是按照从左上角开始沿顺时针顺序返回的。 #### datamatrix.rect() 返回一个矩形元组(x, y, w, h)，用于如数据矩阵的边界框的 image.draw_rectangle 等其他的 image 方法。 #### datamatrix.x() 返回数据矩阵的边界框的x坐标(int)。 您也可以通过索引 [0] 取得这个值。 #### datamatrix.y() 返回数据矩阵的边界框的y坐标(int)。 您也可以通过索引 [1] 取得这个值。 #### datamatrix.w() 返回数据矩阵的边界框的w宽度。 您也可以通过索引 [2] 取得这个值。 #### datamatrix.h() 返回数据矩阵的边界框的h高度。 您也可以通过索引 [3] 取得这个值。 #### datamatrix.payload() 返回数据矩阵的有效载荷的字符串。例：字符串。 您也可以通过索引 [4] 取得这个值。 #### datamatrix.rotation() 返回以弧度计的数据矩阵的旋度(浮点数)。 您也可以通过索引 [5] 取得这个值。 #### datamatrix.rows() 返回数据矩阵的行数(int)。 您也可以通过索引 [6] 取得这个值。 #### datamatrix.columns() 返回数据矩阵的列数(int)。 您也可以通过索引 [7] 取得这个值。 #### datamatrix.capacity() 返回这一数据矩阵所能容纳的字符的数量。 您也可以通过索引 [8] 取得这个值。 #### datamatrix.padding() 返回这一数据矩阵中未使用的字符的数量。 您也可以通过索引 [9] 取得这个值。 ## BarCode类 – 条形码对象 条形码对象是由 image.find_barcodes 返回的。 ## 构造函数 class image.barcode 请调用 image.find_barcodes() 函数来创建此对象。 ### 方法 #### barcode.corners() 返回一个由该对象的四个角组成的四个元组(x,y)的列表。四个角通常是按照从左上角开始沿顺时针顺序返回的。 #### barcode.rect() 返回一个矩形元组(x, y, w, h)，用于如数据矩阵的边界框的 image.draw_rectangle 等其他的 image 方法。 #### barcode.x() 返回条形码的边界框的x坐标(int)。 您也可以通过索引 [0] 取得这个值。 #### barcode.y() 返回条形码的边界框的y坐标(int)。 您也可以通过索引 [1] 取得这个值。 #### barcode.w() 返回条形码的边界框的w宽度(int)。 您也可以通过索引 [2] 取得这个值。 #### barcode.h() 返回条形码的边界框的h高度(int)。 您也可以通过索引 [3] 取得这个值。 #### barcode.payload() 返回条形码的有效载荷的字符串。例：数量。 您也可以通过索引 [4] 取得这个值。 #### barcode.type() 返回条形码的列举类型 (int)。 您也可以通过索引 [5] 取得这个值。 image.EAN2 image.EAN5 image.EAN8 image.UPCE image.ISBN10 image.UPCA image.EAN13 image.ISBN13 image.I25 image.DATABAR image.DATABAR_EXP image.CODABAR image.CODE39 image.PDF417 未来启用 (e.g. 现在还不能正常使用). image.CODE93 image.CODE128 #### barcode.rotation() 返回以弧度计的条形码的旋度(浮点数)。 您也可以通过索引 [6] 取得这个值。 #### barcode.quality() 返回条形码在图像中被检测到的次数(int)。 扫描条形码时，每一条新的扫描线都能解码相同的条形码。每次进行这一过程，条形码的值都会随之增加。 您也可以通过索引 [7] 取得这个值。 ## Displacement类 – 位移对象 位移对象由 image.find_displacement 返回。 ### 构造函数 class image.displacement 请调用 image.find_displacement() 函数来创建此对象。 ### 方法 #### displacement.x_translation() 返回两个图像之间的x平移像素。 这是精确的子像素，所以它是一个浮点数。 您也可以通过索引 [0] 取得这个值。 #### displacement.y_translation() 返回两个图像之间的y平移像素。 这是精确的子像素，所以它是一个浮点数。 您也可以通过索引 [1] 取得这个值。 #### displacement.rotation() 返回两个图像之间的z平移像素。 这是精确的子像素，所以它是一个浮点数。 您也可以通过索引 [2] 取得这个值。 #### displacement.scale() 返回两个图像之间旋转的弧度。 您也可以通过索引 [3] 取得这个值。 #### displacement.response() 返回两幅图像之间位移匹配结果的质量。 范围 0 1。响应小于0.1的 displacement 对象可能是噪声。 您也可以通过索引 [4] 取得这个值。 ## Kptmatch类 – 特征点对象 特征点对象是由 `image.match_descriptor` 返回的。 ### 构造函数 class image.kptmatch 请调用 image.match_descriptor() 函数来创建此对象。 ### 方法 #### kptmatch.rect() 返回一个矩形元组(x, y, w, h)，用于如特征点的边界框的 image.draw_rectangle 等其他的 image 方法。 #### kptmatch.cx() 返回特征点的中心x位置(int)。 您也可以通过索引 [0] 取得这个值。 #### kptmatch.cy() 返回特征点的中心y位置(int)。 您也可以通过索引 [1] 取得这个值。 #### kptmatch.x() 返回特征点边界框的x坐标(int)。 您也可以通过索引 [2] 取得这个值。 #### kptmatch.y() 返回特征点边界框的y坐标(int)。 您也可以通过索引 [3] 取得这个值。 #### kptmatch.w() 返回特征点边界框的w宽度(int)。 您也可以通过索引 [4] 取得这个值。 #### kptmatch.h() 返回特征点边界框的h高度(int)。 您也可以通过索引 [5] 取得这个值。 #### kptmatch.count() 返回匹配的特征点的数量(int)。 您也可以通过索引 [6] 取得这个值。 #### kptmatch.theta() 返回估计的特征点的旋度(int)。 您也可以通过索引 [7] 取得这个值。 #### kptmatch.match() 返回匹配关键点的(x，y)元组列表。 您也可以通过索引 [8] 取得这个值。 ## ImageWriter类 – ImageWriter对象 ImageWriter 对象使得您可以快速地将未压缩的图像写入磁盘。 ##＃　构造函数 class image.ImageWriter(path) 创建一个ImageWriter对象，您就可以以用于OpenMV Cams的简单文件格式将未压缩的图像写到磁盘上。然后未压缩的图像可以使用ImageReader重新读取。 ### 方法 #### imagewriter.size() 返回正在写入的文件的大小。 #### imagewriter.add_frame(img) 将一张图像写入磁盘。由于图像未被压缩，因此执行迅速，但会占用大量磁盘空间。 #### imagewriter.close() 关闭图像流文件。您必须关闭文件，否则文件会损坏。 ## ImageReader 类– ImageReader对象 ImageReader对象使得您可以快速地从磁盘中读取未压缩的图像。 ### 构造函数 class image.ImageReader(path) 创建一个ImageReader对象，用来回放由ImageWriter对象编写的图像数据。ImageWriter对象回放的帧会在与写入磁盘时相同的FPS下回放。 ### 方法 #### imagereader.size() 返回正在读取的文件的大小。 imagereader.next_frame([copy_to_fb True, loop True]) 从ImageWriter写就的文件中返回图像对象。若 copy_to_fb 为True，图像对象将被直接加载到帧缓冲区中。否则图像对象将被放入堆中。注意：除非图像很小，否则堆可能没有足够的空间来存储图像对象。 若 loop 为True，流的最后一个图像读取之后，回放将重新开始。否则所有帧被读取后，这个方法将返回None。 注意： imagereader.next_frame 尝试在读取帧后通过暂停播放来限制回放速度，以与帧记录的速度相匹配。 否则，这个方法会以200+FPS的速度图像快读播放所有图像。 #### imagereader.close() 关闭正在读取的文件。您需要进行这一操作，以防imagereader 对象受损。但由于是只读文件，文件不会在未关闭时受损。 ## Image类 – 图像对象 图像对象是机器视觉操作的基本对象。 ### 构造函数 class image.Image(path[, copy_to_fb False]) 从 path 中的文件中创建一个新的图像对象。 支持bmp/pgm/ppm/jpg/jpeg格式的图像文件。 若 copy_to_fb 为True，图像会直接载入帧缓冲区，您就可以加载大幅图片了。若为False，图像会载入MicroPython的堆中，堆远比帧缓冲区小。 在OpenMV Cam M4中，若 copy_to_fb 为False，您应该尽量把图像大小控制在8KB以下。若为True，则图像最大可为160KB。 在OpenMV Cam M7中，若 copy_to_fb 为False，您应该尽量把图像大小控制在16KB以下。若为True，则图像最大可为320KB。 图像支持“[]”记法。 令 image[index] 8/16 bit value ，以便分配图像像素或 image[index] ，并得到一个图像像素，若是用于RGB图像的16位RGB565值的灰度图像， 这一像素则为8位。 对于JPEG图像而言，“[]”使得您可以访问压缩的节数组形式的JPEG图像色块。由于JPEG图像是压缩的字节流形式，因而对数据组的读取和写入是不透明的。 图像还支持读缓冲区操作。您可以把图像当作节数组对象，将图像输入所有类型的MicroPython函数。若您想传送一个图像，可以将它传递给UART /SPI/ I2C写入函数，可实现自动传送。 ### 方法 #### image.width() 返回以像素计的图像的宽度。 #### image.height() 返回以像素计的图像的高度。 #### image.format() 返回用于灰度图的 sensor.GRAYSCALE 、用于RGB图像的 sensor.RGB565 和用于JPEG图像的 sensor.JPEG 。 #### image.size() 返回以字节计的图像大小。 #### image.get_pixel(x, y[, rgbtuple]) 灰度图：返回(x, y)位置的灰度像素值。 RGB565l：返回(x, y)位置的RGB888像素元组(r, g, b)。 Bayer图像: 返回(x, y)位置的像素值。 不支持压缩图像。 > image.get_pixel() 和 `image.set_pixel()`是允许你操作Bayer模式图像的唯一方法。 Bayer模式图像是文字图像。对于偶数行，其中图像中的像素是R/G/R/G/等。 对于奇数行，其中图像中的像素是G/B/G/B/等。 每个像素是8位。 #### image.set_pixel(x, y, pixel) 灰度图：将(x, y) 位置的像素设置为灰度值 pixel 。 RGB图像：将(x, y) 位置的像素设置为RGB888元组(r, g, b) pixel 。 不支持压缩图像。 > image.get_pixel() 和 `image.set_pixel()`是允许你操作Bayer模式图像的唯一方法。 Bayer模式图像是文字图像。对于偶数行，其中图像中的像素是R/G/R/G/等。 对于奇数行，其中图像中的像素是G/B/G/B/等。 每个像素是8位。 #### image.mean_pool(x_div, y_div) 在图像中找到 x_div * y_div 正方形的平均值，并返回由每个正方形的平均值组成的修改图像。 此方法允许您在原来图像上快速缩小图像。 不支持压缩图像和bayer图像。 #### image.mean_pooled(x_div, y_div) 在图像中找到 x_div * y_div 正方形的平均值，并返回由每个正方形的平均值组成的新图像。 此方法允许您创建缩小的图像副本。 不支持压缩图像和bayer图像。 #### image.midpoint_pool(x_div, y_div[, bias 0.5]) 在图像中找到 x_div * y_div 正方形的中点值，并返回由每个正方形的中点值组成的修改图像。 bias 为0.0返回每个区域的最小值，而``bias`` 为1.0返回每个区域的最大值。 此方法允许您在原来图像上快速缩小图像。 不支持压缩图像和bayer图像。 #### image.midpoint_pooled(x_div, y_div[, bias 0.5]) 在图像中找到 x_div * y_div 正方形的中点值，并返回由每个正方形的中点值组成的新图像。 bias 为0.0返回每个区域的最小值，而``bias`` 为1.0返回每个区域的最大值。 此方法允许您创建缩小的图像副本。 不支持压缩图像和bayer图像。 #### image.to_grayscale([copy False]) 将图像转换为灰度图像。 此方法也会修改基础图像像素，以字节为单位更改图像大小，因此只能在灰度图像或RGB565图像上进行。 否则 copy 必须为True才能在堆上创建新的修改图像。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 #### image.to_rgb565([copy False]) 将图像转换为彩色图像。 此方法也会修改基础图像像素，以字节为单位更改图像大小，因此只能在RGB565图像上进行。 否则 copy 必须为True才能在堆上创建新的修改图像。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 #### image.to_rainbow([copy False]) 将图像转换为彩虹图像。 此方法也会修改基础图像像素，以字节为单位更改图像大小，因此只能在RGB565图像上进行。 否则 copy 必须为True才能在堆上创建新的修改图像。 彩虹图像是彩色图像，对于图像中的每个8位掩模灰度照明值具有唯一的颜色值。 例如，它为热图像提供热图颜色。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 #### image.compress([quality 50]) JPEG对图像进行适当压缩。使用这种方法与 compressed 保存堆空间相比，使用更高quality的压缩率是以破坏原始图像为代价的。 quality 是压缩质量（0 100）（int）。 #### image.compress_for_ide([quality 50]) JPEG对图像进行适当压缩。使用这种方法与 compressed 保存堆空间相比，使用更高quality的压缩率是以破坏原始图像为代价的。 这个方法压缩图像，然后通过将每6比特编码为128 191之间的字节将JPEG数据格式化，转换为OpenMV IDE，以便显示。进行这一步是为防止JPEG数据被误认为是字节流中的其他文本数据。 您需要使用这一方法来格式化图像数据，以便在OpenMV IDE中通过“开放终端”创建的终端窗口中显示。 quality 是压缩质量（0 100）（int）。 #### image.compressed([quality 50]) 返回一个JPEG压缩图像—原始图像未经处理。但是，这个方法需要堆空间的大分配，所以图像压缩质量和图像分辨率必须很低。 quality 是压缩质量（0 100）（int）。 #### image.compressed_for_ide([quality 50]) 返回一个JPEG压缩图像—原始图像未经处理。但是，这个方法需要堆空间的大分配，所以图像压缩质量和图像分辨率必须很低。 这个方法压缩图像，然后通过将每6比特编码为128 191之间的字节将JPEG数据格式化，转换为OpenMV IDE，以便显示。进行这一步是为防止JPEG数据被误认为是字节流中的其他文本数据。 您需要使用这一方法来格式化图像数据，以便在OpenMV IDE中通过“开放终端”创建的终端窗口中显示。 quality 是压缩质量（0 100）（int）。 #### image.copy([roi[, copy_to_fb False]]) 创建一个图像对象的副本。 Roi 是一个用以复制的矩形的感兴趣区域(x, y, w, h)。如果未指定，ROI即复制整个图像的图像矩形。但这不适用于JPEG图像。 请记住图像副本储存在MicroPython 堆中而不是帧缓冲区。同样，您需要将图像副本大小控制在8KB以下（OpenMV）或16KB以下（OpenMV Cam M7） 如果您想使用一个复制操作来使用所有的堆空间，这个函数会出现异常。过大的图像极易触发异常。 如果 copy_to_fb 为True，则该方法将帧缓冲替换为图像。 帧缓冲区具有比堆大得多的空间，并且可以容纳大图像。 #### image.save(path[, roi[, quality 50]]) 将图像的副本保存到 path 中的文件系统。 支持bmp/pgm/ppm/jpg/jpeg格式的图像文件。注意：您无法将jpeg格式的压缩图像保存成未压缩的格式。 roi 是一个用以复制的矩形的感兴趣区域(x, y, w, h)。如果未指定，ROI即复制整个图像的图像矩形。但这不适用于JPEG图像。 quality 指在图像尚未被压缩时将图像保存为JPEG格式的JPEG压缩质量。 #### image.clear() 将图像中的所有像素设置为零（非常快）。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像。 #### image.draw_line(x0, y0, x1, y1[, color[, thickness 1]]) 在图像上绘制一条从(x0，y0)到(x1，y1)的线。 您可以单独传递x0，y0，x1，y1，也可以传递给元组(x0，y0，x1，y1)。 color 是用于灰度或RGB565图像的RGB888元组。默认为白色。但是，您也可以传递灰度图像的基础像素值(0 255)或RGB565图像的字节反转RGB565值。 thickness 控制线的粗细像素。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 #### image.draw_rectangle(x, y, w, h[, color[, thickness 1[, fill False]]]) 在图像上绘制一个矩形。 您可以单独传递x，y，w，h或作为元组(x，y，w，h)传递。 color 是用于灰度或RGB565图像的RGB888元组。默认为白色。但是，您也可以传递灰度图像的基础像素值(0 255)或RGB565图像的字节反转RGB565值。 thickness 控制线的粗细像素。 将 fill 设置为True以填充矩形。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 #### image.draw_ellipse(cx, cy, rx, ry, rotation[, color[, thickness 1[, fill False]]]) 在图像上绘制椭圆。您可以单独传递cx、cy、rx、ry和rotation(以度为单位)，也可以作为元组传递(cx、yc、rx、ry、rotation)。 color 是用于灰度或RGB565图像的RGB888元组。默认为白色。 但是，您也可以为灰度图像传递基础像素值(0 255)，或者为RGB565图像传递字节反转的RGB565值。 thickness 控制边缘的厚度，以像素为单位。 传递 fill 设置为True来填充椭圆。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像或bayer图像。 #### image.draw_circle(x, y, radius[, color[, thickness 1[, fill False]]]) 在图像上绘制一个圆形。 您可以单独传递x，y，半径 或 作为元组(x，y，radius)传递。 color 是用于灰度或RGB565图像的RGB888元组。默认为白色。但是，您也可以传递灰度图像的基础像素值(0 255)或RGB565图像的字节反转RGB565值。 thickness 控制线的粗细像素。 将 fill 设置为True以填充圆形。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 #### image.draw_string(x, y, text[, color[, scale 1[, x_spacing 0[, y_spacing 0[, mono_space True]]]]]) 从图像中的(x, y)位置开始绘制8x10文本。您可以单独传递x，y，也可以作为元组(x，y)传递。 text 是写入图像的字符串。 \\n, \\r, 和 \\r\\n 结束符将光标移至下一行。 color 是用于灰度或RGB565图像的RGB888元组。默认为白色。但是，您也可以传递灰度图像的基础像素值(0 255)或RGB565图像的字节反转RGB565值。 可以增加 scale 以增加图像上文本的大小。 仅整数值（例如，1/2/3 /等）。 x_spacing 允许你在字符之间添加（如果是正数）或减去（如果是负数）x像素，设置字符间距。 y_spacing 允许你在字符之间添加（如果是正数）或减去（如果是负数）y像素，设置行间距。 mono_space 默认为True，强制文本间距固定。对于大文本，这看起来很糟糕。设置False以获得非固定宽度的字符间距，看起来好多了。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 #### image.draw_cross(x, y[, color[, size 5[, thickness 1]]]) 在图像上绘制一个十字。 您可以单独传递x，y或作为元组(x，y)传递。 color 是用于灰度或RGB565图像的RGB888元组。默认为白色。但是，您也可以传递灰度图像的基础像素值(0 255)或RGB565图像的字节反转RGB565值。 size 控制十字线的延伸长度。 thickness 控制边缘的像素厚度。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 #### image.draw_arrow(x0, y0, x1, y1[, color[, thickness 1]]) 在图像上绘制一条从(x0，y0)到(x1，y1)的箭头。 您可以单独传递x0，y0，x1，y1，也可以传递给元组(x0，y0，x1，y1)。 color 是用于灰度或RGB565图像的RGB888元组。默认为白色。但是，您也可以传递灰度图像的基础像素值(0 255)或RGB565图像的字节反转RGB565值。 thickness 控制线的粗细像素。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 #### image.draw_image(image, x, y[, x_scale 1.0[, y_scale 1.0[, mask None[, alpha 256]]]]) 绘制一个 image ，其左上角从位置x，y开始。 您可以单独传递x，y，也可以传递给元组(x，y)。 x_scale 控制图像在x方向(浮点数)缩放的程度。 y_scale 控制图像在y方向(浮点数)缩放的程度。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 您可以使用mask掩码进行绘制操作。 alpha 控制源图像绘制到目标图像中的透明度。256 为绘制不透明的源图像，而小于 256 的值产生源图像和目标图像之间的混合。0 表示不修改目标图像。 不支持压缩图像和bayer图像。 #### image.draw_keypoints(keypoints[, color[, size 10[, thickness 1[, fill False]]]]) 在图像上画出一个特征点对象的各个点。 color 是用于灰度或RGB565图像的RGB888元组。默认为白色。但是，您也可以传递灰度图像的基础像素值(0 255)或RGB565图像的字节反转RGB565值。 size 控制特征点的大小。 thickness 控制线的粗细像素。 将 fill 设置为True以填充特征点。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 #### image.flood_fill(x, y[, seed_threshold 0.05[, floating_threshold 0.05[, color[, invert False[, clear_background False[, mask None]]]]]]) 从位置x，y开始填充图像的区域。 您可以单独传递x，y，也可以传递给元组(x，y)。 seed_threshold 控制填充区域中的像素与原始起始像素的差异。 floating_threshold 控制填充区域中的像素与任何相邻像素的差异。 color 是用于灰度或RGB565图像的RGB888元组。默认为白色。但是，您也可以传递灰度图像的基础像素值(0 255)或RGB565图像的字节反转RGB565值。 将 invert 传递为True，以重新填充flood_fill连接区域外的所有内容。 将 clear_background 传递为True，将其余的flood_fill没有重新着色的像素归零。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩膜中设置的像素会在flood_fill时被评估。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 此方法在OpenMV Cam M4 上不可用。 #### image.binary(thresholds[, invert False[, zero False[, mask None]]]) 根据像素是否在阈值列表 thresholds 中的阈值内，将图像中的所有像素设置为黑色或白色。 thresholds 必须是元组列表。 [(lo, hi), (lo, hi), ..., (lo, hi)] 定义你想追踪的颜色范围。 对于灰度图像，每个元组需要包含两个值 最小灰度值和最大灰度值。 仅考虑落在这些阈值之间的像素区域。 对于RGB565图像，每个元组需要有六个值(l_lo，l_hi，a_lo，a_hi，b_lo，b_hi) 分别是LAB L，A和B通道的最小值和最大值。 为方便使用，此功能将自动修复交换的最小值和最大值。 此外，如果元组大于六个值，则忽略其余值。相反，如果元组太短，则假定其余阈值处于最大范围。 注解 获取所跟踪对象的阈值，只需在 IDE 帧缓冲区中选择（单击并拖动）跟踪对象。 直方图会相应地更新到所在区域。然后只需写下颜色分布在每个直方图通道中起始与下降位置。 这些将是 thresholds 的低值和高值。 由于上下四分位数据相差微小，故手动确定阈值为佳。 您还可以通过进入OpenMV IDE中的 工具 >机器视觉 >阈值编辑器 并从GUI窗口中拖动滑块来确定颜色阈值。 invert 反转阈值操作，像素在已知颜色范围之外进行匹配，而非在已知颜色范围内。 设置 zero 为True来使阈值像素为零，并使不在阈值列表中的像素保持不变。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 #### image.invert() 将二进制图像0（黑色）变为1（白色），1（白色）变为0（黑色），非常快速地翻转二进制图像中的所有像素值。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和Bayer图像。 #### image.b_and(image[, mask None]) 用另一图像与这一图像进行逻辑与运算。 image 可以是图像对象，未压缩图像文件的路径(bmp/pgm/ppm)，也可以是标量值。 如果标量值，该值可以是RGB888元组或基础像素值(例如，灰度图像的8位灰度级或RGB图像的字节反转RGB565值)。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 #### image.b_nand(image[, mask None]) 用另一图像与这一图像进行逻辑与非运算。 image 可以是图像对象，未压缩图像文件的路径(bmp/pgm/ppm)，也可以是标量值。 如果标量值，该值可以是RGB888元组或基础像素值(例如，灰度图像的8位灰度级或RGB图像的字节反转RGB565值)。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 #### image.b_or(image[, mask None]) 用另一图像与这一图像进行逻辑或运算。 image 可以是图像对象，未压缩图像文件的路径(bmp/pgm/ppm)，也可以是标量值。 如果标量值，该值可以是RGB888元组或基础像素值(例如，灰度图像的8位灰度级或RGB图像的字节反转RGB565值)。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 #### image.b_nor(image[, mask None]) 用另一图像与这一图像进行逻辑或非运算。 image 可以是图像对象，未压缩图像文件的路径(bmp/pgm/ppm)，也可以是标量值。 如果标量值，该值可以是RGB888元组或基础像素值(例如，灰度图像的8位灰度级或RGB图像的字节反转RGB565值)。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 #### image.b_xor(image[, mask None]) 用另一图像与这一图像进行逻辑异或运算。 image 可以是图像对象，未压缩图像文件的路径(bmp/pgm/ppm)，也可以是标量值。 如果标量值，该值可以是RGB888元组或基础像素值(例如，灰度图像的8位灰度级或RGB图像的字节反转RGB565值)。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 #### image.b_xnor(image[, mask None]) 用另一图像与这一图像进行逻辑同或运算。 image 可以是图像对象，未压缩图像文件的路径(bmp/pgm/ppm)，也可以是标量值。 如果标量值，该值可以是RGB888元组或基础像素值(例如，灰度图像的8位灰度级或RGB图像的字节反转RGB565值)。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 #### image.erode(size[, threshold[, mask None]]) 从分割区域的边缘删除像素。 这一方法通过卷积图像上((size*2)+1)x((size*2)+1)像素的核来实现，如果相邻像素集的总和小于 threshold ，则对内核的中心像素进行归零。 若 threshold 未设定，这个方法的功能如标准腐蚀方法一样。若threshold设定，您就可以指定腐蚀的特定像素，例如：设置低于2个的像素周围阈值为2。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 #### image.dilate(size[, threshold[, mask None]]) 将像素添加到分割区域的边缘中。 这一方法通过卷积图像上((size*2)+1)x((size*2)+1)像素的核来实现，如果相邻像素集的总和大于 threshold ，则将内核的中心像素进行设置。 若 threshold 未设定，这个方法的功能如标准腐蚀方法一样。若threshold设定，您就可以指定腐蚀的特定像素，例如：设置低于2个的像素周围阈值为2。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 #### image.open(size[, threshold[, mask None]]) 按顺序对图像执行腐蚀和膨胀。有关更多信息，请参阅 image.erode() 和 image.dilate() 。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 #### image.close(size[, threshold[, mask None]]) 按顺序对图像执行膨胀和腐蚀。有关更多信息，请参阅 image.erode() 和 image.dilate() 。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 #### image.top_hat(size[, threshold[, mask None]]) 返回原图像和执行 image.open() 函数后图像的差异。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 不支持压缩图像和bayer图像。 #### image.black_hat(size[, threshold[, mask None]]) 返回原图像和执行 image.close() 函数后图像的差异。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 不支持压缩图像和bayer图像。 #### image.negate() 非常快速地翻转（数字反转）图像中的所有像素值。对每个颜色通道的像素值进行数值转换。例： (255 pixel). 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 #### image.replace(image[, hmirror False[, vflip False[, mask None]]]) image 可以是图像对象，未压缩图像文件的路径(bmp/pgm/ppm)，也可以是标量值。 如果标量值，该值可以是RGB888元组或基础像素值(例如，灰度图像的8位灰度级或RGB图像的字节反转RGB565值)。 将 hmirror 设置为True以水平镜像替换图像。 将 vflip 设置为True以垂直翻转替换图像。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 #### image.add(image[, mask None]) 将两个图像彼此按像素相加。 image 可以是图像对象，未压缩图像文件的路径(bmp/pgm/ppm)，也可以是标量值。 如果标量值，该值可以是RGB888元组或基础像素值(例如，灰度图像的8位灰度级或RGB图像的字节反转RGB565值)。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 #### image.sub(image[, reverse False[, mask None]]) 将两个图像彼此按像素相减。 image 可以是图像对象，未压缩图像文件的路径(bmp/pgm/ppm)，也可以是标量值。 如果标量值，该值可以是RGB888元组或基础像素值(例如，灰度图像的8位灰度级或RGB图像的字节反转RGB565值)。 将 reverse 设置为True可以将减法操作从 this_image image 反转为 image this_image 。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 #### image.mul(image[, invert False[, mask None]]) 将两个图像彼此按像素相乘。 image 可以是图像对象，未压缩图像文件的路径(bmp/pgm/ppm)，也可以是标量值。 如果标量值，该值可以是RGB888元组或基础像素值(例如，灰度图像的8位灰度级或RGB图像的字节反转RGB565值)。 将 invert 设置为True可将乘法运算从 a*b 改为 1/((1/a)*(1/b))。 特别是，这使图像变亮而不是使图像变暗(例如，乘法与刻录操作)。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 #### image.div(image[, invert False[, mask None]]) 将此图像除以另一个图像。 image 可以是图像对象，未压缩图像文件的路径(bmp/pgm/ppm)，也可以是标量值。 如果标量值，该值可以是RGB888元组或基础像素值(例如，灰度图像的8位灰度级或RGB图像的字节反转RGB565值)。 将 invert 设置为True可将除法方向从 a/b 改为 b/a。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 #### image.min(image[, mask None]) 在像素级 用此图像和另一个图像之间的最小像素值替换此图像中的像素。 image 可以是图像对象，未压缩图像文件的路径(bmp/pgm/ppm)，也可以是标量值。 如果标量值，该值可以是RGB888元组或基础像素值(例如，灰度图像的8位灰度级或RGB图像的字节反转RGB565值)。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 这个方法在OpenMV4上不可用. #### image.max(image[, mask None]) 在像素级 用此图像和另一个图像之间的最大像素值替换此图像中的像素。 image 可以是图像对象，未压缩图像文件的路径(bmp/pgm/ppm)，也可以是标量值。 如果标量值，该值可以是RGB888元组或基础像素值(例如，灰度图像的8位灰度级或RGB图像的字节反转RGB565值)。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 #### image.difference(image[, mask None]) 将两个图像彼此按像素取绝对值。例：对于每个颜色通道而言，将每个像素��换为ABS(this.pixel image.pixel)。 image 可以是图像对象，未压缩图像文件的路径(bmp/pgm/ppm)，也可以是标量值。 如果标量值，该值可以是RGB888元组或基础像素值(例如，灰度图像的8位灰度级或RGB图像的字节反转RGB565值)。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 #### image.blend(image[, alpha 128[, mask None]]) 将另外一张图像 image 与这一图像融合。 image 可以是图像对象，未压缩图像文件的路径(bmp/pgm/ppm)，也可以是标量值。 如果标量值，该值可以是RGB888元组或基础像素值(例如，灰度图像的8位灰度级或RGB图像的字节反转RGB565值)。 alpha 控制要混合到这个图像中的其他图像的多少. alpha 应该是0到256之间的整数值。接近零的值会将更多其他图像混合到此图像中，接近256则相反。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 #### image.histeq([adaptive False[, clip_limit 1[, mask None]]]) 在图像上运行直方图均衡算法。 直方图均衡化使图像中的对比度和亮度标准化。 如果 adaptive 传递为True，那么将在图像上运行自适应直方图均衡方法，这通常比非自适应直方图限定更好，但运行时间更长。 clip_limit 提供了一种限制自适应直方图均衡的对比度的方法。 使用较小的值(例如10)可以生成良好的直方图均衡对比度受限图像。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 #### image.mean(size, [threshold False, [offset 0, [invert False, [mask None]]]]]) 使用盒式滤波器的标准均值模糊滤波。 Size 是内核的大小。取1 (3x3 内核)、2 (5x5 内核)或更高值。 如果你想在滤波器的输出上自适应地设置阈值，你可以传递 threshold True 参数来启动图像的自适应阈值处理， 他根据环境像素的亮度（核函数周围的像素的亮度有关），将像素设置为1或者0。 负数 offset 值将更多像素设置为1，而正值仅将最强对比度设置为1。 设置 invert 以反转二进制图像的结果输出。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 median(size, percentile 0.5, threshold False, offset 0, invert False, mask]) 在图像上运行中值滤波。在保留边缘的条件下，中值滤波是用来平滑表面的最佳滤波，但是运行速度极慢。 Size 是内核的大小。取1 (3x3 内核)、2 (5x5 内核)或更高值。 percentile 控制内核中所使用值的百分位数。默认情况下，每个像素都使用相邻的第五十个百分位数（中心）替换。使用最小滤波时，您可将此值设置为0，使用下四分位数滤波时设置为0.25，使用上四分位数滤波时设置为0.75，使用最大滤波时设置为1。 如果你想在滤波器的输出上自适应地设置阈值，你可以传递 threshold True 参数来启动图像的自适应阈值处理， 他根据环境像素的亮度（核函数周围的像素的亮度有关），将像素设置为1或者0。 负数 offset 值将更多像素设置为1，而正值仅将最强对比度设置为1。 设置 invert 以反转二进制图像的结果输出。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 此方法在OpenMV Cam M4 上不可用。 #### image.mode(size[, threshold False, offset 0, invert False, mask]) 在图像上运行众数滤波，用相邻像素的模式替换每个像素。这一方法在灰度图上运行效果良好。但由于这一操作的非线性特性，会在RGB图像边缘上产生许多伪像。 Size 是内核的大小。取1 (3x3 内核)、2 (5x5 内核)。 如果你想在滤波器的输出上自适应地设置阈值，你可以传递 threshold True 参数来启动图像的自适应阈值处理， 他根据环境像素的亮度（核函数周围的像素的亮度有关），将像素设置为1或者0。 负数 offset 值将更多像素设置为1，而正值仅将最强对比度设置为1。 设置 invert 以反转二进制图像的结果输出。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 此方法在OpenMV Cam M4 上不可用。 #### image.midpoint(size[, bias 0.5, threshold False, offset 0, invert False, mask]) 在图像上运行中点滤波。此滤波器找到图像中每个像素邻域的中点((max min)/2)。 size 是内核的大小。取1 (3x3 内核)、2 (5x5 内核)或更高值。 bias 控制图像混合的最小/最大程度。0只适用于最小滤波，1仅用于最大滤波。您可以通过 bias 对图像进行最小/最大化过滤。 如果你想在滤波器的输出上自适应地设置阈值，你可以传递 threshold True 参数来启动图像的自适应阈值处理， 他根据环境像素的亮度（核函数周围的像素的亮度有关），将像素设置为1或者0。 负数 offset 值将更多像素设置为1，而正值仅将最强对比度设置为1。 设置 invert 以反转二进制图像的结果输出。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 此方法在OpenMV Cam M4 上不可用。 #### image.morph(size, kernel, mul Auto, add 0) 通过过滤器内核对图像进行卷积。这允许您对图像执行通用卷积。 size 将内核的大小控制为((size*2)+1)x((size*2)+1)像素。 kernel 用来卷积图像的内核，可为一个元组或一个取值[ 128:127]的列表。 mul 是用以与卷积像素结果相乘的数字。若不设置，则默认一个值，该值将防止卷积输出中的缩放。 add 是用来与每个像素卷积结果相加的数值。 mul 可进行全局对比度调整，add可进行全局亮度调整。 如果你想在滤波器的输出上自适应地设置阈值，你可以传递 threshold True 参数来启动图像的自适应阈值处理， 他根据环境像素的亮度（核函数周围的像素的亮度有关），将像素设置为1或者0。 负数 offset 值将更多像素设置为1，而正值仅将最强对比度设置为1。 设置 invert 以反转二进制图像的结果输出。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 #### image.gaussian(size[, unsharp False[, mul[, add 0[, threshold False[, offset 0[, invert False[, mask None]]]]]]]) 通过平滑高斯核对图像进行卷积。 size 是内核的大小。取1 (3x3 内核)、2 (5x5 内核)或更高值。 如果 unsharp 设置为True，那么这种方法不会仅进行高斯滤波操作，而是执行非锐化掩模操作，从而提高边缘的图像清晰度。 mul 是用以与卷积像素结果相乘的数字。若不设置，则默认一个值，该值将防止卷积输出中的缩放。 add 是用来与每个像素卷积结果相加的数值。 mul 可进行全局对比度调整，add可进行全局亮度调整。 如果你想在滤波器的输出上自适应地设置阈值，你可以传递 threshold True 参数来启动图像的自适应阈值处理， 他根据环境像素的亮度（核函数周围的像素的亮度有关），将像素设置为1或者0。 负数 offset 值将更多像素设置为1，而正值仅将最强对比度设置为1。 设置 invert 以反转二进制图像的结果输出。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 此方法在OpenMV Cam M4 上不可用。 #### image.laplacian(size[, sharpen False[, mul[, add 0[, threshold False[, offset 0[, invert False[, mask None]]]]]]]) 通过边缘检测拉普拉斯核来对图像进行卷积。 size 是内核的大小。取1 (3x3 内核)、2 (5x5 内核)或更高值。 如果 sharpen 被设置为True，那么这种方法将改为锐化图像，而不是仅输出未经过阈值处理的边缘检测图像。 增加内核大小然后增加图像清晰度。 mul 是用以与卷积像素结果相乘的数字。若不设置，则默认一个值，该值将防止卷积输出中的缩放。 add 是用来与每个像素卷积结果相加的数值。 mul 可进行全局对比度调整，add可进行全局亮度调整。 如果你想在滤波器的输出上自适应地设置阈值，你可以传递 threshold True 参数来启动图像的自适应阈值处理， 他根据环境像素的亮度（核函数周围的像素的亮度有关），将像素设置为1或者0。 负数 offset 值将更多像素设置为1，而正值仅将最强对比度设置为1。 设置 invert 以反转二进制图像的结果输出。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 此方法在OpenMV Cam M4 上不可用。 #### image.bilateral(size[, color_sigma 0.1[, space_sigma 1[, threshold False[, offset 0[, invert False[, mask None]]]]]]) 通过双边滤波器对图像进行卷积。 双边滤波器使图像平滑，同时保持图像中的边缘。 size 是内核的大小。取1 (3x3 内核)、2 (5x5 内核)或更高值。 color_sigma 控制使用双边滤波器匹配颜色的接近程度。增加此值可增加颜色模糊。 space_sigma 控制像素在空间方面相互模糊的程度。增加此值可增加像素模糊。 如果你想在滤波器的输出上自适应地设置阈值，你可以传递 threshold True 参数来启动图像的自适应阈值处理， 他根据环境像素的亮度（核函数周围的像素的亮度有关），将像素设置为1或者0。 负数 offset 值将更多像素设置为1，而正值仅将最强对比度设置为1。 设置 invert 以反转二进制图像的结果输出。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 此方法在OpenMV Cam M4 上不可用。 #### image.cartoon(size[, seed_threshold 0.05[, floating_threshold 0.05[, mask None]]]) 漫游图像并使用flood fills算法填充图像中的所有像素区域。 这通过使图像的所有区域中的颜色变平来有效地从图像中去除纹理。 为了获得最佳效果，图像应具有大量对比度，以使区域不会太容易相互渗透。 seed_threshold 控制填充区域中的像素与原始起始像素的差异。 floating_threshold 控制填充区域中的像素与任何相邻像素的差异。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 此方法在OpenMV Cam M4 上不可用。 #### image.remove_shadows([image]) 从该图像中移除阴影。 如果当前图像没有“无阴影”版本出现，则此方法将尝试从图像中去除阴影，但没有真实无阴影的图像依据。 这种算法适用于去除平坦均匀背景中的阴影。 请注意，此方法需要多秒才能运行，并且仅适用于实时移除阴影，动态生成无阴影版本的图像。 该算法的未来版本将适用于更多的环境，但同样缓慢。 如果当前图像有“无阴影”版本出现，则此方法将使用“真实源”背景无阴影图像去除图像中的所有阴影以滤除阴影。 非阴影像素不会被过滤掉，因此您可以向场景中添加以前不存在的新对象，并且这些对象中的任何非阴影像素都将显示出来。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 只支持RGB565图像。 此方法在OpenMV Cam M4 上不可用。 #### image.chrominvar() 从图像中删除照明效果，仅留下颜色渐变。比 image.illuminvar() 更快但受阴影影响。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 仅支持RGB565图像。 此方法在OpenMV Cam M4 上不可用。 #### image.illuminvar() 从图像中删除照明效果，仅留下颜色渐变。比 image.chrominvar() 慢但不受阴影影响。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 仅支持RGB565图像。 此方法在OpenMV Cam M4 上不可用。 #### image.linpolar([reverse False]) 图像从笛卡尔坐标到线性极坐标重新投影。 设置 reverse True 可以在相反的方向重新投影。 线性极坐标重新投影将图像旋转转换为x平移。 不支持压缩图像。 此方法在OpenMV Cam M4 上不可用。 #### image.logpolar([reverse False]) 图像从笛卡尔坐标到对数极坐标重新投影。 设置 reverse True 可以在相反的方向重新投影。 对数极坐标重新投影将图像的旋转转换为x平移和缩放到y平移。 不支持压缩图像。 此方法在OpenMV Cam M4 上不可用。 #### image.lens_corr([strength 1.8[, zoom 1.0]]) 进行镜头畸变校正，以去除镜头造成的图像鱼眼效果。 strength 是一个浮点数，该值确定了对图像进行去鱼眼效果的程度。在默认情况下，首先试用取值1.8，然后调整这一数值使图像显示最佳效果。 zoom 是在对图像进行缩放的数值。默认值为 1.0 。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 #### img.rotation_corr([x_rotation 0.0[, y_rotation 0.0[, z_rotation 0.0[, x_translation 0.0[, y_translation 0.0[, zoom 1.0[, fov 60.0[, corners]]]]]]]]) 通过对帧缓冲区进行3D旋转来纠正图像中的透视问题。 `x_rotation` 是图像在帧缓冲区中绕x轴旋转的角度数(也就是图像上下旋转)。 `y_rotation` 是指图像在帧缓冲区中绕y轴旋转的角度数(即左右旋转图像)。 `z_rotation` 是图像在帧缓冲区中绕z轴旋转的角度数(即图像旋转到适当位置)。 `x_translation` 是图像旋转后向左或向右移动的单位数。因为这种转换应用于3D空间，所以单位不是像素…… `y_translation` 是图像在旋转后向上或向下移动的单位数。因为这种转换应用于3D空间，所以单位不是像素…… `zoom` 是将图像缩放的倍数，默认情况下为1.0。 `fov` 是在进行2D >3D投影时在3D空间旋转图像之前内部使用的视场。当这个值接近0时，图像被放置在距离视口无限远的地方。当这个值接近180时，图像被放置在视口中。通常，你不应该改变这个值，但你可以修改它来改变2D >3D映射效果。 `corners` 是一个拥有四个(x, y) tuples 的 list，代表四个 `corner` 用来创建四点对应单应性,将第一个 `corner` 映射到(0,0),第二个 `corner` (image_width 1, 0),第三个 `corner` (image_width 1 image_height 1)和第四个 `corner` (0,image_height 1)。然后在图像被重新映射后应用3D旋转。这个参数允许你使用 rotation_corr 来做一些事情，比如鸟瞰图转换。例如: ```python top_tilt 10 # if the difference between top/bottom_tilt become to large this method will stop working bottom_tilt 0 points [(tilt, 0), (img.width() tilt, 0), (img.width() 1 bottom_tilt, img.height() 1), (bottom_tilt, img.height() 1)] img.rotation_corr(corners points) ``` 返回图像对象，以便您可以使用 `.` 调用另一个方法。 不支持压缩图像或拜耳图像。 #### image.get_similarity(image) 返回一个“相似度”对象，描述两幅图像使用SSIM算法来比较两幅图像之间的8x8像素色块的相似度。 image 可以是图像对象，未压缩图像文件的路径(bmp/pgm/ppm)，也可以是标量值。 如果标量值，该值可以是RGB888元组或基础像素值(例如，灰度图像的8位灰度级或RGB图像的字节反转RGB565值)。 不支持压缩图像和bayer图像。 此方法在OpenMV Cam M4 上不可用。 #### image.get_histogram([thresholds[, invert False[, roi[, bins[, l_bins[, a_bins[, b_bins]]]]]]]) 在 roi 的所有颜色通道上进行标准化直方图运算，并返回 histogram 对象。 请参考 histogram 对象以获取更多信息。您也可以使用 image.get_hist 或 image.histogram 来调用这一方法。如果传递 thresholds 列表，则直方图信息将仅从阈值列表中的像素计算得出。 thresholds 必须是元组列表。 [(lo, hi), (lo, hi), ..., (lo, hi)] 定义你想追踪的颜色范围。 对于灰度图像，每个元组需要包含两个值 最小灰度值和最大灰度值。 仅考虑落在这些阈值之间的像素区域。 对于RGB565图像，每个元组需要有六个值(l_lo，l_hi，a_lo，a_hi，b_lo，b_hi) 分别是LAB L，A和B通道的最小值和最大值。 为方便使用，此功能将自动修复交换的最小值和最大值。 此外，如果元组大于六个值，则忽略其余值。相反，如果元组太短，则假定其余阈值处于最大范围。 注解 获取所跟踪对象的阈值，只需在IDE帧缓冲区中选择（单击并拖动）跟踪对象。 直方图会相应地更新到所在区域。然后只需写下颜色分布在每个直方图通道中起始与下降位置。 这些将是 thresholds 的低值和高值。 由于上下四分位数据相差微小，故手动确定阈值为佳。 您还可以通过进入OpenMV IDE中的 工具 >机器视觉 >阈值编辑器 并从GUI窗口中拖动滑块来确定颜色阈值。 invert 反转阈值操作，像素在已知颜色范围之外进行匹配，而非在已知颜色范围内。 除非您需要使用颜色统计信息进行高级操作，否则只需使用`image.get_statistics()` 方法代替此方法查看图像中的像素区域。 roi 是感兴趣区域的矩形元组(x，y，w，h)。如果未指定，ROI即整个图像的图像矩形。 操作范围仅限于 roi 区域内的像素。 bins 和其他bin是用于直方图通道的箱数。对于灰度图像，使用 bins ， 对于RGB565图像，使用其他每个通道。每个通道的bin计数必须大于2。 另外，将bin计数设置为大于每个通道的唯一像素值的数量是没有意义的。 默认情况下，直方图将具有每个通道的最大bin数。 不支持压缩图像和bayer图像。 #### image.get_statistics([thresholds[, invert False[, roi[, bins[, l_bins[, a_bins[, b_bins]]]]]]]) 计算 roi 中每个颜色通道的平均值、中值、众值、标准偏差、最小值、最大值、下四分值和上四分值，并返回一个数据对象。 请参见 statistics 对象以获取更多信息。您也可以使用 image.get_stats 或 image.statistics 来调用这一方法。 如果传递 thresholds 列表，则直方图信息将仅从阈值列表中的像素计算得出。 thresholds 必须是元组列表。 [(lo, hi), (lo, hi), ..., (lo, hi)] 定义你想追踪的颜色范围。 对于灰度图像，每个元组需要包含两个值 最小灰度值和最大灰度值。 仅考虑落在这些阈值之间的像素区域。 对于RGB565图像，每个元组需要有六个值(l_lo，l_hi，a_lo，a_hi，b_lo，b_hi) 分别是LAB L，A和B通道的最小值和最大值。 为方便使用，此功能将自动修复交换的最小值和最大值。 此外，如果元组大于六个值，则忽略其余值。相反，如果元组太短，则假定其余阈值处于最大范围。 注解 获取所跟踪对象的阈值，只需在IDE帧缓冲区中选择（单击并拖动）跟踪对象。 直方图会相应地更新到所在区域。然后只需写下颜色分布在每个直方图通道中起始与下降位置。 这些将是 thresholds 的低值和高值。 由于上下四分位数据相差微小，故手动确定阈值为佳。 您还可以通过进入OpenMV IDE中的 工具 >机器视觉 >阈值编辑器 并从GUI窗口中拖动滑块来确定颜色阈值。 invert 反转阈值操作，像素在已知颜色范围之外进行匹配，而非在已知颜色范围内。 您可以在需要获取图像中一个像素区域信息时使用这一方法。例如：若您想用帧差法来检测运动时， 您需要使用这一方法来确定图像颜色通道的变化，从而触发运动检测阈值。 roi 是感兴趣区域的矩形元组(x，y，w，h)。如果未指定，ROI即整个图像的图像矩形。 操作范围仅限于 roi 区域内的像素。 bins 和其他bin是用于直方图通道的箱数。对于灰度图像，使用 bins ， 对于RGB565图像，使用其他每个通道。每个通道的bin计数必须大于2。 另外，将bin计数设置为大于每个通道的唯一像素值的数量是没有意义的。 默认情况下，直方图将具有每个通道的最大bin数。 不支持压缩图像和bayer图像。 #### image.get_regression(thresholds[, invert False[, roi[, x_stride 2[, y_stride 1[, area_threshold 10[, pixels_threshold 10[, robust False]]]]]]]) 对图像所有阈值像素进行线性回归计算。这一计算通过最小二乘法进行，通常速度较快，但不能处理任何异常值。 若 robust 为True，则将使用泰尔指数。泰尔指数计算图像中所有阈值像素间的所有斜率的中值。 若在阈值转换后设定太多像素，即使在80x60的图像上，这一N^2操作也可能将您的FPS降到5以下。 但是，只要阈值转换后的进行设置的像素数量较少，即使在超过30%的阈值像素为异常值的情况下，线性回归也依然有效。 这一方法返回的是一个 image.line 对象。如何轻松运用直线对象， 详见下博文： https://openmv.io/blogs/news/linear regression line following thresholds 必须是元组列表。 [(lo, hi), (lo, hi), ..., (lo, hi)] 定义你想追踪的颜色范围。 对于灰度图像，每个元组需要包含两个值 最小灰度值和最大灰度值。 仅考虑落在这些阈值之间的像素区域。 对于RGB565图像，每个元组需要有六个值(l_lo，l_hi，a_lo，a_hi，b_lo，b_hi) 分别是LAB L，A和B通道的最小值和最大值。 为方便使用，此功能将自动修复交换的最小值和最大值。 此外，如果元组大于六个值，则忽略其余值。相反，如果元组太短，则假定其余阈值处于最大范围。 > 获取所跟踪对象的阈值，只需在IDE帧缓冲区中选择（单击并拖动）跟踪对象。 直方图会相应地更新到所在区域。然后只需写下颜色分布在每个直方图通道中起始与下降位置。 这些将是 thresholds 的低值和高值。 由于上下四分位数据相差微小，故手动确定阈值为佳。 您还可以通过进入OpenMV IDE中的 工具 >机器视觉 >阈值编辑器 并从GUI窗口中拖动滑块来确定颜色阈值。 invert 反转阈值操作，像素在已知颜色范围之外进行匹配，而非在已知颜色范围内。 roi 是感兴趣区域的矩形元组(x，y，w，h)。如果未指定，ROI即整个图像的图像矩形。 操作范围仅限于 roi 区域内的像素。 x_stride 是调用函数时要跳过的x像素数。 y_stride 是调用函数时要跳过的y像素数。 如果回归后的边界框区域小于 area_threshold ，则返回None。 如果回归后的像素数小于 pixel_threshold ，则返回None。 不支持压缩图像和bayer图像。 #### image.find_blobs(thresholds[, invert False[, roi[, x_stride 2[, y_stride 1[, area_threshold 10[, pixels_threshold 10[, merge False[, margin 0[, threshold_cb None[, merge_cb None]]]]]]]]]]) 查找图像中所有色块，并返回一个包括每个色块的色块对象的列表。请观察 image.blob 对象以获取更多信息。 thresholds 必须是元组列表。 [(lo, hi), (lo, hi), ..., (lo, hi)] 定义你想追踪的颜色范围。 对于灰度图像，每个元组需要包含两个值 最小灰度值和最大灰度值。 仅考虑落在这些阈值之间的像素区域。 对于RGB565图像，每个元组需要有六个值(l_lo，l_hi，a_lo，a_hi，b_lo，b_hi) 分别是LAB L，A和B通道的最小值和最大值。 为方便使用，此功能将自动修复交换的最小值和最大值。 此外，如果元组大于六个值，则忽略其余值。相反，如果元组太短，则假定其余阈值处于最大范围。 注解 获取所跟踪对象的阈值，只需在IDE帧缓冲区中选择（单击并拖动）跟踪对象。 直方图会相应地更新到所在区域。然后只需写下颜色分布在每个直方图通道中起始与下降位置。 这些将是 thresholds 的低值和高值。 由于上下四分位数据相差微小，故手动确定阈值为佳。 您还可以通过进入OpenMV IDE中的 工具 >机器视觉 >阈值编辑器 并从GUI窗口中拖动滑块来确定颜色阈值。 invert 反转阈值操作，像素在已知颜色范围之外进行匹配，而非在已知颜色范围内。 roi 是感兴趣区域的矩形元组(x，y，w，h)。如果未指定，ROI即整个图像的图像矩形。 操作范围仅限于 roi 区域内的像素。 x_stride 是查找某色块时需要跳过的x像素的数量。找到色块后，直线填充算法将精确像素。 若已知色块较大，可增加 x_stride 来提高查找色块的速度。 y_stride 是查找某色块时需要跳过的y像素的数量。找到色块后，直线填充算法将精确像素。 若已知色块较大，可增加 y_stride 来提高查找色块的速度。 若一个色块的边界框区域小于 area_threshold ，则会被过滤掉。 若一个色块的像素数小于 pixel_threshold ，则会被过滤掉。 merge 若为True，则合并所有没有被过滤掉的色块，这些色块的边界矩形互相交错重叠。 margin 可在相交测试中用来增大或减小色块边界矩形的大小。例如：边缘为1、相互间边界矩形为1的色块将被合并。 合并色块使颜色代码追踪得以实现。每个色块对象有一个代码值 code ，该值为一个位向量。 例如：若您在 image.find_blobs 中输入两个颜色阈值，则第一个阈值代码为1，第二个代码为2（第三个代码为4，第四个代码为8，以此类推）。 合并色块对所有的code使用逻辑或运算，以便您知道产生它们的颜色。这使得您可以追踪两个颜色，若您用两种颜色得到一个色块对象，则可能是一种颜色代码。 若您使用严格的颜色范围，无法完全追踪目标对象的所有像素，您可能需要合并色块。 最后，若您想要合并色块，但不想两种不同阈值颜色的色块被合并，只需分别两次调用 image.find_blobs ，不同阈值色块就不会被合并。 threshold_cb 可设置为用以调用阈值筛选后的每个色块的函数，以便将其从将要合并的色块列表中过滤出来。 回调函数将收到一个参数：要被筛选的色块对象。然后回调函数需返回True以保留色块或返回False以过滤色块。 merge_cb 可设置为用以调用两个即将合并的色块的函数，以禁止或准许合并。回调函数将收到两个参数—两个将被合并的色块对象。 回调函数须返回True以合并色块，或返回False以防止色块合并。 不支持压缩图像和bayer图像。 #### image.find_lines([roi[, x_stride 2[, y_stride 1[, threshold 1000[, theta_margin 25[, rho_margin 25]]]]]]) 使用霍夫变换查找图像中的所有直线。返回一个 image.line 对象的列表。 roi 是感兴趣区域的矩形元组(x，y，w，h)。如果未指定，ROI即整个图像的图像矩形。操作范围仅限于 roi 区域内的像素。 x_stride 是霍夫变换时需要跳过的x像素的数量。若已知直线较大，可增加 x_stride 。 y_stride 是霍夫变换时需要跳过的y像素的数量。若已知直线较大，可增加 y_stride 。 threshold 控制从霍夫变换中监测到的直线。只返回大于或等于 threshold 的直线。 应用程序的正确的 threshold 值取决于图像。注意：一条直线的大小(magnitude)是组成直线所有索贝尔滤波像素大小的总和。 theta_margin 控制所监测的直线的合并。 直线角度为 theta_margin 的部分和直线p值为 rho_margin 的部分合并。 rho_margin 控制所监测的直线的合并。 直线角度为 theta_margin 的部分和直线p值为 rho_margin 的部分合并。 该方法通过在图像上运行索贝尔滤波器，并利用该滤波器的幅值和梯度响应来进行霍夫变换。 无需对图像进行任何预处理。但是，清理图像过滤器可得到更为稳定的结果。 不支持压缩图像和bayer图像。 此方法在OpenMV Cam M4 上不可用。 #### image.find_line_segments([roi[, merge_distance 0[, max_theta_difference 15]]]) 使用霍夫转换来查找图像中的线段。返回一个 image.line 对象的列表。 roi 是一个用以复制的矩形的感兴趣区域(x, y, w, h)。如果未指定， ROI 即图像矩形。操作范围仅限于roi区域内的像素。 merge_distance 指定两条线段之间的可以相互分开而不被合并的最大像素数。 max_theta_difference 是上面 merge_distancede 要合并的的两个线段的最大角度差值。 此方法使用LSD库（也被OpenCV使用）来查找图像中的线段。这有点慢，但是非常准确，线段不会跳跃。 不支持压缩图像和bayer图像。 此方法在OpenMV Cam M4 上不可用。 #### image.find_circles([roi[, x_stride 2[, y_stride 1[, threshold 2000[, x_margin 10[, y_margin 10[, r_margin 10]]]]]]]) 使用霍夫变换在图像中查找圆。返回一个 image.circle 对象列表（见上）。 roi 是一个用以复制的矩形的感兴趣区域(x, y, w, h)。如果未指定， ROI 即图像矩形。操作范围仅限于roi区域内的像素。 x_stride 是霍夫变换时需要跳过的x像素的数量。若已知圆较大，可增加 x_stride 。 y_stride 是霍夫变换时需要跳过的y像素的数量。若已知圆较大，可增加 y_stride 。 threshold 控制从霍夫变换中监测到的圆。只返回大于或等于 threshold 的圆。 应用程序的正确的 threshold 值取决于图像。注意：一个圆的大小(magnitude)是组成圆所有索贝尔滤波像素大小的总和。 x_margin 控制所检测的圆的合并。 圆像素为 x_margin 、 y_margin 和 r_margin 的部分合并。 y_margin 控制所检测的圆的合并。 圆像素为 x_margin 、 y_margin 和 r_margin 的部分合并。 r_margin 控制所检测的圆的合并。 圆像素为 x_margin 、 y_margin 和 r_margin 的部分合并。 不支持压缩图像和bayer图像。 此方法在OpenMV Cam M4 上不可用。 #### image.find_rects([roi Auto, threshold 10000]) 使用用于查找AprilTAg的相同的quad detection算法来查找图像中的矩形。 最适用与背景形成鲜明对比的矩形。AprilTag的quad detection可以处理任意缩放/旋转/剪切的矩形。 返回一个 image.rect 对象的列表。 roi 是一个用以复制的矩形的感兴趣区域(x, y, w, h)。如果未指定， ROI即图像矩形。操作范围仅限于 roi 区域内的像素。 边界大小（通过在矩形边缘上的所有像素上滑动索贝尔算子并相加该值）小于 threshold 的矩形会从返回列表中过滤出来。 threshold 的正确值取决于您的应用程序/场景。 不支持压缩图像和bayer图像。 此方法在OpenMV Cam M4 上不可用。 #### image.find_qrcodes([roi]) 查找 roi 内的所有二维码并返回一个 image.qrcode 对象的列表。 请参考 image.qrcode 对象以获取更多信息。 为使这一方法成功运行，图像上二维码需比较平展。通过使用 sensor.set_windowing 函数在镜头中心放大、 image.lens_corr 函数来消解镜头的桶形畸变或通过更换视野较为狭小的镜头， 您可得到一个不受镜头畸变影响的更为平展的二维码。有些机器视觉镜头不会造成桶形失真，但是其造价远比OpenMV提供的标准镜片高，这种镜头为无畸变镜头。 roi 是一个用以复制的矩形的感兴趣区域(x, y, w, h)。如果未指定，ROI即整幅图像的图像矩形。 操作范围仅限于 roi 区域内的像素。 不支持压缩图像和bayer图像。 此方法在OpenMV Cam M4 上不可用。 image.find_apriltags([roi[, families image.TAG36H11[, fx[, fy[, cx[, cy]]]]]]) 查找 roi 内的所有AprilTag, 并返回一个 image.apriltag 对象的列表。请参考 image.apriltag 对象以获取更多信息。 与二维码相比，AprilTags可在更远距离、较差光线和更扭曲的图像环境下被检测到。 AprilTags可应对所有种类的图像失真问题，而二维码并不能。也就是说，AprilTags只能将数字ID编码作为其有效载荷。 AprilTags也可用于本地化。每个 image.apriltag 对象都从摄像机返回其三维位置信息和旋转角度。 位置信息由 fx 、 fy 、 cx 和 cy 决定，分别为X和Y方向上图像的焦距和中心点。 > 使用OpenMV IDE内置的标签生成器工具来创建AprilTags。标签生成器可创建可打印的8.5“x11”AprilTags。 roi 是一个用以复制的矩形的感兴趣区域(x, y, w, h)。如果未指定，ROI即整幅图像的图像矩形。 操作范围仅限于 roi 区域内的像素。 families 是要解码的标签家族的位掩码。是一个逻辑或： image.TAG16H5 image.TAG25H7 image.TAG25H9 image.TAG36H10 image.TAG36H11 image.ARTOOLKIT 默认设置为最好用的 image.TAG36H11 标签家族。注意：每启用一个标签家族， find_apriltags 的速度都会略有放慢。 fx 是以像素为单位的相机x方向的焦距。标准OpenMV Cam的值为(2.8 / 3.984) * 656， 该值通过毫米计的焦距值除以X方向上感光元件的长度，再乘以X方向上感光元件的像素数量得来（对OV7725感光元件而言）。 fy 是以像素为单位的相机y方向的焦距。标准OpenMV Cam的值为(2.8 / 2.952) * 488， 该值通过毫米计的焦距值除以Y方向上感光元件的长度，再乘以Y方向上感光元件的像素数量得来（对OV7725感光元件而言）。 cx 是图像的中心，即 image.width()/2 ，而非 roi.w()/2 。 cy 是图像的中心，即 image.height()/2，而非 roi.h()/2 。 不支持压缩图像和bayer图像。 此方法在OpenMV Cam M4 上不可用。 image.find_datamatrices([roi[, effort 200]]) 查找 roi 内的所有数据矩阵并返回一个 image.datamatrix 对象的列表。 请参考 image.datamatrix 对象以获取更多信息。 为使这一方法成功运行，图像上矩形码需比较平展。通过使用 sensor.set_windowing 函数在镜头中心放大、 image.lens_corr 函数来消解镜头的桶形畸变或通过更换视野较为狭小的镜头，您可得到一个不受镜头畸变影响的更为平展的矩形码。 有些机器视觉镜头不会造成桶形失真，但是其造价远比OpenMV提供的标准镜片高，这种镜头是无畸变镜头。 roi 是一个用以复制的矩形的感兴趣区域(x, y, w, h)。如果未指定，ROI即整幅图像的图像矩形。操作范围仅限于 roi 区域内的像素。 effort 控制用于查找矩形码匹配的时间。默认值为200应该适用于所有用例。 但是您也可能以帧速率为代价增加检测，或以检测为代价增加帧速率。 注意：若 effort 设置在约160以下，您就无法进行任何检测；相反，您可将其设置为您需要的任何高值，但是若设置值高于240，检测率将不会继续随之提高。 不支持压缩图像和bayer图像。 此方法在OpenMV Cam M4 上不可用。 #### image.find_barcodes([roi]) 查找 roi 内所有一维条形码并返回一个 image.barcode 对象列表。 请参考 image.barcode 对象以获取更多信息。 为了获得最佳效果，请使用长640、宽40/80／160窗口。垂直程度越低，运行速度越快。由于条形码是线性一维图像，所以只需在一个方向上有较高分辨率， 而在另一方向上只需较低分辨率。注意：该函数进行水平和垂直扫描，所以您可使用宽40/80／160、长480的窗口。 最后，请一定调整镜头，这样条形码会定位在焦距产生最清晰图像的地方。模糊条码无法被解码。 该函数支持所有一维条形码： image.EAN2 image.EAN5 image.EAN8 image.UPCE image.ISBN10 image.UPCA image.EAN13 image.ISBN13 image.I25 image.DATABAR (RSS 14) image.DATABAR_EXP (RSS Expanded) image.CODABAR image.CODE39 image.PDF417 image.CODE93 image.CODE128 roi 是一个用以复制的矩形的感兴趣区域(x, y, w, h)。如果未指定，ROI即整幅图像的图像矩形。操作范围仅限于 roi 区域内的像素。 不支持压缩图像和bayer图像。 此方法在OpenMV Cam M4 上不可用。 image.find_displacement(template[, roi[, template_roi[, logpolar False]]]) 从模板中查找此图像的变换偏移量。 这种方法可以用来做光流。 此方法返回一个 image.displacement 对象，其中包含使用相位相关的位移计算结果。 roi 是需要处理的矩形区域（x，y，w，h）。如果未指定，则等于图像矩形。 template_roi 是需要处理的矩形区域（x，y，w，h）。如果未指定，则等于图像矩形。 roi 和 template roi必须具有相同的w/h，但x/y可以为图像任意位置。您可以在较大图像上滑动较小的rois以获得光流渐变图像. image.find_displacement 通常计算两个图像之间的x/y平移。但是，如果您设置 logpolar True ， 它将会在两个图像之间找到旋转和缩放比例的变化。相同的 image.displacement 对象结果两种可能的反馈。 不支持压缩图像和bayer图像。 注解 请在长宽一致的图像（例如``sensor.B64X64``）上使用此方法。 此方法在OpenMV Cam M4 上不可用。 #### image.find_number(roi) 运行在MINST数据集上训练的LENET 6 CNN（卷积神经网络），以检测位于图像上任何位置的28x28 ROI中的数字。 返回一个包含整数和浮点数的元组，表示检测到的数字（0 9）和检测的置信度（0 1）。 roi 是感兴趣区域的矩形元组(x，y，w，h)。如果未指定，ROI即整个图像的图像矩形。 操作范围仅限于 roi 区域内的像素。 仅支持灰度图像。 注解 这种方法是实验性的。如果未来运行使用Caffe在PC上训练的任何CNN，这种方法可能会删除。 最新3.0.0版本固件已删除此函数。 此方法在OpenMV Cam M4 上不可用。 #### image.classify_object(roi) 在图像的ROI上运行CIFAR 10 CNN，以检测飞机，汽车，鸟类，猫，鹿，狗，青蛙，马，船和卡车。 此方法在内部自动将图像缩放到32x32以馈送到CNN。 roi 是感兴趣区域的矩形元组(x，y，w，h)。如果未指定，ROI即整个图像的图像矩形。 操作范围仅限于 roi 区域内的像素。 仅支持RGB565图像。 注解 这种方法是实验性的。如果未来运行使用Caffe在PC上训练的任何CNN，这种方法可能会删除。 此方法在OpenMV Cam M4 上不可用。 image.find_template(template, threshold[, roi[, step 2[, search image.SEARCH_EX]]]) 尝试使用归一化互相关(NCC)算法在图像中找到第一个模板匹配的位置。返回匹配位置的边界框元组(x, y, w, h)，否则返回None。 template 是一个与这个图像对象相匹配的小图像对象。注意：两图像须都为灰度图。 threshold 是浮点数（0.0 1.0），其中较小的值在提高检测速率同时增加误报率。相反，较高的值会降低检测速率，同时降低误报率。 roi 是感兴趣区域的矩形元组(x，y，w，h)。如果未指定，ROI即整个图像的图像矩形。 操作范围仅限于 roi 区域内的像素。 step 是查找模板时需要跳过的像素数量。跳过像素可大大提高算法运行的速度。该方法只适用于SERACH_EX模式下的算法。 search 可为 image.SEARCH_DS or image.SEARCH_EX. image.SEARCH_DS 搜索模板所用算法较 image.SEARCH_EX 更快，但若模板位于图像边缘周围，可能无法成功搜索。 image.SEARCH_EX 可对图像进行较为详尽的搜索，但其运行速度远低于 image.SEARCH_DS 。 仅支持灰度图像。 #### image.find_features(cascade[, threshold 0.5[, scale 1.5[, roi]]]) 这个方法搜索与Haar Cascade匹配的所有区域的图像，并返回一个关于这些特征的边界框矩形元组(x，y，w，h)的列表。若未发现任何特征，则返回一个空白列表。 cascade 是一个Haar Cascade对象。详细信息请查看 image.HaarCascade() 。 threshold 是浮点数（0.0 1.0），其中较小的值在提高检测速率同时增加误报率。相反，较高的值会降低检测速率，同时降低误报率。 scale 是一个必须大于1.0的浮点数。较高的比例因子运行更快，但其图像匹配相应较差。理想值介于1.35 1.5之间。 roi 是感兴趣区域的矩形元组(x，y，w，h)。如果未指定，ROI即整个图像的图像矩形。 操作范围仅限于 roi 区域内的像素。 仅支持灰度图像。 #### image.find_eye(roi) 在眼睛周围的感兴趣区域(x, y, w, h)查找瞳孔。返回一个包含图像中瞳孔(x，y)位置的元组。若未发现瞳孔，则返回(0,0)。 使用这一函数之前，需首先使用 image.find_features() 和Haar算子 frontalface 来搜索某人面部。 然后使用 image.find_features 和Haar算子 find_eye 在面部搜索眼睛。 最后，在调用 image.find_features 函数后返回的每个眼睛ROI上调用这一方法，以得到瞳孔的坐标。 roi 是感兴趣区域的矩形元组(x，y，w，h)。如果未指定，ROI即整个图像的图像矩形。 操作范围仅限于 roi 区域内的像素。 仅支持灰度图像。 #### image.find_lbp(roi) 从ROI元组(x, y, w, h)中提取LBP（局部二值模式）键点。您可以使用 image.match_descriptor 函数来比较两组关键点，以获取匹配距离。 roi 是感兴趣区域的矩形元组(x，y，w，h)。如果未指定，ROI即整个图像的图像矩形。 操作范围仅限于 roi 区域内的像素。 仅支持灰度图像。 #### image.find_keypoints([roi[, threshold 20[, normalized False[, scale_factor 1.5[, max_keypoints 100[, corner_detector image.CORNER_AGAST]]]]]]) 从ROI元组(x, y, w, h)中提取ORB键点。您可以使用 image.match_descriptor 函数来比较两组关键点，以获取匹配区域。若未发现关键点，则返回None。 roi 是感兴趣区域的矩形元组(x，y，w，h)。如果未指定，ROI即整个图像的图像矩形。 操作范围仅限于 roi 区域内的像素。 threshold 是控制提取的数量的数字（取值0 255）。对于默认的AGAST角点检测器，该值应在20左右。 对于FAST角点检测器，该值约为60 80。阈值越低，您提取的角点越多。 normalized 是布尔值。若为True，在多分辨率下关闭提取键点。 若您不关心处理扩展问题，且希望算法运行更快，就将之设置为True。 scale_factor 是一个必须大于1.0的浮点数。较高的比例因子运行更快，但其图像匹配相应较差。理想值介于1.35 1.5之间。 max_keypoints 是一个键点对象所能容纳的键点最大数量。若键点对象过大导致内存问题，请降低该值。 corner_detector 是从图像中提取键点所使用的角点检测器算法。 可为 image.CORNER_FAST 或 image.CORNER_AGAST 。FAST角点检测器运行速度更快，但其准确度较低。 仅支持灰度图像。 #### image.find_edges(edge_type[, threshold]) 将图像变为黑白，仅将边缘保留为白色像素。 image.EDGE_SIMPLE 简单的阈值高通滤波算法 image.EDGE_CANNY Canny边缘检测算法 threshold 是一个包含一个低阈值和一个高阈值的二值元组。您可以通过调整该值来控制边缘质量。 默认为 (100, 200)。 仅支持灰度图像。 find_hog([roi[, size 8]]) 用HOG（定向梯度直方图）线替换ROI中的像素。 roi 是感兴趣区域的矩形元组(x，y，w，h)。如果未指定，ROI即整个图像的图像矩形。 操作范围仅限于 roi 区域内的像素。 仅支持灰度图像。 此方法在OpenMV Cam M4 上不可用。 ## 常量 ### image.SEARCH_EX 详尽的模板匹配搜索。 ### image.SEARCH_DS 更快的模板匹配搜索。 ### image.EDGE_CANNY 使用Canny边缘检测算法对图像进行边缘检测。 ### image.EDGE_SIMPLE 使用阈值高通滤波算法对图像进行边缘检测。 ### image.CORNER_FAST 用于ORB键点的高速低准确率角点检测算法 ### image.CORNER_AGAST 用于ORB键点的低速高准确率算法。 ### image.TAG16H5 TAG1H5标签群的位掩码枚举。用于AprilTags。 ### image.TAG25H7 TAG25H7标签群的位掩码枚举。用于AprilTags。 ### image.TAG25H9 TAG25H9标签群的位掩码枚举。用于AprilTags。 ### image.TAG36H10 TAG36H10标签群的位掩码枚举。用于AprilTags。 ### image.TAG36H11 TAG36H11标签群的位掩码枚举。用于AprilTags。 ### image.ARTOOLKIT ARTOOLKIT标签群的位掩码枚举。用于AprilTags。 ### image.EAN2 EAN2条形码类型枚举。 ### image.EAN5 EAN5条形码类型枚举。 ### image.EAN8 EAN8条形码类型枚举。 ### image.UPCE UPCE条形码类型枚举。 ### image.ISBN10 ISBN10条形码类型枚举。 ### image.UPCA UPCA条形码类型枚举。 ### image.EAN13 EAN13条形码类型枚举。 ### image.ISBN13 ISBN13条形码类型枚举。 ### image.I25 I25条形码类型枚举。 ### image.DATABAR DATABAR条形码类型枚举。 ### image.DATABAR_EXP DATABAR_EXP条形码类型枚举。 ### image.CODABAR CODABAR条形码类型枚举。 ### image.CODE39 CODE39条形码类型枚举。 ### image.PDF417 PDF417条形码类型枚举（目前尚不能运行）。 ### image.CODE93 CODE93条形码类型枚举。 ### image.CODE128 CODE128条形码类型枚举。"},"/soft/maixpy/zh/api_reference/machine_vision/sensor.html":{"title":"sensor（摄像头）","content":" title: sensor（摄像头） keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy sensor（摄像头） sensor 传感器模块(这里特指摄像头模块)，进行摄像头配置及图像抓取等，用于控制开发板摄像头完成摄像任务。 ## 方法 ### 初始化单目摄像头 重置并初始化单目摄像头 ```python sensor.reset([, freq 24000000[, set_regs True[, dual_buff False]]]) ``` #### 参数 * `freq`: 设置摄像头时钟频率，频率越高帧率越高，但是画质可能更差。默认 `24MHz`， 如果摄像头有彩色斑点(ov7740)，可以适当调低比如 `20MHz` * `set_regs`: 允许程序写摄像头寄存器，默认为 `True`。 如果需要自定义复位序列，可以设置为`False`，然后使用`sensor.__write_reg(addr, value)` 函数自定义写寄存器序列 * `dual_buff`: 默认为`False`。允许使用双缓冲，会增高帧率，但是内存占用也会增加(大约为384KiB) * `choice`: 指定需要搜索的摄像头类型，ov类型(1)，gc类型(2)，mt类型(3)，不传入该参数则搜索全部类型摄像头 #### 返回值 无 ### 重置双目摄像头 重置并初始化双目摄像头 > K210 只有一个 DVP 接口，同一时间只能控制一个 Sensor。但是我们可以借助 `shudown` 方法控制 PWDN 引脚以选择特定的 Sensor。 指定 Sensor 后其余操作不变。详见 例程 2 ```python sensor.binocular_reset() ``` #### 参数 无 #### 返回值 无 ### 设置帧大小 用于设置摄像头输出帧大小，k210最大支持VGA格式，大于VGA将无法获取图像 > MaixPy开发板配置的屏幕是320*240分辨率，推荐设置为QVGA格式 ``` sensor.set_framesize(framesize[, set_regs True]) ``` #### 参数 * `framesize`: 帧大小 * `set_regs`: 允许程序写摄像头寄存器，默认为 `True`。 如果需要自定义设置帧大小的序列，可以设置为`False`，然后使用`sensor.__write_reg(addr, value)` 函数自定义写寄存器序列 #### 返回值 * `True` : 设置成功 * `False`: 设置错误 ### 设置帧格式 用于设置摄像头输出格式 > MaixPy开发板配置的屏幕使用的是RGB565，推荐设置为RGB565格式 ``` sensor.set_pixformat(format[, set_regs True]) ``` #### 参数 * `format`: 帧格式 * `set_regs`: 允许程序写摄像头寄存器，默认为 `True`。 如果需要自定义设置像素格式的序列，可以设置为`False`，然后使用`sensor.__write_reg(addr, value)` 函数自定义写寄存器序列 > 可选的帧格式有`GRAYSCALE`, `RGB565`, `YUV422` #### 返回值 * `True` : 设置成功 * `False`: 设置错误 ### 图像捕捉控制 图像捕捉功能控制 ``` sensor.run(enable) ``` #### 参数 * `enable`: 1 表示开始抓取图像 0 表示停止抓取图像 #### 返回值 * `True` : 设置成功 * `False`: 设置错误 ### 拍摄图像 使用摄像头拍摄一张照片 ``` sensor.snapshot() ``` #### 参数 无 #### 返回值 * `img`: 返回的图像对象 ### 摄像头控制 关闭摄像头/切换摄像头 ``` sensor.shutdown(enable/select) ``` #### 参数 单目摄像头 * `enable`: True 表示开启摄像头 False 表示关闭摄像头 双目摄像头 * `select`: 通过写入 0 或 1 来切换摄像头 #### 返回值 无 ### 跳帧 跳过指定帧数或者跳过指定时间内的图像，让相机图像在改变相机设置后稳定下来 ``` sensor.skip_frames(n, [, time]) ``` #### 参数 * `n`: 跳过 n 帧图像 * `time`: 跳过指定时间，单位为ms > 若 n 和 time 皆未指定，该方法跳过300毫秒的帧；若二者皆指定，该方法会跳过 n 数量的帧，但将在 time 毫秒后返回 #### 返回值 无 ### 分辨率宽度 获取摄像头分辨率宽度 ``` sensor.width() ``` #### 参数 无 #### 返回值 * `int`类型的摄像头分辨率宽度 ### 分辨率高度 获取摄像头分辨率高度 ``` sensor.height() ``` #### 参数 无 #### 返回值 * `int`类型的摄像头分辨率高度 ### 获取帧缓冲 获取当前帧缓冲区 ``` sensor.get_fb() ``` #### 参数 无 #### 返回值 * `image`类型的对象 ### 获取ID 获取当前摄像头ID,需要在摄像头reset之后才能读取到id号 ``` sensor.get_id() ``` #### 参数 摄像头的id号 #### 返回值 * `int`类型的ID ### 设置彩条测试模式 将摄像头设置为彩条测试模式 > 开启彩条测试模式后，摄像头会输出一彩条图像，常用来检测摄像机总线是否连接正确。 ``` sensor.set_colorbar(enable) ``` #### 参数 * `enable`: 1 表示开启彩条测试模式 0 表示关闭彩条测试模式 #### 返回值 无 ### 设置对比度 设置摄像头对比度 ``` sensor.set_contrast(contrast) ``` #### 参数 * `constrast`: 摄像头对比度，范围为[ 2,+2] #### 返回值 * `True` : 设置成功 * `False`: 设置错误 ### 设置亮度 设置摄像头亮度 ``` sensor.set_brightness(brightness) ``` #### 参数 * `brightness`: 摄像头亮度，范围为[ 2,+2] #### 返回值 * `True` : 设置成功 * `False`: 设置错误 ### 设置饱和度 设置摄像头饱和度 ``` sensor.set_saturation(saturation) ``` #### 参数 * `constrast`: 摄像头饱和度，范围为[ 2,+2] #### 返回值 * `True` : 设置成功 * `False`: 设置错误 ### 设置自动增益 设置摄像自动增益模式 ``` sensor.set_auto_gain(enable,gain_db) ``` #### 参数 * `enable`: 1 表示开启自动增益 0 表示关闭自动增益 * `gain_db`: 关闭自动增益时，设置的摄像头固定增益值，单位为dB > 如果需要追踪颜色，需要关闭自动增益 #### 返回值 无 ### 获取增益值 获取摄像头增益值 ``` sensor.get_gain_db() ``` #### 参数 无 #### 返回值 * `float`类型的增益值 ### 设置水平镜像 设置摄像头水平镜像 ``` sensor.set_hmirror(enable) ``` #### 参数 * `enable`: 1 表示开启水平镜像 0 表示关闭水平镜像 #### 返回值 无 ### 设置摄像头垂直翻转 设置摄像头垂直翻转 ``` sensor.set_vflip(enable) ``` #### 参数 * `enable`: 1 表示开启垂直翻转 0 表示关闭垂直翻转 #### 返回值 无 ### 写入寄存器 往摄像头寄存器写入指定值 ``` sensor.__write_reg(address, value) ``` #### 参数 * `address`: 寄存器地址 * `value` ： 写入值 #### 返回值 无 > 请参阅摄像头数据手册以获取详细信息 ### 读取寄存器 读取摄像头寄存器值 ``` sensor.__read_reg(address) ``` #### 参数 * `address`: 寄存器地址 #### 返回值 * `int`类型的寄存器值 > 请参阅摄像头数据手册以获取详细信息 ### set_jb_quality 设置传送给 IDE 图像的质量 ``` sensor.set_jb_quality(quality) ``` #### 参数 `quality`：`int` 类型，图像质量百分比（0~100），数字越大质量越好 ## 例程 ### 例程 1 ```python # 单目摄像头 import sensor import lcd lcd.init() sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) while True: img sensor.snapshot() lcd.display(img) ``` ### 例程 2 ```python # 双目摄像头 import sensor import image import lcd import time lcd.init() sensor.binocular_reset() sensor.shutdown(0) # 选中sensor 0 sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.shutdown(1) # 选中sensor 1 sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) while True: sensor.shutdown(0) # 选中sensor 0 img sensor.snapshot() lcd.display(img) time.sleep_ms(100) sensor.shutdown(1) # 选中sensor 1 img sensor.snapshot() lcd.display(img) time.sleep_ms(100) ```"},"/soft/maixpy/zh/api_reference/Maix/utils.html":{"title":"Maix.utils","content":" title: Maix.utils keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy Maix.utils ## gc_heap_size([size]) 获取或者设置 GC 堆大小，如果报内存不够时可以考虑设置大一点 ### 参数 无 或者 传入新的 GC 堆大小. * 如果没有参数就只是获取堆大小； * 如果有参数则设置堆大小，然后会自动重启 ### 返回值 GC 堆大小 使用实例 ```python import Maix # Maix.utils.gc_heap_size(0x80000) # 固件默认配置为 500KB Maix.utils.gc_heap_size(0x96000) # 600KB ``` ## flash_read(flash_offset, size) 从内部 flash 读取 size 指定大小(字节数) 数据 ### 参数 flash_offset: flash 地址偏移 flash_offset: flash 地址偏移 ## heap_free() ```shell >>> Maix.utils.gc_heap_size() 524288 >>> Maix.utils.heap_free() 4374528 ``` 文章中脚本测试条件为: MaixDock MaixPy v0.5.0_246(标准版固件)"},"/soft/maixpy/zh/api_reference/Maix/i2s.html":{"title":"I2S","content":" title: I2S keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy I2S I2S模块主要用于驱动I2S设备，k210一共有3个I2S设备，每个设备一共有4个通道，在使用前需要对引脚进行映射管理 ## 模块函数 ### 构造函数 新建一个 I2S 对象 ``` from Maix import I2S i2s_dev I2S(device_num) ``` #### 参数 `device_num` I2S号，使用指定的 I2S，可以通过 `I2S.` 按tab键来补全 #### 返回值 返回一个`I2S` 对象 ### 通道配置函数 用于配置 I2S 通道，在此之前需要对引脚进行映射 ``` i2s_dev.channel_config(channel, mode, resolution, cycles, align_mode) ``` #### 参数 * `channel`: I2S通道编号 * `mode`: 通道传输模式，一共有接收和发送模式，录音为接受，播放为发送 * `resolution`: 通道分辨率，即接收数据位数 * `cycles`: 单个数据时钟数 * `align_mode`: 通道对齐模式 #### 返回值 无 ### 设置采样率 用于配置 I2S 采样率 ``` i2s_dev.set_sample_rate(sample_rate) ``` #### 参数 `sample_rate`: int 类型，采样率 #### 返回值 无 ### 接收音频 使用I2S接收音频数据 ``` audio i2s_dev.record(points) ``` #### 参数 * `points`: 一次采集的音频点数 #### 返回值 `audio`: 一个`audio`音频对象 ### 发送音频 使用I2S发送音频数据 ``` i2s_dev.play(audio) ``` #### 参数 * `audio`: 发送的音频对象 #### 返回值 无 ## 例程 ### 例程1 采集数据并直接播放 ```python from Maix import I2S import time from fpioa_manager import * fm.register(20,fm.fpioa.I2S0_IN_D0)#GO fm.register(19,fm.fpioa.I2S0_WS) fm.register(18,fm.fpioa.I2S0_SCLK) fm.register(34,fm.fpioa.I2S2_OUT_D1) fm.register(35,fm.fpioa.I2S2_SCLK) fm.register(33,fm.fpioa.I2S2_WS) sample_rate 44*1000 rx I2S(I2S.DEVICE_0) rx.channel_config(rx.CHANNEL_0, rx.RECEIVER, align_mode I2S.STANDARD_MODE) rx.set_sample_rate(sample_rate) tx I2S(I2S.DEVICE_2) tx.channel_config(tx.CHANNEL_1, tx.TRANSMITTER, align_mode I2S.RIGHT_JUSTIFYING_MODE) tx.set_sample_rate(sample_rate) while True: audio rx.record(256)#sampling points number must be smaller than 256 tx.play(audio) ``` ### 例程2 采集数据转化为 Audio 并播放 ```python from Maix import I2S from Maix import Audio from Maix import FFT import time from fpioa_manager import * fm.register(20,fm.fpioa.I2S0_IN_D0) fm.register(19,fm.fpioa.I2S0_WS) fm.register(18,fm.fpioa.I2S0_SCLK) fm.register(34,fm.fpioa.I2S2_OUT_D1) fm.register(35,fm.fpioa.I2S2_SCLK) fm.register(33,fm.fpioa.I2S2_WS) rx I2S(I2S.DEVICE_0) rx.channel_config(rx.CHANNEL_0, rx.RECEIVER, align_mode I2S.STANDARD_MODE) rx.set_sample_rate(16000) tx I2S(I2S.DEVICE_2) tx.channel_config(tx.CHANNEL_1, tx.TRANSMITTER, align_mode I2S.RIGHT_JUSTIFYING_MODE) tx.set_sample_rate(16000) while True: audio rx.record(256) audio_data audio.to_bytes() play_audio Audio(audio_data) tx.play(play_audio) ```"},"/soft/maixpy/zh/api_reference/Maix/index.html":{"title":"Maix库","content":" title: Maix库 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy Maix库 * [FPIOA](./fpioa.html) * [GPIO](./gpio.html) * [KPU](./kpu.html) * [FFT](./fft.html) * [I2S](./i2s.html) * [Audio](./audio.html) * [freq](./freq.html) * [utils](./utils.html)"},"/soft/maixpy/zh/api_reference/Maix/fft.html":{"title":"FFT运算","content":" title: FFT运算 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy FFT运算 FFT快速傅里叶变换模块，对输入数据进行傅里叶变换并返回相应的频率幅值, FFT快速傅里叶运算可以将时域信号转换为频域信号 ## 模块函数 ### 运算函数 输入时域数据并进行傅里叶变换 ``` from maix import FFT res FFT.run(data, points, shift) ``` #### 参数 * `data`: 输入的时域数据，`bytearray` 类型 * `points`: FFT运算点数，仅支持64, 128，256和512点 * `shift`: 偏移，默认为0 #### 返回值 `res`: 返回计算后的频域数据，以 `list` 类型呈现，该列表有 `points` 个元组，每个元组有 2 个元素，第一个元素为实部，第二个为虚部 ### 频率函数 FFT ``` res FFT.freq(points, sample_rate) ``` #### 参数 * `points`: 计算点数 * `sample_rate`: 采样率 #### 返回值 `res` : 返回一个列表，该列表存放的进行运算后后所有频率点的频率值 ### 幅值函数 用于计算 FFT 运算后的各个频率点的幅值，目前用作测试，用户可以自己在python自行写幅值处理函数 ``` amp FFT.amplitude(FFT_res) ``` #### 参数 `FFT_res`: 函数 `run` 运行后的结果 #### 返回值 `res` : 返回一个列表，该列表存放了各个频率点的幅值 ### 例程 采集声音并进行 FFT 运算，将运算后的数据在屏幕上显示为柱状图: [demo_fft_spectrum](https://github.com/sipeed/MaixPy v1_scripts/blob/master/hardware/demo_fft_spectrum.py) 效果： <iframe width \"600\" height \"350\" src \"//player.bilibili.com/player.html?aid 44617696&cid 78104545&page 1\" scrolling \"no\" border \"0\" frameborder \"no\" framespacing \"0\" allowfullscreen \"true\"> </iframe>"},"/soft/maixpy/zh/api_reference/Maix/fpioa.html":{"title":"FPIOA (现场可编程 IO 阵列， Field Programmable Input and Output Array)","content":" title: FPIOA (现场可编程 IO 阵列， Field Programmable Input and Output Array) keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy FPIOA (现场可编程 IO 阵列， Field Programmable Input and Output Array) K210 支持每个外设随意映射到任意引脚， 使用 FPIOA 功能来实现。 **注意**: 以下 GPIOHS 默认已经被使用， 程序中如非必要尽量不要使用： GPIOHS 功能 描述 GPIOHS5 LCD_DC LCD 读写信号引脚 GPIOHS4 LCD_RST LCD 复位芯片脚 GPIOHS29 SD_CS SD 卡 SPI 片选 GPIOHS28 MIC_LED_CLK SK9822_DAT GPIOHS27 MIC_LED_DATA SK9822_CLK ## 类 `FPIOA` ### 方法 #### help(func) 显示外设及其简要描述 ##### 参数 * `func`： 外设名（功能/编号），可以不传参， 则以表格的形式显示所有外设名即简要描述，这个表格也可以在本页的末尾找到（[附录：外设表](#附录： 外设表)）；</br> 如果传参，则传一个整型值， 找到该编号对应的外设后会打印外设名和描述，</br> 比如 `FPIOA.JTAG_TCLK` 或者 `fm.fpioa.JTAG_TCLK`（`fm`在本页后面介绍） 或者 `0` 比如： ```python from Maix import FPIOA fpioa FPIOA() fpioa.help() fpioa.help(0) fpioa.help(fpioa.JTAG_TCLK) fm.fpioa.help() fm.fpioa.help(fm.fpioa.JTAG_TCLK) ``` ##### 返回 外设名及其简要描述 #### set_function(pin, func) 设置引脚对应的外设功能， 即引脚映射 ##### 参数 * `pin`： 引脚编号，取值 [0, 47]， 具体的引脚连接请看电路图， 也可以使用 `board_info.` 然后按 `TAB` 按键补全来获得板子的常用引脚，比如 `board_info.LED_G` * `func`： 外设功能，传一个整型值，可以通过 `fm.fpioa.help()`或者查本页末尾的 [附录： 外设表](#附录： 外设表) 表得到 比如 需要将连接 `绿色 LED` 的引脚映射到 `高速 GPIO0` 上： ```python fpioa FPIOA() fpioa.set_function(board_info.LED_G, fm.fpioa.GPIOHS0) ``` #### get_Pin_num(func) 获取外设映射到哪个引脚上了 ##### 参数 * `func`： 外设功能，传一个整型值，可以通过 `fm.fpioa.help()`或者查本页末尾的 [附录： 外设表](#附录： 外设表) 表得到 比如： ```python fpioa FPIOA() fpioa.set_function(board_info.LED_G, fm.fpioa.GPIOHS0) pin fpioa.get_Pin_num(fm.fpioa.GPIOHS0) if pin board_info.LED_G: print(\"set function ok\") ``` ## 附录： 外设表 外设功能（func） 简要描述 JTAG_TCLK JTAG Test Clock JTAG_TDI JTAG Test Data In JTAG_TMS JTAG Test Mode Select JTAG_TDO JTAG Test Data Out SPI0_D0 SPI0 Data 0 SPI0_D1 SPI0 Data 1 SPI0_D2 SPI0 Data 2 SPI0_D3 SPI0 Data 3 SPI0_D4 SPI0 Data 4 SPI0_D5 SPI0 Data 5 SPI0_D6 SPI0 Data 6 SPI0_D7 SPI0 Data 7 SPI0_SS0 SPI0 Chip Select 0 SPI0_SS1 SPI0 Chip Select 1 SPI0_SS2 SPI0 Chip Select 2 SPI0_SS3 SPI0 Chip Select 3 SPI0_ARB SPI0 Arbitration SPI0_SCLK SPI0 Serial Clock UARTHS_RX UART High speed Receiver UARTHS_TX UART High speed Transmitter RESV6 Reserved function RESV7 Reserved function CLK_SPI1 Clock SPI1 CLK_I2C1 Clock I2C1 GPIOHS0 GPIO High speed 0 GPIOHS1 GPIO High speed 1 GPIOHS2 GPIO High speed 2 GPIOHS3 GPIO High speed 3 GPIOHS4 GPIO High speed 4 GPIOHS5 GPIO High speed 5 GPIOHS6 GPIO High speed 6 GPIOHS7 GPIO High speed 7 GPIOHS8 GPIO High speed 8 GPIOHS9 GPIO High speed 9 GPIOHS10 GPIO High speed 10 GPIOHS11 GPIO High speed 11 GPIOHS12 GPIO High speed 12 GPIOHS13 GPIO High speed 13 GPIOHS14 GPIO High speed 14 GPIOHS15 GPIO High speed 15 GPIOHS16 GPIO High speed 16 GPIOHS17 GPIO High speed 17 GPIOHS18 GPIO High speed 18 GPIOHS19 GPIO High speed 19 GPIOHS20 GPIO High speed 20 GPIOHS21 GPIO High speed 21 GPIOHS22 GPIO High speed 22 GPIOHS23 GPIO High speed 23 GPIOHS24 GPIO High speed 24 GPIOHS25 GPIO High speed 25 GPIOHS26 GPIO High speed 26 GPIOHS27 GPIO High speed 27 GPIOHS28 GPIO High speed 28 GPIOHS29 GPIO High speed 29 GPIOHS30 GPIO High speed 30 GPIOHS31 GPIO High speed 31 GPIO0 GPIO pin 0 GPIO1 GPIO pin 1 GPIO2 GPIO pin 2 GPIO3 GPIO pin 3 GPIO4 GPIO pin 4 GPIO5 GPIO pin 5 GPIO6 GPIO pin 6 GPIO7 GPIO pin 7 UART1_RX UART1 Receiver UART1_TX UART1 Transmitter UART2_RX UART2 Receiver UART2_TX UART2 Transmitter UART3_RX UART3 Receiver UART3_TX UART3 Transmitter SPI1_D0 SPI1 Data 0 SPI1_D1 SPI1 Data 1 SPI1_D2 SPI1 Data 2 SPI1_D3 SPI1 Data 3 SPI1_D4 SPI1 Data 4 SPI1_D5 SPI1 Data 5 SPI1_D6 SPI1 Data 6 SPI1_D7 SPI1 Data 7 SPI1_SS0 SPI1 Chip Select 0 SPI1_SS1 SPI1 Chip Select 1 SPI1_SS2 SPI1 Chip Select 2 SPI1_SS3 SPI1 Chip Select 3 SPI1_ARB SPI1 Arbitration SPI1_SCLK SPI1 Serial Clock SPI_SLAVE_D0 SPI Slave Data 0 SPI_SLAVE_SS SPI Slave Select SPI_SLAVE_SCLK SPI Slave Serial Clock I2S0_MCLK I2S0 Master Clock I2S0_SCLK I2S0 Serial Clock(BCLK) I2S0_WS I2S0 Word Select(LRCLK) I2S0_IN_D0 I2S0 Serial Data Input 0 I2S0_IN_D1 I2S0 Serial Data Input 1 I2S0_IN_D2 I2S0 Serial Data Input 2 I2S0_IN_D3 I2S0 Serial Data Input 3 I2S0_OUT_D0 I2S0 Serial Data Output 0 I2S0_OUT_D1 I2S0 Serial Data Output 1 I2S0_OUT_D2 I2S0 Serial Data Output 2 I2S0_OUT_D3 I2S0 Serial Data Output 3 I2S1_MCLK I2S1 Master Clock I2S1_SCLK I2S1 Serial Clock(BCLK) I2S1_WS I2S1 Word Select(LRCLK) I2S1_IN_D0 I2S1 Serial Data Input 0 I2S1_IN_D1 I2S1 Serial Data Input 1 I2S1_IN_D2 I2S1 Serial Data Input 2 I2S1_IN_D3 I2S1 Serial Data Input 3 I2S1_OUT_D0 I2S1 Serial Data Output 0 I2S1_OUT_D1 I2S1 Serial Data Output 1 I2S1_OUT_D2 I2S1 Serial Data Output 2 I2S1_OUT_D3 I2S1 Serial Data Output 3 I2S2_MCLK I2S2 Master Clock I2S2_SCLK I2S2 Serial Clock(BCLK) I2S2_WS I2S2 Word Select(LRCLK) I2S2_IN_D0 I2S2 Serial Data Input 0 I2S2_IN_D1 I2S2 Serial Data Input 1 I2S2_IN_D2 I2S2 Serial Data Input 2 I2S2_IN_D3 I2S2 Serial Data Input 3 I2S2_OUT_D0 I2S2 Serial Data Output 0 I2S2_OUT_D1 I2S2 Serial Data Output 1 I2S2_OUT_D2 I2S2 Serial Data Output 2 I2S2_OUT_D3 I2S2 Serial Data Output 3 RESV0 Reserved function RESV1 Reserved function RESV2 Reserved function RESV3 Reserved function RESV4 Reserved function RESV5 Reserved function I2C0_SCLK I2C0 Serial Clock I2C0_SDA I2C0 Serial Data I2C1_SCLK I2C1 Serial Clock I2C1_SDA I2C1 Serial Data I2C2_SCLK I2C2 Serial Clock I2C2_SDA I2C2 Serial Data CMOS_XCLK DVP System Clock CMOS_RST DVP System Reset CMOS_PWDN DVP Power Down Mode CMOS_VSYNC DVP Vertical Sync CMOS_HREF DVP Horizontal Reference output CMOS_PCLK Pixel Clock CMOS_D0 Data Bit 0 CMOS_D1 Data Bit 1 CMOS_D2 Data Bit 2 CMOS_D3 Data Bit 3 CMOS_D4 Data Bit 4 CMOS_D5 Data Bit 5 CMOS_D6 Data Bit 6 CMOS_D7 Data Bit 7 SCCB_SCLK SCCB Serial Clock SCCB_SDA SCCB Serial Data UART1_CTS UART1 Clear To Send UART1_DSR UART1 Data Set Ready UART1_DCD UART1 Data Carrier Detect UART1_RI UART1 Ring Indicator UART1_SIR_IN UART1 Serial Infrared Input UART1_DTR UART1 Data Terminal Ready UART1_RTS UART1 Request To Send UART1_OUT2 UART1 User designated Output 2 UART1_OUT1 UART1 User designated Output 1 UART1_SIR_OUT UART1 Serial Infrared Output UART1_BAUD UART1 Transmit Clock Output UART1_RE UART1 Receiver Output Enable UART1_DE UART1 Driver Output Enable UART1_RS485_EN UART1 RS485 Enable UART2_CTS UART2 Clear To Send UART2_DSR UART2 Data Set Ready UART2_DCD UART2 Data Carrier Detect UART2_RI UART2 Ring Indicator UART2_SIR_IN UART2 Serial Infrared Input UART2_DTR UART2 Data Terminal Ready UART2_RTS UART2 Request To Send UART2_OUT2 UART2 User designated Output 2 UART2_OUT1 UART2 User designated Output 1 UART2_SIR_OUT UART2 Serial Infrared Output UART2_BAUD UART2 Transmit Clock Output UART2_RE UART2 Receiver Output Enable UART2_DE UART2 Driver Output Enable UART2_RS485_EN UART2 RS485 Enable UART3_CTS UART3 Clear To Send UART3_DSR UART3 Data Set Ready UART3_DCD UART3 Data Carrier Detect UART3_RI UART3 Ring Indicator UART3_SIR_IN UART3 Serial Infrared Input UART3_DTR UART3 Data Terminal Ready UART3_RTS UART3 Request To Send UART3_OUT2 UART3 User designated Output 2 UART3_OUT1 UART3 User designated Output 1 UART3_SIR_OUT UART3 Serial Infrared Output UART3_BAUD UART3 Transmit Clock Output UART3_RE UART3 Receiver Output Enable UART3_DE UART3 Driver Output Enable UART3_RS485_EN UART3 RS485 Enable TIMER0_TOGGLE1 TIMER0 Toggle Output 1 TIMER0_TOGGLE2 TIMER0 Toggle Output 2 TIMER0_TOGGLE3 TIMER0 Toggle Output 3 TIMER0_TOGGLE4 TIMER0 Toggle Output 4 TIMER1_TOGGLE1 TIMER1 Toggle Output 1 TIMER1_TOGGLE2 TIMER1 Toggle Output 2 TIMER1_TOGGLE3 TIMER1 Toggle Output 3 TIMER1_TOGGLE4 TIMER1 Toggle Output 4 TIMER2_TOGGLE1 TIMER2 Toggle Output 1 TIMER2_TOGGLE2 TIMER2 Toggle Output 2 TIMER2_TOGGLE3 TIMER2 Toggle Output 3 TIMER2_TOGGLE4 TIMER2 Toggle Output 4 CLK_SPI2 Clock SPI2 CLK_I2C2 Clock I2C2 "},"/soft/maixpy/zh/api_reference/Maix/freq.html":{"title":"Maix.freq","content":" title: Maix.freq keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy Maix.freq 频率模块，支持程序修改 cpu 和 kpu 频率 ## 方法 ### freq.set(cpu, pll1, kpu_div) 设置 cpu 或者 kpu 频率，设置完后会自动重启生效 请注意在频率设置完毕后可能会导致某些外设性能改变 ```python from Maix import freq freq.set(cpu 400, pll1 400, kpu_div 1) ``` 配置文件将会保存在文件系统的`/flash/freq.conf`文件下，请勿修改这个文件，如果文件不存在则会自动创建 #### 参数 不设置的参数会保持之前的值 **注意**： 如果`cpu`频率设置小于`60MHz`， 默认的`REPL`串口波特率会设置为`9600` * `cpu`： 想要设置的cpu频率，范围[26,600]（芯片最高`800`但对电压有要求，`MaixPy`支持的系列不支持最高到`800`，默认`400`, 不同的板子可能表现不同，为了稳定性不建议过高 * `pll1`: `pll1`输出的频率，取值范围[26,1200]（芯片最高1800，MaixPy限制到1200），默认 `400` * `kpu_div`：`kpu`时钟频率分频，取值范围[1,16]，默认`1`。 `kpu`频率 `pll1`/`kpu_div`， 比如想设置`kpu`频率为`400`，则只需设置`pll1`为`400`， `kpu_div`为`1`即可。 注意`kpu`频率范围：[26,600] #### 返回值 如果频率没有变化，则返回空。 如果频率有变化，将会自动重启机器。在使用该接口之前请确认当前情况能能否重启 ### freq.get() 获取当前设置的频率参数 #### 返回值 `cpu`频率和`kpu`的频率，一个元组的形式返回，比如`(400,400)` ### freq.get_cpu() 获取当前`cpu`的频率 #### 返回值 `cpu`频率 ### freq.get_kpu() 获取当前设置的 `kpu` 频率 #### 返回值 当前`kpu`频率"},"/soft/maixpy/zh/api_reference/Maix/gpio.html":{"title":"GPIO","content":" title: GPIO keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy GPIO General Purpose Input Output （通用输入/输出）简称为 GPIO，或总线扩展器。 K210上有高速 GPIO(GPIOHS) 和通用 GPIO 在 K210 上， GPIO 有以下特征： * 高速 GPIO： 高速 GPIO 为 GPIOHS，共 32 个。具有如下特点： * 可配置输入输出信号 * 每个 IO 具有独立中断源 * 中断支持边沿触发和电平触发 * 每个 IO 可以分配到 FPIOA 上 48 个管脚之一 * 可配置上下拉，或者高阻 * 通用 GPIO： 通用 GPIO 共 8 个，具有如下特点: * 8 个 IO 使用一个中断源 * 可配置输入输出信号 * 可配置触发 IO 总中断，边沿触发和电平触发 * 每个 IO 可以分配到 FPIOA 上 48 个管脚之一 **注意**: 以下 GPIOHS 默认已经被使用， 程序中如非必要尽量不要使用： GPIOHS 功能 GPIOHS31 LCD_DC GPIOHS30 LCD_RST GPIOHS29 SD_CS GPIOHS28 MIC_LED_CLK GPIOHS27 MIC_LED_DATA ## 构造函数 ```python class GPIO(ID, MODE, PULL, VALUE) ``` 通过指定的参数新建一个 SPI 对象 ### 参数 * `ID`： 使用的 GPIO 引脚(一定要使用 GPIO 里带的常量来指定) * `MODE`： GPIO模式 • GPIO.IN就是输入模式 • GPIO.OUT就是输出模式 * `PULL`： GPIO上下拉模式 • GPIO.PULL_UP 上拉 ​• GPIO.PULL_DOWN 下拉 ​• GPIO.PULL_NONE 即不上拉也不下拉 ## 方法 ### value 修改/读取 GPIO 引脚状态 ```python GPIO.value([value]) ``` #### 参数 * `[value]`： 可选参数，如果此参数不为空，则返回当前 GPIO 引脚状态 #### 返回值 如果 `[value]` 参数不为空，则返回当前 GPIO 引脚状态 ### irq 配置一个中断处理程序，当 `pin` 的触发源处于活动状态时调用它。如果管脚模式为 pin.in，则触发源是管脚上的外部值。 ```python GPIO.irq(CALLBACK_FUNC,TRIGGER_CONDITION,GPIO.WAKEUP_NOT_SUPPORT,PRORITY) ``` #### 参数 * `CALLBACK_FUNC`：中断回调函数，当中断触发的时候被调用，一个入口函数 `pin_num` ​• PIN_NUM 返回的是触发中断的 GPIO 引脚号(只有GPIOHS支持中断，所以这里的引脚号也是GPIOHS的引脚号) * `TRIGGER_CONDITION`：GPIO 引脚的中断触发模式 ​• GPIO.IRQ_RISING 上升沿触发 ​• GPIO.IRQ_FALLING 下降沿触发 ​• GPIO.IRQ_BOTH 上升沿和下降沿都触发 #### 返回值 无 ### disirq 关闭中断 ```python GPIO.disirq() ``` #### 参数 无 #### 返回值 无 ### mode 设置 GPIO 输入输出模式 ```python GPIO.mode(MODE) ``` #### 参数 * MODE • `GPIO.IN` 输入模式 • `GPIO.PULL_UP` 上拉输入模式 • `GPIO.PULL_DOWN` 下拉输入模式 • `GPIO.OUT` 输出模式 #### 返回值 无 ## 常量 * `GPIO0`: GPIO0 * `GPIO1`: GPIO1 * `GPIO2`: GPIO2 * `GPIO3`: GPIO3 * `GPIO4`: GPIO4 * `GPIO5`: GPIO5 * `GPIO6`: GPIO6 * `GPIO7`: GPIO7 * `GPIOHS0`: GPIOHS0 * `GPIOHS1`: GPIOHS1 * `GPIOHS2`: GPIOHS2 * `GPIOHS3`: GPIOHS3 * `GPIOHS4`: GPIOHS4 * `GPIOHS5`: GPIOHS5 * `GPIOHS6`: GPIOHS6 * `GPIOHS7`: GPIOHS7 * `GPIOHS8`: GPIOHS8 * `GPIOHS9`: GPIOHS9 * `GPIOHS10`: GPIOHS10 * `GPIOHS11`: GPIOHS11 * `GPIOHS12`: GPIOHS12 * `GPIOHS13`: GPIOHS13 * `GPIOHS14`: GPIOHS14 * `GPIOHS15`: GPIOHS15 * `GPIOHS16`: GPIOHS16 * `GPIOHS17`: GPIOHS17 * `GPIOHS18`: GPIOHS18 * `GPIOHS19`: GPIOHS19 * `GPIOHS20`: GPIOHS20 * `GPIOHS21`: GPIOHS21 * `GPIOHS22`: GPIOHS22 * `GPIOHS23`: GPIOHS23 * `GPIOHS24`: GPIOHS24 * `GPIOHS25`: GPIOHS25 * `GPIOHS26`: GPIOHS26 * `GPIOHS27`: GPIOHS27 * `GPIOHS28`: GPIOHS28 * `GPIOHS29`: GPIOHS29 * `GPIOHS30`: GPIOHS30 * `GPIOHS31`: GPIOHS31 * `GPIO.IN`: 输入模式 * `GPIO.OUT`: 输出模式 * `GPIO.PULL_UP`: 上拉 * `GPIO.PULL_DOWN`: 下拉 * `GPIO.PULL_NONE`: 即不上拉也不下拉 * `GPIO.IRQ_RISING`: 上升沿触发 * `GPIO.IRQ_FALLING`:下降沿触发 * `GPIO.IRQ_BOTH`: 上升沿和下降沿都触发 ### DEMO1: 点亮 LED > `board_info` 与板卡相关，不同板卡配置不同，使用前需要[手动配置](../builtin_py/board_info.html)。 ```python import utime from Maix import GPIO from board import board_info from fpioa_manager import fm fm.register(board_info.LED_R,fm.fpioa.GPIO0) led_r GPIO(GPIO.GPIO0,GPIO.OUT) utime.sleep_ms(500) led_r.value() fm.unregister(board_info.LED_R) ``` ### DEMO2: 按键按下点亮 LED > `board_info` 与板卡相关，不同板卡配置不同，使用前需要[手动配置](../builtin_py/board_info.html)。 ```python import utime from Maix import GPIO from board import board_info from fpioa_manager import fm fm.register(board_info.LED_R,fm.fpioa.GPIO0) led_b GPIO(GPIO.GPIO0,GPIO.OUT) led_b.value(1) fm.register(board_info.BOOT_KEY, fm.fpioa.GPIOHS1) key GPIO(GPIO.GPIOHS1, GPIO.IN) utime.sleep_ms(100) while True: if key.value() 0: # 等待按键按下 led_b.value(0) utime.sleep_ms(1000) break utime.sleep_ms(10) led_b.value(1) fm.unregister(board_info.LED_R) fm.unregister(board_info.BOOT_KEY) ``` ### DEMO3: 在 3 秒内等待按键触发中断 > `board_info` 与板卡相关，不同板卡配置不同，使用前需要[手动配置](../builtin_py/board_info.html)。 ```python import utime from Maix import GPIO from board import board_info from fpioa_manager import fm def test_irq(pin_num): print(\"key\", pin_num, \"\\n\") fm.register(board_info.BOOT_KEY, fm.fpioa.GPIOHS0) key GPIO(GPIO.GPIOHS0, GPIO.IN, GPIO.PULL_NONE) utime.sleep_ms(100) key.irq(test_irq, GPIO.IRQ_BOTH, GPIO.WAKEUP_NOT_SUPPORT,7) utime.sleep_ms(3000) # 在 3 秒内等待触发 key.disirq() # 禁用中断 fm.unregister(board_info.BOOT_KEY) ```"},"/soft/maixpy/zh/api_reference/Maix/kpu.html":{"title":"KPU","content":" title: KPU keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy KPU KPU是通用的神经网络处理器，它可以在低功耗的情况下实现卷积神经网络计算，时时获取被检测目标的大小、坐标和种类，对人脸或者物体进行检测和分类。 * KPU 具备以下几个特点： * 支持主流训练框架按照特定限制规则训练出来的定点化模型 * 对网络层数无直接限制，支持每层卷积神经网络参数单独配置，包括输入输出通道数目、输入输 出行宽列高 * 支持两种卷积内核 1x1 和 3x3 * 支持任意形式的激活函数 * 实时工作时最大支持神经网络参数大小为 5.5MiB 到 5.9MiB * 非实时工作时最大支持网络参数大小为（Flash 容量 软件体积） ## 例程 ### 运行人脸检测 模型下载地址：[http://dl.sipeed.com/MAIX/MaixPy/model](http://dl.sipeed.com/MAIX/MaixPy/model) , 下载`face_model_at_0x300000.kfpkg` 完整例程： [face_find](https://github.com/sipeed/MaixPy v1_scripts/tree/master/machine_vision/face_find) ### 运行特征图 模型下载地址：[http://dl.sipeed.com/MAIX/MaixPy/model](http://dl.sipeed.com/MAIX/MaixPy/model) , 下载`face_model_at_0x300000.kfpkg` 该模型是8bit定点模型，约380KB大小，层信息为： ``` 1 2 :160x120 3 4 5 6\t :80x60 7 8 9 10 :40x30 11~16 :20x15 ``` ```python import sensor import image import lcd import KPU as kpu index 3 lcd.init() sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) task kpu.load(0x300000) img image.Image() info kpu.netinfo(task) layer info[index] w layer.wo() h layer.ho() num int(320*240/w/h) list [None]*num x_step int(320/w) y_step int(240/h) img_lcd image.Image() while True: img sensor.snapshot() fmap kpu.forward(task,img,index) for i in range(0,num): list[i] kpu.fmap(fmap,i) for i in range(0,num): list[i].stretch(64,255) for i in range(0,num): a img_lcd.draw_image(list[i],((i%x_step)*w,(int(i/x_step))*h)) \t lcd.display(img_lcd) \tkpu.fmap_free(fmap) ``` ## 模块方法 ### load 从flash或者文件系统中加载模型 ```python KPU.load(offset, file_path) ``` #### 参数 `offset` 和 `file_path` 参数只能二选一，不需要关键词，直接传参即可 * `offset`: 模型在 flash 中的偏移大小，如 `0xd00000` 表示模型烧录在13M起始的地方, `0x300000`表示在 `Flash` `3M`的地方 * `file_path`: 模型在文件系统中为文件名， 如 `“/sd/xxx.kmodel”` ##### 返回 如果正确加载，会返回返回值， 否则会抛出错误， 请看抛出的错误提示， 另外错误代码参考[这里](https://github.com/sipeed/MaixPy v1/blob/fa3cf2c96353fa698e9386e42be8b3c9cf495114/components/kendryte_sdk/include/sipeed_kpu.h#L6 L23) 如果发现错误代码是小于 `2000` 的值， 则是固件版本太低，需要更新固件版本 * `kpu_net`: kpu 网络对象 ### load_flash 与 load 方法作用相同， ```python kpu.load_flash(model_addr, is_dual_buf, batch_size, spi_speed) ``` #### 参数 * `model_addr`：Flash addr 经过预处理的模型烧录到 flash 中的偏移地址。注意，这里需要预处理模型文件[说明](https://github.com/sipeed/MaixPy v1_scripts/blob/master/machine_vision/load_big_model/README_ZH.md)。 * `is_dual_buf`：`0`,单一缓冲区加载，使用较少的 RAM 和较慢的速度动态加载该模型文件； `1`，开启双缓冲加载，需要更大的 RAM， 运行速度相对较快。 * `batch_size`：将 `is_dual_buf` 设置为 1 时，需要设置 load batch_size，建议值为 `0x4000~0x10000`，可以测试出模型的最佳值。如果 `is_dual_buf` 为 0 则设置为 0 * `spi_speed`：使用 SPI flash 加载模型文件时，我们会暂时将 flash 设置为高速模式，并设置所需的 spi 时钟频率。该值应 < 80000000(实际频率，设值可能不等于实际频率。) #### 返回值 * `kpu_net`: kpu 网络对象 ### init_yolo2 为`yolo2`网络模型传入初始化参数， 只有使用`yolo2`时使用 ```python KPU.init_yolo2(kpu_net, threshold, nms_value, anchor_num, anchor) ``` 比如： ```python import KPU as kpu task kpu.load(0x300000) anchor (1.889, 2.5245, 2.9465, 3.94056, 3.99987, 5.3658, 5.155437, 6.92275, 6.718375, 9.01025) kpu.init_yolo2(task, 0.5, 0.3, 5, anchor) ``` #### 参数 * `kpu_net`: kpu 网络对象, 即加载的模型对象, `KPU.load()`的返回值 * `threshold`: 概率阈值， 只有是这个物体的概率大于这个值才会输出结果， 取值范围：[0, 1] * `nms_value`: box_iou 门限, 为了防止同一个物体被框出多个框，当在同一个物体上框出了两个框，这两个框的交叉区域占两个框总占用面积的比例 如果小于这个值时， 就取其中概率最大的一个框 * `anchor_num`: anchor 的锚点数， 这里固定为 `len(anchors)//2` * `anchor`: 锚点参数与模型参数一致，同一个模型这个参数是固定的，和模型绑定的（训练模型时即确定了）， 不能改成其它值。 #### 返回值 * `success`： `bool`类型， 是否成功 ### deinit 释放模型占用的内存， 立即释放， 但是变量还在，可以使用`del kpu_net_object` 的方式删除， 另外也可以直接只使用`del kpu_net_object`来标记对象已被删除，下一次`GC`进行内存回收或者手动调用`gc.collect()`时，会自动释放内存 ```python KPU.deinit(kpu_net) ``` 比如： ```python import KPU as kpu import gc task kpu.load(0x300000) kpu.deinit(task) del task gc.collect() ``` 或者： ```python import KPU as kpu import gc task kpu.load(0x300000) del task gc.collect() ``` #### 参数 `kpu_net`: `KPU.load()` 返回的 `kpu_net` 对象 #### 返回值 * `success`： `bool` 类型， 是否成功 ### run_yolo2 ```python import KPU as kpu import image task kpu.load(offset or file_path) anchor (1.889, 2.5245, 2.9465, 3.94056, 3.99987, 5.3658, 5.155437, 6.92275, 6.718375, 9.01025) kpu.init_yolo2(task, 0.5, 0.3, 5, anchor) img image.Image() kpu.run_yolo2(task, img) ``` > 以上为节选代码，并不是完整部分，详细请看[人脸检测](https://github.com/sipeed/MaixPy v1_scripts/blob/master/machine_vision/face_find/demo_find_face.py)具体的代码 #### 参数 * `kpu_net`: kpu_load 返回的 kpu_net 对象 * `image_t`：从 sensor 采集到的图像 ##### 返回 * `list`: kpu_yolo2_find 的列表 ### forward 计算已加载的网络模型到指定层数，输出目标层的特征图 ```python fmap KPU.forward(kpu_net, img, end_layer) ``` ```python import KPU as kpu task kpu.load(offset or file_path) …… fmap kpu.forward(task,img, 3) ``` #### 参数 * `kpu_net`: kpu_net 对象 * `img`: 图像 `image.Image` 对象 * `end_layer`: 指定计算到网络的第几层， 取值从`0`开始 ##### 返回 * `fmap`: 特征图对象，内含当前层所有通道的特征图 ### fmap 取特征图的指定通道数据到`image.Image`对象 ```python img KPU.fmap(fmap, channel) ``` #### 参数 * `fmap`: 特征图 对象 * `channel`: 指定特征图的通道号, 从`0`开始 ##### 返回 * `img`: 特征图对应通道生成的灰度图，类型`image.Image` ### fmap_free 释放特征图对象 ```python KPU.fmap_free(fmap) ``` #### 参数 * `fmap`: 特征图 对象 ##### 返回 * 无 ### netinfo 获取模型的网络结构信息 ```python info_list kpu.netinfo(task) ``` #### 参数 * `kpu_net`: kpu_net 对象, `KPU.load()`返回值 ##### 返回 * `info_list`：所有层的信息list, 包含信息为： * `index`：当前层在网络中的层数 * `wi`：输入宽度 * `hi`：输入高度 * `wo`：输出宽度 * `ho`：输出高度 * `chi`：输入通道数 * `cho`：输出通道数 * `dw`：是否为depth wise layer * `kernel_type`：卷积核类型，0为1x1， 1为3x3 * `pool_type`：池化类型，0不池化; 1：2x2 max pooling; 2:... * `para_size`：当前层的卷积参数字节数 ### set_outputs ```python success set_outputs(kput_net, out_idx, width, height, channel) ``` 手动设置输出层形状， 对于 nncase v0.2.0 转换出来的 V4 的 kmodel 模型， 在 `load` 之后需要调用此函数手动设置输出层形状， V3 模型不需要 #### 参数 * `kpu_net`: kpu_net 对象 * `out_idx`: 输出层下表， 从 `0` 开始， 比如第一层输出层是`0` * `width`： 层宽度， 如果是一维输出，则为`1` * `height`: 层高度， 如果是一维输出，则为`1` * `channnel`： 层通道数，如果是一维输出，则这里为一维输出的长度 ##### 返回 * `success`： 是否设置成功， 如果不成功，注意看输出的提示信息， 参考[错误代码](https://github.com/sipeed/MaixPy v1/blob/fa3cf2c96353fa698e9386e42be8b3c9cf495114/components/kendryte_sdk/include/sipeed_kpu.h#L6 L23) ### memtest 打印内存使用情况，包括`GC`内存和系统堆内存 * 注意执行这个函数会自动先执行`gc.collect()`进行内存回收一次，再打印`GC`剩余内存 * 系统堆内存只做参考，不一定准确，有时可能出现已经释放了内存，但是显示依然没有释放，以实际能不能分配到内存为准 ```python KPU.memtest() ``` ### face_encode 将 `forward` 返回的特征图进行量化，更多详情请查看：[kpu issue](https://github.com/sipeed/MaixPy v1issues/342) ```python feature kpu.face_encode(fmap[:]) ``` #### 参数 `fmap[:]`：`list` 类型，将 `forward` 函数返回值转化为列表所得到的 #### 返回值 `feature`：`list` 类型，量化后的列表 ### face_compare 将 face_encode 返回的量化值与已录入的人脸进行比较 ```python score kpu.face_compare(record_ftrs[j], feature) ``` #### 参数 `record_ftrs[j] `：`list` 类型，以录入的人脸数据 `feature`：`list` 类型，需要比较的人脸数据， `face_encode` 的返回值 #### 返回值 `score`：`int` 类型，比较得分（0~100），得分越高相似度越大"},"/soft/maixpy/zh/api_reference/standard/uerrno.html":{"title":"uerrno — 系统错误代码","content":" title: uerrno — 系统错误代码 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy uerrno — 系统错误代码 该模块实现了相应CPython模块的子集，如下所述。有关更多信息，请参阅原始CPython文档：[errno](https://docs.python.org/3.5/library/errno.html#module errno)。 该模块描述了 `OSError` 错误的错误标识。特定的代码库存取决于 `Micropython 的移植`， 错误会在特定的会出现错误的函数进行说明。 ## 常量 ### EEXIST, EAGAIN, 等 基于 ANSI C / POSIX 标准的错误代码。所有错误代码均以 “E” 开头。如上所述，代码库存取决于 MicroPython 的移植。错误通常可以作为`exc.args [0]`访问，其中`exc`是`OSError`的一个实例。用法示例： ```python try: uos.mkdir(\"my_dir\") except OSError as exc: if exc.args[0] uerrno.EEXIST: print(\"Directory already exists\") ``` ### uerrno.errorcode 字典将数字错误代码映射到带有符号错误代码的字符串（参见上文）： ```python >>> print(uerrno.errorcode[uerrno.EEXIST]) EEXIST ```"},"/soft/maixpy/zh/api_reference/standard/sys.html":{"title":"sys – 系统特定功能","content":" title: sys – 系统特定功能 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy sys – 系统特定功能 该模块实现了相应CPython模块的子集，如下所述。 有关更多信息，请参阅原始CPython文档：[sys](https://docs.python.org/3.5/library/sys.html#module sys). ## 功能函数 ### sys.exit(retval 0) 使用给定的退出代码终止当前程序。 根据此，此函数引发“SystemExit”异常。 如果给出了一个参数，它的值作为`SystemExit`的参数给出。 ### sys.print_exception(exc, file sys.stdout) 使用回溯到类文件对象文件（或默认情况下为`sys.stdout`）打印异常。 > **和 CPython 的不同** > 这是一个函数的简化版本，它出现在CPython的回溯模块中。 与traceback.print_exception（）不同，此函数只接受异常值而不是异常类型，异常值和回溯对象; file参数应该是位置的; 不支持其他参数。 可以在micropython lib中找到与CPython兼容的回溯模块。 ## 常量 ### sys.argv 当前程序启动时的可变参数列表。 ### sys.byteorder 系统的字节顺序（“小端”或“大端”`）。 ### sys.implementation 包含有关当前Python实现的信息的对象。 对于MicroPython，它具有以下属性： * name 字符串“micropython” * version 元组 (major, minor, micro), e.g. (1, 7, 0) 此对象是区分MicroPython与其他Python实现的推荐方法（请注意，它仍然可能不存在于非常小的端口中）。 > **和 CPython 的不同** > CPython要求为此对象提供更多属性，但实际有用的最低要求是在MicroPython中实现的。 ### sys.maxsize 本机整数类型可以在当前平台上保存的最大值，或MicroPython整数类型可表示的最大值，如果它小于平台最大值（对于没有长int支持的MicroPython端口的情况）。 此属性对于检测平台的“位数”（32位与64位等）非常有用。 建议不要直接将此属性与某个值进行比较，而是计算其中的位数： ```python bits 0 v sys.maxsize while v: bits + 1 v >> 1 if bits > 32: # 64 bit (or more) platform ... else: # 32 bit (or less) platform # Note that on 32 bit platform, value of bits may be less than 32 # (e.g. 31) due to peculiarities described above, so use \"> 16\", # \"> 32\", \"> 64\" style of comparisons. ``` ### sys.modules 加载模块的字典。 在某些端口上，它可能不包含内置模块。 ### sys.path 用于搜索导入模块的可变目录列表。 ### sys.platform 运行 MicroPython 的平台。 对于OS / RTOS端口，这通常是OS的标识符，例如，` “LINUX”`。 对于裸金属端口，它是电路板的标识符，例如 `“pyboard”`用于原始的 MicroPython 参考板。 因此，它可用于区分一块板与另一块板。 如果您需要检查您的程序是否在 MicroPython 上运行（与其他 Python 实现相比），请使用`sys.implementation`。 ### sys.stderr 标准错误 `stream`. ### sys.stdin 标准输入 `stream`. ### sys.stdout 标准输出 `stream`. ### sys.version 实现的 Python 版本， 返回一个字符串 ### sys.version_info 实现的 Python 版本， 返回一个由整数组成的元组"},"/soft/maixpy/zh/api_reference/standard/uzlib.html":{"title":"uzlib  — zlib 解压缩","content":" title: uzlib — zlib 解压缩 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy uzlib — zlib 解压缩 该模块实现了相应CPython模块的子集，如下所述。有关更多信息，请参阅原始CPython文档：[zlib](https://docs.python.org/3.5/library/zlib.html#module zlib)。 该模块允许解压使用 [DEFLATE](https://en.wikipedia.org/wiki/DEFLATE) 算法压缩的二进制数据（通常用于zlib库和gzip存档器）。 压缩尚未实现。 ## 函数 ### decompress 解压 ```python uzlib.decompress(data, wbits 0, bufsize 0) ``` #### 参数 * `wbits`： 压缩期间使用的 DEFLATE 字典窗口大小（8 15，字典大小是该值的2的幂）。 另外，如果值为正，则假定数据为 zlib 流（使用 zlib 头）。 否则，如果它是负数，则假定它是原始 DEFLATE 流。 * `bufsize`： 参数用于与CPython兼容， 可忽略。 #### 返回值 将解压缩的数据作为`bytes`类型返回。 ### DecompIO 创建一个流包装器，允许对另一个流中的压缩数据进行透明解压缩。 这允许处理具有大于可用堆大小的数据的压缩流。 除了decompress（）中描述的值之外，`wbits`可以取值 24..31（16+8..15），这意味着输入流具有gzip头。 ```python class uzlib.DecompIO(stream, wbits 0) ``` ## 与 CPython 的不同 这个类是MicroPython扩展。它包含在临时基础上，可能会在以后的版本中进行大量更改或删除。"},"/soft/maixpy/zh/api_reference/standard/uheapq.html":{"title":"uheapq – 堆队列算法","content":" title: uheapq – 堆队列算法 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy uheapq – 堆队列算法 该模块实现了对应 CPython 模块的子集，如下所述。 有关更多信息，请参阅原始CPython文档：[heapq](https://docs.python.org/3.5/library/heapq.html#module heapq)。 该模块实现堆队列算法。 堆队列只是一个以某种方式存储其元素的列表。 ## 函数 ### heappush ```python uheapq.heappush(heap, item) ``` 将元素放入堆。 ### heappop ```python uheapq.heappop(heap) ``` 弹出堆中的第一个元素，然后将其返回。 如果heap为空，则引发`IndexError`。 ### heapify ```python uheapq.heapify(x) ``` 将列表x转换为堆。 这是一个 in place（划分交换排序）操作。"},"/soft/maixpy/zh/api_reference/standard/usocket.html":{"title":"usocket – 套接字模块","content":" title: usocket – 套接字模块 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy usocket – 套接字模块 该模块实现了相应CPython模块的子集，如下所述。有关更多信息，请参阅原始CPython文档: [socket](https://docs.python.org/3.5/library/socket.html#module socket). 该模块提供对BSD套接字接口的访问 > **与CPython的区别** > 为了提高效率和一致性，MicroPython中的套接字对象直接实现了`stream`（类文件）接口。在CPython中，您需要使用`makefile（）`方法将套接字转换为类文件对象。 MicroPython仍支持此方法（但是无操作），因此在与CPython兼容的情况下，请务必使用它。 ## 套接字地址格式 `usocket`模块的本机套接字地址格式是getaddrinfo函数返回的不透明数据类型，必须用它来解析文本地址（包括数字地址）： ```python sockaddr usocket.getaddrinfo('www.micropython.org', 80)[0][ 1] # You must use getaddrinfo() even for numeric addresses sockaddr usocket.getaddrinfo('127.0.0.1', 80)[0][ 1] # Now you can use that address sock.connect(addr) ``` 使用`getaddrinfo`是最有效的（在内存和处理能力方面），而且也是使用地址的可移植方式。 但是，`socket`模块（注意与此处描述的本机MicroPython`usocket`模块的区别）提供了与CPython兼容的方式来使用元组指定地址，如下所述。请注意，取决于`MicroPython端口`，可以在内置或需要从`micropython lib`安装套接字模块（如“MicroPython Unix端口”的情况），并且某些端口仍然只接受元组中的数字地址格式，并要求使用`getaddrinfo`函数来解析域名。 总的来说： * 编写便携式应用程序时始终使用`getaddrinfo`。 * 如果您的端口支持快速黑客和交互式使用，则下面描述的元组地址可用作快捷方式。 `socket`模块的元组地址格式： * IPv4：（ipv4_address，port），其中ipv4_address是带有点符号数字IPv4地址的字符串，例如， “8.8.8.8”，端口号和整数端口号在1 65535范围内。请注意，域名不被接受为ipv4_address，应首先使用usocket.getaddrinfo（）解析它们。 * IPv6：（ipv6_address，port，flowinfo，scopeid），其中ipv6_address是带冒号数字IPv6地址的字符串，例如： `“2001：db8 :: 1”`，port是1 65535范围内的整数端口号。 flowinfo必须为0. scopeid是链路本地地址的接口范围标识符。请注意，域名不被接受为ipv6_address，应首先使用`usocket.getaddrinfo（）`解析它们。 IPv6支持的可用性取决于`MicroPython端口`。 ## 方法 ### usocket.socket(af AF_INET, type SOCK_STREAM, proto IPPROTO_TCP) 使用给定的地址系列，套接字类型和协议号创建一个新套接字。请注意，在大多数情况下不需要指定proto（不推荐使用，因为一些MicroPython端口可能会省略`IPPROTO_ *`常量）。相反，type参数将自动选择所需的协议： ```python # Create STREAM TCP socket socket(AF_INET, SOCK_STREAM) # Create DGRAM UDP socket socket(AF_INET, SOCK_DGRAM) ``` ### usocket.getaddrinfo(host, port, af 0, type 0, proto 0, flags 0) 将 host / port 参数转换为5元组序列，其中包含用于创建连接到该服务的套接字的所有必要参数。参数af，type和proto（与`socket（）`函数具有相同的含义）可用于过滤返回哪种地址。如果未指定参数或为零，则可以返回所有地址组合（需要在用户端进行过滤）。 生成的5元组列表具有以下结构： ```python (family, type, proto, canonname, sockaddr) ``` 以下示例显示如何连接到给定的URL： ```python s usocket.socket() # This assumes that if \"type\" is not specified, an address for # SOCK_STREAM will be returned, which may be not true s.connect(usocket.getaddrinfo('www.micropython.org', 80)[0][ 1]) ``` 建议使用过滤参数： ```python s usocket.socket() # Guaranteed to return an address which can be connect'ed to for # stream operation. s.connect(usocket.getaddrinfo('www.micropython.org', 80, 0, SOCK_STREAM)[0][ 1]) ``` > 与CPython的区别 > 如果此函数出错，CPython会引发`socket.gaierror`异常（`OSError`子类）。 MicroPython没有`socket.gaierror`并直接引发OSError。请注意，`getaddrinfo（）`的错误号形成一个单独的命名空间，可能与`uerrno`模块中的错误号不匹配。为了区分`getaddrinfo（）`错误，它们用负数表示，而标准系统错误是正数（错误号可以使用来自异常对象的`e.args [0]`属性访问）。使用负值是临时细节，可能在将来发生变化。 ### usocket.inet_ntop(af, bin_addr) 将给定地址族af的二进制网络地址bin_addr转换为文本表示： ```python >>> usocket.inet_ntop(usocket.AF_INET, b\"\\x7f\\0\\0\\1\") '127.0.0.1' ``` ### usocket.inet_pton(af, txt_addr) 将给定地址族af的文本网络地址txt_addr转换为二进制表示： ```python >>> usocket.inet_pton(usocket.AF_INET, \"1.2.3.4\") b'\\x01\\x02\\x03\\x04' ``` ## 常量 ### usocket.AF_INET usocket.AF_INET6 解决家庭类型。可用性取决于特定的`MicroPython端口`。 ### usocket.SOCK_STREAM usocket.SOCK_DGRAM 套接字类型。 ### usocket.IPPROTO_UDP usocket.IPPROTO_TCP IP协议号。可用性取决于特定的`MicroPython端口`。注意，在调用`usocket.socket（）`时不需要指定它们，因为`SOCK_STREAM`套接字类型会自动选择`IPPROTO_TCP`和`SOCK_DGRAM` `IPPROTO_UDP`。因此，这些常量的唯一实际用途是作为`setsockopt（）`的参数。 ### usocket.SOL_* 套接字选项级别（`setsockopt（）`的参数）。确切的库存取决于`MicroPython端口`。 ### usocket.SO_* 套接字选项（`setsockopt（）`的参数）。确切的库存取决于`MicroPython端口`。 ## 类 socket ### 方法 #### socket.close() 标记套接字已关闭并释放所有资源。一旦发生这种情况，套接字对象上的所有未来操作都将失败。如果协议支持，远程端将接收EOF指示。 套接字在被垃圾收集时会自动关闭，但建议你在完成它们之后立即“关闭”它们。 #### (maixpy 未实现)socket.bind(address) 将套接字绑定到地址。套接字必须尚未绑定。 #### (maixpy 未实现)socket.listen([backlog]) 使服务器接受连接。如果指定了积压，则必须至少为0（如果低，则将其设置为0）;并指定在拒绝新连接之前系统将允许的未接受连接数。如果未指定，则选择默认的合理值。 #### (maixpy 未实现)socket.accept() 接受连接。套接字必须绑定到一个地址并侦听连接。返回值是一对（conn，address），其中conn是可用于在连接上发送和接收数据的新套接字对象，address是绑定到连接另一端的套接字的地址。 #### socket.connect(address) 连接到地址处的远程套接字。 #### socket.send(bytes) 将数据发送到套接字。套接字必须连接到远程套接字。返回发送的字节数，可能小于数据长度（“短写”）。 #### socket.sendall(bytes) 将所有数据发送到套接字。套接字必须连接到远程套接字。与`send（）`不同，此方法将尝试通过连续发送数据块来发送所有数据。 此方法在非阻塞套接字上的行为未定义。因此，在MicroPython上，建议使用`write（）`方法，它具有相同的“无短写入”策略来阻塞套接字，并将返回在非阻塞套接字上发送的字节数。 #### socket.recv(bufsize) 从套接字接收数据。返回值是表示接收数据的字节对象。一次接收的最大数据量由bufsize指定。 #### socket.sendto(bytes, address) 将数据发送到套接字。套接字不应连接到远程套接字，因为目标套接字由地址指定。 #### socket.recvfrom(bufsize) 从套接字接收数据。返回值是一对（字节，地址），其中bytes是表示接收数据的字节对象，address是发送数据的套接字的地址。 #### socket.setsockopt(level, optname, value) 设置给定套接字选项的值。所需的符号常量在套接字模块中定义（SO_ *等）。该值可以是整数或表示缓冲区的类字节对象。 #### socket.settimeout(value) 注意：并非每个端口都支持此方法，请参阅下文。 阻止套接字操作设置超时。 value参数可以是表示秒的非负浮点数，也可以是None。如果给出非零值，则如果在操作完成之前已经过了超时时间值，则后续的套接字操作将引发“OSError”异常。如果给出零，则套接字处于非阻塞模式。如果给出None，则套接字处于阻塞模式。 并非每个“MicroPython端口”都支持此方法。更便携和通用的解决方案是使用`uselect.poll`对象。这允许同时等待多个对象（而不仅仅是在套接字上，而是在支持轮询的通用`stream`对象上）。例： ```python # Instead of: s.settimeout(1.0) # time in seconds s.read(10) # may timeout # Use: poller uselect.poll() poller.register(s, uselect.POLLIN) res poller.poll(1000) # time in milliseconds if not res: # s is still not ready for input, i.e. operation timed out ``` > 与CPython的区别 > CPython在超时的情况下引发`socket.timeout`异常，这是一个OSError子类。 MicroPython直接引发了一个`OSError`。如果你使用`除了OSError`：来捕获异常，你的代码将在MicroPython和CPython中都有效。 #### socket.setblocking(flag) 设置套接字的阻塞或非阻塞模式：如果flag为false，则套接字设置为非阻塞，否则设置为阻塞模式。 这个方法是某些`settimeout（）`调用的简写： `sock.setblocking(True)` 相当于`sock.settimeout(None)` `sock.setblocking(False)` i相当于 `sock.settimeout(0)` #### socket.makefile(mode 'rb', buffering 0) 返回与套接字关联的文件对象。确切的返回类型取决于给makefile（）的参数。支持仅限于二进制模式（'rb'，'wb'和'rwb'）。 CPython的参数：不支持编码，错误和换行符。 > 与CPython的区别 > 由于MicroPython不支持缓冲流，因此忽略缓冲参数的值，并将其视为0（无缓冲）。 > 与CPython的区别 > 关闭makefile（）返回的文件对象也将关闭原始套接字。 #### socket.read([size]) 从插槽中读取大小字节。返回一个字节对象。如果没有给出大小，它会读取插座中可用的所有数据，直到EOF;因此，在套接字关闭之前，该方法不会返回。此函数尝试读取所请求的数据（没有“短读取”）。但是，对于非阻塞套接字，这可能是不可能的，然后将返回更少的数据。 #### socket.readinto(buf[, nbytes]) 将字节读入buf。如果指定了nbytes，则最多读取多个字节。否则，最多读取len（buf）字节。就像read（）一样，此方法遵循“无短读”策略。 返回值：读取并存储到buf中的字节数。 #### socket.readline() 读一行，以换行符结尾。 返回值：读取的行。 #### socket.write(buf) 将字节缓冲区写入套接字。此函数将尝试将所有数据写入套接字（无“短写”）。但是，对于非阻塞套接字，这可能是不可能的，并且返回值将小于buf的长度。 返回值：写入的字节数。 #### exception usocket.error MicroPython没有此异常。 > 与CPython的区别 > CPython曾经有一个`socket.error`异常现在已被弃用，它是`OSError`的别名。在MicroPython中，直接使用`OSError`。 ## 例程 ### 例程 1： 下载图片并显示 > 注意需要设置 WiFi SSID 和 密码 ```python import socket import network import gc import os import lcd, image fm.register(board_info.WIFI_RX,fm.fpioa.UART2_TX) fm.register(board_info.WIFI_TX,fm.fpioa.UART2_RX) uart machine.UART(machine.UART.UART2,115200,timeout 1000, read_buf_len 4096) nic network.ESP8285(uart) nic.connect(\"Sipeed_2.4G\",\" \") sock socket.socket() addr socket.getaddrinfo(\"dl.sipeed.com\", 80)[0][ 1] sock.connect(addr) sock.send('''GET /MAIX/MaixPy/assets/Alice.bmp HTTP/1.1 Host: dl.sipeed.com cache control: no cache ''') img b\"\" sock.settimeout(5) while True: data sock.recv(4096) if len(data) 0: break print(\"rcv:\", len(data)) img img + data print(len(img)) img img[img.find(b\"\\r\\n\\r\\n\")+4:] print(len(img)) print(\"save to /sd/Alice.bmp\") f open(\"/sd/Alice.bmp\",\"wb\") f.write(img) f.close() print(\"save ok\") print(\"display\") img image.Image(\"/sd/Alice.bmp\") lcd.init() lcd.display(img) ``` ### 例程 2： 发送图片 ```python import os import socket import network import gc fm.register(board_info.WIFI_RX,fm.fpioa.UART2_TX) fm.register(board_info.WIFI_TX,fm.fpioa.UART2_RX) uart machine.UART(machine.UART.UART2,115200,timeout 1000, read_buf_len 4096) nic network.ESP8285(uart) nic.connect(\"Sipeed_2.4G\",\" \") addr (\"192.168.0.183\", 3456) sock socket.socket() sock.connect(addr) sock.settimeout(5) f open(\"/sd/Alice.bmp\",\"rb\") while True: img f.read(2048) if not img or (len(img) 0): break sock.send(img) f.close() sock.close() ```"},"/soft/maixpy/zh/api_reference/standard/ure.html":{"title":"ure – 简单的正则表达式","content":" title: ure – 简单的正则表达式 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy ure – 简单的正则表达式 该模块实现了相应CPython模块的子集，如下所述。 有关更多信息，请参阅原始CPython文档：[re](https://docs.python.org/3.5/library/re.html#module re). 该模块实现了正则表达式操作。 支持的正则表达式语法是CPython`re`模块的子集（实际上是POSIX扩展正则表达式的子集）。 ## 支持的运算符和特殊序列 * `.` : 匹配任何字符。 * `[...]` : 匹配字符集。 支持单个字符和范围，包括否定集（例如`[^ a c]`）。 * `^` : 匹配字符串的开头。 * `$` : 匹配字符串的结尾。 * `?` : 匹配零个或前一个子模式之一。 * `*` : 匹配前一个子模式的零个或多个。 * `+` : 匹配前一个子模式中的一个或多个。 * `??` : 非贪婪版的`？`，匹配零或一，偏好为零。 * `*?` : `*`的非贪婪版本，匹配零或更多，优先选择最短匹配。 * `+?` : 非贪婪的“+”版本，匹配一个或多个，优先匹配最短。 * `` : 匹配此运算符的左侧或右侧子模式。 * `(...)` : 分组。 每个组都在捕获（它捕获的子字符串可以使用`match.group（）方法访问）。 * `\\d` : 匹配数字。 相当于`[0 9]`。 * `\\D` : 匹配非数字。 相当于`[^ 0 9]`。 * `\\s` : * `\\S` : 匹配空白。 相当于 `[^ \\t \\r]`. * `\\w` : 匹配“单词字符”（仅限ASCII）。 相当于 `[A Za z0 9_]`. * `\\W` : 匹配非“单词字符”（仅限ASCII）。 相当于 `[^A Za z0 9_]`. * `\\` : 转义字符。 除了上面列出的那些之外，反斜杠后面的任何其他字符都是字面意思。 例如，`\\*`等同于文字`*`（不被视为`*`运算符）。 请注意，`\\r`，`\\n，`等不是专门处理的，并且相当于文字字母`r`，`n`等。因此，不建议使用原始Python字符串（`r“”`）用于正则表达式。 例如，`r“\\r \\n”`用作正则表达式时相当于`“rn”`。 要匹配CR后跟LF的字符，请使用`\"\\r\\n\"`。 ## 不支持的表达式 * 重复计算 (`{m,n}`) * 命名组 (`(?P<name>...)`) * 非捕获组 (`(?:...)`) * 更高级的断言 (`\\b, \\B`) * 像`\\r`，`\\n`这样的特殊字符转义 使用Python自己的转义 * 其它 例子： ```python import ure # As ure doesn't support escapes itself, use of r\"\" strings is not # recommended. regex ure.compile(\"[\\r\\n]\") regex.split(\"line1\\rline2\\nline3\\r\\n\") # Result: # ['line1', 'line2', 'line3', '', ''] ``` ## 方法 ### ure.compile(regex_str[, flags]) 编译正则表达式， 返回[regex](http://docs.micropython.org/en/latest/library/ure.html?highlight ure#regex) 对象。 ### ure.match(regex_str, string) 编译regex_str并匹配字符串。 匹配始终从字符串中的起始位置开始。 ### ure.search(regex_str, string) 编译regex_str并在字符串中搜索它。 与`match`不同，这将搜索字符串以匹配正则表达式的第一个位置（如果正则表达式被锚定，它仍然可以是0）。 ### ure.sub(regex_str, replace, string, count 0, flags 0) 编译regex_str并在字符串中搜索它，用replace替换所有匹配项，并返回新字符串。 replace可以是字符串或函数。 如果它是一个字符串，那么`\\<number>`和`\\g<number>`形式的转义序列可用于扩展到相应的组（或不匹配组的空字符串）。 如果replace是一个函数，那么它必须采用一个参数（匹配）并且应该返回一个替换字符串。 如果指定了count并且非零，那么在进行许多替换之后，替换将停止。 flags参数被忽略。 注意：此函数的可用性取决于`MicroPython port`。 ### ure.DEBUG 标记值，显示有关已编译表达式的调试信息。 （可用性取决于`MicroPython 移植实现`。） ## Regex 对象 编译了的正则表达式。 使用`ure.compile()`创建此类的实例。 ### regex.match(string) regex.search(string) regex.sub(replace, string, count 0, flags 0) 类似于模块级函数`match（）`，`search（）`和`sub（）`。 如果将相同的正则表达式应用于多个字符串，则使用方法会更高效。 ### regex.split(string, max_split 1) 使用正则表达式拆分字符串。 如果给出 max_split，则指定要执行的最大拆分数。 返回字符串列表（如果指定了，则最多可以有 max_split + 1 个元素）。 ## Match 对象 匹配`match（）`和`search（）`方法返回的对象，并传递给sub（）中的替换函数。 ### match.group(index) 返回匹配（子）字符串。 整个匹配的索引为0，每个捕获组的索引为1和更高。 仅支持数字组。 ### match.groups() 返回包含匹配组的所有子串的元组。 注意：此方法的可用性取决于`MicroPython 移植实现`。 ### match.start([index]) match.end([index]) 返回匹配的子字符串组的开头或结尾的原始字符串中的索引。 index默认为整个组，否则将选择一个组。 注意：这些方法的可用性取决于`MicroPython 移植实现`。 ### match.span([index]) 返回2元组`（match.start（index），match.end（index））`。 注意：此方法的可用性取决于`MicroPython 移植` 是否实现。"},"/soft/maixpy/zh/api_reference/standard/ustruct.html":{"title":"ustruct – 打包和解包原始数据类型","content":" title: ustruct – 打包和解包原始数据类型 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy ustruct – 打包和解包原始数据类型 该模块实现了相应的`CPython`模块的子集，如下所述。有关更多信息，请参阅原始CPython文档： [struct](https://docs.python.org/3.5/library/struct.html#module struct). 支持的大小/字节顺序前缀: `@`, `<`, `>`, `!`. 支持的格式代码： `b`, `B`, `h`, `H`, `i`, `I`, `l`, `L`, `q`, `Q`, `s`, `P`, `f`, `d` （后者2取决于浮点支持）。 ## 函数 ### calcsize ```python ustruct.calcsize(fmt) ``` 返回存储给定`fmt`所需的字节数。 ### pack ```python ustruct.pack(fmt, v1, v2, ...) ``` 根据格式字符串`fmt`打包值`v1`，`v2`，`...`。返回值是编码值的字节对象。 ### pack_into ```python ustruct.pack_into(fmt, buffer, offset, v1, v2, ...) ``` 根据格式字符串`fmt`将值`v1`，`v2`，`...`打包到从offset开始的缓冲区中。从缓冲区的末尾开始计数可能是负数。 ### unpack ```python ustruct.unpack(fmt, data) ``` 根据格式字符串`fmt`从`data`解包。返回值是解压缩值的元组。 ### unpack_from ```python ustruct.unpack_from(fmt, data, offset 0) ``` 根据格式字符串`fmt`从 `offset` 开始从`data`解包。 `offset`可能是负数，从缓冲区的末尾开始计数。返回值是解压缩值的元组。"},"/soft/maixpy/zh/api_reference/standard/index.html":{"title":"标准库","content":" title: 标准库 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy 标准库 * [cmath](./cmath.html) * [gc](./gc.html) * [math](./math.html) * [sys](./sys.html) * [ubinascii](./ubinascii.html) * [ucollections](./ucollections.html) * [uctypes](./uctypes.html) * [uerrno](./uerrno.html) * [uhashlib](./uhashlib.html) * [uheapq](./uheapq.html) * [ujson](./ujson.html) * [uos](./uos.html) * [ure](./ure.html) * [uselect](./uselect.html) * [usocket](./usocket.html) * [ustruct](./ustruct.html) * [utime](./utime.html) * [uzlib](./uzlib.html)"},"/soft/maixpy/zh/api_reference/standard/uctypes.html":{"title":"uctypes – 以结构化方式访问二进制数据","content":" title: uctypes – 以结构化方式访问二进制数据 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy uctypes – 以结构化方式访问二进制数据 该模块为MicroPython实现“外部数据接口”。 它背后的想法类似于CPython的`ctypes`模块，但实际的API是不同的，流线型和小尺寸优化。 该模块的基本思想是定义具有与C语言允许的功能大致相同的数据的数据结构布局，然后使用熟悉的点语法访问它以引用子字段。 > **警告** > > uctypes模块允许访问机器的任意内存地址（包括I / O和控制寄存器）。 不小心使用它可能会导致崩溃，数据丢失，甚至硬件故障。 > **也可参考** > > **[ustruct](ustruct.html)模块** > > 用于访问二进制数据结构的标准Python方法（不能很好地扩展到大型和复杂的结构）。 例程： ```python import uctypes # Example 1: Subset of ELF file header # https://wikipedia.org/wiki/Executable_and_Linkable_Format#File_header ELF_HEADER { \"EI_MAG\": (0x0 uctypes.ARRAY, 4 uctypes.UINT8), \"EI_DATA\": 0x5 uctypes.UINT8, \"e_machine\": 0x12 uctypes.UINT16, } # \"f\" is an ELF file opened in binary mode buf f.read(uctypes.sizeof(ELF_HEADER, uctypes.LITTLE_ENDIAN)) header uctypes.struct(uctypes.addressof(buf), ELF_HEADER, uctypes.LITTLE_ENDIAN) assert header.EI_MAG b\"\\x7fELF\" assert header.EI_DATA 1, \"Oops, wrong endianness. Could retry with uctypes.BIG_ENDIAN.\" print(\"machine:\", hex(header.e_machine)) # Example 2: In memory data structure, with pointers COORD { \"x\": 0 uctypes.FLOAT32, \"y\": 4 uctypes.FLOAT32, } STRUCT1 { \"data1\": 0 uctypes.UINT8, \"data2\": 4 uctypes.UINT32, \"ptr\": (8 uctypes.PTR, COORD), } # Suppose you have address of a structure of type STRUCT1 in \"addr\" # uctypes.NATIVE is optional (used by default) struct1 uctypes.struct(addr, STRUCT1, uctypes.NATIVE) print(\"x:\", struct1.ptr[0].x) # Example 3: Access to CPU registers. Subset of STM32F4xx WWDG block WWDG_LAYOUT { \"WWDG_CR\": (0, { # BFUINT32 here means size of the WWDG_CR register \"WDGA\": 7 << uctypes.BF_POS 1 << uctypes.BF_LEN uctypes.BFUINT32, \"T\": 0 << uctypes.BF_POS 7 << uctypes.BF_LEN uctypes.BFUINT32, }), \"WWDG_CFR\": (4, { \"EWI\": 9 << uctypes.BF_POS 1 << uctypes.BF_LEN uctypes.BFUINT32, \"WDGTB\": 7 << uctypes.BF_POS 2 << uctypes.BF_LEN uctypes.BFUINT32, \"W\": 0 << uctypes.BF_POS 7 << uctypes.BF_LEN uctypes.BFUINT32, }), } WWDG uctypes.struct(0x40002c00, WWDG_LAYOUT) WWDG.WWDG_CFR.WDGTB 0b10 WWDG.WWDG_CR.WDGA 1 print(\"Current counter:\", WWDG.WWDG_CR.T) ``` ## 定义结构布局 结构布局由“描述符”定义 一个Python字典，它将字段名称编码为键，以及将它们作为关联值访问它们所需的其他属性： ```python { \"field1\": <properties>, \"field2\": <properties>, ... } ``` 目前，`uctypes`需要明确规定每个字段的偏移量。 从结构开始以字节为单位给出偏移量。 以下是各种字段类型的编码示例： * 标量类型: ```python \"field_name\": offset uctypes.UINT32 ``` 换句话说，该值是标量类型标识符，与结构起始处的字段偏移量（以字节为单位）进行或运算。 * 递归结构： ```python \"sub\": (offset, { \"b0\": 0 uctypes.UINT8, \"b1\": 1 uctypes.UINT8, }) ``` 即，值是2元组，其第一个元素是偏移量，第二个是结构描述符字典（注意：递归描述符中的偏移量与其定义的结构相关）。 当然，递归结构不仅可以通过文字字典指定，还可以通过按名称引用结构描述符字典（前面定义）来指定。 * 原始类型的数组： ```python \"arr\": (offset uctypes.ARRAY, size uctypes.UINT8), ``` 即，值是一个2元组，其第一个元素是ARRAY标志与偏移进行OR运算，第二个是标量元素类型ORed数组中的元素数。 *聚合类型数组： ```python \"arr2\": (offset uctypes.ARRAY, size, {\"b\": 0 uctypes.UINT8}), ``` 即，值是一个3元组，其第一个元素是ARRAY标志，与偏移相关，第二个是数组中的元素数，第三个是元素类型的描述符。 *指向原始类型的指针： ```python \"ptr\": (offset uctypes.PTR, uctypes.UINT8), ``` 即，值是2元组，其第一个元素是PTR标志与偏移进行OR运算，第二个元素是标量元素类型。 *指向聚合类型的指针： ```python \"ptr2\": (offset uctypes.PTR, {\"b\": 0 uctypes.UINT8}), ``` 即，值是2元组，其第一个元素是PTR标志与偏移量进行OR运算，第二个元素是指向的类型的描述符。 *比特场： ```python \"bitf0\": offset uctypes.BFUINT16 lsbit << uctypes.BF_POS bitsize << uctypes.BF_LEN, ``` 即，value是一种包含给定位域的标量值（类型名称类似于标量类型，但前缀为“BF”），与包含位域的标量值的偏移进行OR运算，并进一步与位位置和位长度的值进行“或”运算。标量值内的位域，分别移位BF_POS和BF_LEN位。位域位置从标量的最低有效位（具有0的位置）开始计数，并且是字段的最右位的数量（换句话说，它是标量需要向右移位的位数）提取位域）。 在上面的例子中，首先在偏移0处提取UINT16值（当访问硬件寄存器时，这个细节可能很重要，需要特定的访问大小和对齐），然后是最右边的位是此UINT16的lsbit位的位域，以及length是bitsize bits，将被提取。例如，如果lsbit为0且bitsize为8，那么它将有效地访问UINT16的最低有效字节。 注意，位域操作独立于目标字节字节序，特别是上面的例子将在小端和大端结构中访问UINT16的最低有效字节。但它取决于最低有效位被编号为0.某些目标可能在其原生ABI中使用不同的编号，但是“uctypes”总是使用上述的标准化编号。 ## 模块内容 ### class uctypes.struct(addr, descriptor, layout_type NATIVE) 基于内存中的结构地址，描述符（编码为字典）和布局类型（参见下文）来实例化“外部数据结构”对象。 ### uctypes.LITTLE_ENDIAN little endian压缩结构的布局类型。 （打包意味着每个字段占用描述符中定义的字节数，即对齐为1）。 ### uctypes.BIG_ENDIAN big endian压缩结构的布局类型。 ### uctypes.NATIVE 本机结构的布局类型 数据字节顺序和对齐符合运行MicroPython的系统的ABI。 ### uctypes.sizeof(struct, layout_type NATIVE) 以字节为单位返回数据结构的大小。 struct参数可以是结构类，也可以是特定的实例化结构对象（或其聚合字段）。 ### uctypes.addressof(obj) 返回对象的地址。 参数应该是字节，字节数组或其他支持缓冲区协议的对象（该缓冲区的地址实际上是返回的）。 ### uctypes.bytes_at(addr, size) 以给定的地址和大小捕获内存作为bytes对象。 由于bytes对象是不可变的，因此内存实际上是复制并复制到bytes对象中，因此如果内存内容稍后更改，则创建的对象将保留原始值。 ### uctypes.bytearray_at(addr, size) 将给定地址和大小的内存捕获为bytearray对象。 与上面的bytes_at（）函数不同，内存是通过引用捕获的，因此它也可以写入，并且您将在给定的内存地址访问当前值。 ### uctypes.UINT8 uctypes.INT8 uctypes.UINT16 uctypes.INT16 uctypes.UINT32 uctypes.INT32 uctypes.UINT64 uctypes.INT64 结构描述符的整数类型。 提供了8,16,32和64位类型的常量，包括有符号和无符号。 ### uctypes.FLOAT32 uctypes.FLOAT64 结构描述符的浮点类型。 ### uctypes.VOID VOID是UINT8的别名，用于方便地定义C的void指针：（uctypes.PTR，uctypes.VOID）。 ### uctypes.PTR uctypes.ARRAY 输入指针和数组的常量。 请注意，结构没有显式常量，它是隐式的：没有PTR或ARRAY标志的聚合类型是一种结构。 ## 结构描述符和实例化结构对象 给定结构描述符字典及其布局类型，您可以使用`uctypes.struct（）`构造函数在给定的内存地址实例化特定的结构实例。 内存地址通常来自以下来源： *访问裸机系统上的硬件寄存器时的预定义地址。 在特定MCU / SoC的数据表中查找这些地址。 *作为调用某些FFI（外部函数接口）函数的返回值。 *来自uctypes.addressof（），当您想要将参数传递给FFI函数时，或者访问I / O的某些数据（例如，从文件或网络套接字读取的数据）。 ## 结构对象 结构对象允许使用标准点表示法访问单个字段：`my_struct.substruct1.field1。如果字段是标量类型，获取它将产生与字段中包含的值对应的原始值（Python整数或浮点数）。 标量字段也可以分配给。 如果某个字段是一个数组，则可以使用标准的下标运算符[]访问其各个元素 同时读取和分配。 如果一个字段是一个指针，它可以使用[0]语法解除引用（对应于C *运算符，尽管[0]也适用于C）。 还支持使用其他整数值（但是为0）订阅指针，其语义与C中相同。 总而言之，访问结构字段通常遵循C语法，除了指针取消引用，当您需要使用[0]运算符而不是*时。 ## 限制 * 访问非标量字段会导致分配中间对象以表示它们。这意味着应该特别注意布局在禁用内存分配时（例如从中断）需要访问的结构。建议如下： * 避免访问嵌套结构。例如，代替mcu_registers.peripheral_a.register1，为每个外设定义单独的布局描述符，作为peripheral_a.register1进行访问。或者只缓存特定的外设：peripheral_a mcu_registers.peripheral_a。如果寄存器由多个位域组成，则需要缓存对特定寄存器的引用：reg_a mcu_registers.peripheral_a.reg_a。 * 避免使用其他非标量数据，如数组。例如，使用peripheral_a.register0而不是peripheral_a.register [0]。同样，另一种方法是缓存中间值，例如register0 peripheral_a.register [0]。 * `uctypes`模块支持的偏移范围是有限的。支持的确切范围被认为是实现细节，一般建议是将结构定义拆分为从几千字节到几十千字节的最大值。在大多数情况下，这是一种自然情况，例如，在一个结构中定义MCU的所有寄存器（扩展到32位地址空间）没有意义，而是通过外设块定义外设块。在某些极端情况下，您可能需要人工分割几个部分的结构（例如，如果在中间访问具有多兆字节数组的本机数据结构，尽管这将是非常合成的情况）。）"},"/soft/maixpy/zh/api_reference/standard/cmath.html":{"title":"cmath – 复数的数学函数","content":" title: cmath – 复数的数学函数 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy cmath – 复数的数学函数 该模块实现了相应CPython模块的子集，如下所述。有关更多信息，请参阅原始CPython文档: [cmath](https://docs.python.org/3.5/library/cmath.html#module cmath). `cmath` 模块提供了一些处理复数的基本数学函数。 ## 函数 ### cos ```python cmath.cos(z) ``` 返回`z`的余弦。 ### exp ```python cmath.exp(z) ``` 返回`z`的指数。 ### log ```python cmath.log(z) ``` 返回`z`的自然对数。分支切割沿负实轴。 ### log10 ```python cmath.log10(z) ``` 返回`z`的以10为底的对数。分支切割沿负实轴。 ### phase ```python cmath.phase(z) ``` 返回数字“z”的相位，范围（ pi，+ pi）。 ### polar ```python cmath.polar(z) ``` 作为元组返回`z`的极性形式。 ### rect ```python cmath.rect(r, phi) ``` 返回模数`r`和相位`phi`的复数。 ### sin ```python cmath.sin(z) ``` 返回`z`的正弦值。 ### sqrt ```python cmath.sqrt(z) ``` 返回`z`的平方根。 ## Constants ### cmath.e 自然对数的基础 ### cmath.pi 圆周长与直径的比值"},"/soft/maixpy/zh/api_reference/standard/math.html":{"title":"math – 数学函数","content":" title: math – 数学函数 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy math – 数学函数 该模块实现了相应CPython模块的子集，如下所述。有关更多信息，请参阅原始CPython文档：[math](https://docs.python.org/3.5/library/math.html#module math). `math`模块提供了一些处理浮点数的基本数学函数。 ## 函数 ### math.acos(x) 返回`x`的反余弦值。 ### math.acosh(x) 返回`x`的反双曲余弦值。 ### math.asin(x) 返回`x`的反正弦。 ### math.asinh(x) 返回`x`的反双曲正弦值。 ### math.atan(x) 返回`x`的反正切。 ### math.atan2(y, x) 返回`y` /`x`的反正切的主值。 ### math.atanh(x) 返回`x`的反双曲正切。 ### math.ceil(x) 返回一个整数，“x”向正无穷大四舍五入。 ### math.copysign(x, y) 以`y`的符号返回`x`。 ### math.cos(x) 返回`x`的余弦。 ### math.cosh(x) 返回`x`的双曲余弦值 ### math.degrees(x) 返回弧度`x`转换为度数。 ### math.erf(x) 返回`x`的错误函数。 ### math.erfc(x) 返回`x`的互补误差函数。 ### math.exp(x) 返回`x`的指数。 ### math.expm1(x) 返回`exp（x） 1`。 ### math.fabs(x) 返回`x`的绝对值。 ### math.floor(x) 返回一个整数，“x”向负无穷大舍入。 ### math.fmod(x, y) 返回`x` /`y`的余数。 ### math.frexp(x) 将浮点数分解为尾数和指数。返回的值是元组`（m，e）`，使得`x m * 2 ** e`完全正确。如果`x 0`则函数返回`（0.0,0）`，否则关系`0.5 < abs（m）<1`成立。 ### math.gamma(x) 返回`x`的伽玛函数。 ### math.isfinite(x) 如果`x`是有限的，则返回True。 ### math.isinf(x) 如果`x`是无限的，则返回True。 ### math.isnan(x) 如果`x`不是数字，则返回True ### math.ldexp(x, exp) 返回`x *（2 ** exp）`。 ### math.lgamma(x) 返回`x`的伽玛函数的自然对数。 ### math.log(x) 返回`x`的自然对数。 ### math.log10(x) 返回`x`的以10为底的对数。 ### math.log2(x) 返回`x`的base 2对数。 ### math.modf(x) 返回两个浮点数的元组，是“x”的分数和整数部分。两个返回值都与`x`具有相同的符号。 ### math.pow(x, y) 将`x`返回到'y`的幂。 ### math.radians(x) 返回度数`x`转换为弧度。 ### math.sin(x) 返回`x`的正弦值。 ### math.sinh(x) 返回`x`的双曲正弦值。 ### math.sqrt(x) 返回`x`的平方根。 ### math.tan(x) 返回`x`的正切值。 ### math.tanh(x) 返回`x`的双曲正切。 ### math.trunc(x) 返回一个整数，“x”向0舍入。 ## Constants ### math.e 自然对数的基础 ### math.pi 圆周长与直径的比值"},"/soft/maixpy/zh/api_reference/standard/uhashlib.html":{"title":"uhashlib –哈希算法","content":" title: uhashlib –哈希算法 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy uhashlib –哈希算法 该模块实现了相应[CPython](http://docs.micropython.org/en/latest/reference/glossary.html#term cpython)模块的子集，如下所述。有关更多信息，请参阅原始CPython文档：[hashlib](https://docs.python.org/3.5/library/hashlib.html#module hashlib)。 该模块实现二进制数据哈希算法。可用算法的确切清单取决于电路板。在可以实现的算法中： SHA256 SHA2系列的最新现代哈希算法。它适用于密码安全的目的。除非它具有特定的代码大小限制，否则建议将其包含在MicroPython内核中，并建议任何开发板都提供此功能。 在 K210 中有硬件加速，不是软件计算 [例程](https://github.com/sipeed/MaixPy v1_scripts/blob/master/basic/demo_sha256.py)： ```python a bytes([0]*65) b hashlib.sha256(a) c b.digest() print(c) ``` ## 构造函数 ## 类 uhashlib.sha256([data]) 创建一个SHA256哈希对象，并有选择地向其中馈送数据。 ## 方法 ### hash.update(data) 将更多的二进制数据输入哈希。 ### hash.digest() 返回通过哈希传递的所有数据的哈希，作为字节对象。调用此方法后，无法再将更多数据馈入哈希。 **注意**： 在`micropython`中， 使用此函数会完成最后的计算， 不是单纯的将结果显示出来， 所以只能调用一次， 如果你要多次使用这个值， 请保存到变量 ```python c b.digest() print(c) ``` 多次调用会发现返回值不相同 ```python c b.digest() d b.digest() print(c d) # False ``` ### hash.hexdigest() 未实现此方法。使用 `ubinascii.hexlify(hash.digest())` 可获得类似的效果。"},"/soft/maixpy/zh/api_reference/standard/ubinascii.html":{"title":"ubinascii – 二进制/ ASCII转换","content":" title: ubinascii – 二进制/ ASCII转换 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy ubinascii – 二进制/ ASCII转换 该模块实现了相应CPython模块的子集，如下所述。有关更多信息，请参阅原始CPython文档：[binascii](https://docs.python.org/3.5/library/binascii.html#module binascii). 该模块以ASCII格式（两个方向）实现二进制数据与其各种编码之间的转换。 ## 函数 ### ubinascii.hexlify(data[, sep]) 将二进制数据转换为十六进制表示。返回字节字符串。 #### 与CPython的区别 如果提供了附加参数sep，则它将用作十六进制值之间的分隔符。 ### ubinascii.unhexlify(data) 将十六进制数据转换为二进制表示。返回字节字符串。 （即hexlify的倒数） ### ubinascii.a2b_base64(data) 解码base64编码的数据，忽略输入中的无效字符。符合 [RFC 2045 s.6.8.](https://tools.ietf.org/html/rfc2045#section 6.8) 返回一个bytes对象。 ### ubinascii.b2a_base64(data) 以base64格式编码二进制数据，如 [RFC 3548](https://tools.ietf.org/html/rfc3548.html)所述。返回编码数据，后跟换行符，作为bytes对象。"},"/soft/maixpy/zh/api_reference/standard/utime.html":{"title":"utime – 时间相关的功能","content":" title: utime – 时间相关的功能 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy utime – 时间相关的功能 该模块实现了相应CPython模块的子集，如下所述。有关更多信息，请参阅原始CPython文档： [time](https://docs.python.org/3.5/library/time.html#module time). `utime`模块提供获取当前时间和日期，测量时间间隔和延迟的功能。 **时间纪元**: Unix移植版本使用标准为1970 01 01 00:00:00 UTC的POSIX系统时代。但是，嵌入式移植版本使用的是2000 01 01 00:00:00 UTC的纪元。 **维护实际日历日期/时间**: 这需要实时时钟（RTC）。在具有底层OS（包括一些RTOS）的系统上，RTC可能是隐含的。设置和维护实际日历时间是OS / RTOS的责任，并且在MicroPython之外完成，它只使用OS API来查询日期/时间。在裸机移植上，系统时间依赖于`machine.RTC（）`对象。可以使用`machine.RTC（）。datetime（tuple）`函数设置当前日历时间，并通过以下方式维护： * 通过备用电池（可能是特定电路板的附加可选组件）。 * 使用联网时间协议（需要由移植/用户设置）。 * 每次上电时由用户手动设置（许多电路板在硬复位时保持RTC时间，但有些可能需要在这种情况下再次设置）。 如果未使用系统/ MicroPython RTC维护实际日历时间，则低于此要求参考当前绝对时间的函数可能与预期不符。 ## 函数 ### utime.localtime([secs]) 将自纪元（见上文）以秒为单位的时间转换为8元组，其中包含:(年，月，日，小时，分钟，秒，工作日，晚期）如果未提供秒数或无，则为当前时间来自RTC使用。 * 年份包括世纪（例如2014年）。 * 月是1 12 * mday是1 31 * 小时是0 23 * 分钟是0 59 * 秒是0 59 周一至周日的工作日为0 6 * yearday是1 366 ### utime.mktime() 这是本地时间的反函数。它的参数是一个完整的8元组，表示按当地时间表示的时间。它返回一个整数，它是自2000年1月1日以来的秒数。 ### utime.sleep(seconds) 睡眠给定的秒数。有些电路板可能会接受秒作为浮点数来休眠几秒钟。请注意，其他板可能不接受浮点参数，因为与它们的兼容性使用 `sleep_ms()` 和 `sleep_us()` 函数。 ### utime.sleep_ms(ms) 给定毫秒数的延迟应为正或0。 ### utime.sleep_us(us) 给定微秒数的延迟应为正或0。 ### utime.ticks_ms() 返回一个带有任意参考点的递增毫秒计数器，它在某个值之后回绕。 环绕值未明确公开，但我们将其称为TICKS_MAX以简化讨论。值的周期为TICKS_PERIOD TICKS_MAX + 1. TICKS_PERIOD保证为2的幂，但在不同硬件的移植之间可能不同。相同的句点值用于所有`ticks_ms（）`，`ticks_us（）`，`ticks_cpu（）`函数（为简单起见）。因此，这些函数将返回范围[0 .. TICKS_MAX]中的值，包括总TICKS_PERIOD值。请注意，仅使用非负值。在大多数情况下，您应该将这些函数返回的值视为不透明。可用的唯一操作是`ticks_diff（）`和`ticks_add（）`函数，如下所述。 > 注意：直接对这些值执行标准数学运算（+， ）或关系运算符（<，< ，>，> ）将导致无效结果。执行数学运算然后将其结果作为参数传递给ticks_diff（）或ticks_add（）也将导致后者函数的无效结果。 ### utime.ticks_us() 就像上面的'ticks_ms（）`一样，但是在几微秒内。 ### utime.ticks_cpu() 类似于`ticks_ms（）`和`ticks_us（）`，但系统中的分辨率最高。这通常是CPU时钟，这就是函数以这种方式命名的原因。但它不必是CPU时钟，而是可以使用系统中可用的一些其他定时源（例如，高分辨率定时器）。在'utime`模块级别没有指定此函数的确切时间单位（分辨率），但特定硬件的文档可能提供更具体的信息。此功能用于非常精细的基准测试或非常紧凑的实时循环。避免在便携式代码中使用它。 ### utime.ticks_add(ticks, delta) 偏移值按给定数字计算，可以是正数也可以是负数。给定一个ticks值，该函数允许在tick值的模块算术定义之后或之后计算ticks值delta ticks（参见上面的`ticks_ms（）`）。 ticks参数必须是调用`ticks_ms（）`，`ticks_us（）`或`ticks_cpu（）`函数（或从之前调用`ticks_add（）`）的直接结果。但是，delta可以是任意整数或数字表达式。 ticks_add（）对于计算事件/任务的截止日期非常有用。 （注意：你必须使用`ticks_diff（）`函数来处理截止日期。） 例子: ```python # Find out what ticks value there was 100ms ago print(ticks_add(time.ticks_ms(), 100)) # Calculate deadline for operation and test for it deadline ticks_add(time.ticks_ms(), 200) while ticks_diff(deadline, time.ticks_ms()) > 0: do_a_little_of_something() # Find out TICKS_MAX used by this port print(ticks_add(0, 1)) ``` ### utime.ticks_diff(ticks1, ticks2) 测量从`ticks_ms（）`，`ticks_us（）`或`ticks_cpu（）`函数返回的值之间的差异，作为可以回绕的有符号值。 参数顺序与减法运算符相同，`ticks_diff（ticks1，ticks2）`与`ticks1 ticks2`具有相同的含义。但是，`ticks_ms（）`等函数返回的值可能会回绕，因此直接使用减法会产生不正确的结果。这就是为什么需要`ticks_diff（）`，它实现模块化（或更具体地说，环）算术，即使对于环绕值也能产生正确的结果（只要它们之间不太远，见下文）。该函数返回范围为[ TICKS_PERIOD / 2 .. TICKS_PERIOD / 2 1]的**有符号**值（这是二进制补码有符号二进制整数的典型范围定义）。如果结果是否定的，则意味着ticks1在时间上早于ticks2。否则，这意味着ticks1发生在ticks2之后。如果ticks1和ticks2彼此分开不超过TICKS_PERIOD / 2 1滴答，则仅保留**。如果不成立，将返回不正确的结果。具体来说，如果两个刻度值相隔TICKS_PERIOD / 2 1刻度，则该值将由该函数返回。但是，如果实时滴答的TICKS_PERIOD / 2已在它们之间传递，则该函数将返回 TICKS_PERIOD / 2，即结果值将回绕到可能值的负范围。 上述限制的非正式理由：假设您被锁在一个房间内，除了标准的12档时钟外无法监控时间的流逝。然后，如果你现在看表盘，不再看13个小时（例如，如果你长时间睡觉），那么一旦你再看一遍，你可能觉得只有1个小时过去了。为了避免这个错误，请定期查看时钟。您的应用程序也应该这样做。 “太长时间睡眠”这个比喻也直接映射到应用程序行为：不要让你的应用程序运行任何单个任务太长时间。分步运行任务，并在两者之间进行计时。 `ticks_diff()` 旨在适应各种使用模式，其中包括： * 超时轮询。在这种情况下，事件的顺序是已知的，你只会处理`ticks_diff（）`的正面结果： ```python # Wait for GPIO pin to be asserted, but at most 500us start time.ticks_us() while pin.value() 0: if time.ticks_diff(time.ticks_us(), start) > 500: raise TimeoutError ``` * 调度事件。 在这种情况下，如果事件过期，则ticks_diff（）结果可能为负： ```python # This code snippet is not optimized now time.ticks_ms() scheduled_time task.scheduled_time() if ticks_diff(scheduled_time, now) > 0: print(\"Too early, let's nap\") sleep_ms(ticks_diff(scheduled_time, now)) task.run() elif ticks_diff(scheduled_time, now) 0: print(\"Right at time!\") task.run() elif ticks_diff(scheduled_time, now) < 0: print(\"Oops, running late, tell task to run faster!\") task.run(run_faster true) ``` > 注意：不要将`time（）`值传递给`ticks_diff（）`，你应该对它们使用常规的数学运算。但请注意，`time（）`可能（也会）溢出。这被称为https://en.wikipedia.org/wiki/Year_2038_problem . ### utime.time() 返回自纪元以来的整数秒数，假设如上所述设置和维护基础RTC。如果未设置 RTC，则此函数返回自特定硬件移植参考时间点以来的秒数（对于没有电池供电的 RTC 的嵌入式电路板，通常自上电或复位后）。如果要开发便携式 MicroPython 应用程序，则不应依赖此函数来提供高于第二的精度。如果你需要更高的精度，使用`ticks_ms（）`和`ticks_us（）`函数，如果你需要日历时间，`localtime（）`没有参数是一个更好的选择。 #### 与CPython的区别 在 CPython 中，此函数返回自 Unix 纪元（1970 01 01 00:00 UTC）以来的秒数，作为浮点数，通常具有微秒精度。 使用 MicroPython，只有 Unix 移植版本使用相同的纪元，如果浮点精度允许，则返回亚秒精度。 嵌入式硬件通常没有浮点精度来表示长时间范围和亚秒精度，因此它们使用具有第二精度的整数值。 某些嵌入式硬件也缺少电池供电的 RTC，因此返回自上次上电或其他相对硬件特定点（例如复位）以来的秒数。 ### time.ticks() 等同于 `time.ticks_ms` ### time.clock() 获取 `clock` 对象 #### 返回值 `clock` 对象 ## clock 对象 由 `time.clock()` 返回 ### clock.tick() 记录开始时间（ms）， 与`clock.fps()`搭配使用可以计算`fps` #### 返回值 None ### clock.fps() 根据上一个调用`clock.tick()`到现在的时间计算出帧率（`fps`） 比如： ```python import sensor import time clock time.clock() sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) while True: \tclock.tick() \tsensor.snapshot() \tprint(\"fps \",clock.fps()) ``` ### clock.reset() 重置所有标记 ### clock.avg() 根据上一个调用`clock.tick()`到现在的时间计算出每帧消耗的时间"},"/soft/maixpy/zh/api_reference/standard/ujson.html":{"title":"ujson – JSON encoding and decoding","content":" title: ujson – JSON encoding and decoding keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy ujson – JSON encoding and decoding 该模块实现了相应 CPython 模块的子集，如下所述。有关更多信息，请参阅原始 CPython 文档：[json](https://docs.python.org/3.5/library/json.html#module json). 此模块允许在 Python 对象和 JSON 数据格式之间进行转换。 ## 函数 ### dump ```python ujson.dump(obj, stream) ``` 将 `obj` 序列化化为 JSON 字符串，将其写入给定的流。 ### dumps ```python ujson.dumps(obj) ``` 返回表示为 JSON 字符串的 `obj`。 ### load ```python ujson.load(stream) ``` 解析给定的流，将其解释为 JSON 字符串并将数据反序列化为 Python 对象。返回结果对象。 解析继续，直到遇到文件结尾。如果未正确形成流中的数据，则会引发 ValueError。 ### loads ```python ujson.loads(str) ``` 解析JSON str并返回一个对象。如果字符串格式出错，则引发ValueError。"},"/soft/maixpy/zh/api_reference/standard/gc.html":{"title":"gc – 内存回收","content":" title: gc – 内存回收 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy gc – 内存回收 该模块实现了相应CPython模块的子集，如下所述。有关更多信息，请参阅原始CPython文档：[gc](https://docs.python.org/3.5/library/gc.html#module gc). ## 函数 ### gc.enable() 启用自动垃圾回收。 ### gc.disable() 禁用自动垃圾回收。仍然可以分配堆内存，仍然可以使用 `gc.collect()` 手动启动垃圾收集。 ### gc.collect() 运行垃圾回收。 ### gc.mem_alloc() 返回分配的堆 RAM 的字节数。 #### Difference to CPython 此功能是 MicroPython 扩展。 ### gc.mem_free() 返回可用堆RAM的字节数，如果堆剩余数量未知，则返回 1。 #### 与CPython的区别 此功能是MicroPython扩展。 ### gc.threshold([amount]) 设置或查询其他GC分配阈值。通常，仅当不能满足新分配时，即在内存不足（OOM）条件下才触发集合。如果调用此函数，除了OOM之外，每次分配了大量字节后都会触发一个集合（总共，因为上一次分配了这么多的字节）。 amount通常被指定为小于完整堆大小，意图在堆耗尽之前触发集合，并希望早期集合可以防止过多的内存碎片。这是一种启发式度量，其效果因应用程序而异，以及量参数的最佳值。 不带参数调用函数将返回阈值的当前值。值 1表示禁用的分配阈值。 #### 与CPython的区别 此函数是MicroPython扩展。 CPython有一个类似的函数 `set_threshold()`，但是由于不同的GC实现，它的签名和语义是不同的。"},"/soft/maixpy/zh/api_reference/standard/ucollections.html":{"title":"ucollections – 集合和容器类型","content":" title: ucollections – 集合和容器类型 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy ucollections – 集合和容器类型 该模块实现了相应CPython模块的子集，如下所述。有关更多信息，请参阅原始CPython文档 [collections](https://docs.python.org/3.5/library/collections.html#module collections). 此模块实现高级集合和容器类型以保存/累积各种对象。 ## 类 ### ucollections.deque(iterable, maxlen[, flags]) Deques（双端队列）是一个类似列表的容器，支持O（1）追加并从双端队列的任一侧弹出。使用以下参数创建新的deques： * iterable必须是空元组，并且新的deque被创建为空。 * 必须指定maxlen，并且双端队列将限制为此最大长度。一旦双端队列已满，添加的任何新项目将丢弃对方的项目。 * 添加项目时，可选标志可以为1以检查溢出。 除了支持bool和len之外，deque对象还有以下方法： #### `deque.append(x)` 将`x`添加到双端队列的右侧。如果启用了溢出检查并且没有剩余空间，则引发 IndexError。 #### `deque.popleft()` 从双端队列的左侧移除并返回一个项目。如果没有项目，则引发 IndexError。 ### ucollections.namedtuple(name, fields) 这是工厂函数，用于创建具有特定名称和字段集的新的namedtuple类型。 namedtuple是元组的子类，它不仅可以通过数字索引访问其字段，还可以使用符号字段名称访问属性访问语法。 Fields是指定字段名称的字符串序列。为了与CPython兼容，它也可以是一个以空格分隔的字段命名的字符串（但效率较低）。使用示例： ```python from ucollections import namedtuple MyTuple namedtuple(\"MyTuple\", (\"id\", \"name\")) t1 MyTuple(1, \"foo\") t2 MyTuple(2, \"bar\") print(t1.name) assert t2.name t2[1] ``` ### ucollections.OrderedDict(...) `dict`类型子类，它记住并保留添加的键的顺序。当迭代命令dict时，按照添加的顺序返回键/项： ```python from ucollections import OrderedDict # To make benefit of ordered keys, OrderedDict should be initialized # from sequence of (key, value) pairs. d OrderedDict([(\"z\", 1), (\"a\", 2)]) # More items can be added as usual d[\"w\"] 5 d[\"b\"] 3 for k, v in d.items(): print(k, v) ``` Output: ```python z 1 a 2 w 5 b 3 ```"},"/soft/maixpy/zh/api_reference/standard/uos.html":{"title":"uos – 基本的“操作系统”服务","content":" title: uos – 基本的“操作系统”服务 keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy uos – 基本的“操作系统”服务 该模块实现了相应CPython模块的子集，如下所述。有关更多信息，请参阅原始CPython文档：[os](https://docs.python.org/3.5/library/os.html#module os)。 `uos`模块包含用于文件系统访问和挂载，终端重定向和复制以及`uname`和`urandom`等函数。 ## 常用函数 ### uos.uname() 返回一个元组（可能是一个命名了的元组），其中包含有关底层机器和/或其操作系统的信息。元组按以下顺序有五个字段，每个字段都是一个字符串： * sysname 底层系统的名称 * nodename 节点名（/板子名称）（可以与sysname相同） * release 底层系统的版本 * version MicroPython版本和构建日期 * machine 底层硬件的标识符（例如，板，CPU） ### uos.urandom(n) 返回一个包含n个随机字节的字节对象。只要有可能，它就由硬件随机数生成器生成。 ## 文件系统访问 ### uos.chdir(path) 更改当前目录。 ### uos.getcwd() 获取当前目录。 ### uos.ilistdir([dir]) 此函数返回一个迭代器，然后生成与列出的目录中的条目对应的元组。如果不传参数，它列出了当前目录，否则它列出了dir给出的目录。 元组具有形式（名称，类型，inode [，大小]）： * name： 是一个字符串（如果dir是一个字节对象，则为字节），并且是条目的名称; * type： 是一个整数，指定条目的类型，目录为 0x4000，常规文件为 0x8000; * inode： 是对应于文件inode的整数，对于没有这种概念的文件系统可以是0。 * 某些平台可能会返回包含条目大小的4元组。对于文件条目，size是表示文件大小的整数，如果未知则为 1。目前条目的含义目前尚未定义。 ### uos.listdir([dir]) 如果没有参数，请列出当前目录。否则列出给定目录。 ### uos.mkdir(path) 创建一个新目录。 ### uos.remove(path) 删除文件。 ### uos.rmdir(path) 删除目录。 ### uos.rename（old_path，new_path） 重命名文件。 ### uos.stat(path) 获取文件或目录的状态。 ### uos.statvfs(path) 获取文件系统的状态。 按以下顺序返回包含文件系统信息的元组： * f_bsize 文件系统块大小 * f_frsize 片段大小 * f_blocks f_frsize单位中fs的大小 * f_bfree 空闲块数 * f_bavail 无特权用户的空闲块数 * f_files inode数量 * f_ffree 免费inode的数量 * f_favail 无特权用户的免费inode数 * f_flag 挂载标志 * f_namemax 最大文件名长度 与inode相关的参数：`f_files`，`f_ffree`，`f_avail`和`f_flags`参数可能返回'0`，因为它们在特定于硬件的实现中不可用。 ### uos.sync() 同步所有文件系统。 ## 终端重定向和复制 ### uos.dupterm(stream_object，index 0) 在给定的`stream`类对象上复制或切换MicroPython终端（REPL）。 stream_object参数必须实现`readinto（）`和`write（）`方法。流应处于非阻塞模式，如果没有可用于读取的数据，`readinto（）`应返回'None`。 调用此函数后，将在此流上重复所有终端输出，并且流上可用的任何输入都将传递到终端输入。 index参数应为非负整数，并指定设置的复制槽。给定端口可以实现多个槽（槽0将始终可用），并且在这种情况下，终端输入和输出在所有设置的槽上复制。 如果`None`作为stream_object传递，则在索引给出的槽上取消复制。 该函数返回给定槽中的前一个类似流的对象。 ## 文件系统挂载 某些端口提供虚拟文件系统（VFS）以及在此VFS中安装多个“真实”文件系统的功能。文件系统对象可以安装在VFS的根目录中，也可以安装在根目录中的子目录中。这允许Python程序看到的文件系统的动态和灵活配置。具有此功能的端口提供`mount（）`和`umount（）`函数，以及可能由VFS类表示的各种文件系统实现。 ### uos.mount(fsobj，mount_point，*，readonly) 将文件系统对象fsobj挂载到mount_point字符串指定的VFS中的位置。 fsobj可以是一个具有`mount（）`方法或块设备的VFS对象。如果它是块设备，则会自动检测文件系统类型（如果未识别文件系统，则会引发异常）。 mount_point可以是'/'在根目录下挂载fsobj，或者'/ <name>'挂载到根目录下的子目录中。 如果readonly为“True”，则文件系统以只读方式挂载。 在mount过程中，在文件系统对象上调用`mount（）`方法。 如果mount_point已经挂载，将引发`OSError（EPERM）`。 ### uos.umount(mount_point) 卸载文件系统。 mount_point可以是命名安装位置的字符串，也可以是先前安装的文件系统对象。在卸载过程中，在文件系统对象上调用方法`umount（）`。 如果找不到mount_point，会引发`OSError（EINVAL）`。 ### class uos.VfsFat(block_dev) 创建使用FAT文件系统格式的文件系统对象。 FAT文件系统的存储由block_dev提供。可以使用`mount（）`挂载由此构造函数创建的对象。 #### static mkfs(block_dev) 在block_dev上构建FAT文件系统。 ## 文件系统格式化 在MaixPy中，我们提供了对flash进行文件系统格式化的操作。如果用户想要清空flash文件系统那么可以使用该接口 `flash_format` 来实现 ### uos.flash_format() 该接口不需要传入参数，直接使用将对开发板的 flash 进行格式化。请注意，格式化将清空所有文件，在使用前请确认 flash 中文件都是需要删除的 ## 块设备 块设备是实现块协议的对象，块协议是由 `AbstractBlockDev` 类在下面描述的一组方法。该类的具体实现通常允许访问类似存储器的功能作为硬件（如闪存）。特定文件系统驱动程序可以使用块设备来存储其文件系统的数据。 ### class uos.AbstractBlockDev()...) 构造块设备对象。构造函数的参数取决于特定的块设备。 #### readblocks(block_num, buf) 从索引block_num给出的块开始，将块从设备读入buf（字节数组）。要读取的块数由buf的长度给出，该长度将是块大小的倍数。 #### writeblocks(block_num, buf) 从索引block_num给出的块开始，将buf（字节数组）中的块写入设备。要写入的块数由buf的长度给出，该长度将是块大小的倍数。 #### ioctl(op, arg) 控制块设备并查询其参数。要执行的操作由op给出，它是以下整数之一： * 1 初始化设备（arg未使用） * 2 关闭设备（arg未使用） * 3 同步设备（arg未使用） * 4 获取块数的计数，应该返回一个整数（arg未使用） * 5 获取块中的字节数，应该返回一个整数，或者“None”，在这种情况下使用默认值512（arg未使用） ### 例程 #### 例程1 以fat32举例，下面的类将实现一个块设备，它使用`bytearray`将其数据存储在RAM中： ```python class RAMBlockDev: def __init__(self, block_size, num_blocks): self.block_size block_size self.data bytearray(block_size * num_blocks) def readblocks(self, block_num, buf): for i in range(len(buf)): buf[i] self.data[block_num * self.block_size + i] def writeblocks(self, block_num, buf): for i in range(len(buf)): self.data[block_num * self.block_size + i] buf[i] def ioctl(self, op, arg): if op 4: # get number of blocks return len(self.data) // self.block_size if op 5: # get block size return self.block_size ``` 或者： ```python import uos bdev RAMBlockDev(512, 50) uos.VfsFat.mkfs(bdev) vfs uos.VfsFat(bdev) uos.mount(vfs, '/ramdisk') ``` #### 例程2 以spiffs举例，下面的类将实现一个块设备，它使用`bytearray`将其数据存储在RAM中： ```python class RAMFlashDev: def __init__(self): self.fs_size 256*1024 self.fs_data bytearray(256*1024) self.erase_block 32*1024 self.log_block_size 64*1024 self.log_page_size 4*1024 def read(self,buf,size,addr): for i in range(len(buf)): buf[i] self.fs_data[addr+i] def write(self,buf,size,addr): for i in range(len(buf)): self.fs_data[addr+i] buf[i] def erase(self,size,addr): for i in range(size): self.fs_data[addr+i] 0xff ``` ```python blkdev RAMFlashDev.RAMFlashDev() vfs uos.VfsSpiffs(blkdev) vfs.mkfs(vfs) uos.mount(vfs,'/ramdisk') ```"},"/soft/maixpy/zh/api_reference/index.html":{"title":null,"content":" title: keywords: maixpy, k210, AIOT, 边缘计算 desc: maixpy "},"/soft/maixpy/zh/api_reference/extend/onewire.html":{"title":"modules.onewire（单总线）","content":" title: modules.onewire（单总线） keywords: maixpy, k210, AIOT, spmod desc: maixpy modules.onewire（单总线） 单总线即只有单根信号线，该线即传输数据也传输时钟，并且数据传输也为双向，节约 IO 口。 ## 构造方法 onewire(gpio_num) ### 参数 * `gpio_num`：GPIO号。 ### 返回值 * onewire 对象 ## 实例方法 reset() 重置 ### 返回值 * bool 类型，是否成功。 ## 实例方法 readbit() 读取一位数据 ### 返回值 * int 类型，读取到的数据。 ## 实例方法 readbyte() 读取一个字节 ### 返回值 * int 类型，读取到的数据。 ## 实例方法 readbuffer(n) 读取指定长度的字节数 ### 参数 * `n`：int 类型，需要读取的字节数 ### 返回值 * bytearray 类型，读取到的字节数组 ## 实例方法 writebit(bit) 写入一个位 ### 参数 * `bit`：int 类型，需要写入的位数据 ## 实例方法 writebyte(byte) ### 参数 * `byte`：int 类型，需要写入的字节数据 ## 实例方法 writebuffer(buf) ### 参数 * `buf`：bytearray 类型，需要写入的数据 ## 实例方法 select(rom_in) 让主机指定某一个从机。 ### 参数 * `rom_in`：bytearray 类型，表示将指定从机的8byte的ROM数据。 ## 实例方法 search(diff_in) 使用 F0H 标准搜索 ### 参数 * `diff_in`：int 类型，第一次搜索优先选择的路径 ### 返回值 * `list`：元素为(depth,roms)的列表，`depth` 为搜索深度,int 类型，`rom` 为器件 ROM 码，list 类型。 ## 实例方法 skip() 跳过 ROM，适用于单节点 ## 实例方法 depower() 重新使能IO ## 实例方法 crc8(data_in) 计算8位循环冗余校验码 ### 参数 * `data_in`：需要校验的数据 ### 返回值 * 返回校验码"},"/soft/maixpy/zh/api_reference/extend/ultrasonic.html":{"title":"modules.ultrasonic（超声波测距模块）","content":" title: modules.ultrasonic（超声波测距模块） keywords: maixpy, k210, AIOT, 边缘计算, 深度学习, 人工智能 desc: maixpy modules.ultrasonic（超声波测距模块） Grove Ultrasonic Ranger(超声波测距模块)，只需要单根数据线 <div class \"grove_pic\"> <img src \"./../../../assets/hardware/module_grove/ultrasonic.jpg\"> </div> ## 构造方法 ultrasonic(gpiohs) ### 参数 * `gpiohs`: gpiohs 编号，需要先使用`fm`注册引脚,比如 ```python from fpioa_manager import * from modules import ultrasonic fm.register(board_info.D[6], fm.fpioa.GPIOHS0, force True) device ultrasonic(fm.fpioa.GPIOHS0) ``` ### 返回值 返回对象 ## 方法 measure(unit, timeout) ### 参数 * `unit`： 单位， 在下面的常数中取值 * `timeout`: 超时时间，单位为微秒（us） ## 常数 ### ultrasonic.UNIT_CM 返回的距离的单位，厘米 ### ultrasonic.UNIT_INCH 返回的距离的单位，英尺"},"/soft/maixpy/zh/api_reference/extend/index.html":{"title":"外设模块","content":" title: 外设模块 keywords: maixpy, k210, AIOT, spmod desc: maixpy 外设模块 这里的外设模块主要指片外外设（相对于片上外设，比如GPIO、I2C等），比如 `LCD`、 摄像头、 触摸屏等等 关于图像相关的暂时放在了 [机器视觉](../machine_vision/index.html) 分类， 包括以下外设模块 * [lcd](../machine_vision/lcd.html)： 显示图像 * [sensor](../machine_vision/sensor.html)： 获取摄像头数据， 取名叫 `sensor` 是兼容 `openmv`， 当然也不完全一样，请阅读文档 其它外设模块包括： * [touchscreen](./touchscreen.html)： 触摸屏相关操作，读取触摸屏点击状态以及获取点击的坐标等 * [ws2812](./ws2812.html): WS2812单总线灯带 * [热红外温度传感器](./htpa.html) * [超声波](./ultrasonic.html)"},"/soft/maixpy/zh/api_reference/extend/htpa.html":{"title":"modules.htpa（HTPA 热红外测温模组）","content":" title: modules.htpa（HTPA 热红外测温模组） keywords: maixpy, k210, AIOT, spmod desc: maixpy modules.htpa（HTPA 热红外测温模组） 海曼 HTPA 32x32 热红外测温模组 <img src \"../../../assets/hardware/other/htpa32x32.png\"> ## 构造方法 htpa(i2c, scl_pin, sda_pin, i2c_freq) 创建一个实例 ### 参数 * `i2c`: I2C编号， 比如`I2C.I2C0`，取值 [0, 2] (见`machine.I2C`) * `scl_pin`: I2C SCL 引脚 * `sda_pin`: I2C SDA 引脚 * `i2c_freq`: I2C 时钟频率 ### 返回值 htpa 对象 ## 实例方法 temperature() 获取传感器温度值，只能被实例调用 ### 返回值 数组，长度为传感器的宽度x高度，比如`32x32` ## 实例方法 width() 获取传感器分辨率宽度，只能被实例调用 ### 返回值 整数，宽度 ## 实例方法 height() 获取传感器分辨率宽度，只能被实例调用 ## 例子 [heimann_HTPA_32x32](https://github.com/sipeed/MaixPy v1_scripts/tree/master/modules/others/heimann_HTPA_32x32)"},"/soft/maixpy/zh/api_reference/extend/ws2812.html":{"title":"modules.ws2812（WS2812 灯带）","content":" title: modules.ws2812（WS2812 灯带） keywords: maixpy, k210, AIOT, 边缘计算, 深度学习, 人工智能 desc: maixpy modules.ws2812（WS2812 灯带） 本模块使用`K210`的`I2S`进行模块的驱动，所以在使用的过程中需要注意是否冲突 目前最多支持12路灯带 ## 构造函数 ```python from modules import ws2812 class ws2812(led_pin 1,led_num 1,i2s_num I2S_DEVICE_2,i2s_chn I2S_CHANNEL_3,i2s_dma_chn DMAC_CHANNEL1) ``` 通过指定参数新建一个 `ws2812` 对象 ### 参数 * `led_pin`: 灯带数据线连接的引脚，比如 `board_info.D[4]` * `led_num`: 灯带一共有多少颗灯珠 * `i2s_num`: 该对象使用哪个 `I2S` 设备进行驱动，默认为 `I2S_DEVICE_2`,取值范围为 `0 2` * `i2s_chn`: 该对象使用哪个 `I2S` 通道，默认为 `I2S_CHANNEL_3`，取值范围为 `0 3` * `i2s_dma_chn`: 该对象使用的DMA通道，用户一般不考虑 ## 方法 ### set_led 设置某个 led 灯颜色 ```python class_ws2812.set_led(num， color) ``` #### 参数 * `num` : 第 `N` 颗灯珠，从 `0` 开始 * `color` : 该灯珠赋值的颜色，为 `tuple` 类型， （R,G,B） #### 返回值 无 ### display 开始工作，设置完成后调用 ```python class_ws2812.display() ``` #### 参数 无 #### 返回值 无 ## 例程0 30 个 LED 灯全部亮红色 ```python from modules import ws2812 class_ws2812 ws2812(board_info.D[4],30) for i in range(30): class_ws2812.set_led(i,(0xff,0,0)) class_ws2812.display() ``` ## 例程1 灯带红色渐变 ```python from modules import ws2812 class_ws2812 ws2812(board_info.D[4],30) r 0 dir True while True: if dir: r + 1 else: r 1 if r> 255: r 255 dir False elif r<0: r 0 dir True for i in range(30): a class_ws2812.set_led(i,(r,0,0)) a class_ws2812.display() ``` > 以上例程，可见[`MaixPy_scripts`](https://github.com/sipeed/MaixPy v1_scripts/tree/master/modules/grove/ws2812)"}}